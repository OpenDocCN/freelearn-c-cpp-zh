<html><head></head><body>
<div id="book-content" class="calibre2">
<div id="sbo-rt-content" class="calibre3"><section id="chapter-4-basic-libraries-and-tools" class="level" data-number="1.4">
<h1 data-number="1.4" class="calibre5"><span>4</span></h1>
<h1 id="sigil_toc_id_57" class="calibre5"><a id="x1-680004" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Basic Libraries and Tools</h1>
<p class="hidden">LLVM is written in the C++ language and, as of July 2022, it uses the C++17 version of the C++ standard [<a href="B19722_Bib.xhtml#Xllvm_cpp17migration" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">6</a>]. LLVM actively utilizes <a id="dx1-68001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>functionality provided by the <strong class="calibre12">Standard Template Library (STL)</strong>. On the other hand, LLVM contains numerous internal implementations [<a href="B19722_Bib.xhtml#Xllvm_programmer_manual" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">13</a>] for fundamental containers, primarily aimed at optimizing performance. For example, <span><code class="calibre13">llvm</code><code class="calibre13">::</code><code class="calibre13">SmallVector</code></span> has an interface similar to <span><code class="calibre13">std</code><code class="calibre13">::</code><code class="calibre13">vector</code></span> but features an internally optimized implementation. Hence, familiarity with these extensions is essential for anyone wishing to work with LLVM and Clang.</p>
<p class="hidden">Additionally, LLVM has introduced <a id="dx1-68002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>other development tools such as <strong class="calibre12">TableGen</strong>, a <strong class="calibre12">domain specific language </strong>(<strong class="calibre12">DSL</strong>) designed for <a id="dx1-68003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>structural data processing, and <strong class="calibre12">LIT </strong>(LLVM Integrated Tester), the LLVM <a id="dx1-68004" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>test framework. More details about these tools are discussed later in this chapter. We’ll cover the following topics in this chapter:</p>
<ul class="calibre6">
<li class="calibre14"><p class="calibre15">LLVM coding style</p></li>
<li class="calibre14"><p class="calibre15">LLVM basic libraries</p></li>
<li class="calibre14"><p class="calibre15">Clang basic libraries</p></li>
<li class="calibre14"><p class="calibre15">LLVM supporting tools</p></li>
<li class="calibre14"><p class="calibre15">Clang plugin project</p></li>
</ul>
<p class="hidden">We plan to use a simple example project to demonstrate these tools. This project will be a Clang plugin that estimates the complexity of C++ classes. A class is considered complex if the number of methods exceeds a threshold specified as a parameter. While this definition of complexity may be considered trivial, we will explore more advanced definitions of complexity later in <a href="B19722_06.xhtml#x1-1170006" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"><em class="calibre11">Chapter</em><em class="calibre11"> 6</em></a><em class="calibre11">, Advanced</em> <em class="calibre11">Code Analysis</em>. <a id="x1-68005r200" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<section id="technical-requirements-3" class="level" data-number="1.4.1">
<h2 data-number="1.4.1" id="sigil_toc_id_58" class="likechapterhead"><span>4.1 </span> <a id="x1-690001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Technical requirements</h2>
<p class="hidden">The source code for this chapter is located in the <code class="calibre13">chapter4 </code>folder of the book’s GitHub repository: <a href="https://github.com/PacktPublishing/Clang-Compiler-Frontend-Packt/tree/main/chapter4" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">https://github.com/PacktPublishing/Clang-Compiler-Frontend-Packt/tree/main/chapter4</a>. <a id="x1-69001r202" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
</section>
<section id="llvm-coding-style" class="level" data-number="1.4.2">
<h2 data-number="1.4.2" id="sigil_toc_id_59" class="likechapterhead"><span>4.2 </span> <a id="x1-700002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>LLVM coding style</h2>
<p class="hidden">LLVM adheres to specific code-style rules [<a href="B19722_Bib.xhtml#Xllvm_coding_standards" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">11</a>]. The primary objective of these rules is to promote proficient C++ practices with a <a id="dx1-70001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>special focus on performance. As previously mentioned, LLVM employs C++17 and prefers using data structures and algorithms from the <strong class="calibre12">STL </strong>(short for, <strong class="calibre12">Standard Template</strong> <strong class="calibre12">Library</strong>). On the other hand, LLVM offers many optimized <a id="dx1-70002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>versions of data structures that mirror those in the STL. For example, <span><code class="calibre13">llvm</code><code class="calibre13">::</code><code class="calibre13">SmallVector</code><code class="calibre13">&lt;&gt;</code></span> can be regarded as an optimized version of <span><code class="calibre13">std</code><code class="calibre13">::</code><code class="calibre13">vector</code><code class="calibre13">&lt;&gt;</code></span>, especially for small sizes of the vector, a common trait for data structures used in compilers.</p>
<p class="hidden">Given a choice between an STL object/algorithm and its corresponding LLVM version, the LLVM coding standard advises favoring the LLVM version.</p>
<p class="hidden">Additional rules <a id="dx1-70003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>pertain to concerns regarding performance limitations. For instance, both <strong class="calibre12">run-time type information (RTTI) </strong>and C++ exceptions are disallowed. However, there are situations where RTTI could prove beneficial; thus, LLVM offers alternatives such as <span><code class="calibre13">llvm</code><code class="calibre13">::</code><code class="calibre13">isa</code><code class="calibre13">&lt;&gt;</code></span> and other similar template helper functions. More information on this can be found in <a href="#x1-720001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"><em class="calibre11">Section</em><em class="calibre11"> 4.3.1</em></a><em class="calibre11">, RTTI</em> <em class="calibre11">replacement and cast operators</em>. Instead of C++ exceptions, LLVM frequently employs C-style <span><code class="calibre13">assert</code></span>s.</p>
<p class="hidden">Sometimes, asserts are not sufficiently informative. LLVM recommends adding textual messages to them to simplify debugging. Here’s a typical example from Clang’s code:</p>
<pre class="source-code">static bool unionHasUniqueObjectRepresentations(const ASTContext &amp;Context, 
 

                                                const RecordDecl *RD, 
 

                                                bool CheckIfTriviallyCopyable) { 
 

  assert(RD-&gt;isUnion() &amp;&amp; "Must be union type"); 
 

  CharUnits UnionSize = Context.getTypeSizeInChars(RD-&gt;getTypeForDecl());
                                                                     

                                                                     </pre>
<p class="hidden"><a id="x1-70012r1" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-70013" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 4.1</strong>: Usage of assert() in clang/lib/AST/ASTContext.cpp </p>
<p class="hidden">In the code, we check if the second parameter (<span><code class="calibre13">RD</code></span>) is a union and raise an assert with a corresponding message if it’s not.</p>
<p class="hidden">Besides performance considerations, LLVM also introduces some additional requirements. One of these requirements <a id="dx1-70014" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>concerns comments. Code comments are very important. Furthermore, both LLVM and Clang have comprehensive documentation generated from the code. They use Doxygen ( <a href="https://www.doxygen.nl/" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">https://www.doxygen.nl/</a>) for this purpose. This tool is the de facto standard for commenting in C/C++ programs, and you have most likely encountered it before.</p>
<p class="hidden">Clang and LLVM are not monolithic pieces of code; instead, they are implemented as a set of libraries. This design provides advantages in terms of code and functionality reuse, as we will explore in <a href="B19722_08.xhtml#x1-1520008" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"><em class="calibre11">Chapter</em><em class="calibre11"> 8</em></a><em class="calibre11">, IDE Support and</em> <em class="calibre11">Clangd</em>. These libraries also serve as excellent examples of LLVM code style enforcement. Let’s examine these libraries in detail. <a id="x1-70015r203" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
</section>
<section id="llvm-basic-libraries" class="level" data-number="1.4.3">
<h2 data-number="1.4.3" id="sigil_toc_id_60" class="likechapterhead"><span>4.3 </span> <a id="x1-710003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>LLVM basic libraries</h2>
<p class="hidden">We are going to start with RTTI replacement in the LLVM code and discuss how it’s implemented. We will then continue <a id="dx1-71001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>with basic containers and smart pointers. We will conclude with some important classes used to represent token locations and how diagnostics are realized in Clang. Later, in <a href="#x1-840006" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"><em class="calibre11">Section</em><em class="calibre11"> 4.6</em></a><em class="calibre11">, Clang plugin project</em>, we will use some of these classes in our test project. <a id="x1-71002r157" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<section id="rtti-replacement-and-cast-operators" class="level" data-number="1.4.3.1">
<h3 data-number="1.4.3.1" id="sigil_toc_id_61" class="likesectionhead"><span>4.3.1 </span> <a id="x1-720001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>RTTI replacement and cast operators</h3>
<p class="hidden">As mentioned earlier, LLVM avoids using RTTI due to performance concerns. LLVM has introduced several <a id="dx1-72001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>helper functions that replace RTTI counterparts, allowing for the casting of an object from one type to another. The fundamental ones are as follows:</p>
<ul class="calibre6">
<li class="calibre14"><p class="calibre15"><span><code class="calibre13">llvm</code><code class="calibre13">::</code><code class="calibre13">isa</code><code class="calibre13">&lt;&gt;</code></span> is akin to Java’s <span><code class="calibre13">java</code></span>instanceof operator. It returns <span><code class="calibre13">true</code></span> or <span><code class="calibre13">false</code></span> depending on whether the reference to the tested object belongs to the tested class or not.</p></li>
<li class="calibre14"><p class="calibre15"><span><code class="calibre13">llvm</code><code class="calibre13">::</code><code class="calibre13">cast</code><code class="calibre13">&lt;&gt;</code></span>: Use this cast operator when you’re certain that the object is of the specified derived type. If the cast fails (i.e., the object isn’t of the expected type), <span><code class="calibre13">llvm</code><code class="calibre13">::</code><code class="calibre13">cast</code></span> will abort the program. Use it only when you’re confident the cast won’t fail.</p></li>
<li class="calibre14"><p class="calibre15"><span><code class="calibre13">llvm</code><code class="calibre13">::</code><code class="calibre13">dyn_cast</code><code class="calibre13">&lt;&gt;</code></span>: This is perhaps the most frequently used casting operator in LLVM. <span><code class="calibre13">llvm</code><code class="calibre13">::</code><code class="calibre13">dyn_cast</code></span> is employed for safe downcasting when you anticipate the cast will usually succeed, but there’s some uncertainty. If the object isn’t of the specified derived type, <span><code class="calibre13">llvm</code><code class="calibre13">::</code><code class="calibre13">dyn_cast</code><code class="calibre13">&lt;&gt;</code></span> returns <span><code class="calibre13">nullptr</code></span>.</p></li>
</ul>
<p class="hidden">The cast operators do not accept <span><code class="calibre13">nullptr</code></span> as input. However, there are two special cast operators that can handle null pointers:</p>
<ul class="calibre6">
<li class="calibre14"><p class="calibre15"><span><code class="calibre13">llvm</code><code class="calibre13">::</code><code class="calibre13">cast_if_present</code><code class="calibre13">&lt;&gt;</code></span>: A variant of <span><code class="calibre13">llvm</code><code class="calibre13">::</code><code class="calibre13">cast</code><code class="calibre13">&lt;&gt;</code></span> that accepts <span><code class="calibre13">nullptr</code></span> values</p></li>
<li class="calibre14"><p class="calibre15"><span><code class="calibre13">llvm</code><code class="calibre13">::</code><code class="calibre13">dyn_cast_if_present</code><code class="calibre13">&lt;&gt;</code></span>: A variant of <span><code class="calibre13">llvm</code><code class="calibre13">::</code><code class="calibre13">dyn_cast</code><code class="calibre13">&lt;&gt;</code></span> that accepts <span><code class="calibre13">nullptr</code></span> values</p></li>
</ul>
<p class="hidden">Both operators can handle <span><code class="calibre13">nullptr</code></span> values. If the input is <span><code class="calibre13">nullptr</code></span> or if the cast fails, they simply return <span><code class="calibre13">nullptr</code></span>.</p>

<p class="hidden"><span>Important note</span></p>

<p class="hidden">It’s worth noting that the casting operators <span><code class="calibre13">llvm</code><code class="calibre13">::</code><code class="calibre13">cast_if_present</code><code class="calibre13">&lt;&gt;</code></span> and <span><code class="calibre13">llvm</code><code class="calibre13">:</code></span> <span><code class="calibre13">:</code><code class="calibre13">dyn_cast_if_present</code><code class="calibre13">&lt;&gt;</code></span> were introduced recently, specifically in 2022. They serve as replacements for popular ones <span><code class="calibre13">llvm</code><code class="calibre13">::</code><code class="calibre13">cast_or_null</code><code class="calibre13">&lt;&gt;</code></span> and <span><code class="calibre13">llvm</code><code class="calibre13">::</code><code class="calibre13">dyn_cast_or</code></span> <span><code class="calibre13">_null</code><code class="calibre13">&lt;&gt;</code></span>, which had been in recent use. The older versions are still supported and now redirect calls to the newer cast operators. For more information, see the discussion about this change: <a href="https://discourse.llvm.org/t/psa-swapping-out-or-null-with-if-present/65018" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">https://discourse.llvm.org/t/psa-swapping-out-or-null-with-if-present/65018</a></p>

<p class="hidden">.</p>
<p class="hidden">The following question might arise: how can the dynamic cast operation be performed without RTTI? This can be achieved <a id="dx1-72002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>with certain specific decorations, as illustrated in a simple example inspired by <em class="calibre11">How to set up</em> <em class="calibre11">LLVM-style RTTI for your class hierarchy </em>[<a href="B19722_Bib.xhtml#Xllvm_rtti_setup" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">14</a>]. We’ll begin with a base class, <span><code class="calibre13">clangbook</code><code class="calibre13">::</code><code class="calibre13">Animal</code></span>, that has two descendants: <span><code class="calibre13">clangbook</code><code class="calibre13">::</code><code class="calibre13">Horse</code></span> and <span><code class="calibre13">clangbook</code><code class="calibre13">::</code><code class="calibre13">Sheep</code></span>. Each horse can be categorized by its speed (in mph), and each sheep by its wool mass. Here’s how it can be used:</p>
<pre class="source-code"><span>46 </span>void testAnimal() { 
 
<span>47 </span>  auto AnimalPtr = std::make_unique&lt;clangbook::Horse&gt;(10); 
 

<span>48 </span>  if (llvm::isa&lt;clangbook::Horse&gt;(AnimalPtr)) { 
 

<span>49 </span>    llvm::outs() 
 
<span>50 </span>        &lt;&lt; "Animal is a Horse and the horse speed is: " 
 

<span>51 </span>        &lt;&lt; llvm::dyn_cast&lt;clangbook::Horse&gt;(AnimalPtr.get())-&gt;getSpeed() 
 

<span>52 </span>        &lt;&lt; "mph \n"; 
 
<span>53 </span>  } else { 
 
<span>54 </span>    llvm::outs() &lt;&lt; "Animal is not a Horse\n"; 
 

<span>55 </span>  } 
 
<span>56 </span>}</pre>
<p class="hidden"><a id="x1-72015r2" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-72016" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 4.2</strong>: LLVM <span><code class="calibre13">isa</code><code class="calibre13">&lt;&gt;</code> and <span><code class="calibre13">dyn_cast</code><code class="calibre13">&lt;&gt;</code></span> usage example </span></p>
<p class="hidden">The code should produce the following output:</p>
<pre id="verbatim-60" class="console">Animal is a Horse and the horse speed is: 10mph</pre>
<p class="hidden"><em class="calibre11">Line 48 </em>in <a href="#x1-72015r2" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 4.2</a> demonstrates the use of <span><code class="calibre13">llvm</code><code class="calibre13">::</code><code class="calibre13">isa</code><code class="calibre13">&lt;&gt;</code></span>, while <em class="calibre11">Line 51</em> showcases <span><code class="calibre13">llvm</code><code class="calibre13">::</code><code class="calibre13">dyn_cast</code><code class="calibre13">&lt;&gt;</code></span>. In the latter, we cast the base class to <span><code class="calibre13">clangbook</code><code class="calibre13">::</code><code class="calibre13">Horse</code></span> and call a method specific to that class.</p>
<p class="hidden">Let’s look into the class implementations, which will provide insights into how the RTTI replacement works. We will <a id="dx1-72017" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>start with the base class <span><code class="calibre13">clangbook</code><code class="calibre13">::</code><code class="calibre13">Animal</code></span>:</p>
<pre class="source-code"><span>9 </span>class Animal { 
 
<span>10 </span>public: 
 

<span>11 </span>  enum AnimalKind { AK_Horse, AK_Sheep }; 
 
<span>12 </span> 
 
<span>13 </span>public: 
 

<span>14 </span>  Animal(AnimalKind K) : Kind(K){}; 
 

<span>15 </span>  AnimalKind getKind() const { return Kind; } 
 
<span>16 </span> 
 

<span>17 </span>private: 
 
<span>18 </span>  const AnimalKind Kind; 
 
<span>19 </span>};</pre>
<p class="hidden"><a id="x1-72030r3" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-72031" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 4.3</strong>: <span><code class="calibre13">clangbook</code><code class="calibre13">::</code><code class="calibre13">Animal</code> class </span></p>
<p class="hidden">The most crucial aspect is <em class="calibre11">Line 11 </em>in the preceding code. It specifies different ”kinds” of animals. One enum value is used for the horse (<span><code class="calibre13">AK_Horse</code></span>) and another for the sheep (<span><code class="calibre13">AK_Sheep</code></span>). Hence, the base class has some knowledge about its descendants. The implementations for the <span><code class="calibre13">clangbook</code><code class="calibre13">::</code><code class="calibre13">Horse</code></span> and <span><code class="calibre13">clangbook</code><code class="calibre13">::</code><code class="calibre13">Sheep</code></span> classes can be found in the following code:</p>
<pre class="source-code"><span>21 </span>class Horse : public Animal { 
 
<span>22 </span>public: 
 

<span>23 </span>  Horse(int S) : Animal(AK_Horse), Speed(S){}; 
 
<span>24 </span> 
 

<span>25 </span>  static bool classof(const Animal *A) { return A-&gt;getKind() == AK_Horse; } 
 

<span>26 </span> 
 
<span>27 </span>  int getSpeed() { return Speed; } 
 
<span>28 </span> 
 
<span>29 </span>private: 
 

<span>30 </span>  int Speed; 
 
<span>31 </span>}; 
 
<span>32 </span> 
 
<span>33 </span>class Sheep : public Animal { 
 

<span>34 </span>public: 
 
<span>35 </span>  Sheep(int WM) : Animal(AK_Sheep), WoolMass(WM){}; 
 

<span>36 </span> 
 
<span>37 </span>  static bool classof(const Animal *A) { return A-&gt;getKind() == AK_Sheep; } 
 

<span>38 </span> 
 
<span>39 </span>  int getWoolMass() { return WoolMass; } 
 
<span>40 </span> 
 

<span>41 </span>private: 
 
<span>42 </span>  int WoolMass; 
 
<span>43 </span>};</pre>
<p class="hidden"><a id="x1-72056r4" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-72057" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 4.4</strong>: <span><code class="calibre13">clangbook</code><code class="calibre13">::</code><code class="calibre13">Horse</code> and <span><code class="calibre13">clangbook</code><code class="calibre13">::</code><code class="calibre13">Sheep</code></span> classes </span></p>
<p class="hidden"><em class="calibre11">Lines 25 and 37 </em>are particularly important as they contain the <span><code class="calibre13">classof</code></span> static method implementation. This method is <a id="dx1-72058" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>crucial for the cast operators in LLVM. A typical implementation might look like the following (simplified version):</p>
<pre id="listing-25" class="source-code">1template &lt;typename To, typename From&gt; 
 

<span>2 </span>bool isa(const From *Val) { 
 

<span>3 </span>  return To::classof(Val); 
 
<span>4 </span>}</pre>
<p class="hidden"><a id="x1-72063r5" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-72064" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 4.5</strong>: Simplified implementation for <span><code class="calibre13">llvm</code><code class="calibre13">::</code><code class="calibre13">isa</code><code class="calibre13">&lt;&gt;</code> </span></p>
<p class="hidden">The same mechanism can be applied to other cast operators.</p>
<p class="hidden">Our next topic will discuss various <a id="dx1-72065" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>types of containers that serve as more powerful alternatives to their corresponding STL counterparts. <a id="x1-72066r207" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
</section>
<section id="containers" class="level" data-number="1.4.3.2">
<h3 data-number="1.4.3.2" id="sigil_toc_id_62" class="likesectionhead"><span>4.3.2 </span> <a id="x1-730002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Containers</h3>
<p class="hidden">The LLVM ADT (which stands for Abstract Data Type) library offers a set of containers. While some of <a id="dx1-73001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>them are unique to LLVM, others can be <a id="dx1-73002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>considered as replacements for containers from the STL. We will explore <a id="dx1-73003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>some of the most popular classes provided by the ADT.</p>
<section id="string-operations" class="level" data-number="1.4.3.2.1">
<h4 data-number="1.4.3.2.1" class="sigil_not_in_toc"><a id="x1-740002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>String operations</h4>
<p class="hidden">The primary class for working with strings in the standard C++ library is <span><code class="calibre13">std</code><code class="calibre13">::</code><code class="calibre13">string</code></span>. Although this class was <a id="dx1-74001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>designed to be universal, it has some performance related issues. A significant issue concerns the copy operation. Since copying strings is a common operation in compilers, LLVM introduced a specialized class, <span><code class="calibre13">llvm</code><code class="calibre13">::</code><code class="calibre13">StringRef</code></span>, that handles this operation efficiently <a id="dx1-74002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>without using extra memory. This class is comparable to <span><code class="calibre13">std</code><code class="calibre13">::</code><code class="calibre13">string_view</code></span> from C++17 [<a href="B19722_Bib.xhtml#Xstandard_cpp17" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">20</a>] and <span><code class="calibre13">std</code><code class="calibre13">::</code><code class="calibre13">span</code></span> from C++20 [<a href="B19722_Bib.xhtml#Xstandard_cpp20" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">21</a>].</p>
<p class="hidden">The <span><code class="calibre13">llvm</code><code class="calibre13">::</code><code class="calibre13">StringRef</code></span> class maintains a reference to data, which doesn’t need to be null-terminated like traditional C/C++ strings. It essentially holds a pointer to a data block and the block’s size, making the object’s effective size 16 bytes. Because <span><code class="calibre13">llvm</code><code class="calibre13">::</code><code class="calibre13">StringRef</code></span> retains a reference rather than the actual data, it must be constructed from an existing data source. This class can be instantiated from basic string objects such as <span><code class="calibre13">const</code> <code class="calibre13">char</code><code class="calibre13">*</code></span>, <span><code class="calibre13">std</code><code class="calibre13">::</code><code class="calibre13">string</code></span>, and <span><code class="calibre13">std</code><code class="calibre13">::</code><code class="calibre13">string_view</code></span>. The default constructor creates an empty object. Typical usage example for <span><code class="calibre13">llvm</code><code class="calibre13">::</code><code class="calibre13">StringRef</code></span> is shown in <a href="#x1-74011r6" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 4.6</a>:</p>
<pre id="listing-26" class="source-code">1  #include "llvm/ADT/StringRef.h" 
 
<span>2 </span>  ... 
 

<span>3 </span>  llvm::StringRef StrRef("Hello, LLVM!"); 
 

<span>4 </span>  // Efficient substring, no allocations 
 

<span>5 </span>  llvm::StringRef SubStr = StrRef.substr(0, 5); 
 
<span>6 </span> 
 

<span>7 </span>  llvm::outs() &lt;&lt; "Original StringRef: " &lt;&lt; StrRef.str() &lt;&lt; "\n"; 
 

<span>8 </span>  llvm::outs() &lt;&lt; "Substring: " &lt;&lt; SubStr.str() &lt;&lt; "\n";</pre>
<p class="hidden"><a id="x1-74011r6" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-74012" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 4.6</strong>: <span><code class="calibre13">llvm</code><code class="calibre13">::</code><code class="calibre13">StringRef</code> usage example </span></p>
<p class="hidden">The output for the code is shown here:</p>
<pre id="verbatim-61" class="console">Original StringRef: Hello, LLVM!
Substring: Hello</pre>
<p class="hidden">Another class used for <a id="dx1-74013" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>string manipulation in LLVM is <span><code class="calibre13">llvm</code><code class="calibre13">::</code><code class="calibre13">Twine</code></span>, which is particularly useful when concatenating several <a id="dx1-74014" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>objects into one. A typical usage example for the class is shown in <a href="#x1-74024r7" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 4.7</a>:</p>
<pre id="listing-27" class="source-code">1   #include "llvm/ADT/Twine.h" 
 
<span>2 </span>   ... 
 

<span>3 </span>   llvm::StringRef Part1("Hello, "); 
 

<span>4 </span>   llvm::StringRef Part2("Twine!"); 
 

<span>5 </span>   llvm::Twine Twine = Part1 + Part2;  // Efficient concatenation 
 

<span>6 </span> 
 
<span>7 </span>   // Convert twine to a string (actual allocation happens here) 
 

<span>8 </span>   std::string TwineStr = Twine.str(); 
 

<span>9 </span>   llvm::outs() &lt;&lt; "Twine result: " &lt;&lt; TwineStr &lt;&lt; "\n";</pre>
<p class="hidden"><a id="x1-74024r7" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-74025" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 4.7</strong>: <span><code class="calibre13">llvm</code><code class="calibre13">::</code><code class="calibre13">Twine</code> usage example </span></p>
<p class="hidden">The output for the code is shown here:</p>
<pre id="verbatim-62" class="console">Twine result: Hello, Twine!</pre>
<p class="hidden">Another class that is widely used for string manipulations is <span><code class="calibre13">llvm</code><code class="calibre13">::</code><code class="calibre13">SmallString</code><code class="calibre13">&lt;&gt;</code></span>. It represents a string that is stack-allocated up to a fixed size, but can also grow beyond this size, at which point it heap-allocates memory. This is a blend between the space efficiency of stack allocation and the flexibility of heap allocation.</p>
<p class="hidden">The advantage of <span><code class="calibre13">llvm</code><code class="calibre13">::</code><code class="calibre13">SmallString</code><code class="calibre13">&lt;&gt;</code></span> is that for many scenarios, especially in compiler tasks, strings tend to be <a id="dx1-74026" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>small and fit within the stack-allocated space. This avoids the overhead of dynamic memory allocation. But in <a id="dx1-74027" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>situations where a larger string is required, <code class="calibre13">llvm::SmallString </code>can still accommodate by transitioning to heap memory. A typical usage example is show in <a href="#x1-74038r8" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 4.8</a>:</p>
<pre id="listing-28" class="source-code">1   #include "llvm/ADT/SmallString.h" 
 
<span>2 </span>   ... 
 

<span>3 </span>   // Stack allocate space for up to 20 characters. 
 

<span>4 </span>   llvm::SmallString&lt;20&gt; SmallStr; 
 
<span>5 </span> 
 

<span>6 </span>   // No heap allocation happens here. 
 

<span>7 </span>   SmallStr = "Hello, "; 
 
<span>8 </span>   SmallStr += "LLVM!"; 
 
<span>9 </span> 
 

<span>10 </span>   llvm::outs() &lt;&lt; "SmallString result: " &lt;&lt; SmallStr &lt;&lt; "\n";</pre>
<p class="hidden"><a id="x1-74038r8" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-74039" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 4.8</strong>: <span><code class="calibre13">llvm</code><code class="calibre13">::</code><code class="calibre13">SmallString</code><code class="calibre13">&lt;&gt;</code> usage example </span></p>
<p class="hidden">Despite the fact that string manipulation is key in compiler tasks such as text parsing, LLVM has many other helper classes. We’ll explore its sequential containers next.</p>
</section>
<section id="sequential-containers" class="level" data-number="1.4.3.2.2">
<h4 data-number="1.4.3.2.2" class="sigil_not_in_toc"><a id="x1-750002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Sequential containers</h4>
<p class="hidden">LLVM recommends <a id="dx1-75001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>some optimized replacements for <a id="dx1-75002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>arrays and vectors from the standard library. The most notable are:</p>
<ul class="calibre6">
<li class="calibre14"><p class="calibre15"><span><code class="calibre13">llvm</code><code class="calibre13">::</code><code class="calibre13">ArrayRef</code><code class="calibre13">&lt;&gt;</code></span>: A helper class designed for interfaces that accept a sequential list of elements for read-only access. The class is akin to <span><code class="calibre13">llvm</code><code class="calibre13">::</code><code class="calibre13">StringRef</code><code class="calibre13">&lt;&gt;</code></span> in that it does not own the underlying data but merely references it.</p></li>
<li class="calibre14"><p class="calibre15"><span><code class="calibre13">llvm</code><code class="calibre13">::</code><code class="calibre13">SmallVector</code><code class="calibre13">&lt;&gt;</code></span>: An optimized vector for cases with a small size. It resembles <span><code class="calibre13">llvm</code><code class="calibre13">::</code><code class="calibre13">SmallString</code></span>, as discussed in <a href="#x1-740002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"><em class="calibre11">Section</em><em class="calibre11"> 4.3.2</em></a><em class="calibre11">,</em> <em class="calibre11">String operations</em>. Notably, the size for the array isn’t fixed, allowing the number of stored elements to grow. If the number of elements <a id="dx1-75003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>stays below <span><code class="calibre13">N</code></span> (the template argument), then there is no need for additional memory allocation.</p></li>
</ul>
<p class="hidden">Let’s examine the <span><code class="calibre13">llvm</code><code class="calibre13">::</code><code class="calibre13">SmallVector</code><code class="calibre13">&lt;&gt;</code></span> to better <a id="dx1-75004" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>understand these containers, as shown in <a href="#x1-75010r9" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 4.9</a>:</p>
<pre id="listing-29" class="source-code">1    llvm::SmallVector&lt;int, 10&gt; SmallVector; 
 

<span>2 </span>    for (int i = 0; i &lt; 10; i++) { 
 

<span>3 </span>      SmallVector.push_back(i); 
 
<span>4 </span>    } 
 

<span>5 </span>    SmallVector.push_back(10);</pre>
<p class="hidden"><a id="x1-75010r9" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-75011" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 4.9</strong>: <span><code class="calibre13">llvm</code><code class="calibre13">::</code><code class="calibre13">SmallVector</code><code class="calibre13">&lt;&gt;</code> usage </span></p>
<p class="hidden">The vector is initialized at <em class="calibre11">Line 1 </em>with a chosen size of 10 (indicated by the second template argument). The container offers an API similar to <span><code class="calibre13">std</code><code class="calibre13">::</code><code class="calibre13">vector</code><code class="calibre13">&lt;&gt;</code></span>, using the familiar <span><code class="calibre13">push_back</code></span> method to add new elements, as seen in <a href="#x1-75010r9" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 4.9</a>, <em class="calibre11">Lines 3 and 5.</em></p>
<p class="hidden">The first 10 elements are added to the vector without any additional memory allocation (see <a href="#x1-75010r9" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 4.9</a>, <em class="calibre11">Lines 2-4</em>). However, when the eleventh element is added at <em class="calibre11">Line 5</em>, the array’s size surpasses the pre-allocated space for 10 elements, triggering additional memory allocation. This container design efficiently minimizes memory allocation for small objects</p>
<p class="hidden">while maintaining the flexibility to accommodate larger sizes when necessary.</p>
</section>
<section id="map-like-containers" class="level" data-number="1.4.3.2.3">
<h4 data-number="1.4.3.2.3" class="sigil_not_in_toc"><a id="x1-760002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Map-like containers</h4>
<p class="hidden">The standard library <a id="dx1-76001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>provides several containers for storing key-value data. The most common ones are <span><code class="calibre13">std</code><code class="calibre13">::</code><code class="calibre13">map</code><code class="calibre13">&lt;&gt;</code></span> for general-purpose maps and <span><code class="calibre13">std</code><code class="calibre13">::</code><code class="calibre13">unordered_map</code><code class="calibre13">&lt;&gt;</code></span> for hash maps. LLVM offers <a id="dx1-76002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>additional alternatives to these standard containers:</p>
<ul class="calibre6">
<li class="calibre14"><p class="calibre15"><span><code class="calibre13">llvm</code><code class="calibre13">::</code><code class="calibre13">StringMap</code><code class="calibre13">&lt;&gt;</code></span>: A map that uses strings as keys. Typically, this is more performance optimized than the standard associative container, <span><code class="calibre13">std</code><code class="calibre13">::</code><code class="calibre13">unordered_map</code><code class="calibre13">&lt;</code><code class="calibre13">std</code><code class="calibre13">::</code><code class="calibre13">string</code><code class="calibre13">,</code> <code class="calibre13">T</code><code class="calibre13">&gt;</code></span>. It is frequently used in situations where string keys are dominant and performance is critical, as one might expect in a compiler infrastructure like LLVM. Unlike many other data structures in LLVM, <span><code class="calibre13">llvm</code><code class="calibre13">::</code><code class="calibre13">StringMap</code><code class="calibre13">&lt;&gt;</code></span> does not store a copy of the string key. Instead, it keeps a reference to the string data, so it’s crucial to ensure the string data outlives the map to prevent undefined behavior.</p></li>
<li class="calibre14"><p class="calibre15"><span><code class="calibre13">llvm</code><code class="calibre13">::</code><code class="calibre13">DenseMap</code><code class="calibre13">&lt;&gt;</code></span>: This map is designed to be more memory- and time-efficient than <span><code class="calibre13">std</code><code class="calibre13">::</code><code class="calibre13">unordered_map</code><code class="calibre13">&lt;&gt;</code></span> in most situations, though it comes with some additional constraints (e.g., keys and values having trivial destructors). It’s especially beneficial when you have simple key-value types and require high-performance lookups.</p></li>
<li class="calibre14"><p class="calibre15"><span><code class="calibre13">llvm</code><code class="calibre13">::</code><code class="calibre13">SmallDenseMap</code><code class="calibre13">&lt;&gt;</code></span>: This map is akin to <span><code class="calibre13">llvm</code><code class="calibre13">::</code><code class="calibre13">DenseMap</code><code class="calibre13">&lt;&gt;</code></span> but is optimized for instances where the map size is typically small. It allocates from the stack for small maps and only resorts to heap allocation when the map exceeds a predefined size.</p></li>
<li class="calibre14"><p class="calibre15"><span><code class="calibre13">llvm</code><code class="calibre13">::</code><code class="calibre13">MapVector</code><code class="calibre13">&lt;&gt;</code></span>: This container retains the insertion order, akin to Python’s <code class="calibre13">OrderedDict </code>. It is implemented as a blend of <span><code class="calibre13">std</code><code class="calibre13">::</code><code class="calibre13">vector</code></span> and either <span><code class="calibre13">llvm</code><code class="calibre13">::</code><code class="calibre13">DenseMap</code></span> or <span><code class="calibre13">llvm</code><code class="calibre13">::</code><code class="calibre13">SmallDenseMap</code></span>.</p></li>
</ul>
<p class="hidden">It’s noteworthy that these containers utilize a quadratically probed hash table mechanism. This method is effective for hash collision resolution because the cache isn’t recomputed during element lookups. This is crucial for performance-critical applications, such as compilers. <a id="x1-76003r215" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
</section>
</section>
<section id="smart-pointers" class="level" data-number="1.4.3.3">
<h3 data-number="1.4.3.3" id="sigil_toc_id_63" class="likesectionhead"><span>4.3.3 </span> <a id="x1-770003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Smart pointers</h3>
<p class="hidden">Different smart pointers can be found in LLVM code. The most popular ones come from the standard template library: <span><code class="calibre13">std</code><code class="calibre13">::</code><code class="calibre13">unique_ptr</code><code class="calibre13">&lt;&gt;</code></span> and <span><code class="calibre13">std</code><code class="calibre13">::</code><code class="calibre13">shared_ptr</code><code class="calibre13">&lt;&gt;</code></span>. In addition, LLVM provides some supplementary <a id="dx1-77001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>classes to work with smart pointers. One of the most prominent among them is <span><code class="calibre13">llvm</code><code class="calibre13">::</code><code class="calibre13">IntrusiveRefCntPtr</code><code class="calibre13">&lt;&gt;</code></span>. This smart pointer is designed to work with objects that <a id="dx1-77002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>support intrusive reference counting. Unlike <span><code class="calibre13">std</code><code class="calibre13">::</code><code class="calibre13">shared_ptr</code></span>, which maintains its own control block to manage the reference count, <span><code class="calibre13">IntrusiveRefCntPtr</code></span> expects the object to maintain its own reference count. This design can be more memory efficient. A typical usage example is shown here:</p>
<pre id="listing-30" class="source-code">1  class MyClass : public llvm::RefCountedBase&lt;MyClass&gt; { 
 

<span>2 </span>  // ... 
 
<span>3 </span>  }; 
 
<span>4 </span> 
 
<span>5 </span>  llvm::IntrusiveRefCntPtr&lt;MyClass&gt; Ptr = new MyClass();</pre>
<p class="hidden"><a id="x1-77008r10" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-77009" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 4.10</strong>: <span><code class="calibre13">llvm</code><code class="calibre13">::</code><code class="calibre13">IntrusiveRefCntPtr</code><code class="calibre13">&lt;&gt;</code> usage example </span></p>
<p class="hidden">As we can see, the smart pointer prominently employs the CRTP (which stands for Curiously Recurring Template Pattern) that was mentioned earlier in <a href="B19722_03.xhtml#x1-590003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"><em class="calibre11">Section</em><em class="calibre11"> 3.3</em></a><em class="calibre11">, AST traversal</em>. The CRTP is essential for the <span><code class="calibre13">Release</code></span> operation when the reference count drops to 0 and the object must be deleted. The implementation is as follows:</p>
<pre id="listing-31" class="source-code">1template &lt;class Derived&gt; class RefCountedBase { 
 

<span>2 </span>  // ... 
 
<span>3 </span>  void Release() const { 
 

<span>4 </span>   assert(RefCount &gt; 0 &amp;&amp; "Reference count is already zero."); 
 

<span>5 </span>   if (--RefCount == 0) 
 
<span>6 </span>     delete static_cast&lt;const Derived *&gt;(this); 
 

<span>7 </span>  } 
 
<span>8 </span>}</pre>
<p class="hidden"><a id="x1-77018r11" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-77019" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 4.11</strong>: CRTP usage in <span><code class="calibre13">llvm</code><code class="calibre13">::</code><code class="calibre13">RefCountedBase</code><code class="calibre13">&lt;&gt;</code>. The code was sourced from the <code class="calibre13">llvm/ADT/IntrusiveRefCntPtr.h </code>header </span></p>
<p class="hidden">Since <span><code class="calibre13">MyClass</code></span> in <a href="#x1-77008r10" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 4.10</a> is derived from <span><code class="calibre13">RefCountedBase</code></span>, we can perform a cast on it in <em class="calibre11">Line 6 </em>of <a href="#x1-77018r11" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 4.11</a>. This cast is <a id="dx1-77020" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>feasible since the type to cast is known, given that it is provided as a template parameter.</p>
<p class="hidden">We’ve just finished with LLVM basic libraries. Now it is time to move on to Clang basic libraries. Clang is a compiler frontend, and its <a id="dx1-77021" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>most important operations are related to diagnostics. Diagnostics require precise information about position location in the source code. Let’s explore the basic classes that Clang provides for these operations. <a id="x1-77022r206" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
</section>
</section>
<section id="clang-basic-libraries" class="level" data-number="1.4.4">
<h2 data-number="1.4.4" id="sigil_toc_id_64" class="likechapterhead"><span>4.4 </span> <a id="x1-780004" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Clang basic libraries</h2>
<p class="hidden">Clang is a compiler frontend, and its most important operations are related to diagnostics. Diagnostics require <a id="dx1-78001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>precise information about position location in the source code. Let’s explore the basic classes that Clang provides for these operations. <a id="x1-78002r223" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<section id="sourcemanager-and-sourcelocation" class="level" data-number="1.4.4.1">
<h3 data-number="1.4.4.1" id="sigil_toc_id_65" class="likesectionhead"><span>4.4.1 </span> <a id="x1-790001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>SourceManager and SourceLocation</h3>
<p class="hidden">Clang, as a compiler, operates with text files (programs), and <a id="dx1-79001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>locating a specific place in the <a id="dx1-79002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>program is one of the <a id="dx1-79003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>most frequently requested operations. Let’s look at a typical Clang error report. Consider a <a id="dx1-79004" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>program from <a href="B19722_03.xhtml#x1-530003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"><em class="calibre11">Chapter</em><em class="calibre11"> 3</em></a><em class="calibre11">, Clang AST</em>, as seen in <a href="B19722_03.xhtml#x1-65010r33" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 3.33</a>. Clang produces the following error message for the program:</p>
<pre id="verbatim-63" class="console">$ &lt;...&gt;/llvm-project/install/bin/clang -fsyntax-only maxerr.cpp
maxerr.cpp:3:12: error: use of undeclared identifier ’ab’
    return ab;
           ^
<span>1 </span> error generated.</pre>
<p class="hidden"><a id="x1-79005r12" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-79006" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 4.12</strong>: Error reported in maxerr.cpp </p>
<p class="hidden">As we can see in <a href="#x1-79005r12" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 4.12</a>, the following information is required to display the message:</p>
<ul class="calibre6">
<li class="calibre14"><p class="calibre15">Filename: In our case, it’s <code class="calibre13">maxerr.cpp</code></p></li>
<li class="calibre14"><p class="calibre15">Line in the file: In our case, it’s <code class="calibre13">3</code></p></li>
<li class="calibre14"><p class="calibre15">Column in the file: In our case, it’s <code class="calibre13">12</code></p></li>
</ul>
<p class="hidden">The data structure <a id="dx1-79007" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>that stores this information <a id="dx1-79008" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>should be as compact as possible because the compiler uses it frequently. Clang stores the required information in the <span><code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">SourceLocation</code></span> object.</p>
<p class="hidden">This object is <a id="dx1-79009" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>used often, so it should be <a id="dx1-79010" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>small in size and quick to copy. We can check the size of the object using lldb. For instance, if we run Clang under the debugger, we can determine the size as follows:</p>
<pre id="verbatim-64" class="console">$ lldb &lt;...&gt;/llvm-project/install/clang
...
(lldb) p sizeof(clang::SourceLocation)
(unsigned long) 4
(lldb)</pre>
<p class="hidden"><a id="x1-79011r13" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-79012" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 4.13</strong>: clang::SourceLocation size determination under debugger </p>
<p class="hidden">That is, the information is encoded using a single <span><code class="calibre13">unsigned</code> <code class="calibre13">long</code></span> number. How is this possible? The number merely serves as an identifier for a position in the text file. An additional class is required to correctly extract and represent this information, which is <span><code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">SourceManager</code></span>. The <code class="calibre13">SourceManager </code>object contains all the details about a specific location. In Clang, managing <a id="dx1-79013" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>source locations can be <a id="dx1-79014" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>challenging due to the presence of macros, includes, and other preprocessing directives. Consequently, there are several ways to interpret a <a id="dx1-79015" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>given source location. The primary <a id="dx1-79016" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>ones are as follows:</p>
<ul class="calibre6">
<li class="calibre14"><p class="calibre15"><strong class="calibre12">Spelling location</strong>: Refers to the location where something was actually spelled out in the source. If you have a source location pointing inside a macro body, the spelling location will give <a id="dx1-79017" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>you the location in the source code where the contents of the macro are defined.</p></li>
<li class="calibre14"><p class="calibre15"><strong class="calibre12">Expansion location</strong>: Refers to where a macro gets expanded. If you have a source location pointing <a id="dx1-79018" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>inside a macro body, the expansion location will give you the location in the source code where the macro was used (expanded).</p></li>
</ul>
<p class="hidden">Let’s look at a specific example:</p>
<pre class="source-code"><span>1 </span>#define BAR void bar() 
 
<span>2 </span>int foo(int x); 
 
<span>3 </span>BAR;</pre>
<p class="hidden"><a id="x1-79023r14" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-79024" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 4.14</strong>: Example program to test different types of source locations: functions.hpp </p>
<p class="hidden">In <a href="#x1-79023r14" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 4.14</a>, we define two functions: <span><code class="calibre13">int</code> <code class="calibre13">foo</code><code class="calibre13">()</code></span> at <em class="calibre11">Line 2 </em>and <span><code class="calibre13">void</code> <code class="calibre13">bar</code><code class="calibre13">()</code></span> at <em class="calibre11">Line 3</em>. For the first function, both the spelling and expansion locations point to <em class="calibre11">Line 2</em>. However, for the second function, the spelling location is at <em class="calibre11">Line 1</em>, while the expansion location is at <em class="calibre11">Line 3</em>.</p>
<p class="hidden">Let’s examine this with a test Clang tool. We will use the test project from <a href="B19722_03.xhtml#x1-620004" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"><em class="calibre11">Section</em><em class="calibre11"> 3.4</em></a><em class="calibre11">, Recursive AST visitor</em> and replace some parts of the code here. First of all, we have to pass <span><code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">ASTContext</code></span> to our <span><code class="calibre13">Visitor</code></span> implementation. This is required because <span><code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">ASTContext</code></span> provides access to <span><code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">SourceManager</code></span>. We will replace <em class="calibre11">Line 11 </em>in <a href="B19722_03.xhtml#x1-60077r8" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 3.8</a> and pass <code class="calibre13">ASTContext </code>as follows:</p>
<pre class="source-code"><span>10 </span>  CreateASTConsumer(clang::CompilerInstance &amp;CI, llvm::StringRef File) { 
 

<span>11 </span>    return std::make_unique&lt;Consumer&gt;(&amp;CI.getASTContext());</pre>
<p class="hidden">The <span><code class="calibre13">Consumer</code></span> class (see <a href="B19722_03.xhtml#x1-60100r9" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 3.9</a>) will accept the argument and use it as a parameter for <span><code class="calibre13">Visitor</code></span>:</p>
<pre class="source-code"><span>8 </span>  Consumer(clang::ASTContext *Context) 
 

<span>9 </span>      : V(std::make_unique&lt;Visitor&gt;(Context)) {}</pre>
<p class="hidden">The main <a id="dx1-79031" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>changes are for the <span><code class="calibre13">Visitor</code></span> class, which is <a id="dx1-79032" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>mostly rewritten. First of all, we pass <span><code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">ASTContext</code></span> to the class constructor as follows:</p>
<pre class="source-code"><span>5 </span>class Visitor : public clang::RecursiveASTVisitor&lt;Visitor&gt; { 
 

<span>6 </span>public: 
 
<span>7 </span>  explicit Visitor(clang::ASTContext *C) : Context(C) {}</pre>
<p class="hidden"><a id="x1-79039r15" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-79040" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 4.15</strong>: Visitor class implementation: constructor </p>
<p class="hidden">The AST Context <a id="dx1-79041" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>class is stored as a private <a id="dx1-79042" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>member of our class, as shown below:</p>
<pre class="source-code"><span>25 </span>private: 
 
<span>26 </span>  clang::ASTContext *Context;</pre>
<p class="hidden"><a id="x1-79046r16" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-79047" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 4.16</strong>: Visitor class implementation: private section </p>
<p class="hidden">The main processing logic is in <span><code class="calibre13">Visitor</code><code class="calibre13">::</code><code class="calibre13">VisitFunctionDecl</code></span> method, which you can see next</p>
<pre class="source-code"><span>9 </span>  bool VisitFunctionDecl(const clang::FunctionDecl *FD) { 
 

<span>10 </span>    clang::SourceManager &amp;SM = Context-&gt;getSourceManager(); 
 

<span>11 </span>    clang::SourceLocation Loc = FD-&gt;getLocation(); 
 

<span>12 </span>    clang::SourceLocation ExpLoc = SM.getExpansionLoc(Loc); 
 

<span>13 </span>    clang::SourceLocation SpellLoc = SM.getSpellingLoc(Loc); 
 

<span>14 </span>    llvm::StringRef ExpFileName = SM.getFilename(ExpLoc); 
 

<span>15 </span>    llvm::StringRef SpellFileName = SM.getFilename(SpellLoc); 
 

<span>16 </span>    unsigned SpellLine = SM.getSpellingLineNumber(SpellLoc); 
 

<span>17 </span>    unsigned ExpLine = SM.getExpansionLineNumber(ExpLoc); 
 

<span>18 </span>    llvm::outs() &lt;&lt; "Spelling : " &lt;&lt; FD-&gt;getName() &lt;&lt; " at " &lt;&lt; SpellFileName 
 

<span>19 </span>                 &lt;&lt; ":" &lt;&lt; SpellLine &lt;&lt; "\n"; 
 

<span>20 </span>    llvm::outs() &lt;&lt; "Expansion : " &lt;&lt; FD-&gt;getName() &lt;&lt; " at " &lt;&lt; ExpFileName 
 

<span>21 </span>                 &lt;&lt; ":" &lt;&lt; ExpLine &lt;&lt; "\n"; 
 

<span>22 </span>    return true; 
 
<span>23 </span>  }</pre>
<p class="hidden"><a id="x1-79064r17" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-79065" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 4.17</strong>: Visitor class implementation: VisitFunctionDecl method </p>
<p class="hidden">If we <a id="dx1-79066" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>compile and <a id="dx1-79067" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>run the code on the <a id="dx1-79068" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>test file from <a href="#x1-79023r14" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 4.14</a>, the <a id="dx1-79069" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>following output will be generated::</p>
<pre id="verbatim-65" class="console">Spelling : foo at functions.hpp:2
Expansion : foo at functions.hpp:2
Spelling : bar at functions.hpp:1
Expansion : bar at functions.hpp:3</pre>
<p class="hidden"><a id="x1-79070r18" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-79071" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 4.18</strong>: Output from the recursivevisitor executable on the functions.hpp test file </p>
<p class="hidden"><span><code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">SourceLocation</code></span> and <span><code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">SourceManager</code></span> are very powerful classes. In combination with other classes such as <span><code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">SourceRange</code></span> (a pair of two source locations that specify the beginning and end of a source range), they provide a great foundation for diagnostics used in Clang. <a id="x1-79072r227" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
</section>
<section id="diagnostics-support" class="level" data-number="1.4.4.2">
<h3 data-number="1.4.4.2" id="sigil_toc_id_66" class="likesectionhead"><span>4.4.2 </span> <a id="x1-800002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Diagnostics support</h3>
<p class="hidden">Clang’s diagnostics <a id="dx1-80001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>subsystem is responsible for <a id="dx1-80002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>generating and reporting warnings, errors, and other messages [<a href="B19722_Bib.xhtml#Xllvm_clang_cfe_internals_manual" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">8</a>]. The main classes involved are:</p>
<ul class="calibre6">
<li class="calibre14"><p class="calibre15"><span><code class="calibre13">DiagnosticsEngine</code></span>: Manages diagnostic IDs and options</p></li>
<li class="calibre14"><p class="calibre15"><span><code class="calibre13">DiagnosticConsumer</code></span>: Abstract base class for diagnostic consumers</p></li>
<li class="calibre14"><p class="calibre15"><span><code class="calibre13">DiagnosticIDs</code></span>: Handles the mapping between diagnostic flags and internal IDs</p></li>
<li class="calibre14"><p class="calibre15"><span><code class="calibre13">DiagnosticInfo</code></span>: Represents a single diagnostic</p></li>
</ul>
<p class="hidden">Here is a simple example illustrating how you might emit a warning in Clang:</p>
<pre class="source-code"><span>18 </span>  // Emit a warning 
 
<span>19 </span>  DiagnosticsEngine.Report(DiagnosticsEngine.getCustomDiagID( 
 

<span>20 </span>      clang::DiagnosticsEngine::Warning, "This is a custom warning."));</pre>
<p class="hidden"><a id="x1-80007r19" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-80008" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 4.19</strong>: Emit warning with clang::DiagnosticsEngine </p>
<p class="hidden">In our example, we will use a simple DiagnosticConsumer, <span><code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">TextDiagnosticPrinter</code></span>, which formats and prints the processed diagnostic messages.</p>
<p class="hidden">The full code for the main function of our example is shown in <a href="#x1-80027r20" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 4.20</a>:</p>
<pre class="source-code"><span>7 </span>int main() { 
 
<span>8 </span>  llvm::IntrusiveRefCntPtr&lt;clang::DiagnosticOptions&gt; DiagnosticOptions = 
 

<span>9 </span>      new clang::DiagnosticOptions(); 
 

<span>10 </span>  clang::TextDiagnosticPrinter TextDiagnosticPrinter( 
 

<span>11 </span>      llvm::errs(), DiagnosticOptions.get(), false); 
 

<span>12 </span> 
 
<span>13 </span>  llvm::IntrusiveRefCntPtr&lt;clang::DiagnosticIDs&gt; DiagIDs = 
 

<span>14 </span>      new clang::DiagnosticIDs(); 
 

<span>15 </span>  clang::DiagnosticsEngine DiagnosticsEngine(DiagIDs, DiagnosticOptions, 
 

<span>16 </span>                                             &amp;TextDiagnosticPrinter, false); 
 

<span>17 </span> 
 
<span>18 </span>  // Emit a warning 
 
<span>19 </span>  DiagnosticsEngine.Report(DiagnosticsEngine.getCustomDiagID( 
 

<span>20 </span>      clang::DiagnosticsEngine::Warning, "This is a custom warning.")); 
 

<span>21 </span> 
 
<span>22 </span>  return 0; 
 
<span>23 </span>}</pre>
<p class="hidden"><a id="x1-80027r20" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-80028" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 4.20</strong>: Clang diagnostics example </p>
<p class="hidden">The <a id="dx1-80029" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>code will produce <a id="dx1-80030" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>the following output</p>
<pre id="verbatim-66" class="console">warning: This is a custom warning.</pre>
<p class="hidden"><a id="x1-80031r21" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-80032" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 4.21</strong>: Printed diagnostics </p>
<p class="hidden">In this example, we first set up <span><code class="calibre13">DiagnosticsEngine</code></span> with <span><code class="calibre13">TextDiagnosticPrinter</code></span> as its <span><code class="calibre13">DiagnosticConsumer</code></span>. We then use the <span><code class="calibre13">Report</code></span> method of <span><code class="calibre13">DiagnosticsEngine</code></span> to emit a custom warning. We will add a more realistic example later when we create our test project for the Clang plugin in <a href="#x1-840006" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"><em class="calibre11">Section</em><em class="calibre11"> 4.6</em></a><em class="calibre11">, Clang plugin</em> <em class="calibre11">project</em>. <a id="x1-80033r226" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
</section>
</section>
<section id="llvm-supporting-tools" class="level" data-number="1.4.5">
<h2 data-number="1.4.5" id="sigil_toc_id_67" class="likechapterhead"><span>4.5 </span> <a id="x1-810005" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>LLVM supporting tools</h2>
<p class="hidden">The LLVM project has its own tooling support. The most important LLVM tools are TableGen and LIT (which stands for LLVM Integrated Tester). We will look into them with examples from the Clang code. These examples <a id="dx1-81001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>should help us understand the purpose of the tooling and how they can be used. <a id="x1-81002r241" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<section id="tablegen" class="level" data-number="1.4.5.1">
<h3 data-number="1.4.5.1" id="sigil_toc_id_68" class="likesectionhead"><span>4.5.1 </span> <a id="x1-820001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>TableGen</h3>
<p class="hidden">TableGen is a <strong class="calibre12">domain-specific language (DSL) </strong>and associated <a id="dx1-82001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>tool used in the LLVM project for the purpose of describing and generating tables, particularly those that describe a target architecture. This is highly <a id="dx1-82002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>useful for compiler infrastructure, where one frequently needs to describe things such as instruction sets, registers, and various other target-specific attributes in a structured manner.</p>
<p class="hidden">TableGen is employed in various <a id="dx1-82003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>parts of the Clang compiler. It’s primarily used where there’s a need to generate large amounts of similar code. For instance, it can be used for supporting cast operations that necessitate extensive enum declarations in basic classes, or in the diagnostic subsystem where code generation is required to handle numerous similar diagnostic messages. We will examine how TableGen functions within the diagnostics system as an example.</p>
<p class="hidden">We will begin with the <code class="calibre13">Diagnostic.td </code>file, which describes Clang’s diagnostics. This file can be found at <code class="calibre13">clang/include/clang/Basic/Diagnostic.td</code>. Let’s examine how diagnostic severity is defined:</p>
<pre class="source-code"><span>16 </span>// Define the diagnostic severities. 
 

<span>17 </span>class Severity&lt;string N&gt; { 
 
<span>18 </span>  string Name = N; 
 
<span>19 </span>}</pre>
<p class="hidden"><a id="x1-82009r22" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-82010" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 4.22</strong>: Severity definition in clang/include/clang/Basic/Diagnostic.td </p>
<p class="hidden">In <a href="#x1-82009r22" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 4.22</a>, we define a class for severities (<em class="calibre11">Lines 17-19</em>). Each severity is associated with a string, as shown below:</p>
<pre class="source-code"><span>20 </span>def SEV_Ignored : Severity&lt;"Ignored"&gt;; 
 

<span>21 </span>def SEV_Remark  : Severity&lt;"Remark"&gt;; 
 

<span>22 </span>def SEV_Warning : Severity&lt;"Warning"&gt;; 
 

<span>23 </span>def SEV_Error   : Severity&lt;"Error"&gt;; 
 

<span>24 </span>def SEV_Fatal   : Severity&lt;"Fatal"&gt;;</pre>
<p class="hidden"><a id="x1-82017r23" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-82018" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 4.23</strong>: Definitions for different types of severity in clang/include/clang/Basic/Diagnostic.td </p>
<p class="hidden"><a href="#x1-82017r23" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 4.23</a> contains definitions for the different severities; for instance, the <code class="calibre13">Warning </code>severity is defined on <em class="calibre11">Line 22</em>.</p>
<p class="hidden">The severity is later <a id="dx1-82019" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>used to define the <span><code class="calibre13">Diagnostic</code></span> class, with the <span><code class="calibre13">Warning</code></span> diagnostic being defined as a descendant of this class:</p>
<pre id="listing-32" class="source-code">// All diagnostics emitted by the compiler are an indirect subclass of this. 
 

class Diagnostic&lt;string summary, DiagClass DC, Severity defaultmapping&gt; { 
 

  ... 
 
} 
 
... 
 
class Warning&lt;string str&gt;   : Diagnostic&lt;str, CLASS_WARNING, SEV_Warning&gt;;</pre>
<p class="hidden"><a id="x1-82026r24" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-82027" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 4.24</strong>: Diagnostics definition in clang/include/clang/Basic/Diagnostic.td </p>
<p class="hidden">Using the <span><code class="calibre13">Warning</code></span> class definition, different instances of the class can be defined. For example, the following is an instance that defines an unused parameter warning located in <code class="calibre13">DiagnosticSemaKinds.td</code>:</p>
<pre class="source-code">def warn_unused_parameter : Warning&lt;"unused parameter %0"&gt;, 
 

  InGroup&lt;UnusedParameter&gt;, DefaultIgnore;</pre>
<p class="hidden"><a id="x1-82031r25" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-82032" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 4.25</strong>: The definition of the unused parameter warning in clang/include/clang/Basic/DiagnosticSemaKinds.td </p>
<p class="hidden">The <code class="calibre13">clang-tblgen </code>tool will generate the corresponding <code class="calibre13">DiagnosticSemaKinds.inc</code> file:</p>
<pre id="listing-33" class="source-code">DIAG(warn_unused_parameter, CLASS_WARNING, (unsigned)diag::Severity::Ignored, "unused parameter %0", 985, SFINAE_Suppress, false, false, true, false, 2)</pre>
<p class="hidden"><a id="x1-82034r26" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-82035" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 4.26</strong>: The definition of the unused parameter warning in clang/include/clang/Basic/DiagnosticSemaKinds.inc </p>
<p class="hidden">This file retains all the <a id="dx1-82036" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>necessary information about the diagnostic. This information can be retrieved from the Clang source code <a id="dx1-82037" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>using different definitions of the <span><code class="calibre13">DIAG</code></span> macro.</p>
<p class="hidden">For instance, the following code leverages the TableGen-generated code to extract diagnostic descriptions, as found in <code class="calibre13">clang/lib/Basic/DiagnosticIDs.cpp</code>:</p>
<pre id="listing-34" class="source-code">  const StaticDiagInfoDescriptionStringTable StaticDiagInfoDescriptions = { 
 

#define DIAG(ENUM, CLASS, DEFAULT_SEVERITY, DESC, GROUP, SFINAE, NOWERROR,\ 
 

            SHOWINSYSHEADER, SHOWINSYSMACRO, DEFERRABLE, CATEGORY)    \ 
 

  DESC, 
 
... 
 
#include "clang/Basic/DiagnosticSemaKinds.inc" 
 

... 
 
#undef DIAG 
 
};</pre>
<p class="hidden"><a id="x1-82047r27" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-82048" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 4.27</strong>: DIAG macro definition </p>
<p class="hidden">The C++ preprocessor will expand to the following:</p>
<pre id="listing-35" class="source-code">  const StaticDiagInfoDescriptionStringTable StaticDiagInfoDescriptions = { 
 

   ... 
 
   "unused parameter %0", 
 
   ... 
 
  };</pre>
<p class="hidden"><a id="x1-82054r28" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-82055" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 4.28</strong>: DIAG macro expansion </p>
<p class="hidden">The provided example demonstrates how TableGen can be used to generate code in Clang and how it can simplify <a id="dx1-82056" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Clang development. The diagnostic subsystem is not the only area where TableGen is utilized; it is also widely <a id="dx1-82057" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>used in other parts of Clang. For instance, the macros used in various types of AST visitors also rely on the code generated by TableGen; see <a href="B19722_03.xhtml#x1-610002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"><em class="calibre11">Section</em><em class="calibre11"> 3.3.2</em></a><em class="calibre11">, Visitor</em> <em class="calibre11">implementation</em>. <a id="x1-82058r248" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
</section>
<section id="llvm-test-framework" class="level" data-number="1.4.5.2">
<h3 data-number="1.4.5.2" id="sigil_toc_id_69" class="likesectionhead"><span>4.5.2 </span> <a id="x1-830002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>LLVM test framework</h3>
<p class="hidden">LLVM uses <a id="dx1-83001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>several testing frameworks <a id="dx1-83002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>for different types of testing. The primary ones are <strong class="calibre12">LLVM Integrated Tester (LIT) </strong>and <strong class="calibre12">Google Test (GTest) </strong>[<a href="B19722_Bib.xhtml#XGoogleTest" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">24</a>]. Both LIT and GTest play significant <a id="dx1-83003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>roles in Clang’s <a id="dx1-83004" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>testing infrastructure:</p>
<ul class="calibre6">
<li class="calibre14"><p class="calibre15">LIT is primarily used for testing the behavior of the Clang toolchain as a whole, with a focus on its code compilation capabilities and the diagnostics it produces.</p></li>
<li class="calibre14"><p class="calibre15">GTest is utilized for unit tests, targeting specific components of the code base, primarily utility libraries and internal data structures.</p></li>
</ul>
<p class="hidden">These tests are crucial for maintaining the quality and stability of the Clang project.</p>

<p class="hidden"><span>Important note</span></p>

<p class="hidden">We will not delve into GTest, as this testing framework is commonly used outside LLVM and isn’t part of LLVM itself. For more information about GTest, please visit its official page: <a href="https://github.com/google/googletest" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">https://github.com/google/googletest</a></p>

<p class="hidden">Our focus will be on LIT. LIT is LLVM’s own test framework and is heavily used for testing the various tools and libraries in LLVM, including the Clang compiler. LIT is designed to be lightweight and is tailored for the needs of compiler testing. It’s commonly used for running tests that are essentially shell scripts, often with checks for specific patterns in the output. A typical LIT test may consist of a source code file along with a set of ”RUN” commands that specify how to compile, link, or otherwise process the file, and what output to expect.</p>
<p class="hidden">The RUN commands <a id="dx1-83005" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>often use FileCheck, another utility in the LLVM project, to check the output against expected patterns. In Clang, LIT tests are often used to test frontend features such as parsing, semantic analysis, code generation, and diagnostics. These tests typically look like source code <a id="dx1-83006" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>files with embedded comments to indicate how to run the test and what to expect.</p>
<p class="hidden">Consider the following example from <code class="calibre13">clang/test/Sema/attr-unknown.c</code>:</p>
<pre class="source-code"><span>1 </span>// RUN: %clang_cc1 -fsyntax-only -verify -Wattributes %s 
 

<span>2 </span> 
 
<span>3 </span>int x __attribute__((foobar)); // expected-warning {{unknown attribute ’foobar’ ignored}} 
 

<span>4 </span>void z(void) __attribute__((bogusattr)); // expected-warning {{unknown attribute ’bogusattr’ ignored}}</pre>
<p class="hidden"><a id="x1-83012r29" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-83013" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 4.29</strong>: LIT test for Clang warnings about unknown attributes </p>
<p class="hidden">The example is a typical C source file that can be processed by Clang. LIT’s behavior is controlled by comments within the source text. The first comment (on <em class="calibre11">Line 1</em>) specifies how the test should be executed. As indicated, <code class="calibre13">clang</code> should be started with some additional arguments: <code class="calibre13">-fsyntax-only </code>and <code class="calibre13">-verify</code> . There are also substitutions that begin with the ’%’ symbol. The most important of these is ’%s’, which is replaced by the source file’s name. LIT will also examine comments beginning with <code class="calibre13">expected-warning </code>and ensure that the warnings produced by Clang’s output match the expected values.</p>
<p class="hidden">The test can be run as follows:</p>
<pre id="verbatim-67" class="console">$ ./build/bin/llvm-lit ./clang/test/Sema/attr-unknown.c
...
-- Testing: 1 tests, 1 workers --
PASS: Clang :: Sema/attr-unknown.c (1 of 1)

Testing Time: 0.06s
  Passed: 1</pre>
<p class="hidden"><a id="x1-83014r30" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-83015" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 4.30</strong>: LIT test run </p>
<p class="hidden">We run <code class="calibre13">llvm-lit </code>from the <code class="calibre13">build </code>folder because the <a id="dx1-83016" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>tool is not included in the installation procedure. We can <a id="dx1-83017" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>obtain more details about LIT setup and its invocation once we create our test clang plugin project and configure LIT tests for it. <a id="x1-83018r247" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
</section>
</section>
<section id="clang-plugin-project" class="level" data-number="1.4.6">
<h2 data-number="1.4.6" id="sigil_toc_id_70" class="likechapterhead"><span>4.6 </span> <a id="x1-840006" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Clang plugin project</h2>
<p class="hidden">The goal of the test project is to create a clang plugin that will estimate class complexity. Specifically, a class is deemed complex if the number of its methods exceeds a certain threshold. We will <a id="dx1-84001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>leverage all the knowledge we have acquired thus far for this project. This will include the use of a recursive visitor and Clang diagnostics. Additionally, we will create a LIT test for our project. Developing the plugin will necessitate a unique build configuration for LLVM, which will be our initial step. <a id="x1-84002r259" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<section id="environment-setup" class="level" data-number="1.4.6.1">
<h3 data-number="1.4.6.1" id="sigil_toc_id_71" class="likesectionhead"><span>4.6.1 </span> <a id="x1-850001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Environment setup</h3>
<p class="hidden">The plugin will be <a id="dx1-85001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>created as a shared object, and our LLVM installation should be built with support for shared libraries (see <a href="B19722_01.xhtml#x1-270001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"><em class="calibre11">Section</em><em class="calibre11"> 1.3.1</em></a><em class="calibre11">, Configuration with</em> <em class="calibre11">CMake</em>):</p>
<pre id="listing-36" class="source-code">cmake -G Ninja -DCMAKE_BUILD_TYPE=Debug -DCMAKE_INSTALL_PREFIX=../install -DLLVM_TARGETS_TO_BUILD="X86" -DLLVM_ENABLE_PROJECTS="clang" -DLLVM_USE_SPLIT_DWARF=ON -DBUILD_SHARED_LIBS=ON ../llvm</pre>
<p class="hidden"><a id="x1-85003r31" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-85004" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 4.31</strong>: CMake configuration used for the Clang plugin project </p>
<p class="hidden">As can be seen, we use the build configuration from <a href="B19722_01.xhtml#x1-300004" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"><em class="calibre11">Section</em><em class="calibre11"> 1.4</em></a><em class="calibre11">, Test project –</em> <em class="calibre11">syntax check with a Clang tool</em>, as shown in <a href="B19722_01.xhtml#x1-30003r12" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 1.12</a>. In the configuration, we set up a folder for installing artifacts into <code class="calibre13">../install</code>, limit our build targets to the <code class="calibre13">X86 </code>platform, and enable only the <code class="calibre13">clang </code>project. Additionally, we enable <a id="dx1-85005" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>size optimization for debug symbols and use shared libraries instead of static linkage.</p>
<p class="hidden">The next step involves building and installing clang. This can be achieved with the following command:</p>
<pre id="verbatim-68" class="console">$ ninja install</pre>
<p class="hidden">As soon as we are done with the clang build and installation, we can proceed with the <code class="calibre13">CMakeLists.txt </code>file for our project. <a id="x1-85006r264" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
</section>
<section id="cmake-build-configuration-for-plugin" class="level" data-number="1.4.6.2">
<h3 data-number="1.4.6.2" id="sigil_toc_id_72" class="likesectionhead"><span>4.6.2 </span> <a id="x1-860002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>CMake build configuration for plugin</h3>
<p class="hidden">We will use <a href="B19722_03.xhtml#x1-62028r20" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 3.20</a> as the foundation for our plugin build configuration. We will change the project name to <code class="calibre13">classchecker </code>, and <code class="calibre13">ClassComplexityChecker.cpp</code> will serve as our primary source file. The main portion of the file is displayed in <a href="#x1-86023r32" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 4.32</a>. As can be observed, we will construct a shared library (<em class="calibre11">Lines 18-20</em>) rather than an executable, as in our previous test projects. Another modification is in <em class="calibre11">Line 12</em>, where we set up a config parameter for the LLVM build folder. This parameter is necessary to locate the LIT executable, which is not included in the standard installation process, as mentioned earlier in <a href="#x1-830002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"><em class="calibre11">Section</em><em class="calibre11"> 4.5.2</em></a><em class="calibre11">, LLVM test framework</em>. Some additional modifications need to be made to support LIT test invocations, but we will discuss the details later in <a href="#x1-920008" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"><em class="calibre11">Section</em><em class="calibre11"> 4.6.8</em></a><em class="calibre11">, LIT tests for clang plugin</em> (see <a href="#x1-94025r44" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 4.44</a>).</p>
<pre class="source-code"><span>8 </span>  message(STATUS "$LLVM_HOME found: $ENV{LLVM_HOME}") 
 

<span>9 </span>  set(LLVM_HOME $ENV{LLVM_HOME} CACHE PATH "Root of LLVM installation") 
 

<span>10 </span>  set(LLVM_LIB ${LLVM_HOME}/lib) 
 

<span>11 </span>  set(LLVM_DIR ${LLVM_LIB}/cmake/llvm) 
 

<span>12 </span>  set(LLVM_BUILD $ENV{LLVM_BUILD} CACHE PATH "Root of LLVM build") 
 

<span>13 </span>  find_package(LLVM REQUIRED CONFIG) 
 

<span>14 </span>  include_directories(${LLVM_INCLUDE_DIRS}) 
 

<span>15 </span>  link_directories(${LLVM_LIBRARY_DIRS}) 
 
<span>16 </span> 
 

<span>17 </span>  # Add the plugin’s shared library target 
 

<span>18 </span>  add_library(classchecker MODULE 
 

<span>19 </span>    ClassChecker.cpp 
 
<span>20 </span>  ) 
 
<span>21 </span>  set_target_properties(classchecker PROPERTIES COMPILE_FLAGS "-fno-rtti") 
 

<span>22 </span>  target_link_libraries(classchecker 
 

<span>23 </span>    LLVMSupport 
 
<span>24 </span>    clangAST 
 
<span>25 </span>    clangBasic 
 

<span>26 </span>    clangFrontend 
 
<span>27 </span>    clangTooling 
 
<span>28 </span>  )</pre>
<p class="hidden"><a id="x1-86023r32" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-86024" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 4.32</strong>: CMakeLists.txt file for class complexity plugin </p>
<p class="hidden">After completing the <a id="dx1-86025" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>build configuration, we can <a id="dx1-86026" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>start writing the primary code for the plugin. The first component we’ll create is a recursive visitor class named <span><code class="calibre13">ClassVisitor</code></span>. <a id="x1-86027r266" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
</section>
<section id="recursive-visitor-class" class="level" data-number="1.4.6.3">
<h3 data-number="1.4.6.3" id="sigil_toc_id_73" class="likesectionhead"><span>4.6.3 </span> <a id="x1-870003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Recursive visitor class</h3>
<p class="hidden">Our visitor class is located in the <code class="calibre13">ClassVisitor.hpp </code>file (see <a href="#x1-87040r33" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 4.33</a>). This is a recursive visitor <a id="dx1-87001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>that handles <span><code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">CXXRecordDecl</code></span>, which are the AST nodes for C++ class declarations. We calculate the <a id="dx1-87002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>number of methods in <em class="calibre11">Lines 13-16 </em>and emit diagnostics in <em class="calibre11">Lines 19-25 </em>if the threshold is exceeded.</p>
<pre class="source-code"><span>1 </span>#include "clang/AST/ASTContext.h" 
 

<span>2 </span>#include "clang/AST/RecursiveASTVisitor.h" 
 
<span>3 </span> 
 

<span>4 </span>namespace clangbook { 
 
<span>5 </span>namespace classchecker { 
 

<span>6 </span>class ClassVisitor : public clang::RecursiveASTVisitor&lt;ClassVisitor&gt; { 
 

<span>7 </span>public: 
 
<span>8 </span>  explicit ClassVisitor(clang::ASTContext *C, int T) 
 

<span>9 </span>      : Context(C), Threshold(T) {} 
 
<span>10 </span> 
 

<span>11 </span>  bool VisitCXXRecordDecl(clang::CXXRecordDecl *Declaration) { 
 

<span>12 </span>    if (Declaration-&gt;isThisDeclarationADefinition()) { 
 

<span>13 </span>      int MethodCount = 0; 
 
<span>14 </span>      for (const auto *M : Declaration-&gt;methods()) { 
 

<span>15 </span>        MethodCount++; 
 
<span>16 </span>      } 
 
<span>17 </span> 
 
<span>18 </span>      if (MethodCount &gt; Threshold) { 
 

<span>19 </span>        clang::DiagnosticsEngine &amp;D = Context-&gt;getDiagnostics(); 
 

<span>20 </span>        unsigned DiagID = 
 
<span>21 </span>            D.getCustomDiagID(clang::DiagnosticsEngine::Warning, 
 

<span>22 </span>                              "class %0 is too complex: method count = %1"); 
 

<span>23 </span>        clang::DiagnosticBuilder DiagBuilder = 
 

<span>24 </span>            D.Report(Declaration-&gt;getLocation(), DiagID); 
 

<span>25 </span>        DiagBuilder &lt;&lt; Declaration-&gt;getName() &lt;&lt; MethodCount; 
 

<span>26 </span>      } 
 
<span>27 </span>    } 
 
<span>28 </span>    return true; 
 
<span>29 </span>  }</pre>
<pre id="listing-37" class="source-code">30 
 
<span>31 </span>private: 
 
<span>32 </span>  clang::ASTContext *Context; 
 

<span>33 </span>  int Threshold; 
 
<span>34 </span>}; 
 
<span>35 </span>} // namespace classchecker 
 

<span>36 </span>} // namespace clangbook</pre>
<p class="hidden"><a id="x1-87040r33" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-87041" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 4.33</strong>: Source code for ClassVisitor.hpp </p>
<p class="hidden">It’s worth noting the diagnostic calls. The diagnostic message is constructed in <em class="calibre11">Lines 20-22</em>. Our diagnostic message accepts two parameters: the class name and the number of methods for the class. These parameters are <a id="dx1-87042" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>encoded with the ’%1’ and ’%2’ placeholders in <em class="calibre11">Line 22</em>. The actual <a id="dx1-87043" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>values for these parameters are passed in <em class="calibre11">Line 25</em>, where the diagnostic message is constructed using the <span><code class="calibre13">DiagBuild</code></span> object. This object is an instance of the <span><code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">DiagnosticBuilder</code></span> class, which implements the <strong class="calibre12">Resource</strong> <strong class="calibre12">Acquisition Is Initialization (RAII) </strong>pattern. It emits the <a id="dx1-87044" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>actual diagnostics upon its destruction.</p>

<p class="hidden"><span>Important note</span></p>

<p class="hidden">In C++, the RAII principle is a common idiom used to manage resource lifetimes by tying them to the lifetime of an object. When an object goes out of scope, its destructor is automatically called, and this provides an opportunity to release the resource that the object holds.</p>

<p class="hidden"><span><code class="calibre13">ClassVisitor</code></span> is created within an AST consumer class, which will be our next topic. <a id="x1-87045r269" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
</section>
<section id="plugin-ast-consumer-class" class="level" data-number="1.4.6.4">
<h3 data-number="1.4.6.4" id="sigil_toc_id_74" class="likesectionhead"><span>4.6.4 </span> <a id="x1-880004" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Plugin AST consumer class</h3>
<p class="hidden">The AST consumer <a id="dx1-88001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>class is implemented in <code class="calibre13">ClassConsumer.hpp </code>and represents the standard AST consumer, as seen in our AST <a id="dx1-88002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>visitor test projects (refer to <a href="B19722_03.xhtml#x1-60100r9" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 3.9</a>). The code is presented in <a href="#x1-89032r35" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 4.35</a>.</p>
<pre class="source-code"><span>1 </span>namespace clangbook { 
 
<span>2 </span>namespace classchecker { 
 

<span>3 </span>class ClassConsumer : public clang::ASTConsumer { 
 

<span>4 </span>public: 
 
<span>5 </span>  explicit ClassConsumer(clang::ASTContext *Context, int Threshold) 
 

<span>6 </span>      : Visitor(Context, Threshold) {} 
 
<span>7 </span> 
 

<span>8 </span>  virtual void HandleTranslationUnit(clang::ASTContext &amp;Context) { 
 

<span>9 </span>    Visitor.TraverseDecl(Context.getTranslationUnitDecl()); 
 

<span>10 </span>  } 
 
<span>11 </span> 
 
<span>12 </span>private: 
 
<span>13 </span>  ClassVisitor Visitor; 
 

<span>14 </span>}; 
 
<span>15 </span>} // namespace classchecker 
 

<span>16 </span>} // namespace clangbook</pre>
<p class="hidden"><a id="x1-88020r34" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-88021" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 4.34</strong>: Source code for ClassConsumer.hpp </p>
<p class="hidden">The code initializes <code class="calibre13">Visitor </code>at <em class="calibre11">Line 10 </em>and utilizes the Visitor class at <em class="calibre11">Line 13</em> to traverse the declarations, starting <a id="dx1-88022" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>with the top one (translation unit declaration). The consumer must be created <a id="dx1-88023" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>from a special AST action class, which we will discuss next. <a id="x1-88024r272" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
</section>
<section id="plugin-ast-action-class" class="level" data-number="1.4.6.5">
<h3 data-number="1.4.6.5" id="sigil_toc_id_75" class="likesectionhead"><span>4.6.5 </span> <a id="x1-890005" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Plugin AST action class</h3>
<p class="hidden">The code for <a id="dx1-89001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>the AST action is shown in <a href="#x1-89032r35" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 4.35</a>. Several <a id="dx1-89002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>important parts can be observed:</p>
<ul class="calibre6">
<li class="calibre14"><p class="calibre15"><em class="calibre11">Line 7</em>: We inherit our <span><code class="calibre13">ClassAction</code></span> from <span><code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">PluginASTAction</code></span></p></li>
<li class="calibre14"><p class="calibre15"><em class="calibre11">Lines 10-13</em>: We instantiate <span><code class="calibre13">ClassConsumer</code></span> and utilize <span><code class="calibre13">MethodCountThreshold</code></span>, which is derived from an optional plugin argument</p></li>
<li class="calibre14"><p class="calibre15"><em class="calibre11">Lines 15-25</em>: We process the optional <code class="calibre13">threshold </code>argument for our plugin</p></li>
</ul>
<pre class="source-code"><span>1 </span>namespace clangbook { 
 
<span>2 </span>namespace classchecker { 
 

<span>3 </span>class ClassAction : public clang::PluginASTAction { 
 

<span>4 </span>protected: 
 
<span>5 </span>  std::unique_ptr&lt;clang::ASTConsumer&gt; 
 

<span>6 </span>  CreateASTConsumer(clang::CompilerInstance &amp;CI, llvm::StringRef) { 
 

<span>7 </span>    return std::make_unique&lt;ClassConsumer&gt;(&amp;CI.getASTContext(), 
 

<span>8 </span>                                           MethodCountThreshold); 
 

<span>9 </span>  } 
 
<span>10 </span> 
 
<span>11 </span>  bool ParseArgs(const clang::CompilerInstance &amp;CI, 
 

<span>12 </span>                 const std::vector&lt;std::string&gt; &amp;args) { 
 

<span>13 </span>    for (const auto &amp;arg : args) { 
 

<span>14 </span>      if (arg.substr(0, 9) == "threshold") { 
 

<span>15 </span>        auto valueStr = arg.substr(10); // Get the substring after "threshold=" 
 

<span>16 </span>        MethodCountThreshold = std::stoi(valueStr); 
 

<span>17 </span>        return true; 
 
<span>18 </span>      } 
 
<span>19 </span>    } 
 
<span>20 </span>    return true; 
 

<span>21 </span>  } 
 
<span>22 </span>  ActionType getActionType() { return AddAfterMainAction; } 
 

<span>23 </span> 
 
<span>24 </span>private: 
 
<span>25 </span>  int MethodCountThreshold = 5; // default value 
 

<span>26 </span>}; 
 
<span>27 </span>} // namespace classchecker 
 

<span>28 </span>} // namespace clangbook</pre>
<p class="hidden"><a id="x1-89032r35" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-89033" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 4.35</strong>: Source code for ClassAction.hpp </p>
<p class="hidden">We are <a id="dx1-89034" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>almost done and <a id="dx1-89035" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>ready to initialize our plugin. <a id="x1-89036r275" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
</section>
<section id="plugin-code" class="level" data-number="1.4.6.6">
<h3 data-number="1.4.6.6" id="sigil_toc_id_76" class="likesectionhead"><span>4.6.6 </span> <a id="x1-900006" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Plugin code</h3>
<p class="hidden">Our plugin <a id="dx1-90001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>registration is carried out in the <code class="calibre13">ClassChecker.cpp </code>file, shown in <a href="#x1-90009r36" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 4.36</a>.</p>
<pre class="source-code"><span>1 </span>#include "clang/Frontend/FrontendPluginRegistry.h" 
 

<span>2 </span> 
 
<span>3 </span>#include "ClassAction.hpp" 
 
<span>4 </span> 
 
<span>5 </span>static clang::FrontendPluginRegistry::Add&lt;clangbook::classchecker::ClassAction&gt; 
 

<span>6 </span>    X("classchecker", "Checks the complexity of C++ classes");</pre>
<p class="hidden"><a id="x1-90009r36" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-90010" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 4.36</strong>: Source code for ClassChecker.cpp </p>
<p class="hidden">As we can observe, the majority of the initialization is hidden by helper classes, and we only need to pass our implementation to <span><code class="calibre13">lang</code><code class="calibre13">::</code><code class="calibre13">FrontendPluginRegistry</code><code class="calibre13">::</code><code class="calibre13">Add</code></span>.</p>
<p class="hidden">Now we are ready to build and test our clang plugin. <a id="x1-90011r278" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
</section>
<section id="building-and-running-plugin-code" class="level" data-number="1.4.6.7">
<h3 data-number="1.4.6.7" id="sigil_toc_id_77" class="likesectionhead"><span>4.6.7 </span> <a id="x1-910007" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Building and running plugin code</h3>
<p class="hidden">We need to specify a path to the installation folder for our LLVM project. The rest of the procedure is the <a id="dx1-91001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>standard one that we <a id="dx1-91002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>have previously used, see <a href="B19722_03.xhtml#x1-60132r11" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 3.11</a>:</p>
<pre id="verbatim-69" class="console">export LLVM_HOME=&lt;...&gt;/llvm-project/install
mkdir build
cd build
cmake -G Ninja -DCMAKE_BUILD_TYPE=Debug ..
ninja classchecker</pre>
<p class="hidden"><a id="x1-91003r37" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-91004" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 4.37</strong>: Configure and build commands for the Clang plugin </p>
<p class="hidden">The build artifacts will be located in the <code class="calibre13">build </code>folder. We can then run our plugin on a test file as follows, where <code class="calibre13">&lt;filepath&gt; </code>is the file we want to compile:</p>
<pre id="verbatim-70" class="console">$ &lt;...&gt;/llvm-project/install/bin/clang -fsyntax-only\
                 -fplugin=./build/libclasschecker.so\
                 &lt;filepath&gt;</pre>
<p class="hidden"><a id="x1-91005r38" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-91006" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 4.38</strong>: How to run the Clang plugin on a test file </p>
<p class="hidden">For example, if we use a test file named <code class="calibre13">test.cpp </code>that defines a class with three methods (see <a href="#x1-91014r39" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 4.39</a>), we will not receive any warnings.</p>
<pre class="source-code"><span>1 </span>class Simple { 
 
<span>2 </span>public: 
 
<span>3 </span>  void func1() {} 
 

<span>4 </span>  void func2() {} 
 
<span>5 </span>  void func3() {} 
 
<span>6 </span>};</pre>
<p class="hidden"><a id="x1-91014r39" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-91015" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 4.39</strong>: Test for the clang plugin: test.cpp </p>
<p class="hidden">However, if we <a id="dx1-91016" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>specify a smaller threshold, we will <a id="dx1-91017" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>receive a warning for the file:</p>
<pre id="verbatim-71" class="console">$ &lt;...&gt;/llvm-project/install/bin/clang -fsyntax-only \
                 -fplugin-arg-classchecker-threshold=2 \
                 -fplugin=./build/libclasschecker.so \
                 test.cpp
test.cpp:1:7: warning: class Simple is too complex: method count = 3
    1 | class Simple {
      |       ^
<span>1 </span> warning generated.</pre>
<p class="hidden"><a id="x1-91018r40" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-91019" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 4.40</strong>: Clang plugin run on test.cpp </p>
<p class="hidden">It’s now time to create a LIT test for our plugin. <a id="x1-91020r281" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
</section>
<section id="lit-tests-for-clang-plugin" class="level" data-number="1.4.6.8">
<h3 data-number="1.4.6.8" id="sigil_toc_id_78" class="likesectionhead"><span>4.6.8 </span> <a id="x1-920008" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>LIT tests for clang plugin</h3>
<p class="hidden">We’ll begin with a description of the project organization. We’ll adopt the common pattern used in the clang <a id="dx1-92001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>source code and place our <a id="dx1-92002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>tests in the <code class="calibre13">test</code> folder. This folder will contain the following files:</p>
<ul class="calibre6">
<li class="calibre14"><p class="calibre15"><code class="calibre13">lit.site.cfg.py.in </code>: This is the main configuration file, a CMake config file. It replaces patterns marked as ’@...@’ with corresponding values defined during the CMake configuration. Additionally, this file loads <code class="calibre13">lit.cfg.py </code>.</p></li>
<li class="calibre14"><p class="calibre15"><code class="calibre13">lit.cfg.py </code>: This serves as the primary configuration file for LIT tests.</p></li>
<li class="calibre14"><p class="calibre15"><code class="calibre13">simple</code><code class="calibre13">_test.cpp </code>: This is our LIT test file.</p></li>
</ul>
<p class="hidden">The basic workflow is as follows: CMake takes <code class="calibre13">lit.site.cfg.py.in </code>as a template and generates the corresponding <code class="calibre13">lit.site.cfg.py </code>in the <code class="calibre13">build/test</code> folder. This file is then utilized by LIT tests as a seed to execute the tests.</p>
<section id="lit-config-files" class="level" data-number="1.4.6.8.1">
<h4 data-number="1.4.6.8.1" class="sigil_not_in_toc"><a id="x1-930008" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>LIT config files</h4>
<p class="hidden">There are <a id="dx1-93001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>two configuration <a id="dx1-93002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>files for LIT tests. The first one is shown in <a href="#x1-93011r41" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 4.41</a>.</p>
<pre class="source-code"><span>1 </span>config.ClassComplexityChecker_obj_root = "@CMAKE_CURRENT_BINARY_DIR@" 
 

<span>2 </span>config.ClassComplexityChecker_src_root = "@CMAKE_CURRENT_SOURCE_DIR@" 
 

<span>3 </span>config.ClangBinary = "@LLVM_HOME@/bin/clang" 
 

<span>4 </span>config.FileCheck = "@FILECHECK_COMMAND@" 
 
<span>5 </span> 
 

<span>6 </span>lit_config.load_config( 
 
<span>7 </span>        config, os.path.join(config.ClassComplexityChecker_src_root, "test/lit.cfg.py"))</pre>
<p class="hidden"><a id="x1-93011r41" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-93012" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 4.41</strong>: lit.site.cfg.py.in file </p>
<p class="hidden">This file is a CMake template that will be converted into a Python script. The most crucial part is shown in <em class="calibre11">Lines 6-7</em>, where the main LIT config is loaded. It is sourced from the main source tree and is not copied to the <code class="calibre13">build</code> folder.</p>
<p class="hidden">The subsequent configuration is displayed in <a href="#x1-93025r42" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 4.42</a>. It is a Python script containing the primary configuration for LIT tests.</p>
<pre class="source-code"><span>1 </span># lit.cfg.py 
 
<span>2 </span>import lit.formats 
 
<span>3 </span> 
 

<span>4 </span>config.name = ’classchecker’ 
 
<span>5 </span>config.test_format = lit.formats.ShTest(True) 
 

<span>6 </span>config.suffixes = [’.cpp’] 
 
<span>7 </span>config.test_source_root = os.path.dirname(__file__) 
 

<span>8 </span> 
 
<span>9 </span>config.substitutions.append((’%clang-binary’, config.ClangBinary)) 
 

<span>10 </span>config.substitutions.append((’%path-to-plugin’, os.path.join(config.ClassComplexityChecker_obj_root, ’libclasschecker.so’))) 
 




<span>11 </span>config.substitutions.append((’%file-check-binary’, config.FileCheck))</pre>
<p class="hidden"><a id="x1-93025r42" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-93026" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 4.42</strong>: lit.cfg.py file </p>
<p class="hidden"><em class="calibre11">Lines 4-7 </em>define the fundamental configuration; for example, <em class="calibre11">Line 6 </em>determines which files should be utilized for tests. All <a id="dx1-93027" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>files with the ’.cpp’ extension in the <code class="calibre13">test </code>folder will be employed as LIT tests.</p>
<p class="hidden"><em class="calibre11">Lines 9-11 </em>detail the substitutions that <a id="dx1-93028" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>will be employed in the LIT tests. These include the path to the clang binary (<em class="calibre11">Line 9</em>), the path to the shared library with the plugin (<em class="calibre11">Line 10</em>), and the path to the <code class="calibre13">FileCheck </code>utility (<em class="calibre11">Line</em> <em class="calibre11">11</em>).</p>
<p class="hidden">We have defined only one basic LIT test, <code class="calibre13">simple</code><code class="calibre13">_test.cpp </code>, as shown in <a href="#x1-93048r43" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 4.43</a>.</p>
<pre class="source-code"><span>1 </span>// RUN: %clang-binary -fplugin=%path-to-plugin -fsyntax-only %s 2&gt;&amp;1 | %file-check-binary %s 
 

<span>2 </span> 
 
<span>3 </span>class Simple { 
 
<span>4 </span>public: 
 
<span>5 </span>  void func1() {} 
 

<span>6 </span>  void func2() {} 
 
<span>7 </span>}; 
 
<span>8 </span> 
 
<span>9 </span>// CHECK: :[[@LINE+1]]:{{[0-9]+}}: warning: class Complex is too complex: method count = 6 
 

<span>10 </span>class Complex { 
 
<span>11 </span>public: 
 
<span>12 </span>  void func1() {} 
 

<span>13 </span>  void func2() {} 
 
<span>14 </span>  void func3() {} 
 

<span>15 </span>  void func4() {} 
 
<span>16 </span>  void func5() {} 
 

<span>17 </span>  void func6() {} 
 
<span>18 </span>};</pre>
<p class="hidden"><a id="x1-93048r43" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-93049" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 4.43</strong>: simple_test.cpp file </p>
<p class="hidden">The use of substitutions <a id="dx1-93050" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>can be observed in <em class="calibre11">Line 1</em>, where <a id="dx1-93051" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>paths to the clang binary, the plugin shared library, and the <code class="calibre13">FileCheck </code>utility are referenced. Special patterns recognized by the utility are used in <em class="calibre11">Line</em> <em class="calibre11">9</em>.</p>
<p class="hidden">The final piece of the puzzle is the CMake configuration. This will set up the required variables for substitutions in <code class="calibre13">lit.site.cfg.py.in </code>and also define a custom target to run the LIT tests.</p>
</section>
<section id="cmake-configuration-for-lit-tests" class="level" data-number="1.4.6.8.2">
<h4 data-number="1.4.6.8.2" class="sigil_not_in_toc"><a id="x1-940008" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>CMake configuration for LIT tests</h4>
<p class="hidden">The <code class="calibre13">CMakeLists.txt </code>file requires <a id="dx1-94001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>some adjustments to support LIT tests. The necessary changes are displayed in <a href="#x1-94025r44" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 4.44</a>.</p>
<pre class="source-code"><span>31 </span>  find_program(LIT_COMMAND llvm-lit PATH ${LLVM_BUILD}/bin) 
 

<span>32 </span>  find_program(FILECHECK_COMMAND FileCheck ${LLVM_BUILD}/bin) 
 

<span>33 </span>  if(LIT_COMMAND AND FILECHECK_COMMAND) 
 

<span>34 </span>    message(STATUS "$LIT_COMMAND found: ${LIT_COMMAND}") 
 

<span>35 </span>    message(STATUS "$FILECHECK_COMMAND found: ${FILECHECK_COMMAND}") 
 

<span>36 </span> 
 
<span>37 </span>    # Point to our custom lit.cfg.py 
 

<span>38 </span>    set(LIT_CONFIG_FILE "${CMAKE_CURRENT_SOURCE_DIR}/test/lit.cfg.py") 
 

<span>39 </span> 
 
<span>40 </span>    # Configure lit.site.cfg.py using current settings 
 

<span>41 </span>    configure_file("${CMAKE_CURRENT_SOURCE_DIR}/test/lit.site.cfg.py.in" 
 

<span>42 </span>                   "${CMAKE_CURRENT_BINARY_DIR}/test/lit.site.cfg.py" 
 

<span>43 </span>                   @ONLY) 
 
<span>44 </span> 
 
<span>45 </span>    # Add a custom target to run tests with lit 
 

<span>46 </span>    add_custom_target(check-classchecker 
 

<span>47 </span>                      COMMAND ${LIT_COMMAND} -v ${CMAKE_CURRENT_BINARY_DIR}/test 
 

<span>48 </span>                      COMMENT "Running lit tests for classchecker clang plugin" 
 

<span>49 </span>                      USES_TERMINAL) 
 
<span>50 </span>  else() 
 

<span>51 </span>    message(FATAL_ERROR "It was not possible to find the LIT executables at ${LLVM_BUILD}/bin") 
 

<span>52 </span>  endif()</pre>
<p class="hidden"><a id="x1-94025r44" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-94026" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 4.44</strong>: LIT tests configuration at CMakeLists.txt </p>
<p class="hidden">In <em class="calibre11">Lines 31 and 32</em>, we search for the necessary utilities, <code class="calibre13">llvm-lit </code>and <code class="calibre13">FileCheck </code>. It’s worth noting that they rely on the <span>$</span><code class="calibre13">LLVM</code><code class="calibre13">_BUILD </code>environment variable, which we also verify in <em class="calibre11">Line 12 </em>of the config (see <a href="#x1-86023r32" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 4.32</a>). The steps in <em class="calibre11">Lines 41-43 </em>are essential for generating <code class="calibre13">lit.site.cfg.py </code>from the <a id="dx1-94027" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>provided template file, <code class="calibre13">lit.site.cfg.py.in </code>. Lastly, we establish a custom target to execute the LIT tests in <em class="calibre11">Lines 46-49</em>.</p>
<p class="hidden">Now we are ready to start the LIT tests.</p>
</section>
<section id="running-lit-tests" class="level" data-number="1.4.6.8.3">
<h4 data-number="1.4.6.8.3" class="sigil_not_in_toc"><a id="x1-950008" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Running LIT tests</h4>
<p class="hidden">To initiate the LIT tests, we must set an environment variable that points to the build folder, compile the project, and then <a id="dx1-95001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>execute the custom target, <code class="calibre13">check-classchecker</code>. Here’s how this can be done:</p>
<pre id="verbatim-72" class="console">export LLVM_BUILD=&lt;...&gt;/llvm-project/build
export LLVM_HOME=&lt;...&gt;/llvm-project/install
rm -rf build; mkdir build; cd build
cmake -G Ninja -DCMAKE_BUILD_TYPE=Debug ..
ninja classchecker
ninja check-classchecker</pre>
<p class="hidden"><a id="x1-95002r45" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-95003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 4.45</strong>: Configure, build and check commands for the Clang plugin </p>
<p class="hidden">Upon executing these commands, you may observe the following output:</p>
<pre id="verbatim-73" class="console">...
[2/2] Linking CXX shared module libclasschecker.so
[0/1] Running lit tests for classchecker clang plugin
-- Testing: 1 tests, 1 workers --
PASS: classchecker :: simple_test.cpp (1 of 1)

Testing Time: 0.12s
Passed: 1</pre>
<p class="hidden"><a id="x1-95004r46" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-95005" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 4.46</strong>: LIT test execution </p>
<p class="hidden">With this, we conclude our first comprehensive project, which encompasses a practical clang plugin that can be tailored via supplemental plugin arguments. Additionally, it includes the respective tests that can be executed to verify its functionality. <a id="x1-95006r263" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
</section>
</section>
</section>
<section id="summary-3" class="level" data-number="1.4.7">
<h2 data-number="1.4.7" id="sigil_toc_id_79" class="likechapterhead"><span>4.7 </span> <a id="x1-960007" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Summary</h2>
<p class="hidden">In this chapter, we became familiar with the basic classes from the LLVM ADT library. We gained knowledge of Clang diagnostics and the test frameworks used in LLVM for various types of testing. Using this knowledge, we created a simple Clang plugin that detects complex classes and issues a warning about their complexity.</p>
<p class="hidden">The chapter concludes the first part of the book, where we gained basic knowledge of the Clang compiler frontend. We are now prepared to explore various tools built on the foundation of Clang libraries. We will begin with Clang-Tidy, a powerful linter framework used to detect various issues in C++ code. <a id="x1-96001r301" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
</section>
<section id="further-reading-3" class="level" data-number="1.4.8">
<h2 data-number="1.4.8" id="sigil_toc_id_80" class="likechapterhead"><span>4.8 </span> <a id="x1-970008" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Further reading</h2>
<ul class="calibre6">
<li class="calibre14"><p class="calibre15">LLVM Coding Standards: <a href="https://llvm.org/docs/CodingStandards.html" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">https://llvm.org/docs/CodingStandards.html</a></p></li>
<li class="calibre14"><p class="calibre15">LLVM Programmer’s Manual: <a href="https://llvm.org/docs/ProgrammersManual.html" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">https://llvm.org/docs/ProgrammersManual.html</a></p></li>
<li class="calibre14"><p class="calibre15">“Clang” CFE Internals Manual: <a href="https://clang.llvm.org/docs/InternalsManual.html" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">https://clang.llvm.org/docs/InternalsManual.html</a></p></li>
<li class="calibre14"><p class="calibre15">How to set up LLVM-style RTTI for your class hierarchy: <a href="https://llvm.org/docs/HowToSetUpLLVMStyleRTTI.html" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">https://llvm.org/docs/HowToSetUpLLVMStyleRTTI.html</a></p></li>
<li class="calibre14"><p class="calibre15">LIT - LLVM Integrated Tester: <a href="https://llvm.org/docs/CommandGuide/lit.html" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">https://llvm.org/docs/CommandGuide/lit.html</a></p></li>
</ul>
<p class="hidden"><a id="x1-97001r14" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
</section>
</section>
</div>
</div>
</body></html>