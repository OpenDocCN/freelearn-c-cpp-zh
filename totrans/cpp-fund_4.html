<html><head></head><body>
		<div class="Content" id="_idContainer037">
			<h1 id="_idParaDest-119"><em class="italics"><a id="_idTextAnchor127"/>Chapter 4</em></h1>
		</div>
		<div class="Content" id="_idContainer038">
			<h1 id="_idParaDest-120"><a id="_idTextAnchor128"/>Generic Programming and Templates</h1>
		</div>
		<div class="Content" id="_idContainer039">
			<h2>Lesson Objectives</h2>
			<p>By the end of this chapter, you will be able to:</p>
			<ul>
				<li class="bullets">Understand how templates work and when to use them</li>
				<li class="bullets">Identify and implement templated functions</li>
				<li class="bullets">Implement tem<a id="_idTextAnchor129"/>plate classes</li>
				<li class="bullets">Write code that works for multiple types</li>
			</ul>
			<p>In this chapter, you will learn how to use templates effectively in your program.</p>
		</div>
		<div class="Content" id="_idContainer042">
			<h2 id="_idParaDest-121"><a id="_idTextAnchor130"/>Introduction</h2>
			<p>When programming, it is common to face problems that are recurring for different types of objects, such as storing a list of objects, or searching elements in a list, or finding the maximum between two elements.</p>
			<p>Let's say that in our program we want to be able to find the maximum between two elements, either integers or doubles. With the features we have learned so far, we could write the following code:</p>
			<p class="snippet">int max(int a, int b) {</p>
			<p class="snippet">  if ( a &gt; b) return a;</p>
			<p class="snippet">  else return b;</p>
			<p class="snippet">}</p>
			<p class="snippet">double max(double a, double b) {</p>
			<p class="snippet">  if ( a&gt; b) return a;</p>
			<p class="snippet">  else return b;</p>
			<p class="snippet">}</p>
			<p>In the previous code, the two functions are identical except for the <em class="italics">types</em> of the parameters and the <em class="italics">return type</em>. Ideally, we would like to write these kind of operations only once and reuse them in the entire program.</p>
			<p>Moreover, our <strong class="inline">max()</strong> function can only be called with types for which an overload exists: <strong class="inline">int</strong> and <strong class="inline">double</strong> in this case. If we wanted it to work with any numerical type, we would need to write an <strong class="bold">overload</strong> for each of the numerical types: we would need to know in advance about all the types that will be used to call it, especially when the function is part of a library that is intended to be used by other developers, as it becomes impossible for us to know the types that will be used when calling the function.</p>
			<p>We can see that there is nothing specific to integers being required to find the maximum elements; if the elements implement <strong class="inline">operator&lt;</strong>, then it is possible to find the greater of the two numbers, and the algorithm does not change. In these situations, C++ offers an effective tool—<strong class="bold">templates</strong>.</p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor131"/>Templates</h2>
			<p>Templates are a way to define functions or classes that can work for many different types, while still writing them only once.</p>
			<p>They do so by having special kinds of parameters—<strong class="bold">type parameters</strong>.</p>
			<p>When writing the template code, we can use this type parameter as if it were a real type, such as <strong class="inline">int</strong> or <strong class="inline">string</strong>.</p>
			<p>When the templated function is called or the template class is instantiated, the type parameter is substituted with the real type that's used by the calling code.</p>
			<p>Now let's look at an example of a template in C++ code:</p>
			<p class="snippet">template&lt;typename T&gt;</p>
			<p class="snippet">T max(T a, T b) {</p>
			<p class="snippet">  if(a&gt;b) {</p>
			<p class="snippet">    return a;</p>
			<p class="snippet">  } else {</p>
			<p class="snippet">    return b;</p>
			<p class="snippet">  }</p>
			<p class="snippet">}</p>
			<p>A template always starts with the <strong class="inline">template</strong> keyword, followed by the list of template parameters enclosed in <em class="italics">angle</em> brackets.</p>
			<p>A template parameter list is a list of comma-separated parameters. In this case, we only have one—<strong class="inline">typename T</strong>.</p>
			<p>The <strong class="inline">typename</strong> keyword tells the template that we are writing a templated function that uses a generic type, which we are going to name <strong class="inline">T</strong>.</p>
			<h4>Note</h4>
			<p class="callout">You can also use the <strong class="inline">class</strong> keyword in place of <strong class="inline">typename</strong>, since there is no difference between them.</p>
			<p>Then, the definition of the function follows. In the function definition, we can use the name <strong class="inline">T</strong> when we want to refer to the generic type.</p>
			<p>To call the template, we specify the name of the template, followed by the list of types we want to use as <em class="italics">type arguments</em>, enclosed in angle brackets:</p>
			<p class="snippet">max&lt;int&gt;(10, 15);</p>
			<p>This calls the templated function <strong class="inline">max</strong>, specifying <strong class="inline">int</strong> as the type parameter. We say that we instantiated the templated function <strong class="inline">max</strong> with type <strong class="inline">int</strong>, and then called that instance.</p>
			<p>We do not always need to specify the type parameters of a template; the compiler can deduce them from the calling code. A later section will describe this feature.</p>
			<p>Because of how powerful templates are, the big part of the C++ standard library is based on templates, as we will see in <em class="italics">Chapter 5</em>, <em class="italics">Standard Library Containers and Algorithms</em>.</p>
			<p>Now we'll explore in depth what happens when we compile the code that contains templates.</p>
			<h3 id="_idParaDest-123"><a id="_idTextAnchor132"/>Compiling the Template Code</h3>
			<p>Similar to functions and classes, a template needs to be <em class="italics">declared</em> before being used.</p>
			<p>When the compiler first encounters a template definition in the program, it parses it and performs only <em class="italics">part</em> of the checks it usually does on the rest of the code.</p>
			<p>This happens because the compiler does not know which type is going to be used with the template when it parses it, since the types are parameters themselves. This prevents the compiler from performing checks that involve the parameter types, or anything that depends on them.</p>
			<p>Because of this, you get notified of some errors in the template only when you instantiate it.</p>
			<p>Once we define a template, we can instantiate it in our code.</p>
			<p>When a template is instantiated, the compiler looks at the definition of the template and uses it to generate a new instance of the code, where all the references to the type parameters are replaced by the types that are provided when instantiating it.</p>
			<p>For example: when we call <strong class="inline">max&lt;int&gt;(1,2)</strong>, the compiler looks at the template definition we specified earlier and generates code as if we wrote the following:</p>
			<p class="snippet">int max(int a, int b) {</p>
			<p class="snippet">  if(a&gt;b) {</p>
			<p class="snippet">    return a;</p>
			<p class="snippet">  } else {</p>
			<p class="snippet">    return b;</p>
			<p class="snippet">  }</p>
			<p class="snippet">}</p>
			<h4>Note</h4>
			<p class="callout">Since the compiler generates the code from the template definition, it means that the full definitions need to be visible to the calling code, not only the declaration, as was the case for functions and classes.</p>
			<p>The template can still be forward declared, but the compiler must also see the definition. Because of this, when writing templates that should be accessed by several files, both the definition and the declaration of the templates must be in the <strong class="bold">header</strong> file.</p>
			<p>This restriction does not apply if the template is used only in one file.</p>
			<h3 id="_idParaDest-124"><a id="_idTextAnchor133"/>Exercise 11: Finding the Bank Account of the User with the Highest Balance</h3>
			<p>Write a template function that accepts details of two bank accounts (of the same type) and returns the balance of the bank account with the highest balance.</p>
			<p>For this exercise, perform the following steps:</p>
			<ol>
				<li>Let's create two structs named <strong class="inline">EUBankAccount</strong> and <strong class="inline">UKBankAccount</strong> to represent the <strong class="bold">European Union</strong> bank account and the <strong class="bold">United Kingdom</strong> bank account with the required basic information, as shown in the following code:<p class="snippet">#include &lt;string&gt;</p><p class="snippet">struct EUBankAccount {</p><p class="snippet">   std::string IBAN;</p><p class="snippet">   int amount;</p><p class="snippet">};</p><p class="snippet">struct UKBankAccount {</p><p class="snippet">   std::string sortNumber;</p><p class="snippet">   std::string accountNumber;</p><p class="snippet">   int amount;</p><p class="snippet">};</p></li>
				<li>The template function will have to compare the amount of the bank accounts. We want to work with different bank account types, so we need to use a template:<p class="snippet">template&lt;typename BankAccount&gt;</p><p class="snippet">int getMaxAmount(const BankAccount&amp; acc1, const BankAccount&amp; acc2) {</p><p class="snippet">    // All bank accounts have an 'amount' field, so we can access it safely</p><p class="snippet">    if (acc1.amount &gt; acc2.amount) {</p><p class="snippet">        return acc1.amount;</p><p class="snippet">    } else {</p><p class="snippet">        return acc2.amount;</p><p class="snippet">    }</p><p class="snippet">}</p></li>
				<li>Now, in the <strong class="inline">main</strong> function, call both the structs and the template function, as shown here:<p class="snippet">int main() {</p><p class="snippet">    EUBankAccount euAccount1{"IBAN1", 1000};</p><p class="snippet">    EUBankAccount euAccount2{"IBAN2", 2000};</p><p class="snippet">    std::cout &lt;&lt; "The greater amount between EU accounts is " &lt;&lt; getMaxAmount(euAccount1, euAccount2) &lt;&lt; std::endl;</p><p class="snippet">    UKBankAccount ukAccount1{"SORT1", "ACCOUNT_NUM1", 2500};</p><p class="snippet">    UKBankAccount ukAccount2{"SORT2", "ACCOUNT_NUM2", 1500};</p><p class="snippet">    std::cout &lt;&lt; "The greater amount between UK accounts is " &lt;&lt; getMaxAmount(ukAccount1, ukAccount2) &lt;&lt; std::endl;</p><p class="snippet">}</p><p>The output is as follows:</p><p class="snippet">The greater amount between EU accounts is 2000</p><p class="snippet">The greater amount between UK accounts is 2500</p></li>
			</ol>
			<h3 id="_idParaDest-125"><a id="_idTextAnchor134"/>Using Template Type Parameters</h3>
			<p>As we saw earlier, the compiler uses the template as a guide to generate a template instance with some concrete type when the template is used.</p>
			<p>This means that we can use the type as a <em class="italics">concrete</em> type, including applying type modifiers to it.</p>
			<p>We saw earlier, a type can be modified by making it constant with the <strong class="inline">const</strong> modifier, and we can also take a reference to an object of a specific type by using the <em class="italics">reference</em> modifier:</p>
			<p class="snippet">template&lt;typename T&gt;</p>
			<p class="snippet">T createFrom(const T&amp; other) {</p>
			<p class="snippet">    return T(other);</p>
			<p class="snippet">}</p>
			<p>Here, we can see a <strong class="inline">template</strong> function that creates a new object from a different instance of an object.</p>
			<p>Since the function does not modify the original type, the function would like to accept it as a <strong class="inline">const</strong> reference.</p>
			<p>Since we are declaring the type <strong class="inline">T</strong> in the template, in the function definition we can use the modifiers on the type to accept the parameter in the way we deem more appropriate.</p>
			<p>Notice that we used the type two times: once with some modifiers and once with no modifiers.</p>
			<p>This gives a lot of flexibility when using templates and writing functions, as we can liberally modify the type to suit our needs.</p>
			<p>Similarly, we have a lot of freedom in where we can use the template arguments.</p>
			<p>Let's see two templates with a multiple template type argument:</p>
			<p class="snippet">template&lt;typename A, typename B&gt;</p>
			<p class="snippet">A transform(const B&amp; b) {</p>
			<p class="snippet">    return A(b);</p>
			<p class="snippet">}</p>
			<p class="snippet">template&lt;typename A, typename B&gt;</p>
			<p class="snippet">A createFrom() {</p>
			<p class="snippet">  B factory;</p>
			<p class="snippet">  return factory.getA();</p>
			<p class="snippet">}</p>
			<p>We can see that we can use the template argument in the function parameter, in the return type, or instantiate it directly in the function body.</p>
			<p><a id="_idTextAnchor135"/>Also, the order in which the template arguments are declared does not impact where and how the template parameters can be used.</p>
			<h3 id="_idParaDest-126"><a id="_idTextAnchor136"/>Requirements of Template Parameter Types</h3>
			<p>In the code snippet at the beginning of this chapter, we wrote some templates that accept any kind of type. In reality, our code does not work for any kind of type; for example: <strong class="inline">max()</strong> requires the types to support the <strong class="inline">&lt;</strong> operation.</p>
			<p>We can see that there were some requirements on the type.</p>
			<p>Let's try to understand what having a requirement on a type means when using templates in C++ code. We will do so by using the following template code:</p>
			<p class="snippet">template&lt;typename Container, typename User&gt;</p>
			<p class="snippet">void populateAccountCollection (Container&amp; container, const User&amp; user) {</p>
			<p class="snippet">  container.push_back(user.getAccount());</p>
			<p class="snippet">}</p>
			<p>We can then write the following function as main and compile the program:</p>
			<p class="snippet">int main() {</p>
			<p class="snippet">  // do nothing</p>
			<p class="snippet">}</p>
			<p>When we compile this program, the compilation ends successfully without any error.</p>
			<p>Let's say we change the <strong class="inline">main</strong> function to be the following:</p>
			<p class="snippet">int main() {</p>
			<p class="snippet">  std::string accounts;</p>
			<p class="snippet">  int user;</p>
			<p class="snippet">  populateAccountCollection(accounts, user);</p>
			<p class="snippet">}</p>
			<h4>Note</h4>
			<p class="callout">We did not specify the type to the template. We will see later in this chapter when the compiler can automatically deduce the types from the call.</p>
			<p>The compiler will give us an error when we compile it:</p>
			<p class="snippet">error: request for member 'getAccount' in 'user', which is of non-class type 'const int'</p>
			<p>Note how the error appeared when we used the template function, and that it was not detected before.</p>
			<p>The error is telling us that we tried to call the <strong class="inline">getAccount</strong> method on an integer, which does not have such a method.</p>
			<p>Why didn't the compiler tell us this when we were writing the template?</p>
			<p>The reason for this is that the compiler does not know what type <strong class="inline">User</strong> will be; therefore, it cannot tell whether the <strong class="inline">getAccount</strong> method will exist or not.</p>
			<p>When we tried to use the template, we tried to generate the code with two specific types, and the compiler checked that these two types were suitable for the template; they were not, and the compiler gave us an error.</p>
			<p>The types we used were not satisfying the requirements of the template types.</p>
			<p>Unfortunately, there is no easy way in the current C++ standard, even the most recent C++17, to specify the requirements of templates in the code—for that, we need good documentation.</p>
			<p>The template has two type arguments, so we can look at the requirements for each type:</p>
			<ul>
				<li><strong class="bold">User requirements</strong>: The <strong class="inline">User</strong> object must have a <strong class="inline">getAccount</strong> method</li>
				<li><strong class="bold">Container requirements</strong>: The <strong class="inline">Container</strong> object must have a <strong class="inline">push_back</strong> method</li>
			</ul>
			<p>The compiler finds the first problem when we call the <strong class="inline">getAccount()</strong> function and it notifies us.</p>
			<p>To solve this issue, let's declare a suitable class, as shown here:</p>
			<p class="snippet">struct Account {</p>
			<p class="snippet">  // Some fields</p>
			<p class="snippet">};</p>
			<p class="snippet">class User {</p>
			<p class="snippet">public:</p>
			<p class="snippet">  Account getAccount() const{ </p>
			<p class="snippet">    return Account();</p>
			<p class="snippet"> }</p>
			<p class="snippet">};</p>
			<p>Now, let's call the template with the help of the following code:</p>
			<p class="snippet">int main() {</p>
			<p class="snippet">  std::string accounts;</p>
			<p class="snippet">  User user;</p>
			<p class="snippet">  populateAccountCollection(accounts, user);</p>
			<p class="snippet">}</p>
			<p>We still get an error:</p>
			<p class="snippet">error: no matching function for call to 'std::__cxx11::basic_string&lt;char&gt;::push_back(Account)'</p>
			<p>This time, the error message is less clear, but the compiler is telling us that there is no method called <strong class="inline">push_back</strong> that accepts an account in <strong class="inline">basic_string&lt;char&gt;</strong> (<strong class="inline">std::string</strong> is an alias for it). The reason for this is that <strong class="inline">std::string</strong> has a method called <strong class="inline">push_back</strong>, but it only accepts characters. Since we are calling it with an <strong class="inline">Account</strong>, it fails.</p>
			<p>We need to be more precise in the requirements for our template:</p>
			<ul>
				<li><strong class="bold">User requirements</strong>: The user object must have a <strong class="inline">getAccount</strong> method that returns an object</li>
				<li><strong class="bold">Container requirements</strong>: The container object must have a <strong class="inline">push_back</strong> method that accepts objects of the type returned by <strong class="inline">getAccount</strong> on the user<h4>Note</h4><p class="callout">The <strong class="inline">std::vector</strong> type in the C++ standard library allows to store sequences of elements of an arbitrary type. <strong class="inline">push_back </strong>is a method that's used for adding a new element at the end of the vector. We will see more about vectors in <em class="italics">Chapter 5</em>, <em class="italics">Standard Library Containers and Algorithms</em>.</p></li>
			</ul>
			<p>We now change the calling code to consider all the requirements:</p>
			<p class="snippet">#include &lt;vector&gt;</p>
			<p class="snippet">int main(){</p>
			<p class="snippet">   std::vector&lt;Account&gt; accounts;</p>
			<p class="snippet">   User user;</p>
			<p class="snippet">   populateAccountCollection(accounts, user);</p>
			<p class="snippet">}</p>
			<p>This time, the code compiles correctly!</p>
			<p>This shows us how the compiler checks most of the errors, but only when we instantiate the template.</p>
			<p>It is also very important to clearly document the requirements of the template so that the user does not have to read complicated error messages to understand which requirement is not respected.</p>
			<h4>Note</h4>
			<p class="callout">To make it easy to use our templates with many types, we should try to set the least requirements we can on the types.</p>
			<h2 id="_idParaDest-127"><a id="_idTextAnchor137"/>Defining Function and Class Templates</h2>
			<p>In the previous section, we saw the advantages of templates in writing abstractions. In this section, we are going to explore how we can effectively use templates in our code to create <strong class="bold">templated functions</strong> and <strong class="bold">templated classes</strong>.</p>
			<h3 id="_idParaDest-128"><a id="_idTextAnchor138"/>Function Template</h3>
			<p><a id="_idTextAnchor139"/>In the previous section, we learned how function templates are written.</p>
			<p>In this section, we will learn about the two features that were introduced by C++11 that make it easier to write template functions. These two functions are trailing return types and <strong class="inline">decltype</strong>.</p>
			<p>Let's start with the <strong class="inline">decltype</strong>. The <strong class="inline">decltype</strong> is a keyword that accepts an expression and returns the type of that expression. Let's examine the following code:</p>
			<p class="snippet">int x;</p>
			<p class="snippet">decltype(x) y;</p>
			<p>In the previous code, <strong class="inline">y</strong> is declared as an integer, because we are using the type of the expression <strong class="inline">x</strong>, which is <strong class="inline">int</strong>.</p>
			<p>Any expression can be used inside <strong class="inline">decltype</strong>, even complex ones, for example:</p>
			<p class="snippet">User user;</p>
			<p class="snippet">decltype(user.getAccount()) account;</p>
			<p>Let's look at the second feature—<strong class="bold">trailing return types</strong>.</p>
			<p>We saw that a function definition starts with the return type, followed by the name of the function and then the parameters. For example:</p>
			<p class="snippet">int max(int a, int b);</p>
			<p>Starting from C++11, it is possible to use a trailing return type: specifying the return type at the end of the function signature. The syntax to declare a function with a trailing return type is to use the keyword <strong class="inline">auto</strong>, followed by the name of the function and the parameters, and then by an <em class="italics">arrow</em> and the <em class="italics">return type</em>.</p>
			<p>The following is an example of a trailing return type:</p>
			<p class="snippet">auto max(int a, int b) -&gt; int;</p>
			<p>This is not beneficial when writing regular functions, but it becomes useful when writing templates and when combined with <strong class="inline">decltype</strong>.</p>
			<p>The reason for this is that <strong class="inline">decltype</strong> has access to the variables defined in the parameters of the function, and the return type can be computed from them:</p>
			<p class="snippet">template&lt;typename User&gt;</p>
			<p class="snippet">auto getAccount(User user) -&gt; decltype(user.getAccount());</p>
			<p>This is an example of a <strong class="inline">forward declaration</strong> of a function template.</p>
			<h4>Note</h4>
			<p class="callout">When the user wants to provide a definition, it needs to provide the same template declaration, followed by the body of the function.</p>
			<p>Without the trailing return type, we would have to know what the type returned by <strong class="inline">user.getAccount()</strong> is to use it as the return type of the <strong class="inline">getAccount()</strong> function. The return type of <strong class="inline">user.getAccount()</strong> can be different depending on the type of the template parameter <strong class="inline">User</strong>, which in turn means that the return type of the <strong class="inline">getAccount</strong> function could change depending on the <strong class="inline">User</strong> type. With the trailing return type, we don't need to know what type is returned by <strong class="inline">user.getAccount()</strong>, as it is determined automatically. Even better, when different types are used in our function or a user changes the return type of the <strong class="inline">getAccount</strong> method in one of the types that's used to instantiate the template, our code will handle it automatically.</p>
			<p>More recently, C++14 introduced the ability to simply specify <strong class="inline">auto</strong> in the function declaration, without the need for the trailing return type:</p>
			<p class="snippet">auto max(int a, int b)</p>
			<p>The return type is automatically deduced by the compiler, and to do so, the compiler needs to see the definition of the function—we cannot forward declare functions that return <strong class="inline">auto</strong>.</p>
			<p>Additionally, <strong class="inline">auto</strong> always returns a value—it never returns a reference: this is something to be aware of when using it, as we could unintentionally create copies of the returned value.</p>
			<p>One last useful feature of function templates is how to reference them without calling them.</p>
			<p>Up until now, we have only seen how to call the function templates, but C++ allows us to pass functions as parameters as well. For example: when sorting a container, a custom comparison function can be provided.</p>
			<p>We know that a template is just a blueprint for a function, and the real function is going to be created only when the template is instantiated. C++ allows us to instantiate the template function even without calling it. We can do this by specifying the name of the template function, followed by the template parameters, without adding the parameters for the call.</p>
			<p>Let's understand the following example:</p>
			<p class="snippet">template&lt;typename T&gt;</p>
			<p class="snippet">void sort(std::array&lt;T, 5&gt; array, bool (*function)(const T&amp;, const T&amp;));</p>
			<p>The <strong class="inline">sort</strong> is a function that takes an array of five elements and a pointer to the function to compare two elements:</p>
			<p class="snippet">template&lt;typename T&gt;</p>
			<p class="snippet">bool less(const T&amp; a, const T&amp; b) {</p>
			<p class="snippet">  return a &lt; b;</p>
			<p class="snippet">}</p>
			<p>To call <strong class="inline">sort</strong> with an instance of the <strong class="inline">less</strong> template for integers, we would write the following code:</p>
			<p class="snippet">int main() {</p>
			<p class="snippet">  std::array&lt;int, 5&gt; array = {4,3,5,1,2};</p>
			<p class="snippet">  sort(array, &amp;less&lt;int&gt;);</p>
			<p class="snippet">}</p>
			<p>Here, we take a pointer to the instance of <strong class="inline">less</strong> for integers. This is particularly useful when using the Standard Template Library, which we will see in <em class="italics">Chapter 5</em>, <em class="italics">Standard Library Containers and Algorithms</em>.</p>
			<h3 id="_idParaDest-129"><a id="_idTextAnchor140"/>Class Templates</h3>
			<p>In the previous section, we learned how to write template functions. The syntax for class templates is equivalent to the one for functions: first, there is the template declaration, followed by the declaration of the class:</p>
			<p class="snippet">template&lt;typename T&gt;</p>
			<p class="snippet">class MyArray {</p>
			<p class="snippet">  // As usual</p>
			<p class="snippet">};</p>
			<p>And equivalently to functions, to instantiate a class template, we use the angle brackets containing a list of types:</p>
			<p class="snippet">MyArray&lt;int&gt; array;</p>
			<p>Like functions, class template code gets generated when the template is instantiated, and the same restrictions apply: the definition needs to be available to the compiler and some of the error-checking is executed when the template is instantiated.</p>
			<p>As we saw in <em class="italics">Lesson 3</em>, <em class="italics">Classes</em>, while writing the body of a class, the name of the class is sometimes used with a special meaning. For example, the name of the constructor functions must match the name of the class.</p>
			<p>In the same way, when writing a class template, the name of the class can be used directly, and it will refer to the specific template instance being created:</p>
			<p class="snippet">template&lt;typename T&gt;</p>
			<p class="snippet">class MyArray {</p>
			<p class="snippet">  // There is no need to use MyArray&lt;T&gt; to refer to the class, MyArray automatically refers to the current template instantiation</p>
			<p class="snippet">  MyArray();</p>
			<p class="snippet">  // Define the constructor for the current template T</p>
			<p class="snippet">  MyArray&lt;T&gt;();</p>
			<p class="snippet">  // This is not a valid constructor.</p>
			<p class="snippet">};</p>
			<p>This makes writing template classes a similar experience to writing regular classes, with the added benefit of being able to use the template parameters to make the class work with generic types.</p>
			<p>Like regular classes, template classes can have fields and methods. The field can depend on the type declared by the template. Let's review the following code example:</p>
			<p class="snippet">template&lt;typename T&gt;</p>
			<p class="snippet">class MyArray {</p>
			<p class="snippet">  T[] internal_array;</p>
			<p class="snippet">};</p>
			<p>Also when writing methods, the class can use the type parameter of the class:</p>
			<p class="snippet">template&lt;typename T&gt;</p>
			<p class="snippet">class MyArray {</p>
			<p class="snippet">  void push_back(const T&amp; element);</p>
			<p class="snippet">};</p>
			<p>Classes can also have templated methods. Templated methods are similar to template functions, but they can access the class instance data.</p>
			<p>Let's review the following example:</p>
			<p class="snippet">template&lt;typename T&gt;</p>
			<p class="snippet">class MyArray {</p>
			<p class="snippet">  template&lt;typename Comparator&gt;</p>
			<p class="snippet">  void sort (const Comparator &amp; element);</p>
			<p class="snippet">};</p>
			<p>The <strong class="inline">sort</strong> method will accept any type and will compile if the type satisfies all the requirements that the method imposes on the type.</p>
			<p>To call the method, the syntax follows the one for calling functions:</p>
			<p class="snippet">MyArray&lt;int&gt; array;</p>
			<p class="snippet">MyComparator comparator;</p>
			<p class="snippet">array.sort&lt;MyComparator&gt;(comparator);</p>
			<h4>Note</h4>
			<p class="callout">The method template can be part of a non-template class.</p>
			<p>In these situations, the compiler can sometimes deduce the type of the parameter, where the user does not have to specify it.</p>
			<p>If a method is only declared in the class, as we did in the example with <strong class="inline">sort</strong>, the user can later implement it by specifying the template types of both the class and the method:</p>
			<p class="snippet">template&lt;typename T&gt; // template of the class</p>
			<p class="snippet">template&lt;typename Comparator&gt; // template of the method</p>
			<p class="snippet">MyArray&lt;T&gt;::sort(const Comparator&amp; element) {</p>
			<p class="snippet">  // implementation</p>
			<p class="snippet">}</p>
			<p>The name of the types does not have to match, but it is a good practice to be consistent with the names.</p>
			<p>Similar to methods, the class can also have templated overloaded operators. The approach is identical to writing the operator overloads for regular classes, with the difference that the declaration of a template must precede the overload declaration like we saw for method templates.</p>
			<p>Finally, something to be aware of is how static methods and static fields interact with the class template.</p>
			<p>We need to remember that the template is a guide on the code that will be generated for the specific types. This means that when a template class declares a static member, the member is shared only between the instantiations of the template with the same template parameters:</p>
			<p class="snippet">template&lt;typename T&gt;</p>
			<p class="snippet">class MyArray {</p>
			<p class="snippet">  const Static int element_size = sizeof(T);</p>
			<p class="snippet">};</p>
			<p class="snippet">MyArray&lt;int&gt; int_array1;</p>
			<p class="snippet">MyArray&lt;int&gt; int_array2;</p>
			<p class="snippet">MyArray&lt;std::string&gt; string_array;</p>
			<p><strong class="inline">int_array1</strong> and <strong class="inline">int_array2</strong> will share the same static variable, <strong class="inline">element_size</strong>, since they are both of the same type: <strong class="inline">MyArray&lt;int&gt;</strong>. On the other hand, <strong class="inline">string_array</strong> has a different one, because its class type is <strong class="inline">MyArray&lt;std::string&gt;</strong>. <strong class="inline">MyArray&lt;int&gt;</strong> and <strong class="inline">MyArray&lt;std::string&gt;</strong>, even if generated from the same class template, are two different classes, and thus do not share static fields.</p>
			<h3 id="_idParaDest-130"><a id="_idTextAnchor141"/>Dependent Types</h3>
			<p>It's fairly common, especially for code that interacts with templates, to define some public aliases to types.</p>
			<p>A typical example would be the <strong class="inline">value_type</strong> <strong class="inline">type alias</strong> for containers, which specifies the type contained:</p>
			<p class="snippet">template&lt;typename T&gt;</p>
			<p class="snippet">class MyArray {</p>
			<p class="snippet">public:</p>
			<p class="snippet">  using value_type = T;</p>
			<p class="snippet">};</p>
			<p>Why is this being done?</p>
			<p>The reason for this is that if we are accepting a generic array as a template parameter, we might want to find out the contained type.</p>
			<p>If we were accepting a specific type, this problem would not arise. Since we know the type of vector, we could write the following code:</p>
			<p class="snippet">void createOneAndAppend(std::vector&lt;int&gt;&amp; container) {</p>
			<p class="snippet">  int new_element{}; // We know the vector contains int</p>
			<p class="snippet">  container.push_back(new_element);</p>
			<p class="snippet">}</p>
			<p>But how can we do this when we accept any container that provides the <strong class="inline">push_back</strong> method?</p>
			<p class="snippet">template&lt;typename Container&gt;</p>
			<p class="snippet">void createOneAndAppend(Container&amp; container) {</p>
			<p class="snippet">  // what type should new_element be?</p>
			<p class="snippet">  container.push_back(new_element);</p>
			<p class="snippet">}</p>
			<p>We can access the <strong class="inline">type alias</strong> declared inside the container, which specifies which kind of values it contains, and we use it to instantiate a new value:</p>
			<p class="snippet">template&lt;typename Container&gt;</p>
			<p class="snippet">void createOneAndAppend(Container&amp; container) {</p>
			<p class="snippet">  Container::value_type new_element;</p>
			<p class="snippet">  container.push_back(new_element);</p>
			<p class="snippet">}</p>
			<p>This code, unfortunately, does not compile.</p>
			<p>The reason for this is that <strong class="inline">value_type</strong> is a <strong class="keyword">dependent type</strong>. A dependent type is a type that is derived from one of the template parameters.</p>
			<p>When the compiler compiles this code, it notices that we are accessing the <strong class="inline">value_type</strong> identifier in the <strong class="inline">Container</strong> class.</p>
			<p>That could either be a static field or a <strong class="inline">type alias</strong>. The compiler cannot know when it parses the template, since it does not know what the <strong class="inline">Container</strong> type will be and whether it has a <strong class="inline">type alias</strong> or a static variable. Therefore, it assumes we are accessing a static value. If this is the case, the syntax we are using is not valid, since we still have <strong class="inline">new_element{}</strong> after access to the field.</p>
			<p>To solve this issue, we can tell the compiler that we are accessing a type in the class, and we do so by prepending the <strong class="inline">typename</strong> keyword to the type we are accessing:</p>
			<p class="snippet">template&lt;typename Container&gt;</p>
			<p class="snippet">void createOneAndAppend(Container&amp; container) {</p>
			<p class="snippet">  typename Container::value_type new_element{};</p>
			<p class="snippet">  container.push_back(new_element);</p>
			<p class="snippet">}</p>
			<h3 id="_idParaDest-131"><a id="_idTextAnchor142"/>Activity 13: Reading Objects from a Connection</h3>
			<p>The user is creating an online game which require to send and receive its current state over an internet connection. The application has several types of connections (TCP, UDP, socket) each of them has a <strong class="inline">readNext()</strong> method which returns an <strong class="inline">std::array</strong> of 100 chars containing the data inside the connection, and a <strong class="inline">writeNext()</strong> method which takes an <strong class="inline">std::array</strong> of 100 characters which puts data into the connection.</p>
			<p>Let's follow these steps to create our online application:</p>
			<ol>
				<li value="1">The objects that the application wants to send and receive over the connection have a <strong class="inline">serialize()</strong> static method which takes an instance of the object and return an <strong class="inline">std::array</strong> of 100 characters representing the object.<p class="snippet">class UserAccount {</p><p class="snippet">public:</p><p class="snippet">    static std::array&lt;char, 100&gt; serialize(const UserAccount&amp; account) {</p><p class="snippet">        std::cout &lt;&lt; "the user account has been serialized" &lt;&lt; std::endl;</p><p class="snippet">        return std::array&lt;char, 100&gt;();</p><p class="snippet">    }</p><p class="snippet">    static UserAccount deserialize(const std::array&lt;char, 100&gt;&amp; blob) {</p><p class="snippet">        std::cout &lt;&lt; "the user account has been deserialized" &lt;&lt; std::endl;</p><p class="snippet">        return UserAccount();</p><p class="snippet">    }</p><p class="snippet">};</p><p class="snippet">class TcpConnection {</p><p class="snippet">public:</p><p class="snippet">    std::array&lt;char, 100&gt; readNext() {</p><p class="snippet">        std::cout &lt;&lt; "the data has been read" &lt;&lt; std::endl;</p><p class="snippet">        return std::array&lt;char, 100&gt;{};</p><p class="snippet">    }</p><p class="snippet">    void writeNext(const std::array&lt;char, 100&gt;&amp; blob) {</p><p class="snippet">        std::cout &lt;&lt; "the data has been written" &lt;&lt; std::endl;</p><p class="snippet">    }</p><p class="snippet">};</p></li>
				<li>The <strong class="inline">deserialize()</strong> static method takes an <strong class="inline">std::array</strong> of 100 characters representing the object, and creates an object from it.</li>
				<li>The connection objects are already provided. Create the header <strong class="inline">connection.h</strong> with the following declarations:<p class="snippet">template&lt;typename Object, typename Connection&gt;</p><p class="snippet">Object readObjectFromConnection(Connection&amp; con) {</p><p class="snippet">  std::array&lt;char, 100&gt; data = con.readNext();</p><p class="snippet">  return Object::deserialize(data);</p><p class="snippet">}</p></li>
				<li>Write a function template called <strong class="inline">readObjectFromConnection</strong> that takes a connection as the only parameter and the type of the object to read from the connection as a template type parameter. The function returns an instance of the object constructed after deserializing the data in the connection.</li>
				<li>Then, call the function with an instance of the <strong class="inline">TcpConnection</strong> class, extracting an object of type <strong class="inline">UserAccount</strong>:<p class="snippet">TcpConnection connection;</p><p class="snippet">UserAccount userAccount = readObjectFromConnection&lt;UserAccount&gt;(connection);</p></li>
			</ol>
			<p>The aim is to be able to send the information on the account of a user to the other users connected to the same online game, so that they can see the user information like their username and the level of their character.</p>
			<h4>Note</h4>
			<p class="callout">The solution for this activity can be found on page 295.</p>
			<h3 id="_idParaDest-132"><a id="_idTextAnchor143"/>Activity 14: Creating a User Account to Support Multiple Currencies</h3>
			<p>Write a program that supports and stores multiple currencies. Follow these steps:</p>
			<ol>
				<li value="1">We want to create an <strong class="inline">Account</strong> class that stores the account balance in different currencies.</li>
				<li>A <strong class="inline">Currency</strong> is a class that represents a certain value in a specific currency. It has a public field called <strong class="inline">value</strong> and a template function called <strong class="inline">to()</strong> that takes the argument as a <strong class="inline">Currency</strong> type and returns an instance of that currency with the value set to the appropriate conversion of the current value of the class:<p class="snippet">struct Currency {</p><p class="snippet">    static const int conversionRate = CurrencyConversion;</p><p class="snippet">    int d_value;</p><p class="snippet">    Currency(int value): d_value(value) {}</p><p class="snippet">};</p><p class="snippet">template&lt;typename OtherCurrency, typename SourceCurrency&gt;</p><p class="snippet">OtherCurrency to(const SourceCurrency&amp; source) {</p><p class="snippet">    float baseValue = source.d_value / float(source.conversionRate);</p><p class="snippet">    int otherCurrencyValue = int(baseValue * OtherCurrency::conversionRate);</p><p class="snippet">    return OtherCurrency(otherCurrencyValue);</p><p class="snippet">}</p><p class="snippet">using USD = Currency&lt;100&gt;;</p><p class="snippet">using EUR = Currency&lt;87&gt;;</p><p class="snippet">using GBP = Currency&lt;78&gt;;</p><p class="snippet">template&lt;typename Currency&gt;</p><p class="snippet">class UserAccount {</p><p class="snippet">public:</p><p class="snippet">  Currency balance;</p><p class="snippet">};</p></li>
				<li>Our aim is to write an <strong class="inline">Account</strong> class that stores the current balance in any currency provided by the <strong class="inline">template</strong> parameter.</li>
				<li>The user account must provide a method called <strong class="inline">addToBalance</strong> that accepts any kind of currency, and after converting it to the correct currency that's used for the account, it should sum the value to the balance:<p class="snippet">template&lt;typename OtherCurrency&gt;</p><p class="snippet">  void addToBalance(OtherCurrency&amp; other) {</p><p class="snippet">    balance.value += to&lt;Currency&gt;(other).value;</p><p class="snippet">  }</p></li>
				<li>The user now understands how to write class templates, how to instantiate them, and how to call their templates.<h4>Note</h4><p class="callout">The solution for this activity can be found on page 296.</p></li>
			</ol>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor144"/>Non-Type Template Parameters</h2>
			<p>We learned how templates allow you to provide the types as parameters and how we can make use of this to write generic code.</p>
			<p>Templates in C++ have an additional feature—<strong class="bold">non-type template parameters</strong>.</p>
			<p>A non-type template parameter is a template parameter that is not a type—it is a value.</p>
			<p>We made use of such non-type template parameters many times when using <strong class="inline">std::array&lt;int, 10&gt;;</strong>.</p>
			<p>Here, the second parameter is a non-type template parameter, which represents the size of the array.</p>
			<p>The declaration of a non-type template parameter is in the parameter list of the template, but instead of starting with a <strong class="inline">typename</strong> keyword such as the type parameters, it starts with the type of the value, followed by the identifier.</p>
			<p>There are strict restrictions on the types that are supported as non-type template parameters: they must be of integral type.</p>
			<p>Let's examine the following example of the declaration of a non-type template parameter:</p>
			<p class="snippet">template&lt;typename T, unsigned int size&gt;</p>
			<p class="snippet">Array {</p>
			<p class="snippet">  // Implementation</p>
			<p class="snippet">};</p>
			<p>For example: here, we declared a class template that takes a type parameter and a non-type parameter.</p>
			<p>We already saw that functions can take parameters directly and classes can accept parameters in the constructor. Additionally, the type of regular parameters is not restricted to be an integral type.</p>
			<p>What is the difference between template and non-template parameters? Why would we use a non-type template parameter instead of a regular parameter?</p>
			<p>The main difference is when the parameter is known to the program. Like all the template parameters and unlike the non-template parameters, the value must be known at compile time.</p>
			<p>This is useful when we want to use the parameters in expressions that need to be evaluated at compile time, as we do when declaring the size of an array.</p>
			<p>The other advantage is that the compiler has access to the value when compiling the code, so it can perform some computations during compilation, reducing the amount of instruction to execute at runtime, thus making the program faster.</p>
			<p>Additionally, knowing some values at compile time allows our program to perform additional checks so that we can identify problems when we compile the program instead of when the program is executed.</p>
			<h3 id="_idParaDest-134"><a id="_idTextAnchor145"/>Activity 15: Writing a Matrix Class for Mathematical Operations in a Game</h3>
			<p>In a game, it is common to represent the orientation of a character in a special kind of matrix: a <em class="italics">quaternion</em>. We would like to write a <strong class="inline">Matrix</strong> class that will be the base of the mathematical operations inside our game.</p>
			<p>Our <strong class="inline">Matrix</strong> class should be a template that accepts a type, a number of rows, and a number of columns.</p>
			<p>We should store the elements of the matrix inside an <strong class="inline">std::array</strong>, stored inside the class.</p>
			<p>The class should have a method called <strong class="inline">get()</strong> that takes a row and a column, and returns a reference to the element in that position.</p>
			<p>If the row or column is outside of the matrix, we should call <strong class="inline">std::abort()</strong>.</p>
			<p>Let's follow these steps:</p>
			<ol>
				<li value="1">The <strong class="inline">Matrix</strong> class takes three template parameters—one type and the two dimensions of the <strong class="inline">Matrix</strong> class. The dimensions are of type <strong class="inline">int</strong>.<p class="snippet">template&lt;typename T, int R, int C&gt;</p><p class="snippet">class Matrix {</p><p class="snippet">    // We store row_1, row_2, ..., row_C</p><p class="snippet">    std::array&lt;T, R*C&gt; data;</p><p class="snippet">    public:</p><p class="snippet">        Matrix() : data({}) {}</p><p class="snippet">};</p></li>
				<li>Now, create a <strong class="inline">std::array</strong> with a size of the number of rows times the number of columns so that we have enough space for all the elements of the matrix. </li>
				<li>Add a constructor to initialize the array:</li>
				<li>We add a <strong class="inline">get()</strong> method  to the class to return a reference to the element <strong class="inline">T</strong>. The method needs to take the row and column we want to access.</li>
				<li>If the index are outside of the bounds of the matrix, we call <strong class="inline">std::abort()</strong>. In the array, we store all the elements of the first row, then all the elements of the second row, and so on. So, when we want to access the elements of the nth row, we need to skip all the elements of the previous rows, which are going to be the number of elements per row (so the number of columns) times the previous rows:<p class="snippet">T&amp; get(int row, int col) {</p><p class="snippet">  if (row &gt;= R || col &gt;= C) {</p><p class="snippet">    std::abort();</p><p class="snippet">  }</p><p class="snippet">  return data[row*C + col];</p><p class="snippet">}</p><p>The output is as follows:</p><p class="snippet">Initial matrix:</p><p class="snippet">1 2 </p><p class="snippet">3 4 </p><p class="snippet">5 6 </p><h4>Note</h4><p class="callout">The solution for this activity can be found on page 298.</p></li>
			</ol>
			<p><strong class="bold">Bonus step:</strong></p>
			<p>In games, multiplying a matrix by a vector is a common operation.</p>
			<p>Add a method to the class that takes a <strong class="inline">std::array</strong> containing elements of the same type of the matrix, and returns a <strong class="inline">std::array</strong> containing the result of the multiplication. See the definition of a matrix-vector product at <a href="https://mathinsight.org/matrix_vector_multiplication">https://mathinsight.org/matrix_vector_multiplication</a>.</p>
			<p><strong class="bold">Bonus step</strong>:</p>
			<p>We add a new method, <strong class="inline">multiply</strong>, which takes a <strong class="inline">std::array</strong> of type <strong class="inline">T</strong> with the length of <strong class="inline">C</strong> by const reference, since we are not modifying it.</p>
			<p>The function returns an array of the same type, but a length of <strong class="inline">R</strong>?</p>
			<p>We follow the definition of the matrix-vector multiplication to compute the result:</p>
			<p class="snippet">std::array&lt;T, R&gt; multiply(const std::array&lt;T, C&gt;&amp; vector){</p>
			<p class="snippet">    std::array&lt;T, R&gt; result = {};</p>
			<p class="snippet">    for(int r = 0; r &lt; R; r++) {</p>
			<p class="snippet">      for(int c = 0; c &lt; C; c++) {</p>
			<p class="snippet">        result[r] += get(r, c) * vector[c];</p>
			<p class="snippet">      }</p>
			<p class="snippet">    }  </p>
			<p class="snippet">    return result;</p>
			<p class="snippet">  }</p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor146"/>Making Templates Easier to Use</h2>
			<p>We always said that we need to provide the template arguments to the parameters of a template function or class. Now, in this section, we are going to see two features that C++ offers to make it easier to use templates.</p>
			<p>These features are default template arguments and template argument deduction.</p>
			<h3 id="_idParaDest-136"><a id="_idTextAnchor147"/>Default Template Arguments</h3>
			<p>Like function arguments, template arguments can also have default values, both for type and non-type template parameters.</p>
			<p>The syntax for default template arguments is to add after the template identifier the equal, followed by the value:</p>
			<p class="snippet">template&lt;typename MyType = int&gt;</p>
			<p class="snippet">void foo();</p>
			<p>When a template provides a default value for a parameter, the user does not have to specify the parameter when instantiating the template. The default parameter must come after the parameters that do not have a default value.</p>
			<p>Additionally, you can reference the previous template parameters when defining the default type for a subsequent template parameter.</p>
			<p>Let's see some examples of both errors and valid declarations:</p>
			<p class="snippet">template&lt;typename T = void, typename A&gt;</p>
			<p class="snippet">void foo();</p>
			<ul>
				<li><strong class="bold">Error</strong>: The template parameter <strong class="inline">T</strong>, which has a default type, comes before the template parameter <strong class="inline">A</strong>, which does not have a default parameter:<p class="snippet">template&lt;typename T = A, typename A = void&gt;</p><p class="snippet">void foo();</p></li>
				<li><strong class="bold">Error</strong>: The template parameter <strong class="inline">T</strong> references the template parameter <strong class="inline">A</strong>, which comes after <strong class="inline">T</strong>:<p class="snippet">template&lt;typename T, typename A = T &gt;</p><p class="snippet">void foo();</p></li>
				<li><strong class="bold">Correct</strong>: <strong class="inline">A</strong> has a default value, and no other template parameter without default value comes after it. It also references <strong class="inline">T</strong>, which is declared before the template parameter <strong class="inline">A</strong>.</li>
			</ul>
			<p>The reason to use the default arguments is to provide a sensible option for the template, but still allowing the user to provide their own type or value when needed.</p>
			<p>Let's see an example of type arguments:</p>
			<p class="snippet">template&lt;typename T&gt;</p>
			<p class="snippet">struct Less {</p>
			<p class="snippet">  bool operator()(const T&amp; a, const T&amp; b) {</p>
			<p class="snippet">    return a &lt; b;</p>
			<p class="snippet">  }</p>
			<p class="snippet">};</p>
			<p class="snippet">template&lt;typename T, typename Comparator= Less&lt;T&gt;&gt;</p>
			<p class="snippet">class SortedArray;</p>
			<p>The hypothetical type <strong class="inline">SortedArray</strong> is an array that keeps its elements always sorted. It accepts the type of the elements it should hold and a comparator. To make it easy to use for the user, it sets the comparator to use the <strong class="inline">less</strong> operator by default.</p>
			<p>The following code shows how a user can implement it:</p>
			<p class="snippet">SortedArray&lt;int&gt; sortedArray1;</p>
			<p class="snippet">SortedArrat&lt;int, Greater&lt;int&gt;&gt; sortedArray2;</p>
			<p>We can also see an example of a default non-type template parameter:</p>
			<p class="snippet">template&lt;size_t Size = 512&gt;</p>
			<p class="snippet">struct MemoryBuffer;</p>
			<p>The hypothetical type <strong class="inline">MemoryBuffer</strong> is an object that reserves an amount of memory on the stack; the program will then allocate objects into that memory. By default, it uses 512 bytes of memory, but the user can specify a different size:</p>
			<p class="snippet">MemoryBuffer&lt;&gt; buffer1;</p>
			<p class="snippet">MemoryBuffer&lt;1024&gt; buffer2;</p>
			<p>Note the empty angle brackets in the <strong class="inline">buffer1</strong> declaration. They are needed to signal to the compiler that we are making use of a template. This requirement has been removed in C++17, and we can write <strong class="inline">MemoryBuffer buffer1;</strong>.</p>
			<h3 id="_idParaDest-137"><a id="_idTextAnchor148"/>Template Argument Deduction</h3>
			<p>All the template parameters need to be known to instantiate a template, but not all of them need to be explicitly provided by the caller.</p>
			<p><strong class="bold">Template argument deduction</strong> refers to the ability of the compiler to automatically understand some of the types that are used to instantiate the template, without the user having to explicitly type them.</p>
			<p>We are going to see them for functions as that is supported by most of the versions of C++. C++17 introduced <strong class="keyword">deduction guides</strong>, which allow the compiler to perform template argument deduction for class templates from the constructor, but we are not going to see them.</p>
			<p>The detailed rules for template argument deduction are very complex, and so we are going to see them by example so that we can understand them.</p>
			<p>In general, the compiler tries to find the type for which the provided argument and the parameter match the closest.</p>
			<p>The code we are going to analyze is as follows:</p>
			<p class="snippet">template&lt;typename T&gt;</p>
			<p class="snippet">void foo(T parameter);</p>
			<p>The calling code is as follows:</p>
			<p class="snippet">foo(argument);</p>
			<h3 id="_idParaDest-138"><a id="_idTextAnchor149"/>Parameter and Argument Types</h3>
			<p>We are going to see how, based on different pairs of parameters and arguments, the type is deduced:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer040">
					<img alt="Figure 4.1: Different parameter and argument types" src="image/C11557_04_01.jpg"/>
				</div>
			</div>
			<h6>Figure 4.1: Different parameter and argument types</h6>
			<p>The error happens because we cannot bind a temporary value, like 1, to a non-<strong class="inline">const</strong> reference.</p>
			<p>As we can see, the compiler tries to deduce a type so that when it is substituted in the parameter, it matches  the argument as best as possible.</p>
			<p>The compiler cannot always find such a type; in those situations, it gives an error and it's up to the user to provide the type.</p>
			<p>The compiler cannot deduce a type for any of the following reasons:</p>
			<p>The type is not used in the parameters. For example: the compiler cannot deduce a type if it is only used in the return type, or only used inside the body of the function.</p>
			<p>The type in the parameter is a derived type. For example: <strong class="inline">template&lt;typename T&gt; void foo(T::value_type a)</strong>. The compiler cannot find the type <strong class="inline">T</strong> given the parameter that's used to call the function.</p>
			<p>Knowing these rules, we can derive a best practice for the order of the template parameters when writing templates: the types that we expect the user to provide need to come before the types that are deduced.</p>
			<p>The reason for this is that a user can only provide the template arguments in the same order they have been declared.</p>
			<p>Let's consider the following template:</p>
			<p class="snippet">template&lt;typename A, typename B, typename C&gt;</p>
			<p class="snippet">C foo(A, B);</p>
			<p>When calling <strong class="inline">foo(1, 2.23)</strong>, the compiler can deduce <strong class="inline">A</strong> and <strong class="inline">B</strong>, but cannot deduce <strong class="inline">C</strong>. Since we need all the types, and the user has to provide them in order, the user has to provide all of the types: <strong class="inline">foo&lt;int, double, and float&gt;(1, 2.23);</strong>.</p>
			<p>Let's say we put the types that cannot be deduced before the types that can be deduced, as in the following example:</p>
			<p class="snippet">template&lt; typename C, typename A, typename B&gt;</p>
			<p class="snippet">C foo(A, B);</p>
			<p>We could call the function with <strong class="inline">foo&lt;float&gt;(1, 2.23)</strong>. We would then provide the type to use for <strong class="inline">C</strong> and the compiler would automatically deduce <strong class="inline">A</strong> and <strong class="inline">B</strong>.</p>
			<p>In a similar way, we need to reason about default template arguments.</p>
			<p>Since they need to come last, we need to make sure to put the types that the user is more likely to want to modify first, since that will force them to provide all the template arguments up to that parameter.</p>
			<h3 id="_idParaDest-139"><a id="_idTextAnchor150"/>Activity 16: Making the Matrix Class Easier to Use</h3>
			<p>The <strong class="inline">Matrix</strong> class we created in <em class="italics">Activity 15: Writing a Matrix Class for Mathematical Operations in a Game,</em> requires that we provide three template parameters.</p>
			<p>Now, in this activity, we want to make the class easier to use by requiring that the user is required to only pass two parameters: the number of rows and the number of columns in the <strong class="inline">Matrix</strong> class. The class should also take a third argument: the type contained in the <strong class="inline">Matrix</strong> class. If not provided, it should default to <strong class="inline">int</strong>.</p>
			<p>In the previous activity, we added to the matrix a <strong class="inline">multiply</strong> operation. We now want to let the user customize the function by specifying how the multiplication between the types should be executed. By default, we want to use the <strong class="inline">*</strong> operator. For that, a <strong class="inline">class</strong> template named <strong class="inline">std::multiplies</strong> from the<strong class="inline"> &lt;functional&gt;</strong> header exists. It works like the <strong class="inline">Less</strong> class we saw previously in this chapter:</p>
			<ol>
				<li value="1">We start by importing <strong class="inline">&lt;functional&gt;</strong> so that we have access to <strong class="inline">std::multiplies</strong>.</li>
				<li>We then change the order of the template parameters in the class template so that the size parameters come first. We also add a new template parameter, <strong class="inline">Multiply</strong>, which is the type we use for computing the multiplication between the elements in the vector by default, and we store an instance of it in the class.</li>
				<li>We now need to make sure that the <strong class="inline">multiply</strong> method uses the <strong class="inline">Multiply</strong> type provided by the user to perform the multiplication.</li>
				<li>To do so, we need to make sure we call <strong class="inline">multiplier(operand1, operand2)</strong> instead of <strong class="inline">operand1 * operand2</strong> so that we use the instance we stored inside the class:<p class="snippet">std::array&lt;T, R&gt; multiply(const std::array&lt;T, C&gt;&amp; vector) {</p><p class="snippet">    std::array&lt;T, R&gt; result = {};</p><p class="snippet">    for(int r = 0; r &lt; R; r++) {</p><p class="snippet">        for(int c = 0; c &lt; C; c++) {</p><p class="snippet">            result[r] += multiplier(get(r, c), vector[c]);</p><p class="snippet">        }</p><p class="snippet">    }</p><p class="snippet">    return result;</p><p class="snippet">}</p></li>
				<li>Add an example of how we can use the class:<p class="snippet">// Create a matrix of int, with the 'plus' operation by default</p><p class="snippet">Matrix&lt;3, 2, int, std::plus&lt;int&gt;&gt; matrixAdd;</p><p class="snippet">matrixAdd.setRow(0, {1,2});</p><p class="snippet">matrixAdd.setRow(1, {3,4});</p><p class="snippet">matrixAdd.setRow(2, {5,6});</p><p class="snippet">std::array&lt;int, 2&gt; vector = {8, 9};</p><p class="snippet">// This will call std::plus when doing the multiplication</p><p class="snippet">std::array&lt;int, 3&gt; result = matrixAdd.multiply(vector);</p><p>The output is as follows:</p><p class="snippet">Initial matrix:</p><p class="snippet">1 2 </p><p class="snippet">3 4 </p><p class="snippet">5 6 </p><p class="snippet">Result of multiplication (with plus instead of multiply): [20, 24, 28]</p><h4>Note</h4><p class="callout">The solution for this activity can be found on page 300.</p></li>
			</ol>
			<h2 id="_idParaDest-140"><a id="_idTextAnchor151"/>Being Generic in Templates</h2>
			<p>So far, we have learned how the compiler can make our templated functions easier to use by automatically deducing the types used. The template code decides whether to accept a parameter as a value or a reference, and the compiler finds the type for us. But what do we do if we want to be agnostic regarding whether an argument is a value or a reference, and we want to work with it regardless?</p>
			<p>An example would be <strong class="inline">std::invoke</strong> in C++17. <strong class="inline">std::invoke</strong> is a function that takes a function as the first argument, followed by a list of arguments, and calls the function with the arguments. For example:</p>
			<p class="snippet">void do_action(int, float, double);</p>
			<p class="snippet">double d = 1.5;</p>
			<p class="snippet">std::invoke(do_action, 1, 1.2f, d);</p>
			<p>Similar examples would apply if you wanted to log before calling a function, or you wanted to execute the function in a different thread, such as <strong class="inline">std::async</strong> does.</p>
			<p>Let's demystify the difference by using the following code:</p>
			<p class="snippet">struct PrintOnCopyOrMove {</p>
			<p class="snippet">  PrintOnCopyOrMove(std::string name) : _name(name) {}</p>
			<p class="snippet">  PrintOnCopyOrMove(const PrintOnCopyOrMove&amp; other) : _name(other._name) { std::cout &lt;&lt; "Copy: " &lt;&lt; _name &lt;&lt; std::endl; }</p>
			<p class="snippet">  PrintOnCopyOrMove(PrintOnCopyOrMove&amp;&amp; other) : _name(other._name) { std::cout &lt;&lt; "Move: " &lt;&lt; _name &lt;&lt; std::endl; }</p>
			<p class="snippet">    </p>
			<p class="snippet">  std::string _name;</p>
			<p class="snippet">};</p>
			<p class="snippet">void use_printoncopyormove_obj(PrintOnCopyOrMove obj) {}</p>
			<h4>Note</h4>
			<p class="callout"><strong class="inline">use_printoncopyormove_obj</strong> always accepts the parameter by value.</p>
			<p>Let's say we execute the following code:</p>
			<p class="snippet">PrintOnCopyOrMove local{"l-value"};</p>
			<p class="snippet">std::invoke(use_printoncopyormove_obj, local);</p>
			<p class="snippet">std::invoke(use_printoncopyormove_obj, PrintOnCopyOrMove("r-value"));</p>
			<p>The code would print the following:</p>
			<p class="snippet">Copy: l-value</p>
			<p class="snippet">Move: r-value</p>
			<p>H<a id="_idTextAnchor152"/>ow can we write a function such as <strong class="inline">std::invoke</strong> that works regardless of the kind of reference (colloquially referred to as "ref-ness", similarly to how "const-ness" is used to talk about whether a type is const qualified) of the parameters?</p>
			<p>The answer to that is <strong class="keyword">forwarding references</strong>.</p>
			<p>Forwarding references look like r-value references, but they only apply where the type is deduced by the compiler:</p>
			<p class="snippet">void do_action(PrintOnCopyOrMove&amp;&amp;)</p>
			<p class="snippet">// not deduced: r-value reference</p>
			<p class="snippet">template&lt;typename T&gt;</p>
			<p class="snippet">void do_action(T&amp;&amp;) // deduced by the compiler: forwarding reference</p>
			<h4>Note</h4>
			<p class="callout">If you see a type identifier declared in the template, the type is deduced, and the type has &amp;&amp;, then it is a forwarding reference.</p>
			<p>Let's see how the deduction works for forwarding references:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer041">
					<img alt="Figure 4.2: Forward reference function. " src="image/C11557_04_02.jpg"/>
				</div>
			</div>
			<h6>Figure 4.2: Forward reference function.</h6>
			<h4>Note</h4>
			<p class="callout">Let's say the type is not deduced, but, it is provided explicitly, for example:</p>
			<p class="callout"><strong class="inline">int x = 0;</strong></p>
			<p class="callout"><strong class="inline">do_action&lt;int&gt;(x);</strong></p>
			<p class="callout">Here, <strong class="inline">T</strong> will be <strong class="inline">int</strong>, since it was explicitly stated.</p>
			<p>The advantage, as we saw before, is that we work with any kind of reference, and when the calling code knows it can move the object, then we can make use of the additional performance provided by the move constructor, but when a reference is preferred, then the code can use it as well.</p>
			<p>Additionally, some types do not support copying, and we can make our template work with those types as well.</p>
			<p>When we write the body of the template function, the parameter is used as an <strong class="inline">l-value</strong> reference, and we can write code ignoring whether <strong class="inline">T</strong> is an <strong class="inline">l-value</strong> reference or an <strong class="inline">r-value</strong> one:</p>
			<p class="snippet">template&lt;typename T&gt;</p>
			<p class="snippet">void do_action(T&amp;&amp; obj) { /* forwarding reference, but we can access obj as if it was a normal l-value reference */</p>
			<p class="snippet">  obj.some_method();</p>
			<p class="snippet">  some_function(obj);</p>
			<p class="snippet">}</p>
			<p>In <em class="italics">Chapter 3</em>, <em class="italics">Classes</em>, we learned that <strong class="inline">std::move</strong> can make our code more efficient when we need to use an object that we are not going to access after the call happens.</p>
			<p>But we saw that we should never move objects we receive as an <strong class="inline">l-value</strong> reference parameter, since the code that called us might still use the object after we return.</p>
			<p>When we are writing templates using a forwarding reference, we are in front of a dilemma: our type might be a value or a reference, so how do we decide whether we can use <strong class="inline">std::move</strong>?</p>
			<p>Does it mean we cannot make use of the benefit that <strong class="inline">std::move</strong> brings us?</p>
			<p>The answer, of course, is <em class="italics">no</em>:</p>
			<p class="snippet">template&lt;typename T&gt;</p>
			<p class="snippet">void do_action(T&amp;&amp; obj) {</p>
			<p class="snippet">  do_something_with_obj(???); </p>
			<p class="snippet">// We are not using obj after this call.</p>
			<p class="snippet">}</p>
			<p>Should we use move or not in this case?</p>
			<p>The answer is <em class="italics">yes</em>: we should move if <strong class="inline">T</strong> is a value, and, no, we should not move if <strong class="inline">T</strong> is a reference.</p>
			<p>C++ provides us with a tool to do exactly this: <strong class="inline">std::forward</strong>.</p>
			<p><strong class="inline">std::forward</strong> is a function template that always takes an explicit template parameter and a function parameter: <strong class="inline">std::forward&lt;T&gt;(obj)</strong>.</p>
			<p><strong class="inline">Forward</strong> looks at the type of <strong class="inline">T</strong>, and if it's an <strong class="inline">l-value</strong> reference, then it simply returns a reference to the <strong class="inline">obj</strong>, but if it's not, then it is equivalent to calling <strong class="inline">std::move</strong> on the object.</p>
			<p>Let's see it in action:</p>
			<p class="snippet">template&lt;typename T&gt;</p>
			<p class="snippet">void do_action(T&amp;&amp; obj) {</p>
			<p class="snippet">  use_printoncopyormove_obj(std::forward&lt;T&gt;(obj)); </p>
			<p class="snippet">}</p>
			<p>Now, we call it by using the following code:</p>
			<p class="snippet">PrintOnCopyOrMove local{"l-value"};</p>
			<p class="snippet">do_action(local);</p>
			<p class="snippet">do_action(PrintOnCopyOrMove("r-value"));</p>
			<p class="snippet">do_action(std::move(local));</p>
			<p class="snippet">// We can move because we do not use local anymore</p>
			<p>When executed, the code will print the following output:</p>
			<p class="snippet">Copy: l-val</p>
			<p class="snippet">Move: r-val</p>
			<p class="snippet">Move: l-val</p>
			<p>We successfully managed to write code that is independent on whether the type is passed as reference or value, removing a possible requirement on the template type parameter.</p>
			<h4>Note</h4>
			<p class="callout">A template can have many type parameters. Forwarding references can apply to any of the type parameters independently.</p>
			<p>This is important because the caller of the templated code might know whether it is better to pass values or pass references, and our code should work regardless of whether there is a requirement to ask for a specific ref-ness.</p>
			<p>We also saw how we can still maintain the advantages of moving, which is required for some types that do not support copying. This can make our code run much faster, even for types that support copying, without complicating our code: when we have forwarding references we use <strong class="inline">std::forward</strong> where we would have used <strong class="inline">std::move</strong>.</p>
			<h3 id="_idParaDest-141"><a id="_idTextAnchor153"/>Activity 17: Ensuring Users are Logged in When Performing Actions on the Account</h3>
			<p>We want to allow the users of our e-commerce website to perform arbitrary actions (for the scope of this activity, they will be adding and removing items) on their shopping carts.</p>
			<p>Before performing any action, we want to make sure that the user is logged in. Now, let's follow these instructions:</p>
			<ol>
				<li value="1">Ensure that there is a <strong class="inline">UserIdentifier</strong> type for identifying the user, a <strong class="inline">Cart</strong> type that represents the shopping cart of the user, and a <strong class="inline">CartItem</strong> type that represents any item in the cart:<p class="snippet">struct UserIdentifier {</p><p class="snippet">    int userId = 0;</p><p class="snippet">};</p><p class="snippet">struct Cart {</p><p class="snippet">    std::vector&lt;Item&gt; items;</p><p class="snippet">};</p></li>
				<li>Ensure that there is also a function with the signature <strong class="inline">bool isLoggedIn(const UserIdentifier&amp; user)</strong> and a function to retrieve the cart for an user, <strong class="inline">Cart getUserCart(const UserIdentifier&amp; user)</strong>:<p class="snippet">bool isLoggedIn(const UserIdentifier&amp; user) {</p><p class="snippet">    return user.userId % 2 == 0;</p><p class="snippet">}</p><p class="snippet">Cart getUserCart(const UserIdentifier&amp; user) {</p><p class="snippet">    return Cart();</p><p class="snippet">}</p></li>
				<li>In most of our code, we only have access to the <strong class="inline">UserIdentifier</strong> for a user, and we want to make sure that we always check whether the user is logged in before doing any action on the cart.</li>
				<li>To solve this problem, we decide to write a function template called <strong class="inline">execute_on_user_cart</strong>, which takes the user identifier, an action, and a single parameter. The function will check if the user is logged in and if so, retrieve their cart, then perform the action of passing the cart and the single parameter:<p class="snippet">template&lt;typename Action, typename Parameter&gt;</p><p class="snippet">void execute_on_user_cart(UserIdentifier user, Action action, Parameter&amp;&amp; parameter) {</p><p class="snippet">    if(isLoggedIn(user)) {</p><p class="snippet">        Cart cart = getUserCart(user);</p><p class="snippet">        action(cart, std::forward&lt;Parameter&gt;(parameter));</p><p class="snippet">    } else {</p><p class="snippet">        std::cout &lt;&lt; "The user is not logged in" &lt;&lt; std::endl;</p><p class="snippet">    }</p><p class="snippet">}</p></li>
				<li>One of the actions we want to perform is <strong class="inline">void remove_item(Cart, CartItem)</strong>. A second action we want to perform is <strong class="inline">void add_items(Cart, std::vector&lt;CartItem&gt;)</strong>:<p class="snippet">void removeItem(Cart&amp; cart, Item cartItem) {</p><p class="snippet">    auto location = std::find(cart.items.begin(), cart.items.end(), cartItem);</p><p class="snippet">    if (location != cart.items.end()) {</p><p class="snippet">        cart.items.erase(location);</p><p class="snippet">    }</p><p class="snippet">    std::cout &lt;&lt; "Item removed" &lt;&lt; std::endl;</p><p class="snippet">}</p><p class="snippet">void addItems(Cart&amp; cart, std::vector&lt;Item&gt; items) {</p><p class="snippet">    cart.items.insert(cart.items.end(), items.begin(), items.end());</p><p class="snippet">    std::cout &lt;&lt; "Items added" &lt;&lt; std::endl;</p><p class="snippet">}</p><h4>Note</h4><p class="callout">A parameter of a function template can be used to accept functions as parameters.</p><p>The aim is to create a function that performs the necessary checks on whether the user is logged in so that throughout our program we can use it to perform safely any actions that are required by our business on the user cart, without the risk of forgetting to check the logged status of the user.</p></li>
				<li>We can also move the types that are not forwarding references:<p class="snippet">template&lt;typename Action, typename Parameter&gt;</p><p class="snippet">void execute_on_user_cart(UserIdentifier user, Action action, Parameter&amp;&amp; parameter) {</p><p class="snippet">    if(isLoggedIn(user)) {</p><p class="snippet">        Cart cart = getUserCart(user);</p><p class="snippet">        action(std::move(cart), std::forward&lt;Parameter&gt;(parameter));</p><p class="snippet">    }</p><p class="snippet">}</p></li>
				<li>Examples of how the <strong class="inline">execute_on_user_cart</strong> function can be used with the actions we described earlier in the activity is as follows:<p class="snippet">UserIdentifier user{/* initialize */};</p><p class="snippet">execute_on_user_cart(user, remove_item, CartItem{});</p><p class="snippet">std::vector&lt;CartItem&gt; items = {{"Item1"}, {"Item2"}, {"Item3"}}; // might be very long</p><p class="snippet">execute_on_user_cart(user, add_items, std::move(items));</p></li>
				<li>The developers in our software can write the functions they need to execute on the cart, and call <strong class="inline">execute_on_user_cart</strong> to safely execute them.<h4>Note</h4><p class="callout">The solution for this activity can be found on page 302.</p></li>
			</ol>
			<h2 id="_idParaDest-142"><a id="_idTextAnchor154"/>Variadic Templates</h2>
			<p>We just saw how we can write a template that accepts parameters independently from their ref-ness.</p>
			<p>But the two functions we talked about from the standard library, <strong class="inline">std::invoke</strong> and <strong class="inline">std::async</strong>, have an additional property: they can accept any number of arguments.</p>
			<p>In a similar way, <strong class="inline">std::tuple</strong>, a type similar to a <strong class="inline">std::array</strong> but that can contain values of different types, can contain an arbitrary number of types.</p>
			<p>How is it possible for a template to accept an arbitrary number of arguments of different types?</p>
			<p>In the past, a solution to this problem was to provide a great number of overloads for the same function, or multiple implementations of the class or struct, one for each number of the parameters.</p>
			<p>This is clearly code that is not easy to maintain, as it forces us to write the same code multiple times. Another drawback is that there is a limit to the number of template parameters, so if your code requires more parameters than what is provided, you do not have a way to use the function.</p>
			<p>C++11 introduced a nice solution for this problem: <strong class="bold">parameter pack</strong>.</p>
			<p>A parameter pack is a template parameter that can accept zero or more template arguments.</p>
			<p>A parameter pack is declared by appending <strong class="inline">…</strong> to the type of the template parameter.</p>
			<p>Parameter packs are a functionality that works with any template: both functions and classes:</p>
			<p class="snippet">template&lt;typename… Types&gt;</p>
			<p class="snippet">void do_action();</p>
			<p class="snippet">template&lt;typename… Types&gt;</p>
			<p class="snippet">struct MyStruct;</p>
			<p>A template that has a parameter pack is called a <strong class="bold">variadic template</strong>, since it is a template that accepts a varying number of parameters.</p>
			<p>When instantiating a variadic template, any number of arguments can be provided to the parameter pack by separating them with a comma:</p>
			<p class="snippet">do_action&lt;int, std:string, float&gt;();</p>
			<p class="snippet">do_action&lt;&gt;();</p>
			<p class="snippet">MyStruct&lt;&gt; myStruct0;</p>
			<p class="snippet">MyStruct&lt;float, int&gt; myStruct2;</p>
			<p><strong class="inline">Types</strong> will contain the list of arguments that are provided when instantiating the template.</p>
			<p>A parameter pack by itself is a list of types and the code cannot interact with it directly.</p>
			<p>The variadic template can use the parameter pack by expanding it, which happens by appending <strong class="inline">…</strong> to a pattern.</p>
			<p>When a pattern is expanded, it is repeated as many times as there are types in its parameter pack, separating it with a comma. Of course, to be expanded, a pattern must contain at least a parameter pack. If multiple parameters are present in the pattern, or the same parameter is present several times, they are all expanded at the same time.</p>
			<p>The simplest pattern is the name of the parameter pack: <strong class="inline">Types…</strong>.</p>
			<p>For example: to let a function accept multiple arguments, it would expand the parameter pack in the function arguments:</p>
			<p class="snippet">template&lt;typename… MyTypes&gt;</p>
			<p class="snippet">void do_action(MyTypes… my_types);</p>
			<p class="snippet">do_action();</p>
			<p class="snippet">do_action(1, 2, 4.5, 3.5f);</p>
			<p>When we call the function, the compiler automatically deduces the types of the parameter pack. In the last call, <strong class="inline">MyTypes</strong> will contain <strong class="inline">int</strong>, <strong class="inline">double</strong>, and <strong class="inline">float</strong>, and the signature of the generated function would be <strong class="inline">void do_action(int __p0, int __p1, double __p2, float __p3)</strong>.</p>
			<h4>Note</h4>
			<p class="callout">A parameter pack in the list of template parameters can only be followed by template parameters that have a default value, or those that are deduced by the compiler.</p>
			<p class="callout">Most commonly, the parameter pack is the last in the list of template parameters.</p>
			<p>The function parameter <strong class="inline">my_types</strong> is called a <strong class="bold">function parameter pack</strong> and needs to be expanded as well so that it can access the single parameters.</p>
			<p>For example: let's write a variadic struct:</p>
			<p class="snippet">template&lt;typename… Ts&gt;</p>
			<p class="snippet">struct Variadic {</p>
			<p class="snippet">  Variadic(Ts… arguments);</p>
			<p class="snippet">};</p>
			<p>Let's write a function that creates the struct:</p>
			<p class="snippet">template&lt;typename… Ts&gt;</p>
			<p class="snippet">Variadic&lt;Ts…&gt; make_variadic(Ts… args) {</p>
			<p class="snippet">  return Variadic&lt;Ts…&gt;(args…);</p>
			<p class="snippet">}</p>
			<p>Here, we have a variadic function that takes a parameter pack and expands it when calling the constructor of another variadic struct.</p>
			<p>The function <strong class="inline">parameter packs</strong>, which is the function variadic parameter, can be expanded only in some locations—the most common is as parameters when calling a function.</p>
			<p>The template <strong class="inline">parameter packs</strong>, which is a type variadic parameter, can be expanded in template argument lists: the list of arguments between <strong class="inline">&lt;&gt;</strong> when instantiating a template.</p>
			<p>As we mentioned previously, the pattern for the expansion might be more complex than just the name of the argument.</p>
			<p>For example: we can access type aliases declared in the type or we can call a function on the parameter:</p>
			<p class="snippet">template&lt;typename… Containers&gt;</p>
			<p class="snippet">std::tuple&lt;typename Containers::value_type…&gt; get_front(Containers… containers) {</p>
			<p class="snippet">  return std::tuple&lt;typename Containers::value_type…&gt;(containers.front()…);</p>
			<p class="snippet">}</p>
			<p>We call it like so:</p>
			<p class="snippet">std::vector&lt;int&gt; int_vector = {1};</p>
			<p class="snippet">std::vector&lt;double&gt; double_vector = {2.0};</p>
			<p class="snippet">std::vector&lt;float&gt; float_vector = {3.0f};</p>
			<p class="snippet">get_front(int_vector, double_vector, float_vector) // Returns a tuple&lt;int, double, float&gt; containing {1, 2.0, 3.0}</p>
			<p>Alternatively, we can pass the parameter as an argument to a function:</p>
			<p class="snippet">template&lt;typename… Ts&gt;</p>
			<p class="snippet">void modify_and_call (Ts… args) {</p>
			<p class="snippet">  do_things(modify (args)…));</p>
			<p class="snippet">}</p>
			<p>This will call the <strong class="inline">modify</strong> function for each argument and pass the result to <strong class="inline">do_things</strong>.</p>
			<p>In this section, we saw how the variadic parameter functionality of C++ lets us write functions and classes that work with any number and type of parameters.</p>
			<p>While it is not a common everyday task to write variadic templates, almost every programmer uses a variadic template in their day-to-day coding, since it makes it so much easier to write powerful abstractions, and the standard library makes vast use of it.</p>
			<p>Additionally, in the right situation, variadic templates can allow us to write expressive code that works in the multitude of situations we need.</p>
			<h3 id="_idParaDest-143"><a id="_idTextAnchor155"/>Activity 18: Safely Performing Operations on the User Cart with an Arbitrary Number of Parameters</h3>
			<p>In the previous activity, we saw a function, <strong class="inline">execute_on_user_cart</strong>, which allows us to execute arbitrary functions that take an object of type <strong class="inline">Cart</strong> and a single parameter. </p>
			<p>In this activity, we want to expand on the supported types of actions we can perform on the shopping cart of the user by allowing any function that takes an object of type <strong class="inline">Cart</strong> and an arbitrary number of arguments:</p>
			<ol>
				<li value="1">Expand the previous activity to accept any number of the parameter with any kind of ref-ness and pass it to the action provided.</li>
				<li>Write variadic templates and learn how to expand them:<p class="snippet">template&lt;typename Action, typename... Parameters&gt;</p><p class="snippet">void execute_on_user_cart(UserIdentifier user, Action action, Parameters&amp;&amp;... parameters) {</p><p class="snippet">    if(isLoggedIn(user)) {</p><p class="snippet">        Cart cart = getUserCart(user);</p><p class="snippet">        action(std::move(cart), std::forward&lt;Parameters&gt;(parameters)...);</p><p class="snippet">    }</p><p class="snippet">}</p><h4>Note</h4><p class="callout">The solution for this activity can be found on page 303.</p></li>
			</ol>
			<h2 id="_idParaDest-144"><a id="_idTextAnchor156"/>Writing Easy-to-Read Templates</h2>
			<p>Up until now, we have seen many features that we can use to write powerful templates that allow us to create high-level abstractions over the specific problems we face.</p>
			<p>But, as usual, code is more often read than written, and we should optimize for readability: the code should express the intentions of the code more than what operation is achieved.</p>
			<p>Template code can sometimes make that hard to do, but there are a few patterns that can help.</p>
			<h3 id="_idParaDest-145"><a id="_idTextAnchor157"/>Type Alias</h3>
			<p>Type <strong class="bold">aliases</strong> allow the user to give a name to a type. They are declared with using <strong class="inline">name = type</strong>.</p>
			<p>After the declaration, everywhere <em class="italics">Name</em> is used is going to be equivalent to having used <em class="italics">Type</em>.</p>
			<p>This is very powerful for three reasons:</p>
			<ul>
				<li>It can give a shorter and more meaningful name to complex types</li>
				<li>It can declare a nested type to simplify access to it</li>
				<li>It allows you to avoid having to specify the <strong class="inline">typename</strong> keyword in front of a dependent type</li>
			</ul>
			<p>Let's see examples for these two points.</p>
			<p>Imagine we have a type, <strong class="inline">UserAccount</strong>, which contains several fields on the user, such as user ID, user balance, user email, and more.</p>
			<p>We want to organize the user accounts into a high scoreboard based on their account balances to visualize which users are most actively using our service.</p>
			<p>To do so. we can use a data structure that requires a few parameters: the type to store, a way for ordering the types, a way to compare the types, and possibly others.</p>
			<p>The type could be as follows:</p>
			<p class="snippet">template&lt;typename T, typename Comparison = Less&lt;T&gt;, typename Equality = Equal&lt;T&gt;&gt;</p>
			<p class="snippet">class SortedContainer;</p>
			<p>To be easy to use, the template correctly provided some default values for <strong class="inline">Comparison</strong> and <strong class="inline">Equality</strong>, which use the <strong class="inline">&lt;</strong> and <strong class="inline">==</strong> operators, but our <strong class="inline">UserAccount</strong> type does not implement the <strong class="inline">&lt;</strong> operator, as there is no clear ordering, and the <strong class="inline">==</strong> operator does not do what we want, as we are only interested in comparing balances. To solve this, we implemented two structures to provide the functionality we need:</p>
			<p class="snippet">SortedContainer&lt;UserAccount, UserAccountBalanceCompare, UserAccountBalanceEqual&gt; highScoreBoard;</p>
			<p>The creation of a high scoreboard is both verbose.</p>
			<p>Using a type alias, we could write the following:</p>
			<p class="snippet">using HighScoreBoard = SortedContainer&lt;UserAccount, UserAccountBalanceCompare, UserAccountBalanceEqual&gt;;</p>
			<p>Following this, we could create instances of <strong class="inline">HighScoreBoard</strong> directly, with little typing and clearly specify the intent:</p>
			<p class="snippet">HighScoreBoard highScoreBoard;</p>
			<p>We now also have a single place to update if we want to change the way in which we want to sort the accounts. For example: if we also wanted to consider how long the user has been registered in the service, we could change the comparator the comparator. Every user of the type alias will be updated, without the risk of forgetting to update one location.</p>
			<p>Additionally, we clearly have a location where we can put the documentation on the decision made for using the type we picked.</p>
			<h4>Note</h4>
			<p class="callout">When using type aliases, give a name that represents what the type is for, not how it works. <strong class="inline">UserAccountSortedContainerByBalance</strong> is a not a good name because it tells us how the type works instead of what its intention is.</p>
			<p>The second case is extremely useful for allowing code to introspect the class, that is, looking into some of the details of the class:</p>
			<p class="snippet">template&lt;typename T&gt;</p>
			<p class="snippet">class SortedContainer {</p>
			<p class="snippet">public:</p>
			<p class="snippet">  T&amp; front() const;</p>
			<p class="snippet">};</p>
			<p class="snippet">template&lt;typename T&gt;</p>
			<p class="snippet">class ReversedContainer {</p>
			<p class="snippet">public:</p>
			<p class="snippet">  T&amp; front() const;</p>
			<p class="snippet">}</p>
			<p>We have several containers, which mostly support the same operations. We would like to write a template function that takes any container and returns the first element, <strong class="inline">front</strong>:</p>
			<p class="snippet">template&lt;typename Container&gt;</p>
			<p class="snippet">??? get_front(const Container&amp; container);</p>
			<p>How can we find out what type is returned?</p>
			<p>A common pattern is to add a type alias inside the class, like so:</p>
			<p class="snippet">template&lt;typename T&gt;</p>
			<p class="snippet">class SortedContainer {</p>
			<p class="snippet">  using value_type = T; // type alias</p>
			<p class="snippet">  T&amp; front() const;</p>
			<p class="snippet">};</p>
			<p>Now the function can access the type of the contained element:</p>
			<p class="snippet">template&lt;typename Container&gt;</p>
			<p class="snippet">typename Container::value_type&amp; get_front(const Container&amp; container);</p>
			<h4>Note</h4>
			<p class="callout">Remember that <strong class="inline">value_type</strong> depends on the <strong class="inline">Container</strong> type, so it is a dependent type. When we use dependent types, we must use the <strong class="inline">typename</strong> keyword in <strong class="inline">front</strong>.</p>
			<p>This way, our code can work with any type that declares the nested type <strong class="inline">value_type</strong>.</p>
			<p>The third use case, that is, to avoid having to type the <strong class="inline">typename</strong> keyword repeatedly, is common when interacting with code that follows the previous pattern.</p>
			<p>For example: we can have a class that accepts a type:</p>
			<p class="snippet">template&lt;typename Container&gt;</p>
			<p class="snippet">class ContainerWrapper {</p>
			<p class="snippet">  using value_type = typename Container::value_type;</p>
			<p class="snippet">}</p>
			<p>In the rest of the class, we can use <strong class="inline">value_type</strong> directly, without having to type <strong class="inline">typename</strong> anymore. This allows us to avoid a lot of repetitions.</p>
			<p>The three techniques can also be combined. For example: you can have the following:</p>
			<p class="snippet">template&lt;typename T&gt;</p>
			<p class="snippet">class MyObjectWrapper {</p>
			<p class="snippet">  using special_type = MyObject&lt;typename T::value_type&gt;;</p>
			<p class="snippet">};</p>
			<h3 id="_idParaDest-146"><a id="_idTextAnchor158"/>Template Type Alias</h3>
			<p>The ability to create type aliases, as described in the previous part of this chapter, is already very useful for improving the readability of our code.</p>
			<p>C++ gives us the ability to define generic type aliases so that they can simply be reused by the users of our code.</p>
			<p>A template alias is a template that generates aliases.</p>
			<p>Like all the templates we saw in this chapter, they start with a template declaration and follow with the alias declaration, which can depend on the type that's declared in the template:</p>
			<p class="snippet">template&lt;typename Container&gt;</p>
			<p class="snippet">using ValueType = typename Container::value_type;</p>
			<p>A <strong class="inline">ValueType</strong> is a template alias that can be instantiated with the usual template syntax: <strong class="inline">ValueType&lt;SortedContainer&gt; myValue;</strong>.</p>
			<p>This allows the code to just use the alias <strong class="inline">ValueType</strong> whenever they want to access the <strong class="inline">value_type</strong> type inside any container.</p>
			<p>Template aliases can combine all the features of templates: they can accept multiple parameters, accept non-type parameters, and even use parameter packs.</p>
			<h2 id="_idParaDest-147"><a id="_idTextAnchor159"/>Summary</h2>
			<p>In this chapter, the students were introduced to templates in C++. We saw that templates exist to create high-level abstractions that work independently from the types of the objects at zero overhead at runtime. We explained the concept of type requirements: the requirements a type must satisfy to work correctly with the templates. We then showed the students how to write function templates and class templates, mentioning dependent types as well, to give the students the tools to understand a class of errors that happen when writing template code.</p>
			<p>We then showed how templates can work with non-type parameters, and how templates can be made easier to use by providing default template arguments, thanks to template argument deduction.</p>
			<p>We then showed the students how to write more generic templates, thanks to the forwarding reference, <strong class="inline">std::forward</strong>, and the template parameter pack.</p>
			<p>Finally, we concluded with some tools to make templates easier to read and more maintainable.</p>
			<p>In the next chapter, we will cover standard library containers and algorithms.</p>
		</div>
</body></html>