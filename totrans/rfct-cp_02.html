<html><head></head><body>
<div id="_idContainer006">
<h1 class="chapter-number" id="_idParaDest-27"><a id="_idTextAnchor026"/><span class="koboSpan" id="kobo.1.1">2</span></h1>
<h1 id="_idParaDest-28"><a id="_idTextAnchor027"/><span class="koboSpan" id="kobo.2.1">Main Software Development Principles</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In this chapter, we will explore the main software design principles that are used to create well-structured and maintainable code. </span><span class="koboSpan" id="kobo.3.2">One of the most important principles is SOLID, which stands for Single Responsibility Principle, Open-Closed Principle, Liskov Substitution Principle, Interface Segregation Principle, and Dependency Inversion Principle. </span><span class="koboSpan" id="kobo.3.3">These principles are designed to help developers create code that is easy to understand, test, and modify. </span><span class="koboSpan" id="kobo.3.4">We will also discuss the importance of levels of abstraction, which is the practice of breaking down complex systems into smaller, more manageable parts. </span><span class="koboSpan" id="kobo.3.5">Additionally, we will explore the concepts of side effects and mutability and how they can affect the overall quality of software. </span><span class="koboSpan" id="kobo.3.6">By understanding and applying these principles, developers can create software that is more robust, reliable, </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">and scalable.</span></span></p>
<h1 id="_idParaDest-29"><a id="_idTextAnchor028"/><span class="koboSpan" id="kobo.5.1">SOLID</span></h1>
<p><span class="koboSpan" id="kobo.6.1">SOLID is a </span><a id="_idIndexMarker032"/><span class="koboSpan" id="kobo.7.1">set of principles that were first introduced by Robert C. </span><span class="koboSpan" id="kobo.7.2">Martin in his book </span><em class="italic"><span class="koboSpan" id="kobo.8.1">Agile Software Development, Principles, Patterns, and Practices</span></em><span class="koboSpan" id="kobo.9.1">, in 2000. </span><span class="koboSpan" id="kobo.9.2">Robert C. </span><span class="koboSpan" id="kobo.9.3">Martin, also known as Uncle Bob, is a software engineer, author, and speaker. </span><span class="koboSpan" id="kobo.9.4">He is considered one of the most influential figures in the software development industry, known for his work on the SOLID principles and his contributions to the field of object-oriented programming. </span><span class="koboSpan" id="kobo.9.5">Martin has been a software developer for more than 40 years and has worked on a wide variety of projects, from small systems to large enterprise systems. </span><span class="koboSpan" id="kobo.9.6">He is also a well-known speaker and has given presentations on software development at many conferences and events around the world. </span><span class="koboSpan" id="kobo.9.7">He is an advocate of agile methodologies, and he has been influential in the development of the Agile Manifesto. </span><span class="koboSpan" id="kobo.9.8">The SOLID principles were developed as a way to help developers create more maintainable and scalable code by promoting good design practices. </span><span class="koboSpan" id="kobo.9.9">The principles were based on Martin’s experience as a software developer and his observation that many software projects suffer from poor design, which makes them difficult to understand, change, and maintain </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">over time.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">The SOLID principles are intended to be a guide for object-oriented software design, and they are </span><a id="_idIndexMarker033"/><span class="koboSpan" id="kobo.12.1">based on the idea that software should be easy to understand, change, and extend over time. </span><span class="koboSpan" id="kobo.12.2">The principles are meant to be applied in conjunction with other software development practices, such as test-driven development and continuous integration. </span><span class="koboSpan" id="kobo.12.3">By following SOLID principles, developers can create code that is more robust, less prone to bugs, and easier to maintain </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">over time.</span></span></p>
<h2 id="_idParaDest-30"><a id="_idTextAnchor029"/><span class="koboSpan" id="kobo.14.1">The Single Responsibility Principle</span></h2>
<p><span class="koboSpan" id="kobo.15.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.16.1">Single Responsibility Principle</span></strong><span class="koboSpan" id="kobo.17.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.18.1">SRP</span></strong><span class="koboSpan" id="kobo.19.1">) is one of the five SOLID principles of object-oriented </span><a id="_idIndexMarker034"/><span class="koboSpan" id="kobo.20.1">software design. </span><span class="koboSpan" id="kobo.20.2">It states that a</span><a id="_idIndexMarker035"/><span class="koboSpan" id="kobo.21.1"> class should have only one reason to change, meaning that a class should have only one responsibility. </span><span class="koboSpan" id="kobo.21.2">This principle is intended to promote code that is easy to understand, change, </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">and test.</span></span></p>
<p><span class="koboSpan" id="kobo.23.1">The idea behind the SRP is that a class should have a single, well-defined purpose. </span><span class="koboSpan" id="kobo.23.2">This makes it easier to understand the class’s behavior and makes it less likely that changes to the class will have unintended consequences. </span><span class="koboSpan" id="kobo.23.3">When a class has only one responsibility, it is also less likely to have bugs, and it is easier to write automated tests </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">for it.</span></span></p>
<p><span class="koboSpan" id="kobo.25.1">Applying the SRP can be a useful way to improve the design of a software system by making it more modular and easier to understand. </span><span class="koboSpan" id="kobo.25.2">By following this principle, a developer can create classes that are small, focused, and easy to reason about. </span><span class="koboSpan" id="kobo.25.3">This makes it easier to maintain and improve the software </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">over time.</span></span></p>
<p><span class="koboSpan" id="kobo.27.1">Let us look at a messaging system that supports multiple message types sent over the network. </span><span class="koboSpan" id="kobo.27.2">The system has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.28.1">Message</span></strong><span class="koboSpan" id="kobo.29.1"> class that receives sender and receiver IDs and raw data to be sent. </span><span class="koboSpan" id="kobo.29.2">Additionally, it supports saving messages to the disk and sending itself via the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.30.1">send</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.31.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.32.1">
class Message {
public:
  Message(SenderId sender_id, ReceiverId receiver_id,
          const RawData&amp; data)
    : sender_id_{sender_id},
      receiver_id_{receiver_id}, raw_data_{data} {}
  SenderId sender_id() const { return sender_id_; }
  ReceiverId receiver_id() const { return receiver_id_; }
  void save(const std::string&amp; file_path) const {
    // serializes a message to raw bytes and saves
    // to file system
  }
  std::string serialize() const {
    // serializes to JSON
    return {"JSON"};
  }
  void send() const {
    auto sender = Communication::get_instance();
    sender.send(sender_id_, receiver_id_, serialize());
  }
private:
  SenderId sender_id_;
  ReceiverId receiver_id_;
  RawData raw_data_;
};</span></pre>
<p><span class="koboSpan" id="kobo.33.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.34.1">Message</span></strong><span class="koboSpan" id="kobo.35.1"> class is responsible for multiple concerns, such as saving messages from/to the filesystem, serializing data, sending messages, and holding the sender and receiver IDs and raw data. </span><span class="koboSpan" id="kobo.35.2">It would be better to separate these responsibilities into different classes </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">or modules.</span></span></p>
<p><span class="koboSpan" id="kobo.37.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.38.1">Message</span></strong><span class="koboSpan" id="kobo.39.1"> class</span><a id="_idIndexMarker036"/><span class="koboSpan" id="kobo.40.1"> is only responsible for storing the data </span><a id="_idIndexMarker037"/><span class="koboSpan" id="kobo.41.1">and serializing it to </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">JSON format:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.43.1">
class Message {
public:
  Message(SenderId sender_id, ReceiverId receiver_id,
          const RawData&amp; data)
    : sender_id_{sender_id},
      receiver_id_{receiver_id}, raw_data_{data} {}
  SenderId sender_id() const { return sender_id_; }
  ReceiverId receiver_id() const { return receiver_id_; }
  std::string serialize() const {
    // serializes to JSON
    return {"JSON"};
  }
private:
  SenderId sender_id_;
  ReceiverId receiver_id_;
  RawData raw_data_;
};</span></pre>
<p><span class="koboSpan" id="kobo.44.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.45.1">save</span></strong><span class="koboSpan" id="kobo.46.1"> method can be extracted to a separate </span><strong class="source-inline"><span class="koboSpan" id="kobo.47.1">MessageSaver</span></strong><span class="koboSpan" id="kobo.48.1"> class, having a </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">single responsibility:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.50.1">
class MessageSaver {
public:
  MessageSaver(const std::string&amp; target_directory);
  void save(const Message&amp; message) const;
};</span></pre>
<p><span class="koboSpan" id="kobo.51.1">And the </span><strong class="source-inline"><span class="koboSpan" id="kobo.52.1">send</span></strong><span class="koboSpan" id="kobo.53.1"> method</span><a id="_idIndexMarker038"/><span class="koboSpan" id="kobo.54.1"> is implemented in a dedicated </span><strong class="source-inline"><span class="koboSpan" id="kobo.55.1">MessageSender</span></strong><span class="koboSpan" id="kobo.56.1"> class. </span><span class="koboSpan" id="kobo.56.2">All three classes have a single and clear responsibility, and any further changes in any of them would not affect the others. </span><span class="koboSpan" id="kobo.56.3">This approach allows isolating the changes in the code base. </span><span class="koboSpan" id="kobo.56.4">It becomes crucial in a complex system requiring </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">long compilation.</span></span></p>
<p><span class="koboSpan" id="kobo.58.1">In summary, the </span><a id="_idIndexMarker039"/><span class="koboSpan" id="kobo.59.1">SRP states that a class should have only one reason to change, meaning that a class should have only one responsibility. </span><span class="koboSpan" id="kobo.59.2">This principle is intended to promote code that is easy to understand, change, and test, and it helps in creating a more modular, maintainable, and scalable code base. </span><span class="koboSpan" id="kobo.59.3">By following this principle, developers can create classes that are small, focused, and easy to </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">reason about.</span></span></p>
<h3><span class="koboSpan" id="kobo.61.1">Other applications of the SRP</span></h3>
<p><span class="koboSpan" id="kobo.62.1">The SRP can </span><a id="_idIndexMarker040"/><span class="koboSpan" id="kobo.63.1">be applied not only to classes but also to larger components, such as applications. </span><span class="koboSpan" id="kobo.63.2">At the architecture level, the SRP is often implemented as microservices architecture. </span><span class="koboSpan" id="kobo.63.3">The idea of microservices is to build a software system as a collection of small, independent services that communicate with each other over a network rather than building it as a monolithic application. </span><span class="koboSpan" id="kobo.63.4">Each microservice is </span><em class="italic"><span class="koboSpan" id="kobo.64.1">responsible for a specific business capability and can be developed, deployed, and scaled independently from the other services</span></em><span class="koboSpan" id="kobo.65.1">. </span><span class="koboSpan" id="kobo.65.2">This allows for greater flexibility, scalability, and ease of maintenance, as changes to one service do not affect the entire system. </span><span class="koboSpan" id="kobo.65.3">Microservices also enable a more agile development process, as teams can work on different services in parallel, and also allows for a more fine-grained approach to security, monitoring, and testing, as each service can be </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">handled individually.</span></span></p>
<h2 id="_idParaDest-31"><a id="_idTextAnchor030"/><span class="koboSpan" id="kobo.67.1">The Open-Closed Principle</span></h2>
<p><span class="koboSpan" id="kobo.68.1">The Open-Closed principle </span><a id="_idIndexMarker041"/><span class="koboSpan" id="kobo.69.1">states that a module or class should be open for extension but closed for modification. </span><span class="koboSpan" id="kobo.69.2">In other words, it </span><a id="_idIndexMarker042"/><span class="koboSpan" id="kobo.70.1">should be possible to add new functionality to a module or class without modifying its existing code. </span><span class="koboSpan" id="kobo.70.2">This principle helps to promote software maintainability and flexibility. </span><span class="koboSpan" id="kobo.70.3">An example of this principle in C++ is the use of inheritance and polymorphism. </span><span class="koboSpan" id="kobo.70.4">A base class can be written with the ability to be extended by derived classes, allowing for new functionality to be added without modifying the base class. </span><span class="koboSpan" id="kobo.70.5">Another example is using interfaces or abstract classes to define a contract for a set of related classes, allowing new classes to be added that conform to the contract without modifying </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">existing code.</span></span></p>
<p><span class="koboSpan" id="kobo.72.1">The Open-closed Principle can be used to improve our message-sending components. </span><span class="koboSpan" id="kobo.72.2">The current version supports only one message type. </span><span class="koboSpan" id="kobo.72.3">If we want to add more data, we need to change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">Message</span></strong><span class="koboSpan" id="kobo.74.1"> class: add fields, hold a message type as an additional variable, and not to mention serialization based on this variable. </span><span class="koboSpan" id="kobo.74.2">In order to avoid changes in existing code, let us rewrite the </span><strong class="source-inline"><span class="koboSpan" id="kobo.75.1">Message</span></strong><span class="koboSpan" id="kobo.76.1"> class to be purely virtual, providing the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">serialize</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.78.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.79.1">
class Message {
public:
  Message(SenderId sender_id, ReceiverId receiver_id)
    : sender_id_{sender_id}, receiver_id_{receiver_id} {}
  SenderId sender_id() const { return sender_id_; }
  ReceiverId receiver_id() const { return receiver_id_; }
  virtual std::string serialize() const = 0;
private:
  SenderId sender_id_;
  ReceiverId receiver_id_;
};</span></pre>
<p><span class="koboSpan" id="kobo.80.1">Now, let us assume that we need to add another two message types: a “start” message supporting start delay (often done for debugging purposes) and a “stop” message supporting </span><a id="_idIndexMarker043"/><span class="koboSpan" id="kobo.81.1">stop delay (can be used for scheduling); they</span><a id="_idIndexMarker044"/><span class="koboSpan" id="kobo.82.1"> can be implemented </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.84.1">
class StartMessage : public Message {
public:
  StartMessage(SenderId sender_id, ReceiverId receiver_id,
               std::chrono::milliseconds start_delay)
    : Message{sender_id, receiver_id},
      start_delay_{start_delay} {}
  std::string serialize() const override {
    return {"naive serialization to JSON"};
  }
private:
  const std::chrono::milliseconds start_delay_;
};
class StopMessage : public Message {
public:
  StopMessage(SenderId sender_id, ReceiverId receiver_id,
              std::chrono::milliseconds stop_delay)
    : Message{sender_id, receiver_id},
      stop_delay_{stop_delay} {}
  std::string serialize() const override {
    return {"naive serialization to JSON"};
  }
private:
  const std::chrono::milliseconds stop_delay_;
};</span></pre>
<p><span class="koboSpan" id="kobo.85.1">Note </span><a id="_idIndexMarker045"/><span class="koboSpan" id="kobo.86.1">that none of the implementations requires changes in other classes, and each of them provides its own version of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">serialize</span></strong><span class="koboSpan" id="kobo.88.1"> method. </span><span class="koboSpan" id="kobo.88.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">MessageSender</span></strong><span class="koboSpan" id="kobo.90.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.91.1">MessageSaver</span></strong><span class="koboSpan" id="kobo.92.1"> classes do not need additional </span><a id="_idIndexMarker046"/><span class="koboSpan" id="kobo.93.1">adjustments to support the new class hierarchy of messages. </span><span class="koboSpan" id="kobo.93.2">However, we are going to change them too. </span><span class="koboSpan" id="kobo.93.3">The main reason is to make them extendable without requiring changes. </span><span class="koboSpan" id="kobo.93.4">For example, a message can be saved not only to the filesystem but also to remote storage. </span><span class="koboSpan" id="kobo.93.5">In this case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">MessageSaver</span></strong><span class="koboSpan" id="kobo.95.1"> becomes </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">purely virtual:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.97.1">
class MessageSaver {
public:
  virtual void save(const Message&amp; message) const = 0;
};</span></pre>
<p><span class="koboSpan" id="kobo.98.1">The implementation responsible for saving to the filesystem is a class derived </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">MessageSaver</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.102.1">
class FilesystemMessageSaver : public MessageSaver {
public:
  FilesystemMessageSaver(const std::string&amp;
    target_directory);
  void save(const Message&amp; message) const override;
};</span></pre>
<p><span class="koboSpan" id="kobo.103.1">And the remote </span><a id="_idIndexMarker047"/><span class="koboSpan" id="kobo.104.1">storage saver is another class in </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">the</span></span><span class="No-Break"><a id="_idIndexMarker048"/></span><span class="No-Break"><span class="koboSpan" id="kobo.106.1"> hierarchy:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.107.1">
class RemoteMessageSaver : public MessageSaver {
public:
    RemoteMessageSaver(const std::string&amp;
      remote_storage_address);
    void save(const Message&amp; message) const override;
};</span></pre>
<h2 id="_idParaDest-32"><a id="_idTextAnchor031"/><span class="koboSpan" id="kobo.108.1">The Liskov Substitution Principle</span></h2>
<p><span class="koboSpan" id="kobo.109.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.110.1">Liskov Substitution Principle</span></strong><span class="koboSpan" id="kobo.111.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.112.1">LSP</span></strong><span class="koboSpan" id="kobo.113.1">) is a fundamental principle in object-oriented </span><a id="_idIndexMarker049"/><span class="koboSpan" id="kobo.114.1">programming that states that </span><a id="_idIndexMarker050"/><span class="koboSpan" id="kobo.115.1">objects of a superclass should be able to be replaced with objects of a subclass without affecting the correctness of the program. </span><span class="koboSpan" id="kobo.115.2">This principle is also known as the Liskov principle, named after Barbara Liskov, who first formulated it. </span><span class="koboSpan" id="kobo.115.3">The LSP is based on the idea of inheritance and polymorphism, where a subclass can inherit the properties and methods of its parent class and can be used interchangeably </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">with it.</span></span></p>
<p><span class="koboSpan" id="kobo.117.1">In order to follow the LSP, subclasses must be “behaviorally compatible” with their parent class. </span><span class="koboSpan" id="kobo.117.2">This means that they should have the same method signatures and follow the same contracts, such as input and output types and ranges. </span><span class="koboSpan" id="kobo.117.3">Additionally, the behavior of a method in a subclass should not violate any of the contracts established in the </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">parent class.</span></span></p>
<p><span class="koboSpan" id="kobo.119.1">Let’s consider a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">Message</span></strong><span class="koboSpan" id="kobo.121.1"> type, </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">InternalMessage</span></strong><span class="koboSpan" id="kobo.123.1">, which does not support the </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">serialize</span></strong><span class="koboSpan" id="kobo.125.1"> method. </span><span class="koboSpan" id="kobo.125.2">One might be tempted to implement it in the </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">following way:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.127.1">
class InternalMessage : public Message {
public:
    InternalMessage(SenderId sender_id, ReceiverId
      receiver_id)
        : Message{sender_id, receiver_id} {}
    std::string serialize() const override {
        throw std::runtime_error{"InternalMessage can't be
          serialized!"};
    }
};</span></pre>
<p><span class="koboSpan" id="kobo.128.1">In the</span><a id="_idIndexMarker051"/><span class="koboSpan" id="kobo.129.1"> preceding code, </span><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">InternalMessage</span></strong><span class="koboSpan" id="kobo.131.1"> is a subtype of </span><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">Message</span></strong><span class="koboSpan" id="kobo.133.1"> but cannot be serialized, throwing an exception instead. </span><span class="koboSpan" id="kobo.133.2">This </span><a id="_idIndexMarker052"/><span class="koboSpan" id="kobo.134.1">design is problematic for a </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">few reasons:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.136.1">It breaks the Liskov Substitution Principle</span></strong><span class="koboSpan" id="kobo.137.1">: As per the LSP, if </span><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">InternalMessage</span></strong><span class="koboSpan" id="kobo.139.1"> is a subtype of </span><strong class="source-inline"><span class="koboSpan" id="kobo.140.1">Message</span></strong><span class="koboSpan" id="kobo.141.1">, then we should be able to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">InternalMessage</span></strong><span class="koboSpan" id="kobo.143.1"> wherever </span><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">Message</span></strong><span class="koboSpan" id="kobo.145.1"> is expected without affecting the correctness of the program. </span><span class="koboSpan" id="kobo.145.2">By throwing an exception in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">serialize</span></strong><span class="koboSpan" id="kobo.147.1"> method, we are breaking </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">this principle.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.149.1">The caller must handle exceptions</span></strong><span class="koboSpan" id="kobo.150.1">: The caller of </span><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">serialize</span></strong><span class="koboSpan" id="kobo.152.1"> must handle exceptions, which might not have been necessary when dealing with other </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">Message</span></strong><span class="koboSpan" id="kobo.154.1"> types. </span><span class="koboSpan" id="kobo.154.2">This introduces additional complexity and the potential for errors in the </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">caller code.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.156.1">Program crashes</span></strong><span class="koboSpan" id="kobo.157.1">: If the exception is not properly handled, it could lead to the program crashing, which is certainly not a </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">desirable outcome.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.159.1">We could return an empty string instead of throwing an exception, but this still violates the LSP, as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">serialize</span></strong><span class="koboSpan" id="kobo.161.1"> method is expected to return a serialized message, not an empty string. </span><span class="koboSpan" id="kobo.161.2">It also introduces ambiguity, as it’s not clear whether an empty string is the result of a successful serialization of a message with no data or an unsuccessful serialization </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">InternalMessage</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.165.1">A better approach is to separate the concerns of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">Message</span></strong><span class="koboSpan" id="kobo.167.1"> and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">SerializableMessage</span></strong><span class="koboSpan" id="kobo.169.1">, where only </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">SerializableMessage</span></strong><span class="koboSpan" id="kobo.171.1">s have a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">serialize</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.173.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.174.1">
class Message {
public:
    virtual ~Message() = default;
    // other common message behaviors
};
class SerializableMessage : public Message {
public:
    virtual std::string serialize() const = 0;
};
class StartMessage : public SerializableMessage {
    // ...
</span><span class="koboSpan" id="kobo.174.2">};
class StopMessage : public SerializableMessage {
    // ...
</span><span class="koboSpan" id="kobo.174.3">};
class InternalMessage : public Message {
    // InternalMessage doesn't have serialize method now.
</span><span class="koboSpan" id="kobo.174.4">};</span></pre>
<p><span class="koboSpan" id="kobo.175.1">In</span><a id="_idIndexMarker053"/><span class="koboSpan" id="kobo.176.1"> this </span><a id="_idIndexMarker054"/><span class="koboSpan" id="kobo.177.1">corrected design, the base </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">Message</span></strong><span class="koboSpan" id="kobo.179.1"> class does not include a </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">serialize</span></strong><span class="koboSpan" id="kobo.181.1"> method, and a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">SerializableMessage</span></strong><span class="koboSpan" id="kobo.183.1"> class has been introduced that includes this method. </span><span class="koboSpan" id="kobo.183.2">This way, only messages that can be serialized will inherit from </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">SerializableMessage</span></strong><span class="koboSpan" id="kobo.185.1">, and we adhere to </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">the LSP.</span></span></p>
<p><span class="koboSpan" id="kobo.187.1">Adhering to </span><a id="_idIndexMarker055"/><span class="koboSpan" id="kobo.188.1">the LSP allows for more flexible and maintainable </span><a id="_idIndexMarker056"/><span class="koboSpan" id="kobo.189.1">code, as it enables the use of polymorphism and allows for substituting objects of a class with objects of its subclasses without affecting the overall behavior of the program. </span><span class="koboSpan" id="kobo.189.2">This way, the program can take advantage of the new functionality provided by the subclass while maintaining the same behavior as </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">the superclass.</span></span></p>
<p><span class="koboSpan" id="kobo.191.1">The Interface </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">Segregation Principle</span></span></p>
<p><span class="koboSpan" id="kobo.193.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.194.1">Interface Segregation Principle</span></strong><span class="koboSpan" id="kobo.195.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.196.1">ISP</span></strong><span class="koboSpan" id="kobo.197.1">) is a principle in object-oriented programming </span><a id="_idIndexMarker057"/><span class="koboSpan" id="kobo.198.1">that states that a class </span><a id="_idIndexMarker058"/><span class="koboSpan" id="kobo.199.1">should only implement the interfaces it uses. </span><span class="koboSpan" id="kobo.199.2">In other words, it suggests that interfaces should be fine-grained and client-specific rather than having a single, large, and all-encompassing interface. </span><span class="koboSpan" id="kobo.199.3">The ISP is based on the idea that it is better to have many small interfaces that each define a specific set of methods rather than a single large interface that defines </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">many methods.</span></span></p>
<p><span class="koboSpan" id="kobo.201.1">One of the key benefits of the ISP is that it promotes a more modular and flexible design, as it allows for the creation of interfaces that are tailored to the specific needs of a client. </span><span class="koboSpan" id="kobo.201.2">This way, it reduces the number of unnecessary methods that a client needs to implement, and also it reduces the risk of a client depending on methods that it does </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">not need.</span></span></p>
<p><span class="koboSpan" id="kobo.203.1">An example of the ISP can be observed when creating our example messages from MessagePack or JSON files. </span><span class="koboSpan" id="kobo.203.2">Following the best practices, we would create an interface providing two methods, </span><strong class="source-inline"><span class="koboSpan" id="kobo.204.1">from_message_pack</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.205.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">from_json</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.208.1">The current implementations need to implement both methods, but what if a particular class does not need to support both options? </span><span class="koboSpan" id="kobo.208.2">The smaller the interface, the better. </span><span class="koboSpan" id="kobo.208.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">MessageParser</span></strong><span class="koboSpan" id="kobo.210.1"> interface will be split into two separate interfaces, each requiring the implementation of either JSON </span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">or MessagePack:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.212.1">
class JsonMessageParser {
public:
  virtual std::unique_ptr&lt;Message&gt;
  parse(const std::vector&lt;uint8_t&gt;&amp; message_pack)
    const = 0;
};
class MessagePackMessageParser {
public:
  virtual std::unique_ptr&lt;Message&gt;
  parse(const std::vector&lt;uint8_t&gt;&amp; message_pack)
    const = 0;
};</span></pre>
<p><span class="koboSpan" id="kobo.213.1">This </span><a id="_idIndexMarker059"/><span class="koboSpan" id="kobo.214.1">design allows for objects </span><a id="_idIndexMarker060"/><span class="koboSpan" id="kobo.215.1">derived from </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">JsonMessageParser</span></strong><span class="koboSpan" id="kobo.217.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">MessagePackMessageParser</span></strong><span class="koboSpan" id="kobo.219.1"> to understand how to construct themselves from JSON and MessagePack, respectively, while preserving the independence and functionality of each function. </span><span class="koboSpan" id="kobo.219.2">The system remains flexible as new smaller objects can still be composed to achieve the </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">desired functionality.</span></span></p>
<p><span class="koboSpan" id="kobo.221.1">Adhering to the ISP makes the code more maintainable and less prone to errors, as it reduces the number of unnecessary methods that a client needs to implement, and it also reduces the risk of a client depending on methods that it does </span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">not need.</span></span></p>
<h2 id="_idParaDest-33"><a id="_idTextAnchor032"/><span class="koboSpan" id="kobo.223.1">The Dependency inversion principle</span></h2>
<p><span class="koboSpan" id="kobo.224.1">The </span><a id="_idIndexMarker061"/><span class="koboSpan" id="kobo.225.1">Dependency inversion principle is </span><a id="_idIndexMarker062"/><span class="koboSpan" id="kobo.226.1">based on the idea that it is better to depend on abstractions rather than on concrete implementations, as it allows for greater flexibility and maintainability. </span><span class="koboSpan" id="kobo.226.2">It allows the decoupling of high-level modules from low-level modules, making them more independent and less prone to changes in the low-level modules. </span><span class="koboSpan" id="kobo.226.3">This way, it makes it easy to change low-level implementations without affecting high-level modules and </span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">vice versa.</span></span></p>
<p><span class="koboSpan" id="kobo.228.1">The DIP can be illustrated for our messaging system if we try to use all the components via another class. </span><span class="koboSpan" id="kobo.228.2">Let us assume that there is a class responsible for message routing. </span><span class="koboSpan" id="kobo.228.3">In order to build such a class, we are</span><a id="_idIndexMarker063"/><span class="koboSpan" id="kobo.229.1"> going to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">MessageSender</span></strong><span class="koboSpan" id="kobo.231.1"> as a communication module, </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">Message</span></strong><span class="koboSpan" id="kobo.233.1"> based </span><a id="_idIndexMarker064"/><span class="koboSpan" id="kobo.234.1">classes, </span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">MessageSaver</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.238.1">
class MessageRouter {
public:
  MessageRouter(ReceiverId id)
    : id_{id} {}
  void route(const Message&amp; message) const {
    if (message.receiver_id() == id_) {
      handler_.handle(message);
    } else {
      try {
        sender_.send(message);
      } catch (const CommunicationError&amp; e) {
        saver_.save(message);
      }
    }
  }
private:
  const ReceiverId id_;
  const MessageHandler handler_;
  const MessageSender sender_;
  const MessageSaver saver_;
};</span></pre>
<p><span class="koboSpan" id="kobo.239.1">The new class provides only one </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">route</span></strong><span class="koboSpan" id="kobo.241.1"> method, which is called once a new message is available. </span><span class="koboSpan" id="kobo.241.2">The router handles the message to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">MessageHandler</span></strong><span class="koboSpan" id="kobo.243.1"> class if the message’s sender ID equals the router’s. </span><span class="koboSpan" id="kobo.243.2">Otherwise, the router forwards the message to the corresponding receiver. </span><span class="koboSpan" id="kobo.243.3">In case the delivery of the message fails and the communication layer throws an exception, the router saves the message via </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">MessageSaver</span></strong><span class="koboSpan" id="kobo.245.1">. </span><span class="koboSpan" id="kobo.245.2">Those messages will be delivered some </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">other time.</span></span></p>
<p><span class="koboSpan" id="kobo.247.1">The only problem is that </span><a id="_idIndexMarker065"/><span class="koboSpan" id="kobo.248.1">if any dependency needs to be changed, the router’s code has to be updated accordingly. </span><span class="koboSpan" id="kobo.248.2">For example, if the application needs to support several types of senders (TCP and UDP), the message saver (filesystem versus remote) or message handler’s logic changes. </span><span class="koboSpan" id="kobo.248.3">In order to make </span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">MessageRouter</span></strong><span class="koboSpan" id="kobo.250.1"> agnostic to such changes, we </span><a id="_idIndexMarker066"/><span class="koboSpan" id="kobo.251.1">can rewrite it using the </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">DIP principle:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.253.1">
class BaseMessageHandler {
public:
    virtual ~BaseMessageHandler() {}
    virtual void handle(const Message&amp; message) const = 0;
};
class BaseMessageSender {
public:
    virtual ~BaseMessageSender() {}
    virtual void send(const Message&amp; message) const = 0;
};
class BaseMessageSaver {
public:
    virtual ~BaseMessageSaver() {}
    virtual void save(const Message&amp; message) const = 0;
};
class MessageRouter {
public:
    MessageRouter(ReceiverId id,
                  const BaseMessageHandler&amp; handler,
                  const BaseMessageSender&amp; sender,
                  const BaseMessageSaver&amp; saver)
        : id_{id}, handler_{handler}, sender_{sender},
          saver_{saver} {}
    void route(const Message&amp; message) const {
        if (message.receiver_id() == id_) {
            handler_.handle(message);
        } else {
            try {
                sender_.send(message);
            } catch (const CommunicationError&amp; e) {
                saver_.save(message);
            }
        }
    }
private:
    ReceiverId id_;
    const BaseMessageHandler&amp; handler_;
    const BaseMessageSender&amp; sender_;
    const BaseMessageSaver&amp; saver_;
};
int main() {
  auto id      = ReceiverId{42};
  auto handler = MessageHandler{};
  auto sender = MessageSender{
    Communication::get_instance()};
  auto saver =
    FilesystemMessageSaver{"/tmp/undelivered_messages"};
  auto router = MessageRouter{id, sender, saver};
}</span></pre>
<p><span class="koboSpan" id="kobo.254.1">In this</span><a id="_idIndexMarker067"/><span class="koboSpan" id="kobo.255.1"> revised version of the code, </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">MessageRouter</span></strong><span class="koboSpan" id="kobo.257.1"> is now</span><a id="_idIndexMarker068"/><span class="koboSpan" id="kobo.258.1"> decoupled from specific implementations of the message handling, sending, and saving logic. </span><span class="koboSpan" id="kobo.258.2">Instead, it relies on abstractions represented by </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">BaseMessageHandler</span></strong><span class="koboSpan" id="kobo.260.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">BaseMessageSender</span></strong><span class="koboSpan" id="kobo.262.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">BaseMessageSaver</span></strong><span class="koboSpan" id="kobo.264.1">. </span><span class="koboSpan" id="kobo.264.2">This way, any class that derives from these base classes can be used with </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">MessageRouter</span></strong><span class="koboSpan" id="kobo.266.1">, which makes the code more flexible and easier to extend in the future. </span><span class="koboSpan" id="kobo.266.2">The router is not concerned with the specifics of how messages are handled, sent, or saved – it only needs to know that these operations can </span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">be performed.</span></span></p>
<p><span class="koboSpan" id="kobo.268.1">Adhering to the DIP makes code more maintainable and less prone to errors. </span><span class="koboSpan" id="kobo.268.2">It decouples high-level modules from low-level modules, making them more independent and less prone to changes in low-level modules. </span><span class="koboSpan" id="kobo.268.3">It also allows for greater flexibility, making it easy to change low-level implementations without affecting high-level modules and vice versa. </span><span class="koboSpan" id="kobo.268.4">Later in this book, dependency inversion will help us mock parts of the system while developing </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">unit tests.</span></span></p>
<h1 id="_idParaDest-34"><a id="_idTextAnchor033"/><span class="koboSpan" id="kobo.270.1">The KISS principle</span></h1>
<p><span class="koboSpan" id="kobo.271.1">The KISS principle, which </span><a id="_idIndexMarker069"/><span class="koboSpan" id="kobo.272.1">stands for “Keep It Simple, Stupid,” is a design philosophy that emphasizes the importance of keeping things simple and straightforward. </span><span class="koboSpan" id="kobo.272.2">This principle is particularly relevant in the world of programming, where complex code can lead to bugs, confusion, and slow </span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">development time.</span></span></p>
<p><span class="koboSpan" id="kobo.274.1">Here are some examples</span><a id="_idIndexMarker070"/><span class="koboSpan" id="kobo.275.1"> of how the KISS principle can be applied </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">in C++:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.277.1">Avoid Overcomplicating Code</span></strong><span class="koboSpan" id="kobo.278.1">: In C++, it’s easy to get carried away with complex algorithms, data structures, and design patterns. </span><span class="koboSpan" id="kobo.278.2">However, these advanced techniques can lead to code that is harder to understand and debug. </span><span class="koboSpan" id="kobo.278.3">Instead, try to simplify the code as much as possible. </span><span class="koboSpan" id="kobo.278.4">For example, using a simple </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">for</span></strong><span class="koboSpan" id="kobo.280.1"> loop instead of a complex algorithm can often be just as effective and much easier </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">to understand.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.282.1">Keep Functions Small</span></strong><span class="koboSpan" id="kobo.283.1">: Functions in C++ should be small, focused, and easy to understand. </span><span class="koboSpan" id="kobo.283.2">Complex functions can quickly become difficult to maintain and debug, so try to keep functions as simple and concise as possible. </span><span class="koboSpan" id="kobo.283.3">A good rule of thumb is to aim for functions that are no longer than 30-50 lines </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">of code.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.285.1">Use Clear and Concise Variable Names</span></strong><span class="koboSpan" id="kobo.286.1">: In C++, variable names play a crucial role in making code readable and understandable. </span><span class="koboSpan" id="kobo.286.2">Avoid using abbreviations and instead opt for clear and concise names that accurately describe the purpose of </span><span class="No-Break"><span class="koboSpan" id="kobo.287.1">the variable.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.288.1">Avoid Deep Nesting</span></strong><span class="koboSpan" id="kobo.289.1">: Nested loops and conditional statements can make code hard to read and follow. </span><span class="koboSpan" id="kobo.289.2">Try to keep the nesting levels as shallow as possible, and consider breaking up complex functions into smaller, </span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">simpler functions.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.291.1">Write Simple, Readable Code</span></strong><span class="koboSpan" id="kobo.292.1">: Above all, aim to write code that is easy to understand and follow. </span><span class="koboSpan" id="kobo.292.2">This means using clear and concise language and avoiding complicated expressions and structures. </span><span class="koboSpan" id="kobo.292.3">Code that is simple and easy to follow is much more likely to be maintainable </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">and bug-free.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.294.1">Avoid Complex Inheritance Hierarchy</span></strong><span class="koboSpan" id="kobo.295.1">: Complex inheritance hierarchies can make code more difficult to understand, debug, and maintain. </span><span class="koboSpan" id="kobo.295.2">The more complex the</span><a id="_idIndexMarker071"/><span class="koboSpan" id="kobo.296.1"> inheritance structure, the harder it becomes to keep track of the relationships between classes and determine how changes will affect the rest of </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">the code.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.298.1">In conclusion, the KISS principle is a simple and straightforward design philosophy that can help developers write clear, concise, and maintainable code. </span><span class="koboSpan" id="kobo.298.2">By keeping things simple, developers can avoid bugs and confusion and speed up </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">development time.</span></span></p>
<h2 id="_idParaDest-35"><a id="_idTextAnchor034"/><span class="koboSpan" id="kobo.300.1">The KISS and SOLID Principles together</span></h2>
<p><span class="koboSpan" id="kobo.301.1">The </span><a id="_idIndexMarker072"/><span class="koboSpan" id="kobo.302.1">SOLID principles and the KISS principle are both important design philosophies in software development, but they can sometimes contradict </span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">each other.</span></span></p>
<p><span class="koboSpan" id="kobo.304.1">The </span><a id="_idIndexMarker073"/><span class="koboSpan" id="kobo.305.1">SOLID principles are a set of five principles that guide the design of software, aimed at making it more maintainable, scalable, and flexible. </span><span class="koboSpan" id="kobo.305.2">They focus on creating a clean, modular architecture that follows good object-oriented </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">design practices.</span></span></p>
<p><span class="koboSpan" id="kobo.307.1">The KISS principle, on the other hand, is all about keeping things simple. </span><span class="koboSpan" id="kobo.307.2">It advocates for straightforward, simple solutions, avoiding complex algorithms and structures that can make code hard to understand </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">and maintain.</span></span></p>
<p><span class="koboSpan" id="kobo.309.1">While both SOLID and KISS aim to improve software quality, they can sometimes be at odds. </span><span class="koboSpan" id="kobo.309.2">For example, following the SOLID principles may result in code that is more complex and harder to understand to achieve greater modularity and maintainability. </span><span class="koboSpan" id="kobo.309.3">Similarly, the KISS principle may result in less flexible and scalable code to keep it simple </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">and straightforward.</span></span></p>
<p><span class="koboSpan" id="kobo.311.1">In practice, developers often have to strike a balance between the SOLID principles and the KISS principle. </span><span class="koboSpan" id="kobo.311.2">On the one hand, they want to write code that is maintainable, scalable, and flexible. </span><span class="koboSpan" id="kobo.311.3">On the other hand, they want to write code that is simple and easy to understand. </span><span class="koboSpan" id="kobo.311.4">Finding this balance requires careful consideration of trade-offs and an understanding of when each approach is </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">most appropriate.</span></span></p>
<p><span class="koboSpan" id="kobo.313.1">When I have to choose between the SOLID and KISS approaches, I think about something my boss, Amir Taya, said, “When building a Ferrari, you need to start from a scooter.” </span><span class="koboSpan" id="kobo.313.2">This</span><a id="_idIndexMarker074"/><span class="koboSpan" id="kobo.314.1"> phrase is an exaggerated example of KISS: if </span><a id="_idIndexMarker075"/><span class="koboSpan" id="kobo.315.1">you do not know how to build a feature, make the simplest working version (KISS), re-iterate, and extend the solution using SOLID principles </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">if needed.</span></span></p>
<h1 id="_idParaDest-36"><a id="_idTextAnchor035"/><span class="koboSpan" id="kobo.317.1">Side effects and immutability</span></h1>
<p><span class="koboSpan" id="kobo.318.1">Side effects and immutability are two important concepts in programming that have a significant impact on the quality and maintainability </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">of code.</span></span></p>
<p><span class="koboSpan" id="kobo.320.1">Side effects </span><a id="_idIndexMarker076"/><span class="koboSpan" id="kobo.321.1">refer to changes that occur in the state of the program as a result of executing a particular function or piece of code. </span><span class="koboSpan" id="kobo.321.2">Side effects can be explicit, such as writing data to a file or updating a variable, or implicit, such as modifying the global state or causing unexpected behavior in other parts of </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">the code.</span></span></p>
<p><span class="koboSpan" id="kobo.323.1">Immutability, on</span><a id="_idIndexMarker077"/><span class="koboSpan" id="kobo.324.1"> the other hand, refers to the property of a variable or data structure that cannot be modified after it has been created. </span><span class="koboSpan" id="kobo.324.2">In functional programming, immutability is achieved by making data structures and variables constant and avoiding </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">side effects.</span></span></p>
<p><span class="koboSpan" id="kobo.326.1">The importance of avoiding side effects and using immutable variables lies in the fact that they make code easier to understand, debug, and maintain. </span><span class="koboSpan" id="kobo.326.2">When code has few side effects, it is easier to reason about what it does and what it does not do. </span><span class="koboSpan" id="kobo.326.3">This makes finding and fixing bugs and making changes to the code easier without affecting other parts of </span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">the system.</span></span></p>
<p><span class="koboSpan" id="kobo.328.1">In contrast, code with many side effects is harder to understand, as the state of the program can change in unexpected ways. </span><span class="koboSpan" id="kobo.328.2">This makes it more difficult to debug and maintain and can lead to bugs and </span><span class="No-Break"><span class="koboSpan" id="kobo.329.1">unexpected behavior.</span></span></p>
<p><span class="koboSpan" id="kobo.330.1">Functional programming languages have long emphasized the use of immutability and the avoidance of side effects, but it is now possible to write code with these properties using C++. </span><span class="koboSpan" id="kobo.330.2">The easiest way to achieve it is</span><a id="_idIndexMarker078"/><span class="koboSpan" id="kobo.331.1"> to follow the </span><strong class="bold"><span class="koboSpan" id="kobo.332.1">C++ Core Guidelines for Constants </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.333.1">and Immutability</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.334.1">.</span></span></p>
<h2 id="_idParaDest-37"><a id="_idTextAnchor036"/><span class="koboSpan" id="kobo.335.1">Con.1 – by default, make objects immutable</span></h2>
<p><span class="koboSpan" id="kobo.336.1">You can declare</span><a id="_idIndexMarker079"/><span class="koboSpan" id="kobo.337.1"> a built-in data type or an instance of a user-defined data type as constant, resulting in the same effect. </span><span class="koboSpan" id="kobo.337.2">Attempting to modify it will result in a </span><span class="No-Break"><span class="koboSpan" id="kobo.338.1">compiler error:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.339.1">
struct Data {
  int val{42};
};
int main() {
  const Data data;
  data.val = 43; // assignment of member 'Data::val' in
                 // read-only object
  const int val{42};
  val = 43; // assignment of read-only variable 'val'
}</span></pre>
<p><span class="koboSpan" id="kobo.340.1">The same applies </span><span class="No-Break"><span class="koboSpan" id="kobo.341.1">to loops:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.342.1">
for (const int i : array) {
  std::cout &lt;&lt; i &lt;&lt; std::endl; // just reading: const
}
for (int i : array) {
  std::cout &lt;&lt; i &lt;&lt; std::endl; // just reading: non-const
}</span></pre>
<p><span class="koboSpan" id="kobo.343.1">This approach allows the prevention of hard-to-notice changes </span><span class="No-Break"><span class="koboSpan" id="kobo.344.1">of value.</span></span></p>
<p><span class="koboSpan" id="kobo.345.1">Probably, the only exception is function parameters passed </span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">by value:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.347.1">
void foo(const int value);</span></pre>
<p><span class="koboSpan" id="kobo.348.1">Such parameters are rarely passed as </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">const</span></strong><span class="koboSpan" id="kobo.350.1"> and rarely mutated. </span><span class="koboSpan" id="kobo.350.2">In order to avoid confusion, it is recommended not to enforce this rule in </span><span class="No-Break"><span class="koboSpan" id="kobo.351.1">such cases.</span></span></p>
<h2 id="_idParaDest-38"><a id="_idTextAnchor037"/><span class="koboSpan" id="kobo.352.1">Con.2 – by default, make member functions const</span></h2>
<p><span class="koboSpan" id="kobo.353.1">A member </span><a id="_idIndexMarker080"/><span class="koboSpan" id="kobo.354.1">function (method) shall be marked as </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">const</span></strong><span class="koboSpan" id="kobo.356.1"> unless it changes the observable state of an object. </span><span class="koboSpan" id="kobo.356.2">The reason behind this is to give a more precise statement of design intent, better readability, maintainability, more errors caught by the compiler, and theoretically more </span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">optimization opportunities:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.358.1">
class Book {
public:
  std::string name() { return name_; }
private:
  std::string name_;
};
void print(const Book&amp; book) {
  cout &lt;&lt; book.name()
       &lt;&lt; endl; // ERROR: 'this' argument to member
                // function
                // 'name' has type 'const Book', but
                // function is not marked
                // const clang(member_function_call_bad_cvr)
}</span></pre>
<p><span class="koboSpan" id="kobo.359.1">There are two types of constness: </span><strong class="bold"><span class="koboSpan" id="kobo.360.1">physical</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.361.1">and </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.362.1">logical</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">:</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.364.1">Physical constness</span></strong><span class="koboSpan" id="kobo.365.1">: An</span><a id="_idIndexMarker081"/><span class="koboSpan" id="kobo.366.1"> object is declared </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">const</span></strong><span class="koboSpan" id="kobo.368.1"> and cannot </span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">be changed.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.370.1">Logical constness</span></strong><span class="koboSpan" id="kobo.371.1">: An </span><a id="_idIndexMarker082"/><span class="koboSpan" id="kobo.372.1">object is declared </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">const</span></strong><span class="koboSpan" id="kobo.374.1"> but can </span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">be changed.</span></span></p>
<p><span class="koboSpan" id="kobo.376.1">Logical constness </span><a id="_idIndexMarker083"/><span class="koboSpan" id="kobo.377.1">can be achieved with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">mutable</span></strong><span class="koboSpan" id="kobo.379.1"> keyword. </span><span class="koboSpan" id="kobo.379.2">In general, it is a rare use case. </span><span class="koboSpan" id="kobo.379.3">The only good example I can think of is storing in an internal cache or using </span><span class="No-Break"><span class="koboSpan" id="kobo.380.1">a mutex:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.381.1">
class DataReader {
public:
  Data read() const {
    auto lock = std::lock_guard&lt;std::mutex&gt;(mutex);
    // read data
    return Data{};
  }
private:
  mutable std::mutex mutex;
};</span></pre>
<p><span class="koboSpan" id="kobo.382.1">In this example, we need to change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">mutex</span></strong><span class="koboSpan" id="kobo.384.1"> variable to lock it, but this does not affect the logical constness of </span><span class="No-Break"><span class="koboSpan" id="kobo.385.1">the object.</span></span></p>
<p><span class="koboSpan" id="kobo.386.1">Please be aware that there exist legacy codes/libraries that provide functions that declare  </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">T*</span></strong><span class="koboSpan" id="kobo.388.1">, despite not making any changes to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">T</span></strong><span class="koboSpan" id="kobo.390.1">. </span><span class="koboSpan" id="kobo.390.2">This presents an issue for individuals who are trying to mark all logically constant methods as </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">const</span></strong><span class="koboSpan" id="kobo.392.1">. </span><span class="koboSpan" id="kobo.392.2">In order to enforce constness, you can do </span><span class="No-Break"><span class="koboSpan" id="kobo.393.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.394.1">Update the library/code to be const-correct, which is the </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">preferred solution.</span></span></li>
<li><span class="koboSpan" id="kobo.396.1">Provide a wrapper function casting away </span><span class="No-Break"><span class="koboSpan" id="kobo.397.1">the constness.</span></span></li>
</ul>
<p><span class="No-Break"><span class="koboSpan" id="kobo.398.1">Example</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.399.1">
void read_data(int* data); // Legacy code: read_data does
                           // not modify `*data`
void read_data(const int* data) {
  read_data(const_cast&lt;int*&gt;(data));
}</span></pre>
<p><span class="koboSpan" id="kobo.400.1">Note that this </span><a id="_idIndexMarker084"/><span class="koboSpan" id="kobo.401.1">solution is a patch that can be used only when the declaration of </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">read_data</span></strong><span class="koboSpan" id="kobo.403.1"> cannot </span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">be modified.</span></span></p>
<h2 id="_idParaDest-39"><a id="_idTextAnchor038"/><span class="koboSpan" id="kobo.405.1">Con.3 – by default, pass pointers and references to const</span></h2>
<p><span class="koboSpan" id="kobo.406.1">This one is easy; it is far easier to reason about programs when called functions do not </span><span class="No-Break"><span class="koboSpan" id="kobo.407.1">modify state.</span></span></p>
<p><span class="koboSpan" id="kobo.408.1">Let us look at the two </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">following functions:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.410.1">
void foo(char* p);
void bar(const char* p);</span></pre>
<p><span class="koboSpan" id="kobo.411.1">Does the </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">foo</span></strong><span class="koboSpan" id="kobo.413.1"> function modify the data the </span><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">p</span></strong><span class="koboSpan" id="kobo.415.1"> pointer points to? </span><span class="koboSpan" id="kobo.415.2">We cannot answer by looking at the declaration, so we assume it does by default. </span><span class="koboSpan" id="kobo.415.3">However, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">bar</span></strong><span class="koboSpan" id="kobo.417.1"> function states explicitly that the content of </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">p</span></strong><span class="koboSpan" id="kobo.419.1"> will not </span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">be changed.</span></span></p>
<h2 id="_idParaDest-40"><a id="_idTextAnchor039"/><span class="koboSpan" id="kobo.421.1">Con.4 – use const to define objects with values that do not change after construction</span></h2>
<p><span class="koboSpan" id="kobo.422.1">This rule is very similar to the first one, enforcing the constness of objects that are not expected to be changed in the future. </span><span class="koboSpan" id="kobo.422.2">It is often helpful with classes such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">Config</span></strong><span class="koboSpan" id="kobo.424.1"> that are created at the beginning of the application and not changed during </span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">its lifetime:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.426.1">
class Config {
public:
  std::string hostname() const;
  uint16_t port() const;
};
int main(int argc, char* argv[]) {
  const Config config = parse_args(argc, argv);
  run(config);
}</span></pre>
<h2 id="_idParaDest-41"><a id="_idTextAnchor040"/><span class="koboSpan" id="kobo.427.1">Con.5 – use constexpr for values that can be computed at compile time</span></h2>
<p><span class="koboSpan" id="kobo.428.1">Declaring </span><a id="_idIndexMarker085"/><span class="koboSpan" id="kobo.429.1">variables as </span><strong class="source-inline"><span class="koboSpan" id="kobo.430.1">constexpr</span></strong><span class="koboSpan" id="kobo.431.1"> is preferred over </span><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">const</span></strong><span class="koboSpan" id="kobo.433.1"> if the value is computed at compile time. </span><span class="koboSpan" id="kobo.433.2">It provides such benefits as better performance, better compile-time checking, guaranteed compile-time evaluation, and no possibility of </span><span class="No-Break"><span class="koboSpan" id="kobo.434.1">race conditions.</span></span></p>
<h2 id="_idParaDest-42"><a id="_idTextAnchor041"/><span class="koboSpan" id="kobo.435.1">Constness and data races</span></h2>
<p><span class="koboSpan" id="kobo.436.1">Data races occur </span><a id="_idIndexMarker086"/><span class="koboSpan" id="kobo.437.1">when multiple threads access a shared variable simultaneously, and </span><a id="_idIndexMarker087"/><span class="koboSpan" id="kobo.438.1">at least one tries to modify it. </span><span class="koboSpan" id="kobo.438.2">There are synchronization primitives such as mutexes, critical sections, spinlocks, and semaphores, allowing the prevention of data races. </span><span class="koboSpan" id="kobo.438.3">The</span><a id="_idIndexMarker088"/><span class="koboSpan" id="kobo.439.1"> problem with these primitives is that they either do expensive system calls or overuse the CPU, which makes the code less efficient. </span><span class="koboSpan" id="kobo.439.2">However, if none of the threads modifies the variable, there is no place for data races. </span><span class="koboSpan" id="kobo.439.3">We learned that </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">constexpr</span></strong><span class="koboSpan" id="kobo.441.1"> is thread-safe (does not need synchronization) because it is defined at compile time. </span><span class="koboSpan" id="kobo.441.2">What about </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">const</span></strong><span class="koboSpan" id="kobo.443.1">? </span><span class="koboSpan" id="kobo.443.2">It can be thread-safe under the </span><span class="No-Break"><span class="koboSpan" id="kobo.444.1">below conditions.</span></span></p>
<p><span class="koboSpan" id="kobo.445.1">The variable has been </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">const</span></strong><span class="koboSpan" id="kobo.447.1"> since its creation. </span><span class="koboSpan" id="kobo.447.2">If a thread has direct or indirect (via a pointer or reference) non-const access to the variable, all the readers need to use mutexes. </span><span class="koboSpan" id="kobo.447.3">The following code snippet illustrates constant and non-constant access from </span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">multiple threads:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.449.1">
void a() {
  auto value = int{42};
  auto t = std::thread([&amp;]() { std::cout &lt;&lt; value; });
  t.join();
}
void b() {
  auto value = int{42};
  auto t = std::thread([&amp;value = std::as_const(value)]() {
    std::cout &lt;&lt; value;
  });
  t.join();
}
void c() {
  const auto value = int{42};
  auto t = std::thread([&amp;]() {
      auto v = const_cast&lt;int&amp;&gt;(value);
      std::cout &lt;&lt; v;
  });
  t.join();
}
void d() {
  const auto value = int{42};
  auto t = std::thread([&amp;]() { std::cout &lt;&lt; value; });
  t.join();
}</span></pre>
<p><span class="koboSpan" id="kobo.450.1">In </span><a id="_idIndexMarker089"/><span class="koboSpan" id="kobo.451.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">a</span></strong><span class="koboSpan" id="kobo.453.1"> function, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">value</span></strong><span class="koboSpan" id="kobo.455.1"> variable is owned as non-constant by both the main thread and </span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">t</span></strong><span class="koboSpan" id="kobo.457.1">, which makes the code potentially not thread-safe (if a developer decides to change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">value</span></strong><span class="koboSpan" id="kobo.459.1"> later in the main thread). </span><span class="koboSpan" id="kobo.459.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">b</span></strong><span class="koboSpan" id="kobo.461.1">, the main thread has “write” access to </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">value</span></strong><span class="koboSpan" id="kobo.463.1"> while </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">t</span></strong><span class="koboSpan" id="kobo.465.1"> receives it via a </span><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">const</span></strong><span class="koboSpan" id="kobo.467.1"> reference, but still, it is not thread-safe. </span><span class="koboSpan" id="kobo.467.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">c</span></strong><span class="koboSpan" id="kobo.469.1"> function is an example of very bad code: the </span><strong class="source-inline"><span class="koboSpan" id="kobo.470.1">value</span></strong><span class="koboSpan" id="kobo.471.1"> is created as a constant in the main thread and passed as a </span><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">const</span></strong><span class="koboSpan" id="kobo.473.1"> reference but then the constness is cast away, which makes this function not thread-safe. </span><span class="koboSpan" id="kobo.473.2">Only the </span><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">d</span></strong><span class="koboSpan" id="kobo.475.1"> function is thread-safe because neither the main thread nor </span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">t</span></strong><span class="koboSpan" id="kobo.477.1"> can modify </span><span class="No-Break"><span class="koboSpan" id="kobo.478.1">the variable.</span></span></p>
<p><span class="koboSpan" id="kobo.479.1">The data type </span><a id="_idIndexMarker090"/><span class="koboSpan" id="kobo.480.1">and all sub-types of the variable are either physically constant or their logical constness implementation is thread-safe. </span><span class="koboSpan" id="kobo.480.2">For example, in the following example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">Point</span></strong><span class="koboSpan" id="kobo.482.1"> struct is physically constant because its </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">x</span></strong><span class="koboSpan" id="kobo.484.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.485.1">y</span></strong><span class="koboSpan" id="kobo.486.1"> field members are primitive integers, and both threads have only </span><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">const</span></strong><span class="koboSpan" id="kobo.488.1"> access </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">to it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.490.1">
struct Point {
  int x;
  int y;
};
void foo() {
  const auto point = Point{.x = 10, .y = 10};
  auto t           = std::thread([&amp;]() { std::cout &lt;&lt;
    point.x; });
  t.join();
}</span></pre>
<p><span class="koboSpan" id="kobo.491.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.492.1">DataReader</span></strong><span class="koboSpan" id="kobo.493.1"> class that we saw earlier is logically constant because it has a mutable variable, </span><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">mutex</span></strong><span class="koboSpan" id="kobo.495.1">, but this implementation is also thread-safe (due to </span><span class="No-Break"><span class="koboSpan" id="kobo.496.1">the lock):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.497.1">
class DataReader {
public:
  Data read() const {
    auto lock = std::lock_guard&lt;std::mutex&gt;(mutex);
    // read data
    return Data{};
  }
private:
  mutable std::mutex mutex;
};</span></pre>
<p><span class="koboSpan" id="kobo.498.1">However, let </span><a id="_idIndexMarker091"/><span class="koboSpan" id="kobo.499.1">us look into the following case. </span><span class="koboSpan" id="kobo.499.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">RequestProcessor</span></strong><span class="koboSpan" id="kobo.501.1"> class processes some heavy requests and caches the results in an </span><span class="No-Break"><span class="koboSpan" id="kobo.502.1">internal variable:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.503.1">
class RequestProcessor {
public:
  Result process(uint64_t request_id,
                 Request request) const {
    if (auto it = cache_.find(request_id); it !=
      cache_.cend()) {
      return it-&gt;second;
    }
    // process request
    // create result
    auto result = Result{};
    cache_[request_id] = result;
    return result;
  }
private:
  mutable std::unordered_map&lt;uint64_t, Result&gt; cache_;
};
void process_request() {
  auto requests = std::vector&lt;std::tuple&lt;uint64_t,
    Request&gt;&gt;{};
  const auto processor = RequestProcessor{};
  for (const auto&amp; request : requests) {
    auto t = std::thread([&amp;]() {
      processor.process(std::get&lt;0&gt;(request),
                        std::get&lt;1&gt;(request));
    });
    t.detach();
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.504.1">This class is</span><a id="_idIndexMarker092"/><span class="koboSpan" id="kobo.505.1"> logically safe, but the </span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">cache_</span></strong><span class="koboSpan" id="kobo.507.1"> variable is changed in a non-thread-safe way, which makes the class non-thread-safe even when declared </span><span class="No-Break"><span class="koboSpan" id="kobo.508.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">const</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.510.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.511.1">Note that when working with STL containers, it is essential to remember that, despite current implementations tending to be thread-safe (physically and logically), the standard provides very specific </span><span class="No-Break"><span class="koboSpan" id="kobo.512.1">thread-safety guarantees.</span></span></p>
<p><span class="koboSpan" id="kobo.513.1">All functions in a container can be called simultaneously by various threads on different containers. </span><span class="koboSpan" id="kobo.513.2">Broadly, functions from the C++ standard library don’t read objects accessible to other threads unless they are reachable through the function arguments, which includes the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">this</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.515.1"> pointer.</span></span></p>
<p><span class="koboSpan" id="kobo.516.1">All </span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">const</span></strong><span class="koboSpan" id="kobo.518.1"> member functions are thread-safe, meaning they can be invoked simultaneously by various threads on the same container. </span><span class="koboSpan" id="kobo.518.2">Furthermore, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">begin()</span></strong><span class="koboSpan" id="kobo.520.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">end()</span></strong><span class="koboSpan" id="kobo.522.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">rbegin()</span></strong><span class="koboSpan" id="kobo.524.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">rend()</span></strong><span class="koboSpan" id="kobo.526.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">front()</span></strong><span class="koboSpan" id="kobo.528.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">back()</span></strong><span class="koboSpan" id="kobo.530.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">data()</span></strong><span class="koboSpan" id="kobo.532.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">find()</span></strong><span class="koboSpan" id="kobo.534.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">lower_bound()</span></strong><span class="koboSpan" id="kobo.536.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">upper_bound()</span></strong><span class="koboSpan" id="kobo.538.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">equal_range()</span></strong><span class="koboSpan" id="kobo.540.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">at()</span></strong><span class="koboSpan" id="kobo.542.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">operator[]</span></strong><span class="koboSpan" id="kobo.544.1"> (except in associative containers) member functions also behave as </span><strong class="source-inline"><span class="koboSpan" id="kobo.545.1">const</span></strong><span class="koboSpan" id="kobo.546.1"> with regard to thread safety. </span><span class="koboSpan" id="kobo.546.2">In other words, they can also be invoked by various threads on the same container. </span><span class="koboSpan" id="kobo.546.3">Broadly, C++ standard library functions won’t modify objects unless those objects are reachable, directly or indirectly, via the function’s non-const arguments, which includes the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.547.1">this</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.548.1"> pointer.</span></span></p>
<p><span class="koboSpan" id="kobo.549.1">Different elements in the same container can be altered simultaneously by different threads, with the exception of </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">std::vector&lt;bool&gt;</span></strong><span class="koboSpan" id="kobo.551.1"> elements. </span><span class="koboSpan" id="kobo.551.2">For example, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">std::vector</span></strong><span class="koboSpan" id="kobo.553.1"> of </span><strong class="source-inline"><span class="koboSpan" id="kobo.554.1">std::future</span></strong><span class="koboSpan" id="kobo.555.1"> objects can receive values from multiple threads </span><span class="No-Break"><span class="koboSpan" id="kobo.556.1">at once.</span></span></p>
<p><span class="koboSpan" id="kobo.557.1">Operations on</span><a id="_idIndexMarker093"/><span class="koboSpan" id="kobo.558.1"> iterators, such as incrementing an iterator, read the underlying container but don’t modify it. </span><span class="koboSpan" id="kobo.558.2">These operations can be performed concurrently with operations on other iterators of the same container, with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">const</span></strong><span class="koboSpan" id="kobo.560.1"> member functions, or with reads from the elements. </span><span class="koboSpan" id="kobo.560.2">However, operations that invalidate any iterators modify the container and must not be performed concurrently with any operations on existing iterators, even those that are </span><span class="No-Break"><span class="koboSpan" id="kobo.561.1">not invalidated.</span></span></p>
<p><span class="koboSpan" id="kobo.562.1">Elements of the same container can be altered concurrently with those member functions that don’t access these elements. </span><span class="koboSpan" id="kobo.562.2">Broadly, C++ standard library functions won’t read objects indirectly accessible through their arguments (including other elements of a container) except when required by </span><span class="No-Break"><span class="koboSpan" id="kobo.563.1">its specification.</span></span></p>
<p><span class="koboSpan" id="kobo.564.1">Lastly, operations on containers (as well as algorithms or other C++ standard library functions) can be internally parallelized as long as the user-visible results remain unaffected. </span><span class="koboSpan" id="kobo.564.2">For example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">std::transform</span></strong><span class="koboSpan" id="kobo.566.1"> can be parallelized, but </span><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">std::for_each</span></strong><span class="koboSpan" id="kobo.568.1"> cannot, as it is specified to visit each element of a sequence </span><span class="No-Break"><span class="koboSpan" id="kobo.569.1">in order.</span></span></p>
<p><span class="koboSpan" id="kobo.570.1">The idea of having a single mutable reference to an object became one of the pillars of the Rust programming language. </span><span class="koboSpan" id="kobo.570.2">This rule is in place to prevent data races, which occur when multiple threads access the same mutable data concurrently, resulting in unpredictable behavior and potential crashes. </span><span class="koboSpan" id="kobo.570.3">By allowing only one mutable reference to an object at a time, Rust ensures that concurrent access to the same data is properly synchronized and avoids </span><span class="No-Break"><span class="koboSpan" id="kobo.571.1">data races.</span></span></p>
<p><span class="koboSpan" id="kobo.572.1">In addition, this rule helps prevent mutable aliasing, which occurs when multiple mutable references to the same data exist simultaneously. </span><span class="koboSpan" id="kobo.572.2">Mutable aliasing can lead to subtle bugs and make code difficult to reason about, especially in large and complex code bases. </span><span class="koboSpan" id="kobo.572.3">By allowing only one mutable reference to an object, Rust avoids mutable aliasing and helps ensure that code is correct and easy </span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">to understand.</span></span></p>
<p><span class="koboSpan" id="kobo.574.1">However, it’s worth noting that Rust also allows multiple immutable references to an object, which can be useful in scenarios where concurrent access is necessary but mutations are not. </span><span class="koboSpan" id="kobo.574.2">By allowing multiple immutable references, Rust can provide better performance and concurrency while still maintaining safety </span><span class="No-Break"><span class="koboSpan" id="kobo.575.1">and correctness.</span></span></p>
<h1 id="_idParaDest-43"><a id="_idTextAnchor042"/><span class="koboSpan" id="kobo.576.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.577.1">In this chapter, we covered the SOLID principles, the KISS principle, constness, and immutability. </span><span class="koboSpan" id="kobo.577.2">Let’s see what </span><span class="No-Break"><span class="koboSpan" id="kobo.578.1">you learned!</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.579.1">SOLID principles: SOLID is a set of five principles that help us create code that’s easy to maintain, scalable, and flexible. </span><span class="koboSpan" id="kobo.579.2">By understanding these principles, you’re on your way to designing code that’s a dream to </span><span class="No-Break"><span class="koboSpan" id="kobo.580.1">work with!</span></span></li>
<li><span class="koboSpan" id="kobo.581.1">The KISS principle: The KISS principle is all about keeping things simple. </span><span class="koboSpan" id="kobo.581.2">By following this principle, you’ll avoid overcomplicating your code, making it easier to maintain </span><span class="No-Break"><span class="koboSpan" id="kobo.582.1">and debug.</span></span></li>
<li><span class="koboSpan" id="kobo.583.1">Constness: Constness is a property in C++ that makes objects read-only. </span><span class="koboSpan" id="kobo.583.2">By declaring objects as </span><strong class="source-inline"><span class="koboSpan" id="kobo.584.1">const</span></strong><span class="koboSpan" id="kobo.585.1">, you can ensure that their values won’t be accidentally changed, making your code more stable </span><span class="No-Break"><span class="koboSpan" id="kobo.586.1">and predictable.</span></span></li>
<li><span class="koboSpan" id="kobo.587.1">Immutability: Immutability is all about making sure objects can’t be changed after their creation. </span><span class="koboSpan" id="kobo.587.2">By making objects immutable, you can avoid sneaky bugs and make your code </span><span class="No-Break"><span class="koboSpan" id="kobo.588.1">more predictable.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.589.1">With these design principles under your belt, you’re on your way to writing code that’s both robust and reliable. </span><span class="No-Break"><span class="koboSpan" id="kobo.590.1">Happy coding!</span></span></p>
<p><span class="koboSpan" id="kobo.591.1">In the next chapter, we will try to understand what causes </span><span class="No-Break"><span class="koboSpan" id="kobo.592.1">bad code.</span></span></p>
</div>
</body></html>