<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-27"><a id="_idTextAnchor026"/>2</h1>
<h1 id="_idParaDest-28"><a id="_idTextAnchor027"/>Main Software Development Principles</h1>
<p>In this chapter, we will explore the main software design principles that are used to create well-structured and maintainable code. One of the most important principles is SOLID, which stands for Single Responsibility Principle, Open-Closed Principle, Liskov Substitution Principle, Interface Segregation Principle, and Dependency Inversion Principle. These principles are designed to help developers create code that is easy to understand, test, and modify. We will also discuss the importance of levels of abstraction, which is the practice of breaking down complex systems into smaller, more manageable parts. Additionally, we will explore the concepts of side effects and mutability and how they can affect the overall quality of software. By understanding and applying these principles, developers can create software that is more robust, reliable, and scalable.</p>
<h1 id="_idParaDest-29"><a id="_idTextAnchor028"/>SOLID</h1>
<p>SOLID is a <a id="_idIndexMarker032"/>set of principles that were first introduced by Robert C. Martin in his book <em class="italic">Agile Software Development, Principles, Patterns, and Practices</em>, in 2000. Robert C. Martin, also known as Uncle Bob, is a software engineer, author, and speaker. He is considered one of the most influential figures in the software development industry, known for his work on the SOLID principles and his contributions to the field of object-oriented programming. Martin has been a software developer for more than 40 years and has worked on a wide variety of projects, from small systems to large enterprise systems. He is also a well-known speaker and has given presentations on software development at many conferences and events around the world. He is an advocate of agile methodologies, and he has been influential in the development of the Agile Manifesto. The SOLID principles were developed as a way to help developers create more maintainable and scalable code by promoting good design practices. The principles were based on Martin’s experience as a software developer and his observation that many software projects suffer from poor design, which makes them difficult to understand, change, and maintain over time.</p>
<p>The SOLID principles are intended to be a guide for object-oriented software design, and they are <a id="_idIndexMarker033"/>based on the idea that software should be easy to understand, change, and extend over time. The principles are meant to be applied in conjunction with other software development practices, such as test-driven development and continuous integration. By following SOLID principles, developers can create code that is more robust, less prone to bugs, and easier to maintain over time.</p>
<h2 id="_idParaDest-30"><a id="_idTextAnchor029"/>The Single Responsibility Principle</h2>
<p>The <strong class="bold">Single Responsibility Principle</strong> (<strong class="bold">SRP</strong>) is one of the five SOLID principles of object-oriented <a id="_idIndexMarker034"/>software design. It states that a<a id="_idIndexMarker035"/> class should have only one reason to change, meaning that a class should have only one responsibility. This principle is intended to promote code that is easy to understand, change, and test.</p>
<p>The idea behind the SRP is that a class should have a single, well-defined purpose. This makes it easier to understand the class’s behavior and makes it less likely that changes to the class will have unintended consequences. When a class has only one responsibility, it is also less likely to have bugs, and it is easier to write automated tests for it.</p>
<p>Applying the SRP can be a useful way to improve the design of a software system by making it more modular and easier to understand. By following this principle, a developer can create classes that are small, focused, and easy to reason about. This makes it easier to maintain and improve the software over time.</p>
<p>Let us look at a messaging system that supports multiple message types sent over the network. The system has a <code>Message</code> class that receives sender and receiver IDs and raw data to be sent. Additionally, it supports saving messages to the disk and sending itself via the <code>send</code> method:</p>
<pre class="source-code">
class Message {
public:
  Message(SenderId sender_id, ReceiverId receiver_id,
          const RawData&amp; data)
    : sender_id_{sender_id},
      receiver_id_{receiver_id}, raw_data_{data} {}
  SenderId sender_id() const { return sender_id_; }
  ReceiverId receiver_id() const { return receiver_id_; }
  void save(const std::string&amp; file_path) const {
    // serializes a message to raw bytes and saves
    // to file system
  }
  std::string serialize() const {
    // serializes to JSON
    return {"JSON"};
  }
  void send() const {
    auto sender = Communication::get_instance();
    sender.send(sender_id_, receiver_id_, serialize());
  }
private:
  SenderId sender_id_;
  ReceiverId receiver_id_;
  RawData raw_data_;
};</pre>
<p>The <code>Message</code> class is responsible for multiple concerns, such as saving messages from/to the filesystem, serializing data, sending messages, and holding the sender and receiver IDs and raw data. It would be better to separate these responsibilities into different classes or modules.</p>
<p>The <code>Message</code> class<a id="_idIndexMarker036"/> is only responsible for storing the data <a id="_idIndexMarker037"/>and serializing it to JSON format:</p>
<pre class="source-code">
class Message {
public:
  Message(SenderId sender_id, ReceiverId receiver_id,
          const RawData&amp; data)
    : sender_id_{sender_id},
      receiver_id_{receiver_id}, raw_data_{data} {}
  SenderId sender_id() const { return sender_id_; }
  ReceiverId receiver_id() const { return receiver_id_; }
  std::string serialize() const {
    // serializes to JSON
    return {"JSON"};
  }
private:
  SenderId sender_id_;
  ReceiverId receiver_id_;
  RawData raw_data_;
};</pre>
<p>The <code>save</code> method can be extracted to a separate <code>MessageSaver</code> class, having a single responsibility:</p>
<pre class="source-code">
class MessageSaver {
public:
  MessageSaver(const std::string&amp; target_directory);
  void save(const Message&amp; message) const;
};</pre>
<p>And the <code>send</code> method<a id="_idIndexMarker038"/> is implemented in a dedicated <code>MessageSender</code> class. All three classes have a single and clear responsibility, and any further changes in any of them would not affect the others. This approach allows isolating the changes in the code base. It becomes crucial in a complex system requiring long compilation.</p>
<p>In summary, the <a id="_idIndexMarker039"/>SRP states that a class should have only one reason to change, meaning that a class should have only one responsibility. This principle is intended to promote code that is easy to understand, change, and test, and it helps in creating a more modular, maintainable, and scalable code base. By following this principle, developers can create classes that are small, focused, and easy to reason about.</p>
<h3>Other applications of the SRP</h3>
<p>The SRP can <a id="_idIndexMarker040"/>be applied not only to classes but also to larger components, such as applications. At the architecture level, the SRP is often implemented as microservices architecture. The idea of microservices is to build a software system as a collection of small, independent services that communicate with each other over a network rather than building it as a monolithic application. Each microservice is <em class="italic">responsible for a specific business capability and can be developed, deployed, and scaled independently from the other services</em>. This allows for greater flexibility, scalability, and ease of maintenance, as changes to one service do not affect the entire system. Microservices also enable a more agile development process, as teams can work on different services in parallel, and also allows for a more fine-grained approach to security, monitoring, and testing, as each service can be handled individually.</p>
<h2 id="_idParaDest-31"><a id="_idTextAnchor030"/>The Open-Closed Principle</h2>
<p>The Open-Closed principle <a id="_idIndexMarker041"/>states that a module or class should be open for extension but closed for modification. In other words, it <a id="_idIndexMarker042"/>should be possible to add new functionality to a module or class without modifying its existing code. This principle helps to promote software maintainability and flexibility. An example of this principle in C++ is the use of inheritance and polymorphism. A base class can be written with the ability to be extended by derived classes, allowing for new functionality to be added without modifying the base class. Another example is using interfaces or abstract classes to define a contract for a set of related classes, allowing new classes to be added that conform to the contract without modifying existing code.</p>
<p>The Open-closed Principle can be used to improve our message-sending components. The current version supports only one message type. If we want to add more data, we need to change the <code>Message</code> class: add fields, hold a message type as an additional variable, and not to mention serialization based on this variable. In order to avoid changes in existing code, let us rewrite the <code>Message</code> class to be purely virtual, providing the <code>serialize</code> method:</p>
<pre class="source-code">
class Message {
public:
  Message(SenderId sender_id, ReceiverId receiver_id)
    : sender_id_{sender_id}, receiver_id_{receiver_id} {}
  SenderId sender_id() const { return sender_id_; }
  ReceiverId receiver_id() const { return receiver_id_; }
  virtual std::string serialize() const = 0;
private:
  SenderId sender_id_;
  ReceiverId receiver_id_;
};</pre>
<p>Now, let us assume that we need to add another two message types: a “start” message supporting start delay (often done for debugging purposes) and a “stop” message supporting <a id="_idIndexMarker043"/>stop delay (can be used for scheduling); they<a id="_idIndexMarker044"/> can be implemented as follows:</p>
<pre class="source-code">
class StartMessage : public Message {
public:
  StartMessage(SenderId sender_id, ReceiverId receiver_id,
               std::chrono::milliseconds start_delay)
    : Message{sender_id, receiver_id},
      start_delay_{start_delay} {}
  std::string serialize() const override {
    return {"naive serialization to JSON"};
  }
private:
  const std::chrono::milliseconds start_delay_;
};
class StopMessage : public Message {
public:
  StopMessage(SenderId sender_id, ReceiverId receiver_id,
              std::chrono::milliseconds stop_delay)
    : Message{sender_id, receiver_id},
      stop_delay_{stop_delay} {}
  std::string serialize() const override {
    return {"naive serialization to JSON"};
  }
private:
  const std::chrono::milliseconds stop_delay_;
};</pre>
<p>Note <a id="_idIndexMarker045"/>that none of the implementations requires changes in other classes, and each of them provides its own version of the <code>serialize</code> method. The <code>MessageSender</code> and <code>MessageSaver</code> classes do not need additional <a id="_idIndexMarker046"/>adjustments to support the new class hierarchy of messages. However, we are going to change them too. The main reason is to make them extendable without requiring changes. For example, a message can be saved not only to the filesystem but also to remote storage. In this case, <code>MessageSaver</code> becomes purely virtual:</p>
<pre class="source-code">
class MessageSaver {
public:
  virtual void save(const Message&amp; message) const = 0;
};</pre>
<p>The implementation responsible for saving to the filesystem is a class derived from <code>MessageSaver</code>:</p>
<pre class="source-code">
class FilesystemMessageSaver : public MessageSaver {
public:
  FilesystemMessageSaver(const std::string&amp;
    target_directory);
  void save(const Message&amp; message) const override;
};</pre>
<p>And the remote <a id="_idIndexMarker047"/>storage saver is another class in the<a id="_idIndexMarker048"/> hierarchy:</p>
<pre class="source-code">
class RemoteMessageSaver : public MessageSaver {
public:
    RemoteMessageSaver(const std::string&amp;
      remote_storage_address);
    void save(const Message&amp; message) const override;
};</pre>
<h2 id="_idParaDest-32"><a id="_idTextAnchor031"/>The Liskov Substitution Principle</h2>
<p>The <strong class="bold">Liskov Substitution Principle</strong> (<strong class="bold">LSP</strong>) is a fundamental principle in object-oriented <a id="_idIndexMarker049"/>programming that states that <a id="_idIndexMarker050"/>objects of a superclass should be able to be replaced with objects of a subclass without affecting the correctness of the program. This principle is also known as the Liskov principle, named after Barbara Liskov, who first formulated it. The LSP is based on the idea of inheritance and polymorphism, where a subclass can inherit the properties and methods of its parent class and can be used interchangeably with it.</p>
<p>In order to follow the LSP, subclasses must be “behaviorally compatible” with their parent class. This means that they should have the same method signatures and follow the same contracts, such as input and output types and ranges. Additionally, the behavior of a method in a subclass should not violate any of the contracts established in the parent class.</p>
<p>Let’s consider a new <code>Message</code> type, <code>InternalMessage</code>, which does not support the <code>serialize</code> method. One might be tempted to implement it in the following way:</p>
<pre class="source-code">
class InternalMessage : public Message {
public:
    InternalMessage(SenderId sender_id, ReceiverId
      receiver_id)
        : Message{sender_id, receiver_id} {}
    std::string serialize() const override {
        throw std::runtime_error{"InternalMessage can't be
          serialized!"};
    }
};</pre>
<p>In the<a id="_idIndexMarker051"/> preceding code, <code>InternalMessage</code> is a subtype of <code>Message</code> but cannot be serialized, throwing an exception instead. This <a id="_idIndexMarker052"/>design is problematic for a few reasons:</p>
<ul>
<li><code>InternalMessage</code> is a subtype of <code>Message</code>, then we should be able to use <code>InternalMessage</code> wherever <code>Message</code> is expected without affecting the correctness of the program. By throwing an exception in the <code>serialize</code> method, we are breaking this principle.</li>
<li><code>serialize</code> must handle exceptions, which might not have been necessary when dealing with other <code>Message</code> types. This introduces additional complexity and the potential for errors in the caller code.</li>
<li><strong class="bold">Program crashes</strong>: If the exception is not properly handled, it could lead to the program crashing, which is certainly not a desirable outcome.</li>
</ul>
<p>We could return an empty string instead of throwing an exception, but this still violates the LSP, as the <code>serialize</code> method is expected to return a serialized message, not an empty string. It also introduces ambiguity, as it’s not clear whether an empty string is the result of a successful serialization of a message with no data or an unsuccessful serialization of <code>InternalMessage</code>.</p>
<p>A better approach is to separate the concerns of a <code>Message</code> and a <code>SerializableMessage</code>, where only <code>SerializableMessage</code>s have a <code>serialize</code> method:</p>
<pre class="source-code">
class Message {
public:
    virtual ~Message() = default;
    // other common message behaviors
};
class SerializableMessage : public Message {
public:
    virtual std::string serialize() const = 0;
};
class StartMessage : public SerializableMessage {
    // ...
};
class StopMessage : public SerializableMessage {
    // ...
};
class InternalMessage : public Message {
    // InternalMessage doesn't have serialize method now.
};</pre>
<p>In<a id="_idIndexMarker053"/> this <a id="_idIndexMarker054"/>corrected design, the base <code>Message</code> class does not include a <code>serialize</code> method, and a new <code>SerializableMessage</code> class has been introduced that includes this method. This way, only messages that can be serialized will inherit from <code>SerializableMessage</code>, and we adhere to the LSP.</p>
<p>Adhering to <a id="_idIndexMarker055"/>the LSP allows for more flexible and maintainable <a id="_idIndexMarker056"/>code, as it enables the use of polymorphism and allows for substituting objects of a class with objects of its subclasses without affecting the overall behavior of the program. This way, the program can take advantage of the new functionality provided by the subclass while maintaining the same behavior as the superclass.</p>
<p>The Interface Segregation Principle</p>
<p>The <strong class="bold">Interface Segregation Principle</strong> (<strong class="bold">ISP</strong>) is a principle in object-oriented programming <a id="_idIndexMarker057"/>that states that a class <a id="_idIndexMarker058"/>should only implement the interfaces it uses. In other words, it suggests that interfaces should be fine-grained and client-specific rather than having a single, large, and all-encompassing interface. The ISP is based on the idea that it is better to have many small interfaces that each define a specific set of methods rather than a single large interface that defines many methods.</p>
<p>One of the key benefits of the ISP is that it promotes a more modular and flexible design, as it allows for the creation of interfaces that are tailored to the specific needs of a client. This way, it reduces the number of unnecessary methods that a client needs to implement, and also it reduces the risk of a client depending on methods that it does not need.</p>
<p>An example of the ISP can be observed when creating our example messages from MessagePack or JSON files. Following the best practices, we would create an interface providing two methods, <code>from_message_pack</code> and <code>from_json</code>.</p>
<p>The current implementations need to implement both methods, but what if a particular class does not need to support both options? The smaller the interface, the better. The <code>MessageParser</code> interface will be split into two separate interfaces, each requiring the implementation of either JSON or MessagePack:</p>
<pre class="source-code">
class JsonMessageParser {
public:
  virtual std::unique_ptr&lt;Message&gt;
  parse(const std::vector&lt;uint8_t&gt;&amp; message_pack)
    const = 0;
};
class MessagePackMessageParser {
public:
  virtual std::unique_ptr&lt;Message&gt;
  parse(const std::vector&lt;uint8_t&gt;&amp; message_pack)
    const = 0;
};</pre>
<p>This <a id="_idIndexMarker059"/>design allows for objects <a id="_idIndexMarker060"/>derived from <code>JsonMessageParser</code> and <code>MessagePackMessageParser</code> to understand how to construct themselves from JSON and MessagePack, respectively, while preserving the independence and functionality of each function. The system remains flexible as new smaller objects can still be composed to achieve the desired functionality.</p>
<p>Adhering to the ISP makes the code more maintainable and less prone to errors, as it reduces the number of unnecessary methods that a client needs to implement, and it also reduces the risk of a client depending on methods that it does not need.</p>
<h2 id="_idParaDest-33"><a id="_idTextAnchor032"/>The Dependency inversion principle</h2>
<p>The <a id="_idIndexMarker061"/>Dependency inversion principle is <a id="_idIndexMarker062"/>based on the idea that it is better to depend on abstractions rather than on concrete implementations, as it allows for greater flexibility and maintainability. It allows the decoupling of high-level modules from low-level modules, making them more independent and less prone to changes in the low-level modules. This way, it makes it easy to change low-level implementations without affecting high-level modules and vice versa.</p>
<p>The DIP can be illustrated for our messaging system if we try to use all the components via another class. Let us assume that there is a class responsible for message routing. In order to build such a class, we are<a id="_idIndexMarker063"/> going to use <code>MessageSender</code> as a communication module, <code>Message</code> based <a id="_idIndexMarker064"/>classes, and <code>MessageSaver</code>:</p>
<pre class="source-code">
class MessageRouter {
public:
  MessageRouter(ReceiverId id)
    : id_{id} {}
  void route(const Message&amp; message) const {
    if (message.receiver_id() == id_) {
      handler_.handle(message);
    } else {
      try {
        sender_.send(message);
      } catch (const CommunicationError&amp; e) {
        saver_.save(message);
      }
    }
  }
private:
  const ReceiverId id_;
  const MessageHandler handler_;
  const MessageSender sender_;
  const MessageSaver saver_;
};</pre>
<p>The new class provides only one <code>route</code> method, which is called once a new message is available. The router handles the message to the <code>MessageHandler</code> class if the message’s sender ID equals the router’s. Otherwise, the router forwards the message to the corresponding receiver. In case the delivery of the message fails and the communication layer throws an exception, the router saves the message via <code>MessageSaver</code>. Those messages will be delivered some other time.</p>
<p>The only problem is that <a id="_idIndexMarker065"/>if any dependency needs to be changed, the router’s code has to be updated accordingly. For example, if the application needs to support several types of senders (TCP and UDP), the message saver (filesystem versus remote) or message handler’s logic changes. In order to make <code>MessageRouter</code> agnostic to such changes, we <a id="_idIndexMarker066"/>can rewrite it using the DIP principle:</p>
<pre class="source-code">
class BaseMessageHandler {
public:
    virtual ~BaseMessageHandler() {}
    virtual void handle(const Message&amp; message) const = 0;
};
class BaseMessageSender {
public:
    virtual ~BaseMessageSender() {}
    virtual void send(const Message&amp; message) const = 0;
};
class BaseMessageSaver {
public:
    virtual ~BaseMessageSaver() {}
    virtual void save(const Message&amp; message) const = 0;
};
class MessageRouter {
public:
    MessageRouter(ReceiverId id,
                  const BaseMessageHandler&amp; handler,
                  const BaseMessageSender&amp; sender,
                  const BaseMessageSaver&amp; saver)
        : id_{id}, handler_{handler}, sender_{sender},
          saver_{saver} {}
    void route(const Message&amp; message) const {
        if (message.receiver_id() == id_) {
            handler_.handle(message);
        } else {
            try {
                sender_.send(message);
            } catch (const CommunicationError&amp; e) {
                saver_.save(message);
            }
        }
    }
private:
    ReceiverId id_;
    const BaseMessageHandler&amp; handler_;
    const BaseMessageSender&amp; sender_;
    const BaseMessageSaver&amp; saver_;
};
int main() {
  auto id      = ReceiverId{42};
  auto handler = MessageHandler{};
  auto sender = MessageSender{
    Communication::get_instance()};
  auto saver =
    FilesystemMessageSaver{"/tmp/undelivered_messages"};
  auto router = MessageRouter{id, sender, saver};
}</pre>
<p>In this<a id="_idIndexMarker067"/> revised version of the code, <code>MessageRouter</code> is now<a id="_idIndexMarker068"/> decoupled from specific implementations of the message handling, sending, and saving logic. Instead, it relies on abstractions represented by <code>BaseMessageHandler</code>, <code>BaseMessageSender</code>, and <code>BaseMessageSaver</code>. This way, any class that derives from these base classes can be used with <code>MessageRouter</code>, which makes the code more flexible and easier to extend in the future. The router is not concerned with the specifics of how messages are handled, sent, or saved – it only needs to know that these operations can be performed.</p>
<p>Adhering to the DIP makes code more maintainable and less prone to errors. It decouples high-level modules from low-level modules, making them more independent and less prone to changes in low-level modules. It also allows for greater flexibility, making it easy to change low-level implementations without affecting high-level modules and vice versa. Later in this book, dependency inversion will help us mock parts of the system while developing unit tests.</p>
<h1 id="_idParaDest-34"><a id="_idTextAnchor033"/>The KISS principle</h1>
<p>The KISS principle, which <a id="_idIndexMarker069"/>stands for “Keep It Simple, Stupid,” is a design philosophy that emphasizes the importance of keeping things simple and straightforward. This principle is particularly relevant in the world of programming, where complex code can lead to bugs, confusion, and slow development time.</p>
<p>Here are some examples<a id="_idIndexMarker070"/> of how the KISS principle can be applied in C++:</p>
<ul>
<li><code>for</code> loop instead of a complex algorithm can often be just as effective and much easier to understand.</li>
<li><strong class="bold">Keep Functions Small</strong>: Functions in C++ should be small, focused, and easy to understand. Complex functions can quickly become difficult to maintain and debug, so try to keep functions as simple and concise as possible. A good rule of thumb is to aim for functions that are no longer than 30-50 lines of code.</li>
<li><strong class="bold">Use Clear and Concise Variable Names</strong>: In C++, variable names play a crucial role in making code readable and understandable. Avoid using abbreviations and instead opt for clear and concise names that accurately describe the purpose of the variable.</li>
<li><strong class="bold">Avoid Deep Nesting</strong>: Nested loops and conditional statements can make code hard to read and follow. Try to keep the nesting levels as shallow as possible, and consider breaking up complex functions into smaller, simpler functions.</li>
<li><strong class="bold">Write Simple, Readable Code</strong>: Above all, aim to write code that is easy to understand and follow. This means using clear and concise language and avoiding complicated expressions and structures. Code that is simple and easy to follow is much more likely to be maintainable and bug-free.</li>
<li><strong class="bold">Avoid Complex Inheritance Hierarchy</strong>: Complex inheritance hierarchies can make code more difficult to understand, debug, and maintain. The more complex the<a id="_idIndexMarker071"/> inheritance structure, the harder it becomes to keep track of the relationships between classes and determine how changes will affect the rest of the code.</li>
</ul>
<p>In conclusion, the KISS principle is a simple and straightforward design philosophy that can help developers write clear, concise, and maintainable code. By keeping things simple, developers can avoid bugs and confusion and speed up development time.</p>
<h2 id="_idParaDest-35"><a id="_idTextAnchor034"/>The KISS and SOLID Principles together</h2>
<p>The <a id="_idIndexMarker072"/>SOLID principles and the KISS principle are both important design philosophies in software development, but they can sometimes contradict each other.</p>
<p>The <a id="_idIndexMarker073"/>SOLID principles are a set of five principles that guide the design of software, aimed at making it more maintainable, scalable, and flexible. They focus on creating a clean, modular architecture that follows good object-oriented design practices.</p>
<p>The KISS principle, on the other hand, is all about keeping things simple. It advocates for straightforward, simple solutions, avoiding complex algorithms and structures that can make code hard to understand and maintain.</p>
<p>While both SOLID and KISS aim to improve software quality, they can sometimes be at odds. For example, following the SOLID principles may result in code that is more complex and harder to understand to achieve greater modularity and maintainability. Similarly, the KISS principle may result in less flexible and scalable code to keep it simple and straightforward.</p>
<p>In practice, developers often have to strike a balance between the SOLID principles and the KISS principle. On the one hand, they want to write code that is maintainable, scalable, and flexible. On the other hand, they want to write code that is simple and easy to understand. Finding this balance requires careful consideration of trade-offs and an understanding of when each approach is most appropriate.</p>
<p>When I have to choose between the SOLID and KISS approaches, I think about something my boss, Amir Taya, said, “When building a Ferrari, you need to start from a scooter.” This<a id="_idIndexMarker074"/> phrase is an exaggerated example of KISS: if <a id="_idIndexMarker075"/>you do not know how to build a feature, make the simplest working version (KISS), re-iterate, and extend the solution using SOLID principles if needed.</p>
<h1 id="_idParaDest-36"><a id="_idTextAnchor035"/>Side effects and immutability</h1>
<p>Side effects and immutability are two important concepts in programming that have a significant impact on the quality and maintainability of code.</p>
<p>Side effects <a id="_idIndexMarker076"/>refer to changes that occur in the state of the program as a result of executing a particular function or piece of code. Side effects can be explicit, such as writing data to a file or updating a variable, or implicit, such as modifying the global state or causing unexpected behavior in other parts of the code.</p>
<p>Immutability, on<a id="_idIndexMarker077"/> the other hand, refers to the property of a variable or data structure that cannot be modified after it has been created. In functional programming, immutability is achieved by making data structures and variables constant and avoiding side effects.</p>
<p>The importance of avoiding side effects and using immutable variables lies in the fact that they make code easier to understand, debug, and maintain. When code has few side effects, it is easier to reason about what it does and what it does not do. This makes finding and fixing bugs and making changes to the code easier without affecting other parts of the system.</p>
<p>In contrast, code with many side effects is harder to understand, as the state of the program can change in unexpected ways. This makes it more difficult to debug and maintain and can lead to bugs and unexpected behavior.</p>
<p>Functional programming languages have long emphasized the use of immutability and the avoidance of side effects, but it is now possible to write code with these properties using C++. The easiest way to achieve it is<a id="_idIndexMarker078"/> to follow the <strong class="bold">C++ Core Guidelines for Constants </strong><strong class="bold">and Immutability</strong>.</p>
<h2 id="_idParaDest-37"><a id="_idTextAnchor036"/>Con.1 – by default, make objects immutable</h2>
<p>You can declare<a id="_idIndexMarker079"/> a built-in data type or an instance of a user-defined data type as constant, resulting in the same effect. Attempting to modify it will result in a compiler error:</p>
<pre class="source-code">
struct Data {
  int val{42};
};
int main() {
  const Data data;
  data.val = 43; // assignment of member 'Data::val' in
                 // read-only object
  const int val{42};
  val = 43; // assignment of read-only variable 'val'
}</pre>
<p>The same applies to loops:</p>
<pre class="source-code">
for (const int i : array) {
  std::cout &lt;&lt; i &lt;&lt; std::endl; // just reading: const
}
for (int i : array) {
  std::cout &lt;&lt; i &lt;&lt; std::endl; // just reading: non-const
}</pre>
<p>This approach allows the prevention of hard-to-notice changes of value.</p>
<p>Probably, the only exception is function parameters passed by value:</p>
<pre class="source-code">
void foo(const int value);</pre>
<p>Such parameters are rarely passed as <code>const</code> and rarely mutated. In order to avoid confusion, it is recommended not to enforce this rule in such cases.</p>
<h2 id="_idParaDest-38"><a id="_idTextAnchor037"/>Con.2 – by default, make member functions const</h2>
<p>A member <a id="_idIndexMarker080"/>function (method) shall be marked as <code>const</code> unless it changes the observable state of an object. The reason behind this is to give a more precise statement of design intent, better readability, maintainability, more errors caught by the compiler, and theoretically more optimization opportunities:</p>
<pre class="source-code">
class Book {
public:
  std::string name() { return name_; }
private:
  std::string name_;
};
void print(const Book&amp; book) {
  cout &lt;&lt; book.name()
       &lt;&lt; endl; // ERROR: 'this' argument to member
                // function
                // 'name' has type 'const Book', but
                // function is not marked
                // const clang(member_function_call_bad_cvr)
}</pre>
<p>There are two types of constness: <strong class="bold">physical</strong> and <strong class="bold">logical</strong>:</p>
<p><code>const</code> and cannot be changed.</p>
<p><code>const</code> but can be changed.</p>
<p>Logical constness <a id="_idIndexMarker083"/>can be achieved with the <code>mutable</code> keyword. In general, it is a rare use case. The only good example I can think of is storing in an internal cache or using a mutex:</p>
<pre class="source-code">
class DataReader {
public:
  Data read() const {
    auto lock = std::lock_guard&lt;std::mutex&gt;(mutex);
    // read data
    return Data{};
  }
private:
  mutable std::mutex mutex;
};</pre>
<p>In this example, we need to change the <code>mutex</code> variable to lock it, but this does not affect the logical constness of the object.</p>
<p>Please be aware that there exist legacy codes/libraries that provide functions that declare  <code>T*</code>, despite not making any changes to the <code>T</code>. This presents an issue for individuals who are trying to mark all logically constant methods as <code>const</code>. In order to enforce constness, you can do the following:</p>
<ul>
<li>Update the library/code to be const-correct, which is the preferred solution.</li>
<li>Provide a wrapper function casting away the constness.</li>
</ul>
<p>Example</p>
<pre class="source-code">
void read_data(int* data); // Legacy code: read_data does
                           // not modify `*data`
void read_data(const int* data) {
  read_data(const_cast&lt;int*&gt;(data));
}</pre>
<p>Note that this <a id="_idIndexMarker084"/>solution is a patch that can be used only when the declaration of <code>read_data</code> cannot be modified.</p>
<h2 id="_idParaDest-39"><a id="_idTextAnchor038"/>Con.3 – by default, pass pointers and references to const</h2>
<p>This one is easy; it is far easier to reason about programs when called functions do not modify state.</p>
<p>Let us look at the two following functions:</p>
<pre class="source-code">
void foo(char* p);
void bar(const char* p);</pre>
<p>Does the <code>foo</code> function modify the data the <code>p</code> pointer points to? We cannot answer by looking at the declaration, so we assume it does by default. However, the <code>bar</code> function states explicitly that the content of <code>p</code> will not be changed.</p>
<h2 id="_idParaDest-40"><a id="_idTextAnchor039"/>Con.4 – use const to define objects with values that do not change after construction</h2>
<p>This rule is very similar to the first one, enforcing the constness of objects that are not expected to be changed in the future. It is often helpful with classes such as <code>Config</code> that are created at the beginning of the application and not changed during its lifetime:</p>
<pre class="source-code">
class Config {
public:
  std::string hostname() const;
  uint16_t port() const;
};
int main(int argc, char* argv[]) {
  const Config config = parse_args(argc, argv);
  run(config);
}</pre>
<h2 id="_idParaDest-41"><a id="_idTextAnchor040"/>Con.5 – use constexpr for values that can be computed at compile time</h2>
<p>Declaring <a id="_idIndexMarker085"/>variables as <code>constexpr</code> is preferred over <code>const</code> if the value is computed at compile time. It provides such benefits as better performance, better compile-time checking, guaranteed compile-time evaluation, and no possibility of race conditions.</p>
<h2 id="_idParaDest-42"><a id="_idTextAnchor041"/>Constness and data races</h2>
<p>Data races occur <a id="_idIndexMarker086"/>when multiple threads access a shared variable simultaneously, and <a id="_idIndexMarker087"/>at least one tries to modify it. There are synchronization primitives such as mutexes, critical sections, spinlocks, and semaphores, allowing the prevention of data races. The<a id="_idIndexMarker088"/> problem with these primitives is that they either do expensive system calls or overuse the CPU, which makes the code less efficient. However, if none of the threads modifies the variable, there is no place for data races. We learned that <code>constexpr</code> is thread-safe (does not need synchronization) because it is defined at compile time. What about <code>const</code>? It can be thread-safe under the below conditions.</p>
<p>The variable has been <code>const</code> since its creation. If a thread has direct or indirect (via a pointer or reference) non-const access to the variable, all the readers need to use mutexes. The following code snippet illustrates constant and non-constant access from multiple threads:</p>
<pre class="source-code">
void a() {
  auto value = int{42};
  auto t = std::thread([&amp;]() { std::cout &lt;&lt; value; });
  t.join();
}
void b() {
  auto value = int{42};
  auto t = std::thread([&amp;value = std::as_const(value)]() {
    std::cout &lt;&lt; value;
  });
  t.join();
}
void c() {
  const auto value = int{42};
  auto t = std::thread([&amp;]() {
      auto v = const_cast&lt;int&amp;&gt;(value);
      std::cout &lt;&lt; v;
  });
  t.join();
}
void d() {
  const auto value = int{42};
  auto t = std::thread([&amp;]() { std::cout &lt;&lt; value; });
  t.join();
}</pre>
<p>In <a id="_idIndexMarker089"/>the <code>a</code> function, the <code>value</code> variable is owned as non-constant by both the main thread and <code>t</code>, which makes the code potentially not thread-safe (if a developer decides to change the <code>value</code> later in the main thread). In the <code>b</code>, the main thread has “write” access to <code>value</code> while <code>t</code> receives it via a <code>const</code> reference, but still, it is not thread-safe. The <code>c</code> function is an example of very bad code: the <code>value</code> is created as a constant in the main thread and passed as a <code>const</code> reference but then the constness is cast away, which makes this function not thread-safe. Only the <code>d</code> function is thread-safe because neither the main thread nor <code>t</code> can modify the variable.</p>
<p>The data type <a id="_idIndexMarker090"/>and all sub-types of the variable are either physically constant or their logical constness implementation is thread-safe. For example, in the following example, the <code>Point</code> struct is physically constant because its <code>x</code> and <code>y</code> field members are primitive integers, and both threads have only <code>const</code> access to it:</p>
<pre class="source-code">
struct Point {
  int x;
  int y;
};
void foo() {
  const auto point = Point{.x = 10, .y = 10};
  auto t           = std::thread([&amp;]() { std::cout &lt;&lt;
    point.x; });
  t.join();
}</pre>
<p>The <code>DataReader</code> class that we saw earlier is logically constant because it has a mutable variable, <code>mutex</code>, but this implementation is also thread-safe (due to the lock):</p>
<pre class="source-code">
class DataReader {
public:
  Data read() const {
    auto lock = std::lock_guard&lt;std::mutex&gt;(mutex);
    // read data
    return Data{};
  }
private:
  mutable std::mutex mutex;
};</pre>
<p>However, let <a id="_idIndexMarker091"/>us look into the following case. The <code>RequestProcessor</code> class processes some heavy requests and caches the results in an internal variable:</p>
<pre class="source-code">
class RequestProcessor {
public:
  Result process(uint64_t request_id,
                 Request request) const {
    if (auto it = cache_.find(request_id); it !=
      cache_.cend()) {
      return it-&gt;second;
    }
    // process request
    // create result
    auto result = Result{};
    cache_[request_id] = result;
    return result;
  }
private:
  mutable std::unordered_map&lt;uint64_t, Result&gt; cache_;
};
void process_request() {
  auto requests = std::vector&lt;std::tuple&lt;uint64_t,
    Request&gt;&gt;{};
  const auto processor = RequestProcessor{};
  for (const auto&amp; request : requests) {
    auto t = std::thread([&amp;]() {
      processor.process(std::get&lt;0&gt;(request),
                        std::get&lt;1&gt;(request));
    });
    t.detach();
  }
}</pre>
<p>This class is<a id="_idIndexMarker092"/> logically safe, but the <code>cache_</code> variable is changed in a non-thread-safe way, which makes the class non-thread-safe even when declared as <code>const</code>.</p>
<p>Note that when working with STL containers, it is essential to remember that, despite current implementations tending to be thread-safe (physically and logically), the standard provides very specific thread-safety guarantees.</p>
<p>All functions in a container can be called simultaneously by various threads on different containers. Broadly, functions from the C++ standard library don’t read objects accessible to other threads unless they are reachable through the function arguments, which includes the <code>this</code> pointer.</p>
<p>All <code>const</code> member functions are thread-safe, meaning they can be invoked simultaneously by various threads on the same container. Furthermore, the <code>begin()</code>, <code>end()</code>, <code>rbegin()</code>, <code>rend()</code>, <code>front()</code>, <code>back()</code>, <code>data()</code>, <code>find()</code>, <code>lower_bound()</code>, <code>upper_bound()</code>, <code>equal_range()</code>, <code>at()</code>, and <code>operator[]</code> (except in associative containers) member functions also behave as <code>const</code> with regard to thread safety. In other words, they can also be invoked by various threads on the same container. Broadly, C++ standard library functions won’t modify objects unless those objects are reachable, directly or indirectly, via the function’s non-const arguments, which includes the <code>this</code> pointer.</p>
<p>Different elements in the same container can be altered simultaneously by different threads, with the exception of <code>std::vector&lt;bool&gt;</code> elements. For example, a <code>std::vector</code> of <code>std::future</code> objects can receive values from multiple threads at once.</p>
<p>Operations on<a id="_idIndexMarker093"/> iterators, such as incrementing an iterator, read the underlying container but don’t modify it. These operations can be performed concurrently with operations on other iterators of the same container, with the <code>const</code> member functions, or with reads from the elements. However, operations that invalidate any iterators modify the container and must not be performed concurrently with any operations on existing iterators, even those that are not invalidated.</p>
<p>Elements of the same container can be altered concurrently with those member functions that don’t access these elements. Broadly, C++ standard library functions won’t read objects indirectly accessible through their arguments (including other elements of a container) except when required by its specification.</p>
<p>Lastly, operations on containers (as well as algorithms or other C++ standard library functions) can be internally parallelized as long as the user-visible results remain unaffected. For example, <code>std::transform</code> can be parallelized, but <code>std::for_each</code> cannot, as it is specified to visit each element of a sequence in order.</p>
<p>The idea of having a single mutable reference to an object became one of the pillars of the Rust programming language. This rule is in place to prevent data races, which occur when multiple threads access the same mutable data concurrently, resulting in unpredictable behavior and potential crashes. By allowing only one mutable reference to an object at a time, Rust ensures that concurrent access to the same data is properly synchronized and avoids data races.</p>
<p>In addition, this rule helps prevent mutable aliasing, which occurs when multiple mutable references to the same data exist simultaneously. Mutable aliasing can lead to subtle bugs and make code difficult to reason about, especially in large and complex code bases. By allowing only one mutable reference to an object, Rust avoids mutable aliasing and helps ensure that code is correct and easy to understand.</p>
<p>However, it’s worth noting that Rust also allows multiple immutable references to an object, which can be useful in scenarios where concurrent access is necessary but mutations are not. By allowing multiple immutable references, Rust can provide better performance and concurrency while still maintaining safety and correctness.</p>
<h1 id="_idParaDest-43"><a id="_idTextAnchor042"/>Summary</h1>
<p>In this chapter, we covered the SOLID principles, the KISS principle, constness, and immutability. Let’s see what you learned!</p>
<ul>
<li>SOLID principles: SOLID is a set of five principles that help us create code that’s easy to maintain, scalable, and flexible. By understanding these principles, you’re on your way to designing code that’s a dream to work with!</li>
<li>The KISS principle: The KISS principle is all about keeping things simple. By following this principle, you’ll avoid overcomplicating your code, making it easier to maintain and debug.</li>
<li>Constness: Constness is a property in C++ that makes objects read-only. By declaring objects as <code>const</code>, you can ensure that their values won’t be accidentally changed, making your code more stable and predictable.</li>
<li>Immutability: Immutability is all about making sure objects can’t be changed after their creation. By making objects immutable, you can avoid sneaky bugs and make your code more predictable.</li>
</ul>
<p>With these design principles under your belt, you’re on your way to writing code that’s both robust and reliable. Happy coding!</p>
<p>In the next chapter, we will try to understand what causes bad code.</p>
</div>
</body></html>