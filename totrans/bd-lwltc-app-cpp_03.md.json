["```cpp\n#include <cstdio>\n#include <cstdint>\nint main() {\n  double x = 100;\n  const auto orig_x = x;\n  auto x_as_ui = (uint64_t *) (&x);\n  *x_as_ui |= 0x8000000000000000;\n  printf(“orig_x:%0.2f x:%0.2f &x:%p &x_as_ui:%p\\n”,\n       orig_x, x, &x, x_as_ui);\n}\n```", "```cpp\norig_x:100.00 x:-100.00 &x:0x7fff1e6b00d0 &x_as_ui:0x7fff1e6b00d0\n```", "```cpp\nif(a != 0) {\n if(b != 0) {\n   c = true;\n } else {\n   c = false;\n }\n} else {\n c = false;\n}\n```", "```cpp\nif(market_state == PreOpen ||\n   market_state == Opening ||\n   market_state == Trading) {\n  // do something...\n}\n```", "```cpp\nif(market_state & (PreOpen | Opening | Trading)) {\n  // do something...\n}\n```", "```cpp\nvoid func(int* a, int* b, int n) {\n  for(int i = 0; i < n; ++i) {\n    a[i] = *b;\n  }\n}\n```", "```cpp\nvoid func(int *__restrict a, int *__restrict b, int n) {\n  for (int i = 0; i < n; ++i) {\n    a[i] = *b;\n  }\n}\n```", "```cpp\n   int a[5]; a[0] = 0;\n    for(int i = 1; i < 5; ++i)\n      a[i] = a[i-1] + 1;\n```", "```cpp\n    int a[5];\n    a[0] = 0;\n    a[1] = a[0] + 1; a[2] = a[1] + 1;\n    a[3] = a[2] + 1; a[4] = a[3] + 1;\n```", "```cpp\n#define LIKELY_CONDITION(x) __builtin_expect(!!(x), 1)\n#define UNLIKELY_CONDITION (x) __builtin_expect(!!(x), 0)\n```", "```cpp\n#include <iostream>\nstruct LargeClass {\n  int i;\n  char c;\n  double d;\n};\nauto rvoExample(int i, char c, double d) {\n  return LargeClass{i, c, d};\n}\nint main() {\n  LargeClass lc_obj = rvoExample(10, ‘c’, 3.14);\n}\n```", "```cpp\n#include <cstdio>\n#include <vector>\nstruct Order { int id; double price; };\nclass InheritanceOrderBook : public std::vector<Order> { };\nclass CompositionOrderBook {\n  std::vector<Order> orders_;\npublic:\n  auto size() const noexcept {\n    return orders_.size();\n  }\n};\nint main() {\n  InheritanceOrderBook i_book;\n  CompositionOrderBook c_book;\n  printf(“InheritanceOrderBook::size():%lu Composi\n       tionOrderBook:%lu\\n”, i_book.size(), c_book.size());\n}\n```", "```cpp\n#include <cstdio>\nclass RuntimeExample {\npublic:\n  virtual void placeOrder() {\n    printf(“RuntimeExample::placeOrder()\\n”);\n  }\n};\nclass SpecificRuntimeExample : public RuntimeExample {\npublic:\n  void placeOrder() override {\n    printf(“SpecificRuntimeExample::placeOrder()\\n”);\n  }\n};\n```", "```cpp\ntemplate <typename actual_type>\nclass CRTPExample {\npublic:\n  void placeOrder() {\n    static_cast<actual_type*>(this)->actualPlaceOrder();\n  }\n  void actualPlaceOrder() {\n    printf(“CRTPExample::actualPlaceOrder()\\n”);\n  }\n};\nclass SpecificCRTPExample : public CRTPExample<Specific\n     CRTPExample> {\npublic:\n  void actualPlaceOrder() {\n    printf(“SpecificCRTPExample::actualPlaceOrder()\\n”);\n  }\n};\n```", "```cpp\nint main(int, char **) {\n  RuntimeExample* runtime_example = new SpecificRuntimeEx\n       ample();\n  runtime_example->placeOrder();\n  CRTPExample<SpecificCRTPExample> crtp_example;\n  crtp_example.placeOrder();\n  return 0;\n}\n```", "```cpp\nSpecificRuntimeExample::placeOrder()\nSpecificCRTPExample::actualPlaceOrder()\n```", "```cpp\n#include <cstdio>\n#include <cstdint>\n#include <cstddef>\nstruct PoorlyAlignedData {\n  char c;\n  uint16_t u;\n  double d;\n  int16_t i;\n};\nstruct WellAlignedData {\n  double d;\n  uint16_t u;\n  int16_t i;\n  char c;\n};\n#pragma pack(push, 1)\nstruct PackedData {\n  double d;\n  uint16_t u;\n  int16_t i;\n  char c;\n};\n#pragma pack(pop)\nint main() {\n  printf(“PoorlyAlignedData c:%lu u:%lu d:%lu i:%lu\n       size:%lu\\n”,\n         offsetof(struct PoorlyAlignedData,c), offsetof\n              (struct PoorlyAlignedData,u), offsetof(struct\n              PoorlyAlignedData,d), offsetof(struct PoorlyA\n              lignedData,i), sizeof(PoorlyAlignedData));\n  printf(“WellAlignedData d:%lu u:%lu i:%lu c:%lu\n       size:%lu\\n”,\n         offsetof(struct WellAlignedData,d), offsetof\n              (struct WellAlignedData,u), offsetof(struct\n              WellAlignedData,i), offsetof(struct WellAligned\n              Data,c), sizeof(WellAlignedData));\n  printf(“PackedData d:%lu u:%lu i:%lu c:%lu size:%lu\\n”,\n         offsetof(struct PackedData,d), offsetof(struct\n              PackedData,u), offsetof(struct PackedData,i),\n              offsetof(struct PackedData,c), sizeof\n              (PackedData));\n}\n```", "```cpp\nPoorlyAlignedData c:0 u:2 d:8 i:16 size:24\nWellAlignedData d:0 u:8 i:10 c:12 size:16\nPackedData d:0 u:8 i:10 c:12 size:13\n```", "```cpp\n#include <cstdio>\n#include <cstdint>\n#include <cstdlib>\nenum class Side : int16_t { BUY = 1, SELL = -1 };\nint main() {\n  const auto fill_side = (rand() % 2 ? Side::BUY : Side\n       ::SELL);\n  const int fill_qty = 10;\n  printf(“fill_side:%s fill_qty:%d.\\n”, (fill_side == Side\n       ::BUY ? “BUY” : (fill_side == Side::SELL ? “SELL” :\n         “INVALID”)), fill_qty);\n  { // with branching\n    int last_buy_qty = 0, last_sell_qty = 0, position = 0;\n    if (fill_side == Side::BUY) {\n      position += fill_qty; last_buy_qty = fill_qty;\n    } else if (fill_side == Side::SELL) {\n      position -= fill_qty; last_sell_qty = fill_qty; }\n    printf(“With branching - position:%d last-buy:%d last-\n         sell:%d.\\n”, position, last_buy_qty,\n           last_sell_qty);\n  }\n  { // without branching\n    int last_qty[3] = {0, 0, 0}, position = 0;\n    auto sideToInt = [](Side side) noexcept { return\n         static_cast<int16_t>(side); };\n    const auto int_fill_side = sideToInt(fill_side);\n    position += int_fill_side * fill_qty;\n    last_qty[int_fill_side + 1] = fill_qty;\n    printf(“Without branching - position:%d last-buy:%d\n         last-sell:%d.\\n”, position, last_qty[sideToInt\n           (Side::BUY) + 1], last_qty[side\n             ToInt(Side::SELL)+\n             1]);\n  }\n}\n```", "```cpp\nfill_side:BUY fill_qty:10.\nWith branching - position:10 last-buy:10 last-sell:0.\nWithout branching - position:10 last-buy:10 last-sell:0.\n```", "```cpp\nx = a + b + c + d + e + f;\n```", "```cpp\nx = a + b;\nx = x + c;\nx = x + d;\nx = x +e;\nx = x + f;\n```", "```cpp\nx = a + b; p = c + d;\nq = e + f; x = x + p;\nx = x + q;\n```", "```cpp\n  const size_t size = 1024;\n  float x[size], a[size], b[size];\n  for (size_t i = 0; i < size; ++i) {\n    x[i] = a[i] + b[i];\n  }\n```", "```cpp\n  for (size_t i = 0; i < size; i += 4) {\n    x[i] = a[i] + b[i];\n    x[i + 1] = a[i + 1] + b[i + 1];\n    x[i + 2] = a[i + 2] + b[i + 2];\n    x[i + 3] = a[i + 3] + b[i + 3];\n```", "```cpp\n#include <cstdint>\nint main() {\n  const auto price = 10.125; // prices are like: 10.125,\n       10.130, 10.135...\n  constexpr auto min_price_increment = 0.005;\n  [[maybe_unused]] int64_t int_price = 0;\n  // no strength reduction\n  int_price = price / min_price_increment;\n  // strength reduction\n  constexpr auto inv_min_price_increment = 1 /\n       min_price_increment;\n  int_price = price * inv_min_price_increment;\n}\n```", "```cpp\nauto __attribute__ ((noinline)) factorial(unsigned n) ->\n     unsigned {\n  return (n ? n * factorial(n - 1) : 1);\n}\nint main() {\n  [[maybe_unused]] volatile auto res = factorial(100);\n}\n```", "```cpp\ng++ -S -Wall -O3 tail_call.cpp ; cat tail_call.s\n```", "```cpp\n    main:\n    ```", "```cpp\n    .LFB1\n    ```", "```cpp\n        Movl    $100, %edi\n    ```", "```cpp\n        Call    _Z9factorialj\n    ```", "```cpp\n_Z9factorialj:\n.LFB0:\n    Movl    $1, %eax\n    testl    %edi, %edi\n    je    .L4\n.L3:\n    Imull    %edi, %eax\n    subl    $1, %edi\n    jne    .L3\n    ret\n.L4:\n    ret\n```", "```cpp\n  for(auto i = 0; i < 100; ++i)\n    a[i] = i * 10 + 12;\ngets transformed into something of the form presented below\n     and avoids the multiplication in the loop and replaces\n     it\n       with an induction variable based addition.\n  int temp = 12;\n  for(auto i = 0; i < 100; ++i) {\n    a[i] = temp;\n    temp += 10;\n  }\n```", "```cpp\nif(!a && !b) {}\n```", "```cpp\nif(!(a || b)) {}\n```", "```cpp\n#include <cstdlib>\nint main() {\n  auto doSomething = [](double r) noexcept { return 3.14 *\n       r * r; };\n  [[maybe_unused]] int a[100], b = rand();\n  // original\n  for(auto i = 0; i < 100; ++i)\n    a[i] = (doSomething(50) + b * 2) + 1;\n  // loop invariant code movement\n  auto temp = (doSomething(50) + b * 2) + 1;\n  for(auto i = 0; i < 100; ++i)\n    a[i] = temp;\n}\n```"]