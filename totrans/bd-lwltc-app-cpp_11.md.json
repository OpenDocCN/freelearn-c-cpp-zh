["```cpp\nsghosh@sghosh-ThinkPad-X1-Carbon-3rd:~/Building-Low-Latency-Applications-with-CPP/Chapter11$ cat /proc/cpuinfo | grep MHz\ncpu MHz         : 2645.048\ncpu MHz         : 2645.035\ncpu MHz         : 2645.033\ncpu MHz         : 2645.050\n```", "```cpp\n#pragma once\nnamespace Common {\n  inline auto rdtsc() noexcept {\n    unsigned int lo, hi;\n    __asm__ __volatile__ (\"rdtsc\" : \"=a\" (lo), \"=d\" (hi));\n    return ((uint64_t) hi << 32) | lo;\n  }\n}\n```", "```cpp\n#define START_MEASURE(TAG) const auto TAG = Common::rdtsc()\n```", "```cpp\n#define END_MEASURE(TAG, LOGGER) \\\n      do { \\\n        const auto end = Common::rdtsc(); \\\n        LOGGER.log(\"% RDTSC \"#TAG\" %\\n\",\n          Common::getCurrentTimeStr(&time_str_), (end -\n            TAG)); \\\n      } while(false)\n```", "```cpp\n#define TTT_MEASURE(TAG, LOGGER) \\\n      do { \\\n        const auto TAG = Common::getCurrentNanos(); \\\n        LOGGER.log(\"% TTT \"#TAG\" %\\n\", Common::\n          getCurrentTimeStr(&time_str_), TAG); \\\n      } while(false)\n```", "```cpp\nonMarketUpdate() Sat Jun  3 09:46:34 2023 MEMarketUpdate\n```", "```cpp\nonMarketUpdate() 09:46:34.645778416 MEMarketUpdate\n```", "```cpp\n#include \"perf_utils.h\"\n```", "```cpp\nnamespace Common {\n  inline auto& getCurrentTimeStr(std::string* time_str) {\n    const auto clock = std::chrono::system_clock::now();\n    const auto time = std::chrono::\n      system_clock::to_time_t(clock);\n```", "```cpp\n    char nanos_str[24];\n    sprintf(nanos_str, \"%.8s.%09ld\", ctime(&time) + 11,\n      std::chrono::duration_cast<std::chrono::nanoseconds>\n       (clock.time_since_epoch()).count() % NANOS_TO_SECS);\n    time_str->assign(nanos_str);\n    return *time_str;\n  }\n}\n```", "```cpp\n  auto MarketDataPublisher::run() noexcept -> void {\n    ...\n    while (run_) {\n      for (auto market_update = outgoing_md_updates_->\n        getNextToRead();\n           outgoing_md_updates_->size() && market_update;\n             market_update = outgoing_md_updates_->\n               getNextToRead()) {\n        TTT_MEASURE(T5_MarketDataPublisher_LFQueue_read,\n          logger_);\n```", "```cpp\n        START_MEASURE(Exchange_McastSocket_send);\n        incremental_socket_.send(&next_inc_seq_num_,\n          sizeof(next_inc_seq_num_));\n        incremental_socket_.send(market_update,\n          sizeof(MEMarketUpdate));\n        END_MEASURE(Exchange_McastSocket_send, logger_);\n```", "```cpp\n        outgoing_md_updates_->updateReadIndex();\n        TTT_MEASURE(T6_MarketDataPublisher_UDP_write,\n          logger_);\n        ...\n```", "```cpp\n    auto run() noexcept {\n      ...\n      while (run_) {\n      ...\n        for (auto client_response = outgoing_responses_->\n          getNextToRead(); outgoing_responses_->size() &&\n            client_response; client_response =\n              outgoing_responses_->getNextToRead()) {\n          TTT_MEASURE(T5t_OrderServer_LFQueue_read,\n            logger_);\n```", "```cpp\n          START_MEASURE(Exchange_TCPSocket_send);\n          cid_tcp_socket_[client_response->client_id_]->\n            send(&next_outgoing_seq_num,\n              sizeof(next_outgoing_seq_num));\n          cid_tcp_socket_[client_response->client_id_]->\n             send(client_response,\n               sizeof(MEClientResponse));\n          END_MEASURE(Exchange_TCPSocket_send, logger_);\n```", "```cpp\n          outgoing_responses_->updateReadIndex();\n          TTT_MEASURE(T6t_OrderServer_TCP_write, logger_);\n          ...\n```", "```cpp\n    auto recvCallback(TCPSocket *socket, Nanos rx_time)\n      noexcept {\n      TTT_MEASURE(T1_OrderServer_TCP_read, logger_);\n      ...\n```", "```cpp\nSTART_MEASURE(Exchange_FIFOSequencer_addClientRequest);\n          fifo_sequencer_.addClientRequest(rx_time,\n            request->me_client_request_);\n              END_MEASURE(Exchange_FIFOSequencer_\n                addClientRequest, logger_);\n          ...\n```", "```cpp\n    auto recvFinishedCallback() noexcept {\n    START_MEASURE(Exchange_FIFOSequencer_sequenceAndPublis)\n    ;\n      fifo_sequencer_.sequenceAndPublish();\n      END_MEASURE(Exchange_FIFOSequencer_\n        sequenceAndPublish, logger_);\n    }\n```", "```cpp\n    auto sequenceAndPublish() {\n      for (size_t i = 0; i < pending_size_; ++i) {\n        ...\n        auto next_write = incoming_requests_->\n          getNextToWriteTo();\n        *next_write = std::move(client_request.request_);\n        incoming_requests_->updateWriteIndex();\n        TTT_MEASURE(T2_OrderServer_LFQueue_write,\n          (*logger_));\n        ...\n```", "```cpp\n    auto processClientRequest(const MEClientRequest\n      *client_request) noexcept {\n      ...\n      switch (client_request->type_) {\n        case ClientRequestType::NEW: {\n          START_MEASURE(Exchange_MEOrderBook_add);\n          order_book->add(client_request->client_id_,\n           client_request->order_id_, client_request->\n             ticker_id_,\n                           client_request->side_,\n                             client_request->price_,\n                               client_request->qty_);\n          END_MEASURE(Exchange_MEOrderBook_add, logger_);\n          ...\n```", "```cpp\n        case ClientRequestType::CANCEL: {\n          START_MEASURE(Exchange_MEOrderBook_cancel);\n          order_book->cancel(client_request->client_id_,\n            client_request->order_id_, client_request->\n              ticker_id_);\n          END_MEASURE(Exchange_MEOrderBook_cancel,\n            logger_);\n          ...\n```", "```cpp\n    auto sendClientResponse(const MEClientResponse\n      *client_response) noexcept {\n      ...\n      auto next_write = outgoing_ogw_responses_->\n        getNextToWriteTo();\n      *next_write = std::move(*client_response);\n      outgoing_ogw_responses_->updateWriteIndex();\n      TTT_MEASURE(T4t_MatchingEngine_LFQueue_write,\n        logger_);\n    }\n```", "```cpp\n    auto sendMarketUpdate(const MEMarketUpdate\n      *market_update) noexcept {\n      ...\n      auto next_write = outgoing_md_updates_->\n        getNextToWriteTo();\n      *next_write = *market_update;\n      outgoing_md_updates_->updateWriteIndex();\n      TTT_MEASURE(T4_MatchingEngine_LFQueue_write,\n        logger_);\n    }\n```", "```cpp\n    auto run() noexcept {\n      while (run_) {\n        const auto me_client_request = incoming_requests_->\n          getNextToRead();\n        if (LIKELY(me_client_request)) {\n          TTT_MEASURE(T3_MatchingEngine_LFQueue_read,\n            logger_);\n```", "```cpp\nSTART_MEASURE(Exchange_MatchingEngine_processClientRequest);          processClientRequest(me_client_request);\nEND_MEASURE(Exchange_MatchingEngine_processClientRequest,\n  logger_);\n          ...\n```", "```cpp\n  auto MEOrderBook::match(TickerId ticker_id, ClientId\n    client_id, Side side, OrderId client_order_id, OrderId\n      new_market_order_id, MEOrder* itr, Qty* leaves_qty)\n        noexcept {\n    ...\n    if (!order->qty_) {\n      ...\n      START_MEASURE(Exchange_MEOrderBook_removeOrder);\n      removeOrder(order);\n      END_MEASURE(Exchange_MEOrderBook_removeOrder,\n        (*logger_));\n      ...\n```", "```cpp\n  auto MEOrderBook::checkForMatch(ClientId client_id,\n    OrderId client_order_id, TickerId ticker_id, Side side,\n      Price price, Qty qty, Qty new_market_order_id)\n        noexcept {\n    ...\n    if (side == Side::BUY) {\n      while (leaves_qty && asks_by_price_) {\n        ...\n        START_MEASURE(Exchange_MEOrderBook_match);\n        match(ticker_id, client_id, side, client_order_id,\n          new_market_order_id, ask_itr, &leaves_qty);\n        END_MEASURE(Exchange_MEOrderBook_match,\n          (*logger_));\n      }\n    }\n    if (side == Side::SELL) {\n      while (leaves_qty && bids_by_price_) {\n        ...\n        START_MEASURE(Exchange_MEOrderBook_match);\n        match(ticker_id, client_id, side, client_order_id,\n          new_market_order_id, bid_itr, &leaves_qty);\n        END_MEASURE(Exchange_MEOrderBook_match,\n          (*logger_));\n      }\n    }\n    ...\n```", "```cpp\n  auto MEOrderBook::add(ClientId client_id, OrderId\n    client_order_id, TickerId ticker_id, Side side, Price\n      price, Qty qty) noexcept -> void {\n    ...\n    START_MEASURE(Exchange_MEOrderBook_checkForMatch);\n    const auto leaves_qty = checkForMatch(client_id,\n      client_order_id, ticker_id, side, price, qty,\n        new_market_order_id);\n    END_MEASURE(Exchange_MEOrderBook_checkForMatch,\n      (*logger_));\n    …\n```", "```cpp\n      START_MEASURE(Exchange_MEOrderBook_addOrder);\n      addOrder(order);\n      END_MEASURE(Exchange_MEOrderBook_addOrder,\n       (*logger_));\n      ...\n```", "```cpp\n  auto MEOrderBook::cancel(ClientId client_id, OrderId\n    order_id, TickerId ticker_id) noexcept -> void {\n      ...\n      START_MEASURE(Exchange_MEOrderBook_removeOrder);\n      removeOrder(exchange_order);\n      END_MEASURE(Exchange_MEOrderBook_removeOrder,\n        (*logger_));\n      ...\n```", "```cpp\n  auto MarketDataConsumer::recvCallback(McastSocket\n    *socket) noexcept -> void {\n    TTT_MEASURE(T7_MarketDataConsumer_UDP_read, logger_);\n```", "```cpp\n    START_MEASURE(Trading_MarketDataConsumer_recvCallback);\n    ...\n    END_MEASURE(Trading_MarketDataConsumer_recvCallback,\n      logger_);\n  }\n```", "```cpp\n          auto next_write = incoming_md_updates_->\n            getNextToWriteTo();\n          *next_write = std::move(request->\n            me_market_update_);\n          incoming_md_updates_->updateWriteIndex();\n          TTT_MEASURE(T8_MarketDataConsumer_LFQueue_write,\n            logger_);\n```", "```cpp\n  auto OrderGateway::run() noexcept -> void {\n      ...\n      for(auto client_request = outgoing_requests_->\n       getNextToRead(); client_request; client_request =\n         outgoing_requests_->getNextToRead()) {\n        TTT_MEASURE(T11_OrderGateway_LFQueue_read,\n          logger_);\n```", "```cpp\n        START_MEASURE(Trading_TCPSocket_send);\n        tcp_socket_.send(&next_outgoing_seq_num_,\n          sizeof(next_outgoing_seq_num_));\n        tcp_socket_.send(client_request,\n          sizeof(Exchange::MEClientRequest));\n        END_MEASURE(Trading_TCPSocket_send, logger_);\n```", "```cpp\n        outgoing_requests_->updateReadIndex();\n        TTT_MEASURE(T12_OrderGateway_TCP_write, logger_);\n```", "```cpp\n  auto OrderGateway::recvCallback(TCPSocket *socket, Nanos\n    rx_time) noexcept -> void {\n    TTT_MEASURE(T7t_OrderGateway_TCP_read, logger_);\n```", "```cpp\n    START_MEASURE(Trading_OrderGateway_recvCallback);\n    ...\n    END_MEASURE(Trading_OrderGateway_recvCallback,\n      logger_);\n  }\n```", "```cpp\n        auto next_write = incoming_responses_->\n          getNextToWriteTo();\n        *next_write = std::move(response->\n          me_client_response_);\n        incoming_responses_->updateWriteIndex();\n        TTT_MEASURE(T8t_OrderGateway_LFQueue_write,\n          logger_);\n```", "```cpp\n  auto TradeEngine::sendClientRequest(const\n    Exchange::MEClientRequest *client_request) noexcept -> void {\n    auto next_write = outgoing_ogw_requests_->\n     getNextToWriteTo();\n    *next_write = std::move(*client_request);\n    outgoing_ogw_requests_->updateWriteIndex();\n    TTT_MEASURE(T10_TradeEngine_LFQueue_write, logger_);\n```", "```cpp\n  auto TradeEngine::run() noexcept -> void {\n    while (run_) {\n      for (auto client_response = incoming_ogw_responses_->\n        getNextToRead(); client_response; client_response =\n          incoming_ogw_responses_->getNextToRead()) {\n        TTT_MEASURE(T9t_TradeEngine_LFQueue_read, logger_);\n```", "```cpp\n      for (auto market_update = incoming_md_updates_->\n        getNextToRead(); market_update; market_update =\n          incoming_md_updates_->getNextToRead()) {\n        TTT_MEASURE(T9_TradeEngine_LFQueue_read, logger_);\n```", "```cpp\n  auto TradeEngine::onOrderBookUpdate(TickerId ticker_id,\n    Price price, Side side, MarketOrderBook *book) noexcept\n    -> void {\n    ...\n    START_MEASURE(Trading_PositionKeeper_updateBBO);\n    position_keeper_.updateBBO(ticker_id, bbo);\n    END_MEASURE(Trading_PositionKeeper_updateBBO, logger_);\n```", "```cpp\n    START_MEASURE(Trading_FeatureEngine_onOrderBookUpdate);\n    feature_engine_.onOrderBookUpdate(ticker_id, price,\n      side, book);\n    END_MEASURE(Trading_FeatureEngine_onOrderBookUpdate,\n      logger_);\n```", "```cpp\n START_MEASURE(Trading_TradeEngine_algoOnOrderBookUpdate_);\n    algoOnOrderBookUpdate_(ticker_id, price, side, book);\n    END_MEASURE(Trading_TradeEngine_algoOnOrderBookUpdate_,\n      logger_);\n```", "```cpp\n  auto TradeEngine::onTradeUpdate(const\n    Exchange::MEMarketUpdate *market_update,\n      MarketOrderBook *book) noexcept -> void {\n    ...\n    START_MEASURE(Trading_FeatureEngine_onTradeUpdate);\n    feature_engine_.onTradeUpdate(market_update, book);\n    END_MEASURE(Trading_FeatureEngine_onTradeUpdate,\n      logger_);\n```", "```cpp\n    START_MEASURE(Trading_TradeEngine_algoOnTradeUpdate_);\n    algoOnTradeUpdate_(market_update, book);\n    END_MEASURE(Trading_TradeEngine_algoOnTradeUpdate_,\n      logger_);\n```", "```cpp\n  auto TradeEngine::onOrderUpdate(const\n    Exchange::MEClientResponse *client_response) noexcept -\n     > void {\n    if (UNLIKELY(client_response->type_ ==\n      Exchange::ClientResponseType::FILLED)) {\n      START_MEASURE(Trading_PositionKeeper_addFill);\n      position_keeper_.addFill(client_response);\n      END_MEASURE(Trading_PositionKeeper_addFill, logger_);\n    }\n```", "```cpp\n    START_MEASURE(Trading_TradeEngine_algoOnOrderUpdate_);\n    algoOnOrderUpdate_(client_response);\n    END_MEASURE(Trading_TradeEngine_algoOnOrderUpdate_,\n      logger_);\n```", "```cpp\n    auto moveOrder(OMOrder *order, TickerId ticker_id,\n      Price price, Side side, Qty qty) noexcept {\n      switch (order->order_state_) {\n        case OMOrderState::LIVE: {\n          if(order->price_ != price) {\n           START_MEASURE(Trading_OrderManager_cancelOrder);\n            cancelOrder(order);\n            END_MEASURE(Trading_OrderManager_cancelOrder,\n              (*logger_));\n```", "```cpp\n        case OMOrderState::DEAD: {\n          if(LIKELY(price != Price_INVALID)) {\n            START_MEASURE(Trading_RiskManager_checkPreTrade\nRisk);\n            const auto risk_result =\n              risk_manager_.checkPreTradeRisk(ticker_id,\n                side, qty);\n            END_MEASURE(Trading_RiskManager_checkPreTradeRi\nsk,\n  (*logger_));\n```", "```cpp\n            if(LIKELY(risk_result ==\n              RiskCheckResult::ALLOWED)) {\n              START_MEASURE(Trading_OrderManager_newOrder);\n              newOrder(order, ticker_id, price, side, qty);\n              END_MEASURE(Trading_OrderManager_newOrder,\n                (*logger_));\n```", "```cpp\n    auto moveOrders(TickerId ticker_id, Price bid_price,\n      Price ask_price, Qty clip) noexcept {\n        ...\n        START_MEASURE(Trading_OrderManager_moveOrder);\n        moveOrder(bid_order, ticker_id, bid_price,\n          Side::BUY, clip);\n        END_MEASURE(Trading_OrderManager_moveOrder,\n          (*logger_));\n        ...\n        START_MEASURE(Trading_OrderManager_moveOrder);\n        moveOrder(ask_order, ticker_id, ask_price,\n          Side::SELL, clip);\n        END_MEASURE(Trading_OrderManager_moveOrder,\n          (*logger_));\n```", "```cpp\n  auto MarketOrderBook::onMarketUpdate(const\n    Exchange::MEMarketUpdate *market_update) noexcept ->\nvoid {\n    ...\n    switch (market_update->type_) {\n      case Exchange::MarketUpdateType::ADD: {\n        auto order = order_pool_.allocate(market_update->\n          order_id_, market_update->side_, market_update->\n            price_,\n                                          market_update->\n                                            qty_,\n                                     market_update-\n                                       >priority_, nullptr,\n                                         nullptr);\n        START_MEASURE(Trading_MarketOrderBook_addOrder);\n        addOrder(order);\n        END_MEASURE(Trading_MarketOrderBook_addOrder,\n          (*logger_));\n```", "```cpp\n      case Exchange::MarketUpdateType::CANCEL: {\n        auto order = oid_to_order_.at(market_update-\n          >order_id_);\n        START_MEASURE(Trading_MarketOrderBook_removeOrder);\n        removeOrder(order);\n        END_MEASURE(Trading_MarketOrderBook_removeOrder,\n          (*logger_));\n```", "```cpp\n    START_MEASURE(Trading_MarketOrderBook_updateBBO);\n    updateBBO(bid_updated, ask_updated);\n    END_MEASURE(Trading_MarketOrderBook_updateBBO,\n      (*logger_));\n```", "```cpp\n    auto onTradeUpdate(const Exchange::MEMarketUpdate\n      *market_update, MarketOrderBook *book) noexcept ->\nvoid {\n        ...\n        if (agg_qty_ratio >= threshold) {\n          START_MEASURE(OrderManager_moveOrders);\n          if (market_update->side_ == Side::BUY)\n            order_manager_->moveOrders(market_update->\n              ticker_id_, bbo->ask_price_, Price_INVALID,\n                clip);\n          else\n            order_manager_->moveOrders(market_update->\n              ticker_id_, Price_INVALID, bbo->bid_price_,\n                clip);\n          END_MEASURE(OrderManager_moveOrders, (*logger_));\n        }\n```", "```cpp\n    auto onOrderUpdate(const Exchange::MEClientResponse\n      *client_response) noexcept -> void {\n      START_MEASURE(Trading_OrderManager_onOrderUpdate);\n      order_manager_->onOrderUpdate(client_response);\n      END_MEASURE(Trading_OrderManager_onOrderUpdate,\n        (*logger_));\n```", "```cpp\n    auto onOrderBookUpdate(TickerId ticker_id, Price price,\n      Side side, const MarketOrderBook *book) noexcept ->\nvoid {\n        ...\n        START_MEASURE(Trading_OrderManager_moveOrders);\n        order_manager_->moveOrders(ticker_id, bid_price,\n          ask_price, clip);\n        END_MEASURE(Trading_OrderManager_moveOrders,\n          (*logger_));\n```", "```cpp\n    auto onOrderUpdate(const Exchange::MEClientResponse\n      *client_response) noexcept -> void {\n      ...\n      START_MEASURE(Trading_OrderManager_onOrderUpdate);\n      order_manager_->onOrderUpdate(client_response);\n      END_MEASURE(Trading_OrderManager_onOrderUpdate,\n        (*logger_));\n```", "```cpp\nsghosh@sghosh-ThinkPad-X1-Carbon-3rd:~/Building-Low-Latency-Applications-with-CPP/Chapter11$ bash scripts/run_exchange_and_clients.sh\n```", "```cpp\nsghosh@sghosh-ThinkPad-X1-Carbon-3rd:~/Building-Low-Latency-Applications-with-CPP/Chapter11$ grep Exchange_MEOrderBook_match *.log\nexchange_matching_engine.log:02:42:59.980424597 RDTSC Exchange_MEOrderBook_match 205247\nexchange_matching_engine.log:02:43:00.022326352 RDTSC Exchange_MEOrderBook_match 216239\n```", "```cpp\nsghosh@sghosh-ThinkPad-X1-Carbon-3rd:~/Building-Low-Latency-Applications-with-CPP/Chapter11$ grep Trading_MarketOrderBook_addOrder *.log\ntrading_engine_1.log:02:44:18.894251975 RDTSC Trading_MarketOrderBook_addOrder 204\ntrading_engine_1.log:02:44:18.904221378 RDTSC Trading_MarketOrderBook_addOrder 971\n```", "```cpp\nsghosh@sghosh-ThinkPad-X1-Carbon-3rd:~/Building-Low-Latency-Applications-with-CPP/Chapter11$ grep T6_MarketDataPublisher_UDP_write *.log\nexchange_market_data_publisher.log:02:40:13.596201293 TTT T6_MarketDataPublisher_UDP_write 1685864413596201240\nexchange_market_data_publisher.log:02:40:13.624236967 TTT T6_MarketDataPublisher_UDP_write 1685864413624236907\n```", "```cpp\nsghosh@sghosh-ThinkPad-X1-Carbon-3rd:~/Building-Low-Latency-Applications-with-CPP/Chapter11$ grep T8t_OrderGateway_LFQueue_write *.log\ntrading_order_gateway_1.log:02:40:14.524401434 TTT T8t_OrderGateway_LFQueue_write 1685864414524401386\ntrading_order_gateway_1.log:02:40:14.524425862 TTT T8t_OrderGateway_LFQueue_write 1685864414524425811\n```"]