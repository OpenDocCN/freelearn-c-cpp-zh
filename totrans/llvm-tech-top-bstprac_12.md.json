["```cpp\n$ ninja opt\n```", "```cpp\nint foo(int* restrict x, int* restrict y) {\n  *x = *y + 1;\n  return *y;\n}\n```", "```cpp\n…\n// Programmers will NEVER write the following code\nint main() {\n  int V = 1;\n  return foo(&V, &V);\n}\n```", "```cpp\nfoo:                                    \n     mov   eax, dword ptr [rsi]\n     add   eax, 1\n     mov   dword ptr [rdi], eax\n     mov   eax, dword ptr [rsi]\n     ret\n```", "```cpp\nfoo:                                    \n     mov   eax, dword ptr [rsi]\n     lea   ecx, [rax + 1]\n     mov   dword ptr [rdi], ecx\n     ret\n```", "```cpp\ndefine i32 @foo(i32* noalias %0, i32* noalias %1) {\n  %3 = load i32, i32* %1\n  %4 = add i32 %3, 1\n  store i32 %4, i32* %0\n  ret i32 %3\n}\n```", "```cpp\ndefine i32 @foo(i32* %0, i32* %1) {\n  %3 = load i32, i32* %1\n  %4 = add i32 %3, 1\n  store i32 %4, i32* %0\n  %5 = load i32, i32* %1\n  ret i32 %5\n}\n```", "```cpp\n$ opt --load-pass-plugin=StrictOpt.so \\\n      --passes=\"function(strict-opt)\" \\\n      -S -o – test.ll\n```", "```cpp\n$ opt -O3 --enable-new-pm \\\n      --load-pass-plugin=StrictOpt.so \\\n      -S -o – test.ll\n```", "```cpp\n    #include \"llvm/IR/PassManager.h\"\n    struct StrictOpt : public Function IR unit. The run method is the primary entry point for this Pass, which we are going to fill in later. It takes two arguments: a Function class that we will work on and a FunctionAnalysisManager class that can give you analysis data. It returns a PreservedAnalyses instance, which tells PassManager (and AnalysisManager) what analysis data was *invalidated* by this Pass.If you have prior experience in writing LLVM Pass for the *legacy* PassManager, you might find several differences between the legacy Pass and the new Pass:a) The Pass class no longer derives from one of the `FunctionPass`, `ModulePass`, or `LoopPass`. Instead, the Passes running on different IR units are all deriving from `PassInfoMixin<YOUR_PASS>`. In fact, deriving from `PassInfoMixin` is *not* even a requirement for a functional Pass anymore – we will leave this as an exercise for you.b) Instead of *overriding* methods, such as `runOnFunction` or `runOnModule`, you will define a normal class member method, `run` (be aware that `run` does *not* have an `override` keyword that follows), which operates on the desired IR unit.Overall, the new Pass has a cleaner interface compared to the legacy one. This difference also allows the new PassManager to have less overhead runtime.\n    ```", "```cpp\n    #include \"StrictOpt.h\"\n    using namespace llvm;\n    PreservedAnalyses StrictOpt::run(Function &F,\n                              FunctionAnalysisManager &FAM) {\n      return PreservedAnalyses::all(); // Just a placeholder\n    }\n    ```", "```cpp\n    // Inside StrictOpt::run…\n    bool Modified = false;\n    for (auto &Arg : F.args() method of the Function class will return a range of Argument instances representing all of the formal parameters. We check each of their types to make sure there isn't an existing noalias attribute (which is represented by the Attribute::NoAlias enum). If everything looks good, we use addAttr to attach noalias. Here, the `Modified` flag here records whether any of the arguments were modified in this function. We will use this flag shortly.\n    ```", "```cpp\n    #include \"llvm/Analysis/AliasAnalysis.h\"\n    …\n    // Inside StrictOpt::run…\n    auto PA = PreservedAnalyses instance, PA, which represents *all analyses*. Then, if the Function class we are working on here has been modified, we *discard* the AAManager analysis via the abandon method. AAManager represents the noalias attribute we are discussing here has strong relations with this analysis since they're working on a nearly identical problem. Therefore, if any new noalias attribute was generated, all the cached alias analysis data would be outdated. This is why we invalidate it using abandon.Note that you can always return a `PreservedAnalyses::none()` instance, which tells AnalysisManager to mark *every* analysis as outdated if you are not sure what analyses have been affected. This comes at a cost, of course, since AnalysisManager then needs to spend extra effort to recalculate the analyses that might contain expensive computations.\n    ```", "```cpp\n    extern \"C\" ::llvm::PassPluginLibraryInfo instance, which contains various piecesLLVM_PLUGIN_API_VERSION) and the Pass name (StrictOpt). One of its most important fields is a lambda function that takes a single PassBuilder& argument. In that particular function, we are going to insert our StrictOpt into a proper position within the Pass pipeline.`PassBuilder`, as its name suggests, is an entity LLVM that is used to build the Pass pipeline. In addition to its primary job, which involves configuring the pipeline according to the optimization level, it also allows developers to insert Passes into some of the places in the pipeline. Furthermore, to increase its flexibility, `PassBuilder` allows you to specify a *textual* description of the pipeline you want to run by using the `--passes` argument on `opt`, as we have seen previously. For instance, the following command will run `InstCombine`, `PromoteMemToReg`, and `SROA` (`opt` will run our Pass if `strict-opt` appears in the `--passes` argument, as follows:\n\n    ```", "```cpp\n    …\n    [](PassBuilder &PB) {\n      using PipelineElement = typename PassBuilder::PipelineElement;\n      PB.registerPipelineParsingCallback method takes another lambda callback as the argument. This callback is invoked whenever PassBuilder encounters an unrecognized Pass name while parsing the textual pipeline representation. Therefore, in our implementation, we simply insert our StrictOpt pass into the pipeline via FunctionPassManager::addPass when the unrecognized Pass name, that is, the Name parameter, is strict-opt.\n    ```", "```cpp\n\n    ```", "```cpp\n    $ opt -O2 --enable-new-pm \\\n          --enable-new-pm flag in the preceding command forced opt to use the new PassManager since it's still using the legacy one by default. We haven't used this flag before because --passes implicitly enables the new PassManager under the hood.)To do this, instead of using `PassBuilder::registerPipelineParsingCallback` to register a custom (pipeline) parser callback, we are going to use `registerPipelineStartEPCallback` to handle this. Here is the alternative version of the code snippet from the previous step:\n\n    ```", "```cpp\n\n    ```", "```cpp\nint foo(int x, int y) {\n  if (x < 43) {\n    my_halt();\n    if (y > 45)\n      return x + 1;\n    else {\n      bar();\n      return x;\n    }\n  } else {\n    return y;\n  }\n}\n```", "```cpp\n$ opt --enable-new-pm --load-pass-plugin ./HaltAnalyzer.so \\\n      --disable-output ./test.ll\n[WARNING] Unreachable BB: label %if.else\n[WARNING] Unreachable BB: label %if.then2\n$\n```", "```cpp\n    class HaltAnalyzer : public PassInfoMixin<HaltAnalyzer> {\n      static constexpr const char* HaltFuncName = \"my_halt\";\n      // All the call sites to \"my_halt\"\n      SmallVector<Instruction*, 2> run method that we saw in the previous section, we are creating an additional method, findHaltCalls, which will collect all of the Instruction calls to my_halt in the current function and store them inside the Calls vector.\n    ```", "```cpp\n    void HaltAnalyzer::findHaltCalls(Function &F) {\n      Calls.clear();\n      for (auto &I : llvm::instructions to iterate through every Instruction call in the current function and check them one by one. If the Instruction call is a CallInst – representing a typical function call site – and the callee name is my_halt, we will push it into the Calls vector for later use.Function name manglingBe aware that when a line of C++ code is compiled into LLVM IR or native code, the name of any symbol – including the function name – will be different from what you saw in the original source code. For example, a simple function that has the name of *foo* and takes no argument might have *_Z3foov* as its name in LLVM IR. We call such a transformation in C++ **name mangling**. Different platforms also adopt different name mangling schemes. For example, in Visual Studio, the same function name becomes *?foo@@YAHH@Z* in LLVM IR.\n    ```", "```cpp\n    #include \"llvm/IR/Dominators.h\"\n    …\n    PreservedAnalyses\n    HaltAnalyzer::run(Function &F, FunctionAnalysisManager type argument to retrieve specific analysis data (in this case, DominatorTree) for a specific Function class.Although, so far, we have (kind of) used the words *analysis* and *analysis data* interchangeably, in a real LLVM implementation, they are actually two different entities. Take the DT that we are using here as an example:a) `Function`. In other words, it is the one that *performs* the analysis.b) `DominatorTreeAnalysis`. This is just static data that will be cached by AnalysisManager until it is invalidated.Furthermore, LLVM asks every analysis to clarify its affiliated result type via the `Result` member type. For example, `DominatorTreeAnalysis::Result` is equal to `DominatorTree`.To make this even more formal, to associate the analysis data of an analysis class, `T`, with a `Function` variable, `F`, we can use the following snippet:\n\n    ```", "```cpp\n\n    ```", "```cpp\n    PreservedAnalyses\n    HaltAnalyzer::run(Function &F, FunctionAnalysisManager &FAM) {\n      …\n      SmallVector<BasicBlock*, 4> DomBBs;\n      for (auto *I : Calls) {\n        auto *BB = I->getParent();\n        DomBBs.clear();\n        DT.DominatorTree::getDescendants method, we can retrieve all of the basic blocks dominated by a my_halt call site. Note that the results from getDescendants will also contain the block you put into the query (in this case, the block containing the my_halt call sites), so we need to exclude it before printing the basic block name using the BasicBlock::printAsOperand method.With the ending of the returning `PreservedAnalyses::all()`, which tells AnalysisManager that this Pass does not invalidate any analysis since we don't modify the IR at all, we will wrap up the `HaltAnalyzer::run` method here.\n    ```", "```cpp\n    extern \"C\" ::llvm::PassPluginLibraryInfo LLVM_ATTRIBUTE_WEAK\n    llvmGetPassPluginInfo() {\n      return {\n        LLVM_PLUGIN_API_VERSION, \"HaltAnalyzer\", \"v0.1\",\n        [](PassBuilder &PB) {\n          using OptimizationLevel\n            = typename PassBuilder::OptimizationLevel;\n          PB.StrictOpt in the previous section, we are using registerOptimizerLastEPCallback to insert HaltAnalyzer *after* all of the other optimization Passes. The rationale behind this is that some optimizations might move basic blocks around, so prompting warnings too early might not be very useful. Nevertheless, we are still leveraging ModuletoFunctionPassAdaptor to wrap around our Pass; this is because registerOptimizerLastEPCallback only provides ModulePassManager for us to add our Pass, which is a function Pass.\n    ```", "```cpp\nint bar(int x) {\n  int y = x;\n  return y * 4;\n}\nint foo(int z) {\n  return z + z * 2;\n}\n```", "```cpp\n$ clang -O0 -Xclang -disable-O0-optnone -emit-llvm -S test.c\n```", "```cpp\n$ opt -O2 --disable-output --debug-pass-manager test.ll\nStarting llvm::Module pass manager run.\n…\nRunning pass: Annotation2MetadataPass on ./test.ll\nRunning pass: ForceFunctionAttrsPass on ./test.ll\n…\nStarting llvm::Function pass manager run.\nRunning pass: SimplifyCFGPass on bar\nRunning pass: SROA on bar\nRunning analysis: DominatorTreeAnalysis on bar\nRunning pass: EarlyCSEPass on bar\n…\nFinished llvm::Function pass manager run.\n…\nStarting llvm::Function pass manager run.\nRunning pass: SimplifyCFGPass on foo\n…\nFinished llvm::Function pass manager run.\nInvalidating analysis: VerifierAnalysis on ./test.ll\n…\n$\n```", "```cpp\n$ opt -O2 --disable-output --print-changed ./test.ll\n*** IR Dump At Start: ***\n...\ndefine dso_local i32 @bar(i32 %x) #0 {\nentry:\n  %x.addr = alloca i32, align 4\n  %y = alloca i32, align 4\n  …\n  %1 = load i32, i32* %y, align 4\n  %mul = mul nsw i32 %1, 4\n  ret i32 %mul\n}\n...\n*** IR Dump After VerifierPass (module) omitted because no change ***\n…\n...\n*** IR Dump After SROA *** (function: bar)\n; Function Attrs: noinline nounwind uwtable\ndefine dso_local i32 @bar(i32 %x) #0 {\nentry:\n  %mul = mul nsw i32 %x, 4\n  ret i32 %mul\n}\n...\n$\n```", "```cpp\n$ opt -O2 --disable-output \\\n          --print-changed --filter-print-funcs=foo ./test.ll\n```", "```cpp\n$ opt -O2 --disable-output \\\n          --print-changed \\\n          --filter-passes=SROA,InstCombinePass ./test.ll\n```", "```cpp\n$ opt -O2 --opt-bisect-limit=5 -S -o – test.ll\nBISECT: running pass (1) Annotation2MetadataPass on module (./test.ll)\nBISECT: running pass (2) ForceFunctionAttrsPass on module (./test.ll)\nBISECT: running pass (3) InferFunctionAttrsPass on module (./test.ll)\nBISECT: running pass (4) SimplifyCFGPass on function (bar)\nBISECT: running pass (5) SROA on function (bar)\nBISECT: NOT running pass (6) EarlyCSEPass on function (bar)\nBISECT: NOT running pass (7) LowerExpectIntrinsicPass on function (bar)\nBISECT: NOT running pass (8) SimplifyCFGPass on function (foo)\nBISECT: NOT running pass (9) SROA on function (foo)\nBISECT: NOT running pass (10) EarlyCSEPass on function (foo)\n...\ndefine dso_local i32 @bar(i32 %x) #0 {\nentry:\n  %mul = mul nsw i32 %x, 4\n  ret i32 %mul\n}\ndefine dso_local i32 @foo(i32 %y) #0 {\nentry:\n  %y.addr = alloca i32, align 4\n  store i32 %y, i32* %y.addr, align 4\n  %0 = load i32, i32* %y.addr, align 4\n  %1 = load i32, i32* %y.addr, align 4\n  %mul = mul nsw i32 %1, 2\n  %add = add nsw i32 %0, %mul\n  ret i32 %add\n}\n$\n```"]