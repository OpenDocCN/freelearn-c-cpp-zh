<html><head></head><body>
		<div id="_idContainer011">
			<h1 id="_idParaDest-15" class="chapter-number"><a id="_idTextAnchor015"/>1</h1>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor016"/>The Basics of std::vector</h1>
			<p><strong class="source-inline">std::vector</strong> is a fundamental component of C++ programming. This chapter will explore <strong class="source-inline">std::vector</strong> as a dynamic array, discussing its utility in various programming contexts. By the end of the chapter, you should be adept at declaring, initializing, and manipulating vectors. These skills will enable you to utilize <strong class="source-inline">std::vector</strong> effectively in diverse applications. It will provide a solid foundation for understanding the broader set of data structures and algorithms of the <strong class="bold">Standard Template </strong><span class="No-Break"><strong class="bold">Library</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">STL</strong></span><span class="No-Break">).</span></p>
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>The significance <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">std::vector</strong></span></li>
				<li>Declaring and <span class="No-Break">initializing </span><span class="No-Break"><strong class="source-inline">std::vector</strong></span></li>
				<li><span class="No-Break">Accessing elements</span></li>
				<li>Adding and <span class="No-Break">removing elements</span></li>
			</ul>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor017"/>Technical requirements</h1>
			<p>The code in this chapter can be found on GitHub: </p>
			<p><a href="https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL"><span class="No-Break">https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL</span></a></p>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor018"/>The significance of std::vector</h1>
			<p>In C++, <strong class="source-inline">std::vector</strong> is a<a id="_idIndexMarker000"/> frequently chosen data structure. While beginners might initially see parallels between it and the basic arrays in C, the advantages of <strong class="source-inline">std::vector</strong> become evident with deeper exploration. Additionally, a solid grasp of <strong class="source-inline">std::vector</strong> facilitates a smoother transition to understanding other components <span class="No-Break">of STL.</span></p>
			<p>Both vectors and arrays function as containers for collections of elements. The critical distinction between them lies in their flexibility and capabilities. Arrays are static in size, set at declaration time, and cannot be <span class="No-Break">altered afterward.</span></p>
			<p>In contrast, vectors<a id="_idIndexMarker001"/> are dynamic. They can expand or contract based on the operations performed on them. Unlike arrays, which commit to a fixed memory block upon declaration, vectors dynamically manage memory. They frequently allocate extra memory to anticipate future growth, optimizing efficiency and flexibility. While arrays offer simple index-based element access and modification, vectors provide a broader set of functions, including methods for inserting, deleting, and <span class="No-Break">locating elements.</span></p>
			<p>The primary advantage of <strong class="source-inline">std::vector</strong> is its combination of dynamic resizing and optimized performance. Traditional C++ arrays have their size set at compile time. If an array is declared to hold 10 elements, it’s constrained to that capacity. However, in many real-world scenarios, the volume of data isn’t determined until runtime. This is where <span class="No-Break"><strong class="source-inline">std::vector</strong></span><span class="No-Break"> shines.</span></p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor019"/>A basic comparison of C-style arrays and std::vector</h2>
			<p>Acting as a<a id="_idIndexMarker002"/> dynamic array, <strong class="source-inline">std::vector</strong> can adjust its size during program execution. It efficiently manages its memory, reallocating not for each <a id="_idIndexMarker003"/>new addition, but in larger chunks to maintain a balance between performance and adaptability. Thus, rather than pre-committing to a specific size and risking either memory waste or a shortage, <strong class="source-inline">std::vector</strong> dynamically responds to varying <span class="No-Break">data demands.</span></p>
			<p>Here are two code examples that demonstrate the contrast between using a C-style array <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">std::vector</strong></span><span class="No-Break">.</span></p>
			<p>The following code demonstrates the use of a <span class="No-Break">C-style array:</span></p>
			<pre class="source-code">
#include &lt;iostream&gt;
int main() {
  int *cArray = new int[5];
  for (int i = 0; i &lt; 5; ++i) { cArray[i] = i + 1; }
  for (int i = 0; i &lt; 5; ++i) {
    std::cout &lt;&lt; cArray[i] &lt;&lt; " ";
  }
  std::cout &lt;&lt; "\n";
  const int newSize = 7;
  int *newCArray = new int[newSize];
  for (int i = 0; i &lt; 5; ++i) { newCArray[i] = cArray[i]; }
  delete[] cArray;
  cArray = newCArray;
  for (int i = 0; i &lt; newSize; ++i) {
    std::cout &lt;&lt; cArray[i] &lt;&lt; " ";
  }
  std::cout &lt;&lt; "\n";
  int arraySize = newSize;
  std::cout &lt;&lt; "Size of cArray: " &lt;&lt; arraySize &lt;&lt; "\n";
  delete[] cArray;
  return 0;
}</pre>			<p>Here is the <span class="No-Break">example output:</span></p>
			<pre class="console">
1 2 3 4 5
1 2 3 4 5 0 0
Size of cArray: 7</pre>			<p>In this<a id="_idIndexMarker004"/> example, we<a id="_idIndexMarker005"/> do <span class="No-Break">the following:</span></p>
			<ol>
				<li>Declare a C-style dynamic array with a size <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">5</strong></span><span class="No-Break">.</span></li>
				<li>Initialize the <span class="No-Break">dynamic array.</span></li>
				<li>Print the contents of <span class="No-Break">the array.</span></li>
				<li>Resize the array to a new size (<span class="No-Break">e.g., </span><span class="No-Break"><strong class="source-inline">7</strong></span><span class="No-Break">).</span></li>
				<li>Copy the elements from the old array to the <span class="No-Break">new one.</span></li>
				<li>Deallocate the <span class="No-Break">old array.</span></li>
				<li>Update the pointer to the <span class="No-Break">new array.</span></li>
				<li>Print the contents of the <span class="No-Break">resized array.</span></li>
				<li>Get the size of the <span class="No-Break">resized array.</span></li>
				<li>Deallocate the resized array <span class="No-Break">when done.</span></li>
			</ol>
			<p>In contrast, the following code demonstrates the use <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">std::vector</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;vector&gt;
int main() {
  std::vector&lt;int&gt; stlVector = {1, 2, 3, 4, 5};
  for (const int val : stlVector) {
    std::cout &lt;&lt; val &lt;&lt; " ";
  }
  std::cout &lt;&lt; "\n";
  stlVector.resize(7);
  for (const int val : stlVector) {
    std::cout &lt;&lt; val &lt;&lt; " ";
  }
  std::cout &lt;&lt; "\n";
  std::cout &lt;&lt; "Size of stlVector: " &lt;&lt; stlVector.size()
            &lt;&lt; "\n";
  return 0;
}</pre>			<p>Here is<a id="_idIndexMarker006"/> the <span class="No-Break">example output:</span></p>
			<pre class="console">
1 2 3 4 5
1 2 3 4 5 0 0
Size of stlVector: 7</pre>			<p>By way of <a id="_idIndexMarker007"/>contrast with the C-style version, in this example, we do <span class="No-Break">the following:</span></p>
			<ol>
				<li>Declare <strong class="source-inline">std::vector</strong> with <span class="No-Break">initial values.</span></li>
				<li>Print the contents of <span class="No-Break">the vector.</span></li>
				<li>Resize. This operation is easy <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">std::vector</strong></span><span class="No-Break">.</span></li>
				<li>Print again to see <span class="No-Break">the change.</span></li>
				<li>Get the size. This operation is simple with the <strong class="source-inline">size()</strong> <span class="No-Break">member function.</span></li>
			</ol>
			<p>In the initial example, the C-style array is constrained by its fixed size. Modifying its size typically requires a non-trivial procedure. Conversely, <strong class="source-inline">std::vector</strong> can adjust its size effortlessly and provides a <strong class="source-inline">size()</strong> method to determine the number of elements <span class="No-Break">it holds.</span></p>
			<p>Beyond its <a id="_idIndexMarker008"/>dynamic resizing capability, <strong class="source-inline">std::vector</strong> further simplifies memory management<a id="_idIndexMarker009"/> compared to traditional arrays. With <strong class="source-inline">std::vector</strong>, there’s no need for explicit memory allocations or deallocations as it internally handles these tasks. This approach minimizes the risk of memory leaks and streamlines the development process. As a result, many C++ developers, regardless of their experience level, prefer using <strong class="source-inline">std::vector</strong> over raw arrays for convenience <span class="No-Break">and safety.</span></p>
			<p>Let’s look at an example that contrasts how a legacy C-style array manages memory and how <strong class="source-inline">std::vector</strong> makes this easier <span class="No-Break">and safer.</span></p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor020"/>Comparison of C-style arrays and std::vector for memory management</h2>
			<p>First, let us consider an example of a C-style array with manual <span class="No-Break">memory management.</span></p>
			<p>In this <a id="_idIndexMarker010"/>example, we’ll use<a id="_idIndexMarker011"/> dynamic memory allocation (<strong class="source-inline">new</strong> and <strong class="source-inline">delete</strong>) to simulate some of the resizing capabilities <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">std::vector</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
#include &lt;iostream&gt;
int main() {
  int *cArray = new int[5];
  for (int i = 0; i &lt; 5; ++i) { cArray[i] = i + 1; }
  int *temp = new int[10];
  for (int i = 0; i &lt; 5; ++i) { temp[i] = cArray[i]; }
  delete[] cArray; // Important: free the old memory
  cArray = temp;
  for (int i = 5; i &lt; 10; ++i) { cArray[i] = i + 1; }
  for (int i = 0; i &lt; 10; ++i) {
    std::cout &lt;&lt; cArray[i] &lt;&lt; " ";
  }
  std::cout &lt;&lt; "\n";
  delete[] cArray;
  return 0;
}</pre>			<p>Here is the <span class="No-Break">example output:</span></p>
			<pre class="console">
1 2 3 4 5 6 7 8 9 10</pre>			<p>In this <a id="_idIndexMarker012"/>example, we do <span class="No-Break">the</span><span class="No-Break"><a id="_idIndexMarker013"/></span><span class="No-Break"> following:</span></p>
			<ol>
				<li>Dynamically allocate a C-style array with a size <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">5</strong></span><span class="No-Break">.</span></li>
				<li>Populate <span class="No-Break">the array.</span></li>
				<li>Simulate a resize: allocate a larger array and copy <span class="No-Break">the data.</span></li>
				<li>Populate the rest of the <span class="No-Break">new array.</span></li>
				<li>Print the <span class="No-Break">array’s content.</span></li>
				<li>Clean up the <span class="No-Break">allocated memory.</span></li>
			</ol>
			<p>Now, let us consider an example of <strong class="source-inline">std::vector</strong> with built-in <span class="No-Break">memory management.</span></p>
			<p>Using <strong class="source-inline">std::vector</strong>, you don’t have to allocate or deallocate memory manually; it is <span class="No-Break">managed internally:</span></p>
			<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;vector&gt;
int main() {
  std::vector&lt;int&gt; myVector(5);
  for (int i = 0; i &lt; 5; ++i) { myVector[i] = i + 1; }
  for (int i = 5; i &lt; 10; ++i) {
    myVector.push_back(i + 1);
  }
  for (int val : myVector) { std::cout &lt;&lt; val &lt;&lt; " "; }
  std::cout &lt;&lt; "\n";
  return 0;
}</pre>			<p>Here is the <span class="No-Break">example output:</span></p>
			<pre class="console">
1 2 3 4 5 6 7 8 9 10</pre>			<p>The steps in <a id="_idIndexMarker014"/>this example<a id="_idIndexMarker015"/> include <span class="No-Break">the following:</span></p>
			<ol>
				<li>Create <strong class="source-inline">std::vector</strong> with a size <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">5</strong></span><span class="No-Break">.</span></li>
				<li>Populate <span class="No-Break">the vector.</span></li>
				<li>Resizing is straightforward with <strong class="source-inline">push_back()</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">resize()</strong></span><span class="No-Break">.</span></li>
				<li>Print the <span class="No-Break">vector’s contents.</span><p class="list-inset">There’s no need for explicit <span class="No-Break">memory deallocation.</span></p></li>
			</ol>
			<p>In the first<a id="_idIndexMarker016"/> example, the challenges <a id="_idIndexMarker017"/>of manual memory management are evident. Failing to use <strong class="source-inline">delete</strong> appropriately can result in memory leaks. On the other hand, the second example highlights the efficiency of <strong class="source-inline">std::vector</strong>, which internally manages memory, eliminating the need for manual resizing and memory operations and enhancing the <span class="No-Break">development process.</span></p>
			<p>Traditional arrays come with a basic set of operations. In contrast, <strong class="source-inline">std::vector</strong> offers various member functions that provide advanced data manipulation and retrieval capabilities. These functions will be explored in <span class="No-Break">subsequent sections.</span></p>
			<p>In C++ development, <strong class="source-inline">std::vector</strong> is a fundamental tool. Its flexibility makes it a go-to choice for various applications, from game development to complex software projects. The built-in safety mechanisms against common memory issues underscore its value. As an STL component, <strong class="source-inline">std::vector</strong> encourages consistent and optimal coding practices by integrating well with other <span class="No-Break">STL elements.</span></p>
			<p>This section explored the fundamental differences between C-style arrays and <strong class="source-inline">std::vector</strong>. Unlike static C-style arrays, we learned that <strong class="source-inline">std::vector</strong> offers dynamic resizing and robust memory management, which are critical for developing flexible and efficient applications. The comparison detailed how <strong class="source-inline">std::vector</strong> abstracts away low-level memory handling, thus minimizing common errors associated with manual <span class="No-Break">memory management.</span></p>
			<p>Understanding <strong class="source-inline">std::vector</strong> is beneficial because it is one of the most widely used sequence containers in C++ programming. <strong class="source-inline">std::vector</strong> supports dynamic growth in contiguously allocated memory and random access iteration and is compatible with a range of algorithms in the STL. We also discussed how <strong class="source-inline">std::vector</strong> provides a safer and more intuitive interface for managing collections <span class="No-Break">of objects.</span></p>
			<p>The following section will build upon this foundational knowledge. We will learn the syntax for declaring <strong class="source-inline">std::vector</strong> and the various methods available for initializing it. This will include an examination of default, copy, and move semantics as they pertain <span class="No-Break">to vectors.</span></p>
			<h1 id="_idParaDest-21"><a id="_idTextAnchor021"/>Declaring and initializing std::vector</h1>
			<p>Having established the foundational knowledge of <strong class="source-inline">std::vector</strong> in C++ development, it’s time to delve into its practical applications—expressly, how to declare and <span class="No-Break">initialize vectors.</span></p>
			<p>The essence of <strong class="source-inline">std::vector</strong> lies in its dynamic nature. Unlike traditional arrays with fixed sizes, vectors can grow or shrink as necessary, making them a versatile tool <span class="No-Break">for developers.</span></p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor022"/>Declaring a vector</h2>
			<p>The <a id="_idIndexMarker018"/>performance of <strong class="source-inline">std::vector</strong> stems from its design, which combines the benefits of a contiguous memory layout (such as arrays) with the flexibility of dynamic resizing. It reserves memory to hold that many elements when initialized with a specified size. But if the vector fills up and more capacity is needed, it allocates a larger memory block, transfers the existing elements, and deallocates the old memory. This dynamic resizing process is optimized to reduce overhead, ensuring that vectors remain efficient. The fusion of contiguous storage and automated memory management distinguishes <strong class="source-inline">std::vector</strong> as an essential component in the <span class="No-Break">C++ ecosystem.</span></p>
			<p>To declare a basic <strong class="source-inline">std::vector</strong>, use <span class="No-Break">the following:</span></p>
			<pre class="source-code">
std::vector&lt;int&gt; vec;</pre>			<p>This line of code initializes an empty <strong class="source-inline">std::vector</strong> named <strong class="source-inline">vec</strong> specifically designed to hold values of type <strong class="source-inline">int</strong>. (<strong class="source-inline">int</strong> is the template parameter inside the <strong class="source-inline">&lt;&gt;</strong> for <strong class="source-inline">std::vector's</strong> type.) <strong class="source-inline">std::vector</strong> is a dynamic array, which means that even though <strong class="source-inline">vec</strong> begins with a size of <strong class="source-inline">0</strong>, its capacity can grow as needed. As you insert integers into <strong class="source-inline">vec</strong>, the container will automatically allocate memory to accommodate the increasing number of elements. This dynamic resizing makes <strong class="source-inline">std::vector</strong> a versatile and widely used container in C++ for situations where the number of elements isn’t known in advance or might change <span class="No-Break">over time.</span></p>
			<p>When creating <strong class="source-inline">std::vector</strong>, it’s possible to specify its initial size. This can be beneficial if you have prior knowledge about the number of elements you’ll need <span class="No-Break">to store:</span></p>
			<pre class="source-code">
std::vector&lt;int&gt; vec(10);</pre>			<p>In the preceding code, <strong class="source-inline">std::vector</strong> named <strong class="source-inline">vec</strong> is initialized with space for 10 integers. By default, these integers will be value-initialized, which means they will be set to <strong class="source-inline">0</strong> for fundamental data types such <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">int</strong></span><span class="No-Break">.</span></p>
			<p>If you wish<a id="_idIndexMarker019"/> to initialize the elements with a specific value, you can provide a second argument during the <span class="No-Break">vector’s construction:</span></p>
			<pre class="source-code">
std::vector&lt;int&gt; vec(10, 5);</pre>			<p>Here, <strong class="source-inline">std::vector</strong> is declared with 10 integers, and each of those 10 integers is initialized to the value of <strong class="source-inline">5</strong>. This approach ensures efficient memory allocation and desired value initialization in a <span class="No-Break">single step.</span></p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor023"/>Initializing a vector</h2>
			<p>In C++11 and<a id="_idIndexMarker020"/> later versions, <strong class="source-inline">std::vector</strong> initialization became more straightforward with the introduction of initializer lists. This allows developers to specify the initial values of the vector directly within <span class="No-Break">curly braces:</span></p>
			<pre class="source-code">
std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};</pre>			<p>The preceding statement creates an instance of <strong class="source-inline">std::vector</strong> named <strong class="source-inline">vec</strong> and initializes it with five integers. This method provides a concise way to declare and populate a vector simultaneously. This is just one way to initialize <strong class="source-inline">std::vector</strong>. Depending on your needs, there are many ways this can <span class="No-Break">be done:</span></p>
			<pre class="source-code">
// Method 1: Declare a vector and then add elements using
// push_back (Add integers from 0 to 4)
std::vector&lt;int&gt; vec1;
for (int i = 0; i &lt; 5; ++i) { vec1.push_back(i); }
// Method 2: Initialize a vector with a specific size and
// default value (5 elements with the value 10)
std::vector&lt;int&gt; vec2(5, 10);
// Method 3: List initialization with braced initializers
// Initialize with a list of integers
std::vector&lt;int&gt; vec3 = {1, 2, 3, 4, 5};
// Method 4: Initialize a vector using the fill
// constructor Default-initializes the five elements (with
// zeros)
std::vector&lt;int&gt; vec4(5);
// Method 5: Using std::generate with a lambda function
std::vector&lt;int&gt; vec5(5);
int value = 0;
std::generate(vec5.begin(), vec5.end(),
              [&amp;value]() { return value++; });</pre>			<p><strong class="source-inline">std::vector</strong> is a versatile templated container capable of storing various data types, not just primitives such as <strong class="source-inline">int</strong>. You can store objects of custom classes, other standard library types, and pointers. This adaptability makes <strong class="source-inline">std::vector</strong> suitable for a wide range of <a id="_idIndexMarker021"/>applications <span class="No-Break">and scenarios.</span></p>
			<p>Furthermore, vectors provide a straightforward mechanism for copying the contents of one vector to another. This is <a id="_idIndexMarker022"/>known as <strong class="bold">copy initialization</strong>. The following code <span class="No-Break">demonstrates this:</span></p>
			<pre class="source-code">
std::vector&lt;int&gt; vec1 = {1, 2, 3, 4, 5};
std::vector&lt;int&gt; vec2(vec1);</pre>			<p>In this example, <strong class="source-inline">vec2</strong> is initialized as an exact copy of <strong class="source-inline">vec1</strong>, meaning <strong class="source-inline">vec2</strong> will contain the same elements as <strong class="source-inline">vec1</strong>. This copy initialization ensures that the original vector (<strong class="source-inline">vec1</strong>) remains unchanged and that the new vector (<strong class="source-inline">vec2</strong>) is provided with a separate copy of <span class="No-Break">the data.</span></p>
			<p>One of the true strengths of STL containers is their ability to handle user-defined types seamlessly, extending beyond primitive data types such as <strong class="source-inline">int</strong> or <strong class="source-inline">double</strong>. This flexibility is a <a id="_idIndexMarker023"/>testament to its templated design, which allows it to adapt to various data types while maintaining type safety. In the upcoming example, we illustrate this versatility by utilizing <strong class="source-inline">std::vector</strong> with a <span class="No-Break">custom class:</span></p>
			<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
class Person {
public:
  Person() = default;
  Person(std::string_view n, int a) : name(n), age(a) {}
  void display() const {
    std::cout &lt;&lt; "Name: " &lt;&lt; name &lt;&lt; ", Age: " &lt;&lt; age
              &lt;&lt; "\n";
  }
private:
  std::string name;
  int age{0};
};
int main() {
  std::vector&lt;Person&gt; people;
  people.push_back(Person("Lisa", 30));
  people.push_back(Person("Corbin", 25));
  people.resize(3);
  people[2] = Person("Aaron", 28);
  for (const auto &amp;person : people) { person.display(); }
  return 0;
}</pre>			<p>Here is the <a id="_idIndexMarker024"/><span class="No-Break">example output:</span></p>
			<pre class="console">
Name: Lisa, Age: 30
Name: Corbin, Age: 25
Name: Aaron, Age: 28</pre>			<p>In this example, <strong class="source-inline">std::vector</strong> is first used to manage objects of the custom <strong class="source-inline">Person</strong> class. It demonstrates the ease with which <strong class="source-inline">std::vector</strong> accommodates and manages memory for built-in and <span class="No-Break">user-defined types.</span></p>
			<p>In C++, while static arrays have their utility, they come with fixed sizes that can sometimes be limiting. On the other hand, <strong class="source-inline">std::vector</strong> provides a dynamic and <span class="No-Break">flexible alternative.</span></p>
			<p>Understanding the declaration and initialization of vectors is essential for effective C++ programming. <strong class="source-inline">std::vector</strong> is a versatile tool suitable for various tasks, from implementing complex algorithms to developing large-scale applications. Incorporating <strong class="source-inline">std::vector</strong> into your programming practices can enhance the efficiency and maintainability of <span class="No-Break">your code.</span></p>
			<p>In this section, we covered the syntactical aspects of working with <strong class="source-inline">std::vector</strong>. Specifically, we delved into the proper techniques for declaring <strong class="source-inline">std::vector</strong> of various types and the diverse strategies for initializing these vectors to suit different <span class="No-Break">programming scenarios.</span></p>
			<p>We learned that declaring <strong class="source-inline">std::vector</strong> involves specifying the type of elements it will contain and, optionally, the initial size and default value for the elements. We discovered multiple methods regarding initialization, including direct-list initialization and initializing with a specific range of values. This section underscored the flexibility of <strong class="source-inline">std::vector</strong>, showing how it can be tailored to start with a predefined set of elements or be constructed from <span class="No-Break">existing collections.</span></p>
			<p>This information<a id="_idIndexMarker025"/> is crucial for practical C++ development as it provides a foundation for using <strong class="source-inline">std::vector</strong> effectively. Proper initialization can lead to performance optimizations and ensure the vector is in a valid state appropriate for its intended use. The ability to declare and initialize vectors succinctly and correctly is a foundational skill for leveraging the power of the STL in real-world <span class="No-Break">C++ applications.</span></p>
			<p>In the next section, <em class="italic">Accessing elements</em>, we will focus on the operations that allow us to retrieve and modify the contents of a <strong class="source-inline">std::vector</strong>. We will learn about random access, which allows for the efficient retrieval and modification of elements at any position within the vector. Additionally, we will explore how to access the first and last elements, and the importance of understanding and managing vector size to ensure robust and <span class="No-Break">error-free code.</span></p>
			<h1 id="_idParaDest-24"><a id="_idTextAnchor024"/>Accessing elements</h1>
			<p>Having <a id="_idIndexMarker026"/>discussed the declaration and initialization of <strong class="source-inline">std::vector</strong>, our focus now shifts to accessing and manipulating the contained data. Multiple methods in C++ allow you to access vector elements with both speed <span class="No-Break">and safety.</span></p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor025"/>Random access</h2>
			<p>The <a id="_idIndexMarker027"/>subscript <strong class="source-inline">[]</strong> operator allows direct element access via indices, similar to arrays. In the following example, given a vector, the expression <strong class="source-inline">numbers[1]</strong> returns the value <strong class="source-inline">20</strong>. However, using this operator doesn’t involve boundary checks. An index that is out of range, such as <strong class="source-inline">numbers[10]</strong>, results in undefined behavior, leading to <span class="No-Break">unpredictable outcomes.</span></p>
			<p>This is shown in the <span class="No-Break">following example:</span></p>
			<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;vector&gt;
int main() {
  std::vector&lt;int&gt; numbers = {10, 20, 30, 40, 50};
  const auto secondElement = numbers[1];
  std::cout &lt;&lt; "The second element is: " &lt;&lt; secondElement
            &lt;&lt; "\n";
  // Beware: The following line can cause undefined
  // behavior!
  const auto outOfBoundsElement = numbers[10];
  std::cout &lt;&lt; "Accessing an out-of-bounds index: "
            &lt;&lt; outOfBoundsElement &lt;&lt; "\n";
  return 0;
}</pre>			<p>Here is<a id="_idIndexMarker028"/> the <span class="No-Break">example output:</span></p>
			<pre class="console">
The second element is: 20
Accessing an out-of-bounds index: 0</pre>			<p>For safer index-based access, <strong class="source-inline">std::vector</strong> offers the <strong class="source-inline">at()</strong> member function. It performs an index boundary check and throws an <strong class="source-inline">out_of_range</strong> exception for <span class="No-Break">invalid indices.</span></p>
			<p>Here is an example <span class="No-Break">of this:</span></p>
			<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;vector&gt;
int main() {
  std::vector&lt;int&gt; numbers = {10, 20, 30, 40, 50};
  try {
    const auto secondElement = numbers.at(1);
    std::cout &lt;&lt; "The second element is: " &lt;&lt; secondElement
              &lt;&lt; "\n";
  } catch (const std::out_of_range &amp;e) {
    std::cerr &lt;&lt; "Error: " &lt;&lt; e.what() &lt;&lt; "\n";
  }
  try {
    const auto outOfBoundsElement = numbers.at(10);
    std::cout &lt;&lt; "Accessing an out-of-bounds index: "
              &lt;&lt; outOfBoundsElement &lt;&lt; "\n";
  } catch (const std::out_of_range &amp;e) {
    std::cerr &lt;&lt; "Error: " &lt;&lt; e.what() &lt;&lt; "\n";
  }
  return 0;
}</pre>			<p>Caution<a id="_idIndexMarker029"/> is paramount when accessing vector elements. While C++ favors performance, it often sidesteps safety checks, as evident with the subscript operator. Hence, developers must ensure valid access through careful index management or by employing safer methods such <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">at()</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor026"/>Accessing the first and last elements</h2>
			<p>The <a id="_idIndexMarker030"/>first and last elements can be accessed with <strong class="source-inline">front()</strong> and <span class="No-Break"><strong class="source-inline">back()</strong></span><span class="No-Break">, respectively.</span></p>
			<p>This is shown in the <span class="No-Break">following example:</span></p>
			<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;vector&gt;
int main() {
  std::vector&lt;int&gt; numbers = {10, 20, 30, 40, 50};
  const auto firstElement = numbers.front();
  std::cout &lt;&lt; "The first element is: " &lt;&lt; firstElement
            &lt;&lt; "\n";
  const auto lastElement = numbers.back();
  std::cout &lt;&lt; "The last element is: " &lt;&lt; lastElement
            &lt;&lt; "\n";
  return 0;
}</pre>			<p>The example output is <span class="No-Break">as follows:</span></p>
			<pre class="console">
The first element is: 10
The last element is: 50</pre>			<h2 id="_idParaDest-27"><a id="_idTextAnchor027"/>Vector size</h2>
			<p>With <strong class="source-inline">std::vector</strong>, understanding<a id="_idIndexMarker031"/> the structure and the amount of data it contains is essential. The <strong class="source-inline">size()</strong> member function provides the current count of elements stored within the vector. Invoking this function on an instance of <strong class="source-inline">std::vector</strong> will return the number of elements it holds. This count represents the active elements and can be used to determine the range for valid indexing. The returned value is of type <strong class="source-inline">size_t</strong>, an unsigned integer type suitable for representing <a id="_idIndexMarker032"/>sizes and counts. It’s beneficial when iterating through a vector, performing size comparisons, or allocating space based on the number of <span class="No-Break">vector elements.</span></p>
			<p>Let us look at the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;vector&gt;
int main() {
  std::vector&lt;int&gt; data = {1, 2, 3, 4, 5};
  const auto elementCount = data.size();
  std::cout &lt;&lt; "Vector contains " &lt;&lt; elementCount
            &lt;&lt; " elements.\n";
  return 0;
}</pre>			<p>In the preceding code, the <strong class="source-inline">size()</strong> function is called on the data vector to retrieve and display the number of elements it contains. The result, as expected, indicates that there are five elements in <span class="No-Break">the vector.</span></p>
			<p>In summary, <strong class="source-inline">std::vector</strong> offers a suite of tools, ranging from the efficient subscript operator to the safer <strong class="source-inline">at()</strong> method, and the convenient <strong class="source-inline">front()</strong> and <strong class="source-inline">back()</strong> methods. Understanding these tools is vital to efficiently and safely access and manipulate data within <span class="No-Break">a vector.</span></p>
			<p>In this section, we concentrated on the methodologies for retrieving and inspecting the contents of <strong class="source-inline">std::vector</strong>. We learned about the capabilities of <strong class="source-inline">std::vector</strong> to provide random access to its elements, enabling direct access to any element using its index with constant time complexity. This section also detailed the methods to access a vector’s first and last elements through the <strong class="source-inline">front()</strong> and <strong class="source-inline">back()</strong> member <span class="No-Break">functions, respectively.</span></p>
			<p>Moreover, we <a id="_idIndexMarker033"/>discussed the importance of understanding and utilizing the <strong class="source-inline">size() </strong>member function to determine the number of elements currently stored in <strong class="source-inline">std::vector</strong>. This understanding is instrumental in ensuring that our access patterns remain within the bounds of the vector, thereby preventing out-of-range errors and <span class="No-Break">undefined behavior.</span></p>
			<p>The skills acquired from this section are essential, as they form the basis of interacting with <strong class="source-inline">std::vector</strong>’s contents. These access patterns are core to using vectors effectively in C++ applications, whether for reading or modifying elements. The ability to directly access elements in a vector leads to efficient algorithms and supports a wide range of everyday <span class="No-Break">programming tasks.</span></p>
			<p>The following section will advance our knowledge further by addressing how to modify the size and contents of <strong class="source-inline">std::vector</strong>. We will explore how to add elements to a vector and the various methods available to remove them. This will include understanding how vectors manage their capacity and its implications on performance. We will learn why and how to use <strong class="source-inline">.empty()</strong> as a more performant alternative to checking whether the size is <strong class="source-inline">0</strong>, and we will delve into clearing all elements from <span class="No-Break">a vector.</span></p>
			<h1 id="_idParaDest-28"><a id="_idTextAnchor028"/>Adding and removing elements</h1>
			<p>One of the advantages of <strong class="source-inline">std::vector</strong> over traditional arrays is its ability to resize dynamically. As applications evolve, so do data requirements; static data structures do not cut it. In this section, we will explore dynamic data management with <strong class="source-inline">std::vector</strong>, learning to seamlessly add to and remove from vectors while making sure we are <span class="No-Break">staying safe.</span></p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor029"/>Adding elements</h2>
			<p>Let’s<a id="_idIndexMarker034"/> start with adding elements. The <strong class="source-inline">push_back()</strong> member function is possibly the most straightforward way to add an element to the end of a vector. Suppose you have <strong class="source-inline">std::vector&lt;int&gt; scores;</strong> and wish to append a new score, say <strong class="source-inline">95</strong>. You would simply invoke <strong class="source-inline">scores.push_back(95);</strong>, and voilà, your score <span class="No-Break">is added.</span></p>
			<p>Here’s a simple<a id="_idIndexMarker035"/> illustrative <span class="No-Break">code example:</span></p>
			<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;vector&gt;
int main() {
  std::vector&lt;int&gt; scores;
  std::cout &lt;&lt; "Initial size of scores: " &lt;&lt; scores.size()
            &lt;&lt; "\n";
  scores.push_back(95);
  std::cout &lt;&lt; "Size after adding one score:"
            &lt;&lt; scores.size() &lt;&lt; "\n";
  std::cout &lt;&lt; "Recently added score: " &lt;&lt; scores[0]
            &lt;&lt; "\n";
  return 0;
}</pre>			<p>When run, this program will display the vector’s size before and after adding a score and the score itself, demonstrating the <strong class="source-inline">push_back()</strong> function <span class="No-Break">in action.</span></p>
			<p>What if you need to insert a score at a specific position, not just at the end? The <strong class="source-inline">insert()</strong> function becomes your best ally. If you wanted to insert a score of <strong class="source-inline">85</strong> at the third position, you’d use an iterator to specify <span class="No-Break">the location:</span></p>
			<p> <strong class="source-inline">scores.insert(scores.begin() + </strong><span class="No-Break"><strong class="source-inline">2, 85);</strong></span></p>
			<p>Remember that vector indexing starts at <strong class="source-inline">0</strong>; the <strong class="source-inline">+ 2</strong> is for the <span class="No-Break">third position.</span></p>
			<p>Let’s expand on the previous example by incorporating the use of the <strong class="source-inline">insert()</strong> function<a id="_idIndexMarker036"/> in <span class="No-Break">the following:</span></p>
			<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;vector&gt;
int main() {
  std::vector&lt;int&gt; scores = {90, 92, 97};
  std::cout &lt;&lt; "Initial scores: ";
  for (int score : scores) { std::cout &lt;&lt; " " &lt;&lt; score; }
  std::cout &lt;&lt; "\n";
  scores.push_back(95);
  std::cout &lt;&lt; "Scores after adding 95 to the end: ";
  for (int score : scores) { std::cout &lt;&lt; " " &lt;&lt; score; }
  std::cout &lt;&lt; "\n";
  scores.insert(scores.begin() + 2, 85);
  std::cout &lt;&lt; "Scores after inserting 85 at the third "
               "position:";
  for (int score : scores) { std::cout &lt;&lt; " " &lt;&lt; score; }
  std::cout &lt;&lt; "\n";
  return 0;
}</pre>			<p>This program will showcase the original scores, display the scores after appending one to the end, and inserting one in the third position. It illustrates the <strong class="source-inline">push_back()</strong> and <strong class="source-inline">insert()</strong> functions <span class="No-Break">in action.</span></p>
			<p>And vectors<a id="_idIndexMarker037"/> don’t stop there. The <strong class="source-inline">emplace_back()</strong> and <strong class="source-inline">emplace()</strong> functions allow for constructing elements directly inside the vector. This means fewer temporary objects and a potential boost in performance, especially with complex <span class="No-Break">data types.</span></p>
			<p>Let’s consider a <strong class="source-inline">Person</strong> class that has a few data members. To create a new <strong class="source-inline">Person</strong> object, a string concatenation operation is performed. Using <strong class="source-inline">emplace_back()</strong> and <strong class="source-inline">emplace()</strong> will avoid extra temporary objects and copy/move operations that <strong class="source-inline">push_back()</strong> might cause, offering a performance boost. The following code <span class="No-Break">demonstrates this:</span></p>
			<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
class Person {
public:
  Person(const std::string &amp;firstName,
         const std::string &amp;lastName)
      : fullName(firstName + " " + lastName) {}
  const std::string &amp;getName() const { return fullName; }
private:
  std::string fullName;
};
int main() {
  std::vector&lt;Person&gt; people;
  people.emplace_back("John", "Doe");
  people.emplace(people.begin(), "Jane", "Doe");
  for (const auto &amp;person : people) {
    std::cout &lt;&lt; person.getName() &lt;&lt; "\n";
  }
  return 0;
}</pre>			<p>This <a id="_idIndexMarker038"/>example clarifies how <strong class="source-inline">emplace_back()</strong> and <strong class="source-inline">emplace()</strong> allow for the direct construction of objects inside the vector. Using <strong class="source-inline">push_back()</strong> might create temporary <strong class="source-inline">Person</strong> objects. Using <strong class="source-inline">emplace_back()</strong> directly constructs the object in place, potentially avoiding temporary object creation. Using <strong class="source-inline">insert()</strong> might create temporary <strong class="source-inline">Person</strong> objects. Using <strong class="source-inline">emplace()</strong> directly constructs the object in place at the specified location. This is particularly beneficial with types such as <strong class="source-inline">Person</strong>, where the constructor might involve resource-intensive operations (such as string concatenation). In such scenarios, the performance advantage of <strong class="source-inline">emplace</strong> methods over their <strong class="source-inline">push</strong> counterparts <span class="No-Break">becomes evident.</span></p>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor030"/>Removing elements</h2>
			<p>But life isn’t just <a id="_idIndexMarker039"/>about adding. Sometimes, we need to remove data. The <strong class="source-inline">pop_back() </strong>function removes the last element of a vector, reducing its size by one. If, however, you’re looking to remove from a specific position or even a range of positions, the <strong class="source-inline">erase()</strong> function will be <span class="No-Break">your go-to.</span></p>
			<h3>The erase-remove idiom</h3>
			<p>In C++ and its STL, there <a id="_idIndexMarker040"/>are established coding patterns that experienced developers often use. One notable pattern is the <strong class="bold">erase-remove</strong> idiom, which facilitates the removal of specific elements from a container based on defined criteria. This section will detail the functionality of this idiom and discuss newer alternatives introduced <span class="No-Break">in C++20.</span></p>
			<p>STL containers, especially <strong class="source-inline">std::vector</strong>, do not provide a straightforward method to remove elements based on a predicate. Instead, they provide separate methods: one to rearrange elements (using <strong class="source-inline">std::remove</strong> and <strong class="source-inline">std::remove_if</strong>) and another to <span class="No-Break">erase them.</span></p>
			<p>Here’s how the <a id="_idIndexMarker041"/>erase-remove <span class="No-Break">idiom works:</span></p>
			<ol>
				<li><strong class="source-inline">std::remove</strong> or <strong class="source-inline">std::remove_if</strong> is used to reorder elements of the container. Elements that need to be removed are moved to <span class="No-Break">the end.</span></li>
				<li>These algorithms return an iterator pointing to the start of the <span class="No-Break">removed elements.</span></li>
				<li>The container’s <strong class="source-inline">erase</strong> method is then used to remove the elements from the <span class="No-Break">container physically.</span></li>
			</ol>
			<p>A classic example removes all instances of <strong class="source-inline">0</strong> <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">std::vector&lt;int&gt;</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
std::vector&lt;int&gt; numbers = {1, 0, 3, 0, 5};
auto end = std::remove(numbers.begin(), numbers.end(), 0);
numbers.erase(end, numbers.end());</pre>			<h3>Modernizing with std::erase and std::erase_if</h3>
			<p>Recognizing<a id="_idIndexMarker042"/> the ubiquity and somewhat counterintuitive nature of the erase-remove idiom, C++20 introduced direct utility functions to simplify this operation: <strong class="source-inline">std::erase</strong> and <strong class="source-inline">std::erase_if</strong>. These functions merge the two-step process into one, offering a more intuitive and less <span class="No-Break">error-prone approach.</span></p>
			<p>Using the <a id="_idIndexMarker043"/>previous example, removing all instances of <strong class="source-inline">0</strong> with <span class="No-Break">C++20 becomes:</span></p>
			<pre class="source-code">
std::vector&lt;int&gt; numbers = {1, 0, 3, 0, 5};
std::erase(numbers, 0);</pre>			<p>No longer does one have to invoke separate algorithms and remember to handle both stages of the process. Similarly, to remove elements based on a predicate, you would do <span class="No-Break">the following:</span></p>
			<pre class="source-code">
std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5};
std::erase_if(numbers, [](int x){ return x % 2 == 0; });</pre>			<p>While<a id="_idIndexMarker044"/> the <a id="_idIndexMarker045"/>erase-remove idiom has been a cornerstone of STL-based C++ programming for years, modern C++ continues to evolve and simplify common patterns. With <strong class="source-inline">std::erase</strong> and <strong class="source-inline">std::erase_if</strong>, developers now have more straightforward tools to remove container elements, leading to cleaner and more readable code. It’s a testament to the ongoing commitment of the C++ community to enhance the language’s user-friendliness while retaining its power <span class="No-Break">and expressiveness.</span></p>
			<p>Note that <strong class="source-inline">std::vector</strong> has been ingeniously designed to optimize memory operations. While one might intuitively expect the underlying array to resize every time an element is added or removed, that isn’t the case. Instead, when a vector grows, it often allocates more memory than immediately necessary, anticipating future additions. This strategy minimizes the frequent memory reallocations, which could be computationally expensive. Conversely, when elements are removed, the vector doesn’t always shrink its allocated memory immediately. This behavior provides a balance between memory usage and performance. However, it is worth noting that the specifics of these memory management decisions can vary by the C++ library implementation. As such, while the behavior is consistent across implementations in terms of the interface, the internal memory management nuances <span class="No-Break">might differ.</span></p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor031"/>Capacity</h2>
			<p>You <a id="_idIndexMarker046"/>can use the <strong class="source-inline">capacity()</strong> member function to know how much memory has been allocated. The <strong class="source-inline">std::vector::capacity()</strong> member function returns the amount of memory allocated for the vector, which may be greater than its actual size. This value represents the maximum number of elements the vector can hold before reallocating memory, ensuring efficient growth patterns without frequent <span class="No-Break">memory operations.</span></p>
			<p>This can be seen in <span class="No-Break">the following:</span></p>
			<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;vector&gt;
int main() {
  std::vector&lt;int&gt; numbers;
  std::cout &lt;&lt; "Initial size: " &lt;&lt; numbers.size() &lt;&lt; "\n";
  std::cout &lt;&lt; "Initial capacity: " &lt;&lt; numbers.capacity()
            &lt;&lt; "\n";
  for (auto i = 1; i &lt;= 10; ++i) { numbers.push_back(i); }
  std::cout &lt;&lt; "Size after adding 10 elements: "
            &lt;&lt; numbers.size() &lt;&lt; "\n";
  std::cout &lt;&lt; "Capacity after adding 10 elements: "
            &lt;&lt; numbers.capacity() &lt;&lt; "\n";
  for (auto i = 11; i &lt;= 20; ++i) { numbers.push_back(i); }
  std::cout &lt;&lt; "Size after adding 20 elements: "
            &lt;&lt; numbers.size() &lt;&lt; "\n";
  std::cout &lt;&lt; "Capacity after adding 20 elements: "
            &lt;&lt; numbers.capacity() &lt;&lt; "\n";
  for (auto i = 0; i &lt; 5; ++i) { numbers.pop_back(); }
  std::cout &lt;&lt; "Size after removing 5 elements: "
            &lt;&lt; numbers.size() &lt;&lt; "\n";
  std::cout &lt;&lt; "Capacity after removing 5 elements: "
            &lt;&lt; numbers.capacity() &lt;&lt; "\n";
  return 0;
}</pre>			<p>The exact output may be different for your compiler, but here is an <span class="No-Break">example output:</span></p>
			<pre class="console">
Initial size: 0
Initial capacity: 0
Size after adding 10 elements: 10
Capacity after adding 10 elements: 16
Size after adding 20 elements: 20
Capacity after adding 20 elements: 32
Size after removing 5 elements: 15
Capacity after removing 5 elements: 32</pre>			<p>This example <a id="_idIndexMarker047"/>illustrates how the size and capacity of a <strong class="source-inline">std::vector</strong> instance change as elements are added and removed. Examining the outputs shows that the capacity often doesn’t correspond directly with the size, highlighting the memory <span class="No-Break">optimization techniques.</span></p>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor032"/>Prefer using empty() when possible</h2>
			<p>In C++, when <a id="_idIndexMarker048"/>the primary intention is to check whether a container is devoid of elements, it’s recommended to use the <strong class="source-inline">.empty()</strong> member function instead of comparing <strong class="source-inline">.size()</strong> or <strong class="source-inline">.capacity()</strong> with <strong class="source-inline">0</strong>. The <strong class="source-inline">.empty()</strong> function provides a direct way to ascertain whether a container has any elements, and in many implementations, it can offer a performance advantage. Specifically, <strong class="source-inline">.empty()</strong> typically has a constant time complexity of <strong class="source-inline">O(1)</strong>, whereas <strong class="source-inline">.size()</strong> might have a linear time complexity of <strong class="source-inline">O(n)</strong> for some container types, making <strong class="source-inline">.empty()</strong> a more efficient choice for mere emptiness checks. Using <strong class="source-inline">.empty()</strong> can lead to more concise and potentially faster code, especially in <span class="No-Break">performance-critical sections.</span></p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor033"/>Clearing all elements</h2>
			<p>The <strong class="source-inline">clear()</strong> function of <strong class="source-inline">std::vector</strong> is a powerful utility that swiftly erases all elements within<a id="_idIndexMarker049"/> the container. After invoking this function, the <strong class="source-inline">size()</strong> of the vector will return <strong class="source-inline">0</strong>, indicating its now-empty state. However, a crucial aspect to be aware of is that any references, pointers, or iterators that previously pointed to the elements within the vector are invalidated by this operation. This <a id="_idIndexMarker050"/>also holds for any past-the-end iterators. Interestingly, while <strong class="source-inline">clear()</strong> purges all the elements, it doesn’t alter the capacity of the vector. This means that the memory allocated for the vector remains unchanged, allowing for efficient subsequent insertions without <span class="No-Break">immediate reallocation.</span></p>
			<p>The <strong class="source-inline">clear()</strong> member function of <strong class="source-inline">std::vector</strong> removes all elements from the vector, effectively reducing its size to <strong class="source-inline">0</strong>. Here’s a simple example to demonstrate <span class="No-Break">its usage:</span></p>
			<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;vector&gt;
int main() {
  std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5};
  std::cout &lt;&lt; "Original numbers: ";
  for (const auto num : numbers) {
    std::cout &lt;&lt; num &lt;&lt; " ";
  }
  std::cout &lt;&lt; "\n";
  numbers.clear();
  std::cout &lt;&lt; "After using clear(): ";
  // This loop will produce no output.
  for (const auto num : numbers) {
    std::cout &lt;&lt; num &lt;&lt; " ";
  }
  std::cout &lt;&lt; "\n";
  std::cout &lt;&lt; "Size of vector after clear(): "
            &lt;&lt; numbers.size() &lt;&lt; "\n";
  return 0;
}</pre>			<p>Here is the <span class="No-Break">example output:</span></p>
			<pre class="console">
Original numbers: 1 2 3 4 5
After using clear():
Size of vector after clear(): 0</pre>			<p>This <a id="_idIndexMarker051"/>example underscores the efficiency of <strong class="source-inline">std::vector</strong> in handling bulk deletions with a single function call, making data management even <span class="No-Break">more straightforward.</span></p>
			<p>Dynamic resizing is a prominent feature of <strong class="source-inline">std::vector</strong>, but it requires careful management to maintain efficiency. When a vector’s contents exceed its capacity, it necessitates memory reallocation, which involves allocating a new memory block, copying the existing elements, and deallocating the old memory. This process can introduce performance overheads, mainly if the vector grows by small amounts repeatedly. If you can anticipate the maximum size, use the <strong class="source-inline">reserve()</strong> function to pre-allocate memory to mitigate <span class="No-Break">such inefficiencies.</span></p>
			<p>For example, invoking <strong class="source-inline">scores.reserve(100);</strong> allocates memory for 100 elements, reducing the need for frequent reallocations up to <span class="No-Break">that limit.</span></p>
			<p><strong class="source-inline">std::vector</strong> offers a comprehensive set of functions tailored for dynamic data management. It facilitates quickly adding elements, inserting them in between, or removing them from various positions. Coupled with its efficient memory management, <strong class="source-inline">std::vector</strong> stands out as both a flexible and performance-oriented container. As you delve deeper into C++, the utility of <strong class="source-inline">std::vector</strong> will become increasingly apparent, as it addresses a wide range of programming <span class="No-Break">scenarios effectively.</span></p>
			<p>In this section, we explored the dynamic nature of <strong class="source-inline">std::vector</strong>, which allows us to modify its content and size. We learned how to add elements to a vector using methods such as <strong class="source-inline">push_back</strong>, <strong class="source-inline">emplace_back</strong>, and insertion at a specific position using iterators. We also examined the process of removing elements, whether a single element at a particular position, a range of elements, or removing elements <span class="No-Break">by value.</span></p>
			<p>We discussed <a id="_idIndexMarker052"/>the concept of capacity, the amount of pre-allocated space for elements in a vector, and how it differs from size, which is the actual number of elements currently in the vector. Understanding this distinction is critical for writing memory- and <span class="No-Break">performance-efficient programs.</span></p>
			<p>The use of <strong class="source-inline">empty()</strong> as a preferred method for checking whether a vector contains any elements was also highlighted. We discussed the advantages of <strong class="source-inline">empty()</strong> over checking whether <strong class="source-inline">size()</strong> returns <strong class="source-inline">0</strong>, particularly regarding clarity and potential <span class="No-Break">performance benefits.</span></p>
			<p>Additionally, we covered the importance of the <strong class="source-inline">clear()</strong> function, which removes all elements from a vector, effectively resetting its size to <strong class="source-inline">0</strong> without necessarily changing <span class="No-Break">its capacity.</span></p>
			<p>This section’s information is handy because it allows us to manage <strong class="source-inline">std::vector</strong>’s contents actively and efficiently. Knowledge of adding and removing elements is vital for implementing algorithms that require dynamic data manipulation, which is a common scenario in <span class="No-Break">software development.</span></p>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor034"/>Summary</h1>
			<p>In this chapter, you have learned the foundational aspects of <strong class="source-inline">std::vector</strong> in C++ STL. The chapter began by explaining the significance of <strong class="source-inline">std::vector</strong>, highlighting its advantages over C-style arrays, particularly regarding memory management and ease of use. The chapter thoroughly compared C-style arrays and <strong class="source-inline">std::vector</strong>, demonstrating how <strong class="source-inline">std::vector</strong> facilitates dynamic size adjustment and safer <span class="No-Break">memory operations.</span></p>
			<p>Next, you were guided through the processes of declaring and initializing vectors. You learned how to declare <strong class="source-inline">std::vector</strong> and initialize these instances using different methods. The chapter then explored the myriad ways of accessing elements within <strong class="source-inline">std::vector</strong>, from random access to accessing the first and last elements, and underscored the importance of understanding <span class="No-Break">vector size.</span></p>
			<p>Further, the chapter delved into the intricacies of adding and removing elements. This section illuminated the best practices for modifying the contents of a vector, including when to use <strong class="source-inline">empty()</strong> instead of checking for a size of <strong class="source-inline">0</strong> and the significance of understanding a <span class="No-Break">vector’s capacity.</span></p>
			<p>The information presented in this chapter is invaluable as it builds the foundational knowledge required to effectively utilize <strong class="source-inline">std::vector</strong> (and many other STL data types) in various programming scenarios. Mastery of <strong class="source-inline">std::vector</strong> allows for writing more efficient and maintainable code, enabling C++ developers to leverage STL’s full potential for dynamic <span class="No-Break">array manipulation.</span></p>
			<p>In the next chapter, you will elevate your understanding of <strong class="source-inline">std::vector</strong> by learning about iterators, central to navigating through elements in <span class="No-Break">STL containers.</span></p>
		</div>
	</body></html>