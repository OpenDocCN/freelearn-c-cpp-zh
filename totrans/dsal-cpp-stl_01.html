<html><head></head><body>
		<div><h1 id="_idParaDest-15" class="chapter-number"><a id="_idTextAnchor015"/>1</h1>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor016"/>The Basics of std::vector</h1>
			<p><code>std::vector</code> is a fundamental component of C++ programming. This chapter will explore <code>std::vector</code> as a dynamic array, discussing its utility in various programming contexts. By the end of the chapter, you should be adept at declaring, initializing, and manipulating vectors. These skills will enable you to utilize <code>std::vector</code> effectively in diverse applications. It will provide a solid foundation for understanding the broader set of data structures and algorithms of the <strong class="bold">Standard Template </strong><strong class="bold">Library</strong> (<strong class="bold">STL</strong>).</p>
			<p>In this chapter, we’re going to cover the following main topics:</p>
			<ul>
				<li>The significance of <code>std::vector</code></li>
				<li>Declaring and initializing <code>std::vector</code></li>
				<li>Accessing elements</li>
				<li>Adding and removing elements</li>
			</ul>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor017"/>Technical requirements</h1>
			<p>The code in this chapter can be found on GitHub: </p>
			<p><a href="https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL">https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL</a></p>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor018"/>The significance of std::vector</h1>
			<p>In C++, <code>std::vector</code> is a<a id="_idIndexMarker000"/> frequently chosen data structure. While beginners might initially see parallels between it and the basic arrays in C, the advantages of <code>std::vector</code> become evident with deeper exploration. Additionally, a solid grasp of <code>std::vector</code> facilitates a smoother transition to understanding other components of STL.</p>
			<p>Both vectors and arrays function as containers for collections of elements. The critical distinction between them lies in their flexibility and capabilities. Arrays are static in size, set at declaration time, and cannot be altered afterward.</p>
			<p>In contrast, vectors<a id="_idIndexMarker001"/> are dynamic. They can expand or contract based on the operations performed on them. Unlike arrays, which commit to a fixed memory block upon declaration, vectors dynamically manage memory. They frequently allocate extra memory to anticipate future growth, optimizing efficiency and flexibility. While arrays offer simple index-based element access and modification, vectors provide a broader set of functions, including methods for inserting, deleting, and locating elements.</p>
			<p>The primary advantage of <code>std::vector</code> is its combination of dynamic resizing and optimized performance. Traditional C++ arrays have their size set at compile time. If an array is declared to hold 10 elements, it’s constrained to that capacity. However, in many real-world scenarios, the volume of data isn’t determined until runtime. This is where <code>std::vector</code> shines.</p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor019"/>A basic comparison of C-style arrays and std::vector</h2>
			<p>Acting as a<a id="_idIndexMarker002"/> dynamic array, <code>std::vector</code> can adjust its size during program execution. It efficiently manages its memory, reallocating not for each <a id="_idIndexMarker003"/>new addition, but in larger chunks to maintain a balance between performance and adaptability. Thus, rather than pre-committing to a specific size and risking either memory waste or a shortage, <code>std::vector</code> dynamically responds to varying data demands.</p>
			<p>Here are two code examples that demonstrate the contrast between using a C-style array and <code>std::vector</code>.</p>
			<p>The following code demonstrates the use of a C-style array:</p>
			<pre class="source-code">
#include &lt;iostream&gt;
int main() {
  int *cArray = new int[5];
  for (int i = 0; i &lt; 5; ++i) { cArray[i] = i + 1; }
  for (int i = 0; i &lt; 5; ++i) {
    std::cout &lt;&lt; cArray[i] &lt;&lt; " ";
  }
  std::cout &lt;&lt; "\n";
  const int newSize = 7;
  int *newCArray = new int[newSize];
  for (int i = 0; i &lt; 5; ++i) { newCArray[i] = cArray[i]; }
  delete[] cArray;
  cArray = newCArray;
  for (int i = 0; i &lt; newSize; ++i) {
    std::cout &lt;&lt; cArray[i] &lt;&lt; " ";
  }
  std::cout &lt;&lt; "\n";
  int arraySize = newSize;
  std::cout &lt;&lt; "Size of cArray: " &lt;&lt; arraySize &lt;&lt; "\n";
  delete[] cArray;
  return 0;
}</pre>			<p>Here is the example output:</p>
			<pre class="console">
1 2 3 4 5
1 2 3 4 5 0 0
Size of cArray: 7</pre>			<p>In this<a id="_idIndexMarker004"/> example, we<a id="_idIndexMarker005"/> do the following:</p>
			<ol>
				<li>Declare a C-style dynamic array with a size of <code>5</code>.</li>
				<li>Initialize the dynamic array.</li>
				<li>Print the contents of the array.</li>
				<li>Resize the array to a new size (e.g., <code>7</code>).</li>
				<li>Copy the elements from the old array to the new one.</li>
				<li>Deallocate the old array.</li>
				<li>Update the pointer to the new array.</li>
				<li>Print the contents of the resized array.</li>
				<li>Get the size of the resized array.</li>
				<li>Deallocate the resized array when done.</li>
			</ol>
			<p>In contrast, the following code demonstrates the use of <code>std::vector</code>:</p>
			<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;vector&gt;
int main() {
  std::vector&lt;int&gt; stlVector = {1, 2, 3, 4, 5};
  for (const int val : stlVector) {
    std::cout &lt;&lt; val &lt;&lt; " ";
  }
  std::cout &lt;&lt; "\n";
  stlVector.resize(7);
  for (const int val : stlVector) {
    std::cout &lt;&lt; val &lt;&lt; " ";
  }
  std::cout &lt;&lt; "\n";
  std::cout &lt;&lt; "Size of stlVector: " &lt;&lt; stlVector.size()
            &lt;&lt; "\n";
  return 0;
}</pre>			<p>Here is<a id="_idIndexMarker006"/> the example output:</p>
			<pre class="console">
1 2 3 4 5
1 2 3 4 5 0 0
Size of stlVector: 7</pre>			<p>By way of <a id="_idIndexMarker007"/>contrast with the C-style version, in this example, we do the following:</p>
			<ol>
				<li>Declare <code>std::vector</code> with initial values.</li>
				<li>Print the contents of the vector.</li>
				<li>Resize. This operation is easy with <code>std::vector</code>.</li>
				<li>Print again to see the change.</li>
				<li>Get the size. This operation is simple with the <code>size()</code> member function.</li>
			</ol>
			<p>In the initial example, the C-style array is constrained by its fixed size. Modifying its size typically requires a non-trivial procedure. Conversely, <code>std::vector</code> can adjust its size effortlessly and provides a <code>size()</code> method to determine the number of elements it holds.</p>
			<p>Beyond its <a id="_idIndexMarker008"/>dynamic resizing capability, <code>std::vector</code> further simplifies memory management<a id="_idIndexMarker009"/> compared to traditional arrays. With <code>std::vector</code>, there’s no need for explicit memory allocations or deallocations as it internally handles these tasks. This approach minimizes the risk of memory leaks and streamlines the development process. As a result, many C++ developers, regardless of their experience level, prefer using <code>std::vector</code> over raw arrays for convenience and safety.</p>
			<p>Let’s look at an example that contrasts how a legacy C-style array manages memory and how <code>std::vector</code> makes this easier and safer.</p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor020"/>Comparison of C-style arrays and std::vector for memory management</h2>
			<p>First, let us consider an example of a C-style array with manual memory management.</p>
			<p>In this <a id="_idIndexMarker010"/>example, we’ll use<a id="_idIndexMarker011"/> dynamic memory allocation (<code>new</code> and <code>delete</code>) to simulate some of the resizing capabilities of <code>std::vector</code>:</p>
			<pre class="source-code">
#include &lt;iostream&gt;
int main() {
  int *cArray = new int[5];
  for (int i = 0; i &lt; 5; ++i) { cArray[i] = i + 1; }
  int *temp = new int[10];
  for (int i = 0; i &lt; 5; ++i) { temp[i] = cArray[i]; }
  delete[] cArray; // Important: free the old memory
  cArray = temp;
  for (int i = 5; i &lt; 10; ++i) { cArray[i] = i + 1; }
  for (int i = 0; i &lt; 10; ++i) {
    std::cout &lt;&lt; cArray[i] &lt;&lt; " ";
  }
  std::cout &lt;&lt; "\n";
  delete[] cArray;
  return 0;
}</pre>			<p>Here is the example output:</p>
			<pre class="console">
1 2 3 4 5 6 7 8 9 10</pre>			<p>In this <a id="_idIndexMarker012"/>example, we do the<a id="_idIndexMarker013"/> following:</p>
			<ol>
				<li>Dynamically allocate a C-style array with a size of <code>5</code>.</li>
				<li>Populate the array.</li>
				<li>Simulate a resize: allocate a larger array and copy the data.</li>
				<li>Populate the rest of the new array.</li>
				<li>Print the array’s content.</li>
				<li>Clean up the allocated memory.</li>
			</ol>
			<p>Now, let us consider an example of <code>std::vector</code> with built-in memory management.</p>
			<p>Using <code>std::vector</code>, you don’t have to allocate or deallocate memory manually; it is managed internally:</p>
			<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;vector&gt;
int main() {
  std::vector&lt;int&gt; myVector(5);
  for (int i = 0; i &lt; 5; ++i) { myVector[i] = i + 1; }
  for (int i = 5; i &lt; 10; ++i) {
    myVector.push_back(i + 1);
  }
  for (int val : myVector) { std::cout &lt;&lt; val &lt;&lt; " "; }
  std::cout &lt;&lt; "\n";
  return 0;
}</pre>			<p>Here is the example output:</p>
			<pre class="console">
1 2 3 4 5 6 7 8 9 10</pre>			<p>The steps in <a id="_idIndexMarker014"/>this example<a id="_idIndexMarker015"/> include the following:</p>
			<ol>
				<li>Create <code>std::vector</code> with a size of <code>5</code>.</li>
				<li>Populate the vector.</li>
				<li>Resizing is straightforward with <code>push_back()</code> or <code>resize()</code>.</li>
				<li>Print the vector’s contents.<p class="list-inset">There’s no need for explicit memory deallocation.</p></li>
			</ol>
			<p>In the first<a id="_idIndexMarker016"/> example, the challenges <a id="_idIndexMarker017"/>of manual memory management are evident. Failing to use <code>delete</code> appropriately can result in memory leaks. On the other hand, the second example highlights the efficiency of <code>std::vector</code>, which internally manages memory, eliminating the need for manual resizing and memory operations and enhancing the development process.</p>
			<p>Traditional arrays come with a basic set of operations. In contrast, <code>std::vector</code> offers various member functions that provide advanced data manipulation and retrieval capabilities. These functions will be explored in subsequent sections.</p>
			<p>In C++ development, <code>std::vector</code> is a fundamental tool. Its flexibility makes it a go-to choice for various applications, from game development to complex software projects. The built-in safety mechanisms against common memory issues underscore its value. As an STL component, <code>std::vector</code> encourages consistent and optimal coding practices by integrating well with other STL elements.</p>
			<p>This section explored the fundamental differences between C-style arrays and <code>std::vector</code>. Unlike static C-style arrays, we learned that <code>std::vector</code> offers dynamic resizing and robust memory management, which are critical for developing flexible and efficient applications. The comparison detailed how <code>std::vector</code> abstracts away low-level memory handling, thus minimizing common errors associated with manual memory management.</p>
			<p>Understanding <code>std::vector</code> is beneficial because it is one of the most widely used sequence containers in C++ programming. <code>std::vector</code> supports dynamic growth in contiguously allocated memory and random access iteration and is compatible with a range of algorithms in the STL. We also discussed how <code>std::vector</code> provides a safer and more intuitive interface for managing collections of objects.</p>
			<p>The following section will build upon this foundational knowledge. We will learn the syntax for declaring <code>std::vector</code> and the various methods available for initializing it. This will include an examination of default, copy, and move semantics as they pertain to vectors.</p>
			<h1 id="_idParaDest-21"><a id="_idTextAnchor021"/>Declaring and initializing std::vector</h1>
			<p>Having established the foundational knowledge of <code>std::vector</code> in C++ development, it’s time to delve into its practical applications—expressly, how to declare and initialize vectors.</p>
			<p>The essence of <code>std::vector</code> lies in its dynamic nature. Unlike traditional arrays with fixed sizes, vectors can grow or shrink as necessary, making them a versatile tool for developers.</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor022"/>Declaring a vector</h2>
			<p>The <a id="_idIndexMarker018"/>performance of <code>std::vector</code> stems from its design, which combines the benefits of a contiguous memory layout (such as arrays) with the flexibility of dynamic resizing. It reserves memory to hold that many elements when initialized with a specified size. But if the vector fills up and more capacity is needed, it allocates a larger memory block, transfers the existing elements, and deallocates the old memory. This dynamic resizing process is optimized to reduce overhead, ensuring that vectors remain efficient. The fusion of contiguous storage and automated memory management distinguishes <code>std::vector</code> as an essential component in the C++ ecosystem.</p>
			<p>To declare a basic <code>std::vector</code>, use the following:</p>
			<pre class="source-code">
std::vector&lt;int&gt; vec;</pre>			<p>This line of code initializes an empty <code>std::vector</code> named <code>vec</code> specifically designed to hold values of type <code>int</code>. (<code>int</code> is the template parameter inside the <code>&lt;&gt;</code> for <code>std::vector's</code> type.) <code>std::vector</code> is a dynamic array, which means that even though <code>vec</code> begins with a size of <code>0</code>, its capacity can grow as needed. As you insert integers into <code>vec</code>, the container will automatically allocate memory to accommodate the increasing number of elements. This dynamic resizing makes <code>std::vector</code> a versatile and widely used container in C++ for situations where the number of elements isn’t known in advance or might change over time.</p>
			<p>When creating <code>std::vector</code>, it’s possible to specify its initial size. This can be beneficial if you have prior knowledge about the number of elements you’ll need to store:</p>
			<pre class="source-code">
std::vector&lt;int&gt; vec(10);</pre>			<p>In the preceding code, <code>std::vector</code> named <code>vec</code> is initialized with space for 10 integers. By default, these integers will be value-initialized, which means they will be set to <code>0</code> for fundamental data types such as <code>int</code>.</p>
			<p>If you wish<a id="_idIndexMarker019"/> to initialize the elements with a specific value, you can provide a second argument during the vector’s construction:</p>
			<pre class="source-code">
std::vector&lt;int&gt; vec(10, 5);</pre>			<p>Here, <code>std::vector</code> is declared with 10 integers, and each of those 10 integers is initialized to the value of <code>5</code>. This approach ensures efficient memory allocation and desired value initialization in a single step.</p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor023"/>Initializing a vector</h2>
			<p>In C++11 and<a id="_idIndexMarker020"/> later versions, <code>std::vector</code> initialization became more straightforward with the introduction of initializer lists. This allows developers to specify the initial values of the vector directly within curly braces:</p>
			<pre class="source-code">
std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};</pre>			<p>The preceding statement creates an instance of <code>std::vector</code> named <code>vec</code> and initializes it with five integers. This method provides a concise way to declare and populate a vector simultaneously. This is just one way to initialize <code>std::vector</code>. Depending on your needs, there are many ways this can be done:</p>
			<pre class="source-code">
// Method 1: Declare a vector and then add elements using
// push_back (Add integers from 0 to 4)
std::vector&lt;int&gt; vec1;
for (int i = 0; i &lt; 5; ++i) { vec1.push_back(i); }
// Method 2: Initialize a vector with a specific size and
// default value (5 elements with the value 10)
std::vector&lt;int&gt; vec2(5, 10);
// Method 3: List initialization with braced initializers
// Initialize with a list of integers
std::vector&lt;int&gt; vec3 = {1, 2, 3, 4, 5};
// Method 4: Initialize a vector using the fill
// constructor Default-initializes the five elements (with
// zeros)
std::vector&lt;int&gt; vec4(5);
// Method 5: Using std::generate with a lambda function
std::vector&lt;int&gt; vec5(5);
int value = 0;
std::generate(vec5.begin(), vec5.end(),
              [&amp;value]() { return value++; });</pre>			<p><code>std::vector</code> is a versatile templated container capable of storing various data types, not just primitives such as <code>int</code>. You can store objects of custom classes, other standard library types, and pointers. This adaptability makes <code>std::vector</code> suitable for a wide range of <a id="_idIndexMarker021"/>applications and scenarios.</p>
			<p>Furthermore, vectors provide a straightforward mechanism for copying the contents of one vector to another. This is <a id="_idIndexMarker022"/>known as <strong class="bold">copy initialization</strong>. The following code demonstrates this:</p>
			<pre class="source-code">
std::vector&lt;int&gt; vec1 = {1, 2, 3, 4, 5};
std::vector&lt;int&gt; vec2(vec1);</pre>			<p>In this example, <code>vec2</code> is initialized as an exact copy of <code>vec1</code>, meaning <code>vec2</code> will contain the same elements as <code>vec1</code>. This copy initialization ensures that the original vector (<code>vec1</code>) remains unchanged and that the new vector (<code>vec2</code>) is provided with a separate copy of the data.</p>
			<p>One of the true strengths of STL containers is their ability to handle user-defined types seamlessly, extending beyond primitive data types such as <code>int</code> or <code>double</code>. This flexibility is a <a id="_idIndexMarker023"/>testament to its templated design, which allows it to adapt to various data types while maintaining type safety. In the upcoming example, we illustrate this versatility by utilizing <code>std::vector</code> with a custom class:</p>
			<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
class Person {
public:
  Person() = default;
  Person(std::string_view n, int a) : name(n), age(a) {}
  void display() const {
    std::cout &lt;&lt; "Name: " &lt;&lt; name &lt;&lt; ", Age: " &lt;&lt; age
              &lt;&lt; "\n";
  }
private:
  std::string name;
  int age{0};
};
int main() {
  std::vector&lt;Person&gt; people;
  people.push_back(Person("Lisa", 30));
  people.push_back(Person("Corbin", 25));
  people.resize(3);
  people[2] = Person("Aaron", 28);
  for (const auto &amp;person : people) { person.display(); }
  return 0;
}</pre>			<p>Here is the <a id="_idIndexMarker024"/>example output:</p>
			<pre class="console">
Name: Lisa, Age: 30
Name: Corbin, Age: 25
Name: Aaron, Age: 28</pre>			<p>In this example, <code>std::vector</code> is first used to manage objects of the custom <code>Person</code> class. It demonstrates the ease with which <code>std::vector</code> accommodates and manages memory for built-in and user-defined types.</p>
			<p>In C++, while static arrays have their utility, they come with fixed sizes that can sometimes be limiting. On the other hand, <code>std::vector</code> provides a dynamic and flexible alternative.</p>
			<p>Understanding the declaration and initialization of vectors is essential for effective C++ programming. <code>std::vector</code> is a versatile tool suitable for various tasks, from implementing complex algorithms to developing large-scale applications. Incorporating <code>std::vector</code> into your programming practices can enhance the efficiency and maintainability of your code.</p>
			<p>In this section, we covered the syntactical aspects of working with <code>std::vector</code>. Specifically, we delved into the proper techniques for declaring <code>std::vector</code> of various types and the diverse strategies for initializing these vectors to suit different programming scenarios.</p>
			<p>We learned that declaring <code>std::vector</code> involves specifying the type of elements it will contain and, optionally, the initial size and default value for the elements. We discovered multiple methods regarding initialization, including direct-list initialization and initializing with a specific range of values. This section underscored the flexibility of <code>std::vector</code>, showing how it can be tailored to start with a predefined set of elements or be constructed from existing collections.</p>
			<p>This information<a id="_idIndexMarker025"/> is crucial for practical C++ development as it provides a foundation for using <code>std::vector</code> effectively. Proper initialization can lead to performance optimizations and ensure the vector is in a valid state appropriate for its intended use. The ability to declare and initialize vectors succinctly and correctly is a foundational skill for leveraging the power of the STL in real-world C++ applications.</p>
			<p>In the next section, <em class="italic">Accessing elements</em>, we will focus on the operations that allow us to retrieve and modify the contents of a <code>std::vector</code>. We will learn about random access, which allows for the efficient retrieval and modification of elements at any position within the vector. Additionally, we will explore how to access the first and last elements, and the importance of understanding and managing vector size to ensure robust and error-free code.</p>
			<h1 id="_idParaDest-24"><a id="_idTextAnchor024"/>Accessing elements</h1>
			<p>Having <a id="_idIndexMarker026"/>discussed the declaration and initialization of <code>std::vector</code>, our focus now shifts to accessing and manipulating the contained data. Multiple methods in C++ allow you to access vector elements with both speed and safety.</p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor025"/>Random access</h2>
			<p>The <a id="_idIndexMarker027"/>subscript <code>[]</code> operator allows direct element access via indices, similar to arrays. In the following example, given a vector, the expression <code>numbers[1]</code> returns the value <code>20</code>. However, using this operator doesn’t involve boundary checks. An index that is out of range, such as <code>numbers[10]</code>, results in undefined behavior, leading to unpredictable outcomes.</p>
			<p>This is shown in the following example:</p>
			<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;vector&gt;
int main() {
  std::vector&lt;int&gt; numbers = {10, 20, 30, 40, 50};
  const auto secondElement = numbers[1];
  std::cout &lt;&lt; "The second element is: " &lt;&lt; secondElement
            &lt;&lt; "\n";
  // Beware: The following line can cause undefined
  // behavior!
  const auto outOfBoundsElement = numbers[10];
  std::cout &lt;&lt; "Accessing an out-of-bounds index: "
            &lt;&lt; outOfBoundsElement &lt;&lt; "\n";
  return 0;
}</pre>			<p>Here is<a id="_idIndexMarker028"/> the example output:</p>
			<pre class="console">
The second element is: 20
Accessing an out-of-bounds index: 0</pre>			<p>For safer index-based access, <code>std::vector</code> offers the <code>at()</code> member function. It performs an index boundary check and throws an <code>out_of_range</code> exception for invalid indices.</p>
			<p>Here is an example of this:</p>
			<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;vector&gt;
int main() {
  std::vector&lt;int&gt; numbers = {10, 20, 30, 40, 50};
  try {
    const auto secondElement = numbers.at(1);
    std::cout &lt;&lt; "The second element is: " &lt;&lt; secondElement
              &lt;&lt; "\n";
  } catch (const std::out_of_range &amp;e) {
    std::cerr &lt;&lt; "Error: " &lt;&lt; e.what() &lt;&lt; "\n";
  }
  try {
    const auto outOfBoundsElement = numbers.at(10);
    std::cout &lt;&lt; "Accessing an out-of-bounds index: "
              &lt;&lt; outOfBoundsElement &lt;&lt; "\n";
  } catch (const std::out_of_range &amp;e) {
    std::cerr &lt;&lt; "Error: " &lt;&lt; e.what() &lt;&lt; "\n";
  }
  return 0;
}</pre>			<p>Caution<a id="_idIndexMarker029"/> is paramount when accessing vector elements. While C++ favors performance, it often sidesteps safety checks, as evident with the subscript operator. Hence, developers must ensure valid access through careful index management or by employing safer methods such as <code>at()</code>.</p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor026"/>Accessing the first and last elements</h2>
			<p>The <a id="_idIndexMarker030"/>first and last elements can be accessed with <code>front()</code> and <code>back()</code>, respectively.</p>
			<p>This is shown in the following example:</p>
			<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;vector&gt;
int main() {
  std::vector&lt;int&gt; numbers = {10, 20, 30, 40, 50};
  const auto firstElement = numbers.front();
  std::cout &lt;&lt; "The first element is: " &lt;&lt; firstElement
            &lt;&lt; "\n";
  const auto lastElement = numbers.back();
  std::cout &lt;&lt; "The last element is: " &lt;&lt; lastElement
            &lt;&lt; "\n";
  return 0;
}</pre>			<p>The example output is as follows:</p>
			<pre class="console">
The first element is: 10
The last element is: 50</pre>			<h2 id="_idParaDest-27"><a id="_idTextAnchor027"/>Vector size</h2>
			<p>With <code>std::vector</code>, understanding<a id="_idIndexMarker031"/> the structure and the amount of data it contains is essential. The <code>size()</code> member function provides the current count of elements stored within the vector. Invoking this function on an instance of <code>std::vector</code> will return the number of elements it holds. This count represents the active elements and can be used to determine the range for valid indexing. The returned value is of type <code>size_t</code>, an unsigned integer type suitable for representing <a id="_idIndexMarker032"/>sizes and counts. It’s beneficial when iterating through a vector, performing size comparisons, or allocating space based on the number of vector elements.</p>
			<p>Let us look at the following code:</p>
			<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;vector&gt;
int main() {
  std::vector&lt;int&gt; data = {1, 2, 3, 4, 5};
  const auto elementCount = data.size();
  std::cout &lt;&lt; "Vector contains " &lt;&lt; elementCount
            &lt;&lt; " elements.\n";
  return 0;
}</pre>			<p>In the preceding code, the <code>size()</code> function is called on the data vector to retrieve and display the number of elements it contains. The result, as expected, indicates that there are five elements in the vector.</p>
			<p>In summary, <code>std::vector</code> offers a suite of tools, ranging from the efficient subscript operator to the safer <code>at()</code> method, and the convenient <code>front()</code> and <code>back()</code> methods. Understanding these tools is vital to efficiently and safely access and manipulate data within a vector.</p>
			<p>In this section, we concentrated on the methodologies for retrieving and inspecting the contents of <code>std::vector</code>. We learned about the capabilities of <code>std::vector</code> to provide random access to its elements, enabling direct access to any element using its index with constant time complexity. This section also detailed the methods to access a vector’s first and last elements through the <code>front()</code> and <code>back()</code> member functions, respectively.</p>
			<p>Moreover, we <a id="_idIndexMarker033"/>discussed the importance of understanding and utilizing the <code>size() </code>member function to determine the number of elements currently stored in <code>std::vector</code>. This understanding is instrumental in ensuring that our access patterns remain within the bounds of the vector, thereby preventing out-of-range errors and undefined behavior.</p>
			<p>The skills acquired from this section are essential, as they form the basis of interacting with <code>std::vector</code>’s contents. These access patterns are core to using vectors effectively in C++ applications, whether for reading or modifying elements. The ability to directly access elements in a vector leads to efficient algorithms and supports a wide range of everyday programming tasks.</p>
			<p>The following section will advance our knowledge further by addressing how to modify the size and contents of <code>std::vector</code>. We will explore how to add elements to a vector and the various methods available to remove them. This will include understanding how vectors manage their capacity and its implications on performance. We will learn why and how to use <code>.empty()</code> as a more performant alternative to checking whether the size is <code>0</code>, and we will delve into clearing all elements from a vector.</p>
			<h1 id="_idParaDest-28"><a id="_idTextAnchor028"/>Adding and removing elements</h1>
			<p>One of the advantages of <code>std::vector</code> over traditional arrays is its ability to resize dynamically. As applications evolve, so do data requirements; static data structures do not cut it. In this section, we will explore dynamic data management with <code>std::vector</code>, learning to seamlessly add to and remove from vectors while making sure we are staying safe.</p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor029"/>Adding elements</h2>
			<p>Let’s<a id="_idIndexMarker034"/> start with adding elements. The <code>push_back()</code> member function is possibly the most straightforward way to add an element to the end of a vector. Suppose you have <code>std::vector&lt;int&gt; scores;</code> and wish to append a new score, say <code>95</code>. You would simply invoke <code>scores.push_back(95);</code>, and voilà, your score is added.</p>
			<p>Here’s a simple<a id="_idIndexMarker035"/> illustrative code example:</p>
			<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;vector&gt;
int main() {
  std::vector&lt;int&gt; scores;
  std::cout &lt;&lt; "Initial size of scores: " &lt;&lt; scores.size()
            &lt;&lt; "\n";
  scores.push_back(95);
  std::cout &lt;&lt; "Size after adding one score:"
            &lt;&lt; scores.size() &lt;&lt; "\n";
  std::cout &lt;&lt; "Recently added score: " &lt;&lt; scores[0]
            &lt;&lt; "\n";
  return 0;
}</pre>			<p>When run, this program will display the vector’s size before and after adding a score and the score itself, demonstrating the <code>push_back()</code> function in action.</p>
			<p>What if you need to insert a score at a specific position, not just at the end? The <code>insert()</code> function becomes your best ally. If you wanted to insert a score of <code>85</code> at the third position, you’d use an iterator to specify the location:</p>
			<p> <code>scores.insert(scores.begin() + </code><code>2, 85);</code></p>
			<p>Remember that vector indexing starts at <code>0</code>; the <code>+ 2</code> is for the third position.</p>
			<p>Let’s expand on the previous example by incorporating the use of the <code>insert()</code> function<a id="_idIndexMarker036"/> in the following:</p>
			<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;vector&gt;
int main() {
  std::vector&lt;int&gt; scores = {90, 92, 97};
  std::cout &lt;&lt; "Initial scores: ";
  for (int score : scores) { std::cout &lt;&lt; " " &lt;&lt; score; }
  std::cout &lt;&lt; "\n";
  scores.push_back(95);
  std::cout &lt;&lt; "Scores after adding 95 to the end: ";
  for (int score : scores) { std::cout &lt;&lt; " " &lt;&lt; score; }
  std::cout &lt;&lt; "\n";
  scores.insert(scores.begin() + 2, 85);
  std::cout &lt;&lt; "Scores after inserting 85 at the third "
               "position:";
  for (int score : scores) { std::cout &lt;&lt; " " &lt;&lt; score; }
  std::cout &lt;&lt; "\n";
  return 0;
}</pre>			<p>This program will showcase the original scores, display the scores after appending one to the end, and inserting one in the third position. It illustrates the <code>push_back()</code> and <code>insert()</code> functions in action.</p>
			<p>And vectors<a id="_idIndexMarker037"/> don’t stop there. The <code>emplace_back()</code> and <code>emplace()</code> functions allow for constructing elements directly inside the vector. This means fewer temporary objects and a potential boost in performance, especially with complex data types.</p>
			<p>Let’s consider a <code>Person</code> class that has a few data members. To create a new <code>Person</code> object, a string concatenation operation is performed. Using <code>emplace_back()</code> and <code>emplace()</code> will avoid extra temporary objects and copy/move operations that <code>push_back()</code> might cause, offering a performance boost. The following code demonstrates this:</p>
			<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
class Person {
public:
  Person(const std::string &amp;firstName,
         const std::string &amp;lastName)
      : fullName(firstName + " " + lastName) {}
  const std::string &amp;getName() const { return fullName; }
private:
  std::string fullName;
};
int main() {
  std::vector&lt;Person&gt; people;
  people.emplace_back("John", "Doe");
  people.emplace(people.begin(), "Jane", "Doe");
  for (const auto &amp;person : people) {
    std::cout &lt;&lt; person.getName() &lt;&lt; "\n";
  }
  return 0;
}</pre>			<p>This <a id="_idIndexMarker038"/>example clarifies how <code>emplace_back()</code> and <code>emplace()</code> allow for the direct construction of objects inside the vector. Using <code>push_back()</code> might create temporary <code>Person</code> objects. Using <code>emplace_back()</code> directly constructs the object in place, potentially avoiding temporary object creation. Using <code>insert()</code> might create temporary <code>Person</code> objects. Using <code>emplace()</code> directly constructs the object in place at the specified location. This is particularly beneficial with types such as <code>Person</code>, where the constructor might involve resource-intensive operations (such as string concatenation). In such scenarios, the performance advantage of <code>emplace</code> methods over their <code>push</code> counterparts becomes evident.</p>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor030"/>Removing elements</h2>
			<p>But life isn’t just <a id="_idIndexMarker039"/>about adding. Sometimes, we need to remove data. The <code>pop_back() </code>function removes the last element of a vector, reducing its size by one. If, however, you’re looking to remove from a specific position or even a range of positions, the <code>erase()</code> function will be your go-to.</p>
			<h3>The erase-remove idiom</h3>
			<p>In C++ and its STL, there <a id="_idIndexMarker040"/>are established coding patterns that experienced developers often use. One notable pattern is the <strong class="bold">erase-remove</strong> idiom, which facilitates the removal of specific elements from a container based on defined criteria. This section will detail the functionality of this idiom and discuss newer alternatives introduced in C++20.</p>
			<p>STL containers, especially <code>std::vector</code>, do not provide a straightforward method to remove elements based on a predicate. Instead, they provide separate methods: one to rearrange elements (using <code>std::remove</code> and <code>std::remove_if</code>) and another to erase them.</p>
			<p>Here’s how the <a id="_idIndexMarker041"/>erase-remove idiom works:</p>
			<ol>
				<li><code>std::remove</code> or <code>std::remove_if</code> is used to reorder elements of the container. Elements that need to be removed are moved to the end.</li>
				<li>These algorithms return an iterator pointing to the start of the removed elements.</li>
				<li>The container’s <code>erase</code> method is then used to remove the elements from the container physically.</li>
			</ol>
			<p>A classic example removes all instances of <code>0</code> from <code>std::vector&lt;int&gt;</code>:</p>
			<pre class="source-code">
std::vector&lt;int&gt; numbers = {1, 0, 3, 0, 5};
auto end = std::remove(numbers.begin(), numbers.end(), 0);
numbers.erase(end, numbers.end());</pre>			<h3>Modernizing with std::erase and std::erase_if</h3>
			<p>Recognizing<a id="_idIndexMarker042"/> the ubiquity and somewhat counterintuitive nature of the erase-remove idiom, C++20 introduced direct utility functions to simplify this operation: <code>std::erase</code> and <code>std::erase_if</code>. These functions merge the two-step process into one, offering a more intuitive and less error-prone approach.</p>
			<p>Using the <a id="_idIndexMarker043"/>previous example, removing all instances of <code>0</code> with C++20 becomes:</p>
			<pre class="source-code">
std::vector&lt;int&gt; numbers = {1, 0, 3, 0, 5};
std::erase(numbers, 0);</pre>			<p>No longer does one have to invoke separate algorithms and remember to handle both stages of the process. Similarly, to remove elements based on a predicate, you would do the following:</p>
			<pre class="source-code">
std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5};
std::erase_if(numbers, [](int x){ return x % 2 == 0; });</pre>			<p>While<a id="_idIndexMarker044"/> the <a id="_idIndexMarker045"/>erase-remove idiom has been a cornerstone of STL-based C++ programming for years, modern C++ continues to evolve and simplify common patterns. With <code>std::erase</code> and <code>std::erase_if</code>, developers now have more straightforward tools to remove container elements, leading to cleaner and more readable code. It’s a testament to the ongoing commitment of the C++ community to enhance the language’s user-friendliness while retaining its power and expressiveness.</p>
			<p>Note that <code>std::vector</code> has been ingeniously designed to optimize memory operations. While one might intuitively expect the underlying array to resize every time an element is added or removed, that isn’t the case. Instead, when a vector grows, it often allocates more memory than immediately necessary, anticipating future additions. This strategy minimizes the frequent memory reallocations, which could be computationally expensive. Conversely, when elements are removed, the vector doesn’t always shrink its allocated memory immediately. This behavior provides a balance between memory usage and performance. However, it is worth noting that the specifics of these memory management decisions can vary by the C++ library implementation. As such, while the behavior is consistent across implementations in terms of the interface, the internal memory management nuances might differ.</p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor031"/>Capacity</h2>
			<p>You <a id="_idIndexMarker046"/>can use the <code>capacity()</code> member function to know how much memory has been allocated. The <code>std::vector::capacity()</code> member function returns the amount of memory allocated for the vector, which may be greater than its actual size. This value represents the maximum number of elements the vector can hold before reallocating memory, ensuring efficient growth patterns without frequent memory operations.</p>
			<p>This can be seen in the following:</p>
			<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;vector&gt;
int main() {
  std::vector&lt;int&gt; numbers;
  std::cout &lt;&lt; "Initial size: " &lt;&lt; numbers.size() &lt;&lt; "\n";
  std::cout &lt;&lt; "Initial capacity: " &lt;&lt; numbers.capacity()
            &lt;&lt; "\n";
  for (auto i = 1; i &lt;= 10; ++i) { numbers.push_back(i); }
  std::cout &lt;&lt; "Size after adding 10 elements: "
            &lt;&lt; numbers.size() &lt;&lt; "\n";
  std::cout &lt;&lt; "Capacity after adding 10 elements: "
            &lt;&lt; numbers.capacity() &lt;&lt; "\n";
  for (auto i = 11; i &lt;= 20; ++i) { numbers.push_back(i); }
  std::cout &lt;&lt; "Size after adding 20 elements: "
            &lt;&lt; numbers.size() &lt;&lt; "\n";
  std::cout &lt;&lt; "Capacity after adding 20 elements: "
            &lt;&lt; numbers.capacity() &lt;&lt; "\n";
  for (auto i = 0; i &lt; 5; ++i) { numbers.pop_back(); }
  std::cout &lt;&lt; "Size after removing 5 elements: "
            &lt;&lt; numbers.size() &lt;&lt; "\n";
  std::cout &lt;&lt; "Capacity after removing 5 elements: "
            &lt;&lt; numbers.capacity() &lt;&lt; "\n";
  return 0;
}</pre>			<p>The exact output may be different for your compiler, but here is an example output:</p>
			<pre class="console">
Initial size: 0
Initial capacity: 0
Size after adding 10 elements: 10
Capacity after adding 10 elements: 16
Size after adding 20 elements: 20
Capacity after adding 20 elements: 32
Size after removing 5 elements: 15
Capacity after removing 5 elements: 32</pre>			<p>This example <a id="_idIndexMarker047"/>illustrates how the size and capacity of a <code>std::vector</code> instance change as elements are added and removed. Examining the outputs shows that the capacity often doesn’t correspond directly with the size, highlighting the memory optimization techniques.</p>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor032"/>Prefer using empty() when possible</h2>
			<p>In C++, when <a id="_idIndexMarker048"/>the primary intention is to check whether a container is devoid of elements, it’s recommended to use the <code>.empty()</code> member function instead of comparing <code>.size()</code> or <code>.capacity()</code> with <code>0</code>. The <code>.empty()</code> function provides a direct way to ascertain whether a container has any elements, and in many implementations, it can offer a performance advantage. Specifically, <code>.empty()</code> typically has a constant time complexity of <code>O(1)</code>, whereas <code>.size()</code> might have a linear time complexity of <code>O(n)</code> for some container types, making <code>.empty()</code> a more efficient choice for mere emptiness checks. Using <code>.empty()</code> can lead to more concise and potentially faster code, especially in performance-critical sections.</p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor033"/>Clearing all elements</h2>
			<p>The <code>clear()</code> function of <code>std::vector</code> is a powerful utility that swiftly erases all elements within<a id="_idIndexMarker049"/> the container. After invoking this function, the <code>size()</code> of the vector will return <code>0</code>, indicating its now-empty state. However, a crucial aspect to be aware of is that any references, pointers, or iterators that previously pointed to the elements within the vector are invalidated by this operation. This <a id="_idIndexMarker050"/>also holds for any past-the-end iterators. Interestingly, while <code>clear()</code> purges all the elements, it doesn’t alter the capacity of the vector. This means that the memory allocated for the vector remains unchanged, allowing for efficient subsequent insertions without immediate reallocation.</p>
			<p>The <code>clear()</code> member function of <code>std::vector</code> removes all elements from the vector, effectively reducing its size to <code>0</code>. Here’s a simple example to demonstrate its usage:</p>
			<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;vector&gt;
int main() {
  std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5};
  std::cout &lt;&lt; "Original numbers: ";
  for (const auto num : numbers) {
    std::cout &lt;&lt; num &lt;&lt; " ";
  }
  std::cout &lt;&lt; "\n";
  numbers.clear();
  std::cout &lt;&lt; "After using clear(): ";
  // This loop will produce no output.
  for (const auto num : numbers) {
    std::cout &lt;&lt; num &lt;&lt; " ";
  }
  std::cout &lt;&lt; "\n";
  std::cout &lt;&lt; "Size of vector after clear(): "
            &lt;&lt; numbers.size() &lt;&lt; "\n";
  return 0;
}</pre>			<p>Here is the example output:</p>
			<pre class="console">
Original numbers: 1 2 3 4 5
After using clear():
Size of vector after clear(): 0</pre>			<p>This <a id="_idIndexMarker051"/>example underscores the efficiency of <code>std::vector</code> in handling bulk deletions with a single function call, making data management even more straightforward.</p>
			<p>Dynamic resizing is a prominent feature of <code>std::vector</code>, but it requires careful management to maintain efficiency. When a vector’s contents exceed its capacity, it necessitates memory reallocation, which involves allocating a new memory block, copying the existing elements, and deallocating the old memory. This process can introduce performance overheads, mainly if the vector grows by small amounts repeatedly. If you can anticipate the maximum size, use the <code>reserve()</code> function to pre-allocate memory to mitigate such inefficiencies.</p>
			<p>For example, invoking <code>scores.reserve(100);</code> allocates memory for 100 elements, reducing the need for frequent reallocations up to that limit.</p>
			<p><code>std::vector</code> offers a comprehensive set of functions tailored for dynamic data management. It facilitates quickly adding elements, inserting them in between, or removing them from various positions. Coupled with its efficient memory management, <code>std::vector</code> stands out as both a flexible and performance-oriented container. As you delve deeper into C++, the utility of <code>std::vector</code> will become increasingly apparent, as it addresses a wide range of programming scenarios effectively.</p>
			<p>In this section, we explored the dynamic nature of <code>std::vector</code>, which allows us to modify its content and size. We learned how to add elements to a vector using methods such as <code>push_back</code>, <code>emplace_back</code>, and insertion at a specific position using iterators. We also examined the process of removing elements, whether a single element at a particular position, a range of elements, or removing elements by value.</p>
			<p>We discussed <a id="_idIndexMarker052"/>the concept of capacity, the amount of pre-allocated space for elements in a vector, and how it differs from size, which is the actual number of elements currently in the vector. Understanding this distinction is critical for writing memory- and performance-efficient programs.</p>
			<p>The use of <code>empty()</code> as a preferred method for checking whether a vector contains any elements was also highlighted. We discussed the advantages of <code>empty()</code> over checking whether <code>size()</code> returns <code>0</code>, particularly regarding clarity and potential performance benefits.</p>
			<p>Additionally, we covered the importance of the <code>clear()</code> function, which removes all elements from a vector, effectively resetting its size to <code>0</code> without necessarily changing its capacity.</p>
			<p>This section’s information is handy because it allows us to manage <code>std::vector</code>’s contents actively and efficiently. Knowledge of adding and removing elements is vital for implementing algorithms that require dynamic data manipulation, which is a common scenario in software development.</p>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor034"/>Summary</h1>
			<p>In this chapter, you have learned the foundational aspects of <code>std::vector</code> in C++ STL. The chapter began by explaining the significance of <code>std::vector</code>, highlighting its advantages over C-style arrays, particularly regarding memory management and ease of use. The chapter thoroughly compared C-style arrays and <code>std::vector</code>, demonstrating how <code>std::vector</code> facilitates dynamic size adjustment and safer memory operations.</p>
			<p>Next, you were guided through the processes of declaring and initializing vectors. You learned how to declare <code>std::vector</code> and initialize these instances using different methods. The chapter then explored the myriad ways of accessing elements within <code>std::vector</code>, from random access to accessing the first and last elements, and underscored the importance of understanding vector size.</p>
			<p>Further, the chapter delved into the intricacies of adding and removing elements. This section illuminated the best practices for modifying the contents of a vector, including when to use <code>empty()</code> instead of checking for a size of <code>0</code> and the significance of understanding a vector’s capacity.</p>
			<p>The information presented in this chapter is invaluable as it builds the foundational knowledge required to effectively utilize <code>std::vector</code> (and many other STL data types) in various programming scenarios. Mastery of <code>std::vector</code> allows for writing more efficient and maintainable code, enabling C++ developers to leverage STL’s full potential for dynamic array manipulation.</p>
			<p>In the next chapter, you will elevate your understanding of <code>std::vector</code> by learning about iterators, central to navigating through elements in STL containers.</p>
		</div>
	</body></html>