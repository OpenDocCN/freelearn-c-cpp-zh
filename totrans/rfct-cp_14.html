<html><head></head><body>
<div id="_idContainer028">
<h1 class="chapter-number" id="_idParaDest-283"><a id="_idTextAnchor282"/><span class="koboSpan" id="kobo.1.1">14</span></h1>
<h1 id="_idParaDest-284"><a id="_idTextAnchor283"/><span class="koboSpan" id="kobo.2.1">Version Control</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In software development, maintaining a clean commit history is essential for producing enduring and coherent code. </span><span class="koboSpan" id="kobo.3.2">This chapter emphasizes that a well-organized commit history is fundamental to robust software engineering. </span><span class="koboSpan" id="kobo.3.3">By focusing on version control, particularly through clear commit summaries and messages, we will explore the techniques and intentional practices needed to achieve clarity </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">and precision.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">Committing code is like adding individual threads to the overall narrative of a project’s development. </span><span class="koboSpan" id="kobo.5.2">Each commit, with its summary and message, contributes to the understanding of the project’s history and future direction. </span><span class="koboSpan" id="kobo.5.3">Maintaining a clean commit history goes beyond organizational neatness; it embodies effective communication among developers, facilitates seamless collaboration, and enables quick navigation through the project’s </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">development history.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">In the following sections, we will examine what makes a “good” commit, focusing on attributes that bring clarity, purpose, and utility to commit messages. </span><span class="koboSpan" id="kobo.7.2">This exploration goes beyond the basics, delving into strategic documentation of code changes and insights gained through tools such as Git. </span><span class="koboSpan" id="kobo.7.3">With illustrative examples, we will see how well-crafted commit histories can transform understanding, aid in debugging, and streamline the review process by clearly conveying the rationale behind </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">code alterations.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">Advancing further, we will decode the Conventional Commits specification, a structured framework designed to standardize commit messages, thereby infusing them with predictability and machine-parseable clarity. </span><span class="koboSpan" id="kobo.9.2">This section illuminates the symbiotic relationship between commit message structure and automated tooling, showcasing how adherence to such conventions can dramatically enhance </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">project maintainability.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">As we progress, the narrative unfolds to reveal the practicalities of enforcing these best practices through the lens of commit linting. </span><span class="koboSpan" id="kobo.11.2">Here, we delve into the integration of automated tools within </span><strong class="bold"><span class="koboSpan" id="kobo.12.1">Continuous Integration</span></strong><span class="koboSpan" id="kobo.13.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.14.1">CI</span></strong><span class="koboSpan" id="kobo.15.1">) workflows, demonstrating</span><a id="_idIndexMarker808"/><span class="koboSpan" id="kobo.16.1"> how such mechanisms serve as vigilant guardians of commit quality, ensuring consistency and compliance with </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">established norms.</span></span></p>
<p><span class="koboSpan" id="kobo.18.1">This chapter goes beyond explaining the mechanics of version control; it invites you to view crafting clean commit histories as a vital part of software craftsmanship. </span><span class="koboSpan" id="kobo.18.2">By following the principles and practices discussed here, developers and teams can improve their code repositories’ quality and create an environment that promotes innovation, collaboration, and efficiency. </span><span class="koboSpan" id="kobo.18.3">As we explore this chapter, remember that a clear commit history reflects our dedication to excellence in </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">software development.</span></span></p>
<h1 id="_idParaDest-285"><a id="_idTextAnchor284"/><span class="koboSpan" id="kobo.20.1">What is a good commit?</span></h1>
<p><span class="koboSpan" id="kobo.21.1">At the heart of effective version control practices lies the concept of a “good commit,” a fundamental unit of change that embodies the </span><a id="_idIndexMarker809"/><span class="koboSpan" id="kobo.22.1">principles of clarity, atomicity, and purposefulness within the code base. </span><span class="koboSpan" id="kobo.22.2">Understanding what constitutes a good commit is essential for developers who strive to maintain a clean, navigable, and informative project history. </span><span class="koboSpan" id="kobo.22.3">This section delves into the key attributes that define the quality of a commit, offering insights into how developers can enhance their version </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">control practices.</span></span></p>
<h2 id="_idParaDest-286"><a id="_idTextAnchor285"/><span class="koboSpan" id="kobo.24.1">The principle of singular focus</span></h2>
<p><span class="koboSpan" id="kobo.25.1">A good commit adheres to the principle of atomicity, meaning it encapsulates a single logical change within the code base. </span><span class="koboSpan" id="kobo.25.2">This singular focus ensures that each commit is independently meaningful and that the project can be safely </span><a id="_idIndexMarker810"/><span class="koboSpan" id="kobo.26.1">and easily reverted or modified by reverting or adjusting individual commits. </span><span class="koboSpan" id="kobo.26.2">Atomic commits simplify code review processes, making it easier for team members to understand and evaluate each change without the noise of unrelated modifications. </span><span class="koboSpan" id="kobo.26.3">For example, instead of combining a new feature implementation with a separate bug fix in one commit, they should be split into two distinct commits, each with its clear purpose </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">and scope.</span></span></p>
<h2 id="_idParaDest-287"><a id="_idTextAnchor286"/><span class="koboSpan" id="kobo.28.1">The art of communication</span></h2>
<p><span class="koboSpan" id="kobo.29.1">The essence of a good commit also lies in its clarity, particularly </span><a id="_idIndexMarker811"/><span class="koboSpan" id="kobo.30.1">evident in the commit message. </span><span class="koboSpan" id="kobo.30.2">A clear commit message succinctly describes the what and the why of the change, serving as concise documentation for future reference. </span><span class="koboSpan" id="kobo.30.3">This clarity extends beyond the immediate team, aiding anyone who interacts with the code base, including new team members, external collaborators, and even the future self. </span><span class="koboSpan" id="kobo.30.4">This becomes especially important when revisiting the code base after a prolonged period, as the commit messages serve as a historical record of the project’s evolution. </span><span class="koboSpan" id="kobo.30.5">This approach is crucial for open source projects because it allows contributors to understand the context and rationale behind the changes, thereby fostering a collaborative and </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">inclusive environment.</span></span></p>
<p><span class="koboSpan" id="kobo.32.1">A well-structured commit message typically includes a concise title line summarizing the change, followed by a blank line and a more detailed explanation if necessary. </span><span class="koboSpan" id="kobo.32.2">The explanation can delve into the rationale behind the change, any implications it might have, and any additional context that helps understand the commit’s purpose. </span><span class="koboSpan" id="kobo.32.3">It is recommended to keep the subject line up to 50 characters. </span><span class="koboSpan" id="kobo.32.4">This ensures that the message fits within the standard width of most terminals, is not terminated by GitHub or other platforms, and is easily scannable. </span><span class="koboSpan" id="kobo.32.5">GitHub truncates subjects shorter than 72 characters, so 72 will be a hard limit and 50 a soft one. </span><span class="koboSpan" id="kobo.32.6">For example, the commit message </span><strong class="source-inline"><span class="koboSpan" id="kobo.33.1">feat: added a lots of needed include directives to make things compile properly</span></strong><span class="koboSpan" id="kobo.34.1"> will be truncated by GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer022">
<span class="koboSpan" id="kobo.36.1"><img alt="Figure 14.1 – Truncated commit message" src="image/B19606_13_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.37.1">Figure 14.1 – Truncated commit message</span></p>
<p><span class="koboSpan" id="kobo.38.1">GitHub truncates the</span><a id="_idIndexMarker812"/><span class="koboSpan" id="kobo.39.1"> last word, </span><strong class="source-inline"><span class="koboSpan" id="kobo.40.1">properly</span></strong><span class="koboSpan" id="kobo.41.1">, and in order to read it, developers will have to click on the commit message. </span><span class="koboSpan" id="kobo.41.2">This is not a big deal but it is a small inconvenience that can be easily avoided by keeping the subject </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">line short.</span></span></p>
<p><span class="koboSpan" id="kobo.43.1">More importantly, it forces the author to be concise and to </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">the point.</span></span></p>
<p><span class="koboSpan" id="kobo.45.1">Other useful practices include using the imperative mood in the subject line, which is a common convention in commit messages. </span><span class="koboSpan" id="kobo.45.2">This means that the subject line should be phrased as a command or instruction, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.46.1">fix the bug</span></strong><span class="koboSpan" id="kobo.47.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.48.1">add the feature</span></strong><span class="koboSpan" id="kobo.49.1">. </span><span class="koboSpan" id="kobo.49.2">This style of writing is more direct and aligns with the idea that a commit represents a change that is being applied to the </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">code base.</span></span></p>
<p><span class="koboSpan" id="kobo.51.1">Prefer not to end the subject line with a period, as it is not a complete sentence and does not help to keep the message short. </span><span class="koboSpan" id="kobo.51.2">The body of the commit message can provide additional context, such as the motivation for the change, the problem it solves, and any relevant details about </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">the implementation.</span></span></p>
<p><span class="koboSpan" id="kobo.53.1">Prefer to wrap the body at 72 characters, because Git does not wrap text for you. </span><span class="koboSpan" id="kobo.53.2">It is a common convention and it makes the message more readable in various contexts, such as terminal windows, text editors, and version control tools. </span><span class="koboSpan" id="kobo.53.3">It can be easily achieved by configuring your </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">code editor.</span></span></p>
<p><span class="koboSpan" id="kobo.55.1">Therefore, the moment spent in reflection before finalizing a commit is not just about ensuring the clarity of the message; it is about reaffirming the value and intent behind the changes themselves. </span><span class="koboSpan" id="kobo.55.2">It is an opportunity to ensure that each contribution to the code base is deliberate, meaningful, and aligned with the project’s objectives. </span><span class="koboSpan" id="kobo.55.3">In this light, taking the time to craft a precise and informative commit message is not only a good practice but a testament to the developer’s commitment to quality </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">and collaboration.</span></span></p>
<h2 id="_idParaDest-288"><a id="_idTextAnchor287"/><span class="koboSpan" id="kobo.57.1">The art of refinement</span></h2>
<p><span class="koboSpan" id="kobo.58.1">Before merging feature branches into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.59.1">main</span></strong><span class="koboSpan" id="kobo.60.1"> branch, it’s prudent for developers to consider the cleanliness and clarity of their commit </span><a id="_idIndexMarker813"/><span class="koboSpan" id="kobo.61.1">history. </span><span class="koboSpan" id="kobo.61.2">Squashing intermediate commits is a thoughtful practice that streamlines the commit log, making it more readable and meaningful for anyone who explores the </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">project history.</span></span></p>
<p><span class="koboSpan" id="kobo.63.1">When you’re on the verge of integrating your work, take a moment to reflect on the commit messages that have accumulated during development. </span><span class="koboSpan" id="kobo.63.2">Ask yourself whether each commit message adds value to the understanding of the project’s evolution or whether it merely clutters the history with redundant or overly granular details. </span><span class="koboSpan" id="kobo.63.3">In many cases, the iterative steps you took to arrive at the final solution—such as minor bug fixes, adjustments in response to code reviews, or corrections to unit tests—may not hold significant value for other contributors or for the </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">future you.</span></span></p>
<p><span class="koboSpan" id="kobo.65.1">Consider a commit history filled with messages such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.66.1">fix bug</span></strong><span class="koboSpan" id="kobo.67.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.68.1">fix unit test</span></strong><span class="koboSpan" id="kobo.69.1">, or multiple </span><strong class="source-inline"><span class="koboSpan" id="kobo.70.1">fix cr</span></strong><span class="koboSpan" id="kobo.71.1"> entries. </span><span class="koboSpan" id="kobo.71.2">Such messages, while indicative of the development process, do not necessarily provide meaningful insights into the changes or their impact on the project. </span><span class="koboSpan" id="kobo.71.3">Squashing these intermediate commits into a single, well-crafted commit not only tidies up the commit log but also ensures that each entry in the history conveys a significant step in the </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">project’s development.</span></span></p>
<p><span class="koboSpan" id="kobo.73.1">By squashing commits, you consolidate these iterative changes into a cohesive narrative that highlights the introduction of a new feature, the resolution of a significant bug, or the implementation of a crucial refactor. </span><span class="koboSpan" id="kobo.73.2">This curated history aids both current contributors and future maintainers in navigating and understanding the project’s progression, enhancing collaboration </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">and efficiency.</span></span></p>
<p><span class="koboSpan" id="kobo.75.1">In summary, before merging, consider the broader perspective of the project’s commit history. </span><span class="koboSpan" id="kobo.75.2">Squashing intermediate commits is a practice in mindfulness, ensuring that the commit log remains a valuable and navigable resource for all contributors, encapsulating the essence of each change in a clear and </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">concise manner.</span></span></p>
<h1 id="_idParaDest-289"><a id="_idTextAnchor288"/><span class="koboSpan" id="kobo.77.1">Conventional Commits specification</span></h1>
<p><span class="koboSpan" id="kobo.78.1">Consistency in commit messages and structures across a project enhances readability and predictability, making it easier for team </span><a id="_idIndexMarker814"/><span class="koboSpan" id="kobo.79.1">members to navigate the project history. </span><span class="koboSpan" id="kobo.79.2">Adhering to a predefined format or set of conventions, such as the Conventional Commits specification, ensures that commit messages are uniformly structured and informative. </span><span class="koboSpan" id="kobo.79.3">These might include starting commit messages with a verb in the imperative mood, specifying the type of change (e.g., </span><strong class="source-inline"><span class="koboSpan" id="kobo.80.1">fix</span></strong><span class="koboSpan" id="kobo.81.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.82.1">feat</span></strong><span class="koboSpan" id="kobo.83.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.84.1">refactor</span></strong><span class="koboSpan" id="kobo.85.1">), and optionally including a scope to clarify what part of the project </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">is affected.</span></span></p>
<h2 id="_idParaDest-290"><a id="_idTextAnchor289"/><span class="koboSpan" id="kobo.87.1">Linking code to context</span></h2>
<p><span class="koboSpan" id="kobo.88.1">A good commit enhances traceability by linking the code change to its broader context, such as a ticket in the project’s issue-tracking system or</span><a id="_idIndexMarker815"/><span class="koboSpan" id="kobo.89.1"> relevant documentation. </span><span class="koboSpan" id="kobo.89.2">Including references in commit messages creates a tangible connection between the technical implementation and the requirements or issues it addresses, facilitating better understanding and tracking of </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">project progress.</span></span></p>
<p><span class="koboSpan" id="kobo.91.1">Incorporating issue tracker IDs, ticket numbers, or other relevant identifiers in commit messages can significantly improve the traceability of changes and the ease with which they can be related to the project’s objectives or reported issues. </span><span class="koboSpan" id="kobo.91.2">It often looks similar to </span><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">fix(FP-1234): corrected the user authentication flow</span></strong><span class="koboSpan" id="kobo.93.1">, where </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">FP-1234</span></strong><span class="koboSpan" id="kobo.95.1"> is the ticket number in the </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">issue-tracking system.</span></span></p>
<p><span class="koboSpan" id="kobo.97.1">In essence, a good commit acts as a coherent, self-contained story within the broader narrative of a project’s development history. </span><span class="koboSpan" id="kobo.97.2">By adhering to these principles, developers not only contribute to the maintainability and readability of the code base but also foster a culture of meticulousness and accountability in version control practices. </span><span class="koboSpan" id="kobo.97.3">Through the disciplined creation of good commits, the project’s history becomes a valuable asset for collaboration, review, and understanding the evolution of </span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">the software.</span></span></p>
<p><span class="koboSpan" id="kobo.99.1">One of the best ways to create good commit messages is by following the Conventional Commits specification. </span><span class="koboSpan" id="kobo.99.2">The Conventional Commits specification stands as a structured framework for commit message formatting, designed with the dual aim of simplifying the process of creating readable commit logs and enabling automated tooling to facilitate version management and release note generation. </span><span class="koboSpan" id="kobo.99.3">This specification delineates a standardized format for commit messages, intending to clearly communicate the nature and intent of changes within a version control system, such </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">as Git.</span></span></p>
<h2 id="_idParaDest-291"><a id="_idTextAnchor290"/><span class="koboSpan" id="kobo.101.1">Overview and intent</span></h2>
<p><span class="koboSpan" id="kobo.102.1">At its core, the Conventional </span><a id="_idIndexMarker816"/><span class="koboSpan" id="kobo.103.1">Commits specification prescribes a format that includes a type, an optional scope, and a succinct description. </span><span class="koboSpan" id="kobo.103.2">The format typically follows </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">this structure:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.105.1">
&lt;type&gt;[optional scope]: &lt;description&gt;
[optional body]
[optional footer(s)]</span></pre>
<p><span class="koboSpan" id="kobo.106.1">The </span><em class="italic"><span class="koboSpan" id="kobo.107.1">type</span></em><span class="koboSpan" id="kobo.108.1"> categorizes the commit according to the nature of the change it introduces, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">feat</span></strong><span class="koboSpan" id="kobo.110.1"> for a new feature or </span><strong class="source-inline"><span class="koboSpan" id="kobo.111.1">fix</span></strong><span class="koboSpan" id="kobo.112.1"> for a bug fix. </span><span class="koboSpan" id="kobo.112.2">The </span><em class="italic"><span class="koboSpan" id="kobo.113.1">scope</span></em><span class="koboSpan" id="kobo.114.1">, though optional, provides additional contextual information, often indicating the part of the code base affected by the change. </span><span class="koboSpan" id="kobo.114.2">The </span><em class="italic"><span class="koboSpan" id="kobo.115.1">description</span></em><span class="koboSpan" id="kobo.116.1"> offers a concise summary of the change, crafted in an </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">imperative mood.</span></span></p>
<h2 id="_idParaDest-292"><a id="_idTextAnchor291"/><span class="koboSpan" id="kobo.118.1">Options and usage</span></h2>
<p><span class="koboSpan" id="kobo.119.1">Commit linting, particularly when adhering to the Conventional Commits specification, ensures that commits are structured in </span><a id="_idIndexMarker817"/><span class="koboSpan" id="kobo.120.1">a clear, predictable, and useful manner. </span><span class="koboSpan" id="kobo.120.2">Here are some examples of commits that comply with commit linting rules, showcasing various types of changes that might occur in a </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">software project:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.122.1">Adding a </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">new feature:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.124.1">
feat(authentication): add biometric authentication support</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.125.1">This commit message indicates that a new feature (</span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">feat</span></strong><span class="koboSpan" id="kobo.127.1">) has been added, (specifically, biometric authentication support) and the scope of this feature is within the authentication module of </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">the application.</span></span></p></li>
<li><span class="koboSpan" id="kobo.129.1">Fixing </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">a bug:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.131.1">
fix(database): resolve race condition in user data retrieval</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.132.1">Here, a bug fix (</span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">fix</span></strong><span class="koboSpan" id="kobo.134.1">) is being committed, addressing a race condition issue within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">database</span></strong><span class="koboSpan" id="kobo.136.1"> module, particularly in the process of user </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">data retrieval.</span></span></p></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.138.1">Improving documentation:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.139.1">
docs(readme): update installation instructions</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.140.1">This example shows a documentation update (</span><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">docs</span></strong><span class="koboSpan" id="kobo.142.1">), with the changes made to the project’s README file to update the </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">installation instructions.</span></span></p></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.144.1">Code refactoring:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.145.1">
refactor(ui): simplify button component logic</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.146.1">In this commit, existing code has been refactored (</span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">refactor</span></strong><span class="koboSpan" id="kobo.148.1">) without adding any new features or fixing any bugs. </span><span class="koboSpan" id="kobo.148.2">The scope of the refactoring is the UI, specifically simplifying the logic used in a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">button</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.150.1"> component.</span></span></p></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.151.1">Style adjustments:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.152.1">
style(css): remove unused CSS classes</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.153.1">This commit message signifies a styling change (</span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">style</span></strong><span class="koboSpan" id="kobo.155.1">), where unused CSS classes are being removed. </span><span class="koboSpan" id="kobo.155.2">It’s worth noting that this type of commit does not affect the functionality of </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">the code.</span></span></p></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.157.1">Adding tests:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.158.1">
test(api): add tests for new user endpoint</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.159.1">Here, new tests (</span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">test</span></strong><span class="koboSpan" id="kobo.161.1">) have been </span><a id="_idIndexMarker818"/><span class="koboSpan" id="kobo.162.1">added for a new user endpoint in the API, indicating an enhancement in the project’s </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">test coverage.</span></span></p></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.164.1">Chore tasks:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.165.1">
chore(build): update build script for deployment</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.166.1">This commit represents a chore (</span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">chore</span></strong><span class="koboSpan" id="kobo.168.1">), typically a maintenance or setup task that doesn’t directly modify the source code or add functionality, such as updating a build script </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">for deployment.</span></span></p></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.170.1">Breaking change:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.171.1">
feat(database): change database schema for users table</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.172.1">
BREAKING CHANGE: The database schema modification requires resetting the database. </span><span class="koboSpan" id="kobo.172.2">This change will affect all services interacting with the users table.</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.173.1">Another method to indicate a breaking change is by adding an exclamation mark (</span><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">!</span></strong><span class="koboSpan" id="kobo.175.1">) after the type and scope but before the colon in the commit message. </span><span class="koboSpan" id="kobo.175.2">This method is succinct and </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">visually noticeable:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.177.1">
feat!(api): overhaul authentication system</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.178.1">This commit introduces a new feature (</span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">feat</span></strong><span class="koboSpan" id="kobo.180.1">) related to the database schema of the user’s table but also includes a </span><span class="No-Break"><span class="koboSpan" id="kobo.181.1">breaking change.</span></span></p></li>
</ul>
<p><span class="koboSpan" id="kobo.182.1">These examples illustrate how commit linting, guided by the Conventional Commits specification, facilitates clear, structured, and informative commit messages that enhance project maintainability </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">and collaboration.</span></span></p>
<h2 id="_idParaDest-293"><a id="_idTextAnchor292"/><span class="koboSpan" id="kobo.184.1">Origins and adoption</span></h2>
<p><span class="koboSpan" id="kobo.185.1">The Conventional Commits specification</span><a id="_idIndexMarker819"/><span class="koboSpan" id="kobo.186.1"> was inspired by the need to streamline the creation of readable and automated changelogs. </span><span class="koboSpan" id="kobo.186.2">It builds upon earlier practices from the AngularJS team and has since been adopted by various open source and enterprise projects seeking to standardize commit messaging for improved project maintainability </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">and collaboration.</span></span></p>
<h2 id="_idParaDest-294"><a id="_idTextAnchor293"/><span class="koboSpan" id="kobo.188.1">Advantages of Conventional Commits</span></h2>
<p><span class="koboSpan" id="kobo.189.1">Adhering to the Conventional Commits specification offers </span><a id="_idIndexMarker820"/><span class="No-Break"><span class="koboSpan" id="kobo.190.1">numerous benefits:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.191.1">Automated Semver handling</span></strong><span class="koboSpan" id="kobo.192.1">: By categorizing commits, tools can automatically determine version bumps based on the semantic meaning </span><a id="_idIndexMarker821"/><span class="koboSpan" id="kobo.193.1">of changes, adhering to </span><strong class="bold"><span class="koboSpan" id="kobo.194.1">Semantic Versioning</span></strong><span class="koboSpan" id="kobo.195.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.196.1">Semver</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">) principles</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.198.1">Streamlined release notes</span></strong><span class="koboSpan" id="kobo.199.1">: Automated tools can generate comprehensive and clear release notes and changelogs by parsing structured commit messages, significantly reducing manual effort and enhancing </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">release documentation</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.201.1">Enhanced readability</span></strong><span class="koboSpan" id="kobo.202.1">: The standardized format improves the readability of commit history, making it easier for developers to navigate and understand </span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">project evolution</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.204.1">Facilitated code reviews</span></strong><span class="koboSpan" id="kobo.205.1">: The clear categorization and description of changes aid in the code review process, enabling reviewers to quickly grasp the scope and intent </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">of changes</span></span></li>
</ul>
<h1 id="_idParaDest-295"><a id="_idTextAnchor294"/><span class="koboSpan" id="kobo.207.1">Commitlint – enforcing commit message standards</span></h1>
<p><span class="koboSpan" id="kobo.208.1">Commitlint is a powerful, configurable tool designed to enforce commit message conventions, ensuring consistency and clarity across a</span><a id="_idIndexMarker822"/><span class="koboSpan" id="kobo.209.1"> project’s commit history. </span><span class="koboSpan" id="kobo.209.2">It plays a crucial role in maintaining a clean, readable, and meaningful commit log, particularly when used in conjunction with conventions such as the Conventional Commits specification. </span><span class="koboSpan" id="kobo.209.3">This section provides a comprehensive guide on how to install, configure, and use commitlint to check commit messages locally, fostering a disciplined approach to version control </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">and collaboration.</span></span></p>
<h2 id="_idParaDest-296"><a id="_idTextAnchor295"/><span class="koboSpan" id="kobo.211.1">Installation</span></h2>
<p><span class="koboSpan" id="kobo.212.1">Commitlint is typically installed via npm, the package manager for Node.js. </span><span class="koboSpan" id="kobo.212.2">To get started, you’ll need to have Node.js and</span><a id="_idIndexMarker823"/><span class="koboSpan" id="kobo.213.1"> npm installed on your development machine. </span><span class="koboSpan" id="kobo.213.2">Once set up, you can install commitlint and its conventional </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">config</span></strong><span class="koboSpan" id="kobo.215.1"> package by running the following commands in your project’s </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">root directory:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.217.1">
npm install --save-dev @commitlint/{cli,config-conventional,prompt-cli}</span></pre>
<p><span class="koboSpan" id="kobo.218.1">This command installs commitlint and the conventional commits configuration as development dependencies in your project, making them available for use in the local </span><span class="No-Break"><span class="koboSpan" id="kobo.219.1">development environment.</span></span></p>
<h2 id="_idParaDest-297"><a id="_idTextAnchor296"/><span class="koboSpan" id="kobo.220.1">Configuration</span></h2>
<p><span class="koboSpan" id="kobo.221.1">After installation, commitlint requires a </span><a id="_idIndexMarker824"/><span class="koboSpan" id="kobo.222.1">configuration file to define the rules it will enforce. </span><span class="koboSpan" id="kobo.222.2">The most straightforward way to configure commitlint is by using the conventional commits configuration, which aligns with the Conventional Commits specification. </span><span class="koboSpan" id="kobo.222.3">Create a file named </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">commitlint.config.js</span></strong><span class="koboSpan" id="kobo.224.1"> in your project’s root directory, and add the </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">following content:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.226.1">
module.exports = {extends: ['@commitlint/config-conventional']};</span></pre>
<p><span class="koboSpan" id="kobo.227.1">This configuration instructs commitlint to use the standard rules provided by the Conventional Commits configuration, which include checks for the structure, types, and scopes of </span><span class="No-Break"><span class="koboSpan" id="kobo.228.1">commit messages.</span></span></p>
<h2 id="_idParaDest-298"><a id="_idTextAnchor297"/><span class="koboSpan" id="kobo.229.1">Local usage</span></h2>
<p><span class="koboSpan" id="kobo.230.1">To check commit messages locally, you can use</span><a id="_idIndexMarker825"/><span class="koboSpan" id="kobo.231.1"> commitlint in conjunction with Husky, a tool for managing Git hooks. </span><span class="koboSpan" id="kobo.231.2">Husky can be configured to trigger commitlint to evaluate commit messages before they are committed, providing immediate feedback to </span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">the developer.</span></span></p>
<p><span class="koboSpan" id="kobo.233.1">First, install Husky as a </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">development dependency:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.235.1">
npm install --save-dev husky</span></pre>
<p><span class="koboSpan" id="kobo.236.1">Let us check local commits </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">with commitlint:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.238.1">
npx commitlint --from HEAD~1 --to HEAD --verbose
⧗   input: feat: add output
✔   found 0 problems, 0 warnings</span></pre>
<p><span class="koboSpan" id="kobo.239.1">In this example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">--from HEAD~1</span></strong><span class="koboSpan" id="kobo.241.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">--to HEAD</span></strong><span class="koboSpan" id="kobo.243.1"> specify the range of commits to check, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">--verbose</span></strong><span class="koboSpan" id="kobo.245.1"> provides</span><a id="_idIndexMarker826"/><span class="koboSpan" id="kobo.246.1"> detailed output. </span><span class="koboSpan" id="kobo.246.2">If the commit message does not adhere to the specified conventions, commitlint will output an error message, indicating the violations that need to </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">be addressed.</span></span></p>
<p><span class="koboSpan" id="kobo.248.1">Let us add a bad commit message and check it </span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">with commitlint:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.250.1">
git commit -m"Changed output type"
npx commitlint --from HEAD~1 --to HEAD --verbose
⧗   input: Changed output type
✖   subject may not be empty [subject-empty]
✖   type may not be empty [type-empty]
✖   found 2 problems, 0 warnings
ⓘ   Get help: https://github.com/conventional-changelog/commitlint/#what-is-commitlint</span></pre>
<p><span class="koboSpan" id="kobo.251.1">Commitlint can be integrated as a Git hook by adding the following configuration to your </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">package.json</span></strong><span class="koboSpan" id="kobo.253.1"> file or by creating a </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">.huskyrc</span></strong><span class="koboSpan" id="kobo.255.1"> file with the </span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">same content:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.257.1">
"husky": {
  "hooks": {
    "commit-msg": "commitlint -E HUSKY_GIT_PARAMS"
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.258.1">This configuration sets up a pre-commit hook that invokes commitlint with the commit message that is about to be committed. </span><span class="koboSpan" id="kobo.258.2">If the commit message does not meet the specified standards, commitlint will reject the commit, and the developer will need to revise the </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">message accordingly.</span></span></p>
<h2 id="_idParaDest-299"><a id="_idTextAnchor298"/><span class="koboSpan" id="kobo.260.1">Customizing rules</span></h2>
<p><span class="koboSpan" id="kobo.261.1">Commitlint offers a wide array of configuration and customization options, allowing teams to tailor commit message validation rules to fit their</span><a id="_idIndexMarker827"/><span class="koboSpan" id="kobo.262.1"> specific project requirements and workflows. </span><span class="koboSpan" id="kobo.262.2">This flexibility ensures that commitlint can be adapted to support various commit conventions beyond the standard Conventional Commits format, providing a robust framework for enforcing consistent and meaningful commit messages across diverse </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">development environments.</span></span></p>
<h2 id="_idParaDest-300"><a id="_idTextAnchor299"/><span class="koboSpan" id="kobo.264.1">Basic configuration</span></h2>
<p><span class="koboSpan" id="kobo.265.1">The basic configuration of commitlint involves </span><a id="_idIndexMarker828"/><span class="koboSpan" id="kobo.266.1">setting up a </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">commitlint.config.js</span></strong><span class="koboSpan" id="kobo.268.1"> file in your project’s root directory. </span><span class="koboSpan" id="kobo.268.2">This file serves as the central point for defining the rules and conventions that commitlint will enforce. </span><span class="koboSpan" id="kobo.268.3">At its simplest, the configuration might extend a predefined set of rules, such as those provided by </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">@commitlint/config-conventional</span></strong><span class="koboSpan" id="kobo.270.1">, as </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.272.1">
module.exports = {
  extends: ['@commitlint/config-conventional'],
};</span></pre>
<p><span class="koboSpan" id="kobo.273.1">This configuration instructs commitlint to use the conventional commit message rules, enforcing a standard structure and set of types for </span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">commit messages.</span></span></p>
<h2 id="_idParaDest-301"><a id="_idTextAnchor300"/><span class="koboSpan" id="kobo.275.1">Custom rule configuration</span></h2>
<p><span class="koboSpan" id="kobo.276.1">Commitlint’s real power lies in its ability to </span><a id="_idIndexMarker829"/><span class="koboSpan" id="kobo.277.1">customize rules to match specific project needs. </span><span class="koboSpan" id="kobo.277.2">Each rule in commitlint is identified by a string key and can be configured with an array specifying the rule’s level, applicability, and, in some cases, additional options or values. </span><span class="koboSpan" id="kobo.277.3">The rule configuration array generally follows the format </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">[level, </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">applicability, value]</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.281.1">Level</span></strong><span class="koboSpan" id="kobo.282.1">: Determines the severity of violations (</span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">0</span></strong><span class="koboSpan" id="kobo.284.1"> = disabled, </span><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">1</span></strong><span class="koboSpan" id="kobo.286.1"> = warning, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">2</span></strong><span class="koboSpan" id="kobo.288.1"> = </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">error)</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.290.1">Applicability</span></strong><span class="koboSpan" id="kobo.291.1">: Specifies whether the rule is applied (</span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">'always'</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.293.1">or </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">'never'</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">)</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.296.1">Value</span></strong><span class="koboSpan" id="kobo.297.1">: Additional parameters or options for the rule, varying </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">by rule</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.299.1">For example, to enforce that commit messages must start with a type followed by a colon and a space, you could configure the </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">type-enum</span></strong><span class="koboSpan" id="kobo.301.1"> rule </span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.303.1">
module.exports = {
  rules: {
    'type-enum': [2, 'always', ['feat', 'fix', 'docs', 'style', 'refactor', 'test', 'chore']],
  },
};</span></pre>
<p><span class="koboSpan" id="kobo.304.1">This configuration sets the rule level to error (</span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">2</span></strong><span class="koboSpan" id="kobo.306.1">), specifies that the rule should always be applied, and defines a list of acceptable types for </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">commit messages.</span></span></p>
<h2 id="_idParaDest-302"><a id="_idTextAnchor301"/><span class="koboSpan" id="kobo.308.1">Scope and subject configuration</span></h2>
<p><span class="koboSpan" id="kobo.309.1">Commitlint also allows for detailed </span><a id="_idIndexMarker830"/><span class="koboSpan" id="kobo.310.1">configuration of commit message scopes and subjects. </span><span class="koboSpan" id="kobo.310.2">For instance, you can enforce specific scopes or require that commit message subjects do not end with </span><span class="No-Break"><span class="koboSpan" id="kobo.311.1">a period:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.312.1">
module.exports = {
  rules: {
    'scope-enum': [2, 'always', ['ui', 'backend', 'api', 'docs']],
    'subject-full-stop': [2, 'never', '.'],
  },
};</span></pre>
<p><span class="koboSpan" id="kobo.313.1">This setup mandates that commits must use one of the predefined scopes and that the subject line must not end with </span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">a period.</span></span></p>
<h2 id="_idParaDest-303"><a id="_idTextAnchor302"/><span class="koboSpan" id="kobo.315.1">Customizing and sharing configurations</span></h2>
<p><span class="koboSpan" id="kobo.316.1">For projects or organizations with unique</span><a id="_idIndexMarker831"/><span class="koboSpan" id="kobo.317.1"> commit message conventions, custom configurations can be defined and, if needed, shared across multiple projects. </span><span class="koboSpan" id="kobo.317.2">You can create a </span><a id="_idIndexMarker832"/><span class="koboSpan" id="kobo.318.1">dedicated npm package for your commitlint configuration, allowing teams to easily extend this </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">shared configuration:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.320.1">
// commitlint-config-myorg.js
module.exports = {
  rules: {
    // Custom rules here
  },
};
// In a project's commitlint.config.js
module.exports = {
  extends: ['commitlint-config-myorg'],
};</span></pre>
<p><span class="koboSpan" id="kobo.321.1">This approach promotes consistency across projects and simplifies the management of commit message rules within </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">an organization.</span></span></p>
<h2 id="_idParaDest-304"><a id="_idTextAnchor303"/><span class="koboSpan" id="kobo.323.1">Integration with CI</span></h2>
<p><span class="koboSpan" id="kobo.324.1">Ensuring the enforcement of commitlint via CI is a crucial practice in maintaining high-quality commit messages across a project. </span><span class="koboSpan" id="kobo.324.2">While local Git hooks, such</span><a id="_idIndexMarker833"/><span class="koboSpan" id="kobo.325.1"> as those managed by Husky, offer a first line of defense by checking commit messages on the developer’s machine, they are not infallible. </span><span class="koboSpan" id="kobo.325.2">Developers might intentionally or accidentally disable Git hooks, and </span><strong class="bold"><span class="koboSpan" id="kobo.326.1">Integrated Development Environments</span></strong><span class="koboSpan" id="kobo.327.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.328.1">IDEs</span></strong><span class="koboSpan" id="kobo.329.1">) or text editors </span><a id="_idIndexMarker834"/><span class="koboSpan" id="kobo.330.1">might not be properly configured to enforce these hooks or might encounter issues that lead to </span><span class="No-Break"><span class="koboSpan" id="kobo.331.1">their malfunction.</span></span></p>
<p><span class="koboSpan" id="kobo.332.1">Given these potential gaps in local enforcement, CI serves as the authoritative source of truth, providing a centralized, consistent platform for verifying commit messages against the project’s standards. </span><span class="koboSpan" id="kobo.332.2">By integrating commitlint into the CI pipeline, projects ensure that every commit, regardless of its origin or the method used to submit it, adheres to the defined commit message conventions before it is merged into the main code base. </span><span class="koboSpan" id="kobo.332.3">This CI-based enforcement fosters a culture of discipline and accountability, ensuring that all contributions, regardless of their source, meet the project’s </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">quality standards.</span></span></p>
<h3><span class="koboSpan" id="kobo.334.1">Integrating commitlint into CI with GitHub Actions</span></h3>
<p><span class="koboSpan" id="kobo.335.1">GitHub Actions offers a straightforward and powerful platform for integrating commitlint into your CI workflow. </span><span class="koboSpan" id="kobo.335.2">The following example </span><a id="_idIndexMarker835"/><span class="koboSpan" id="kobo.336.1">demonstrates how to set up a</span><a id="_idIndexMarker836"/><span class="koboSpan" id="kobo.337.1"> GitHub action to enforce commit message standards using commitlint on every push or pull request targeting the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">main</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.339.1"> branch.</span></span></p>
<p><span class="koboSpan" id="kobo.340.1">First, create a new file in your repository under </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">.github/workflows/commitlint.yml</span></strong><span class="koboSpan" id="kobo.342.1"> with the </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">following content:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.344.1">
name: Commitlint
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
jobs:
  commitlint:
    runs-on: ubuntu-latest
    steps:
    - name: Check out code
      uses: actions/checkout@v3
      with:
        # Fetch at least the immediate parents so that if this is
        # a pull request then we can checkout the head.
</span><span class="koboSpan" id="kobo.344.2">        fetch-depth: 0
    - name: Check Commit Message
      uses: wagoid/commitlint-github-action@v5
      with:
        failOnWarnings: true</span></pre>
<p><span class="koboSpan" id="kobo.345.1">This workflow defines a job named </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">commitlint</span></strong><span class="koboSpan" id="kobo.347.1"> that triggers on pushes and pull requests to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">main</span></strong><span class="koboSpan" id="kobo.349.1"> branch. </span><span class="koboSpan" id="kobo.349.2">The only</span><a id="_idIndexMarker837"/><span class="koboSpan" id="kobo.350.1"> configuration that I would like to highlight is </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">failOnWarnings: true</span></strong><span class="koboSpan" id="kobo.352.1">, which configures the action to fail the job if any </span><a id="_idIndexMarker838"/><span class="koboSpan" id="kobo.353.1">commitlint warnings are encountered. </span><span class="koboSpan" id="kobo.353.2">This ensures strict adherence to the commit message standards by treating warnings with the same severity </span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">as errors.</span></span></p>
<p><span class="koboSpan" id="kobo.355.1">Let us create a bad commit message and open a PR to see how the </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">action works:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.357.1">
git commit -m"Changed output type"
git checkout -b exit_message
git push origin exit_message</span></pre>
<p><span class="koboSpan" id="kobo.358.1">After we open a PR, we will see that the action </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">has failed:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer023">
<span class="koboSpan" id="kobo.360.1"><img alt="Figure 14.2 – Commitlint action failed" src="image/B19606_13_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.361.1">Figure 14.2 – Commitlint action failed</span></p>
<p><span class="koboSpan" id="kobo.362.1">The logs will show the reason for the failure in the same format as the </span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">local check:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer024">
<span class="koboSpan" id="kobo.364.1"><img alt="Figure 14.3 – Commitlint action log failed" src="image/B19606_13_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.365.1">Figure 14.3 – Commitlint action log failed</span></p>
<p><span class="koboSpan" id="kobo.366.1">By incorporating this workflow into your project, you ensure that every commit is scrutinized for adherence to your commit </span><a id="_idIndexMarker839"/><span class="koboSpan" id="kobo.367.1">message standards before it becomes part of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">main</span></strong><span class="koboSpan" id="kobo.369.1"> branch. </span><span class="koboSpan" id="kobo.369.2">This CI-based check acts as a final gatekeeper, reinforcing the importance of well-structured commit messages and </span><a id="_idIndexMarker840"/><span class="koboSpan" id="kobo.370.1">maintaining the integrity of the project’s </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">commit history.</span></span></p>
<p><span class="koboSpan" id="kobo.372.1">Commitlint’s configurability and customization options provide a powerful platform for enforcing commit message standards tailored to a project’s or organization’s specific needs. </span><span class="koboSpan" id="kobo.372.2">By leveraging these capabilities, teams can ensure that their commit logs remain clear, consistent, and meaningful, thereby enhancing project maintainability and collaboration. </span><span class="koboSpan" id="kobo.372.3">Whether adhering to widely accepted conventions such as the Conventional Commits specification or defining a set of custom rules, commitlint offers the flexibility and control needed to maintain a high-quality </span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">commit history.</span></span></p>
<h1 id="_idParaDest-305"><a id="_idTextAnchor304"/><span class="koboSpan" id="kobo.374.1">Generating changelogs</span></h1>
<p><span class="koboSpan" id="kobo.375.1">Automatic changelog generation is a</span><a id="_idIndexMarker841"/><span class="koboSpan" id="kobo.376.1"> method where software tools automatically create a log of changes made to a project, categorizing and listing updates, fixes, and features. </span><span class="koboSpan" id="kobo.376.2">This process is favored for its efficiency and consistency, ensuring that all significant modifications are documented systematically. </span><span class="koboSpan" id="kobo.376.3">We’ll explore this concept through GitCliff, a tool that parses structured commit messages to generate detailed changelogs, aiding in transparent project management and communication. </span><span class="koboSpan" id="kobo.376.4">GitCliff’s utility in this process exemplifies its role in automating and streamlining project </span><span class="No-Break"><span class="koboSpan" id="kobo.377.1">documentation tasks.</span></span></p>
<h2 id="_idParaDest-306"><a id="_idTextAnchor305"/><span class="koboSpan" id="kobo.378.1">Installation</span></h2>
<p><span class="koboSpan" id="kobo.379.1">GitCliff is written in Rust and </span><a id="_idIndexMarker842"/><span class="koboSpan" id="kobo.380.1">can be installed using Cargo, the Rust package manager. </span><span class="koboSpan" id="kobo.380.2">To install GitCliff, ensure that you have Rust and Cargo installed on your system, and then run the </span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">following command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.382.1">
curl https://sh.rustup.rs -sSf | sh</span></pre>
<p><span class="koboSpan" id="kobo.383.1">After installing Rust, you can install GitCliff </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">using Cargo:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.385.1">
cargo install git-cliff</span></pre>
<p><span class="koboSpan" id="kobo.386.1">The last configuration step is to initialize GitCliff in </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">your project:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.388.1">
git cliff --init</span></pre>
<p><span class="koboSpan" id="kobo.389.1">This generates a default </span><a id="_idIndexMarker843"/><span class="koboSpan" id="kobo.390.1">configuration file, </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">.cliff.toml</span></strong><span class="koboSpan" id="kobo.392.1">, in the root of </span><span class="No-Break"><span class="koboSpan" id="kobo.393.1">your project.</span></span></p>
<h2 id="_idParaDest-307"><a id="_idTextAnchor306"/><span class="koboSpan" id="kobo.394.1">GitCliff usage</span></h2>
<p><span class="koboSpan" id="kobo.395.1">After installing and initializing GitCliff, you can </span><a id="_idIndexMarker844"/><span class="koboSpan" id="kobo.396.1">generate a changelog by running the following command in your project’s </span><span class="No-Break"><span class="koboSpan" id="kobo.397.1">root directory:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.398.1">
git cliff -o CHANGELOG.md</span></pre>
<p><span class="koboSpan" id="kobo.399.1">The tool generates a Markdown file with the changelog, </span><span class="No-Break"><span class="koboSpan" id="kobo.400.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer025">
<span class="koboSpan" id="kobo.401.1"><img alt="Figure 14.4 – Generated changelog" src="image/B19606_13_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.402.1">Figure 14.4 – Generated changelog</span></p>
<p><span class="koboSpan" id="kobo.403.1">The log contains a list of changes, categorized by type, and it highlights </span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">breaking changes.</span></span></p>
<p><span class="koboSpan" id="kobo.405.1">Let us add a release tag and generate a changelog for </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">the release:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.407.1">
git tag v1.0.0 HEAD
git cliff</span></pre>
<p><span class="koboSpan" id="kobo.408.1">The changelog will now</span><a id="_idIndexMarker845"/><span class="koboSpan" id="kobo.409.1"> contain the release tag and the changes since the </span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">last release:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer026">
<span class="koboSpan" id="kobo.411.1"><img alt="Figure 14.5 – Generated changelog with release tag" src="image/B19606_13_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.412.1">Figure 14.5 – Generated changelog with release tag</span></p>
<p><span class="koboSpan" id="kobo.413.1">We can introduce a </span><a id="_idIndexMarker846"/><span class="koboSpan" id="kobo.414.1">breaking change and bump </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">the version:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.416.1">
git commit -m"feat!: make breaking change"
git cliff --bump</span></pre>
<p><span class="koboSpan" id="kobo.417.1">As you can see, GitCliff has detected the breaking change and bumped the version </span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">to 2.0.0:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer027">
<span class="koboSpan" id="kobo.419.1"><img alt="Figure 14.6 – Generated changelog with breaking change" src="image/B19606_13_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.420.1">Figure 14.6 – Generated changelog with breaking change</span></p>
<p><span class="koboSpan" id="kobo.421.1">In the preceding sections, we have comprehensively explored the significant functionalities of </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">git-cliff</span></strong><span class="koboSpan" id="kobo.423.1">, revealing its substantial utility in automating change log generation. </span><span class="koboSpan" id="kobo.423.2">This tool distinguishes itself not only through</span><a id="_idIndexMarker847"/><span class="koboSpan" id="kobo.424.1"> its capacity to streamline the documentation process but also through its seamless integration with CI platforms, including but not limited to GitHub. </span><span class="koboSpan" id="kobo.424.2">Such integration ensures that changelogs are consistently synchronized with the latest project developments, thereby maintaining the accuracy and relevance of </span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">project documentation.</span></span></p>
<p><span class="koboSpan" id="kobo.426.1">An equally noteworthy feature of git-cliff is the extensive customization it offers for changelog generation. </span><span class="koboSpan" id="kobo.426.2">Users are afforded the flexibility to tailor the format, content, and presentation of changelogs to meet specific project requirements or personal preferences. </span><span class="koboSpan" id="kobo.426.3">This high degree of customizability ensures that the output not only aligns with but also enhances the project’s </span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">documentation standards.</span></span></p>
<p><span class="koboSpan" id="kobo.428.1">Given the depth of functionality and the potential benefits that git-cliff offers, those interested in leveraging this tool to its fullest are encouraged to consult the official documentation. </span><span class="koboSpan" id="kobo.428.2">This resource is a treasure trove of detailed information, covering the breadth of features, configurations, and best practices associated with git-cliff. </span><span class="koboSpan" id="kobo.428.3">Engaging with the official documentation will not only solidify your understanding of the tool but also equip you with the knowledge to implement it effectively in </span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">your projects.</span></span></p>
<p><span class="koboSpan" id="kobo.430.1">To summarize, having </span><a id="_idIndexMarker848"/><span class="koboSpan" id="kobo.431.1">delved into the major capabilities and advantages of git-cliff, the path forward for those looking to integrate this tool into their development workflow is through a thorough exploration of the official documentation. </span><span class="koboSpan" id="kobo.431.2">This exploration promises to extend your proficiency in utilizing git-cliff, ensuring that you can fully harness its capabilities to enhance your project’s change log generation and </span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">documentation processes.</span></span></p>
<h1 id="_idParaDest-308"><a id="_idTextAnchor307"/><span class="koboSpan" id="kobo.433.1">Utilizing git-bisect in bug hunting</span></h1>
<p><span class="koboSpan" id="kobo.434.1">During the process of software development, the task of identifying </span><a id="_idIndexMarker849"/><span class="koboSpan" id="kobo.435.1">and rectifying bugs is</span><a id="_idIndexMarker850"/><span class="koboSpan" id="kobo.436.1"> paramount to ensure the stability and reliability of the application. </span><span class="koboSpan" id="kobo.436.2">Among the arsenal available to developers for this purpose, </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">git-bisect</span></strong><span class="koboSpan" id="kobo.438.1"> stands out as a powerful tool, specifically designed for the task of isolating the commit that introduced a bug into the </span><span class="No-Break"><span class="koboSpan" id="kobo.439.1">code base.</span></span></p>
<p><span class="koboSpan" id="kobo.440.1">Embedded within the Git version control system, </span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">git-bisect</span></strong><span class="koboSpan" id="kobo.442.1"> is a utility based on the binary search algorithm. </span><span class="koboSpan" id="kobo.442.2">It aids developers in sifting through a potentially vast commit history to pinpoint the exact change that caused a regression or introduced an error. </span><span class="koboSpan" id="kobo.442.3">By adopting a divide-and-conquer strategy, </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">git-bisect</span></strong><span class="koboSpan" id="kobo.444.1"> significantly streamlines the debugging process, making it an efficient approach </span><span class="No-Break"><span class="koboSpan" id="kobo.445.1">to troubleshooting.</span></span></p>
<p><span class="koboSpan" id="kobo.446.1">The journey with </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">git-bisect</span></strong><span class="koboSpan" id="kobo.448.1"> begins by establishing two critical points in the project’s timeline: a commit where the bug is known to be absent (referred to as </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">good</span></strong><span class="koboSpan" id="kobo.450.1">) and a commit where the bug is confirmed to be present (</span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">bad</span></strong><span class="koboSpan" id="kobo.452.1">). </span><span class="koboSpan" id="kobo.452.2">With these markers set, </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">git-bisect</span></strong><span class="koboSpan" id="kobo.454.1"> proceeds to check out a commit that lies midway between the </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">good</span></strong><span class="koboSpan" id="kobo.456.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">bad</span></strong><span class="koboSpan" id="kobo.458.1"> commits. </span><span class="koboSpan" id="kobo.458.2">This step requires the developer to test the current state of the application to determine whether the bug is present </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">or not.</span></span></p>
<p><span class="koboSpan" id="kobo.460.1">The iterative process involves </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">git-bisect</span></strong><span class="koboSpan" id="kobo.462.1"> selecting a new commit based on the developer’s feedback, and continually narrowing down the search area by halving it with each step. </span><span class="koboSpan" id="kobo.462.2">The cycle of testing and feedback continues until </span><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">git-bisect</span></strong><span class="koboSpan" id="kobo.464.1"> successfully isolates the commit that introduced the bug, effectively zeroing in on the root cause with minimal </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">manual review.</span></span></p>
<p><span class="koboSpan" id="kobo.466.1">The efficiency of </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">git-bisect</span></strong><span class="koboSpan" id="kobo.468.1"> lies in its ability to reduce the number of commits that need to be scrutinized manually, thus conserving valuable development time. </span><span class="koboSpan" id="kobo.468.2">Its methodical approach ensures precision in identifying the problematic </span><a id="_idIndexMarker851"/><span class="koboSpan" id="kobo.469.1">commit, which is crucial for understanding the context of the bug and</span><a id="_idIndexMarker852"/><span class="koboSpan" id="kobo.470.1"> formulating an effective fix. </span><span class="koboSpan" id="kobo.470.2">Being an integral part of the Git ecosystem, </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">git-bisect</span></strong><span class="koboSpan" id="kobo.472.1"> seamlessly fits into the developer’s existing workflow, offering a familiar and straightforward interface </span><span class="No-Break"><span class="koboSpan" id="kobo.473.1">for debugging.</span></span></p>
<p><span class="koboSpan" id="kobo.474.1">To optimize the effectiveness of </span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">git-bisect</span></strong><span class="koboSpan" id="kobo.476.1">, it is imperative to use a reliable and accurate test case for evaluating each commit. </span><span class="koboSpan" id="kobo.476.2">This ensures that the feedback provided to </span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">git-bisect</span></strong><span class="koboSpan" id="kobo.478.1"> correctly reflects the presence or absence of the bug, thereby preventing misidentification. </span><span class="koboSpan" id="kobo.478.2">Maintaining a clean and logical commit history, where each commit encapsulates a single change, enhances the tool’s efficiency. </span><span class="koboSpan" id="kobo.478.3">Furthermore, automating the testing process within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">git-bisect</span></strong><span class="koboSpan" id="kobo.480.1"> session, when feasible, can expedite the </span><span class="No-Break"><span class="koboSpan" id="kobo.481.1">bug-hunting endeavor.</span></span></p>
<p><span class="koboSpan" id="kobo.482.1">Consider a scenario where a regression is detected in a feature that was previously functioning correctly. </span><span class="koboSpan" id="kobo.482.2">It happens often when certain tests are running only at night. </span><span class="koboSpan" id="kobo.482.3">The task is to identify the commit responsible for this regression </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">git-bisect</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.486.1">Start the </span><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">bisect</span></strong><span class="koboSpan" id="kobo.488.1"> session with </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">git </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.490.1">bisect start</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.491.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.492.1">Mark the commit in which the bug is present as </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">git bisect bad &lt;commit hash&gt;</span></strong><span class="koboSpan" id="kobo.494.1"> (usually, it </span><span class="No-Break"><span class="koboSpan" id="kobo.495.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">HEAD</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.497.1">).</span></span></li>
<li><span class="koboSpan" id="kobo.498.1">Identify a commit in the past where the feature worked correctly and mark it as </span><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">good</span></strong><span class="koboSpan" id="kobo.500.1"> using </span><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">git bisect </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">good &lt;commit-hash&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.503.1">.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">git-bisect</span></strong><span class="koboSpan" id="kobo.505.1"> will then check out a commit halfway between the </span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">good</span></strong><span class="koboSpan" id="kobo.507.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">bad</span></strong><span class="koboSpan" id="kobo.509.1"> commits. </span><span class="koboSpan" id="kobo.509.2">Test this commit to see whether the </span><span class="No-Break"><span class="koboSpan" id="kobo.510.1">bug exists.</span></span></li>
<li><span class="koboSpan" id="kobo.511.1">Based on the test outcome, mark the commit as </span><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">good</span></strong><span class="koboSpan" id="kobo.513.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">bad</span></strong><span class="koboSpan" id="kobo.515.1">. </span><strong class="source-inline"><span class="koboSpan" id="kobo.516.1">git-bisect</span></strong><span class="koboSpan" id="kobo.517.1"> uses this feedback to narrow down the search space and selects a new commit </span><span class="No-Break"><span class="koboSpan" id="kobo.518.1">for testing.</span></span></li>
<li><span class="koboSpan" id="kobo.519.1">Repeat the testing and marking process until </span><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">git-bisect</span></strong><span class="koboSpan" id="kobo.521.1"> identifies the commit that introduced </span><span class="No-Break"><span class="koboSpan" id="kobo.522.1">the bug.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.523.1">Once the problematic commit is identified, developers can examine the changes introduced in that commit to understand the cause of the bug and proceed with developing </span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">a fix.</span></span></p>
<p><span class="koboSpan" id="kobo.525.1">To demonstrate how it works, I cloned the master branch of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">rapidjson</span></strong><span class="koboSpan" id="kobo.527.1"> library a bug and put it in the middle of the local repo. </span><span class="koboSpan" id="kobo.527.2">The Git log looks as follows, where </span><strong class="source-inline"><span class="koboSpan" id="kobo.528.1">Bad commit (6 hours ago) &lt;f-squirrel&gt;</span></strong><span class="koboSpan" id="kobo.529.1"> is the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">bad</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.531.1"> one:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.532.1">
a85e2979 - (HEAD -&gt; master) Add RAPIDJSON_BUILD_CXX20 option (6 hours ago) &lt;Brian Rogers&gt;
2cd6149d - fix Visual Studio 2022 (using /std:c++20) warning warning C5232: in C++20 this comparison ...
</span><span class="koboSpan" id="kobo.532.2">478cd636 - Bad commit (6 hours ago) &lt;f-squirrel&gt;
25edb27a - tests: Only run valgrind tests if valgrind was found (23 hours ago) &lt;Richard W.M. </span><span class="koboSpan" id="kobo.532.3">Jones&gt;
606791f6 - Fix static_cast in regex.h (23 hours ago) &lt;Dylan Burr&gt;
5f071d72 - Fix comparision of two doubles (23 hours ago) &lt;Esther Wang&gt;
060a09a1 - Fix schema regex preprocessor include logic (6 weeks ago) &lt;Bryant Ferguson&gt;
6089180e - Use correct format for printf (4 months ago) &lt;Esther Wang&gt;
...</span></pre>
<p><span class="koboSpan" id="kobo.533.1">Let us start bisecting by </span><a id="_idIndexMarker853"/><span class="koboSpan" id="kobo.534.1">marking </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">good</span></strong><span class="koboSpan" id="kobo.536.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">bad</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.538.1"> commits:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.539.1">
$ git bisect start
$ git bisect bad HEAD
$ git bisect good 6089180e
Bisecting: 3 revisions left to test after this (roughly 2 steps)
[606791f6662c136ba34f842313b807114580852d] Fix static_cast in regex.h</span></pre>
<p><span class="koboSpan" id="kobo.540.1">I have prepared a script that </span><a id="_idIndexMarker854"/><span class="koboSpan" id="kobo.541.1">checks whether the bug is present in the current commit. </span><span class="koboSpan" id="kobo.541.2">The script is called </span><strong class="source-inline"><span class="koboSpan" id="kobo.542.1">test.sh</span></strong><span class="koboSpan" id="kobo.543.1"> and looks </span><span class="No-Break"><span class="koboSpan" id="kobo.544.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.545.1">
cmake --build ./build -j $(nproc) || exit 1
./build/bin/unittest || exit 1</span></pre>
<p><span class="koboSpan" id="kobo.546.1">Every time I run the script, I mark the commit as </span><strong class="source-inline"><span class="koboSpan" id="kobo.547.1">good</span></strong><span class="koboSpan" id="kobo.548.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.549.1">bad</span></strong><span class="koboSpan" id="kobo.550.1">. </span><span class="koboSpan" id="kobo.550.2">After a few iterations, I have found the commit that introduced </span><span class="No-Break"><span class="koboSpan" id="kobo.551.1">the bug:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.552.1">
[  PASSED  ] 468 tests.
</span><span class="koboSpan" id="kobo.552.2">$ git bisect good
Bisecting: 1 revision left to test after this (roughly 1 step)
[478cd636a813abe76e32154544b0ec793fdc5566] Bad commit</span></pre>
<p><span class="koboSpan" id="kobo.553.1">If we run the test script again, we will see that the bug is present in </span><span class="No-Break"><span class="koboSpan" id="kobo.554.1">the commit:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.555.1">
[  FAILED  ] 2 tests, listed below:
[  FAILED  ] BigInteger.Constructor
[  FAILED  ] BigInteger.LeftShift
 2 FAILED TESTS</span></pre>
<p><span class="koboSpan" id="kobo.556.1">Once we finish our bug hunt, we can</span><a id="_idIndexMarker855"/><span class="koboSpan" id="kobo.557.1"> reset the </span><strong class="source-inline"><span class="koboSpan" id="kobo.558.1">bisect</span></strong><span class="koboSpan" id="kobo.559.1"> session with </span><strong class="source-inline"><span class="koboSpan" id="kobo.560.1">git </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.561.1">bisect reset</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.562.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.563.1">Jumping between commits for a user is a </span><a id="_idIndexMarker856"/><span class="koboSpan" id="kobo.564.1">useful functionality but not the only one. </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">git-bisect</span></strong><span class="koboSpan" id="kobo.566.1"> can be automated with a script that will run the tests and mark the commits</span><a id="_idIndexMarker857"/><span class="koboSpan" id="kobo.567.1"> as good or bad based on the test results. </span><span class="koboSpan" id="kobo.567.2">Note that the script should return </span><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">0</span></strong><span class="koboSpan" id="kobo.569.1"> if the commit is good and </span><strong class="source-inline"><span class="koboSpan" id="kobo.570.1">1</span></strong><span class="koboSpan" id="kobo.571.1"> if the commit is bad. </span><span class="koboSpan" id="kobo.571.2">The script will run until the bug is found and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.572.1">bisect</span></strong><span class="koboSpan" id="kobo.573.1"> session will be reset. </span><span class="koboSpan" id="kobo.573.2">For our repository, it will look </span><span class="No-Break"><span class="koboSpan" id="kobo.574.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.575.1">
$ git bisect start
$ git bisect bad HEAD
$ git bisect good 6089180e
Bisecting: 3 revisions left to test after this (roughly 2 steps)
[606791f6662c136ba34f842313b807114580852d] Fix static_cast in regex.h
$ git bisect run ./test.sh
running  './test.sh'
... </span><span class="koboSpan" id="kobo.575.2">build and test output ...
</span><span class="koboSpan" id="kobo.575.3">[==========] 468 tests from 34 test suites ran. </span><span class="koboSpan" id="kobo.575.4">(321 ms total)
[  PASSED  ] 468 tests.
</span><span class="koboSpan" id="kobo.575.5">478cd636a813abe76e32154544b0ec793fdc5566 is the first bad commit
commit 478cd636a813abe76e32154544b0ec793fdc5566
Author: f-squirrel &lt;dmitry.b.danilov@gmail.com&gt;
Date:   Mon Mar 25 15:18:18 2024 +0200
    Bad commit
 include/rapidjson/internal/biginteger.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
bisect found first bad commit</span></pre>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.576.1">git-bisect</span></strong><span class="koboSpan" id="kobo.577.1"> is an indispensable</span><a id="_idIndexMarker858"/><span class="koboSpan" id="kobo.578.1"> debugging tool within the Git suite, offering a systematic and efficient </span><a id="_idIndexMarker859"/><span class="koboSpan" id="kobo.579.1">approach to identifying bug-inducing commits. </span><span class="koboSpan" id="kobo.579.2">Its integration into the development workflow, combined with the practice of maintaining a clear commit history and employing automated tests, makes it a highly effective solution for maintaining code quality </span><span class="No-Break"><span class="koboSpan" id="kobo.580.1">and stability.</span></span></p>
<h1 id="_idParaDest-309"><a id="_idTextAnchor308"/><span class="koboSpan" id="kobo.581.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.582.1">In this chapter dedicated to version control, we embarked on an insightful journey through the core principles and practices that underpin effective software version management. </span><span class="koboSpan" id="kobo.582.2">Central to our exploration was the adoption of conventional commits, a structured approach to commit messaging that enhances readability and facilitates automated processing of commit logs. </span><span class="koboSpan" id="kobo.582.3">This practice, grounded in a standardized format for commit messages, enables teams to convey the nature and intent of changes with clarity </span><span class="No-Break"><span class="koboSpan" id="kobo.583.1">and precision.</span></span></p>
<p><span class="koboSpan" id="kobo.584.1">We also delved into SemVer, a methodology designed to manage version numbers in a meaningful way. </span><span class="koboSpan" id="kobo.584.2">SemVer’s systematic approach to versioning, based on the significance of changes in the code base, provides clear guidelines on when and how version numbers should be incremented. </span><span class="koboSpan" id="kobo.584.3">This method offers a transparent framework for version control, ensuring compatibility and facilitating effective dependency management within and </span><span class="No-Break"><span class="koboSpan" id="kobo.585.1">across projects.</span></span></p>
<p><span class="koboSpan" id="kobo.586.1">The chapter further introduced change log creation tools, with a particular focus on git-cliff, a versatile tool that automates the generation of detailed and customizable change logs from Git history. </span><span class="koboSpan" id="kobo.586.2">These tools streamline the documentation process, ensuring that project stakeholders are well informed about the changes, features, and fixes introduced with each </span><span class="No-Break"><span class="koboSpan" id="kobo.587.1">new version.</span></span></p>
<p><span class="koboSpan" id="kobo.588.1">A significant portion of the chapter was dedicated to debugging techniques, highlighting the utility of </span><strong class="source-inline"><span class="koboSpan" id="kobo.589.1">git-bisect</span></strong><span class="koboSpan" id="kobo.590.1"> in the process of isolating bugs. </span><strong class="source-inline"><span class="koboSpan" id="kobo.591.1">git-bisect</span></strong><span class="koboSpan" id="kobo.592.1">, through its binary search algorithm, enables developers to efficiently pinpoint the commit that introduced a bug, thereby significantly reducing the time and effort required </span><span class="No-Break"><span class="koboSpan" id="kobo.593.1">for troubleshooting.</span></span></p>
<p><span class="koboSpan" id="kobo.594.1">In summary, this chapter provided a comprehensive overview of version control practices, emphasizing the importance of structured commit messages, strategic versioning, automated changelog generation, and efficient debugging techniques. </span><span class="koboSpan" id="kobo.594.2">By adopting these practices, development teams can enhance collaboration, maintain code base integrity, and ensure the delivery of </span><span class="No-Break"><span class="koboSpan" id="kobo.595.1">high-quality software.</span></span></p>
<p><span class="koboSpan" id="kobo.596.1">In the next chapter, we will turn our attention to a critical aspect of the development process: code reviews. </span><span class="koboSpan" id="kobo.596.2">We will examine the importance of code reviews in ensuring code quality, fostering team collaboration, and enhancing overall productivity. </span><span class="koboSpan" id="kobo.596.3">By understanding best practices and effective strategies for conducting thorough and constructive code reviews, you will be well equipped to elevate the standards of your code base and contribute more effectively to your team’s success. </span><span class="koboSpan" id="kobo.596.4">Stay tuned as we embark on this insightful journey into the art and science of </span><span class="No-Break"><span class="koboSpan" id="kobo.597.1">code reviews.</span></span></p>
</div>
</body></html>