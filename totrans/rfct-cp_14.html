<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-283"><a id="_idTextAnchor282"/>14</h1>
<h1 id="_idParaDest-284"><a id="_idTextAnchor283"/>Version Control</h1>
<p>In software development, maintaining a clean commit history is essential for producing enduring and coherent code. This chapter emphasizes that a well-organized commit history is fundamental to robust software engineering. By focusing on version control, particularly through clear commit summaries and messages, we will explore the techniques and intentional practices needed to achieve clarity and precision.</p>
<p>Committing code is like adding individual threads to the overall narrative of a project’s development. Each commit, with its summary and message, contributes to the understanding of the project’s history and future direction. Maintaining a clean commit history goes beyond organizational neatness; it embodies effective communication among developers, facilitates seamless collaboration, and enables quick navigation through the project’s development history.</p>
<p>In the following sections, we will examine what makes a “good” commit, focusing on attributes that bring clarity, purpose, and utility to commit messages. This exploration goes beyond the basics, delving into strategic documentation of code changes and insights gained through tools such as Git. With illustrative examples, we will see how well-crafted commit histories can transform understanding, aid in debugging, and streamline the review process by clearly conveying the rationale behind code alterations.</p>
<p>Advancing further, we will decode the Conventional Commits specification, a structured framework designed to standardize commit messages, thereby infusing them with predictability and machine-parseable clarity. This section illuminates the symbiotic relationship between commit message structure and automated tooling, showcasing how adherence to such conventions can dramatically enhance project maintainability.</p>
<p>As we progress, the narrative unfolds to reveal the practicalities of enforcing these best practices through the lens of commit linting. Here, we delve into the integration of automated tools within <strong class="bold">Continuous Integration</strong> (<strong class="bold">CI</strong>) workflows, demonstrating<a id="_idIndexMarker808"/> how such mechanisms serve as vigilant guardians of commit quality, ensuring consistency and compliance with established norms.</p>
<p>This chapter goes beyond explaining the mechanics of version control; it invites you to view crafting clean commit histories as a vital part of software craftsmanship. By following the principles and practices discussed here, developers and teams can improve their code repositories’ quality and create an environment that promotes innovation, collaboration, and efficiency. As we explore this chapter, remember that a clear commit history reflects our dedication to excellence in software development.</p>
<h1 id="_idParaDest-285"><a id="_idTextAnchor284"/>What is a good commit?</h1>
<p>At the heart of effective version control practices lies the concept of a “good commit,” a fundamental unit of change that embodies the <a id="_idIndexMarker809"/>principles of clarity, atomicity, and purposefulness within the code base. Understanding what constitutes a good commit is essential for developers who strive to maintain a clean, navigable, and informative project history. This section delves into the key attributes that define the quality of a commit, offering insights into how developers can enhance their version control practices.</p>
<h2 id="_idParaDest-286"><a id="_idTextAnchor285"/>The principle of singular focus</h2>
<p>A good commit adheres to the principle of atomicity, meaning it encapsulates a single logical change within the code base. This singular focus ensures that each commit is independently meaningful and that the project can be safely <a id="_idIndexMarker810"/>and easily reverted or modified by reverting or adjusting individual commits. Atomic commits simplify code review processes, making it easier for team members to understand and evaluate each change without the noise of unrelated modifications. For example, instead of combining a new feature implementation with a separate bug fix in one commit, they should be split into two distinct commits, each with its clear purpose and scope.</p>
<h2 id="_idParaDest-287"><a id="_idTextAnchor286"/>The art of communication</h2>
<p>The essence of a good commit also lies in its clarity, particularly <a id="_idIndexMarker811"/>evident in the commit message. A clear commit message succinctly describes the what and the why of the change, serving as concise documentation for future reference. This clarity extends beyond the immediate team, aiding anyone who interacts with the code base, including new team members, external collaborators, and even the future self. This becomes especially important when revisiting the code base after a prolonged period, as the commit messages serve as a historical record of the project’s evolution. This approach is crucial for open source projects because it allows contributors to understand the context and rationale behind the changes, thereby fostering a collaborative and inclusive environment.</p>
<p>A well-structured commit message typically includes a concise title line summarizing the change, followed by a blank line and a more detailed explanation if necessary. The explanation can delve into the rationale behind the change, any implications it might have, and any additional context that helps understand the commit’s purpose. It is recommended to keep the subject line up to 50 characters. This ensures that the message fits within the standard width of most terminals, is not terminated by GitHub or other platforms, and is easily scannable. GitHub truncates subjects shorter than 72 characters, so 72 will be a hard limit and 50 a soft one. For example, the commit message <code>feat: added a lots of needed include directives to make things compile properly</code> will be truncated by GitHub as follows:</p>
<div><div><img alt="Figure 14.1 – Truncated commit message" src="img/B19606_13_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.1 – Truncated commit message</p>
<p>GitHub truncates the<a id="_idIndexMarker812"/> last word, <code>properly</code>, and in order to read it, developers will have to click on the commit message. This is not a big deal but it is a small inconvenience that can be easily avoided by keeping the subject line short.</p>
<p>More importantly, it forces the author to be concise and to the point.</p>
<p>Other useful practices include using the imperative mood in the subject line, which is a common convention in commit messages. This means that the subject line should be phrased as a command or instruction, such as <code>fix the bug</code> or <code>add the feature</code>. This style of writing is more direct and aligns with the idea that a commit represents a change that is being applied to the code base.</p>
<p>Prefer not to end the subject line with a period, as it is not a complete sentence and does not help to keep the message short. The body of the commit message can provide additional context, such as the motivation for the change, the problem it solves, and any relevant details about the implementation.</p>
<p>Prefer to wrap the body at 72 characters, because Git does not wrap text for you. It is a common convention and it makes the message more readable in various contexts, such as terminal windows, text editors, and version control tools. It can be easily achieved by configuring your code editor.</p>
<p>Therefore, the moment spent in reflection before finalizing a commit is not just about ensuring the clarity of the message; it is about reaffirming the value and intent behind the changes themselves. It is an opportunity to ensure that each contribution to the code base is deliberate, meaningful, and aligned with the project’s objectives. In this light, taking the time to craft a precise and informative commit message is not only a good practice but a testament to the developer’s commitment to quality and collaboration.</p>
<h2 id="_idParaDest-288"><a id="_idTextAnchor287"/>The art of refinement</h2>
<p>Before merging feature branches into the <code>main</code> branch, it’s prudent for developers to consider the cleanliness and clarity of their commit <a id="_idIndexMarker813"/>history. Squashing intermediate commits is a thoughtful practice that streamlines the commit log, making it more readable and meaningful for anyone who explores the project history.</p>
<p>When you’re on the verge of integrating your work, take a moment to reflect on the commit messages that have accumulated during development. Ask yourself whether each commit message adds value to the understanding of the project’s evolution or whether it merely clutters the history with redundant or overly granular details. In many cases, the iterative steps you took to arrive at the final solution—such as minor bug fixes, adjustments in response to code reviews, or corrections to unit tests—may not hold significant value for other contributors or for the future you.</p>
<p>Consider a commit history filled with messages such as <code>fix bug</code>, <code>fix unit test</code>, or multiple <code>fix cr</code> entries. Such messages, while indicative of the development process, do not necessarily provide meaningful insights into the changes or their impact on the project. Squashing these intermediate commits into a single, well-crafted commit not only tidies up the commit log but also ensures that each entry in the history conveys a significant step in the project’s development.</p>
<p>By squashing commits, you consolidate these iterative changes into a cohesive narrative that highlights the introduction of a new feature, the resolution of a significant bug, or the implementation of a crucial refactor. This curated history aids both current contributors and future maintainers in navigating and understanding the project’s progression, enhancing collaboration and efficiency.</p>
<p>In summary, before merging, consider the broader perspective of the project’s commit history. Squashing intermediate commits is a practice in mindfulness, ensuring that the commit log remains a valuable and navigable resource for all contributors, encapsulating the essence of each change in a clear and concise manner.</p>
<h1 id="_idParaDest-289"><a id="_idTextAnchor288"/>Conventional Commits specification</h1>
<p>Consistency in commit messages and structures across a project enhances readability and predictability, making it easier for team <a id="_idIndexMarker814"/>members to navigate the project history. Adhering to a predefined format or set of conventions, such as the Conventional Commits specification, ensures that commit messages are uniformly structured and informative. These might include starting commit messages with a verb in the imperative mood, specifying the type of change (e.g., <code>fix</code>, <code>feat</code>, or <code>refactor</code>), and optionally including a scope to clarify what part of the project is affected.</p>
<h2 id="_idParaDest-290"><a id="_idTextAnchor289"/>Linking code to context</h2>
<p>A good commit enhances traceability by linking the code change to its broader context, such as a ticket in the project’s issue-tracking system or<a id="_idIndexMarker815"/> relevant documentation. Including references in commit messages creates a tangible connection between the technical implementation and the requirements or issues it addresses, facilitating better understanding and tracking of project progress.</p>
<p>Incorporating issue tracker IDs, ticket numbers, or other relevant identifiers in commit messages can significantly improve the traceability of changes and the ease with which they can be related to the project’s objectives or reported issues. It often looks similar to <code>fix(FP-1234): corrected the user authentication flow</code>, where <code>FP-1234</code> is the ticket number in the issue-tracking system.</p>
<p>In essence, a good commit acts as a coherent, self-contained story within the broader narrative of a project’s development history. By adhering to these principles, developers not only contribute to the maintainability and readability of the code base but also foster a culture of meticulousness and accountability in version control practices. Through the disciplined creation of good commits, the project’s history becomes a valuable asset for collaboration, review, and understanding the evolution of the software.</p>
<p>One of the best ways to create good commit messages is by following the Conventional Commits specification. The Conventional Commits specification stands as a structured framework for commit message formatting, designed with the dual aim of simplifying the process of creating readable commit logs and enabling automated tooling to facilitate version management and release note generation. This specification delineates a standardized format for commit messages, intending to clearly communicate the nature and intent of changes within a version control system, such as Git.</p>
<h2 id="_idParaDest-291"><a id="_idTextAnchor290"/>Overview and intent</h2>
<p>At its core, the Conventional <a id="_idIndexMarker816"/>Commits specification prescribes a format that includes a type, an optional scope, and a succinct description. The format typically follows this structure:</p>
<pre class="source-code">
&lt;type&gt;[optional scope]: &lt;description&gt;
[optional body]
[optional footer(s)]</pre>
<p>The <em class="italic">type</em> categorizes the commit according to the nature of the change it introduces, such as <code>feat</code> for a new feature or <code>fix</code> for a bug fix. The <em class="italic">scope</em>, though optional, provides additional contextual information, often indicating the part of the code base affected by the change. The <em class="italic">description</em> offers a concise summary of the change, crafted in an imperative mood.</p>
<h2 id="_idParaDest-292"><a id="_idTextAnchor291"/>Options and usage</h2>
<p>Commit linting, particularly when adhering to the Conventional Commits specification, ensures that commits are structured in <a id="_idIndexMarker817"/>a clear, predictable, and useful manner. Here are some examples of commits that comply with commit linting rules, showcasing various types of changes that might occur in a software project:</p>
<ul>
<li>Adding a new feature:<pre class="source-code">
feat(authentication): add biometric authentication support</pre><p class="list-inset">This commit message indicates that a new feature (<code>feat</code>) has been added, (specifically, biometric authentication support) and the scope of this feature is within the authentication module of the application.</p></li>
<li>Fixing a bug:<pre class="source-code">
fix(database): resolve race condition in user data retrieval</pre><p class="list-inset">Here, a bug fix (<code>fix</code>) is being committed, addressing a race condition issue within the <code>database</code> module, particularly in the process of user data retrieval.</p></li>
<li>Improving documentation:<pre class="source-code">
docs(readme): update installation instructions</pre><p class="list-inset">This example shows a documentation update (<code>docs</code>), with the changes made to the project’s README file to update the installation instructions.</p></li>
<li>Code refactoring:<pre class="source-code">
refactor(ui): simplify button component logic</pre><p class="list-inset">In this commit, existing code has been refactored (<code>refactor</code>) without adding any new features or fixing any bugs. The scope of the refactoring is the UI, specifically simplifying the logic used in a <code>button</code> component.</p></li>
<li>Style adjustments:<pre class="source-code">
style(css): remove unused CSS classes</pre><p class="list-inset">This commit message signifies a styling change (<code>style</code>), where unused CSS classes are being removed. It’s worth noting that this type of commit does not affect the functionality of the code.</p></li>
<li>Adding tests:<pre class="source-code">
test(api): add tests for new user endpoint</pre><p class="list-inset">Here, new tests (<code>test</code>) have been <a id="_idIndexMarker818"/>added for a new user endpoint in the API, indicating an enhancement in the project’s test coverage.</p></li>
<li>Chore tasks:<pre class="source-code">
chore(build): update build script for deployment</pre><p class="list-inset">This commit represents a chore (<code>chore</code>), typically a maintenance or setup task that doesn’t directly modify the source code or add functionality, such as updating a build script for deployment.</p></li>
<li>Breaking change:<pre class="source-code">
feat(database): change database schema for users table</pre><pre class="source-code">
BREAKING CHANGE: The database schema modification requires resetting the database. This change will affect all services interacting with the users table.</pre><p class="list-inset">Another method to indicate a breaking change is by adding an exclamation mark (<code>!</code>) after the type and scope but before the colon in the commit message. This method is succinct and visually noticeable:</p><pre class="source-code">
feat!(api): overhaul authentication system</pre><p class="list-inset">This commit introduces a new feature (<code>feat</code>) related to the database schema of the user’s table but also includes a breaking change.</p></li>
</ul>
<p>These examples illustrate how commit linting, guided by the Conventional Commits specification, facilitates clear, structured, and informative commit messages that enhance project maintainability and collaboration.</p>
<h2 id="_idParaDest-293"><a id="_idTextAnchor292"/>Origins and adoption</h2>
<p>The Conventional Commits specification<a id="_idIndexMarker819"/> was inspired by the need to streamline the creation of readable and automated changelogs. It builds upon earlier practices from the AngularJS team and has since been adopted by various open source and enterprise projects seeking to standardize commit messaging for improved project maintainability and collaboration.</p>
<h2 id="_idParaDest-294"><a id="_idTextAnchor293"/>Advantages of Conventional Commits</h2>
<p>Adhering to the Conventional Commits specification offers <a id="_idIndexMarker820"/>numerous benefits:</p>
<ul>
<li><strong class="bold">Automated Semver handling</strong>: By categorizing commits, tools can automatically determine version bumps based on the semantic meaning <a id="_idIndexMarker821"/>of changes, adhering to <strong class="bold">Semantic Versioning</strong> (<strong class="bold">Semver</strong>) principles</li>
<li><strong class="bold">Streamlined release notes</strong>: Automated tools can generate comprehensive and clear release notes and changelogs by parsing structured commit messages, significantly reducing manual effort and enhancing release documentation</li>
<li><strong class="bold">Enhanced readability</strong>: The standardized format improves the readability of commit history, making it easier for developers to navigate and understand project evolution</li>
<li><strong class="bold">Facilitated code reviews</strong>: The clear categorization and description of changes aid in the code review process, enabling reviewers to quickly grasp the scope and intent of changes</li>
</ul>
<h1 id="_idParaDest-295"><a id="_idTextAnchor294"/>Commitlint – enforcing commit message standards</h1>
<p>Commitlint is a powerful, configurable tool designed to enforce commit message conventions, ensuring consistency and clarity across a<a id="_idIndexMarker822"/> project’s commit history. It plays a crucial role in maintaining a clean, readable, and meaningful commit log, particularly when used in conjunction with conventions such as the Conventional Commits specification. This section provides a comprehensive guide on how to install, configure, and use commitlint to check commit messages locally, fostering a disciplined approach to version control and collaboration.</p>
<h2 id="_idParaDest-296"><a id="_idTextAnchor295"/>Installation</h2>
<p>Commitlint is typically installed via npm, the package manager for Node.js. To get started, you’ll need to have Node.js and<a id="_idIndexMarker823"/> npm installed on your development machine. Once set up, you can install commitlint and its conventional <code>config</code> package by running the following commands in your project’s root directory:</p>
<pre class="source-code">
npm install --save-dev @commitlint/{cli,config-conventional,prompt-cli}</pre>
<p>This command installs commitlint and the conventional commits configuration as development dependencies in your project, making them available for use in the local development environment.</p>
<h2 id="_idParaDest-297"><a id="_idTextAnchor296"/>Configuration</h2>
<p>After installation, commitlint requires a <a id="_idIndexMarker824"/>configuration file to define the rules it will enforce. The most straightforward way to configure commitlint is by using the conventional commits configuration, which aligns with the Conventional Commits specification. Create a file named <code>commitlint.config.js</code> in your project’s root directory, and add the following content:</p>
<pre class="source-code">
module.exports = {extends: ['@commitlint/config-conventional']};</pre>
<p>This configuration instructs commitlint to use the standard rules provided by the Conventional Commits configuration, which include checks for the structure, types, and scopes of commit messages.</p>
<h2 id="_idParaDest-298"><a id="_idTextAnchor297"/>Local usage</h2>
<p>To check commit messages locally, you can use<a id="_idIndexMarker825"/> commitlint in conjunction with Husky, a tool for managing Git hooks. Husky can be configured to trigger commitlint to evaluate commit messages before they are committed, providing immediate feedback to the developer.</p>
<p>First, install Husky as a development dependency:</p>
<pre class="source-code">
npm install --save-dev husky</pre>
<p>Let us check local commits with commitlint:</p>
<pre class="source-code">
npx commitlint --from HEAD~1 --to HEAD --verbose
⧗   input: feat: add output
✔   found 0 problems, 0 warnings</pre>
<p>In this example, <code>--from HEAD~1</code> and <code>--to HEAD</code> specify the range of commits to check, and <code>--verbose</code> provides<a id="_idIndexMarker826"/> detailed output. If the commit message does not adhere to the specified conventions, commitlint will output an error message, indicating the violations that need to be addressed.</p>
<p>Let us add a bad commit message and check it with commitlint:</p>
<pre class="source-code">
git commit -m"Changed output type"
npx commitlint --from HEAD~1 --to HEAD --verbose
⧗   input: Changed output type
✖   subject may not be empty [subject-empty]
✖   type may not be empty [type-empty]
✖   found 2 problems, 0 warnings
ⓘ   Get help: https://github.com/conventional-changelog/commitlint/#what-is-commitlint</pre>
<p>Commitlint can be integrated as a Git hook by adding the following configuration to your <code>package.json</code> file or by creating a <code>.huskyrc</code> file with the same content:</p>
<pre class="source-code">
"husky": {
  "hooks": {
    "commit-msg": "commitlint -E HUSKY_GIT_PARAMS"
  }
}</pre>
<p>This configuration sets up a pre-commit hook that invokes commitlint with the commit message that is about to be committed. If the commit message does not meet the specified standards, commitlint will reject the commit, and the developer will need to revise the message accordingly.</p>
<h2 id="_idParaDest-299"><a id="_idTextAnchor298"/>Customizing rules</h2>
<p>Commitlint offers a wide array of configuration and customization options, allowing teams to tailor commit message validation rules to fit their<a id="_idIndexMarker827"/> specific project requirements and workflows. This flexibility ensures that commitlint can be adapted to support various commit conventions beyond the standard Conventional Commits format, providing a robust framework for enforcing consistent and meaningful commit messages across diverse development environments.</p>
<h2 id="_idParaDest-300"><a id="_idTextAnchor299"/>Basic configuration</h2>
<p>The basic configuration of commitlint involves <a id="_idIndexMarker828"/>setting up a <code>commitlint.config.js</code> file in your project’s root directory. This file serves as the central point for defining the rules and conventions that commitlint will enforce. At its simplest, the configuration might extend a predefined set of rules, such as those provided by <code>@commitlint/config-conventional</code>, as shown here:</p>
<pre class="source-code">
module.exports = {
  extends: ['@commitlint/config-conventional'],
};</pre>
<p>This configuration instructs commitlint to use the conventional commit message rules, enforcing a standard structure and set of types for commit messages.</p>
<h2 id="_idParaDest-301"><a id="_idTextAnchor300"/>Custom rule configuration</h2>
<p>Commitlint’s real power lies in its ability to <a id="_idIndexMarker829"/>customize rules to match specific project needs. Each rule in commitlint is identified by a string key and can be configured with an array specifying the rule’s level, applicability, and, in some cases, additional options or values. The rule configuration array generally follows the format <code>[level, </code><code>applicability, value]</code>:</p>
<ul>
<li><code>0</code> = disabled, <code>1</code> = warning, and <code>2</code> = error)</li>
<li><code>'always'</code> or <code>'never'</code>)</li>
<li><strong class="bold">Value</strong>: Additional parameters or options for the rule, varying by rule</li>
</ul>
<p>For example, to enforce that commit messages must start with a type followed by a colon and a space, you could configure the <code>type-enum</code> rule as follows:</p>
<pre class="source-code">
module.exports = {
  rules: {
    'type-enum': [2, 'always', ['feat', 'fix', 'docs', 'style', 'refactor', 'test', 'chore']],
  },
};</pre>
<p>This configuration sets the rule level to error (<code>2</code>), specifies that the rule should always be applied, and defines a list of acceptable types for commit messages.</p>
<h2 id="_idParaDest-302"><a id="_idTextAnchor301"/>Scope and subject configuration</h2>
<p>Commitlint also allows for detailed <a id="_idIndexMarker830"/>configuration of commit message scopes and subjects. For instance, you can enforce specific scopes or require that commit message subjects do not end with a period:</p>
<pre class="source-code">
module.exports = {
  rules: {
    'scope-enum': [2, 'always', ['ui', 'backend', 'api', 'docs']],
    'subject-full-stop': [2, 'never', '.'],
  },
};</pre>
<p>This setup mandates that commits must use one of the predefined scopes and that the subject line must not end with a period.</p>
<h2 id="_idParaDest-303"><a id="_idTextAnchor302"/>Customizing and sharing configurations</h2>
<p>For projects or organizations with unique<a id="_idIndexMarker831"/> commit message conventions, custom configurations can be defined and, if needed, shared across multiple projects. You can create a <a id="_idIndexMarker832"/>dedicated npm package for your commitlint configuration, allowing teams to easily extend this shared configuration:</p>
<pre class="source-code">
// commitlint-config-myorg.js
module.exports = {
  rules: {
    // Custom rules here
  },
};
// In a project's commitlint.config.js
module.exports = {
  extends: ['commitlint-config-myorg'],
};</pre>
<p>This approach promotes consistency across projects and simplifies the management of commit message rules within an organization.</p>
<h2 id="_idParaDest-304"><a id="_idTextAnchor303"/>Integration with CI</h2>
<p>Ensuring the enforcement of commitlint via CI is a crucial practice in maintaining high-quality commit messages across a project. While local Git hooks, such<a id="_idIndexMarker833"/> as those managed by Husky, offer a first line of defense by checking commit messages on the developer’s machine, they are not infallible. Developers might intentionally or accidentally disable Git hooks, and <strong class="bold">Integrated Development Environments</strong> (<strong class="bold">IDEs</strong>) or text editors <a id="_idIndexMarker834"/>might not be properly configured to enforce these hooks or might encounter issues that lead to their malfunction.</p>
<p>Given these potential gaps in local enforcement, CI serves as the authoritative source of truth, providing a centralized, consistent platform for verifying commit messages against the project’s standards. By integrating commitlint into the CI pipeline, projects ensure that every commit, regardless of its origin or the method used to submit it, adheres to the defined commit message conventions before it is merged into the main code base. This CI-based enforcement fosters a culture of discipline and accountability, ensuring that all contributions, regardless of their source, meet the project’s quality standards.</p>
<h3>Integrating commitlint into CI with GitHub Actions</h3>
<p>GitHub Actions offers a straightforward and powerful platform for integrating commitlint into your CI workflow. The following example <a id="_idIndexMarker835"/>demonstrates how to set up a<a id="_idIndexMarker836"/> GitHub action to enforce commit message standards using commitlint on every push or pull request targeting the <code>main</code> branch.</p>
<p>First, create a new file in your repository under <code>.github/workflows/commitlint.yml</code> with the following content:</p>
<pre class="source-code">
name: Commitlint
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
jobs:
  commitlint:
    runs-on: ubuntu-latest
    steps:
    - name: Check out code
      uses: actions/checkout@v3
      with:
        # Fetch at least the immediate parents so that if this is
        # a pull request then we can checkout the head.
        fetch-depth: 0
    - name: Check Commit Message
      uses: wagoid/commitlint-github-action@v5
      with:
        failOnWarnings: true</pre>
<p>This workflow defines a job named <code>commitlint</code> that triggers on pushes and pull requests to the <code>main</code> branch. The only<a id="_idIndexMarker837"/> configuration that I would like to highlight is <code>failOnWarnings: true</code>, which configures the action to fail the job if any <a id="_idIndexMarker838"/>commitlint warnings are encountered. This ensures strict adherence to the commit message standards by treating warnings with the same severity as errors.</p>
<p>Let us create a bad commit message and open a PR to see how the action works:</p>
<pre class="source-code">
git commit -m"Changed output type"
git checkout -b exit_message
git push origin exit_message</pre>
<p>After we open a PR, we will see that the action has failed:</p>
<div><div><img alt="Figure 14.2 – Commitlint action failed" src="img/B19606_13_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.2 – Commitlint action failed</p>
<p>The logs will show the reason for the failure in the same format as the local check:</p>
<div><div><img alt="Figure 14.3 – Commitlint action log failed" src="img/B19606_13_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.3 – Commitlint action log failed</p>
<p>By incorporating this workflow into your project, you ensure that every commit is scrutinized for adherence to your commit <a id="_idIndexMarker839"/>message standards before it becomes part of the <code>main</code> branch. This CI-based check acts as a final gatekeeper, reinforcing the importance of well-structured commit messages and <a id="_idIndexMarker840"/>maintaining the integrity of the project’s commit history.</p>
<p>Commitlint’s configurability and customization options provide a powerful platform for enforcing commit message standards tailored to a project’s or organization’s specific needs. By leveraging these capabilities, teams can ensure that their commit logs remain clear, consistent, and meaningful, thereby enhancing project maintainability and collaboration. Whether adhering to widely accepted conventions such as the Conventional Commits specification or defining a set of custom rules, commitlint offers the flexibility and control needed to maintain a high-quality commit history.</p>
<h1 id="_idParaDest-305"><a id="_idTextAnchor304"/>Generating changelogs</h1>
<p>Automatic changelog generation is a<a id="_idIndexMarker841"/> method where software tools automatically create a log of changes made to a project, categorizing and listing updates, fixes, and features. This process is favored for its efficiency and consistency, ensuring that all significant modifications are documented systematically. We’ll explore this concept through GitCliff, a tool that parses structured commit messages to generate detailed changelogs, aiding in transparent project management and communication. GitCliff’s utility in this process exemplifies its role in automating and streamlining project documentation tasks.</p>
<h2 id="_idParaDest-306"><a id="_idTextAnchor305"/>Installation</h2>
<p>GitCliff is written in Rust and <a id="_idIndexMarker842"/>can be installed using Cargo, the Rust package manager. To install GitCliff, ensure that you have Rust and Cargo installed on your system, and then run the following command:</p>
<pre class="source-code">
curl https://sh.rustup.rs -sSf | sh</pre>
<p>After installing Rust, you can install GitCliff using Cargo:</p>
<pre class="source-code">
cargo install git-cliff</pre>
<p>The last configuration step is to initialize GitCliff in your project:</p>
<pre class="source-code">
git cliff --init</pre>
<p>This generates a default <a id="_idIndexMarker843"/>configuration file, <code>.cliff.toml</code>, in the root of your project.</p>
<h2 id="_idParaDest-307"><a id="_idTextAnchor306"/>GitCliff usage</h2>
<p>After installing and initializing GitCliff, you can <a id="_idIndexMarker844"/>generate a changelog by running the following command in your project’s root directory:</p>
<pre class="source-code">
git cliff -o CHANGELOG.md</pre>
<p>The tool generates a Markdown file with the changelog, as follows:</p>
<div><div><img alt="Figure 14.4 – Generated changelog" src="img/B19606_13_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.4 – Generated changelog</p>
<p>The log contains a list of changes, categorized by type, and it highlights breaking changes.</p>
<p>Let us add a release tag and generate a changelog for the release:</p>
<pre class="source-code">
git tag v1.0.0 HEAD
git cliff</pre>
<p>The changelog will now<a id="_idIndexMarker845"/> contain the release tag and the changes since the last release:</p>
<div><div><img alt="Figure 14.5 – Generated changelog with release tag" src="img/B19606_13_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.5 – Generated changelog with release tag</p>
<p>We can introduce a <a id="_idIndexMarker846"/>breaking change and bump the version:</p>
<pre class="source-code">
git commit -m"feat!: make breaking change"
git cliff --bump</pre>
<p>As you can see, GitCliff has detected the breaking change and bumped the version to 2.0.0:</p>
<div><div><img alt="Figure 14.6 – Generated changelog with breaking change" src="img/B19606_13_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.6 – Generated changelog with breaking change</p>
<p>In the preceding sections, we have comprehensively explored the significant functionalities of <code>git-cliff</code>, revealing its substantial utility in automating change log generation. This tool distinguishes itself not only through<a id="_idIndexMarker847"/> its capacity to streamline the documentation process but also through its seamless integration with CI platforms, including but not limited to GitHub. Such integration ensures that changelogs are consistently synchronized with the latest project developments, thereby maintaining the accuracy and relevance of project documentation.</p>
<p>An equally noteworthy feature of git-cliff is the extensive customization it offers for changelog generation. Users are afforded the flexibility to tailor the format, content, and presentation of changelogs to meet specific project requirements or personal preferences. This high degree of customizability ensures that the output not only aligns with but also enhances the project’s documentation standards.</p>
<p>Given the depth of functionality and the potential benefits that git-cliff offers, those interested in leveraging this tool to its fullest are encouraged to consult the official documentation. This resource is a treasure trove of detailed information, covering the breadth of features, configurations, and best practices associated with git-cliff. Engaging with the official documentation will not only solidify your understanding of the tool but also equip you with the knowledge to implement it effectively in your projects.</p>
<p>To summarize, having <a id="_idIndexMarker848"/>delved into the major capabilities and advantages of git-cliff, the path forward for those looking to integrate this tool into their development workflow is through a thorough exploration of the official documentation. This exploration promises to extend your proficiency in utilizing git-cliff, ensuring that you can fully harness its capabilities to enhance your project’s change log generation and documentation processes.</p>
<h1 id="_idParaDest-308"><a id="_idTextAnchor307"/>Utilizing git-bisect in bug hunting</h1>
<p>During the process of software development, the task of identifying <a id="_idIndexMarker849"/>and rectifying bugs is<a id="_idIndexMarker850"/> paramount to ensure the stability and reliability of the application. Among the arsenal available to developers for this purpose, <code>git-bisect</code> stands out as a powerful tool, specifically designed for the task of isolating the commit that introduced a bug into the code base.</p>
<p>Embedded within the Git version control system, <code>git-bisect</code> is a utility based on the binary search algorithm. It aids developers in sifting through a potentially vast commit history to pinpoint the exact change that caused a regression or introduced an error. By adopting a divide-and-conquer strategy, <code>git-bisect</code> significantly streamlines the debugging process, making it an efficient approach to troubleshooting.</p>
<p>The journey with <code>git-bisect</code> begins by establishing two critical points in the project’s timeline: a commit where the bug is known to be absent (referred to as <code>good</code>) and a commit where the bug is confirmed to be present (<code>bad</code>). With these markers set, <code>git-bisect</code> proceeds to check out a commit that lies midway between the <code>good</code> and <code>bad</code> commits. This step requires the developer to test the current state of the application to determine whether the bug is present or not.</p>
<p>The iterative process involves <code>git-bisect</code> selecting a new commit based on the developer’s feedback, and continually narrowing down the search area by halving it with each step. The cycle of testing and feedback continues until <code>git-bisect</code> successfully isolates the commit that introduced the bug, effectively zeroing in on the root cause with minimal manual review.</p>
<p>The efficiency of <code>git-bisect</code> lies in its ability to reduce the number of commits that need to be scrutinized manually, thus conserving valuable development time. Its methodical approach ensures precision in identifying the problematic <a id="_idIndexMarker851"/>commit, which is crucial for understanding the context of the bug and<a id="_idIndexMarker852"/> formulating an effective fix. Being an integral part of the Git ecosystem, <code>git-bisect</code> seamlessly fits into the developer’s existing workflow, offering a familiar and straightforward interface for debugging.</p>
<p>To optimize the effectiveness of <code>git-bisect</code>, it is imperative to use a reliable and accurate test case for evaluating each commit. This ensures that the feedback provided to <code>git-bisect</code> correctly reflects the presence or absence of the bug, thereby preventing misidentification. Maintaining a clean and logical commit history, where each commit encapsulates a single change, enhances the tool’s efficiency. Furthermore, automating the testing process within the <code>git-bisect</code> session, when feasible, can expedite the bug-hunting endeavor.</p>
<p>Consider a scenario where a regression is detected in a feature that was previously functioning correctly. It happens often when certain tests are running only at night. The task is to identify the commit responsible for this regression using <code>git-bisect</code>:</p>
<ol>
<li>Start the <code>bisect</code> session with <code>git </code><code>bisect start</code>.</li>
<li>Mark the commit in which the bug is present as <code>git bisect bad &lt;commit hash&gt;</code> (usually, it is <code>HEAD</code>).</li>
<li>Identify a commit in the past where the feature worked correctly and mark it as <code>good</code> using <code>git bisect </code><code>good &lt;commit-hash&gt;</code>.</li>
<li><code>git-bisect</code> will then check out a commit halfway between the <code>good</code> and <code>bad</code> commits. Test this commit to see whether the bug exists.</li>
<li>Based on the test outcome, mark the commit as <code>good</code> or <code>bad</code>. <code>git-bisect</code> uses this feedback to narrow down the search space and selects a new commit for testing.</li>
<li>Repeat the testing and marking process until <code>git-bisect</code> identifies the commit that introduced the bug.</li>
</ol>
<p>Once the problematic commit is identified, developers can examine the changes introduced in that commit to understand the cause of the bug and proceed with developing a fix.</p>
<p>To demonstrate how it works, I cloned the master branch of the <code>rapidjson</code> library a bug and put it in the middle of the local repo. The Git log looks as follows, where <code>Bad commit (6 hours ago) &lt;f-squirrel&gt;</code> is the <code>bad</code> one:</p>
<pre class="source-code">
a85e2979 - (HEAD -&gt; master) Add RAPIDJSON_BUILD_CXX20 option (6 hours ago) &lt;Brian Rogers&gt;
2cd6149d - fix Visual Studio 2022 (using /std:c++20) warning warning C5232: in C++20 this comparison ...
478cd636 - Bad commit (6 hours ago) &lt;f-squirrel&gt;
25edb27a - tests: Only run valgrind tests if valgrind was found (23 hours ago) &lt;Richard W.M. Jones&gt;
606791f6 - Fix static_cast in regex.h (23 hours ago) &lt;Dylan Burr&gt;
5f071d72 - Fix comparision of two doubles (23 hours ago) &lt;Esther Wang&gt;
060a09a1 - Fix schema regex preprocessor include logic (6 weeks ago) &lt;Bryant Ferguson&gt;
6089180e - Use correct format for printf (4 months ago) &lt;Esther Wang&gt;
...</pre>
<p>Let us start bisecting by <a id="_idIndexMarker853"/>marking <code>good</code> and <code>bad</code> commits:</p>
<pre class="source-code">
$ git bisect start
$ git bisect bad HEAD
$ git bisect good 6089180e
Bisecting: 3 revisions left to test after this (roughly 2 steps)
[606791f6662c136ba34f842313b807114580852d] Fix static_cast in regex.h</pre>
<p>I have prepared a script that <a id="_idIndexMarker854"/>checks whether the bug is present in the current commit. The script is called <code>test.sh</code> and looks as follows:</p>
<pre class="source-code">
cmake --build ./build -j $(nproc) || exit 1
./build/bin/unittest || exit 1</pre>
<p>Every time I run the script, I mark the commit as <code>good</code> or <code>bad</code>. After a few iterations, I have found the commit that introduced the bug:</p>
<pre class="source-code">
[  PASSED  ] 468 tests.
$ git bisect good
Bisecting: 1 revision left to test after this (roughly 1 step)
[478cd636a813abe76e32154544b0ec793fdc5566] Bad commit</pre>
<p>If we run the test script again, we will see that the bug is present in the commit:</p>
<pre class="source-code">
[  FAILED  ] 2 tests, listed below:
[  FAILED  ] BigInteger.Constructor
[  FAILED  ] BigInteger.LeftShift
 2 FAILED TESTS</pre>
<p>Once we finish our bug hunt, we can<a id="_idIndexMarker855"/> reset the <code>bisect</code> session with <code>git </code><code>bisect reset</code>.</p>
<p>Jumping between commits for a user is a <a id="_idIndexMarker856"/>useful functionality but not the only one. <code>git-bisect</code> can be automated with a script that will run the tests and mark the commits<a id="_idIndexMarker857"/> as good or bad based on the test results. Note that the script should return <code>0</code> if the commit is good and <code>1</code> if the commit is bad. The script will run until the bug is found and the <code>bisect</code> session will be reset. For our repository, it will look as follows:</p>
<pre class="source-code">
$ git bisect start
$ git bisect bad HEAD
$ git bisect good 6089180e
Bisecting: 3 revisions left to test after this (roughly 2 steps)
[606791f6662c136ba34f842313b807114580852d] Fix static_cast in regex.h
$ git bisect run ./test.sh
running  './test.sh'
... build and test output ...
[==========] 468 tests from 34 test suites ran. (321 ms total)
[  PASSED  ] 468 tests.
478cd636a813abe76e32154544b0ec793fdc5566 is the first bad commit
commit 478cd636a813abe76e32154544b0ec793fdc5566
Author: f-squirrel &lt;dmitry.b.danilov@gmail.com&gt;
Date:   Mon Mar 25 15:18:18 2024 +0200
    Bad commit
 include/rapidjson/internal/biginteger.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
bisect found first bad commit</pre>
<p><code>git-bisect</code> is an indispensable<a id="_idIndexMarker858"/> debugging tool within the Git suite, offering a systematic and efficient <a id="_idIndexMarker859"/>approach to identifying bug-inducing commits. Its integration into the development workflow, combined with the practice of maintaining a clear commit history and employing automated tests, makes it a highly effective solution for maintaining code quality and stability.</p>
<h1 id="_idParaDest-309"><a id="_idTextAnchor308"/>Summary</h1>
<p>In this chapter dedicated to version control, we embarked on an insightful journey through the core principles and practices that underpin effective software version management. Central to our exploration was the adoption of conventional commits, a structured approach to commit messaging that enhances readability and facilitates automated processing of commit logs. This practice, grounded in a standardized format for commit messages, enables teams to convey the nature and intent of changes with clarity and precision.</p>
<p>We also delved into SemVer, a methodology designed to manage version numbers in a meaningful way. SemVer’s systematic approach to versioning, based on the significance of changes in the code base, provides clear guidelines on when and how version numbers should be incremented. This method offers a transparent framework for version control, ensuring compatibility and facilitating effective dependency management within and across projects.</p>
<p>The chapter further introduced change log creation tools, with a particular focus on git-cliff, a versatile tool that automates the generation of detailed and customizable change logs from Git history. These tools streamline the documentation process, ensuring that project stakeholders are well informed about the changes, features, and fixes introduced with each new version.</p>
<p>A significant portion of the chapter was dedicated to debugging techniques, highlighting the utility of <code>git-bisect</code> in the process of isolating bugs. <code>git-bisect</code>, through its binary search algorithm, enables developers to efficiently pinpoint the commit that introduced a bug, thereby significantly reducing the time and effort required for troubleshooting.</p>
<p>In summary, this chapter provided a comprehensive overview of version control practices, emphasizing the importance of structured commit messages, strategic versioning, automated changelog generation, and efficient debugging techniques. By adopting these practices, development teams can enhance collaboration, maintain code base integrity, and ensure the delivery of high-quality software.</p>
<p>In the next chapter, we will turn our attention to a critical aspect of the development process: code reviews. We will examine the importance of code reviews in ensuring code quality, fostering team collaboration, and enhancing overall productivity. By understanding best practices and effective strategies for conducting thorough and constructive code reviews, you will be well equipped to elevate the standards of your code base and contribute more effectively to your team’s success. Stay tuned as we embark on this insightful journey into the art and science of code reviews.</p>
</div>
</body></html>