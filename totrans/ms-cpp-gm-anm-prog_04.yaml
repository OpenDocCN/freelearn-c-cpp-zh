- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding a Visual Selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to *Chapter 3*! In the previous chapter, we offloaded the majority of
    matrix and vector calculations to the GPU. A modern graphics card has more (and
    also more specialized) computing cores than a desktop CPU, so, moving the compute
    load to the GPU will free the main CPU from most of the animation work.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will add a couple of simplifications when working with a
    lot of model instances. After the changes in the previous chapter, we are able
    to display thousands of model instances on the screen, but selecting a specific
    instance is still hard. We will start by adding coordinate arrows to identify
    the currently selected instance. Next, we will add a function that allows us to
    center the specified instance in the middle of the screen. Then, a graphical highlight
    will be created, further helping us to find the selected instance among all instances.
    As the last step, we will add a model without triangles, and an instance from
    this empty model, allowing us to deselect the visible instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a “move to instance” function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a highlight to the selected instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting a model instance with point and click
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a null object to allow deselection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At first glance, these topics may look unrelated to animation programming. But
    proper tooling is an essential part of creating a user-friendly application. Good
    tools will help the user to simplify application handling.
  prefs: []
  type: TYPE_NORMAL
- en: Later in the book, when you have created dozens or even hundreds of instances
    that are happily jumping and running around randomly on the screen, selecting
    one instance by simply clicking on it with the mouse, using a UI button to center
    the instance on the screen, or moving and rotating the instance by using the mouse
    will make your life a lot easier. And you might even forget how cumbersome the
    first two chapters were when it came to selecting an instance or changing instance
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will need the application code from [*Chapter 2*](Chapter_2.xhtml): [https://github.com/PacktPublishing/Mastering-Cpp-Game-Animation-Programming](https://github.com/PacktPublishing/Mastering-Cpp-Game-Animation-Programming).'
  prefs: []
  type: TYPE_NORMAL
- en: The example source code for this chapter can be found in the folder `chapter03`,
    subfolder `01_opengl_selection` for OpenGL, and `02_vulkan_selection` for Vulkan.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a “move to instance” function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the first change for the “move to instance” functionality, we will add a
    small set of coordinate arrows appearing at the origin of the drawn model to identify
    the currently selected instance. We will also add a button to center the currently
    selected instance. Let’s start with the implementation of the coordinate arrows.
  prefs: []
  type: TYPE_NORMAL
- en: Adding coordinate arrows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since we will use lines instead of triangles to draw coordinate arrows at the
    center of the selected instance, we need some extra data structures, objects and
    shaders. To store the vertex and color data, we add two new structs to the declarations
    in the file `OGLRenderData.h` in the `opengl` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: For Vulkan, the new structs are named `VkLineVertex` and `VkLineMesh`, residing
    in the file `VkRenderData.h` in the `vulkan` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Uploading the coordinate arrow data to the GPU, a new class, `LineVertexBuffer`,
    in the `opengl` folder, will be added. A simple way to get the new class files
    is to copy the two source files for the `VertexIndexBuffer` class (`VertexIndexBuffer.h`
    and `VertexIndexBuffer.cpp`) in the `opengl` folder, and then adjust the `init()`
    method to send `position` and `color` data to the graphics card:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We must also enable both the `position` and the `color` attributes by using
    `glEnableVertexAttribArray()` with the corresponding index values (the first parameter
    of `glVertexAttribPointer`) to send the vertex data for both attributes to the
    vertex shader.
  prefs: []
  type: TYPE_NORMAL
- en: On the GPU side, two simple pass-through shaders are needed – the vertex and
    fragment shader will only pass the data through without additional transformations,
    except the required view and projection matrix transformations. The vertex shader
    named `line.vert`, located in the `shader` folder, uses the `view` and `projection`
    matrices of the camera position to calculate the final vertex positions. Then,
    the position and the color of the line endpoints are handed over to the fragment
    shader named `line.frag`, also located in the `shader` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The vertices for our coordinate arrows are taken from a static model file named
    `CoordArrowsModel` in the `model` folder. We can hard-code the vertex positions
    and colors to keep the initialization simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The final positions for the vertices of the coordinate arrows are set in the
    `draw()` call of the render. As the first step, the line counter will be zeroed,
    and the `mLineMesh` vector for the vertices of the coordinate arrows is cleared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we retrieve the settings of the currently selected instance, containing
    the position and rotation of the instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we add the number of vertices to the line counter variable `mCoordArrowsLineIndexCount`
    and iterate over each vertex in a `std::for_each`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: By using a lambda function, the position data of the vertices is altered to
    match the position and rotation of the instance. In addition, we dim the color
    of the coordinate arrows by dividing the color vector by a value of two.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting per-vertex data is collected in the `mLineMesh` vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will upload the vertex data to the GPU, and draw the coordinate lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `mCoordArrowsLineIndexCount` is used to check if coordinate lines
    exist at all, and as a parameter to draw the correct number of points for the
    lines. Using the line count as a check value and a counter helps us if we don’t
    want to draw any coordinate lines at all: We can simply skip filling `mLineMesh`
    and counting coordinate lines, skipping the line drawing automatically. Or, we
    could draw multiple coordinate arrows in a multi-selection scenario.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Uploading vertex data in Vulkan is much more complex compared to OpenGL due
    to the explicit nature of the Vulkan API. The full process for creating a different
    shader and uploading vertex data requires the following steps in Vulkan:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a pair of passthrough shaders in GLSL or HLSL (High-Level Shader Language
    for DirectX). For GLSL shaders, the syntax has only small differences – mostly
    it’s about being more explicit when using the `layout` statement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new pipeline with the new shaders and a corresponding attribute definition.
    Vulkan needs a new pipeline since the pipeline itself will become *immutable*
    after creation (except for a few explicit dynamically configurable sub-objects,
    like the viewport). Vulkan shaders *cannot* be swapped at runtime like in OpenGL;
    we need to bind another pipeline to draw vertices with a different shader.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upload the vertex data to the GPU by using a staging buffer. To achieve the
    best performance in Vulkan, the vertex data should be stored in an optimized format
    in a memory area where only the GPU has access. Using a buffer shared between
    the CPU and GPU requires additional synchronization by the driver and the data
    may not be in the optimal format for the GPU to draw, resulting in performance
    losses.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While recording the render pass commands to send to the GPU, we must bind both
    the new pipeline by using the `vkCmdBindPipeline()` method and the vertex buffer
    by using `vkCmdBindVertexBuffers()`. After submitting the command buffer to the
    driver, the vertices are drawn with the new shader.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can check out the classes `Shader`, `Pipeline`, and `VertexBuffer` in the
    `vulkan` folder of the example code for implementation details. Also, a link in
    the section *Additional resources* to a Vulkan tutorial is available. The tutorial
    has a separate section about vertex buffer creation and data uploading.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, three small arrows are added to the selected instance, as shown in *Figure
    3.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_3.1_B22428.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: New coordinate arrows to identify the selected instance'
  prefs: []
  type: TYPE_NORMAL
- en: The red arrow points to the direction of the positive `x` axis, the blue arrow
    points to the positive `z` axis, and the green arrow towards the positive `y`
    axis.
  prefs: []
  type: TYPE_NORMAL
- en: As the second step towards the “move to instance” function, the new UI button
    will be added.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a button to center the selected instance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the new button in the user interface, we will follow the previous implementations
    and add a callback for the `UserInterface` class. The callback calls a method
    in the renderer class, moving the camera calculations related from the user interface
    to the renderer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `UserInterface` class, we add a new ImGui button, plus the new callback,
    using the current instance as parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'When the renderer is initialized, the callback `miInstanceCenterCallbackFunction`
    will be bound via a lambda function to the new `centerInstance()` method of the
    renderer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `centerInstance()` method extracts the position of the instance, adds a
    static offset of 5 units on all axes, and calls `moveCameraTo()` of the camera
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, `moveCameraTo()` moves the camera to the instance position plus offset
    given in the renderer, and uses fixed values for azimuth and elevation to center
    the selected instance in the middle of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Using hard-coded values for azimuth and elevation makes the process a bit easier,
    since the extraction of both values from a matrix generated by a method like `glm::lookAt()`
    is a bit more complex. You might try to set the camera angles from a transformation
    matrix by yourself – see the *Practical sessions* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add the new ImGui centering button anywhere in the collapsed header
    for the instances. In the example code, the button has been placed right below
    the arrows to select the current instance, as shown in *Figure 3.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_3.2_B22428.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.2: The currently selected instance has been centered'
  prefs: []
  type: TYPE_NORMAL
- en: Centering the currently selected instance is a huge step towards a better *look
    & feel* for the application. We don’t need to search for the blinking instance
    or the coordinate arrows to find the selected instance; now, we are literally
    only a mouse click away from reaching the instance.
  prefs: []
  type: TYPE_NORMAL
- en: Still, this solution has some drawbacks. What if we don’t want to center the
    selected instance, maybe because we would like to keep the camera position fixed.
    So, let’s add another function to the code that makes the currently selected instance
    even easier to find among all instances shown on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a highlight to the selected instance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At first sight, adding some sort of highlight seems to be easy by adding some
    more fields to the vertices and the vertex buffer. Sadly, we are using instanced
    rendering for performance reasons. This means that all instances share the same
    vertex data. So, this approach does not work.
  prefs: []
  type: TYPE_NORMAL
- en: The next idea may be the instance placement and animations data. These matrices
    are calculated entirely by our compute shaders from [*Chapter 2*](Chapter_2.xhtml),
    fed by the node transform data of the nodes. Adding model related data to every
    node seems to be a bit overkill, since the highlighted data is needed only once
    per instance, not once per node.
  prefs: []
  type: TYPE_NORMAL
- en: A better idea would be another SSBO, filled with the correct data in the `draw()`
    call of the renderer, right after the node transform data has been retrieved from
    the instance. In the instance loop, we have direct access to all instances of
    a model and can simply push a value to a `std::vector`, stating if this is the
    selected instance or not. After uploading the data of the vector to the SSBO,
    the shader instance can check the buffer data to see if the highlight should be
    added to the instance it is working on, or not.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the renderer to support highlights
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As the first step for adding the highlight to the selected instance, we add
    a vector containing a `float`, and, for the OpenGL renderer, an SSBO to the renderer
    header file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Due to the different data logic, for Vulkan, a `VkShaderStorageBufferData` object
    in the `VkRenderData` struct in the file `VkRenderData.h` will be used instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `draw()` call of the renderer, we save the smart pointer of the currently
    selected instance, right before we start the loop across the models and instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to storing the instance, we alter a float value inside the `OGLRenderData`
    respective `VkRenderData` struct by adding a scaled `deltaTime`, and resetting
    the value once it reaches `2.0f`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The value of the variable `rdSelectedInstanceHighlightValue` will be used in
    the shader to scale up or down the color of the selected instance. By adding the
    value of `deltaTime` in every `draw()` call and resetting the highlight variable
    to `0.1f` when we reach `2.0f`, the selected install will blink from very dark
    to very bright. The blinking instance will be easier to spot on the screen, compared
    to just the coordinate arrows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the instance loop, we compare the smart pointer of the instance we are
    working on and the saved smart pointer of the selected instance. If they are identical,
    the alternating value of the variable `rdSelectedInstanceHighlightValue` will
    be set at the index of the current instance in the `mSelectedInstance` vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If we are working on any other instance in the loop, we simply set the `x` value
    to `1.0f`, resulting in an unchanged color of the instance in the shader.
  prefs: []
  type: TYPE_NORMAL
- en: 'The collected data of the `mSelectedInstance` vector is then uploaded to the
    SSBO. For example, the OpenGL renderer uses the `uploadSsboData()` method of the
    `ShaderStorageBuffer` class to upload the vector data to the GPU:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Adjusting logic to shaders and the UI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As the next step for adding the highlight to the selected instance, the shaders
    have to be adjusted. In the `assimp_skinning.vert` vertex shader in the `shader`
    folder, the new SSBO must be added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The same addition is needed in the `assimp.vert` shader in the `shader` folder,
    used for non-animated model instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please check the binding number – due to the missing animation data, the number
    of SSBOs differs between the shaders for animated and non-animated instances:
    The shader for animated models binds the instance selection data on binding point
    `3` since binding point `2` is already used by the world position matrices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In contrast, the shader for non-animated models binds only two buffers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To adjust the color of the selected instance, we can now use the internal variable
    `gl_InstanceID` of the shader, retrieving the value of the data at the location
    of the instance in the `selected` buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As an optional change, we could also decrement the depth value of the selected
    instance by `1.0f`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Lowering the `z` element of the internal variable `gl_Position` will adjust
    the depth value of the triangle to the lowest possible value. This depth adjustment
    makes the highlighted instance visible even if other instances are closer to the
    camera position.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we add a `Boolean` variable named `rdHighlightSelectedInstance` in
    the `OGLRenderData` respective `VkRenderData` struct, allowing us to switch the
    highlight on and off. This new variable will be attached to an ImGui checkbox
    in the `UserInterface` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In *Figure 3.3*, the effect of combining highlighting and `z` position adjustment
    in the vertex shader is shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_3.3_B22428.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.3: Highlighted instance drawn on top of instances closer to the camera'
  prefs: []
  type: TYPE_NORMAL
- en: According to the relative size of the brighter instance, this instance would
    be at least partially hidden behind other instances closer to the camera. Yet,
    the adjustment of the `z` position draws the selected instance on top of all instances
    on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: What cannot be shown in the picture is the alternating brightness of the selected
    instance. As set in the `draw()` call of the renderer, the colors of the selected
    instance go up from only 10% of the original color (start value of `0.1f`) to
    200% of the original colors (clamping at `2.0f`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The flashing colors of the instance will make it fairly easy to find the currently
    selected instance on the screen. But there is still a piece missing in the application:
    Being able to select the instance of choice by clicking into the window, instead
    of searching through all instances by using the instance number arrows. Let’s
    tackle the visual selection now.'
  prefs: []
  type: TYPE_NORMAL
- en: Selecting a model instance with point and click
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start with the implementation, we will look at the two different
    approaches to add visual selection to an application: by “shooting” a ray into
    the virtual scene, and by using a texture holding an index of the instances.'
  prefs: []
  type: TYPE_NORMAL
- en: Pros and cons of shooting virtual rays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may find the following idea of shooting a virtual ray into your scene appealing:'
  prefs: []
  type: TYPE_NORMAL
- en: We already have the position of the camera in the virtual world as the first
    endpoint, and by mapping the mouse pointer positions back from screen positions
    to scene coordinates, you will get the second endpoint. Mapping coordinates back
    to the scene is only a couple of matrix inversions and multiplications away.
  prefs: []
  type: TYPE_NORMAL
- en: Sounds promising and easy, doesn’t it?
  prefs: []
  type: TYPE_NORMAL
- en: Sadly, it is common to underestimate the final complexity at this point. As
    long as you only have a single model in the world, or two, everything is fine.
    You shoot the virtual ray into the scene, and loop over the triangles of each
    instance to find the closest intersection between the ray and the instance triangles.
  prefs: []
  type: TYPE_NORMAL
- en: But what happens when you have, say, 1,000 instances?
  prefs: []
  type: TYPE_NORMAL
- en: Every time you click the selection button on your mouse, you would have to iterate
    over all triangles of all instances, hoping to find at least one match. The test
    model of the book has roughly 2,000 triangles, so you will have to check for 2,000,000
    possible intersections in a virtual world with 1,000 instances. Even with massive
    parallel computer shaders, this amount of calculation is a lot of wood to chuck
    for modern graphics cards.
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways to exclude large areas of the virtual world from the
    hit tests. In combination with other hierarchical approaches on the node level,
    the number of intersection checks can be lowered by several orders of magnitude.
    We will cover optimizations of the process to find intersections when we handle
    instance collisions in [*Chapter 8*](Chapter_8.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: What about the alternative idea – using a texture?
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of drawing the instance index into a texture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The basic idea of an extra texture for the instance selection comes from **Deferred
    Rendering**. In deferred rendering, computations like lighting are not done in
    the fragment shader, but “deferred” after storing the required information in
    textures. The set of textures containing all information about the pixels on the
    screen is called the **G-Buffer**, short for **geometry buffer**.
  prefs: []
  type: TYPE_NORMAL
- en: By using the data of the textures in the G-Buffer, the complexity to apply lighting
    to a scene is lowered from `Number of triangles * Number of lights in the entire
    scene` to `Number of pixels of the G-Buffer * Number of nearby lights`.
  prefs: []
  type: TYPE_NORMAL
- en: Even for 4K or 8K graphic resolutions, the number of operations to create the
    lighting information is lowered drastically. And, by using other information from
    the rendering process, other effects are easily possible with deferred rendering,
    like shadow mapping, or indirect lighting.
  prefs: []
  type: TYPE_NORMAL
- en: For naive ray-shooting, the selection complexity grows with the number of instances
    in the virtual world, even if these instances are not visible on the screen. When
    we apply the deferred rendering approach to visual selection, we have a constant
    overhead of drawing some pixels into a separate texture. Our selection process
    no longer depends on a variable number of instances in the world. Also, the resolution
    of the buffers may affect the performance of the instance selection only marginally.
  prefs: []
  type: TYPE_NORMAL
- en: The amount of changes required to add visual selection with a separate texture
    is surprisingly low. Let’s look at the steps we have to take.
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting the framebuffer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We start with the `FrameBuffer` class and add a new color attachment. For the
    OpenGL version, the new color attachment is created as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: For the selection texture, we add a texture containing only a single element,
    the red color. But we use a 32-bit wide red color, not only 8 bits, allowing us
    to store much more instance indices. The new texture is then added as a color
    attachment with the index 1 to the framebuffer.
  prefs: []
  type: TYPE_NORMAL
- en: A note on the texture data type (float)
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to create a texture with the type of `GL_R32UI`, containing a
    32-bit wide unsigned integer for every pixel. But all integer versions of the
    texture use a conversion factor for the components, raising the complexity of
    the selection process due to extra computations on reads and writes. In contrast,
    a `GL_R32F` buffer stores and retrieves an unaltered float value. By using a float
    on the GPU side, we are still able to store ~16.7 million instance indices (2^(24)),
    before the precision of a 32-bit float may lead to rounding errors during the
    conversion between integer and float values. See the section *Additional resources*
    for a link to a blog entry with more details of float precision.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, during framebuffer creation, we have to make sure our shader writes to
    both color attachments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If we don’t change the buffers to draw to, only the models will be drawn on
    the screen, and the selection texture will never be filled.
  prefs: []
  type: TYPE_NORMAL
- en: 'To clear the color buffer and the selection buffer with different values, a
    new method called `clearTextures()` has been added to the `FrameBuffer` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The selection texture can store arbitrary float values, using a `-1.0f` to clear
    the selection texture, which is a nice method to have a unique value for the empty
    background.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also avoid creating yet another SSBO to store the instance index, and extend
    the `mSelectedInstance` vector from `float` to `glm::vec2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: By moving the existing highlight color to the `x` element of the `glm::vec2`
    vector, we have a free `float` type spot, and we can store the instance index
    in the `y` element.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a selection shader
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Adding a new color buffer to the framebuffer also requires two new pairs of
    vertex/fragment shaders: One pair for animated models, another pair for non-animated
    models. But since we already send the selection information for instance highlighting
    to the shader, only small additions to the existing shader code are needed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we can reuse the shaders, the first step is to copy the existing files.
    For the non-animated models, copy the shader `assimp.vert` to `assimp_selection.vert`,
    and `assimp.frag` to `assimp_selection.frag`. The same name addition will be used
    for the animated model shader: Copy the file `assimp_skinning.vert` to `assimp_skinning_selection.vert`,
    and `assimp_skinning.frag` to `assimp_skinning_selection.frag`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need two new shader objects in the renderer, so we add the `private`
    `Shader` member variables named `mAssimpSelectionShader` and `mAssimpSkinningSelectionShader`
    to the file `OGLRenderer.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Like the existing shaders, the two new shaders are loaded in the `init()` method
    of the renderer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, two lines must be added to the new vertex shaders. The first new line
    adds a new output variable named `selectInfo` to the vertex shader, allowing us
    to hand over the selection data for the current triangle to the fragment shader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The second line at the end of the `main()` method does the actual forwarding
    to the fragment shader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'For the two new fragment shaders, similar changes are needed. On top of the
    shader code, we must add the new input variable `selectInfo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, the fragment shader output has to be adjusted. Replace the single `FragColor`
    output line with the following two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We write two different outputs now, one for each color buffer: The color buffer
    of the frame buffer will be filled with the RGBA values for the on-screen color
    of each pixel as before, and at the end of the `main()` method, the instance index
    passed through from the vertex shader will be written to the second color buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: If we use the new selection shader now when drawing the instances, the index
    of the instance will be added to the selection buffer for every single pixel of
    that of the instances onscreen.
  prefs: []
  type: TYPE_NORMAL
- en: Reading a pixel from a texture
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reading out the color of the pixel at a given position will be done in the method
    `readPixelFromPos()` of the `FrameBuffer` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we initialize our designated return variable with a special value, making
    it easy to find errors when OpenGL refuses to read out the pixel color due to
    a configuration problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we bind our framebuffer object as buffer to read from, and we select
    the color attachment `1` of the framebuffer, containing the selection texture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we adjust the internal alignment used during the read process, and read
    out the color value of a single pixel at the given `xPos` and `yPos` position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we switch the framebuffer back to color attachment `0`, unbind the
    buffer and return the pixel color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Adding mouse button handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Selecting an instance will be added to the left mouse button. It feels natural
    to click on an instance to select it. To store the status of the selection, a
    Boolean member variable named `mMousePick` is added to the renderer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the following line must be added to the `handleMouseButtonEvents()` method
    of the renderer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Using the `GLFW_RELEASE` `action` here, reacting when the left mouse button
    is released, matches the selection style of many applications. If you want to
    change the behavior, you can use the action `GLFW_PRESS`.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `mMousePick` value to trigger different actions in the drawing process
    only when a selection event has been triggered by the user. Separating normal
    drawing and the extra operation for selection helps to retain the maximum speed
    of the application, avoiding operations that are only required during the selection.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, the shader with the logic to draw into the selection texture
    will be only called if a selection event was triggered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Assigning an index to each instance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To ensure we always maintain a unique index for every instance, any time an
    instance is added or removed, we assign its overall index. Using the unique index
    per instance also helps us in accessing the current instance in the `miAssimpInstances`
    vector.
  prefs: []
  type: TYPE_NORMAL
- en: 'We add a new variable `isInstanceIndexPosition` to the struct `InstanceSettings`,
    located in the file `InstanceSettings.h` in the `model` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The variable `isInstanceIndexPosition` will be set in the method `assignInstanceIndices()`,
    doing a loop over all the instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The method `assignInstanceIndices()` is called whenever instances are added
    or removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having an easy to access instance number at hand helps us to fill the `y` element
    of the `mSelectedInstance` vector during the loop over all instances of a model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Selecting the instance at mouse positions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As the final step for the visual selection, we trigger the pixel read at the
    end of the `draw()` call in the renderer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: By surrounding the pixel read with a check for the `mMousePick` variable, we
    make sure the functions to read back the pixel will be called only on the selection
    event.
  prefs: []
  type: TYPE_NORMAL
- en: This guarding check is especially important for the calls to `glFlush()` and
    `glFinish()`. Both commands are required to make sure all shader runs have ended,
    and the data in the selection texture is complete. While `glFlush()` empties the
    internal buffers and triggers the rendering itself, `glFinish()` blocks the renderer
    and waits for all previous OpenGL calls to have finished. Forcing these OpenGL
    commands on every frame decreases the number of frames per second in most implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we call `readPixelFromPos()` on the `FrameBuffer` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Due to the different orientations of the `y` axis in OpenGL on the one hand
    and Windows and Linux on the other, we need to invert the `y` position when reading
    out the pixel.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we retrieve the pixel color, we check if any instance was selected, or
    the mouse click was done on the background of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: As the last step, we set `mMousePick` to `false`, stopping the selection mode
    immediately.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 3.4*, the selection texture for a larger group of model instances
    is shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_3.4_B22428.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.4: The selection texture'
  prefs: []
  type: TYPE_NORMAL
- en: The background color in *Figure 3.4* has been changed to white. In the actual
    selection texture, the clear value of `-1.0f` will be clamped to zero, resulting
    in a black background. Also, the index values have been adjusted to enhance the
    visibility of the instances. If we render the selection texture with the real
    float values, all index values will be clamped to `1.0f`, resulting in a picture
    where all instances appear in bright red.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting a single instance by using the mouse is working great now. As one
    of the ideas in the *Practical sessions* section, you could try to add more functionality,
    like selecting multiple instances at the same time. i.e., by keeping the *Ctrl*
    or *Shift* key down while selecting instances, newly selected instances are added,
    showing the coordinate arrows and the highlight on all selected instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'But there is one thing left that may annoy you: There is no way to select no
    instance at all. We will add a solution for an empty selection in the last section
    of this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a null object to allow deselection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Adding a deselection by doing a click into the background of the application
    window comes with a bunch of interesting implications. For instance, the position
    `0` may be a valid index in the `miAssimpInstance` vector, stating that the first
    instance has been selected. So, simply using zero to signal that no instances
    are selected does not work. Even worse: Using zero as the first index may confuse
    users of the application, as it is not intentional to start counting numbers at
    zero, instead of one.'
  prefs: []
  type: TYPE_NORMAL
- en: In addition, the default buffer background value of `–1` is an invalid array
    index. Using the value of `-1` as an index into the `miAssimpInstance` vector
    would simply crash the application. Since we will use the instance vector frequently
    in the code, adding a range check for every single access would be crucial because
    even missing a single check will lead to a crash.
  prefs: []
  type: TYPE_NORMAL
- en: So, we need another signalling mechanism to switch between the two selection
    variants and a simplification of the range checks. To catch both problems with
    a single solution, we will use an empty model as a **null object**.
  prefs: []
  type: TYPE_NORMAL
- en: What is a null object?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using a null object is a well-known design pattern for object-oriented programming.
    Usually, you would use a `nullptr` to signal the absence of an object instance.
    But, using a `nullptr` requires creating an extra check before every usage of
    the instance for being valid or not. Dereferencing a non-existing instance leads
    to a runtime error, and the application crashes.
  prefs: []
  type: TYPE_NORMAL
- en: The null object is a valid object instance, delivering a well-defined, but neutral
    behavior. Function calls in the instance of the null object are valid, but may
    return nothing viable, like an empty list, or some default values. This behavior
    frees the code of extra checks, since the instance itself is valid.
  prefs: []
  type: TYPE_NORMAL
- en: For our selection problem, we simply create an instance of the `AssimpModel`
    class that returns no vertices, plus empty lists or vectors for nodes, meshes,
    and so on. Then, we add the special model as the first model to the `miModelList`
    vector and add one instance of the “null model” as the first instance to the `miAssimpInstances`
    vector and to the `miAssimpInstancesPerModel` map.
  prefs: []
  type: TYPE_NORMAL
- en: If we select the first model instance now, we have a valid object, just without
    any triangles drawn to the screen. Switching off the coordinate arrows or adjusting
    the user interface to disable controls if no instance is selected can be done
    without extra signalling variables. We just need to test `miSelectedInstance`
    for being `0`.
  prefs: []
  type: TYPE_NORMAL
- en: We will alter the original pattern a bit, and don’t use a derived class. Instead,
    we will provide an empty object of the `AssimpModel` class.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and using the AssimpModel null object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we initialized the class members variables already in the header file
    `AssimpModel.h` with default values, creating a null object can be achieved by
    creating an empty instance. And the simplest way to create an instance of the
    `AssimpModel` class without setting any data is by using the implicitly created
    default constructor. We don’t even need to define a custom constructor; the C++
    compiler will handle everything we need in the background.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `init()` method of the renderer, we create a smart pointer to the null
    model, and add the model pointer to the `miModelList` vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can create an `AssimpInstance` instance from the null model, and place
    it into the `miAssimpInstancesPerModel` map and the `miAssimpInstances` vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'As the final initialization step, we update the index numbers of the instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Now, the instance of the `nullModel` model has the index number `0`. Any instance
    added in the application will now start at index `1`. Matching numbers for the
    overall number of instances and the instance index will avoid confusion about
    differences in the instance numbering schema.
  prefs: []
  type: TYPE_NORMAL
- en: 'To skip the model during vertex processing in the `draw()` call of the renderer,
    a check for the triangle count has been added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: In case we have no triangles in a model, all instances of this specific model
    will be skipped.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, we check for the instance number `0` before generating the final
    vertex position for the coordinate arrows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Whenever the very first instance is selected – the instance of the null model
    – no coordinate arrows will be drawn on the screen. We can even remove the `size()`
    check of the `miAssimpInstances` vector here, as we know we have at least one
    valid instance available.
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting the user interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the user interface, we will cheat a bit to keep the instance selection fields
    disabled in case the null instance is selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: By subtracting `1` from the size of the `miModelList` vector, we ignore the
    null model in that vector. We also ignore the null instance of the null model
    to count the instances in `numberOfInstances`. The additional Boolean `nullInstanceSelected`
    helps us to disable parts of the user interface when models and instances are
    available, but we have not selected any of the instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 3.5*, the effect of the deselection by using the null object is
    shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_3.5_B22428.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.5: User interface is partially disabled when nothing is selected'
  prefs: []
  type: TYPE_NORMAL
- en: No coordinate arrows are drawn at the feet of the model instance, as we hide
    the arrows when the null instance is selected. Also, the user interface is partially
    disabled, an effect of ignoring the null instance when counting the number of
    instances.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we enhanced the instance selection methods in the code for
    better handling of finding the selected instance on the screen. Plus, we added
    the ability to select an instance by using the mouse. First, we implemented a
    button to center our virtual camera on the selected instance. Next, we added the
    ability to highlight the selected model, making it easier to spot on the screen.
    Then, we implemented a visual selection, allowing the user to select an instance
    by clicking on any instance with the mouse. Finally, we created the possibility
    to select no instance at all, avoiding accidental changes.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will lay some groundwork to adapt more game engine features
    to the model viewer. As well as splitting the behavior of the viewer into an edit
    mode and a pure viewer functionality, we will add the ability to revert ongoing
    changes to an instance. At the end of the next chapter, we will implement undo/redo
    functionality, allowing the user to revert changes, or to reapply previous changes.
  prefs: []
  type: TYPE_NORMAL
- en: Practical sessions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are some additions you could make to the code:'
  prefs: []
  type: TYPE_NORMAL
- en: Calculate azimuth and elevation when moving the camera.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Right now, the values for azimuth and elevation are hard-coded. You could try
    to calculate both values from the transformation matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Implement a visual multi-selection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhance the selection so that holding *Ctrl* or *Shift* during selection clicks
    will add the newly selected instance to the other selected instances, instead
    of replacing the current selected instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Extra difficulty: Implement instance moving via coordinate arrows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the coordinate arrows for the selection are drawn in a separate shader,
    you could try to add an extra set of selection indices to the arrows and adding
    the arrows to the selection texture. When the user clicks on one of the arrows
    instead of the mode, you could switch the application to a mode where the instance
    can be moved along the selected axis. This behavior is similar to moving an instance
    in any common 3D editor.
  prefs: []
  type: TYPE_NORMAL
- en: Additional resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OpenGL basics: [https://learnopengl.com/Getting-started/Hello-Triangle](https://learnopengl.com/Getting-started/Hello-Triangle)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OpenGL Shader programming: [https://learnopengl.com/Getting-started/Shaders](https://learnopengl.com/Getting-started/Shaders)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Vulkan Tutorial: [https://vulkan-tutorial.com](https://vulkan-tutorial.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Demystifying Floating Point Precision: [https://blog.demofox.org/2017/11/21/floating-point-precision/](https://blog.demofox.org/2017/11/21/floating-point-precision/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Null object pattern: [https://www.geeksforgeeks.org/null-object-design-pattern/](https://www.geeksforgeeks.org/null-object-design-pattern/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://packt.link/cppgameanimation](https://packt.link/cppgameanimation)'
  prefs: []
  type: TYPE_NORMAL
- en: '![A qr code with black squares  AI-generated content may be incorrect.](img/QR_code_Discord.png)'
  prefs: []
  type: TYPE_IMG
