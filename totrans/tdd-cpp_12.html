<html><head></head><body>
		<div><h1 id="_idParaDest-115" class="chapter-number" lang="en-GB"><a id="_idTextAnchor123"/>12</h1>
			<h1 id="_idParaDest-116" lang="en-GB"><a id="_idTextAnchor124"/>Creating Better Test Confirmations</h1>
			<p lang="en-GB">This chapter introduces <em class="italic" lang="">Part 3</em>, where we extend the TDD library to support the growing needs of the logging library. <em class="italic" lang="">Part 1</em>, <em class="italic" lang="">Testing MVP</em>, of this book developed a basic unit test library, and <em class="italic" lang="">Part 2</em>, <em class="italic" lang="">Logging Library</em>, started to use the unit test library to build a logging library. Now we are following TDD, which encourages enhancing something once the basic tests are working.</p>
			<p lang="en-GB">Well, we managed to get a basic unit test library working and proved its worth by building a logging library. In a way, the logging library is like systems tests for the unit test library. Now it’s time to enhance the unit test library.</p>
			<p lang="en-GB">This chapter adds a completely new type of confirmation to the unit test library. First, we’ll look at the existing confirmations to understand how they can be improved and what the new solution will look like.</p>
			<p lang="en-GB">The new confirmations will be more intuitive, more flexible, and extensible. And remember to pay attention not only to the code being developed in this chapter but also to the process. That’s because we’ll be using TDD throughout to write some tests, starting with a simple solution and then enhancing the tests to create an even better solution.</p>
			<p lang="en-GB">In this chapter, we will cover the following main topics:</p>
			<ul>
				<li lang="en-GB">The problem with the current confirmations</li>
				<li lang="en-GB">How to simplify string confirmations</li>
				<li lang="en-GB">Enhancing the unit test library to support Hamcrest-style confirmations</li>
				<li lang="en-GB">Adding more Hamcrest matcher types</li>
			</ul>
			<h1 id="_idParaDest-117" lang="en-GB"><a id="_idTextAnchor125"/>Technical requirements</h1>
			<p lang="en-GB">All code in this chapter uses standard C++ that builds on any modern C++ 20 or later compiler and standard library. The code is based on and continues enhancing the testing library from <em class="italic" lang="">Part 1</em>, <em class="italic" lang="">Testing MVP</em>, of this book.</p>
			<p lang="en-GB">You can find all the code for this chapter in the following GitHub repository:</p>
			<p lang="en-GB"><a href="https://github.com/PacktPublishing/Test-Driven-Development-with-CPP">https://github.com/PacktPublishing/Test-Driven-Development-with-CPP</a></p>
			<h1 id="_idParaDest-118" lang="en-GB"><a id="_idTextAnchor126"/>The problem with the current confirmations</h1>
			<p lang="en-GB">Before we begin<a id="_idIndexMarker456"/> making changes, we should have some idea of why. TDD is all about the customer experience. How can we design something that is easy and intuitive to use? Let’s start by taking a look at a couple of existing tests:</p>
			<pre class="source-code" lang="en-GB">
TEST("Test string and string literal confirms")
{
    std::string result = "abc";
    CONFIRM("abc", result);
}
TEST("Test float confirms")
{
    float f1 = 0.1f;
    float f2 = 0.2f;
    float sum = f1 + f2;
    float expected = 0.3f;
    CONFIRM(expected, sum);
}</pre>
			<p lang="en-GB">These tests have served well and are easy, right? What we’re looking at here is not the tests themselves but the confirmations. This style <a id="_idIndexMarker457"/>of confirmation is called the <em class="italic" lang="">classic style</em>.</p>
			<p lang="en-GB">How would we speak or read aloud the first confirmation? It might go like this: “<em class="italic" lang="">Confirm the expected value of abc matches the value </em><em class="italic" lang="">of result</em>.”</p>
			<p lang="en-GB">That’s not too bad, but it’s a bit awkward. That’s not how a person would normally talk. Without looking at any code, a more natural way to say the same thing would be: “<em class="italic" lang="">Confirm that result </em><em class="italic" lang="">equals abc</em>.”</p>
			<p lang="en-GB">At first glance, maybe all we need to do is reverse the order of the parameters and put the actual value first followed by the expected value. But there’s a piece missing. How do we know that a confirmation is checking for equality? We know because that’s the only thing the existing <code>confirm</code> functions know how to check. Also, that means the <code>CONFIRM</code> macro only knows how to check for equality, too.</p>
			<p lang="en-GB">We have a better solution for bool values because we created special <code>CONFIRM_TRUE</code> and <code>CONFIRM_FALSE</code> macros that are easy to use and understand. And because the bool versions only take a single parameter, there’s no question of expected versus actual ordering.</p>
			<p lang="en-GB">There’s a better solution that aligns with the more natural way we would speak about a confirmation. The better <a id="_idIndexMarker458"/>solution uses something called matchers and is referred <a id="_idIndexMarker459"/>to as the <em class="italic" lang="">Hamcrest style</em>. The name “Hamcrest” is just a reordering of the letters in the word “matchers.” Here is what a test would look like written in the Hamcrest style:</p>
			<pre class="source-code" lang="en-GB">
TEST("Test can use hamcrest style confirm")
{
    int ten = 10;
    CONFIRM_THAT(ten, Equals(10));
}</pre>
			<p lang="en-GB">We’re not really designing the Hamcrest style in this book. The style already exists and is common in other testing libraries. And the main reason the testing library in this book puts the expected value first followed by the actual value for the classical style is to follow the common practice of the classical style.</p>
			<p lang="en-GB">Imagine you were to reinvent a better light switch. And I’ve been in buildings that have tried. The light switch might actually be better in some way. But if it doesn’t follow normal expectations, then people will get confused.</p>
			<p lang="en-GB">The same is true of the classical confirmations we started with in this book. I could have designed the confirmations to put the actual value first and maybe that would be better. But it would be unexpected for anybody who is even a little familiar with the existing testing libraries.</p>
			<p lang="en-GB">This brings up a great point to consider when creating designs using TDD. Sometimes, an inferior solution is better when that’s what the customer expects. Remember that whatever we design should be easy and intuitive to use. The goal is not to make the ultimate and most modern design but to make something that the user will be happy with.</p>
			<p lang="en-GB">This is why Hamcrest matchers work. The design doesn’t just switch the order of the expected and actual values because switching the order by itself would only confuse users.</p>
			<p lang="en-GB">Hamcrest works well because something else was added: the matcher. Notice the <code>Equals(10)</code> part of the confirmation. <code>Equals</code> is a matcher that makes it clear what the confirmation is doing. The matcher, together with a more intuitive ordering, gives a solution enough benefits to overcome the natural reluctance people have with switching to a new way of doing things. The Hamcrest style is not just a better light switch. Hamcrest is different enough and provides enough value that it avoids the confusion of a slightly<a id="_idIndexMarker460"/> better but different solution.</p>
			<p lang="en-GB">Also, notice that the name of the macro has changed from <code>CONFIRM</code> to <code>CONFIRM_THAT</code>. The name change is another way to avoid confusion and lets users continue to use the older classical style or opt for the newer Hamcrest style.</p>
			<p lang="en-GB">Now that we have a place to specify something such as <code>Equals</code>, we can also use different matchers such as <code>GreaterThan</code> or <code>BeginsWith</code>. Imagine that you wanted to confirm that some text begins with some expected characters. How would you write a test like that using classical confirmations? You would have to check for the beginning text outside of the confirmation and then confirm the result of the check. With the Hamcrest style and an appropriate matcher, you can confirm the text with a single-line confirmation. And you get the benefit of a more readable confirmation that makes it clear what is being confirmed.</p>
			<p lang="en-GB">What if you can’t find a matcher that fits your needs? You can always write your own to do exactly what you need. So, Hamcrest is extensible.</p>
			<p lang="en-GB">Before diving into the new Hamcrest design, the next section will take a slight detour to explain an improvement to the existing classic <code>confirm</code> template function. This improvement will be used in the Hamcrest design, so understanding the improvement first will help later when we get to the Hamcrest code explanations.</p>
			<h1 id="_idParaDest-119" lang="en-GB"><a id="_idTextAnchor127"/>Simplifying string confirmations</h1>
			<p lang="en-GB">While I was writing the code for this <a id="_idIndexMarker461"/>chapter, I ran into a problem confirming string data types that reminded me of how we added support for confirming strings in <a href="B18567_05.xhtml#_idTextAnchor045"><em class="italic" lang="">Chapter 5</em></a><em class="italic" lang="">, Adding More Confirm Types</em>. The motivating factor from <a href="B18567_05.xhtml#_idTextAnchor045"><em class="italic" lang="">Chapter 5</em></a> was to get the code to compile because we can’t pass <code>std::string</code> to a <code>std::to_string</code> function. I’ll briefly explain the problem again here.</p>
			<p lang="en-GB">I’m not sure of the exact reasons, but I think that the C++ standard library designers felt there was no need to provide an overload of <code>std::to_string</code> that accepts <code>std::string</code> because no conversion is needed. A string is already a string! Why convert something into what it already is?</p>
			<p lang="en-GB">Maybe this decision was<a id="_idIndexMarker462"/> on purpose or maybe it was an oversight. But it sure would have helped to have a string conversion into a string for template functions that need to convert their generic types into strings. That’s because, without the overload, we have to take extra steps to avoid compile errors. What we need is a <code>to_string</code> function that can convert any type into a string even if the type is already a string. If we had this ability to always be able to convert types into strings, then a template wouldn’t need to be specialized for strings.</p>
			<p lang="en-GB">In <a href="B18567_05.xhtml#_idTextAnchor045"><em class="italic" lang="">Chapter 5</em></a>, we introduced this template:</p>
			<pre class="source-code" lang="en-GB">
template &lt;typename T&gt;
void confirm (
    T const &amp; expected,
    T const &amp; actual,
    int line)
{
    if (actual != expected)
    {
        throw ActualConfirmException(
            std::to_string(expected),
            std::to_string(actual),
            line);
    }
}</pre>
			<p lang="en-GB">The <code>confirm</code> function accepts two templatized parameters, called <code>expected</code> and <code>actual</code>, that are compared for equality. If they are not equal, then the function passes both parameters to an exception that gets thrown. The parameters need to be converted into strings, as needed, by the <code>ActualConfirmException</code> constructor.</p>
			<p lang="en-GB">This is where we run into a problem. If the <code>confirm</code> template function is called with strings, then it doesn’t compile because strings can’t be converted into strings by calling <code>std::to_string</code>.</p>
			<p lang="en-GB">The solution we went with in <a href="B18567_05.xhtml#_idTextAnchor045"><em class="italic" lang="">Chapter 5</em></a> was to overload the <code>confirm</code> function with a non-template version that directly accepted strings. We actually created two overloads, one for strings and one for string views. This solved the problem but left us with the following two additional <a id="_idIndexMarker463"/>overloads:</p>
			<pre class="source-code" lang="en-GB">
inline void confirm (
    std::string_view expected,
    std::string_view actual,
    int line)
{
    if (actual != expected)
    {
        throw ActualConfirmException(
            expected,
            actual,
            line);
    }
}
inline void confirm (
    std::string const &amp; expected,
    std::string const &amp; actual,
    int line)
{
    confirm(
        std::string_view(expected),
        std::string_view(actual),
        line);
}</pre>
			<p lang="en-GB">When calling <code>confirm</code> with strings, these overloads are used instead of the template. The version that accepts <code>std::string</code> types calls into the version that takes <code>std::string_view</code> types, which uses the <code>expected</code> and <code>actual</code> parameters directly without trying to call <code>std::to_string</code>.</p>
			<p lang="en-GB">At the time, this wasn’t such a bad solution because we already had extra overloads of <code>confirm</code> for bools and the various floating point types. Two more overloads for strings was okay. Later, you’ll see how a small change will let us remove these two string overloads.</p>
			<p lang="en-GB">And now we come back to the problem of converting string data types with the new Hamcrest design we’ll be working on in this chapter. We will no longer need extra overloads of <code>confirm</code> even for bool or floating point types. As I was working on a new solution, I came back to the earlier solution from <a href="B18567_05.xhtml#_idTextAnchor045"><em class="italic" lang="">Chapter 5</em></a> and decided to refactor the existing classic confirms so that both solutions would be similar.</p>
			<p lang="en-GB">We’ll get into the new design later in this chapter. But so that we don’t have to interrupt that explanation, I have decided to take the detour now and explain how to remove the need for the string and string view overloads of the classic <code>confirm</code> function. Going through the explanation now should also make it easier to understand the new Hamcrest design since you’ll already be familiar with this part of the solution.</p>
			<p lang="en-GB">Also, I’d like to add that TDD helps with this type of refactoring. Because we already have existing tests for the <a id="_idIndexMarker464"/>classic confirms, we can remove the string overloads of <code>confirm</code> and make sure that all the tests continue to pass. I’ve worked on projects before where only the new code would use the better solution and we would have to leave the existing code unchanged in order to avoid introducing bugs. Doing this just makes the code harder to maintain because now there would be two different solutions in the same project. Having good tests helps give you the confidence needed to change existing code.</p>
			<p lang="en-GB">Okay, the core of the problem is that the C++ standard library does not include overloads of <code>to_string</code> that work with strings. And while it might be tempting to just add our own version of <code>to_string</code> to the <code>std</code> namespace, this is not allowed. It would probably work, and I’m sure that lots of people have done this. But it’s technically undefined behavior to add any function into the <code>std</code> namespace. There are very specific cases where we are allowed to add something into the <code>std</code> namespace, and unfortunately, this is not one of the allowed exceptions to the rules.</p>
			<p lang="en-GB">We will need our own version of <code>to_string</code>. We just can’t put our version in the <code>std</code> namespace. That’s a problem because when we call <code>to_string</code>, we currently specify the namespace by calling <code>std::to_string</code>. What we need to do is simply call <code>to_string</code> without any namespace and let the compiler look in either the <code>std</code> namespace to find the versions of <code>to_string</code> that work with numeric types, or look in our namespace to find our new version that works with strings. The new <code>to_string</code> function and the modified <code>confirm</code> template function look like this:</p>
			<pre class="source-code" lang="en-GB">
inline std::string to_string (std::string const &amp; str)
{
    return str;
}
template &lt;typename ExpectedT, typename ActualT&gt;
void confirm (
    ExpectedT const &amp; expected,
    ActualT const &amp; actual,
    int line)
{
    using std::to_string;
    using MereTDD::to_string;
    if (actual != expected)
    {
        throw ActualConfirmException(
            to_string(expected),
            to_string(actual),
            line);
    }
}</pre>
			<p lang="en-GB">We can remove the two overloads of <code>confirm</code> that take string views and strings. Now, the <code>confirm</code> template function will work for strings.</p>
			<p lang="en-GB">With the new <code>to_string</code> function<a id="_idIndexMarker465"/> that accepts <code>std::string</code>, all it needs to do is return the same string. We don’t really need another <code>to_string</code> function that works with string views.</p>
			<p lang="en-GB">The <code>confirm</code> template function is a little more complicated because it now needs two types, <code>ExpectedT</code> and <code>ActualT</code>. The two types are needed for those cases when we need to compare a string literal with a string, such as in the following test:</p>
			<pre class="source-code" lang="en-GB">
TEST("Test string and string literal confirms")
{
    std::string result = "abc";
    CONFIRM("abc", result);
}</pre>
			<p lang="en-GB">The reason this test used to compile when we had only a single <code>confirm</code> template parameter is that it wasn’t calling into the template. The compiler was converting the <code>"abc"</code> string literal into a string and calling the overload of <code>confirm</code> that accepted two strings. Or maybe it was converting both the string literal and the string into string views and calling the overload of <code>confirm</code> that accepted two string views. Either way, because we had separate overloads of <code>confirm</code>, the compiler was able to make it work.</p>
			<p lang="en-GB">Now that we removed both <code>confirm</code> overloads that deal with strings, we have only the template, and we need to let it accept different types in order to compile. I know, we still have overloads for bool and the floating point types. I’m only talking about the string overloads that we can remove.</p>
			<p lang="en-GB">In the new template, you can see that we call <code>to_string</code> without any namespace specification. The compiler is able to find the versions of <code>to_string</code> it needs because of the two using statements inside the template function. The first using statement tells the compiler that it should consider all the <code>to_string</code> overloads in the <code>std</code> namespace. And the second using statement tells the compiler to also consider any <code>to_string</code> functions it finds in the <code>MereTDD</code> namespace.</p>
			<p lang="en-GB">The compiler is now able to <a id="_idIndexMarker466"/>find a version of <code>to_string</code> that works with the numeric types when <code>confirm</code> is called with numeric types. And the compiler can find our new <code>to_string</code> function that works with strings when needed. We no longer need to limit the compiler to only look in the <code>std</code> namespace.</p>
			<p lang="en-GB">Now we can go back to the new Hamcrest style design, which we will do in the next section. The Hamcrest design will, eventually, use a solution similar to what was just described here.</p>
			<h1 id="_idParaDest-120" lang="en-GB"><a id="_idTextAnchor128"/>Enhancing the test library to support Hamcrest matchers</h1>
			<p lang="en-GB">Once you get a basic implementation<a id="_idIndexMarker467"/> working and passing<a id="_idIndexMarker468"/> the tests, TDD guides us to enhance the design by creating more tests and then getting the new tests to pass. That’s exactly what this chapter is all about. We’re enhancing the classic style confirmations to support the Hamcrest style.</p>
			<p lang="en-GB">Let’s start by creating a new file, called <code>Hamcrest.cpp</code>, in the <code>tests</code> folder. Now, the overall project structure should look like this:</p>
			<pre class="source-code" lang="en-GB">
MereTDD project root folder
    Test.h
    tests folder
        main.cpp
        Confirm.cpp
        Creation.cpp
        Hamcrest.cpp
        Setup.cpp</pre>
			<p lang="en-GB">If you’ve been following all the code in this book so far, remember that we’re going back to the <em class="italic" lang="">MereTDD</em> project that we last worked on in <a href="B18567_07.xhtml#_idTextAnchor065"><em class="italic" lang="">Chapter 7</em></a>, <em class="italic" lang="">Test Setup and Teardown</em>. This is not the <em class="italic" lang="">MereMemo</em> logging project.</p>
			<p lang="en-GB">The Hamcrest style test that we need to support goes inside <code>Hamcrest.cpp</code> so that the new file looks like this:</p>
			<pre class="source-code" lang="en-GB">
#include "../Test.h"
TEST("Test can use hamcrest style confirm")
{
    int ten = 10;
    CONFIRM_THAT(ten, Equals(10));
}</pre>
			<p lang="en-GB">We might as well start <a id="_idIndexMarker469"/>with the new <code>CONFIRM_THAT</code> macro, which goes at the end of <code>Test.h</code> right after the other <code>CONFIRM</code> macros, like this:</p>
			<pre class="source-code" lang="en-GB">
#define CONFIRM_FALSE( actual ) \
    MereTDD::confirm(false, actual, __LINE__)
#define CONFIRM_TRUE( actual ) \
    MereTDD::confirm(true, actual, __LINE__)
#define CONFIRM( expected, actual ) \
    MereTDD::confirm(expected, actual, __LINE__)
#define CONFIRM_THAT( actual, matcher ) \
    MereTDD::confirm_that(actual, matcher, __LINE__)</pre>
			<p lang="en-GB">The <code>CONFIRM_THAT</code> macro is similar to the <code>CONFIRM</code> macro except that the <code>actual</code> parameter comes first, and instead of an <code>expected</code> parameter, we have a parameter called <code>matcher</code>. We’ll also call a new function called <code>confirm_that</code>. The new function helps make it simpler to keep the classic style <code>confirm</code> overloads separate from the Hamcrest-style <code>confirm_that</code> function.</p>
			<p lang="en-GB">We don’t need all the overloads in the same way that we needed for <code>confirm</code>. The <code>confirm_that</code> function can be implemented with a single template function. Place this new template in <code>Test.h</code> right after the classic <code>confirm</code> template function. Both template functions should look like this:</p>
			<pre class="source-code" lang="en-GB">
template &lt;typename ExpectedT, typename ActualT&gt;
void confirm (
    ExpectedT const &amp; expected,
    ActualT const &amp; actual,
    int line)
{
    using std::to_string;
    using MereTDD::to_string;
    if (actual != expected)
    {
        throw ActualConfirmException(
            to_string(expected),
            to_string(actual),
            line);
    }
}
template &lt;typename ActualT, typename MatcherT&gt;
inline void confirm_that (
    ActualT const &amp; actual,
    MatcherT const &amp; matcher,
    int line)
{
    using std::to_string;
    using MereTDD::to_string;
    if (not matcher.pass(actual))
    {
        throw ActualConfirmException(
            to_string(matcher),
            to_string(actual),
            line);
    }
}</pre>
			<p lang="en-GB">We’re only adding the <code>confirm_that</code> function. I decided to show both functions so that you can see the differences easier. Notice that now, the <code>ActualT</code> type is given first. The order doesn’t really <a id="_idIndexMarker470"/>matter, but I like to put the template <a id="_idIndexMarker471"/>parameters in a reasonable order. We no longer have an <code>ExpectedT</code> type; instead, we have a <code>MatcherT</code> type.</p>
			<p lang="en-GB">The name of the new template function is different too, so there is no ambiguity due to the similar template parameters. The new template function is called <code>confirm_that</code>.</p>
			<p lang="en-GB">While the classic <code>confirm</code> function compares the <code>actual</code> parameter directly with the <code>expected</code> parameter, the new <code>confirm_that</code> function calls into a <code>pass</code> method on the <code>matcher</code> to perform the check. We don’t really know what the <code>matcher</code> will be doing in the <code>pass</code> method because that is for the <code>matcher</code> to decide. And because any changes in the comparison from one type to another are wrapped up in the <code>matcher</code>, we don’t need to overload the <code>confirm_that</code> function like we had to do for the classic <code>confirm</code> function. We’ll still need a special code, but the differences will be handled by the <code>matcher</code> in this design.</p>
			<p lang="en-GB">This is where I realized that there needs to be a different solution for converting the <code>matcher</code> and <code>actual</code> parameters into strings. It seems pointless to override <code>confirm_that</code> just to avoid calling <code>to_string</code> when the type of <code>ActualT</code> is a string. So, I stopped calling <code>std::to_string(actual)</code> and instead started calling <code>to_string(actual)</code>. In order for the compiler to find the necessary <code>to_string</code> functions, the using statements<a id="_idIndexMarker472"/> are needed. This is<a id="_idIndexMarker473"/> the explanation that the previous section describes for simplifying the string comparisons.</p>
			<p lang="en-GB">Now that we have the <code>confirm_that</code> template, we can focus on the <code>matcher</code>. We need to be able to call a <code>pass</code> method and convert a <code>matcher</code> into a string. Let’s create a base class for all the matchers to inherit from, so they will all have a common interface. Place this base class and <code>to_string</code> function right after the <code>confirm_that</code> function in <code>Test.h</code>, as follows:</p>
			<pre class="source-code" lang="en-GB">
class Matcher
{
public:
    virtual ~Matcher () = default;
    Matcher (Matcher const &amp; other) = delete;
    Matcher (Matcher &amp;&amp; other) = delete;
    virtual std::string to_string () const = 0;
    Matcher &amp; operator = (Matcher const &amp; rhs) = delete;
    Matcher &amp; operator = (Matcher &amp;&amp; rhs) = delete;
protected:
    Matcher () = default;
};
inline std::string to_string (Matcher const &amp; matcher)
{
    return matcher.to_string();
}</pre>
			<p lang="en-GB">The <code>to_string</code> function will let us convert a matcher into a string by calling the virtual <code>to_string</code> method in the <code>Matcher</code> base class. Notice there is no <code>pass</code> method in the <code>Matcher</code> class.</p>
			<p lang="en-GB">The <code>Matcher</code> class itself is a base class that doesn’t need to be copied or assigned. The only common interface the <code>Matcher</code> class defines is a <code>to_string</code> method that all matchers will implement to convert themselves into a string that can be sent to the test run summary report.</p>
			<p lang="en-GB">What happened to the <code>pass</code> method? Well, the <code>pass</code> method needs to accept the actual type that will be used to determine whether the actual value matches the expected value. The expected <a id="_idIndexMarker474"/>value itself will be<a id="_idIndexMarker475"/> held in the derived matcher class. The actual value will be passed to the <code>pass</code> method.</p>
			<p lang="en-GB">The types of values accepted for the actual and expected values will be fully under the control of the derived matcher class. Because the types can change from one usage of a matcher to another, we can’t define a <code>pass</code> method in the <code>Matcher</code> base class. This is okay because the <code>confirm_that</code> template doesn’t work with the <code>Matcher</code> base class. The <code>confirm_that</code> template will have knowledge of the real matcher-derived class and can call the <code>pass</code> method directly as a non-virtual method.</p>
			<p lang="en-GB">The <code>to_string</code> method is different because we want to call the virtual <code>Matcher::to_string</code> method from within the <code>to_string</code> helper function that accepts any <code>Matcher</code> reference.</p>
			<p lang="en-GB">So, when converting a matcher into a string, we treat all matchers the same and go through the virtual <code>to_string</code> method. And when calling <code>pass</code>, we work directly with the real matcher class and call <code>pass</code> directly.</p>
			<p lang="en-GB">Let’s see what a real matcher class will look like. The test we are implementing uses a matcher called <code>Equals</code>. We can create the derived <code>Equals</code> class right after the <code>Matcher</code> class and the <code>to_string</code> function, as follows:</p>
			<pre class="source-code" lang="en-GB">
template &lt;typename T&gt;
class Equals : public Matcher
{
public:
    Equals (T const &amp; expected)
    : mExpected(expected)
    { }
    bool pass (T const &amp; actual) const
    {
        return actual == mExpected;
    }
    std::string to_string () const override
    {
        using std::to_string;
        using MereTDD::to_string;
        return to_string(mExpected);
    }
private:
    T mExpected;
};</pre>
			<p lang="en-GB">The <code>Equals</code> class is another template because it needs to hold the proper expected value type, and it needs to use <a id="_idIndexMarker476"/>the same type in the <code>pass</code> method for the <code>actual</code> parameter.</p>
			<p lang="en-GB">Notice that the <code>to_string</code> override method uses the same solution to convert the <code>mExpected</code> data member into a <a id="_idIndexMarker477"/>string that we’ve been using. We call <code>to_string</code> and let the compiler find an appropriate match in either the <code>std</code> or <code>MereTDD</code> namespaces.</p>
			<p lang="en-GB">We need one more small change to get everything working. In our Hamcrest test, we use the <code>Equals</code> matcher without any namespace specification. We could refer to it as <code>MereTDD::Equals</code>. But the namespace specification distracts from the readability of the tests. Let’s add a <code>using namespace MereTDD</code> statement to the top of any test file that will use Hamcrest matchers so we can refer to them directly, like this:</p>
			<pre class="source-code" lang="en-GB">
#include "../Test.h"
using namespace MereTDD;
TEST("Test can use hamcrest style confirm")
{
    int ten = 10;
    CONFIRM_THAT(ten, Equals(10));
}</pre>
			<p lang="en-GB">That’s everything needed to support our first Hamcrest matcher unit test – building and running show that all tests pass. What about an expected failure? First, let’s create a new test like this:</p>
			<pre class="source-code" lang="en-GB">
TEST("Test hamcrest style confirm failure")
{
    int ten = 10;
    CONFIRM_THAT(ten, Equals(9));
}</pre>
			<p lang="en-GB">This test is designed to fail because <code>10</code> will not equal <code>9</code>. We need to build and run once just to get the failure message from the summary report. Then, we can add a call to <code>setExpectedFailureReason</code> with the exactly formatted failure message. Remember that the failure message<a id="_idIndexMarker478"/> needs to match exactly, including all the spaces and punctuation. I know this can be tedious, but it should not be a test that you need to worry about unless you’re <a id="_idIndexMarker479"/>testing one of your own custom matchers to make sure the custom matcher is able to format a proper error message.</p>
			<p lang="en-GB">After getting the exact error message, we can modify the test to turn it into an expected failure, as follows:</p>
			<pre class="source-code" lang="en-GB">
TEST("Test hamcrest style confirm failure")
{
    std::string reason = "    Expected: 9\n";
    reason += "    Actual  : 10";
    setExpectedFailureReason(reason);
    int ten = 10;
    CONFIRM_THAT(ten, Equals(9));
}</pre>
			<p lang="en-GB">Building and running again shows both Hamcrest tests results, as follows:</p>
			<pre class="source-code" lang="en-GB">
<strong class="bold" lang="">------- Test: Test can use hamcrest style confirm</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: Test hamcrest style confirm failure</strong>
<strong class="bold" lang="">Expected failure</strong>
<strong class="bold" lang="">    Expected: 9</strong>
<strong class="bold" lang="">    Actual  : 10</strong></pre>
			<p lang="en-GB">This is a good start. We haven’t yet started talking about how to design custom matchers. Before we start custom matchers, what about other basic types? We only have a couple of Hamcrest tests that compare int values. The next section will explore other basic types and add more tests.</p>
			<h1 id="_idParaDest-121" lang="en-GB"><a id="_idTextAnchor129"/>Adding more Hamcrest types</h1>
			<p lang="en-GB">There is a pattern to using TDD that you should be familiar with by now. We add a little bit of something, get it working, and then <a id="_idIndexMarker480"/>add more. We have the ability to confirm int values with a Hamcrest <code>Equals</code> matcher. Now it’s time to add more types. Some of these types might work without any extra work due to the template <code>confirm_that</code> function. Other types might need changes. We’ll find out what needs to be done by writing some tests.</p>
			<p lang="en-GB">The first test ensures that the other integer types work as expected. Add this test to <code>Hamcrest.cpp</code>:</p>
			<pre class="source-code" lang="en-GB">
TEST("Test other hamcrest style integer confirms")
{
    char c1 = 'A';
    char c2 = 'A';
    CONFIRM_THAT(c1, Equals(c2));
    CONFIRM_THAT(c1, Equals('A'));
    short s1 = 10;
    short s2 = 10;
    CONFIRM_THAT(s1, Equals(s2));
    CONFIRM_THAT(s1, Equals(10));
    unsigned int ui1 = 3'000'000'000;
    unsigned int ui2 = 3'000'000'000;
    CONFIRM_THAT(ui1, Equals(ui2));
    CONFIRM_THAT(ui1, Equals(3'000'000'000));
    long long ll1 = 5'000'000'000'000LL;
    long long ll2 = 5'000'000'000'000LL;
    CONFIRM_THAT(ll1, Equals(ll2));
    CONFIRM_THAT(ll1, Equals(5'000'000'000'000LL));
}</pre>
			<p lang="en-GB">First, the test declares a couple of chars and uses the <code>Equals</code> matcher in a couple of different ways. The first is to test for equality with another char. The second uses a char literal value, <code>'A'</code>, for the comparison.</p>
			<p lang="en-GB">The second set of confirmations is based on short ints. We use the <code>Equals</code> matcher with another short int and then an int literal value of <code>10</code> for the comparison.</p>
			<p lang="en-GB">The third set of confirmations is based on unsigned ints and, again, tries to use the <code>Equals</code> matcher with another variable of the same type and with a literal int.</p>
			<p lang="en-GB">The fourth set of confirmations makes sure that long long types are supported.</p>
			<p lang="en-GB">We’re not creating helper functions designed to simulate other software being tested. You already know how to use confirmations in a real project based on the tests in the logging library. That’s why this test makes things simple and just focuses on making sure that the <code>CONFIRM_THAT</code> macro, which calls the <code>confirm_that</code> template function, works.</p>
			<p lang="en-GB">Building and running these tests <a id="_idIndexMarker481"/>show that all tests pass with no changes or enhancements needed.</p>
			<p lang="en-GB">What about bool types? Here is a test that goes into <code>Hamcrest.cpp</code> to test bool types:</p>
			<pre class="source-code" lang="en-GB">
TEST("Test hamcrest style bool confirms")
{
    bool b1 = true;
    bool b2 = true;
    CONFIRM_THAT(b1, Equals(b2));
    // This works but probably won't be used much.
    CONFIRM_THAT(b1, Equals(true));
    // When checking a bool variable for a known value,
    // the classic style is probably better.
    CONFIRM_TRUE(b1);
}</pre>
			<p lang="en-GB">This test shows that the Hamcrest style works for bool types, too. When comparing one bool variable with another, the Hamcrest style is better than the classic style. However, when comparing a bool variable with an expected true or false literal, it’s actually more readable to use the classic style because we have simplified <code>CONFIRM_TRUE</code> and <code>CONFIRM_FALSE</code> macros.</p>
			<p lang="en-GB">Now, let’s move on to strings with this test that goes into <code>Hamcrest.cpp</code>. Note that this test will fail to compile at first and that’s okay. The test looks like this:</p>
			<pre class="source-code" lang="en-GB">
TEST("Test hamcrest style string confirms")
{
    std::string s1 = "abc";
    std::string s2 = "abc";
    CONFIRM_THAT(s1, Equals(s2));     // string vs. string
    CONFIRM_THAT(s1, Equals("abc"));  // string vs. literal
    CONFIRM_THAT("abc", Equals(s1));  // literal vs. string
}</pre>
			<p lang="en-GB">There are several confirms in this test, and that’s okay because they’re all related. The comments help to clarify what each confirmation is testing.</p>
			<p lang="en-GB">We’re always looking for <a id="_idIndexMarker482"/>two things with a new test. The first is whether the test compiles at all. And the second is whether it passes. Right now, the test will fail to compile with an error similar to the following:</p>
			<pre class="source-code" lang="en-GB">
<strong class="bold" lang="">MereTDD/tests/../Test.h: In instantiation of 'MereTDD::Equals&lt;T&gt;::Equals(const T&amp;) [with T = char [4]]':</strong>
<strong class="bold" lang="">MereTDD/tests/Hamcrest.cpp:63:5:   required from here</strong>
<strong class="bold" lang="">MereTDD/tests/../Test.h:209:7: error: array used as initializer</strong>
<strong class="bold" lang="">  209 |     : mExpected(expected)</strong>
<strong class="bold" lang="">      |       ^~~~~~~~~~~~~~~~~~~</strong></pre>
			<p lang="en-GB">You might get different line numbers, so I’ll explain what the error is referring to. The failure is in the <code>Equals</code> constructor, which looks like this:</p>
			<pre class="source-code" lang="en-GB">
    Equals (T const &amp; expected)
    : mExpected(expected)
    { }</pre>
			<p lang="en-GB">And line 63 in <code>Hamcrest.cpp</code> is the following line:</p>
			<pre class="source-code" lang="en-GB">
    CONFIRM_THAT(s1, Equals("abc"));  // string vs. literal</pre>
			<p lang="en-GB">We’re trying to construct an <code>Equals</code> matcher given the <code>"abc"</code> string literal, and this fails to compile. The reason is that the <code>T</code> type is an array that needs to be initialized in a different manner.</p>
			<p lang="en-GB">What we need is a special version of <code>Equals</code> that works with string literals. Since a string literal is an array of constant chars, the following template specialization will work. Place this new template in <code>Test.h</code> right after the existing <code>Equals</code> template:</p>
			<pre class="source-code" lang="en-GB">
template &lt;typename T, std::size_t N&gt; requires (
    std::is_same&lt;char, std::remove_const_t&lt;T&gt;&gt;::value)
class Equals&lt;T[N]&gt; : public Matcher
{
public:
    Equals (char const (&amp; expected)[N])
    {
        memcpy(mExpected, expected, N);
    }
    bool pass (std::string const &amp; actual) const
    {
        return actual == mExpected;
    }
    std::string to_string () const override
    {
        return std::string(mExpected);
    }
private:
    char mExpected[N];
};</pre>
			<p lang="en-GB">We’ll need a couple of extra<a id="_idIndexMarker483"/> includes in <code>Test.h</code> for <code>cstring</code> and <code>type_traits</code>, as follows:</p>
			<pre class="source-code" lang="en-GB">
#include &lt;cstring&gt;
#include &lt;map&gt;
#include &lt;ostream&gt;
#include &lt;string_view&gt;
#include &lt;type_traits&gt;
#include &lt;vector&gt;</pre>
			<p lang="en-GB">The template specialization uses a new C++20 feature, called <em class="italic" lang="">requires</em>, which helps us to place constraints on template parameters. The <code>requires</code> keyword is actually part of a bigger enhancement in C++20, called <em class="italic" lang="">concepts</em>. Concepts are a huge enhancement to C++ and a full explanation would be beyond the scope of this book. We’re using concepts and the <code>requires</code> keyword to simplify the template specialization to only work with strings. The template itself takes a <code>T</code> type like before and a new numeric value, <code>N</code>, which will be the size of the string literal. The requires clause makes sure that <code>T</code> is a char. We need to remove the const qualifier from <code>T</code> because string literals are actually constant.</p>
			<p lang="en-GB">The <code>Equals</code> specialization then says it is an array of <code>T[N]</code>. The constructor takes a reference to an array of <code>N</code> chars, and instead of trying to directly initialize <code>mExpected</code> with the constructor’s <code>expected</code> parameter, it now calls <code>memcpy</code> to copy the chars from the literal into the <code>mExpected</code> array. The strange syntax of <code>char const (&amp; expected)[N]</code> is how C++ specifies an array as a method parameter that does not get decayed into a simple pointer.</p>
			<p lang="en-GB">Now the <code>pass</code> method can take a string reference as its <code>actual</code> parameter type since we know that we are dealing with strings. Additionally, the <code>to_string</code> method can directly construct and return <code>std::string</code> from the <code>mExpected</code> char array.</p>
			<p lang="en-GB">One interesting, and maybe only theoretical, benefit of the <code>Equals</code> template specialization and the <code>pass</code> method<a id="_idIndexMarker484"/> is that we can now confirm that a string literal equals another string literal. I can’t think of any place where this would be useful but it works, so we might as well add it to the test like this:</p>
			<pre class="source-code" lang="en-GB">
TEST("Test hamcrest style string confirms")
{
    std::string s1 = "abc";
    std::string s2 = "abc";
    CONFIRM_THAT(s1, Equals(s2));       // string vs. string
    CONFIRM_THAT(s1, Equals("abc"));    // string vs. literal
    CONFIRM_THAT("abc", Equals(s1));    // literal vs. string
    // Probably not needed, but this works too.
    CONFIRM_THAT("abc", Equals("abc")); // literal vs. Literal
}</pre>
			<p lang="en-GB">What about char pointers? They’re not <a id="_idIndexMarker485"/>as common as char arrays for template parameters because char arrays come from working with string literals. A char pointer is slightly different. We should consider char pointers because while they are not as common in template parameters, a char pointer is probably more common overall than char arrays. Here is a test that demonstrates char pointers. Note that this test will not compile yet. Add this into <code>Hamcrest.cpp</code>:</p>
			<pre class="source-code" lang="en-GB">
TEST("Test hamcrest style string pointer confirms")
{
    char const * sp1 = "abc";
    std::string s1 = "abc";
    char const * sp2 = s1.c_str();    // avoid sp1 and sp2 being same
    CONFIRM_THAT(sp1, Equals(sp2));   // pointer vs. pointer
    CONFIRM_THAT(sp2, Equals("abc")); // pointer vs. literal
    CONFIRM_THAT("abc", Equals(sp2)); // literal vs. pointer
    CONFIRM_THAT(sp1, Equals(s1));    // pointer vs. string
    CONFIRM_THAT(s1, Equals(sp1));    // string vs. pointer
}</pre>
			<p lang="en-GB">We can initialize a char pointer given a string literal just like how <code>std::string</code> is initialized. But while <code>std::string</code> copies the text into its own memory to manage, a char pointer just points to the first char in the string literal. I keep saying that we’re working with char pointers. But to be<a id="_idIndexMarker486"/> more specific, we’re working with constant char pointers. The code needs to use const, but I sometimes leave const out when speaking or writing.</p>
			<p lang="en-GB">The new test for the string pointer confirms the need to take extra steps to make sure that <code>sp1</code> and <code>sp2</code> point to different memory addresses.</p>
			<p lang="en-GB">String literals in C++ are consolidated so that duplicate literal values all point to the same memory address. Even though a literal such as <code>"abc"</code> might be used many times in the source code, there will only be one copy of the string literal in the final executable that gets built. The test must go through extra steps to make sure that <code>sp1</code> and <code>sp2</code> have different pointer values while maintaining the same text. Whenever <code>std::string</code> is initialized with a string literal, the text of the string literal gets copied into <code>std::string</code> to manage. The <code>std::string</code> might use dynamically allocated memory or local memory on the stack. A <code>std::string</code> will not just point to the memory address used in the initialization. If we simply initialized <code>sp2</code> the same way as <code>sp1</code>, then both pointers would point to the same memory address. But by initializing <code>sp2</code> to point to the string inside <code>s1</code>, then <code>sp2</code> points to a different memory address from <code>sp1</code>. Even though <code>sp1</code> and <code>sp2</code> point to different memory addresses, the value of the text chars at each address is the same.</p>
			<p lang="en-GB">Okay, now that you understand what the test is doing, does it compile? No. The build fails while trying to call the <code>pass</code> method in the <code>confirm_that</code> template function.</p>
			<p lang="en-GB">The line in the test that causes the build failure is the last confirmation. The compiler is trying to convert the <code>s1</code> string into a constant char pointer. But this is misleading because even if we comment out the last confirmation so that the build succeeds, the test then fails at runtime, like this:</p>
			<pre class="source-code" lang="en-GB">
<strong class="bold" lang="">------- Test: Test hamcrest style string pointer confirms</strong>
<strong class="bold" lang="">Failed confirm on line 75</strong>
<strong class="bold" lang="">    Expected: abc</strong>
<strong class="bold" lang="">    Actual  : abc</strong></pre>
			<p lang="en-GB">Because you might get different line numbers, I’ll explain that line 75 is the first confirmation from the test:</p>
			<pre class="source-code" lang="en-GB">
    CONFIRM_THAT(sp1, Equals(sp2));   // pointer vs. pointer</pre>
			<p lang="en-GB">Look at the test failure message though. It says that <code>"abc"</code> is not equal to <code>"abc"</code>! What is going on?</p>
			<p lang="en-GB">Because we’re using the original <code>Equals</code> template class, it only knows that we are dealing with char pointers. When we call <code>pass</code>, it’s the pointer values that are being compared. And because we<a id="_idIndexMarker487"/> took extra steps to make sure that <code>sp1</code> and <code>sp2</code> have different pointer values, the test fails. And the test fails even though the text both pointers refer to is the same.</p>
			<p lang="en-GB">In order to support pointers, we’ll need another template specialization of <code>Equals</code>. But we can’t just specialize on any pointer type, in the same way we couldn’t specialize on any array type. We made sure that the array specialization only works for char arrays. So, we should also make sure that our pointer specialization only works with char pointers. Add this specialization right after the second <code>Equals</code> class in <code>Test.h</code>:</p>
			<pre class="source-code" lang="en-GB">
template &lt;typename T&gt; requires (
    std::is_same&lt;char, std::remove_const_t&lt;T&gt;&gt;::value)
class Equals&lt;T *&gt; : public Matcher
{
public:
    Equals (char const * expected)
    : mExpected(expected)
    { }
    bool pass (std::string const &amp; actual) const
    {
        return actual == mExpected;
    }
    std::string to_string () const override
    {
        return mExpected;
    }
private:
    std::string mExpected;
};</pre>
			<p lang="en-GB">With this third version of the <code>Equals</code> class, we not only fix the build error but all the confirmations pass too! This template specializes <code>Equals</code> for <code>T *</code> and also requires that <code>T</code> be a char type.</p>
			<p lang="en-GB">The constructor accepts a pointer to constant chars and initializes <code>mExpected</code> with the pointer. The <code>mExpected</code> data <a id="_idIndexMarker488"/>member is <code>std::string</code>, which knows how to initialize itself from a pointer.</p>
			<p lang="en-GB">The <code>pass</code> method also accepts <code>std::string</code>, which will let it compare against actual strings or char pointers. Additionally, the <code>to_string</code> method can return <code>mExpected</code> directly since it’s already a string.</p>
			<p lang="en-GB">When we were adding more classical confirmations in <a href="B18567_05.xhtml#_idTextAnchor045"><em class="italic" lang="">Chapter 5</em></a>, <em class="italic" lang="">Adding More Confirm Types</em>, we added special support for floating point types. We’ll need to add special support for confirming floating-point types in the Hamcrest style, too. The Hamcrest floating-point specializations will come in the next chapter along with learning how to write custom matchers.</p>
			<h1 id="_idParaDest-122" lang="en-GB"><a id="_idTextAnchor130"/>Summary</h1>
			<p lang="en-GB">We used TDD throughout this chapter to add Hamcrest confirmations and even improve the existing code for classical confirmations. Without TDD, the existing code in a real project would likely not get approval from management to make changes.</p>
			<p lang="en-GB">This chapter showed you the benefits of having unit tests that can help verify the quality of code after making changes. We were able to refactor the existing classical confirmations design for dealing with strings so that it matches the new design, which has a similar need. This lets both the classical and Hamcrest confirmations share a similar design instead of maintaining two different designs. All the changes were possible because the unit tests verified that everything continued to run as expected.</p>
			<p lang="en-GB">The most important changes in this chapter added Hamcrest style confirmations, which are more intuitive and more flexible than the classic confirmations developed in <a href="B18567_04.xhtml#_idTextAnchor038"><em class="italic" lang="">Chapter 4</em></a>, <em class="italic" lang="">Adding Tests to a Project</em>. Additionally, the new Hamcrest confirmations are extensible.</p>
			<p lang="en-GB">We added support for Hamcrest confirmations<a id="_idIndexMarker489"/> following a TDD approach, which let us start simply. The simplicity was critical because we soon got into more advanced template specializations and even a new C++20 feature, called <em class="italic" lang="">requires</em>, that lets us specify how the templates should be used.</p>
			<p lang="en-GB">TDD makes the process of designing software flow better – from simple ideas at the start of a project or the beginning of an enhancement to an enhanced solution like this chapter developed. Even though we have working Hamcrest confirmations, we’re not done yet. We’ll continue to enhance the confirmations in the next chapter by making sure we can confirm floating-point values and custom-type values.</p>
		</div>
	</body></html>