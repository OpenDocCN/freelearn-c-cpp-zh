<html><head></head><body>
		<div id="_idContainer025">
			<h1 id="_idParaDest-115" class="chapter-number" lang="en-GB"><a id="_idTextAnchor123"/>12</h1>
			<h1 id="_idParaDest-116" lang="en-GB"><a id="_idTextAnchor124"/>Creating Better Test Confirmations</h1>
			<p lang="en-GB">This chapter introduces <em class="italic" lang="">Part 3</em>, where we extend the TDD library to support the growing needs of the logging library. <em class="italic" lang="">Part 1</em>, <em class="italic" lang="">Testing MVP</em>, of this book developed a basic unit test library, and <em class="italic" lang="">Part 2</em>, <em class="italic" lang="">Logging Library</em>, started to use the unit test library to build a logging library. Now we are following TDD, which encourages enhancing something once the basic tests <span class="No-Break" lang="">are working.</span></p>
			<p lang="en-GB">Well, we managed to get a basic unit test library working and proved its worth by building a logging library. In a way, the logging library is like systems tests for the unit test library. Now it’s time to enhance the unit <span class="No-Break" lang="">test library.</span></p>
			<p lang="en-GB">This chapter adds a completely new type of confirmation to the unit test library. First, we’ll look at the existing confirmations to understand how they can be improved and what the new solution will <span class="No-Break" lang="">look like.</span></p>
			<p lang="en-GB">The new confirmations will be more intuitive, more flexible, and extensible. And remember to pay attention not only to the code being developed in this chapter but also to the process. That’s because we’ll be using TDD throughout to write some tests, starting with a simple solution and then enhancing the tests to create an even <span class="No-Break" lang="">better solution.</span></p>
			<p lang="en-GB">In this chapter, we will cover the following <span class="No-Break" lang="">main topics:</span></p>
			<ul>
				<li lang="en-GB">The problem with the <span class="No-Break" lang="">current confirmations</span></li>
				<li lang="en-GB">How to simplify <span class="No-Break" lang="">string confirmations</span></li>
				<li lang="en-GB">Enhancing the unit test library to support <span class="No-Break" lang="">Hamcrest-style confirmations</span></li>
				<li lang="en-GB">Adding more Hamcrest <span class="No-Break" lang="">matcher types</span></li>
			</ul>
			<h1 id="_idParaDest-117" lang="en-GB"><a id="_idTextAnchor125"/>Technical requirements</h1>
			<p lang="en-GB">All code in this chapter uses standard C++ that builds on any modern C++ 20 or later compiler and standard library. The code is based on and continues enhancing the testing library from <em class="italic" lang="">Part 1</em>, <em class="italic" lang="">Testing MVP</em>, of <span class="No-Break" lang="">this book.</span></p>
			<p lang="en-GB">You can find all the code for this chapter in the following <span class="No-Break" lang="">GitHub repository:</span></p>
			<p lang="en-GB"><a href="https://github.com/PacktPublishing/Test-Driven-Development-with-CPP"><span class="No-Break" lang="">https://github.com/PacktPublishing/Test-Driven-Development-with-CPP</span></a></p>
			<h1 id="_idParaDest-118" lang="en-GB"><a id="_idTextAnchor126"/>The problem with the current confirmations</h1>
			<p lang="en-GB">Before we begin<a id="_idIndexMarker456"/> making changes, we should have some idea of why. TDD is all about the customer experience. How can we design something that is easy and intuitive to use? Let’s start by taking a look at a couple of <span class="No-Break" lang="">existing tests:</span></p>
			<pre class="source-code" lang="en-GB">
TEST("Test string and string literal confirms")
{
    std::string result = "abc";
    CONFIRM("abc", result);
}
TEST("Test float confirms")
{
    float f1 = 0.1f;
    float f2 = 0.2f;
    float sum = f1 + f2;
    float expected = 0.3f;
    CONFIRM(expected, sum);
}</pre>
			<p lang="en-GB">These tests have served well and are easy, right? What we’re looking at here is not the tests themselves but the confirmations. This style <a id="_idIndexMarker457"/>of confirmation is called the <span class="No-Break" lang=""><em class="italic" lang="">classic style</em></span><span class="No-Break" lang="">.</span></p>
			<p lang="en-GB">How would we speak or read aloud the first confirmation? It might go like this: “<em class="italic" lang="">Confirm the expected value of abc matches the value </em><span class="No-Break" lang=""><em class="italic" lang="">of result</em></span><span class="No-Break" lang="">.”</span></p>
			<p lang="en-GB">That’s not too bad, but it’s a bit awkward. That’s not how a person would normally talk. Without looking at any code, a more natural way to say the same thing would be: “<em class="italic" lang="">Confirm that result </em><span class="No-Break" lang=""><em class="italic" lang="">equals abc</em></span><span class="No-Break" lang="">.”</span></p>
			<p lang="en-GB">At first glance, maybe all we need to do is reverse the order of the parameters and put the actual value first followed by the expected value. But there’s a piece missing. How do we know that a confirmation is checking for equality? We know because that’s the only thing the existing <strong class="source-inline" lang="">confirm</strong> functions know how to check. Also, that means the <strong class="source-inline" lang="">CONFIRM</strong> macro only knows how to check for <span class="No-Break" lang="">equality, too.</span></p>
			<p lang="en-GB">We have a better solution for bool values because we created special <strong class="source-inline" lang="">CONFIRM_TRUE</strong> and <strong class="source-inline" lang="">CONFIRM_FALSE</strong> macros that are easy to use and understand. And because the bool versions only take a single parameter, there’s no question of expected versus <span class="No-Break" lang="">actual ordering.</span></p>
			<p lang="en-GB">There’s a better solution that aligns with the more natural way we would speak about a confirmation. The better <a id="_idIndexMarker458"/>solution uses something called matchers and is referred <a id="_idIndexMarker459"/>to as the <em class="italic" lang="">Hamcrest style</em>. The name “Hamcrest” is just a reordering of the letters in the word “matchers.” Here is what a test would look like written in the <span class="No-Break" lang="">Hamcrest style:</span></p>
			<pre class="source-code" lang="en-GB">
TEST("Test can use hamcrest style confirm")
{
    int ten = 10;
    CONFIRM_THAT(ten, Equals(10));
}</pre>
			<p lang="en-GB">We’re not really designing the Hamcrest style in this book. The style already exists and is common in other testing libraries. And the main reason the testing library in this book puts the expected value first followed by the actual value for the classical style is to follow the common practice of the <span class="No-Break" lang="">classical style.</span></p>
			<p lang="en-GB">Imagine you were to reinvent a better light switch. And I’ve been in buildings that have tried. The light switch might actually be better in some way. But if it doesn’t follow normal expectations, then people will <span class="No-Break" lang="">get confused.</span></p>
			<p lang="en-GB">The same is true of the classical confirmations we started with in this book. I could have designed the confirmations to put the actual value first and maybe that would be better. But it would be unexpected for anybody who is even a little familiar with the existing <span class="No-Break" lang="">testing libraries.</span></p>
			<p lang="en-GB">This brings up a great point to consider when creating designs using TDD. Sometimes, an inferior solution is better when that’s what the customer expects. Remember that whatever we design should be easy and intuitive to use. The goal is not to make the ultimate and most modern design but to make something that the user will be <span class="No-Break" lang="">happy with.</span></p>
			<p lang="en-GB">This is why Hamcrest matchers work. The design doesn’t just switch the order of the expected and actual values because switching the order by itself would only <span class="No-Break" lang="">confuse users.</span></p>
			<p lang="en-GB">Hamcrest works well because something else was added: the matcher. Notice the <strong class="source-inline" lang="">Equals(10)</strong> part of the confirmation. <strong class="source-inline" lang="">Equals</strong> is a matcher that makes it clear what the confirmation is doing. The matcher, together with a more intuitive ordering, gives a solution enough benefits to overcome the natural reluctance people have with switching to a new way of doing things. The Hamcrest style is not just a better light switch. Hamcrest is different enough and provides enough value that it avoids the confusion of a slightly<a id="_idIndexMarker460"/> better but <span class="No-Break" lang="">different solution.</span></p>
			<p lang="en-GB">Also, notice that the name of the macro has changed from <strong class="source-inline" lang="">CONFIRM</strong> to <strong class="source-inline" lang="">CONFIRM_THAT</strong>. The name change is another way to avoid confusion and lets users continue to use the older classical style or opt for the newer <span class="No-Break" lang="">Hamcrest style.</span></p>
			<p lang="en-GB">Now that we have a place to specify something such as <strong class="source-inline" lang="">Equals</strong>, we can also use different matchers such as <strong class="source-inline" lang="">GreaterThan</strong> or <strong class="source-inline" lang="">BeginsWith</strong>. Imagine that you wanted to confirm that some text begins with some expected characters. How would you write a test like that using classical confirmations? You would have to check for the beginning text outside of the confirmation and then confirm the result of the check. With the Hamcrest style and an appropriate matcher, you can confirm the text with a single-line confirmation. And you get the benefit of a more readable confirmation that makes it clear what is <span class="No-Break" lang="">being confirmed.</span></p>
			<p lang="en-GB">What if you can’t find a matcher that fits your needs? You can always write your own to do exactly what you need. So, Hamcrest <span class="No-Break" lang="">is extensible.</span></p>
			<p lang="en-GB">Before diving into the new Hamcrest design, the next section will take a slight detour to explain an improvement to the existing classic <strong class="source-inline" lang="">confirm</strong> template function. This improvement will be used in the Hamcrest design, so understanding the improvement first will help later when we get to the Hamcrest <span class="No-Break" lang="">code explanations.</span></p>
			<h1 id="_idParaDest-119" lang="en-GB"><a id="_idTextAnchor127"/>Simplifying string confirmations</h1>
			<p lang="en-GB">While I was writing the code for this <a id="_idIndexMarker461"/>chapter, I ran into a problem confirming string data types that reminded me of how we added support for confirming strings in <a href="B18567_05.xhtml#_idTextAnchor045"><span class="No-Break" lang=""><em class="italic" lang="">Chapter 5</em></span></a><em class="italic" lang="">, Adding More Confirm Types</em>. The motivating factor from <a href="B18567_05.xhtml#_idTextAnchor045"><span class="No-Break" lang=""><em class="italic" lang="">Chapter 5</em></span></a> was to get the code to compile because we can’t pass <strong class="source-inline" lang="">std::string</strong> to a <strong class="source-inline" lang="">std::to_string</strong> function. I’ll briefly explain the problem <span class="No-Break" lang="">again here.</span></p>
			<p lang="en-GB">I’m not sure of the exact reasons, but I think that the C++ standard library designers felt there was no need to provide an overload of <strong class="source-inline" lang="">std::to_string</strong> that accepts <strong class="source-inline" lang="">std::string</strong> because no conversion is needed. A string is already a string! Why convert something into what it <span class="No-Break" lang="">already is?</span></p>
			<p lang="en-GB">Maybe this decision was<a id="_idIndexMarker462"/> on purpose or maybe it was an oversight. But it sure would have helped to have a string conversion into a string for template functions that need to convert their generic types into strings. That’s because, without the overload, we have to take extra steps to avoid compile errors. What we need is a <strong class="source-inline" lang="">to_string</strong> function that can convert any type into a string even if the type is already a string. If we had this ability to always be able to convert types into strings, then a template wouldn’t need to be specialized <span class="No-Break" lang="">for strings.</span></p>
			<p lang="en-GB">In <a href="B18567_05.xhtml#_idTextAnchor045"><span class="No-Break" lang=""><em class="italic" lang="">Chapter 5</em></span></a>, we introduced <span class="No-Break" lang="">this template:</span></p>
			<pre class="source-code" lang="en-GB">
template &lt;typename T&gt;
void confirm (
    T const &amp; expected,
    T const &amp; actual,
    int line)
{
    if (actual != expected)
    {
        throw ActualConfirmException(
            std::to_string(expected),
            std::to_string(actual),
            line);
    }
}</pre>
			<p lang="en-GB">The <strong class="source-inline" lang="">confirm</strong> function accepts two templatized parameters, called <strong class="source-inline" lang="">expected</strong> and <strong class="source-inline" lang="">actual</strong>, that are compared for equality. If they are not equal, then the function passes both parameters to an exception that gets thrown. The parameters need to be converted into strings, as needed, by the <span class="No-Break" lang=""><strong class="source-inline" lang="">ActualConfirmException</strong></span><span class="No-Break" lang=""> constructor.</span></p>
			<p lang="en-GB">This is where we run into a problem. If the <strong class="source-inline" lang="">confirm</strong> template function is called with strings, then it doesn’t compile because strings can’t be converted into strings by <span class="No-Break" lang="">calling </span><span class="No-Break" lang=""><strong class="source-inline" lang="">std::to_string</strong></span><span class="No-Break" lang="">.</span></p>
			<p lang="en-GB">The solution we went with in <a href="B18567_05.xhtml#_idTextAnchor045"><span class="No-Break" lang=""><em class="italic" lang="">Chapter 5</em></span></a> was to overload the <strong class="source-inline" lang="">confirm</strong> function with a non-template version that directly accepted strings. We actually created two overloads, one for strings and one for string views. This solved the problem but left us with the following two <span class="No-Break" lang="">additional </span><span class="No-Break" lang=""><a id="_idIndexMarker463"/></span><span class="No-Break" lang="">overloads:</span></p>
			<pre class="source-code" lang="en-GB">
inline void confirm (
    std::string_view expected,
    std::string_view actual,
    int line)
{
    if (actual != expected)
    {
        throw ActualConfirmException(
            expected,
            actual,
            line);
    }
}
inline void confirm (
    std::string const &amp; expected,
    std::string const &amp; actual,
    int line)
{
    confirm(
        std::string_view(expected),
        std::string_view(actual),
        line);
}</pre>
			<p lang="en-GB">When calling <strong class="source-inline" lang="">confirm</strong> with strings, these overloads are used instead of the template. The version that accepts <strong class="source-inline" lang="">std::string</strong> types calls into the version that takes <strong class="source-inline" lang="">std::string_view</strong> types, which uses the <strong class="source-inline" lang="">expected</strong> and <strong class="source-inline" lang="">actual</strong> parameters directly without trying to <span class="No-Break" lang="">call </span><span class="No-Break" lang=""><strong class="source-inline" lang="">std::to_string</strong></span><span class="No-Break" lang="">.</span></p>
			<p lang="en-GB">At the time, this wasn’t such a bad solution because we already had extra overloads of <strong class="source-inline" lang="">confirm</strong> for bools and the various floating point types. Two more overloads for strings was okay. Later, you’ll see how a small change will let us remove these two <span class="No-Break" lang="">string overloads.</span></p>
			<p lang="en-GB">And now we come back to the problem of converting string data types with the new Hamcrest design we’ll be working on in this chapter. We will no longer need extra overloads of <strong class="source-inline" lang="">confirm</strong> even for bool or floating point types. As I was working on a new solution, I came back to the earlier solution from <a href="B18567_05.xhtml#_idTextAnchor045"><span class="No-Break" lang=""><em class="italic" lang="">Chapter 5</em></span></a> and decided to refactor the existing classic confirms so that both solutions would <span class="No-Break" lang="">be similar.</span></p>
			<p lang="en-GB">We’ll get into the new design later in this chapter. But so that we don’t have to interrupt that explanation, I have decided to take the detour now and explain how to remove the need for the string and string view overloads of the classic <strong class="source-inline" lang="">confirm</strong> function. Going through the explanation now should also make it easier to understand the new Hamcrest design since you’ll already be familiar with this part of <span class="No-Break" lang="">the solution.</span></p>
			<p lang="en-GB">Also, I’d like to add that TDD helps with this type of refactoring. Because we already have existing tests for the <a id="_idIndexMarker464"/>classic confirms, we can remove the string overloads of <strong class="source-inline" lang="">confirm</strong> and make sure that all the tests continue to pass. I’ve worked on projects before where only the new code would use the better solution and we would have to leave the existing code unchanged in order to avoid introducing bugs. Doing this just makes the code harder to maintain because now there would be two different solutions in the same project. Having good tests helps give you the confidence needed to change <span class="No-Break" lang="">existing code.</span></p>
			<p lang="en-GB">Okay, the core of the problem is that the C++ standard library does not include overloads of <strong class="source-inline" lang="">to_string</strong> that work with strings. And while it might be tempting to just add our own version of <strong class="source-inline" lang="">to_string</strong> to the <strong class="source-inline" lang="">std</strong> namespace, this is not allowed. It would probably work, and I’m sure that lots of people have done this. But it’s technically undefined behavior to add any function into the <strong class="source-inline" lang="">std</strong> namespace. There are very specific cases where we are allowed to add something into the <strong class="source-inline" lang="">std</strong> namespace, and unfortunately, this is not one of the allowed exceptions to <span class="No-Break" lang="">the rules.</span></p>
			<p lang="en-GB">We will need our own version of <strong class="source-inline" lang="">to_string</strong>. We just can’t put our version in the <strong class="source-inline" lang="">std</strong> namespace. That’s a problem because when we call <strong class="source-inline" lang="">to_string</strong>, we currently specify the namespace by calling <strong class="source-inline" lang="">std::to_string</strong>. What we need to do is simply call <strong class="source-inline" lang="">to_string</strong> without any namespace and let the compiler look in either the <strong class="source-inline" lang="">std</strong> namespace to find the versions of <strong class="source-inline" lang="">to_string</strong> that work with numeric types, or look in our namespace to find our new version that works with strings. The new <strong class="source-inline" lang="">to_string</strong> function and the modified <strong class="source-inline" lang="">confirm</strong> template function look <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
inline std::string to_string (std::string const &amp; str)
{
    return str;
}
template &lt;typename ExpectedT, typename ActualT&gt;
void confirm (
    ExpectedT const &amp; expected,
    ActualT const &amp; actual,
    int line)
{
    using std::to_string;
    using MereTDD::to_string;
    if (actual != expected)
    {
        throw ActualConfirmException(
            to_string(expected),
            to_string(actual),
            line);
    }
}</pre>
			<p lang="en-GB">We can remove the two overloads of <strong class="source-inline" lang="">confirm</strong> that take string views and strings. Now, the <strong class="source-inline" lang="">confirm</strong> template function will work <span class="No-Break" lang="">for strings.</span></p>
			<p lang="en-GB">With the new <strong class="source-inline" lang="">to_string</strong> function<a id="_idIndexMarker465"/> that accepts <strong class="source-inline" lang="">std::string</strong>, all it needs to do is return the same string. We don’t really need another <strong class="source-inline" lang="">to_string</strong> function that works with <span class="No-Break" lang="">string views.</span></p>
			<p lang="en-GB">The <strong class="source-inline" lang="">confirm</strong> template function is a little more complicated because it now needs two types, <strong class="source-inline" lang="">ExpectedT</strong> and <strong class="source-inline" lang="">ActualT</strong>. The two types are needed for those cases when we need to compare a string literal with a string, such as in the <span class="No-Break" lang="">following test:</span></p>
			<pre class="source-code" lang="en-GB">
TEST("Test string and string literal confirms")
{
    std::string result = "abc";
    CONFIRM("abc", result);
}</pre>
			<p lang="en-GB">The reason this test used to compile when we had only a single <strong class="source-inline" lang="">confirm</strong> template parameter is that it wasn’t calling into the template. The compiler was converting the <strong class="source-inline" lang="">"abc"</strong> string literal into a string and calling the overload of <strong class="source-inline" lang="">confirm</strong> that accepted two strings. Or maybe it was converting both the string literal and the string into string views and calling the overload of <strong class="source-inline" lang="">confirm</strong> that accepted two string views. Either way, because we had separate overloads of <strong class="source-inline" lang="">confirm</strong>, the compiler was able to make <span class="No-Break" lang="">it work.</span></p>
			<p lang="en-GB">Now that we removed both <strong class="source-inline" lang="">confirm</strong> overloads that deal with strings, we have only the template, and we need to let it accept different types in order to compile. I know, we still have overloads for bool and the floating point types. I’m only talking about the string overloads that we <span class="No-Break" lang="">can remove.</span></p>
			<p lang="en-GB">In the new template, you can see that we call <strong class="source-inline" lang="">to_string</strong> without any namespace specification. The compiler is able to find the versions of <strong class="source-inline" lang="">to_string</strong> it needs because of the two using statements inside the template function. The first using statement tells the compiler that it should consider all the <strong class="source-inline" lang="">to_string</strong> overloads in the <strong class="source-inline" lang="">std</strong> namespace. And the second using statement tells the compiler to also consider any <strong class="source-inline" lang="">to_string</strong> functions it finds in the <span class="No-Break" lang=""><strong class="source-inline" lang="">MereTDD</strong></span><span class="No-Break" lang=""> namespace.</span></p>
			<p lang="en-GB">The compiler is now able to <a id="_idIndexMarker466"/>find a version of <strong class="source-inline" lang="">to_string</strong> that works with the numeric types when <strong class="source-inline" lang="">confirm</strong> is called with numeric types. And the compiler can find our new <strong class="source-inline" lang="">to_string</strong> function that works with strings when needed. We no longer need to limit the compiler to only look in the <span class="No-Break" lang=""><strong class="source-inline" lang="">std</strong></span><span class="No-Break" lang=""> namespace.</span></p>
			<p lang="en-GB">Now we can go back to the new Hamcrest style design, which we will do in the next section. The Hamcrest design will, eventually, use a solution similar to what was just <span class="No-Break" lang="">described here.</span></p>
			<h1 id="_idParaDest-120" lang="en-GB"><a id="_idTextAnchor128"/>Enhancing the test library to support Hamcrest matchers</h1>
			<p lang="en-GB">Once you get a basic implementation<a id="_idIndexMarker467"/> working and passing<a id="_idIndexMarker468"/> the tests, TDD guides us to enhance the design by creating more tests and then getting the new tests to pass. That’s exactly what this chapter is all about. We’re enhancing the classic style confirmations to support the <span class="No-Break" lang="">Hamcrest style.</span></p>
			<p lang="en-GB">Let’s start by creating a new file, called <strong class="source-inline" lang="">Hamcrest.cpp</strong>, in the <strong class="source-inline" lang="">tests</strong> folder. Now, the overall project structure should look <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
MereTDD project root folder
    Test.h
    tests folder
        main.cpp
        Confirm.cpp
        Creation.cpp
        Hamcrest.cpp
        Setup.cpp</pre>
			<p lang="en-GB">If you’ve been following all the code in this book so far, remember that we’re going back to the <em class="italic" lang="">MereTDD</em> project that we last worked on in <a href="B18567_07.xhtml#_idTextAnchor065"><span class="No-Break" lang=""><em class="italic" lang="">Chapter 7</em></span></a>, <em class="italic" lang="">Test Setup and Teardown</em>. This is not the <em class="italic" lang="">MereMemo</em> <span class="No-Break" lang="">logging project.</span></p>
			<p lang="en-GB">The Hamcrest style test that we need to support goes inside <strong class="source-inline" lang="">Hamcrest.cpp</strong> so that the new file looks <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
#include "../Test.h"
TEST("Test can use hamcrest style confirm")
{
    int ten = 10;
    CONFIRM_THAT(ten, Equals(10));
}</pre>
			<p lang="en-GB">We might as well start <a id="_idIndexMarker469"/>with the new <strong class="source-inline" lang="">CONFIRM_THAT</strong> macro, which goes at the end of <strong class="source-inline" lang="">Test.h</strong> right after the other <strong class="source-inline" lang="">CONFIRM</strong> macros, <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
#define CONFIRM_FALSE( actual ) \
    MereTDD::confirm(false, actual, __LINE__)
#define CONFIRM_TRUE( actual ) \
    MereTDD::confirm(true, actual, __LINE__)
#define CONFIRM( expected, actual ) \
    MereTDD::confirm(expected, actual, __LINE__)
#define CONFIRM_THAT( actual, matcher ) \
    MereTDD::confirm_that(actual, matcher, __LINE__)</pre>
			<p lang="en-GB">The <strong class="source-inline" lang="">CONFIRM_THAT</strong> macro is similar to the <strong class="source-inline" lang="">CONFIRM</strong> macro except that the <strong class="source-inline" lang="">actual</strong> parameter comes first, and instead of an <strong class="source-inline" lang="">expected</strong> parameter, we have a parameter called <strong class="source-inline" lang="">matcher</strong>. We’ll also call a new function called <strong class="source-inline" lang="">confirm_that</strong>. The new function helps make it simpler to keep the classic style <strong class="source-inline" lang="">confirm</strong> overloads separate from the Hamcrest-style <span class="No-Break" lang=""><strong class="source-inline" lang="">confirm_that</strong></span><span class="No-Break" lang=""> function.</span></p>
			<p lang="en-GB">We don’t need all the overloads in the same way that we needed for <strong class="source-inline" lang="">confirm</strong>. The <strong class="source-inline" lang="">confirm_that</strong> function can be implemented with a single template function. Place this new template in <strong class="source-inline" lang="">Test.h</strong> right after the classic <strong class="source-inline" lang="">confirm</strong> template function. Both template functions should look <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
template &lt;typename ExpectedT, typename ActualT&gt;
void confirm (
    ExpectedT const &amp; expected,
    ActualT const &amp; actual,
    int line)
{
    using std::to_string;
    using MereTDD::to_string;
    if (actual != expected)
    {
        throw ActualConfirmException(
            to_string(expected),
            to_string(actual),
            line);
    }
}
template &lt;typename ActualT, typename MatcherT&gt;
inline void confirm_that (
    ActualT const &amp; actual,
    MatcherT const &amp; matcher,
    int line)
{
    using std::to_string;
    using MereTDD::to_string;
    if (not matcher.pass(actual))
    {
        throw ActualConfirmException(
            to_string(matcher),
            to_string(actual),
            line);
    }
}</pre>
			<p lang="en-GB">We’re only adding the <strong class="source-inline" lang="">confirm_that</strong> function. I decided to show both functions so that you can see the differences easier. Notice that now, the <strong class="source-inline" lang="">ActualT</strong> type is given first. The order doesn’t really <a id="_idIndexMarker470"/>matter, but I like to put the template <a id="_idIndexMarker471"/>parameters in a reasonable order. We no longer have an <strong class="source-inline" lang="">ExpectedT</strong> type; instead, we have a <span class="No-Break" lang=""><strong class="source-inline" lang="">MatcherT</strong></span><span class="No-Break" lang=""> type.</span></p>
			<p lang="en-GB">The name of the new template function is different too, so there is no ambiguity due to the similar template parameters. The new template function is <span class="No-Break" lang="">called </span><span class="No-Break" lang=""><strong class="source-inline" lang="">confirm_that</strong></span><span class="No-Break" lang="">.</span></p>
			<p lang="en-GB">While the classic <strong class="source-inline" lang="">confirm</strong> function compares the <strong class="source-inline" lang="">actual</strong> parameter directly with the <strong class="source-inline" lang="">expected</strong> parameter, the new <strong class="source-inline" lang="">confirm_that</strong> function calls into a <strong class="source-inline" lang="">pass</strong> method on the <strong class="source-inline" lang="">matcher</strong> to perform the check. We don’t really know what the <strong class="source-inline" lang="">matcher</strong> will be doing in the <strong class="source-inline" lang="">pass</strong> method because that is for the <strong class="source-inline" lang="">matcher</strong> to decide. And because any changes in the comparison from one type to another are wrapped up in the <strong class="source-inline" lang="">matcher</strong>, we don’t need to overload the <strong class="source-inline" lang="">confirm_that</strong> function like we had to do for the classic <strong class="source-inline" lang="">confirm</strong> function. We’ll still need a special code, but the differences will be handled by the <strong class="source-inline" lang="">matcher</strong> in <span class="No-Break" lang="">this design.</span></p>
			<p lang="en-GB">This is where I realized that there needs to be a different solution for converting the <strong class="source-inline" lang="">matcher</strong> and <strong class="source-inline" lang="">actual</strong> parameters into strings. It seems pointless to override <strong class="source-inline" lang="">confirm_that</strong> just to avoid calling <strong class="source-inline" lang="">to_string</strong> when the type of <strong class="source-inline" lang="">ActualT</strong> is a string. So, I stopped calling <strong class="source-inline" lang="">std::to_string(actual)</strong> and instead started calling <strong class="source-inline" lang="">to_string(actual)</strong>. In order for the compiler to find the necessary <strong class="source-inline" lang="">to_string</strong> functions, the using statements<a id="_idIndexMarker472"/> are needed. This is<a id="_idIndexMarker473"/> the explanation that the previous section describes for simplifying the <span class="No-Break" lang="">string comparisons.</span></p>
			<p lang="en-GB">Now that we have the <strong class="source-inline" lang="">confirm_that</strong> template, we can focus on the <strong class="source-inline" lang="">matcher</strong>. We need to be able to call a <strong class="source-inline" lang="">pass</strong> method and convert a <strong class="source-inline" lang="">matcher</strong> into a string. Let’s create a base class for all the matchers to inherit from, so they will all have a common interface. Place this base class and <strong class="source-inline" lang="">to_string</strong> function right after the <strong class="source-inline" lang="">confirm_that</strong> function in <strong class="source-inline" lang="">Test.h</strong>, <span class="No-Break" lang="">as follows:</span></p>
			<pre class="source-code" lang="en-GB">
class Matcher
{
public:
    virtual ~Matcher () = default;
    Matcher (Matcher const &amp; other) = delete;
    Matcher (Matcher &amp;&amp; other) = delete;
    virtual std::string to_string () const = 0;
    Matcher &amp; operator = (Matcher const &amp; rhs) = delete;
    Matcher &amp; operator = (Matcher &amp;&amp; rhs) = delete;
protected:
    Matcher () = default;
};
inline std::string to_string (Matcher const &amp; matcher)
{
    return matcher.to_string();
}</pre>
			<p lang="en-GB">The <strong class="source-inline" lang="">to_string</strong> function will let us convert a matcher into a string by calling the virtual <strong class="source-inline" lang="">to_string</strong> method in the <strong class="source-inline" lang="">Matcher</strong> base class. Notice there is no <strong class="source-inline" lang="">pass</strong> method in the <span class="No-Break" lang=""><strong class="source-inline" lang="">Matcher</strong></span><span class="No-Break" lang=""> class.</span></p>
			<p lang="en-GB">The <strong class="source-inline" lang="">Matcher</strong> class itself is a base class that doesn’t need to be copied or assigned. The only common interface the <strong class="source-inline" lang="">Matcher</strong> class defines is a <strong class="source-inline" lang="">to_string</strong> method that all matchers will implement to convert themselves into a string that can be sent to the test run <span class="No-Break" lang="">summary report.</span></p>
			<p lang="en-GB">What happened to the <strong class="source-inline" lang="">pass</strong> method? Well, the <strong class="source-inline" lang="">pass</strong> method needs to accept the actual type that will be used to determine whether the actual value matches the expected value. The expected <a id="_idIndexMarker474"/>value itself will be<a id="_idIndexMarker475"/> held in the derived matcher class. The actual value will be passed to the <span class="No-Break" lang=""><strong class="source-inline" lang="">pass</strong></span><span class="No-Break" lang=""> method.</span></p>
			<p lang="en-GB">The types of values accepted for the actual and expected values will be fully under the control of the derived matcher class. Because the types can change from one usage of a matcher to another, we can’t define a <strong class="source-inline" lang="">pass</strong> method in the <strong class="source-inline" lang="">Matcher</strong> base class. This is okay because the <strong class="source-inline" lang="">confirm_that</strong> template doesn’t work with the <strong class="source-inline" lang="">Matcher</strong> base class. The <strong class="source-inline" lang="">confirm_that</strong> template will have knowledge of the real matcher-derived class and can call the <strong class="source-inline" lang="">pass</strong> method directly as a <span class="No-Break" lang="">non-virtual method.</span></p>
			<p lang="en-GB">The <strong class="source-inline" lang="">to_string</strong> method is different because we want to call the virtual <strong class="source-inline" lang="">Matcher::to_string</strong> method from within the <strong class="source-inline" lang="">to_string</strong> helper function that accepts any <span class="No-Break" lang=""><strong class="source-inline" lang="">Matcher</strong></span><span class="No-Break" lang=""> reference.</span></p>
			<p lang="en-GB">So, when converting a matcher into a string, we treat all matchers the same and go through the virtual <strong class="source-inline" lang="">to_string</strong> method. And when calling <strong class="source-inline" lang="">pass</strong>, we work directly with the real matcher class and call <span class="No-Break" lang=""><strong class="source-inline" lang="">pass</strong></span><span class="No-Break" lang=""> directly.</span></p>
			<p lang="en-GB">Let’s see what a real matcher class will look like. The test we are implementing uses a matcher called <strong class="source-inline" lang="">Equals</strong>. We can create the derived <strong class="source-inline" lang="">Equals</strong> class right after the <strong class="source-inline" lang="">Matcher</strong> class and the <strong class="source-inline" lang="">to_string</strong> function, <span class="No-Break" lang="">as follows:</span></p>
			<pre class="source-code" lang="en-GB">
template &lt;typename T&gt;
class Equals : public Matcher
{
public:
    Equals (T const &amp; expected)
    : mExpected(expected)
    { }
    bool pass (T const &amp; actual) const
    {
        return actual == mExpected;
    }
    std::string to_string () const override
    {
        using std::to_string;
        using MereTDD::to_string;
        return to_string(mExpected);
    }
private:
    T mExpected;
};</pre>
			<p lang="en-GB">The <strong class="source-inline" lang="">Equals</strong> class is another template because it needs to hold the proper expected value type, and it needs to use <a id="_idIndexMarker476"/>the same type in the <strong class="source-inline" lang="">pass</strong> method for the <span class="No-Break" lang=""><strong class="source-inline" lang="">actual</strong></span><span class="No-Break" lang=""> parameter.</span></p>
			<p lang="en-GB">Notice that the <strong class="source-inline" lang="">to_string</strong> override method uses the same solution to convert the <strong class="source-inline" lang="">mExpected</strong> data member into a <a id="_idIndexMarker477"/>string that we’ve been using. We call <strong class="source-inline" lang="">to_string</strong> and let the compiler find an appropriate match in either the <strong class="source-inline" lang="">std</strong> or <span class="No-Break" lang=""><strong class="source-inline" lang="">MereTDD</strong></span><span class="No-Break" lang=""> namespaces.</span></p>
			<p lang="en-GB">We need one more small change to get everything working. In our Hamcrest test, we use the <strong class="source-inline" lang="">Equals</strong> matcher without any namespace specification. We could refer to it as <strong class="source-inline" lang="">MereTDD::Equals</strong>. But the namespace specification distracts from the readability of the tests. Let’s add a <strong class="source-inline" lang="">using namespace MereTDD</strong> statement to the top of any test file that will use Hamcrest matchers so we can refer to them directly, <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
#include "../Test.h"
using namespace MereTDD;
TEST("Test can use hamcrest style confirm")
{
    int ten = 10;
    CONFIRM_THAT(ten, Equals(10));
}</pre>
			<p lang="en-GB">That’s everything needed to support our first Hamcrest matcher unit test – building and running show that all tests pass. What about an expected failure? First, let’s create a new test <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
TEST("Test hamcrest style confirm failure")
{
    int ten = 10;
    CONFIRM_THAT(ten, Equals(9));
}</pre>
			<p lang="en-GB">This test is designed to fail because <strong class="source-inline" lang="">10</strong> will not equal <strong class="source-inline" lang="">9</strong>. We need to build and run once just to get the failure message from the summary report. Then, we can add a call to <strong class="source-inline" lang="">setExpectedFailureReason</strong> with the exactly formatted failure message. Remember that the failure message<a id="_idIndexMarker478"/> needs to match exactly, including all the spaces and punctuation. I know this can be tedious, but it should not be a test that you need to worry about unless you’re <a id="_idIndexMarker479"/>testing one of your own custom matchers to make sure the custom matcher is able to format a proper <span class="No-Break" lang="">error message.</span></p>
			<p lang="en-GB">After getting the exact error message, we can modify the test to turn it into an expected failure, <span class="No-Break" lang="">as follows:</span></p>
			<pre class="source-code" lang="en-GB">
TEST("Test hamcrest style confirm failure")
{
    std::string reason = "    Expected: 9\n";
    reason += "    Actual  : 10";
    setExpectedFailureReason(reason);
    int ten = 10;
    CONFIRM_THAT(ten, Equals(9));
}</pre>
			<p lang="en-GB">Building and running again shows both Hamcrest tests results, <span class="No-Break" lang="">as follows:</span></p>
			<pre class="source-code" lang="en-GB">
<strong class="bold" lang="">------- Test: Test can use hamcrest style confirm</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: Test hamcrest style confirm failure</strong>
<strong class="bold" lang="">Expected failure</strong>
<strong class="bold" lang="">    Expected: 9</strong>
<strong class="bold" lang="">    Actual  : 10</strong></pre>
			<p lang="en-GB">This is a good start. We haven’t yet started talking about how to design custom matchers. Before we start custom matchers, what about other basic types? We only have a couple of Hamcrest tests that compare int values. The next section will explore other basic types and add <span class="No-Break" lang="">more tests.</span></p>
			<h1 id="_idParaDest-121" lang="en-GB"><a id="_idTextAnchor129"/>Adding more Hamcrest types</h1>
			<p lang="en-GB">There is a pattern to using TDD that you should be familiar with by now. We add a little bit of something, get it working, and then <a id="_idIndexMarker480"/>add more. We have the ability to confirm int values with a Hamcrest <strong class="source-inline" lang="">Equals</strong> matcher. Now it’s time to add more types. Some of these types might work without any extra work due to the template <strong class="source-inline" lang="">confirm_that</strong> function. Other types might need changes. We’ll find out what needs to be done by writing <span class="No-Break" lang="">some tests.</span></p>
			<p lang="en-GB">The first test ensures that the other integer types work as expected. Add this test <span class="No-Break" lang="">to </span><span class="No-Break" lang=""><strong class="source-inline" lang="">Hamcrest.cpp</strong></span><span class="No-Break" lang="">:</span></p>
			<pre class="source-code" lang="en-GB">
TEST("Test other hamcrest style integer confirms")
{
    char c1 = 'A';
    char c2 = 'A';
    CONFIRM_THAT(c1, Equals(c2));
    CONFIRM_THAT(c1, Equals('A'));
    short s1 = 10;
    short s2 = 10;
    CONFIRM_THAT(s1, Equals(s2));
    CONFIRM_THAT(s1, Equals(10));
    unsigned int ui1 = 3'000'000'000;
    unsigned int ui2 = 3'000'000'000;
    CONFIRM_THAT(ui1, Equals(ui2));
    CONFIRM_THAT(ui1, Equals(3'000'000'000));
    long long ll1 = 5'000'000'000'000LL;
    long long ll2 = 5'000'000'000'000LL;
    CONFIRM_THAT(ll1, Equals(ll2));
    CONFIRM_THAT(ll1, Equals(5'000'000'000'000LL));
}</pre>
			<p lang="en-GB">First, the test declares a couple of chars and uses the <strong class="source-inline" lang="">Equals</strong> matcher in a couple of different ways. The first is to test for equality with another char. The second uses a char literal value, <strong class="source-inline" lang="">'A'</strong>, for <span class="No-Break" lang="">the comparison.</span></p>
			<p lang="en-GB">The second set of confirmations is based on short ints. We use the <strong class="source-inline" lang="">Equals</strong> matcher with another short int and then an int literal value of <strong class="source-inline" lang="">10</strong> for <span class="No-Break" lang="">the comparison.</span></p>
			<p lang="en-GB">The third set of confirmations is based on unsigned ints and, again, tries to use the <strong class="source-inline" lang="">Equals</strong> matcher with another variable of the same type and with a <span class="No-Break" lang="">literal int.</span></p>
			<p lang="en-GB">The fourth set of confirmations makes sure that long long types <span class="No-Break" lang="">are supported.</span></p>
			<p lang="en-GB">We’re not creating helper functions designed to simulate other software being tested. You already know how to use confirmations in a real project based on the tests in the logging library. That’s why this test makes things simple and just focuses on making sure that the <strong class="source-inline" lang="">CONFIRM_THAT</strong> macro, which calls the <strong class="source-inline" lang="">confirm_that</strong> template <span class="No-Break" lang="">function, works.</span></p>
			<p lang="en-GB">Building and running these tests <a id="_idIndexMarker481"/>show that all tests pass with no changes or <span class="No-Break" lang="">enhancements needed.</span></p>
			<p lang="en-GB">What about bool types? Here is a test that goes into <strong class="source-inline" lang="">Hamcrest.cpp</strong> to test <span class="No-Break" lang="">bool types:</span></p>
			<pre class="source-code" lang="en-GB">
TEST("Test hamcrest style bool confirms")
{
    bool b1 = true;
    bool b2 = true;
    CONFIRM_THAT(b1, Equals(b2));
    // This works but probably won't be used much.
    CONFIRM_THAT(b1, Equals(true));
    // When checking a bool variable for a known value,
    // the classic style is probably better.
    CONFIRM_TRUE(b1);
}</pre>
			<p lang="en-GB">This test shows that the Hamcrest style works for bool types, too. When comparing one bool variable with another, the Hamcrest style is better than the classic style. However, when comparing a bool variable with an expected true or false literal, it’s actually more readable to use the classic style because we have simplified <strong class="source-inline" lang="">CONFIRM_TRUE</strong> and <span class="No-Break" lang=""><strong class="source-inline" lang="">CONFIRM_FALSE</strong></span><span class="No-Break" lang=""> macros.</span></p>
			<p lang="en-GB">Now, let’s move on to strings with this test that goes into <strong class="source-inline" lang="">Hamcrest.cpp</strong>. Note that this test will fail to compile at first and that’s okay. The test looks <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
TEST("Test hamcrest style string confirms")
{
    std::string s1 = "abc";
    std::string s2 = "abc";
    CONFIRM_THAT(s1, Equals(s2));     // string vs. string
    CONFIRM_THAT(s1, Equals("abc"));  // string vs. literal
    CONFIRM_THAT("abc", Equals(s1));  // literal vs. string
}</pre>
			<p lang="en-GB">There are several confirms in this test, and that’s okay because they’re all related. The comments help to clarify what each confirmation <span class="No-Break" lang="">is testing.</span></p>
			<p lang="en-GB">We’re always looking for <a id="_idIndexMarker482"/>two things with a new test. The first is whether the test compiles at all. And the second is whether it passes. Right now, the test will fail to compile with an error similar to <span class="No-Break" lang="">the following:</span></p>
			<pre class="source-code" lang="en-GB">
<strong class="bold" lang="">MereTDD/tests/../Test.h: In instantiation of 'MereTDD::Equals&lt;T&gt;::Equals(const T&amp;) [with T = char [4]]':</strong>
<strong class="bold" lang="">MereTDD/tests/Hamcrest.cpp:63:5:   required from here</strong>
<strong class="bold" lang="">MereTDD/tests/../Test.h:209:7: error: array used as initializer</strong>
<strong class="bold" lang="">  209 |     : mExpected(expected)</strong>
<strong class="bold" lang="">      |       ^~~~~~~~~~~~~~~~~~~</strong></pre>
			<p lang="en-GB">You might get different line numbers, so I’ll explain what the error is referring to. The failure is in the <strong class="source-inline" lang="">Equals</strong> constructor, which looks <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
    Equals (T const &amp; expected)
    : mExpected(expected)
    { }</pre>
			<p lang="en-GB">And line 63 in <strong class="source-inline" lang="">Hamcrest.cpp</strong> is the <span class="No-Break" lang="">following line:</span></p>
			<pre class="source-code" lang="en-GB">
    CONFIRM_THAT(s1, Equals("abc"));  // string vs. literal</pre>
			<p lang="en-GB">We’re trying to construct an <strong class="source-inline" lang="">Equals</strong> matcher given the <strong class="source-inline" lang="">"abc"</strong> string literal, and this fails to compile. The reason is that the <strong class="source-inline" lang="">T</strong> type is an array that needs to be initialized in a <span class="No-Break" lang="">different manner.</span></p>
			<p lang="en-GB">What we need is a special version of <strong class="source-inline" lang="">Equals</strong> that works with string literals. Since a string literal is an array of constant chars, the following template specialization will work. Place this new template in <strong class="source-inline" lang="">Test.h</strong> right after the existing <span class="No-Break" lang=""><strong class="source-inline" lang="">Equals</strong></span><span class="No-Break" lang=""> template:</span></p>
			<pre class="source-code" lang="en-GB">
template &lt;typename T, std::size_t N&gt; requires (
    std::is_same&lt;char, std::remove_const_t&lt;T&gt;&gt;::value)
class Equals&lt;T[N]&gt; : public Matcher
{
public:
    Equals (char const (&amp; expected)[N])
    {
        memcpy(mExpected, expected, N);
    }
    bool pass (std::string const &amp; actual) const
    {
        return actual == mExpected;
    }
    std::string to_string () const override
    {
        return std::string(mExpected);
    }
private:
    char mExpected[N];
};</pre>
			<p lang="en-GB">We’ll need a couple of extra<a id="_idIndexMarker483"/> includes in <strong class="source-inline" lang="">Test.h</strong> for <strong class="source-inline" lang="">cstring</strong> and <strong class="source-inline" lang="">type_traits</strong>, <span class="No-Break" lang="">as follows:</span></p>
			<pre class="source-code" lang="en-GB">
#include &lt;cstring&gt;
#include &lt;map&gt;
#include &lt;ostream&gt;
#include &lt;string_view&gt;
#include &lt;type_traits&gt;
#include &lt;vector&gt;</pre>
			<p lang="en-GB">The template specialization uses a new C++20 feature, called <em class="italic" lang="">requires</em>, which helps us to place constraints on template parameters. The <strong class="source-inline" lang="">requires</strong> keyword is actually part of a bigger enhancement in C++20, called <em class="italic" lang="">concepts</em>. Concepts are a huge enhancement to C++ and a full explanation would be beyond the scope of this book. We’re using concepts and the <strong class="source-inline" lang="">requires</strong> keyword to simplify the template specialization to only work with strings. The template itself takes a <strong class="source-inline" lang="">T</strong> type like before and a new numeric value, <strong class="source-inline" lang="">N</strong>, which will be the size of the string literal. The requires clause makes sure that <strong class="source-inline" lang="">T</strong> is a char. We need to remove the const qualifier from <strong class="source-inline" lang="">T</strong> because string literals are <span class="No-Break" lang="">actually constant.</span></p>
			<p lang="en-GB">The <strong class="source-inline" lang="">Equals</strong> specialization then says it is an array of <strong class="source-inline" lang="">T[N]</strong>. The constructor takes a reference to an array of <strong class="source-inline" lang="">N</strong> chars, and instead of trying to directly initialize <strong class="source-inline" lang="">mExpected</strong> with the constructor’s <strong class="source-inline" lang="">expected</strong> parameter, it now calls <strong class="source-inline" lang="">memcpy</strong> to copy the chars from the literal into the <strong class="source-inline" lang="">mExpected</strong> array. The strange syntax of <strong class="source-inline" lang="">char const (&amp; expected)[N]</strong> is how C++ specifies an array as a method parameter that does not get decayed into a <span class="No-Break" lang="">simple pointer.</span></p>
			<p lang="en-GB">Now the <strong class="source-inline" lang="">pass</strong> method can take a string reference as its <strong class="source-inline" lang="">actual</strong> parameter type since we know that we are dealing with strings. Additionally, the <strong class="source-inline" lang="">to_string</strong> method can directly construct and return <strong class="source-inline" lang="">std::string</strong> from the <strong class="source-inline" lang="">mExpected</strong> <span class="No-Break" lang="">char array.</span></p>
			<p lang="en-GB">One interesting, and maybe only theoretical, benefit of the <strong class="source-inline" lang="">Equals</strong> template specialization and the <strong class="source-inline" lang="">pass</strong> method<a id="_idIndexMarker484"/> is that we can now confirm that a string literal equals another string literal. I can’t think of any place where this would be useful but it works, so we might as well add it to the test <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
TEST("Test hamcrest style string confirms")
{
    std::string s1 = "abc";
    std::string s2 = "abc";
    CONFIRM_THAT(s1, Equals(s2));       // string vs. string
    CONFIRM_THAT(s1, Equals("abc"));    // string vs. literal
    CONFIRM_THAT("abc", Equals(s1));    // literal vs. string
    // Probably not needed, but this works too.
    CONFIRM_THAT("abc", Equals("abc")); // literal vs. Literal
}</pre>
			<p lang="en-GB">What about char pointers? They’re not <a id="_idIndexMarker485"/>as common as char arrays for template parameters because char arrays come from working with string literals. A char pointer is slightly different. We should consider char pointers because while they are not as common in template parameters, a char pointer is probably more common overall than char arrays. Here is a test that demonstrates char pointers. Note that this test will not compile yet. Add this <span class="No-Break" lang="">into </span><span class="No-Break" lang=""><strong class="source-inline" lang="">Hamcrest.cpp</strong></span><span class="No-Break" lang="">:</span></p>
			<pre class="source-code" lang="en-GB">
TEST("Test hamcrest style string pointer confirms")
{
    char const * sp1 = "abc";
    std::string s1 = "abc";
    char const * sp2 = s1.c_str();    // avoid sp1 and sp2 being same
    CONFIRM_THAT(sp1, Equals(sp2));   // pointer vs. pointer
    CONFIRM_THAT(sp2, Equals("abc")); // pointer vs. literal
    CONFIRM_THAT("abc", Equals(sp2)); // literal vs. pointer
    CONFIRM_THAT(sp1, Equals(s1));    // pointer vs. string
    CONFIRM_THAT(s1, Equals(sp1));    // string vs. pointer
}</pre>
			<p lang="en-GB">We can initialize a char pointer given a string literal just like how <strong class="source-inline" lang="">std::string</strong> is initialized. But while <strong class="source-inline" lang="">std::string</strong> copies the text into its own memory to manage, a char pointer just points to the first char in the string literal. I keep saying that we’re working with char pointers. But to be<a id="_idIndexMarker486"/> more specific, we’re working with constant char pointers. The code needs to use const, but I sometimes leave const out when speaking <span class="No-Break" lang="">or writing.</span></p>
			<p lang="en-GB">The new test for the string pointer confirms the need to take extra steps to make sure that <strong class="source-inline" lang="">sp1</strong> and <strong class="source-inline" lang="">sp2</strong> point to different <span class="No-Break" lang="">memory addresses.</span></p>
			<p lang="en-GB">String literals in C++ are consolidated so that duplicate literal values all point to the same memory address. Even though a literal such as <strong class="source-inline" lang="">"abc"</strong> might be used many times in the source code, there will only be one copy of the string literal in the final executable that gets built. The test must go through extra steps to make sure that <strong class="source-inline" lang="">sp1</strong> and <strong class="source-inline" lang="">sp2</strong> have different pointer values while maintaining the same text. Whenever <strong class="source-inline" lang="">std::string</strong> is initialized with a string literal, the text of the string literal gets copied into <strong class="source-inline" lang="">std::string</strong> to manage. The <strong class="source-inline" lang="">std::string</strong> might use dynamically allocated memory or local memory on the stack. A <strong class="source-inline" lang="">std::string</strong> will not just point to the memory address used in the initialization. If we simply initialized <strong class="source-inline" lang="">sp2</strong> the same way as <strong class="source-inline" lang="">sp1</strong>, then both pointers would point to the same memory address. But by initializing <strong class="source-inline" lang="">sp2</strong> to point to the string inside <strong class="source-inline" lang="">s1</strong>, then <strong class="source-inline" lang="">sp2</strong> points to a different memory address from <strong class="source-inline" lang="">sp1</strong>. Even though <strong class="source-inline" lang="">sp1</strong> and <strong class="source-inline" lang="">sp2</strong> point to different memory addresses, the value of the text chars at each address is <span class="No-Break" lang="">the same.</span></p>
			<p lang="en-GB">Okay, now that you understand what the test is doing, does it compile? No. The build fails while trying to call the <strong class="source-inline" lang="">pass</strong> method in the <strong class="source-inline" lang="">confirm_that</strong> <span class="No-Break" lang="">template function.</span></p>
			<p lang="en-GB">The line in the test that causes the build failure is the last confirmation. The compiler is trying to convert the <strong class="source-inline" lang="">s1</strong> string into a constant char pointer. But this is misleading because even if we comment out the last confirmation so that the build succeeds, the test then fails at runtime, <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
<strong class="bold" lang="">------- Test: Test hamcrest style string pointer confirms</strong>
<strong class="bold" lang="">Failed confirm on line 75</strong>
<strong class="bold" lang="">    Expected: abc</strong>
<strong class="bold" lang="">    Actual  : abc</strong></pre>
			<p lang="en-GB">Because you might get different line numbers, I’ll explain that line 75 is the first confirmation from <span class="No-Break" lang="">the test:</span></p>
			<pre class="source-code" lang="en-GB">
    CONFIRM_THAT(sp1, Equals(sp2));   // pointer vs. pointer</pre>
			<p lang="en-GB">Look at the test failure message though. It says that <strong class="source-inline" lang="">"abc"</strong> is not equal to <strong class="source-inline" lang="">"abc"</strong>! What is <span class="No-Break" lang="">going on?</span></p>
			<p lang="en-GB">Because we’re using the original <strong class="source-inline" lang="">Equals</strong> template class, it only knows that we are dealing with char pointers. When we call <strong class="source-inline" lang="">pass</strong>, it’s the pointer values that are being compared. And because we<a id="_idIndexMarker487"/> took extra steps to make sure that <strong class="source-inline" lang="">sp1</strong> and <strong class="source-inline" lang="">sp2</strong> have different pointer values, the test fails. And the test fails even though the text both pointers refer to is <span class="No-Break" lang="">the same.</span></p>
			<p lang="en-GB">In order to support pointers, we’ll need another template specialization of <strong class="source-inline" lang="">Equals</strong>. But we can’t just specialize on any pointer type, in the same way we couldn’t specialize on any array type. We made sure that the array specialization only works for char arrays. So, we should also make sure that our pointer specialization only works with char pointers. Add this specialization right after the second <strong class="source-inline" lang="">Equals</strong> class <span class="No-Break" lang="">in </span><span class="No-Break" lang=""><strong class="source-inline" lang="">Test.h</strong></span><span class="No-Break" lang="">:</span></p>
			<pre class="source-code" lang="en-GB">
template &lt;typename T&gt; requires (
    std::is_same&lt;char, std::remove_const_t&lt;T&gt;&gt;::value)
class Equals&lt;T *&gt; : public Matcher
{
public:
    Equals (char const * expected)
    : mExpected(expected)
    { }
    bool pass (std::string const &amp; actual) const
    {
        return actual == mExpected;
    }
    std::string to_string () const override
    {
        return mExpected;
    }
private:
    std::string mExpected;
};</pre>
			<p lang="en-GB">With this third version of the <strong class="source-inline" lang="">Equals</strong> class, we not only fix the build error but all the confirmations pass too! This template specializes <strong class="source-inline" lang="">Equals</strong> for <strong class="source-inline" lang="">T *</strong> and also requires that <strong class="source-inline" lang="">T</strong> be a <span class="No-Break" lang="">char type.</span></p>
			<p lang="en-GB">The constructor accepts a pointer to constant chars and initializes <strong class="source-inline" lang="">mExpected</strong> with the pointer. The <strong class="source-inline" lang="">mExpected</strong> data <a id="_idIndexMarker488"/>member is <strong class="source-inline" lang="">std::string</strong>, which knows how to initialize itself from <span class="No-Break" lang="">a pointer.</span></p>
			<p lang="en-GB">The <strong class="source-inline" lang="">pass</strong> method also accepts <strong class="source-inline" lang="">std::string</strong>, which will let it compare against actual strings or char pointers. Additionally, the <strong class="source-inline" lang="">to_string</strong> method can return <strong class="source-inline" lang="">mExpected</strong> directly since it’s already <span class="No-Break" lang="">a string.</span></p>
			<p lang="en-GB">When we were adding more classical confirmations in <a href="B18567_05.xhtml#_idTextAnchor045"><span class="No-Break" lang=""><em class="italic" lang="">Chapter 5</em></span></a>, <em class="italic" lang="">Adding More Confirm Types</em>, we added special support for floating point types. We’ll need to add special support for confirming floating-point types in the Hamcrest style, too. The Hamcrest floating-point specializations will come in the next chapter along with learning how to write <span class="No-Break" lang="">custom matchers.</span></p>
			<h1 id="_idParaDest-122" lang="en-GB"><a id="_idTextAnchor130"/>Summary</h1>
			<p lang="en-GB">We used TDD throughout this chapter to add Hamcrest confirmations and even improve the existing code for classical confirmations. Without TDD, the existing code in a real project would likely not get approval from management to <span class="No-Break" lang="">make changes.</span></p>
			<p lang="en-GB">This chapter showed you the benefits of having unit tests that can help verify the quality of code after making changes. We were able to refactor the existing classical confirmations design for dealing with strings so that it matches the new design, which has a similar need. This lets both the classical and Hamcrest confirmations share a similar design instead of maintaining two different designs. All the changes were possible because the unit tests verified that everything continued to run <span class="No-Break" lang="">as expected.</span></p>
			<p lang="en-GB">The most important changes in this chapter added Hamcrest style confirmations, which are more intuitive and more flexible than the classic confirmations developed in <a href="B18567_04.xhtml#_idTextAnchor038"><span class="No-Break" lang=""><em class="italic" lang="">Chapter 4</em></span></a>, <em class="italic" lang="">Adding Tests to a Project</em>. Additionally, the new Hamcrest confirmations <span class="No-Break" lang="">are extensible.</span></p>
			<p lang="en-GB">We added support for Hamcrest confirmations<a id="_idIndexMarker489"/> following a TDD approach, which let us start simply. The simplicity was critical because we soon got into more advanced template specializations and even a new C++20 feature, called <em class="italic" lang="">requires</em>, that lets us specify how the templates should <span class="No-Break" lang="">be used.</span></p>
			<p lang="en-GB">TDD makes the process of designing software flow better – from simple ideas at the start of a project or the beginning of an enhancement to an enhanced solution like this chapter developed. Even though we have working Hamcrest confirmations, we’re not done yet. We’ll continue to enhance the confirmations in the next chapter by making sure we can confirm floating-point values and <span class="No-Break" lang="">custom-type values.</span></p>
		</div>
	</body></html>