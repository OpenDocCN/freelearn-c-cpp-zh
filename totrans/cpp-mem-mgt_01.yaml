- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Objects, Pointers, and References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start discussing memory management in C++, let’s make sure we understand
    each other and agree on a common vocabulary. If you’re a long-time C++ programmer,
    you probably have your own ideas about what pointers, objects, and references
    are. Your ideas will stem from a wealth of experience. If you are coming to this
    book from another language, you might also have your own ideas as to what these
    terms mean in C++ and how they relate to memory and memory management.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to make sure we have a common understanding of
    some basic (but profound) ideas so that we can build on this shared understanding
    for the rest of our adventure together. Specifically, we will explore questions
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How is memory represented in C++? What exactly is that thing we call memory,
    at least in the context of the C++ language?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are objects, pointers, and references? What do we mean by those terms in
    C++? What are the lifetime rules of objects? How do they relate to memory?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are arrays in C++? In this language, arrays are a low-level but highly
    efficient construct represented in a way that directly impacts memory management.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This book assumes that readers have some basic knowledge of C++ or of syntactically
    similar languages such as C, Java, C#, or JavaScript. For this reason, we will
    not explain the basics of variable declarations, loops, `if` statements, or functions.
  prefs: []
  type: TYPE_NORMAL
- en: We will, however, use some aspects of the C++ language in this chapter that
    some readers might be less comfortable with. Please refer to [*Annexure*](B21071_16.xhtml#_idTextAnchor221)*:*
    *Things You Should Know*, before reading this book.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the examples use C++20 or C++23, so make sure that your compiler supports
    this version of the standard to get the most out of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for this chapter can be found here: [https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter1](https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter1).'
  prefs: []
  type: TYPE_NORMAL
- en: Representation of memory in C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a book on memory management. You, readers, are trying to figure out
    what it means, and I, as the author, am trying to convey what it means.
  prefs: []
  type: TYPE_NORMAL
- en: The way in which the standard describes memory can be seen in [[wg21.link/basic.memobj](http://wg21.link/basic.memobj)].
    Essentially, memory in C++ is expressed as one or more sequences of contiguous
    bytes. This opens up the possibility of memory expressed as a set of discontinuous
    blocks of contiguous memory because, historically, C++ has supported memories
    made of various distinct segments. Every byte in a C++ program has a unique address.
  prefs: []
  type: TYPE_NORMAL
- en: Memory in a C++ program is populated with various entities such as objects,
    functions, references, and so on. Managing memory efficiently requires grasping
    what these entities mean and how programs can make use of them.
  prefs: []
  type: TYPE_NORMAL
- en: The meaning of the word byte is important in C++. As detailed in [[wg21.link/intro.memory](http://wg21.link/intro.memory)],
    bytes are the fundamental storage unit in C++. The number of bits in a byte is
    implementation-defined in C++. The standard does state, however, that a byte has
    to be wide enough to contain both the ordinary literal encoding of any element
    of the basic literal character set and the eight-bit code units of the UTF-8 encoding
    form. It also states that a byte is made of a contiguous sequence of bits.
  prefs: []
  type: TYPE_NORMAL
- en: 'What often surprises people is that in C++, a byte is not necessarily an octet:
    a byte consists of at least eight bits but could be made of more (something that’s
    useful on some exotic hardware). This might change in the future, as the standard
    committee might constrain that definition someday, but this is the situation at
    the time of the publication of this book. The key idea here is that a byte is
    the smallest addressable unit of memory in a program.'
  prefs: []
  type: TYPE_NORMAL
- en: Objects, pointers, and references
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We tend to use words such as object, pointer, and reference informally, without
    thinking too much about what they mean. In a language such as C++, these words
    have precise meanings that define and delimit what we can do in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Before we get our hands dirty, so to speak, let’s examine the formal meaning
    of these terms in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we polled programmers working with different languages and asked them how
    they would define the term object, we could probably expect such answers as “something
    that groups together variables and related functions” or “an instance of a class,”
    which correspond to traditional takes on that term from the realm of object-oriented
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'C++ as a language tries to provide homogeneous support for user-defined types
    such as structs or classes. It also provides support for fundamental types such
    as `int` or `float`. Thus, it probably should not be surprising that, for C++,
    the definition of an object is expressed in terms of its properties, not in terms
    of what the word means, and that this definition includes the most fundamental
    types. The definition of an object in C++ is described in [[wg21.link/intro.object](http://wg21.link/intro.object)]
    and takes the following factors into account:'
  prefs: []
  type: TYPE_NORMAL
- en: How the object is created explicitly, such as when defining the object or constructing
    it through one of the many variations of `operator new`. The object may also be
    created implicitly such as when creating a temporary object as the result of some
    expression or when changing the active member of a `union`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fact that an object is somewhere (it has an address) and occupies a region
    of storage of non-zero size, from the start of its construction to the end of
    its destruction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other properties of an object, including its name (if it has one), its type,
    and its storage duration (`automatic`, `static`, `thread_local`, and so on.).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The C++ standard explicitly calls out functions as not being objects, even if
    a function has an address and occupies storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'From this, we can infer that even a humble `int` is an object, but a function
    is not. You can see already, dear reader, that the book you’re reading will touch
    on fundamental topics, since lifetime and the storage occupied by objects are
    part of the fundamental properties of these entities we use in our programs every
    day. Such things as lifetime and storage are clearly part of what memory management
    is about. You can convince yourself of that fact with this simple program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: What is an object? It’s something that has a lifetime and occupies storage.
    Controlling these characteristics is part of the reasons why this book exists.
  prefs: []
  type: TYPE_NORMAL
- en: Pointers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are numerous (around 2,000) mentions of the word “pointer” in the text
    of the C++ standard, but if you open an electronic copy of that document and search
    through it, you’ll find that a formal definition is surprisingly hard to come
    by. This can be surprising given the fact that people tend to associate that idea
    with C and (by extension) C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us try to offer a useful yet informal definition, then: a pointer is a
    typed address. It associates a type with what is found at some location in memory.
    For that reason, in code like the following, one reads that `n` is an `int` object
    and that `p` points to an `int` object that happens to be the address of the `n`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It’s important to understand here that `p` indeed points to an `int`, unless
    `p` is left uninitialized, `p` points to `nullptr`, or programmers have played
    tricks with the type system and made `p` point to something else deliberately.
    Of course, pointer `p` is an object, as it respects all the rules to that effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Much of the (syntactic) confusion about pointers probably comes from the contextual
    meaning of the `*` and `&` symbols. The trick is to remember that they have different
    roles when they appear in the introduction of a name and when they are used on
    an existing object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, when introducing an object, `*` means “pointer to.” On an existing
    object, it means “what that pointer points to” (the pointee). Similarly, when
    introducing a name, `&` means “reference to” (something we will discuss imminently).
    On an existing object, it means “address of” and yields a pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pointers allow us to do arithmetic, but that’s (legitimately) seen as a dangerous
    operation, as it can take us to arbitrary locations in a program and can therefore
    lead to serious damage. Arithmetic on a pointer depends on its type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Of course, accessing the contents of arbitrary addresses is just asking for
    trouble. This is because it would mean invoking undefined behavior (described
    in [*Chapter 2*](B21071_02.xhtml#_idTextAnchor027)), and if you do that, you’re
    on your own. Please do not do such things in real code, as you could hurt programs
    – or worse, people. C++ is powerful and flexible, but if you program in C++, you’re
    expected to behave responsibly and professionally.
  prefs: []
  type: TYPE_NORMAL
- en: 'C++ has four special types for pointer manipulation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`void*` means “address with no specific (type-related) semantics.” A `void*`
    is an address with no associated type. All pointers (if we discount the `const`
    and `volatile` qualifiers) are implicitly convertible to `void*`; an informal
    way to read this is as “all pointers, regardless of type, really are addresses.”
    The converse does not hold. For example, it’s not true that all addresses are
    implicitly convertible to `int` pointers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`char*` means “pointer to a byte.” Due to the C language roots of C++, a `char*`
    can alias any address in memory (the `char` type, regardless of its name, which
    evocates “character”, really means “byte” in C and, by extension, in C++). There
    is an ongoing effort in C++ to give `char` the meaning of “character,” but as
    of this writing, a `char*` can alias pretty much anything in a program. This hampers
    some compiler optimization opportunities (it is hard to constrain or reason about
    something that can lead to literally anything in memory).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::byte*` is the new “pointer to a byte,” at least since C++17\. The (long-term)
    intent of `byte*` is to replace `char*` in those functions that do byte-per-byte
    manipulation or addressing, but since there’s so much code that uses `char*` to
    that effect, this will take time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For an example of conversion from and to `void*`, consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example, which is somewhat more elaborate, uses `const char*`
    (but could use `const byte*` instead). It shows that one can compare the byte-per-byte
    representation of two objects, at least in some circumstances, to see whether
    they are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `has_unique_object_representations` trait is true for types uniquely defined
    by their values, that is, types exempt of padding bits.. That’s sometimes important
    as C++ does not say what happens to padding bits in an object, and performing
    a bit-per-bit comparison of two objects might yield surprising results. Note that
    objects of floating point types are not considered uniquely defined by their values
    as there are many distinct values that qualify as NaN, or “not a number”.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The C++ language supports two related families of indirections: pointers and
    references. Like their cousins, the pointers, references are often mentioned by
    the C++ standard (more than 1,800 times) but it’s hard to find a formal definition
    for them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will try once again to provide an informal but operational definition: a
    reference can be seen as an alias for an existing entity. We deliberately did
    not use object, since one could refer to a function and we already know that a
    function is not an object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pointers are objects. As such, they occupy storage. References, on the other
    hand, are not objects and use no storage of their own, even though an implementation
    could simulate their existence with pointers. Compare `std::is_object_v<int*>`
    with `std::is_object_v<int&>`: the former is `true`, and the latter is `false`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `sizeof` operator, applied to a reference, will yield the size of what it
    refers to. Consequently, taking the address of a reference yields the address
    of what it refers to.
  prefs: []
  type: TYPE_NORMAL
- en: 'In C++, a reference is always bound to an object and remains bound to that
    object until the end of the reference’s lifetime. A pointer, on the other hand,
    can point to numerous distinct objects during its lifetime, as we have seen before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Another difference between pointers and references is that, contrary to the
    situation that prevails with pointers, there is no such thing as reference arithmetic.
    This makes references somewhat safer than pointers. There is room for both kinds
    of indirections in a program (and we will use them both in this book!), but for
    everyday programming, a good rule of thumb is to use references if possible and
    to use pointers if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have examined the representation of memory and taken a look at how
    C++ defines some fundamental ideas such as a byte, an object, a pointer, or a
    reference, we can delve a little deeper into some important defining properties
    of objects.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the fundamental properties of objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw earlier that in C++, an object has a type and an address. It also occupies
    a region of storage from the beginning of its construction to the end of its destruction.
    We will now examine these fundamental properties in more detail in order to understand
    how these properties affect the ways in which we write programs.
  prefs: []
  type: TYPE_NORMAL
- en: Object lifetime
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of C++’s strengths, but also one reason for its relative complexity, arises
    from the control one has over the lifetime of objects. In C++, generally speaking,
    automatic objects are destructed at the end of their scope in a well-defined order.
    Static (global) objects are destructed on program termination in a somewhat well-defined
    order (in a given file, the order of destruction is clear, but it’s more complicated
    for static objects in different files). Dynamically allocated objects are destructed
    “when your program says so” (there are many nuances to this).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine some aspects of object lifetime with the following (very) simple
    program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When executed, that program will print the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The fact that the number of constructors and destructors do not match is a sign
    that we did something wrong. More specifically, in this example, we manually created
    an object (pointed to by `p1`) with `operator new` but never manually destructed
    that object afterward.
  prefs: []
  type: TYPE_NORMAL
- en: One common source of confusion for programmers unfamiliar with C++ is the distinction
    between pointer and pointee. In this program, `p0` and `p1` are both destructed
    when reaching the end of their scope (by the closing brace of the `main()` function),
    just as `xmain` will be. However, since `p0` and `p1` point to dynamically allocated
    objects, the pointees have to be explicitly destructed, something we did for `p0`
    but (deliberately, for the sake of the example) neglected to do for `p1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'What happens to `p1`’s pointee then? Well, it has been manually constructed
    and has not been manually destructed. As such, it floats in memory where no one
    can access it anymore. This is what people often call a memory leak: a chunk of
    memory your program allocated but never deallocated.'
  prefs: []
  type: TYPE_NORMAL
- en: Worse than leaking the storage for the `X` object pointed to by `p1`, however,
    is the fact that the pointee’s destructor will never be called, which can cause
    all sorts of resource leaks (files not closed, database connections not closed,
    system handles not released, and so on). In [*Chapter 4*](B21071_04.xhtml#_idTextAnchor062),
    *Using Destructors*, we will examine how it is possible to avoid such situations
    and write clean, simple code at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Object size, alignment, and padding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since each object occupies storage, the space associated with an object is
    an important (if low-level) property of C++ types. For example, look at the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In that example, trying to define the `D` class would not compile. This is because
    in order to create a `D` object, the compiler needs to reserve enough space for
    a `D` object, but a `D` object is also a `B` object, and as such we cannot know
    the size of a `D` object without knowing the size of a `B` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The size of an object or, equivalently, of a type can be obtained through the
    `sizeof` operator. This operator yields a compile-time, non-zero unsigned integral
    value corresponding to the number of bytes required to store an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `Tiny` class is empty because it has no data member.
    A class could have member functions and still be empty. Empty classes that expose
    member functions are very commonly used in C++.
  prefs: []
  type: TYPE_NORMAL
- en: A C++ object always occupies at least one byte of storage, even in the case
    of empty classes such as `Tiny`. That’s because if an object’s size was zero,
    that object could be at the same memory location as its immediate neighbor, which
    would be somewhat hard to reason about.
  prefs: []
  type: TYPE_NORMAL
- en: 'C++ differs from many other languages in that it does not standardize the size
    of all fundamental types. For example, `sizeof(int)` can yield different values
    depending on the compiler and platform. Still, there are rules concerning the
    size of objects:'
  prefs: []
  type: TYPE_NORMAL
- en: The size reported by operator `sizeof` for objects of type `signed char`, `unsigned
    char` and `char` is 1, and the same goes for `sizeof(std::byte)` as each of these
    types can be used to represent a single byte.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expressions `sizeof(short)>=sizeof(char)` and `sizeof(int)>=sizeof(short)` will
    hold on all platforms, which means that there might be cases where `sizeof(char)`
    and `sizeof(int)` are both 1\. In terms of width (i.e., bits used in the value
    representation) of fundamental types, the C++ standard limits itself to stating
    the minimum width for each type. The list can be found at [[wg21.link/tab:basic.fundamental.width](http://wg21.link/tab:basic.fundamental.width)].
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we have already said, expression `sizeof(T)>0` holds for any type `T`. In
    C++, there are no zero-sized objects, not even objects of empty classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The size occupied by an object of any `struct` or `class` cannot be less than
    the sum of the size of its data members (but there are caveats).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This last rule deserves an explanation. Consider the following situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The line marked `<-- here` might be intriguing. Why would `sizeof(Y)` be equal
    to `sizeof(X)` if every `Y` object contains an `X` object? Remember that `sizeof(X)`
    is greater than `0` even though `X` is an empty class because every C++ object
    has to occupy at least one byte of storage. However, in the case of `Y`, which
    is not an empty class, each `Y` object already occupies storage due to its `x`
    data member. There’s no reason to somewhat artificially add storage space to objects
    of that type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, consider this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The same reasoning applies again: an object of type `X` occupies the same amount
    of storage space as its only data member (of type `char`), and an object of type
    `Y` occupies the same amount of storage space as its only data member (of type
    `X`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing this exploration, consider this :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This is the rule we mentioned earlier but expressed formally for a specific
    type. In this situation, supposing that `sizeof(X)`being equal to `1` is highly
    probable, one could even reasonably expect that `sizeof(Y)`would be equal to the
    sum of`sizeof(char)`and `sizeof(X)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, consider this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We moved from having an object of class `X` being a data member of `Y` to `X`
    being a base class of `Y`. This has an interesting consequence: since the base
    class `X` is empty, and since we know from definition that objects of the derived
    class `Y` will occupy at least one byte of storage, the base class can be flattened
    into the derived class for `Y` objects. This is a useful optimization called the
    **empty base optimization**. You can reasonably expect compilers to perform this
    optimization in practice, at least in the case of single inheritance relationships.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that since the presence of an `X` in a `Y` is an implementation detail,
    not something that participates in the interface of class `Y`, we used private
    inheritance in this example. The empty base optimization would apply with public
    or protected inheritance too, but in this case, private inheritance preserves
    the fact that the `X` part of a `Y` is something that only the `Y` knows about.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since C++20, if you think composition would be more appropriate than inheritance
    to describe the relation between two classes such as `X` and `Y`, you can mark
    a data member as `[[no_unique_address]]` to inform the compiler that this member,
    if it is an object of an empty class, does not have to occupy storage within the
    enclosing object. Compilers are not forced to comply, since attributes can be
    ignored, so make sure to verify that your chosen compilers implement this before
    writing code that relies on this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'All of the examples so far have been very simple, using classes with zero,
    one, or two very small data members. Code is rarely so simple. Consider the following
    program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Supposing that the first two static assertions hold, which is probable but not
    guaranteed, we know that `sizeof(X)` will be at least `7` (the sum of the sizes
    of its data members). In practice, however, you will probably see that `sizeof(X)`
    is equal to 8\. Now, this might seem surprising at first, but it’s a logical consequence
    of something called **alignment**.
  prefs: []
  type: TYPE_NORMAL
- en: The alignment of an object (or of its type) tells us where that object can be
    placed in memory. The `char` type has an alignment of `1`, and as such one can
    place a `char` object literally anywhere (as long as one can access that memory).
    For an alignment of `2` (which is likely for type `short`), objects can only be
    placed at addresses that are a multiple of 2\. More generally, if a type has an
    alignment of `n`, then objects of that type must be placed at an address that
    is a multiple of `n`. Note that alignment has to be a strictly positive power
    of 2; not respecting this rule incurs undefined behavior. Of course, your compiler
    will not put you in that position, but you might put yourself in such trouble
    if you’re not careful, given some of the tricks we will be using in this book.
    With great control comes great responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'The C++ language offers two operators related to alignment:'
  prefs: []
  type: TYPE_NORMAL
- en: The `alignof` operator, which yields the natural alignment of a type `T` or
    of an object of that type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `alignas` operator, which lets programmers impose the alignment of an object.
    This is often useful when playing tricks with memory (as we will) or when interfacing
    with exotic hardware (the term “exotic” here can be taken in a very broad sense).
    Of course, `alignas` can only reasonably increase the natural alignment of a type,
    not reduce it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For some fundamental type `T`, one can expect the assertion that `sizeof(T)`
    is equal to `alignof(T)` to hold, but that assertion does not generalize to composite
    types. For example, consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Generally speaking, for a composite type, the alignment will correspond to the
    worst alignment of its data members. Here, “worst” means “biggest.” For class
    `X`, the worst-aligned data member is `n` of type `int` and as such, `X` objects
    will be aligned on boundaries of `alignof(int)` bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might wonder now why we can expect the assertion that `sizeof(X)` is equal
    to `8` to hold if `sizeof(short)==2` and `sizeof(int)==4`. Let’s look at the probable
    layout for objects of the `X` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1 – Compact layout of an object of type X in memory](img/B21071_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.1 – Compact layout of an object of type X in memory
  prefs: []
  type: TYPE_NORMAL
- en: Each box in this figure is a byte in memory. As we can see, there’s a `?` between
    `c` and the first byte of `s`. That comes from alignment. If `alignof(short)==2`
    and `alignof(int)==4`, then the only correct layout for an `X` object places its
    `n` member at a boundary of `4`. This means that there will be a padding byte
    (a byte that does not participate in the value representation of `X`) between
    `c` and `s` to align `s` on a two-byte boundary and to align `n` on a four-byte
    boundary.
  prefs: []
  type: TYPE_NORMAL
- en: 'What might seem more surprising is that the order in which data members are
    laid out in a class impacts the size of the objects of that class. For example,
    consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'That often surprises people, but it’s true, and something to think about. With
    this example, the probable layout for an `X` object would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2 – Less compact layout for an object of type X in memory](img/B21071_01_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.2 – Less compact layout for an object of type X in memory
  prefs: []
  type: TYPE_NORMAL
- en: By now, the two `?` “squares” between `s` and `n` are probably clear, but the
    three trailing `?` “squares” might seem surprising. After all, why add padding
    at the end of an object?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is *because of arrays*. As we will soon discuss, elements of an array
    are contiguous in memory, and for that reason, it is important that each element
    of an array is properly aligned. In a case such as this, the trailing padding
    bytes in an object of class `X` ensure that if an element in an array of `X` objects
    is properly aligned, then the next element will be properly aligned too.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know about alignment, consider that just changing the order of
    elements from one version of class `X` to another resulted in a memory consumption
    increase of 50% for each object of that type. That hurts your program’s memory
    space consumption and its speed all at once. C++ compilers cannot reorder your
    data members for you, as your code sees the addresses of objects. Changing the
    relative position of data members could break users’ code, so it’s up to programmers
    to be careful with their chosen layouts. Note that keeping objects small is not
    the only factor that can influence the choice of layout in an object, especially
    in multithreaded code (where sometimes keeping two objects at a distance from
    one another can lead to better cache usage), so one should remember that layout
    is important, but not something to take on naïvely.
  prefs: []
  type: TYPE_NORMAL
- en: Copy and movement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, we need to say a few words about copy and movement, two fundamental
    considerations in a language such as C++ where there are actual objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The C++ language considers six member functions as special. These functions
    will be automatically generated for your types unless you take steps to prevent
    it. These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The default constructor**: It’s probably the least special of all six, as
    it’s only implicitly generated if you write no constructor of your own.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The destructor**: This is called at the end of an object’s lifetime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The copy constructor**: It is called when constructing an object with a single
    object of the same type as argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The copy assignment**: It is called when replacing the contents of an existing
    object with a copy of the contents of another object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::move()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The move assignment**: It behaves like copy assignment but is applied when
    the argument passed to the assignment operator is something one can move from.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When a type does not explicitly manage any resources on its own, one can usually
    write none of these special functions, as the ones generated by the compiler will
    be exactly what one wants. For example, consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here, type `Point2D` represents a 2D coordinate that has no invariants (all
    values are fine for its `x` and `y` data members). Since we used default initializers
    for `x` and `y` that set these data members to 0, a default `Point2D` object will
    represent coordinate `(0,0)` and the six special member functions will behave
    as expected. The copy constructor will call the data members’ copy constructors,
    the copy assignment will call their copy assignment operators, the destructor
    will be trivial, and move operations will behave like copy operations since the
    data members are of fundamental types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Should we decide to add a parametric constructor to explicitly let user code
    initialize the `x` and `y` data members to other values than our chosen defaults,
    we can do so. However, this will cost us our implicit default constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can of course fix this. One way to do so is by writing the details of a
    default constructor explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Another approach is to delegate work from the default constructor to the parametric
    constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Another even better approach is to inform the compiler that we want to retain
    the default behavior even though we did something (writing another constructor)
    that would otherwise prevent it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The latter option will usually lead to the best generated code, as compilers
    are really good at getting maximal results from minimal effort when they understand
    the programmer’s intent. In this case, `=default` makes the intent very explicit:
    *please do what you would have done normally if my code had* *not interfered*.'
  prefs: []
  type: TYPE_NORMAL
- en: A note about these constructors
  prefs: []
  type: TYPE_NORMAL
- en: We added parametric constructors to `Point2D` for the sake of this example,
    but it’s not necessary in this case as `Point2D` is an aggregate. These types
    have special initialization support, but that’s beside the point for our illustration.
    Aggregate types are types that comply with several restrictions (no user-declared
    or inherited constructors, no private non-static data members, no virtual bases
    classes, and so on) and that usually have no invariants to maintain, but can be
    initialized very efficiently by your compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a class explicitly manages resources, the default-generated special functions
    rarely do what we would want. Indeed, how could the compiler know about our intents
    in such a situation? Suppose we make a naïve `string`-like class of our own, starting
    with the following (incomplete) excerpt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Naïve as it is, this class clearly does explicit resource allocation by allocating
    a chunk of `size()+1` bytes to hold a copy of the sequence of characters starting
    at `p`. For that reason, the compiler-provided special member functions will not
    do the right thing for our class. For example, the default-generated copy constructor
    will copy pointer `p`, but that means we will have two pointers (the original
    `p` and `p` in the copy) sharing a common pointee, which is probably not what
    we want. The default-generated destructor will destroy the pointer, but we also
    want to deallocate the pointee and avoid a memory leak, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In a case such as this, we want to implement the so-called rule of three and
    code the destructor as well as the two copy operations (the copy constructor and
    the copy assignment). Before the arrival of move semantics in C++11, that was
    sufficient to properly implement resource management for our types. It technically
    still is today but considering move semantics too will help us get a more efficient
    type in many ways. In contemporary code, when discussing code that implements
    the two move operations in addition to the rule of three, we typically speak of
    the rule of five.
  prefs: []
  type: TYPE_NORMAL
- en: Destruction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As our `naive_string` type does resource management with the dynamically allocated
    array pointed to by `p`, the destructor for that class will be simple, as its
    role will be limited to deallocating the chunk of memory pointed to by `p`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note that there is no need to check that `p` is non-null (`delete nullptr;`
    does nothing in C++ and is inherently non-dangerous). Also note that we are using
    `delete[]`, not `delete`, as we allocated the chunk of memory with `new[]`, not
    `new`. The nuances between these operations will be explained in [*Chapter 7*](B21071_07.xhtml#_idTextAnchor116).
  prefs: []
  type: TYPE_NORMAL
- en: Copy operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The copy constructor is the function called when constructing an object of
    the `naive_string` class with an argument that is another object of that class.
    For example, consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'For our `naive_string` class, a correct copy constructor could be written as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy assignments could be written in numerous ways, but many of them are complicated
    or just plain dangerous. For example, consider the following example…but do not
    write your assignment operator like this!:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, this might seem reasonable (if a bit long-winded), but if we look at the
    line where memory allocation is performed, one has to wonder: what will happen
    if this fails? Indeed it could. For example, it might fail if the process is running
    low on available memory and `other.size()` is too much for whatever resources
    are left. In C++, by default, allocation with `operator new` throws an exception
    on failure. This would complete the execution of our copy assignment function,
    leaving `*this` in an incorrect (and dangerous!) state whereby `p` is non-null
    and `nelems` is non-zero but `p` points to what most would call garbage: memory
    we do not own and whose contents would lead to undefined behavior if used.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We could claim that we can do better and write even more code trying to fix
    this bug. The recommendation to avoid writing your copy assignment operators like
    this holds also in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This looks safer on the surface, as we do not try to clean up the existing
    state of `*this` until we are sure that the allocation has worked. It might even
    pass most of your tests – until someone crafts the following test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: With this use case, our copy assignment will behave very badly. After allocating
    a properly sized chunk of memory pointed to by `q`, it will delete what `p` points
    to. Unfortunately, this also happens to be what `other.p` points to, destroying
    the actual source data we are aiming to copy from. What follows that step reads
    from memory we do not own anymore, and the program stops making sense.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can still try to patch this, and even make it work, but beware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This fix is a pessimization, since we will be making every copy assignment call
    pay for that `if` branch that, in practice, should almost never be used. Brute-force
    problem-solving led us to complicated code that works (though it’s not necessarily
    self-evident) and that will need to be reconsidered with every resource-managing
    class we write.
  prefs: []
  type: TYPE_NORMAL
- en: About the word pessimization
  prefs: []
  type: TYPE_NORMAL
- en: 'The word *pessimization* is generally used as the opposite of *optimization*,
    referring to a programming maneuver or technique that makes program behavior less
    efficient than it should be. The preceding case is a well-known example of such
    a maneuver: everyone will pay for the potential branch introduced by the `if`
    statement even though it’s only required for rare and degenerate cases – things
    that should not happen.'
  prefs: []
  type: TYPE_NORMAL
- en: When faced with a “pessimization” opportunity, it’s often worth it to take a
    step back and reconsider. Maybe we’ve been taking the wrong angle when approaching
    the problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, there is a well-known idiom in C++ called the **safe assignment idiom**,
    colloquially known as copy-and-swap. The trick is to recognize that the assignment
    is made of two parts: a destructive part that cleans up the existing state owned
    by the destination object (the left side of the assignment) and a constructive
    part that copies the state from a source object (right side of the assignment)
    to the destination object. The destructive part is generally equivalent to the
    code found in the type’s destructor, and the constructive part is generally equivalent
    to the code found in the type’s copy constructor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The informal copy-and-swap name for that technique comes from the fact that
    it is usually implemented through a combination of the type’s copy constructor,
    its destructor, and a `swap()` member function that swaps member variables one
    by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'That idiom is extremely useful to know and use as it’s exception-safe, simple,
    and works for almost all types. The line that does all the work performs three
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, it constructs an anonymous copy of `other` using that type’s copy constructor.
    Now, that might fail if an exception is thrown, but if it does, `*this` has not
    been modified and thus remains uncorrupted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, it swaps that anonymous temporary’s contents (holding what we want to
    put in `*this`) with the destination object’s contents (putting the now-unneeded
    state in that anonymous temporary object).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the anonymous temporary object is destroyed at the end of the expression
    (being anonymous), leaving `*this` holding a copy of the state of `other`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This idiom even works safely for self-assignment. It incurs an unneeded copy,
    but it trades an `if` branch that every call would have paid but almost none would
    have benefitted from for a copy that will rarely be useless.
  prefs: []
  type: TYPE_NORMAL
- en: You might notice `noexcept` preceding the opening brace of the `swap()` member
    function. We will return to this later, but for now, the important point is that
    we can claim that this function (swapping objects of fundamental types as it does)
    will never throw an exception. This information will help us achieve some precious
    optimizations later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Move operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our `naive_string`, which is augmented by its destructor, copy constructor,
    and copy assignment member functions, now manages resources appropriately. It
    could, however, be made faster, and sometimes even safer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following non-member string concatenation operator that someone
    could want to add to complement our class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'An operation like this could be used in user code such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The expression that follows the `return` statement first performs a call to
    `operator+()` and creates an unnamed `naive_string` object from the concatenation
    of `s0` and `name`. Then, that unnamed object is passed as the first argument
    to another call to `operator+()` that yields another unnamed object created from
    the concatenation of the first unnamed object and `s1`. With our current implementation,
    each unnamed object incurs an allocation, a copy of the data held in its buffer,
    a destruction, and more. It’s more costly than it looks at first glance and is
    made even worse by the fact that each allocation could throw an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Still, it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since C++11, we can make such code significantly more efficient through move
    semantics. In addition to the traditional rule of three functions we just discussed,
    one can augment a class such as `naive_string` with a move constructor and a move
    assignment operator. These will kick in implicitly when the compiler operates
    on objects it knows will not be used anymore. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This translates to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'It then translates to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: When one thinks about it, the reason for copy operations is to keep the source
    object intact in case we need it later. Temporary objects that have no name do
    not need to be preserved from further modifications as they cannot be referred
    to later. For that reason, we can be more aggressive with these and essentially
    move their contents instead of copying them. The rule we are asked to follow by
    the standard is to leave the moved-from object in a valid-yet-indeterminate state.
    Essentially, the moved-from object has to be in such a state that it can be safely
    destroyed or assigned to, and its invariants should still hold. In practice, that
    often amounts to leaving the moved-from object in something equivalent to its
    default state.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our `naive_string` type, a move constructor could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The calls to `std::move()` in this specific case could be avoided (moving objects
    of fundamental types is equivalent to copying them), but it’s probably more hygienic
    to make sure that the intent to move those objects is inscribed explicitly in
    the source code. We’ll look cursorily at `std::move()` later in this section,
    but the important thing to remember is that `std::move()` does not move anything.
    It marks an object as movable in the eyes of the compiler. In other words, *it’s*
    *a cast*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The important things to note with our move constructor are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The argument is of type `naive_string&&`. This means it is a reference to an
    `rvalue`, with `rvalue` itself informally meaning “something one could find on
    the right side of an assignment operator.”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like `swap()`, it is marked `noexcept` to express the fact that no exception
    will be thrown during its execution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s effectively transferring state from the source object, `other`, to the
    object under construction, `*this`. After the completion of this transfer, we
    leave `other` in a valid state (equivalent to what we would have with a default
    `naive_string` object), respecting the standard’s recommendation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One could write this function in a slightly terser manner with a small but
    quite useful function found in the `<utility>` header and named `std::exchange()`.
    Indeed, consider the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This expression means “assign to `a` the value of `b` but replace the value
    of `b` with the value of `c`.” This is a very common sequence of operations in
    real code. With this function, our move constructor becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: That form is idiomatic C++ and can lead to some interesting optimizations in
    some circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: 'What about the move assignment? Well, we can take note of the idiomatic copy
    assignment we discussed at some length earlier and express it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Following the path set by our copy assignment operator, we expressed the move
    assignment operator as a combination of `swap()`, a destructor, and a move constructor.
    The general logic behind both idioms is the same.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have used arrays in our preceding examples, but we have not really provided
    a formal definition for that useful-yet-low-level construct. Note that in this
    section, the term “array” refers to raw, built-in arrays, not to other very useful
    but higher-level constructs such as `std::vector<T>` or `std::array<T,N>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Quite simply, in C++, an array is a contiguous sequence of elements of the
    same type. Thus, in the following excerpt, the `a0` object occupies `10*sizeof(int)`
    bytes in memory, whereas the `a1` object occupies `20*sizeof(std::string)` bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The number of bytes between elements at indices `i` and `i+1` in an array of
    some type `T` is precisely equal to `sizeof(T)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following expression, which would be used in C++, as in C, for
    some array `arr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'It evaluates to the same address as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Since pointer arithmetic is typed, the `+ i` part in this expression means “plus
    `i` elements” or “plus `i` times the size of an element in bytes.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Array sizes are positive but cannot be 0 unless the array is dynamically allocated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Each call to `operator new[]` has to yield a different address, even if the
    array’s size is 0\. Each call technically returns the address of a different object.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we took a look at fundamental ideas of the C++ language such
    as: what is an object? What are pointers and references? What do we mean when
    we talk about the size and alignment of an object or of a type? Why are there
    no zero-size objects in C++? What are the special members of a class and when
    do we need to write them explicitly? This non-exhaustive list of topics gave us
    a common vocabulary from which to build what you, dear reader, will find in the
    chapters to come.'
  prefs: []
  type: TYPE_NORMAL
- en: With this, we are ready to get our hands dirty, so to speak. We have given ourselves
    a set of low-level tools and ideas from which to build higher-level abstractions,
    but we have to give ourselves some measure of discipline.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will discuss some things we need to avoid. Those include undefined
    behavior, implementation-defined behavior (to a lesser extent), ill-formed no-diagnostic-required
    code, buffer overflows, and other unrecommendable behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we will follow with a chapter describing C++ casts, and how they can help
    us express clear ideas even when we feel the need to eschew some of the rules
    set out for us by the language’s type system.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we will start to build beautiful and powerful abstractions that
    will help us with our stated goal of safely and efficiently managing resources
    in general and managing memory in particular.
  prefs: []
  type: TYPE_NORMAL
