<html><head></head><body>
        

                            
                    <h1 class="header-title">Advanced Tools and Upcoming Features</h1>
                
            
            
                
<p class="mce-root">WebAssembly's ecosystem is constantly growing and evolving. Developers have seen the potential for WebAssembly. They build tools to improve the development experience or output Wasm modules from their language of choice (albeit with some limitations).</p>
<p class="mce-root">In this chapter, we'll evaluate the underlying technologies that make WebAssembly tick. We'll also review tools you can use in the browser and cover an advanced use case that utilizes Web Workers. Finally, we'll quickly review upcoming features and proposals that are on the roadmap for WebAssembly.</p>
<p class="mce-root">Our goal for this chapter is to understand the following:</p>
<ul>
<li class="mce-root">How WABT and Binaryen fit into the build process and what they can be used for</li>
<li class="mce-root">How to compile a WebAssembly module using LLVM (rather than Emscripten)</li>
<li class="mce-root">Online tools such as WasmFiddle and other useful tooling online</li>
<li class="mce-root">How to utilize Web Workers to run WebAssembly in parallel</li>
<li class="mce-root">Upcoming features (proposed and in progress) that will be integrated into WebAssembly in the future</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">WABT and Binaryen</h1>
                
            
            
                
<p>WABT and Binaryen allow developers to work with source files and develop tooling for WebAssembly. If you're interested in working with WebAssembly at a lower level, these tools provide the means for accomplishing such a goal. In this section, we'll evaluate these tools in greater detail and review the purpose and capabilities of each one.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">WABT – the WebAssembly binary toolkit</h1>
                
            
            
                
<p class="mce-root">WABT's focus is on the manipulation of WebAssembly binary (<kbd>.wasm</kbd>) files and text (<kbd>.wat</kbd>) files, as well as conversion between the two formats. WABT provides tools to translate <strong>Wat to Wasm</strong> (<strong>wat2wasm</strong>) and vice versa (<strong>wasm2wat</strong>), as well as a tool to convert a Wasm file to a C source and header file (<strong>wasm2c</strong>). You can view the entire list of tools in the README file of the WABT GitHub repository at <a href="https://github.com/WebAssembly/wabt">https://github.com/WebAssembly/wabt</a>.</p>
<p class="mce-root">One example use case of WABT is the <em>WebAssembly Toolkit for VS Code</em> extension we installed in <a href="706c89b2-c820-4fb0-906c-2f2e49602d27.xhtml">Chapter 3</a>, <a href="706c89b2-c820-4fb0-906c-2f2e49602d27.xhtml"/><em>Setting Up a Development Environment</em>. The extension depends on WABT to view the text format associated with a <kbd>.wasm</kbd> file. The repository provides links to wat2wasm and wasm2wat demos, which you can use to test the validity of a Wat program or interact with a compiled binary using JavaScript. The following screenshot contains the Wat and JavaScript instantiation code from the wat2wasm demo:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/0c941193-4415-400d-9085-4d78bd80a19a.png" style="width:32.83em;height:31.50em;"/></p>
<p>Wat and JavaScript loading code from wat2wasm's "simple" example</p>
<p class="mce-root"/>
<p class="mce-root">In line <kbd>3</kbd> of the JS panel, you may have noticed that the <kbd>addTwo()</kbd> function from <kbd>wasmInstance.exports</kbd> isn't prefixed with a <kbd>_</kbd>. Emscripten adds the <kbd>_</kbd> automatically in the compilation process. You could omit the <kbd>_</kbd> by converting the <kbd>.wasm</kbd> file to a <kbd>.wat</kbd>, updating the function names, and converting it back to <kbd>.wasm</kbd> using the WABT, although this wouldn't be very practical. The WABT simplifies the process of transforming text format to binary format and vice versa. If you want to build compilation tooling for WebAssembly, you'd use Binaryen, which we will cover next.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Binaryen</h1>
                
            
            
                
<p class="mce-root">Binaryen's GitHub page at <a href="https://github.com/WebAssembly/binaryen">https://github.com/WebAssembly/binaryen</a> describes Binaryen as a compiler and toolchain infrastructure library for WebAssembly, written in C++. It aims to make compiling to WebAssembly easy, fast, and effective. It achieves these aims by providing a simple C API, an internal IR, and an optimizer. Just as with the WABT, Binaryen provides an extensive suite of tools for developing WebAssembly tooling. The following list describes a subset of the tools that Binaryen provides:</p>
<ul>
<li class="mce-root"><strong>wasm-shell</strong>: Tool capable of loading and interpreting WebAssembly</li>
<li class="mce-root"><strong>asm2wasm</strong>: Compiles asm.js code to a Wasm module</li>
<li class="mce-root"><strong>wasm2js</strong>: Compiles a Wasm module to JavaScript</li>
<li class="mce-root"><strong>wasm-merge</strong>: Combines multiple Wasm files into one</li>
<li class="mce-root"><strong>wasm.js</strong>: JavaScript library that includes the Binaryen interpreter, asm2wasm, the Wat parser, and other Binaryen tools</li>
<li class="mce-root"><strong>binaryen.js</strong>: JavaScript library that provides a JavaScript interface for the Binaryen toolchain</li>
</ul>
<p class="mce-root">The wasm.js and binaryen.js tools are of particular interest for JavaScript developers interested in building WebAssembly tooling. The <kbd>binaryen.js</kbd> library is available as an <kbd>npm</kbd> package (<a href="https://www.npmjs.com/package/binaryen">https://www.npmjs.com/package/binaryen</a>).</p>
<p class="mce-root">An excellent example of <kbd>binaryen.js</kbd> usage is AssemblyScript (<a href="https://github.com/AssemblyScript/assemblyscript">https://github.com/AssemblyScript/assemblyscript</a>). AssemblyScript is a strictly typed subset of TypeScript that generates WebAssembly modules. The library comes packaged with a CLI to quickly scaffold new projects and manage the build step. In the <em>Compiling with LLVM </em>section, we'll cover how to compile Wasm modules using LLVM.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Compiling with LLVM</h1>
                
            
            
                
<p>In <a href="15ca4834-5544-4dd8-b307-f0bc95c63a21.xhtml">Chapter 1, </a><em>What is WebAssembly?</em>, we discussed the relationship between Emscripten's EMSDK and LLVM. Emscripten uses LLVM and Clang to compile C/C++ down to LLVM bitcode. The Emscripten compiler (<kbd>emcc</kbd>) compiles that bitcode to asm.js, which is passed to Binaryen to generate a Wasm file. If you're interested in using LLVM, you can compile C/C++ to Wasm without installing the EMSDK. In this section, we will review the process for enabling Wasm compilation using LLVM. After compiling some example C++ code to a Wasm file, we'll try it out in the browser.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The installation process</h1>
                
            
            
                
<p class="mce-root">If you want to compile WebAssembly modules using LLVM, several tools need to be installed and configured. Getting these tools working together correctly can be an arduous and time-consuming process. Fortunately, someone went through the trouble of making this process much simpler. Daniel Wirtz created an <kbd>npm</kbd> package named <kbd>webassembly</kbd> (<a href="https://www.npmjs.com/package/webassembly">https://www.npmjs.com/package/webassembly</a>) that can perform the following operations (with the corresponding CLI commands):</p>
<ul>
<li class="mce-root">Compile C/C++ code to a WebAssembly module (<kbd>wa compile</kbd>)</li>
<li class="mce-root">Link multiple WebAssembly modules to one (<kbd>wa link</kbd>)</li>
<li class="mce-root">Decompile a WebAssembly module to text format (<kbd>wa disassemble</kbd>)</li>
<li class="mce-root">Assemble WebAssembly text format to a module (<kbd>wa assemble</kbd>)</li>
</ul>
<p class="mce-root">The library is using Binaryen, Clang, LLVM, and additional LLVM tools behind the scenes. We'll install this package globally to ensure we have access to the <kbd>wa</kbd> command. To install, open a terminal instance and run the following command:</p>
<pre class="mce-root"><strong>npm install -g webassembly</strong></pre>
<p class="mce-root">It may take a few minutes to install any required dependencies. Once complete, run the following command to validate the installation:</p>
<pre class="mce-root"><strong>wa</strong></pre>
<p class="mce-root">You should see the following in terminal:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/02098a68-e5fa-4ef1-8370-ba78bed728b4.png" style="width:38.83em;height:36.08em;"/></p>
<p>Output of the wa command</p>
<p class="mce-root">You should be ready to start compiling Wasm modules. Let's move on to the example code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The example code</h1>
                
            
            
                
<p class="mce-root">To test out the compiler, we're going to use a slightly modified version of the <kbd>without-glue.c</kbd> file from the <em>Interacting with JavaScript without glue code</em> section of <a href="51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml">Chapter 5</a>, <a href="51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml"/><em>Creating and Loading a WebAssembly Module</em>. The code for this section is located in the <kbd>/chapter-10-advanced-tools/compile-with-llvm</kbd> directory of the <kbd>learn-webassembly</kbd> repository. Follow the following instructions to create the files necessary for the compiler test. Let's start with the C++ file.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The C++ file</h1>
                
            
            
                
<p class="mce-root">Create a new directory in your <kbd>/book-examples</kbd> directory named <kbd>/compile-with-llvm</kbd>. Create a new file in the <kbd>/compile-with-llvm</kbd> directory named <kbd>main.cpp</kbd> and populate it with the following contents:</p>
<pre class="mce-root">#include &lt;stdbool.h&gt;<br/><br/>#define BOUNDS 255<br/>#define RECT_SIDE 50<br/>#define BOUNCE_POINT (BOUNDS - RECT_SIDE)<br/><br/>bool isRunning = true;<br/><br/>typedef struct Rect {<br/>  int x;<br/>  int y;<br/>  char direction;<br/>} Rect;<br/><br/>struct Rect rect;<br/><br/>void updateRectLocation() {<br/>    if (rect.x == BOUNCE_POINT) rect.direction = 'L';<br/>    if (rect.x == 0) rect.direction = 'R';<br/>    int incrementer = 1;<br/>    if (rect.direction == 'L') incrementer = -1;<br/>    rect.x = rect.x + incrementer;<br/>    rect.y = rect.y + incrementer;<br/>}<br/><br/>extern "C" {<br/>extern int jsClearRect();<br/>extern int jsFillRect(int x, int y, int width, int height);<br/><br/>__attribute__((visibility("default")))<br/>void moveRect() {<br/>    jsClearRect();<br/>    updateRectLocation();<br/>    jsFillRect(rect.x, rect.y, RECT_SIDE, RECT_SIDE);<br/>}<br/><br/>__attribute__((visibility("default")))<br/>bool getIsRunning() {<br/>    return isRunning;<br/>}<br/><br/>__attribute__((visibility("default")))<br/>void setIsRunning(bool newIsRunning) {<br/>    isRunning = newIsRunning;<br/>}<br/><br/>__attribute__((visibility("default")))<br/>void init() {<br/>    rect.x = 0;<br/>    rect.y = 0;<br/>    rect.direction = 'R';<br/>    setIsRunning(true);<br/>}<br/>}</pre>
<p class="mce-root">The code in this file is almost identical to the contents of <kbd>without-glue.c</kbd> from <a href="51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml">Chapter 5</a>, <a href="51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml"/><em>Creating and Loading a WebAssembly Module</em>. The comments have been removed from the file and the imported/exported functions are wrapped in an <kbd>extern "C"</kbd> block. The <kbd>__attribute__((visibility("default")))</kbd> lines are macro statements (similar to <kbd>EMSCRIPTEN_KEEPALIVE</kbd>) that ensure the functions aren't removed from the compiled output during the dead-code elimination step. Just as with prior examples, we'll interact with the compiled Wasm module through an HTML file. Let's create that next.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The HTML file</h1>
                
            
            
                
<p class="mce-root">Create a file named <kbd>index.html</kbd> in the <kbd>/compile-with-llvm</kbd> directory and populate it with the following contents:</p>
<pre class="mce-root">&lt;!doctype html&gt;<br/>&lt;html lang="en-us"&gt;<br/>&lt;head&gt;<br/>  &lt;title&gt;LLVM Test&lt;/title&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>  &lt;h1&gt;LLVM Test&lt;/h1&gt;<br/>  &lt;canvas id="myCanvas" width="255" height="255"&gt;&lt;/canvas&gt;<br/>  &lt;div style="margin-top: 16px;"&gt;<br/>    &lt;button id="actionButton" style="width: 100px; height: 24px;"&gt;<br/>      Pause<br/>    &lt;/button&gt;<br/>  &lt;/div&gt;<br/>  &lt;script type="application/javascript"&gt;<br/>    const canvas = document.querySelector('#myCanvas');<br/>    const ctx = canvas.getContext('2d');<br/><br/>    const importObj = {<br/>      env: {<br/>        memoryBase: 0,<br/>        tableBase: 0,<br/>        memory: new WebAssembly.Memory({ initial: 256 }),<br/>        table: new WebAssembly.Table({ initial: 8, element: 'anyfunc' }),<br/>        abort: console.log,<br/>        jsFillRect: function(x, y, w, h) {<br/>          ctx.fillStyle = '#0000ff';<br/>          ctx.fillRect(x, y, w, h);<br/>        },<br/>        jsClearRect: function() {<br/>          ctx.fillStyle = '#ff0000';<br/>          ctx.fillRect(0, 0, 255, 255);<br/>        }<br/>      }<br/>    };<br/><br/>    WebAssembly.instantiateStreaming(fetch('main.wasm'), importObj)<br/>      .then(({ instance }) =&gt; {<br/>        const m = instance.exports;<br/>        m.init();<br/><br/>        const loopRectMotion = () =&gt; {<br/>          setTimeout(() =&gt; {<br/>            m.moveRect();<br/>            if (m.getIsRunning()) loopRectMotion();<br/>          }, 20)<br/>        };<br/><br/>    document.querySelector('#actionButton')<br/>      .addEventListener('click', event =&gt; {<br/>        const newIsRunning = !m.getIsRunning();<br/>        m.setIsRunning(newIsRunning);<br/>        event.target.innerHTML = newIsRunning ? 'Pause' : 'Start';<br/>        if (newIsRunning) loopRectMotion();<br/>      });<br/><br/>      loopRectMotion();<br/>    });<br/>  &lt;/script&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</pre>
<p class="mce-root">The contents of this file are very similar to the <kbd>without-glue.html</kbd> file from <a href="51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml">Chapter 5</a>, <em>Creating and Loading a WebAssembly Module</em>. Instead of using the <kbd>loadWasm()</kbd> function from the <kbd>/common/load-wasm.js</kbd> file, we're using the <kbd>WebAssembly.instantiateStreaming()</kbd> function. This allows us to omit an additional <kbd>&lt;script&gt;</kbd> element and serve the files directly from the <kbd>/compile-with-llvm</kbd> directory.</p>
<p class="mce-root">The <kbd>_</kbd> is omitted from the <kbd>jsFillRect</kbd> and <kbd>jsClearRect</kbd> functions passed into the <kbd>importObj</kbd>. We can omit the <kbd>_</kbd> for the functions present on the <kbd>instance.exports</kbd> object as well. LLVM doesn't prefix any of the data/functions passed in or out of the module with a <kbd>_</kbd>. In the next section, we'll compile <kbd>main.cpp</kbd> and interact with the resultant Wasm file in the browser.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Compiling and running the example</h1>
                
            
            
                
<p class="mce-root">We installed the <kbd>webassembly npm</kbd> package with the <kbd>-g</kbd> flag, so the <kbd>wa</kbd> command should be available in the terminal. Open a terminal instance in the <kbd>/compile-with-llvm</kbd> directory and run the following command:</p>
<pre class="mce-root"><strong>wa compile main.cpp -o main.wasm</strong></pre>
<p>You should see a file named <kbd>main.wasm</kbd> appear in the <kbd>compile-with-llvm</kbd> folder of VS Code's file explorer. To ensure the Wasm module compiled correctly, run the following command within the <kbd>/compile-with-llvm</kbd> directory:</p>
<pre><strong>serve -l 8080</strong></pre>
<p>If you navigate to <kbd>http://127.0.0.1:8080/index.html</kbd> in your browser, you should see the following:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/bb069bef-1df9-437f-b2ce-8622b845ef2c.png" style="width:23.33em;height:22.33em;"/></p>
<p>LLVM compiled module running in the browser </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Online tooling</h1>
                
            
            
                
<p class="mce-root">The installation and configuration process for compiling WebAssembly modules locally is, admittedly, a little cumbersome. Fortunately, there are several online tools available that allow you to develop and interact with WebAssembly in the browser. In this section, we'll review those tools and discuss the functionality each one provides.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">WasmFiddle</h1>
                
            
            
                
<p class="mce-root">In the <em>Connecting the dots with WasmFiddle</em> section in <a href="0b30dfc9-4624-48b6-a968-0342540d1ef5.xhtml">Chapter 2</a>, <em>Elements of WebAssembly</em> <em>- Wat, Wasm, and the JavaScript API</em>, we used WasmFiddle to compile a simple C function to Wasm and interact with it using JavaScript. WasmFiddle provides a C/C++ editor, JavaScript editor, Wat/x86 viewer, and JavaScript output panel. You can also interact with the <kbd>&lt;canvas&gt;</kbd> if desired. WasmFiddle uses LLVM to generate the Wasm modules, which is why the imports and exports aren't prefixed with a <kbd>_</kbd>. You can interact with WasmFiddle at <a href="https://wasdk.github.io/WasmFiddle">https://wasdk.github.io/WasmFiddle</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">WebAssembly Explorer</h1>
                
            
            
                
<p class="mce-root">WebAssembly Explorer, located at <a href="https://mbebenita.github.io/WasmExplorer">https://mbebenita.github.io/WasmExplorer</a>, provides similar functionality to WasmFiddle. It allows you to compile C or C++ to a Wasm module and view the corresponding Wat. However, WebAssembly Explorer provides additional functionality not present in WasmFiddle. For example, you can compile C or C++ to Wasm and view the corresponding Firefox x86 and LLVM x86 code. You can select from a list of code examples and specify the optimization level (<kbd>-O</kbd> flag in <kbd>emcc</kbd>). It also provides a button that allows you to import the code into WasmFiddle:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/cbe79b3c-c5b9-41b1-b817-e71e0e85c3fa.png" style="width:57.33em;height:46.75em;"/></p>
<p>Screenshot of WebAssembly Explorer</p>


            

            
        
    

        

                            
                    <h1 class="header-title">WebAssembly Studio</h1>
                
            
            
                
<p class="mce-root">WebAssembly Studio, located at <a href="https://webassembly.studio">https://webassembly.studio</a>, is a feature-rich editor and development environment. You can create C, Rust, and AssemblyScript projects. It provides the capabilities to build and run code within the browser and integrates well with GitHub. WebAssembly Studio enables you to build a web application without having to install and configure the required WebAssembly tooling locally:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/586895b5-ace5-4179-9423-bae1c39361ce.png"/></p>
<p>Screenshot of WebAssembly Studio</p>
<p class="mce-root">In the next section, we'll demonstrate how to add parallelism to your WebAssembly application with Web Workers.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Parallel Wasm with Web Workers</h1>
                
            
            
                
<p class="mce-root">The process of building a complex application that performs heavy computation or other resource-intensive work can benefit greatly from using <strong>threads</strong>. Threads allow you to perform operations in parallel by dividing functionality among tasks that run independently. At of writing this, support for threads in WebAssembly is in the <em>Feature Proposal</em> phase. In this phase, the specification hasn't been written and the feature isn't implemented. Fortunately, JavaScript provides threading capabilities in the form of Web Workers. In this section, we'll demonstrate how to use JavaScript's Web Workers API to interact with Wasm modules in separate threads.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Web Workers and WebAssembly</h1>
                
            
            
                
<p class="mce-root">Web Workers allow you to utilize threads in the browser, which can improve the performance of your application by offloading some of the logic from the main (UI) thread. Worker threads are also capable of performing I/O using <kbd>XMLHttpRequest</kbd>. Worker threads communicate with the main thread by posting messages to an event handler.</p>
<p class="mce-root">Web Workers allow us to load Wasm modules into separate threads and perform operations that don't hinder the performance of the UI. Web Workers do have some limitations. They're unable to directly manipulate the DOM or access some of the methods and properties on the <kbd>window</kbd> object. The messages passed between threads must be serialized objects, which means you can't pass functions. Now that you know what a worker is, let's discuss how to create one.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a worker</h1>
                
            
            
                
<p class="mce-root">Before you can create a worker, you need a JavaScript file with code that runs in the worker thread. You can see a simple example of a worker definition file at <a href="https://github.com/mdn/simple-web-worker/blob/gh-pages/worker.js">https://github.com/mdn/simple-web-worker/blob/gh-pages/worker.js</a>. The file should contain a <kbd>message</kbd> event listener that performs operations when messages are received from other threads and responds accordingly.</p>
<p class="mce-root">Once that file is created, you're ready to use it with a worker. A worker is created by passing a URL argument to the <kbd>Worker()</kbd> constructor. The URL can be a string representing the name of the file with your worker definition code, or constructed using a <kbd>Blob</kbd>. The <kbd>Blob</kbd> technique can be useful if you're fetching the worker definition code from a server. The example application demonstrates how to use both approaches. Let's move on to the process of integrating WebAssembly with Web Workers.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">The WebAssembly workflow</h1>
                
            
            
                
<p class="mce-root">In order to utilize Wasm modules in separate threads, the Wasm file must be compiled in the main thread and instantiated in a Web Worker. Let's review this process in more detail:</p>
<ol>
<li class="mce-root">A new Web Worker (we'll refer to it as <kbd>wasmWorker</kbd>) is created using the <kbd>Worker()</kbd> constructor.</li>
<li class="mce-root">A fetch call is made to retrieve a <kbd>.wasm</kbd> file and the <kbd>arrayBuffer()</kbd> function is called on the response.</li>
<li class="mce-root">The resolved value of the <kbd>arrayBuffer()</kbd> function is passed to the <kbd>WebAssembly.compile()</kbd> function.</li>
<li class="mce-root">The <kbd>WebAssembly.compile()</kbd> function resolves with a <kbd>WebAssembly.Module</kbd> instance, which is included in the body of a message posted to the <kbd>wasmWorker</kbd> using the <kbd>postMessage()</kbd> function.</li>
<li class="mce-root">Within <kbd>wasmWorker</kbd>, the <kbd>WebAssembly.Module</kbd> instance from the message body is passed to the <kbd>WebAssembly.instantiate()</kbd> function, which resolves with a <kbd>WebAssembly.Instance</kbd>.</li>
<li class="mce-root">The <kbd>WebAssembly.Instance</kbd> exports object is assigned to a local variable in <kbd>wasmWorker</kbd> and is used to call Wasm functions.</li>
</ol>
<p class="mce-root">To call a function from the <kbd>wasmWorker</kbd> Wasm instance, you post a message to the worker thread with any arguments to pass to the Wasm function. Then, <kbd>wasmWorker</kbd> executes the function and passes the results back to the main thread. That's the crux of how threads are utilized in the context of Web Workers. Before we move on to the example application, you may need to address a limitation that Google Chrome imposes. Follow the instructions in the <em>Limitations in Google Chrome </em>section to ensure the example application works successfully.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Limitations in Google Chrome</h1>
                
            
            
                
<p class="mce-root">Google Chrome places a restriction on what can be included in the body of a Web Worker's <kbd>postMessage()</kbd> function. If you tried to send a compiled <kbd>WebAssembly.Module</kbd> to a worker, you'd get an error and the operation would be unsuccessful. You can override this by setting a flag. To enable this functionality, open Google Chrome and enter <kbd>chrome://flags</kbd> in the address bar. Type <kbd>cloning</kbd> in the search box at the top of the page. You should see a list item titled WebAssembly structured cloning support. Select the Enabled option from the dropdown next to the list item and press the RELAUNCH NOW button when prompted:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/077e795e-460d-413b-b6f4-cf82e5e797b0.png"/></p>
<p>Updating the WebAssembly flag in Google Chrome</p>
<p class="mce-root">After Chrome restarts, you can run the example application without issue. If you're using Mozilla Firefox, no action is required. It supports this feature by default. Let's move on to the example application that demonstrates the use of WebAssembly in threads.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Overview of the code</h1>
                
            
            
                
<p class="mce-root">The example application isn't much of an application. It's a simple form that accepts two input values and returns the sum or difference of these two values. The add and subtract operations are each exported from their own Wasm module instantiated in a worker thread. The example may be contrived, but it effectively demonstrates how to integrate WebAssembly into Web Workers.</p>
<p class="mce-root"/>
<p class="mce-root">The code for this section is located in the <kbd>/chapter-10-advanced-tools/parallel-wasm</kbd> directory of the <kbd>learn-webassembly</kbd> repository. The following sections walk through each section of the code base and describe how to build the application from scratch. If you wish to follow along, create a folder in your <kbd>/book-examples</kbd> directory named <kbd>/parallel-wasm</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The C code</h1>
                
            
            
                
<p class="mce-root">The example uses two worker threads: one for addition and another for subtraction. Consequently, we'll need two separate Wasm modules. Create a folder named <kbd>/lib</kbd> in your <kbd>/parallel-wasm</kbd> directory. Within the <kbd>/lib</kbd> directory, create a file named <kbd>add.c</kbd> and populate it with the following contents:</p>
<pre class="mce-root">int calculate(int firstVal, int secondVal) {<br/>    return firstVal + secondVal;<br/>}</pre>
<p class="mce-root">Create another file in <kbd>/lib</kbd> named <kbd>subtract.c</kbd> and populate it with the following contents:</p>
<pre class="mce-root">int calculate(int firstVal, int secondVal) {<br/>    return firstVal - secondVal;<br/>}</pre>
<p class="mce-root">Note that the function name in both files is <kbd>calculate</kbd>. This was done so we don't have to write any conditional logic within the worker code to determine the Wasm function to call. The algebraic operation is tied to a worker, so when we need to add two numbers, the <kbd>_calculate()</kbd> function will be called in the <kbd>addWorker</kbd>. This will become clearer when we review the JavaScript portion of the code, which we'll cover next.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The JavaScript code</h1>
                
            
            
                
<p class="mce-root">Before we dig into the JavaScript code, create a folder named <kbd>/src</kbd> in your <kbd>/parallel-wasm</kbd> directory. Let's start with the file containing the code that runs in the worker thread.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Defining thread execution in worker.js</h1>
                
            
            
                
<p class="mce-root">Create a new file in the <kbd>/src</kbd> directory named <kbd>worker.js</kbd> and populate it with the following contents:</p>
<pre class="mce-root">var wasmInstance = null;<br/><br/>self.addEventListener('message', event =&gt; {<br/>  /**<br/>   * Once the WebAssembly compilation is complete, this posts a message<br/>   * back with whether or not the instantiation was successful. If the<br/>   * payload is null, the compilation succeeded.<br/>   */<br/>  const sendCompilationMessage = (error = null) =&gt; {<br/>    self.postMessage({<br/>      type: 'COMPILE_WASM_RESPONSE',<br/>      payload: error<br/>    });<br/>  };<br/><br/>  const { type, payload } = event.data;<br/>  switch (type) {<br/>    // Instantiates the compiled Wasm module and posts a message back to<br/>    // the main thread indicating if the instantiation was successful:<br/>    case 'COMPILE_WASM_REQUEST':<br/>      const importObj = {<br/>        env: {<br/>          memoryBase: 0,<br/>          tableBase: 0,<br/>          memory: new WebAssembly.Memory({ initial: 256 }),<br/>          table: new WebAssembly.Table({ initial: 2, element: 'anyfunc' }),<br/>          abort: console.log<br/>        }<br/>      };<br/><br/>      WebAssembly.instantiate(payload, importObj)<br/>        .then(instance =&gt; {<br/>          wasmInstance = instance.exports;<br/>          sendCompilationMessage();<br/>        })<br/>        .catch(error =&gt; {<br/>          sendCompilationMessage(error);<br/>        });<br/>      break;<br/><br/>    // Calls the `calculate` method associated with the instance (add or<br/>    // subtract, and posts the result back to the main thread:<br/>    case 'CALC_REQUEST':<br/>      const { firstVal, secondVal } = payload;<br/>      const result = wasmInstance._calculate(firstVal, secondVal);<br/><br/>      self.postMessage({<br/>        type: 'CALC_RESPONSE',<br/>        payload: result<br/>      });<br/>      break;<br/><br/>    default:<br/>      break;<br/>  }<br/>}, false);</pre>
<p class="mce-root">The code is encapsulated within the event listener for the <kbd>message</kbd> event (<kbd>self.addEventListener(...)</kbd>), which is raised when the <kbd>postMessage()</kbd> function is called on the corresponding worker. The <kbd>event</kbd> parameter in the event listener's callback function contains a <kbd>data</kbd> property with the contents of the message. All of the messages passed between threads in the application follow the <strong>Flux Standard Action</strong> (<strong>FSA</strong>) convention. Objects that adhere to this convention have a <kbd>type</kbd> and <kbd>payload</kbd> property, where <kbd>type</kbd> is a string and <kbd>payload</kbd> can be of any type. You can read more about the FSA at <a href="https://github.com/redux-utilities/flux-standard-action">https://github.com/redux-utilities/flux-standard-action</a>.</p>
<p>You can use any format or structure for the data you pass using the <kbd>postMessage()</kbd> function, as long as the data is serializable.</p>
<p class="mce-root">The <kbd>switch</kbd> statement executes an action based on the message's <kbd>type</kbd> value, which is a string. If the <kbd>type</kbd> is <kbd>'COMPILE_WASM_REQUEST'</kbd>, the <kbd>WebAssembly.instantiate()</kbd> function is called with the <kbd>payload</kbd> from the message and <kbd>importObj</kbd>. The <kbd>exports</kbd> object of the result is assigned to the local <kbd>wasmInstance</kbd> variable for later use. If the <kbd>type</kbd> is <kbd>'CALC_REQUEST'</kbd>, the <kbd>wasmInstance._calculate()</kbd> function is called with the <kbd>firstVal</kbd> and <kbd>secondVal</kbd> values from the <kbd>payload</kbd> object. The calculation code should shed some light on why the function was named <kbd>_calculate()</kbd> instead of <kbd>_add()</kbd> or <kbd>_subtract()</kbd>. By using a general name, the worker doesn't care what operation it's performing, it just calls the function to get the result.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root">In both cases, the worker posts a message back to the main thread using the <kbd>postMessage()</kbd> function. I used a <kbd>REQUEST</kbd>/<kbd>RESPONSE</kbd> convention for the <kbd>type</kbd> property value. This allows you to quickly identify which thread the messages are originating from. Messages sent from the main thread end with <kbd>_REQUEST</kbd> in the <kbd>type</kbd> while responses coming from the worker threads end with <kbd>_RESPONSE</kbd>. Let's move on to the WebAssembly interaction code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Interacting with Wasm in WasmWorker.js</h1>
                
            
            
                
<p class="mce-root">Create a new file in the <kbd>/src</kbd> directory named <kbd>WasmWorker.js</kbd> and populate it with the following contents:</p>
<pre class="mce-root">/**<br/> * Web Worker associated with an instantiated Wasm module.<br/> * @class<br/> */<br/>export default class WasmWorker {<br/>  constructor(workerUrl) {<br/>    this.worker = new Worker(workerUrl);<br/>    this.listenersByType = {};<br/>    this.addListeners();<br/>  }<br/><br/>  // Add a listener associated with the `type` value from the<br/>  // Worker message:<br/>  addListenerForType(type, listener) {<br/>    this.listenersByType[type] = listener;<br/>  }<br/><br/>  // Add event listeners for error and message handling.<br/>  addListeners() {<br/>    this.worker.addEventListener('error', event =&gt; {<br/>      console.error(`%cError: ${event.message}`, 'color: red;');<br/>    }, false);<br/><br/>    // If a handler was specified using the `addListener` method,<br/>    // fire that method if the `type` matches:<br/>    this.worker.addEventListener('message', event =&gt; {<br/>      if (<br/>        event.data instanceof Object &amp;&amp;<br/>        event.data.hasOwnProperty('type') &amp;&amp;<br/>        event.data.hasOwnProperty('payload')<br/>      ) {<br/>        const { type, payload } = event.data;<br/>        if (this.listenersByType[type]) {<br/>          this.listenersByType[type](payload);<br/>        }<br/>      } else {<br/>        console.log(event.data);<br/>      }<br/>    }, false);<br/>  }<br/><br/>  // Fetches the Wasm file, compiles it, and passes the compiled result<br/>  // to the corresponding worker. The compiled module is instantiated<br/>  // in the worker.<br/>  initialize(name) {<br/>    return fetch(`calc-${name}.wasm`)<br/>      .then(response =&gt; response.arrayBuffer())<br/>      .then(bytes =&gt; WebAssembly.compile(bytes))<br/>      .then(wasmModule =&gt; {<br/>        this.worker.postMessage({<br/>          type: 'COMPILE_WASM_REQUEST',<br/>          payload: wasmModule<br/>      });<br/>      return Promise.resolve();<br/>    });<br/>  }<br/><br/>  // Posts a message to the worker thread to call the `calculate`<br/>  // method from the Wasm instance:<br/>  calculate(firstVal, secondVal) {<br/>    this.worker.postMessage({<br/>      type: 'CALC_REQUEST',<br/>        payload: {<br/>        firstVal,<br/>        secondVal<br/>      }<br/>    });<br/>  }<br/>}</pre>
<p class="mce-root">The <kbd>WasmWorker</kbd> class manages a worker thread associated with a Wasm file. In the <kbd>WasmWorker</kbd> constructor, a new <kbd>Worker</kbd> is created and default event listeners are added for the <kbd>error</kbd> and <kbd>message</kbd> events. The <kbd>initialize()</kbd> function fetches the <kbd>.wasm</kbd> file associated with the <kbd>name</kbd> argument, compiles it, and sends the resultant <kbd>WebAssembly.Module</kbd> instance to the worker thread to be instantiated.</p>
<p class="mce-root"/>
<p class="mce-root">The <kbd>addListenerForType()</kbd> function is used to specify a <kbd>callback</kbd> function (<kbd>listener</kbd>) to execute when the <kbd>type</kbd> field in the message response matches the <kbd>type</kbd> argument passed to the function. This is required to capture the result of the <kbd>_calculate()</kbd> function from the worker thread.</p>
<p class="mce-root">Finally, the <kbd>calculate()</kbd> function in <kbd>WasmWorker</kbd> posts a message to the worker thread with the <kbd>firstVal</kbd> and <kbd>secondVal</kbd> arguments passed in from the <kbd>&lt;input&gt;</kbd> elements on the <kbd>&lt;form&gt;</kbd>. Let's move on to the application loading code to see how <kbd>WasmWorker</kbd> interacts with the UI.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Loading the application in index.js</h1>
                
            
            
                
<p class="mce-root">Create a new file in the <kbd>/src</kbd> directory named <kbd>index.js</kbd> and populate it with the following contents:</p>
<pre class="mce-root">import WasmWorker from './WasmWorker.js';<br/><br/>/**<br/> * If you add ?blob=true to the end of the URL (e.g.<br/> * http://localhost:8080/index.html?blob=true), the worker will be<br/> * created from a Blob rather than a URL. This returns the<br/> * URL to use for the Worker either as a string or created from a Blob.<br/> */<br/>const getWorkerUrl = async () =&gt; {<br/>  const url = new URL(window.location);<br/>  const isBlob = url.searchParams.get('blob');<br/>  var workerUrl = 'worker.js';<br/>  document.title = 'Wasm Worker (String URL)';<br/><br/>  // Create a Blob instance from the text contents of `worker.js`:<br/>  if (isBlob === 'true') {<br/>    const response = await fetch('worker.js');<br/>    const results = await response.text();<br/>    const workerBlob = new Blob([results]);<br/>    workerUrl = window.URL.createObjectURL(workerBlob);<br/>    document.title = 'Wasm Worker (Blob URL)';<br/>  }<br/><br/>  return Promise.resolve(workerUrl);<br/>};<br/><br/>/**<br/> * Instantiates the Wasm module associated with the specified worker<br/> * and adds event listeners to the "Add" and "Subtract" buttons.<br/> */<br/>const initializeWorker = async (wasmWorker, name) =&gt; {<br/>  await wasmWorker.initialize(name);<br/>  wasmWorker.addListenerForType('CALC_RESPONSE', payload =&gt; {<br/>    document.querySelector('#result').value = payload;<br/>  });<br/><br/>  document.querySelector(`#${name}`).addEventListener('click', () =&gt; {<br/>    const inputs = document.querySelectorAll('input');<br/>    var [firstInput, secondInput] = inputs.values();<br/>    wasmWorker.calculate(+firstInput.value, +secondInput.value);<br/>  });<br/>};<br/><br/>/**<br/> * Spawns (2) workers: one associated with calc-add.wasm and another<br/> * with calc-subtract.wasm. Adds an event listener to the "Reset"<br/> * button to clear all the input values.<br/> */<br/>const loadPage = async () =&gt; {<br/>  document.querySelector('#reset').addEventListener('click', () =&gt; {<br/>    const inputs = document.querySelectorAll('input');<br/>    inputs.forEach(input =&gt; (input.value = 0));<br/>  });<br/><br/>  const workerUrl = await getWorkerUrl();<br/>  const addWorker = new WasmWorker(workerUrl);<br/>  await initializeWorker(addWorker, 'add');<br/><br/>  const subtractWorker = new WasmWorker(workerUrl);<br/>  await initializeWorker(subtractWorker, 'subtract');<br/>};<br/><br/>loadPage()<br/>  .then(() =&gt; console.log('%cPage loaded!', 'color: green;'))<br/>  .catch(error =&gt; console.error(error));</pre>
<p class="mce-root">The application entry point is the <kbd>loadPage()</kbd> function. Before we dig into the worker initialization code, let's discuss the <kbd>getWorkerUrl()</kbd> function. Earlier in this section, we learned that you can pass a string representing a filename or a URL created from a <kbd>Blob</kbd> to the <kbd>Worker()</kbd> constructor. The following example code demonstrates the first technique:</p>
<pre class="mce-root">var worker = new Worker('worker.js');</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root">The second technique is demonstrated in the <kbd>if (isBlob === 'true')</kbd> block of the <kbd>getWorkerUrl()</kbd> function. If the current <kbd>window.location</kbd> value ends with <kbd>?blob=true</kbd>, the URL passed to the <kbd>Worker()</kbd> constructor is created from a <kbd>Blob</kbd>. The only noticeable difference is the <kbd>document.title</kbd> value, which updates to reflect the URL type. Let's jump back to the <kbd>loadPage()</kbd> function to discuss the initialization code.</p>
<p class="mce-root">After an event listener is added to the Reset button in the <kbd>loadPage()</kbd> function, two <kbd>WasmWorker</kbd> instances are created: <kbd>addWorker</kbd> and <kbd>subtractWorker</kbd>. Each worker is passed to the <kbd>initializeWorker()</kbd> function as the <kbd>wasmWorker</kbd> argument. In <kbd>initializeWorker()</kbd>, the <kbd>wasmWorker.initialize()</kbd> function is called to instantiate the Wasm module. The <kbd>wasmWorker.addListenerForType()</kbd> function is called to set the value of the Result <kbd>&lt;input&gt;</kbd> to the value returned from the <kbd>_calculate()</kbd> function in the corresponding worker. Finally, an event listener is added to the <kbd>click</kbd> event of the <kbd>&lt;button&gt;</kbd> that either adds or subtracts the <kbd>firstVal</kbd> and <kbd>secondVal</kbd> <kbd>&lt;input&gt;</kbd> values (based on the <kbd>name</kbd> argument). That's it for the JavaScript code. Let's create an HTML and CSS file, then move on to the build step.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The web assets</h1>
                
            
            
                
<p class="mce-root">We need an HTML file to act as the entry point to the application. Create a file in the <kbd>/src</kbd> directory named <kbd>index.html</kbd> and populate it with the following contents:</p>
<pre class="mce-root">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>&lt;head&gt;<br/>  &lt;meta charset="utf-8"&gt;<br/>  &lt;title&gt;Wasm Workers&lt;/title&gt;<br/>  &lt;link rel="stylesheet" type="text/css" href="styles.css" /&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>  &lt;form class="valueForm"&gt;<br/>    &lt;div class="valueForm"&gt;<br/>      &lt;label for="firstVal"&gt;First Value:&lt;/label&gt;<br/>      &lt;input id="firstVal" type="number" value="0" /&gt;<br/>    &lt;/div&gt;<br/>    &lt;div class="valueForm"&gt;<br/>      &lt;label for="secondVal"&gt;Second Value:&lt;/label&gt;<br/>      &lt;input id="secondVal" type="number" value="0" /&gt;<br/>    &lt;/div&gt;<br/>    &lt;div class="valueForm"&gt;<br/>      &lt;label for="result"&gt;Result:&lt;/label&gt;<br/>      &lt;input id="result" type="number" value="0" readonly /&gt;<br/>    &lt;/div&gt;<br/>  &lt;/form&gt;<br/>  &lt;div&gt;<br/>    &lt;button id="add"&gt;Add&lt;/button&gt;<br/>    &lt;button id="subtract"&gt;Subtract&lt;/button&gt;<br/>    &lt;button id="reset"&gt;Reset&lt;/button&gt;<br/>  &lt;/div&gt;<br/>  &lt;script type="module" src="img/index.js"&gt;&lt;/script&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</pre>
<p class="mce-root">The application consists of a <kbd>&lt;form&gt;</kbd> with three <kbd>&lt;input&gt;</kbd> elements and a block of three <kbd>&lt;button&gt;</kbd> elements. The first two <kbd>&lt;input&gt;</kbd> elements correspond to the <kbd>firstVal</kbd> and <kbd>secondVal</kbd> properties included in the <kbd>payload</kbd> sent to either worker thread. The final <kbd>&lt;input&gt;</kbd> is read-only and displays the result of either operation.</p>
<p class="mce-root">The block of <kbd>&lt;button&gt;</kbd> elements below the <kbd>&lt;form&gt;</kbd> perform operations on the <kbd>&lt;input&gt;</kbd> values. The first two <kbd>&lt;button&gt;</kbd> elements send the <kbd>&lt;input&gt;</kbd> values to either the <kbd>addWorker</kbd> or <kbd>subtractWorker</kbd> thread (depending on which button was pressed). The final <kbd>&lt;button&gt;</kbd> sets all of the <kbd>&lt;input&gt;</kbd> values to <kbd>0</kbd>.</p>
<p class="mce-root">The application is initialized in the <kbd>&lt;script&gt;</kbd> tag in the last line before the <kbd>&lt;/body&gt;</kbd> closing tag. Just as with Cook the Books, the <kbd>type="module"</kbd> attribute allows us to use the <kbd>import</kbd>/<kbd>export</kbd> syntax available in newer browsers. Finally, we need to add some styles to the application. Create a file in the <kbd>/src</kbd> directory named <kbd>styles.css</kbd> and populate it with the following contents:</p>
<pre class="mce-root">* {<br/>  font-family: sans-serif;<br/>  font-size: 14px;<br/>}<br/><br/>body {<br/>  margin: 16px;<br/>}<br/><br/>form.valueForm {<br/>  display: table;<br/>}<br/><br/>div.valueForm {<br/>  display: table-row;<br/>}<br/><br/>label, input {<br/>  display: table-cell;<br/>  margin-bottom: 16px;<br/>}<br/><br/>label {<br/>  font-weight: bold;<br/>  padding-right: 16px;<br/>}<br/><br/>button {<br/>  border: 1px solid black;<br/>  border-radius: 4px;<br/>  cursor: pointer;<br/>  font-weight: bold;<br/>  height: 24px;<br/>  margin-right: 4px;<br/>  width: 80px;<br/>}<br/><br/>button:hover {<br/>  background: lightgray;<br/>}</pre>
<p class="mce-root">That's the last file we need to create, but not the last one required to run the application. We still need to generate Wasm files from the C files in the <kbd>/lib</kbd> directory. Let's move on to the build step.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Building and running the application</h1>
                
            
            
                
<p class="mce-root">With the code written, it's time to build and test the application. After completing the build step, we'll interact with the running application and review how to troubleshoot Web Workers using the browser's development tools.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Compiling the C files</h1>
                
            
            
                
<p class="mce-root">We need to compile each C file to a separate <kbd>.wasm</kbd> file, which means the command needed to perform the compilation step is verbose. To perform the build, open a terminal instance in your <kbd>/parallel-wasm</kbd> directory and run the following commands:</p>
<pre class="mce-root"># First, compile the add.c file:<strong><br/>emcc -Os -s WASM=1 -s SIDE_MODULE=1 -s BINARYEN_ASYNC_COMPILATION=0 lib/add.c -o src/calc-add.wasm<br/><br/></strong># Next, compile the subtract.c file<strong><br/></strong><strong>emcc -Os -s WASM=1 -s SIDE_MODULE=1 -s BINARYEN_ASYNC_COMPILATION=0 lib/subtract.c -o src/calc-subtract.wasm</strong></pre>
<p class="mce-root">You should see two new files in the <kbd>/src</kbd> directory: <kbd>calc-add.wasm</kbd> and <kbd>calc-subtract.wasm</kbd>. With the required files in place, it's time to test out the application.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Interacting with the application</h1>
                
            
            
                
<p class="mce-root">Open a terminal instance in the <kbd>/parallel-wasm</kbd> directory and run the following command:</p>
<pre class="mce-root"><strong>serve -l 8080 src</strong></pre>
<p class="mce-root">If you navigate to <kbd>http://127.0.0.1:8080/index.html</kbd> in your browser, you should see this:</p>
<div><img src="img/de8e6b2e-53e0-49d2-9628-af2948abcb4e.png" style="width:42.42em;height:18.17em;"/></div>
<p>￼Wasm Workers application running in the browser</p>
<p class="mce-root">Try changing the values in the First Value and Second Value inputs and pressing the Add and Subtract buttons. The Result input should update with the calculated result. If you navigate to <kbd>http://127.0.0.1:8080/index.html?blob=true</kbd>, the URL argument passed to the <kbd>Worker()</kbd> constructor will use a <kbd>Blob</kbd> instead of the filename. The tab should change to reflect that the <kbd>Blob</kbd> technique is used to construct the URL:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/06832741-0c1c-40a3-9b02-e6694db0942c.png" style="width:26.00em;height:5.75em;"/></p>
<p>Tab title updated to reflect the Blob URL technique</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Debugging Web Workers</h1>
                
            
            
                
<p class="mce-root">You can set breakpoints and interact with worker threads using the browser's development tools. In Google Chrome, open Developer Tools and select the Sources tab. The file list panel should contain two instances of <kbd>worker.js</kbd>. The debugger panel contains a Threads section with the <kbd>main</kbd> thread and two <kbd>worker.js</kbd> threads. The following screenshot indicates the thread debugging elements within the Chrome Developer Tools panel for the running application:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/243575cd-3c5c-43ad-a78c-cc3c248a0158.png"/></p>
<p>Thread debugging tools in the Chrome Developer Tools panel</p>
<p class="mce-root"/>
<p class="mce-root">In Firefox, worker debugging is done in separate Developer Tools windows. To see this in action, open Developer Tools in Firefox and select the Debugger panel. Click on one of the <kbd>worker.js</kbd> list items in the Workers panel. A new Developer Tools window should appear that corresponds with the selected worker. The following screenshot shows a separate Developer Tools window for one of the <kbd>worker.js</kbd> instances selected from the Workers panel:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/886e9bcd-c446-4a8d-aab4-2a303255aa2e.png"/></p>
<p>Thread debugging tools in the Firefox Developer Tools panel</p>
<p class="mce-root">In the next section, we'll discuss some of the upcoming features of WebAssembly.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Upcoming features</h1>
                
            
            
                
<p class="mce-root">There are several upcoming WebAssembly features in various phases of the standardization process. Some of them are more impactful than others, but all of them are valuable improvements. In this section, we'll describe the standardization process and review a subset of the features that represent a significant shift in WebAssembly's capabilities. Most of the content in this section was referenced from Colin Eberhardt's blog post titled <em>The future of WebAssembly - A look at upcoming features and proposals</em>. The post can be found at <a href="https://blog.scottlogic.com/2018/07/20/wasm-future.html">https://blog.scottlogic.com/2018/07/20/wasm-future.html</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The standardization process</h1>
                
            
            
                
<p class="mce-root">The WebAssembly W3C Process documentation at <a href="https://github.com/WebAssembly/meetings/blob/master/process/phases.md">https://github.com/WebAssembly/meetings/blob/master/process/phases.md</a> describes the six phases (from 0 to 5) of the standardization process. The following list provides brief descriptions of each of these phases:</p>
<ul>
<li class="mce-root"><strong>Phase 0. Pre-Proposal</strong>: A WebAssembly <strong>Community Group</strong> (<strong>CG</strong>) member has an idea, and the CG votes on whether to move it to Phase 1.</li>
<li class="mce-root"><strong>Phase 1. Feature Proposal</strong>: The pre-proposal process has succeeded and a repository is created in the WebAssembly organization on GitHub to document the feature.</li>
<li class="mce-root"><strong>Phase 2. Proposed Spec Text Available</strong>: The full proposed spec text is available, possible implementations are prototyped, and a test suite is added.</li>
<li class="mce-root"><strong>Phase 3. Implementation Phase</strong>: Embedders implement the feature, the repository is updated to include revisions to the formalization, and the spec is updated to include implementation of the feature in the reference interpreter.</li>
<li class="mce-root"><strong>Phase 4. Standardize the Feature</strong>: If two or more Web VMs and at least one toolchain implement the feature, the feature is fully handed off to the WebAssembly <strong>Working Group</strong> (<strong>WG</strong>).</li>
<li class="mce-root"><strong>Phase 5. The Feature is Standardized</strong>: The WG members have reached consensus that the feature is complete.</li>
</ul>
<p class="mce-root">Now that you're familiar with the phases associated with the standardization process, let's move on to the threads proposal.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Threads</h1>
                
            
            
                
<p class="mce-root">In the previous section, we used Web Workers to move Wasm modules into worker threads, which allowed us to call Wasm functions without blocking the main thread. However, passing messages between worker threads has performance limitations. In an effort to address this issue, a threads feature was proposed for WebAssembly.</p>
<p class="mce-root">The proposal, currently in Phase 1, is described in detail at <a href="https://github.com/WebAssembly/threads/blob/master/proposals/threads/Overview.md">https://github.com/WebAssembly/threads/blob/master/proposals/threads/Overview.md</a>. Per the proposal documentation, the threads feature adds a new shared linear memory type and some new operations for atomic memory access. This proposal is relatively limited in scope. Eberhardt provides the following elaboration in his blog post:</p>
<p>"Notably, this proposal does not introduce a mechanism for creating threads (which has caused a lot of debate) instead this functionality is supplied by the host. Within the context of wasm executed by the browser this will be the familiar WebWorkers."</p>
<p class="mce-root">Although the feature wouldn't allow for the creation of threads, it provides a simpler way of sharing data between the worker threads we create in JavaScript.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Host bindings</h1>
                
            
            
                
<p class="mce-root">The host bindings proposal, which is also in Phase 1, would address a significant limitation of WebAssembly when used in the browser: DOM manipulation. The proposal documentation at <a href="https://github.com/WebAssembly/host-bindings/blob/master/proposals/host-bindings/Overview.md">https://github.com/WebAssembly/host-bindings/blob/master/proposals/host-bindings/Overview.md</a> provides the following list of goals for this feature:</p>
<ul>
<li class="mce-root"><strong>Ergonomics</strong>: Allow WebAssembly modules to create, pass around, call, and manipulate JavaScript + DOM objects</li>
<li class="mce-root"><strong>Speed</strong>: Allow JS/DOM or other host calls to be well optimized</li>
<li class="mce-root"><strong>Platform consistency</strong>: Allow WebIDL to be used to annotate Wasm imports/exports (via a tool)</li>
<li class="mce-root"><strong>Incrementalism</strong>: Provide a strategy that is polyfillable</li>
</ul>
<p class="mce-root">Improving WebAssembly's interoperability with JavaScript and Web APIs would simplify the development process considerably. It would also eliminate the need for the "glue" code that tools such as Emscripten provide.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Garbage collection</h1>
                
            
            
                
<p class="mce-root">The <strong>garbage collection</strong> (<strong>GC</strong>) proposal is currently in Phase 1. We discussed garbage collection in the <em>What are the Limitations?</em> section of <a href="15ca4834-5544-4dd8-b307-f0bc95c63a21.xhtml">Chapter 1</a>, <em>What is WebAssembly?</em> The proposal documentation at <a href="https://github.com/WebAssembly/gc/blob/master/proposals/gc/Overview.md">https://github.com/WebAssembly/gc/blob/master/proposals/gc/Overview.md</a> provides an extensive overview of the feature and describes the elements that need to be added to the specification. Eberhardt provides the following description of the proposal in his blog post:</p>
<p>"This proposal adds GC capabilities to WebAssembly. Interestingly, it will not have its own GC, instead it will integrate with the GC provided by the host environment. This makes a lot of sense as this, and various other proposals (host bindings, reference types), are designed to improve the interop with the host, making it easier to share state and call APIs. Having a single GC to manage memory makes this much easier."</p>
<p class="mce-root">This feature will require a great deal of effort to implement, but adding it to WebAssembly will be worth the effort. Let's wrap up this section with a feature currently in the implementation phase: reference types.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Reference types</h1>
                
            
            
                
<p class="mce-root">Reference types, currently in Phase 3, form the basis for the host bindings and GC features. The proposal documentation at <a href="https://github.com/WebAssembly/reference-types/blob/master/proposals/reference-types/Overview.md">https://github.com/WebAssembly/reference-types/blob/master/proposals/reference-types/Overview.md</a> describes the addition of a new type, <kbd>anyref</kbd>, which can be used as both a value type and a table element type. The <kbd>anyref</kbd> type allows you to pass a JavaScript object to a Wasm module. Eberhardt describes the implications of this feature in his blog post:</p>
<p>"The wasm module can't really do much with the object via the anyref type. What's more important is that the module is holding a reference to a garbage collected object on the JS heap, meaning they need to be traced during wasm execution. This proposal is seen as a stepping-stone towards the more significant garbage collection proposal."</p>
<p class="mce-root">There are several other exciting features in the pipeline for WebAssembly. The WebAssembly CG and WG are devoting their time and resources to making these features a reality. You can view all of the proposals at the WebAssembly organization page on GitHub, located at <a href="https://github.com/WebAssembly">https://github.com/WebAssembly</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p class="mce-root">In this chapter, we reviewed advanced tools and an alternate compilation method for WebAssembly. We learned about WABT and Binaryen's role in the WebAssembly development process and the functionality they provide. We compiled a Wasm module with LLVM through the use of the WebAssembly <kbd>npm</kbd> package and interacted with the result in the browser. We reviewed some of the WebAssembly tooling available online and created a simple application that uses Web Workers to store Wasm modules in separate threads. Finally, we discussed the upcoming features of WebAssembly and the standardization process. Now that you've gained a greater understanding of WebAssembly, go out there and build something!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Questions</h1>
                
            
            
                
<ul>
<li class="mce-root">What does WABT stand for?</li>
<li class="mce-root">What three elements does Binaryen provide to make compiling to WebAssembly <em>easy</em>, <em>fast</em>, and <em>effective</em>?</li>
<li class="mce-root">What is the main difference between modules compiled using Emscripten versus LLVM with regard to the <kbd>importObj</kbd>/<kbd>exports</kbd>?</li>
<li class="mce-root">Which online tool allows you to use AssemblyScript?</li>
<li class="mce-root">What are the two types of arguments you can pass to the <kbd>Worker()</kbd> constructor?</li>
<li class="mce-root">What convention was used for passing messages between the main thread and worker threads?</li>
<li class="mce-root">How many phases are in the WebAssembly standardization process?</li>
<li class="mce-root">What is the name of the new type defined in the reference types feature?</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Further reading</h1>
                
            
            
                
<ul>
<li>A crash course in memory management: <a href="https://hacks.mozilla.org/2017/06/a-crash-course-in-memory-management">https://hacks.mozilla.org/2017/06/a-crash-course-in-memory-management</a></li>
<li class="mce-root">MDN Web Workers API: <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API">https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API</a></li>
<li>WebAssembly - Web Workers: <a href="https://medium.com/@c.gerard.gallant/webassembly-web-workers-f2ba637c3e4a">https://medium.com/@c.gerard.gallant/webassembly-web-workers-f2ba637c3e4a</a></li>
</ul>


            

            
        
    </body></html>