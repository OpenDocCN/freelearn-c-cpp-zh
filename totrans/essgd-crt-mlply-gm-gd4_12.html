<html><head></head><body>
		<div><h1 class="chapter-number" id="_idParaDest-173"><a id="_idTextAnchor285"/>12</h1>
			<h1 id="_idParaDest-174"><a id="_idTextAnchor286"/>Implementing Lag Compensation</h1>
			<p>Welcome to one of the most anticipated chapters in the book. Here, we will dive into the core of online multiplayer game optimization. In the world of online gaming, where players from across the globe unite to embark on epic adventures, two formidable adversaries lurk in the shadows; they <a id="_idIndexMarker435"/>are <strong class="bold">lag</strong> and <strong class="bold">latency</strong>. These foes can transform a thrilling gaming <a id="_idIndexMarker436"/>experience into a frustrating trial. In this chapter, we’ll confront these challenges head-on, arming you with the knowledge and tools to mitigate their impact and create an engaging online gaming environment.</p>
			<p>In this chapter, we will use <code>Player</code> node’s<em class="italic"> </em><code>Spaceship</code> node maintain its position and rotation, synced throughout the game instances across the network. For that, we will understand the core issues regarding packet loss and latency, something common when we use unreliable packets, as we do when using the ENet protocols. Then, we will fake some latency and packet loss by using <code>Timer</code> nodes so that we can understand how these issues may display in the actual game. After that, we will talk about some common techniques to create solutions for these issues.</p>
			<p>By the end of the chapter, you will understand how we can fake some smooth movement, even when the game’s <code>MultiplayerSynchronizer</code> fails to deliver data across peers’ game instances.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Introducing lag issues</li>
				<li>Dealing with unreliable packets</li>
				<li>Common compensation techniques</li>
			</ul>
			<h1 id="_idParaDest-175"><a id="_idTextAnchor287"/>Technical requirements</h1>
			<p>As mentioned in <a href="B18527_10.xhtml#_idTextAnchor260"><em class="italic">Chapter 10</em></a>, <em class="italic">Debugging and Profiling the Network</em>, <em class="italic">Part 3</em>,<em class="italic"> Optimizing the Online Experience</em>, of this book focuses on the final version of the project made in <em class="italic">Chapter 9</em>, <em class="italic">Creating an Online Adventure Prototype</em>, so it’s fundamental to read, exercise, and implement the concepts presented there. You can get the files necessary to start this chapter at the following link: <a href="https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0/tree/12.prediction-and-interpolation">https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0/tree/12.prediction-and-interpolation</a>. They contain the progress we’ve made for optimizations in <a href="B18527_11.xhtml#_idTextAnchor276"><em class="italic">Chapter 11</em></a>, <em class="italic">Optimizing </em><em class="italic">Data Requests</em>.</p>
			<p>It’s also necessary that you have read and understood the concepts and tools presented in <a href="B18527_11.xhtml#_idTextAnchor276"><em class="italic">Chapter 11</em></a>, <em class="italic">Optimizing Data Requests</em>, so that we can continue with the assumption that you already know what they are and how to use them properly.</p>
			<h1 id="_idParaDest-176"><a id="_idTextAnchor288"/>Introducing lag issues</h1>
			<p>Addressing lag<a id="_idIndexMarker438"/> and unreliable packets involves three techniques – <strong class="bold">interpolation</strong>, <strong class="bold">prediction</strong>, and <strong class="bold">extrapolation</strong>. These <a id="_idIndexMarker439"/>techniques smoothen player movements, maintain<a id="_idIndexMarker440"/> responsiveness, and anticipate object movements. The Godot Engine’s <a id="_idIndexMarker441"/>physics simulation and RPC method are crucial in these techniques, aiding in realistic object movement and data synchronization, despite network issues.</p>
			<p>Lag and latency<a id="_idIndexMarker442"/> are the archenemies of any online multiplayer game. Lag, often used interchangeably with latency, refers to the delay between a player’s action and its corresponding effect in the game. It’s the momentary pause between pulling the trigger and seeing the enemy fall. Latency, on the other hand, represents the time it takes for data to travel from a player’s device to the game server and back. Together, these factors can disrupt the fluidity of gameplay, leaving players frustrated and disconnected from the virtual world.</p>
			<p>Within the world of online multiplayer gaming, the transmission of data is seldom a seamless journey. Unreliable packets, those mischievous bits of information, can create issues by arriving out of order or disappearing altogether. When packets are out of order, a player might see an opponent magically teleport across the map and back or perform impossible feats. Data loss results in vital game updates never reaching their intended destination, leaving characters and objects frozen in time. Our mission in this chapter is to combat these issues and bring order to the chaos.</p>
			<p>In the realm of online multiplayer gaming, a recurring and often frustrating issue that plagues both developers and players alike is the challenge of lag and latency. In this section, we’ll talk about these two fundamental aspects of online gaming and shed light on the profound impact they have on a player’s experience. As you already discovered in previous chapters, creating a seamless and immersive multiplayer environment requires a nuanced understanding of these concepts.</p>
			<p>Now, let’s talk about the impact of lag and latency on gameplay. When a player experiences lag, it disrupts the flow of the game and can lead to missed opportunities, frustration, and, in competitive scenarios, unfavorable outcomes. Imagine firing a weapon in an online shooter, only to have the shot register seconds later, long after your target has moved to safety.</p>
			<p>Understanding the causes of lag<a id="_idIndexMarker443"/> and latency<a id="_idIndexMarker444"/> is crucial for effective mitigation. Network congestion, hardware limitations, and geographic distance between players and servers are common causes. <strong class="bold">Network congestion</strong> occurs <a id="_idIndexMarker445"/>when the data traffic on a network is too high, causing data packets to be delayed or lost. Hardware limitations, such as a slow internet connection or an underpowered computer, can also contribute to latency.</p>
			<p>Mitigating lag and latency is a constant challenge for game developers. One strategy is server optimization, where game servers are finely tuned to handle large volumes of data efficiently. Another approach is client-side prediction and interpolation, techniques that help to smooth out gameplay even when there are network delays; we will talk about these in the <em class="italic">Common compensation techniques</em> section. On top of these, choosing the right network infrastructure, such as <strong class="bold">Content Delivery Networks</strong> (<strong class="bold">CDNs</strong>), can <a id="_idIndexMarker446"/>significantly reduce latency by placing game assets closer to players.</p>
			<p>We’ve peeled back the layers of lag and latency, understanding how these factors impact online multiplayer games. We saw some of their causes and discussed strategies for mitigation, all with the goal of enhancing a player’s gaming experience. In the next section, we will talk about issues specific to unreliable packets, which are what we usually use to transfer data over a network in online multiplayer games.</p>
			<h1 id="_idParaDest-177"><a id="_idTextAnchor289"/>Dealing with unreliable packets</h1>
			<p>One of the top concerns that<a id="_idIndexMarker447"/> developers grapple with when creating online multiplayer games is the reliability of data packets. In this section, we’ll see the complexities surrounding unreliable packets, shedding light on the issues they bring to the forefront of online multiplayer games. As you’ve already gleaned from our discussions, understanding these challenges is core to crafting a smooth and immersive multiplayer gaming experience.</p>
			<p><strong class="bold">Unreliable packets</strong>, as the <a id="_idIndexMarker448"/>name suggests, are data packets sent over a network without any guarantee of arrival or order. They’re like letters in the wind, reaching their destination only if the conditions are favorable. These packets are used to transmit non-critical data in online games, such as character positions, because they offer lower latency compared to reliable packets, which come with built-in delivery assurances at the expense of potential lag.</p>
			<p>One of the primary issues associated with unreliable packets is packet loss. This occurs when packets sent from one player’s device fail to reach a server or another player’s device. It’s like pieces of a puzzle disappearing into thin air, leading to incomplete and inconsistent data. In a fast-paced action game, packet loss can manifest as abrupt character teleportations, vanished projectiles, or inexplicable desynchronization among players.</p>
			<p>Another challenge is the out-of-order arrival of packets. In an ideal world, data packets would arrive at their destination in the same order they were sent. However, the unpredictability of network routes can cause packets to arrive out of order, leading to chaos in the game world. Imagine receiving instructions to assemble a piece of furniture, only to receive the steps out of sequence; it’s a recipe for confusion and frustration. Usually, in these cases, we only use the latest data and ignore the older ones, as only the most recent information is relevant to the game.</p>
			<p>The consequences of unreliable packets can be dire for gameplay. Packet loss and out-of-order arrivals can lead to player disconnection, incorrect character positions, and erratic synchronization among players. For example, a player’s character might appear to jump from one location to another due to missing packets. This not only disrupts immersion but also undermines the fairness and integrity of competitive play.</p>
			<p>Mitigating the issues brought on by unreliable packets requires a multifaceted approach. Developers often employ techniques such as client-side prediction, where the client makes informed guesses about missing data to maintain a coherent game state. Interpolation, another valuable tool, smooths out the jitters caused by missing packets by smoothly transitioning between known data points.</p>
			<p>In this section, we saw that packet loss is a common issue where packets fail to reach their destination, leading to incomplete and inconsistent data. We also saw that some packets may arrive out of order, causing chaos in the game world. These issues can result in player disconnection, incorrect character positions, and erratic synchronization among players. In the next section, we are going to see the most common compensation techniques to solve these<a id="_idIndexMarker449"/> and the lag-related issues.</p>
			<h1 id="_idParaDest-178"><a id="_idTextAnchor290"/>Common compensation techniques</h1>
			<p>Welcome to the<a id="_idIndexMarker450"/> most anticipated section in our journey through the realm of online multiplayer game development. In the previous sections, we unraveled the complexities of networking, synchronization, and the intricacies of dealing with unreliable packets. Now, we stand at a <a id="_idIndexMarker451"/>crucial juncture, ready to explore the fascinating world of <strong class="bold">interpolation</strong>, <strong class="bold">prediction</strong>, and <strong class="bold">extrapolation</strong>, a<a id="_idIndexMarker452"/> trio of techniques that hold the key to creating seamless and <a id="_idIndexMarker453"/>responsive online gaming experiences, or at least to get as close as we can to this Holy Grail.</p>
			<p>Picture this – you’re in the heat of an intense multiplayer battle, and the stakes couldn’t be higher. In the world of online gaming, every second counts, and every move must be precise. But what happens when network latency rears its head, causing a slight delay in transmitting data between players? This is where interpolation, prediction, and extrapolation come to the rescue.</p>
			<p>One of the cornerstones of implementing interpolation, prediction, and extrapolation is the integration of physics simulation. In <strong class="bold">Godot Engine</strong>, the <a id="_idIndexMarker454"/>physics engine plays a crucial role in determining how objects move and interact within the game world. By marrying physics with prediction algorithms, you can create a realistic and responsive gameplay experience that feels in sync with the laws of our virtual universe.</p>
			<p>To orchestrate the symphony of data synchronization, we’ll take rid of the <code>Player</code> node’s <code>MultiplayerSynchronizer</code> node and employ some <em class="italic">RPC</em> methods. These functions serve as the conductor of our data orchestra, allowing us to send the necessary information to clients or a server precisely when it’s needed. With RPCs, we can trigger the transmission of interpolated, predicted, or extrapolated data, ensuring that all players stay on the same page.</p>
			<p>In the next sections, we’ll jump into the implementation of interpolation, prediction, and extrapolation in our online multiplayer top-down adventure prototype. By the end, you’ll understand how these techniques work together to compensate for network latency. So, fasten your seatbelts, for we are about to navigate the intricacies of smooth and responsive gameplay in the dynamic world of online multiplayer gaming.</p>
			<h2 id="_idParaDest-179"><a id="_idTextAnchor291"/>Implementing server-side motion</h2>
			<p>To have a <a id="_idIndexMarker455"/>better setup to understand how lag influences the gameplay experience, we are going to make some changes to the <code>Player</code> scene and scripts. Instead of allowing the movement to happen on the client side and being synced to the server and other peers, a player will use input events to change the movement of a server’s <code>Spaceship</code> instance. This will allow us to also decrease the amount of syncing data sent by <code>MultiplayerSynchronizer</code>, since now we will have the motion simulated, based on <code>Spaceship</code>’s thrusting and rotating states. To do that, let’s open the <code>res://09.prototyping-space-adventure/Actors/Player/Player2D.tscn</code> scene. Then, follow the following steps:</p>
			<ol>
				<li>Select the <code>MultiplayerSynchronizer</code> node, and in the <code>Spaceship</code>’s position and rotation sync on both the <strong class="bold">Spawn</strong> and <strong class="bold">Sync</strong> options:</li>
			</ol>
			<div><div><img alt="Figure 12.1 – The Player scene’s MultiplayerSynchronizer Replication menu, with the Spaceship position and rotation properties disabled" src="img/Figure_12.01_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1 – The Player scene’s MultiplayerSynchronizer Replication menu, with the Spaceship position and rotation properties disabled</p>
			<ol>
				<li value="2">Then, let’s open the <code>res://09.prototyping-space- adventure/Actors/Player/Player2D.gd</code> file, and we will make some changes to the <code>setup_multiplayer()</code> method. The first thing to do here is to remove the line that enables the <code>_physics_process()</code> and <code>_process()</code> callbacks, leaving only <code>_unhandled_input()</code>. We will see why in the following steps:<pre class="source-code">
@rpc("any_peer", "call_local")
func setup_multiplayer(player_id):
     var self_id = multiplayer.get_unique_id()
     var is_player = self_id == player_id
     set_process_unhandled_input(is_player)
     camera.enabled = is_player</pre></li>				<li>Then, we <a id="_idIndexMarker456"/>will check whether the current instance isn’t the server; if it isn’t, we call the <code>make_current()</code> method, effectively enabling this player’s <code>Camera2D</code> node on their game instance:<pre class="source-code">
func setup_multiplayer(player_id):
     var self_id = multiplayer.get_unique_id()     var is_player = self_id == player_id      set_process_unhandled_input(is_player)      camera.enabled = is_player
     if not multiplayer.is_server():</pre></li>				<li>Next, we will lay the groundwork the new <code>Spaceship</code> node movement logic, get rid of the <code>_physics_process()</code> callback, and work in the <code>_unhandled_input()</code> callback instead. The whole logic follows the same idea of <code>Weapon2D</code>; <code>Spaceship</code> will have <code>thrusting</code>, <code>direction</code>, and <code>turning</code> variables that we can use to change its movement. Based on the input events we get in <code>_unhandled_input()</code>, we will change the state of these variables. The secret here is that we will use the <code>rpc_id()</code> method to change these states on the server’s <code>Spaceship</code> instance.<pre>_unhandled_input()</strong> callback after adding this new logic:</pre><pre class="source-code">
func _unhandled_input(event):
     if event.is_action_pressed("shoot"):
          weapon.rpc("set_firing", true)
     elif event.is_action_released("shoot"):
          weapon.rpc("set_firing", false)
# Thrusting logic. The spaceship enables its thrust based on if the `thurst_acti
on` was pressed or released
     if event.is_action_pressed(thrust_action):
          spaceship.rpc_id(1, "set_thrusting", true)
     elif event.is_action_released(thrust_action):
          spaceship.rpc_id(1, "set_thrusting", false)
# Turning logic. If a turning key is just pressed or still pressed, the spaceshi
p turns, it only stops turning if neither `turn_left_action` or `turn_right_action
` are pressed.
     if event.is_action_pressed(turn_left_action):
          spaceship.rpc_id(1, "set_direction", -1)
          spaceship.rpc_id(1, "set_turning", true)
     elif event.is_action_released(turn_left_action):
          if Input.is_action_pressed(turn_right_action):
spaceship.rpc_id(1, "set_direction", 1)
12 Implementing Lag Compensation 8
     else:
          spaceship.rpc_id(1, "set_turning", false)
          spaceship.rpc_id(1, "set_direction", 0)
     if event.is_action_pressed(turn_right_action):
          spaceship.rpc_id(1, "set_direction", 1)
          spaceship.rpc_id(1, "set_turning", true)
     elif event.is_action_released(turn_right_action):
     if Input.is_action_pressed(turn_left_action):
          spaceship.rpc_id(1, "set_direction", -1)
     else:
          spaceship.rpc_id(1, "set_turning", false)
          spaceship.rpc_id(1, "set_direction", 0)</pre></li>				<li>Now, let’s<a id="_idIndexMarker457"/> move on to the <code>res://09.prototyping-space- adventure/Objects/Spaceship/Spaceship.gd</code> script, where we will implement the variables and methods necessary for the aforementioned changes to work. First, let’s declare the properties and their setter methods:<pre class="source-code">
@export var thrusting = false : set = set_thrusting @export var turning = false : set = set_turning
@export_range(-1, 1, 1) var direction = 0 : set = set_direction</pre></li>				<li>Then, let’s declare these methods; here’s the trick – they are <em class="italic">RPCs</em> that any peer can call, and they will be called locally:<pre class="source-code">
@rpc("any_peer", "call_local")
func set_thrusting(is_thrusting):
     thrusting = is_thrusting
@rpc("any_peer", "call_local")
func set_turning(is_turning):
     turning = is_turning
@rpc("any_peer", "call_local")
func set_direction(new_direction):
     direction = new_direction</pre></li>				<li>Then, we will make changes to the <code>thrust()</code> and <code>turn()</code> methods. The whole idea is that they will receive the delta as an argument now. The <code>turn()</code> doesn’t need to receive a direction argument anymore, since the direction became a <code>member</code> variable:<pre class="source-code">
func thrust(delta):
     linear_velocity += (acceleration * delta) * Vector2.RIGHT.rotated(rotation)
func turn(delta):
     angular_velocity += (direction * turn_torque) * delta</pre></li>				<li>Finally, we <a id="_idIndexMarker458"/>will use the <code>_physics_process()</code> callback to call the <code>thrust()</code> and <code>turn()</code> methods, based on the thrusting and turning variable states:<pre class="source-code">
func _physics_process(delta):
if thrusting:
     thrust(delta)
if turning:
     turn(delta)</pre><p class="list-inset">With that, we have everything we need to keep the movement as it was, but now the server is responsible for responding to the player’s input instead of being passive to how the <code>Spaceship</code> node behaved in the player’s game instance. This is important, due to how lag and latency compensation works, as we need an instance of the game to always fall back to if we need to update some data that may have been lost on the network. On top of that, some techniques involve the server side ultimately handling discrepancies. There’s an excellent video on <em class="italic">YouTube</em> called <em class="italic">How to reduce Lag - A Tutorial on Lag Compensation Techniques for Online Games</em> that explains the role of each side of the connection in <a id="_idIndexMarker459"/>lag compensation techniques. This video is available at this link and is highly recommended: <a href="https://www.youtube.com/watch?v=2kIgbvl7FRs">https://www.youtube.com/watch?v=2kIgbvl7FRs</a>.</p></li>			</ol>
			<p>Now that we have this in place, we can start to implement the actual techniques that will help us deal with this issue. In the next section, we will set up our fake lag mechanisms, which are basically <code>twoTimers</code>, and see how we can use the <code>Tween</code> node to implement <em class="italic">interpolation</em> in our game so that we can create a fluid motion, based on the sparse <code>Spaceship</code> node position and rotation updates.</p>
			<h2 id="_idParaDest-180"><a id="_idTextAnchor292"/>Bridging the gaps with interpolation</h2>
			<p><strong class="bold">Interpolation</strong> is the art of<a id="_idIndexMarker460"/> filling in the gaps between received data points. When data packets arrive at irregular intervals due to network latency or packet loss, interpolation <a id="_idIndexMarker461"/>ensures that the movement of characters, objects, and projectiles appears smooth and continuous. Imagine it as the magic glue that binds fragmented data, allowing players to witness uninterrupted, fluid motion.</p>
			<p>In this section, we will see how we can use the <code>Tween</code> class to interpolate the sparse data we will receive from players. <code>Tween</code> is a specialized class that is used to interpolate values in Godot Engine. We will also use the lerping methods, <code>lerp()</code> and <code>lerp_angle()</code>, to find the correct values to use in the interpolation, especially for <code>Spaceship</code>’s rotation angles.</p>
			<p>To fake some latency, we will use <code>Timer</code> nodes so that we can see how our interpolation will work in different scenarios. However, ideally, you would use <code>ENetPacketPeer.get_statistic()</code> method passing <code>ENetPacketPeer.PEER_ROUND_TRIP_TIME</code> as argument to get access to the actual network latency. We can access the <code>ENetPacketPeer</code> instance referring to the server’s peer connection using <code>multiplayer.multiplayer_peer.get_peer(1)</code>in order to call the <code>get_statistic()</code> method on it. So, to access a player’s latency to a server, we can use the following code snippet:</p>
			<pre class="source-code">
# Only clients should get statistics about their connection with the server, so we don't call that on the server itself.
if not multiplayer.is_server():
     var server_connection = multiplayer.multiplayer_peer.get_peer(1)
     var latency = server_connection.get_statistic(ENetPacketPeer.PEER_ROUND_TRIP_TIM
E))
     print(latency)</pre>			<p>That being said, we <a id="_idIndexMarker462"/>are going to make some changes to the <code>Player</code> scene and script so that we can implement the interpolation logic and understand how to use this technique. Open the <code>res://09.prototyping-space-adventure/Actors/Player/Player2D.tscn</code> scene and follow the following steps to implement our interpolation logic:</p>
			<ol>
				<li>Since we are not syncing the <code>Spaceship</code> node’s position and rotation properties using the <code>MultiplayerSynchronizer</code> node anymore, we are going to add <code>Timer</code> node to simulate some latency. So, add a new <code>Timer</code> node to the scene, and name it <code>InterpolationTimer</code>.</li>
			</ol>
			<div><div><img alt="Figure 12.2 – Player’s scene node hierarchy with the newly added InterpolationTimer" src="img/Figure_12.02_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2 – Player’s scene node hierarchy with the newly added InterpolationTimer</p>
			<ol>
				<li value="2">Then, let’s set <code>0.1</code>. In this context, <code>0.1</code> wait time would<a id="_idIndexMarker463"/> be as high as a 100 ms latency, which is already high enough for players to start noticing some jittering and noticeable delays in their interactions.</li>
			</ol>
			<div><div><img alt="Figure 12.3 – The InterpolationTimer node settings" src="img/Figure_12.03_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.3 – The InterpolationTimer node settings</p>
			<ol>
				<li value="3">With that, our <a id="_idIndexMarker464"/>next step is to connect the <code>timeout</code> signal to the <code>Player</code> node’s script; we can create a callback method called <code>_on_interpolation_timer_timeout()</code>, like so:</li>
			</ol>
			<div><div><img alt="Figure 12.4 – The InterpolationTimer timeout signal connection" src="img/Figure_12.04_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.4 – The InterpolationTimer timeout signal connection</p>
			<ol>
				<li value="4">Then, let’s move on to the <code>res://09.prototyping-space-nadventure/Actors/Player/Player2D.gd</code> script. Here, we will create two new variables to store the previously known <code>Spaceship</code> node’s position and rotation. This will be necessary to interpolate from the previous to the newest values moving forward:<pre class="source-code">
@onready var previous_position = spaceship.position
@onready var previous_rotation = spaceship.rotation</pre></li>				<li>Now, in the <code>_on_interpolation_timer_timeout()</code> callback, we will make two<a id="_idIndexMarker465"/> RPC calls. One to the the <code>"interpolate_position"</code>method and the other to the <code>"interpolate_rotation"</code> method. These methods will ask for two arguments – the target property (for example, position or rotation), and the duration of the interpolation. In this case, we will use the <code>InterpolationTimer.wait_time</code> property as the duration, since this is the time interval between network updates in this context. We will set up these methods in the following steps:<pre class="source-code">
func _on_interpolation_timer_timeout():
     rpc("interpolate_position", spaceship.position, $InterpolationTimer.wait_time)
     rpc("interpolate_rotation", spaceship.rotation, $InterpolationTimer.wait_time)</pre></li>				<li>Now, let’s declare these methods, starting with <code>interpolate_position()</code>. Only the server should be able to call these methods remotely because it’s the server that will update these properties, so their <code>@rpc</code> annotation should use <code>"authority"</code> and <code>"call_remote"</code> as options:<pre class="source-code">
@rpc("authority", "call_remote")
func interpolate_position(target_position, duration_in_seconds):</pre></li>				<li>Inside the <code>interpolate_position()</code> method, the first thing we will do is create a new <code>Tween</code> instance and store it in a variable, using the <code>create_tween()</code> method:<pre class="source-code">
@rpc("authority", "call_remote")
func interpolate_position(target_position, duration_in_seconds):
     var tween = create_tween()</pre></li>				<li>Then, we will <a id="_idIndexMarker466"/>use the <code>lerp()</code> function to figure out the final value we will use in the interpolation. For the <code>position</code> property, this is not as useful, but it will be in the rotation case. However, let’s do it this way to maintain some consistency between these functions:<pre class="source-code">
@rpc("authority", "call_remote")
func interpolate_position(target_position, duration_in_seconds):
     var tween = create_tween()</pre></li>				<li>Since we are playing with a body that will run some physics simulation, it’s safer to use the <code>Tween.TWEEN_PROCESS_PHYSICS</code> mode in <code>tween</code> variable so that the interpolation happens during the physics processing. For that, we use the <code>Tween.set_process_mode()</code> method:<pre class="source-code">
@rpc("authority", "call_remote")
func interpolate_position(target_position, duration_in_seconds):
     var tween = create_tween()
     var final_value = lerp(previous_position, target_position, 1.0)
     tween.set_process_mode(Tween.TWEEN_PROCESS_PHYSICS)</pre></li>				<li>Then, we can<a id="_idIndexMarker467"/> start the actual interpolation; we will store it into a variable called <code>tweener</code>, as <code>Tween.tween_property</code> returns a <code>PropertyTween</code> object that we can use when necessary. In this function, we pass four arguments – the object, the property that’s going to be interpolated, the target value, and the duration of the interpolation in seconds:<pre class="source-code">
@rpc("authority", "call_remote")
func interpolate_position(target_position, duration_in_seconds):
     var tween = create_tween()
     var final_value = lerp(previous_position, target_position, 1.0)
     tween.set_process_mode(Tween.TWEEN_PROCESS_PHYSICS)
     var tweener = tween.tween_property(spaceship, "position", final_value, duration_
in_seconds)</pre></li>				<li>To ensure the interpolation will happen from the previous known value and the most recent one, we will change <code>tweener</code>’s starting value, using the <code>from()</code> method and passing <code>previous_position</code> as an argument:<pre class="source-code">
@rpc("authority", "call_remote")
func interpolate_position(target_position, duration_in_seconds):
     var tween = create_tween()
     var final_value = lerp(previous_position, target_position, 1.0)
     tween.set_process_mode(Tween.TWEEN_PROCESS_PHYSICS)
     var tweener = tween.tween_property(spaceship, "position", final_value, duration_
in_seconds)
     tweener.from(previous_position)</pre></li>				<li>Then, we <a id="_idIndexMarker468"/>update <code>previous_posistion</code> to match the now-known most current value, which is our <code>final_value</code>:<pre class="source-code">
@rpc("authority", "call_remote")
func interpolate_position(target_position, duration_in_seconds):var tween = create_tween()
     var final_value = lerp(previous_position, target_position, 1.0)
     tween.set_process_mode(Tween.TWEEN_PROCESS_PHYSICS)
     var tweener = tween.tween_property(spaceship, "position", final_value, duration_
in_seconds)
     tweener.from(previous_position)
     previous_position = final_value</pre></li>				<li>As for <code>interpolate_rotation</code>, we will do the same thing, but this time, we will use the <code>lerp_angle()</code> function. This is because interpolating angles is a bit trickier, as we would need to know the shortest path between the starting and target angles. Using this function with a weight of <code>1.0</code> provides the final value properly and saves us a lot of time. The whole <code>interpolate_rotation()</code> method is very similar to the <code>interpolate_position()</code> method but, of course, passing the <code>previous_rotation</code> variable instead of the <code>previous_position</code> variable. It looks like this:<pre class="source-code">
@rpc("authority", "call_remote")
func interpolate_rotation(target_rotation, duration_in_seconds):
     var tween = create_tween()
     var final_value = lerp_angle(previous_rotation, target_rotation, 1.0)
     tween.set_process_mode(Tween.TWEEN_PROCESS_PHYSICS)
     var tweener = tween.tween_property(spaceship, "rotation", final_value, duration_
in_seconds)
     tweener.from(previous_rotation)
     previous_rotation = final_value</pre></li>				<li>Now, we need to start <code>InterpolationTimer</code> if the current instance is the connection’s server. For that, move to the <code>setup_multiplayer()</code> method and add an <code>else</code> statement; inside it, start the timer. Don’t forget to remove the line that sets up the new instance authority, as from now on, the server itself will always be <code>Player</code>’s authority. The <code>setup_multiplayer()</code> method should look <a id="_idIndexMarker469"/>like this:<pre class="source-code">
@rpc("any_peer", "call_local")
func setup_multiplayer(player_id):
     var self_id = multiplayer.get_unique_id() var      is_player = self_id == player_id      set_process_unhandled_input(is_player)      camera.enabled = is_player
     if not multiplayer.is_server():
          camera.make_current()
     else:</pre><p class="list-inset">And there we have it – our interpolation logic is ready to smoothly move and rotate our <code>Spaceship</code> node, just by getting sparse updates from a server. Note that since we are faking some latency, we are using a fixed interpolation duration. In a more realistic scenario, you’d use the <code>ENetPacketPeer.PEER_ROUND_TRIP_TIME</code> statistic as a reference for the actual interpolation <a id="_idIndexMarker470"/>duration.</p></li>			</ol>
			<p>In this section, we saw how we can use the <code>Timer</code> node to fake some latency and, by using the <code>Tween</code> class, interpolate between two known values for the <code>Spaceship</code> node’s position and rotation. We also saw how to access some statistics regarding the connection between two peers, especially regarding the latency between clients and a server. However, what happens when we need to keep some consistency in movement while we don’t get updates from the server? This is what we will discuss in the next section!</p>
			<h2 id="_idParaDest-181"><a id="_idTextAnchor293"/>Playing ahead with prediction</h2>
			<p><strong class="bold">Prediction</strong>, different from<a id="_idIndexMarker471"/> interpolation, is all about playing ahead of the game – quite <a id="_idIndexMarker472"/>literally. It involves making informed guesses about an object’s future position based on its past behavior. When network delays cause data updates to lag, prediction steps in, ensuring that your character’s actions remain responsive and instantaneous, even in the face of network hiccups.</p>
			<p>To implement prediction, we are going to use some Newtonian physics to calculate the <code>Spaceship</code> node’s velocity and project, based on this calculation, where it will likely be in the next tic, and use it to extrapolate its position and rotation moving forward. This will help us prevent the <code>Spaceship</code> node from idling.</p>
			<p>A core aspect of prediction and extrapolation is that they aim to fix some drawbacks of the interpolation. For instance, from time to time, we need to re-sync the actual <code>Spaceship</code> node’s position because, otherwise, due to the interpolation duration and potential latency involved, the <code>Spaceship</code> node will always be lagged behind, and this can accumulate to a point where the game isn’t played in real time anymore. Also, we will use this synchronization time as a reference for the predictions. So, open the <code>res://09.prototyping-space-adventure/Actors/Player/Player2D.tscn</code> scene, and let’s start implementing the necessary steps:</p>
			<ol>
				<li>First of all, let’s add a new <code>Timer</code> node, and name it <code>SynchronizationTimer</code>. This one needs to be at a pace greater than <code>InterpolationTimer</code>.</li>
			</ol>
			<div><div><img alt="Figure 12.5 – Player’s scene hierarchy with the SynchronizationTimer node" src="img/Figure_12.05_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.5 – Player’s scene hierarchy with the SynchronizationTimer node</p>
			<ol>
				<li value="2">Then, we will<a id="_idIndexMarker473"/> connect <code>SynchronizationTimer</code> node’s <code>timeout</code> signal to the <code>Player</code> node’s script in a callback, which we can name <code>_on_synchronization_timer_timeout()</code>.</li>
			</ol>
			<div><div><img alt="Figure 12.6 – The SynchronizationTimer timeout signal connecting to Player’s _on_synchronization_timer_timeout() method" src="img/Figure_12.06_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.6 – The SynchronizationTimer timeout signal connecting to Player’s _on_synchronization_timer_timeout() method</p>
			<ol>
				<li value="3">Then, let’s <a id="_idIndexMarker474"/>open the <code>res://09.prototyping-space-</code> <code>adventure/Actors/Player/Player2D.gd</code> script, and in the <code>setup_multiplayer()</code> method, we will also start <code>SynchronizationTimer</code> if this instance is the server:<pre class="source-code">
@rpc("any_peer", "call_local")
func setup_multiplayer(player_id):
     var self_id = multiplayer.get_unique_id()
     var is_player = self_id == player_id
     set_process_unhandled_input(is_player)
     camera.enabled = is_player
     if not multiplayer.is_server():
          camera.make_current()
     else:
          $InterpolationTimer.start()
          $SynchronizationTimer.start()</pre></li>				<li>Now, in the <code>_on_synchronization_timer_timeout()</code> callback, we will make two <em class="italic">RPC</em>s – one to a method called <code>synchronize_position()</code> and another to a method called <code>synchronize_rotation()</code>. We will implement these methods<a id="_idIndexMarker475"/> shortly, but for now, just know they ask for a target position and rotation, respectively, and a synchronization tic. For the synchronization tic, we will use the <code>SynchronizationTimer</code> node’s <code>wait_time</code> property as reference:<pre class="source-code">
func _on_synchronization_timer_timeout():
     rpc("synchronize_position", spaceship.position, $SynchronizationTimer.wait_time)
     rpc("synchronize_rotation", spaceship.rotation, $SynchronizationTimer.wait_time)</pre></li>				<li>Now, let’s start by implementing the <code>synchronize_position()</code> method. Only the <code>Spaceship</code> node, it should only call remotely:<pre class="source-code">
@rpc("authority", "call_remote")
func synchronize_position(new_position, synchronization_tic):</pre></li>				<li>Inside this method, we will stop all currently processing <code>Tween</code> instances; note that this approach works in our game because we only have the <code>interpolate_*()</code> methods creating <code>Tween</code> instances. If you have other <code>Tween</code> instances running in your game, I recommend storing them in an array and running through them to stop the active ones. We do that to stop the interpolation from continuing as we will set the <code>Spaceship</code> node’s final position manually:<pre class="source-code">
@rpc("authority", "call_remote")
func synchronize_position(new_position, synchronization_tic):
     for tween in get_tree().get_processed_tweens():
          tween.stop()</pre></li>				<li>Then, we will <a id="_idIndexMarker477"/>create a variable to store the future position, based on a prediction we will make, taking the previous and the new positions we just received. We will work on the prediction method later, but for now, just know that it will ask for a new position and how many seconds ahead you want to predict. We will use this prediction to extrapolate movement when we implement extrapolation in the <em class="italic">Gazing into the future with </em><em class="italic">extrapolation</em> section:<pre class="source-code">
@rpc("authority", "call_remote")
func synchronize_position(new_position,      synchronization_tic):
     for tween in get_tree().get_processed_tweens():
     tween.stop()
     var future_position = predict_position(new_position, synchronization_tic)</pre></li>				<li>After that, we can set the <code>Spaceship</code> node’s position to the new position and update <code>previous_position</code> to match the most recent value, so in the next tic, it maintains a reference to the previously updated value:<pre class="source-code">
@rpc("authority", "call_remote")
func synchronize_position(new_position, synchronization_tic):
for tween in get_tree().get_processed_tweens():
tween.stop()
var future_position = predict_position(new_position, synchronization_tic)
spaceship.position = new_position
previous_position = new_position</pre></li>				<li>As for the <code>predict_position()</code> method, it will happen locally on the client’s machine, so there’s no need to make an RPC here. Let’s declare the function’s signature and see how we can predict the future with some physics:<pre class="source-code">
func predict_position(new_position, seconds_ahead):</pre><p class="list-inset">Inside the <code>predict_position()</code> method, we will calculate the distance from the previous<a id="_idIndexMarker478"/> position to the new one. We will also calculate the direction from the previous position to the new position so that we have <code>Vector2</code> to work with, predicting the movement’s velocity:</p><pre class="source-code">func predict_position(new_position, seconds_ahead):
var distance = previous_position.distance_to(new_position)
var direction = previous_position.direction_to(new_position)</pre></li>				<li>With that, we will calculate the movement’s linear velocity, based on how many seconds ahead we want to predict. We will then set this linear velocity as the <code>Spaceship</code>.<code>linear_velocity</code> property so that we it doesn’t idle between updates, asthe <code>Spaceship</code> node will start moving using this new velocity:<pre class="source-code">
func predict_position(new_position, seconds_ahead): var distance = previous_position.distance_to(new_position) var direction = previous_position.direction_to(new_position) var linear_velocity = (direction * distance) / seconds_ahead spaceship.linear_velocity = linear_velocity</pre></li>				<li>Finally, we will add the linear velocity to the new position to predict what will be the next position. We will then return this new position so that we can use this value when we decide to extrapolate the <code>Spaceship</code> node’s movement:<pre class="source-code">
func predict_position(new_position, seconds_ahead):
var distance = previous_position.distance_to(new_position)
var direction = previous_position.direction_to(new_position)
var linear_velocity = (direction * distance) / seconds_ahead
spaceship.linear_velocity = linear_velocity
var next_position = new_position + (linear_velocity * seconds_ahead)
return next_position</pre></li>				<li>The logic <a id="_idIndexMarker479"/>to predict the rotation will be exactly the same, but take into account that we will use the <code>learp_angle()</code> built-in method to figure out the closest angle to extrapolate to. The <code>synchronize_rotation()</code> method will look like this:<pre class="source-code">
@rpc("authority", "call_remote")
func synchronize_rotation(new_rotation, synchronization_tic):
for tween in get_tree().get_processed_tweens():
tween.stop()
var future_rotation = predict_rotation(new_rotation, synchronization_tic)
spaceship.rotation = new_rotation
previous_rotation = new_rotation</pre></li>				<li>The <code>predict_rotation()</code> method will look like this:<pre class="source-code">
func predict_rotation(new_rotation, seconds_ahead):
var angular_velocity = lerp_angle(previous_rotation, new_rotation, 1.0) / second
s_ahead
spaceship.angular_velocity = angular_velocity
var next_rotation = spaceship.rotation + (angular_velocity * seconds_ahead)
return next_rotation</pre><p class="list-inset">With that, we can start to make assumptions of where the <code>Spaceship</code> node is likely to be in the near future, based on <code>SynchronizationTimer</code> node’s tics. However, note that this is a very important available function on the server side, as sometimes, we may want to use it to mitigate lag in <em class="italic">Player</em> interactions and trigger the right game events. For<a id="_idIndexMarker480"/> instance, if we decide to have some <strong class="bold">player versus player</strong> (<strong class="bold">PvP</strong>) interactions, we may need to predict where a given player’s <em class="italic">Spaceship</em> was when another player fired their gun. This is because, due to latency, the player may have made a guessed shot and landed a hit. However, it is up to the server to decide whether the shot would actually land, given the<a id="_idIndexMarker481"/> latency and other aspects.</p></li>			</ol>
			<p>In this section, we have seen two important techniques to handle lag and latency in online multiplayer games – prediction and synchronization. Prediction involves making informed guesses about an object’s future position and rotation, based on its past behavior. To implement prediction, Newtonian physics calculations are used to calculate the <code>Spaceship</code> node’s velocity and project its likely future position and rotation.</p>
			<p>We also saw how to implement the synchronization process, by stopping ongoing <code>Tween</code> instances and updating the <code>Spaceship</code> node’s position and rotation accordingly.</p>
			<p>In the next section, we will use the predicted position and rotation to extrapolate <code>Spaceship</code> node’s movement, both linear and angular, so that if we happen to miss updates, we can at least fake a movement and fix it in the synchronization later if necessary.</p>
			<h2 id="_idParaDest-182"><a id="_idTextAnchor294"/>Gazing into the future with extrapolation</h2>
			<p>Extrapolation is the<a id="_idIndexMarker482"/> visionary member of the lag compensation trio, gazing into the future to anticipate where objects will be next. By analyzing the current state of a game and the <a id="_idIndexMarker483"/>trajectory of objects, extrapolation extends beyond the data you have, offering a glimpse into what lies ahead. This technique is particularly handy for fast-paced games, where a split-second delay can mean the difference between victory and defeat.</p>
			<p>The whole idea of<a id="_idIndexMarker484"/> extrapolation is that it is an interpolation into the future. Using the predictions we’ve made, we can create another <a id="_idIndexMarker485"/>interpolation, based on some assumptions of where a player is likely to be while we wait for its actual position. This will prevent hiccups and idling between updates. Let’s implement our extrapolation algorithm. Open the <code>res://09.prototyping-space- adventure/Actors/Player/Player2D.gd</code> script, and follow the following steps:</p>
			<ol>
				<li>Starting with the function’s signature, the <code>extrapolation_position()</code> method will ask for the next position and duration in seconds that the extrapolation lasts for. Here, we will use terms similar to the ones in prediction, such as <code>seconds_ahead</code>, as we will work with future timing:<pre class="source-code">
func extrapolate_position(next_position, seconds_ahead):</pre></li>				<li>This function only happens on the client side, so there’s no need to add any RPC annotations to it. Inside this function, we will use a new <code>Tween</code> instance to interpolate from the previous known position to the predicted next position, using <code>seconds_ahead</code> variable as the duration:<pre class="source-code">
func extrapolate_position(next_position, seconds_ahead):
     var tween = create_tween()
     tween.set_process_mode(Tween.TWEEN_PROCESS_PHYSICS)
     var tweener = tween.tween_property(spaceship, "position", next_position, seconds_ahead)
     tweener.from(previous_position)</pre></li>				<li>And that’s basically it. We will call the <code>extrapolate_position()</code> method inside the <code>synchronize_position()</code> method right before updating the current and previous positions. Also, we will use the <code>future_position</code> variable, which <a id="_idIndexMarker486"/>stores the predicted position as an argument for the extrapolated next position:<pre class="source-code">
@rpc("authority", "call_remote")
func synchronize_position(new_position, synchronization_tic):
     for tween in get_tree().get_processed_tweens():
          tween.stop()
     var future_position = predict_position(new_position, synchronization_tic)
     extrapolate_position(future_position, synchronization_tic)
     spaceship.position = new_position
     previous_position = new_position</pre></li>				<li>We do the same thing for the <code>extrapolate_rotation()</code> method. It should look like this:<pre class="source-code">
func extrapolate_rotation(target_rotation, seconds_ahead):
     var tween = create_tween()
     tween.set_process_mode(Tween.TWEEN_PROCESS_PHYSICS)
     var tweener = tween.tween_property(spaceship, "rotation", target_rotation, secon
ds_ahead)
     tweener.from(previous_rotation)</pre></li>				<li>The <code>synchronize_rotation()</code> method should look like this after adding the line to <a id="_idIndexMarker487"/>call the <code>extrapolate_rotation()</code> method, using the <code>future_rotation</code> variable as an argument:<pre class="source-code">
@rpc("authority", "call_remote")
func synchronize_rotation(new_rotation, synchronization_tic):
     for tween in get_tree().get_processed_tweens():
          tween.stop()
     var future_rotation = predict_rotation(new_rotation, synchronization_tic)
     extrapolate_rotation(future_rotation, synchronization_tic)
     spaceship.rotation = new_rotation
     previous_rotation = new_rotation</pre></li>			</ol>
			<p>In this section, you learned about the concept of extrapolation in the context of online multiplayer game development. Extrapolation is a technique that looks into the future to anticipate where objects will be next. By analyzing the current state of a game and the trajectory of objects, extrapolation extends beyond the available data, providing a glimpse into what lies ahead. It is particularly useful in fast-paced games where a split-second delay can significantly impact gameplay. The implementation of extrapolation involves interpolating from the previous known position and rotation to the predicted next position and rotation, using <code>Tween</code> instances, with the duration set to the desired time into the future.</p>
			<h1 id="_idParaDest-183"><a id="_idTextAnchor295"/>Summary</h1>
			<p>In this chapter, we learned about the issues caused by lag, latency, and packet loss. Then, we saw how to fix them by implementing lag compensation techniques. We explored the concepts of interpolation, prediction, synchronization, and extrapolation to ensure smooth and responsive gameplay, even in the face of network delays.</p>
			<p>First, we delved into interpolation, which is the core technique regarding lag compensation. Interpolation helps to fix some drawbacks of latency and sparse data updates by animating between two known values, while actual updates don’t arrive. This ensures that the <code>Spaceship</code> node won’t idling, waiting for new updates from the network. It will smoothly move toward new data, instead of abruptly teleporting to it.</p>
			<p>Then, we discussed prediction, which involves making informed guesses about an object’s future position, based on its past behavior. By using Newtonian physics calculations, we were able to calculate the spaceship’s velocity and project its likely future position and rotation. This helps prevent idle movements and keeps gameplay responsive.</p>
			<p>We then explored extrapolation, which extends beyond available data to anticipate where objects will be next. By interpolating from the previous known position and rotation to the predicted next position and rotation, we were able to create smooth movements, even when updates were missed. This technique is particularly useful in fast-paced games where split-second delays can significantly impact gameplay.</p>
			<p>By implementing these lag compensation techniques, we can provide players with a seamless and immersive multiplayer gaming experience, even in the presence of network hiccups and delays.</p>
			<p>In the next chapter, we will see how we can store some data on a client’s machine to reduce the bandwidth used in our game, relying on data that the players already have available on their machines.</p>
		</div>
	</body></html>