<html><head></head><body>
		<div id="_idContainer142">
			<h1 class="chapter-number" id="_idParaDest-173"><a id="_idTextAnchor285"/>12</h1>
			<h1 id="_idParaDest-174"><a id="_idTextAnchor286"/>Implementing Lag Compensation</h1>
			<p>Welcome to one of the most anticipated chapters in the book. Here, we will dive into the core of online multiplayer game optimization. In the world of online gaming, where players from across the globe unite to embark on epic adventures, two formidable adversaries lurk in the shadows; they <a id="_idIndexMarker435"/>are <strong class="bold">lag</strong> and <strong class="bold">latency</strong>. These foes can transform a thrilling gaming <a id="_idIndexMarker436"/>experience into a frustrating trial. In this chapter, we’ll confront these challenges head-on, arming you with the knowledge and tools to mitigate their impact and create an engaging online <span class="No-Break">gaming environment.</span></p>
			<p>In this chapter, we will use <strong class="bold">Remote Procedure Calls</strong> (<strong class="bold">RPCs</strong>) to implement lag compensation techniques, in order to <a id="_idIndexMarker437"/>make the <strong class="source-inline">Player</strong> node’s<em class="italic"> </em><strong class="source-inline">Spaceship</strong> node maintain its position and rotation, synced throughout the game instances across the network. For that, we will understand the core issues regarding packet loss and latency, something common when we use unreliable packets, as we do when using the ENet protocols. Then, we will fake some latency and packet loss by using <strong class="source-inline">Timer</strong> nodes so that we can understand how these issues may display in the actual game. After that, we will talk about some common techniques to create solutions for <span class="No-Break">these issues.</span></p>
			<p>By the end of the chapter, you will understand how we can fake some smooth movement, even when the game’s <strong class="source-inline">MultiplayerSynchronizer</strong> fails to deliver data across peers’ <span class="No-Break">game instances.</span></p>
			<p>In this chapter, we will cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Introducing <span class="No-Break">lag issues</span></li>
				<li>Dealing with <span class="No-Break">unreliable packets</span></li>
				<li>Common <span class="No-Break">compensation techniques</span></li>
			</ul>
			<h1 id="_idParaDest-175"><a id="_idTextAnchor287"/>Technical requirements</h1>
			<p>As mentioned in <a href="B18527_10.xhtml#_idTextAnchor260"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>, <em class="italic">Debugging and Profiling the Network</em>, <em class="italic">Part 3</em>,<em class="italic"> Optimizing the Online Experience</em>, of this book focuses on the final version of the project made in <span class="No-Break"><em class="italic">Chapter 9</em></span>, <em class="italic">Creating an Online Adventure Prototype</em>, so it’s fundamental to read, exercise, and implement the concepts presented there. You can get the files necessary to start this chapter at the following link: <a href="https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0/tree/12.prediction-and-interpolation">https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0/tree/12.prediction-and-interpolation</a>. They contain the progress we’ve made for optimizations in <a href="B18527_11.xhtml#_idTextAnchor276"><span class="No-Break"><em class="italic">Chapter 11</em></span></a>, <em class="italic">Optimizing </em><span class="No-Break"><em class="italic">Data Requests</em></span><span class="No-Break">.</span></p>
			<p>It’s also necessary that you have read and understood the concepts and tools presented in <a href="B18527_11.xhtml#_idTextAnchor276"><span class="No-Break"><em class="italic">Chapter 11</em></span></a>, <em class="italic">Optimizing Data Requests</em>, so that we can continue with the assumption that you already know what they are and how to use <span class="No-Break">them properly.</span></p>
			<h1 id="_idParaDest-176"><a id="_idTextAnchor288"/>Introducing lag issues</h1>
			<p>Addressing lag<a id="_idIndexMarker438"/> and unreliable packets involves three techniques – <strong class="bold">interpolation</strong>, <strong class="bold">prediction</strong>, and <strong class="bold">extrapolation</strong>. These <a id="_idIndexMarker439"/>techniques smoothen player movements, maintain<a id="_idIndexMarker440"/> responsiveness, and anticipate object movements. The Godot Engine’s <a id="_idIndexMarker441"/>physics simulation and RPC method are crucial in these techniques, aiding in realistic object movement and data synchronization, despite <span class="No-Break">network issues.</span></p>
			<p>Lag and latency<a id="_idIndexMarker442"/> are the archenemies of any online multiplayer game. Lag, often used interchangeably with latency, refers to the delay between a player’s action and its corresponding effect in the game. It’s the momentary pause between pulling the trigger and seeing the enemy fall. Latency, on the other hand, represents the time it takes for data to travel from a player’s device to the game server and back. Together, these factors can disrupt the fluidity of gameplay, leaving players frustrated and disconnected from the <span class="No-Break">virtual world.</span></p>
			<p>Within the world of online multiplayer gaming, the transmission of data is seldom a seamless journey. Unreliable packets, those mischievous bits of information, can create issues by arriving out of order or disappearing altogether. When packets are out of order, a player might see an opponent magically teleport across the map and back or perform impossible feats. Data loss results in vital game updates never reaching their intended destination, leaving characters and objects frozen in time. Our mission in this chapter is to combat these issues and bring order to <span class="No-Break">the chaos.</span></p>
			<p>In the realm of online multiplayer gaming, a recurring and often frustrating issue that plagues both developers and players alike is the challenge of lag and latency. In this section, we’ll talk about these two fundamental aspects of online gaming and shed light on the profound impact they have on a player’s experience. As you already discovered in previous chapters, creating a seamless and immersive multiplayer environment requires a nuanced understanding of <span class="No-Break">these concepts.</span></p>
			<p>Now, let’s talk about the impact of lag and latency on gameplay. When a player experiences lag, it disrupts the flow of the game and can lead to missed opportunities, frustration, and, in competitive scenarios, unfavorable outcomes. Imagine firing a weapon in an online shooter, only to have the shot register seconds later, long after your target has moved <span class="No-Break">to safety.</span></p>
			<p>Understanding the causes of lag<a id="_idIndexMarker443"/> and latency<a id="_idIndexMarker444"/> is crucial for effective mitigation. Network congestion, hardware limitations, and geographic distance between players and servers are common causes. <strong class="bold">Network congestion</strong> occurs <a id="_idIndexMarker445"/>when the data traffic on a network is too high, causing data packets to be delayed or lost. Hardware limitations, such as a slow internet connection or an underpowered computer, can also contribute <span class="No-Break">to latency.</span></p>
			<p>Mitigating lag and latency is a constant challenge for game developers. One strategy is server optimization, where game servers are finely tuned to handle large volumes of data efficiently. Another approach is client-side prediction and interpolation, techniques that help to smooth out gameplay even when there are network delays; we will talk about these in the <em class="italic">Common compensation techniques</em> section. On top of these, choosing the right network infrastructure, such as <strong class="bold">Content Delivery Networks</strong> (<strong class="bold">CDNs</strong>), can <a id="_idIndexMarker446"/>significantly reduce latency by placing game assets closer <span class="No-Break">to players.</span></p>
			<p>We’ve peeled back the layers of lag and latency, understanding how these factors impact online multiplayer games. We saw some of their causes and discussed strategies for mitigation, all with the goal of enhancing a player’s gaming experience. In the next section, we will talk about issues specific to unreliable packets, which are what we usually use to transfer data over a network in online <span class="No-Break">multiplayer games.</span></p>
			<h1 id="_idParaDest-177"><a id="_idTextAnchor289"/>Dealing with unreliable packets</h1>
			<p>One of the top concerns that<a id="_idIndexMarker447"/> developers grapple with when creating online multiplayer games is the reliability of data packets. In this section, we’ll see the complexities surrounding unreliable packets, shedding light on the issues they bring to the forefront of online multiplayer games. As you’ve already gleaned from our discussions, understanding these challenges is core to crafting a smooth and immersive multiplayer <span class="No-Break">gaming experience.</span></p>
			<p><strong class="bold">Unreliable packets</strong>, as the <a id="_idIndexMarker448"/>name suggests, are data packets sent over a network without any guarantee of arrival or order. They’re like letters in the wind, reaching their destination only if the conditions are favorable. These packets are used to transmit non-critical data in online games, such as character positions, because they offer lower latency compared to reliable packets, which come with built-in delivery assurances at the expense of <span class="No-Break">potential lag.</span></p>
			<p>One of the primary issues associated with unreliable packets is packet loss. This occurs when packets sent from one player’s device fail to reach a server or another player’s device. It’s like pieces of a puzzle disappearing into thin air, leading to incomplete and inconsistent data. In a fast-paced action game, packet loss can manifest as abrupt character teleportations, vanished projectiles, or inexplicable desynchronization <span class="No-Break">among players.</span></p>
			<p>Another challenge is the out-of-order arrival of packets. In an ideal world, data packets would arrive at their destination in the same order they were sent. However, the unpredictability of network routes can cause packets to arrive out of order, leading to chaos in the game world. Imagine receiving instructions to assemble a piece of furniture, only to receive the steps out of sequence; it’s a recipe for confusion and frustration. Usually, in these cases, we only use the latest data and ignore the older ones, as only the most recent information is relevant to <span class="No-Break">the game.</span></p>
			<p>The consequences of unreliable packets can be dire for gameplay. Packet loss and out-of-order arrivals can lead to player disconnection, incorrect character positions, and erratic synchronization among players. For example, a player’s character might appear to jump from one location to another due to missing packets. This not only disrupts immersion but also undermines the fairness and integrity of <span class="No-Break">competitive play.</span></p>
			<p>Mitigating the issues brought on by unreliable packets requires a multifaceted approach. Developers often employ techniques such as client-side prediction, where the client makes informed guesses about missing data to maintain a coherent game state. Interpolation, another valuable tool, smooths out the jitters caused by missing packets by smoothly transitioning between known <span class="No-Break">data points.</span></p>
			<p>In this section, we saw that packet loss is a common issue where packets fail to reach their destination, leading to incomplete and inconsistent data. We also saw that some packets may arrive out of order, causing chaos in the game world. These issues can result in player disconnection, incorrect character positions, and erratic synchronization among players. In the next section, we are going to see the most common compensation techniques to solve these<a id="_idIndexMarker449"/> and the <span class="No-Break">lag-related issues.</span></p>
			<h1 id="_idParaDest-178"><a id="_idTextAnchor290"/>Common compensation techniques</h1>
			<p>Welcome to the<a id="_idIndexMarker450"/> most anticipated section in our journey through the realm of online multiplayer game development. In the previous sections, we unraveled the complexities of networking, synchronization, and the intricacies of dealing with unreliable packets. Now, we stand at a <a id="_idIndexMarker451"/>crucial juncture, ready to explore the fascinating world of <strong class="bold">interpolation</strong>, <strong class="bold">prediction</strong>, and <strong class="bold">extrapolation</strong>, a<a id="_idIndexMarker452"/> trio of techniques that hold the key to creating seamless and <a id="_idIndexMarker453"/>responsive online gaming experiences, or at least to get as close as we can to this <span class="No-Break">Holy Grail.</span></p>
			<p>Picture this – you’re in the heat of an intense multiplayer battle, and the stakes couldn’t be higher. In the world of online gaming, every second counts, and every move must be precise. But what happens when network latency rears its head, causing a slight delay in transmitting data between players? This is where interpolation, prediction, and extrapolation come to <span class="No-Break">the rescue.</span></p>
			<p>One of the cornerstones of implementing interpolation, prediction, and extrapolation is the integration of physics simulation. In <strong class="bold">Godot Engine</strong>, the <a id="_idIndexMarker454"/>physics engine plays a crucial role in determining how objects move and interact within the game world. By marrying physics with prediction algorithms, you can create a realistic and responsive gameplay experience that feels in sync with the laws of our <span class="No-Break">virtual universe.</span></p>
			<p>To orchestrate the symphony of data synchronization, we’ll take rid of the <strong class="source-inline">Player</strong> node’s <strong class="source-inline">MultiplayerSynchronizer</strong> node and employ some <em class="italic">RPC</em> methods. These functions serve as the conductor of our data orchestra, allowing us to send the necessary information to clients or a server precisely when it’s needed. With RPCs, we can trigger the transmission of interpolated, predicted, or extrapolated data, ensuring that all players stay on the <span class="No-Break">same page.</span></p>
			<p>In the next sections, we’ll jump into the implementation of interpolation, prediction, and extrapolation in our online multiplayer top-down adventure prototype. By the end, you’ll understand how these techniques work together to compensate for network latency. So, fasten your seatbelts, for we are about to navigate the intricacies of smooth and responsive gameplay in the dynamic world of online <span class="No-Break">multiplayer gaming.</span></p>
			<h2 id="_idParaDest-179"><a id="_idTextAnchor291"/>Implementing server-side motion</h2>
			<p>To have a <a id="_idIndexMarker455"/>better setup to understand how lag influences the gameplay experience, we are going to make some changes to the <strong class="source-inline">Player</strong> scene and scripts. Instead of allowing the movement to happen on the client side and being synced to the server and other peers, a player will use input events to change the movement of a server’s <strong class="source-inline">Spaceship</strong> instance. This will allow us to also decrease the amount of syncing data sent by <strong class="source-inline">MultiplayerSynchronizer</strong>, since now we will have the motion simulated, based on <strong class="source-inline">Spaceship</strong>’s thrusting and rotating states. To do that, let’s open the <strong class="source-inline">res://09.prototyping-space-adventure/Actors/Player/Player2D.tscn</strong> scene. Then, follow the <span class="No-Break">following steps:</span></p>
			<ol>
				<li>Select the <strong class="source-inline">MultiplayerSynchronizer</strong> node, and in the <strong class="bold">Replication</strong> menu, disable <strong class="source-inline">Spaceship</strong>’s position and rotation sync on both the <strong class="bold">Spawn</strong> and <span class="No-Break"><strong class="bold">Sync</strong></span><span class="No-Break"> options:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer136">
					<img alt="Figure 12.1 – The Player scene’s MultiplayerSynchronizer Replication menu, with the Spaceship position and rotation properties disabled" src="image/Figure_12.01_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1 – The Player scene’s MultiplayerSynchronizer Replication menu, with the Spaceship position and rotation properties disabled</p>
			<ol>
				<li value="2">Then, let’s open the <strong class="source-inline">res://09.prototyping-space- adventure/Actors/Player/Player2D.gd</strong> file, and we will make some changes to the <strong class="source-inline">setup_multiplayer()</strong> method. The first thing to do here is to remove the line that enables the <strong class="source-inline">_physics_process()</strong> and <strong class="source-inline">_process()</strong> callbacks, leaving only <strong class="source-inline">_unhandled_input()</strong>. We will see why in the <span class="No-Break">following steps:</span><pre class="source-code">
@rpc("any_peer", "call_local")
func setup_multiplayer(player_id):
     var self_id = multiplayer.get_unique_id()
     var is_player = self_id == player_id
     set_process_unhandled_input(is_player)
     camera.enabled = is_player</pre></li>				<li>Then, we <a id="_idIndexMarker456"/>will check whether the current instance isn’t the server; if it isn’t, we call the <strong class="source-inline">make_current()</strong> method, effectively enabling this player’s <strong class="source-inline">Camera2D</strong> node on their <span class="No-Break">game instance:</span><pre class="source-code">
func setup_multiplayer(player_id):
     var self_id = multiplayer.get_unique_id()     var is_player = self_id == player_id      set_process_unhandled_input(is_player)      camera.enabled = is_player
     if not multiplayer.is_server():</pre></li>				<li>Next, we will lay the groundwork the new <strong class="source-inline">Spaceship</strong> node movement logic, get rid of the <strong class="source-inline">_physics_process()</strong> callback, and work in the <strong class="source-inline">_unhandled_input()</strong> callback instead. The whole logic follows the same idea of <strong class="source-inline">Weapon2D</strong>; <strong class="source-inline">Spaceship</strong> will have <strong class="source-inline">thrusting</strong>, <strong class="source-inline">direction</strong>, and <strong class="source-inline">turning</strong> variables that we can use to change its movement. Based on the input events we get in <strong class="source-inline">_unhandled_input()</strong>, we will change the state of these variables. The secret here is that we will use the <strong class="source-inline">rpc_id()</strong> method to change these states on the server’s <span class="No-Break"><strong class="source-inline">Spaceship</strong></span><span class="No-Break"> instance.</span><p class="list-inset">The following snippet showcases the <strong class="source-inline">_unhandled_input()</strong> callback after adding this <span class="No-Break">new logic:</span></p><pre class="source-code">
func _unhandled_input(event):
     if event.is_action_pressed("shoot"):
          weapon.rpc("set_firing", true)
     elif event.is_action_released("shoot"):
          weapon.rpc("set_firing", false)
# Thrusting logic. The spaceship enables its thrust based on if the `thurst_acti
on` was pressed or released
     if event.is_action_pressed(thrust_action):
          spaceship.rpc_id(1, "set_thrusting", true)
     elif event.is_action_released(thrust_action):
          spaceship.rpc_id(1, "set_thrusting", false)
# Turning logic. If a turning key is just pressed or still pressed, the spaceshi
p turns, it only stops turning if neither `turn_left_action` or `turn_right_action
` are pressed.
     if event.is_action_pressed(turn_left_action):
          spaceship.rpc_id(1, "set_direction", -1)
          spaceship.rpc_id(1, "set_turning", true)
     elif event.is_action_released(turn_left_action):
          if Input.is_action_pressed(turn_right_action):
spaceship.rpc_id(1, "set_direction", 1)
12 Implementing Lag Compensation 8
     else:
          spaceship.rpc_id(1, "set_turning", false)
          spaceship.rpc_id(1, "set_direction", 0)
     if event.is_action_pressed(turn_right_action):
          spaceship.rpc_id(1, "set_direction", 1)
          spaceship.rpc_id(1, "set_turning", true)
     elif event.is_action_released(turn_right_action):
     if Input.is_action_pressed(turn_left_action):
          spaceship.rpc_id(1, "set_direction", -1)
     else:
          spaceship.rpc_id(1, "set_turning", false)
          spaceship.rpc_id(1, "set_direction", 0)</pre></li>				<li>Now, let’s<a id="_idIndexMarker457"/> move on to the <strong class="source-inline">res://09.prototyping-space- adventure/Objects/Spaceship/Spaceship.gd</strong> script, where we will implement the variables and methods necessary for the aforementioned changes to work. First, let’s declare the properties and their <span class="No-Break">setter methods:</span><pre class="source-code">
@export var thrusting = false : set = set_thrusting @export var turning = false : set = set_turning
@export_range(-1, 1, 1) var direction = 0 : set = set_direction</pre></li>				<li>Then, let’s declare these methods; here’s the trick – they are <em class="italic">RPCs</em> that any peer can call, and they will be <span class="No-Break">called locally:</span><pre class="source-code">
@rpc("any_peer", "call_local")
func set_thrusting(is_thrusting):
     thrusting = is_thrusting
@rpc("any_peer", "call_local")
func set_turning(is_turning):
     turning = is_turning
@rpc("any_peer", "call_local")
func set_direction(new_direction):
     direction = new_direction</pre></li>				<li>Then, we will make changes to the <strong class="source-inline">thrust()</strong> and <strong class="source-inline">turn()</strong> methods. The whole idea is that they will receive the delta as an argument now. The <strong class="source-inline">turn()</strong> doesn’t need to receive a direction argument anymore, since the direction became a <span class="No-Break"><strong class="source-inline">member</strong></span><span class="No-Break"> variable:</span><pre class="source-code">
func thrust(delta):
     linear_velocity += (acceleration * delta) * Vector2.RIGHT.rotated(rotation)
func turn(delta):
     angular_velocity += (direction * turn_torque) * delta</pre></li>				<li>Finally, we <a id="_idIndexMarker458"/>will use the <strong class="source-inline">_physics_process()</strong> callback to call the <strong class="source-inline">thrust()</strong> and <strong class="source-inline">turn()</strong> methods, based on the thrusting and turning <span class="No-Break">variable states:</span><pre class="source-code">
func _physics_process(delta):
if thrusting:
     thrust(delta)
if turning:
     turn(delta)</pre><p class="list-inset">With that, we have everything we need to keep the movement as it was, but now the server is responsible for responding to the player’s input instead of being passive to how the <strong class="source-inline">Spaceship</strong> node behaved in the player’s game instance. This is important, due to how lag and latency compensation works, as we need an instance of the game to always fall back to if we need to update some data that may have been lost on the network. On top of that, some techniques involve the server side ultimately handling discrepancies. There’s an excellent video on <em class="italic">YouTube</em> called <em class="italic">How to reduce Lag - A Tutorial on Lag Compensation Techniques for Online Games</em> that explains the role of each side of the connection in <a id="_idIndexMarker459"/>lag compensation techniques. This video is available at this link and is highly <span class="No-Break">recommended: </span><a href="https://www.youtube.com/watch?v=2kIgbvl7FRs"><span class="No-Break">https://www.youtube.com/watch?v=2kIgbvl7FRs</span></a><span class="No-Break">.</span></p></li>			</ol>
			<p>Now that we have this in place, we can start to implement the actual techniques that will help us deal with this issue. In the next section, we will set up our fake lag mechanisms, which are basically <strong class="source-inline">twoTimers</strong>, and see how we can use the <strong class="source-inline">Tween</strong> node to implement <em class="italic">interpolation</em> in our game so that we can create a fluid motion, based on the sparse <strong class="source-inline">Spaceship</strong> node position and <span class="No-Break">rotation updates.</span></p>
			<h2 id="_idParaDest-180"><a id="_idTextAnchor292"/>Bridging the gaps with interpolation</h2>
			<p><strong class="bold">Interpolation</strong> is the art of<a id="_idIndexMarker460"/> filling in the gaps between received data points. When data packets arrive at irregular intervals due to network latency or packet loss, interpolation <a id="_idIndexMarker461"/>ensures that the movement of characters, objects, and projectiles appears smooth and continuous. Imagine it as the magic glue that binds fragmented data, allowing players to witness uninterrupted, <span class="No-Break">fluid motion.</span></p>
			<p>In this section, we will see how we can use the <strong class="source-inline">Tween</strong> class to interpolate the sparse data we will receive from players. <strong class="source-inline">Tween</strong> is a specialized class that is used to interpolate values in Godot Engine. We will also use the lerping methods, <strong class="source-inline">lerp()</strong> and <strong class="source-inline">lerp_angle()</strong>, to find the correct values to use in the interpolation, especially for <strong class="source-inline">Spaceship</strong>’s <span class="No-Break">rotation angles.</span></p>
			<p>To fake some latency, we will use <strong class="source-inline">Timer</strong> nodes so that we can see how our interpolation will work in different scenarios. However, ideally, you would use <strong class="source-inline">ENetPacketPeer.get_statistic()</strong> method passing <strong class="source-inline">ENetPacketPeer.PEER_ROUND_TRIP_TIME</strong> as argument to get access to the actual network latency. We can access the <strong class="source-inline">ENetPacketPeer</strong> instance referring to the server’s peer connection using <strong class="source-inline">multiplayer.multiplayer_peer.get_peer(1)</strong>in order to call the <strong class="source-inline">get_statistic()</strong> method on it. So, to access a player’s latency to a server, we can use the following <span class="No-Break">code snippet:</span></p>
			<pre class="source-code">
# Only clients should get statistics about their connection with the server, so we don't call that on the server itself.
if not multiplayer.is_server():
     var server_connection = multiplayer.multiplayer_peer.get_peer(1)
     var latency = server_connection.get_statistic(ENetPacketPeer.PEER_ROUND_TRIP_TIM
E))
     print(latency)</pre>			<p>That being said, we <a id="_idIndexMarker462"/>are going to make some changes to the <strong class="source-inline">Player</strong> scene and script so that we can implement the interpolation logic and understand how to use this technique. Open the <strong class="source-inline">res://09.prototyping-space-adventure/Actors/Player/Player2D.tscn</strong> scene and follow the following steps to implement our <span class="No-Break">interpolation logic:</span></p>
			<ol>
				<li>Since we are not syncing the <strong class="source-inline">Spaceship</strong> node’s position and rotation properties using the <strong class="source-inline">MultiplayerSynchronizer</strong> node anymore, we are going to add <strong class="source-inline">Timer</strong> node to simulate some latency. So, add a new <strong class="source-inline">Timer</strong> node to the scene, and name <span class="No-Break">it </span><span class="No-Break"><strong class="source-inline">InterpolationTimer</strong></span><span class="No-Break">.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer137">
					<img alt="Figure 12.2 – Player’s scene node hierarchy with the newly added InterpolationTimer" src="image/Figure_12.02_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2 – Player’s scene node hierarchy with the newly added InterpolationTimer</p>
			<ol>
				<li value="2">Then, let’s set <strong class="bold">Process Callback</strong> to <strong class="bold">Physics</strong> and <strong class="bold">Wait Time</strong> to <strong class="source-inline">0.1</strong>. In this context, <strong class="bold">Wait Time</strong> represents, in seconds, the latency we want to simulate. A <strong class="source-inline">0.1</strong> wait time would<a id="_idIndexMarker463"/> be as high as a 100 ms latency, which is already high enough for players to start noticing some jittering and noticeable delays in <span class="No-Break">their interactions.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer138">
					<img alt="Figure 12.3 – The InterpolationTimer node settings" src="image/Figure_12.03_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.3 – The InterpolationTimer node settings</p>
			<ol>
				<li value="3">With that, our <a id="_idIndexMarker464"/>next step is to connect the <strong class="source-inline">timeout</strong> signal to the <strong class="source-inline">Player</strong> node’s script; we can create a callback method called <strong class="source-inline">_on_interpolation_timer_timeout()</strong>, <span class="No-Break">like so:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer139">
					<img alt="Figure 12.4 – The InterpolationTimer timeout signal connection" src="image/Figure_12.04_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.4 – The InterpolationTimer timeout signal connection</p>
			<ol>
				<li value="4">Then, let’s move on to the <strong class="source-inline">res://09.prototyping-space-nadventure/Actors/Player/Player2D.gd</strong> script. Here, we will create two new variables to store the previously known <strong class="source-inline">Spaceship</strong> node’s position and rotation. This will be necessary to interpolate from the previous to the newest values <span class="No-Break">moving forward:</span><pre class="source-code">
@onready var previous_position = spaceship.position
@onready var previous_rotation = spaceship.rotation</pre></li>				<li>Now, in the <strong class="source-inline">_on_interpolation_timer_timeout()</strong> callback, we will make two<a id="_idIndexMarker465"/> RPC calls. One to the the <strong class="source-inline">"interpolate_position"</strong>method and the other to the <strong class="source-inline">"interpolate_rotation"</strong> method. These methods will ask for two arguments – the target property (for example, position or rotation), and the duration of the interpolation. In this case, we will use the <strong class="source-inline">InterpolationTimer.wait_time</strong> property as the duration, since this is the time interval between network updates in this context. We will set up these methods in the <span class="No-Break">following steps:</span><pre class="source-code">
func _on_interpolation_timer_timeout():
     rpc("interpolate_position", spaceship.position, $InterpolationTimer.wait_time)
     rpc("interpolate_rotation", spaceship.rotation, $InterpolationTimer.wait_time)</pre></li>				<li>Now, let’s declare these methods, starting with <strong class="source-inline">interpolate_position()</strong>. Only the server should be able to call these methods remotely because it’s the server that will update these properties, so their <strong class="source-inline">@rpc</strong> annotation should use <strong class="source-inline">"authority"</strong> and <strong class="source-inline">"call_remote"</strong> <span class="No-Break">as options:</span><pre class="source-code">
@rpc("authority", "call_remote")
func interpolate_position(target_position, duration_in_seconds):</pre></li>				<li>Inside the <strong class="source-inline">interpolate_position()</strong> method, the first thing we will do is create a new <strong class="source-inline">Tween</strong> instance and store it in a variable, using the <span class="No-Break"><strong class="source-inline">create_tween()</strong></span><span class="No-Break"> method:</span><pre class="source-code">
@rpc("authority", "call_remote")
func interpolate_position(target_position, duration_in_seconds):
     var tween = create_tween()</pre></li>				<li>Then, we will <a id="_idIndexMarker466"/>use the <strong class="source-inline">lerp()</strong> function to figure out the final value we will use in the interpolation. For the <strong class="source-inline">position</strong> property, this is not as useful, but it will be in the rotation case. However, let’s do it this way to maintain some consistency between <span class="No-Break">these functions:</span><pre class="source-code">
@rpc("authority", "call_remote")
func interpolate_position(target_position, duration_in_seconds):
     var tween = create_tween()</pre></li>				<li>Since we are playing with a body that will run some physics simulation, it’s safer to use the <strong class="source-inline">Tween.TWEEN_PROCESS_PHYSICS</strong> mode in <strong class="source-inline">tween</strong> variable so that the interpolation happens during the physics processing. For that, we use the <span class="No-Break"><strong class="source-inline">Tween.set_process_mode()</strong></span><span class="No-Break"> method:</span><pre class="source-code">
@rpc("authority", "call_remote")
func interpolate_position(target_position, duration_in_seconds):
     var tween = create_tween()
     var final_value = lerp(previous_position, target_position, 1.0)
     tween.set_process_mode(Tween.TWEEN_PROCESS_PHYSICS)</pre></li>				<li>Then, we can<a id="_idIndexMarker467"/> start the actual interpolation; we will store it into a variable called <strong class="source-inline">tweener</strong>, as <strong class="source-inline">Tween.tween_property</strong> returns a <strong class="source-inline">PropertyTween</strong> object that we can use when necessary. In this function, we pass four arguments – the object, the property that’s going to be interpolated, the target value, and the duration of the interpolation <span class="No-Break">in seconds:</span><pre class="source-code">
@rpc("authority", "call_remote")
func interpolate_position(target_position, duration_in_seconds):
     var tween = create_tween()
     var final_value = lerp(previous_position, target_position, 1.0)
     tween.set_process_mode(Tween.TWEEN_PROCESS_PHYSICS)
     var tweener = tween.tween_property(spaceship, "position", final_value, duration_
in_seconds)</pre></li>				<li>To ensure the interpolation will happen from the previous known value and the most recent one, we will change <strong class="source-inline">tweener</strong>’s starting value, using the <strong class="source-inline">from()</strong> method and passing <strong class="source-inline">previous_position</strong> as <span class="No-Break">an argument:</span><pre class="source-code">
@rpc("authority", "call_remote")
func interpolate_position(target_position, duration_in_seconds):
     var tween = create_tween()
     var final_value = lerp(previous_position, target_position, 1.0)
     tween.set_process_mode(Tween.TWEEN_PROCESS_PHYSICS)
     var tweener = tween.tween_property(spaceship, "position", final_value, duration_
in_seconds)
     tweener.from(previous_position)</pre></li>				<li>Then, we <a id="_idIndexMarker468"/>update <strong class="source-inline">previous_posistion</strong> to match the now-known most current value, which is <span class="No-Break">our </span><span class="No-Break"><strong class="source-inline">final_value</strong></span><span class="No-Break">:</span><pre class="source-code">
@rpc("authority", "call_remote")
func interpolate_position(target_position, duration_in_seconds):var tween = create_tween()
     var final_value = lerp(previous_position, target_position, 1.0)
     tween.set_process_mode(Tween.TWEEN_PROCESS_PHYSICS)
     var tweener = tween.tween_property(spaceship, "position", final_value, duration_
in_seconds)
     tweener.from(previous_position)
     previous_position = final_value</pre></li>				<li>As for <strong class="source-inline">interpolate_rotation</strong>, we will do the same thing, but this time, we will use the <strong class="source-inline">lerp_angle()</strong> function. This is because interpolating angles is a bit trickier, as we would need to know the shortest path between the starting and target angles. Using this function with a weight of <strong class="source-inline">1.0</strong> provides the final value properly and saves us a lot of time. The whole <strong class="source-inline">interpolate_rotation()</strong> method is very similar to the <strong class="source-inline">interpolate_position()</strong> method but, of course, passing the <strong class="source-inline">previous_rotation</strong> variable instead of the <strong class="source-inline">previous_position</strong> variable. It looks <span class="No-Break">like this:</span><pre class="source-code">
@rpc("authority", "call_remote")
func interpolate_rotation(target_rotation, duration_in_seconds):
     var tween = create_tween()
     var final_value = lerp_angle(previous_rotation, target_rotation, 1.0)
     tween.set_process_mode(Tween.TWEEN_PROCESS_PHYSICS)
     var tweener = tween.tween_property(spaceship, "rotation", final_value, duration_
in_seconds)
     tweener.from(previous_rotation)
     previous_rotation = final_value</pre></li>				<li>Now, we need to start <strong class="source-inline">InterpolationTimer</strong> if the current instance is the connection’s server. For that, move to the <strong class="source-inline">setup_multiplayer()</strong> method and add an <strong class="source-inline">else</strong> statement; inside it, start the timer. Don’t forget to remove the line that sets up the new instance authority, as from now on, the server itself will always be <strong class="source-inline">Player</strong>’s authority. The <strong class="source-inline">setup_multiplayer()</strong> method should look <a id="_idIndexMarker469"/><span class="No-Break">like this:</span><pre class="source-code">
@rpc("any_peer", "call_local")
func setup_multiplayer(player_id):
     var self_id = multiplayer.get_unique_id() var      is_player = self_id == player_id      set_process_unhandled_input(is_player)      camera.enabled = is_player
     if not multiplayer.is_server():
          camera.make_current()
     else:</pre><p class="list-inset">And there we have it – our interpolation logic is ready to smoothly move and rotate our <strong class="source-inline">Spaceship</strong> node, just by getting sparse updates from a server. Note that since we are faking some latency, we are using a fixed interpolation duration. In a more realistic scenario, you’d use the <strong class="source-inline">ENetPacketPeer.PEER_ROUND_TRIP_TIME</strong> statistic as a reference for the actual <span class="No-Break">interpolation </span><span class="No-Break"><a id="_idIndexMarker470"/></span><span class="No-Break">duration.</span></p></li>			</ol>
			<p>In this section, we saw how we can use the <strong class="source-inline">Timer</strong> node to fake some latency and, by using the <strong class="source-inline">Tween</strong> class, interpolate between two known values for the <strong class="source-inline">Spaceship</strong> node’s position and rotation. We also saw how to access some statistics regarding the connection between two peers, especially regarding the latency between clients and a server. However, what happens when we need to keep some consistency in movement while we don’t get updates from the server? This is what we will discuss in the <span class="No-Break">next section!</span></p>
			<h2 id="_idParaDest-181"><a id="_idTextAnchor293"/>Playing ahead with prediction</h2>
			<p><strong class="bold">Prediction</strong>, different from<a id="_idIndexMarker471"/> interpolation, is all about playing ahead of the game – quite <a id="_idIndexMarker472"/>literally. It involves making informed guesses about an object’s future position based on its past behavior. When network delays cause data updates to lag, prediction steps in, ensuring that your character’s actions remain responsive and instantaneous, even in the face of <span class="No-Break">network hiccups.</span></p>
			<p>To implement prediction, we are going to use some Newtonian physics to calculate the <strong class="source-inline">Spaceship</strong> node’s velocity and project, based on this calculation, where it will likely be in the next tic, and use it to extrapolate its position and rotation moving forward. This will help us prevent the <strong class="source-inline">Spaceship</strong> node <span class="No-Break">from idling.</span></p>
			<p>A core aspect of prediction and extrapolation is that they aim to fix some drawbacks of the interpolation. For instance, from time to time, we need to re-sync the actual <strong class="source-inline">Spaceship</strong> node’s position because, otherwise, due to the interpolation duration and potential latency involved, the <strong class="source-inline">Spaceship</strong> node will always be lagged behind, and this can accumulate to a point where the game isn’t played in real time anymore. Also, we will use this synchronization time as a reference for the predictions. So, open the <strong class="source-inline">res://09.prototyping-space-adventure/Actors/Player/Player2D.tscn</strong> scene, and let’s start implementing the <span class="No-Break">necessary steps:</span></p>
			<ol>
				<li>First of all, let’s add a new <strong class="source-inline">Timer</strong> node, and name it <strong class="source-inline">SynchronizationTimer</strong>. This one needs to be at a pace greater <span class="No-Break">than </span><span class="No-Break"><strong class="source-inline">InterpolationTimer</strong></span><span class="No-Break">.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer140">
					<img alt="Figure 12.5 – Player’s scene hierarchy with the SynchronizationTimer node" src="image/Figure_12.05_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.5 – Player’s scene hierarchy with the SynchronizationTimer node</p>
			<ol>
				<li value="2">Then, we will<a id="_idIndexMarker473"/> connect <strong class="source-inline">SynchronizationTimer</strong> node’s <strong class="source-inline">timeout</strong> signal to the <strong class="source-inline">Player</strong> node’s script in a callback, which we can <span class="No-Break">name </span><span class="No-Break"><strong class="source-inline">_on_synchronization_timer_timeout()</strong></span><span class="No-Break">.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer141">
					<img alt="Figure 12.6 – The SynchronizationTimer timeout signal connecting to Player’s _on_synchronization_timer_timeout() method" src="image/Figure_12.06_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.6 – The SynchronizationTimer timeout signal connecting to Player’s _on_synchronization_timer_timeout() method</p>
			<ol>
				<li value="3">Then, let’s <a id="_idIndexMarker474"/>open the <strong class="source-inline">res://09.prototyping-space-</strong> <strong class="source-inline">adventure/Actors/Player/Player2D.gd</strong> script, and in the <strong class="source-inline">setup_multiplayer()</strong> method, we will also start <strong class="source-inline">SynchronizationTimer</strong> if this instance is <span class="No-Break">the server:</span><pre class="source-code">
@rpc("any_peer", "call_local")
func setup_multiplayer(player_id):
     var self_id = multiplayer.get_unique_id()
     var is_player = self_id == player_id
     set_process_unhandled_input(is_player)
     camera.enabled = is_player
     if not multiplayer.is_server():
          camera.make_current()
     else:
          $InterpolationTimer.start()
          $SynchronizationTimer.start()</pre></li>				<li>Now, in the <strong class="source-inline">_on_synchronization_timer_timeout()</strong> callback, we will make two <em class="italic">RPC</em>s – one to a method called <strong class="source-inline">synchronize_position()</strong> and another to a method called <strong class="source-inline">synchronize_rotation()</strong>. We will implement these methods<a id="_idIndexMarker475"/> shortly, but for now, just know they ask for a target position and rotation, respectively, and a synchronization tic. For the synchronization tic, we will use the <strong class="source-inline">SynchronizationTimer</strong> node’s <strong class="source-inline">wait_time</strong> property <span class="No-Break">as reference:</span><pre class="source-code">
func _on_synchronization_timer_timeout():
     rpc("synchronize_position", spaceship.position, $SynchronizationTimer.wait_time)
     rpc("synchronize_rotation", spaceship.rotation, $SynchronizationTimer.wait_time)</pre></li>				<li>Now, let’s start by implementing the <strong class="source-inline">synchronize_position()</strong> method. Only the <strong class="bold">Multiplayer Authority</strong> (in this case, the server) should be able to make an RPC to this method, and<a id="_idIndexMarker476"/> since the server doesn’t need to sync its own <strong class="source-inline">Spaceship</strong> node, it should only <span class="No-Break">call remotely:</span><pre class="source-code">
@rpc("authority", "call_remote")
func synchronize_position(new_position, synchronization_tic):</pre></li>				<li>Inside this method, we will stop all currently processing <strong class="source-inline">Tween</strong> instances; note that this approach works in our game because we only have the <strong class="source-inline">interpolate_*()</strong> methods creating <strong class="source-inline">Tween</strong> instances. If you have other <strong class="source-inline">Tween</strong> instances running in your game, I recommend storing them in an array and running through them to stop the active ones. We do that to stop the interpolation from continuing as we will set the <strong class="source-inline">Spaceship</strong> node’s final <span class="No-Break">position manually:</span><pre class="source-code">
@rpc("authority", "call_remote")
func synchronize_position(new_position, synchronization_tic):
     for tween in get_tree().get_processed_tweens():
          tween.stop()</pre></li>				<li>Then, we will <a id="_idIndexMarker477"/>create a variable to store the future position, based on a prediction we will make, taking the previous and the new positions we just received. We will work on the prediction method later, but for now, just know that it will ask for a new position and how many seconds ahead you want to predict. We will use this prediction to extrapolate movement when we implement extrapolation in the <em class="italic">Gazing into the future with </em><span class="No-Break"><em class="italic">extrapolation</em></span><span class="No-Break"> section:</span><pre class="source-code">
@rpc("authority", "call_remote")
func synchronize_position(new_position,      synchronization_tic):
     for tween in get_tree().get_processed_tweens():
     tween.stop()
     var future_position = predict_position(new_position, synchronization_tic)</pre></li>				<li>After that, we can set the <strong class="source-inline">Spaceship</strong> node’s position to the new position and update <strong class="source-inline">previous_position</strong> to match the most recent value, so in the next tic, it maintains a reference to the previously <span class="No-Break">updated value:</span><pre class="source-code">
@rpc("authority", "call_remote")
func synchronize_position(new_position, synchronization_tic):
for tween in get_tree().get_processed_tweens():
tween.stop()
var future_position = predict_position(new_position, synchronization_tic)
spaceship.position = new_position
previous_position = new_position</pre></li>				<li>As for the <strong class="source-inline">predict_position()</strong> method, it will happen locally on the client’s machine, so there’s no need to make an RPC here. Let’s declare the function’s signature and see how we can predict the future with <span class="No-Break">some physics:</span><pre class="source-code">
func predict_position(new_position, seconds_ahead):</pre><p class="list-inset">Inside the <strong class="source-inline">predict_position()</strong> method, we will calculate the distance from the previous<a id="_idIndexMarker478"/> position to the new one. We will also calculate the direction from the previous position to the new position so that we have <strong class="source-inline">Vector2</strong> to work with, predicting the <span class="No-Break">movement’s velocity:</span></p><pre class="source-code">func predict_position(new_position, seconds_ahead):
var distance = previous_position.distance_to(new_position)
var direction = previous_position.direction_to(new_position)</pre></li>				<li>With that, we will calculate the movement’s linear velocity, based on how many seconds ahead we want to predict. We will then set this linear velocity as the <strong class="source-inline">Spaceship</strong>.<strong class="source-inline">linear_velocity</strong> property so that we it doesn’t idle between updates, asthe <strong class="source-inline">Spaceship</strong> node will start moving using this <span class="No-Break">new velocity:</span><pre class="source-code">
func predict_position(new_position, seconds_ahead): var distance = previous_position.distance_to(new_position) var direction = previous_position.direction_to(new_position) var linear_velocity = (direction * distance) / seconds_ahead spaceship.linear_velocity = linear_velocity</pre></li>				<li>Finally, we will add the linear velocity to the new position to predict what will be the next position. We will then return this new position so that we can use this value when we decide to extrapolate the <strong class="source-inline">Spaceship</strong> <span class="No-Break">node’s movement:</span><pre class="source-code">
func predict_position(new_position, seconds_ahead):
var distance = previous_position.distance_to(new_position)
var direction = previous_position.direction_to(new_position)
var linear_velocity = (direction * distance) / seconds_ahead
spaceship.linear_velocity = linear_velocity
var next_position = new_position + (linear_velocity * seconds_ahead)
return next_position</pre></li>				<li>The logic <a id="_idIndexMarker479"/>to predict the rotation will be exactly the same, but take into account that we will use the <strong class="source-inline">learp_angle()</strong> built-in method to figure out the closest angle to extrapolate to. The <strong class="source-inline">synchronize_rotation()</strong> method will look <span class="No-Break">like this:</span><pre class="source-code">
@rpc("authority", "call_remote")
func synchronize_rotation(new_rotation, synchronization_tic):
for tween in get_tree().get_processed_tweens():
tween.stop()
var future_rotation = predict_rotation(new_rotation, synchronization_tic)
spaceship.rotation = new_rotation
previous_rotation = new_rotation</pre></li>				<li>The <strong class="source-inline">predict_rotation()</strong> method will look <span class="No-Break">like this:</span><pre class="source-code">
func predict_rotation(new_rotation, seconds_ahead):
var angular_velocity = lerp_angle(previous_rotation, new_rotation, 1.0) / second
s_ahead
spaceship.angular_velocity = angular_velocity
var next_rotation = spaceship.rotation + (angular_velocity * seconds_ahead)
return next_rotation</pre><p class="list-inset">With that, we can start to make assumptions of where the <strong class="source-inline">Spaceship</strong> node is likely to be in the near future, based on <strong class="source-inline">SynchronizationTimer</strong> node’s tics. However, note that this is a very important available function on the server side, as sometimes, we may want to use it to mitigate lag in <em class="italic">Player</em> interactions and trigger the right game events. For<a id="_idIndexMarker480"/> instance, if we decide to have some <strong class="bold">player versus player</strong> (<strong class="bold">PvP</strong>) interactions, we may need to predict where a given player’s <em class="italic">Spaceship</em> was when another player fired their gun. This is because, due to latency, the player may have made a guessed shot and landed a hit. However, it is up to the server to decide whether the shot would actually land, given the<a id="_idIndexMarker481"/> latency and <span class="No-Break">other aspects.</span></p></li>			</ol>
			<p>In this section, we have seen two important techniques to handle lag and latency in online multiplayer games – prediction and synchronization. Prediction involves making informed guesses about an object’s future position and rotation, based on its past behavior. To implement prediction, Newtonian physics calculations are used to calculate the <strong class="source-inline">Spaceship</strong> node’s velocity and project its likely future position <span class="No-Break">and rotation.</span></p>
			<p>We also saw how to implement the synchronization process, by stopping ongoing <strong class="source-inline">Tween</strong> instances and updating the <strong class="source-inline">Spaceship</strong> node’s position and <span class="No-Break">rotation accordingly.</span></p>
			<p>In the next section, we will use the predicted position and rotation to extrapolate <strong class="source-inline">Spaceship</strong> node’s movement, both linear and angular, so that if we happen to miss updates, we can at least fake a movement and fix it in the synchronization later <span class="No-Break">if necessary.</span></p>
			<h2 id="_idParaDest-182"><a id="_idTextAnchor294"/>Gazing into the future with extrapolation</h2>
			<p>Extrapolation is the<a id="_idIndexMarker482"/> visionary member of the lag compensation trio, gazing into the future to anticipate where objects will be next. By analyzing the current state of a game and the <a id="_idIndexMarker483"/>trajectory of objects, extrapolation extends beyond the data you have, offering a glimpse into what lies ahead. This technique is particularly handy for fast-paced games, where a split-second delay can mean the difference between victory <span class="No-Break">and defeat.</span></p>
			<p>The whole idea of<a id="_idIndexMarker484"/> extrapolation is that it is an interpolation into the future. Using the predictions we’ve made, we can create another <a id="_idIndexMarker485"/>interpolation, based on some assumptions of where a player is likely to be while we wait for its actual position. This will prevent hiccups and idling between updates. Let’s implement our extrapolation algorithm. Open the <strong class="source-inline">res://09.prototyping-space- adventure/Actors/Player/Player2D.gd</strong> script, and follow the <span class="No-Break">following steps:</span></p>
			<ol>
				<li>Starting with the function’s signature, the <strong class="source-inline">extrapolation_position()</strong> method will ask for the next position and duration in seconds that the extrapolation lasts for. Here, we will use terms similar to the ones in prediction, such as <strong class="source-inline">seconds_ahead</strong>, as we will work with <span class="No-Break">future timing:</span><pre class="source-code">
func extrapolate_position(next_position, seconds_ahead):</pre></li>				<li>This function only happens on the client side, so there’s no need to add any RPC annotations to it. Inside this function, we will use a new <strong class="source-inline">Tween</strong> instance to interpolate from the previous known position to the predicted next position, using <strong class="source-inline">seconds_ahead</strong> variable as <span class="No-Break">the duration:</span><pre class="source-code">
func extrapolate_position(next_position, seconds_ahead):
     var tween = create_tween()
     tween.set_process_mode(Tween.TWEEN_PROCESS_PHYSICS)
     var tweener = tween.tween_property(spaceship, "position", next_position, seconds_ahead)
     tweener.from(previous_position)</pre></li>				<li>And that’s basically it. We will call the <strong class="source-inline">extrapolate_position()</strong> method inside the <strong class="source-inline">synchronize_position()</strong> method right before updating the current and previous positions. Also, we will use the <strong class="source-inline">future_position</strong> variable, which <a id="_idIndexMarker486"/>stores the predicted position as an argument for the extrapolated <span class="No-Break">next position:</span><pre class="source-code">
@rpc("authority", "call_remote")
func synchronize_position(new_position, synchronization_tic):
     for tween in get_tree().get_processed_tweens():
          tween.stop()
     var future_position = predict_position(new_position, synchronization_tic)
     extrapolate_position(future_position, synchronization_tic)
     spaceship.position = new_position
     previous_position = new_position</pre></li>				<li>We do the same thing for the <strong class="source-inline">extrapolate_rotation()</strong> method. It should look <span class="No-Break">like this:</span><pre class="source-code">
func extrapolate_rotation(target_rotation, seconds_ahead):
     var tween = create_tween()
     tween.set_process_mode(Tween.TWEEN_PROCESS_PHYSICS)
     var tweener = tween.tween_property(spaceship, "rotation", target_rotation, secon
ds_ahead)
     tweener.from(previous_rotation)</pre></li>				<li>The <strong class="source-inline">synchronize_rotation()</strong> method should look like this after adding the line to <a id="_idIndexMarker487"/>call the <strong class="source-inline">extrapolate_rotation()</strong> method, using the <strong class="source-inline">future_rotation</strong> variable as <span class="No-Break">an argument:</span><pre class="source-code">
@rpc("authority", "call_remote")
func synchronize_rotation(new_rotation, synchronization_tic):
     for tween in get_tree().get_processed_tweens():
          tween.stop()
     var future_rotation = predict_rotation(new_rotation, synchronization_tic)
     extrapolate_rotation(future_rotation, synchronization_tic)
     spaceship.rotation = new_rotation
     previous_rotation = new_rotation</pre></li>			</ol>
			<p>In this section, you learned about the concept of extrapolation in the context of online multiplayer game development. Extrapolation is a technique that looks into the future to anticipate where objects will be next. By analyzing the current state of a game and the trajectory of objects, extrapolation extends beyond the available data, providing a glimpse into what lies ahead. It is particularly useful in fast-paced games where a split-second delay can significantly impact gameplay. The implementation of extrapolation involves interpolating from the previous known position and rotation to the predicted next position and rotation, using <strong class="source-inline">Tween</strong> instances, with the duration set to the desired time into <span class="No-Break">the future.</span></p>
			<h1 id="_idParaDest-183"><a id="_idTextAnchor295"/>Summary</h1>
			<p>In this chapter, we learned about the issues caused by lag, latency, and packet loss. Then, we saw how to fix them by implementing lag compensation techniques. We explored the concepts of interpolation, prediction, synchronization, and extrapolation to ensure smooth and responsive gameplay, even in the face of <span class="No-Break">network delays.</span></p>
			<p>First, we delved into interpolation, which is the core technique regarding lag compensation. Interpolation helps to fix some drawbacks of latency and sparse data updates by animating between two known values, while actual updates don’t arrive. This ensures that the <strong class="source-inline">Spaceship</strong> node won’t idling, waiting for new updates from the network. It will smoothly move toward new data, instead of abruptly teleporting <span class="No-Break">to it.</span></p>
			<p>Then, we discussed prediction, which involves making informed guesses about an object’s future position, based on its past behavior. By using Newtonian physics calculations, we were able to calculate the spaceship’s velocity and project its likely future position and rotation. This helps prevent idle movements and keeps <span class="No-Break">gameplay responsive.</span></p>
			<p>We then explored extrapolation, which extends beyond available data to anticipate where objects will be next. By interpolating from the previous known position and rotation to the predicted next position and rotation, we were able to create smooth movements, even when updates were missed. This technique is particularly useful in fast-paced games where split-second delays can significantly <span class="No-Break">impact gameplay.</span></p>
			<p>By implementing these lag compensation techniques, we can provide players with a seamless and immersive multiplayer gaming experience, even in the presence of network hiccups <span class="No-Break">and delays.</span></p>
			<p>In the next chapter, we will see how we can store some data on a client’s machine to reduce the bandwidth used in our game, relying on data that the players already have available on <span class="No-Break">their machines.</span></p>
		</div>
	</body></html>