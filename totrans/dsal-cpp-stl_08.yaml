- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Advanced Unordered Associative Container Usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While our journey with ordered associative containers has provided us with
    the prowess of relationship mapping and the power of ordering, it is time to venture
    into a domain that prioritizes speed over sorted behavior: unordered associative
    containers. As their name suggests, these containers do not guarantee any specific
    order of their elements, but they make up for it with potentially faster access
    times.'
  prefs: []
  type: TYPE_NORMAL
- en: In the world of computing, there are always trade-offs. Unordered associative
    containers might relinquish the beauty of order, but in many scenarios, they make
    up for it with speed, especially when hashing operates at its best. Whether you’re
    developing a high-frequency trading system, a caching mechanism, or a real-time
    multiplayer game backend, understanding when to harness the power of unordered
    associated containers can make a difference.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter provides references for the following containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::unordered_set`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_map`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_multiset`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_multimap`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code in this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
  prefs: []
  type: TYPE_NORMAL
- en: std::unordered_set
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This container is akin to `std::set` but with a twist: it does not maintain
    the elements in any particular order. Instead, it employs a hashing mechanism
    to access its elements quickly. This hash-based approach can offer constant time
    average complexity for most operations, given a good hash function.'
  prefs: []
  type: TYPE_NORMAL
- en: Purpose and suitability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::unordered_set` is a hash-based container in the C++ **Standard Template
    Library** (**STL**) that stores unique elements in no particular order. Its core
    strengths include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Providing average constant-time operations for insertions, deletions, and searches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling non-trivial data types effectively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You should choose `std::unordered_set` in the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: When you need rapid checks for the existence of elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the order of elements is not a concern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When frequent insertions and deletions are expected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, if the ordering of elements is crucial, `std::set` might be a better
    alternative.
  prefs: []
  type: TYPE_NORMAL
- en: Ideal use cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are some of the ideal use cases for `std::unordered_set`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::unordered_set` is your candidate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_set` to create a collection of unique items from an existing
    dataset.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_set` where quick insertions and deletions are more critical
    than maintaining order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_set` over `std::set` when the order of elements doesn’t matter
    since `std::unordered_set` provides faster lookup, insertion, and removal operations.
    However, `std::unordered_set` may use more memory than `std::set`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The algorithmic performance of `std::unordered_set` is characterized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Insertion**: Average-case *O(1)*, worst-case *O(n)* due to potential hash
    collisions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deletion**: Average-case *O(1)*, worst-case *O(n)* due to potential hash
    collisions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access**: *O(1)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory overhead**: Generally higher than ordered containers due to hashing
    mechanisms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The key trade-off here revolves around average versus worst-case scenarios,
    especially concerning hash collisions.
  prefs: []
  type: TYPE_NORMAL
- en: Memory management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::unordered_set` manages its memory using a series of buckets to store
    elements. The number of buckets can grow, usually when the load factor exceeds
    a certain threshold. Using custom allocators can help tailor this behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: Thread safety
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Concurrent reading is safe. However, operations that modify the set (such as
    insertions or deletions) require external synchronization mechanisms, such as
    mutexes.
  prefs: []
  type: TYPE_NORMAL
- en: Extensions and variants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::unordered_multiset` is a close relative, allowing multiple instances
    of an element to be used. If ordered storage is vital, `std::set` and `std::multiset`
    come into play.'
  prefs: []
  type: TYPE_NORMAL
- en: Sorting and searching complexity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Its sorting and search complexity is characterized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::unordered_set` is not ordered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Searching**: It has an average *O(1)* time due to hashing, but its worst-case
    scenario can be *O(n)* with poor hashing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special interface and member functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some handy member functions to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`emplace`: This allows elements to be constructed directly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bucket`: This can retrieve the bucket number for a given element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`load_factor` and `max_load_factor`: These are required for managing performance
    characteristics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparisons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Compared to `std::set`, `std::unordered_set` generally offers faster operations
    but loses the inherent order and might have a higher memory overhead.
  prefs: []
  type: TYPE_NORMAL
- en: Interactions with algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Due to its unordered nature, `std::unordered_set` might not be the best candidate
    for STL algorithms that require ordered data. However, algorithms revolving around
    unique elements can fit well.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Operations can throw exceptions if allocations fail or if hash functions throw.
    Ensure your hash functions are exception-free to guarantee the container’s exception
    safety.
  prefs: []
  type: TYPE_NORMAL
- en: Customization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Custom hash functions and equality predicates can be applied to fine-tune the
    container’s behavior for specific data types. Moreover, custom allocators can
    also be beneficial in some scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::unordered_set` stores unique elements in no particular order. The primary
    operations it supports are insertion, deletion, and member checking. Unlike `std::set`,
    which uses a balanced binary tree internally, `std::unordered_set` uses a hash
    table, making the average insertion, deletion, and search complexities *O(1)*,
    albeit with higher constants and worse worst-case performance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows an example demonstrating best practices when using
    `std::unordered_set`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the example output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some key takeaways from the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::unordered_set` allows rapid insertions, deletions, and lookups.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`find` can be used to check for the existence of an element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `rehash` method can change the number of buckets in the underlying hash
    table, which might help when you know the number of elements in advance and wish
    to reduce the overhead of rehashing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always be cautious about the load factor (covered in the following Best practices
    section) and consider rehashing when necessary to maintain efficient performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember that the order of elements in `std::unordered_set` is not guaranteed.
    The order can change over time as elements are inserted or deleted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `std::unordered_set` is appropriate when you need rapid lookups and are
    not worried about the order of elements. If ordering is essential, you might want
    to consider using `std::set` instead.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s explore the best practices of using `std::unordered_set`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::unordered_set` is designed without the need to maintain any specific
    order of its elements. Never rely on any sequential consistency within this container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hash collision awareness**: Hash collisions can detrimentally affect performance,
    transforming average-case constant-time operations into worst-case linear-time
    operations. Always be aware of this, especially when designing hash functions
    or handling large datasets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_set` can be intimately tied to its bucket count and load factor.
    Consider the load factor and rehashing policies of `std::unordered_set` for performance
    tuning. The `bucket_count()`: The current number of buckets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`load_factor()`: The current number of elements divided by the bucket count'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max_load_factor()`: The load factor threshold, which, when surpassed, triggers
    a rehash'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::hash` standard template specialization. This allows hashing behavior
    to be fine-tuned.*   `rehash()` or `reserve()` when necessary. This can help prevent
    unexpected performance drops, especially when inserting new elements.*   **Uniform
    hash distribution**: A good hash function will distribute values uniformly across
    buckets, minimizing the chance of collisions. Ensure your hash function achieves
    this by testing its distribution with sample data before deploying it in performance-critical
    applications. Use a well-designed hash function that distributes elements evenly
    across the buckets to avoid performance degradation.*   `std::unordered_set` is
    not the ideal choice. Consider migrating to `std::set` or leveraging other ordered
    containers within the STL.*   `std::unordered_set` in multi-threaded applications,
    ensure proper synchronization mechanisms are in place. Concurrent reads are safe,
    but writes or simultaneous reads and writes demand external synchronization.*   `std::unordered_set`
    dynamically manages its size, it is beneficial to use functions such as `reserve()`
    if you have an estimate of the number of elements to be stored. This can help
    in reducing the number of rehashes and improve performance.*   `erase` member
    function judiciously. Remember that erasing by the iterator is faster (*O(1)*)
    than erasing by the key value (*O(n)* in the worst case.*   `std::unordered_set`,
    due to its hashing mechanism, might have a higher memory overhead than other containers.
    Consider this aspect, especially in memory-sensitive applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: std::unordered_map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Think of this container as an unsorted version of `std::map`. It associates
    keys with values but without imposing any order. Instead, it banks on hashing
    for swift operations.
  prefs: []
  type: TYPE_NORMAL
- en: Purpose and suitability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::unordered_map` is a hash table-based key-value container in the STL.
    Its core strengths are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Fast average-case key-based access, insertion, and removal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ability to maintain a key-value association
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This container is the go-to in the following circumstances:'
  prefs: []
  type: TYPE_NORMAL
- en: When insertions, deletions, and lookups must be swift on average
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the order of elements isn’t a concern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ideal use cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are some of the ideal use cases for `std::unordered_map`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::unordered_map` provides average constant-time complexity for `search`,
    `insert`, and `delete` operations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_map` is ideal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_map` allows you to map items to their occurrence counts efficiently'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_map` can map the attribute to a list or set of objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_map` can associate setting keys with their current values for
    quick lookups and modifications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_map` can serve as an efficient index for quick record access
    based on unique identifiers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_map` offers an efficient way to update and access data categories
    or counters based on unique keys'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_map` provides an efficient structure to handle key-value pairs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_map` proves invaluable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_map` can associate resource keys with their status or attributes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To summarize, `std::unordered_map` is optimal for scenarios that demand quick
    associative lookups, insertions, and deletions without needing the keys to maintain
    any specific order. If a key’s sequence or sorted nature is a priority, structures
    such as `std::map` would be more suitable.
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The algorithmic performance of `std::unordered_map` is characterized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Insertion**: *O(1)* average-case, *O(n)* worst-case'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deletion**: *O(1)* average-case, *O(n)* worst-case'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access**: *O(1)* average-case, *O(n)* worst-case due to potential hash collisions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory overhead**: Generally higher than ordered map counterparts due to
    the hashing infrastructure'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::unordered_map` manages its memory automatically, resizing when load factors
    exceed certain thresholds. Allocators can offer finer control over this process.'
  prefs: []
  type: TYPE_NORMAL
- en: Thread safety
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Concurrent reading is safe. However, modifications or mixed read-writes necessitate
    external synchronization, such as using mutexes.
  prefs: []
  type: TYPE_NORMAL
- en: Extensions and variants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::map` is the ordered counterpart, providing log(n) guarantees at the cost
    of maintaining order. Based on your requirements, decide whether you need order
    or average-case speed.'
  prefs: []
  type: TYPE_NORMAL
- en: Sorting and searching complexity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Its sorting and search complexity is characterized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::unordered_map` is inherently unordered'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Searching**: Fast *O(1)* average-case key-based lookups'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special interface and member functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Apart from the standard functions (`insert`, `erase`, `find`), become familiar
    with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`emplace`: Constructs key-value pairs in place'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bucket_count`: Returns the number of buckets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`load_factor`: Provides the current load factor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparisons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Compared to `std::map`, `std::unordered_map` trades order for faster average-case
    operations. The unordered variant often outperforms in scenarios where constant
    order isn’t vital.
  prefs: []
  type: TYPE_NORMAL
- en: Interactions with algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most STL algorithms that work with sequences aren’t directly applicable to key-value
    map structures. Still, the container provides methods that are optimized for its
    use case.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Failures in memory allocation or the hash function can throw exceptions. Some
    operations, such as `at()`, can throw `std::out_of_range`. It’s crucial to ensure
    exception safety, especially during insertions or emplacements.
  prefs: []
  type: TYPE_NORMAL
- en: Customization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can supply custom hash functions and key equality functions to optimize
    further or adapt behavior. Additionally, custom allocators are available for memory
    management tweaks.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::unordered_map` is a container that associates keys with values. It is
    similar to `std::map`, but while `std::map` maintains its elements in a sorted
    manner (based on keys), `std::unordered_map` does not maintain any order. Internally,
    it uses a hash table, which gives it an *O(1)* complexity for insertions, deletions,
    and lookups.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows an example demonstrating best practices when using
    `std::unordered_map`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the example output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some key takeaways from the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `operator[]` or the `insert` method to add elements to the map. Note
    that using an index operator on a non-existent key will create it with a default
    value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `find` method checks for the existence of a key. It’s more efficient than
    using the `index` operator when you want to check a key’s existence without potential
    insertion.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always be aware of the map’s load factor and consider rehashing if necessary
    to maintain efficient performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As with `std::unordered_set`, the order of elements in `std::unordered_map`
    is not guaranteed. It can change as elements are inserted or removed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_map` is suitable when you need quick key-based access and don’t
    care about the order of elements. If ordering is essential, then `std::map` would
    be a more appropriate choice.'
  prefs: []
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s explore the best practices of using `std::unordered_map`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Element order is not guaranteed**: Do not assume the map maintains element
    order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Beware of hash collisions**: Ensure you account for potential worst-case
    performance in hash-collision scenarios.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_map` to maintain optimal performance. Regularly check the load
    factor and consider rehashing if necessary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_map` is highly dependent on the effectiveness of the hash function
    used. A poorly designed hash function can lead to poor performance due to cache
    misses and collision resolution overhead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_map` to improve memory efficiency, particularly in scenarios
    with high insertions and deletions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Check for an existing key**: Always check for an existing key before insertion
    to avoid overwriting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`emplace` to construct entries in place, reducing overhead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_map` is expensive when using `operator[]` for accessing elements,
    which can be a performance pitfall.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: std::unordered_multiset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This container is a flexible counterpart to `std::unordered_set`, allowing multiple
    occurrences of an element. It amalgamates the speed of hashing with the liberty
    of non-unique elements.
  prefs: []
  type: TYPE_NORMAL
- en: Purpose and suitability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::unordered_multiset` is a hash table-based container that allows you to
    store multiple equivalent items in an unordered manner. Its primary attractions
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Quick average-case insertion and lookup times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to store multiple items with the same value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It’s particularly suitable in the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: When the order of elements doesn’t matter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you anticipate having multiple elements with the same value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you want average-case constant time complexity for insertions and lookups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When searching for a container where duplicates are permissible and order isn’t
    crucial, `std::unordered_multiset` is a compelling choice.
  prefs: []
  type: TYPE_NORMAL
- en: Ideal use cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are some of the ideal use cases for `std::unordered_multiset`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::unordered_multiset` is suitable. It permits the storage of multiple identical
    elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_multiset` can be an efficient structure where each unique value
    is stored alongside its duplicates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_multiset` can be useful for managing hash collisions by storing
    collided items together.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_multiset` can store these repeating patterns for further analysis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_multiset` is efficient as it allows constant time average complexity
    for inserts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_multiset` can efficiently manage these tag occurrences.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_multiset` provides a way to manage these grouped items.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_multiset` can be an efficient in-memory tool to manage these
    redundant data points.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_multiset` is best suited for scenarios where quick insertions
    and lookups are needed, duplicates are allowed, and the order of elements is not
    significant. When unique keys or ordered data structures are a requirement, other
    containers, such as `std::unordered_set` or `std::map`, may be more appropriate.'
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The algorithmic performance of `std::unordered_multiset` is characterized as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Insertion**: *O(1)* average-case though worst-case can be *O(n)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deletion:** *O(1)* average-case'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access**: No direct access like an array, but finding an element is *O(1)*
    average-case'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory overhead**: Typically, this is higher than ordered containers due
    to hashing mechanisms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One trade-off is that while `std::unordered_multiset` offers average-case *O(1)*
    insertion, lookup, and deletion, worst-case performance can degrade to *O(n)*.
  prefs: []
  type: TYPE_NORMAL
- en: Memory management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::unordered_multiset` dynamically manages its bucket list. The container
    can be resized, which might happen automatically when elements are inserted and
    the size exceeds `max_load_factor`. Allocators can be used to influence memory
    allocation.'
  prefs: []
  type: TYPE_NORMAL
- en: Thread safety
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Reading from the container is thread-safe, but modifications (for example, insertions
    or deletions) require external synchronization. Multiple threads writing to `std::unordered_multiset`
    simultaneously can lead to race conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Extensions and variants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::unordered_set` functions similarly but doesn’t allow duplicate elements.
    It contrasts with `std::multiset`, which keeps its elements ordered but permits
    duplicates.'
  prefs: []
  type: TYPE_NORMAL
- en: Sorting and searching complexity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Its sorting and search complexity is characterized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sorting**: Not inherently sorted, but you can copy elements to a vector and
    sort them'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Searching**: *O(1)* average-case complexity for lookups due to hashing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special interface and member functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While it offers standard functions (`insert`, `erase`, `find`), you can also
    explore the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`count`: Returns the number of elements that match a specific value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bucket`: Returns the bucket number for a given value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max_load_factor`: Manages when the container decides to resize'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparisons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Compared to `std::multiset`, this container offers faster average-case performance
    but at the expense of order and potentially higher memory usage.
  prefs: []
  type: TYPE_NORMAL
- en: Interactions with algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Hash-based containers such as `std::unordered_multiset` don’t always benefit
    as much from STL algorithms that have been optimized for ordered containers. Algorithms
    that don’t rely on element order are preferable (that is, `std::for_each`, `std::count`,
    `std::all_of`, `std::transform`, and others).
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Standard exceptions can be thrown for bad allocations. It’s critical to know
    that operations on `std::unordered_multiset` offer strong exception safety.
  prefs: []
  type: TYPE_NORMAL
- en: Customization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The container supports custom allocators and hash functions, allowing for refined
    control over memory allocation and hashing behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::unordered_multiset` is similar to `std::unordered_set` but allows multiple
    occurrences of the same element. Like other unordered containers, it uses a hash
    table internally, so it doesn’t maintain any order of elements. The key characteristic
    of `unordered_multiset` is its ability to store duplicates, which can be useful
    in certain applications, such as counting or categorizing items based on some
    criterion.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates some best practices when using `std::unordered_multiset`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the example output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some key takeaways from the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::unordered_multiset` can store duplicate values. Use the `count` method
    to check how many occurrences of a given element exist in the container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `equal_range` function provides a range of iterators pointing to all instances
    of a specific element.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As with other unordered containers, be conscious of the load factor and consider
    rehashing when necessary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember that the elements in `unordered_multiset` are unordered. If you need
    ordered data with duplicate values, you should use `std::multiset`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You’d need to iterate through the set and use the iterator-based `erase()` method
    to erase specific occurrences of a duplicate value. In the preceding example,
    we removed all occurrences of `apple` for simplicity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `std::unordered_multiset` to keep track of elements where the order doesn’t
    matter, and duplicates are allowed. It offers efficient constant-time average
    complexity for insertions, deletions, and lookups.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s explore the best practices of using `std::unordered_multiset`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::unordered_multiset` and `std::unordered_set`. Unlike `std::unordered_set`,
    `std::unordered_multiset` allows duplicates. Choose `std::unordered_multiset`
    if your application must store multiple equivalent keys.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_multiset` is its ability to handle duplicate elements. This
    is particularly useful in scenarios where you need to track multiple instances
    of an element. However, this also means that operations such as `find()` will
    return an iterator to the first instance of the element, and iterating through
    all duplicates might be necessary for certain operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_set`, the performance of `std::unordered_multiset` is affected
    by the load factor. A higher load factor can cause more hash collisions, impacting
    performance. Conversely, a lower load factor, while reducing collisions, can lead
    to memory inefficiency. Use `load_factor()` to monitor and `rehash()` or `max_load_factor()`
    to manage the load factor effectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_multiset` for efficient element distribution, especially when
    dealing with custom or complex data types. Implement a specialized hash function
    using `std::hash` template specialization to ensure uniform distribution and minimize
    collision.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_multiset` may not be the right choice due to its unordered
    nature. In such cases, consider using `std::multiset`, which maintains order but
    still allows duplicates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`erase()` function to remove elements. Removing an element by an iterator is
    an *O(1)* operation, whereas removing by value can take up to *O(n)* in the worst
    case. Be mindful of this when designing your erasure strategy, especially in performance-critical
    applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_set`, `std::unordered_multiset` can have higher memory overhead
    due to its hashing mechanism. This should be a consideration in environments where
    memory is a constraint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_multiset` supports concurrent reads but requires external synchronization
    mechanisms for writes or concurrent reads and writes. This is crucial in multi-threaded
    environments to avoid data races and maintain data integrity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_multiset`, be aware of algorithms that expect a sorted range
    since they are not suitable for an unordered container. Always ensure that the
    chosen algorithm aligns with the characteristics of `std::unordered_multiset`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: std::unordered_multimap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By blending the principles of `std::unordered_map` and the flexibility of multiplicity,
    this container allows a single key to be associated with multiple values without
    the need to maintain a specific order.
  prefs: []
  type: TYPE_NORMAL
- en: Purpose and suitability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::unordered_multimap` is a hash-based container that permits multiple values
    to be associated with a single key. Unlike `std::unordered_map`, it doesn’t enforce
    unique keys. It’s especially apt in the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: When quick average-case lookup times are desired
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you anticipate multiple values for the same key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When key order doesn’t matter, as elements aren’t stored in any particular order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose `std::unordered_multimap` for situations that require non-unique keys
    and swift lookups. If order or unique keys matter, consider other options.
  prefs: []
  type: TYPE_NORMAL
- en: Ideal use cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are some of the ideal use cases for `std::unordered_multimap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::unordered_multimap` is a suitable container. For example, one author
    (key) can have numerous books in a database of authors and their books (values).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_multimap` is beneficial.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_multimap` can manage hash collisions by linking collided keys
    to their respective values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_multimap` can organize these tag-to-item or item-to-tag relationships.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_multimap` can be an efficient in-memory tool.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_multimap` can serve as a storage system. As an example, this
    can be useful if you’re grouping people by their birth year, where one year (key)
    can correspond to many people (values).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_multimap` is useful. An example would be color-naming systems,
    where one color can have several associated names.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_multimap` can associate one coordinate with multiple objects
    in that space.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_multimap` is a highly versatile tool that’s apt for applications
    where fast insertions and lookups are crucial, and one key should be linked to
    multiple values. When unique keys or ordered data structures are required, other
    containers, such as `std::unordered_map` or `std::set`, might be more fitting.'
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The algorithmic performance of `std::unordered_multimap` is characterized as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Insertion**: Average-case *O(1)*, worst-case *O(n)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deletion**: Average-case *O(1)*, worst-case *O(n)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access**: Average-case *O(1)*, worst-case *O(n)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory overhead**: Moderate due to hashing infrastructure, potentially increasing
    with hash collisions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its trade-offs include speedy average-case operations but potential slowdowns
    if hash collisions become prevalent.
  prefs: []
  type: TYPE_NORMAL
- en: Memory management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::unordered_multimap` resizes when the load factor exceeds its maximum
    value. Allocators can be used to customize memory behavior, including allocation
    and deallocation strategies.'
  prefs: []
  type: TYPE_NORMAL
- en: Thread safety
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Reading from different instances is thread-safe. However, concurrent reading
    and writing to the same instance necessitates external synchronization.
  prefs: []
  type: TYPE_NORMAL
- en: Extensions and variants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::unordered_map` is a variant that holds unique keys. If you need ordered
    key behavior, `std::multimap` and `std::map` are tree-based alternatives.'
  prefs: []
  type: TYPE_NORMAL
- en: Sorting and searching complexity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Its sorting and search complexity is characterized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sorting**: Not inherently sortable as it is unordered; must be copied to
    a sortable container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Searching**: Average-case *O(1)* due to hashing, but can degrade in the presence
    of many hash collisions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special interface and member functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Beyond common functions (`insert`, `find`, `erase`), dive into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`emplace`: Directly constructs the element in the container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bucket`: Fetches the bucket number for a given key'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`load_factor`: Provides the ratio of elements to buckets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparisons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Compared to `std::unordered_map`, this container allows non-unique keys. If
    key order matters, `std::multimap` is a tree-based alternative.
  prefs: []
  type: TYPE_NORMAL
- en: Interactions with algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Being unordered, many STL algorithms designed for ordered sequences might not
    be directly applicable or would necessitate a different approach.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Failures in memory allocation or hash function complications can throw exceptions.
    Container operations offer basic exception safety, ensuring the container remains
    valid.
  prefs: []
  type: TYPE_NORMAL
- en: Customization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use custom allocators for memory adjustments. Custom hash functions
    or key equality predicates can also optimize behavior for specific use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::unordered_multimap` is similar to `std::unordered_map` but allows for
    multiple key-value pairs with equivalent keys. It is an associative container,
    meaning its value type is formed by combining its key and mapped types.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code example demonstrates some best practices when using `std::unordered_multimap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the example output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some key takeaways from the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: With `std::unordered_multimap`, it is possible to insert multiple key-value
    pairs with the same key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use `equal_range` to get a range of iterators to all the key-value pairs
    with a specific key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `count` method helps you determine the number of key-value pairs with a
    specific key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like other unordered containers, you should be aware of the load factor and
    might want to rehash it if necessary to achieve optimal performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `erase()` method with a key will remove all the key-value pairs associated
    with that key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since it is an unordered container, the order of the elements is not guaranteed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `std::unordered_multimap` when you need to keep track of multiple values
    associated with the same key and don’t need the key-value pairs to be sorted.
    It provides average constant-time complexity for most operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s explore the best practices of using `std::unordered_multimap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::unordered_multimap` signifies that the container maintains no specific
    order for its key-value pairs. Iterating through the container does not guarantee
    any particular sequence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_multimap` is its ability to store multiple entries for a single
    key. Remember this when inserting, erasing, or searching to avoid unintended logic
    errors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`load_factor()` function to monitor the current load factor. If it gets too
    high, consider rehashing the container using the `rehash()` function. It’s also
    possible to set a desired upper limit on the load factor with the `max_load_factor()`
    function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::hash` template specialization for custom data types to ensure efficient
    and consistent hashing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Handle hash collisions**: Even with an efficient hash function, collisions
    might occur. The container handles these internally, but awareness of them helps
    with making better design decisions. Collisions can lead to a performance drop
    in insertion and search operations, so balancing the load factor and the number
    of buckets is essential.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`equal_range()` when iterating through all values associated with a specific
    key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Iterator invalidation**: Iterator invalidation can be a concern, especially
    after operations such as rehashing. Always ensure that iterators, pointers, or
    references to the elements are not used after they might have been invalidated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`emplace` or `emplace_hint` methods. These allow the key-value pair to be constructed
    directly within the container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Concurrency considerations**: Concurrent reads are thread-safe, but you’ll
    need external synchronization for any modifications or concurrent reads and writes.
    Use synchronization primitives such as mutexes in multi-threaded scenarios.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_multimap`. However, ensure the selected algorithm doesn’t expect
    ordering or unique keys, since those assumptions would contradict the container’s
    properties.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
