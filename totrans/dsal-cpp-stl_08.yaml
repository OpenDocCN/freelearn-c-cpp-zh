- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Advanced Unordered Associative Container Usage
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While our journey with ordered associative containers has provided us with
    the prowess of relationship mapping and the power of ordering, it is time to venture
    into a domain that prioritizes speed over sorted behavior: unordered associative
    containers. As their name suggests, these containers do not guarantee any specific
    order of their elements, but they make up for it with potentially faster access
    times.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: In the world of computing, there are always trade-offs. Unordered associative
    containers might relinquish the beauty of order, but in many scenarios, they make
    up for it with speed, especially when hashing operates at its best. Whether you’re
    developing a high-frequency trading system, a caching mechanism, or a real-time
    multiplayer game backend, understanding when to harness the power of unordered
    associated containers can make a difference.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter provides references for the following containers:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '`std::unordered_set`'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_map`'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_multiset`'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_multimap`'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code in this chapter can be found on GitHub:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: std::unordered_set
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This container is akin to `std::set` but with a twist: it does not maintain
    the elements in any particular order. Instead, it employs a hashing mechanism
    to access its elements quickly. This hash-based approach can offer constant time
    average complexity for most operations, given a good hash function.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Purpose and suitability
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::unordered_set` is a hash-based container in the C++ **Standard Template
    Library** (**STL**) that stores unique elements in no particular order. Its core
    strengths include the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Providing average constant-time operations for insertions, deletions, and searches
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling non-trivial data types effectively
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You should choose `std::unordered_set` in the following scenarios:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: When you need rapid checks for the existence of elements
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the order of elements is not a concern
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When frequent insertions and deletions are expected
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, if the ordering of elements is crucial, `std::set` might be a better
    alternative.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Ideal use cases
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are some of the ideal use cases for `std::unordered_set`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '`std::unordered_set` is your candidate.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_set` to create a collection of unique items from an existing
    dataset.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_set` where quick insertions and deletions are more critical
    than maintaining order.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_set` over `std::set` when the order of elements doesn’t matter
    since `std::unordered_set` provides faster lookup, insertion, and removal operations.
    However, `std::unordered_set` may use more memory than `std::set`.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The algorithmic performance of `std::unordered_set` is characterized as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '**Insertion**: Average-case *O(1)*, worst-case *O(n)* due to potential hash
    collisions'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deletion**: Average-case *O(1)*, worst-case *O(n)* due to potential hash
    collisions'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access**: *O(1)*'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory overhead**: Generally higher than ordered containers due to hashing
    mechanisms'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The key trade-off here revolves around average versus worst-case scenarios,
    especially concerning hash collisions.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Memory management
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::unordered_set` manages its memory using a series of buckets to store
    elements. The number of buckets can grow, usually when the load factor exceeds
    a certain threshold. Using custom allocators can help tailor this behavior.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Thread safety
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Concurrent reading is safe. However, operations that modify the set (such as
    insertions or deletions) require external synchronization mechanisms, such as
    mutexes.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Extensions and variants
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::unordered_multiset` is a close relative, allowing multiple instances
    of an element to be used. If ordered storage is vital, `std::set` and `std::multiset`
    come into play.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Sorting and searching complexity
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Its sorting and search complexity is characterized as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '`std::unordered_set` is not ordered.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Searching**: It has an average *O(1)* time due to hashing, but its worst-case
    scenario can be *O(n)* with poor hashing.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special interface and member functions
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some handy member functions to note are as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '`emplace`: This allows elements to be constructed directly.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bucket`: This can retrieve the bucket number for a given element.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`load_factor` and `max_load_factor`: These are required for managing performance
    characteristics.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparisons
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Compared to `std::set`, `std::unordered_set` generally offers faster operations
    but loses the inherent order and might have a higher memory overhead.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Interactions with algorithms
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Due to its unordered nature, `std::unordered_set` might not be the best candidate
    for STL algorithms that require ordered data. However, algorithms revolving around
    unique elements can fit well.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Operations can throw exceptions if allocations fail or if hash functions throw.
    Ensure your hash functions are exception-free to guarantee the container’s exception
    safety.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Customization
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Custom hash functions and equality predicates can be applied to fine-tune the
    container’s behavior for specific data types. Moreover, custom allocators can
    also be beneficial in some scenarios.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Example
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::unordered_set` stores unique elements in no particular order. The primary
    operations it supports are insertion, deletion, and member checking. Unlike `std::set`,
    which uses a balanced binary tree internally, `std::unordered_set` uses a hash
    table, making the average insertion, deletion, and search complexities *O(1)*,
    albeit with higher constants and worse worst-case performance.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows an example demonstrating best practices when using
    `std::unordered_set`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here’s the example output:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here are some key takeaways from the preceding code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '`std::unordered_set` allows rapid insertions, deletions, and lookups.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_set`允许快速插入、删除和查找。'
- en: '`find` can be used to check for the existence of an element.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find`可用于检查元素的存在。'
- en: The `rehash` method can change the number of buckets in the underlying hash
    table, which might help when you know the number of elements in advance and wish
    to reduce the overhead of rehashing.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rehash`方法可以改变底层哈希表中的桶数，这在你事先知道元素数量并希望减少重新散列开销时可能有所帮助。'
- en: Always be cautious about the load factor (covered in the following Best practices
    section) and consider rehashing when necessary to maintain efficient performance.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是小心地考虑负载因子（在下面的最佳实践部分有介绍）并在必要时考虑重新散列以保持高效性能。
- en: Remember that the order of elements in `std::unordered_set` is not guaranteed.
    The order can change over time as elements are inserted or deleted.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记住，`std::unordered_set`中元素的顺序是不保证的。随着元素的插入或删除，顺序可能会随时间改变。
- en: Using `std::unordered_set` is appropriate when you need rapid lookups and are
    not worried about the order of elements. If ordering is essential, you might want
    to consider using `std::set` instead.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要快速查找且不关心元素顺序时，使用`std::unordered_set`是合适的。如果顺序是必需的，你可能想考虑使用`std::set`。
- en: Best practices
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最佳实践
- en: 'Let’s explore the best practices of using `std::unordered_set`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨使用`std::unordered_set`的最佳实践：
- en: '`std::unordered_set` is designed without the need to maintain any specific
    order of its elements. Never rely on any sequential consistency within this container.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_set`设计时无需维护其元素的具体顺序。不要依赖于此容器内的任何顺序一致性。'
- en: '**Hash collision awareness**: Hash collisions can detrimentally affect performance,
    transforming average-case constant-time operations into worst-case linear-time
    operations. Always be aware of this, especially when designing hash functions
    or handling large datasets.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**哈希冲突意识**：哈希冲突会损害性能，将平均情况下的常数时间操作转换为最坏情况下的线性时间操作。始终对此保持警觉，尤其是在设计哈希函数或处理大数据集时。'
- en: '`std::unordered_set` can be intimately tied to its bucket count and load factor.
    Consider the load factor and rehashing policies of `std::unordered_set` for performance
    tuning. The `bucket_count()`: The current number of buckets'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_set`与其桶数和负载因子紧密相关。考虑`std::unordered_set`的负载因子和重新散列策略以进行性能调整。`bucket_count()`:
    当前桶数'
- en: '`load_factor()`: The current number of elements divided by the bucket count'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`load_factor()`: 当前元素数量除以桶数'
- en: '`max_load_factor()`: The load factor threshold, which, when surpassed, triggers
    a rehash'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max_load_factor()`: 负载因子阈值，当超过此阈值时触发重新散列'
- en: '`std::hash` standard template specialization. This allows hashing behavior
    to be fine-tuned.*   `rehash()` or `reserve()` when necessary. This can help prevent
    unexpected performance drops, especially when inserting new elements.*   **Uniform
    hash distribution**: A good hash function will distribute values uniformly across
    buckets, minimizing the chance of collisions. Ensure your hash function achieves
    this by testing its distribution with sample data before deploying it in performance-critical
    applications. Use a well-designed hash function that distributes elements evenly
    across the buckets to avoid performance degradation.*   `std::unordered_set` is
    not the ideal choice. Consider migrating to `std::set` or leveraging other ordered
    containers within the STL.*   `std::unordered_set` in multi-threaded applications,
    ensure proper synchronization mechanisms are in place. Concurrent reads are safe,
    but writes or simultaneous reads and writes demand external synchronization.*   `std::unordered_set`
    dynamically manages its size, it is beneficial to use functions such as `reserve()`
    if you have an estimate of the number of elements to be stored. This can help
    in reducing the number of rehashes and improve performance.*   `erase` member
    function judiciously. Remember that erasing by the iterator is faster (*O(1)*)
    than erasing by the key value (*O(n)* in the worst case.*   `std::unordered_set`,
    due to its hashing mechanism, might have a higher memory overhead than other containers.
    Consider this aspect, especially in memory-sensitive applications.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::hash` 标准模板特化。这允许对哈希行为进行微调。*   在必要时进行 `rehash()` 或 `reserve()`。这可以帮助防止性能意外下降，尤其是在插入新元素时。*   **均匀的哈希分布**：一个好的哈希函数将在桶之间均匀分布值，最小化冲突的可能性。在将哈希函数部署到性能关键应用之前，通过测试其分布来确保您的哈希函数实现这一点。使用设计良好的哈希函数，将元素均匀分布到桶中，以避免性能下降。*   `std::unordered_set`
    不是理想的选择。考虑迁移到 `std::set` 或利用 STL 中的其他有序容器。*   在多线程应用程序中，`std::unordered_set` 确保适当的位置同步机制。并发读取是安全的，但写入或同时读取和写入需要外部同步。*   `std::unordered_set`
    动态管理其大小，如果您对要存储的元素数量有一个估计，则使用 `reserve()` 等函数是有益的。这有助于减少重新哈希的次数并提高性能。*   适度使用
    `erase` 成员函数。记住，通过迭代器删除比通过键值删除更快（最坏情况下为 *O(1)*，而通过键值删除为 *O(n)*）。*   由于 `std::unordered_set`
    的哈希机制，它可能比其他容器具有更高的内存开销。在内存敏感的应用程序中，请考虑这一点。'
- en: std::unordered_map
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: std::unordered_map
- en: Think of this container as an unsorted version of `std::map`. It associates
    keys with values but without imposing any order. Instead, it banks on hashing
    for swift operations.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个容器视为 `std::map` 的无序版本。它将键与值关联起来，但不强加任何顺序。相反，它依赖于哈希以实现快速操作。
- en: Purpose and suitability
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目的和适用性
- en: '`std::unordered_map` is a hash table-based key-value container in the STL.
    Its core strengths are as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::unordered_map` 是 STL 中基于哈希表的键值容器。其核心优势如下：'
- en: Fast average-case key-based access, insertion, and removal
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速的平均情况基于键的访问、插入和删除
- en: Ability to maintain a key-value association
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护键值关联的能力
- en: 'This container is the go-to in the following circumstances:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，这个容器是首选：
- en: When insertions, deletions, and lookups must be swift on average
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当插入、删除和查找必须平均快速时
- en: When the order of elements isn’t a concern
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当元素顺序不是关注点时
- en: Ideal use cases
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理想用例
- en: 'The following are some of the ideal use cases for `std::unordered_map`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些 `std::unordered_map` 的理想用例：
- en: '`std::unordered_map` provides average constant-time complexity for `search`,
    `insert`, and `delete` operations'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_map` 提供了平均常数时间复杂度用于 `search`、`insert` 和 `delete` 操作'
- en: '`std::unordered_map` is ideal'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_map` 是理想的'
- en: '`std::unordered_map` allows you to map items to their occurrence counts efficiently'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_map` 允许您有效地将项目映射到它们的出现次数'
- en: '`std::unordered_map` can map the attribute to a list or set of objects'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_map` 可以将属性映射到对象列表或集合'
- en: '`std::unordered_map` can associate setting keys with their current values for
    quick lookups and modifications'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_map` 可以将设置键与其当前值关联起来，以便快速查找和修改'
- en: '`std::unordered_map` can serve as an efficient index for quick record access
    based on unique identifiers'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_map` 可以作为基于唯一标识符快速记录访问的索引'
- en: '`std::unordered_map` offers an efficient way to update and access data categories
    or counters based on unique keys'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_map` 提供了一种有效的方法来根据唯一键更新和访问数据类别或计数器'
- en: '`std::unordered_map` provides an efficient structure to handle key-value pairs'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_map` 提供了一种高效的结构来处理键值对'
- en: '`std::unordered_map` proves invaluable'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_map` 非常宝贵'
- en: '`std::unordered_map` can associate resource keys with their status or attributes'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To summarize, `std::unordered_map` is optimal for scenarios that demand quick
    associative lookups, insertions, and deletions without needing the keys to maintain
    any specific order. If a key’s sequence or sorted nature is a priority, structures
    such as `std::map` would be more suitable.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The algorithmic performance of `std::unordered_map` is characterized as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '**Insertion**: *O(1)* average-case, *O(n)* worst-case'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deletion**: *O(1)* average-case, *O(n)* worst-case'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access**: *O(1)* average-case, *O(n)* worst-case due to potential hash collisions'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory overhead**: Generally higher than ordered map counterparts due to
    the hashing infrastructure'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory management
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::unordered_map` manages its memory automatically, resizing when load factors
    exceed certain thresholds. Allocators can offer finer control over this process.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Thread safety
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Concurrent reading is safe. However, modifications or mixed read-writes necessitate
    external synchronization, such as using mutexes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Extensions and variants
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::map` is the ordered counterpart, providing log(n) guarantees at the cost
    of maintaining order. Based on your requirements, decide whether you need order
    or average-case speed.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Sorting and searching complexity
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Its sorting and search complexity is characterized as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '`std::unordered_map` is inherently unordered'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Searching**: Fast *O(1)* average-case key-based lookups'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special interface and member functions
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Apart from the standard functions (`insert`, `erase`, `find`), become familiar
    with the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '`emplace`: Constructs key-value pairs in place'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bucket_count`: Returns the number of buckets'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`load_factor`: Provides the current load factor'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparisons
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Compared to `std::map`, `std::unordered_map` trades order for faster average-case
    operations. The unordered variant often outperforms in scenarios where constant
    order isn’t vital.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Interactions with algorithms
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most STL algorithms that work with sequences aren’t directly applicable to key-value
    map structures. Still, the container provides methods that are optimized for its
    use case.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Failures in memory allocation or the hash function can throw exceptions. Some
    operations, such as `at()`, can throw `std::out_of_range`. It’s crucial to ensure
    exception safety, especially during insertions or emplacements.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Customization
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can supply custom hash functions and key equality functions to optimize
    further or adapt behavior. Additionally, custom allocators are available for memory
    management tweaks.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Example
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::unordered_map` is a container that associates keys with values. It is
    similar to `std::map`, but while `std::map` maintains its elements in a sorted
    manner (based on keys), `std::unordered_map` does not maintain any order. Internally,
    it uses a hash table, which gives it an *O(1)* complexity for insertions, deletions,
    and lookups.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows an example demonstrating best practices when using
    `std::unordered_map`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例展示了使用`std::unordered_map`时的最佳实践：
- en: '[PRE2]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here’s the example output:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是示例输出：
- en: '[PRE3]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here are some key takeaways from the preceding code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从前面的代码中得出的关键要点：
- en: Use the `operator[]` or the `insert` method to add elements to the map. Note
    that using an index operator on a non-existent key will create it with a default
    value.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`operator[]`或`insert`方法向映射中添加元素。请注意，在不存在键上使用索引操作符将创建它并使用默认值。
- en: The `find` method checks for the existence of a key. It’s more efficient than
    using the `index` operator when you want to check a key’s existence without potential
    insertion.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find`方法检查键的存在。当你想检查键的存在而不进行潜在插入时，它比使用`index`操作符更有效。'
- en: Always be aware of the map’s load factor and consider rehashing if necessary
    to maintain efficient performance.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是注意地图的负载因子，并在必要时考虑重新散列以保持高效性能。
- en: As with `std::unordered_set`, the order of elements in `std::unordered_map`
    is not guaranteed. It can change as elements are inserted or removed.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与`std::unordered_set`一样，`std::unordered_map`中元素的顺序是不保证的。随着元素的插入或删除，顺序可能会改变。
- en: '`std::unordered_map` is suitable when you need quick key-based access and don’t
    care about the order of elements. If ordering is essential, then `std::map` would
    be a more appropriate choice.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要快速基于键的访问且不关心元素顺序时，`std::unordered_map`是合适的。如果顺序很重要，那么`std::map`将是一个更合适的选择。
- en: Best practices
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最佳实践
- en: 'Let’s explore the best practices of using `std::unordered_map`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨使用`std::unordered_map`的最佳实践：
- en: '**Element order is not guaranteed**: Do not assume the map maintains element
    order.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**元素顺序不保证**：不要假设映射保持元素顺序。'
- en: '**Beware of hash collisions**: Ensure you account for potential worst-case
    performance in hash-collision scenarios.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注意哈希冲突**：确保在哈希冲突场景中考虑潜在的糟糕性能。'
- en: '`std::unordered_map` to maintain optimal performance. Regularly check the load
    factor and consider rehashing if necessary.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::unordered_map`以保持最佳性能。定期检查负载因子，并在必要时考虑重新散列。
- en: '`std::unordered_map` is highly dependent on the effectiveness of the hash function
    used. A poorly designed hash function can lead to poor performance due to cache
    misses and collision resolution overhead.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_map`高度依赖于所使用的哈希函数的有效性。一个设计不良的哈希函数可能导致性能不佳，因为缓存未命中和冲突解决开销。'
- en: '`std::unordered_map` to improve memory efficiency, particularly in scenarios
    with high insertions and deletions.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::unordered_map`来提高内存效率，尤其是在插入和删除频繁的场景中。
- en: '**Check for an existing key**: Always check for an existing key before insertion
    to avoid overwriting.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检查现有键**：在插入之前始终检查现有键以避免覆盖。'
- en: '`emplace` to construct entries in place, reducing overhead.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`emplace`就地构建条目，减少开销。
- en: '`std::unordered_map` is expensive when using `operator[]` for accessing elements,
    which can be a performance pitfall.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`operator[]`访问元素时，`std::unordered_map`成本较高，这可能是性能陷阱。
- en: std::unordered_multiset
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`std::unordered_multiset`'
- en: This container is a flexible counterpart to `std::unordered_set`, allowing multiple
    occurrences of an element. It amalgamates the speed of hashing with the liberty
    of non-unique elements.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 此容器是`std::unordered_set`的灵活对应物，允许元素出现多次。它结合了散列的速度和非唯一元素的自由度。
- en: Purpose and suitability
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目的和适用性
- en: '`std::unordered_multiset` is a hash table-based container that allows you to
    store multiple equivalent items in an unordered manner. Its primary attractions
    are as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::unordered_multiset`是一个基于哈希表的容器，允许你以无序方式存储多个等效项。其主要吸引力如下：'
- en: Quick average-case insertion and lookup times
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速的平均情况插入和查找时间
- en: The ability to store multiple items with the same value
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储具有相同值的多个项的能力
- en: 'It’s particularly suitable in the following scenarios:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 它特别适合以下场景：
- en: When the order of elements doesn’t matter
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当元素的顺序不重要时
- en: When you anticipate having multiple elements with the same value
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你预期有多个具有相同值的元素
- en: When you want average-case constant time complexity for insertions and lookups
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你希望插入和查找的平均情况时间复杂度为常数时
- en: When searching for a container where duplicates are permissible and order isn’t
    crucial, `std::unordered_multiset` is a compelling choice.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在搜索允许重复且顺序不重要的容器时，`std::unordered_multiset`是一个有力的选择。
- en: Ideal use cases
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理想用例
- en: 'The following are some of the ideal use cases for `std::unordered_multiset`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些`std::unordered_multiset`的理想用例：
- en: '`std::unordered_multiset` is suitable. It permits the storage of multiple identical
    elements.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_multiset` can be an efficient structure where each unique value
    is stored alongside its duplicates.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_multiset` can be useful for managing hash collisions by storing
    collided items together.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_multiset` can store these repeating patterns for further analysis.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_multiset` is efficient as it allows constant time average complexity
    for inserts.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_multiset` can efficiently manage these tag occurrences.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_multiset` provides a way to manage these grouped items.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_multiset` can be an efficient in-memory tool to manage these
    redundant data points.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_multiset` is best suited for scenarios where quick insertions
    and lookups are needed, duplicates are allowed, and the order of elements is not
    significant. When unique keys or ordered data structures are a requirement, other
    containers, such as `std::unordered_set` or `std::map`, may be more appropriate.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The algorithmic performance of `std::unordered_multiset` is characterized as
    follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '**Insertion**: *O(1)* average-case though worst-case can be *O(n)*'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deletion:** *O(1)* average-case'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access**: No direct access like an array, but finding an element is *O(1)*
    average-case'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory overhead**: Typically, this is higher than ordered containers due
    to hashing mechanisms'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One trade-off is that while `std::unordered_multiset` offers average-case *O(1)*
    insertion, lookup, and deletion, worst-case performance can degrade to *O(n)*.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Memory management
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::unordered_multiset` dynamically manages its bucket list. The container
    can be resized, which might happen automatically when elements are inserted and
    the size exceeds `max_load_factor`. Allocators can be used to influence memory
    allocation.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Thread safety
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Reading from the container is thread-safe, but modifications (for example, insertions
    or deletions) require external synchronization. Multiple threads writing to `std::unordered_multiset`
    simultaneously can lead to race conditions.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Extensions and variants
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::unordered_set` functions similarly but doesn’t allow duplicate elements.
    It contrasts with `std::multiset`, which keeps its elements ordered but permits
    duplicates.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Sorting and searching complexity
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Its sorting and search complexity is characterized as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '**Sorting**: Not inherently sorted, but you can copy elements to a vector and
    sort them'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Searching**: *O(1)* average-case complexity for lookups due to hashing'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special interface and member functions
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While it offers standard functions (`insert`, `erase`, `find`), you can also
    explore the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '`count`: Returns the number of elements that match a specific value'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bucket`: Returns the bucket number for a given value'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max_load_factor`: Manages when the container decides to resize'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparisons
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Compared to `std::multiset`, this container offers faster average-case performance
    but at the expense of order and potentially higher memory usage.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `std::multiset` 相比，这个容器提供了更快的平均性能，但牺牲了顺序和可能更高的内存使用。
- en: Interactions with algorithms
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与算法的交互
- en: Hash-based containers such as `std::unordered_multiset` don’t always benefit
    as much from STL algorithms that have been optimized for ordered containers. Algorithms
    that don’t rely on element order are preferable (that is, `std::for_each`, `std::count`,
    `std::all_of`, `std::transform`, and others).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 基于哈希的容器，如 `std::unordered_multiset`，并不总是像针对有序容器优化过的 STL 算法那样受益。不依赖于元素顺序的算法更可取（即
    `std::for_each`、`std::count`、`std::all_of`、`std::transform` 等）。
- en: Exceptions
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常
- en: Standard exceptions can be thrown for bad allocations. It’s critical to know
    that operations on `std::unordered_multiset` offer strong exception safety.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不良分配可能会抛出标准异常。重要的是要知道对 `std::unordered_multiset` 的操作提供了强大的异常安全性。
- en: Customization
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定制化
- en: The container supports custom allocators and hash functions, allowing for refined
    control over memory allocation and hashing behavior.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 容器支持自定义分配器和哈希函数，允许对内存分配和哈希行为进行精细控制。
- en: Example
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例
- en: '`std::unordered_multiset` is similar to `std::unordered_set` but allows multiple
    occurrences of the same element. Like other unordered containers, it uses a hash
    table internally, so it doesn’t maintain any order of elements. The key characteristic
    of `unordered_multiset` is its ability to store duplicates, which can be useful
    in certain applications, such as counting or categorizing items based on some
    criterion.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::unordered_multiset` 与 `std::unordered_set` 类似，但允许相同元素的多重出现。与其他无序容器一样，它内部使用哈希表，因此不维护元素的任何顺序。`unordered_multiset`
    的关键特性是其存储重复元素的能力，这在某些应用中可能很有用，例如根据某些标准对项目进行计数或分类。'
- en: 'The following example demonstrates some best practices when using `std::unordered_multiset`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了使用 `std::unordered_multiset` 时的几个最佳实践：
- en: '[PRE4]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here’s the example output:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这是示例输出：
- en: '[PRE5]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here are some key takeaways from the preceding code:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从前面代码中得出的几个关键要点：
- en: '`std::unordered_multiset` can store duplicate values. Use the `count` method
    to check how many occurrences of a given element exist in the container.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_multiset` 可以存储重复值。使用 `count` 方法检查容器中给定元素出现的次数。'
- en: The `equal_range` function provides a range of iterators pointing to all instances
    of a specific element.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`equal_range` 函数提供了一个迭代器范围，指向特定元素的所有实例。'
- en: As with other unordered containers, be conscious of the load factor and consider
    rehashing when necessary.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其他无序容器一样，要意识到负载因子，并在必要时考虑重新哈希。
- en: Remember that the elements in `unordered_multiset` are unordered. If you need
    ordered data with duplicate values, you should use `std::multiset`.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记住，`unordered_multiset` 中的元素是无序的。如果您需要有序数据且允许重复值，应使用 `std::multiset`。
- en: You’d need to iterate through the set and use the iterator-based `erase()` method
    to erase specific occurrences of a duplicate value. In the preceding example,
    we removed all occurrences of `apple` for simplicity.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要遍历集合并使用基于迭代器的 `erase()` 方法来删除特定重复值的实例。在前面的示例中，我们为了简单起见移除了所有 `apple` 的实例。
- en: Use `std::unordered_multiset` to keep track of elements where the order doesn’t
    matter, and duplicates are allowed. It offers efficient constant-time average
    complexity for insertions, deletions, and lookups.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `std::unordered_multiset` 来跟踪顺序不重要且允许重复的元素。它为插入、删除和查找提供了高效的平均常数时间复杂度。
- en: Best practices
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最佳实践
- en: 'Let’s explore the best practices of using `std::unordered_multiset`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨使用 `std::unordered_multiset` 的最佳实践：
- en: '`std::unordered_multiset` and `std::unordered_set`. Unlike `std::unordered_set`,
    `std::unordered_multiset` allows duplicates. Choose `std::unordered_multiset`
    if your application must store multiple equivalent keys.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_multiset` 和 `std::unordered_set`。与 `std::unordered_set` 不同，`std::unordered_multiset`
    允许重复。如果您的应用程序必须存储多个等效键，请选择 `std::unordered_multiset`。'
- en: '`std::unordered_multiset` is its ability to handle duplicate elements. This
    is particularly useful in scenarios where you need to track multiple instances
    of an element. However, this also means that operations such as `find()` will
    return an iterator to the first instance of the element, and iterating through
    all duplicates might be necessary for certain operations.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_multiset` 的能力在于处理重复元素。这在需要跟踪元素多个实例的场景中特别有用。然而，这也意味着像 `find()`
    这样的操作将返回元素第一个实例的迭代器，并且对于某些操作可能需要遍历所有重复项。'
- en: '`std::unordered_set`, the performance of `std::unordered_multiset` is affected
    by the load factor. A higher load factor can cause more hash collisions, impacting
    performance. Conversely, a lower load factor, while reducing collisions, can lead
    to memory inefficiency. Use `load_factor()` to monitor and `rehash()` or `max_load_factor()`
    to manage the load factor effectively.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_multiset` for efficient element distribution, especially when
    dealing with custom or complex data types. Implement a specialized hash function
    using `std::hash` template specialization to ensure uniform distribution and minimize
    collision.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_multiset` may not be the right choice due to its unordered
    nature. In such cases, consider using `std::multiset`, which maintains order but
    still allows duplicates.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`erase()` function to remove elements. Removing an element by an iterator is
    an *O(1)* operation, whereas removing by value can take up to *O(n)* in the worst
    case. Be mindful of this when designing your erasure strategy, especially in performance-critical
    applications.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_set`, `std::unordered_multiset` can have higher memory overhead
    due to its hashing mechanism. This should be a consideration in environments where
    memory is a constraint.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_multiset` supports concurrent reads but requires external synchronization
    mechanisms for writes or concurrent reads and writes. This is crucial in multi-threaded
    environments to avoid data races and maintain data integrity.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_multiset`, be aware of algorithms that expect a sorted range
    since they are not suitable for an unordered container. Always ensure that the
    chosen algorithm aligns with the characteristics of `std::unordered_multiset`.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: std::unordered_multimap
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By blending the principles of `std::unordered_map` and the flexibility of multiplicity,
    this container allows a single key to be associated with multiple values without
    the need to maintain a specific order.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Purpose and suitability
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::unordered_multimap` is a hash-based container that permits multiple values
    to be associated with a single key. Unlike `std::unordered_map`, it doesn’t enforce
    unique keys. It’s especially apt in the following scenarios:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: When quick average-case lookup times are desired
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you anticipate multiple values for the same key
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When key order doesn’t matter, as elements aren’t stored in any particular order
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose `std::unordered_multimap` for situations that require non-unique keys
    and swift lookups. If order or unique keys matter, consider other options.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Ideal use cases
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are some of the ideal use cases for `std::unordered_multimap`:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '`std::unordered_multimap` is a suitable container. For example, one author
    (key) can have numerous books in a database of authors and their books (values).'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_multimap` is beneficial.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_multimap` can manage hash collisions by linking collided keys
    to their respective values.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_multimap` can organize these tag-to-item or item-to-tag relationships.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_multimap` can be an efficient in-memory tool.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_multimap` can serve as a storage system. As an example, this
    can be useful if you’re grouping people by their birth year, where one year (key)
    can correspond to many people (values).'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_multimap` is useful. An example would be color-naming systems,
    where one color can have several associated names.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_multimap` can associate one coordinate with multiple objects
    in that space.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_multimap` is a highly versatile tool that’s apt for applications
    where fast insertions and lookups are crucial, and one key should be linked to
    multiple values. When unique keys or ordered data structures are required, other
    containers, such as `std::unordered_map` or `std::set`, might be more fitting.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The algorithmic performance of `std::unordered_multimap` is characterized as
    follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '**Insertion**: Average-case *O(1)*, worst-case *O(n)*'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deletion**: Average-case *O(1)*, worst-case *O(n)*'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access**: Average-case *O(1)*, worst-case *O(n)*'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory overhead**: Moderate due to hashing infrastructure, potentially increasing
    with hash collisions'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its trade-offs include speedy average-case operations but potential slowdowns
    if hash collisions become prevalent.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Memory management
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::unordered_multimap` resizes when the load factor exceeds its maximum
    value. Allocators can be used to customize memory behavior, including allocation
    and deallocation strategies.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Thread safety
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Reading from different instances is thread-safe. However, concurrent reading
    and writing to the same instance necessitates external synchronization.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Extensions and variants
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::unordered_map` is a variant that holds unique keys. If you need ordered
    key behavior, `std::multimap` and `std::map` are tree-based alternatives.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Sorting and searching complexity
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Its sorting and search complexity is characterized as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '**Sorting**: Not inherently sortable as it is unordered; must be copied to
    a sortable container'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Searching**: Average-case *O(1)* due to hashing, but can degrade in the presence
    of many hash collisions'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special interface and member functions
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Beyond common functions (`insert`, `find`, `erase`), dive into the following:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '`emplace`: Directly constructs the element in the container'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bucket`: Fetches the bucket number for a given key'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`load_factor`: Provides the ratio of elements to buckets'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparisons
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Compared to `std::unordered_map`, this container allows non-unique keys. If
    key order matters, `std::multimap` is a tree-based alternative.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Interactions with algorithms
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Being unordered, many STL algorithms designed for ordered sequences might not
    be directly applicable or would necessitate a different approach.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Failures in memory allocation or hash function complications can throw exceptions.
    Container operations offer basic exception safety, ensuring the container remains
    valid.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Customization
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义
- en: You can use custom allocators for memory adjustments. Custom hash functions
    or key equality predicates can also optimize behavior for specific use cases.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用自定义分配器进行内存调整。自定义哈希函数或键相等谓词也可以针对特定用例优化行为。
- en: Example
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例
- en: '`std::unordered_multimap` is similar to `std::unordered_map` but allows for
    multiple key-value pairs with equivalent keys. It is an associative container,
    meaning its value type is formed by combining its key and mapped types.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::unordered_multimap` 与 `std::unordered_map` 类似，但允许具有等效键的多个键值对。它是一个关联容器，其值类型是通过结合其键和映射类型形成的。'
- en: 'The following code example demonstrates some best practices when using `std::unordered_multimap`:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例演示了使用 `std::unordered_multimap` 的一些最佳实践：
- en: '[PRE6]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here’s the example output:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是示例输出：
- en: '[PRE7]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here are some key takeaways from the preceding code:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是从前面的代码中得出的几个要点：
- en: With `std::unordered_multimap`, it is possible to insert multiple key-value
    pairs with the same key.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `std::unordered_multimap` 中，可以插入具有相同键的多个键值对。
- en: You can use `equal_range` to get a range of iterators to all the key-value pairs
    with a specific key.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 `equal_range` 获取与特定键关联的所有键值对的迭代器范围。
- en: The `count` method helps you determine the number of key-value pairs with a
    specific key.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count` 方法可以帮助您确定具有特定键的键值对数量。'
- en: Like other unordered containers, you should be aware of the load factor and
    might want to rehash it if necessary to achieve optimal performance.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如同其他无序容器一样，您应该注意负载因子，并在必要时重新散列以实现最佳性能。
- en: Using the `erase()` method with a key will remove all the key-value pairs associated
    with that key.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用带有键的 `erase()` 方法将删除与该键关联的所有键值对。
- en: Since it is an unordered container, the order of the elements is not guaranteed.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于它是一个无序容器，元素的顺序是不保证的。
- en: Use `std::unordered_multimap` when you need to keep track of multiple values
    associated with the same key and don’t need the key-value pairs to be sorted.
    It provides average constant-time complexity for most operations.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您需要跟踪与同一键关联的多个值且不需要对键值对进行排序时，请使用 `std::unordered_multimap`。它为大多数操作提供平均常数时间复杂度。
- en: Best practices
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最佳实践
- en: 'Let’s explore the best practices of using `std::unordered_multimap`:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索使用 `std::unordered_multimap` 的最佳实践：
- en: '`std::unordered_multimap` signifies that the container maintains no specific
    order for its key-value pairs. Iterating through the container does not guarantee
    any particular sequence.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_multimap` 表示容器不维护其键值对的具体顺序。遍历容器不保证任何特定序列。'
- en: '`std::unordered_multimap` is its ability to store multiple entries for a single
    key. Remember this when inserting, erasing, or searching to avoid unintended logic
    errors.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_multimap` 的能力是存储单个键的多个条目。在插入、删除或搜索时记住这一点，以避免意外的逻辑错误。'
- en: '`load_factor()` function to monitor the current load factor. If it gets too
    high, consider rehashing the container using the `rehash()` function. It’s also
    possible to set a desired upper limit on the load factor with the `max_load_factor()`
    function.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `load_factor()` 函数来监控当前的负载因子。如果它变得过高，可以考虑使用 `rehash()` 函数重新散列容器。也可以使用 `max_load_factor()`
    函数设置负载因子的期望上限。
- en: '`std::hash` template specialization for custom data types to ensure efficient
    and consistent hashing.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为自定义数据类型提供 `std::hash` 模板特化，以确保高效且一致的散列。
- en: '**Handle hash collisions**: Even with an efficient hash function, collisions
    might occur. The container handles these internally, but awareness of them helps
    with making better design decisions. Collisions can lead to a performance drop
    in insertion and search operations, so balancing the load factor and the number
    of buckets is essential.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理哈希冲突**：即使有高效的哈希函数，也可能发生冲突。容器内部处理这些冲突，但了解它们有助于做出更好的设计决策。冲突可能导致插入和搜索操作的性能下降，因此平衡负载因子和桶的数量是至关重要的。'
- en: '`equal_range()` when iterating through all values associated with a specific
    key.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在遍历与特定键关联的所有值时使用 `equal_range()`。
- en: '**Iterator invalidation**: Iterator invalidation can be a concern, especially
    after operations such as rehashing. Always ensure that iterators, pointers, or
    references to the elements are not used after they might have been invalidated.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**迭代器失效**：迭代器失效可能是一个问题，尤其是在重新散列等操作之后。始终确保在可能失效之后不使用指向元素的迭代器、指针或引用。'
- en: '`emplace` or `emplace_hint` methods. These allow the key-value pair to be constructed
    directly within the container.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`emplace` 或 `emplace_hint` 方法。这些方法允许在容器内直接构造键值对。'
- en: '**Concurrency considerations**: Concurrent reads are thread-safe, but you’ll
    need external synchronization for any modifications or concurrent reads and writes.
    Use synchronization primitives such as mutexes in multi-threaded scenarios.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发考虑**: 并发读取是线程安全的，但对于任何修改或并发读取和写入，你需要外部同步。在多线程场景中使用同步原语，如互斥锁（mutexes）。'
- en: '`std::unordered_multimap`. However, ensure the selected algorithm doesn’t expect
    ordering or unique keys, since those assumptions would contradict the container’s
    properties.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_multimap`。然而，确保选定的算法不期望排序或唯一键，因为这些假设会与容器的属性相矛盾。'
