- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern Approach to Managing Third Parties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In modern software development, the reliance on third-party libraries is virtually
    inescapable. From foundational components such as OpenSSL for secure communication,
    and Boost for extensive C++ libraries, to even the standard library that forms
    the bedrock of C++ programming, external libraries are integral to building functional
    and efficient applications. This dependency underscores the importance of understanding
    how third-party libraries are managed within the C++ ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Given the complexity and diversity of these libraries, it’s crucial for developers
    to grasp the basics of third-party library management. This knowledge not only
    aids in the seamless integration of these libraries into projects but also influences
    deployment strategies. The compilation method of a library, whether static or
    dynamic, directly impacts the number of files deployed and the overall footprint
    of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike some other programming languages that benefit from a standardized library
    ecosystem, C++ presents a unique challenge due to the absence of such a unified
    system. This chapter delves into the existing solutions for third-party library
    management in C++, exploring tools such as vcpkg, Conan, and others. By examining
    these tools, we aim to provide insights into which solution might best fit your
    project’s needs, considering factors such as platform compatibility, ease of use,
    and the scope of the library catalog.
  prefs: []
  type: TYPE_NORMAL
- en: As we navigate through these solutions, our goal is to equip you with the knowledge
    to make informed decisions about integrating and managing third-party libraries
    in your C++ projects, thereby enhancing your development workflow and the quality
    of your software.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of linking and shared V threads::ThreadsS static libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the context of C and C++ development, third-party entities are external libraries
    or frameworks that developers integrate into their projects. These entities serve
    to improve functionality or utilize existing solutions. These third-party components
    can vary significantly in scope, from minimal utility libraries to comprehensive
    frameworks offering a broad range of features.
  prefs: []
  type: TYPE_NORMAL
- en: The process of integrating third-party libraries into a project involves using
    header files that outline the interfaces of these libraries. These header files
    contain the declarations of classes, functions, and variables provided by the
    library, allowing the compiler to understand the required signatures and structures
    for successful compilation. Including a header file in a C++ source file essentially
    concatenates the contents of the header file to the point of inclusion, enabling
    access to the library’s interfaces without embedding the actual implementation
    within the source file.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of these libraries is supplied through compiled object code,
    typically distributed as either static libraries or shared libraries. Static libraries
    are archives of object files that are directly incorporated into the final executable
    by the linker, resulting in a larger executable size due to the embedding of the
    library code. On the other hand, shared libraries, known as **Dynamic Link Libraries
    (DLLs)** on Windows or **Shared Objects (SOs)** on Unix-like systems, are not
    embedded into the executable. Instead, references to these libraries are included,
    and the operating system loads them into memory at runtime. This mechanism allows
    multiple applications to utilize the same library code, conserving memory.
  prefs: []
  type: TYPE_NORMAL
- en: Shared libraries were designed to facilitate the sharing of common libraries,
    such as libc or C++ standard libraries, among multiple applications. This practice
    is especially advantageous for frequently utilized libraries. This design also
    theoretically allows users to update shared libraries without needing to upgrade
    the entire application. However, in practice, this is not always seamless and
    can introduce compatibility issues, making it less advantageous for applications
    to provide their dependencies as shared libraries. Furthermore, opting for shared
    libraries over static ones can reduce linker time, as the linker does not need
    to embed the library code into the executable, which can speed up the build process.
  prefs: []
  type: TYPE_NORMAL
- en: The linker plays a pivotal role in this process, merging various object files
    and libraries into a single executable or library, and resolving symbol references
    along the way to ensure the final binary is complete and executable.
  prefs: []
  type: TYPE_NORMAL
- en: The choice between static and dynamic linking significantly affects application
    performance, size, and deployment strategies. Static linking simplifies deployment
    by creating self-contained executables but at the cost of larger file sizes and
    the necessity to recompile for library updates. Dynamic linking, while reducing
    memory usage by sharing library code among applications and facilitating easier
    library updates, introduces complexities in deployment to ensure all dependencies
    are met.
  prefs: []
  type: TYPE_NORMAL
- en: Given the complexities associated with linking external shared objects and the
    widespread use of templated code in C++, many library developers have started
    to prefer supplying their libraries as “header-only” libraries. A header-only
    library is a library that is entirely contained within header files, with no separate
    implementation files or precompiled binaries. This means that all the code, including
    function and class definitions, is included in the header files.
  prefs: []
  type: TYPE_NORMAL
- en: This approach simplifies the integration process significantly. When a developer
    includes a header file from a header-only library, they are not just including
    interface declarations but the entire implementation. Consequently, there is no
    need for separate compilation or linking of the library’s implementation; the
    compiler includes and compiles the library’s code directly into the developer’s
    source code when the header file is included. This direct inclusion can lead to
    more efficient inlining and optimizations by the compiler, potentially resulting
    in faster executable code due to the elimination of function call overheads.
  prefs: []
  type: TYPE_NORMAL
- en: However, it’s worth noting that while header-only libraries offer convenience
    and ease of integration, they also have some downsides. Since the entire library
    is included and compiled with each source file that includes it, this can lead
    to increased compilation times, especially for large libraries or projects that
    include the library in multiple files. Furthermore, any change in the header file
    necessitates recompiling all source files that include it, which can further increase
    development time.
  prefs: []
  type: TYPE_NORMAL
- en: Despite its drawbacks, the header-only approach in C++ is highly attractive
    to many developers and users due to its simplicity of distribution and use. Additionally,
    it helps avoid linking issues and offers benefits for template-heavy libraries.
    This model is especially prevalent in libraries where heavy use of templates is
    made, such as those providing metaprogramming facilities, because templates must
    be available in their entirety to the compiler at compile time, making the header-only
    model a natural fit.
  prefs: []
  type: TYPE_NORMAL
- en: In essence, the management of third-party dependencies in C++ projects involves
    a deep understanding of header files, static and shared libraries, and the intricacies
    of the linking process. Developers must carefully consider the trade-offs between
    static and dynamic linking in the context of application requirements and deployment
    environments, balancing factors such as performance, size, and ease of maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: Managing third-party libraries in C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing third-party libraries is a critical aspect of C++ development. While
    there is no standardized package manager for C++, various methods and tools have
    been adopted to streamline this process, each with its own set of practices and
    supported platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Installing libraries with OS package managers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many developers rely on the operating system’s package manager to install third-party
    libraries. On Ubuntu and other Debian-based systems, `apt` is commonly used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For Red Hat-based systems, `yum` or its successor `dnf` is the go-to option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'On macOS, Homebrew is a popular choice for managing packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Windows users often turn to Chocolatey or `vcpkg` (the latter also functions
    as a general C++ library manager beyond just Windows):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: These OS package managers are convenient for common libraries but might not
    always offer the latest version or specific configurations needed for development.
  prefs: []
  type: TYPE_NORMAL
- en: Using Git as a third-party manager via submodules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Git submodules allow developers to include and manage the source code of third-party
    libraries directly within their repositories. This method is advantageous for
    ensuring all team members and the build system use an exact version of a library.
    A typical workflow for adding a submodule and integrating it with CMake might
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In `CMakeLists.txt`, you’d include the submodule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This method tightly couples your project with specific versions of the library
    and facilitates tracking updates through Git.
  prefs: []
  type: TYPE_NORMAL
- en: Using CMake FetchContent to download libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'CMake’s `FetchContent` module provides a more flexible alternative to submodules
    by downloading dependencies at configure time, without the need to include them
    directly in your repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This approach differs from Git submodules by not requiring the library’s source
    code to be present in your repository or updating it manually. `FetchContent`
    dynamically retrieves the specified version, making it easier to manage and update
    dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Conan – advanced dependency management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Conan is a powerful package manager for C and C++ that simplifies the process
    of integrating third-party libraries and managing dependencies across various
    platforms and configurations. It stands out for its ability to handle multiple
    versions of libraries, complex dependency graphs, and different build configurations,
    making it an essential tool for modern C++ development.
  prefs: []
  type: TYPE_NORMAL
- en: Conan configuration and features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Conan’s configuration is stored in `conanfile.txt` or `conanfile.py`, where
    developers specify the required libraries, versions, settings, and options. This
    file serves as the manifest for project dependencies, enabling precise control
    over the libraries used in a project.
  prefs: []
  type: TYPE_NORMAL
- en: '**Key features**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Multi-platform support**: Conan is designed to work on Windows, Linux, macOS,
    and FreeBSD, offering a consistent experience across different operating systems'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Build configuration management**: Developers can specify settings such as
    compiler version, architecture, and build type (debug, release) to ensure compatibility
    and optimal builds for their projects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Version handling**: Conan can manage multiple versions of the same library,
    allowing projects to depend on specific versions as needed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency resolution**: It automatically resolves and downloads transitive
    dependencies, ensuring that all required libraries are available for the build
    process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Library locations and Conan Center
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The primary repository for Conan packages is **Conan Center**, an extensive
    collection of open source C and C++ libraries. Conan Center is the go-to place
    to find and download packages, but developers can also specify custom or private
    repositories for their projects.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to Conan Center, companies and development teams can host their
    own Conan servers or use services such as Artifactory to manage private or proprietary
    packages, enabling a centralized approach to dependency management within an organization.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring static or dynamic linking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Conan allows developers to specify whether to use static or dynamic linking
    for libraries. This is typically done through options in `conanfile.txt` or `conanfile.py`.
    Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: These settings instruct Conan to download and use the dynamic version of the
    specified libraries. Similarly, setting the option to `False` would favor static
    libraries. It’s essential to note that not all packages will support both linking
    options, depending on how they were packaged for Conan.
  prefs: []
  type: TYPE_NORMAL
- en: Extending Conan with custom packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the strengths of Conan is its extensible nature. If a required library
    is not available in Conan Center or does not meet specific needs, developers can
    create and contribute their own packages. Conan provides a Python-based development
    kit for creating packages, which includes tools for defining build processes,
    dependencies, and package metadata.
  prefs: []
  type: TYPE_NORMAL
- en: To create a Conan package, developers define `conanfile.py` that describes how
    to source, build, and package the library. This file includes methods such as
    `source()`, `build()`, and `package()` that Conan executes during the package
    creation process.
  prefs: []
  type: TYPE_NORMAL
- en: Once a package is developed, it can be shared through Conan Center by submitting
    it for inclusion, or it can be distributed through private repositories to maintain
    control over distribution and usage.
  prefs: []
  type: TYPE_NORMAL
- en: Conan’s flexibility, support for multiple platforms and configurations, and
    its comprehensive package repository make it an invaluable tool for C++ developers.
    By leveraging Conan, teams can streamline their dependency management process,
    ensuring consistent, reproducible builds across different environments. The ability
    to configure static or dynamic linking, coupled with the option to extend the
    repository with custom packages, underscores Conan’s adaptability to diverse project
    requirements. Whether working with widely-used open source libraries or specialized
    proprietary code, Conan provides a robust framework for managing C++ dependencies
    efficiently and effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Conan is a dedicated C++ package manager that excels in managing different versions
    of libraries and their dependencies. It operates independently of the operating
    system’s package manager and provides a high level of control and flexibility.
    A typical Conan workflow involves creating `conanfile.txt` or `conanfile.py` to
    declare dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: CMake integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'CMake is widely used in C++ projects for its powerful scripting capabilities
    and cross-platform support. Integrating Conan with CMake can significantly streamline
    the process of managing dependencies. Here’s how you can achieve this integration:'
  prefs: []
  type: TYPE_NORMAL
- en: '`conanbuildinfo.cmake` file generated by Conan in your project’s `CMakeLists.txt`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This script sets up the necessary `include` paths and library paths, and defines
    the dependencies managed by Conan, making them available to your CMake project.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`TARGETS` option in `conan_basic_setup()` generates CMake targets for your
    Conan dependencies, allowing you to link against them using the `target_link_libraries()`
    function in CMake:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This approach provides a clean and explicit way to link your project’s targets
    against the libraries managed by Conan.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Other build system integration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Conan’s flexibility extends to other build systems as well, making it adaptable
    to various project requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '`include` paths, library paths, and flags that can be included in a Makefile:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.props` files that can be imported into Visual Studio projects, providing
    a seamless integration with the MSBuild ecosystem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bazel, Meson, and others**: While direct support for some build systems such
    as Bazel or Meson might require custom integration scripts or tools, the Conan
    community often contributes generators and tools to bridge these gaps, extending
    Conan’s reach to virtually any build system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom integration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For build systems without direct support or for projects with unique requirements,
    Conan offers the ability to customize the generated files or even write custom
    generators. This allows developers to tailor the integration to their specific
    build process, making Conan a highly adaptable tool for dependency management.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The integration of Conan with CMake and other build systems underscores its
    versatility as a package manager for C++ projects. By providing straightforward
    mechanisms to incorporate dependencies into various build environments, Conan
    not only simplifies dependency management but also enhances build reproducibility
    and consistency across different platforms and configurations. Whether you’re
    working with a widely used build system such as CMake or a more specialized setup,
    Conan’s flexible integration options ensure that you can maintain an efficient
    and streamlined development workflow.
  prefs: []
  type: TYPE_NORMAL
- en: vcpkg
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: vcpkg, developed by Microsoft, is a cross-platform C++ package manager that
    simplifies the process of acquiring and building C++ open source libraries. It
    is designed to work seamlessly with CMake and other build systems, providing a
    straightforward and consistent way to manage C++ library dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Key differences from Conan
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While both vcpkg and Conan are aimed at simplifying dependency management in
    C++ projects, there are notable differences in their approach and ecosystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Origin and backing**: vcpkg was created and is maintained by Microsoft, which
    ensures tight integration with Visual Studio and the MSBuild system, although
    it remains fully functional and useful across different platforms and development
    environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Package sources**: vcpkg focuses on compiling from source, ensuring that
    libraries are built with the same compiler and settings as the consuming project.
    This approach contrasts with Conan, which can manage precompiled binaries, allowing
    for quicker integration but potentially leading to binary incompatibility issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration**: vcpkg integrates natively with CMake and Visual Studio, providing
    manifest files for project-level integration. This can make it particularly attractive
    for projects already using these tools, offering a more seamless integration experience.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ecosystem and libraries**: Both package managers boast a large collection
    of available libraries, but their ecosystems might differ slightly due to the
    community and backing of each project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operating system support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'vcpkg is designed to be cross-platform, with support for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: macOS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This wide range of support makes it a versatile option for developers working
    in diverse development environments.
  prefs: []
  type: TYPE_NORMAL
- en: Example of configuring a project with vcpkg
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To illustrate the use of vcpkg in a project, let’s go through a simple example
    of integrating a library, such as the JSON for Modern C++ library (`nlohmann-json`),
    into a C++ project using CMake.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clone the vcpkg repository and run the bootstrap script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`vcpkg` will download and compile the library, making it available for projects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use vcpkg with a CMake project, you can set the `CMAKE_TOOLCHAIN_FILE` variable
    to the path of the `vcpkg.cmake` toolchain file when configuring your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`vcpkg`, with its emphasis on source-based distribution and integration with
    CMake and Visual Studio, offers a robust solution for C++ developers looking to
    manage library dependencies effectively. Its simplicity, coupled with the backing
    of Microsoft, makes it a compelling choice for projects that prioritize consistency
    with the build environment and seamless integration with existing Microsoft tools.
    While it shares common goals with Conan in simplifying dependency management,
    the choice between vcpkg and Conan may come down to specific project requirements,
    preferred workflow, and the development ecosystem.'
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing Docker for C++ builds
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A notable shortfall within C++ is its absence of an inherent mechanism for
    managing dependencies. Consequently, the incorporation of third-party elements
    is achieved through a heterogeneous array of methodologies: the utilization of
    package managers provided by Linux distributions (for instance, `apt-get`), the
    direct installation via `make install`, the inclusion of third-party libraries
    as Git submodules and their subsequent compilation within the project’s source
    tree, or the adoption of package management solutions such as Conan or Vcpkgvcpkg.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Regrettably, each of these methods comes with its own set of drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: The installation of dependencies directly on a development machine tends to
    compromise the cleanliness of the environment, rendering it dissimilar to those
    of CI/CD pipelines or production environments – a discrepancy that becomes more
    pronounced with each update of third-party components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is often a formidable task to ensure uniformity in the versions of compilers,
    debuggers, and other tools utilized by all developers. This lack of standardization
    can culminate in a scenario where a build executes successfully on an individual
    developer’s machine yet fails within the CI/CD environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The practice of integrating third-party libraries as Git submodules and compiling
    them within the project’s source directory poses a challenge, particularly when
    dealing with substantial libraries (such as Boost, Protobuf, Thrift, etc.). This
    method can lead to a significant deceleration of the build process, to the extent
    that developers may hesitate to clear the build directory or to alternate between
    branches.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Package management solutions such as Conan may not always offer the desired
    version of a specific dependency, and the inclusion of such a version necessitates
    the authoring of additional code in Python, which, in my opinion, is unduly burdensome.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A single isolated and reproducible build environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The optimal resolution for the aforementioned challenges involves the formulation
    of a Docker image, embedded with all requisite dependencies and tools, such as
    compilers and debuggers, to facilitate the project’s compilation within a container
    derived from this image.
  prefs: []
  type: TYPE_NORMAL
- en: This particular image serves as the cornerstone for a **singular** build environment
    that is uniformly employed by developers on their respective workstations as well
    as on CI/CD servers, effectively eliminating the all-too-common discrepancy of
    “it works on my machine but fails at CI!”.
  prefs: []
  type: TYPE_NORMAL
- en: Owing to the encapsulated nature of the build process within the container,
    it remains impervious to any external variables, tools, or configurations peculiar
    to an individual developer’s local setup, thereby rendering the build environment
    **isolated**.
  prefs: []
  type: TYPE_NORMAL
- en: In an ideal scenario, Docker images are meticulously labeled with meaningful
    version identifiers, enabling users to seamlessly transition between different
    environments by retrieving the appropriate image from the registry. Furthermore,
    in the event that an image is no longer available in the registry, it’s worth
    noting that Docker images are constructed from Dockerfiles, which are typically
    maintained within Git repositories. This ensures that, should the need arise,
    there is always the feasibility to reconstruct the image from a previous version
    of the Dockerfile. This attribute of the Dockerized build framework lends it a
    characteristic of being **reproducible**.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the build image
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will embark on developing a straightforward application and compile it within
    a container. The essence of the application is to display its size utilizing `boost::filesystem`.
    The selection of Boost for this demonstration is intentional, aiming to illustrate
    the integration of Docker with a “heavy” third-party library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The CMake file is quite simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In this example, Boost is linked statically since it is required if the target
    machine does not have the right version of Boost pre-installed; this recommendation
    applies to all dependencies pre-installed in the Docker image.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Dockerfile employed for this task is notably uncomplicated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To ensure that its name is distinctive and does not overlap with existing Dockerfiles,
    while also clearly conveying its purpose, I have named it `DockerfileBuildEnv`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*Note that the version is not the “latest” but has a meaningful name (e.g., 0.1).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the image has been successfully constructed, we are positioned to proceed
    with the project’s build process. The initial step involves initiating a Docker
    container that is based on our crafted image, followed by the execution of the
    Bash shell within this container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The parameter of particular importance in this context is `--``mount type=bind,source=$`
    **{PWD},target=/src**. This directive instructs Docker to bind mount the current
    directory, which houses the source code, to the `/src` directory within the container.
    This approach circumvents the need to copy source files into the container. Moreover,
    as will be demonstrated subsequently, it enables the storage of output binaries
    directly on the host’s file system, thereby eliminating the need for redundant
    copying. For an understanding of the remaining flags and options, it is advisable
    to consult the official Docker documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the container, we will proceed to compile the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Et voilà, the project was built successfully!
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting binary runs successfully, both in the container and on the host,
    because Boost is linked *statically*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Making the environment usable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this juncture, it’s reasonable to feel overwhelmed by the multitude of Docker
    commands and wonder how one is expected to memorize them all. It’s important to
    emphasize that developers are not expected to retain every detail of these commands
    for project-building purposes. To streamline this process, I propose encapsulating
    the Docker commands within a tool that is widely familiar to most developers –
    `make`.
  prefs: []
  type: TYPE_NORMAL
- en: To facilitate this, I have established a GitHub repository ([https://github.com/f-squirrel/dockerized_cpp](https://github.com/f-squirrel/dockerized_cpp))
    that contains a versatile Makefile. This Makefile is designed to be easily adaptable
    and can typically be employed for nearly any project that utilizes CMake without
    necessitating modifications. Users have the option to either directly download
    it from this repository or integrate it into their project as a Git submodule,
    ensuring access to the most recent updates. I advocate for the latter approach
    and will provide further details on this.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Makefile is configured to support fundamental commands. Users can display
    the available command options by executing `make help` in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To integrate the Makefile into our sample project, we’ll begin by adding it
    as a Git submodule within the `build_tools` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to create another Makefile in the root of the repository and
    include the Makefile that we have just checked out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Before the project compilation, it’s prudent to adjust certain default settings
    to better suit the specific needs of your project. This can be efficiently achieved
    by declaring variables in the top-level Makefile prior to the inclusion of `build_tools/Makefile`.
    Such preemptive declarations allow for the customization of various parameters,
    ensuring that the build environment and process are optimally configured for your
    project’s requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Make is now ready to build the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The Makefile, by default, assigns the latest tag to the Docker image. For better
    version control and to align with our project’s current stage, it is advisable
    to tag the image with a specific version. In this context, we shall tag the image
    as `0.1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let us build the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Upon inspecting the build directory on the host, you’ll observe that the output
    binary has been seamlessly placed there, facilitating easy access and management.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both the Makefile and an example of a project that utilizes it with its default
    values can be found on GitHub. This provides a practical demonstration of how
    the Makefile can be integrated into a project, offering a turnkey solution for
    developers seeking to implement a Dockerized build environment in their C++ projects:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Makefile repository: [https://github.com/f-squirrel/dockerized_cpp](https://github.com/f-squirrel/dockerized_cpp)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example project: [https://github.com/f-squirrel/dockerized_cpp](https://github.com/f-squirrel/dockerized_cpp)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhancements for user management within Dockerized builds
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The initial iteration of the Docker-based build system executed operations under
    the root user’s privileges. While this setup typically doesn’t pose immediate
    problems—developers have the option to modify file permissions using `chmod`—executing
    Docker containers as the root user is generally discouraged from a security standpoint.
    More critically, this approach can lead to complications if any of the build targets
    modify the source code, such as code formatting or applying `clang-tidy` corrections
    through `make` commands. Such modifications could result in source files being
    owned by the root user, thereby restricting the ability to edit these files directly
    from the host.
  prefs: []
  type: TYPE_NORMAL
- en: 'To address this concern, modifications have been made to the Dockerized build’s
    source code, enabling the container to execute as the host user by specifying
    the current user’s ID and group ID. This adjustment is now the standard configuration
    to enhance security and usability. Should there be a need to revert to running
    the container as the root user, the following command can be utilized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: It is important to recognize that the Docker image does not replicate the host
    user’s environment in its entirety—there is no corresponding home directory, nor
    are the user’s name and group replicated within the container. This implies that
    if the build process relies on accessing the home directory, this modified approach
    may not be suitable.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored various strategies and tools for managing third-party
    dependencies in C++ projects, a critical aspect that significantly impacts the
    efficiency and reliability of the development process. We delved into traditional
    methods, such as utilizing operating system package managers and incorporating
    dependencies directly via Git submodules, each with its unique advantages and
    limitations.
  prefs: []
  type: TYPE_NORMAL
- en: We then transitioned to more specialized C++ package managers, highlighting
    Conan and vcpkg. Conan, with its robust ecosystem, extensive library support through
    Conan Center, and flexible configuration options, offers a comprehensive solution
    for managing complex dependencies, integrating seamlessly with multiple build
    systems, and supporting both static and dynamic linking. Its ability to handle
    multiple versions of libraries and the ease with which developers can extend the
    repository with custom packages make it an invaluable tool for modern C++ development.
  prefs: []
  type: TYPE_NORMAL
- en: vcpkg, developed by Microsoft, presents a slightly different approach, focusing
    on source-based distribution and ensuring libraries are built with the same compiler
    and settings as the consuming project. Its tight integration with CMake and Visual
    Studio, coupled with the backing of Microsoft, ensures a smooth experience, particularly
    for projects within the Microsoft ecosystem. The emphasis on compiling from source
    addresses potential binary incompatibility issues, making vcpkg a reliable choice
    for managing dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we discussed the adoption of Dockerized builds as an advanced strategy
    for creating consistent, reproducible build environments, particularly beneficial
    in Linux systems. This approach, while more complex, offers significant advantages
    in terms of isolation, scalability, and consistency across development, testing,
    and deployment stages.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the chapter, we aimed to equip you with the knowledge and tools necessary
    to navigate the landscape of dependency management in C++ projects. By understanding
    the strengths and limitations of each method and tool, developers can make informed
    decisions tailored to their project’s specific needs, leading to more efficient
    and reliable software development processes.
  prefs: []
  type: TYPE_NORMAL
