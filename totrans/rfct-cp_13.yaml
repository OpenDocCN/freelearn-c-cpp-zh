- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Modern Approach to Managing Third Parties
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理第三方库的现代方法
- en: In modern software development, the reliance on third-party libraries is virtually
    inescapable. From foundational components such as OpenSSL for secure communication,
    and Boost for extensive C++ libraries, to even the standard library that forms
    the bedrock of C++ programming, external libraries are integral to building functional
    and efficient applications. This dependency underscores the importance of understanding
    how third-party libraries are managed within the C++ ecosystem.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代软件开发中，对第三方库的依赖几乎是不可避免的。从基础组件，如用于安全通信的 OpenSSL 和用于广泛 C++ 库的 Boost，甚至构成 C++
    编程基石的标准库，外部库对于构建功能强大和高效的程序至关重要。这种依赖性突显了理解如何在 C++ 生态系统中管理第三方库的重要性。
- en: Given the complexity and diversity of these libraries, it’s crucial for developers
    to grasp the basics of third-party library management. This knowledge not only
    aids in the seamless integration of these libraries into projects but also influences
    deployment strategies. The compilation method of a library, whether static or
    dynamic, directly impacts the number of files deployed and the overall footprint
    of the application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些库的复杂性和多样性，开发人员掌握第三方库管理的基本知识至关重要。这种知识不仅有助于将这些库无缝集成到项目中，而且还会影响部署策略。库的编译方法，无论是静态还是动态，都会直接影响部署的文件数量和应用程序的整体影响范围。
- en: Unlike some other programming languages that benefit from a standardized library
    ecosystem, C++ presents a unique challenge due to the absence of such a unified
    system. This chapter delves into the existing solutions for third-party library
    management in C++, exploring tools such as vcpkg, Conan, and others. By examining
    these tools, we aim to provide insights into which solution might best fit your
    project’s needs, considering factors such as platform compatibility, ease of use,
    and the scope of the library catalog.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 与一些受益于标准化库生态系统的其他编程语言不同，C++ 由于缺乏这样的统一系统而面临独特的挑战。本章深入探讨了 C++ 中第三方库管理的现有解决方案，例如
    vcpkg、Conan 以及其他工具。通过检查这些工具，我们旨在提供见解，了解哪种解决方案可能最适合您的项目需求，考虑因素包括平台兼容性、易用性和库目录的范围。
- en: As we navigate through these solutions, our goal is to equip you with the knowledge
    to make informed decisions about integrating and managing third-party libraries
    in your C++ projects, thereby enhancing your development workflow and the quality
    of your software.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们浏览这些解决方案，我们的目标是为您提供知识，以便您在 C++ 项目中集成和管理第三方库时做出明智的决定，从而提高您的开发工作流程和软件质量。
- en: Overview of linking and shared V threads::ThreadsS static libraries
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接和共享 V 线程概述：线程静态库
- en: In the context of C and C++ development, third-party entities are external libraries
    or frameworks that developers integrate into their projects. These entities serve
    to improve functionality or utilize existing solutions. These third-party components
    can vary significantly in scope, from minimal utility libraries to comprehensive
    frameworks offering a broad range of features.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 和 C++ 开发背景下，第三方实体是开发人员将其集成到项目中的外部库或框架。这些实体旨在提高功能或利用现有解决方案。这些第三方组件在范围上可能差异很大，从最小实用库到提供广泛功能的全面框架。
- en: The process of integrating third-party libraries into a project involves using
    header files that outline the interfaces of these libraries. These header files
    contain the declarations of classes, functions, and variables provided by the
    library, allowing the compiler to understand the required signatures and structures
    for successful compilation. Including a header file in a C++ source file essentially
    concatenates the contents of the header file to the point of inclusion, enabling
    access to the library’s interfaces without embedding the actual implementation
    within the source file.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 将第三方库集成到项目中的过程涉及使用概述这些库接口的头文件。这些头文件包含库提供的类、函数和变量的声明，使编译器能够理解成功编译所需的签名和结构。在 C++
    源文件中包含头文件实际上是将头文件的内容连接到包含点，从而允许访问库的接口，而无需在源文件中嵌入实际的实现。
- en: The implementation of these libraries is supplied through compiled object code,
    typically distributed as either static libraries or shared libraries. Static libraries
    are archives of object files that are directly incorporated into the final executable
    by the linker, resulting in a larger executable size due to the embedding of the
    library code. On the other hand, shared libraries, known as **Dynamic Link Libraries
    (DLLs)** on Windows or **Shared Objects (SOs)** on Unix-like systems, are not
    embedded into the executable. Instead, references to these libraries are included,
    and the operating system loads them into memory at runtime. This mechanism allows
    multiple applications to utilize the same library code, conserving memory.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这些库的实现通过编译后的目标代码提供，通常以静态库或共享库的形式分发。静态库是目标文件的归档，由链接器直接合并到最终的可执行文件中，由于库代码的嵌入，导致可执行文件大小更大。另一方面，共享库，在Windows上称为**动态链接库（DLLs**），或在类Unix系统上称为**共享对象（SOs**），不会嵌入到可执行文件中。相反，包括对这些库的引用，操作系统在运行时将它们加载到内存中。这种机制允许多个应用程序利用相同的库代码，从而节省内存。
- en: Shared libraries were designed to facilitate the sharing of common libraries,
    such as libc or C++ standard libraries, among multiple applications. This practice
    is especially advantageous for frequently utilized libraries. This design also
    theoretically allows users to update shared libraries without needing to upgrade
    the entire application. However, in practice, this is not always seamless and
    can introduce compatibility issues, making it less advantageous for applications
    to provide their dependencies as shared libraries. Furthermore, opting for shared
    libraries over static ones can reduce linker time, as the linker does not need
    to embed the library code into the executable, which can speed up the build process.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 共享库旨在促进多个应用程序之间共享常见库，如libc或C++标准库。这种做法对于频繁使用的库特别有利。这种设计从理论上也允许用户在不升级整个应用程序的情况下更新共享库。然而，在实践中，这并不总是无缝的，可能会引入兼容性问题，使得应用程序提供其依赖项作为共享库的优势减少。此外，选择共享库而不是静态库可以减少链接器时间，因为链接器不需要将库代码嵌入到可执行文件中，这可以加快构建过程。
- en: The linker plays a pivotal role in this process, merging various object files
    and libraries into a single executable or library, and resolving symbol references
    along the way to ensure the final binary is complete and executable.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 链接器在这个过程中扮演着至关重要的角色，它将各种目标文件和库合并成一个单一的可执行文件或库，并在过程中解决符号引用，以确保最终的二进制文件完整且可执行。
- en: The choice between static and dynamic linking significantly affects application
    performance, size, and deployment strategies. Static linking simplifies deployment
    by creating self-contained executables but at the cost of larger file sizes and
    the necessity to recompile for library updates. Dynamic linking, while reducing
    memory usage by sharing library code among applications and facilitating easier
    library updates, introduces complexities in deployment to ensure all dependencies
    are met.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在静态链接和动态链接之间的选择对应用程序的性能、大小和部署策略有显著影响。静态链接通过创建自包含的可执行文件简化了部署，但代价是文件大小更大，以及需要重新编译以更新库。动态链接，通过在应用程序之间共享库代码以减少内存使用并简化库更新，在部署中引入了复杂性，以确保满足所有依赖项。
- en: Given the complexities associated with linking external shared objects and the
    widespread use of templated code in C++, many library developers have started
    to prefer supplying their libraries as “header-only” libraries. A header-only
    library is a library that is entirely contained within header files, with no separate
    implementation files or precompiled binaries. This means that all the code, including
    function and class definitions, is included in the header files.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到与链接外部共享对象相关的复杂性以及C++中模板代码的广泛应用，许多库开发者已经开始倾向于提供“仅头文件”库。仅头文件库是一个完全包含在头文件中的库，没有单独的实现文件或预编译的二进制文件。这意味着所有代码，包括函数和类定义，都包含在头文件中。
- en: This approach simplifies the integration process significantly. When a developer
    includes a header file from a header-only library, they are not just including
    interface declarations but the entire implementation. Consequently, there is no
    need for separate compilation or linking of the library’s implementation; the
    compiler includes and compiles the library’s code directly into the developer’s
    source code when the header file is included. This direct inclusion can lead to
    more efficient inlining and optimizations by the compiler, potentially resulting
    in faster executable code due to the elimination of function call overheads.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法显著简化了集成过程。当开发者从一个仅包含头文件的库中包含头文件时，他们不仅仅是包含接口声明，还包括整个实现。因此，不需要对库的实现进行单独的编译或链接；当包含头文件时，编译器将库的代码直接包含并编译到开发者的源代码中。这种直接包含可能导致编译器进行更有效的内联和优化，从而可能由于消除了函数调用开销而生成更快的可执行代码。
- en: However, it’s worth noting that while header-only libraries offer convenience
    and ease of integration, they also have some downsides. Since the entire library
    is included and compiled with each source file that includes it, this can lead
    to increased compilation times, especially for large libraries or projects that
    include the library in multiple files. Furthermore, any change in the header file
    necessitates recompiling all source files that include it, which can further increase
    development time.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，值得注意的是，虽然仅包含头文件的库提供了便利和易于集成的优势，但它们也有一些缺点。由于整个库被包含并编译到包含它的每个源文件中，这可能导致编译时间增加，尤其是在大型库或包含库在多个文件中的项目中。此外，任何对头文件的更改都需要重新编译包含它的所有源文件，这可能会进一步增加开发时间。
- en: Despite its drawbacks, the header-only approach in C++ is highly attractive
    to many developers and users due to its simplicity of distribution and use. Additionally,
    it helps avoid linking issues and offers benefits for template-heavy libraries.
    This model is especially prevalent in libraries where heavy use of templates is
    made, such as those providing metaprogramming facilities, because templates must
    be available in their entirety to the compiler at compile time, making the header-only
    model a natural fit.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在缺点，但由于其分发和使用简单，C++中的仅包含头文件的方案对许多开发者和用户来说极具吸引力。此外，它有助于避免链接问题，并为模板密集型库提供好处。这种模式在那些大量使用模板的库中尤为普遍，例如提供元编程功能的库，因为模板必须在编译时完整地提供给编译器，这使得仅包含头文件的模型成为一种自然的选择。
- en: In essence, the management of third-party dependencies in C++ projects involves
    a deep understanding of header files, static and shared libraries, and the intricacies
    of the linking process. Developers must carefully consider the trade-offs between
    static and dynamic linking in the context of application requirements and deployment
    environments, balancing factors such as performance, size, and ease of maintenance.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，C++项目中第三方依赖项的管理涉及对头文件、静态库和共享库的深入了解，以及链接过程的复杂性。开发者必须仔细考虑在应用需求和部署环境中静态链接和动态链接之间的权衡，平衡性能、大小和维护便利性等因素。
- en: Managing third-party libraries in C++
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++中管理第三方库
- en: Managing third-party libraries is a critical aspect of C++ development. While
    there is no standardized package manager for C++, various methods and tools have
    been adopted to streamline this process, each with its own set of practices and
    supported platforms.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 管理第三方库是C++开发的关键方面。虽然C++没有标准化的包管理器，但已经采用了各种方法和工具来简化此过程，每种方法都有自己的实践和受支持的平台。
- en: Installing libraries with OS package managers
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用操作系统包管理器安装库
- en: 'Many developers rely on the operating system’s package manager to install third-party
    libraries. On Ubuntu and other Debian-based systems, `apt` is commonly used:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者依赖于操作系统的包管理器来安装第三方库。在Ubuntu和其他基于Debian的系统上，通常使用`apt`：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For Red Hat-based systems, `yum` or its successor `dnf` is the go-to option:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于Red Hat的系统，`yum`或其继任者`dnf`是首选选项：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'On macOS, Homebrew is a popular choice for managing packages:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS上，Homebrew是管理包的流行选择：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Windows users often turn to Chocolatey or `vcpkg` (the latter also functions
    as a general C++ library manager beyond just Windows):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Windows用户通常转向Chocolatey或`vcpkg`（后者也作为Windows之外的通用C++库管理器使用）：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: These OS package managers are convenient for common libraries but might not
    always offer the latest version or specific configurations needed for development.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作系统包管理器对于常见库来说很方便，但可能并不总是提供最新的版本或开发所需的具体配置。
- en: Using Git as a third-party manager via submodules
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过子模块使用Git作为第三方管理器
- en: 'Git submodules allow developers to include and manage the source code of third-party
    libraries directly within their repositories. This method is advantageous for
    ensuring all team members and the build system use an exact version of a library.
    A typical workflow for adding a submodule and integrating it with CMake might
    look like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Git子模块允许开发者直接在其仓库中包含和管理第三方库的源代码。此方法有利于确保所有团队成员和构建系统使用库的确切版本。添加子模块并将其与CMake集成的典型工作流程可能如下所示：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In `CMakeLists.txt`, you’d include the submodule:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CMakeLists.txt`中，您将包括子模块：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This method tightly couples your project with specific versions of the library
    and facilitates tracking updates through Git.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将您的项目与特定版本的库紧密耦合，并通过Git促进更新跟踪。
- en: Using CMake FetchContent to download libraries
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用CMake FetchContent下载库
- en: 'CMake’s `FetchContent` module provides a more flexible alternative to submodules
    by downloading dependencies at configure time, without the need to include them
    directly in your repository:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: CMake的`FetchContent`模块通过在配置时下载依赖项，而不需要在您的仓库中直接包含它们，提供了一种比子模块更灵活的替代方案：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This approach differs from Git submodules by not requiring the library’s source
    code to be present in your repository or updating it manually. `FetchContent`
    dynamically retrieves the specified version, making it easier to manage and update
    dependencies.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法与Git子模块不同，因为它不需要库的源代码存在于您的仓库中或手动更新它。`FetchContent`动态检索指定的版本，使其更容易管理和更新依赖项。
- en: Conan – advanced dependency management
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Conan – 高级依赖管理
- en: Conan is a powerful package manager for C and C++ that simplifies the process
    of integrating third-party libraries and managing dependencies across various
    platforms and configurations. It stands out for its ability to handle multiple
    versions of libraries, complex dependency graphs, and different build configurations,
    making it an essential tool for modern C++ development.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Conan是C和C++的强大包管理器，简化了集成第三方库和在各种平台和配置中管理依赖项的过程。它因其能够处理库的多个版本、复杂的依赖图和不同的构建配置而脱颖而出，是现代C++开发的必备工具。
- en: Conan configuration and features
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Conan配置和功能
- en: Conan’s configuration is stored in `conanfile.txt` or `conanfile.py`, where
    developers specify the required libraries, versions, settings, and options. This
    file serves as the manifest for project dependencies, enabling precise control
    over the libraries used in a project.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Conan的配置存储在`conanfile.txt`或`conanfile.py`中，开发者在此指定所需的库、版本、设置和选项。此文件作为项目依赖项的清单，允许对项目中使用的库进行精确控制。
- en: '**Key features**:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键特性**：'
- en: '**Multi-platform support**: Conan is designed to work on Windows, Linux, macOS,
    and FreeBSD, offering a consistent experience across different operating systems'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多平台支持**：Conan旨在在Windows、Linux、macOS和FreeBSD上运行，在不同操作系统上提供一致的经验'
- en: '**Build configuration management**: Developers can specify settings such as
    compiler version, architecture, and build type (debug, release) to ensure compatibility
    and optimal builds for their projects'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建配置管理**：开发者可以指定设置，如编译器版本、架构和构建类型（调试、发布），以确保项目的兼容性和最佳构建'
- en: '**Version handling**: Conan can manage multiple versions of the same library,
    allowing projects to depend on specific versions as needed'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本管理**：Conan可以管理同一库的多个版本，允许项目根据需要依赖特定版本'
- en: '**Dependency resolution**: It automatically resolves and downloads transitive
    dependencies, ensuring that all required libraries are available for the build
    process'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖解析**：它自动解析和下载传递依赖项，确保所有必需的库在构建过程中可用'
- en: Library locations and Conan Center
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图书馆位置和康南中心
- en: The primary repository for Conan packages is **Conan Center**, an extensive
    collection of open source C and C++ libraries. Conan Center is the go-to place
    to find and download packages, but developers can also specify custom or private
    repositories for their projects.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Conan包的主要仓库是**康南中心**，这是一个包含大量开源C和C++库的集合。康南中心是查找和下载包的首选地点，但开发者也可以为他们的项目指定自定义或私有仓库。
- en: In addition to Conan Center, companies and development teams can host their
    own Conan servers or use services such as Artifactory to manage private or proprietary
    packages, enabling a centralized approach to dependency management within an organization.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Conan Center 之外，公司和开发团队可以托管自己的 Conan 服务器或使用 Artifactory 等服务来管理私有或专有包，从而在组织内部实现依赖项管理的集中化方法。
- en: Configuring static or dynamic linking
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置静态或动态链接
- en: 'Conan allows developers to specify whether to use static or dynamic linking
    for libraries. This is typically done through options in `conanfile.txt` or `conanfile.py`.
    Here’s an example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Conan 允许开发者指定是否为库使用静态或动态链接。这通常通过 `conanfile.txt` 或 `conanfile.py` 中的选项来完成。以下是一个示例：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: These settings instruct Conan to download and use the dynamic version of the
    specified libraries. Similarly, setting the option to `False` would favor static
    libraries. It’s essential to note that not all packages will support both linking
    options, depending on how they were packaged for Conan.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设置指示 Conan 下载并使用指定库的动态版本。同样，将选项设置为 `False` 将优先考虑静态库。需要注意的是，并非所有包都支持这两种链接选项，这取决于它们是如何为
    Conan 打包的。
- en: Extending Conan with custom packages
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过自定义包扩展 Conan
- en: One of the strengths of Conan is its extensible nature. If a required library
    is not available in Conan Center or does not meet specific needs, developers can
    create and contribute their own packages. Conan provides a Python-based development
    kit for creating packages, which includes tools for defining build processes,
    dependencies, and package metadata.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Conan 的一个优势是其可扩展性。如果所需的库在 Conan Center 中不可用或不符合特定需求，开发者可以创建并贡献他们自己的包。Conan 提供了一个基于
    Python 的开发工具包来创建包，其中包括定义构建过程、依赖项和包元数据的工具。
- en: To create a Conan package, developers define `conanfile.py` that describes how
    to source, build, and package the library. This file includes methods such as
    `source()`, `build()`, and `package()` that Conan executes during the package
    creation process.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个 Conan 包，开发者定义 `conanfile.py` 文件，该文件描述了如何获取、构建和打包库。该文件包括 `source()`、`build()`
    和 `package()` 等方法，这些方法在包创建过程中由 Conan 执行。
- en: Once a package is developed, it can be shared through Conan Center by submitting
    it for inclusion, or it can be distributed through private repositories to maintain
    control over distribution and usage.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦开发了一个包，它可以通过提交以供包含或通过私有仓库进行分发来通过 Conan Center 进行共享，以保持对分发和使用的控制。
- en: Conan’s flexibility, support for multiple platforms and configurations, and
    its comprehensive package repository make it an invaluable tool for C++ developers.
    By leveraging Conan, teams can streamline their dependency management process,
    ensuring consistent, reproducible builds across different environments. The ability
    to configure static or dynamic linking, coupled with the option to extend the
    repository with custom packages, underscores Conan’s adaptability to diverse project
    requirements. Whether working with widely-used open source libraries or specialized
    proprietary code, Conan provides a robust framework for managing C++ dependencies
    efficiently and effectively.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Conan 的灵活性、对多个平台和配置的支持以及其全面的包仓库使其成为 C++ 开发者的无价之宝。通过利用 Conan，团队可以简化他们的依赖管理流程，确保在不同环境中构建的一致性和可重复性。能够配置静态或动态链接，以及可以扩展仓库以包含自定义包的选项，突显了
    Conan 对不同项目需求的适应性。无论是与广泛使用的开源库还是专用专有代码一起工作，Conan 都提供了一个强大而有效的框架来高效有效地管理 C++ 依赖项。
- en: Conan is a dedicated C++ package manager that excels in managing different versions
    of libraries and their dependencies. It operates independently of the operating
    system’s package manager and provides a high level of control and flexibility.
    A typical Conan workflow involves creating `conanfile.txt` or `conanfile.py` to
    declare dependencies.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Conan 是一个专门的 C++ 包管理器，在管理库的不同版本及其依赖项方面表现出色。它独立于操作系统的包管理器，并提供高水平的控制和灵活性。典型的 Conan
    工作流程涉及创建 `conanfile.txt` 或 `conanfile.py` 来声明依赖项。
- en: CMake integration
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CMake 集成
- en: 'CMake is widely used in C++ projects for its powerful scripting capabilities
    and cross-platform support. Integrating Conan with CMake can significantly streamline
    the process of managing dependencies. Here’s how you can achieve this integration:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 因其强大的脚本能力和跨平台支持而在 C++ 项目中得到广泛应用。将 Conan 与 CMake 集成可以显著简化依赖项管理的过程。以下是如何实现这种集成的步骤：
- en: '`conanbuildinfo.cmake` file generated by Conan in your project’s `CMakeLists.txt`:'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在项目的 `CMakeLists.txt` 中由 Conan 生成的 `conanbuildinfo.cmake` 文件：
- en: '[PRE8]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This script sets up the necessary `include` paths and library paths, and defines
    the dependencies managed by Conan, making them available to your CMake project.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此脚本设置了必要的 `include` 路径和库路径，并定义了由 Conan 管理的依赖项，使它们可用于您的 CMake 项目。
- en: '`TARGETS` option in `conan_basic_setup()` generates CMake targets for your
    Conan dependencies, allowing you to link against them using the `target_link_libraries()`
    function in CMake:'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`conan_basic_setup()` 中的 `TARGETS` 选项为您的 Conan 依赖项生成 CMake 目标，允许您使用 CMake 中的
    `target_link_libraries()` 函数来链接它们：'
- en: '[PRE10]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This approach provides a clean and explicit way to link your project’s targets
    against the libraries managed by Conan.
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此方法提供了一种清晰明确的方式来链接您的项目目标到由 Conan 管理的库。
- en: Other build system integration
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他构建系统集成
- en: 'Conan’s flexibility extends to other build systems as well, making it adaptable
    to various project requirements:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Conan 的灵活性也扩展到其他构建系统，使其能够适应各种项目需求：
- en: '`include` paths, library paths, and flags that can be included in a Makefile:'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可包含在 Makefile 中的 `include` 路径、库路径和标志：
- en: '[PRE11]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`.props` files that can be imported into Visual Studio projects, providing
    a seamless integration with the MSBuild ecosystem.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可导入到 Visual Studio 项目的 `.props` 文件，提供与 MSBuild 生态系统的无缝集成。
- en: '**Bazel, Meson, and others**: While direct support for some build systems such
    as Bazel or Meson might require custom integration scripts or tools, the Conan
    community often contributes generators and tools to bridge these gaps, extending
    Conan’s reach to virtually any build system.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Bazel, Meson 和其他工具**: 尽管对某些构建系统（如 Bazel 或 Meson）的直接支持可能需要自定义集成脚本或工具，但 Conan
    社区通常贡献生成器和工具来弥合这些差距，使 Conan 能够扩展到几乎任何构建系统。'
- en: Custom integration
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义集成
- en: For build systems without direct support or for projects with unique requirements,
    Conan offers the ability to customize the generated files or even write custom
    generators. This allows developers to tailor the integration to their specific
    build process, making Conan a highly adaptable tool for dependency management.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于没有直接支持或对项目有独特要求的构建系统，Conan 提供了自定义生成文件或编写自定义生成器的功能。这允许开发者根据其特定的构建过程定制集成，使 Conan
    成为依赖项管理的高度适应性的工具。
- en: Conclusion
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: The integration of Conan with CMake and other build systems underscores its
    versatility as a package manager for C++ projects. By providing straightforward
    mechanisms to incorporate dependencies into various build environments, Conan
    not only simplifies dependency management but also enhances build reproducibility
    and consistency across different platforms and configurations. Whether you’re
    working with a widely used build system such as CMake or a more specialized setup,
    Conan’s flexible integration options ensure that you can maintain an efficient
    and streamlined development workflow.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Conan 与 CMake 和其他构建系统的集成凸显了其在 C++ 项目包管理器方面的多功能性。通过提供将依赖项纳入各种构建环境的简单机制，Conan
    不仅简化了依赖项管理，还增强了不同平台和配置下的构建可重复性和一致性。无论您是在使用广泛使用的构建系统（如 CMake）还是更专业的设置，Conan 的灵活集成选项都能确保您能够保持高效和流畅的开发工作流程。
- en: vcpkg
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: vcpkg
- en: vcpkg, developed by Microsoft, is a cross-platform C++ package manager that
    simplifies the process of acquiring and building C++ open source libraries. It
    is designed to work seamlessly with CMake and other build systems, providing a
    straightforward and consistent way to manage C++ library dependencies.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由微软开发的 vcpkg 是一个跨平台的 C++ 包管理器，简化了获取和构建 C++ 开源库的过程。它旨在与 CMake 和其他构建系统无缝协作，提供一种简单一致的方式来管理
    C++ 库依赖项。
- en: Key differences from Conan
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与 Conan 的关键区别
- en: 'While both vcpkg and Conan are aimed at simplifying dependency management in
    C++ projects, there are notable differences in their approach and ecosystem:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 vcpkg 和 Conan 都旨在简化 C++ 项目的依赖项管理，但它们在方法和生态系统方面存在显著差异：
- en: '**Origin and backing**: vcpkg was created and is maintained by Microsoft, which
    ensures tight integration with Visual Studio and the MSBuild system, although
    it remains fully functional and useful across different platforms and development
    environments.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**起源和支持**: vcpkg 由微软创建并维护，确保了与 Visual Studio 和 MSBuild 系统的紧密集成，尽管它在不同的平台和开发环境中仍然完全功能性和有用。'
- en: '**Package sources**: vcpkg focuses on compiling from source, ensuring that
    libraries are built with the same compiler and settings as the consuming project.
    This approach contrasts with Conan, which can manage precompiled binaries, allowing
    for quicker integration but potentially leading to binary incompatibility issues.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包源**：vcpkg专注于从源编译，确保库使用与消费项目相同的编译器和设置进行构建。这种方法与Conan形成对比，Conan可以管理预编译的二进制文件，允许更快地集成，但可能导致二进制不兼容问题。'
- en: '**Integration**: vcpkg integrates natively with CMake and Visual Studio, providing
    manifest files for project-level integration. This can make it particularly attractive
    for projects already using these tools, offering a more seamless integration experience.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成**：vcpkg与CMake和Visual Studio原生集成，提供项目级集成的清单文件。这对于已经使用这些工具的项目尤其有吸引力，可以提供更无缝的集成体验。'
- en: '**Ecosystem and libraries**: Both package managers boast a large collection
    of available libraries, but their ecosystems might differ slightly due to the
    community and backing of each project.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生态系统和库**：这两个包管理器都拥有大量可用的库，但它们的生态系统可能因每个项目的社区和支持而略有不同。'
- en: Operating system support
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作系统支持
- en: 'vcpkg is designed to be cross-platform, with support for the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: vcpkg旨在跨平台，支持以下平台：
- en: Windows
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows
- en: Linux
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux
- en: macOS
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: macOS
- en: This wide range of support makes it a versatile option for developers working
    in diverse development environments.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这广泛的兼容性使其成为在多样化开发环境中工作的开发者的多功能选择。
- en: Example of configuring a project with vcpkg
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用vcpkg配置项目的示例
- en: To illustrate the use of vcpkg in a project, let’s go through a simple example
    of integrating a library, such as the JSON for Modern C++ library (`nlohmann-json`),
    into a C++ project using CMake.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明在项目中使用vcpkg，让我们通过一个简单的示例来展示如何将库（例如，现代C++的JSON库`nlohmann-json`）集成到C++项目中，使用CMake进行操作。
- en: 'Clone the vcpkg repository and run the bootstrap script:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 克隆vcpkg仓库并运行引导脚本：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`vcpkg` will download and compile the library, making it available for projects.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`vcpkg`将下载并编译库，使其可用于项目。'
- en: 'To use vcpkg with a CMake project, you can set the `CMAKE_TOOLCHAIN_FILE` variable
    to the path of the `vcpkg.cmake` toolchain file when configuring your project:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要在CMake项目中使用vcpkg，您可以在配置项目时将`CMAKE_TOOLCHAIN_FILE`变量设置为`vcpkg.cmake`工具链文件的路径：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`vcpkg`, with its emphasis on source-based distribution and integration with
    CMake and Visual Studio, offers a robust solution for C++ developers looking to
    manage library dependencies effectively. Its simplicity, coupled with the backing
    of Microsoft, makes it a compelling choice for projects that prioritize consistency
    with the build environment and seamless integration with existing Microsoft tools.
    While it shares common goals with Conan in simplifying dependency management,
    the choice between vcpkg and Conan may come down to specific project requirements,
    preferred workflow, and the development ecosystem.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`vcpkg`强调基于源的分发，并与CMake和Visual Studio集成，为希望有效管理库依赖的C++开发者提供了一个强大的解决方案。它的简单性，加上微软的支持，使其成为优先考虑与构建环境一致性以及与现有微软工具无缝集成的项目的诱人选择。虽然它与Conan在简化依赖管理方面有共同目标，但vcpkg和Conan之间的选择可能取决于具体的项目需求、首选的工作流程和开发生态系统。'
- en: Utilizing Docker for C++ builds
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用Docker进行C++构建
- en: 'A notable shortfall within C++ is its absence of an inherent mechanism for
    managing dependencies. Consequently, the incorporation of third-party elements
    is achieved through a heterogeneous array of methodologies: the utilization of
    package managers provided by Linux distributions (for instance, `apt-get`), the
    direct installation via `make install`, the inclusion of third-party libraries
    as Git submodules and their subsequent compilation within the project’s source
    tree, or the adoption of package management solutions such as Conan or Vcpkgvcpkg.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，一个显著的不足是其缺乏管理依赖项的内建机制。因此，引入第三方元素是通过一系列异构的方法实现的：利用Linux发行版提供的包管理器（例如，`apt-get`），通过`make
    install`直接安装，将第三方库作为Git子模块包含并随后在项目的源树中编译，或者采用Conan或Vcpkg等包管理解决方案。
- en: 'Regrettably, each of these methods comes with its own set of drawbacks:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，每种方法都有自己的缺点：
- en: The installation of dependencies directly on a development machine tends to
    compromise the cleanliness of the environment, rendering it dissimilar to those
    of CI/CD pipelines or production environments – a discrepancy that becomes more
    pronounced with each update of third-party components.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发机器上直接安装依赖通常会影响环境的清洁性，使其与CI/CD管道或生产环境不同——这种差异随着第三方组件的每次更新而变得更加明显。
- en: It is often a formidable task to ensure uniformity in the versions of compilers,
    debuggers, and other tools utilized by all developers. This lack of standardization
    can culminate in a scenario where a build executes successfully on an individual
    developer’s machine yet fails within the CI/CD environment.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保所有开发者使用的编译器、调试器和其他工具版本的一致性通常是一项艰巨的任务。这种缺乏标准化可能导致一种情况，即构建在个别开发者的机器上成功执行，但在CI/CD环境中失败。
- en: The practice of integrating third-party libraries as Git submodules and compiling
    them within the project’s source directory poses a challenge, particularly when
    dealing with substantial libraries (such as Boost, Protobuf, Thrift, etc.). This
    method can lead to a significant deceleration of the build process, to the extent
    that developers may hesitate to clear the build directory or to alternate between
    branches.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将第三方库作为Git子模块集成并在项目的源目录中编译的做法提出了挑战，尤其是在处理大型库（如Boost、Protobuf、Thrift等）时。这种方法可能导致构建过程显著减速，以至于开发者可能会犹豫清除构建目录或在不同分支之间切换。
- en: Package management solutions such as Conan may not always offer the desired
    version of a specific dependency, and the inclusion of such a version necessitates
    the authoring of additional code in Python, which, in my opinion, is unduly burdensome.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包管理解决方案如Conan可能并不总是提供特定依赖项所需版本，包含该版本需要编写额外的Python代码，在我看来，这是不必要的负担。
- en: A single isolated and reproducible build environment
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个单独的隔离且可重复的构建环境
- en: The optimal resolution for the aforementioned challenges involves the formulation
    of a Docker image, embedded with all requisite dependencies and tools, such as
    compilers and debuggers, to facilitate the project’s compilation within a container
    derived from this image.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 解决上述挑战的最佳方案是制定一个Docker镜像，其中包含所有必需的依赖项和工具，如编译器和调试器，以方便在从该镜像派生的容器中编译项目。
- en: This particular image serves as the cornerstone for a **singular** build environment
    that is uniformly employed by developers on their respective workstations as well
    as on CI/CD servers, effectively eliminating the all-too-common discrepancy of
    “it works on my machine but fails at CI!”.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的镜像作为构建环境的基石，被开发者在其各自的工作站以及CI/CD服务器上统一使用，有效地消除了“在我的机器上运行正常但在CI中失败”的常见差异。
- en: Owing to the encapsulated nature of the build process within the container,
    it remains impervious to any external variables, tools, or configurations peculiar
    to an individual developer’s local setup, thereby rendering the build environment
    **isolated**.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于容器内构建过程的封装特性，它对任何外部变量、工具或配置都保持免疫，这些变量、工具或配置是特定于个别开发者的本地设置，因此使得构建环境**隔离**。
- en: In an ideal scenario, Docker images are meticulously labeled with meaningful
    version identifiers, enabling users to seamlessly transition between different
    environments by retrieving the appropriate image from the registry. Furthermore,
    in the event that an image is no longer available in the registry, it’s worth
    noting that Docker images are constructed from Dockerfiles, which are typically
    maintained within Git repositories. This ensures that, should the need arise,
    there is always the feasibility to reconstruct the image from a previous version
    of the Dockerfile. This attribute of the Dockerized build framework lends it a
    characteristic of being **reproducible**.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想情况下，Docker镜像会仔细标记有意义的版本标识符，使用户能够通过从注册表中检索适当的镜像来无缝地在不同环境之间切换。此外，如果镜像不再在注册表中可用，值得注意的是，Docker镜像是由Dockerfile构建的，这些Dockerfile通常维护在Git仓库中。这确保了，如果需要，始终有可能从之前的Dockerfile版本重新构建镜像。这种Docker化构建框架的特性使其具有**可重复性**。
- en: Creating the build image
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建构建镜像
- en: 'We will embark on developing a straightforward application and compile it within
    a container. The essence of the application is to display its size utilizing `boost::filesystem`.
    The selection of Boost for this demonstration is intentional, aiming to illustrate
    the integration of Docker with a “heavy” third-party library:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The CMake file is quite simple:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: In this example, Boost is linked statically since it is required if the target
    machine does not have the right version of Boost pre-installed; this recommendation
    applies to all dependencies pre-installed in the Docker image.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'The Dockerfile employed for this task is notably uncomplicated:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To ensure that its name is distinctive and does not overlap with existing Dockerfiles,
    while also clearly conveying its purpose, I have named it `DockerfileBuildEnv`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Note that the version is not the “latest” but has a meaningful name (e.g., 0.1).'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the image has been successfully constructed, we are positioned to proceed
    with the project’s build process. The initial step involves initiating a Docker
    container that is based on our crafted image, followed by the execution of the
    Bash shell within this container:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The parameter of particular importance in this context is `--``mount type=bind,source=$`
    **{PWD},target=/src**. This directive instructs Docker to bind mount the current
    directory, which houses the source code, to the `/src` directory within the container.
    This approach circumvents the need to copy source files into the container. Moreover,
    as will be demonstrated subsequently, it enables the storage of output binaries
    directly on the host’s file system, thereby eliminating the need for redundant
    copying. For an understanding of the remaining flags and options, it is advisable
    to consult the official Docker documentation.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the container, we will proceed to compile the project:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Et voilà, the project was built successfully!
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting binary runs successfully, both in the container and on the host,
    because Boost is linked *statically*:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Making the environment usable
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this juncture, it’s reasonable to feel overwhelmed by the multitude of Docker
    commands and wonder how one is expected to memorize them all. It’s important to
    emphasize that developers are not expected to retain every detail of these commands
    for project-building purposes. To streamline this process, I propose encapsulating
    the Docker commands within a tool that is widely familiar to most developers –
    `make`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: To facilitate this, I have established a GitHub repository ([https://github.com/f-squirrel/dockerized_cpp](https://github.com/f-squirrel/dockerized_cpp))
    that contains a versatile Makefile. This Makefile is designed to be easily adaptable
    and can typically be employed for nearly any project that utilizes CMake without
    necessitating modifications. Users have the option to either directly download
    it from this repository or integrate it into their project as a Git submodule,
    ensuring access to the most recent updates. I advocate for the latter approach
    and will provide further details on this.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，我建立了一个 GitHub 仓库 ([https://github.com/f-squirrel/dockerized_cpp](https://github.com/f-squirrel/dockerized_cpp))，其中包含一个通用的
    Makefile。这个 Makefile 设计得易于适应，通常可以用于几乎任何使用 CMake 的项目，而无需进行修改。用户可以选择直接从该仓库下载它，或者将其作为
    Git 子模块集成到他们的项目中，以确保访问最新的更新。我提倡后者方法，并将提供更多详细信息。
- en: 'The Makefile is configured to support fundamental commands. Users can display
    the available command options by executing `make help` in the terminal:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Makefile 已配置为支持基本命令。用户可以通过在终端中执行 `make help` 来显示可用的命令选项：
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To integrate the Makefile into our sample project, we’ll begin by adding it
    as a Git submodule within the `build_tools` directory:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 Makefile 集成到我们的示例项目中，我们首先将其添加为 `build_tools` 目录内的 Git 子模块：
- en: '[PRE22]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The next step is to create another Makefile in the root of the repository and
    include the Makefile that we have just checked out:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在仓库的根目录下创建另一个 Makefile，并包含我们刚刚检出的 Makefile：
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Before the project compilation, it’s prudent to adjust certain default settings
    to better suit the specific needs of your project. This can be efficiently achieved
    by declaring variables in the top-level Makefile prior to the inclusion of `build_tools/Makefile`.
    Such preemptive declarations allow for the customization of various parameters,
    ensuring that the build environment and process are optimally configured for your
    project’s requirements:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目编译之前，明智的做法是调整某些默认设置以更好地满足项目的特定需求。这可以通过在包含 `build_tools/Makefile` 之前在顶级 Makefile
    中声明变量来实现。这种预防性声明允许自定义各种参数，确保构建环境和过程针对项目的需求进行了最佳配置：
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Make is now ready to build the image:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Make 现在已准备好构建镜像：
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The Makefile, by default, assigns the latest tag to the Docker image. For better
    version control and to align with our project’s current stage, it is advisable
    to tag the image with a specific version. In this context, we shall tag the image
    as `0.1`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Makefile 将最新标签分配给 Docker 镜像。为了更好的版本控制和与我们的项目当前阶段保持一致，建议使用特定版本标记镜像。在此上下文中，我们将镜像标记为
    `0.1`。
- en: 'Finally, let us build the project:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们构建项目：
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Upon inspecting the build directory on the host, you’ll observe that the output
    binary has been seamlessly placed there, facilitating easy access and management.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查主机上的构建目录后，你会注意到输出二进制文件已经无缝地放置在那里，便于访问和管理。
- en: 'Both the Makefile and an example of a project that utilizes it with its default
    values can be found on GitHub. This provides a practical demonstration of how
    the Makefile can be integrated into a project, offering a turnkey solution for
    developers seeking to implement a Dockerized build environment in their C++ projects:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Makefile 及其默认值的一个示例项目可以在 GitHub 上找到。这提供了一个实际演示，说明如何将 Makefile 集成到项目中，为寻求在 C++
    项目中实现 Dockerized 构建环境的开发者提供了一个即插即用的解决方案：
- en: 'Makefile repository: [https://github.com/f-squirrel/dockerized_cpp](https://github.com/f-squirrel/dockerized_cpp)'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Makefile 仓库：[https://github.com/f-squirrel/dockerized_cpp](https://github.com/f-squirrel/dockerized_cpp)
- en: 'Example project: [https://github.com/f-squirrel/dockerized_cpp](https://github.com/f-squirrel/dockerized_cpp)'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例项目：[https://github.com/f-squirrel/dockerized_cpp](https://github.com/f-squirrel/dockerized_cpp)
- en: Enhancements for user management within Dockerized builds
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Dockerized 构建中的用户管理增强
- en: The initial iteration of the Docker-based build system executed operations under
    the root user’s privileges. While this setup typically doesn’t pose immediate
    problems—developers have the option to modify file permissions using `chmod`—executing
    Docker containers as the root user is generally discouraged from a security standpoint.
    More critically, this approach can lead to complications if any of the build targets
    modify the source code, such as code formatting or applying `clang-tidy` corrections
    through `make` commands. Such modifications could result in source files being
    owned by the root user, thereby restricting the ability to edit these files directly
    from the host.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Docker的构建系统的初始迭代是在root用户的权限下执行操作的。虽然这种设置通常不会立即引起问题——开发者有修改文件权限使用`chmod`的选项——但从安全角度来看，通常不建议以root用户身份运行Docker容器。更重要的是，如果任何构建目标修改了源代码，例如代码格式化或通过`make`命令应用`clang-tidy`修正，这种方法可能会导致问题。此类修改可能导致源文件归root用户所有，从而限制从宿主直接编辑这些文件的能力。
- en: 'To address this concern, modifications have been made to the Dockerized build’s
    source code, enabling the container to execute as the host user by specifying
    the current user’s ID and group ID. This adjustment is now the standard configuration
    to enhance security and usability. Should there be a need to revert to running
    the container as the root user, the following command can be utilized:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个担忧，对基于Docker的构建系统的源代码进行了修改，使容器能够通过指定当前用户ID和组ID以宿主用户身份执行。这种调整现在是标准配置，以提高安全性和可用性。如果需要将容器回滚到以root用户身份运行，可以使用以下命令：
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: It is important to recognize that the Docker image does not replicate the host
    user’s environment in its entirety—there is no corresponding home directory, nor
    are the user’s name and group replicated within the container. This implies that
    if the build process relies on accessing the home directory, this modified approach
    may not be suitable.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要认识到，Docker镜像并不能完全复制宿主用户的环境——没有对应的家目录，用户名和组也不会在容器内复制。这意味着如果构建过程依赖于访问家目录，这种修改后的方法可能不适用。
- en: Summary
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored various strategies and tools for managing third-party
    dependencies in C++ projects, a critical aspect that significantly impacts the
    efficiency and reliability of the development process. We delved into traditional
    methods, such as utilizing operating system package managers and incorporating
    dependencies directly via Git submodules, each with its unique advantages and
    limitations.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了管理C++项目中第三方依赖项的各种策略和工具，这是影响开发过程效率和可靠性的关键方面。我们深入研究了传统方法，例如利用操作系统包管理器和通过Git子模块直接合并依赖项，每种方法都有其独特的优点和局限性。
- en: We then transitioned to more specialized C++ package managers, highlighting
    Conan and vcpkg. Conan, with its robust ecosystem, extensive library support through
    Conan Center, and flexible configuration options, offers a comprehensive solution
    for managing complex dependencies, integrating seamlessly with multiple build
    systems, and supporting both static and dynamic linking. Its ability to handle
    multiple versions of libraries and the ease with which developers can extend the
    repository with custom packages make it an invaluable tool for modern C++ development.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们转向了更专业的C++包管理器，重点介绍了Conan和vcpkg。Conan凭借其强大的生态系统、通过Conan Center提供的广泛库支持以及灵活的配置选项，为管理复杂依赖项、无缝集成到多个构建系统和支持静态和动态链接提供了一个全面的解决方案。它处理多个版本库的能力以及开发者扩展存储库以自定义包的简便性，使其成为现代C++开发的宝贵工具。
- en: vcpkg, developed by Microsoft, presents a slightly different approach, focusing
    on source-based distribution and ensuring libraries are built with the same compiler
    and settings as the consuming project. Its tight integration with CMake and Visual
    Studio, coupled with the backing of Microsoft, ensures a smooth experience, particularly
    for projects within the Microsoft ecosystem. The emphasis on compiling from source
    addresses potential binary incompatibility issues, making vcpkg a reliable choice
    for managing dependencies.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 由微软开发的vcpkg采用了一种略有不同的方法，侧重于基于源的分发，并确保库使用与消费项目相同的编译器和设置来构建。它与CMake和Visual Studio的紧密集成，加上微软的支持，确保了流畅的使用体验，尤其是在微软生态系统内的项目。强调从源编译可以解决潜在的二进制不兼容性问题，使vcpkg成为管理依赖项的可靠选择。
- en: Lastly, we discussed the adoption of Dockerized builds as an advanced strategy
    for creating consistent, reproducible build environments, particularly beneficial
    in Linux systems. This approach, while more complex, offers significant advantages
    in terms of isolation, scalability, and consistency across development, testing,
    and deployment stages.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了采用 Docker 化构建作为创建一致、可重复的构建环境的高级策略，这在 Linux 系统中尤其有益。这种方法虽然更复杂，但在隔离性、可扩展性和开发、测试和部署阶段的一致性方面提供了显著的优势。
- en: Throughout the chapter, we aimed to equip you with the knowledge and tools necessary
    to navigate the landscape of dependency management in C++ projects. By understanding
    the strengths and limitations of each method and tool, developers can make informed
    decisions tailored to their project’s specific needs, leading to more efficient
    and reliable software development processes.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们的目标是为您提供必要的知识和工具，以便在 C++ 项目的依赖管理领域中导航。通过理解每种方法和工具的优势和局限性，开发者可以做出针对项目特定需求的有信息量的决策，从而实现更高效和可靠的软件开发过程。
