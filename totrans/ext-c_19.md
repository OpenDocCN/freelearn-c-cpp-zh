# 第十九章

# 单主机 IPC 和套接字

在上一章中，我们讨论了两个进程如何能够同时以同步方式操作同一共享资源的技术。在本章中，我们将扩展这些技术，并介绍一种新的方法类别，允许两个进程传输数据。这些技术，包括上一章中介绍的技术和本章将要讨论的技术，统称为**进程间通信（IPC**）技术。

在本章和接下来的章节中，我们将讨论 IPC 技术，尽管我们在上一章讨论了方法，但这些方法涉及两个进程之间的一种*消息传递*或*信号*。传输的消息不会存储在任何共享位置，如文件或共享内存，而是由进程发出和接收。

在本章中，我们将涵盖两个主要主题。首先，我们巩固 IPC 技术，并讨论单主机 IPC 和 POSIX API。其次，我们开始介绍套接字编程及其相关主题。这些主题包括计算机网络、监听器-连接器模型以及两个进程建立连接时存在的序列。

作为本章的一部分，我们将讨论以下主题：

+   各种 IPC 技术。我们介绍了基于推送和基于拉取的 IPC 技术，并将上一章中讨论的技术定义为基于拉取的 IPC 技术。

+   通信协议以及协议通常具有的特性。我们介绍序列化和反序列化的含义以及它们如何有助于实现完全操作的进程间通信（IPC）。

+   文件描述符及其在建立 IPC 通道中的关键作用。

+   本章讨论了 POSIX 信号、POSIX 管道和 POSIX 消息队列的公开 API。对于每种技术，都提供了一个示例来演示基本用法。

+   计算机网络以及两个进程如何通过现有网络进行通信。

+   监听器-连接器模型以及两个进程如何在多个网络上建立传输连接。这是我们未来关于套接字编程讨论的基础。

+   套接字编程是什么以及套接字对象是什么。

+   参与监听器-连接器连接的每个进程存在的序列，以及它们必须从 POSIX 套接字库中使用的 API。

在第一部分，我们将回顾 IPC 技术。

# IPC 技术

IPC 技术通常指的是进程用来通信和传输数据的方法。在上一章中，我们讨论了文件系统和共享内存作为我们在两个进程之间共享数据的起点。在那个阶段，我们没有使用“IPC”这个术语，但实际上这正是它们所代表的！在本章中，我们将添加一些我们已遇到的 IPC 技术，但我们应该记住，它们在许多方面是不同的。在尝试比较差异并尝试对它们进行分类之前，让我们列出一些 IPC 技术：

+   共享内存

+   文件系统（包括磁盘和内存中的）

+   POSIX 信号

+   POSIX 管道

+   POSIX 消息队列

+   Unix 域套接字

+   互联网（或网络）套接字

从编程的角度来看，共享内存和文件系统技术在某些方面是相似的，因此它们可以被归入同一个组，称为*基于拉取*的 IPC 技术。其余的技术突出，并且它们有自己的类别。我们将它们称为*基于推送*的 IPC 技术。本章以及下一章将致力于基于推送的 IPC，并讨论各种技术。

注意，所有的 IPC 技术都负责在两个进程之间传输多条消息。由于我们将在接下来的段落中大量使用术语*消息*，因此首先定义它是有意义的。

每条消息都包含一系列字节，这些字节根据一个定义良好的接口、协议或标准组合在一起。消息的结构应该为处理该消息的两个进程所知晓，并且它通常作为通信协议的一部分来处理。

以下是可以看到基于拉取和基于推送技术之间差异的列表：

+   在基于拉取的技术中，我们有一个共享资源或*介质*，它位于两个进程外部，并在用户空间中可用。文件、共享内存，甚至像**网络文件系统**（**NFS**）服务器这样的网络服务都可以是共享资源。这些介质是进程创建和消费消息的主要占位符。而在基于推送的技术中，没有这样的共享资源或介质，而是有一个*通道*。进程通过这个通道发送和接收消息，而这些消息不会存储在任何中间介质中。

+   在基于拉取的技术中，每个进程必须从介质中*拉取*可用的消息。在基于推送的技术中，传入的消息被*推送*（*交付*）到接收端。

+   在基于拉取的技术中，由于存在共享资源或介质，对介质的并发访问必须同步。这就是为什么我们在上一章中探讨了各种同步技术，用于此类 IPC 技术。请注意，这与基于推送的技术不同，并且不需要同步。

+   在基于拉的技术中，进程可以独立操作。这是因为消息可以存储在共享资源中，稍后可以检索。换句话说，进程可以以*异步*方式操作。相反，在基于推的 IPC 技术中，两个进程应该同时运行，并且由于消息是即时推送的，如果接收进程处于关闭状态，它可能会丢失一些传入的消息。换句话说，进程以*同步*方式操作。

    **注意**：

    在基于推的技术中，我们为每个进程都有一个临时消息缓冲区，用于存储传入的推送消息。这个消息缓冲区位于内核中，只要进程在运行，它就会存在。这个消息缓冲区可能被并发访问，但同步必须由内核本身来保证。

当使用基于推的技术时，消息要么在 IPC 通道中传输，要么在基于拉的技术中使用 IPC 介质存储，其内容应该是接收进程可理解的。这意味着两个进程——发送端和接收端——都必须知道如何创建和解析消息。由于消息由字节组成，这意味着两个进程都必须知道如何将对象（文本或视频）转换为一系列字节，以及如何从接收到的字节中恢复相同的对象。我们将很快看到，进程之间的互操作性是由它们共同采用的*通信协议*所覆盖的。

在下一节中，我们将更深入地讨论通信协议。

# 通信协议

仅有一个通信通道或介质是不够的。愿意通过共享通道进行通信的两个当事人还需要相互理解！一个非常简单的例子是当两个人想用同一种语言（如英语或日语）相互交谈时。在这里，语言可以被认为是两个当事人用来进行通信的协议。

在进程间通信（IPC）的背景下，进程也不例外；它们需要一个共同的语言以便进行通信。技术上，我们使用术语*协议*来指代任何两个当事人之间的这种共同语言。作为本节的一部分，我们将讨论通信协议及其各种特性，如*消息长度*和*消息内容*。在能够讨论这些特性之前，我们需要更深入地描述一个通信协议。请注意，本章的主要重点是 IPC 技术；因此，我们只讨论两个进程之间的通信协议。本章不涵盖除进程之外的其他当事人之间的任何类型的通信。

进程只能传输字节。这实际上意味着在通过任何 IPC 技术传输之前，每条信息都必须被转换为一组字节。这被称为*序列化*或*打包*。一段文本、一段音频、一首音乐或任何其他类型的对象在通过 IPC 通道发送或存储在 IPC 介质之前都必须进行序列化。因此，关于 IPC 通信协议，这意味着进程之间传输的消息是一系列字节，它们按照非常具体和明确的顺序排列。

相反，当进程从一个 IPC 通道接收一系列字节时，它应该能够从传入的字节中重建原始对象。这被称为*反序列化*或*反序列化*。

为了在同一个流程中解释序列化和反序列化，当进程想要通过任何已经建立的 IPC 通道向另一个进程发送对象时，发送进程首先将对象序列化为字节数组。然后它将字节数组传输给另一方。在接收端，进程将传入的字节反序列化，并恢复发送的对象。正如你所看到的，这些操作是彼此的逆操作，并且它们被双方使用，以便使用面向字节的 IPC 通道传输信息。这是你无法避免的，并且每种基于 IPC 的技术（RPC、RMI 等）都严重依赖于各种对象的序列化和反序列化。从现在开始，我们使用术语序列化来指代序列化和反序列化操作。

注意，序列化并不仅限于我们之前讨论的基于推的 IPC 技术。在基于拉的 IPC 技术（如文件系统或共享内存）中，我们仍然需要序列化。这是因为这些技术中的底层介质可以存储一系列字节，如果进程想要将对象存储在共享文件中，例如，它必须在存储之前将其序列化。因此，序列化对所有 IPC 技术都是通用的；无论你使用哪种 IPC 方法，在使用底层通道或介质时，你都必须处理大量的序列化和反序列化操作。

选择一个通信协议隐式地决定了序列化，因为作为协议的一部分，我们非常仔细地定义了字节顺序。这一点至关重要，因为序列化的对象必须在接收端反序列化回相同的对象。因此，序列化和反序列化都必须遵守协议规定的相同规则。两端都使用不兼容的序列化和反序列化工具实际上意味着根本无法通信，仅仅因为接收端无法重建传输的对象。

**注意**：

有时，我们将术语*parsing*用作*反序列化*的同义词，但它们实际上在本质上是有区别的。

为了使讨论更加具体，让我们来谈谈一些真实例子。一个网络服务器和一个网络客户端使用**超文本传输协议**（**HTTP**）进行通信。因此，双方都需要使用兼容的 HTTP 序列化和反序列化器来相互交流。作为另一个例子，让我们来谈谈**域名系统**（**DNS**）协议。DNS 客户端和服务器必须使用兼容的序列化和反序列化器，以便它们能够通信。请注意，与具有文本内容的 HTTP 不同，DNS 是一个二进制协议。我们将在接下来的部分中简要讨论这一点。

由于序列化操作可以在软件项目的各种组件中使用，因此它们通常作为一些库提供，这些库可以添加到任何希望使用它们的组件中。对于像 HTTP、DNS 和 FTP 这样的著名协议，有众所周知的第三方库可以无障碍地使用。但对于专门为项目设计的自定义协议，序列化库必须由团队自己编写。

**注意：**

如 HTTP、FTP 和 DNS 这样的知名协议是标准，它们在称为**请求评论**（**RFC**）的官方公开文档中进行了描述。例如，HTTP/1.1 协议在 RFC-2616 中进行了描述。通过简单的谷歌搜索就可以找到 RFC 页面。

作为关于*序列化库*的进一步说明，它们可以以各种编程语言提供。请注意，特定的序列化本身并不依赖于任何编程语言，因为它只涉及字节的顺序以及它们应该如何被解释。因此，序列化和反序列化算法可以使用任何编程语言来开发。这是一个关键要求。在一个大型软件项目中，我们可以有多个用各种编程语言编写的组件，并且在这些组件之间必须传输信息的情况。因此，我们需要用各种语言编写的相同的序列化算法。例如，我们有用 C、C++、Java、Python 等语言编写的 HTTP 序列化器。 

为了总结本节的主要观点，我们需要在双方之间建立一个定义良好的协议，以便它们能够相互交流。IPC 协议是一种标准，它规定了整体通信必须如何进行，以及关于字节顺序和它们在各个消息中的含义必须遵守哪些细节。我们必须使用一些序列化算法来消费面向字节的 IPC 通道以传输对象。

在下一节中，我们将描述 IPC 协议的特点。

## 协议特点

IPC 协议具有各种特性。简而言之，每个协议都可以为通过 IPC 通道传输的消息指定不同的内容类型。在另一个协议中，消息可以具有固定长度或可变长度。一些协议规定提供的操作必须以同步方式消费，而有些协议允许异步使用。在接下来的章节中，我们将介绍这些区分因素。请注意，现有的协议可以根据这些特性进行分类。

### 内容类型

通过 IPC 通道发送的消息可以是*文本*内容或*二进制*内容，或者两者的组合。二进制内容具有值在 0 到 255 之间所有可能数值的字节。但文本内容只有用于文本的字符。换句话说，只有字母数字字符和一些符号允许在文本内容中使用。

虽然文本内容可以被视为二进制内容的特例，但我们尽量将它们分开，并分别对待。例如，文本消息在发送前进行压缩是很好的候选，而二进制消息则受制于较差的*压缩比*（实际大小除以压缩大小）。了解一些协议完全是文本的，如 JSON，而另一些则是完全二进制的，如 DNS，是有益的。还有一些协议，如 BSON 和 HTTP，允许消息内容是文本和二进制数据的组合。在这些协议中，原始字节可以与文本混合，形成最终的消息。

注意，二进制内容可以作为文本发送。有多种编码方式允许您使用文本字符来表示二进制内容。*Base64* 是最著名的*二进制到文本编码*算法之一，它允许这种转换。这些编码算法在纯文本协议（如 JSON）中广泛用于发送二进制数据。

### 消息长度

根据 IPC 协议产生的消息可以是*固定长度*或*可变长度*。固定长度意味着所有消息都具有相同的长度。相反，可变长度意味着产生的消息可以有不同的长度。接收固定长度或可变长度的消息在反序列化消息内容时对接收方有直接影响。使用总是产生固定长度消息的协议可以减少解析接收消息的负担，因为接收方已经知道它应该从通道中读取的字节数，并且通常（但不总是）具有相同大小的消息具有相同的结构。当从 IPC 通道读取固定长度消息时，如果所有消息都遵循相同的结构，我们就有机会使用 C 结构通过一些已定义的字段来引用这些字节，类似于我们在上一章中为放置在共享内存中的对象所做的那样。

对于产生可变长度消息的协议，找到单个消息的结束并不容易，接收方（我们将在稍后解释）应决定它是否已经读取了一个完整的消息或还需要从通道中读取更多字节。请注意，接收方在读取一个完整的消息之前可能会从通道中读取多个数据块，并且一个数据块可能包含两个相邻消息的数据。我们将在下一章中看到一个例子。

由于大多数协议都是可变长度的，而且通常没有处理固定长度消息的便利，因此讨论各种协议采用的方法来使它们的可变长度消息可区分或可分离是值得的。换句话说，这些协议使用一种机制来标记消息的结束，这样接收者就可以使用这些标记来指示它已经读取了一个完整的消息。接下来，你可以看到一些这些方法：

+   **使用分隔符或分隔符**：分隔符或分隔符是一系列字节（在二进制消息中）或字符（在文本消息中），它指示消息的结束。应根据消息的内容选择分隔符，因为它应该很容易与实际内容区分开来。

+   **长度前缀帧定界**：在这些协议中，每个消息都有一个固定长度的前缀（通常是 4 个字节或更多），它携带接收者应该读取的字节数，以便获得一个完整的消息。各种协议，如所有**标签-值-长度**（**TLV**）协议，以**抽象语法表示**（**ASN**）为例，都使用这种技术。

+   **使用有限状态机**：这些协议遵循一种*正规文法*，可以用*有限状态机*来建模。接收方应了解协议的文法，并应使用基于有限状态机的适当反序列化器来从 IPC 通道中读取一个完整的消息。

### 顺序性

在大多数协议中，两个进程之间发生的是一种遵循*请求-响应*方案的*对话*。一方发送请求，另一方回复。这种方案通常用于客户端-服务器场景。监听器进程，通常是服务器进程，等待消息，并在收到消息后相应地回复。

如果协议是同步或顺序的，发送者（客户端）将等待监听器（服务器）完成请求并发送回响应。换句话说，发送者将保持在*阻塞*状态，直到监听器回复。在异步协议中，发送者进程不会被阻塞，它可以在监听器处理请求的同时继续执行其他任务。也就是说，发送者在准备回复时不会被阻塞。

在异步协议中，应该有一个*拉取*或*推送*机制，这允许发送者检查回复。在拉取场景中，发送者将定期询问监听者的结果。在推送场景中，监听者将通过相同的或不同的通信通道将回复推送给发送者。

协议的顺序性不仅限于请求-响应场景。消息应用通常使用这种技术以在服务器端和客户端都实现最大的响应性。

# 单主机通信

在本节中，我们将讨论单主机进程间通信（IPC）。多主机 IPC 将是下一章讨论的主题。当进程位于同一台机器上时，可以使用以下四种主要技术进行通信：

+   POSIX 信号

+   POSIX 管道

+   POSIX 消息队列

+   Unix 域套接字

与其他前述技术不同，POSIX 信号不会在进程之间创建通信通道，但可以用作通知进程有关事件的方式。在某些情况下，这些信号可以被进程用来通知彼此关于系统中特定事件的详细信息。

在跳转到第一种 IPC 技术 POSIX 信号之前，让我们先讨论文件描述符。除了 POSIX 信号之外，无论你使用哪种 IPC 技术，你都将处理某种类型的文件描述符。因此，我们现在将专门为它们设立一个单独的部分，并进一步讨论它们。

## 文件描述符

两个通信进程可以运行在同一台机器上，也可以运行在通过计算机网络连接的两个不同的机器上。在本节以及本章的大部分内容中，我们的重点是第一种情况，即进程位于同一台机器上。这就是文件描述符变得极其重要的地方。请注意，在多主机 IPC 中，我们仍然会处理文件描述符，但它们在那里被称为*套接字*。我们将在下一章中详细讨论它们。

文件描述符是对系统内对象的抽象句柄，可以用来读写数据。正如你所见，尽管名称如此，文件描述符可以引用一系列处理读写字节流的机制。

正规文件当然是可以由文件描述符引用的对象之一。这些文件位于文件系统上，无论是在硬盘上还是在内存中。

可以通过文件描述符引用和访问的其他事物包括设备。正如我们在第十章“Unix - 历史 和 架构”中看到的，每个设备都可以通过设备文件来访问，该文件通常位于`/dev`目录中。

关于基于推送的 IPC 技术，文件描述符可以表示一个 IPC 通道。在这种情况下，文件描述符可以用来从表示的通道中读取和写入数据。这就是为什么设置 IPC 通道的第一步是定义一定数量的文件描述符。

现在你已经了解了文件描述符及其代表的含义，我们可以继续讨论在单主机多进程系统中可以使用的第一个 IPC 技术；然而，POSIX 信号不使用文件描述符。你将在未来关于 POSIX 管道和 POSIX 消息队列的章节中了解更多关于文件描述符的内容。让我们从 POSIX 信号开始。

## POSIX 信号

在 POSIX 系统中，进程和线程可以发送和接收许多预定义的信号。信号可以由进程、线程或内核本身发送。信号实际上是为了通知进程或线程有关事件或错误。例如，当系统即将重启时，系统向所有进程发送 `SIGTERM` 信号，让它们知道正在重启，它们必须立即退出。一旦进程收到这个信号，它应该做出相应的反应。在某些情况下，可能不需要做任何事情，但在某些情况下，进程的当前状态应该被保存。

以下表格显示了 Linux 系统中可用的信号。该表格是从 Linux 信号 [手册页](http://www.man7.org/linux/man-pages/man7/signal.7.html) 提取的：

```cpp
 Signal      Standard   Action   Comment ───────────────────────────────────────────────────────────
SIGABRT      P1990      Core    Abort signal from abort(3)SIGALRM      P1990      Term    Timer signal from alarm(2)SIGBUS       P2001      Core    Bus error (bad memory access)SIGCHLD      P1990      Ign     Child stopped or terminated SIGCLD         -        Ign     A synonym for SIGCHLD SIGCONT      P1990      Cont    Continue if stopped SIGEMT         -        Term    Emulator trap SIGFPE       P1990      Core    Floating-point exception SIGHUP       P1990      Term    Hangup detected on controlling terminal                                 or death of controlling process SIGILL       P1990      Core    Illegal Instruction SIGINFO        -                A synonym for SIGPWR SIGINT       P1990      Term    Interrupt from keyboard SIGIO          -        Term    I/O now possible (4.2BSD)SIGIOT         -        Core    IOT trap. A synonym for SIGABRT SIGKILL      P1990      Term    Kill signal SIGLOST        -        Term    File lock lost (unused)SIGPIPE      P1990      Term    Broken pipe: write to pipe with no                                 readers; see pipe(7)SIGPOLL      P2001      Term    Pollable event (Sys V).                                Synonym for SIGIO SIGPROF      P2001      Term    Profiling timer expired SIGPWR         -        Term    Power failure (System V)SIGQUIT      P1990      Core    Quit from keyboard SIGSEGV      P1990      Core    Invalid memory reference SIGSTKFLT      -        Term    Stack fault on coprocessor (unused)SIGSTOP      P1990      Stop    Stop process SIGTSTP      P1990      Stop    Stop typed at terminal SIGSYS       P2001      Core    Bad system call (SVr4);                                see also seccomp(2)SIGTERM      P1990      Term    Termination signal SIGTRAP      P2001      Core    Trace/breakpoint trap SIGTTIN      P1990      Stop    Terminal input for background process SIGTTOU      P1990      Stop    Terminal output for background process SIGUNUSED      -        Core    Synonymous with SIGSYS SIGURG       P2001      Ign     Urgent condition on socket (4.2BSD)SIGUSR1      P1990      Term    User-defined signal 1 SIGUSR2      P1990      Term    User-defined signal 2 SIGVTALRM    P2001      Term    Virtual alarm clock (4.2BSD)SIGXCPU      P2001      Core    CPU time limit exceeded (4.2BSD);                                see setrlimit(2)SIGXFSZ      P2001      Core    File size limit exceeded (4.2BSD);                                see setrlimit(2)SIGWINCH       -        Ign     Window resize signal (4.3BSD, Sun)
```

表 19-1：Linux 系统中所有可用的信号列表

如前表所示，并非所有信号都是 POSIX 信号，Linux 有自己的信号。虽然大多数信号对应于已知事件，但有两个 POSIX 信号可以被用户定义。这通常用于当你想在程序运行时调用某些功能时。*示例 19.1* 展示了如何在 C 程序中使用信号以及如何处理它们。接下来，你可以找到 *示例 19.1* 的代码：

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
void handle_user_signals(int signal) {
  switch (signal) {
    case SIGUSR1:
      printf("SIGUSR1 received!\n");
      break;
    case SIGUSR2:
      printf("SIGUSR2 received!\n");
      break;
    default:
      printf("Unsupported signal is received!\n");
  }
}
void handle_sigint(int signal) {
  printf("Interrupt signal is received!\n");
}
void handle_sigkill(int signal) {
  printf("Kill signal is received! Bye.\n");
  exit(0);
}
int main(int argc, char** argv) {
  signal(SIGUSR1, handle_user_signals);
  signal(SIGUSR2, handle_user_signals);
  signal(SIGINT, handle_sigint);
  signal(SIGKILL, handle_sigkill);
  while (1);
  return 0;
}
```

代码框 19-1 [ExtremeC_examples_chapter19_1.c]: 处理 POSIX 信号

在前面的示例中，我们使用了 `signal` 函数将各种信号处理程序分配给一些特定的信号。正如你所见，我们有一个用于用户定义信号的信号处理程序，一个用于 `SIGINT` 信号的信号处理程序，以及一个用于 `SIGKILL` 信号的信号处理程序。

程序只是一个永无止境的循环，我们只想处理一些信号。以下命令显示了如何在后台编译和运行示例：

```cpp
$ gcc ExtremeC_examples_chapter19_1.c -o ex19_1.out
$ ./ex19_1.out &
[1] 4598
$
```

Shell 框 19-1：编译和运行示例 19.1

现在我们知道了程序的 PID，我们可以向它发送一些信号。PID 是 4598，程序正在后台运行。请注意，对于你来说，PID 可能是不同的。你可以使用 `kill` 命令向进程发送信号。以下命令用于检查前面的示例：

```cpp
$ kill -SIGUSR2 4598
SIGUSR2 received!
$ kill -SIGUSR1 4598
SIGUSR2 received!
$ kill -SIGINT 4598
Interrupt signal is received!
$ kill -SIGKILL 4598
$
[1]+  Stopped         ./ex19_1.out
$
```

Shell 框 19-2：向后台进程发送不同的信号

如你所见，程序处理了除 `SIGKILL` 信号之外的所有信号。`SIGKILL` 不能被任何进程处理，通常，创建进程的父进程可以收到其子进程被杀的通知。

注意，可以通过按下 `Ctrl` + `C` 发送 `SIGINT` 信号，或中断信号，到前台程序。因此，每次你按下这个键组合时，实际上是在向正在运行的程序发送中断信号。默认的处理程序只是停止程序，但正如你在前面的示例中看到的，我们可以处理 `SIGINT` 信号并忽略它。

除了可以使用 shell 命令向进程发送信号的能力之外，如果知道目标进程的 PID，进程还可以向另一个进程发送信号。你可以使用 `kill` 函数（在 `signal.h` 中声明），它与它的命令行版本完全一样。它接受两个参数：第一个是目标 PID，第二个是信号号。进程或线程也可以使用 `kill` 或 `raise` 函数向自身发送信号。请注意，`raise` 函数向当前线程发送信号。这些函数在你想通知程序的其他部分有关事件的情况下非常有用。

关于前面示例的最后一点是，正如你在*Shell Box 19-2*中看到的，主线程忙于无限循环并不重要，信号是异步传递的。因此，你可以确信你总是能接收到传入的信号。

现在是时候讨论 POSIX 管道作为另一种单主机 IPC 技术的时候了，在某些情况下这可能很有用。

## POSIX 管道

在 Unix 中，POSIX 管道是单向通道，可以在需要交换消息的两个进程之间使用。创建 POSIX 管道时，你会得到两个文件描述符。一个文件描述符用于向管道写入，另一个用于从管道读取。以下示例展示了 POSIX 管道的基本用法：

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
int main(int argc, char** argv) {
  int fds[2];
  pipe(fds);
  int childpid = fork();
  if (childpid == -1) {
    fprintf(stderr, "fork error!\n");
    exit(1);
  }
  if (childpid == 0) {
    // Child closes the read file descriptor
    close(fds[0]);
    char str[] = "Hello Daddy!";
    // Child writes to the write file descriptor
    fprintf(stdout, "CHILD: Waiting for 2 seconds ...\n");
    sleep(2);
    fprintf(stdout, "CHILD: Writing to daddy ...\n");
    write(fds[1], str, strlen(str) + 1);
  } else {
    // Parent closes the write file descriptor
    close(fds[1]);
    char buff[32];
    // Parent reads from the read file descriptor
    fprintf(stdout, "PARENT: Reading from child ...\n");
    int num_of_read_bytes = read(fds[0], buff, 32);
    fprintf(stdout, "PARENT: Received from child: %s\n", buff);
  }
  return 0;
}
```

代码框 19-2 [ExtremeC_examples_chapter19_2.c]: 使用 POSIX 管道的示例 19.2

如你所见，在 `main` 函数的第二行，我们使用了 `pipe` 函数。正如我们之前所说的，它接受一个包含两个文件描述符的数组，并打开两个文件描述符，一个用于从管道读取，另一个用于向管道写入。第一个文件描述符位于索引 0，应用于读取；第二个文件描述符位于索引 1，应用于向管道写入。

为了拥有两个进程，我们使用了 `fork` API。正如我们在*第十七章*，*进程执行*中解释的，`fork` API 会克隆父进程并创建一个新的子进程。因此，在调用 `fork` 函数后，打开的文件描述符对子进程也是可用的。

当子进程被创建时，父进程进入`else`块，而子进程进入`if`块。首先，每个进程都应该关闭它不打算使用的文件描述符。在这个例子中，父进程想要从管道读取，而子进程想要向管道写入。这就是为什么父进程关闭第二个文件描述符（写入文件描述符），而子进程关闭第一个文件描述符（读取文件描述符）。请注意，管道是单向的，反向通信是不可能的。

下面的 shell box 展示了前面示例的输出：

```cpp
$ gcc ExtremeC_examples_chapter19_2.c -o ex19_2.out
$ ./ex19_2.out
PARENT: Reading from child ...
CHILD: Waiting for 2 seconds ...
CHILD: Writing to daddy ...
PARENT: Received from child: Hello Daddy!
$
```

Shell Box 19-3：运行示例 19.2 的输出

如你在*Code Box 19-2*中看到的，对于读写操作，我们使用`read`和`write`函数。正如我们之前提到的，在基于推的 IPC 中，文件描述符指向一个字节通道，当你有一个指向通道的文件描述符时，你可以使用文件描述符的相关函数。`read`和`write`函数接受一个文件描述符，无论背后的 IPC 通道是什么类型，它们都以相同的方式操作底层的通道。

在前面的例子中，我们使用了 fork API 来创建一个新的进程。如果出现这样的情况，即我们分别创建了两个不同的进程，问题是如何通过共享管道进行通信？如果一个进程需要在系统中访问管道对象，它应该有相应的文件描述符。有两种选择可用：

+   其中一个进程应该设置管道并将相应的文件描述符传输给另一个进程。

+   进程应该使用命名管道。

在第一种场景中，进程必须使用 Unix 域套接字通道来交换文件描述符。问题是，如果两个进程之间存在这样的通道，它们可以使用它进行进一步的通信，并且不需要设置另一个通道（POSIX 管道），该通道的 API 比 Unix 域套接字不友好。

第二种场景似乎更有前景。其中一个进程可以使用`mkfifo`函数，通过提供路径来创建一个队列文件。然后，第二个进程可以使用已创建文件的路径并打开它以进行进一步的通信。请注意，通道仍然是单向的，并且根据场景的不同，其中一个进程应该以只读模式打开文件，而另一个进程应该以只写模式打开文件。

关于前面的示例，还有一点需要讨论。正如你所看到的，子进程在写入管道之前会等待 2 秒。在此期间，父进程在`read`函数上被阻塞。因此，在没有消息写入管道的情况下，从管道读取的进程会变得阻塞。

作为本节的最后一点，我们知道 POSIX 管道是基于推送的。正如我们之前所解释的，基于推送的 IPC 技术都有一个相应的临时内核缓冲区来存储传入的推送消息。POSIX 管道也不例外，内核会保留写入的消息，直到它们被读取。请注意，如果所有者进程退出，管道对象及其对应的内核缓冲区将被销毁。

在下一节中，我们将讨论 POSIX 消息队列。

## POSIX 消息队列

内核托管的消息队列是 POSIX 标准的一部分。它们在许多方面与 POSIX 管道有显著的不同。在这里，我们考察这些基本的不同点：

+   管道内部是字节。相反，消息队列持有消息。管道对写入的字节中存在的任何结构都不知情，而消息队列则保留实际的消息，每次调用 `write` 函数都会在队列中添加一条新消息。消息队列保留了写入消息之间的边界。为了更详细地说明这一点，假设我们有三个消息：第一个消息有 10 个字节，第二个消息有 20 个字节，第三个消息有 30 个字节。我们将这些消息同时写入 POSIX 管道和 POSIX 消息队列。管道只知道它内部有 60 个字节，并允许程序读取 15 个字节。但消息队列只知道它有 3 条消息，并且不允许程序读取 15 个字节，因为我们没有 15 个字节的任何消息。

+   管道有一个最大大小，单位是字节数。而消息队列则有一个最大消息数。在消息队列中，每个消息都有一个以字节为单位的最大大小。

+   每个消息队列，就像一个命名共享内存或命名信号量，都会打开一个文件。虽然这些文件不是常规文件，但未来的进程可以使用它们来访问相同的消息队列实例。

+   消息队列可以被赋予优先级，而管道对字节优先级并不关心。

它们还具有以下共同属性：

+   它们都是单向的。为了实现双向通信，你需要创建两个管道或队列的实例。

+   它们都有有限的容量；你不能写入任何你想要的字节数或消息数。

+   在大多数 POSIX 系统中，它们都使用文件描述符来表示；因此，可以使用 `read` 和 `write` 等 I/O 函数。

+   这两种技术都是**无连接的**。换句话说，如果两个不同的进程写入两条不同的消息，其中一条消息有可能被另一个进程读取。换句话说，没有为消息定义所有权，任何进程都可以读取它们。这可能会成为一个问题，尤其是在有多个进程同时操作同一个管道或消息队列的情况下。

**注意**：

本章中解释的 POSIX 消息队列不应与在 **消息队列中间件** (**MQM**) 架构中使用的消息队列代理混淆。

互联网上有各种资源解释 POSIX 消息队列。以下链接专门解释了 QNX 操作系统上的 POSIX 消息队列，但大部分内容仍然适用于其他 POSIX 系统：https://users.pja.edu.pl/~jms/qnx/help/watcom/clibref/mq_overview.html。

现在是时候举一个例子了。*示例 16.3* 与我们之前在 *示例 16.2* 中的场景相同，但它使用 POSIX 消息队列而不是 POSIX 管道。与 POSIX 管道和 POSIX 消息队列相比，与 POSIX 消息队列相关的所有函数都声明在 `mqueue.h` 头文件中。我们将在稍后解释其中的一些。

注意，以下代码在 macOS 上无法编译，因为 OS/X 不支持 POSIX 消息队列：

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <mqueue.h>
int main(int argc, char** argv) {
  // The message queue handler
  mqd_t mq;
  struct mq_attr attr;
  attr.mq_flags = 0;
  attr.mq_maxmsg = 10;
  attr.mq_msgsize = 32;
  attr.mq_curmsgs = 0;
  int childpid = fork();
  if (childpid == -1) {
    fprintf(stderr, "fork error!\n");
    exit(1);
  }
  if (childpid == 0) {
    // Child waits while the parent is creating the queue
    sleep(1);
    mqd_t mq = mq_open("/mq0", O_WRONLY);
    char str[] = "Hello Daddy!";
    // Child writes to the write file descriptor
    fprintf(stdout, "CHILD: Waiting for 2 seconds ...\n");
    sleep(2);
    fprintf(stdout, "CHILD: Writing to daddy ...\n");
    mq_send(mq, str, strlen(str) + 1, 0);
    mq_close(mq);
  } else {
    mqd_t mq = mq_open("/mq0", O_RDONLY | O_CREAT, 0644, &attr);
    char buff[32];
    fprintf(stdout, "PARENT: Reading from child ...\n");
    int num_of_read_bytes = mq_receive(mq, buff, 32, NULL);
    fprintf(stdout, "PARENT: Received from child: %s\n", buff);
    mq_close(mq);
    mq_unlink("/mq0");
  }
  return 0;
}
```

代码框 19-3 [ExtremeC_examples_chapter19_3.c]: 使用 POSIX 消息队列的示例 19.3

为了编译前面的代码，请运行以下命令。请注意，前面的代码应在 Linux 上与 `rt` 库链接：

```cpp
$ gcc ExtremeC_examples_chapter19_3.c -lrt -o ex19_3.out
$
```

Shell Box 19-4: 在 Linux 上构建示例 19.3

以下 Shell 框演示了 *示例 19.3* 的输出。正如您所看到的，输出与我们之前在 *示例 19.2* 中得到的结果完全相同，但它使用 POSIX 消息队列来执行我们在 *示例 19.2* 中编写的相同逻辑：

```cpp
$ ./ex19_3.out
PARENT: Reading from child ...
CHILD: Waiting for 2 seconds ...
CHILD: Writing to daddy ...
PARENT: Received from child: Hello Daddy!
$
```

Shell Box 19-5: 在 Linux 上运行示例 19.3

注意，POSIX 管道和消息队列在内核中都有一个有限的缓冲区。因此，在没有消费者读取其内容的情况下向管道和消息队列写入可能会导致所有写入操作被阻塞。换句话说，任何 `write` 函数调用都会保持阻塞，直到消费者从消息队列中读取消息或从管道中读取一些字节。

在以下部分，我们将简要解释 Unix 域套接字。在单主机设置中连接两个本地进程时，它们通常是首选。

## Unix 域套接字

另一种可以在单主机部署中由多个进程使用的通信技术是使用 Unix 域套接字。它们是一种仅在相同机器上操作的特定类型的套接字。因此，它们与允许两个不同机器上的两个进程通过现有网络相互通信的网络套接字不同。Unix 域套接字具有各种特性，使它们与 POSIX 管道和 POSIX 消息队列相比显得重要且复杂。最重要的特性是 Unix 域套接字是双向的。因此，单个套接字对象就足够从底层通道读取和写入。换句话说，Unix 域套接字操作的通道是全双工的。此外，Unix 域套接字可以是 *会话感知* 和 *消息感知* 的。这使得它们更加灵活。我们将在以下章节中讨论会话感知性和消息感知性。

由于没有了解套接字编程的基础，Unix 域套接字无法讨论，所以我们不会在本章中走得更远。相反，在接下来的几节中，我们将介绍套接字编程及其相关概念。关于 Unix 域套接字的全面讨论将在下一章中给出。让我们从套接字编程开始。

# 套接字编程简介

作为本章的一部分，我们决定在下一章通过实际的 C 代码示例之前讨论套接字编程。这是因为有一些基本概念在你跳到代码之前需要了解。

套接字编程可以在单主机和多主机部署上执行。正如你可能已经猜到的，单主机系统中的套接字编程是通过 Unix 域套接字完成的。在多主机设置中，套接字编程是关于创建和使用网络套接字。Unix 套接字和网络套接字在某种程度上使用相同的 API 并共享相同的概念，因此在下一章中一起介绍它们是有意义的。

在使用网络套接字之前的一个关键概念是计算机网络是如何工作的。在接下来的部分，我们将讨论这个问题，并介绍计算机网络。在能够编写你的第一个套接字编程示例之前，你应该了解许多术语和概念。

## 计算机网络

我们在本节中解释网络概念的方法与你在其他关于这个主题的文本中可能找到的方法不同。我们的目标是创建对计算机网络中事物如何工作的基本理解，特别是在两个进程之间。我们希望从程序员的视角来看待这个概念。我们讨论中的主要角色是进程，而不是计算机。因此，你可能会觉得章节的顺序一开始有点奇怪，但它将帮助你理解在计算机网络上 IPC 是如何工作的。

注意，本节不应被视为计算机网络的一个完整描述，当然，它不可能在几页纸和仅一个章节中完成。

### 物理层

首先，让我们忘记进程，只考虑计算机，或者简单地说是机器。在继续前进之前，请注意我们使用各种术语来指代网络中的计算机。我们可以称之为计算机、机器、主机、节点，甚至系统。当然，上下文有助于你找出给定术语背后的真正含义。

拥有多主机软件的第一步是连接在一起的一组计算机，或者更精确地说，是一个计算机网络。现在，让我们专注于我们想要连接的两台计算机。为了将这两台物理机器连接起来，我们当然需要某种物理介质，比如一根电线或无线设置。

当然，如果没有这样的物理介质（它不需要是可见的，例如在无线网络中），连接将无法实现。这些物理连接类似于城市之间的道路。我们将坚持这个类比，因为它可以非常接近地解释计算机网络内部发生的事情。

所需的所有硬件设备，用于在物理上连接两台机器，都被认为是*物理层*的一部分。这是我们探索的第一个也是最基本的一层。没有这一层，就无法在两台计算机之间传输数据并假定它们已连接。这一层之上的一切都不是物理的，你所能找到的只是一系列关于数据如何传输的各种标准。

让我们谈谈下一层，即链路层。

### 链路层

虽然仅有道路不足以让交通在其上移动，但计算机之间的物理连接也是如此。为了使用道路，我们需要有关车辆、标志、材料、边界、速度、车道、方向等的法律和法规，没有它们，沿道路行驶将会混乱且有问题。在两个计算机之间的直接物理连接中也需要类似的规则。

虽然连接多个计算机所需的物理组件和设备都属于物理层，但管理物理层上数据传输方式的强制规定和协议都属于一个称为*链路层*的上层。

作为链路协议实施的规则的一部分，消息应该被分成称为*帧*的部分。这类似于道路系统中定义的车辆在特定道路上行驶的最大长度的规定。你不能在道路上驾驶 1 公里长的拖车（假设在物理上可能），你必须将其分解成更小的部分，或者更小的车辆。同样，长数据块应该被分解成多个帧，并且每个帧都必须在网络中自由传输，独立于其他帧。

值得注意的是，网络可以存在于任何两个计算设备之间。它们不一定是计算机。在工业界有许多设备和机器可以相互连接以形成一个网络。工业网络有自己的物理布线、连接器、终端等标准，它们有自己的链路协议和标准。

许多标准描述了这样的链路连接，例如，如何将台式计算机连接到工业机器。设计用于通过有线方式连接多个计算机的最突出的链路协议之一是*以太网*。以太网描述了管理计算机网络上数据传输的所有规则和规定。我们还有另一个广泛使用的链路协议，称为 IEEE 802.11，它管理无线网络。

由通过特定链路协议通过物理连接连接的计算机（或任何其他同质计算机器或设备组）组成的网络称为**局域网**（**LAN**）。请注意，任何希望加入局域网的设备都必须使用一个称为*网络适配器*或**网络接口控制器**（**NIC**）的物理组件。例如，想要加入以太网网络的计算机必须有一个*以太网 NIC*。

一台计算机可以连接多个 NIC。每个 NIC 可以连接到特定的局域网，因此具有三个 NIC 的计算机能够同时连接到三个不同的局域网。

也可能它使用其所有三个 NIC 连接到同一个局域网。配置 NIC 的方式以及将计算机连接到各种局域网的方式应该在事先设计，并且应该有一个精确的计划。

每个 NIC 都有一个由治理链路协议定义的特定且唯一的地址。这个地址将用于局域网内节点之间的数据传输。以太网和 IEEE 802.11 协议为每个兼容的 NIC 定义了一个**媒体访问控制**（**MAC**）地址。因此，任何以太网 NIC 或 IEEE 802.11 Wi-Fi 适配器都应该有一个唯一的 MAC 地址，以便加入一个兼容的局域网。在局域网内，分配的 MAC 地址应该是唯一的。请注意，理想情况下，任何 MAC 地址应该是全球唯一且不可更改的。然而，情况并非如此，你甚至可以设置 NIC 的 MAC 地址。

总结到目前为止我们所解释的内容，我们有一个两层堆栈，下面是物理层，上面是链路层。这足以连接单个局域网上的多个计算机。但这并没有结束。我们需要在这些两层之上再添加一层，以便能够连接来自不同局域网的计算机，无论是否有中间局域网。

### 网络层

到目前为止，我们已经看到 MAC 地址在以太网局域网中用于连接多个节点。但如果来自两个不同局域网的计算机需要相互连接会发生什么？请注意，这些局域网网络不一定兼容。

例如，其中一个局域网可能是有线以太网网络，而另一个局域网可能是主要使用光纤作为物理层的**光纤分布式数据接口**（**FDDI**）网络。另一个例子是连接到普通以太网局域网的**工业以太网**（**IE**）局域网上的工业机器，需要连接到操作员计算机。这些例子以及更多例子表明，我们需要在上述协议之上添加另一层，以便连接来自不同局域网的各个节点。请注意，我们甚至需要这个第三层来连接兼容的局域网。如果我们打算通过多个中间局域网将数据从一个局域网传输到另一个局域网（兼容或异构），这将更加关键。我们将在接下来的段落中进一步解释这一点。

就像链路层中的帧一样，我们在网络层中有**数据包**。长消息被分成更小的部分，称为数据包。虽然帧和数据包在不同的层中指的是两个不同的概念，但为了简单起见，我们考虑它们是相同的，并在本章的其余部分使用术语**数据包**。

作为关键的区别，你应该知道帧封装数据包，换句话说，一个帧包含一个数据包。我们不会深入探讨帧和数据包，但你可以在互联网上找到许多描述这些概念各个方面的资源。

网络协议用于填补各种局域网之间的差距，以便将它们相互连接。虽然每个局域网都可以有自己的特定物理层、自己的特定链路层标准和协议，但所有这些局域网应遵循相同的网络协议。否则，异构（不兼容）的局域网无法相互连接。目前最著名的网络协议是**互联网协议**（**IP**）。它在通常由较小的以太网或 Wi-Fi 局域网组成的大型计算机网络中得到广泛使用。IP 根据其地址长度分为两个版本：IPv4 和 IPv6。

但如何将来自两个不同局域网的计算机连接起来呢？答案在于**路由**机制。为了接收来自外部局域网的数据，应该有一个**路由器**节点。假设我们要连接两个不同的局域网：LAN1 和 LAN2。路由器就是一个节点，它通过拥有两个网络接口卡（NICs）同时存在于两个网络中。一个 NIC 位于 LAN1，另一个位于 LAN2。然后，一个特殊的路由算法决定哪些数据包需要传输以及如何在网络之间传输。

通过路由机制，多个网络可以通过路由器节点进行双向数据流动。为了实现这一点，每个局域网内都应该有一个路由器节点。因此，当你想要向位于不同地理区域的计算机发送数据时，你的数据可能需要通过数十个路由器才能到达目标。我不会深入探讨路由概念，但在网络上可以找到大量关于这一机制的优秀信息。

**注意**：

有一个名为**traceroute**的实用程序，它允许你查看你的计算机和目标计算机之间的路由器。

到目前为止，来自两个不同局域网的两个主机可以相互连接，无论是否有中间局域网。任何进一步的具体连接尝试都应该在这个层次之上进行。因此，两个不同节点上的两个程序之间的任何通信都必须在三个协议层（物理层、链路层和最终的网络层）之上进行。但当我们说两台计算机连接在一起时，这究竟意味着什么呢？

说两个节点是连接的，至少对于程序员来说有点模糊。为了更精确，这些节点的操作系统是相互连接的，它们是传输数据的执行者。加入网络并与同一局域网或不同局域网中的其他节点通信的能力，在大多数当前操作系统中是固有的。基于 Unix 的操作系统能够成为我们本书的主要焦点，它们都是支持网络的操作系统能够安装在参与网络的节点上。

Linux、Microsoft Windows 和几乎任何现代操作系统都支持网络。实际上，一个操作系统如果不能在网络中运行，可能无法生存。请注意，是内核，或者更准确地说，内核中的一个单元，管理网络连接，因此更确切地说，实际的网络功能是由内核提供的。

由于网络功能由内核提供，用户空间中的任何进程都可以从中受益，并且它可以连接到网络中不同节点上的另一个进程。作为一个程序员，你不需要担心内核操作（物理层、链路层和网络层）的层级，你可以专注于它们之上的层级，那些与你的代码相关的层级。

IP 网络中的每个节点都有一个 IP 地址。正如我们之前所说的，我们有两种 IP 地址版本：**IP 版本 4**（**IPv4**）和**IP 版本 6**（**IPv6**）。IPv4 地址由四个段组成，每个段可以存储介于 0 到 255 之间的数值。因此，IPv4 地址从`0.0.0.0`开始，到`255.255.255.255`结束。正如你所见，我们只需要 4 个字节（或 32 位）来存储一个 IPv4 地址。对于 IPv6 地址，这增加到 16 个字节（或 128 位）。此外，我们还有私有和公共 IP 地址，但详细内容远远超出了本章的主题。我们只需要知道，IP 网络中的每个节点都有一个唯一的 IP 地址。

在上一节的基础上，在单个局域网中，每个节点都有一个链路层地址和一个 IP 地址，但我们将使用 IP 地址来连接该节点，而不是链路层地址。例如，在一个以太网局域网中，每个节点有两个地址；一个是 MAC 地址，另一个是 IP 地址。MAC 地址由链路层协议用于在局域网内传输数据，而 IP 地址由驻留在各个节点上的程序用于在同一局域网内或多个局域网之间建立网络连接。

网络层的主要功能是连接两个或更多局域网。这最终会导致一个庞大的网络网状结构，这些网络相互连接，形成一个包含许多独立局域网的大型网络。实际上，这样的网络是存在的，我们称之为互联网。

像任何其他网络一样，每个可访问互联网的节点都必须有一个 IP 地址。但可访问互联网的节点和不可访问的节点的主要区别在于，互联网节点必须有一个公网 IP 地址，而通常不可通过互联网访问的节点有一个私有地址。

以一个例子来说明，你的家庭网络可能连接到互联网，但互联网上的外部节点无法连接到你的笔记本电脑，因为你的笔记本电脑有一个私有 IP 地址而没有公网 IP 地址。虽然你的笔记本电脑仍然可以在家庭网络内部访问，但它不在互联网上。因此，如果你的软件要在互联网上可用，它应该在具有公网 IP 地址的机器上运行。

关于 IP 网络的信息量巨大，我们不会涵盖所有内容，但作为一个程序员，了解私有地址和公网地址之间的区别是非常重要的。

在网络中，确保节点之间的连接不是程序员的职责；能够检测网络缺陷被认为是你的技能的一部分。这一点非常重要，因为它可以让你知道一个错误或不正常行为是否根植于你的代码，或者它是一个基础设施（或网络）问题。这就是为什么我们必须在这里涉及一些更多概念和工具。

确保两个主机（节点），无论是在同一局域网内还是在不同的局域网中，能够传输数据，或者它们能够“看到”对方的基本工具是*ping*工具。你可能已经知道了它。它发送一系列**互联网控制消息协议**（**ICMP**）数据包，如果收到回复，则表示另一台主机正在运行、已连接并响应。

**注意**：

ICMP 是另一种网络层协议，主要用于在出现连接性或服务质量问题及故障时，对基于 IP 的网络进行监控和管理。

假设你要检查你的电脑是否可以看到公网 IP 地址`8.8.8.8`（如果它连接到互联网，它应该可以看到）。以下命令将帮助你检查连接性：

```cpp
$ ping 8.8.8.8
PING 8.8.8.8 (8.8.8.8): 56 data bytes
64 bytes from 8.8.8.8: icmp_seq=0 ttl=123 time=12.190 ms
64 bytes from 8.8.8.8: icmp_seq=1 ttl=123 time=25.254 ms
64 bytes from 8.8.8.8: icmp_seq=2 ttl=123 time=15.478 ms
64 bytes from 8.8.8.8: icmp_seq=3 ttl=123 time=22.287 ms
64 bytes from 8.8.8.8: icmp_seq=4 ttl=123 time=21.029 ms
64 bytes from 8.8.8.8: icmp_seq=5 ttl=123 time=28.806 ms
64 bytes from 8.8.8.8: icmp_seq=6 ttl=123 time=20.324 ms
^C
--- 8.8.8.8 ping statistics ---
7 packets transmitted, 7 packets received, 0.0% packet loss
round-trip min/avg/max/stddev = 12.190/20.767/28.806/5.194 ms
$
```

Shell Box 19-6：使用 ping 实用程序检查互联网连接性

如你在输出中看到的那样，它表示已经发送了 7 个 ICMP ping 数据包，在传输过程中没有丢失任何一个。这意味着 IP 地址`8.8.8.8`背后的操作系统正在运行并响应。

**注意**：

公网 IP 地址`8.8.8.8`指的是谷歌公共 DNS 服务。更多信息请参阅：https://en.wikipedia.org/wiki/Google_Public_DNS。

在本节中，我们解释了如何通过网络将两台计算机连接起来。现在，我们正接近这样一个点，即两个进程实际上可以相互连接并跨越多个局域网传输数据。为此，我们需要在网络层之上添加另一个层。这就是网络编程开始的地方。

### 传输层

到目前为止，我们已经看到，两台计算机可以通过三层堆栈相互连接：物理层、链路层和网络层。对于进程间通信，我们实际上需要两个进程连接并相互交谈。但是，通过这三层连接的两台计算机上可以运行许多进程，并且运行在第一台机器上的任何进程都可能想要与位于第二台机器上的另一个进程建立连接。因此，仅基于网络层的连接过于通用，无法支持由各种进程发起的多个不同的连接。

正因如此，我们才需要在网络层之上再添加一层。*传输层*就是为了满足这一需求而存在的。虽然主机通过网络层连接，但运行在这些主机上的进程可以通过在网络层之上建立的传输层进行连接。像任何其他具有自己独特标识符或地址的层一样，这一层也有一个新概念作为其唯一标识符，通常被称为*端口*。我们将在接下来的章节中对此进行详细阐述，但在那之前，我们必须解释*监听器-连接器*模型，该模型允许双方通过一个通道进行通信。在下一节中，我们将通过将计算机网络与电话网络进行类比来解释这一模型。

#### 电话网络的类比

最佳的例子就是**公共交换电话网络**（或**PSTN**）。虽然计算机网络与电话网络之间的相似性可能看起来并不很有希望，但它们之间存在着强烈的相似性，这使我们能够以合理的方式解释传输层。

在我们的类比中，使用电话网络的人就像计算机网络中的进程。因此，电话通话相当于*传输连接*。人们只有当必要的基础设施已经安装时才能进行通话。这类似于应该存在的网络基础设施，以便使进程能够进行通信。

我们假设所需的底层基础设施已经到位并且运行完美，基于这一点，我们希望在这两个系统中存在两个实体来建立一个通道并传输数据。这类似于 PSTN 中的两个人和计算机网络中两个不同主机上的两个进程。

任何想要使用 PSTN 的人都需要一部电话设备。这类似于计算机节点需要网络接口卡（NIC）的要求。在这些设备之上，有多个由各种协议组成的层。这些构建底层基础设施的层使得创建传输通道成为可能。

现在，在 PSTN 中，连接到 PSTN 的其中一个电话设备会等待接收到电话。我们称之为**听者**一方。请注意，连接到 PSTN 的电话设备总是等待来自网络的呼叫信号，并且一旦接收到信号，就会响起铃声。

现在，让我们谈谈另一方，它是发起通话的一方。请注意，发起通话相当于创建一个传输通道。另一方也有一个用于发起通话的电话设备。听者可以通过电话号码访问，这可以被视为听者的地址。**连接者**一方必须知道这个电话号码才能发起通话。因此，连接者拨打听者的电话号码，底层基础设施会让听者知道有一个来电。

当听者一方接听电话时，它接受传入的连接，并在听者和连接者之间建立一条通道。从现在起，两端坐着的人就可以通过创建的 PSTN 通道进行交谈和继续讨论。请注意，如果一方无法理解另一方的语言，通信将无法继续，并且一方会挂断电话，通道将被销毁。

#### 面向连接与无连接的传输通信

上述类比试图解释计算机网络中的传输通信，但实际上它描述的是**面向连接的通信**。在这里，我们将介绍并描述另一种类型的通信：**无连接通信**。但在那之前，让我们更深入地了解面向连接的通信。

在面向连接的通信中，为连接者创建了一个特定的专用通道。因此，如果我们有一个听者与三个连接者通信，我们就有了三个专用通道。无论传输的消息有多大，消息都会以正确的形式到达另一方，而不会在通道内丢失。如果向同一位置发送多个消息，发送消息的顺序将被保留，接收进程不会注意到底层基础设施中的任何干扰。

如我们在前几节中解释的那样，任何消息在通过计算机网络传输时，总是被分解成更小的块，称为数据包。然而，在面向连接的方案中，无论是听者还是连接者，都不会注意到底层**数据包交换**的任何情况。即使发送的数据包接收到的顺序不同，接收者的操作系统也会重新排列数据包，以便以正确的形式重建消息，接收进程不会注意到任何异常。

更重要的是，如果在传输过程中某个数据包丢失，接收方的操作系统将请求重新发送，以恢复完整消息。例如，**传输控制协议**（**TCP**）是一种传输层协议，其行为与我们上面解释的完全一致。因此，TCP 通道是面向连接的。

除了面向连接的通道外，我们还有无连接通信。在面向连接的通信中，我们保证两个因素：单个数据包的*交付*和数据包的*顺序*。例如，TCP 这样的面向连接的传输协议同时保持这些因素。相反，无连接传输协议不保证它们。

换句话说，你可能无法保证消息被分割成单独的数据包的交付，或者你可能无法保证所有数据包都将按正确的顺序排列。或者你可能两者都没有保证！例如，**用户数据报协议**（**UDP**）不保证数据包的交付或数据包的顺序。请注意，单个数据包内容的正确性保证由网络层和链路层的协议提供。

现在是时候解释两个在网络编程中常用的术语了。*流*是通过面向连接的通道传输的字节序列。这意味着无连接传输实际上不提供数据流。我们有一个特定的术语来描述通过无连接通道传输的数据单元。我们称之为*数据报*。数据报是在无连接通道中可以整体交付的数据块。任何大于最大数据报大小的数据块都无法确保交付，或者最终的顺序可能错误。数据报是在传输层定义的概念，它是网络层中数据包的对立概念。

例如，关于 UDP 数据包，可以保证每个单独的 UDP 数据报（数据包）被正确传输，但关于两个相邻数据报（数据包）之间的相关性，则无话可说。人们普遍认为，UDP 数据报之外不应存在完整性，但 TCP 并非如此。在 TCP 中，由于交付保证和发送数据包顺序的保持，我们可以将单个数据包放在一边，将其视为两个进程之间传输的字节流。

#### 传输初始化序列

在本小节中，我们将讨论每个进程为了建立传输通信所采取的步骤。我们为面向连接和无连接方案有不同的序列，因此我们将分别在接下来的两个小节中分别讨论它们。请注意，差异仅出现在通道的初始化过程中，之后，双方将使用更多或更少的相同 API 来读取和写入创建的通道。

监听器过程始终*绑定*一个端点（通常是 IP 地址与端口号的组合），而连接器过程始终*连接*到该端点。这无论是有连接还是无连接的通道都是如此。

注意，在以下序列中，我们假设监听器和连接器过程所在的主机之间已经建立了 IP 网络。

#### 无连接的初始化序列

为了建立无连接的通信通道，监听器过程将执行以下操作：

1.  监听器过程将在现有的一个或所有网络接口卡（NIC）上绑定一个端口。这意味着监听器过程请求其宿主操作系统将传入数据重定向到该端口，从而重定向到监听器过程。端口是一个介于 0 到 65535（2 字节）之间的数字，并且不能被另一个监听器过程绑定。尝试绑定一个已使用的端口将导致错误。请注意，在绑定特定 NIC 上的端口时，操作系统将重定向所有针对该绑定端口且在该特定 NIC 上接收到的目标数据包到监听器过程。

1.  进程等待并读取在创建的通道上可用的消息，并通过将响应写回通道来对这些消息进行响应。

连接器过程将执行以下操作：

1.  它必须知道监听器过程的 IP 地址和端口号。因此，它尝试通过向其宿主操作系统提供 IP 地址和端口号来连接监听器端。如果目标过程没有在指定的端口上监听，或者 IP 地址指向无效或错误的主机，连接将失败。

1.  当连接成功建立后，连接器过程可以几乎以相同的方式写入通道并从中读取，这意味着与监听器过程使用的相同 API。

注意，除了执行上述步骤之外，监听器和连接器过程都应该使用相同的传输协议，否则消息不能被它们的宿主操作系统读取和理解。

#### 面向连接的初始化序列

在面向连接的场景中，监听器过程将按照以下顺序进行初始化：

1.  绑定端口，就像之前解释的无连接场景一样。端口与之前章节中解释的完全相同，并遵循相同的约束。

1.  监听器过程继续通过配置其*后备队列*的大小来进行配置。后备队列是尚未被监听器过程接受的挂起连接的队列。在面向连接的通信中，监听器端应在能够传输任何数据之前接受传入的连接。配置后备队列后，监听器过程进入*监听模式*。

1.  现在，监听器进程开始*接受*传入的连接。这是建立传输通道的一个基本步骤。只有在接受传入连接之后，它们才能传输数据。请注意，如果连接器进程向监听器进程发送一个连接，但监听器进程无法接受该连接，它将保留在队列中，直到被接受或*超时*。这可能会发生在监听器进程忙于处理其他连接，无法接受任何新的连接时。然后，传入的连接将堆积在队列中，当队列满时，主机操作系统将立即拒绝新的连接。

连接器进程的顺序与我们之前章节中解释的无连接通信非常相似。连接器通过提供 IP 地址和端口号连接到某个端点，并在被监听器进程接受后，可以使用相同的 API 从连接导向的通道中读取和写入。

由于建立的通道是面向连接的，监听器进程有专门连接到连接器侧的通道；因此，它们可以交换一个没有字节数量上限的字节流。因此，两个进程可以传输大量数据，其正确性由管理和网络传输协议保证。

作为关于传输层的最后一项说明，我们提到监听器进程（无论底层通道是面向连接的还是无连接的）都需要绑定一个端点。具体到 UDP 和 TCP，这个端点由一个 IP 地址和一个端口号组成。

### 应用层

当两个位于不同端点的进程之间建立传输通道时，它们应该能够相互通信。我们在这里所说的“通信”是指传输一系列双方都能理解的字节。正如我们在本章前面的部分所解释的，这里需要一个通信协议。由于该协议位于*应用层*，并且由进程（或作为进程运行的应用程序）使用，因此它被称为*应用协议*。

虽然在链路、网络和传输层使用的协议并不多，它们大多是众所周知的，但我们有大量的应用协议在应用层使用。这又类似于电信网络。虽然电话网络没有多少标准，但人们用来通信的语言数量庞大，差异很大。在计算机网络中，每个作为进程运行的应用都需要使用一个应用协议才能与其他进程通信。

因此，程序员要么使用一个众所周知的应用协议，如 HTTP 或 FTP，要么必须使用一个本地设计和构建的定制应用协议。

到目前为止，我们已经讨论了五层；物理层、链路层、网络层、传输层和应用层。现在是我们将它们全部放入一个单一体系并用作设计部署计算机网络的参考的时候了。在接下来的部分，我们将讨论互联网协议套件。

### 互联网协议套件

我们每天看到的并且广泛应用的网络安全模型是**互联网协议套件**（**IPS**）。IPS 主要在互联网上使用，由于几乎所有的计算机都想访问互联网，它们普遍采用了 IPS，尽管 IPS 并不是由 ISO 正式批准的标准。计算机网络的标准模型是**开放系统互联**（**OSI**）模型，它更多的是一个理论模型，几乎从未公开部署和使用。IPS 具有以下层。请注意，以下列表中提到了每一层的突出协议：

+   物理层

+   链路层：以太网，IEEE 802.11 Wi-Fi

+   互联网层：IPv4，IPv6 和 ICMP

+   传输层：TCP，UDP

+   应用层：包括 HTTP、FTP、DNS 和 DHCP 等众多协议。

如你所见，这些层与我们在本章中讨论的层有很好的对应关系，但只有一个例外；网络层被重命名为互联网层。这是因为作为 IPS 的一部分，在这个层中突出的网络协议只有 IPv4 和 IPv6。其余的解释可以应用于 IPS 层。IPS 是我们将在整本书和实际工作环境中处理的主要模型。

现在我们已经了解了计算机网络的工作原理，我们处于一个很好的位置继续前进，看看什么是*套接字编程*。作为本章剩余部分和即将到来的章节的一部分，你将看到传输层中讨论的概念与套接字编程中的概念之间存在深刻的对应关系。

## 什么是套接字编程？

现在我们已经了解了 IPS 模型和不同的网络层，解释什么是套接字编程就变得容易多了。在深入讨论套接字编程的技术细节之前，我们应该将其定义为一个 IPC 技术，它允许我们连接位于同一节点或两个不同节点上的两个进程，这两个节点之间有网络连接。如果我们不考虑单主机套接字编程，另一种形式要求我们在两个节点之间有一个可操作的网络安全环境。正是这个事实将套接字编程与计算机网络以及我们迄今为止所解释的一切联系在一起。

要使其更加技术化，我们应该说套接字编程主要发生在传输层。正如我们之前所说的，传输层负责在现有的网络层（网络层）上连接两个进程。因此，传输层是建立套接字编程上下文的关键层。基本上，这就是为什么作为程序员，你应该更多地了解传输层及其各种协议。一些与套接字编程相关的错误其根源在于底层的传输通道。

在套接字编程中，套接字是建立传输通道的主要工具。请注意，尽管我们迄今为止已经讨论了，套接字编程可以超越传输层或**进程间通信**，它还可以包括网络层（网络层）或**主机间通信**。这意味着我们可以有网络层特定的套接字以及传输层套接字。考虑到这一点，我们看到的并与之交互的大多数套接字都是传输套接字，在本章的剩余部分和下一章中，我们将主要讨论传输套接字。

### 什么是套接字？

正如我们在上一节中解释的那样，传输层是实际套接字编程发生的地方。其上的一切只是使套接字编程更加具体；然而，实际的底层通道已经在传输层建立。

我们还讨论了，在传输通道已建立的互联网连接（网络连接）实际上是操作系统之间的连接，或者更具体地说，是那些操作系统的内核之间的连接。因此，内核中应该有一个类似于连接的概念。不仅如此，同一个内核可以发起或接受许多已建立的连接，仅仅是因为可能有多个进程在该操作系统中运行并托管，并且愿意建立网络连接。

我们正在寻找的概念是 *套接字*。对于系统中已建立或即将建立的任何连接，都有一个专门的套接字来标识该连接。对于两个进程之间建立的单一连接，每一边恰好有一个套接字指向相同的连接。正如我们之前解释的那样，其中一个套接字属于连接器端，另一个套接字属于监听器端。允许我们定义和管理套接字对象的 API 由操作系统公开的 *套接字库* 描述。

由于我们主要讨论的是 POSIX 系统，我们期望有一个这样的套接字库作为 POSIX API 的一部分，实际上我们确实有这样的库。在本章的剩余部分，我们将讨论 *POSIX 套接字库*，并解释如何使用它来在两个进程之间建立连接。

### POSIX 套接字库

每个套接字对象都有三个属性：*域*、*类型*和*协议*。虽然操作系统的手册页对这些属性解释得很好，但我们想讨论一些这些属性常用的值。我们首先从域属性开始，它也被称为**地址族**（**AF**）或**协议族**（**PF**）。以下列表中可以看到一些广泛使用的值。请注意，这些地址族支持面向连接和无连接的传输连接。

+   `AF_LOCAL` 或 `AF_UNIX`：这些是本地套接字，仅在连接器和监听器进程都位于同一主机上时才工作。

+   `AF_INET`：这些套接字允许两个进程通过 IPv4 连接相互连接。

+   `AF_INET6`：这些套接字允许两个进程通过 IPv6 连接相互连接。

**注意**：

在某些 POSIX 系统中，您可能会在用于域属性的常量中找到前缀`PF_`而不是`AF_`。通常情况下，`AF_`常量与`PF_`常量具有相同的值，因此它们可以互换使用。

在下一章中，我们将演示`AF_UNIX`和`AF_INET`域的使用，但应该很容易找到使用`AF_INET6`域的示例。此外，可能存在特定于某些操作系统的地址族，在其他系统上找不到。

套接字对象类型属性的已知值如下：

+   `SOCK_STREAM`：这意味着套接字将表示面向连接的传输通信，保证发送内容的交付、正确性和顺序。正如我们在前面的章节中解释的流，术语`STREAM`也暗示了这一点。请注意，在此阶段，您无法预测实际底层的传输协议是 TCP，因为这与属于`AF_UNIX`地址族的本地区套接字不符。

+   `SOCK_DGRAM`：这意味着套接字将表示无连接的传输通信。请注意，术语数据报（datagram），缩写为`DGRAM`，正如我们在前面的章节中解释的那样，指的是一系列无法被视为流的字节。相反，它们可以被视为一些称为数据报的独立数据块。在更技术性的背景下，数据报表示通过网络传输的数据包。

+   `SOCK_RAW`：原始套接字可以表示面向连接和无连接的通道。`SOCK_RAW`与`SOCK_DGRAM`或`SOCK_STREAM`之间的主要区别在于内核实际上知道底层使用的传输协议（UDP 或 TCP），并且它可以解析数据包并提取头部和内容。但是，对于原始套接字，内核并不这样做，而是由打开套接字的程序负责读取和提取各个部分。

    换句话说，当使用`SOCK_RAW`时，数据包会直接传递给程序，程序应该自行提取和理解数据包结构。请注意，如果底层通道是流通道（面向连接的），丢失的数据包恢复和数据包重排序不是由内核完成的，程序应该自行完成这些操作。这意味着，当您选择 TCP 作为传输协议时，恢复和数据包重排序实际上是由内核完成的。

第三个属性，协议，标识了应该用于套接字对象的协议。由于大多数地址族与类型一起确定了一个特定的协议，因此该属性可以在套接字创建时由操作系统选择。在存在多个可能协议的情况下，应该定义此属性。

套接字编程为单主机和多主机 IPC 提供了解决方案。换句话说，虽然使用互联网（网络）套接字连接位于两个不同主机和两个不同局域网上的两个进程是完全可能的，但使用 Unix 域套接字连接同一主机上的两个进程也是完全可能的。

作为本节的最后一项注意，我们应该补充说明，套接字连接是双向和全双工的。这意味着双方都可以从底层通道读取和写入，而不会干扰对方。这是一个期望的特性，因为在大多数与进程间通信（IPC）相关的场景中，通常都有这样的要求。

现在您已经了解了套接字的概念，我们必须回顾之前章节中关于监听器和连接器进程的序列。但这次，我们将更深入地探讨，并描述如何使用套接字来执行这些序列。

#### 回顾监听器-连接器序列

正如我们之前提到的，作为计算机网络的一部分，几乎在每一次连接中，一端总是处于监听状态，等待传入的连接，而另一端则尝试连接到监听端。我们也讨论了一个关于电话网络的例子，解释了电话是如何用来监听传入的呼叫，以及它是如何用来发起呼叫并连接到其他监听设备的。在套接字编程中，也存在类似的情况。在这里，我们想要探讨两个不同端点的进程应该遵循的序列，以便建立成功的传输连接。

在以下小节中，我们将更深入地探讨套接字创建的细节以及想要建立连接的两个进程应该执行的各种操作。以下小节中解释的监听器和连接器进程的序列是基础设施无关的，并得益于套接字编程在底层传输连接上提供的通用化。

正如你应该记得的，我们分别就面向连接和无连接通信讨论了监听器和连接器序列。我们在这里采取同样的方法，首先从流（面向连接）监听序列开始。

##### 流监听序列

想要监听新的流连接的过程应遵循以下步骤。您已经在之前的章节中介绍了绑定、监听和接受阶段，但在这里我们将从套接字编程的角度来讨论它们。请注意，大部分实际功能都是由内核提供的，进程只需从套接字库中调用正确的函数，以便将自己置于监听模式：

1.  该过程应使用 `socket` 函数创建一个套接字对象。这个套接字对象通常被称为 *监听套接字*。套接字对象代表整个监听进程，它将被用来接受新的连接。根据底层通道的不同，发送给 `socket` 函数的参数可能会有所不同。我们可以传递 `AF_UNIX` 或 `AF_INET` 作为套接字的地址族，但我们必须使用 `SOCK_STREAM` 作为套接字类型，因为我们将要有一个流通道。套接字对象协议属性可以由操作系统确定。例如，如果你为套接字对象选择了 `AF_INET` 和 `SOCK_STREAM`，则默认选择 TCP 作为协议属性。

1.  现在，套接字必须使用 `bind` 函数绑定到一个 *端点*，该端点可以通过连接器进程访问。所选端点的详细信息严重依赖于所选的地址族。例如，对于互联网通道，端点应该是 IP 地址和端口的组合。对于 Unix 域套接字，端点应该是文件系统上 *套接字文件* 的路径。

1.  套接字必须配置为监听。在这里，我们使用 `listen` 函数。正如我们之前所解释的，它只是为监听套接字创建一个队列。队列是一系列尚未被监听进程接受的等待连接。当监听进程无法接受新的传入连接时，内核将保留在相应队列中的传入连接，直到监听进程变得空闲并开始接受它们。一旦队列满，内核将拒绝任何进一步的传入连接。选择较小的队列大小可能导致在监听进程拥塞时许多连接被拒绝，而选择较大的队列大小可能导致大量等待连接最终超时并断开。队列大小应根据监听程序的动态性来选择。

1.  在配置了 backlog 之后，是时候接受传入的连接了。对于每一个传入的连接，都应该调用`accept`函数。因此，将`accept`函数放在一个永不结束的循环中是一个广泛使用的模式。当监听器进程停止接受新的连接时，连接器进程将被放入 backlog 中，一旦 backlog 满了，它们将被拒绝。请注意，每次对`accept`函数的调用只是简单地从套接字的 backlog 中取出下一个等待的连接。如果 backlog 为空，并且监听套接字被配置为阻塞模式，那么对`accept`函数的任何调用都将被阻塞，直到有新的连接到来。

注意，`accept`函数返回一个新的套接字对象。这意味着内核为每个接受的连接分配了一个新的唯一套接字对象。换句话说，一个已经接受 100 个客户端的监听器进程至少使用了 101 个套接字：1 个用于监听套接字，100 个用于其传入的连接。从`accept`函数返回的套接字应用于与通道另一端的客户端进行进一步的通信。

注意，这个函数调用序列对所有类型的流（面向连接的）基于套接字的 IPC 都保持一致。在下一章中，我们将展示如何使用 C 语言编程实现这些步骤的实例。在下一小节中，我们将处理流连接器序列。

##### 流连接器序列

当连接器进程想要连接到一个已经处于监听模式的监听器进程时，它应该遵循以下序列。请注意，监听器进程应该处于监听模式，否则连接将被目标主机的内核拒绝：

1.  连接器进程应该通过调用`socket`函数来创建一个套接字。这个套接字将用于连接到目标进程。这个套接字的特征应该与为监听套接字设置的相似，或者至少是兼容的，否则我们无法建立连接。因此，我们需要设置与监听套接字相同的地址族。并且类型应保持为`SOCK_STREAM`。

1.  然后它应该通过传递唯一标识监听端点的参数来使用`connect`函数。监听端点应该可以被连接器进程访问，并且它应该已经被目标进程提供。如果`connect`函数成功，这意味着连接已经被目标进程接受。在此之前，连接可能已经在目标进程的 backlog 中等待。如果指定的目标端点由于任何原因不可用，连接将失败，并且连接器进程将收到一个错误。

就像监听进程中的 `accept` 函数调用一样，`connect` 函数返回一个套接字对象。这个套接字标识了连接，并且应该用于与监听进程的进一步通信。在下一章中，我们将通过计算器示例演示前面的序列。

##### 数据报监听器序列

为了初始化，数据报监听进程将按以下顺序执行：

1.  与流监听器一样，数据报监听器进程通过调用 `socket` 函数创建一个套接字对象。但这次，它必须将套接字类型属性设置为 `SOCK_DGRAM`。

1.  现在监听套接字已经创建，监听进程应该将其绑定到一个端点。端点和其约束与流监听端类似。请注意，对于数据报监听套接字，不会有监听模式或接受阶段，因为底层通道是无连接的，我们无法为每个传入连接分配一个专用会话。

正如解释的那样，数据报服务器套接字没有监听模式或接受阶段。此外，数据报监听器应该使用 `recvfrom` 和 `sendto` 函数来从连接进程读取和写入。读取仍然可以使用 `read` 函数完成，但仅使用简单的 `write` 函数调用无法写入响应。当我们查看下一章中的数据报监听器示例时，您将看到原因。

##### 数据报连接序列

数据报连接器几乎与流连接器有相同的序列。唯一的区别是套接字类型，对于数据报连接器必须是 `SOCK_DGRAM`。对于数据报 Unix 域连接套接字有一个特殊情况，它们必须绑定到一个 Unix 域套接字文件，以便接收来自服务器的响应。我们将在下一章中，作为使用 Unix 域套接字的数据报计算器示例的一部分，对此进行详细说明。

现在我们已经讨论了所有可能的序列，是时候解释套接字和 *套接字描述符* 之间的关系了。这是本章的最后一节，通过开始下一章，我们将给出涵盖所有序列的真实 C 语言示例。

### 套接字有自己的描述符！

与其他使用文件描述符工作的基于推的 IPC 技术不同，基于套接字的技术处理套接字对象。每个套接字对象都由一个整数值引用，这是内核中的套接字描述符。这个套接字描述符可以用来引用底层通道。

注意，文件描述符和套接字描述符是不同的。文件描述符指的是常规文件或设备文件，而套接字描述符指的是由 `socket`、`accept` 和 `connect` 函数调用创建的套接字对象。

虽然文件描述符和套接字描述符不同，但我们仍然可以使用相同的 API 或函数集来读取和写入它们。因此，可以使用`read`和`write`函数来处理套接字，就像处理文件一样。

这些描述符还有一个相似之处；它们都可以通过相同的 API 配置为非阻塞。非阻塞描述符可以用于以非阻塞方式处理背后的文件或套接字。

## 摘要

在本章中，我们开始讨论允许两个进程进行通信和传输数据的 IPC 技术。本章的讨论将在下一章中完成，我们将具体讨论套接字编程，并提供各种真实的 C 语言示例。

作为本章的一部分，我们涵盖了以下主题：

+   拉模型和推模型的 IPC 技术以及它们的不同和相似之处。

+   我们比较了单主机 IPC 技术与多主机 IPC 技术。

+   你学习了关于通信协议及其各种特性的内容。

+   我们回顾了序列化和反序列化概念以及它们如何操作以满足特定的通信协议。

+   我们解释了协议的内容、长度和顺序特性如何影响接收器进程。

+   我们解释了 POSIX 管道，并通过示例演示了如何使用它们。

+   你看到了 POSIX 消息队列是什么以及它如何被用来使两个进程能够通信。

+   我们简要介绍了 Unix 域套接字及其基本特性。

+   我们解释了计算机网络是什么以及各种网络层堆栈如何导致传输连接。

+   我们解释了套接字编程是什么。

+   我们解释了监听器和连接器进程的初始化序列以及它们成为初始化状态所采取的步骤。

+   我们比较了文件描述符和套接字描述符。

在下一章中，我们将继续讨论套接字编程，重点提供真实的 C 语言示例。我们将定义一个计算器客户端和一个计算器服务器的示例。之后，我们将使用 Unix 域套接字和互联网套接字在计算器客户端和其服务器之间建立完全功能化的客户端-服务器通信。
