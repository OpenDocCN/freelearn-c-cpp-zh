["```cpp\nclass Renderer { \n  friend Window; \npublic: \n  ... \n  void EnableDeferredRendering(); \n  void BeginSceneRendering(); \n  void BeginTextureRendering(); \n  sf::RenderTexture* GetCurrentTexture(); \n  sf::RenderTexture* GetFinishedTexture(); \n  void SwapTextures(); \n  void ClearCurrentTexture(); \n  void ClearFinishedTexture(); \n  void ClearTextures(); \n  void DrawBufferTexture(); \n  void DisableDeferredRendering(); \n  ... \nprivate: \n  void CreateTextures(); \n  ... \n  sf::Shader* m_currentShader; \n  sf::RenderTexture* m_currentTexture; \n  sf::RenderTexture m_texture1; \n  sf::RenderTexture m_texture2; \n  ... \n  bool m_deferred; \n}; \n\n```", "```cpp\nvoid Renderer::EnableDeferredRendering() { \n  if (!m_useShaders) { return; } \n  m_deferred = true; \n} \n\nvoid Renderer::DisableDeferredRendering() { m_deferred = false; } \n\n```", "```cpp\nvoid Renderer::CreateTextures() { \n  if (!m_useShaders) { return; } \n  m_texture1.create(m_screenSize.x, m_screenSize.y); \n  m_texture2.create(m_screenSize.x, m_screenSize.y); \n  ClearTextures(); \n  m_texture1.display(); \n  m_texture2.display(); \n  m_currentTexture = &m_texture1; \n} \n\n```", "```cpp\nvoid Renderer::BeginSceneRendering() { \n  auto& view = m_window->GetRenderWindow()->getView(); \n  m_currentTexture->setView(view); \n} \n\nvoid Renderer::BeginTextureRendering() { \n  auto& view = m_window->GetRenderWindow()->getDefaultView(); \n  m_currentTexture->setView(view); \n} \n\n```", "```cpp\nsf::RenderTexture* Renderer::GetCurrentTexture() { \n  if (!m_useShaders) { return nullptr; } \n  return m_currentTexture; \n} \n\nsf::RenderTexture* Renderer::GetFinishedTexture() { \n  if (!m_useShaders) { return nullptr; } \n  if (!m_currentTexture) { return nullptr; } \n  return (m_currentTexture == &m_texture1 ? \n    &m_texture2 : &m_texture1); \n} \n\n```", "```cpp\nvoid Renderer::ClearCurrentTexture() { \n  if (!m_useShaders) { return; } \n  if (!m_currentTexture) { return; } \n  m_currentTexture->clear(); \n} \n\nvoid Renderer::ClearFinishedTexture() { \n  if (!m_useShaders) { return; } \n  auto texture = GetFinishedTexture(); \n  if (!texture) { return; } \n  texture->clear(); \n} \n\nvoid Renderer::ClearTextures() { \n  if (!m_useShaders) { return; } \n  m_texture1.clear(); \n  m_texture2.clear(); \n} \n\n```", "```cpp\nvoid Renderer::SwapTextures() { \n  if (!m_useShaders) { return; } \n  if (m_currentTexture) { m_currentTexture->display(); } \n  if (m_currentTexture != &m_texture1) { \n    m_currentTexture = &m_texture1; \n  } else { \n    m_currentTexture = &m_texture2; \n  } \n} \n\n```", "```cpp\nvoid Renderer::Draw(const sf::Drawable& l_drawable, \n  sf::RenderTarget* l_target) \n{ \n  if (!l_target) { \n    if (!m_deferred || !m_useShaders) { \n      l_target = m_window->GetRenderWindow(); \n    } else { l_target = m_currentTexture; } \n  } \n  sf::RenderStates states = sf::RenderStates::Default; \n  if (m_addBlend) { states.blendMode = sf::BlendAdd; } \n  if (m_useShaders && m_currentShader) { \n    states.shader = m_currentShader; \n  } \n  l_target->draw(l_drawable, states); \n  ++m_drawCalls; \n} \n\n```", "```cpp\nvoid Renderer::DrawBufferTexture() { \n  if (!m_useShaders) { return; } \n  auto texture = GetFinishedTexture(); \n  if (!texture) { return; } \n  m_sprite.setTexture(texture->getTexture()); \n  Draw(m_sprite); \n} \n\n```", "```cpp\nrenderer->EnableDeferredRendering(); \nrenderer->UseShader(\"default\"); \nrenderer->BeginSceneRendering(); \n\nfor (unsigned int i = 0; i < Sheet::Num_Layers; ++i) { \n  context->m_gameMap->Draw(i); \n  context->m_systemManager->Draw(window, i); \n  particles->Draw(window, i); \n} \nparticles->Draw(window, -1); \n\nrenderer->SwapTextures(); \n\n```", "```cpp\nrenderer->BeginTextureRendering(); \n\nif(renderer->UseShader(\"LightPass\")) { \n  auto shader = renderer->GetCurrentShader(); \n  auto time = context->m_gameMap->GetTimeNormal(); \n  shader->setUniform(\"AmbientLight\", \n    sf::Glsl::Vec3(time, time, time)); \n  sf::Vector3f lightPos(700.f, 300.f, 10.f); \n  sf::Vector2i screenPos = window->GetRenderWindow()-> \n    mapCoordsToPixel({ lightPos.x, lightPos.y }); \n  shader->setUniform(\"LightPosition\", \n    sf::Glsl::Vec3(screenPos.x, window->GetWindowSize().y - \n    screenPos.y, lightPos.z)); \n  shader->setUniform(\"LightColor\", \n    sf::Glsl::Vec3(0.1f, 0.1f, 0.1f)); \n  shader->setUniform(\"LightRadius\", 128.f); \n\n  shader->setUniform(\"texture\", \n    renderer->GetFinishedTexture()->getTexture()); \n\n  auto size = context->m_wind->GetWindowSize(); \n\n  sf::VertexArray vertices(sf::TrianglesStrip, 4); \n  vertices[0] = sf::Vertex(sf::Vector2f(0, 0), \n    sf::Vector2f(0,   1)); \n  vertices[1] = sf::Vertex(sf::Vector2f(size.x, 0), \n    sf::Vector2f(1, 1)); \n  vertices[2] = sf::Vertex(sf::Vector2f(0, size.y), \n    sf::Vector2f(0, 0)); \n  vertices[3] = sf::Vertex(sf::Vector2f(size), \n    sf::Vector2f(1, 0)); \n\n  renderer->Draw(vertices); \n  renderer->SwapTextures(); \n} \n\n```", "```cpp\nrenderer->DisableDeferredRendering(); \nwindow->GetRenderWindow()->setView( \n  window->GetRenderWindow()->getDefaultView()); \nrenderer->DrawBufferTexture(); \nwindow->GetRenderWindow()->setView(currentView); \nrenderer->DisableShader(); \n\n```", "```cpp\nuniform sampler2D texture; \nuniform vec3 AmbientLight; \nuniform vec3 LightPosition; \nuniform vec3 LightColor; \nuniform float LightRadius; \n\nvoid main() \n{ \n  vec4 pixel = texture2D(texture, gl_TexCoord[0].xy); \n\n  float dist = sqrt( \n    pow(LightPosition.x - gl_FragCoord.x, 2) + \n    pow(LightPosition.y - gl_FragCoord.y, 2) + \n    pow(LightPosition.z - gl_FragCoord.z, 2)); \n\n  vec4 finalPixel; \n\n  if(dist <= LightRadius) \n    finalPixel = (gl_Color * pixel) + \n    (pixel * vec4(LightColor, 1.0)); \n  else \n    finalPixel = (gl_Color * pixel) * vec4(AmbientLight, 1.0); \n  gl_FragColor = finalPixel; \n} \n\n```", "```cpp\nuniform sampler2D texture; \nuniform vec3 AmbientLight; \nuniform vec3 LightPosition; \nuniform vec3 LightColor; \nuniform float LightRadius; \nuniform float LightFalloff; \n\nvoid main() \n{ \n  vec4 pixel = texture2D(texture, gl_TexCoord[0].xy); \n  // Nornalized light vector and distance to the light surface. \n  vec3 L = LightPosition - gl_FragCoord.xyz; \n  float distance = length(L); \n  float d = max(distance - LightRadius, 0); \n  L /= distance; \n  // calculate basic attenuation \n  float attenuation = 1 / pow(d/LightRadius + 1, 2); \n\n  attenuation = (attenuation - LightFalloff) / (1 - LightFalloff); \n  attenuation = max(attenuation, 0); \n\n  vec4 finalPixel = (gl_Color * pixel); \n  finalPixel *= vec4(AmbientLight, 1.0); // IF FIRST PASS ONLY! \n  finalPixel += (pixel * vec4(LightColor, 1.0) * attenuation); \n\n  gl_FragColor = finalPixel; \n} \n\n```", "```cpp\nuniform sampler2D LastPass; \nuniform sampler2D DiffuseMap; \nuniform vec3 AmbientLight; \nuniform int LightCount; \nuniform int PassNumber; \n\nstruct LightInfo { \n  vec3 position; \n  vec3 color; \n  float radius; \n  float falloff; \n}; \n\nconst int MaxLights = 3; \nuniform LightInfo Lights[MaxLights]; \n\n```", "```cpp\nvoid main() \n{ \n  vec4 pixel = texture2D(LastPass, gl_TexCoord[0].xy); \n  vec4 diffusepixel = texture2D(DiffuseMap, gl_TexCoord[0].xy); \n  vec4 finalPixel = gl_Color * pixel; \n  if(PassNumber == 1) { finalPixel *= vec4(AmbientLight, 1.0); } \n  // IF FIRST PASS ONLY! \n  for(int i = 0; i < LightCount; ++i) { \n     vec3 L = Lights[i].position - gl_FragCoord.xyz; \n     float distance = length(L); \n     float d = max(distance - Lights[i].radius, 0); \n     L /= distance; \n     float attenuation = 1 / pow(d/Lights[i].radius + 1, 2); \n     attenuation = (attenuation - Lights[i].falloff) / \n       (1 - Lights[i].falloff); \n     attenuation = max(attenuation, 0); \n     finalPixel += diffusepixel * \n       ((vec4(Lights[i].color, 1.0) * attenuation)); \n  } \n  gl_FragColor = finalPixel; \n} \n\n```", "```cpp\nstruct LightBase { \n  LightBase(const sf::Vector3f& l_pos, \n    const sf::Vector3f& l_color, float l_rad, float l_fall) \n    : m_lightPos(l_pos), m_lightColor(l_color), m_radius(l_rad), \n    m_falloff(l_fall) {} \n  LightBase(const sf::Vector3f& l_color): m_lightColor(l_color) {} \n  sf::Vector3f m_lightPos; \n  sf::Vector3f m_lightColor; \n  float m_radius; \n  float m_falloff; \n}; \n\n```", "```cpp\n... // Diffuse pass. \nrenderer->SwapTextures(); \nauto DiffuseImage = renderer->GetFinishedTexture()-> \n  getTexture().copyToImage(); \nDiffuseImage.flipVertically(); \nauto DiffuseTexture = sf::Texture(); \nDiffuseTexture.loadFromImage(DiffuseImage); \nrenderer->BeginTextureRendering(); \n... \nstd::vector<LightBase> lights; \n// {Position}, {Color}, Radius, Falloff \nlights.push_back({ { 700.f, 350.f, 10.f }, { 1.f, 0.f, 0.f }, \n  128.f, 0.005f }); \nlights.push_back({ { 600.f, 350.f, 10.f }, { 0.f, 1.f, 0.f }, \n  128.f, 0.005f }); \nlights.push_back({ { 500.f, 350.f, 10.f }, { 0.f, 0.f, 1.f }, \n  128.f, 0.005f }); \nlights.push_back({ { 400.f, 600.f, 10.f },{ 1.f, 0.f, 0.f }, \n  128.f, 0.005f }); \nlights.push_back({ { 300.f, 600.f, 10.f },{ 0.f, 1.f, 0.f }, \n  128.f, 0.005f }); \nlights.push_back({ { 200.f, 600.f, 10.f },{ 0.f, 0.f, 1.f }, \n  128.f, 0.005f }); \nlights.push_back({ { 600.f, 550.f, 0.f }, { 1.f, 1.f, 1.f }, \n  128.f, 0.005f }); \n\nconst int LightsPerPass = 3; \n\n```", "```cpp\nif (renderer->UseShader(\"LightPass\")) { \n  renderer->BeginTextureRendering(); \n  auto shader = renderer->GetCurrentShader(); \n  shader->setUniform(\"AmbientLight\", \n    sf::Glsl::Vec3(0.f, 0.f, 0.2f)); \n  int i = 0; \n  int pass = 0; \n  auto lightCount = lights.size(); \n  for (auto& light : lights) { \n    std::string id = \"Lights[\" + std::to_string(i) + \"]\"; \n    sf::Vector2i screenPos = window->GetRenderWindow()-> \n      mapCoordsToPixel({light.m_lightPos.x, light.m_lightPos.y}); \n    shader->setUniform(id + \".position\", sf::Glsl::Vec3( \n      screenPos.x, window->GetWindowSize().y - screenPos.y, \n      light.m_lightPos.z)); \n    shader->setUniform(id + \".color\", \n      sf::Glsl::Vec3(light.m_lightColor)); \n    shader->setUniform(id + \".radius\", light.m_radius); \n    shader->setUniform(id + \".falloff\", light.m_falloff); \n    ++i; \n    if (i < LightsPerPass && (pass * LightsPerPass) + i \n      < lightCount) \n    { continue; } \n    shader->setUniform(\"LightCount\", i); \n    i = 0; \n    shader->setUniform(\"PassNumber\", pass + 1); \n    shader->setUniform(\"LastPass\", \n      renderer->GetFinishedTexture()->getTexture()); \n    shader->setUniform(\"DiffuseMap\", DiffuseTexture); \n    renderer->Draw(vertices); \n    renderer->SwapTextures(); \n    renderer->BeginTextureRendering(); \n    ++pass; \n  } \n} \n... \n\n```", "```cpp\nclass LightManager; \nclass Window; \n\nclass LightUser { \n  friend class LightManager; \n  virtual void Draw(MaterialMapContainer& l_materials, \n    Window& l_window, int l_layer) = 0; \n}; \n\n```", "```cpp\nenum class MaterialMapType { Diffuse, Height, Normal, \n  Specular, COUNT }; \nusing MaterialMapContainer = std::unordered_map< \n  MaterialMapType, std::unique_ptr<sf::RenderTexture>>; \n\n```", "```cpp\nusing LightContainer = std::vector<LightBase>; \nusing LightUserContainer = std::vector<LightUser*>; \n\n```", "```cpp\nclass Window; \n\nclass LightManager { \npublic: \n  LightManager(Window* l_window); \n\n  void AddLight(const LightBase& l_light); \n  void AddLightUser(LightUser* l_user); \n  LightBase* GetAmbientLight(); \n\n  void RenderMaterials(); \n  void RenderScene(); \n\n  const unsigned int LightsPerPass = 4; \nprotected: \n  MaterialMapContainer m_materialMaps; \nprivate: \n  void ClearAll(); \n  void SetViews(); \n  void DisplayAll(); \n  LightBase m_ambientLight; \n  LightContainer m_lights; \n  LightUserContainer m_users; \n\n  sf::VertexArray m_fullScreenQuad; \n\n  Window* m_window; \n}; \n\n```", "```cpp\nLightManager::LightManager(Window* l_window) : m_window(l_window), \n  m_ambientLight({ 0.f, 0.f, 0.f }) \n{ \n  auto windowSize = l_window->GetWindowSize(); \n  for (auto i = 0; \n    i < static_cast<int>(MaterialMapType::COUNT); ++i) \n  { \n    auto pair = m_materialMaps.emplace( \n      static_cast<MaterialMapType>(i), \n      std::move(std::make_unique<sf::RenderTexture>())); \n    auto& texture = pair.first->second; \n    texture->create(windowSize.x, windowSize.y); \n  } \n\n  m_fullScreenQuad = sf::VertexArray(sf::TriangleStrip, 4); \n\n  m_fullScreenQuad[0] = sf::Vertex( \n    sf::Vector2f(0, 0), sf::Vector2f(0, 1)); \n  m_fullScreenQuad[1] = sf::Vertex( \n    sf::Vector2f(windowSize.x, 0), sf::Vector2f(1, 1)); \n  m_fullScreenQuad[2] = sf::Vertex( \n    sf::Vector2f(0, windowSize.y), sf::Vector2f(0, 0)); \n  m_fullScreenQuad[3] = sf::Vertex( \n    sf::Vector2f(windowSize), sf::Vector2f(1, 0)); \n} \n\n```", "```cpp\nvoid LightManager::AddLight(const LightBase& l_light) { \n  m_lights.push_back(l_light); \n} \nvoid LightManager::AddLightUser(LightUser* l_user) { \n  m_users.emplace_back(l_user); \n} \nLightBase* LightManager::GetAmbientLight() { \n  return &m_ambientLight; \n} \n\n```", "```cpp\nvoid LightManager::ClearAll() { \n  for (auto& map : m_materialMaps) { map.second->clear(); } \n} \n\nvoid LightManager::SetViews() { \n  auto view = m_window->GetRenderWindow()->getView(); \n  for (auto& map : m_materialMaps) { map.second->setView(view); } \n} \n\nvoid LightManager::DisplayAll() { \n  for (auto& map : m_materialMaps) { map.second->display(); } \n} \n\n```", "```cpp\nvoid LightManager::RenderMaterials() { \n  ClearAll(); \n  SetViews(); \n  // Render each elevation in proper order. \n  for (auto i = 0; i < Sheet::Num_Layers; ++i) { \n    for (auto& user : m_users) { \n      user->Draw(m_materialMaps, *m_window, i); \n    } \n  } \n  // Render everything above allowed height. \n  for (auto& user : m_users) { \n    user->Draw(m_materialMaps, *m_window, -1); \n  } \n  DisplayAll(); \n} \n\n```", "```cpp\nvoid LightManager::RenderScene() { \n  auto renderer = m_window->GetRenderer(); \n  auto window = m_window->GetRenderWindow(); \n  auto size = window->getSize(); \n  auto currentView = window->getView(); \n\n  renderer->EnableDeferredRendering(); \n\n  if (renderer->UseShader(\"LightPass\")) { \n    // Light pass. \n    auto shader = renderer->GetCurrentShader(); \n    shader->setUniform(\"AmbientLight\", \n      sf::Glsl::Vec3(m_ambientLight.m_lightColor)); \n    shader->setUniform(\"DiffuseMap\", \n      m_materialMaps[MaterialMapType::Diffuse]->getTexture()); \n    ... \n    int LightID = 0; \n    int pass = 0; \n    for (auto& light : m_lights) { \n      std::string id = \"Lights[\" + std::to_string(LightID) + \"]\"; \n      sf::Vector2i screenPos = window->mapCoordsToPixel( \n        { light.m_lightPos.x, light.m_lightPos.y }, currentView); \n      float y = static_cast<float>( \n        static_cast<int>(size.y) - screenPos.y); \n      shader->setUniform(id + \".position\", \n        sf::Glsl::Vec3(screenPos.x, y, light.m_lightPos.z)); \n      shader->setUniform(id + \".color\", \n        sf::Glsl::Vec3(light.m_lightColor)); \n      shader->setUniform(id + \".radius\", light.m_radius); \n      shader->setUniform(id + \".falloff\", light.m_falloff); \n      ++LightID; \n      if (LightID < LightsPerPass && (pass * LightsPerPass) \n        + LightID < m_lights.size()) \n      { continue; } \n      renderer->BeginTextureRendering(); \n      shader->setUniform(\"LightCount\", LightID); \n      LightID = 0; \n      shader->setUniform(\"PassNumber\", pass + 1); \n      if (pass == 0) { \n        shader->setUniform(\"LastPass\", \n          m_materialMaps[MaterialMapType::Diffuse]->getTexture()); \n      } else { \n        shader->setUniform(\"LastPass\", \n          renderer->GetFinishedTexture()->getTexture()); \n      } \n      renderer->Draw(m_fullScreenQuad); \n      renderer->SwapTextures(); \n      ++pass; \n    } \n  } \n\n  renderer->DisableDeferredRendering(); \n  renderer->DisableShader(); \n  window->setView(window->getDefaultView()); \n  renderer->DrawBufferTexture(); \n  window->setView(currentView); \n} \n\n```", "```cpp\nState_Game::State_Game(StateManager* l_stateManager) \n  : BaseState(l_stateManager), \n    m_lightManager(l_stateManager->GetContext()->m_wind) \n{ \n  auto context = m_stateMgr->GetContext(); \n  m_lightManager.AddLightUser(context->m_gameMap); \n  m_lightManager.AddLightUser(context->m_systemManager); \n  m_lightManager.AddLightUser(context->m_particles); \n} \n\n```", "```cpp\nvoid State_Game::OnCreate() { \n  ... \n  m_lightManager.GetAmbientLight()->m_lightColor = \n    sf::Vector3f(0.2f, 0.2f, 0.2f); \n  m_lightManager.AddLight({ { 700.f, 350.f, 32.f }, \n    { 1.f, 0.f, 0.f }, 128.f, 0.005f }); \n  m_lightManager.AddLight({ { 600.f, 350.f, 32.f }, \n    { 0.f, 1.f, 0.f }, 128.f, 0.005f }); \n  m_lightManager.AddLight({ { 500.f, 350.f, 32.f }, \n    { 0.f, 0.f, 1.f }, 128.f, 0.005f }); \n  m_lightManager.AddLight({ { 400.f, 600.f, 32.f }, \n    { 1.f, 0.f, 0.f }, 128.f, 0.005f }); \n  m_lightManager.AddLight({ { 300.f, 600.f, 32.f }, \n    { 0.f, 1.f, 0.f }, 128.f, 0.005f }); \n  m_lightManager.AddLight({ { 200.f, 600.f, 32.f }, \n    { 0.f, 0.f, 1.f }, 128.f, 0.005f }); \n  m_lightManager.AddLight({ { 600.f, 550.f, 33.f }, \n    { 1.f, 1.f, 1.f }, 128.f, 0.01f }); \n} \n\n```", "```cpp\nvoid State_Game::Draw() { \n  m_lightManager.RenderMaterials(); \n  m_lightManager.RenderScene(); \n} \n\n```", "```cpp\nclass Map : ..., public LightUser { \npublic: \n  ... \n  void Draw(MaterialMapContainer& l_materials, \n    Window& l_window, int l_layer); \nprotected: \n  ... \n  Void CheckTextureSizes(int l_fromZ, int l_toZ); \n  std::array<sf::RenderTexture, Sheet::Num_Layers> m_textures; \n  ... \n}; \n\n```", "```cpp\nvoid Map::CheckTextureSizes(int l_fromZ, int l_toZ) { \n  auto realMapSize = m_tileMap.GetMapSize() * \n    static_cast<unsigned int>(Sheet::Tile_Size); \n  for (auto layer = l_fromZ; layer <= l_toZ; ++layer) { \n    if (m_textures[layer].getSize() != realMapSize) { \n      ... // Information printed to the console. \n      if (!m_textures[layer].create(realMapSize.x, realMapSize.y)) \n      { ... } // Error message. \n    } \n    ... // Other textures. \n  } \n} \n\n```", "```cpp\nvoid Map::Redraw(sf::Vector3i l_from, sf::Vector3i l_to) { \n  ... \n  CheckTextureSizes(l_from.z, l_to.z); \n  ClearMapTexture(l_from, originalTo); \n  auto renderer = m_window->GetRenderer(); \n\n  if (renderer->UseShader(\"default\")) { \n    // Diffuse pass. \n    for (auto x = l_from.x; x <= l_to.x; ++x) { \n      for (auto y = l_from.y; y <= l_to.y; ++y) { \n        for (auto layer = l_from.z; layer <= l_to.z; ++layer) { \n          auto tile = m_tileMap.GetTile(x, y, layer); \n          if (!tile) { continue; } \n          auto& sprite = tile->m_properties->m_sprite; \n          sprite.setPosition( \n            static_cast<float>(x * Sheet::Tile_Size), \n            static_cast<float>(y * Sheet::Tile_Size)); \n          renderer->Draw(sprite, &m_textures[layer]); \n        } \n      } \n    } \n  } \n  ... // Other passes. \n  renderer->DisableShader(); \n  DisplayAllTextures(l_from.z, l_to.z); \n} \n\n```", "```cpp\nvoid Map::ClearMapTexture(sf::Vector3i l_from, sf::Vector3i l_to){ \n  ... \n  if (l_to.x == -1 && l_to.y == -1) { \n    // Clearing the entire texture. \n    for (auto layer = l_from.z; layer <= toLayer; ++layer) { \n      m_textures[layer].clear({ 0,0,0,0 }); \n      ... // Other textures. \n    } \n    return; \n  } \n  // Portion of the map needs clearing. \n  ... \n  for (auto layer = l_from.z; layer <= toLayer; ++layer) { \n    m_textures[layer].draw(shape, sf::BlendMultiply); \n    ... // Other textures. \n  } \n  DisplayAllTextures(l_from.z, toLayer); \n} \n\n```", "```cpp\nvoid Map::DisplayAllTextures(int l_fromZ, int l_toZ) { \n  for (auto layer = l_fromZ; layer <= l_toZ; ++layer) { \n    m_textures[layer].display(); \n    ... // Other textures. \n  } \n} \n\n```", "```cpp\nvoid Map::Draw(MaterialMapContainer& l_materials, \n  Window& l_window, int l_layer) \n{ \n  if (l_layer < 0) { return; } \n  if (l_layer >= Sheet::Num_Layers) { return; } \n  auto rect = sf::IntRect(sf::Vector2i(0, 0), \n    sf::Vector2i(m_textures[l_layer].getSize())); \n  m_layerSprite.setTextureRect(rect); \n  // Diffuse. \n  m_layerSprite.setTexture(m_textures[l_layer].getTexture()); \n  m_window->GetRenderer()->Draw(m_layerSprite, \n    l_materials[MaterialMapType::Diffuse].get()); \n  ... // Other textures. \n} \n\n```", "```cpp\nvoid SystemManager::Draw(MaterialMapContainer& l_materials, \n  Window& l_window, int l_layer) \n{ \n  ... \n  auto system = dynamic_cast<S_Renderer*>(itr->second.get()); \n  system->Draw(l_materials, l_window, l_layer); \n} \n\n```", "```cpp\nvoid S_Renderer::Draw(MaterialMapContainer& l_materials, \n  Window& l_window, int l_layer) \n{ \n  ... \n  if (renderer->UseShader(\"default\")) { \n    // Diffuse pass. \n    for (auto &entity : m_entities) { \n      auto position = entities->GetComponent<C_Position>( \n        entity, Component::Position); \n      if (position->GetElevation() < l_layer) { continue; } \n      if (position->GetElevation() > l_layer) { break; } \n      C_Drawable* drawable = GetDrawableFromType(entity); \n      if (!drawable) { continue; } \n      drawable->Draw(&l_window, \n        l_materials[MaterialMapType::Diffuse].get()); \n    } \n  } \n  ... // Other passes. \n  renderer->DisableShader(); \n} \n\n```", "```cpp\nclass C_Drawable : public C_Base{ \n  ... \n  virtual void Draw(Window* l_wind, \n    sf::RenderTarget* l_target = nullptr) = 0; \n}; \n\nclass C_SpriteSheet : public C_Drawable{ \n  ... \n  void Draw(Window* l_wind, sf::RenderTarget* l_target = nullptr){ \n    if (!m_spriteSheet) { return; } \n    m_spriteSheet->Draw(l_wind, l_target); \n  } \n  ... \n}; \n\nvoid SpriteSheet::Draw(Window* l_wnd, sf::RenderTarget* l_target) { \n  l_wnd->GetRenderer()->Draw(m_sprite, l_target); \n} \n\n```", "```cpp\nvoid ParticleSystem::Draw(MaterialMapContainer& l_materials, \n  Window& l_window, int l_layer) \n{ \n  ... \n  if (renderer->UseShader(\"default\")) { \n  // Diffuse pass. \n    for (size_t i = 0; i < container->m_countAlive; ++i) { \n      if (l_layer >= 0) { \n        if (positions[i].z < l_layer * Sheet::Tile_Size) \n        { continue; } \n        if (positions[i].z >= (l_layer + 1) * Sheet::Tile_Size) \n        { continue; } \n      } else if(positions[i].z<Sheet::Num_Layers*Sheet::Tile_Size) \n      { continue; } \n      renderer->AdditiveBlend(blendModes[i]); \n      renderer->Draw(drawables[i], \n        l_materials[MaterialMapType::Diffuse].get()); \n    } \n  } \n  renderer->AdditiveBlend(false); \n  ... // Other passes. \n  renderer->DisableShader(); \n} \n\n```", "```cpp\nclass Map : ..., public LightUser { \npublic: \n  ... \n  void Draw(MaterialMapContainer& l_materials, \n    Window& l_window, int l_layer); \nprotected: \n  ... \n  std::array<sf::RenderTexture, Sheet::Num_Layers> m_textures; \n  std::array<sf::RenderTexture, Sheet::Num_Layers> m_normals; \n  std::array<sf::RenderTexture, Sheet::Num_Layers> m_speculars; \n  std::array<sf::RenderTexture, Sheet::Num_Layers> m_heightMap; \n  ... \n}; \n\n```", "```cpp\nvoid Map::CheckTextureSizes(int l_fromZ, int l_toZ) { \n  auto realMapSize = m_tileMap.GetMapSize() * \n    static_cast<unsigned int>(Sheet::Tile_Size); \n  for (auto layer = l_fromZ; layer <= l_toZ; ++layer) { \n    ... \n    if (m_normals[layer].getSize() != realMapSize) { \n      if (!m_normals[layer].create(realMapSize.x, realMapSize.y)) \n      { ... } \n    } \n    if (m_speculars[layer].getSize() != realMapSize) { \n      if (!m_speculars[layer].create(realMapSize.x,realMapSize.y)) \n      { ... } \n    } \n    if (m_heightMap[layer].getSize() != realMapSize) { \n      if (!m_heightMap[layer].create(realMapSize.x,realMapSize.y)) \n      { ... } \n    } \n  } \n} \n\n```", "```cpp\nvoid Map::ClearMapTexture(sf::Vector3i l_from, sf::Vector3i l_to) \n{ \n  ... \n  if (l_to.x == -1 && l_to.y == -1) { \n    for (auto layer = l_from.z; layer <= toLayer; ++layer) { \n      ... \n      m_normals[layer].clear({ 0,0,0,0 }); \n      m_speculars[layer].clear({ 0,0,0,0 }); \n      m_heightMap[layer].clear({ 0,0,0,0 }); \n    } \n    return; \n  } \n  ... \n  for (auto layer = l_from.z; layer <= toLayer; ++layer) { \n    ... \n    m_normals[layer].draw(shape, sf::BlendMultiply); \n    m_speculars[layer].draw(shape, sf::BlendMultiply); \n    m_heightMap[layer].draw(shape, sf::BlendMultiply); \n  } \n  DisplayAllTextures(l_from.z, toLayer); \n} \n\n```", "```cpp\nvoid Map::DisplayAllTextures(int l_fromZ, int l_toZ) { \n  for (auto layer = l_fromZ; layer <= l_toZ; ++layer) { \n    m_textures[layer].display(); \n    m_normals[layer].display(); \n    m_speculars[layer].display(); \n    m_heightMap[layer].display(); \n  } \n} \n\n```", "```cpp\nvoid Map::Draw(MaterialMapContainer& l_materials, \n  Window& l_window, int l_layer) \n{ \n  ... // Diffuse. \n  // Normal. \n  m_layerSprite.setTexture(m_normals[l_layer].getTexture()); \n  m_window->GetRenderer()->Draw(m_layerSprite, \n    l_materials[MaterialMapType::Normal].get()); \n  // Specular. \n  m_layerSprite.setTexture(m_speculars[l_layer].getTexture()); \n  m_window->GetRenderer()->Draw(m_layerSprite, \n    l_materials[MaterialMapType::Specular].get()); \n  // Height. \n  m_layerSprite.setTexture(m_heightMap[l_layer].getTexture()); \n  m_window->GetRenderer()->Draw(m_layerSprite, \n    l_materials[MaterialMapType::Height].get()); \n} \n\n```", "```cpp\nclass ResourceManager{ \npublic: \n  bool RequireResource(const std::string& l_id, \n    bool l_notifyDerived = true) \n  { \n    ... \n    if (l_notifyDerived) { OnRequire(l_id); } \n    return true; \n  } \n\n  bool ReleaseResource(const std::string& l_id, \n    bool l_notifyDerived = true) \n  { \n    ... \n    if (l_notifyDerived) { OnRelease(l_id); } \n    return true; \n  } \nprotected: \n  ... \n  virtual void OnRequire(const std::string& l_id) {} \n  virtual void OnRelease(const std::string& l_id) {} \n}; \n\nclass TextureManager : ...{ \npublic: \n  ... \n  void OnRequire(const std::string& l_id) { \n    if (RequireResource(l_id + \"_normal\", false)) { ... } \n    if (RequireResource(l_id + \"_specular\", false)) { ... } \n  } \n\n  void OnRelease(const std::string& l_id) { \n    if (ReleaseResource(l_id + \"_normal\", false)) { ... } \n    if (ReleaseResource(l_id + \"_specular\", false)) { ... } \n  } \n}; \n\n```", "```cpp\nuniform sampler2D texture; \nuniform sampler2D material; \nvoid main() \n{ \n  vec4 pixel = texture2D(texture, gl_TexCoord[0].xy); \n  vec4 materialPixel = texture2D(material, gl_TexCoord[0].xy); \n  materialPixel.a *= pixel.a; \n  gl_FragColor = gl_Color * materialPixel; \n} \n\n```", "```cpp\nuniform sampler2D texture; \nuniform vec3 material; \nvoid main() \n{ \n  vec4 pixel = texture2D(texture, gl_TexCoord[0].xy); \n  float alpha = 0.0; \n  if(pixel == vec4(0.0, 0.0, 0.0, 1.0)) \n    alpha = gl_Color.a; \n  else \n    alpha = pixel.a; \n  gl_FragColor = gl_Color * vec4(material.rgb, alpha); \n} \n\n```", "```cpp\nvoid Map::Redraw(sf::Vector3i l_from, sf::Vector3i l_to) { \n  ... \n  if (renderer->UseShader(\"MaterialPass\")) { \n    // Material pass. \n    auto shader = renderer->GetCurrentShader(); \n    auto textureName = m_tileMap.GetTileSet().GetTextureName(); \n    auto normalMaterial = m_textureManager-> \n      GetResource(textureName + \"_normal\"); \n    for (auto x = l_from.x; x <= l_to.x; ++x) { \n      for (auto y = l_from.y; y <= l_to.y; ++y) { \n        for (auto layer = l_from.z; layer <= l_to.z; ++layer) { \n          auto tile = m_tileMap.GetTile(x, y, layer); \n          if (!tile) { continue; } \n          auto& sprite = tile->m_properties->m_sprite; \n          sprite.setPosition( \n            static_cast<float>(x * Sheet::Tile_Size), \n            static_cast<float>(y * Sheet::Tile_Size)); \n          // Normal pass. \n          if (normalMaterial) { \n            shader->setUniform(\"material\", *normalMaterial); \n            renderer->Draw(sprite, &m_normals[layer]); \n          } \n        } \n      } \n    } \n  } \n  ... \n} \n\n```", "```cpp\nvoid S_Renderer::Draw(MaterialMapContainer& l_materials, \n  Window& l_window, int l_layer) \n{ \n  ... \n  if (renderer->UseShader(\"MaterialPass\")) { \n    // Material pass. \n    auto shader = renderer->GetCurrentShader(); \n    auto textures = m_systemManager-> \n      GetEntityManager()->GetTextureManager(); \n    for (auto &entity : m_entities) { \n      auto position = entities->GetComponent<C_Position>( \n        entity, Component::Position); \n      if (position->GetElevation() < l_layer) { continue; } \n      if (position->GetElevation() > l_layer) { break; } \n      C_Drawable* drawable = GetDrawableFromType(entity); \n      if (!drawable) { continue; } \n      if (drawable->GetType() != Component::SpriteSheet) \n      { continue; } \n      auto sheet = static_cast<C_SpriteSheet*>(drawable); \n      auto name = sheet->GetSpriteSheet()->GetTextureName(); \n      auto normals = textures->GetResource(name + \"_normal\"); \n      // Normal pass. \n      if (normals) { \n        shader->setUniform(\"material\", *normals); \n        drawable->Draw(&l_window, \n          l_materials[MaterialMapType::Normal].get()); \n      } \n    } \n  } \n  ... \n} \n\n```", "```cpp\nvoid ParticleSystem::Draw(MaterialMapContainer& l_materials, \n  Window& l_window, int l_layer) \n{ \n  ... \n  if (renderer->UseShader(\"MaterialValuePass\")) { \n    // Material pass. \n    auto shader = renderer->GetCurrentShader(); \n    for (size_t i = 0; i < container->m_countAlive; ++i) { \n      if (l_layer >= 0) { \n        if (positions[i].z < l_layer * Sheet::Tile_Size) \n        { continue; } \n        if (positions[i].z >= (l_layer + 1) * Sheet::Tile_Size) \n        { continue; } \n      } else if (positions[i].z < \n        Sheet::Num_Layers * Sheet::Tile_Size) \n      { continue; } \n      // Normal pass. \n      shader->setUniform(\"material\", \n        sf::Glsl::Vec3(0.5f, 0.5f, 1.f)); \n      renderer->Draw(drawables[i], \n        l_materials[MaterialMapType::Normal].get()); \n    } \n  } \n  ... \n} \n\n```", "```cpp\nuniform sampler2D LastPass; \nuniform sampler2D DiffuseMap; \nuniform sampler2D NormalMap; \nuniform vec3 AmbientLight; \nuniform int LightCount; \nuniform int PassNumber; \n\nstruct LightInfo { \n  vec3 position; \n  vec3 color; \n  float radius; \n  float falloff; \n}; \n\nconst int MaxLights = 4; \nuniform LightInfo Lights[MaxLights]; \n\nvoid main() \n{ \n  vec4 pixel = texture2D(LastPass, gl_TexCoord[0].xy); \n  vec4 diffusepixel = texture2D(DiffuseMap, gl_TexCoord[0].xy); \n  vec4 normalpixel = texture2D(NormalMap, gl_TexCoord[0].xy); \n  vec3 PixelCoordinates = \n    vec3(gl_FragCoord.x, gl_FragCoord.y, gl_FragCoord.z); \n  vec4 finalPixel = gl_Color * pixel; \n  vec3 viewDirection = vec3(0, 0, 1); \n  if(PassNumber == 1) { finalPixel *= vec4(AmbientLight, 1.0); } \n  // IF FIRST PASS ONLY! \n  vec3 N = normalize(normalpixel.rgb * 2.0 - 1.0); \n  for(int i = 0; i < LightCount; ++i) { \n\n    vec3 L = Lights[i].position - PixelCoordinates;\n    float distance = length(L);\n    float d = max(distance - Lights[i].radius, 0);\n    L /= distance;\n    float attenuation = 1 / pow(d/Lights[i].radius + 1, 2); \n    attenuation = (attenuation - Lights[i].falloff) / \n      (1 - Lights[i].falloff); \n    attenuation = max(attenuation, 0); \n    float normalDot = max(dot(N, L), 0.0); \n    finalPixel += (diffusepixel * \n      ((vec4(Lights[i].color, 1.0) * attenuation))) * normalDot; \n  } \n  gl_FragColor = finalPixel; \n} \n\n```", "```cpp\nvoid LightManager::RenderScene() { \n  ... \n  if (renderer->UseShader(\"LightPass\")) { \n    // Light pass. \n    ... \n    shader->setUniform(\"NormalMap\", \n      m_materialMaps[MaterialMapType::Normal]->getTexture()); \n    ... \n  } \n  ... \n} \n\n```", "```cpp\nstruct LightBase { \n  ... \n  float m_specularExponent = 10.f; \n  float m_specularStrength = 1.f; \n}; \n\n```", "```cpp\nvoid Map::Redraw(sf::Vector3i l_from, sf::Vector3i l_to) { \n  ... \n  if (renderer->UseShader(\"MaterialPass\")) { \n    // Material pass. \n    ... \n    auto specMaterial = m_textureManager->GetResource( \n      textureName + \"_specular\"); \n    for (auto x = l_from.x; x <= l_to.x; ++x) { \n      for (auto y = l_from.y; y <= l_to.y; ++y) { \n        for (auto layer = l_from.z; layer <= l_to.z; ++layer) { \n          ... // Normal pass. \n          // Specular pass. \n          if (specMaterial) { \n            shader->setUniform(\"material\", *specMaterial); \n            renderer->Draw(sprite, &m_speculars[layer]); \n          } \n        } \n      } \n    } \n  } \n  ... \n} \n\n```", "```cpp\nvoid S_Renderer::Draw(MaterialMapContainer& l_materials, \n  Window& l_window, int l_layer) \n{ \n  ... \n  if (renderer->UseShader(\"MaterialPass\")) { \n    // Material pass. \n    ... \n    for (auto &entity : m_entities) { \n      ... // Normal pass. \n      // Specular pass. \n      if (specular) { \n        shader->setUniform(\"material\", *specular); \n        drawable->Draw(&l_window, \n          l_materials[MaterialMapType::Specular].get()); \n      } \n    } \n  } \n  ... \n} \n\n```", "```cpp\nvoid ParticleSystem::Draw(MaterialMapContainer& l_materials, \n  Window& l_window, int l_layer) \n{ \n  ... \n  if (renderer->UseShader(\"MaterialValuePass\")) { \n    // Material pass. \n    auto shader = renderer->GetCurrentShader(); \n    for (size_t i = 0; i < container->m_countAlive; ++i) { \n      ... // Normal pass. \n      // Specular pass. \n      shader->setUniform(\"material\", \n        sf::Glsl::Vec3(0.f, 0.f, 0.f)); \n      renderer->Draw(drawables[i], \n        l_materials[MaterialMapType::Specular].get()); \n    } \n  } \n} \n\n```", "```cpp\nuniform sampler2D LastPass; \nuniform sampler2D DiffuseMap; \nuniform sampler2D NormalMap; \nuniform sampler2D SpecularMap; \nuniform vec3 AmbientLight; \nuniform int LightCount; \nuniform int PassNumber; \n\nstruct LightInfo { \n  vec3 position; \n  vec3 color; \n  float radius; \n  float falloff; \n  float specularExponent; \n  float specularStrength; \n}; \n\nconst int MaxLights = 4; \nuniform LightInfo Lights[MaxLights]; \n\nconst float SpecularConstant = 0.4; \n\nvoid main() \n{ \n  ... \n  vec4 specularpixel = texture2D(SpecularMap, gl_TexCoord[0].xy); \n  vec3 viewDirection = vec3(0, 0, 1); // Looking at positive Z. \n  ... \n  for(int i = 0; i < LightCount; ++i){ \n    ... \n    float specularLevel = 0.0; \n    specularLevel = \n      pow(max(0.0, dot(reflect(-L, N), viewDirection)), \n      Lights[i].specularExponent * specularpixel.a) \n      * SpecularConstant; \n    vec3 specularReflection = Lights[i].color * specularLevel * \n      specularpixel.rgb * Lights[i].specularStrength; \n    finalPixel += \n      (diffusepixel * ((vec4(Lights[i].color, 1.0) * attenuation)) \n      + vec4(specularReflection, 1.0)) * normalDot; \n  } \n  gl_FragColor = finalPixel; \n} \n\n```", "```cpp\nvoid LightManager::RenderScene() { \n  ... \n  if (renderer->UseShader(\"LightPass\")) { \n    // Light pass. \n    ... \n    shader->setUniform(\"SpecularMap\", \n      m_materialMaps[MaterialMapType::Specular]->getTexture()); \n    ... \n    for (auto& light : m_lights) { \n      ... \n      shader->setUniform(id + \".specularExponent\", \n        light.m_specularExponent); \n      shader->setUniform(id + \".specularStrength\", \n        light.m_specularStrength); \n      ... \n    } \n  } \n} \n\n```", "```cpp\nstruct Tile { \n  ... \n  sf::Vector3f m_normal; \n}; \n\nvoid TileMap::ReadInTile(std::stringstream& l_stream) { \n  ... \n  sf::Vector3f normals(0.f, 1.f, 0.f); \n  l_stream >> normals.x >> normals.y >> normals.z; \n  tile->m_normal = normals; \n  ... \n} \n\nTILE 57 15 3 1 1 // Tile entry without a normal. \nTILE 144 15 8 1 1 0 0 1 // Tile entry with a normal 0,0,1 \n\n```", "```cpp\nvoid Map::Redraw(sf::Vector3i l_from, sf::Vector3i l_to) { \n  ... \n  if (renderer->UseShader(\"HeightPass\")) { \n    // Height pass. \n    auto shader = renderer->GetCurrentShader(); \n    for (auto x = l_from.x; x <= l_to.x; ++x) { \n      for (auto y = l_from.y; y <= l_to.y; ++y) { \n        for (auto layer = l_from.z; layer <= l_to.z; ++layer) { \n          auto tile = m_tileMap.GetTile(x, y, layer); \n          if (!tile) { continue; } \n          auto& sprite = tile->m_properties->m_sprite; \n          sprite.setPosition( \n            static_cast<float>(x * Sheet::Tile_Size), \n            static_cast<float>(y * Sheet::Tile_Size)); \n          shader->setUniform(\"BaseHeight\", \n            static_cast<float>(layer * Sheet::Tile_Size)); \n          shader->setUniform(\"YPosition\", sprite.getPosition().y); \n          shader->setUniform(\"SurfaceNormal\", \n            sf::Glsl::Vec3(tile->m_normal)); \n          renderer->Draw(sprite, &m_heightMap[layer]); \n        } \n      } \n    } \n  } \n  ... \n} \n\n```", "```cpp\nvoid S_Renderer::Draw(MaterialMapContainer& l_materials, \n  Window& l_window, int l_layer) \n{ \n  ... \n  if (renderer->UseShader(\"HeightPass\")) { \n    // Height pass. \n    auto shader = renderer->GetCurrentShader(); \n    shader->setUniform(\"BaseHeight\", \n      static_cast<float>(l_layer * Sheet::Tile_Size)); \n    shader->setUniform(\"SurfaceNormal\", \n      sf::Glsl::Vec3(0.f, 0.f, 1.f)); \n    for (auto &entity : m_entities) { \n      auto position = entities->GetComponent<C_Position>( \n        entity, Component::Position); \n      if (position->GetElevation() < l_layer) { continue; } \n      if (position->GetElevation() > l_layer) { break; } \n      C_Drawable* drawable = GetDrawableFromType(entity); \n      if (!drawable) { continue; } \n      if (drawable->GetType() != Component::SpriteSheet) \n      { continue; } \n      auto sheet = static_cast<C_SpriteSheet*>(drawable); \n      shader->setUniform(\"YPosition\", position->GetPosition().y); \n      drawable->Draw(&l_window, \n        l_materials[MaterialMapType::Height].get()); \n    } \n  } \n  ... \n} \n\n```", "```cpp\nvoid ParticleSystem::Draw(MaterialMapContainer& l_materials, \n  Window& l_window, int l_layer) \n{ \n  ... \n  if (renderer->UseShader(\"HeightPass\")) { \n    // Height pass. \n    auto shader = renderer->GetCurrentShader(); \n    shader->setUniform(\"SurfaceNormal\", \n      sf::Glsl::Vec3(0.f, 1.f, 0.f)); \n    for (size_t i = 0; i < container->m_countAlive; ++i) { \n      if (l_layer >= 0) { \n        if (positions[i].z < l_layer * Sheet::Tile_Size) \n        { continue; } \n        if (positions[i].z >= (l_layer + 1) * Sheet::Tile_Size) \n        { continue; } \n      } else if (positions[i].z < \n        Sheet::Num_Layers * Sheet::Tile_Size) \n      { continue; } \n      shader->setUniform(\"BaseHeight\", positions[i].z); \n      shader->setUniform(\"YPosition\", positions[i].y); \n      renderer->Draw(drawables[i], \n        l_materials[MaterialMapType::Height].get()); \n    } \n  } \n  ... \n} \n\n```", "```cpp\nuniform float YPosition; \nout float Height; \nvoid main() \n{ \n  gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex; \n  gl_TexCoord[0] = gl_TextureMatrix[0] * gl_MultiTexCoord0; \n  gl_FrontColor = gl_Color; \n  Height = gl_Vertex.y - YPosition; \n} \n\n```", "```cpp\nuniform sampler2D texture; \nuniform vec3 SurfaceNormal; \nuniform float BaseHeight; \nin float Height; \nvoid main() \n{ \n  vec4 pixel = texture2D(texture, gl_TexCoord[0].xy); \n  float value = (BaseHeight - (Height * SurfaceNormal.z)) / 255.0; \n  gl_FragColor = vec4(value, value, value, pixel.a); \n} \n\n```", "```cpp\n... \nuniform sampler2D HeightMap; \n... \nvoid main() \n{ \n  ... \n  float pixelheight = texture2D(HeightMap, gl_TexCoord[0].xy).r \n    * 255; \n  vec3 PixelCoordinates = \n    vec3(gl_FragCoord.x, gl_FragCoord.y, pixelheight); \n  ... \n  gl_FragColor = finalPixel; \n} \n\n```", "```cpp\nvoid LightManager::RenderScene() { \n  ... \n  if (renderer->UseShader(\"LightPass\")) { \n    // Light pass. \n    ... \n    shader->setUniform(\"HeightMap\", \n      m_materialMaps[MaterialMapType::Height]->getTexture()); \n    ... \n  } \n  ... \n} \n\n```"]