- en: Chapter 7.  Third-Party Libraries Without a Headache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we have used our own libraries or the ones provided by
    Qt. In this chapter, we will learn how to integrate the third-party library OpenCV
    with a Qt project. This library will give you an impressive image processing toolbox.
    For each platform, you will learn to use a different specific compiler link configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Qt Designer is a powerful WYSIWYG editor. This is why this chapter will also
    teach you to build a Qt Designer plugin that can be dragged and dropped from the
    **Widget Box** to the **Form Editor**, and then configured directly from Qt Creator.
  prefs: []
  type: TYPE_NORMAL
- en: In the example project, the user can load a picture, select a filter from thumbnail
    previews, and save the result. This application will rely on OpenCV functions
    for image processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Prepare a cross-platform project to host a third-party library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Link with a third party library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a custom `QWidget` class using Qt Designer plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How the OpenCV API can work with Qt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a Qt application that relies on a custom `QWidget` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your Qt Designer plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 4](part0040.xhtml#aid-164MG2 "Chapter 4.  Conquering the Desktop
    UI"), *Conquering the Desktop UI*, we created a custom Qt widget in Qt Designer
    using the promoting technique. It is now time to learn how to create a custom
    Qt widget by building a plugin for Qt Designer. Your widget will be available
    from the **Design mode** in the **Widget Box** alongside other regular Qt widgets.
    For this project example, we will create a `FilterWidget` class that processes
    an input image to apply a filter. The widget will also display the filter name
    and a dynamic thumbnail of the filtered picture.
  prefs: []
  type: TYPE_NORMAL
- en: 'This project is composed of two sub-projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`filter-plugin-designer`: This is a Qt Designer plugin containing `FilterWidget`
    class and the image processing code. This plugin is a dynamic library that will
    be used by the Qt Creator to offer our new `FilterWidget` in the **Form Editor**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`image-filter`: This is a Qt Widget application using multiple `FilterWidget`.
    The user can open an image from their hard disk, select a filter (grayscale, blur,
    and so on), and save the filtered image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our `filter-plugin-designer` will use the third-party library **OpenCV** (**Open
    Source Computer Vision**). It is a powerful, cross-platform open source library
    to manipulate images. Here is an overview schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating your Qt Designer plugin](img/image00407.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can see a plugin as a kind of module, which can be easily added to an existing
    software. A plugin must respect a specific interface to be automatically called
    by the application. In our case, the Qt Designer is the application that loads
    Qt plugins. So creating a plugin allows us to enhance the application without
    the need to modify the Qt Designer source code and recompile it. A plugin is a
    generally dynamic library (`.dll`/`.so`), so it will be loaded at runtime by the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have a clear mind about the Qt Designer plugins, let''s build
    one! First, create a `Subdirs` project called `ch07-image-filter`. Then, you can
    add a subproject, `filter-plugin-designer`. You can use the **Empty qmake Project** template
    because we start this project from scratch. Here is the `filter-plugin-designer.pro`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Please note the `uiplugin` and `plugin` keywords for `QT` and `CONFIG`. They
    are required to create a Qt Designer plugin. We set the `TEMPLATE` keyword to `lib`
    because we are creating a dynamic library. The define, `FILTERPLUGINDESIGNER_LIBRARY`,
    will be used by the import/export mechanism of the library. We already covered
    this topic in [Chapter 3](part0034.xhtml#aid-10DJ42 "Chapter 3.  Dividing Your
    Project and Ruling Your Code"), *Dividing Your Project and Ruling Your Code*.
    By default, our `TARGET` is `filter-plugin-designer`; the `$$qtLibraryTarget()`
    function will update it according to your platform. For example, the suffix "d"
    (standing for debug) will be appended on Windows. Finally, we append `target`
    to `INSTALLS`. Right now, this line does nothing, but we will describe a destination
    path for each platform soon; this way, executing the `make install` command will
    copy our target library file (`.dll`/`.so`) into the correct folder. To automatically
    perform this task on each compilation, you can add a new build step.
  prefs: []
  type: TYPE_NORMAL
- en: 'The deploy path is configured, but it will not be done automatically. Open
    the **Projects** tab and do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Build Settings** | **Build Steps**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Add Build Step** | **Make**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Make arguments** field, type `install`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should get something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating your Qt Designer plugin](img/image00408.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Each time you build the project, the `make install` command will be called and
    it will deploy the library in Qt Creator.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the project for Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before preparing this project on Windows, let''s talk about the available choices
    when you develop a Qt application on a Windows host. The official Qt website provides
    multiple binary packages. We are mainly interested in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Qt for Windows 32-bit (MinGW)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Qt for Windows 32-bit (VS 2013)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may already be using one of these versions. The first one comes with a MinGW
    GCC compiler and the Qt framework. The second only provides the Qt framework and
    relies on the Microsoft Visual C++ compiler that will be installed with Visual
    Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Both versions are fine when you want to create a common Qt application for Windows.
    However, for this chapter, we want to link our `filter-plugin-designer` project
    with OpenCV libraries. Qt Designer must also be able to dynamically load `filter-plugin-designer`,
    so we must use a consistent compiler version at all stages.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that Qt Creator on Windows is always based on MSVC, even in the
    MinGW binary package! So if you create a Qt Designer plugin using a MinGW compiler,
    your Qt Creator will not be able to load it. OpenCV for Windows provides only
    MSVC libraries, compile for MSVC11 (which is VS 2012), and MSVC12 (VS 2013).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a summary of the different solutions for building our project example
    in Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring the project for Windows](img/image00409.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Keep in mind that for open-source software such as Qt Creator and OpenCV you
    can always try to compile them from a source with a different compiler. So, if
    you absolutely want to use a MinGW compiler, you must recompile OpenCV and Qt
    Creator from sources. Otherwise, we suggest that you use Qt for Windows 32-bit
    (VS 2013) as explained shortly. Here are the steps to prepare your development
    environment:'
  prefs: []
  type: TYPE_NORMAL
- en: Download and install Visual Studio Community Edition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download and install Qt for Windows 32-bit (VS 2013).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download and extract OpenCV for Windows (for example: `C:\lib\opencv`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new `OPENCV_HOME`: `C:\lib\opencv\build\x86\vc12` environment variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Append to your system `Path`: `C:\lib\opencv\build\x86\vc12\bin` environment
    variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `OPENCV_HOME` directory will be used in our `.pro` file. We also add an
    OpenCV libraries folder to the `Path` directory to easily resolve the dependencies
    at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now add the following snippet to the `filter-plugin-designer.pro` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `target` path is set to the Qt Creator plugin folder. We also create a `target_lib`
    library to copy the `.lib` file generated by MSVC when we make a dynamic library
    (`.dll`). We add the OpenCV headers folder to the `INCLUDEPATH` to easily include
    them in our code. Finally, we update `LIBS` variable to link our plugin with the
    OpenCV modules (`core` and `imgproc`) from the OpenCV `lib` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the standalone Qt Designer application and the Qt Creator are
    different software. Both programs use a different plugin path. In our case, we
    only used the form editor from the Qt Creator, so we are targeting the Qt Creator
    plugin path.
  prefs: []
  type: TYPE_NORMAL
- en: Just as we appended `target` and `target_lib` to `INSTALLS`, both `.dll` and `.lib`
    files will be copied in the Qt Creator plugin path on a `make install` command.
    Qt Creator only requires the `.dll` file to load the plugin at runtime. The `.lib`
    file is only used to resolve the links with `filter-plugin-designer` when building
    our `image-filter` application. For simplicity, we are using the same directory.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the project for Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OpenCV binaries are certainly available in official software repositories.
    Depending on your distribution and your package manager, you can install it with
    commands such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When OpenCV is installed on your Linux, you can add this snippet to the `filter-plugin-designer.pro`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This time we do not use the `LIBS` variable but `PKGCONFIG`, which relies on `pkg-config`.
    It is a helper tool that will insert the correct options into the compile command
    line. In our case, we will request `pkg-config` to link our project with OpenCV.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can list all the libs managed by `pkg-config` with the `pkg-config --list-all`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the project for Mac
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step in making the project work on Mac OS is to install OpenCV. Fortunately,
    this is very easy using the `brew` command. If you develop on Mac OS and do not
    use it already, you should download it right now. In a nutshell, `brew` is an
    alternate package manager that gives you access to many packages (for developers
    and non-developers) that are not available on the Mac App Store.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can download and install brew from [http://brew.sh/](http://brew.sh/).
  prefs: []
  type: TYPE_NORMAL
- en: 'In a terminal, simply type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This will download, compile, and install OpenCV on your machine. At the time
    of writing, the latest OpenCV version available on brew was version 2.4.13\. Once
    this is done, open `filter-plugin-designer.pro` and add the following block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We add OpenCV headers and link the path with `INCLUDEPATH` and `LIBS` variables.
    The `target` definition and `INSTALLS` are used to automatically deploy the output
    shared object to the Qt Creator application plugins directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing we have to do is to add an environment variable to let the Qt
    Creator know where it will find the library that will link it to the final application.
    In the **Projects** tab, go through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Details** window in **Build Environment**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Add** Button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type `DYLD_LIBRARY_PATH` in the `<VARIABLE>` field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type the path of the build directory in `<VALUE>` (you can copy and paste it
    from the section **General** | **Build directory**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implementing your OpenCV filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that your development environment is ready, we can begin the fun part!
    We will implement three filters using OpenCV:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FilterOriginal`: This filter does nothing and returns the same picture (lazy!)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FilterGrayscale`: This filter converts a picture from color to grayscale'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FilterBlur`: This filter smoothes the picture'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The parent class of all these filters is `Filter`. Here is this abstract class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, `process()` is a pure abstract method. All filters will implement
    a specific behavior with this function. Let''s begin with the simple `FilterOriginal`
    class. Here is `FilterOriginal.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This class inherits `Filter` and we override the  `process()` function. The
    implementation is also really simple. Fill `FilterOriginal.cpp` with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'No modification is performed; we return the same picture. Now that the filter
    structure is clear, we can create `FilterGrayscale`. The `.h`/`.cpp` files are
    close to `FilterOriginalFilter`, so let''s jump to the `process()` function of `FilterGrayscale.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the Qt framework, we use the `QImage` class to manipulate pictures. In the
    OpenCV world, we use the `Mat` class, so the first step is to create a correct `Mat`
    object from the `QImage` source. OpenCV and Qt both handle many image formats.
    An image format describes the data bytes organization with information such as
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Channel count`: A grayscale picture only needs one channel (white intensity),
    while a color picture requires three channels (red, green, and blue). You will
    even need four channels to handle the opacity (alpha) pixel information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Bit depth`: The number of bits used to store a pixel color.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Channel order`: The most common orders are RGB and BGR. Alpha can be placed
    before or after the color information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, the OpenCV image format, `CV_8UC4`, means four channels of unsigned
    8-bit, which is the perfect fit for an alpha color picture. In our case, we are
    using a compatible Qt and OpenCV image format to convert our `QImage` in `Mat`.
    Here is a little summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing your OpenCV filters](img/image00410.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Please note that some `QImage` class formats also depend on your platform endianness.
    The preceding table is for a little endian system. For OpenCV, the order is always
    the same: `BGRA`. It is not required in our project example, but you can swap
    blue and red channels as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'OpenCV `Mat` and Qt `QImage` classes perform shallow construction/copy by default.
    This means that only metadata is really copied; the pixel data is shared. To create
    a deep copy of a picture, you must call the `copy()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We created a `Mat` class called `tmp` from the `QImage` class. Note that `tmp`
    is not a deep copy of `image`; they share the same data pointer. Then, we can
    call the OpenCV function to convert the picture from color to grayscale using `cv::cvtColor()`.
    Finally, we create a `QImage` class from the grayscale `resultMat` element. In
    that case too, `resultMat` and `resultImage` share the same data pointer. Once
    we're done, we return a deep copy of `resultImage`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is now time to implement the last filter. Here is the `process()` function
    of `FilterBlur.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The conversion from `QImage` to `Mat` is the same. The processing differs because
    we use the `cv::GaussianBlur()` OpenCV function to smooth the picture. The `blur`
    is the kernel size used by the Gaussian blur. You can increase this value to get
    a softer picture, but only use an odd and positive number. Finally, we convert
    the `Mat` to `QImage` and return a deep copy to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the UI with FilterWidget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Fine. Our filter classes are implemented, and we can now create our custom
    widget. This widget will take in input, a source, and a thumbnail picture. Then
    the thumbnail is immediately processed to display a preview of the filter. If
    the user clicks on the widget, it will process the source picture and trigger
    a signal with the filtered picture. Keep in mind that this widget will later be
    dragged and dropped in the **Form Editor** of Qt Creator. That''s why we will
    provide properties with getters and setters to select a filter from Qt Creator.
    Please create a new widget called `FilterWidget` using the **Qt Designer Form
    Class** template. The `FilterWidget.ui` is really simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing the UI with FilterWidget](img/image00411.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `titleLabel` is a `QLabel` on top of the `QWidget`. Below, `thumbnailLabel`
    will display the filtered picture thumbnail. Let''s switch to `FilterWidget.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The top part defines all the available filter types with the `enumFilterType`.
    We also use the Qtproperty system to expose the widget title and the current filter
    type to the **Property Editor** of Qt Creator. The syntax is like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Please note that exposing an enumeration requires it to be registered using
    the `Q_ENUM()` macro, so the **Property Editor** will display a combo box that
    allows you to choose the filter type from Qt Creator.
  prefs: []
  type: TYPE_NORMAL
- en: The middle part lists all functions, slots, and signals. The most notable is
    the `process()` function that will use the current filter to modify the source
    picture. The `pictureProcessed()` signal will notify the application with the
    filtered picture.
  prefs: []
  type: TYPE_NORMAL
- en: The bottom part lists the picture and thumbnail `QImage` variables used in this
    class. In both cases, we handle both source and filtered pictures. The default
    source picture is an embedded picture in the plugin. This allows you to display
    a default preview when no thumbnail has been provided. The `mFilter` variable
    is a smart pointer to the current `Filter` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s switch to the implementation with `FilterWidget.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the constructor and the destructor. Please note that the default source
    picture loads an embedded picture of the gorgeous Lenna often used in image processing
    literature. The picture is in the resource file, `filter-plugin-designer.qrc`.
    The `mSourceThumbnail` function is initialized with a scaled picture of Lenna.
    The constructor calls the `setFilterType()`function to initialize an `Original`
    filter by default. Here is the core `process()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `process()` function is powerful, but really simple. We call `process()`
    of the current filter to update our filtered picture from the current source picture.
    Then we trigger the `pictureProcessed()` signal with the filtered picture. We
    can now add our `QImage` setters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `setSourcePicture()` function is a simple setter called by the application
    with a new source picture. The `updateThumbnail()` method will filter the new
    source thumbnail and display it. Let''s add the setters used by `Q_PROPERTY`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `setTitle()`function is a simple setter used to customize the widget title.
    Let's talk about the `setFilterType()` function. As you can see, this function
    does not just update the current filter type, `mFilterType`. Depending on the
    type, the corresponding filter will be created. Do you remember the smart pointer
    from [Chapter 3](part0034.xhtml#aid-10DJ42 "Chapter 3.  Dividing Your Project
    and Ruling Your Code"), *Dividing Your Project and Ruling Your Code*? Here we
    are using a `unique_ptr` pointer for the `mFilter` variable, so we can use `make_unique`
    instead of a `new` raw. The `FilterWidget` class takes the ownership of the `Filter`
    class, and we do not need to worry about the memory management. Upon the `make_unique`
    instruction, the old owned pointer (if there is any) will be automatically deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we call the `updateThumbnail()` function to display a filtered thumbnail
    corresponding to the selected filter type. Here are the getters and the mouse
    event handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `title()` and `filterType()` functions are getters used by the Qt Property
    System. We override the `mousePressEvent()` function to call our  `process()`
    function each time the user clicks on the widget.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing your plugin to Qt Designer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `FilterWidget` class is completed and ready to be used. We now have to register `FilterWidget`
    with the Qt Designer plugin system. This glue code is made using a child class
    of `QDesignerCustomWidgetInterface`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new C++ class named `FilterPluginDesigner` and update `FilterPluginDesigner.h`
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `FilterPlugin` class inherits from two classes:'
  prefs: []
  type: TYPE_NORMAL
- en: The `QObject` class, to rely on the Qt parenting system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `QDesignerCustomWidgetInterface` class to properly expose the `FilterWidget`
    information to the plugin system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `QDesignerCustomWidgetInterface` class brings two new macros:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Q_PLUGIN_METADATA()` macro annotates the class to indicate a unique name
    for our filter to the meta-object system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Q_INTERFACES()` macro tells the meta-object system which interface the
    current class has implemented
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Qt Designer is now able to detect our plugin. We now have to provide information
    about the plugin itself. Update `FilterPluginDesigner.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This is much less overwhelming than it looks. The body of each one of these
    functions usually takes a single line. Here is the implementation of the most
    straightforward functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, there isn''t much to say about these functions. Most of them
    will simply return a `QString` value that will be displayed on the appropriate
    spot in the Qt Designer UI. We will focus only on the most interesting ones. Let''s
    start with `includeFile()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This function will be called by `uic` (**User Interface Compiler**) to generate
    the header corresponding to a `.ui` file. Continuing with `createWidget()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This function makes the bridge between Qt Designer and `FilterWidget`. When
    you add the `FilterWidget` class in a `.ui` file, Qt Designer will call the `createWidget()`
    function to have an instance of the `FilterWidget` class and display its content.
    It also provides the `parent` element to which `FilterWidget` will be attached.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s finish with `initialize()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing much is done in this function. However, the `QDesignerFormEditorInterface*`
    parameter is worth some explanation. This pointer, provided by Qt Designer, gives
    access to a few of Qt Designer''s components via functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`actionEditor()`: This function is the action editor (bottom panel of the designer)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`formWindowManager()`: This function is the interface that enables you to create
    a new form window'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`objectInspector()`: This function is the hierarchical representation of your
    layout (top right panel of the designer)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`propertyEditor()`: This function is the list of all the editable properties
    of the currently selected widget (bottom right panel of the designer)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`topLevel()`: This function is the top-level widget of the designer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We covered each of these panels in [Chapter 1](part0014.xhtml#aid-DB7S1 "Chapter 1. 
    Get Your Qt Feet Wet"), *Get Your Qt Feet Wet*. If your widget plugin needs to
    intervene in any of these areas, this function is the entry point to customize
    the behavior of Qt Designer.
  prefs: []
  type: TYPE_NORMAL
- en: Using your Qt Designer plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our custom plugin is now finished. Because we added a custom `Build` command
    to automatically deploy the filter-widget library, it should be visible in Qt
    Designer. The deploy path we specified is inside the Qt Creator directory. Qt
    Creator integrates Qt Designer via a plugin that displays the UI inside Qt Creator.
  prefs: []
  type: TYPE_NORMAL
- en: When Qt Creator starts, it will try to load every library available in its specific
    paths. This means that you have to restart Qt Creator each time you modify the
    plugin (if you want to see the result of your modifications in the designer).
  prefs: []
  type: TYPE_NORMAL
- en: To see the plugin in action, we now have to create the application project of
    the chapter. Create a **Qt Widgets Application** sub-project in the `ch07-image-filter`
    project named `image-filter`. In the wizard, let it generate the form, `MainWindow.ui`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To properly use the plugin, just link the `filter-plugin-designer` library
    in `image-filter.pro` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: To have access to the headers of `filter-plugin-designer`, we simply add it
    to the `INCLUDEPATH` directory. Finally, the linker is instructed to link to the
    library we deployed in Qt Creator. This ensures that the same library is used
    by Qt Designer and by our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `MainWindow.ui` file and scroll to the bottom of the **Widget box**.
    Lo and behold, you should see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using your Qt Designer plugin](img/image00412.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `FilterWidget` plugin appears under the Mastering Qt5 section. It even
    displays the famous Lenna as a preview icon. If you do not see the `FilterWidget`
    plugin, then restart Qt Creator and make sure that the plugin is properly loaded.
    To check this (in the **Design** tab), go to **Tools** | **Form Editor** | **About
    Qt Designer Plugins**. This is what it should display:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using your Qt Designer plugin](img/image00413.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If the `FilterWidget` plugin does not appear in this list, you should check
    the Qt Creator plugin directory content (the path is stated in `image-filter.pro`).
  prefs: []
  type: TYPE_NORMAL
- en: Building the image-filter application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can proceed to build the UI of the application. The idea is to open a picture
    from the filesystem and apply to it the various filters we developed in the `filter-designer-plugin`
    project. If you want to keep the result, you can save the resulting image.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by designing the UI. Modify `MainWindow.ui` to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the image-filter application](img/image00414.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the Object Inspector content to help you build this layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the image-filter application](img/image00415.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are three elements of this UI:'
  prefs: []
  type: TYPE_NORMAL
- en: The `menuFile` element, which contains three possible actions: `actionOpenPicture`, `actionExit`,
    and `actionSaveAs`. You can see the details of these actions in the `Action Editor`
    window.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `pictureLabel` element, which will display the loaded picture in the empty
    top part.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `filtersLayout` element, which contains the three instances of our `FilterWidget`
    class in the bottom part.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you add a `FilterWidget` class in `filtersLayout`, you can see that you can
    customize the `title` and the `filterType` in the **Property Editor** window.
    The preview will be automatically updated with the selected filter applied to
    our default picture. A dynamic preview like this is simply awesome, and you can
    foresee that your custom Qt Designer widgets can become quite powerful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement the logic of our application. Update `MainWindow.h` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some elements that we have to explain:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mSourcePicture`: This element is the loaded picture.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mSourceThumbnail`: This element is the generated thumbnail from `mSourcePicture`.
    To avoid wasting CPU cycles, `mSourcePicture` will be resized only once, and each
    of the `FilterWidget` instances will process this thumbnail rather than the full-resolution
    picture.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mCurrentPixmap`: This element is the currently displayed `QPixmap` in the `pictureLabel`
    widget.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mCurrentFilter`: This element is the currently applied filter. Each time the
    user clicks on a different `FilterWidget`, this pointer will be updated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mFilters`: This element is a `QVector` of the `FilterWidget` class that we
    added to `MainWindow.ui`. It is only a helper, introduced to easily apply the
    same instructions to each `FilterWidget` class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now for the functions, we will limit ourselves to a broad overview. The details
    will be covered when we look at the implementation of each function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`loadPicture()`: This function triggers the whole pipeline. It will be called
    when the user clicks on `actionOpenPicture`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`initFilters()`: This function is in charge of initializing `mFilters.`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`displayPicture()`: This function is the slot called by `mCurrentWidget::pictureProcessed()`
    to display the filtered picture.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`updatePicturePixmap()`: This function handles the display of `mCurrentPixmap`
    inside `pictureLabel`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at the `MainWindow` class''s constructor implementation in `MainWindow.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We connect the `actionOpenPicture::triggered()` signal to our yet-to-be-implemented `loadPicture()`
    function. The `actionExit` is straightforward; it is simply connected to the `QMainWindow::close()`
    slot. Finally, `initFilter()` is called. Let''s see its body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Each `FilterWidget` instance is added to `mFilters`. We then proceed to connect
    the `pictureProcessed()` signal to the `MainWindow::displayPicture` instruction
    and `mCurrentFilter` is initialized to the original filter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class is now ready to load some pictures! This is the implementation of
    `loadPicture()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The  `mSourcePicture` method is loaded using a `QFileDialog`, and `mSourceThumbnail`
    is generated from this input. Every `FilterWidget` class is updated with this
    new data and the `mCurrentFilter` element is triggered by calling its `process()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'When `FilterWidget::process()` is finished, it emits the `pictureProcessed()`
    signal, which is connected to our `displayPicture()` slot. Let''s switch to this
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing very fancy here: `mCurrentPixmap` is updated from the given picture
    and the `updatePicturePixmap()` function is in charge of updating the `pictureLabel`
    element. Here is the implementation of `updatePicturePixmap()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This function simply creates a scaled version of `mCurrentPixmap` that fits
    inside `pictureLabel`.
  prefs: []
  type: TYPE_NORMAL
- en: The whole picture loading/filter processing is completed. If you run the application
    you should be able to load and modify your pictures. However, if you resize the
    window, you will see that the `pictureLabel` element does not scale very well.
  prefs: []
  type: TYPE_NORMAL
- en: 'To address this issue, we have to regenerate the scaled version of `mCurrentPixmap`
    each time the window is resized. Update `MainWindow` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Here, the separation of `mCurrentPixmap` and the `pictureLabel` element's pixmap
    makes sense. Because we always generate the scaled version from the full-resolution `mCurrentPixmap`,
    we are sure that the resulting pixmap will look good.
  prefs: []
  type: TYPE_NORMAL
- en: 'The image-filter application would not be complete without the ability to save
    your filtered picture. This will not take much effort. Here is the updated version
    of `MainWindow.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we simply added a `saveAsPicture()` function that will take the `mFilteredPicture`
    element and save it to a file. The implementation in `MainWindow.cpp` should not
    blow your mind:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The code snippet is long, but not very complex. The `actionSaveAs` function
    is enabled only when a picture is loaded. When the picture has been processed, `mFilteredPicture`
    is updated with the given picture. Because it is a reference, it costs absolutely
    nothing to store this filtered picture.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `saveAsPicture()` function asks the user for a path and saves it
    using the `QImage` API, which tries to deduce the picture type based on the file
    extension.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to integrate a third-party library with each
    desktop OS (Windows, Linux, and Mac). We chose the OpenCV library, which has been
    included in a custom Qt Designer plugin, and which can display a live preview
    of your image processing result in Qt Designer. We created an image filtering
    application that can open pictures, apply filters to them, and save the result
    on your machine.
  prefs: []
  type: TYPE_NORMAL
- en: We had a good look at how you can integrate third-party libraries and how to
    make a Qt Designer plugin. In the next chapter, we will push things forward by
    making the `image-filter` application ready to load filter plugins that could
    be implemented by third-party developers. To make things even cooler, we will
    cover the Qt animation framework to make the `image-filter` more spectacular.
  prefs: []
  type: TYPE_NORMAL
