<html><head></head><body>
        

                            
                    <h1 class="header-title">Diving into Modern C++</h1>
                
            
            
                
<p>The C++ programming language has been changed dramatically since its invention in 1979. Some people in this era might be a little bit scared to code using C++ language since it is not user-friendly. The memory management we have to deal with sometimes makes people unwilling to use this language. Fortunately, since <strong>C++11</strong>--also known as <strong>modern C++</strong>, along with <strong>C++14</strong> and <strong>C++17</strong>--has been released, numerous features have been introduced to simplify our code in the C++ language. Moreover, the best part of it is that the C++ programming language is a great language for any project, from low-level programming to web programming, as well as functional programming.</p>
<p>This chapter is the best place to start our journey in this book, as it is addressed to the C++ programmers to refresh their knowledge and will discuss the following topics:</p>
<ul>
<li>Understanding several new features in modern C++</li>
<li>Implementing the C++ Standard Libraries in modern C++</li>
<li>The use of the Lambda expression and all features included in C++ Lambda</li>
<li>Using smart pointer to avoid manual memory management</li>
<li>Dealing with many return values using tuples</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting closer with several new features in modern C++</h1>
                
            
            
                
<p>So, what is new in modern C++ in comparison to the old one? There are so many changes in modern C++ compared to the old one, and the book pages will dramatically increase if we discuss all of them. However, we will discuss the new features in modern C++, which we should know about, to make us more productive in coding activities. We will discuss several new keywords, such as <kbd>auto</kbd>, <kbd>decltype</kbd>, and <kbd>nullptr</kbd>. We will also discuss the enhancement of the <kbd>begin()</kbd> and <kbd>end()</kbd> function that has now become a non-member class function. We will also discuss the augmented support for the <kbd>for-each</kbd> technique to iterate over collections using the <kbd>range-based for loop</kbd> techniques.<br/></p>
<p>The next few subsections in this chapter will also discuss the new features of modern C++, namely Lambda expressions, smart pointers, and tuples, which were just added in the C++11 release.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Defining the data type automatically using the auto keyword</h1>
                
            
            
                
<p>Prior to the modern C++, the C++ language has a keyword named <kbd>auto</kbd> that is used to explicitly specify that the variable should have <strong>automatic duration</strong>. The automatic duration that adheres to the variable will create the variable at the point of definition (and initialized, if relevant) and destroy the variable when the block they are defined in is exited. For instance, the local variable will be created when it is defined at the beginning of the function and destroyed when the program exits the function where the local variable is there.</p>
<p>Since C++11, the <kbd>auto</kbd> keyword is used to tell the compiler to deduce the actual type of a variable that is being declared from its initializer. And since C++14, the keyword can also be applied to a function to specify the return type of the function that is a trailing return type. Now, in modern C++, the use of the <kbd>auto</kbd> keyword to specify the automatic duration is abolished since all variables are set to automatic duration by default.</p>
<p>The following is an <kbd>auto.cpp</kbd> code demonstrating the use of the <kbd>auto</kbd> keyword in the variables. We will define four variables with the <kbd>auto</kbd> keyword, and then find out the data type for each variable using the <kbd>typeid()</kbd> function. Let's take a look:</p>
<pre>
    /* auto.cpp */<br/><br/>    #include &lt;iostream&gt;<br/>    #include &lt;typeinfo&gt;<br/><br/>    int main()<br/>    {<br/>      std::cout &lt;&lt; "[auto.cpp]" &lt;&lt; std::endl;<br/><br/>      // Creating several auto-type variables<br/>      auto a = 1;<br/>      auto b = 1.0;<br/>      auto c = a + b;<br/>      auto d = {b, c};<br/><br/>      // Displaying the preceding variables' type<br/>      std::cout &lt;&lt; "type of a: " &lt;&lt; typeid(a).name() &lt;&lt; std::endl;<br/>      std::cout &lt;&lt; "type of b: " &lt;&lt; typeid(b).name() &lt;&lt; std::endl;<br/>      std::cout &lt;&lt; "type of c: " &lt;&lt; typeid(c).name() &lt;&lt; std::endl;<br/>      std::cout &lt;&lt; "type of d: " &lt;&lt; typeid(d).name() &lt;&lt; std::endl;<br/>      return 0;<br/>    }
</pre>
<p>As we can see in the preceding code, we have an <kbd>a</kbd> variable that will store the <kbd>integer</kbd> value and have a <kbd>b</kbd> variable that will store the <kbd>double</kbd> value. We calculate the addition of <kbd>a</kbd> and <kbd>b</kbd> and store the result in variable <kbd>c</kbd>. Here, we expect that <kbd>c</kbd> will store the <kbd>double</kbd> object since we add the <kbd>integer</kbd> and <kbd>double</kbd> object. The last is the <kbd>d</kbd> variable that will store the <kbd>initializer_list&lt;double&gt;</kbd> data type. When we run the preceding code, we will see the following output on the console:</p>
<div><img class=" image-border" src="img/5d5e1164-6f13-4afb-9011-c6444f0c3589.png"/></div>
<p>As can be seen in the preceding snapshot, we are just given the first character of the data type, such as <kbd>i</kbd> for <kbd>integer</kbd>, <kbd>d</kbd> for <kbd>double</kbd>, and <kbd>St16initializer_listIdE</kbd> for <kbd>initializer_list&lt;double&gt;</kbd>, that is the last lowercase <kbd>d</kbd> character that stands for <kbd>double</kbd>.</p>
<p>We may have to enable the <strong>Run-Time Type Information</strong> (<strong>RTTI</strong>) feature in our compiler options to retrieve the data type object. However, GCC has enabled the feature by default. Also, the output of the use of the <kbd>typeid()</kbd> function depends on the compiler. We may get the raw type name or just a symbol as we did in the preceding example.</p>
<p>Besides, for variable, as we discussed earlier, the <kbd>auto</kbd> keyword can also be applied to a function to deduce a function's return type automatically. Suppose we have the following trivial function named <kbd>add()</kbd> to calculate the addition of two parameters:</p>
<pre>
    int add(int i, int j)<br/>    {<br/>      return i + j;<br/>    }
</pre>
<p>We can refactor the preceding method to use the <kbd>auto</kbd> keyword, as we can see in the following lines of code:</p>
<pre>
    auto add(int i, int j)<br/>    {<br/>      return i + j;<br/>    }
</pre>
<p>Similar to the auto-type variable, the compiler can decide the correct return type based on the returned value of the function. And, as shown in the preceding code, the function will indeed return the integer value since we just add two integer values.</p>
<p>Another feature that uses the <kbd>auto</kbd> keyword in modern C++ is trailing the return type syntax. By using this feature, we can specify the return type, the rest of the function prototype, or function signature. From the preceding code, we can refactor it to use the feature as follows:</p>
<pre>
    auto add(int i, int j) -&gt; int<br/>    {<br/>      return i + j;<br/>    }
</pre>
<p>You might ask me why we have to specify the data type again after the arrow symbol (<kbd>-&gt;</kbd>), even though we have used the <kbd>auto</kbd> keyword. We will find the answer when we cover the <kbd>decltype</kbd> keyword in the next section. Also, by using this feature, we can now refactor the preceding <kbd>auto.cpp</kbd> code a little bit by modifying the syntax of the <kbd>main()</kbd> method, instead of the following syntax of <kbd>main()</kbd> function signature:</p>
<pre>
    int main()<br/>    {<br/>      // The body of the function<br/>    }
</pre>
<p>We can change the signature syntax into the following line of code:</p>
<pre>
    auto main -&gt; int<br/>    {<br/>      // The body of the function<br/>    }
</pre>
<p>Now, we will see all of our code in this book using this trailing return type feature to apply the modern C++ syntax.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Querying the type of an expression using the decltype keyword</h1>
                
            
            
                
<p>We discussed in the preceding section that the <kbd>auto</kbd> keyword can automatically deduce the type of the variable based on the type of values it stores. The keyword can also deduce the function's return type based on the type of its return value. Now, let's combine the <kbd>auto</kbd> keyword and the <kbd>decltype</kbd> keyword to gain the power of modern C++.</p>
<p>Before we combine the two keywords, we will find out what the <kbd>decltype</kbd> keyword is used for--it is used for asking the type of an object or an expression. Let's take a look at the following several lines of trivial variable declaration:</p>
<pre>
    const int func1();<br/>    const int&amp; func2();<br/>    int i;<br/><br/>    struct X { double d; };<br/>    const X* x = new X();
</pre>
<p>Now, based on the preceding code, we can declare other variables using the <kbd>decltype</kbd> keyword as follows:</p>
<pre>
    // Declaring const int variable<br/>    // using func1() type<br/>    decltype(func1()) f1;<br/><br/>    // Declaring const int&amp; variable<br/>    // using func2() type<br/>    decltype(func2()) f2;<br/><br/>    // Declaring int variable<br/>    // using i type<br/>    decltype(i) i1;<br/><br/>    // Declaring double variable<br/>    // using struct X type<br/>    decltype(x-&gt;d) d1; // type is double<br/>    decltype((x-&gt;d)) d2; // type is const double&amp;
</pre>
<p>As we can see in the preceding code, we can specify the type of an object based on another object's type. Now, let's suppose we need to refactor the preceding <kbd>add()</kbd> method to become a template. Without the <kbd>auto</kbd> and <kbd>decltype</kbd> keyword, we will have the following template implementation:</p>
<pre>
    template&lt;typename I, typename J, typename K&gt;<br/>    K add(I i, J j)<br/>    {<br/>      return i + j;<br/>    }
</pre>
<p>Fortunately, since the <kbd>auto</kbd> keyword can specify the return type of the function, which is a trailing return type, and the <kbd>decltype</kbd> keyword can deduce the type based on the expression, we can refactor the preceding template as follows:</p>
<pre>
    template&lt;typename I, typename J&gt;<br/>    auto add(I i, J j) -&gt; decltype(i + j)<br/>    {<br/>      return i + j;<br/>    }
</pre>
<p>To prove, let's compile and run the following <kbd>decltype.cpp</kbd> code. We will use the following template to calculate the addition of two different value types--<kbd>integer</kbd> and <kbd>double</kbd>:</p>
<pre>
    /* decltype.cpp */<br/>    #include &lt;iostream&gt;<br/><br/>    // Creating template<br/>    template&lt;typename I, typename J&gt;<br/>    auto add(I i, J j) -&gt; decltype(i + j)<br/>    {<br/>      return i + j;<br/>    }<br/><br/>    auto main() -&gt; int<br/>    {<br/>      std::cout &lt;&lt; "[decltype.cpp]" &lt;&lt; std::endl;<br/><br/>      // Consuming the template<br/>      auto d = add&lt;int, double&gt;(2, 2.5);<br/><br/>      // Displaying the preceding variables' type<br/>      std::cout &lt;&lt; "result of 2 + 2.5: " &lt;&lt; d &lt;&lt; std::endl;<br/><br/>      return 0;<br/>    }
</pre>
<p>The compilation process should run smoothly without error. We will see the following output on the screen if we run the preceding code:</p>
<div><img class=" image-border" src="img/9b573b77-6cc6-41a6-94cb-8fc04dd314c8.png"/></div>
<p>As we can see, we have successfully combined the <kbd>auto</kbd> and <kbd>decltype</kbd> keyword to create a template simpler than we usually do before the modern C++ is announced.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Pointing to a null pointer</h1>
                
            
            
                
<p>Another new feature in modern C++ is a keyword named <kbd>nullptr</kbd> that replaces the <kbd>NULL</kbd> macro to represent a null pointer. Now, there's no ambiguity in the use of the <kbd>NULL</kbd> macro for zero numeric or a null pointer. Let's suppose we have the following two method's signature in our declaration:</p>
<pre>
    void funct(const char *);<br/>    void funct(int)
</pre>
<p>The former function will pass a pointer as the argument and the latter will pass the integer number as its argument. Then, we invoke the <kbd>funct()</kbd> method and pass the <kbd>NULL</kbd> macro as the parameter, as shown here:</p>
<pre>
    funct(NULL);
</pre>
<p>What we intend to call is the former function. However, since we pass the <kbd>NULL</kbd> parameters, which is basically defined as <kbd>0</kbd>, the latter function will be invoked. In modern C++, we can use the <kbd>nullptr</kbd> keyword to ensure that we will pass a null pointer to the argument. The invocation of the <kbd>funct()</kbd> method should be as follows:</p>
<pre>
    funct(nullptr);
</pre>
<p>Now the compiler will invoke the former function since it passes a null pointer to the argument, and this is what we expect. There will be no ambiguity anymore, and it will avoid unnecessary future problems.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Returning an iterator using non-member begin() and end() function</h1>
                
            
            
                
<p>Prior to modern C++, to iterate a sequence, we call the <kbd>begin()</kbd> and <kbd>end()</kbd> member method of each container. For array, we can iterate its element by iterating the index. Since C++11, the language has a non-member function--<kbd>begin()</kbd> and <kbd>end()</kbd>--to retrieve the iterator of the sequence. Let's suppose we have an array of the following elements:</p>
<pre>
    int arr[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
</pre>
<p>When the language doesn't have the <kbd>begin()</kbd> and <kbd>end()</kbd> function, we need to iterate the elements of the array using the index we can see in the following lines of code:</p>
<pre>
    for (unsigned int i = 0; i &lt; sizeof(arr)/sizeof(arr[0]); ++i)<br/>    // Do something to the array
</pre>
<p>Fortunately, using the <kbd>begin()</kbd> and <kbd>end()</kbd> function, we can refactor the preceding <kbd>for</kbd> loop to become as follows:</p>
<pre>
    for (auto i = std::begin(arr); i != std::end(arr); ++i)<br/>    // Do something to the array
</pre>
<p>As we can see, the use of the <kbd>begin()</kbd> and <kbd>end()</kbd> function creates a compact code since we don't need to worry about the length of the array because the iterator pointer of <kbd>begin()</kbd> and <kbd>end()</kbd> will do it for us. For comparison, let's take a look at the following <kbd>begin_end.cpp</kbd> code:</p>
<pre class="mce-root">
    /* begin_end.cpp */<br/>    #include &lt;iostream&gt;<br/><br/>    auto main() -&gt; int<br/>    {<br/>      std::cout &lt;&lt; "[begin_end.cpp]" &lt;&lt; std::endl;<br/><br/>      // Declaring an array<br/>      int arr[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };<br/><br/>      // Displaying the array elements<br/>      // using conventional for-loop<br/>      std::cout &lt;&lt; "Displaying array element using conventional for-<br/>       loop";<br/>      std::cout &lt;&lt; std::endl;<br/>      for (unsigned int i = 0; i &lt; sizeof(arr)/sizeof(arr[0]); ++i)<br/>      std::cout &lt;&lt; arr[i] &lt;&lt; " ";<br/>      std::cout &lt;&lt; std::endl;<br/><br/>      // Displaying the array elements<br/>      // using non-member begin() and end()<br/>      std::cout &lt;&lt; "Displaying array element using non-member begin()<br/>       and end()";<br/>      std::cout &lt;&lt; std::endl;<br/>      for (auto i = std::begin(arr); i != std::end(arr); ++i)<br/>       std::cout &lt;&lt; *i &lt;&lt; " ";<br/>      std::cout &lt;&lt; std::endl;<br/><br/>      return 0;<br/>    }
</pre>
<p>To prove the preceding code, we can compile the code, and, when we run it, the following output should be displayed on the console screen:</p>
<div><img class=" image-border" src="img/3219ad51-9855-43ce-b596-536273d9c047.png"/></div>
<p>As we can see in the screenshot, we've got the exact same output when we use the conventional <kbd>for-loop</kbd> or <kbd>begin()</kbd> and <kbd>end()</kbd> functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Iterating over collections using range-based for loops</h1>
                
            
            
                
<p>In the modern C++, there is a new feature that is augmented to support the <kbd>for-each</kbd> technique to iterate over collections. This feature is useful if you want to do something to the elements of a collection or array without caring about the number of elements or the indexes. The syntax of the feature is also simple. Suppose we have an array named <kbd>arr</kbd> and we want to iterate each element using the <kbd>range-based for loop</kbd> technique; we can use the following syntax:</p>
<pre>
    for (auto a : arr)<br/>    // Do something with a
</pre>
<p>So, we can refactor our preceding <kbd>begin_end.cpp</kbd> code to use <kbd>range-based for loop</kbd> as we can see in the following code:</p>
<pre class="mce-root">
    /* range_based_for_loop.cpp */<br/>    #include &lt;iostream&gt;<br/><br/>    auto main() -&gt; int<br/>    {<br/>      std::cout &lt;&lt; "[range_based_for_loop.cpp]" &lt;&lt; std::endl;<br/><br/>      // Declaring an array<br/>      int arr[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};<br/><br/>      // Displaying the array elements<br/>      // using non-member begin() and end()<br/>      std::cout &lt;&lt; "Displaying array element using range-based for<br/>        loop";<br/>      std::cout &lt;&lt; std::endl;<br/>      <strong>for (auto a : arr) </strong><strong>std::cout &lt;&lt; a &lt;&lt; " ";</strong><br/>      std::cout &lt;&lt; std::endl;<br/><br/>      return 0;<br/>    }
</pre>
<p>The syntax we see in the preceding code is simpler now. If we compile the preceding code, we should find no error and, if we run the code, we should see the following output on the console screen:</p>
<div><img class=" image-border" src="img/3f3f2d37-a65c-491d-86e6-c0cc8523e391.png"/></div>
<p>We now have a new technique to iterate over the collection without caring about the indexes of the collection. We will keep using it in this book.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Leveraging the use of C++ language with the C++ Standard Libraries</h1>
                
            
            
                
<p>The C++ Standard Libraries are a powerful set of classes and functions that have many capabilities needed to create an application. They are controlled by the C++ ISO Standard Committee and is influenced by the <strong>Standard Template Libraries</strong> (<strong>STL</strong>), which were the generic libraries before C++11 was introduced. All features in Standard Libraries are declared in <kbd>std namespace</kbd> and no headers end in <kbd>.h</kbd> anymore (except 18 headers of the ISO C90 C Standard Library that is incorporated into the C++ Standard Libraries).</p>
<p>There are several header files containing the declaration of the C++ Standard Libraries. However, it is almost impossible to discuss all header files in these tiny chapters. We will, therefore, talk about some features that we will use most in our daily coding activities.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Placing any objects in the container</h1>
                
            
            
                
<p><strong>Container</strong> is an object that is used to store other objects and manage the memory that is used by the objects it contains. An array is a new feature added in C++11 to store the collection of specific data types. It is a sequence container since it stores the same data type objects and arranges them linearly. Let's take a look at the following code snippet:</p>
<pre class="mce-root">
    /* array.cpp */<br/>    #include &lt;array&gt;<br/>    #include &lt;iostream&gt;<br/><br/>    auto main() -&gt; int<br/>    {<br/>      std::cout &lt;&lt; "[array.cpp]" &lt;&lt; std::endl;<br/> <br/>      // Initializing an array containing five integer elements<br/>      std::array&lt;int, 10&gt; arr = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };<br/><br/>      // Displaying the original elements of the array<br/>      std::cout &lt;&lt; "Original Data : ";<br/>      for(auto a : arr) std::cout &lt;&lt; a &lt;&lt; " ";<br/>      std::cout &lt;&lt; std::endl;<br/><br/>      // Modifying the content of<br/>      // the 1st and 3rd element of the array<br/>      arr[1] = 9;<br/>      arr[3] = 7;<br/><br/>      // Displaying the altered array elements<br/>      std::cout &lt;&lt; "Manipulated Data: ";<br/>      for(auto a : arr) std::cout &lt;&lt; a &lt;&lt; " ";<br/>      std::cout &lt;&lt; std::endl;<br/><br/>      return 0;<br/>     }
</pre>
<p>As we can see in the preceding code, we instance a new array named <kbd>arr</kbd>, set its length as <kbd>10</kbd>, and only approve the <kbd>int</kbd> element. As we can guess, the output of the code is a line of numbers <kbd>0</kbd> through <kbd>9</kbd>, which is shown in the original data, and the other line will show the altered data, as we can see in the following screenshot:</p>
<div><img class=" image-border" src="img/9bf41be3-c581-4cf9-87d9-be35bc06f403.png"/></div>
<p>There is no performance issue if we declare an array using <kbd>std::array</kbd>; we use in the <kbd>array.cpp</kbd> code and compare it with a usual array as we use in the <kbd>begin_end.cpp</kbd> code. However, in modern C++, we are given a new array declaration that has a friendly value semantic, so that it can be passed to or returned from functions by value. Also, the interface of this new array declaration makes it more convenient to find the size, and use it with <strong>Standard Template Library</strong> (<strong>STL</strong>)-style iterator-based algorithms.</p>
<p>It is good to use an array as the container since we can store the data and manipulate them. We can also sort and find a specific element if we want. However, since the array is a compile-time non-resizable object, we have to decide the size of the array we intend to use at the very beginning as we cannot change the size later. In other words, we cannot insert or remove the element from the existing array. As a solution to this problem, and for the best practice of using the container as well, we can now use a <kbd>vector</kbd> to store our collection. Let's take a look at the following code:</p>
<pre class="mce-root">
    /* vector.cpp */<br/>    #include &lt;vector&gt;<br/>    #include &lt;iostream&gt;<br/><br/>    auto main() -&gt; int<br/>    {<br/>      std::cout &lt;&lt; "[vector.cpp]" &lt;&lt; std::endl;<br/><br/>      // Initializing a vector containing three integer elements<br/>      std::vector&lt;int&gt; vect = { 0, 1, 2 };<br/><br/>      // Displaying the original elements of the vector<br/>      std::cout &lt;&lt; "Original Data : ";<br/>      for (auto v : vect) std::cout &lt;&lt; v &lt;&lt; " ";<br/>      std::cout &lt;&lt; std::endl;<br/><br/>      // Adding two new data<br/>      vect.push_back(3);<br/>      vect.push_back(4);<br/><br/>      // Displaying the elements of the new vector<br/>      // and reverse the order<br/>      std::cout &lt;&lt; "New Data Added : ";<br/>      for (auto v : vect) std::cout &lt;&lt; v &lt;&lt; " ";<br/>      std::cout &lt;&lt; std::endl;<br/><br/>      // Modifying the content of<br/>      // the 2nd and 4th element of the vector<br/>      vect.at(2) = 5;<br/>      vect.at(4) = 6;<br/><br/>      // Displaying the altered array elements<br/>      std::cout &lt;&lt; "Manipulate Data: ";<br/>      for (auto v : vect) std::cout &lt;&lt; v &lt;&lt; " ";<br/>      std::cout &lt;&lt; std::endl;<br/><br/>      return 0;<br/>    }
</pre>
<p class="mce-root">Now, we have a <kbd>vector</kbd> instance in our preceding code instead of an <kbd>array</kbd> instance. As we can see, we give an additional value for the <kbd>vector</kbd> instance using the <kbd>push_back()</kbd> method. We can add the value anytime we want. The manipulation of each element is also easier since <kbd>vector</kbd> has an <kbd>at()</kbd> method that returns a reference to the element of the specific index. The following screenshot is what we will see as the output when running the code:</p>
<div><img class=" image-border" src="img/d6c12da0-75ee-450a-b324-a86e4bf59dad.png"/></div>
<p>It is better to always use the <kbd>at()</kbd> method instead of the <kbd>[]</kbd> operator when we want to access the specific element by its index in a <kbd>vector</kbd> instance. It's because, when we accidentally access the out of range position, the <kbd>at()</kbd> method will throw an <kbd>out_of_range</kbd> exception. Otherwise, the <kbd>[]</kbd> operator will give undefined behavior.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using algorithms</h1>
                
            
            
                
<p>We can sort the elements of the collection we have in <kbd>array</kbd> or <kbd>vector</kbd>, as well as find specific content of the element. For these purposes, we have to use the algorithm feature provided by the C++ Standard Library. Let's take a look at the following code to demonstrate the sorting element capability in the algorithm feature:</p>
<pre>
    /* sort.cpp */<br/>    #include &lt;vector&gt;<br/>    #include &lt;algorithm&gt;<br/>    #include &lt;iostream&gt;<br/><br/>    bool comparer(int a, int b)<br/>    {<br/>      return (a &gt; b);<br/>    }<br/><br/>    auto main() -&gt; int<br/>    {<br/>      std::cout &lt;&lt; "[sort.cpp]" &lt;&lt; std::endl;<br/><br/>      // Initializing a vector containing several integer elements<br/>      std::vector&lt;int&gt; vect = { 20, 43, 11, 78, 5, 96 };<br/><br/>      // Displaying the original elements of the vector<br/>      std::cout &lt;&lt; "Original Data : ";<br/>      for (auto v : vect)<br/>      std::cout &lt;&lt; v &lt;&lt; " ";<br/>      std::cout &lt;&lt; std::endl;<br/><br/>      // Sorting the vector element ascending<br/>      std::sort(std::begin(vect), std::end(vect));<br/><br/>      // Displaying the ascending sorted elements<br/>      // of the vector<br/>      std::cout &lt;&lt; "Ascending Sorted : ";<br/>      for (auto v : vect)<br/>      std::cout &lt;&lt; v &lt;&lt; " ";<br/>      std::cout &lt;&lt; std::endl;<br/><br/>      // Sorting the vector element descending<br/>      // using comparer<br/>      std::sort(std::begin(vect), std::end(vect), comparer);<br/><br/>      // Displaying the descending sorted elements<br/>      // of the vector<br/>      std::cout &lt;&lt; "Descending Sorted: ";<br/>      for (auto v : vect)<br/>      std::cout &lt;&lt; v &lt;&lt; " ";<br/>      std::cout &lt;&lt; std::endl;<br/><br/>      return 0;<br/>   }
</pre>
<p class="mce-root">As we see in the preceding code, we invoked the <kbd>sort()</kbd> method twice. First, we just supplied the range of the elements we wanted to sort. Then we added the comparison function, <kbd>comparer()</kbd>, to be provided to the <kbd>sort()</kbd> method to gain more flexibility the method has. The output we will see on the console from the preceding code is as follows:</p>
<div><img class=" image-border" src="img/a39ab3f7-55b8-4dda-8f2f-4d253d92f0d9.png"/></div>
<p>From the preceding screenshot, we can see that we have six elements in a <kbd>vector</kbd> at the beginning. We then sort the elements of the vector using a simple <kbd>sort()</kbd> method. Then, we invoke the <kbd>sort()</kbd> method again, but instead of a simple <kbd>sort()</kbd> method, we now supply <kbd>comparer()</kbd> to the <kbd>sort()</kbd> method. As a result, the vector elements will be sorted descendingly since the <kbd>comparer()</kbd> function looks for the greater value from two inputs.</p>
<p>Now, let's move to another capability the algorithm feature has, which is finding a particular element. Let's suppose we have the <kbd>Vehicle</kbd> class in our code. It has two private fields named <kbd>m_vehicleType</kbd> and <kbd>m_totalOfWheel</kbd>, and we can retrieve the value from the getter methods named <kbd>GetType()</kbd> and <kbd>GetNumOfWheel()</kbd> respectively. It also has two constructors, which are the default constructor and the user-defined one. The declaration of the class should be as follows:</p>
<pre>
    /* vehicle.h */<br/>    #ifndef __VEHICLE_H__<br/>    #define __VEHICLE_H__<br/><br/>    #include &lt;string&gt;<br/><br/>    class Vehicle<br/>    {<br/>      private:<br/>        std::string vehicleType;<br/>        int totalOfWheel;<br/><br/>      public:<br/>        Vehicle(<br/>          const std::string &amp;type,<br/>          int _wheel);<br/>        Vehicle();<br/>        ~Vehicle();<br/>        std::string GetType() const {return vehicleType;}<br/>        int GetNumOfWheel() const {return totalOfWheel;}<br/>    };<br/><br/>    #endif // End of __VEHICLE_H__
</pre>
<p>The implementation of the <kbd>Vehicle</kbd> class is as follows:</p>
<pre>
    /* vehicle.cpp */<br/>    #include "vehicle.h"<br/><br/>    using namespace std;<br/><br/>    // Constructor with default value for<br/>    // m_vehicleType and m_totalOfWheel<br/>    Vehicle::Vehicle() : m_totalOfWheel(0)<br/>    {<br/>    }<br/><br/>    // Constructor with user-defined value for<br/>    // m_vehicleType and m_totalOfWheel<br/>    Vehicle::Vehicle( const string &amp;type, int wheel) :<br/>     m_vehicleType(type),<br/>     m_totalOfWheel(wheel)<br/>    {<br/>    }<br/><br/>    // Destructor<br/>    Vehicle::~Vehicle()<br/>    {<br/>    }
</pre>
<p>We will store a collection of <kbd>Vehicle</kbd> in the <kbd>vector</kbd> container, and then we will search for some elements based on its property. The code will be as follows:</p>
<pre>
    /* find.cpp */<br/>    #include &lt;vector&gt;<br/>    #include &lt;algorithm&gt;<br/>    #include &lt;iostream&gt;<br/>    #include "../vehicle/vehicle.h"<br/><br/>    using namespace std;<br/>   <br/>    bool TwoWheeled(const Vehicle &amp;vehicle)<br/>    {<br/>      return _vehicle.GetNumOfWheel() == 2 ? <br/>        true : false;<br/>     }<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[find.cpp]" &lt;&lt; endl;<br/><br/>      // Initializing several Vehicle instances<br/>      Vehicle car("car", 4);<br/>      Vehicle motorcycle("motorcycle", 2);<br/>      Vehicle bicycle("bicycle", 2);<br/>      Vehicle bus("bus", 6);<br/>  <br/>      // Assigning the preceding Vehicle instances to a vector<br/>      vector&lt;Vehicle&gt; vehicles = { car, motorcycle, bicycle, bus };<br/><br/>      // Displaying the elements of the vector<br/>      cout &lt;&lt; "All vehicles:" &lt;&lt; endl;;<br/>      for (auto v : vehicles)<br/>        std::cout &lt;&lt; v.GetType() &lt;&lt; endl;<br/>      cout &lt;&lt; endl;<br/><br/>      // Displaying the elements of the vector<br/>      // which are the two-wheeled vehicles<br/>      cout &lt;&lt; "Two-wheeled vehicle(s):" &lt;&lt; endl;;<br/>      auto tw = find_if(<br/>                      begin(vehicles),<br/>                      end(vehicles),<br/>                      TwoWheeled);<br/>      while (tw != end(vehicles))<br/>      {<br/>        cout &lt;&lt; tw-&gt;GetType() &lt;&lt; endl ;<br/>        tw = find_if(++tw, end(vehicles), TwoWheeled);<br/>      }<br/>      cout &lt;&lt; endl;<br/><br/>      // Displaying the elements of the vector<br/>      // which are not the two-wheeled vehicles<br/>      cout &lt;&lt; "Not the two-wheeled vehicle(s):" &lt;&lt; endl;;<br/>      auto ntw = find_if_not(begin(vehicles),<br/>                           end(vehicles),<br/>                           TwoWheeled);<br/>      while (ntw != end(vehicles))<br/>      {<br/>        cout &lt;&lt; ntw-&gt;GetType() &lt;&lt; endl ;<br/>        ntw = find_if_not(++ntw, end(vehicles), TwoWheeled);<br/>      }<br/><br/>      return 0;<br/>     }
</pre>
<p>As we can see, we instance four <kbd>Vehicle</kbd> objects, then store them in <kbd>vector</kbd>. There, we try to find the vehicle that has two wheels. The <kbd>find_if()</kbd> function is used for this purpose. We also have the <kbd>TwoWheeled()</kbd> method to provide the comparison value. Since we are finding the two-wheeled vehicle, we will inspect the <kbd>totalOfWheel</kbd> variable in the <kbd>Vehicle</kbd> class by invoking the <kbd>GetNumOfWheel()</kbd> method. In contrast, if we want to find the element that doesn't conform to the comparison value, we can use the <kbd>find_if_not()</kbd> function, which had been added in C++11. The output we get should look like this:</p>
<div><img class=" image-border" src="img/7c5af549-86c7-4414-896e-e9fe96a9cb20.png"/></div>
<p>As we can see in the <kbd>vehicle.cpp</kbd> code and <kbd>find.cpp</kbd> code, we now add the <kbd>using namespace std;</kbd> line in the <kbd>*.cpp</kbd> files. We do this to make our coding activity become more productive since we don't have to type many words. In contrast, in <kbd>vehicle.h</kbd>, we still using <kbd>std::</kbd> followed by the methods or properties name rather than use the std namespace at the beginning. It's best practice to not declare <kbd>using namespace</kbd> in header files since the header files are the files we will deliver if we create some libraries for instances. The user of our library may have another method with the same name as the function our library has. It will definitely create conflict between these two functions.</p>
<p>Another algorithm feature we will use most is the <kbd>for_each</kbd> loop. Instead of using the <kbd>for</kbd> loop, the use of the <kbd>for_each</kbd> loop will make our code more concise in many cases. It's also simpler and less error prone than a <kbd>for</kbd> loop because we can define a specific function for the <kbd>for_each</kbd> loop. Now let's refactor our previous code to use the <kbd>for_each</kbd> loop. The code is written as follows:</p>
<pre>
    /* for_each.cpp */<br/>    #include &lt;vector&gt;<br/>    #include &lt;algorithm&gt;<br/>    #include &lt;iostream&gt;<br/>    #include "vehicle.h"<br/><br/>    using namespace std;<br/><br/>    void PrintOut(const Vehicle &amp;vehicle)<br/>    {<br/>      cout &lt;&lt; vehicle.GetType() &lt;&lt; endl;<br/>    }<br/><br/>    auto main() -&gt; int<br/>   {<br/>      cout &lt;&lt; "[for_each.cpp]" &lt;&lt; endl;<br/><br/>      // Initializing several Vehicle instances<br/>      Vehicle car("car", 4);<br/>      Vehicle motorcycle("motorcycle", 2);<br/>      Vehicle bicycle("bicycle", 2);<br/>      Vehicle bus("bus", 6);<br/><br/>      // Assigning the preceding Vehicle instances to a vector<br/>      vector&lt;Vehicle&gt; vehicles = { car, motorcycle, bicycle, bus };<br/><br/>      // Displaying the elements of the vector<br/>      cout &lt;&lt; "All vehicles:" &lt;&lt; endl;<br/>      for_each(begin(vehicles), end(vehicles), PrintOut);<br/><br/>      return 0;<br/>    }
</pre>
<p>Now, with the <kbd>for_each</kbd> loop, we have a clearer code. We only need to provide the first and last iterator and then pass a function--the <kbd>PrintOut()</kbd> function in this case--that will be invoked in each element in the range.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Simplifying the function notation using a Lambda expression</h1>
                
            
            
                
<p>The Lambda expression is an anonymous notation that represents something that performs an operation or calculation. In functional programming, the Lambda expression is useful to produce the first class and pure function, which we will discuss in separate chapters in this book. For now, let's familiarize ourselves with this new feature introduced in C++11 by investigating three basic parts of the Lambda expression:</p>
<ul>
<li>capturing list: []</li>
<li>parameter list: ()</li>
<li>body: {}</li>
</ul>
<p>The order of these three basic parts is as follows:</p>
<pre>
    [](){} 
</pre>
<p>The capturing list part is also used as a mark to identify the Lambda expression. It is a placeholder to value to be involved in the expression. The only capture defaults are the ampersand symbol (<kbd>&amp;</kbd>), which will implicitly capture the automatic variables by reference, and the equal sign (<kbd>=</kbd>), which will implicitly capture the automatic variables by copy (we will discuss it further in the upcoming section). The parameter list is similar to the capturing list in every function where we can pass the value to it. The body is the implementation of the function itself.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using the Lambda expression for a tiny function</h1>
                
            
            
                
<p>Imagine we have a tiny one-line function that we invoke only once. It's better if we write the operation of that function directly when we need it. We actually had this function in our previous example when discussing the C++ Standard Library. Just go back to the <kbd>for_each.cpp</kbd> file and we will find the <kbd>PrintOut()</kbd> function that is only invoked once by <kbd>for_each()</kbd>. We can make this <kbd>for_each</kbd> loop more readable if we use Lambda. Let's take a look at the following code snippet to examine how we refactor the <kbd>for_each.cpp</kbd> file:</p>
<pre class="mce-root">
    /* lambda_tiny_func.cpp */<br/>    #include &lt;vector&gt;<br/>    #include &lt;algorithm&gt;<br/>    #include &lt;iostream&gt;<br/>    #include "../vehicle/vehicle.h"<br/><br/>    using namespace std;<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[lambda_tiny_func.cpp]" &lt;&lt; endl;<br/><br/>      // Initializing several Vehicle instances<br/>      Vehicle car("car", 4);<br/>      Vehicle motorcycle("motorcycle", 2);<br/>      Vehicle bicycle("bicycle", 2);<br/>      Vehicle bus("bus", 6);<br/><br/>      // Assigning the preceding Vehicle instances to a vector<br/>      vector&lt;Vehicle&gt; vehicles = { car, motorcycle, bicycle, bus };<br/><br/>      // Displaying the elements of the vector<br/>      // using Lambda expression<br/>      cout &lt;&lt; "All vehicles:" &lt;&lt; endl;<br/>      for_each(<br/>             begin(vehicles),<br/>             end(vehicles),<br/>             [](const Vehicle &amp;vehicle){<br/>                 cout &lt;&lt; vehicle.GetType() &lt;&lt; endl;<br/>            });<br/><br/>      return 0;<br/>    }
</pre>
<p>As we can see, we have transformed the <kbd>PrintOut()</kbd> function that we used in the <kbd>for_each.cpp</kbd> file into a Lambda expression and passed it to the <kbd>for_each</kbd> loop. It will indeed give the same output as the <kbd>for_each.cpp</kbd> file does. However, now our code becomes more concise and readable.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using the Lambda expression for multiline functions</h1>
                
            
            
                
<p>The Lambda expression can also be used for multiline functions, so we can put the body of the function on it. This will make our code more readable as well. Let's make a new code. In that code, we will have an integer collection and an intent to inspect whether the selected element is the prime number or not. We can make a separate function, for instance, <kbd>PrintPrime()</kbd>, then invoke it. However, since the prime number checking operation is called only once, it's more readable if we transform it into a Lambda expression. The code should look like this:</p>
<pre class="mce-root">
    /* lambda_multiline_func.cpp */<br/>    #include &lt;vector&gt;<br/>    #include &lt;algorithm&gt;<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[lambda_multiline_func.cpp]" &lt;&lt; endl;<br/><br/>      // Initializing a vector containing integer element<br/>      vector&lt;int&gt; vect;<br/>      for (int i = 0; i &lt; 10; ++i)<br/>        vect.push_back(i);<br/><br/>      // Displaying whether or not the element is prime number<br/>      for_each(<br/>             begin(vect),<br/>             end(vect),<br/>             [](int n) {<br/>                cout &lt;&lt; n &lt;&lt; " is";<br/>                if(n &lt; 2)<br/>                {<br/>                  if(n == 0)<br/>                  cout &lt;&lt; " not";<br/>                }<br/>                else<br/>                {<br/>                  for (int j = 2; j &lt; n; ++j)<br/>                    {<br/>                       if (n % j == 0)<br/>                       {<br/>                         cout &lt;&lt; " not";<br/>                         break;<br/>                       }<br/>                   }<br/>                 }<br/><br/>                cout &lt;&lt; " prime number" &lt;&lt; endl;<br/>            });<br/><br/>        return 0;<br/>     }
</pre>
<p>The output we should see on the screen is as follows:</p>
<div><img class=" image-border" src="img/04d24940-d788-4a9d-a8cd-006f15cfc228.png"/></div>
<p>As we can see in the preceding screenshot, we have successfully identified the prime number by using the Lambda expression.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Returning a value from the Lambda expression</h1>
                
            
            
                
<p>Our two preceding samples of the Lambda expression are just for the purpose to print on console. It means the function does not need to return any value. However, we can ask the Lambda expression to return a value for an instance if we do the calculation inside the function and return the calculation result. Let's take a look at the following code to examine the use of this Lambda:</p>
<pre class="mce-root">
    /* lambda_returning_value.cpp */<br/>    #include &lt;vector&gt;<br/>    #include &lt;algorithm&gt;<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[lambda_returning_value.cpp]" &lt;&lt; endl;<br/><br/>      // Initializing a vector containing integer element<br/>      vector&lt;int&gt; vect;<br/>      for (int i = 0; i &lt; 10; ++i)<br/>        vect.push_back(i);<br/><br/>      // Displaying the elements of vect<br/>      cout &lt;&lt; "Original Data:" &lt;&lt; endl;<br/>      for_each(<br/>             begin(vect),<br/>             end(vect),<br/>             [](int n){<br/>                cout &lt;&lt; n &lt;&lt; " ";<br/>            });<br/>      cout &lt;&lt; endl;<br/><br/>      // Creating another vect2 vector<br/>      vector&lt;int&gt; vect2;<br/>      // Resize the size of vect2 exactly same with vect<br/>      vect2.resize(vect.size());<br/>      // Doubling the elements of vect and store to vect2<br/>      transform(<br/>              begin(vect),<br/>              end(vect),<br/>              begin(vect2),<br/>              [](int n) {<br/>                return n * n;<br/>            });<br/><br/>      // Displaying the elements of vect2<br/>      cout &lt;&lt; "Squared Data:" &lt;&lt; endl;<br/>      for_each(<br/>             begin(vect2),<br/>             end(vect2),<br/>             [](int n) {<br/>                cout &lt;&lt; n &lt;&lt; " ";<br/>            });<br/>      cout &lt;&lt; endl;<br/><br/>      // Creating another vect3 vector<br/>      vector&lt;double&gt; vect3;<br/>      // Resize the size of vect3 exactly same with vect<br/>      vect3.resize(vect.size());<br/>      // Finding the average of the elements of vect<br/>      // and store to vect2<br/>      transform(<br/>              begin(vect2),<br/>              end(vect2),<br/>              begin(vect3),<br/>              [](int n) -&gt; double {<br/>                return n / 2.0;<br/>            });<br/><br/>      // Displaying the elements of vect3<br/>      cout &lt;&lt; "Average Data:" &lt;&lt; endl;<br/>      for_each(<br/>             begin(vect3),<br/>             end(vect3),<br/>             [](double d) {<br/>                cout &lt;&lt; d &lt;&lt; " ";<br/>            });<br/>      cout &lt;&lt; endl;<br/><br/>      return 0;<br/>     }
</pre>
<p>When we use the <kbd>transform()</kbd> method in the preceding code, we have a Lambda expression that returns a value from the calculation of <kbd>n * n</kbd>. However, there's no return type stated in the expression. This is because we can omit the statement of the return type since the compiler has understood that the expression will return an <kbd>integer</kbd> value. So, after we have another vector, <kbd>vect2</kbd>, which has the same size as <kbd>vect</kbd>, we can invoke the <kbd>transform()</kbd> method along with the Lambda expression, and the value of <kbd>vect</kbd> will be doubled and stored in <kbd>vect2</kbd>.</p>
<p>We can, if we want to, specify the return type to the Lambda expression. As we can see in the preceding code, we transformed the <kbd>vect3</kbd> vector based on all values of the <kbd>vect</kbd> vector, but now we specify the return type to <kbd>double</kbd> using the arrow symbol (<kbd>-&gt;</kbd>). The result of the preceding code should be like the following screenshot:</p>
<div><img class=" image-border" src="img/e395ef78-2ab2-418d-a186-6fe8b1884f70.png"/></div>
<p>As we can see from the preceding screenshot, we have successfully found the doubled and average result using the Lambda expression.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Capturing a value to the Lambda expression</h1>
                
            
            
                
<p>In our previous Lambda expression examples, we keep the capturing part and the square bracket (<kbd>[]</kbd>) empty since the Lambda doesn't capture anything and doesn't have any extra member variable in the anonymous object generated by the compiler. We can also specify the object we want to capture in the Lambda expression by specifying it in this square bracket. Let's take a look at the following piece of code to go through the discussion:</p>
<pre class="mce-root">
    /* lambda_capturing_by_value.cpp */<br/>    #include &lt;vector&gt;<br/>    #include &lt;algorithm&gt;<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[lambda_capturing_by_value.cpp]" &lt;&lt; endl;<br/><br/>      // Initializing a vector containing integer element<br/>      vector&lt;int&gt; vect;<br/>      for (int i = 0; i &lt; 10; ++i)<br/>      vect.push_back(i);<br/><br/>      // Displaying the elements of vect<br/>      cout &lt;&lt; "Original Data:" &lt;&lt; endl;<br/>      for_each(<br/>             begin(vect),<br/>             end(vect),<br/>             [](int n){<br/>                cout &lt;&lt; n &lt;&lt; " ";<br/>             });<br/>      cout &lt;&lt; endl;<br/><br/>      // Initializing two variables<br/>      int a = 2;<br/>      int b = 8;<br/><br/>      // Capturing value explicitly from the two variables<br/>      cout &lt;&lt; "Printing elements between " &lt;&lt; a;<br/>      cout &lt;&lt; " and " &lt;&lt; b &lt;&lt; " explicitly [a,b]:" &lt;&lt; endl;<br/>      for_each(<br/>             begin(vect),<br/>             end(vect),<br/>             [a,b](int n){<br/>                if (n &gt;= a &amp;&amp; n &lt;= b)<br/>                cout &lt;&lt; n &lt;&lt; " ";<br/>             });<br/>      cout &lt;&lt; endl;<br/><br/>      // Modifying variable a and b<br/>      a = 3;<br/>      b = 7;<br/><br/>      // Capturing value implicitly from the two variables<br/>      cout &lt;&lt; "printing elements between " &lt;&lt; a;<br/>      cout &lt;&lt; " and " &lt;&lt; b &lt;&lt; " implicitly[=]:" &lt;&lt; endl;<br/>      for_each(<br/>             begin(vect),<br/>             end(vect),<br/>             [=](int n){<br/>                if (n &gt;= a &amp;&amp; n &lt;= b)<br/>                cout &lt;&lt; n &lt;&lt; " ";<br/>            });<br/>      cout &lt;&lt; endl;<br/><br/>      return 0;<br/>    }
</pre>
<p>In the preceding code, we will try to capture the value in the Lambda expression, explicitly and implicitly. Let's suppose we have two variables, <kbd>a</kbd> and <kbd>b</kbd>, and we want to explicitly capture the values, we can specify them in the Lambda expression using the <kbd>[a,b]</kbd> statement, and then using the values inside the function body. Moreover, if we wish to capture the value implicitly, just use <kbd>[=]</kbd> for the capturing part and then the expression will know which variable we intend to use when we specify them in the function body. If we run the preceding code, we will get the following output on the screen:</p>
<div><img class=" image-border" src="img/f55d1c5a-b38f-4bed-a8e2-b2e2945878c8.png"/></div>
<p>We can also mutate the state of the values we capture without modifying the value outside the Lambda expression function body. For this purpose, we can use the same techniques as used previously, and add the <kbd>mutable</kbd> keyword as shown in the following block of code:</p>
<pre class="mce-root">
    /* lambda_capturing_by_value_mutable.cpp */<br/>    #include &lt;vector&gt;<br/>    #include &lt;algorithm&gt;<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[lambda_capturing_by_value_mutable.cpp]" &lt;&lt; endl;<br/><br/>      // Initializing a vector containing integer element<br/>      vector&lt;int&gt; vect;<br/>      for (int i = 0; i &lt; 10; ++i)<br/>        vect.push_back(i);<br/><br/>      // Displaying the elements of vect<br/>      cout &lt;&lt; "Original Data:" &lt;&lt; endl;<br/>      for_each(<br/>             begin(vect),<br/>             end(vect),<br/>             [](int n){<br/>                 cout &lt;&lt; n &lt;&lt; " ";<br/>            });<br/>      cout &lt;&lt; endl;<br/><br/>      // Initializing two variables<br/>      int a = 1;<br/>      int b = 1;<br/><br/>      // Capturing value from the two variables<br/>      // without mutate them<br/>      for_each(<br/>             begin(vect),<br/>             end(vect),<br/>             [=](int&amp; x) mutable {<br/>                 const int old = x;<br/>                 x *= 2;<br/>                 a = b;<br/>                 b = old;<br/>             });<br/><br/>      // Displaying the elements of vect<br/>      cout &lt;&lt; "Squared Data:" &lt;&lt; endl;<br/>      for_each(<br/>             begin(vect),<br/>             end(vect),<br/>             [](int n) {<br/>                  cout &lt;&lt; n &lt;&lt; " ";<br/>            });<br/>      cout &lt;&lt; endl &lt;&lt; endl;<br/><br/>      // Displaying value of variable a and b<br/>      cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; endl;<br/>      cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; endl;<br/><br/>      return 0;<br/>    }
</pre>
<p>The preceding code will double the element of the <kbd>vect</kbd> vector. It uses capturing by value in the Lambda expression and also the <kbd>mutable</kbd> keyword. As we can see, we passed the vector element by reference <kbd>(int&amp; x)</kbd> and multiplied it by two, then changed the value of <kbd>a</kbd> and <kbd>b</kbd>. However, since we use the <kbd>mutable</kbd> keyword, the final result of <kbd>a</kbd> and <kbd>b</kbd> will remain the same, although, we have passed the vector by reference. The output on the console looks like the following screenshot:</p>
<div><img class=" image-border" src="img/a1a58756-c71c-4554-afd8-05f6e71dff45.png"/></div>
<p>If we want to change the value of the <kbd>a</kbd> and <kbd>b</kbd> variables, we have to use the Lambda expression to capture by reference. We can do this by passing the reference to the angle bracket in the Lambda expression, for instance, <kbd>[&amp;a, &amp;b]</kbd>. For more detail, let's take a look at the following piece of code:</p>
<pre class="mce-root">
    /* lambda_capturing_by_reference.cpp */<br/>    #include &lt;vector&gt;<br/>    #include &lt;algorithm&gt;<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[lambda_capturing_by_reference.cpp]" &lt;&lt; endl;<br/><br/>      // Initializing a vector containing integer element<br/>      vector&lt;int&gt; vect;<br/>      for (int i = 0; i &lt; 10; ++i)<br/>        vect.push_back(i);<br/><br/>      // Displaying the elements of vect<br/>      cout &lt;&lt; "Original Data:" &lt;&lt; endl;<br/>      for_each(<br/>             begin(vect),<br/>             end(vect),<br/>             [](int n){<br/>                 cout &lt;&lt; n &lt;&lt; " ";<br/>            });<br/>      cout &lt;&lt; endl;<br/><br/>      // Initializing two variables<br/>      int a = 1;<br/>      int b = 1;<br/><br/>      // Capturing value from the two variables<br/>      // and mutate them<br/>      for_each(<br/>             begin(vect),<br/>             end(vect),<br/>             [&amp;a, &amp;b](int&amp; x){<br/>                 const int old = x;<br/>                 x *= 2;<br/>                 a = b;<br/>                 b = old;<br/>            });<br/><br/>      // Displaying the elements of vect<br/>      cout &lt;&lt; "Squared Data:" &lt;&lt; endl;<br/>      for_each(<br/>             begin(vect),<br/>             end(vect),<br/>             [](int n) {<br/>                 cout &lt;&lt; n &lt;&lt; " ";<br/>            });<br/>      cout &lt;&lt; endl &lt;&lt; endl;<br/><br/>      // Displaying value of variable a and b<br/>      cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; endl;<br/>      cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; endl;<br/><br/>      return 0;<br/>     }
</pre>
<p>The preceding code has the same behavior with the <kbd>lambda_capturing_by_value_mutable.cpp</kbd> file that will double the element of the <kbd>vect</kbd> vector. However, by capturing by reference, it now also modifies the value of <kbd>a</kbd> and <kbd>b</kbd> when they are processed in the <kbd>for_each</kbd> loop. The <kbd>a</kbd> and <kbd>b</kbd> values will be changed at the end of the code, as we can see in the following screenshot:</p>
<div><img class=" image-border" src="img/7d62a43b-5efe-443e-899c-c80c88f26608.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Preparing the value using initialization captures</h1>
                
            
            
                
<p>Another great feature of the Lambda expression coming up in C++14 is its initialization captures. The expression can capture a value of the variable and assign it to the expression's variable. Let's take a look at the following piece of code implementing the initialization captures:</p>
<pre class="mce-root">
    /* lambda_initialization_captures.cpp */<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[lambda_initialization_captures.cpp]" &lt;&lt; endl;<br/><br/>      // Initializing a variable<br/>      int a = 5;<br/>      cout &lt;&lt; "Initial a = " &lt;&lt; a &lt;&lt; endl;<br/><br/>      // Initializing value to lambda using the variable<br/>      auto myLambda = [&amp;x = a]() { x += 2; };<br/><br/>      // Executing the Lambda<br/>      myLambda();<br/><br/>      // Displaying a new value of the variable<br/>      cout &lt;&lt; "New a = " &lt;&lt; a &lt;&lt; endl;<br/><br/>      return 0;<br/>     }
</pre>
<p>As we can see in the preceding code, we have an int variable named <kbd>a</kbd> with the value <kbd>5</kbd>. The Lambda expression, <kbd>myLambda</kbd>, then captures the <kbd>a</kbd> value and executes it in the code. The result is that now the <kbd>a</kbd> value will be <kbd>7</kbd> since it is added by <kbd>2</kbd>. The following output screenshot should appear in our console window when we run the preceding code:</p>
<div><img class=" image-border" src="img/66131890-ed47-4d35-93cc-c79b68cbd840.png"/></div>
<p>From the preceding snapshot, we see that we can prepare the value to be included in the calculation inside the Lambda expression.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Writing a generic Lambda expression to be used many times with many different data types</h1>
                
            
            
                
<p>Before C++14, we have to specifically state the type of the parameter list. Fortunately, now in C++14, Lambda expressions accept <kbd>auto</kbd> as a valid parameter type. Therefore, we can now build a generic Lambda expression as demonstrated in the following code. In that code, we have only one Lambda expression to find out which is the greatest value between two numbers passed to the expression. We will use the <kbd>auto</kbd> keyword in parameter declaration so it can be passed by any data type. Therefore, the <kbd>findMax()</kbd> function parameters can be passed by both the <kbd>int</kbd> and <kbd>float</kbd> data type. The code should be as follows:</p>
<pre class="mce-root">
    /* lambda_expression_generic.cpp */<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[lambda_expression_generic.cpp]" &lt;&lt; endl;<br/> <br/>      // Creating a generic lambda expression<br/>      auto findMax = [](auto &amp;x, auto &amp;y){<br/>        return x &gt; y ? x : y; };<br/><br/>      // Initializing various variables<br/>      int i1 = 5, i2 = 3;<br/>      float f1 = 2.5f, f2 = 2.05f;<br/><br/>      // Consuming generic lambda expression<br/>      // using integer data type<br/>      cout &lt;&lt; "i1 = 5, i2 = 3" &lt;&lt; endl;<br/>      cout &lt;&lt; "Max: " &lt;&lt; findMax(i1, i2) &lt;&lt; endl &lt;&lt; endl;<br/><br/>      // Consuming generic lambda expression<br/>      // using double data type<br/>      cout &lt;&lt; "f1 = 2.5f, f2 = 2.05f" &lt;&lt; endl;<br/>      cout &lt;&lt; "Max: " &lt;&lt; findMax(f1, f2) &lt;&lt; endl &lt;&lt; endl;<br/><br/>      return 0;<br/>     }
</pre>
<p>The output we will see on the console should be as follows:</p>
<div><img class=" image-border" src="img/f2d0eb85-dba1-4aa5-bd8e-445522a4e8a2.png"/></div>
<p>The C++17 language plans to introduce two new features for the Lambda expression--they are capturing <kbd>*this</kbd>, which allows the expression to capture the enclosing object by copy, and the <kbd>constexpr</kbd> Lambda expressions, which allows us to use the result of the Lambda expressions and generate <kbd>constexpr</kbd> objects at compile time. However, since C++17 has not been released yet, we cannot try it for now.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Avoiding manual memory management with smart pointers</h1>
                
            
            
                
<p>The smart pointers are highly useful and have an essential knowledge in using C++ efficiently. C++11 added many new abilities for the smart pointer we can find in the <kbd>memory</kbd> header file. For a long time, before C++11, we used <kbd>auto_ptr</kbd> as a smart pointer. However, it was quite unsafe since it had incompatible copy semantics. It's also deprecated now, and we should not use it anymore. Fortunately, C++ has presented <kbd>unique_ptr</kbd>, which has a similar functionality, but with additional features, such as adding <kbd>deleters</kbd> and support for arrays. Anything we can do with <kbd>auto_pt</kbd>, we can and should do with <kbd>unique_ptr</kbd> instead. We will discuss <kbd>unique_ptr</kbd> in depth along with other new smart pointers in C++11--<kbd>shared_ptr</kbd> and <kbd>weak_ptr</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Replacing a raw pointer using unique_ptr</h1>
                
            
            
                
<p>The next pointer we will see is the <kbd>unique_ptr</kbd> pointer. It is fast, efficient, and a near drop-in replacement for raw or naked pointers. It provides exclusive ownership semantics, which exclusively owns the object that it points to. By its exclusiveness, it can destroy the object when its destructor is called if it has a non-null pointer. It also cannot be copied due to its exclusiveness. It has no copy constructor and copy assignment. Although it cannot be copied, it can be moved since it provides a move constructor and a move assignment.</p>
<p>These are the methods we can use to construct <kbd>unique_ptr</kbd>:</p>
<pre>
    auto up1 = unique_ptr&lt;int&gt;{};<br/>    auto up2 = unique_ptr&lt;int&gt;{ nullptr };<br/>    auto up3 = unique_ptr&lt;int&gt;{ new int { 1234 } };
</pre>
<p>Based on the preceding code, <kbd>up1</kbd> and <kbd>up2</kbd> will construct two new <kbd>unique_ptr</kbd> that point to nothing (null), whereas <kbd>up3</kbd> will point to the address that holds the <kbd>1234</kbd> value. However, C++14 adds a new library function to construct <kbd>unique_ptr</kbd>, that is, <kbd>make_unique</kbd>. So, we can construct a new <kbd>unique_ptr</kbd> pointer as follows:</p>
<pre>
    auto up4 = make_unique&lt;int&gt;(1234);
</pre>
<p>The <kbd>up4</kbd> variable will also point to the address that holds the <kbd>1234</kbd> value.</p>
<p>Now, let's take a look at the following block of code:</p>
<pre>
    /* unique_ptr_1.cpp */<br/>    #include &lt;memory&gt;<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    struct BodyMass<br/>    {<br/>      int Id;<br/>      float Weight;<br/><br/>      BodyMass(int id, float weight) :<br/>        Id(id),<br/>        Weight(weight)<br/>        {<br/>          cout &lt;&lt; "BodyMass is constructed!" &lt;&lt; endl;<br/>          cout &lt;&lt; "Id = " &lt;&lt; Id &lt;&lt; endl;<br/>          cout &lt;&lt; "Weight = " &lt;&lt; Weight &lt;&lt; endl;<br/>        }<br/>       <br/>       ~BodyMass()<br/>       {<br/>         cout &lt;&lt; "BodyMass is destructed!" &lt;&lt; endl;<br/>       }<br/>     };<br/><br/>     auto main() -&gt; int<br/>     {<br/>       cout &lt;&lt; "[unique_ptr_1.cpp]" &lt;&lt; endl;<br/>       auto myWeight = make_unique&lt;BodyMass&gt;(1, 165.3f);<br/>       cout &lt;&lt; endl &lt;&lt; "Doing something!!!" &lt;&lt; endl &lt;&lt; endl;<br/>       return 0;<br/>     }
</pre>
<p>We try to construct a new <kbd>unique_ptr</kbd> pointer that points to the address that holds a <kbd>BodyMass</kbd> data type. In <kbd>BodyMass</kbd>, we have a constructor as well as a destructor. Now, let's see how the <kbd>unique_ptr</kbd> pointer works by running the preceding code. The output we get on the screen should be like the following screenshot:</p>
<div><img class=" image-border" src="img/1f91c15d-0216-4193-9396-a4d0aba1463d.png"/></div>
<p>As we can see in the preceding screenshot, the constructor is invoked when we construct <kbd>unique_ptr</kbd>. Moreover, unlike the traditional C++ language, where we have to free the memory up when we use a pointer, in modern C++, the memory will be freed up automatically when it is out of scope. We can see that the destructor of <kbd>BodyMass</kbd> is invoked when the program exits, which means <kbd>myWeight</kbd> is out of scope.</p>
<p>Now, let's test the exclusiveness of <kbd>unique_ptr</kbd> by analyzing the following code snippet:</p>
<pre>
    /* unique_ptr_2.cpp */<br/>    #include &lt;memory&gt;<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/>     <br/>    struct BodyMass<br/>    {<br/>      int Id;<br/>      float Weight;<br/><br/>      BodyMass(int id, float weight) :<br/>        Id(id), <br/>        Weight(weight)<br/>        {<br/>          cout &lt;&lt; "BodyMass is constructed!" &lt;&lt; endl;<br/>          cout &lt;&lt; "Id = " &lt;&lt; Id &lt;&lt; endl;<br/>          cout &lt;&lt; "Weight = " &lt;&lt; Weight &lt;&lt; endl;<br/>        }<br/><br/><strong>      BodyMass(const BodyMass &amp;other) :</strong><br/><strong>        Id(other.Id),</strong><br/><strong>        Weight(other.Weight)</strong><br/><strong>        {</strong><br/><strong>          cout &lt;&lt; "BodyMass is copy constructed!" &lt;&lt; endl;</strong><br/><strong>          cout &lt;&lt; "Id = " &lt;&lt; Id &lt;&lt; endl;</strong><br/><strong>          cout &lt;&lt; "Weight = " &lt;&lt; Weight &lt;&lt; endl;</strong><br/><strong>        }</strong><br/>      <br/>      ~BodyMass()<br/>       {<br/>          cout &lt;&lt; "BodyMass is destructed!" &lt;&lt; endl;<br/>       }<br/>    };<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[unique_ptr_2.cpp]" &lt;&lt; endl;<br/><br/>      auto myWeight = make_unique&lt;BodyMass&gt;(1, 165.3f);<br/><br/>      // The compiler will forbid to create another pointer<br/>      // that points to the same allocated memory/object<br/>      // since it's unique pointer<br/>      //auto myWeight2 = myWeight;<br/><br/>      // However, we can do the following expression<br/>      // since it actually copies the object that has been allocated<br/>      // (not the unique_pointer)<br/>      auto copyWeight = *myWeight;<br/> <br/>      return 0;<br/>    }
</pre>
<p>As we can see in the preceding code, we see that we can't assign the <kbd>unique_ptr</kbd> instance to another pointer since it will break the exclusiveness of <kbd>unique_ptr</kbd>. The compiler will throw an error if we make the following expression:</p>
<pre>
    auto myWeight2 = myWeight;
</pre>
<p>However, we can assign the value of the <kbd>unique_ptr</kbd> to another object since it has been allocated. To prove it, we have added a copy constructor to log when the following expression is executed:</p>
<pre>
    auto copyWeight = *myWeight;
</pre>
<p>If we run the preceding <kbd>unique_ptr_2.cpp</kbd> code, we will see the following output on the screen:</p>
<div><img class=" image-border" src="img/f33ba25b-3a90-47b9-a234-0d796c2c263e.png"/></div>
<p>As we can see in the preceding screenshot, the copy constructor is called when the copy assignment is executed. It proves that we can copy the value of the <kbd>unique_ptr</kbd> object but not the object itself.</p>
<p>As we discussed earlier, <kbd>unique_ptr</kbd> has moved the constructor, although it has no copy constructor. The use of this construction can be found in the following piece of code:</p>
<pre>
    /* unique_ptr_3.cpp */<br/>    #include &lt;memory&gt;<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    struct BodyMass<br/>    {<br/>      int Id;<br/>      float Weight;<br/><br/>      BodyMass(int id, float weight) :<br/>        Id(id), <br/>        Weight(weight)<br/>        {<br/>          cout &lt;&lt; "BodyMass is constructed!" &lt;&lt; endl;<br/>          cout &lt;&lt; "Id = " &lt;&lt; Id &lt;&lt; endl;<br/>          cout &lt;&lt; "Weight = " &lt;&lt; Weight &lt;&lt; endl;<br/>        }<br/><br/>      ~BodyMass()<br/>       {<br/>         cout &lt;&lt; "BodyMass is destructed!" &lt;&lt; endl;<br/>       }<br/>    };<br/><br/>    unique_ptr&lt;BodyMass&gt; GetBodyMass()<br/>    {<br/>      return make_unique&lt;BodyMass&gt;(1, 165.3f);<br/>    }<br/><br/>    unique_ptr&lt;BodyMass&gt; UpdateBodyMass(<br/>      unique_ptr&lt;BodyMass&gt; bodyMass)<br/>      {<br/>        bodyMass-&gt;Weight += 1.0f;<br/>        return bodyMass;<br/>      }<br/><br/>     auto main() -&gt; int<br/>     {<br/>       cout &lt;&lt; "[unique_ptr_3.cpp]" &lt;&lt; endl;<br/><br/>       auto myWeight = GetBodyMass();<br/><br/>       cout &lt;&lt; "Current weight = " &lt;&lt; myWeight-&gt;Weight &lt;&lt; endl;<br/><br/>       myWeight = UpdateBodyMass(move(myWeight));<br/>   <br/>       cout &lt;&lt; "Updated weight = " &lt;&lt; myWeight-&gt;Weight &lt;&lt; endl;<br/><br/>       return 0;<br/>     }
</pre>
<p>In the preceding code, we have two new functions--<kbd>GetBodyMass()</kbd> and <kbd>UpdateBodyMass()</kbd>. We construct a new <kbd>unique_ptr</kbd> object from the <kbd>GetBodyMass()</kbd> function, then we update the value of its <em>Weight</em> using the <kbd>UpdateBodyMass()</kbd> function. We can see that we use the <kbd>move</kbd> function when we pass an argument to the <kbd>UpdateBodyMass()</kbd> function. It's because <kbd>unique_ptr</kbd> has no copy constructor, and it has to be moved in order to update the value of its property. The screen output of the preceding code is as follows:</p>
<div><img class=" image-border" src="img/5188478c-d944-4612-b5cf-2b73c89a204d.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Sharing objects using shared_ptr</h1>
                
            
            
                
<p>In contrast to <kbd>unique_ptr</kbd>, <kbd>shared_ptr</kbd> implements shared ownership semantics, so it offers the ability of copy constructor and copy assignment. Although they have a difference in the implementation, <kbd>shared_ptr</kbd> is actually the counted version of <kbd>unique_ptr</kbd>. We can call the <kbd>use_count()</kbd> method to find out the counter value of the <kbd>shared_ptr</kbd> reference. Each instance of the <kbd>shared_ptr</kbd> valid object is counted as one. We can copy the <kbd>shared_ptr</kbd> instance to other <kbd>shared_ptr</kbd> variables and the reference count will be incremented. When a <kbd>shared_ptr</kbd> object is destroyed, the destructor decrements the reference count. The object will be deleted only if the count reaches zero. Now let's examine the following <kbd>shared_ptr</kbd> code:</p>
<pre>
    /* shared_ptr_1.cpp */<br/>    #include &lt;memory&gt;<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[shared_ptr_1.cpp]" &lt;&lt; endl;<br/><br/>      auto sp1 = shared_ptr&lt;int&gt;{};<br/><br/>      if(sp1)<br/>         cout &lt;&lt; "sp1 is initialized" &lt;&lt; endl;<br/>      else<br/>         cout &lt;&lt; "sp1 is not initialized" &lt;&lt; endl;<br/>      cout &lt;&lt; "sp1 pointing counter = " &lt;&lt; sp1.use_count() &lt;&lt; endl;<br/>      if(sp1.unique())<br/>         cout &lt;&lt; "sp1 is unique" &lt;&lt; endl;<br/>      else<br/>        cout &lt;&lt; "sp1 is not unique" &lt;&lt; endl;<br/>      cout &lt;&lt; endl;<br/>    <br/>      sp1 = make_shared&lt;int&gt;(1234);<br/>  <br/>      if(sp1)<br/>        cout &lt;&lt; "sp1 is initialized" &lt;&lt; endl;<br/>      else<br/>        cout &lt;&lt; "sp1 is not initialized" &lt;&lt; endl;<br/>      cout &lt;&lt; "sp1 pointing counter = " &lt;&lt; sp1.use_count() &lt;&lt; endl;<br/>      if(sp1.unique())<br/>        cout &lt;&lt; "sp1 is unique" &lt;&lt; endl;<br/>      else<br/>        cout &lt;&lt; "sp1 is not unique" &lt;&lt; endl;<br/>      cout &lt;&lt; endl;<br/><br/>      auto sp2 = sp1;<br/>  <br/>      cout &lt;&lt; "sp1 pointing counter = " &lt;&lt; sp1.use_count() &lt;&lt; endl;<br/>      if(sp1.unique())<br/>        cout &lt;&lt; "sp1 is unique" &lt;&lt; endl;<br/>      else<br/>        cout &lt;&lt; "sp1 is not unique" &lt;&lt; endl;<br/>      cout &lt;&lt; endl;<br/><br/>      cout &lt;&lt; "sp2 pointing counter = " &lt;&lt; sp2.use_count() &lt;&lt; endl;<br/>      if(sp2.unique())<br/>        cout &lt;&lt; "sp2 is unique" &lt;&lt; endl;<br/>      else<br/>        cout &lt;&lt; "sp2 is not unique" &lt;&lt; endl;<br/>      cout &lt;&lt; endl;<br/><br/>      sp2.reset();<br/><br/>      cout &lt;&lt; "sp1 pointing counter = " &lt;&lt; sp1.use_count() &lt;&lt; endl;<br/>      if(sp1.unique())<br/>        cout &lt;&lt; "sp1 is unique" &lt;&lt; endl;<br/>      else<br/>        cout &lt;&lt; "sp1 is not unique" &lt;&lt; endl;<br/>      cout &lt;&lt; endl;<br/><br/>      return 0;<br/>    }
</pre>
<p>Before we examine each line of the preceding code, let's take a look at the following output that should appear on the console window:</p>
<div><img class=" image-border" height="264" src="img/88c9cd88-ace1-4cb8-a3bf-bd423b32376a.png" width="526"/></div>
<p>First, we create a <kbd>shared_ptr</kbd> object named <kbd>sp1</kbd> without instantiating it. From the console, we see that <kbd>sp1</kbd> is not initialized and the counter is still <kbd>0</kbd>. It is also not unique since the pointer is pointed to nothing. We then construct <kbd>sp1</kbd> using the <kbd>make_shared</kbd> method. Now, <kbd>sp1</kbd> is initialized and the counter becomes <kbd>1</kbd>. It also becomes unique since it's only one of the <kbd>shared_ptr</kbd> object (proven by the value of the counter that is <kbd>1</kbd>). Next, we create another variable named <kbd>sp2</kbd>, and copy <kbd>sp1</kbd> to it. As a result, <kbd>sp1</kbd> and <kbd>sp2</kbd> now share the same object proven by the counter and the uniqueness value. Then, invoking the <kbd>reset()</kbd> method in <kbd>sp2</kbd> will destroy the object of <kbd>sp2</kbd>. Now, the counter of <kbd>sp1</kbd> becomes <kbd>1</kbd>, and it is unique again.</p>
<p>In the <kbd>shared_ptr_1.cpp</kbd> code, we declare the <kbd>unique_ptr</kbd> object using <kbd>shared_ptr&lt;int&gt;</kbd>, then invoke <kbd>make_shared&lt;int&gt;</kbd> to instance the pointer. It's because we just need to analyze the <kbd>shared_ptr</kbd> behavior. However, we should use <kbd>make_shared&lt;&gt;</kbd> for shared pointers since it has to keep the reference counter somewhere in memory and allocates the counter and memory for objects together instead of two separate allocations.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Tracking the objects using a weak_ptr pointer</h1>
                
            
            
                
<p>We have discussed the <kbd>shared_ptr</kbd> in the preceding section. The pointer is actually a little bit fat pointer. It logically points to two objects, the object being managed and the pointing counter using the <kbd>use_count()</kbd> method. Every <kbd>shared_ptr</kbd> basically has a strong reference count that prevents the object from being deleted and a weak reference count that does not prevent the object being deleted if the <kbd>shared_ptr</kbd> object's use count reaches 0, although we don't even use the weak reference count. For this reason, we can use only one reference count so we can use the <kbd>weak_ptr</kbd> pointer. The <kbd>weak_ptr</kbd> pointer refers to an object that is managed by <kbd>shared_ptr</kbd>. The advantage of <kbd>weak_ptr</kbd> is that it can be used to refer to an object, but we can only access it if the object still exists and without preventing the object from being deleted by some other reference holder if the strong reference count reaches zero. It is useful when we deal with data structures. Let's take a look at the following block of code to analyze the use of <kbd>weak_ptr</kbd>:</p>
<pre>
    /* weak_ptr_1.cpp */<br/>    #include &lt;memory&gt;<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[weak_ptr_1.cpp]" &lt;&lt; endl;<br/><br/>      auto sp = make_shared&lt;int&gt;(1234);<br/><br/>      auto wp = weak_ptr&lt;int&gt;{ sp };<br/> <br/>      if(wp.expired())<br/>       cout &lt;&lt; "wp is expired" &lt;&lt; endl;<br/>      else<br/>       cout &lt;&lt; "wp is not expired" &lt;&lt; endl;<br/>      cout &lt;&lt; "wp pointing counter = " &lt;&lt; wp.use_count() &lt;&lt; endl;<br/>      if(auto locked = wp.lock())<br/>       cout &lt;&lt; "wp is locked. Value = " &lt;&lt; *locked &lt;&lt; endl;<br/>      else<br/>      {<br/>        cout &lt;&lt; "wp is unlocked" &lt;&lt; endl;<br/>        wp.reset();<br/>      }<br/>      cout &lt;&lt; endl;<br/> <br/>      sp = nullptr;<br/><br/>      if(wp.expired())<br/>       cout &lt;&lt; "wp is expired" &lt;&lt; endl;<br/>      else<br/>       cout &lt;&lt; "wp is not expired" &lt;&lt; endl;<br/>      cout &lt;&lt; "wp pointing counter = " &lt;&lt; wp.use_count() &lt;&lt; endl;<br/>      if(auto locked = wp.lock())<br/>       cout &lt;&lt; "wp is locked. Value = " &lt;&lt; *locked &lt;&lt; endl;<br/>      else<br/>      {<br/>        cout &lt;&lt; "wp is unlocked" &lt;&lt; endl;<br/>        wp.reset();<br/>      }<br/>      cout &lt;&lt; endl;<br/><br/>      return 0;<br/>     }
</pre>
<p>Before we analyze the preceding code, let's take a look at the following screenshot from the output console if we run the code:</p>
<div><img class=" image-border" src="img/ed5b0412-e22b-4ff3-86b2-2cb32d2480b7.png"/></div>
<p>At first, we instantiate <kbd>shared_ptr</kbd> and, as we discussed previously, the <kbd>weak_ptr</kbd> points to the object managed by <kbd>shared_ptr</kbd>. We then assign <kbd>wp</kbd> to the <kbd>shared_ptr</kbd> variable, <kbd>sp</kbd>. After we have a <kbd>weak_ptr</kbd> pointer, we then check its behavior. By calling the <kbd>expired()</kbd> method, we can figure out whether the referenced object was already deleted. And, since the <kbd>wp</kbd> variable is just constructed, it is not expired yet. The <kbd>weak_ptr</kbd> pointer also holds the value of the object counting by calling the <kbd>use_count()</kbd> method, as we used in <kbd>shared_ptr</kbd>. We then invoke the <kbd>locked()</kbd> method to create a <kbd>shared_ptr</kbd> that manages the referenced object and finds the value <kbd>weak_ptr</kbd> is pointing at. We now have a <kbd>shared_ptr</kbd> variable pointing to the address that holds the <kbd>1234</kbd> value.</p>
<p>We reset <kbd>sp</kbd> to <kbd>nullptr</kbd> afterward. Although we don't touch the <kbd>weak_ptr</kbd> pointer, it is also changed. As we can see from the console screenshot, now <kbd>wp</kbd> is expired since the object has been deleted. The counter also changes and becomes <kbd>0</kbd> since it points to nothing. Moreover, it is unlocked since the <kbd>shared_ptr</kbd> object has been deleted.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Storing many different data types using tuples</h1>
                
            
            
                
<p>We will get acquainted with tuples, an object that is able to hold a collection of elements, and each element can be of a different type. It is a new feature in C++11 and gives power to functional programming. The tuples will be most useful when creating a function that returns the value. Moreover, since functions don't change the global state in functional programming, we can return the tuples for all the values we need to change instead. Now, let's examine the following piece of code:</p>
<pre>
    /* tuples_1.cpp */<br/>    #include &lt;tuple&gt;<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[tuples_1.cpp]" &lt;&lt; endl;<br/><br/>      // Initializing two Tuples<br/>      tuple&lt;int, string, bool&gt; t1(1, "Robert", true);<br/>      auto t2 = make_tuple(2, "Anna", false);<br/><br/>      // Displaying t1 Tuple elements<br/>      cout &lt;&lt; "t1 elements:" &lt;&lt; endl;<br/>      cout &lt;&lt; get&lt;0&gt;(t1) &lt;&lt; endl;<br/>      cout &lt;&lt; get&lt;1&gt;(t1) &lt;&lt; endl;<br/>      cout &lt;&lt; (get&lt;2&gt;(t1) == true ? "Male" : "Female") &lt;&lt; endl;<br/>      cout &lt;&lt; endl;<br/><br/>      // Displaying t2 Tuple elements<br/>      cout &lt;&lt; "t2 elements:" &lt;&lt; endl;<br/>      cout &lt;&lt; get&lt;0&gt;(t2) &lt;&lt; endl;<br/>      cout &lt;&lt; get&lt;1&gt;(t2) &lt;&lt; endl;<br/>      cout &lt;&lt; (get&lt;2&gt;(t2) == true ? "Male" : "Female") &lt;&lt; endl;<br/>      cout &lt;&lt; endl;<br/><br/>      return 0;<br/>    }
</pre>
<p>In the preceding code, we created two tuples, <kbd>t1</kbd> and <kbd>t2</kbd>, with different constructing techniques using <kbd>tuple&lt;int, string, bool&gt;</kbd> and <kbd>make_tuple</kbd>. However, these two different techniques will give the same result. Obviously, in the code, we access each element in tuples using <kbd>get&lt;x&gt;(y)</kbd>, where <kbd>x</kbd> is the index and <kbd>y</kbd> is the tuple object. And, with confidence, we will get the following result on the console:</p>
<div><img class=" image-border" src="img/d1853ef6-56aa-4020-949d-d1e527e4f8ff.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Unpacking tuples values</h1>
                
            
            
                
<p>Another useful member that functions in the tuples classes is <kbd>tie()</kbd>, which is used to unpack a tuple into individual objects or create a tuple of <kbd>lvalue</kbd> references. Also, we have the <kbd>ignore</kbd> helper class in tuples, a placeholder to skip an element when unpacking a tuple is using <kbd>tie()</kbd>. Let's see the use of <kbd>tie()</kbd> and <kbd>ignore</kbd> in the following block of code:</p>
<pre>
    /* tuples_2.cpp */<br/>    #include &lt;tuple&gt;<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    auto main() -&gt; int<br/>   {<br/>      cout &lt;&lt; "[tuples_2.cpp]" &lt;&lt; endl;<br/><br/>      // Initializing two Tuples<br/>      tuple&lt;int, string, bool&gt; t1(1, "Robert", true);<br/>      auto t2 = make_tuple(2, "Anna", false);<br/><br/>      int i;<br/>      string s;<br/>      bool b;<br/><br/>      // Unpacking t1 Tuples<br/>      tie(i, s, b) = t1;<br/>      cout &lt;&lt; "tie(i, s, b) = t1" &lt;&lt; endl;<br/>      cout &lt;&lt; "i = " &lt;&lt; i &lt;&lt; endl;<br/>      cout &lt;&lt; "s = " &lt;&lt; s &lt;&lt; endl;<br/>      cout &lt;&lt; "b = " &lt;&lt; boolalpha &lt;&lt; b &lt;&lt; endl;<br/>      cout &lt;&lt; endl;<br/><br/>      // Unpacking t2 Tuples<br/>      tie(ignore, s, ignore) = t2;<br/>      cout &lt;&lt; "tie(ignore, s, ignore) = t2" &lt;&lt; endl;<br/>      cout &lt;&lt; "new i = " &lt;&lt; i &lt;&lt; endl;<br/>      cout &lt;&lt; "new s = " &lt;&lt; s &lt;&lt; endl;<br/>      cout &lt;&lt; "new b = " &lt;&lt; boolalpha &lt;&lt; b &lt;&lt; endl;<br/>      cout &lt;&lt; endl;<br/><br/>      return 0;<br/>    }
</pre>
<p>In the preceding code, we have the same two tuples that <kbd>tuples_1.cpp</kbd> has. We want to unpack <kbd>t1</kbd> into variables <kbd>i</kbd>, <kbd>s</kbd>, and <kbd>b</kbd> respectively, using the <kbd>tie()</kbd> method. Then, we unpack <kbd>t2</kbd> to the <kbd>s</kbd> variable only, ignoring the <kbd>int</kbd> and <kbd>bool</kbd> data in <kbd>t2</kbd>. If we run the code, the output should be as follows:</p>
<div><img class=" image-border" src="img/cb5b261a-d591-4942-8062-caadadba0aac.png"/></div>
<div><h1 class="header-title">Returning a tuple value type</h1>
                
            
            
                
<p>As we discussed earlier, we can maximize the use of tuples in functional programming when we want to write a function that returns multiple data. Let's take a look at the following block of code to know how to return the tuple and access the return value:</p>
<pre>
    /* tuples_3.cpp */<br/>    #include &lt;tuple&gt;<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/> <br/>    tuple&lt;int, string, bool&gt; GetData(int DataId)<br/>    {<br/>      if (DataId == 1) <br/>        return std::make_tuple(0, "Chloe", false);<br/>      else if (DataId == 2) <br/>        return std::make_tuple(1, "Bryan", true);<br/>      else <br/>        return std::make_tuple(2, "Zoey", false);<br/>     }<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[tuples_3.cpp]" &lt;&lt; endl;<br/><br/>      auto name = GetData(1);<br/>      cout &lt;&lt; "Details of Id 1" &lt;&lt; endl;<br/>      cout &lt;&lt; "ID = " &lt;&lt; get&lt;0&gt;(name) &lt;&lt; endl;<br/>      cout &lt;&lt; "Name = " &lt;&lt; get&lt;1&gt;(name) &lt;&lt; endl;<br/>      cout &lt;&lt; "Gender = " &lt;&lt; (get&lt;2&gt;(name) == true ? <br/>        "Male" : "Female");<br/>      cout &lt;&lt; endl &lt;&lt; endl;<br/><br/>      int i;<br/>      string s;<br/>      bool b;<br/>      tie(i, s, b) = GetData(2);<br/>      cout &lt;&lt; "Details of Id 2" &lt;&lt; endl;<br/>      cout &lt;&lt; "ID = " &lt;&lt; i &lt;&lt; endl;<br/>      cout &lt;&lt; "Name = " &lt;&lt; s &lt;&lt; endl;<br/>      cout &lt;&lt; "Gender = " &lt;&lt; (b == true ? "Male" : "Female");<br/>      cout &lt;&lt; endl;<br/>  <br/>      return 0;<br/>    }
</pre>
<p>As we can see in the preceding code, we have a new function named <kbd>GetData()</kbd> returning a <kbd>Tuple</kbd> value. From that function, we will consume the data returning from it. We begin with creating the name variable and get the value from the <kbd>GetData()</kbd> function. We can also use the <kbd>tie()</kbd> method to unpack the tuple coming from the <kbd>GetData()</kbd> function, as we can see in the code when we access the data when ID = <kbd>2</kbd>. The output on the console should be like the following screenshot when we run the code:</p>
<div><img class=" image-border" src="img/f46900eb-e1ba-4d02-9f88-af7b6a43b879.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>We have refreshed our experience in the C++ language by completing this chapter. Now we know that C++ is more modern, and it comes with numerous features that assist us in creating a better program. We can use the Standard Library to make our code efficient since we don't need to write too many redundant functions. We can use the Lambda expression to make our code tidy, easy to read, and easy to maintain. We can also use the smart pointer so we don't need to worry about memory management anymore. Moreover, as we are concerned about immutability in functional programming, we will discuss that deeper in the next chapter; the use of tuples can help us ensure that no global state is involved in our code.</p>
<p>In the next chapter, we will discuss First-Class and Pure Function, which is used to purify our class and ensure that no outside state is involved in the current function. As a result, it will avoid side effects in our functional code.</p>


            

            
        
    </body></html>