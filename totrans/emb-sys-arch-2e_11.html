<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-247"><a id="_idTextAnchor403"/>11</h1>
<h1 id="_idParaDest-248"><a id="_idTextAnchor404"/>Trusted Execution Environment</h1>
<p>An important step in the technological evolution of microcontroller hardware architecture has been recently achieved with the introduction of a domain separation mechanism, which is already present in other<a id="_idIndexMarker818"/> architectures, where it is usually referred to as a <strong class="bold">Trusted Execution Environment</strong>, or <strong class="bold">TEE</strong>.</p>
<p>TEE is an abstraction that provides two or more separated execution domains, or “worlds”, with different capabilities and permissions to access devices, resources, and peripherals.</p>
<p>Isolating the execution environment of one or more software components<a id="_idIndexMarker819"/> and modules, also generally known as <strong class="bold">sandboxing</strong>, consists of limiting their view of the system, without impacting their performance and normal operation. This is a requirement for many use cases and domains in computer science, and not only for increasing the security of embedded systems.</p>
<p>Similar hardware-assisted isolation mechanisms in other domains are the building blocks of the cloud server infrastructure as we know it today, in the form of virtualization extensions and security isolation mechanisms that allow us to run multiple “guest” virtual machines or containers simultaneously on the same hardware.</p>
<p>The concepts and technologies analyzed in this chapter are as follows:</p>
<ul>
<li>Sandboxing</li>
<li>TrustZone-M</li>
<li>System resources separation</li>
<li>Building and running the example</li>
</ul>
<p>By the end of this chapter, you will have learned about TEE and how to configure and use TrustZone-M on Cortex-M microcontrollers to obtain two separate execution domains.</p>
<h1 id="_idParaDest-249"><a id="_idTextAnchor405"/>Technical requirements</h1>
<p>In order to run the proposed example available in this book’s repository, an STM32L552 microcontroller is required. The TrustZone-M technology is only supported by the newest family of ARM Cortex-M microcontrollers. The STM32L552 is a Cortex-M33, fully supporting TrustZone-M, which makes it a convenient and affordable choice for taking our first steps when learning about this technology.</p>
<p>The code files for this chapter are available at <a href="https://github.com/PacktPublishing/Embedded-Systems-Architecture-Second-Edition/tree/main/Chapter11">https://github.com/PacktPublishing/Embedded-Systems-Architecture-Second-Edition/tree/main/Chapter11</a>.</p>
<h1 id="_idParaDest-250"><a id="_idTextAnchor406"/>Sandboxing</h1>
<p>Sandboxing is a generic concept<a id="_idIndexMarker820"/> in computer security that refers to a set of hardware and software measures that limit the “view” of the system for one or more of its components, to restrict the area of the system affected by accidental malfunctions or purposedly forged malicious attacks and prevent them from spreading across the entire system. Sandboxing can have different forms and implementations, which may or may not leverage specific hardware functionalities to improve safety and effectiveness.</p>
<p>By the term TEE, we refer<a id="_idIndexMarker821"/> to those sandbox mechanisms that involve the CPU keeping track of the secure status of the running code at all times, without significantly impacting the performance of the running application. Due to these TEE mechanisms being intrinsically bonded to the CPU design, TEE behavior, management, and communication models in sandboxes differ across heterogeneous platforms and heavily depend on the architecture. Moreover, TEEs can be used for different purposes, often in combination with cryptography to preserve the integrity and authenticity of software through a hardware root of trust.</p>
<p>In 2005, Intel implemented the first virtualization instructions (Intel VT) for x86 processors to run isolated virtual machine code natively (as opposed to emulating the CPU in a dedicated process on the host machine), by providing the hardware-assisted virtualization of the core components (CPU, RAM, and peripherals). Intel CPUs limit the access of the guest virtual machines to the real hardware using an extension of the existing hierarchical<a id="_idIndexMarker822"/> protection domains, often simply called <strong class="bold">rings</strong>, already used for kernel/userspace separation.</p>
<p>Virtual machines<a id="_idIndexMarker823"/> are not the only use case<a id="_idIndexMarker824"/> of TEE on x86 processors. Intel <strong class="bold">Software Guard Extensions</strong> (<strong class="bold">SGX</strong>) is a set of security-related instructions present in many x86 CPUs, protecting specific memory regions, or enclaves, from unauthorized access. While these instructions have been recently removed from consumer Intel CPUs, they are still present in specific microprocessors in the cloud and enterprise hardware segment. SGX can be used for several purposes, such as providing a secure vault to hide secret keys to be used securely by the applications. Originally, however, they were introduced<a id="_idIndexMarker825"/> to fulfill the specific task of implementing <strong class="bold">Digital Rights Management</strong> (<strong class="bold">DRM</strong>) on PCs, which would have enforced copyright protection on media and proprietary software content by authorizing access to the protected content only to pre-authorized, signed software applications. In this setup, the adversaries that TEE protects the system against are the final users themselves.</p>
<p>Later on, AMD added vendor-specific architecture<a id="_idIndexMarker826"/> extensions to their CPUs, grouped into a technology called <strong class="bold">Secure Encrypted Virtualization</strong> (<strong class="bold">SEV</strong>). In addition to providing a sandbox for running virtual machines managed by a hypervisor, SEV uses hardware-assisted encryption to ensure the confidentiality of the content of single memory pages, and even CPU registers, during execution.</p>
<p>The Intel architectures, however, were not the first ones to introduce CPU-assisted, built-in, secure extensions. ARM started research on trusted computing in the early 2000s and finally<a id="_idIndexMarker827"/> announced support for a technology called TrustZone in 2003. Modern ARM microprocessors, such as those<a id="_idIndexMarker828"/> in the Cortex-A family, support a technology called TrustZone-A, which implements two separate Secure (S) and Non-Secure (NS) worlds, the latter having a restricted pre-configured view on the actual system, while the former is capable of accessing all the hardware resources directly.</p>
<p>To find the first microcontrollers implementing TEE, we have to look at the recently designed RISC-V architecture. Both microprocessors and microcontrollers within the RISC-V families offer complete sandboxes separate from each other, in both 32-bit and 64-bit architectures that implement “S” or “U” extensions. Each hardware-assisted container provides a subset of the resources available on the system and runs its own firmware.</p>
<p>Finally, the newest family of microcontrollers by ARM, the ARMv8-M family, includes the extensions and the microcode needed to implement isolation between secure and non-secure execution domains, based on the existing and well-oiled TrustZone technology design. This feature is called TrustZone-M, and it is the specific<a id="_idIndexMarker829"/> technology that we will be focusing on in more detail later in this chapter. ARMv8-M is a direct evolution of the ARMv7-M family of microcontrollers that have been used as a reference platform in all the previous chapters of this book.</p>
<p>The rest of this chapter<a id="_idIndexMarker830"/> will refer exclusively to TrustZone-M and how to configure and develop components in an embedded system, implementing TEE on the ARMv8-M family of microcontrollers. The term TrustZone from now on will refer specifically to the TrustZone-M technology.</p>
<h1 id="_idParaDest-251"><a id="_idTextAnchor407"/>TrustZone-M</h1>
<p>ARMv7-M cores, such as the Cortex-M0+ and Cortex-M4<a id="_idIndexMarker831"/> microcontrollers, have dominated the embedded market for decades and are still the most popular choice for many embedded system designs. Although there have been a number of changes and additions, the new Cortex-M23 and Cortex-M33 cores, as well as the newer M35P and M55, have inherited and expanded many of the successful features of the Cortex-M0, Cortex-M4, and Cortex-M7 microcontrollers.</p>
<p>In a typical TrustZone use case, multiple actors may be involved in the distinct phases of software development. The owner of a device may provide a base system, already equipped with all the software authorized to run in the secure world. This would still leave the possibility for a system integrator to customize the non-secure part but with a restricted view of the system, which depends on the configuration of the resources allowed by the secure domain. The system integrator in this case receives a system that is partially locked, with TrustZone enabled and flash memory protections in place to protect its integrity. The secure software provided supervises the execution of any custom software in the non-secure domain, while preserving the resources mapped in the secure world and limiting access from the running application. System integrators without authorized access to the secure execution domain can still run privileged or non-privileged software in the non-secure world, thus including operating systems and device drivers that access the interfaces authorized, either directly, or with some assistance from the secure supervisor.</p>
<p>The example associated with this chapter can be compiled and run on the reference platform. This example is based on the bootloader example introduced in <a href="B18730_04.xhtml#_idTextAnchor115"><em class="italic">Chapter 4</em></a>, <em class="italic">The Boot-Up Procedure</em>. This is due to the similarity of the structure of the TrustZone-based solution that we want to describe, because the software for the two execution domains is shipped into separate binaries. In the TrustZone case, the separation between bootloader code executing in the secure domain and staging an application running in the non-secure world will help us understand the elements and tools u<a id="_idTextAnchor408"/>sed to build, configure, and run the components on a real system.</p>
<p>The next subsection<a id="_idIndexMarker832"/> contains a description of the reference platform, and then we will briefly introduce the execution model behind the secure and non-secure domains, which will then bring us to a deeper analysis of the TrustZone-M units and controllers regulating resource separation on a system.</p>
<h2 id="_idParaDest-252"><a id="_idTextAnchor409"/>Reference platform</h2>
<p>The microcontroller used for reference<a id="_idIndexMarker833"/> in the examples is the STM32L552, a Cortex-M33 CPU that can be found on development boards in the convenient Nucleo-144 format. The STM32L5 series of microcontrollers may be considered the closest evolution of the older STM32F4 series, targeting the same slice of the market by combining low-power modes with high performance. For this reason, a microcontroller in this series has been selected in this chapter as a reference platform for the examples provided. Most of the concepts and the components of the TrustZone-M technology that will be described are, however, applicable to all the microcontrollers in the ARMv8-M family available from ST Microelectronics and several other chip manufacturers.</p>
<p>On the STM32L552ZE, the CPU clock can be configured to run at 110 MHz. The microcontroller is equipped with 256 KB of SRAM, divided into two banks SRAM1 and SRAM2 mapped into separate regions. 512 KB of flash memory can be used as one contiguous space or configured as two separate banks. The ST microcontroller provides platform-specific libraries and tools that are not part of the provided examples, which as usual are based on a fresh implementation that begins with an understanding of the documentation. The only exception to this approach in the example we are going to introduce is the use of the STM32 programming command-line interface, <code>STM32_Programmer_CLI</code>, which can be used to display the current value of the programmable option bytes, just by connecting through the ST-Link debugger on board to the PC with a USB cable and running the following:</p>
<pre class="console">
STM32_Programmer_CLI -c port=swd -ob displ</pre>
<p>This tool will be useful<a id="_idIndexMarker834"/> to set the <em class="italic">option bytes</em> required to turn TrustZone on and off and set up other options for separating areas of flash memory. Values for option bytes are stored in non-volatile memory, and the values will be retained after the board has been powered off.</p>
<p class="callout-heading">Important note</p>
<p class="callout">Modifying some of the option bytes accessible through a programmer tool may be irreversible and, in some cases, brick your device. Please refer to the reference manual and application notes of your microcontroller before changing any option.</p>
<p>One of the option bytes contains the <code>TZEN</code> flag, which should be disabled per the factory default. Only when TrustZone-M has been configured will we then enable it on the target to upload and run the example. The bootloader part in the secure world will be responsible for setting up the environment for the application, installed as a different binary, and executing it in the non-secure domain. We will then demonstrate the transitions between the two worlds by introducing new ARMv8 assembly instructions introduced f<a id="_idTextAnchor410"/>or this purpose.</p>
<p>In the next subsection, we will introduce the extensions included in the ARMv8-M architecture for executing code and controlling execution domains. These extensions are generic and included in all the ARMv8-M microcontrollers that support TrustZone, and are the core component for the execution in separate domains.</p>
<h2 id="_idParaDest-253">Secure and non-secure e<a id="_idTextAnchor411"/>xecution domains</h2>
<p>In <a href="B18730_10.xhtml#_idTextAnchor357"><em class="italic">Chapter 10</em></a>, <em class="italic">Parallel Tasks and Scheduling</em>, we learned that resource<a id="_idIndexMarker835"/> separation among threads and between<a id="_idIndexMarker836"/> threads and the operating system is possible, with the help of memory segmentation. In the ARMv8-m family of microcontrollers, TrustZone-M is often referred to as a security extension because it does, in fact, add one additional level of privilege separation between software components that are running on the target. These security extensions do not replace the existing thread separation we implemented earlier in the safe version of the scheduler. Instead, they introduce an additional security mode on top of the existing separati<a id="_idTextAnchor412"/>on.</p>
<p>Similar to how an OS running without these extensions enforces a separation between thread mode and privileged mode, and can<a id="_idIndexMarker837"/> set boundaries for accessing memory-mapped areas using a MPU, TrustZone-M adds <strong class="bold">Secure</strong> (<strong class="bold">S</strong>) and <strong class="bold">Non-Secure</strong> (<strong class="bold">NS</strong>) execution domains (or “worlds”) with CPU-controlled<a id="_idIndexMarker838"/> access to the single resources.</p>
<p>Within each of those<a id="_idIndexMarker839"/> worlds, it is still possible to implement<a id="_idIndexMarker840"/> privileged/thread separation by using the existing mechanism based on the CONTROL bit. Each security world can have its own privileged and non-privileged execution modes. An OS running in the NS world can still use the classic privilege separation that has been inherited from the previous ARMv7-M architecture. This creates a total of four available execution contexts that can be followed simultaneously by the CPU, summarized in this table as a combination of domain and privilege levels:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table001">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Secure world</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Non-secure world</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Secure privileged execution</p>
</td>
<td class="No-Table-Style">
<p>Non-secure privileged execution</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Secure thread execution</p>
</td>
<td class="No-Table-Style">
<p>Non-secure thread execution</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 11.1 – Available execution modes in secure/non-secure domains</p>
<p>As we pointed out in <a href="B18730_10.xhtml#_idTextAnchor357"><em class="italic">Chapter 10</em></a>, <em class="italic">Parallel Tasks and Scheduling</em>, the Cortex-M4 provides two separate stack pointers (MSP and PSP) to keep track of the different contexts when executing threads or kernel code. In the Cortex-M33, there is a total of four different stack pointers, MSP_S, PSP_S, MSP_NS, and PSP_NS. Each stack pointer is aliased into the actual SP register during execution, depending on the current domain and context.</p>
<p>A very convenient feature has been added to the ARMv8-M architecture when MAIN extensions are present on the CPU, as in our reference<a id="_idIndexMarker841"/> platform. Each one of the four stack pointers has a corresponding <strong class="bold">stack pointer limit</strong> (<strong class="bold">SPLIM</strong>) register (called MSPLIM_S, PSPLIM_S, MSPLIM_NS, and PSPLIM_NS respectively). These registers indicate the lower limit for the stack pointer value in the four cases. This is in fact an effective countermeasure to the issues analyzed in the <em class="italic">Stack overflows</em> subsection in<em class="italic"> </em><a href="B18730_05.xhtml#_idTextAnchor149"><em class="italic">Chapter 5</em></a>, <em class="italic">Memory Management</em>. The CPU will constantly check at runtime that the stack never grows past its lower limit in memory by generating an exception when this happens. This mechanism provides a better hardware-assisted way to protect memory from accidental stack overflows and collisions with other memory regions than the one proposed in the examples from <a href="B18730_05.xhtml#_idTextAnchor149"><em class="italic">Chapter 5</em></a>, <em class="italic">Memory Management</em>, where we introduced a guard region between the two memory areas assigned to heap and stack.</p>
<p>We already analyzed how to switch between execution modes, and how setting or clearing the CONTROL bit while returning from system calls plays a role in the transactions between privilege and thread execution modes.<a id="_idTextAnchor413"/> The mechanisms for switching between secure and non-secure executions are implemented via specific assembly instructions, which we will explain later after introducing resource separation between secure and non-secure worlds.</p>
<p>To better understand<a id="_idIndexMarker842"/> what system resources the software<a id="_idIndexMarker843"/> running in the non-secure world may or may not access, the next section will go into detail about the different possibilities provided by the TrustZone-M controller modules to isolate and separate hardware resources.</p>
<h1 id="_idParaDest-254"><a id="_idTextAnchor414"/>System resources separation</h1>
<p>When TrustZone-M is enabled, all areas<a id="_idIndexMarker844"/> mapped in memory, including RAM, peripherals, and even FLASH storage, receive a new security attribute. Besides the secure and non-secure domains, a security attribute may assume a third value, <strong class="bold">Non-Secure Callable</strong> (<strong class="bold">NSC</strong>). This last attribute defines special regions<a id="_idIndexMarker845"/> of memory used to implement transactions from the non-secure world to the secure world through a specific mechanism, which will be explained in the last section, <em class="italic">Building and running the ex<a id="_idTextAnchor415"/>ample</em>. An NSC area is used to offer secure APIs that act like system calls with new powers. The secure domain exposes service routines that can perform specific controlled actions while accessing secure resources from its non-secure counterpart.</p>
<h2 id="_idParaDest-255"><a id="_idTextAnchor416"/>Security attributes and memory regions</h2>
<p>Cortex-M33 microcontrollers<a id="_idIndexMarker846"/> <a id="_idTextAnchor417"/>offer various levels<a id="_idIndexMarker847"/> of protection. The combination of the effects of those <a id="_idTextAnchor418"/>levels determines which of the memory-mapped areas associated with a resource on the system are available to both execution domains and which of them are only accessible from the secure world.</p>
<p>Enabling TrustZone-M will also duplicate the representation of some of the system reso<a id="_idTextAnchor419"/>urces. The flash memory usually mapped from the start of the address 0x08000000 has an alias in the region 0x0C000000, which is used to access the same storage from the secure world. Many system registers are “banked” and have secure and non-secure versions at separate memory locations. For example, the GPIOA controller is mapped to the address 0x42020000 when TrustZone is disabled. When TrustZone is enabled, the same address is used by software running in the non-secure domain if the GPIOA controller is accessible from the non-secure world. However, software running in the secure domain will use the same controller mapped from the start of the address 0x52020000. The same banking applies to many other registers in the peripheral region, whic<a id="_idTextAnchor420"/>h have secure and non-secure versions of the same registers mapped into two separate regions.</p>
<p>Before being processed by other TrustZone-aware<a id="_idIndexMarker848"/> components, each memory access is monitored and filtered<a id="_idIndexMarker849"/> by two units responsible for configuring the attributes. These are the <strong class="bold">Security Attribution Unit</strong> (<strong class="bold">SAU</strong>) and <strong class="bold">Implementation-Defined Attribution Unit</strong> (<strong class="bold">IDAU</strong>). These units affect the accessibility of the entire memory mapping regardless of the type of resource associated with each<a id="_idTextAnchor421"/> region. While the SAU is configurable through a set of registers, the IDAU contains hardcoded mappings enforced by the chip manufacturer. The combination of the attributes of IDAU and SAU influences the accessibility of each memory-mapped region, the following in particular:</p>
<ul>
<li>Regions mapped as secure by IDAU are not influenced by SAU attributes and will always stay mapped as secure</li>
<li>Regions mapped as NSC by IDAU can be secure or NSC, based on the SAU attribute</li>
<li>Regions mapped as non-secure by IDAU will follow the SAU mapping</li>
</ul>
<p>The combination of the attributes and the resulting mapping for each region is summarized in the following table:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table002">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">IDAU attribute</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">SAU attribute</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Resulting attribute</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Secure</p>
</td>
<td class="No-Table-Style">
<p>Secure, NSC, or Non-secure</p>
</td>
<td class="No-Table-Style">
<p>Secure</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>NSC</p>
</td>
<td class="No-Table-Style">
<p>Secure</p>
</td>
<td class="No-Table-Style">
<p>Secure</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Non-secure</p>
</td>
<td class="No-Table-Style">
<p>Secure</p>
</td>
<td class="No-Table-Style">
<p>Secure</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>NSC</p>
</td>
<td class="No-Table-Style">
<p>NSC or Non-secure</p>
</td>
<td class="No-Table-Style">
<p>NSC</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Non-secure</p>
</td>
<td class="No-Table-Style">
<p>NSC</p>
</td>
<td class="No-Table-Style">
<p>NSC</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Non-secure</p>
</td>
<td class="No-Table-Style">
<p>Non-secure</p>
</td>
<td class="No-Table-Style">
<p>Non-secure</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 11.2 – A combination of IDAU and SAU attributes</p>
<p>By default, our IDAU<a id="_idIndexMarker850"/> in the STM32L552 reference<a id="_idIndexMarker851"/> platform enforces the secure/NSC mapping of a few key regions:</p>
<ul>
<li>The flash memory mapping in secure space, starting at the address <code>0x0C000000</code></li>
<li>The second SRAM bank, SRAM2, mapped from the start of the address <code>0x30000000</code></li>
<li>The memory between <code>0x50000000</code> and <code>0x5FFFFFFF</code>, reserved for secure peripherals’ control and configuration</li>
</ul>
<p>The SAU sets all the regions as secure upo<a id="_idTextAnchor422"/>n reset and is disabled by default. To execute non-secure code, we must define at least two non-secure regions within the intervals allowed by the IDAU configuration.</p>
<p>In our example, we initialize a few memory areas to allow access from the applications, before enabling SAU. SAU is controlled through four main 32-bit registers:</p>
<ul>
<li><strong class="bold">SAU_CTRL</strong> (SAU control): Used to activate SAU. It contains<a id="_idIndexMarker852"/> a flag to “invert” the logic of the SAU filter, by setting all the memory regions as non-secure.</li>
<li><strong class="bold">SAU_RNR</strong> (SAU region number register): Contains the region<a id="_idIndexMarker853"/> number to select at the beginning of the configuration procedure for the memory regions. Further writes to SAU_RBAR and SAU_RLAR will refer to this numbered region.</li>
<li><strong class="bold">SAU_RBAR</strong> (SAU region base address register): Indicates the base address<a id="_idIndexMarker854"/> of the region that we want to configure.</li>
<li><strong class="bold">SAU_RLAR</strong> (SAU region limit address register): Contains<a id="_idIndexMarker855"/> the end address of the region to configure. The least significant 5 bits are reserved for flags. Bit 1, when on, indicates that the region is secure or non-secure callable. Bit 0 enables the region and indi<a id="_idTextAnchor423"/>cates that its configuration is complete.</li>
</ul>
<p>In the following example<a id="_idIndexMarker856"/> code, you can find <a id="_idIndexMarker857"/>the <code>sau_init_region</code> convenience function. Given a region identifier, base address, end address, and secure bit value, it will set all the register values accordingly:</p>
<pre class="source-code">
static void sau_init_region(uint32_t region,
    uint32_t start_addr,
    uint32_t end_addr,
    int secure)
{
  uint32_t secure_flag = 0;
  if (secure)
      secure_flag = SAU_REG_SECURE;
  SAU_RNR = region &amp; SAU_REGION_MASK;
  SAU_RBAR = start_addr &amp; SAU_ADDR_MASK;
  SAU_RLAR = (end_addr &amp; SAU_ADDR_MASK)
      | secure_flag | SAU_REG_ENABLE;
}</pre>
<p>This function is called by the <code>secure_world_init</code> initialization function to map the four SAU regions<a id="_idIndexMarker858"/> that we want to configure for this example, which are, specifically, the following:</p>
<ul>
<li><code>nsc_blue_led_toggle</code>, which will be the only way that the application can access an otherwise secure-only GPIO, wired to the blue LED on the Nucleo board.</li>
<li><code>0x08040000</code>. This is where the code of our non-secure application will reside.</li>
<li><strong class="bold">Region 2</strong>: An non-secure part of the SRAM1 bank that can be used by the non-secure application for the stack and variables. This is a necessary step to ensure the application can access RAM addresses.</li>
<li><code>0x40000000</code>, including the non-secure GPIO controllers. This area will be accessed by the non-secure application to set the system clock and control the green led in the example.</li>
</ul>
<p>The code for the SAU initialization<a id="_idIndexMarker859"/> in the example<a id="_idIndexMarker860"/> is the following:</p>
<pre class="source-code">
static void secure_world_init(void)
{
  /* Non-secure callable: NSC functions area */
  sau_init_region(0, 0x0C001000, 0x0C001FFF, 1);
  /* Non-secure: application flash area */
  sau_init_region(1, 0x08040000, 0x0804FFFF, 0);
  /* Non-secure RAM region in SRAM1 */
  sau_init_region(2, 0x20018000, 0x2002FFFF, 0);
  /* Non-secure: internal peripherals */
  sau_init_region(3, 0x40000000, 0x4FFFFFFF, 0);</pre>
<p>The code in the tail of this function activates the SAU and enables a specific handler that detects secure faults:</p>
<pre class="source-code">
  /* Enable SAU */
  SAU_CTRL = SAU_INIT_CTRL_ENABLE;
  /* Enable securefault handler */
  SCB_SHCSR |= SCB_SHCSR_SECUREFAULT_EN;
}</pre>
<p>By default, enabling SAU would mark all regions as secure, so each region configuration trims an non-secure or non-secure callable “window” within the addressable memory space. Region 0 is the only region marked with the NSC flag in our example configuration, which means that NSC code (explained later) will be installed here by the secure application. Regions 1, 2, and 3 are the only memory areas that may be accessed when running in the non-secure domain with TrustZone-M enabled.</p>
<p>As previously <a id="_idIndexMarker861"/>mentioned, IDAU/SAU<a id="_idIndexMarker862"/> is just the first level of filters for the TrustZone-M protection mechanisms. Flash memory and RAM are protected by additional secure gates, which can be block-based or watermark-based. The STM32L552 microcontroller is equipped with a <strong class="bold">Global TrustZone Controller</strong> (<strong class="bold">GTZC</strong>), which includes one watermark-based<a id="_idIndexMarker863"/> gate controller for the flash and one block-based to define secure/non-secure RAM blocks.</p>
<h2 id="_idParaDest-256"><a id="_idTextAnchor424"/>Flash memory and secure watermarks</h2>
<p>On the target<a id="_idIndexMarker864"/> platform, flash memory<a id="_idIndexMarker865"/> can be configured<a id="_idIndexMarker866"/> to be mapped as a single, contiguous<a id="_idIndexMarker867"/> space, or split in half by activating a dual bank configuration. For the sake of our TrustZone-M example, we will keep the flash memory in a single bank.</p>
<p>In this configuration, when TrustZone is enabled, we can assign an non-secure area in the higher half of the contiguous flash memory space, starting at the address <code>0x08040000</code>. When the flash is divided into two banks, each bank can configure its own independent secure watermark. The flash area in between the start/end addresses is marked as secure, and everything left outside of the marks is non-secure. The secure area in each bank is delimited by the value of the option bytes, SECWMx_PSTRT and SECWMx_PEND. If the delimiters overlap – that is, when the value of SECWMx_PEND is bigger than that of SECWMx_PSTRT – the entire area is marked as non-secure.</p>
<p>Their value can be modified using the programmer tool provided, as shown here:</p>
<pre class="source-code">
STM32_Programmer_CLI -c port=swd -ob SECWM1_PSTRT=0
   SECWM1_PEND=0x39</pre>
<p>In single-bank mode, each flash sector is 4096 B. By setting these option bytes, we are marking the first 64 sectors (from <code>0x00</code> to <code>0x39</code>) as secure, which leaves the other half of the flash, starting from the address <code>0x08040000</code>, to be used by the non-secure application in our example. The programmer tool, launched with the <code>-ob displ</code> option, will show the following:</p>
<pre class="source-code">
<strong class="bold">   Secure Area 1:</strong>
<strong class="bold">     SECWM1_PSTRT : 0x0  (0x8000000)</strong>
<strong class="bold">     SECWM1_PEND  : 0x39  (0x8039000)</strong></pre>
<h2 id="_idParaDest-257"><a id="_idTextAnchor425"/>GTZC configuration and block-based SRAM protection</h2>
<p>An additional<a id="_idIndexMarker868"/> gate to control <a id="_idIndexMarker869"/>access is present in the TrustZone controller<a id="_idIndexMarker870"/> on the reference<a id="_idIndexMarker871"/> platform. The block-based gate component of the GTZC allows us to configure the secure-only bit to portions of SRAM. SRAM on STM32L552 is divided into two main banks:</p>
<ul>
<li>SRAM1: 192 KB of RAM mapped at the address <code>0x08000000</code></li>
<li>SRAM2: 64 KB of RAM mapped at the address <code>0x30000000</code> and set as NSC in IDAU</li>
</ul>
<p>In our example, we are marking the higher half of SRAM1, starting at the address <code>0x2018000</code>, as non-secure. To do so, the GTZC provides two sets of registers, one for each bank, to configure the block-based gate to each page in RAM. Each block represents 25 6B, and each 32-bit register, by holding one secure bit per block, can map 32 pages, also defined a<a id="_idTextAnchor426"/>s an 8 KB superblock. 24 registers are required to map the 24 superblocks for a total of 192 KB in SRAM1, and only 8 are required to map the 64 KB area in SRAM2.</p>
<p>Like for the SAU<a id="_idIndexMarker872"/> initialization, once again the approach<a id="_idIndexMarker873"/> taken in the example<a id="_idIndexMarker874"/> relies on a convenient macro<a id="_idIndexMarker875"/> that, given a me<a id="_idTextAnchor427"/>mory bank, the superblock number, and its register value, calculates the address for the right register that refers to the superblock and generates the right assignment statement:</p>
<pre class="source-code">
#define SET_GTZC_MPCBBx_S_VCTR(bank,n,val) \
(*((volatile uint32_t *)(GTZC_MPCBB##bank##_S_VCTR_BASE )\
           + n ))= val</pre>
<p>This way we can easily configure block-based gates of contiguous regions within a loop. The secure-world application example uses the following function to configure the block-based gates for the two banks:</p>
<pre class="source-code">
 static void gtzc_init(void)
{
   int i;
  /* Configure lower half of SRAM1 as secure */
   for (i = 0; i &lt; 12; i++) {
       SET_GTZC_MPCBBx_S_VCTR(1, i, 0xFFFFFFFF);
   }
   /* Configure upper half of SRAM1 as non-secure */
   for (i = 12; i &lt; 24; i++) {
       SET_GTZC_MPCBBx_S_VCTR(1, i, 0x0);
   }
  /* Configure SRAM2 as secure */
   for (i = 0; i &lt; 8; i++) {
       SET_GTZC_MPCBBx_S_VCTR(<a id="_idTextAnchor428"/>2, i, 0xFFFFFFFF);
   }
}</pre>
<p>We now have everything<a id="_idIndexMarker876"/> required to run the simplest non-secure<a id="_idIndexMarker877"/> application on the system; we have<a id="_idIndexMarker878"/> defined the non-secure areas<a id="_idIndexMarker879"/> in SAU, set the watermark for the separation of the flash memory, and finally, set the block-based gates to enable non-secure access to the higher half of SRAM1.</p>
<p>There is, however, another aspect that deserves attention, and that is the possibility of configuring secure access to peripherals.</p>
<h2 id="_idParaDest-258"><a id="_idTextAnchor429"/>Configuring secure access to peripherals</h2>
<p>On the reference<a id="_idIndexMarker880"/> platforms, peripherals<a id="_idIndexMarker881"/> are divided into two categories:</p>
<ul>
<li><strong class="bold">Securable peripherals</strong>: Peripherals are not directly connected<a id="_idIndexMarker882"/> to a local bus, but through a gate system<a id="_idIndexMarker883"/> controlled by the <strong class="bold">TrustZone Secure </strong><strong class="bold">Controller</strong> (<strong class="bold">TZSC</strong>)</li>
<li><strong class="bold">TrustZone-aware peripherals</strong>: These are peripherals that integrate with TrustZone<a id="_idIndexMarker884"/> mechanisms – for example, by offering separate interfaces to access their resources, depending on the execution domain</li>
</ul>
<p>For the first category of peripherals, the configuration of the secure access and privileged access within secure and non-secure domains can be configured through the TZSC registers within the GTZC. At system startup, all devices are set as secure by default, so to enable access to UART, I2C, timers, and other peripherals, it will be necessary to turn off the secure bit associated with the specific controller.</p>
<p>TrustZone-aware peripherals have banked registers for both secure domains. In the next example, we configure three GPIO controllers (<code>GPIOA</code>, <code>GPIOB</code>, and <code>GPIOC</code>), which are connected to the LEDs on the Nucleo-144 board, via pins C7 (the green LED), B7 (the blue LED), and A9 (the red LED). The GPIO<a id="_idIndexMarker885"/> controller registers, when TrustZone is enabled, are banked<a id="_idIndexMarker886"/> into two regions. You will notice in the example code the difference between the two LED driver interfaces in the secure and non-secure applications. In the secure version of <code>led.h</code>, we define the following address base for the GPIO controller registers:</p>
<pre class="source-code">
#define GPIOA_BASE 0x52020000
#define GPIOB_BASE 0x52020400
#define GPIOC_BASE 0x52020800</pre>
<p>The same controllers, in the non-secure world application, are mapped in the non-secure peripheral address space:</p>
<pre class="source-code">
#define GPIOA_BASE 0x42020000
#define GPIOB_BASE 0x42020400
#define GPIOC_BASE 0x42020800</pre>
<p>This ensures that the GPIO configuration is accessible only through the interface assigned to the non-secure space when running in the non-secure domain.</p>
<p>Additionally, each GPIO controller provides an interface to secure each single controlled pin. This is achieved through a write-only register controlling the secure and non-secure access with a flag corresponding to each pin. The<a id="_idIndexMarker887"/> register is called GPIOx_SECCFG and is located at an offset of <code>0x24</code> in each GPIO controller space. This is only accessible for writing when running in a secure domain.</p>
<p>In the example, we define functions to set/clear the secure bit for each GPIO pin connected to the three LEDs. For example, we can set the secure state of the red LED, before staging the non-secure application to disallow changing the LED state in the application by calling <code>red_led_secure(1)</code>, which is implemented as follows:</p>
<pre class="source-code">
void red_led_secure(int onoff)
{
  if (onoff)
      GPIOA_SECCFG |= (1 &lt;&lt; RED_LED);
  else
      GPIOA_SECCFG &amp;= ~(1 &lt;&lt; RED_LED);
}</pre>
<p>Our secure-world example application in fact restricts access to the blue and red LED before staging while allowing access to the green LED:</p>
<pre class="source-code">
    red_led_secure(1);
    green_led_secure(0);
    blue_led_secure(1);</pre>
<p>After the domain switch, the non-secure application will attempt to turn on all three LEDs, but only the green one will actually be turned on, and the other will stay off because access through the non-secure interface is gated by the SECCFG bit set in the secure world and has no effect on the GPIO.</p>
<p>Blinking the blue LED, however, will still be done using a special non-secure callable interface, explained in the <em class="italic">Inter-domain transitions</em> subsection in the next section.</p>
<p>After configuring<a id="_idIndexMarker888"/> all the securable<a id="_idIndexMarker889"/> and TrustZone-aware peripherals, we are finally ready to build and install the firmware images for the two domains and observe their effects on the system.</p>
<h1 id="_idParaDest-259"><a id="_idTextAnchor430"/>Building and running the example</h1>
<p>Finally, we are putting all we <a id="_idIndexMarker890"/>have learned about TrustZone-M into practice, by activating<a id="_idIndexMarker891"/> the option flags needed to enable TrustZone-M and running the two software components associated with the execution domains.</p>
<h2 id="_idParaDest-260"><a id="_idTextAnchor431"/>Enabling TrustZone-M</h2>
<p>By default, TrustZone-M is turned off on our microcontroller<a id="_idIndexMarker892"/> when it is in its factory state. Turning on TrustZone is a one-way operation, but it is typically not irreversible unless combined with other hardware-assisted protection mechanisms that make it impossible to disable it when the embedded system is deployed. Disabling TrustZone once enabled, however, requires a more complex procedure than just clearing one bit in a register.</p>
<p class="callout-heading">Important note</p>
<p class="callout">Please refer to your microcontroller’s reference manual and application notes, and ensure that you understand the procedure and the consequences of enabling or attempting to disable TrustZone-M on your device.</p>
<p>On the reference platform, to enable TrustZone, we set the associated flag in the option bytes via the following command:</p>
<pre class="console">
STM32_Programmer_CLI -c port=swd mode=hotplug -ob TZEN=1</pre>
<p>Once TrustZone has been enabled<a id="_idTextAnchor432"/>, we can<a id="_idIndexMarker893"/> build and install the secure firmware. The next subsection highlights some important aspects to consider when building the secure part of the system.</p>
<h2 id="_idParaDest-261"><a id="_idTextAnchor433"/>Secure application entry point</h2>
<p>The regions defined in the secure-world linker script<a id="_idIndexMarker894"/> reflect the system resources as seen by the secure firmware. We allocate a RAM region covering the lower half of the SRAM1 bank:</p>
<pre class="source-code">
    RAM (rwx) : ORIGIN = 0x20000000, LENGTH = 0x00018000</pre>
<p>Our <code>.text</code> and <code>.data</code> LMSes end up in the FLASH region, mapped to its secure-domain address:</p>
<pre class="source-code">
    FLASH (rx) : ORIGIN = 0x0C000000, LENGTH = 0x1000</pre>
<p>For our simple example, 4 KB is enough to store the bootloader image. Additionally, we define a non-secure callable area, which will contain the implementation <a id="_idTextAnchor434"/>of our secure stubs. This is an area dedicated to accessing secure APIs from the non-secure world through pre-defined inter-domain special function calls:</p>
<pre class="source-code">
    FLASH_NSC(rx): ORIGIN = 0x0C001000, LENGTH = 0x1000</pre>
<p>The entry point of the secure application on the reference platform is hardcoded in the option bytes. Before installing our image, we must ensure that the option bytes for <code>SECBOOTADD0</code> are configured to point to the address <code>0x0C000000</code>, which is the beginning of the flash memory in the secure system view. If, for any reason, the value has been previously modified, it can be restored via the following command:</p>
<pre class="source-code">
STM32_Programmer_CLI -c port=swd mode=hotplug -ob SECBOOTADD0=0x180000</pre>
<p>This is because the granularity of <code>SECBOOTADD0</code> is 128 bytes, so setting a value of <code>0x180000</code> will result in a pointer to the address <code>0x0C000000</code>.</p>
<p>This last value completes the setup of option bytes, so we are finally ready to build and install the secure application.</p>
<p>A list of the option bytes<a id="_idIndexMarker895"/> and their values, assigned in order to configure the target run of the example code, is provided in the repository of this book, in the <code>Chapter11/option-bytes.txt</code> file.</p>
<h2 id="_idParaDest-262"><a id="_idTextAnchor435"/>Compiling and linking secure-world applications</h2>
<p>If you look in the<a id="_idIndexMarker896"/> Makefile for the secure-world<a id="_idIndexMarker897"/> application, you will notice two new flags<a id="_idTextAnchor436"/> have been introduced in the build process. gcc requires us to use the <code>-mcmse</code> flag to indicate that we are compilin<a id="_idTextAnchor437"/>g secure code for a TrustZone system. By adding<a id="_idIndexMarker898"/> this flag, we are telling the compiler to generate <code>nsc_led.c</code> file:</p>
<pre class="source-code">
void __attribute__((cmse_nonsecure_entry))
    nsc_blue_led_toggle(void)
{
  if ((GPIOB_ODR &amp; (1 &lt;&lt; BLUE_LED)) == (1 &lt;&lt; BLUE_LED))
    blue_led_off();
  else
    blue_led_on();
}</pre>
<p>The <code>__attribute__((cmse_nonsecure_entry))</code> compiler attribute tells gcc to generate the SG stub for this function. The <code>FLASH_NSC </code>section that we defined in the linker script is used <a id="_idIndexMarker899"/>to store the SG stubs for the secure API<a id="_idIndexMarker900"/> that we configure. The SG stubs are automatically placed in a section called <code>.gnu.sgstubs</code>, which we place in the <code>FLASH_NSC</code> region in the example linker script:</p>
<pre class="source-code">
.gnu.sgstubs :
{
  . = ALIGN(4);
  *(.gnu.sgstubs*)   /* Secure Gateway stubs */
  . = ALIGN(4);
} &gt;FLASH_NSC</pre>
<p>The extra linker flags, <code>--cmse-implib</code> and <code>--out-implib=led_cmse.o</code>, have a different purpose that does not directly affect the secure domain. When linking the secure application, by adding these flags we are asking the linker to create a new object file, which will not be linked in the final secure application. This new object file instead will be linked in the non-secure world application and contains the veneers for the secure API. These veneers prepare the jump from non-secure to non-secure callable world. In other words, this new file, <code>led_cmse.o</code>, is the non-secure world counterpart implementation of the secure calls through a non-secure callable SG stub. The veneers are generated by the linker and contain the code<a id="_idTextAnchor438"/> needed to jump to the non-secure callable stub. To recap, to build the secure application, we need to introduce two specific set of flags:</p>
<ul>
<li>The<code>–mcmse</code> compile time flag, which tells gcc that we are generating secure code for TrustZone and enables SG stubs for non-secure entry points</li>
<li>The<code>–cmse-implib</code> and <code>–out-implib=…</code> linker flags, which tell the linker to generate veneers in object file formats, which in turn will be linked to the non-secure domain to access the associated secure API calls</li>
</ul>
<p>Once built using <code>make</code>, the secure firmware image can be uploaded to the device flash, using the following command:</p>
<pre class="console">
STM32_Programmer_CLI -c port=swd -d bootloader.bin 0x0C000000</pre>
<p>The microcontroller flash is now populated with the secure firmware, our enhanced bootloader that is ready<a id="_idIndexMarker901"/> to set up all the parameters in the TrustZone controller<a id="_idIndexMarker902"/> and stage the non-secure application. The obvious next step is to compile and install the non-secure world counterpart.</p>
<h2 id="_idParaDest-263"><a id="_idTextAnchor439"/>Compiling and linking non-secure applications</h2>
<p>The linker script for our non-secure application<a id="_idIndexMarker903"/> defines the boundaries for the world<a id="_idIndexMarker904"/> as seen from the non-secure execution domain. Secure and NSC regions are not reachable from here. Our view on the flash memory is restricted to its upper half, and the accessible RAM is limited to the upper half of the SRAM1 bank. The <code>target.ld</code> linker script in the non-secure application defines these regions as follows:</p>
<pre class="source-code">
FLASH (rx) : ORIGIN = 0x08040000, LENGTH = 256K
RAM (rwx) :  ORIGIN = 0x20018000, LENGTH = 96K</pre>
<p>From this point onward, the build process is similar to building normal applications with no support for TrustZone. Unlike its secure counterpart, non-secure applications do not require any special compiler or <a id="_idTextAnchor440"/>linker flags.</p>
<p>The noticeable exception consists of the extra object file generated by the secure application build process, which allows the non-secure application to briefly interact with the secure world. The contract between the secure and non-secure domains consists of the secure API defined by the secure world. In our example, we have only defined one single secure function, <code>nsc_blue_led_toggle</code>. The object file containing the veneers (called <code>cmse_led.o</code> in our example), automatically generated when compiling the code for the secure domain, is linked within the non-secure application, and it is in fact the code that satisfies the symbol dependency in the secure application for these special symbols. We will explore the details of this procedure in the next subsection, <em class="italic">Inter-domain transitions</em>.</p>
<p>Once the non-secure application has been built by running <code>make</code>, we upload the non-secure firmware image into the internal flash of the target, starting from the address <code>0x08040000</code>:</p>
<pre class="console">
STM32_Programmer_CLI -c port=swd <a id="_idTextAnchor441"/>-d image.bin 0x08040000</pre>
<p>We will now take a c<a id="_idTextAnchor442"/>loser look at the transitions from secure to non-secure domains and vice versa, to understand how new ARMv8-M instructions<a id="_idIndexMarker905"/> are involved in the transition operations<a id="_idIndexMarker906"/> and how these should be used in such cases.</p>
<h2 id="_idParaDest-264"><a id="_idTextAnchor443"/>Inter-domain transitions</h2>
<p>When our secure world<a id="_idIndexMarker907"/> example bootloader is ready to stage the non-secure world application, we can notice some differences in the assembly that prepares <a id="_idTextAnchor444"/>the CPU registers and executes the jump to the non-secure domain. First, the <code>VTOR</code> system register is banked when TrustZone is enabled. This means that there are two separate registers that hold the offset for the vector table, one for each execution domain – VTOR_S and VTOR_NS, for secure and non-secure domains, respectively. Before jumping into the entry point for non-secure world code, the VTOR_NS register should contain the offset of the interrupt vector for the non-secure world application. As we know, the IV sits at the beginning of the binary image, so the following assignment in the bootloader’s <code>main</code> procedure ensures that eventually our non-secure domain code will be able to execute interrupt service routines:</p>
<pre class="source-code">
  /* Update IV */
  VTOR_NS = ((uint32_t)app_IV);</pre>
<p>After this system register is set, we acquire the two important pointers needed for staging, similar to how we would do for bootloaders without TrustZone-M capabilities, like the one proposed in <a href="B18730_04.xhtml#_idTextAnchor115"><em class="italic">Chapter 4</em></a>, <em class="italic">The Boot-Up Procedure</em>. These pointers, stored in the first two 32-bit words of the non-secure application binary image, are the initial stack pointer and the actual entry point containing the address of the <code>isr_reset</code> handler respectively. We read these two addresses into local stack variables before staging:</p>
<pre class="source-code">
  app_end_stack =
     (*((uint32_t *)(NS_WORLD_ENTRY_ADDRESS)));
  app_entry =
     (void *)(*((uint32_t *)(NS_WORLD_ENTRY_ADDRESS + 4)));</pre>
<p>In our example, we size the stack area in advance for the non-secure application, calculating the lowest address allowed for the stack as follows:</p>
<pre class="source-code">
  app_stack_limit = app_end_stack - MAX_NS_STACK_SIZE;</pre>
<p>We then assign this value to the MSPLIM_NS register. MSPLIM_NS is a special register, so as usual we must use the <code>msr</code> instruction:</p>
<pre class="source-code">
  asm volatile("msr msplim_ns, %0" ::"r"(app_stack_limit));</pre>
<p>We then set the value for the new stack pointer, which will replace SP once the domain transition is complete:</p>
<pre class="source-code">
  asm volatile("msr msp_ns, %0" ::"r"(app_end_stack));</pre>
<p>The actual jump to non-secure code<a id="_idIndexMarker908"/> is where things differ a lot from our previous bootloader introduced in <a href="B18730_04.xhtml#_idTextAnchor115"><em class="italic">Chapter 4</em></a>, <em class="italic">The Boot-Up Procedure</em>. First, we must ensure that the address for the jump is adjusted to comply with the convention used in ARMv8 transitions. The value we read from the binary image into the <code>app_entry</code> local variable is in fact odd, which is the classic requirement when assigning a new value to the PC register when jumping within the same domain – for example, when using <code>mov pc, ...</code> instructions in ARMv7-M, such as the one in the example bootloader from <a href="B18730_04.xhtml#_idTextAnchor115"><em class="italic">Chapter 4</em></a>, <em class="italic">The Boot-Up Procedure</em>. In ARMv8-M, the instruction that executes the jump and the domain transition into the non-secure world at the same time, is <code>blxns</code>. However, when invoking <code>blxns</code> or any other instruction that implies a jump to a non-secure address, we must ensure that the destination address for t<a id="_idTextAnchor445"/>he jump has its least significant bit turned off. For this reason, we decrease the value of <code>app_entry</code> by one before executing <code>blxns</code>:</p>
<pre class="source-code">
  /* Jump to non-secure app_entry */
  asm volatile("mov r12, %0" ::"r"
     ((uint32_t)app_entry - 1));
  asm volatile("blxns   r12" );</pre>
<p>This is the last instruction executed in the secure domain before finally staging our non-secure application. If we use the debugger to check the values of the registers while stepping through these last instructions, we can see the values of the CPU registers being updated, and then finally, the SP register will point to the new context in the non-secure domain.</p>
<p>From this point onward, any<a id="_idTextAnchor446"/> attempt to jump back into the secure domain is, of course, not allowed and will generate an exception. However, as we have previously mentioned, the purpose of the functions placed in the NSC region is to provide temporary and controlled execution of secure functions from the non-secure domain.</p>
<p>In our example, before transitioning to the non-secure execution domain, we impose some limitation on access to the GPIO lines associated with the three LEDs, by setting the corresponding bits in the <code>GPIOx_SECCFG</code> register, as explained in the <em class="italic">Configuring secure access to peripherals</em> subsection previously in this chapter.</p>
<p>When both images composing<a id="_idIndexMarker909"/> the example are uploaded to the target platform, we can power-cycle <a id="_idTextAnchor447"/>and observe the effects by looking at the three LEDs. After rebooting, we should see the red LED that will be turned on at startup<a id="_idTextAnchor448"/> and kept on while the secure code is running in the bootloader. After spinning for an arbitrary number of cycles, to give us enough time to inspect the LED status, the red LED will then be turned off and secured. The blue LED is secured too, through the <code>blue_led_secure(1)</code> call executed before staging. The green LED is not secured and can be accessed normally in the non-secure domain.</p>
<p>When the non-secure application starts, we can see the green LED constantly on and the blue LED rapidly blinking. The latter i<a id="_idTextAnchor449"/>s only possible thanks to the fact that non-secure applications can access a function within the secure APIs.</p>
<p>We can have a look at the assembly generated for this function by running <code>arm-none-eabi-objdump –D</code> on the secure-world <strong class="bold">elf</strong> file. We immediately not<a id="_idTextAnchor450"/>ice<a id="_idIndexMarker910"/> that the non-secure callable function stub generated is in fact a short procedure placed at the beginning of the non-callable section:</p>
<pre class="source-code">
0c001000 &lt;nsc_blue_led_toggle&gt;:
c001000:   e97f e97f   sg
c001004:   f7ff bdd2   b.w c000bac
              &lt;__acle_se_nsc_blue_led_toggle&gt;</pre>
<p>The most interesting part of the code running in the NSC area is the use of the special assembly instruction, <code>sg</code>, which is a new instruction introduced in ARMv8-M with the specific purpose of implementing secure calls from non-secure domains. This instruction prepares the branching to an secure call in the secure flash space, and it is only legal when it is executed from an non-secure callable area.</p>
<p>Also, note that the real implementation is in fact contained in the <code>__acle_se_nsc_blue_led_toggle</code> function, generated by the compiler and placed in the S region of the flash.</p>
<p>The assembly code generated by the veneer for <code>nsc_blue_led_toggle</code>, as seen by disassembling the non-secure application in the same way after including the generated object in the final image, should look like the following:</p>
<pre class="source-code">
080408e8 &lt;__nsc_blue_led_toggle_veneer&gt;:
80408e8:   f85f f000   ldr.w   pc, [pc]    ; 80408ec \
                       &lt;__nsc_blue_led_toggle_veneer+0x4&gt;
80408ec:   0c001001</pre>
<p>The conclusion of the procedure<a id="_idIndexMarker911"/> of calling an secure function from the non-secure domain is in the tail of the actual implementation of the secure function toggling the blue LED, <code>__acle_se_nsc_blue_led_toggle</code>:</p>
<pre class="source-code">
c000bee:   4774        bxns    lr</pre>
<p>This should already look familiar to us, as it is in fact the non-linked version of the <code>bxlns</code> instruction that we have seen before, performing a jump to the return address of the non-secure veneer stored in the link register, while also transitioning back to the non-secure domain. The following checklist is a recap of the steps involved when a secure function is called from the NS execution domain in this chapter’s example:</p>
<ol>
<li>non-secure world code calls the veneer for <code>nsc_blue_led_toggle</code>, which is implemented in the <code>cmse_leds.o</code> object that is generate<a id="_idTextAnchor451"/>d when compiling the secure code and linked to the non-secure application.</li>
<li>The veneer knows the SG stub location in the NSC region. This region is accessible for execution from the secure world, while being placed in a specific region inside the secure firmware. The veneer then proceeds to jump to the SG stub.</li>
<li>The SG stub calls the <code>sg</code> instruction, initiating the transition to the secure world, and then jumps to the actual implementation, <code>__acle_se_nsc_blue_led_toggle</code>. This now executes in the secure domain, performing the requested action (in our example, this is toggling the value of the GPIO line connected to the blue LED).</li>
<li>When the procedure terminates, the secure function performs a transition back to the non-secure world by using the <code>bxns</code> instruction, while at the same time jumping back to the address of the original caller in the non-secure world.</li>
</ol>
<p>Despite its simplicity, our example shows how to configure and use all the features needed to separate the two execution domains, as well as the mechanisms to be used to implement the interactions between the two worlds. The design of these interactions in the secure domain will determine the capabilities offered to non-secure applications. The boundaries and the interface for the transitions act like a contract between the two parts, which is enforced <a id="_idIndexMarker912"/>by the hardware itself, thanks to TrustZone-M.</p>
<h1 id="_idParaDest-265"><a id="_idTextAnchor452"/>Summary</h1>
<p>ARMv8-M is the newest architecture defined by ARM for modern microcontrollers. It extends and completes the capabilities of its predecessor, ARMv7-M, by integrating several new features. The most important improvement for this novel architecture design is the possibility to implement a TEE by separating the execution domains and creating a sandboxed environment to execute non-secure applications.</p>
<p>In real-life scenarios, this gives flexibility to the deployment of applications from different providers, with distinct levels of trust regarding accessing features and resources on a system.</p>
<p>In this last chapter, we have analyzed the mechanisms available in the TrustZone-M technology. TrustZone-M can be activated on ARMv8-M systems for the purpose of integrating a powerful, hardware-assisted solution, aimed to protect system components from any access that has not been explicitly authorized by a system supervisor component running in the secure domain.</p>
</div>
</body></html>