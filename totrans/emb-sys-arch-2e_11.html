<html><head></head><body>
<div id="_idContainer064">
<h1 class="chapter-number" id="_idParaDest-247"><a id="_idTextAnchor403"/><span class="koboSpan" id="kobo.1.1">11</span></h1>
<h1 id="_idParaDest-248"><a id="_idTextAnchor404"/><span class="koboSpan" id="kobo.2.1">Trusted Execution Environment</span></h1>
<p><span class="koboSpan" id="kobo.3.1">An important step in the technological evolution of microcontroller hardware architecture has been recently achieved with the introduction of a domain separation mechanism, which is already present in other</span><a id="_idIndexMarker818"/><span class="koboSpan" id="kobo.4.1"> architectures, where it is usually referred to as a </span><strong class="bold"><span class="koboSpan" id="kobo.5.1">Trusted Execution Environment</span></strong><span class="koboSpan" id="kobo.6.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.7.1">or </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.8.1">TEE</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.10.1">TEE is an abstraction that provides two or more separated execution domains, or “worlds”, with different capabilities and permissions to access devices, resources, </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">and peripherals.</span></span></p>
<p><span class="koboSpan" id="kobo.12.1">Isolating the execution environment of one or more software components</span><a id="_idIndexMarker819"/><span class="koboSpan" id="kobo.13.1"> and modules, also generally known as </span><strong class="bold"><span class="koboSpan" id="kobo.14.1">sandboxing</span></strong><span class="koboSpan" id="kobo.15.1">, consists of limiting their view of the system, without impacting their performance and normal operation. </span><span class="koboSpan" id="kobo.15.2">This is a requirement for many use cases and domains in computer science, and not only for increasing the security of </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">embedded systems.</span></span></p>
<p><span class="koboSpan" id="kobo.17.1">Similar hardware-assisted isolation mechanisms in other domains are the building blocks of the cloud server infrastructure as we know it today, in the form of virtualization extensions and security isolation mechanisms that allow us to run multiple “guest” virtual machines or containers simultaneously on the </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">same hardware.</span></span></p>
<p><span class="koboSpan" id="kobo.19.1">The concepts and technologies analyzed in this chapter are </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">as follows:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.21.1">Sandboxing</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.22.1">TrustZone-M</span></span></li>
<li><span class="koboSpan" id="kobo.23.1">System </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">resources separation</span></span></li>
<li><span class="koboSpan" id="kobo.25.1">Building and running </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">the example</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.27.1">By the end of this chapter, you will have learned about TEE and how to configure and use TrustZone-M on Cortex-M microcontrollers to obtain two separate </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">execution domains.</span></span></p>
<h1 id="_idParaDest-249"><a id="_idTextAnchor405"/><span class="koboSpan" id="kobo.29.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.30.1">In order to run the proposed example available in this book’s repository, an STM32L552 microcontroller is required. </span><span class="koboSpan" id="kobo.30.2">The TrustZone-M technology is only supported by the newest family of ARM Cortex-M microcontrollers. </span><span class="koboSpan" id="kobo.30.3">The STM32L552 is a Cortex-M33, fully supporting TrustZone-M, which makes it a convenient and affordable choice for taking our first steps when learning about </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">this technology.</span></span></p>
<p><span class="koboSpan" id="kobo.32.1">The code files for this chapter are available </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">at </span></span><a href="https://github.com/PacktPublishing/Embedded-Systems-Architecture-Second-Edition/tree/main/Chapter11"><span class="No-Break"><span class="koboSpan" id="kobo.34.1">https://github.com/PacktPublishing/Embedded-Systems-Architecture-Second-Edition/tree/main/Chapter11</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.35.1">.</span></span></p>
<h1 id="_idParaDest-250"><a id="_idTextAnchor406"/><span class="koboSpan" id="kobo.36.1">Sandboxing</span></h1>
<p><span class="koboSpan" id="kobo.37.1">Sandboxing is a generic concept</span><a id="_idIndexMarker820"/><span class="koboSpan" id="kobo.38.1"> in computer security that refers to a set of hardware and software measures that limit the “view” of the system for one or more of its components, to restrict the area of the system affected by accidental malfunctions or purposedly forged malicious attacks and prevent them from spreading across the entire system. </span><span class="koboSpan" id="kobo.38.2">Sandboxing can have different forms and implementations, which may or may not leverage specific hardware functionalities to improve safety </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">and effectiveness.</span></span></p>
<p><span class="koboSpan" id="kobo.40.1">By the term TEE, we refer</span><a id="_idIndexMarker821"/><span class="koboSpan" id="kobo.41.1"> to those sandbox mechanisms that involve the CPU keeping track of the secure status of the running code at all times, without significantly impacting the performance of the running application. </span><span class="koboSpan" id="kobo.41.2">Due to these TEE mechanisms being intrinsically bonded to the CPU design, TEE behavior, management, and communication models in sandboxes differ across heterogeneous platforms and heavily depend on the architecture. </span><span class="koboSpan" id="kobo.41.3">Moreover, TEEs can be used for different purposes, often in combination with cryptography to preserve the integrity and authenticity of software through a hardware root </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">of trust.</span></span></p>
<p><span class="koboSpan" id="kobo.43.1">In 2005, Intel implemented the first virtualization instructions (Intel VT) for x86 processors to run isolated virtual machine code natively (as opposed to emulating the CPU in a dedicated process on the host machine), by providing the hardware-assisted virtualization of the core components (CPU, RAM, and peripherals). </span><span class="koboSpan" id="kobo.43.2">Intel CPUs limit the access of the guest virtual machines to the real hardware using an extension of the existing hierarchical</span><a id="_idIndexMarker822"/><span class="koboSpan" id="kobo.44.1"> protection domains, often simply called </span><strong class="bold"><span class="koboSpan" id="kobo.45.1">rings</span></strong><span class="koboSpan" id="kobo.46.1">, already used for </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">kernel/userspace separation.</span></span></p>
<p><span class="koboSpan" id="kobo.48.1">Virtual machines</span><a id="_idIndexMarker823"/><span class="koboSpan" id="kobo.49.1"> are not the only use case</span><a id="_idIndexMarker824"/><span class="koboSpan" id="kobo.50.1"> of TEE on x86 processors. </span><span class="koboSpan" id="kobo.50.2">Intel </span><strong class="bold"><span class="koboSpan" id="kobo.51.1">Software Guard Extensions</span></strong><span class="koboSpan" id="kobo.52.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.53.1">SGX</span></strong><span class="koboSpan" id="kobo.54.1">) is a set of security-related instructions present in many x86 CPUs, protecting specific memory regions, or enclaves, from unauthorized access. </span><span class="koboSpan" id="kobo.54.2">While these instructions have been recently removed from consumer Intel CPUs, they are still present in specific microprocessors in the cloud and enterprise hardware segment. </span><span class="koboSpan" id="kobo.54.3">SGX can be used for several purposes, such as providing a secure vault to hide secret keys to be used securely by the applications. </span><span class="koboSpan" id="kobo.54.4">Originally, however, they were introduced</span><a id="_idIndexMarker825"/><span class="koboSpan" id="kobo.55.1"> to fulfill the specific task of implementing </span><strong class="bold"><span class="koboSpan" id="kobo.56.1">Digital Rights Management</span></strong><span class="koboSpan" id="kobo.57.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.58.1">DRM</span></strong><span class="koboSpan" id="kobo.59.1">) on PCs, which would have enforced copyright protection on media and proprietary software content by authorizing access to the protected content only to pre-authorized, signed software applications. </span><span class="koboSpan" id="kobo.59.2">In this setup, the adversaries that TEE protects the system against are the final </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">users themselves.</span></span></p>
<p><span class="koboSpan" id="kobo.61.1">Later on, AMD added vendor-specific architecture</span><a id="_idIndexMarker826"/><span class="koboSpan" id="kobo.62.1"> extensions to their CPUs, grouped into a technology called </span><strong class="bold"><span class="koboSpan" id="kobo.63.1">Secure Encrypted Virtualization</span></strong><span class="koboSpan" id="kobo.64.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.65.1">SEV</span></strong><span class="koboSpan" id="kobo.66.1">). </span><span class="koboSpan" id="kobo.66.2">In addition to providing a sandbox for running virtual machines managed by a hypervisor, SEV uses hardware-assisted encryption to ensure the confidentiality of the content of single memory pages, and even CPU registers, </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">during execution.</span></span></p>
<p><span class="koboSpan" id="kobo.68.1">The Intel architectures, however, were not the first ones to introduce CPU-assisted, built-in, secure extensions. </span><span class="koboSpan" id="kobo.68.2">ARM started research on trusted computing in the early 2000s and finally</span><a id="_idIndexMarker827"/><span class="koboSpan" id="kobo.69.1"> announced support for a technology called TrustZone in 2003. </span><span class="koboSpan" id="kobo.69.2">Modern ARM microprocessors, such as those</span><a id="_idIndexMarker828"/><span class="koboSpan" id="kobo.70.1"> in the Cortex-A family, support a technology called TrustZone-A, which implements two separate Secure (S) and Non-Secure (NS) worlds, the latter having a restricted pre-configured view on the actual system, while the former is capable of accessing all the hardware </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">resources directly.</span></span></p>
<p><span class="koboSpan" id="kobo.72.1">To find the first microcontrollers implementing TEE, we have to look at the recently designed RISC-V architecture. </span><span class="koboSpan" id="kobo.72.2">Both microprocessors and microcontrollers within the RISC-V families offer complete sandboxes separate from each other, in both 32-bit and 64-bit architectures that implement “S” or “U” extensions. </span><span class="koboSpan" id="kobo.72.3">Each hardware-assisted container provides a subset of the resources available on the system and runs its </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">own firmware.</span></span></p>
<p><span class="koboSpan" id="kobo.74.1">Finally, the newest family of microcontrollers by ARM, the ARMv8-M family, includes the extensions and the microcode needed to implement isolation between secure and non-secure execution domains, based on the existing and well-oiled TrustZone technology design. </span><span class="koboSpan" id="kobo.74.2">This feature is called TrustZone-M, and it is the specific</span><a id="_idIndexMarker829"/><span class="koboSpan" id="kobo.75.1"> technology that we will be focusing on in more detail later in this chapter. </span><span class="koboSpan" id="kobo.75.2">ARMv8-M is a direct evolution of the ARMv7-M family of microcontrollers that have been used as a reference platform in all the previous chapters of </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">this book.</span></span></p>
<p><span class="koboSpan" id="kobo.77.1">The rest of this chapter</span><a id="_idIndexMarker830"/><span class="koboSpan" id="kobo.78.1"> will refer exclusively to TrustZone-M and how to configure and develop components in an embedded system, implementing TEE on the ARMv8-M family of microcontrollers. </span><span class="koboSpan" id="kobo.78.2">The term TrustZone from now on will refer specifically to the </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">TrustZone-M technology.</span></span></p>
<h1 id="_idParaDest-251"><a id="_idTextAnchor407"/><span class="koboSpan" id="kobo.80.1">TrustZone-M</span></h1>
<p><span class="koboSpan" id="kobo.81.1">ARMv7-M cores, such as the Cortex-M0+ and Cortex-M4</span><a id="_idIndexMarker831"/><span class="koboSpan" id="kobo.82.1"> microcontrollers, have dominated the embedded market for decades and are still the most popular choice for many embedded system designs. </span><span class="koboSpan" id="kobo.82.2">Although there have been a number of changes and additions, the new Cortex-M23 and Cortex-M33 cores, as well as the newer M35P and M55, have inherited and expanded many of the successful features of the Cortex-M0, Cortex-M4, and </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">Cortex-M7 microcontrollers.</span></span></p>
<p><span class="koboSpan" id="kobo.84.1">In a typical TrustZone use case, multiple actors may be involved in the distinct phases of software development. </span><span class="koboSpan" id="kobo.84.2">The owner of a device may provide a base system, already equipped with all the software authorized to run in the secure world. </span><span class="koboSpan" id="kobo.84.3">This would still leave the possibility for a system integrator to customize the non-secure part but with a restricted view of the system, which depends on the configuration of the resources allowed by the secure domain. </span><span class="koboSpan" id="kobo.84.4">The system integrator in this case receives a system that is partially locked, with TrustZone enabled and flash memory protections in place to protect its integrity. </span><span class="koboSpan" id="kobo.84.5">The secure software provided supervises the execution of any custom software in the non-secure domain, while preserving the resources mapped in the secure world and limiting access from the running application. </span><span class="koboSpan" id="kobo.84.6">System integrators without authorized access to the secure execution domain can still run privileged or non-privileged software in the non-secure world, thus including operating systems and device drivers that access the interfaces authorized, either directly, or with some assistance from the </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">secure supervisor.</span></span></p>
<p><span class="koboSpan" id="kobo.86.1">The example associated with this chapter can be compiled and run on the reference platform. </span><span class="koboSpan" id="kobo.86.2">This example is based on the bootloader example introduced in </span><a href="B18730_04.xhtml#_idTextAnchor115"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.87.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.88.1">, </span><em class="italic"><span class="koboSpan" id="kobo.89.1">The Boot-Up Procedure</span></em><span class="koboSpan" id="kobo.90.1">. </span><span class="koboSpan" id="kobo.90.2">This is due to the similarity of the structure of the TrustZone-based solution that we want to describe, because the software for the two execution domains is shipped into separate binaries. </span><span class="koboSpan" id="kobo.90.3">In the TrustZone case, the separation between bootloader code executing in the secure domain and staging an application running in the non-secure world will help us understand the elements and tools u</span><a id="_idTextAnchor408"/><span class="koboSpan" id="kobo.91.1">sed to build, configure, and run the components on a </span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">real system.</span></span></p>
<p><span class="koboSpan" id="kobo.93.1">The next subsection</span><a id="_idIndexMarker832"/><span class="koboSpan" id="kobo.94.1"> contains a description of the reference platform, and then we will briefly introduce the execution model behind the secure and non-secure domains, which will then bring us to a deeper analysis of the TrustZone-M units and controllers regulating resource separation on </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">a system.</span></span></p>
<h2 id="_idParaDest-252"><a id="_idTextAnchor409"/><span class="koboSpan" id="kobo.96.1">Reference platform</span></h2>
<p><span class="koboSpan" id="kobo.97.1">The microcontroller used for reference</span><a id="_idIndexMarker833"/><span class="koboSpan" id="kobo.98.1"> in the examples is the STM32L552, a Cortex-M33 CPU that can be found on development boards in the convenient Nucleo-144 format. </span><span class="koboSpan" id="kobo.98.2">The STM32L5 series of microcontrollers may be considered the closest evolution of the older STM32F4 series, targeting the same slice of the market by combining low-power modes with high performance. </span><span class="koboSpan" id="kobo.98.3">For this reason, a microcontroller in this series has been selected in this chapter as a reference platform for the examples provided. </span><span class="koboSpan" id="kobo.98.4">Most of the concepts and the components of the TrustZone-M technology that will be described are, however, applicable to all the microcontrollers in the ARMv8-M family available from ST Microelectronics and several other </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">chip manufacturers.</span></span></p>
<p><span class="koboSpan" id="kobo.100.1">On the STM32L552ZE, the CPU clock can be configured to run at 110 MHz. </span><span class="koboSpan" id="kobo.100.2">The microcontroller is equipped with 256 KB of SRAM, divided into two banks SRAM1 and SRAM2 mapped into separate regions. </span><span class="koboSpan" id="kobo.100.3">512 KB of flash memory can be used as one contiguous space or configured as two separate banks. </span><span class="koboSpan" id="kobo.100.4">The ST microcontroller provides platform-specific libraries and tools that are not part of the provided examples, which as usual are based on a fresh implementation that begins with an understanding of the documentation. </span><span class="koboSpan" id="kobo.100.5">The only exception to this approach in the example we are going to introduce is the use of the STM32 programming command-line interface, </span><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">STM32_Programmer_CLI</span></strong><span class="koboSpan" id="kobo.102.1">, which can be used to display the current value of the programmable option bytes, just by connecting through the ST-Link debugger on board to the PC with a USB cable and running </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.104.1">
STM32_Programmer_CLI -c port=swd -ob displ</span></pre>
<p><span class="koboSpan" id="kobo.105.1">This tool will be useful</span><a id="_idIndexMarker834"/><span class="koboSpan" id="kobo.106.1"> to set the </span><em class="italic"><span class="koboSpan" id="kobo.107.1">option bytes</span></em><span class="koboSpan" id="kobo.108.1"> required to turn TrustZone on and off and set up other options for separating areas of flash memory. </span><span class="koboSpan" id="kobo.108.2">Values for option bytes are stored in non-volatile memory, and the values will be retained after the board has been </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">powered off.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.110.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.111.1">Modifying some of the option bytes accessible through a programmer tool may be irreversible and, in some cases, brick your device. </span><span class="koboSpan" id="kobo.111.2">Please refer to the reference manual and application notes of your microcontroller before changing </span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">any option.</span></span></p>
<p><span class="koboSpan" id="kobo.113.1">One of the option bytes contains the </span><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">TZEN</span></strong><span class="koboSpan" id="kobo.115.1"> flag, which should be disabled per the factory default. </span><span class="koboSpan" id="kobo.115.2">Only when TrustZone-M has been configured will we then enable it on the target to upload and run the example. </span><span class="koboSpan" id="kobo.115.3">The bootloader part in the secure world will be responsible for setting up the environment for the application, installed as a different binary, and executing it in the non-secure domain. </span><span class="koboSpan" id="kobo.115.4">We will then demonstrate the transitions between the two worlds by introducing new ARMv8 assembly instructions introduced f</span><a id="_idTextAnchor410"/><span class="koboSpan" id="kobo.116.1">or </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">this purpose.</span></span></p>
<p><span class="koboSpan" id="kobo.118.1">In the next subsection, we will introduce the extensions included in the ARMv8-M architecture for executing code and controlling execution domains. </span><span class="koboSpan" id="kobo.118.2">These extensions are generic and included in all the ARMv8-M microcontrollers that support TrustZone, and are the core component for the execution in </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">separate domains.</span></span></p>
<h2 id="_idParaDest-253"><span class="koboSpan" id="kobo.120.1">Secure and non-secure e</span><a id="_idTextAnchor411"/><span class="koboSpan" id="kobo.121.1">xecution domains</span></h2>
<p><span class="koboSpan" id="kobo.122.1">In </span><a href="B18730_10.xhtml#_idTextAnchor357"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.123.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.124.1">, </span><em class="italic"><span class="koboSpan" id="kobo.125.1">Parallel Tasks and Scheduling</span></em><span class="koboSpan" id="kobo.126.1">, we learned that resource</span><a id="_idIndexMarker835"/><span class="koboSpan" id="kobo.127.1"> separation among threads and between</span><a id="_idIndexMarker836"/><span class="koboSpan" id="kobo.128.1"> threads and the operating system is possible, with the help of memory segmentation. </span><span class="koboSpan" id="kobo.128.2">In the ARMv8-m family of microcontrollers, TrustZone-M is often referred to as a security extension because it does, in fact, add one additional level of privilege separation between software components that are running on the target. </span><span class="koboSpan" id="kobo.128.3">These security extensions do not replace the existing thread separation we implemented earlier in the safe version of the scheduler. </span><span class="koboSpan" id="kobo.128.4">Instead, they introduce an additional security mode on top of the </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">existing separati</span><a id="_idTextAnchor412"/><span class="koboSpan" id="kobo.130.1">on.</span></span></p>
<p><span class="koboSpan" id="kobo.131.1">Similar to how an OS running without these extensions enforces a separation between thread mode and privileged mode, and can</span><a id="_idIndexMarker837"/><span class="koboSpan" id="kobo.132.1"> set boundaries for accessing memory-mapped areas using a MPU, TrustZone-M adds </span><strong class="bold"><span class="koboSpan" id="kobo.133.1">Secure</span></strong><span class="koboSpan" id="kobo.134.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.135.1">S</span></strong><span class="koboSpan" id="kobo.136.1">) and </span><strong class="bold"><span class="koboSpan" id="kobo.137.1">Non-Secure</span></strong><span class="koboSpan" id="kobo.138.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.139.1">NS</span></strong><span class="koboSpan" id="kobo.140.1">) execution domains (or “worlds”) with CPU-controlled</span><a id="_idIndexMarker838"/><span class="koboSpan" id="kobo.141.1"> access to the </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">single resources.</span></span></p>
<p><span class="koboSpan" id="kobo.143.1">Within each of those</span><a id="_idIndexMarker839"/><span class="koboSpan" id="kobo.144.1"> worlds, it is still possible to implement</span><a id="_idIndexMarker840"/><span class="koboSpan" id="kobo.145.1"> privileged/thread separation by using the existing mechanism based on the CONTROL bit. </span><span class="koboSpan" id="kobo.145.2">Each security world can have its own privileged and non-privileged execution modes. </span><span class="koboSpan" id="kobo.145.3">An OS running in the NS world can still use the classic privilege separation that has been inherited from the previous ARMv7-M architecture. </span><span class="koboSpan" id="kobo.145.4">This creates a total of four available execution contexts that can be followed simultaneously by the CPU, summarized in this table as a combination of domain and </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">privilege levels:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table001">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.147.1">Secure world</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.148.1">Non-secure world</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.149.1">Secure </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">privileged execution</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.151.1">Non-secure </span><span class="No-Break"><span class="koboSpan" id="kobo.152.1">privileged execution</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.153.1">Secure </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">thread execution</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.155.1">Non-secure </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">thread execution</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.157.1">Table 11.1 – Available execution modes in secure/non-secure domains</span></p>
<p><span class="koboSpan" id="kobo.158.1">As we pointed out in </span><a href="B18730_10.xhtml#_idTextAnchor357"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.159.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.160.1">, </span><em class="italic"><span class="koboSpan" id="kobo.161.1">Parallel Tasks and Scheduling</span></em><span class="koboSpan" id="kobo.162.1">, the Cortex-M4 provides two separate stack pointers (MSP and PSP) to keep track of the different contexts when executing threads or kernel code. </span><span class="koboSpan" id="kobo.162.2">In the Cortex-M33, there is a total of four different stack pointers, MSP_S, PSP_S, MSP_NS, and PSP_NS. </span><span class="koboSpan" id="kobo.162.3">Each stack pointer is aliased into the actual SP register during execution, depending on the current domain </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">and context.</span></span></p>
<p><span class="koboSpan" id="kobo.164.1">A very convenient feature has been added to the ARMv8-M architecture when MAIN extensions are present on the CPU, as in our reference</span><a id="_idIndexMarker841"/><span class="koboSpan" id="kobo.165.1"> platform. </span><span class="koboSpan" id="kobo.165.2">Each one of the four stack pointers has a corresponding </span><strong class="bold"><span class="koboSpan" id="kobo.166.1">stack pointer limit</span></strong><span class="koboSpan" id="kobo.167.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.168.1">SPLIM</span></strong><span class="koboSpan" id="kobo.169.1">) register (called MSPLIM_S, PSPLIM_S, MSPLIM_NS, and PSPLIM_NS respectively). </span><span class="koboSpan" id="kobo.169.2">These registers indicate the lower limit for the stack pointer value in the four cases. </span><span class="koboSpan" id="kobo.169.3">This is in fact an effective countermeasure to the issues analyzed in the </span><em class="italic"><span class="koboSpan" id="kobo.170.1">Stack overflows</span></em><span class="koboSpan" id="kobo.171.1"> subsection in</span><em class="italic"> </em><a href="B18730_05.xhtml#_idTextAnchor149"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.172.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.173.1">, </span><em class="italic"><span class="koboSpan" id="kobo.174.1">Memory Management</span></em><span class="koboSpan" id="kobo.175.1">. </span><span class="koboSpan" id="kobo.175.2">The CPU will constantly check at runtime that the stack never grows past its lower limit in memory by generating an exception when this happens. </span><span class="koboSpan" id="kobo.175.3">This mechanism provides a better hardware-assisted way to protect memory from accidental stack overflows and collisions with other memory regions than the one proposed in the examples from </span><a href="B18730_05.xhtml#_idTextAnchor149"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.176.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.177.1">, </span><em class="italic"><span class="koboSpan" id="kobo.178.1">Memory Management</span></em><span class="koboSpan" id="kobo.179.1">, where we introduced a guard region between the two memory areas assigned to heap </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">and stack.</span></span></p>
<p><span class="koboSpan" id="kobo.181.1">We already analyzed how to switch between execution modes, and how setting or clearing the CONTROL bit while returning from system calls plays a role in the transactions between privilege and thread execution modes.</span><a id="_idTextAnchor413"/><span class="koboSpan" id="kobo.182.1"> The mechanisms for switching between secure and non-secure executions are implemented via specific assembly instructions, which we will explain later after introducing resource separation between secure and </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">non-secure worlds.</span></span></p>
<p><span class="koboSpan" id="kobo.184.1">To better understand</span><a id="_idIndexMarker842"/><span class="koboSpan" id="kobo.185.1"> what system resources the software</span><a id="_idIndexMarker843"/><span class="koboSpan" id="kobo.186.1"> running in the non-secure world may or may not access, the next section will go into detail about the different possibilities provided by the TrustZone-M controller modules to isolate and separate </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">hardware resources.</span></span></p>
<h1 id="_idParaDest-254"><a id="_idTextAnchor414"/><span class="koboSpan" id="kobo.188.1">System resources separation</span></h1>
<p><span class="koboSpan" id="kobo.189.1">When TrustZone-M is enabled, all areas</span><a id="_idIndexMarker844"/><span class="koboSpan" id="kobo.190.1"> mapped in memory, including RAM, peripherals, and even FLASH storage, receive a new security attribute. </span><span class="koboSpan" id="kobo.190.2">Besides the secure and non-secure domains, a security attribute may assume a third value, </span><strong class="bold"><span class="koboSpan" id="kobo.191.1">Non-Secure Callable</span></strong><span class="koboSpan" id="kobo.192.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.193.1">NSC</span></strong><span class="koboSpan" id="kobo.194.1">). </span><span class="koboSpan" id="kobo.194.2">This last attribute defines special regions</span><a id="_idIndexMarker845"/><span class="koboSpan" id="kobo.195.1"> of memory used to implement transactions from the non-secure world to the secure world through a specific mechanism, which will be explained in the last section, </span><em class="italic"><span class="koboSpan" id="kobo.196.1">Building and running the ex</span><a id="_idTextAnchor415"/><span class="koboSpan" id="kobo.197.1">ample</span></em><span class="koboSpan" id="kobo.198.1">. </span><span class="koboSpan" id="kobo.198.2">An NSC area is used to offer secure APIs that act like system calls with new powers. </span><span class="koboSpan" id="kobo.198.3">The secure domain exposes service routines that can perform specific controlled actions while accessing secure resources from its </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">non-secure counterpart.</span></span></p>
<h2 id="_idParaDest-255"><a id="_idTextAnchor416"/><span class="koboSpan" id="kobo.200.1">Security attributes and memory regions</span></h2>
<p><span class="koboSpan" id="kobo.201.1">Cortex-M33 microcontrollers</span><a id="_idIndexMarker846"/> <a id="_idTextAnchor417"/><span class="koboSpan" id="kobo.202.1">offer various levels</span><a id="_idIndexMarker847"/><span class="koboSpan" id="kobo.203.1"> of protection. </span><span class="koboSpan" id="kobo.203.2">The combination of the effects of those </span><a id="_idTextAnchor418"/><span class="koboSpan" id="kobo.204.1">levels determines which of the memory-mapped areas associated with a resource on the system are available to both execution domains and which of them are only accessible from the </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">secure world.</span></span></p>
<p><span class="koboSpan" id="kobo.206.1">Enabling TrustZone-M will also duplicate the representation of some of the system reso</span><a id="_idTextAnchor419"/><span class="koboSpan" id="kobo.207.1">urces. </span><span class="koboSpan" id="kobo.207.2">The flash memory usually mapped from the start of the address 0x08000000 has an alias in the region 0x0C000000, which is used to access the same storage from the secure world. </span><span class="koboSpan" id="kobo.207.3">Many system registers are “banked” and have secure and non-secure versions at separate memory locations. </span><span class="koboSpan" id="kobo.207.4">For example, the GPIOA controller is mapped to the address 0x42020000 when TrustZone is disabled. </span><span class="koboSpan" id="kobo.207.5">When TrustZone is enabled, the same address is used by software running in the non-secure domain if the GPIOA controller is accessible from the non-secure world. </span><span class="koboSpan" id="kobo.207.6">However, software running in the secure domain will use the same controller mapped from the start of the address 0x52020000. </span><span class="koboSpan" id="kobo.207.7">The same banking applies to many other registers in the peripheral region, whic</span><a id="_idTextAnchor420"/><span class="koboSpan" id="kobo.208.1">h have secure and non-secure versions of the same registers mapped into two </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">separate regions.</span></span></p>
<p><span class="koboSpan" id="kobo.210.1">Before being processed by other TrustZone-aware</span><a id="_idIndexMarker848"/><span class="koboSpan" id="kobo.211.1"> components, each memory access is monitored and filtered</span><a id="_idIndexMarker849"/><span class="koboSpan" id="kobo.212.1"> by two units responsible for configuring the attributes. </span><span class="koboSpan" id="kobo.212.2">These are the </span><strong class="bold"><span class="koboSpan" id="kobo.213.1">Security Attribution Unit</span></strong><span class="koboSpan" id="kobo.214.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.215.1">SAU</span></strong><span class="koboSpan" id="kobo.216.1">) and </span><strong class="bold"><span class="koboSpan" id="kobo.217.1">Implementation-Defined Attribution Unit</span></strong><span class="koboSpan" id="kobo.218.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.219.1">IDAU</span></strong><span class="koboSpan" id="kobo.220.1">). </span><span class="koboSpan" id="kobo.220.2">These units affect the accessibility of the entire memory mapping regardless of the type of resource associated with each</span><a id="_idTextAnchor421"/><span class="koboSpan" id="kobo.221.1"> region. </span><span class="koboSpan" id="kobo.221.2">While the SAU is configurable through a set of registers, the IDAU contains hardcoded mappings enforced by the chip manufacturer. </span><span class="koboSpan" id="kobo.221.3">The combination of the attributes of IDAU and SAU influences the accessibility of each memory-mapped region, the following </span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">in particular:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.223.1">Regions mapped as secure by IDAU are not influenced by SAU attributes and will always stay mapped </span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">as secure</span></span></li>
<li><span class="koboSpan" id="kobo.225.1">Regions mapped as NSC by IDAU can be secure or NSC, based on the </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">SAU attribute</span></span></li>
<li><span class="koboSpan" id="kobo.227.1">Regions mapped as non-secure by IDAU will follow the </span><span class="No-Break"><span class="koboSpan" id="kobo.228.1">SAU mapping</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.229.1">The combination of the attributes and the resulting mapping for each region is summarized in the </span><span class="No-Break"><span class="koboSpan" id="kobo.230.1">following table:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table002">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.231.1">IDAU attribute</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.232.1">SAU attribute</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.233.1">Resulting attribute</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.234.1">Secure</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.235.1">Secure, NSC, </span><span class="No-Break"><span class="koboSpan" id="kobo.236.1">or Non-secure</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.237.1">Secure</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.238.1">NSC</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.239.1">Secure</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.240.1">Secure</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.241.1">Non-secure</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.242.1">Secure</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.243.1">Secure</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.244.1">NSC</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.245.1">NSC </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">or </span></span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">N</span></span><span class="No-Break"><span class="koboSpan" id="kobo.248.1">on-secure</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.249.1">NSC</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.250.1">Non-secure</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.251.1">NSC</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.252.1">NSC</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.253.1">Non-secure</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.254.1">Non-secure</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.255.1">Non-secure</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.256.1">Table 11.2 – A combination of IDAU and SAU attributes</span></p>
<p><span class="koboSpan" id="kobo.257.1">By default, our IDAU</span><a id="_idIndexMarker850"/><span class="koboSpan" id="kobo.258.1"> in the STM32L552 reference</span><a id="_idIndexMarker851"/><span class="koboSpan" id="kobo.259.1"> platform enforces the secure/NSC mapping of a few </span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">key regions:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.261.1">The flash memory mapping in secure space, starting at the </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">address </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">0x0C000000</span></strong></span></li>
<li><span class="koboSpan" id="kobo.264.1">The second SRAM bank, SRAM2, mapped from the start of the </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">address </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">0x30000000</span></strong></span></li>
<li><span class="koboSpan" id="kobo.267.1">The memory between </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">0x50000000</span></strong><span class="koboSpan" id="kobo.269.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">0x5FFFFFFF</span></strong><span class="koboSpan" id="kobo.271.1">, reserved for secure peripherals’ control </span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">and configuration</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.273.1">The SAU sets all the regions as secure upo</span><a id="_idTextAnchor422"/><span class="koboSpan" id="kobo.274.1">n reset and is disabled by default. </span><span class="koboSpan" id="kobo.274.2">To execute non-secure code, we must define at least two non-secure regions within the intervals allowed by the </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">IDAU configuration.</span></span></p>
<p><span class="koboSpan" id="kobo.276.1">In our example, we initialize a few memory areas to allow access from the applications, before enabling SAU. </span><span class="koboSpan" id="kobo.276.2">SAU is controlled through four main </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">32-bit registers:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.278.1">SAU_CTRL</span></strong><span class="koboSpan" id="kobo.279.1"> (SAU control): Used to activate SAU. </span><span class="koboSpan" id="kobo.279.2">It contains</span><a id="_idIndexMarker852"/><span class="koboSpan" id="kobo.280.1"> a flag to “invert” the logic of the SAU filter, by setting all the memory regions </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">as non-secure.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.282.1">SAU_RNR</span></strong><span class="koboSpan" id="kobo.283.1"> (SAU region number register): Contains the region</span><a id="_idIndexMarker853"/><span class="koboSpan" id="kobo.284.1"> number to select at the beginning of the configuration procedure for the memory regions. </span><span class="koboSpan" id="kobo.284.2">Further writes to SAU_RBAR and SAU_RLAR will refer to this </span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">numbered region.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.286.1">SAU_RBAR</span></strong><span class="koboSpan" id="kobo.287.1"> (SAU region base address register): Indicates the base address</span><a id="_idIndexMarker854"/><span class="koboSpan" id="kobo.288.1"> of the region that we want </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">to configure.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.290.1">SAU_RLAR</span></strong><span class="koboSpan" id="kobo.291.1"> (SAU region limit address register): Contains</span><a id="_idIndexMarker855"/><span class="koboSpan" id="kobo.292.1"> the end address of the region to configure. </span><span class="koboSpan" id="kobo.292.2">The least significant 5 bits are reserved for flags. </span><span class="koboSpan" id="kobo.292.3">Bit 1, when on, indicates that the region is secure or non-secure callable. </span><span class="koboSpan" id="kobo.292.4">Bit 0 enables the region and indi</span><a id="_idTextAnchor423"/><span class="koboSpan" id="kobo.293.1">cates that its configuration </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">is complete.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.295.1">In the following example</span><a id="_idIndexMarker856"/><span class="koboSpan" id="kobo.296.1"> code, you can find </span><a id="_idIndexMarker857"/><span class="koboSpan" id="kobo.297.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">sau_init_region</span></strong><span class="koboSpan" id="kobo.299.1"> convenience function. </span><span class="koboSpan" id="kobo.299.2">Given a region identifier, base address, end address, and secure bit value, it will set all the register </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">values accordingly:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.301.1">
static void sau_init_region(uint32_t region,
    uint32_t start_addr,
    uint32_t end_addr,
    int secure)
{
  uint32_t secure_flag = 0;
  if (secure)
      secure_flag = SAU_REG_SECURE;
  SAU_RNR = region &amp; SAU_REGION_MASK;
  SAU_RBAR = start_addr &amp; SAU_ADDR_MASK;
  SAU_RLAR = (end_addr &amp; SAU_ADDR_MASK)
      | secure_flag | SAU_REG_ENABLE;
}</span></pre>
<p><span class="koboSpan" id="kobo.302.1">This function is called by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">secure_world_init</span></strong><span class="koboSpan" id="kobo.304.1"> initialization function to map the four SAU regions</span><a id="_idIndexMarker858"/><span class="koboSpan" id="kobo.305.1"> that we want to configure for this example, which are, specifically, </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.307.1">Region 0</span></strong><span class="koboSpan" id="kobo.308.1">: An non-secure callable section, where our secure API that is callable from the non-secure application will be stored. </span><span class="koboSpan" id="kobo.308.2">In this example, we expose a single function called </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">nsc_blue_led_toggle</span></strong><span class="koboSpan" id="kobo.310.1">, which will be the only way that the application can access an otherwise secure-only GPIO, wired to the blue LED on the </span><span class="No-Break"><span class="koboSpan" id="kobo.311.1">Nucleo board.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.312.1">Region 1</span></strong><span class="koboSpan" id="kobo.313.1">: An non-secure area in the flash, starting from the address </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">0x08040000</span></strong><span class="koboSpan" id="kobo.315.1">. </span><span class="koboSpan" id="kobo.315.2">This is where the code of our non-secure application </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">will reside.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.317.1">Region 2</span></strong><span class="koboSpan" id="kobo.318.1">: An non-secure part of the SRAM1 bank that can be used by the non-secure application for the stack and variables. </span><span class="koboSpan" id="kobo.318.2">This is a necessary step to ensure the application can access </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">RAM addresses.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.320.1">Region 3</span></strong><span class="koboSpan" id="kobo.321.1">: The non-secure peripheral control mapped at the address </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">0x40000000</span></strong><span class="koboSpan" id="kobo.323.1">, including the non-secure GPIO controllers. </span><span class="koboSpan" id="kobo.323.2">This area will be accessed by the non-secure application to set the system clock and control the green led in </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">the example.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.325.1">The code for the SAU initialization</span><a id="_idIndexMarker859"/><span class="koboSpan" id="kobo.326.1"> in the example</span><a id="_idIndexMarker860"/><span class="koboSpan" id="kobo.327.1"> is </span><span class="No-Break"><span class="koboSpan" id="kobo.328.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.329.1">
static void secure_world_init(void)
{
  /* Non-secure callable: NSC functions area */
  sau_init_region(0, 0x0C001000, 0x0C001FFF, 1);
  /* Non-secure: application flash area */
  sau_init_region(1, 0x08040000, 0x0804FFFF, 0);
  /* Non-secure RAM region in SRAM1 */
  sau_init_region(2, 0x20018000, 0x2002FFFF, 0);
  /* Non-secure: internal peripherals */
  sau_init_region(3, 0x40000000, 0x4FFFFFFF, 0);</span></pre>
<p><span class="koboSpan" id="kobo.330.1">The code in the tail of this function activates the SAU and enables a specific handler that detects </span><span class="No-Break"><span class="koboSpan" id="kobo.331.1">secure faults:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.332.1">
  /* Enable SAU */
  SAU_CTRL = SAU_INIT_CTRL_ENABLE;
  /* Enable securefault handler */
  SCB_SHCSR |= SCB_SHCSR_SECUREFAULT_EN;
}</span></pre>
<p><span class="koboSpan" id="kobo.333.1">By default, enabling SAU would mark all regions as secure, so each region configuration trims an non-secure or non-secure callable “window” within the addressable memory space. </span><span class="koboSpan" id="kobo.333.2">Region 0 is the only region marked with the NSC flag in our example configuration, which means that NSC code (explained later) will be installed here by the secure application. </span><span class="koboSpan" id="kobo.333.3">Regions 1, 2, and 3 are the only memory areas that may be accessed when running in the non-secure domain with </span><span class="No-Break"><span class="koboSpan" id="kobo.334.1">TrustZone-M enabled.</span></span></p>
<p><span class="koboSpan" id="kobo.335.1">As previously </span><a id="_idIndexMarker861"/><span class="koboSpan" id="kobo.336.1">mentioned, IDAU/SAU</span><a id="_idIndexMarker862"/><span class="koboSpan" id="kobo.337.1"> is just the first level of filters for the TrustZone-M protection mechanisms. </span><span class="koboSpan" id="kobo.337.2">Flash memory and RAM are protected by additional secure gates, which can be block-based or watermark-based. </span><span class="koboSpan" id="kobo.337.3">The STM32L552 microcontroller is equipped with a </span><strong class="bold"><span class="koboSpan" id="kobo.338.1">Global TrustZone Controller</span></strong><span class="koboSpan" id="kobo.339.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.340.1">GTZC</span></strong><span class="koboSpan" id="kobo.341.1">), which includes one watermark-based</span><a id="_idIndexMarker863"/><span class="koboSpan" id="kobo.342.1"> gate controller for the flash and one block-based to define secure/non-secure </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">RAM blocks.</span></span></p>
<h2 id="_idParaDest-256"><a id="_idTextAnchor424"/><span class="koboSpan" id="kobo.344.1">Flash memory and secure watermarks</span></h2>
<p><span class="koboSpan" id="kobo.345.1">On the target</span><a id="_idIndexMarker864"/><span class="koboSpan" id="kobo.346.1"> platform, flash memory</span><a id="_idIndexMarker865"/><span class="koboSpan" id="kobo.347.1"> can be configured</span><a id="_idIndexMarker866"/><span class="koboSpan" id="kobo.348.1"> to be mapped as a single, contiguous</span><a id="_idIndexMarker867"/><span class="koboSpan" id="kobo.349.1"> space, or split in half by activating a dual bank configuration. </span><span class="koboSpan" id="kobo.349.2">For the sake of our TrustZone-M example, we will keep the flash memory in a </span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">single bank.</span></span></p>
<p><span class="koboSpan" id="kobo.351.1">In this configuration, when TrustZone is enabled, we can assign an non-secure area in the higher half of the contiguous flash memory space, starting at the address </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">0x08040000</span></strong><span class="koboSpan" id="kobo.353.1">. </span><span class="koboSpan" id="kobo.353.2">When the flash is divided into two banks, each bank can configure its own independent secure watermark. </span><span class="koboSpan" id="kobo.353.3">The flash area in between the start/end addresses is marked as secure, and everything left outside of the marks is non-secure. </span><span class="koboSpan" id="kobo.353.4">The secure area in each bank is delimited by the value of the option bytes, SECWMx_PSTRT and SECWMx_PEND. </span><span class="koboSpan" id="kobo.353.5">If the delimiters overlap – that is, when the value of SECWMx_PEND is bigger than that of SECWMx_PSTRT – the entire area is marked </span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">as non-secure.</span></span></p>
<p><span class="koboSpan" id="kobo.355.1">Their value can be modified using the programmer tool provided, as </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.357.1">
STM32_Programmer_CLI -c port=swd -ob SECWM1_PSTRT=0
   SECWM1_PEND=0x39</span></pre>
<p><span class="koboSpan" id="kobo.358.1">In single-bank mode, each flash sector is 4096 B. </span><span class="koboSpan" id="kobo.358.2">By setting these option bytes, we are marking the first 64 sectors (from </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">0x00</span></strong><span class="koboSpan" id="kobo.360.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">0x39</span></strong><span class="koboSpan" id="kobo.362.1">) as secure, which leaves the other half of the flash, starting from the address </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">0x08040000</span></strong><span class="koboSpan" id="kobo.364.1">, to be used by the non-secure application in our example. </span><span class="koboSpan" id="kobo.364.2">The programmer tool, launched with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">-ob displ</span></strong><span class="koboSpan" id="kobo.366.1"> option, will show </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">the following:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.368.1">   Secure Area 1:</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.369.1">     SECWM1_PSTRT : 0x0  (0x8000000)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.370.1">     SECWM1_PEND  : 0x39  (0x8039000)</span></strong></pre>
<h2 id="_idParaDest-257"><a id="_idTextAnchor425"/><span class="koboSpan" id="kobo.371.1">GTZC configuration and block-based SRAM protection</span></h2>
<p><span class="koboSpan" id="kobo.372.1">An additional</span><a id="_idIndexMarker868"/><span class="koboSpan" id="kobo.373.1"> gate to control </span><a id="_idIndexMarker869"/><span class="koboSpan" id="kobo.374.1">access is present in the TrustZone controller</span><a id="_idIndexMarker870"/><span class="koboSpan" id="kobo.375.1"> on the reference</span><a id="_idIndexMarker871"/><span class="koboSpan" id="kobo.376.1"> platform. </span><span class="koboSpan" id="kobo.376.2">The block-based gate component of the GTZC allows us to configure the secure-only bit to portions of SRAM. </span><span class="koboSpan" id="kobo.376.3">SRAM on STM32L552 is divided into two </span><span class="No-Break"><span class="koboSpan" id="kobo.377.1">main banks:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.378.1">SRAM1: 192 KB of RAM mapped at the </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">address </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.380.1">0x08000000</span></strong></span></li>
<li><span class="koboSpan" id="kobo.381.1">SRAM2: 64 KB of RAM mapped at the address </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">0x30000000</span></strong><span class="koboSpan" id="kobo.383.1"> and set as NSC </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">in IDAU</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.385.1">In our example, we are marking the higher half of SRAM1, starting at the address </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">0x2018000</span></strong><span class="koboSpan" id="kobo.387.1">, as non-secure. </span><span class="koboSpan" id="kobo.387.2">To do so, the GTZC provides two sets of registers, one for each bank, to configure the block-based gate to each page in RAM. </span><span class="koboSpan" id="kobo.387.3">Each block represents 25 6B, and each 32-bit register, by holding one secure bit per block, can map 32 pages, also defined a</span><a id="_idTextAnchor426"/><span class="koboSpan" id="kobo.388.1">s an 8 KB superblock. </span><span class="koboSpan" id="kobo.388.2">24 registers are required to map the 24 superblocks for a total of 192 KB in SRAM1, and only 8 are required to map the 64 KB area </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">in SRAM2.</span></span></p>
<p><span class="koboSpan" id="kobo.390.1">Like for the SAU</span><a id="_idIndexMarker872"/><span class="koboSpan" id="kobo.391.1"> initialization, once again the approach</span><a id="_idIndexMarker873"/><span class="koboSpan" id="kobo.392.1"> taken in the example</span><a id="_idIndexMarker874"/><span class="koboSpan" id="kobo.393.1"> relies on a convenient macro</span><a id="_idIndexMarker875"/><span class="koboSpan" id="kobo.394.1"> that, given a me</span><a id="_idTextAnchor427"/><span class="koboSpan" id="kobo.395.1">mory bank, the superblock number, and its register value, calculates the address for the right register that refers to the superblock and generates the right </span><span class="No-Break"><span class="koboSpan" id="kobo.396.1">assignment statement:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.397.1">
#define SET_GTZC_MPCBBx_S_VCTR(bank,n,val) \
(*((volatile uint32_t *)(GTZC_MPCBB##bank##_S_VCTR_BASE )\
           + n ))= val</span></pre>
<p><span class="koboSpan" id="kobo.398.1">This way we can easily configure block-based gates of contiguous regions within a loop. </span><span class="koboSpan" id="kobo.398.2">The secure-world application example uses the following function to configure the block-based gates for the </span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">two banks:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.400.1">
 static void gtzc_init(void)
{
   int i;
  /* Configure lower half of SRAM1 as secure */
   for (i = 0; i &lt; 12; i++) {
       SET_GTZC_MPCBBx_S_VCTR(1, i, 0xFFFFFFFF);
   }
   /* Configure upper half of SRAM1 as non-secure */
   for (i = 12; i &lt; 24; i++) {
       SET_GTZC_MPCBBx_S_VCTR(1, i, 0x0);
   }
  /* Configure SRAM2 as secure */
   for (i = 0; i &lt; 8; i++) {
       SET_GTZC_MPCBBx_S_VCTR(</span><a id="_idTextAnchor428"/><span class="koboSpan" id="kobo.401.1">2, i, 0xFFFFFFFF);
   }
}</span></pre>
<p><span class="koboSpan" id="kobo.402.1">We now have everything</span><a id="_idIndexMarker876"/><span class="koboSpan" id="kobo.403.1"> required to run the simplest non-secure</span><a id="_idIndexMarker877"/><span class="koboSpan" id="kobo.404.1"> application on the system; we have</span><a id="_idIndexMarker878"/><span class="koboSpan" id="kobo.405.1"> defined the non-secure areas</span><a id="_idIndexMarker879"/><span class="koboSpan" id="kobo.406.1"> in SAU, set the watermark for the separation of the flash memory, and finally, set the block-based gates to enable non-secure access to the higher half </span><span class="No-Break"><span class="koboSpan" id="kobo.407.1">of SRAM1.</span></span></p>
<p><span class="koboSpan" id="kobo.408.1">There is, however, another aspect that deserves attention, and that is the possibility of configuring secure access </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">to peripherals.</span></span></p>
<h2 id="_idParaDest-258"><a id="_idTextAnchor429"/><span class="koboSpan" id="kobo.410.1">Configuring secure access to peripherals</span></h2>
<p><span class="koboSpan" id="kobo.411.1">On the reference</span><a id="_idIndexMarker880"/><span class="koboSpan" id="kobo.412.1"> platforms, peripherals</span><a id="_idIndexMarker881"/><span class="koboSpan" id="kobo.413.1"> are divided into </span><span class="No-Break"><span class="koboSpan" id="kobo.414.1">two categories:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.415.1">Securable peripherals</span></strong><span class="koboSpan" id="kobo.416.1">: Peripherals are not directly connected</span><a id="_idIndexMarker882"/><span class="koboSpan" id="kobo.417.1"> to a local bus, but through a gate system</span><a id="_idIndexMarker883"/><span class="koboSpan" id="kobo.418.1"> controlled by the </span><strong class="bold"><span class="koboSpan" id="kobo.419.1">TrustZone Secure </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.420.1">Controller</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.421.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.422.1">TZSC</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.423.1">)</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.424.1">TrustZone-aware peripherals</span></strong><span class="koboSpan" id="kobo.425.1">: These are peripherals that integrate with TrustZone</span><a id="_idIndexMarker884"/><span class="koboSpan" id="kobo.426.1"> mechanisms – for example, by offering separate interfaces to access their resources, depending on the </span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">execution domain</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.428.1">For the first category of peripherals, the configuration of the secure access and privileged access within secure and non-secure domains can be configured through the TZSC registers within the GTZC. </span><span class="koboSpan" id="kobo.428.2">At system startup, all devices are set as secure by default, so to enable access to UART, I2C, timers, and other peripherals, it will be necessary to turn off the secure bit associated with the </span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">specific controller.</span></span></p>
<p><span class="koboSpan" id="kobo.430.1">TrustZone-aware peripherals have banked registers for both secure domains. </span><span class="koboSpan" id="kobo.430.2">In the next example, we configure three GPIO controllers (</span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">GPIOA</span></strong><span class="koboSpan" id="kobo.432.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">GPIOB</span></strong><span class="koboSpan" id="kobo.434.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">GPIOC</span></strong><span class="koboSpan" id="kobo.436.1">), which are connected to the LEDs on the Nucleo-144 board, via pins C7 (the green LED), B7 (the blue LED), and A9 (the red LED). </span><span class="koboSpan" id="kobo.436.2">The GPIO</span><a id="_idIndexMarker885"/><span class="koboSpan" id="kobo.437.1"> controller registers, when TrustZone is enabled, are banked</span><a id="_idIndexMarker886"/><span class="koboSpan" id="kobo.438.1"> into two regions. </span><span class="koboSpan" id="kobo.438.2">You will notice in the example code the difference between the two LED driver interfaces in the secure and non-secure applications. </span><span class="koboSpan" id="kobo.438.3">In the secure version of </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">led.h</span></strong><span class="koboSpan" id="kobo.440.1">, we define the following address base for the GPIO </span><span class="No-Break"><span class="koboSpan" id="kobo.441.1">controller registers:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.442.1">
#define GPIOA_BASE 0x52020000
#define GPIOB_BASE 0x52020400
#define GPIOC_BASE 0x52020800</span></pre>
<p><span class="koboSpan" id="kobo.443.1">The same controllers, in the non-secure world application, are mapped in the non-secure peripheral </span><span class="No-Break"><span class="koboSpan" id="kobo.444.1">address space:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.445.1">
#define GPIOA_BASE 0x42020000
#define GPIOB_BASE 0x42020400
#define GPIOC_BASE 0x42020800</span></pre>
<p><span class="koboSpan" id="kobo.446.1">This ensures that the GPIO configuration is accessible only through the interface assigned to the non-secure space when running in the </span><span class="No-Break"><span class="koboSpan" id="kobo.447.1">non-secure domain.</span></span></p>
<p><span class="koboSpan" id="kobo.448.1">Additionally, each GPIO controller provides an interface to secure each single controlled pin. </span><span class="koboSpan" id="kobo.448.2">This is achieved through a write-only register controlling the secure and non-secure access with a flag corresponding to each pin. </span><span class="koboSpan" id="kobo.448.3">The</span><a id="_idIndexMarker887"/><span class="koboSpan" id="kobo.449.1"> register is called GPIOx_SECCFG and is located at an offset of </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">0x24</span></strong><span class="koboSpan" id="kobo.451.1"> in each GPIO controller space. </span><span class="koboSpan" id="kobo.451.2">This is only accessible for writing when running in a </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">secure domain.</span></span></p>
<p><span class="koboSpan" id="kobo.453.1">In the example, we define functions to set/clear the secure bit for each GPIO pin connected to the three LEDs. </span><span class="koboSpan" id="kobo.453.2">For example, we can set the secure state of the red LED, before staging the non-secure application to disallow changing the LED state in the application by calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">red_led_secure(1)</span></strong><span class="koboSpan" id="kobo.455.1">, which is implemented </span><span class="No-Break"><span class="koboSpan" id="kobo.456.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.457.1">
void red_led_secure(int onoff)
{
  if (onoff)
      GPIOA_SECCFG |= (1 &lt;&lt; RED_LED);
  else
      GPIOA_SECCFG &amp;= ~(1 &lt;&lt; RED_LED);
}</span></pre>
<p><span class="koboSpan" id="kobo.458.1">Our secure-world example application in fact restricts access to the blue and red LED before staging while allowing access to the </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">green LED:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.460.1">
    red_led_secure(1);
    green_led_secure(0);
    blue_led_secure(1);</span></pre>
<p><span class="koboSpan" id="kobo.461.1">After the domain switch, the non-secure application will attempt to turn on all three LEDs, but only the green one will actually be turned on, and the other will stay off because access through the non-secure interface is gated by the SECCFG bit set in the secure world and has no effect on </span><span class="No-Break"><span class="koboSpan" id="kobo.462.1">the GPIO.</span></span></p>
<p><span class="koboSpan" id="kobo.463.1">Blinking the blue LED, however, will still be done using a special non-secure callable interface, explained in the </span><em class="italic"><span class="koboSpan" id="kobo.464.1">Inter-domain transitions</span></em><span class="koboSpan" id="kobo.465.1"> subsection in the </span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">next section.</span></span></p>
<p><span class="koboSpan" id="kobo.467.1">After configuring</span><a id="_idIndexMarker888"/><span class="koboSpan" id="kobo.468.1"> all the securable</span><a id="_idIndexMarker889"/><span class="koboSpan" id="kobo.469.1"> and TrustZone-aware peripherals, we are finally ready to build and install the firmware images for the two domains and observe their effects on </span><span class="No-Break"><span class="koboSpan" id="kobo.470.1">the system.</span></span></p>
<h1 id="_idParaDest-259"><a id="_idTextAnchor430"/><span class="koboSpan" id="kobo.471.1">Building and running the example</span></h1>
<p><span class="koboSpan" id="kobo.472.1">Finally, we are putting all we </span><a id="_idIndexMarker890"/><span class="koboSpan" id="kobo.473.1">have learned about TrustZone-M into practice, by activating</span><a id="_idIndexMarker891"/><span class="koboSpan" id="kobo.474.1"> the option flags needed to enable TrustZone-M and running the two software components associated with the </span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">execution domains.</span></span></p>
<h2 id="_idParaDest-260"><a id="_idTextAnchor431"/><span class="koboSpan" id="kobo.476.1">Enabling TrustZone-M</span></h2>
<p><span class="koboSpan" id="kobo.477.1">By default, TrustZone-M is turned off on our microcontroller</span><a id="_idIndexMarker892"/><span class="koboSpan" id="kobo.478.1"> when it is in its factory state. </span><span class="koboSpan" id="kobo.478.2">Turning on TrustZone is a one-way operation, but it is typically not irreversible unless combined with other hardware-assisted protection mechanisms that make it impossible to disable it when the embedded system is deployed. </span><span class="koboSpan" id="kobo.478.3">Disabling TrustZone once enabled, however, requires a more complex procedure than just clearing one bit in </span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">a register.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.480.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.481.1">Please refer to your microcontroller’s reference manual and application notes, and ensure that you understand the procedure and the consequences of enabling or attempting to disable TrustZone-M on </span><span class="No-Break"><span class="koboSpan" id="kobo.482.1">your device.</span></span></p>
<p><span class="koboSpan" id="kobo.483.1">On the reference platform, to enable TrustZone, we set the associated flag in the option bytes via the </span><span class="No-Break"><span class="koboSpan" id="kobo.484.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.485.1">
STM32_Programmer_CLI -c port=swd mode=hotplug -ob TZEN=1</span></pre>
<p><span class="koboSpan" id="kobo.486.1">Once TrustZone has been enabled</span><a id="_idTextAnchor432"/><span class="koboSpan" id="kobo.487.1">, we can</span><a id="_idIndexMarker893"/><span class="koboSpan" id="kobo.488.1"> build and install the secure firmware. </span><span class="koboSpan" id="kobo.488.2">The next subsection highlights some important aspects to consider when building the secure part of </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">the system.</span></span></p>
<h2 id="_idParaDest-261"><a id="_idTextAnchor433"/><span class="koboSpan" id="kobo.490.1">Secure application entry point</span></h2>
<p><span class="koboSpan" id="kobo.491.1">The regions defined in the secure-world linker script</span><a id="_idIndexMarker894"/><span class="koboSpan" id="kobo.492.1"> reflect the system resources as seen by the secure firmware. </span><span class="koboSpan" id="kobo.492.2">We allocate a RAM region covering the lower half of the </span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">SRAM1 bank:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.494.1">
    RAM (rwx) : ORIGIN = 0x20000000, LENGTH = 0x00018000</span></pre>
<p><span class="koboSpan" id="kobo.495.1">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">.text</span></strong><span class="koboSpan" id="kobo.497.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">.data</span></strong><span class="koboSpan" id="kobo.499.1"> LMSes end up in the FLASH region, mapped to its </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">secure-domain address:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.501.1">
    FLASH (rx) : ORIGIN = 0x0C000000, LENGTH = 0x1000</span></pre>
<p><span class="koboSpan" id="kobo.502.1">For our simple example, 4 KB is enough to store the bootloader image. </span><span class="koboSpan" id="kobo.502.2">Additionally, we define a non-secure callable area, which will contain the implementation </span><a id="_idTextAnchor434"/><span class="koboSpan" id="kobo.503.1">of our secure stubs. </span><span class="koboSpan" id="kobo.503.2">This is an area dedicated to accessing secure APIs from the non-secure world through pre-defined inter-domain special </span><span class="No-Break"><span class="koboSpan" id="kobo.504.1">function calls:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.505.1">
    FLASH_NSC(rx): ORIGIN = 0x0C001000, LENGTH = 0x1000</span></pre>
<p><span class="koboSpan" id="kobo.506.1">The entry point of the secure application on the reference platform is hardcoded in the option bytes. </span><span class="koboSpan" id="kobo.506.2">Before installing our image, we must ensure that the option bytes for </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">SECBOOTADD0</span></strong><span class="koboSpan" id="kobo.508.1"> are configured to point to the address </span><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">0x0C000000</span></strong><span class="koboSpan" id="kobo.510.1">, which is the beginning of the flash memory in the secure system view. </span><span class="koboSpan" id="kobo.510.2">If, for any reason, the value has been previously modified, it can be restored via the </span><span class="No-Break"><span class="koboSpan" id="kobo.511.1">following command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.512.1">
STM32_Programmer_CLI -c port=swd mode=hotplug -ob SECBOOTADD0=0x180000</span></pre>
<p><span class="koboSpan" id="kobo.513.1">This is because the granularity of </span><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">SECBOOTADD0</span></strong><span class="koboSpan" id="kobo.515.1"> is 128 bytes, so setting a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.516.1">0x180000</span></strong><span class="koboSpan" id="kobo.517.1"> will result in a pointer to the </span><span class="No-Break"><span class="koboSpan" id="kobo.518.1">address </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">0x0C000000</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.520.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.521.1">This last value completes the setup of option bytes, so we are finally ready to build and install the </span><span class="No-Break"><span class="koboSpan" id="kobo.522.1">secure application.</span></span></p>
<p><span class="koboSpan" id="kobo.523.1">A list of the option bytes</span><a id="_idIndexMarker895"/><span class="koboSpan" id="kobo.524.1"> and their values, assigned in order to configure the target run of the example code, is provided in the repository of this book, in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">Chapter11/option-bytes.txt</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.526.1"> file.</span></span></p>
<h2 id="_idParaDest-262"><a id="_idTextAnchor435"/><span class="koboSpan" id="kobo.527.1">Compiling and linking secure-world applications</span></h2>
<p><span class="koboSpan" id="kobo.528.1">If you look in the</span><a id="_idIndexMarker896"/><span class="koboSpan" id="kobo.529.1"> Makefile for the secure-world</span><a id="_idIndexMarker897"/><span class="koboSpan" id="kobo.530.1"> application, you will notice two new flags</span><a id="_idTextAnchor436"/><span class="koboSpan" id="kobo.531.1"> have been introduced in the build process. </span><span class="koboSpan" id="kobo.531.2">gcc requires us to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">-mcmse</span></strong><span class="koboSpan" id="kobo.533.1"> flag to indicate that we are compilin</span><a id="_idTextAnchor437"/><span class="koboSpan" id="kobo.534.1">g secure code for a TrustZone system. </span><span class="koboSpan" id="kobo.534.2">By adding</span><a id="_idIndexMarker898"/><span class="koboSpan" id="kobo.535.1"> this flag, we are telling the compiler to generate </span><strong class="bold"><span class="koboSpan" id="kobo.536.1">Secure Gateway</span></strong><span class="koboSpan" id="kobo.537.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.538.1">SG</span></strong><span class="koboSpan" id="kobo.539.1">) stubs for the functions that are marked as non-secure callable. </span><span class="koboSpan" id="kobo.539.2">When compiling sources marked as secure, gcc allows specific attributes to mark our secure API calls. </span><span class="koboSpan" id="kobo.539.3">In our example, we define a secure API call that will allow non-secure code to toggle the value of the GPIO pin connected to the blue LED. </span><span class="koboSpan" id="kobo.539.4">The non-secure callable function is defined in the secure application code; in the case of the example, it is contained in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.540.1">nsc_led.c</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.541.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.542.1">
void __attribute__((cmse_nonsecure_entry))
    nsc_blue_led_toggle(void)
{
  if ((GPIOB_ODR &amp; (1 &lt;&lt; BLUE_LED)) == (1 &lt;&lt; BLUE_LED))
    blue_led_off();
  else
    blue_led_on();
}</span></pre>
<p><span class="koboSpan" id="kobo.543.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.544.1">__attribute__((cmse_nonsecure_entry))</span></strong><span class="koboSpan" id="kobo.545.1"> compiler attribute tells gcc to generate the SG stub for this function. </span><span class="koboSpan" id="kobo.545.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">FLASH_NSC </span></strong><span class="koboSpan" id="kobo.547.1">section that we defined in the linker script is used </span><a id="_idIndexMarker899"/><span class="koboSpan" id="kobo.548.1">to store the SG stubs for the secure API</span><a id="_idIndexMarker900"/><span class="koboSpan" id="kobo.549.1"> that we configure. </span><span class="koboSpan" id="kobo.549.2">The SG stubs are automatically placed in a section called </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">.gnu.sgstubs</span></strong><span class="koboSpan" id="kobo.551.1">, which we place in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">FLASH_NSC</span></strong><span class="koboSpan" id="kobo.553.1"> region in the example </span><span class="No-Break"><span class="koboSpan" id="kobo.554.1">linker script:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.555.1">
.gnu.sgstubs :
{
  . </span><span class="koboSpan" id="kobo.555.2">= ALIGN(4);
  *(.gnu.sgstubs*)   /* Secure Gateway stubs */
  . </span><span class="koboSpan" id="kobo.555.3">= ALIGN(4);
} &gt;FLASH_NSC</span></pre>
<p><span class="koboSpan" id="kobo.556.1">The extra linker flags, </span><strong class="source-inline"><span class="koboSpan" id="kobo.557.1">--cmse-implib</span></strong><span class="koboSpan" id="kobo.558.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">--out-implib=led_cmse.o</span></strong><span class="koboSpan" id="kobo.560.1">, have a different purpose that does not directly affect the secure domain. </span><span class="koboSpan" id="kobo.560.2">When linking the secure application, by adding these flags we are asking the linker to create a new object file, which will not be linked in the final secure application. </span><span class="koboSpan" id="kobo.560.3">This new object file instead will be linked in the non-secure world application and contains the veneers for the secure API. </span><span class="koboSpan" id="kobo.560.4">These veneers prepare the jump from non-secure to non-secure callable world. </span><span class="koboSpan" id="kobo.560.5">In other words, this new file, </span><strong class="source-inline"><span class="koboSpan" id="kobo.561.1">led_cmse.o</span></strong><span class="koboSpan" id="kobo.562.1">, is the non-secure world counterpart implementation of the secure calls through a non-secure callable SG stub. </span><span class="koboSpan" id="kobo.562.2">The veneers are generated by the linker and contain the code</span><a id="_idTextAnchor438"/><span class="koboSpan" id="kobo.563.1"> needed to jump to the non-secure callable stub. </span><span class="koboSpan" id="kobo.563.2">To recap, to build the secure application, we need to introduce two specific set </span><span class="No-Break"><span class="koboSpan" id="kobo.564.1">of flags:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.565.1">The</span><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">–mcmse</span></strong><span class="koboSpan" id="kobo.567.1"> compile time flag, which tells gcc that we are generating secure code for TrustZone and enables SG stubs for non-secure </span><span class="No-Break"><span class="koboSpan" id="kobo.568.1">entry points</span></span></li>
<li><span class="koboSpan" id="kobo.569.1">The</span><strong class="source-inline"><span class="koboSpan" id="kobo.570.1">–cmse-implib</span></strong><span class="koboSpan" id="kobo.571.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.572.1">–out-implib=…</span></strong><span class="koboSpan" id="kobo.573.1"> linker flags, which tell the linker to generate veneers in object file formats, which in turn will be linked to the non-secure domain to access the associated secure </span><span class="No-Break"><span class="koboSpan" id="kobo.574.1">API calls</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.575.1">Once built using </span><strong class="source-inline"><span class="koboSpan" id="kobo.576.1">make</span></strong><span class="koboSpan" id="kobo.577.1">, the secure firmware image can be uploaded to the device flash, using the </span><span class="No-Break"><span class="koboSpan" id="kobo.578.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.579.1">
STM32_Programmer_CLI -c port=swd -d bootloader.bin 0x0C000000</span></pre>
<p><span class="koboSpan" id="kobo.580.1">The microcontroller flash is now populated with the secure firmware, our enhanced bootloader that is ready</span><a id="_idIndexMarker901"/><span class="koboSpan" id="kobo.581.1"> to set up all the parameters in the TrustZone controller</span><a id="_idIndexMarker902"/><span class="koboSpan" id="kobo.582.1"> and stage the non-secure application. </span><span class="koboSpan" id="kobo.582.2">The obvious next step is to compile and install the non-secure </span><span class="No-Break"><span class="koboSpan" id="kobo.583.1">world counterpart.</span></span></p>
<h2 id="_idParaDest-263"><a id="_idTextAnchor439"/><span class="koboSpan" id="kobo.584.1">Compiling and linking non-secure applications</span></h2>
<p><span class="koboSpan" id="kobo.585.1">The linker script for our non-secure application</span><a id="_idIndexMarker903"/><span class="koboSpan" id="kobo.586.1"> defines the boundaries for the world</span><a id="_idIndexMarker904"/><span class="koboSpan" id="kobo.587.1"> as seen from the non-secure execution domain. </span><span class="koboSpan" id="kobo.587.2">Secure and NSC regions are not reachable from here. </span><span class="koboSpan" id="kobo.587.3">Our view on the flash memory is restricted to its upper half, and the accessible RAM is limited to the upper half of the SRAM1 bank. </span><span class="koboSpan" id="kobo.587.4">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.588.1">target.ld</span></strong><span class="koboSpan" id="kobo.589.1"> linker script in the non-secure application defines these regions </span><span class="No-Break"><span class="koboSpan" id="kobo.590.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.591.1">
FLASH (rx) : ORIGIN = 0x08040000, LENGTH = 256K
RAM (rwx) :  ORIGIN = 0x20018000, LENGTH = 96K</span></pre>
<p><span class="koboSpan" id="kobo.592.1">From this point onward, the build process is similar to building normal applications with no support for TrustZone. </span><span class="koboSpan" id="kobo.592.2">Unlike its secure counterpart, non-secure applications do not require any special compiler or </span><a id="_idTextAnchor440"/><span class="No-Break"><span class="koboSpan" id="kobo.593.1">linker flags.</span></span></p>
<p><span class="koboSpan" id="kobo.594.1">The noticeable exception consists of the extra object file generated by the secure application build process, which allows the non-secure application to briefly interact with the secure world. </span><span class="koboSpan" id="kobo.594.2">The contract between the secure and non-secure domains consists of the secure API defined by the secure world. </span><span class="koboSpan" id="kobo.594.3">In our example, we have only defined one single secure function, </span><strong class="source-inline"><span class="koboSpan" id="kobo.595.1">nsc_blue_led_toggle</span></strong><span class="koboSpan" id="kobo.596.1">. </span><span class="koboSpan" id="kobo.596.2">The object file containing the veneers (called </span><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">cmse_led.o</span></strong><span class="koboSpan" id="kobo.598.1"> in our example), automatically generated when compiling the code for the secure domain, is linked within the non-secure application, and it is in fact the code that satisfies the symbol dependency in the secure application for these special symbols. </span><span class="koboSpan" id="kobo.598.2">We will explore the details of this procedure in the next subsection, </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.599.1">Inter-domain transitions</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.600.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.601.1">Once the non-secure application has been built by running </span><strong class="source-inline"><span class="koboSpan" id="kobo.602.1">make</span></strong><span class="koboSpan" id="kobo.603.1">, we upload the non-secure firmware image into the internal flash of the target, starting from the </span><span class="No-Break"><span class="koboSpan" id="kobo.604.1">address </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">0x08040000</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.606.1">:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.607.1">
STM32_Programmer_CLI -c port=swd </span><a id="_idTextAnchor441"/><span class="koboSpan" id="kobo.608.1">-d image.bin 0x08040000</span></pre>
<p><span class="koboSpan" id="kobo.609.1">We will now take a c</span><a id="_idTextAnchor442"/><span class="koboSpan" id="kobo.610.1">loser look at the transitions from secure to non-secure domains and vice versa, to understand how new ARMv8-M instructions</span><a id="_idIndexMarker905"/><span class="koboSpan" id="kobo.611.1"> are involved in the transition operations</span><a id="_idIndexMarker906"/><span class="koboSpan" id="kobo.612.1"> and how these should be used in </span><span class="No-Break"><span class="koboSpan" id="kobo.613.1">such cases.</span></span></p>
<h2 id="_idParaDest-264"><a id="_idTextAnchor443"/><span class="koboSpan" id="kobo.614.1">Inter-domain transitions</span></h2>
<p><span class="koboSpan" id="kobo.615.1">When our secure world</span><a id="_idIndexMarker907"/><span class="koboSpan" id="kobo.616.1"> example bootloader is ready to stage the non-secure world application, we can notice some differences in the assembly that prepares </span><a id="_idTextAnchor444"/><span class="koboSpan" id="kobo.617.1">the CPU registers and executes the jump to the non-secure domain. </span><span class="koboSpan" id="kobo.617.2">First, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.618.1">VTOR</span></strong><span class="koboSpan" id="kobo.619.1"> system register is banked when TrustZone is enabled. </span><span class="koboSpan" id="kobo.619.2">This means that there are two separate registers that hold the offset for the vector table, one for each execution domain – VTOR_S and VTOR_NS, for secure and non-secure domains, respectively. </span><span class="koboSpan" id="kobo.619.3">Before jumping into the entry point for non-secure world code, the VTOR_NS register should contain the offset of the interrupt vector for the non-secure world application. </span><span class="koboSpan" id="kobo.619.4">As we know, the IV sits at the beginning of the binary image, so the following assignment in the bootloader’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">main</span></strong><span class="koboSpan" id="kobo.621.1"> procedure ensures that eventually our non-secure domain code will be able to execute interrupt </span><span class="No-Break"><span class="koboSpan" id="kobo.622.1">service routines:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.623.1">
  /* Update IV */
  VTOR_NS = ((uint32_t)app_IV);</span></pre>
<p><span class="koboSpan" id="kobo.624.1">After this system register is set, we acquire the two important pointers needed for staging, similar to how we would do for bootloaders without TrustZone-M capabilities, like the one proposed in </span><a href="B18730_04.xhtml#_idTextAnchor115"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.625.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.626.1">, </span><em class="italic"><span class="koboSpan" id="kobo.627.1">The Boot-Up Procedure</span></em><span class="koboSpan" id="kobo.628.1">. </span><span class="koboSpan" id="kobo.628.2">These pointers, stored in the first two 32-bit words of the non-secure application binary image, are the initial stack pointer and the actual entry point containing the address of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.629.1">isr_reset</span></strong><span class="koboSpan" id="kobo.630.1"> handler respectively. </span><span class="koboSpan" id="kobo.630.2">We read these two addresses into local stack variables </span><span class="No-Break"><span class="koboSpan" id="kobo.631.1">before staging:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.632.1">
  app_end_stack =
     (*((uint32_t *)(NS_WORLD_ENTRY_ADDRESS)));
  app_entry =
     (void *)(*((uint32_t *)(NS_WORLD_ENTRY_ADDRESS + 4)));</span></pre>
<p><span class="koboSpan" id="kobo.633.1">In our example, we size the stack area in advance for the non-secure application, calculating the lowest address allowed for the stack </span><span class="No-Break"><span class="koboSpan" id="kobo.634.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.635.1">
  app_stack_limit = app_end_stack - MAX_NS_STACK_SIZE;</span></pre>
<p><span class="koboSpan" id="kobo.636.1">We then assign this value to the MSPLIM_NS register. </span><span class="koboSpan" id="kobo.636.2">MSPLIM_NS is a special register, so as usual we must use the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.637.1">msr</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.638.1"> instruction:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.639.1">
  asm volatile("msr msplim_ns, %0" ::"r"(app_stack_limit));</span></pre>
<p><span class="koboSpan" id="kobo.640.1">We then set the value for the new stack pointer, which will replace SP once the domain transition </span><span class="No-Break"><span class="koboSpan" id="kobo.641.1">is complete:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.642.1">
  asm volatile("msr msp_ns, %0" ::"r"(app_end_stack));</span></pre>
<p><span class="koboSpan" id="kobo.643.1">The actual jump to non-secure code</span><a id="_idIndexMarker908"/><span class="koboSpan" id="kobo.644.1"> is where things differ a lot from our previous bootloader introduced in </span><a href="B18730_04.xhtml#_idTextAnchor115"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.645.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.646.1">, </span><em class="italic"><span class="koboSpan" id="kobo.647.1">The Boot-Up Procedure</span></em><span class="koboSpan" id="kobo.648.1">. </span><span class="koboSpan" id="kobo.648.2">First, we must ensure that the address for the jump is adjusted to comply with the convention used in ARMv8 transitions. </span><span class="koboSpan" id="kobo.648.3">The value we read from the binary image into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.649.1">app_entry</span></strong><span class="koboSpan" id="kobo.650.1"> local variable is in fact odd, which is the classic requirement when assigning a new value to the PC register when jumping within the same domain – for example, when using </span><strong class="source-inline"><span class="koboSpan" id="kobo.651.1">mov pc, ...</span></strong><span class="koboSpan" id="kobo.652.1"> instructions in ARMv7-M, such as the one in the example bootloader from </span><a href="B18730_04.xhtml#_idTextAnchor115"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.653.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.654.1">, </span><em class="italic"><span class="koboSpan" id="kobo.655.1">The Boot-Up Procedure</span></em><span class="koboSpan" id="kobo.656.1">. </span><span class="koboSpan" id="kobo.656.2">In ARMv8-M, the instruction that executes the jump and the domain transition into the non-secure world at the same time, is </span><strong class="source-inline"><span class="koboSpan" id="kobo.657.1">blxns</span></strong><span class="koboSpan" id="kobo.658.1">. </span><span class="koboSpan" id="kobo.658.2">However, when invoking </span><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">blxns</span></strong><span class="koboSpan" id="kobo.660.1"> or any other instruction that implies a jump to a non-secure address, we must ensure that the destination address for t</span><a id="_idTextAnchor445"/><span class="koboSpan" id="kobo.661.1">he jump has its least significant bit turned off. </span><span class="koboSpan" id="kobo.661.2">For this reason, we decrease the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.662.1">app_entry</span></strong><span class="koboSpan" id="kobo.663.1"> by one before </span><span class="No-Break"><span class="koboSpan" id="kobo.664.1">executing </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">blxns</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.666.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.667.1">
  /* Jump to non-secure app_entry */
  asm volatile("mov r12, %0" ::"r"
     ((uint32_t)app_entry - 1));
  asm volatile("blxns   r12" );</span></pre>
<p><span class="koboSpan" id="kobo.668.1">This is the last instruction executed in the secure domain before finally staging our non-secure application. </span><span class="koboSpan" id="kobo.668.2">If we use the debugger to check the values of the registers while stepping through these last instructions, we can see the values of the CPU registers being updated, and then finally, the SP register will point to the new context in the </span><span class="No-Break"><span class="koboSpan" id="kobo.669.1">non-secure domain.</span></span></p>
<p><span class="koboSpan" id="kobo.670.1">From this point onward, any</span><a id="_idTextAnchor446"/><span class="koboSpan" id="kobo.671.1"> attempt to jump back into the secure domain is, of course, not allowed and will generate an exception. </span><span class="koboSpan" id="kobo.671.2">However, as we have previously mentioned, the purpose of the functions placed in the NSC region is to provide temporary and controlled execution of secure functions from the </span><span class="No-Break"><span class="koboSpan" id="kobo.672.1">non-secure domain.</span></span></p>
<p><span class="koboSpan" id="kobo.673.1">In our example, before transitioning to the non-secure execution domain, we impose some limitation on access to the GPIO lines associated with the three LEDs, by setting the corresponding bits in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.674.1">GPIOx_SECCFG</span></strong><span class="koboSpan" id="kobo.675.1"> register, as explained in the </span><em class="italic"><span class="koboSpan" id="kobo.676.1">Configuring secure access to peripherals</span></em><span class="koboSpan" id="kobo.677.1"> subsection previously in </span><span class="No-Break"><span class="koboSpan" id="kobo.678.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.679.1">When both images composing</span><a id="_idIndexMarker909"/><span class="koboSpan" id="kobo.680.1"> the example are uploaded to the target platform, we can power-cycle </span><a id="_idTextAnchor447"/><span class="koboSpan" id="kobo.681.1">and observe the effects by looking at the three LEDs. </span><span class="koboSpan" id="kobo.681.2">After rebooting, we should see the red LED that will be turned on at startup</span><a id="_idTextAnchor448"/><span class="koboSpan" id="kobo.682.1"> and kept on while the secure code is running in the bootloader. </span><span class="koboSpan" id="kobo.682.2">After spinning for an arbitrary number of cycles, to give us enough time to inspect the LED status, the red LED will then be turned off and secured. </span><span class="koboSpan" id="kobo.682.3">The blue LED is secured too, through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.683.1">blue_led_secure(1)</span></strong><span class="koboSpan" id="kobo.684.1"> call executed before staging. </span><span class="koboSpan" id="kobo.684.2">The green LED is not secured and can be accessed normally in the </span><span class="No-Break"><span class="koboSpan" id="kobo.685.1">non-secure domain.</span></span></p>
<p><span class="koboSpan" id="kobo.686.1">When the non-secure application starts, we can see the green LED constantly on and the blue LED rapidly blinking. </span><span class="koboSpan" id="kobo.686.2">The latter i</span><a id="_idTextAnchor449"/><span class="koboSpan" id="kobo.687.1">s only possible thanks to the fact that non-secure applications can access a function within the </span><span class="No-Break"><span class="koboSpan" id="kobo.688.1">secure APIs.</span></span></p>
<p><span class="koboSpan" id="kobo.689.1">We can have a look at the assembly generated for this function by running </span><strong class="source-inline"><span class="koboSpan" id="kobo.690.1">arm-none-eabi-objdump –D</span></strong><span class="koboSpan" id="kobo.691.1"> on the secure-world </span><strong class="bold"><span class="koboSpan" id="kobo.692.1">elf</span></strong><span class="koboSpan" id="kobo.693.1"> file. </span><span class="koboSpan" id="kobo.693.2">We immediately not</span><a id="_idTextAnchor450"/><span class="koboSpan" id="kobo.694.1">ice</span><a id="_idIndexMarker910"/><span class="koboSpan" id="kobo.695.1"> that the non-secure callable function stub generated is in fact a short procedure placed at the beginning of the </span><span class="No-Break"><span class="koboSpan" id="kobo.696.1">non-callable section:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.697.1">
0c001000 &lt;nsc_blue_led_toggle&gt;:
c001000:   e97f e97f   sg
c001004:   f7ff bdd2   b.w c000bac
              &lt;__acle_se_nsc_blue_led_toggle&gt;</span></pre>
<p><span class="koboSpan" id="kobo.698.1">The most interesting part of the code running in the NSC area is the use of the special assembly instruction, </span><strong class="source-inline"><span class="koboSpan" id="kobo.699.1">sg</span></strong><span class="koboSpan" id="kobo.700.1">, which is a new instruction introduced in ARMv8-M with the specific purpose of implementing secure calls from non-secure domains. </span><span class="koboSpan" id="kobo.700.2">This instruction prepares the branching to an secure call in the secure flash space, and it is only legal when it is executed from an non-secure </span><span class="No-Break"><span class="koboSpan" id="kobo.701.1">callable area.</span></span></p>
<p><span class="koboSpan" id="kobo.702.1">Also, note that the real implementation is in fact contained in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.703.1">__acle_se_nsc_blue_led_toggle</span></strong><span class="koboSpan" id="kobo.704.1"> function, generated by the compiler and placed in the S region of </span><span class="No-Break"><span class="koboSpan" id="kobo.705.1">the flash.</span></span></p>
<p><span class="koboSpan" id="kobo.706.1">The assembly code generated by the veneer for </span><strong class="source-inline"><span class="koboSpan" id="kobo.707.1">nsc_blue_led_toggle</span></strong><span class="koboSpan" id="kobo.708.1">, as seen by disassembling the non-secure application in the same way after including the generated object in the final image, should look like </span><span class="No-Break"><span class="koboSpan" id="kobo.709.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.710.1">
080408e8 &lt;__nsc_blue_led_toggle_veneer&gt;:
80408e8:   f85f f000   ldr.w   pc, [pc]    ; 80408ec \
                       &lt;__nsc_blue_led_toggle_veneer+0x4&gt;
80408ec:   0c001001</span></pre>
<p><span class="koboSpan" id="kobo.711.1">The conclusion of the procedure</span><a id="_idIndexMarker911"/><span class="koboSpan" id="kobo.712.1"> of calling an secure function from the non-secure domain is in the tail of the actual implementation of the secure function toggling the blue </span><span class="No-Break"><span class="koboSpan" id="kobo.713.1">LED, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.714.1">__acle_se_nsc_blue_led_toggle</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.715.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.716.1">
c000bee:   4774        bxns    lr</span></pre>
<p><span class="koboSpan" id="kobo.717.1">This should already look familiar to us, as it is in fact the non-linked version of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.718.1">bxlns</span></strong><span class="koboSpan" id="kobo.719.1"> instruction that we have seen before, performing a jump to the return address of the non-secure veneer stored in the link register, while also transitioning back to the non-secure domain. </span><span class="koboSpan" id="kobo.719.2">The following checklist is a recap of the steps involved when a secure function is called from the NS execution domain in this </span><span class="No-Break"><span class="koboSpan" id="kobo.720.1">chapter’s example:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.721.1">non-secure world code calls the veneer for </span><strong class="source-inline"><span class="koboSpan" id="kobo.722.1">nsc_blue_led_toggle</span></strong><span class="koboSpan" id="kobo.723.1">, which is implemented in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.724.1">cmse_leds.o</span></strong><span class="koboSpan" id="kobo.725.1"> object that is generate</span><a id="_idTextAnchor451"/><span class="koboSpan" id="kobo.726.1">d when compiling the secure code and linked to the </span><span class="No-Break"><span class="koboSpan" id="kobo.727.1">non-secure application.</span></span></li>
<li><span class="koboSpan" id="kobo.728.1">The veneer knows the SG stub location in the NSC region. </span><span class="koboSpan" id="kobo.728.2">This region is accessible for execution from the secure world, while being placed in a specific region inside the secure firmware. </span><span class="koboSpan" id="kobo.728.3">The veneer then proceeds to jump to the </span><span class="No-Break"><span class="koboSpan" id="kobo.729.1">SG stub.</span></span></li>
<li><span class="koboSpan" id="kobo.730.1">The SG stub calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.731.1">sg</span></strong><span class="koboSpan" id="kobo.732.1"> instruction, initiating the transition to the secure world, and then jumps to the actual implementation, </span><strong class="source-inline"><span class="koboSpan" id="kobo.733.1">__acle_se_nsc_blue_led_toggle</span></strong><span class="koboSpan" id="kobo.734.1">. </span><span class="koboSpan" id="kobo.734.2">This now executes in the secure domain, performing the requested action (in our example, this is toggling the value of the GPIO line connected to the </span><span class="No-Break"><span class="koboSpan" id="kobo.735.1">blue LED).</span></span></li>
<li><span class="koboSpan" id="kobo.736.1">When the procedure terminates, the secure function performs a transition back to the non-secure world by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.737.1">bxns</span></strong><span class="koboSpan" id="kobo.738.1"> instruction, while at the same time jumping back to the address of the original caller in the </span><span class="No-Break"><span class="koboSpan" id="kobo.739.1">non-secure world.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.740.1">Despite its simplicity, our example shows how to configure and use all the features needed to separate the two execution domains, as well as the mechanisms to be used to implement the interactions between the two worlds. </span><span class="koboSpan" id="kobo.740.2">The design of these interactions in the secure domain will determine the capabilities offered to non-secure applications. </span><span class="koboSpan" id="kobo.740.3">The boundaries and the interface for the transitions act like a contract between the two parts, which is enforced </span><a id="_idIndexMarker912"/><span class="koboSpan" id="kobo.741.1">by the hardware itself, thanks </span><span class="No-Break"><span class="koboSpan" id="kobo.742.1">to TrustZone-M.</span></span></p>
<h1 id="_idParaDest-265"><a id="_idTextAnchor452"/><span class="koboSpan" id="kobo.743.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.744.1">ARMv8-M is the newest architecture defined by ARM for modern microcontrollers. </span><span class="koboSpan" id="kobo.744.2">It extends and completes the capabilities of its predecessor, ARMv7-M, by integrating several new features. </span><span class="koboSpan" id="kobo.744.3">The most important improvement for this novel architecture design is the possibility to implement a TEE by separating the execution domains and creating a sandboxed environment to execute </span><span class="No-Break"><span class="koboSpan" id="kobo.745.1">non-secure applications.</span></span></p>
<p><span class="koboSpan" id="kobo.746.1">In real-life scenarios, this gives flexibility to the deployment of applications from different providers, with distinct levels of trust regarding accessing features and resources on </span><span class="No-Break"><span class="koboSpan" id="kobo.747.1">a system.</span></span></p>
<p><span class="koboSpan" id="kobo.748.1">In this last chapter, we have analyzed the mechanisms available in the TrustZone-M technology. </span><span class="koboSpan" id="kobo.748.2">TrustZone-M can be activated on ARMv8-M systems for the purpose of integrating a powerful, hardware-assisted solution, aimed to protect system components from any access that has not been explicitly authorized by a system supervisor component running in the </span><span class="No-Break"><span class="koboSpan" id="kobo.749.1">secure domain.</span></span></p>
</div>
</body></html>