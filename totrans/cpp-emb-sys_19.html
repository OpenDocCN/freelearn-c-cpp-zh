<html><head></head><body>
<div><h1 class="chapterNumber">15</h1>
<h1 class="chapterTitle" id="_idParaDest-199">Practical Patterns – Building a Temperature Publisher</h1>
<p class="normal">Design patterns are tools for solving common problems. So far, we have covered a few design patterns in this book, such as the Command and Adapter patterns. In this chapter, we will go over the <strong class="keyWord">Observer pattern</strong> and apply it to a common problem in embedded systems – handling temperature readings in different parts of the system.</p>
<p class="normal">We will start by <a id="_idIndexMarker642"/>looking at the Observer pattern and how it can be implemented at runtime. This pattern is particularly useful when multiple components need to react to changes in data from a central source. Imagine a temperature sensor in an embedded device that reports changes to multiple listeners. This could be part of a smart thermostat, an industrial machine monitor, or an HVAC control board – each with components such as a screen, a logger, or a fan controller that react to temperature updates.</p>
<p class="normal">Next, we will transition to a compile-time implementation of the same pattern using modern C++ techniques such as variadic templates and fold expressions. By leveraging these techniques, we can generate highly optimized code at compile time, avoiding virtual dispatch, associated with runtime polymorphism. This approach results in a smaller memory footprint and faster code that’s better suited to systems with limited resources.</p>
<p class="normal">In this chapter, we’re going to cover the following main topics:</p>
<ul>
<li class="bulletList">The Observer pattern</li>
<li class="bulletList">Runtime implementation</li>
<li class="bulletList">Compile-time implementation</li>
</ul>
<h1 class="heading-1" id="_idParaDest-200">Technical requirements</h1>
<p class="normal">To get the most out of this chapter, I strongly recommend using Compiler Explorer (<a href="https://godbolt.org/">https://godbolt.org/</a>) as you read through the examples. Add an execution pane with GCC as your compiler for x86 architecture. This will allow you to see standard output and better observe the code’s behavior. As we are using a lot of modern C++ features, make sure to select C++23 standard, by adding <code class="inlineCode">-std=c++23</code> in the <strong class="screenText">compiler options</strong> box, and set the optimization level to <code class="inlineCode">-O3</code>. Also, add a compiler pane using <code class="inlineCode">ARM gcc 11.2.1 (none)</code> to inspect the assembly output of the examples.</p>
<p class="normal">You can try the examples from this chapter in the Renode simulator in the Docker container you set up in <a href="Chapter_04.xhtml"><em class="italic">Chapter 4</em></a>. Make sure that the Docker container is running.</p>
<p class="normal">You can find the files for this chapter on GitHub at <a href="https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter15/observer">https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter15/observer</a>.</p>
<h1 class="heading-1" id="_idParaDest-201">The Observer pattern</h1>
<p class="normal">The <strong class="keyWord">Observer pattern</strong> is often used in event-driven systems to publish events to subscribed objects, usually by <a id="_idIndexMarker643"/>calling a method on them. An object that publishes <a id="_idIndexMarker644"/>events is called a <strong class="keyWord">subject</strong> or <strong class="keyWord">publisher</strong>. Objects that receive events from a publisher are <a id="_idIndexMarker645"/>called <strong class="keyWord">observers</strong> or <strong class="keyWord">subscribers</strong>. From now on, we will use the terms <strong class="keyWord">publisher</strong> and <strong class="keyWord">subscriber</strong>.</p>
<p class="normal">A publisher has <a id="_idIndexMarker646"/>an internal list of subscribers and provides an interface to register and unregister a subscriber from the internal list. It also provides the <code class="inlineCode">notify</code> method, used by its client, which in turn calls <code class="inlineCode">update</code> methods on subscribers – that’s why we say that the publisher notifies subscribers.</p>
<p class="normal">An example of a publisher-subscriber mechanism that is common in embedded systems would be a temperature publisher, which notifies the logger, display, and data sender at regular intervals. Before we go on to the implementation of this example, we will first go through a UML diagram of the Observer pattern.</p>
<figure class="mediaobject"><img alt="Figure 15.1 – UML diagram of the Observer pattern" src="img/B22402_15_01.png"/></figure>
<p class="packt_figref">Figure 15.1 – UML diagram of the Observer pattern</p>
<p class="normal"><em class="italic">Figure 15.1</em> depicts the UML <a id="_idIndexMarker647"/>class diagram of the Observer pattern. In the diagram, we see that the <code class="inlineCode">publisher</code> class has the following members:</p>
<ul>
<li class="bulletList"><code class="inlineCode">etl::vector&lt;subscribers_, 8&gt;</code>: Internal list of pointers to the subscriber interface, for which we will use <code class="inlineCode">vector</code> from ETL.</li>
<li class="bulletList"><code class="inlineCode">register_sub(subscriber *)</code>: The method used to register a subscriber. The <code class="inlineCode">register</code> keyword is reserved in C++ and used as a storage specifier, so we are using <code class="inlineCode">register_sub</code> as the name for this method.</li>
<li class="bulletList"><code class="inlineCode">unregister(subscriber *)</code>: The method used to unregister a subscriber.</li>
<li class="bulletList"><code class="inlineCode">notify(float)</code>: The method used by the publisher’s client to trigger the updating of subscribers.</li>
</ul>
<p class="normal">The <code class="inlineCode">subscriber</code> interface class <a id="_idIndexMarker648"/>has one pure virtual method – <code class="inlineCode">void update(float)</code>. This method is overridden in the concrete implementation of the <code class="inlineCode">subscriber</code> class. To see this in action, we will proceed with the runtime implementation of the Observer pattern.</p>
<h1 class="heading-1" id="_idParaDest-202">Runtime implementation</h1>
<p class="normal">We will go <a id="_idIndexMarker649"/>through the runtime implementation of the Observer pattern on the example of temperature publisher. Subscribers will be a logger, display, and data sender. The code of the subscriber interface and concrete subscribers is shown here:</p>
<pre class="programlisting code"><code class="hljs-code">#include &lt;cstdio&gt;
#include “etl/vector.h”
#include &lt;algorithm&gt;
class subscriber {
public:
    virtual void update(float) = 0;
    virtual ~subscriber() = default;
};
class display : public subscriber {
public:
    void update(float temp) override {
        printf(“Displaying temperature %.2f \r\n”, temp);
    }
};
class data_sender : public subscriber {
public:
    void update(float temp) override {
        printf(“Sending temperature %.2f \r\n”, temp);
    }
};
class logger : public subscriber {
public:
    void update(float temp) override {
        printf(“Logging temperature %.2f \r\n”, temp);
    }
};
</code></pre>
<p class="normal">The preceding code defines the <code class="inlineCode">subscriber</code> interface and concrete subscriber classes: <code class="inlineCode">display</code>, <code class="inlineCode">data_sender</code>, and <code class="inlineCode">logger</code>. Concrete classes override the pure virtual <code class="inlineCode">update</code> method from the interface class. For the sake of simplicity of the example, all concrete implementations <a id="_idIndexMarker650"/>are printing temperature to standard output.</p>
<p class="normal">Using the interface class allows the publisher to depend on the interface. The publisher maintains an internal container of pointers to the subscriber interface. This makes it possible to add different implementations of the subscriber interface through the pointer on the base interface class. The code for the <code class="inlineCode">publisher</code> class is provided here:</p>
<pre class="programlisting code"><code class="hljs-code">class publisher {
public:
    void register_sub(subscriber * sub) {
        if(std::find(subs_.begin(), subs_.end(), sub) == subs_.end())
        {
            subs_.push_back(sub);
        }
    }
    void unregister(subscriber * sub) {
        if(auto it = std::find(subs_.begin(), subs_.end(),
                                  sub); it != subs_.end())
        {
            subs_.erase(it);
        }
    }
    void notify(float value) {
        for(auto sub: subs_) {
            sub-&gt;update(value);
        }
    }
private:
    etl::vector&lt;subscriber*, 8&gt; subs_;
};
</code></pre>
<p class="normal">In the preceding <code class="inlineCode">publisher</code> class, we see the following members:</p>
<ul>
<li class="bulletList"><code class="inlineCode">etl::vector&lt;subscriber*, 8&gt; subs_</code>: A private container used to maintain subscribers. If you are running this example in Compiler Explorer, make sure to add the ETL library using the <strong class="screenText">Libraries</strong> option.</li>
<li class="bulletList"><code class="inlineCode">void register_sub(subscriber * sub)</code>: A method used to register the subscriber. It uses the <code class="inlineCode">std::find</code> algorithm to check if a subscriber has already been added.</li>
<li class="bulletList"><code class="inlineCode">void unregister(subscriber * sub)</code>: A method used to unregister a subscriber. It uses the <code class="inlineCode">std::find</code> algorithm to check if a subscriber is added before the calling method <code class="inlineCode">erase</code> to remove it from a vector. The method <code class="inlineCode">erase</code> is provided by the iterator returned by <code class="inlineCode">std::find</code> if it is different from <code class="inlineCode">subs_.end()</code>.</li>
<li class="bulletList"><code class="inlineCode">void notify(float value)</code>: Loops through registered subscribers and calls the method <code class="inlineCode">update</code> on them.</li>
</ul>
<p class="normal">Now, let us see <a id="_idIndexMarker651"/>how to use the preceding publisher and subscribers in the following code:</p>
<pre class="programlisting code"><code class="hljs-code">int main() {   
    logger temp_logger;
    display temp_display;
    data_sender temp_data_sender;
    publisher temp_publisher;
    temp_publisher.register_sub(&amp;temp_logger);
    temp_publisher.register_sub(&amp;temp_display);
    temp_publisher.notify(24.02f);
    temp_publisher.unregister(&amp;temp_logger);
    temp_publisher.register_sub(&amp;temp_data_sender);
    temp_publisher.notify(44.02f);
    return 0;
}
</code></pre>
<p class="normal">In the code, we perform the following steps:</p>
<ol>
<li class="numberedList" value="1">Instantiate the following concrete subscribers: <code class="inlineCode">temp_logger</code>, <code class="inlineCode">temp_display</code>, and <code class="inlineCode">temp_data_sender</code>.</li>
<li class="numberedList">Instantiate the publisher <code class="inlineCode">temp_publisher</code>.</li>
<li class="numberedList">Register the subscribers <code class="inlineCode">temp_logger</code> and <code class="inlineCode">temp_display</code>.</li>
<li class="numberedList">Call <code class="inlineCode">notify(24.02f)</code> on <code class="inlineCode">temp_publisher</code>.</li>
</ol>
<p class="normal">After these steps, we expect the following output:</p>
<pre class="programlisting con"><code class="hljs-con">Logging temperature 24.02
Displaying temperature 24.02
</code></pre>
<p class="normal">Next, we perform <a id="_idIndexMarker652"/>the following steps:</p>
<ol>
<li class="numberedList" value="1">Unregister the subscriber <code class="inlineCode">temp_logger</code>.</li>
<li class="numberedList">Register the subscriber <code class="inlineCode">temp_data_sender</code>.</li>
<li class="numberedList">Call <code class="inlineCode">notify(44.02f)</code> on <code class="inlineCode">temp_publisher</code>.</li>
</ol>
<p class="normal">After these steps, we expect the following output:</p>
<pre class="programlisting con"><code class="hljs-con">Displaying temperature 44.02
Sending temperature 44.02
</code></pre>
<p class="normal">As an <em class="italic">exercise</em>, create a new subscriber class <code class="inlineCode">eeprom_writer</code> that records temperature if it goes under or above a set threshold.</p>
<p class="normal">You can run the full example in Renode. Start Visual Studio Code, attach it to the running container, open the <code class="inlineCode">Chapter15/observer</code> project as described in <a href="Chapter_04.xhtml"><em class="italic">Chapter 4</em></a>, and run the following commands in the Visual Studio Code terminal, or run them directly in the container terminal:</p>
<pre class="programlisting con"><code class="hljs-con">$ cmake –B build
$ cmake --build build --target run_in_renode
</code></pre>
<p class="normal">Next, we will go through the compile-time implementation of the Observer pattern.</p>
<h1 class="heading-1" id="_idParaDest-203">Compile-time implementation</h1>
<p class="normal">In most embedded applications, we know a lot about the system’s behavior at compile time. This means <a id="_idIndexMarker653"/>that when using the Observer pattern, we already know all the subscribers. If we assume that subscribers are only registered once and never unregistered, we can create a compile-time version of the Observer pattern.</p>
<p class="normal">To enable this, we’ll first break down the key C++17 features that make compile-time implementation feasible.</p>
<h2 class="heading-2" id="_idParaDest-204">Leveraging variadic templates</h2>
<p class="normal">We will base the implementation on variadic templates. We will start with a simplified implementation <a id="_idIndexMarker654"/>to explain variadic templates, parameter packs, and fold expressions – C++ features that will allow us to create a compile-time version of the Observer pattern. Let us proceed with the following code:</p>
<pre class="programlisting code"><code class="hljs-code">#include &lt;cstdio&gt;
struct display {
    static void update(float temp) {
        printf(“Displaying temperature %.2f \r\n”, temp);
    }
};
struct data_sender {
    static void update(float temp) {
        printf(“Sending temperature %.2f \r\n”, temp);
    }
};
struct logger {
    static void update(float temp) {
        printf(“Logging temperature %.2f \r\n”, temp);
    }
};
template &lt;typename... Subs&gt;
struct publisher {
    static void notify(float temp) {
        (Subs::update(temp), ...);
    }
};
int main() {
    using temp_publisher = publisher&lt;display,
    data_sender,
    logger&gt;;
    temp_publisher::notify(23.47);
    return 0;
}
</code></pre>
<p class="normal">In the code above, we have subscribers structs <code class="inlineCode">display</code>, <code class="inlineCode">data_sender</code>, and <code class="inlineCode">logger</code>. All structs implement the static method <code class="inlineCode">update</code>, which takes <code class="inlineCode">temperature</code> as a parameter and prints it.</p>
<p class="normal">The struct <code class="inlineCode">publisher</code> is a variadic <a id="_idIndexMarker655"/>class template. A <strong class="keyWord">variadic template</strong> is a template <a id="_idIndexMarker656"/>with at least one <strong class="keyWord">parameter pack</strong>. A template parameter <a id="_idIndexMarker657"/>pack is a template parameter that accepts zero or more template arguments. <code class="inlineCode">typename... Subs</code> is a type template parameter pack named <code class="inlineCode">Subs</code>, meaning we can instantiate the struct <code class="inlineCode">publisher</code> with zero or more different types. To sum it up:</p>
<ul>
<li class="bulletList"><code class="inlineCode">publisher</code> is a variadic class template as it has a template parameter pack <code class="inlineCode">typename... Subs</code>.</li>
<li class="bulletList">We can instantiate it with a variable number of types provided as template arguments. This is the way to register subscribers to the publisher.</li>
</ul>
<p class="normal">In the <code class="inlineCode">main</code> function, we create the alias <code class="inlineCode">temp_publisher</code> as <code class="inlineCode">publisher&lt;display, data_sender, logger&gt;</code>. We call the <code class="inlineCode">notify</code> method on this alias, which will result in calls to update functions in types provided through the template parameter pack, thanks to the fold expression in the <code class="inlineCode">notify</code> method.</p>
<p class="normal">The final piece of the puzzle is the fold expression <code class="inlineCode">(Subs::update(temp), ...)</code>. This is a fold expression that uses the comma operator as the folding operator. It expands to: <code class="inlineCode">(display::update(temp), data_sender::update(temp), logger::update(temp))</code>.</p>
<p class="normal">The fold expression ensures that <code class="inlineCode">display::update(temp)</code> is called first, then <code class="inlineCode">data_sender::update(temp)</code>, then <code class="inlineCode">logger::update(temp)</code>. The order of evaluation is strictly left to right for the operands of the comma operator. Each <code class="inlineCode">update(temp)</code> call returns a value (likely <code class="inlineCode">void</code>).</p>
<p class="normal">The comma operator discards all return values except the last one, so only the final <code class="inlineCode">logger::update(temp)</code> determines the fold’s result. If they all return void, the whole expression also returns void.</p>
<p class="normal">Fold expressions were introduced in C++17 and using the comma operator is a concise way to call a function on each type in the parameter pack. Before that, a recursion was needed to iterate through types and call a function on them.</p>
<p class="normal">When examining the disassembly output in Compiler Explorer, you’ll notice that the generated assembly code is relatively brief, approximately 30 lines in total, as shown here:</p>
<pre class="programlisting code"><code class="hljs-code">.LC0:
.ascii “Displaying temperature %.2f \015\012\000”
.LC1:
.ascii “Sending temperature %.2f \015\012\000”
.LC2:
.ascii “Logging temperature %.2f \015\012\000”
main:
push    {r4, r5, r6, lr}
        mov r4, #-536870912
ldr r5, .L3
        mov r2, r4
mov r3, r5
ldr r0, .L3+4
bl      printf
        mov r2, r4
mov r3, r5
ldr r0, .L3+8
bl      printf
        mov r2, r4
mov r3, r5
ldr r0, .L3+12
bl      printf
        mov r0, #0
pop     {r4, r5, r6, lr}
        bx lr
.L3:
.word 1077377105
.word   .LC0
        .word   .LC1
        .word   .LC2
</code></pre>
<p class="normal">In this assembly code, we can see that there are no calls to the static update methods from the <code class="inlineCode">display</code>, <code class="inlineCode">data_sender</code>, and <code class="inlineCode">logger</code> structs. This means the compiler was able to optimize these <a id="_idIndexMarker658"/>calls out, along with the registration of subscribers and the call to the publisher’s <code class="inlineCode">notify</code> method, resulting in direct calls to the <code class="inlineCode">printf</code> function. </p>
<p class="normal">The result is a small memory footprint and fast performance. This example demonstrates the zero-cost abstraction design principle: we have abstractions for the publisher and subscribers, yet there is zero overhead, as the compiler is able to optimize the code to be as efficient as if it were written by hand.</p>
<p class="normal">Compare the assembly output of the compile-time implementation with that of the runtime implementation using the same optimization level (<code class="inlineCode">-O3</code>). It is clear that the compile-time implementation uses less memory and is faster as the compiler optimized away most of the function calls, and there is no indirection caused by virtual functions.</p>
<p class="normal">As we analyze the assembly code, let’s take the opportunity to better understand fold expressions. To prevent GCC from optimizing away calls to the <code class="inlineCode">update</code> methods, we can use the <code class="inlineCode">__attribute__((noinline))</code> function attribute, e.g. <code class="inlineCode">static void __attribute__((noinline)) update(float temp)</code>. Add this attribute to the static <code class="inlineCode">update</code> method of the <code class="inlineCode">display</code>, <code class="inlineCode">data_sender</code>, and <code class="inlineCode">logger</code> structs, and observe the generated assembly code. You’ll see how the call to the <code class="inlineCode">notify</code> method in the <code class="inlineCode">main</code> function results in parameter pack expansion and generates calls to the <code class="inlineCode">update</code> methods of the <code class="inlineCode">display</code>, <code class="inlineCode">data_sender</code>, and <code class="inlineCode">logger</code> structs.</p>
<p class="normal">You can run <a id="_idIndexMarker659"/>the full example in Renode. Start Visual Studio Code, attach it to the running container, open the <code class="inlineCode">Chapter15/observer</code> project as described in <a href="Chapter_04.xhtml"><em class="italic">Chapter 4</em></a>, and run the following commands in the Visual Studio Code terminal, or run them directly in the container terminal:</p>
<pre class="programlisting con"><code class="hljs-con">$ cmake -B build
-DMAIN_CPP_FILE_NAME=main_observer_ct_basic.cpp
$ cmake --build build --target run_in_renode
</code></pre>
<p class="normal">Simplified compile-time implementation of the Observer pattern has a couple of limits:</p>
<ul>
<li class="bulletList">Subscribers can only be registered.</li>
<li class="bulletList">All subscribers are registered when the publisher is instantiated. They cannot be registered after the publisher is instantiated.</li>
</ul>
<p class="normal">Next, we will tackle the last point, as registering all subscribers in a single line of code may be cumbersome and not always practical. This will provide us with a more flexible compile-time design.</p>
<h2 class="heading-2" id="_idParaDest-205">Improving the compile-time implementation</h2>
<p class="normal">We will not <a id="_idIndexMarker660"/>change the interface of the publisher template struct. Instead, we will allow it to receive other publishers as arguments. The code is below:</p>
<pre class="programlisting code"><code class="hljs-code">template&lt;typename T&gt;
concept Updatable = requires (T, float f) {
    { T::update(f) } -&gt; std::same_as&lt;void&gt;;
};
template&lt;typename T&gt;
concept Notifiable = requires (T, float f) {
    { T::notify(f) } -&gt; std::same_as&lt;void&gt;;
};
template &lt;typename... Subs&gt;
struct publisher {
    static void notify(float temp) {
        (call_update_or_notify&lt;Subs&gt;(temp), ...);
    }
private:
    template&lt;typename T&gt;
 static void call_update_or_notify(float temp) {
        if constexpr (Updatable&lt;T&gt;) {
            T::update(temp);
        } else if constexpr (Notifiable&lt;T&gt;) {
            T::notify(temp);
        }
        else {
            static_assert(false, “Type is not Updatable or Notifiable”);
        }
    }
};
</code></pre>
<p class="normal">In the <a id="_idIndexMarker661"/>code above, we defined the following concepts:</p>
<ul>
<li class="bulletList"><code class="inlineCode">Updatable</code>: This describes a type that has a static method <code class="inlineCode">update</code> that accepts a float</li>
<li class="bulletList"><code class="inlineCode">Notifiable</code>: This describes a type that has a static method <code class="inlineCode">notify</code> that accepts a float</li>
</ul>
<p class="normal">We covered concepts in more detail in <a href="Chapter_08.xhtml"><em class="italic">Chapter 8</em></a>. The variadic template class <code class="inlineCode">publisher</code> has a new method – <code class="inlineCode">call_update_or_notify</code>. It is called on every type in the parameter pack <code class="inlineCode">typename... Subs</code> in the method <code class="inlineCode">notify</code> using the fold expression and the comma operator.</p>
<p class="normal">In the method <code class="inlineCode">call_update_or_notify</code>, we use <code class="inlineCode">if constexpr</code> to check, at compile-time, if the type is <code class="inlineCode">Updatable</code> or <code class="inlineCode">Notifiable</code> and call the <code class="inlineCode">update</code> or <code class="inlineCode">notify</code> static method on it respectively.</p>
<p class="normal">Below is an example of using the new version of the Observer pattern:</p>
<pre class="programlisting code"><code class="hljs-code"> using temp_publisher = publisher&lt;display, data_sender&gt;;
    temp_publisher::notify(23.47);
    using temp_publisher_new = publisher&lt;temp_publisher, logger&gt;;
    temp_publisher_new::notify(42.42);
</code></pre>
<p class="normal">In the code above, we instantiate <code class="inlineCode">temp_publisher</code> by providing the variadic class template <code class="inlineCode">publisher</code> with types <code class="inlineCode">display</code> and <code class="inlineCode">data_sender</code>, which are both subscribers are <code class="inlineCode">Updatable</code>.</p>
<p class="normal">Next, we instantiate <code class="inlineCode">temp_publisher_new</code> by providing <code class="inlineCode">publisher</code> with the previously instantiated <code class="inlineCode">temp_publisher</code> and the subscriber <code class="inlineCode">logger</code>. Below is the output of the above example:</p>
<pre class="programlisting con"><code class="hljs-con">Displaying temperature 23.47
Sending temperature 23.47
Displaying temperature 42.42
Sending temperature 42.42
Logging temperature 42.42
</code></pre>
<p class="normal">You can <a id="_idIndexMarker662"/>run the full example in Renode. Start Visual Studio Code, attach it to the running container, open the <code class="inlineCode">Chapter15/observer</code> project as described in <a href="Chapter_04.xhtml"><em class="italic">Chapter 4</em></a>, and run the following commands in the Visual Studio Code terminal, or run them directly in the container terminal:</p>
<pre class="programlisting con"><code class="hljs-con">$ cmake -B build -DMAIN_CPP_FILE_NAME=main_observer_ct.cpp
$ cmake --build build --target run_in_renode
</code></pre>
<p class="normal">This implementation of the Observer pattern allows us to register subscribers in a more flexible manner. To make it more generic, as an exercise, you can modify it so that the <code class="inlineCode">notify</code> method is able to take a variable number of arguments.</p>
<h1 class="heading-1" id="_idParaDest-206">Summary</h1>
<p class="normal">In this chapter, we went through the Observer pattern, both runtime and compile-time implementations.</p>
<p class="normal">Compile-time implementation is utilizing what we know about the application during compile-time. It is based on variadic template classes and fold expressions. The result is super compact and fast code, as we are not storing information about subscribers in a container, nor do we need to iterate through the container to make a call to <code class="inlineCode">update</code> methods.</p>
<p class="normal">In the next chapter, we will cover <strong class="keyWord">Finite State Machines (FSM)</strong> and the implementation of the State patterns in C++.</p>
<h1 class="heading-1" id="_idParaDest-207">Join our community on Discord</h1>
<p class="normal">Join our community’s Discord space for discussions with the author and other readers:</p>
<p class="normal"><a href="https://packt.link/embeddedsystems">https://packt.link/embeddedsystems</a></p>
<p class="normal"><img alt="" role="presentation" src="img/QR_code_Discord.png"/></p>
</div>
</body></html>