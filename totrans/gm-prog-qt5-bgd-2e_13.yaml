- en: Animations in Qt Quick Games
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt Quick 游戏中的动画
- en: In the previous two chapters, we introduced you to the basics of Qt Quick and
    QML. By now, you should be fluent enough with the syntax and understand the basic
    concepts of how Qt Quick works. In this chapter, we will show you how to make
    your games stand out from the crowd by introducing different kinds of animations
    that make your applications feel more like the real world. You will also learn
    to treat Qt Quick objects as separate entities programmable using state machines.
    A significant part of this chapter will introduce how to implement a number of
    important gaming concepts using Qt Quick. All this will be shown while we build
    a simple 2D action game using the presented concepts.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两章中，我们向您介绍了 Qt Quick 和 QML 的基础知识。到现在，您应该已经足够熟练地掌握了语法，并理解了 Qt Quick 的工作基本概念。在本章中，我们将向您展示如何通过引入不同类型的动画，使您的游戏与众不同，使您的应用程序感觉更像现实世界。您还将学习如何将
    Qt Quick 对象视为可使用状态机编程的独立实体。由于书籍无法包含动态图像，所以您将不得不通过运行提供的 Qt Quick 代码来自行测试我们描述的大多数内容。
- en: 'The main topics covered in this chapter are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主要主题如下：
- en: Animation framework in Qt Quick
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt Quick 中的动画框架
- en: States and transitions in depth
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入理解状态和转换
- en: Implementing games in Qt Quick
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Qt Quick 中实现游戏
- en: Sprite animations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精灵动画
- en: Using state machines for animation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用状态机进行动画
- en: Parallax scrolling
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垂直滚动
- en: Collision detection
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碰撞检测
- en: Animation framework in Qt Quick
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt Quick 中的动画框架
- en: In [Chapter 11](b81d9c47-58fa-49dd-931a-864c7be05840.xhtml), *Introduction to
    Qt Quick*, we implemented a simple animation using Qt Quick states and transitions.
    We will now deepen our knowledge on this topic and learn how to add some dynamics
    into the user interfaces we create. Thus far, books cannot contain moving pictures,
    so you will have to test most things we describe here yourself by running the
    provided Qt Quick code.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 11 章](b81d9c47-58fa-49dd-931a-864c7be05840.xhtml) “Qt Quick 简介”中，我们使用 Qt
    Quick 状态和转换实现了简单的动画。现在，我们将深化对这个主题的了解，并学习如何在我们创建的用户界面中添加一些动态效果。到目前为止，书籍无法包含动态图像，所以您将不得不通过运行提供的
    Qt Quick 代码来自行测试我们描述的大多数内容。
- en: Qt Quick provides a very extensive framework for creating animations. By that,
    we don't mean only moving items around. We define an animation as *changing an
    arbitrary value over time*. So, what can we animate? Of course, we can animate
    item geometry. However, we can also animate rotation, scale, other numeric values,
    and even colors, but let's not stop here. Qt Quick also lets you animate the parent-child
    hierarchy of items or anchor assignments. Almost anything that can be represented
    by an item property can be animated.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick 提供了一个非常广泛的框架来创建动画。我们这里所说的不仅仅是指移动项目。我们定义动画为“随时间改变任意值”。那么，我们可以动画化什么？当然，我们可以动画化项目几何形状。然而，我们还可以动画化旋转、缩放、其他数值，甚至是颜色，但让我们不要止步于此。Qt
    Quick 还允许您动画化项目的父子层次结构或锚点分配。几乎任何可以用项目属性表示的东西都可以进行动画化。
- en: Moreover, the changes are rarely linear—if you kick a ball in the air, it first
    gains height quickly because its initial speed was large. However, the ball is
    a physical object being pulled down by the earth's gravity, which slows the climb
    down until the ball stops and then starts falling down, accelerating until it
    hits the ground. Depending on the properties of both the ground and the ball,
    the object can bounce off the surface into the air again with less momentum, repeating
    the spring-like motion until eventually it fades away, leaving the ball on the
    ground. Qt Quick lets you model all that using easing curves that can be assigned
    to animations.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，变化很少是线性的——如果你把球踢到空中，它首先会迅速上升，因为它的初始速度很大。然而，球是一个受到地球重力拉扯的物理对象，这会减缓上升速度，直到球停止并开始下落，加速直到它触地。根据地面和球体的属性，物体可以弹起再次进入空中，动量减少，重复弹簧般的运动，直到最终它逐渐消失，球落在地上。Qt
    Quick 允许您使用可以分配给动画的缓动曲线来模拟所有这些。
- en: Generic animations
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用动画
- en: Qt Quick provides a number of animation types derived from a generic `Animation` element
    that you will never use directly. The type exists only to provide an API common
    to different animation types.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick 提供了多种从通用 `Animation` 元素派生出的动画类型，您永远不会直接使用。这种类型的存在只是为了提供不同动画类型共有的 API。
- en: Let's take a closer look at the animation framework by looking at a family of
    animation types derived from the most common animation type—`PropertyAnimation`.
    As the name implies, they provide the means to animate values of object properties.
    Despite the fact that you can use the `PropertyAnimation` element directly, it
    is usually more convenient to use one of its subclasses that specialises in dealing
    with the peculiarities of different data types.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看从最常见的动画类型`PropertyAnimation`派生的一系列动画类型，让我们更深入地了解动画框架。正如其名所示，它们提供了动画化对象属性值的方法。尽管您可以直接使用`PropertyAnimation`元素，但通常使用其子类会更方便，这些子类专门处理不同数据类型的特殊性。
- en: 'The most basic property animation type is `NumberAnimation`, which lets you
    animate all kinds of numeric values of both integral and real numbers. The simplest
    way of using it is to declare an animation, tell it to animate a specific property
    in a specific object, and then set the length of the animation and the starting
    and ending value for the property:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的属性动画类型是`NumberAnimation`，它允许您对整数和实数的所有数值进行动画处理。使用它的最简单方法是声明一个动画，告诉它在一个特定对象中动画化一个特定的属性，然后设置动画的长度以及属性的起始和结束值：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Time for action – Scene for an action game
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动场景 – 行动游戏场景
- en: Let's try something new for our new project. Select New File or Project from
    the File menu of Qt Creator, switch to the Other Project category and choose the Qt
    Quick UI Prototype template. Qt Creator will create a main QML file and a project
    file with the `.qmlproject` extension. This kind of project file is different
    than regular project files with the `.pro` extension. This is a pure QML project
    that does not contain any C++ code and thus does not require compilation. However,
    you need a QML runtime environment to run this project. Your Qt installation provides
    such an environment, so you can run the project from the terminal using the `qmlscene
    main.qml` command or just let Qt Creator handle that. Note that the Qt resources
    system is not used with these projects, and the QML files are loaded directly
    from the filesystem.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的新项目中尝试一些新东西。从Qt Creator的文件菜单中选择新建文件或项目，切换到其他项目类别，并选择Qt Quick UI原型模板。Qt
    Creator将创建一个主QML文件和一个具有`.qmlproject`扩展名的项目文件。这种项目文件与具有`.pro`扩展名的常规项目文件不同。这是一个纯QML项目，不包含任何C++代码，因此不需要编译。但是，您需要一个QML运行时环境来运行此项目。您的Qt安装提供了这样的环境，因此您可以使用`qmlscene
    main.qml`命令从终端运行项目，或者让Qt Creator处理。请注意，这些项目不使用Qt资源系统，QML文件直接从文件系统中加载。
- en: If you need to add C++ code to your project or you intend to distribute compiled
    binaries of the project, use the Qt Quick Application templates instead. The Qt
    Quick UI Prototype template, as the name implies, is only good for prototypes.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要向项目中添加C++代码或您打算分发项目的编译二进制文件，请使用Qt Quick应用程序模板。正如其名所示，Qt Quick UI原型模板仅适用于原型。
- en: 'In the project directory, make a subdirectory called `images` and from the
    game project that we have created using Graphics View, copy `grass.png`, `sky.png`,
    and `trees.png`. Then, put the following code into the QML document:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目目录中，创建一个名为`images`的子目录，并从使用Graphics View创建的游戏项目中复制`grass.png`、`sky.png`和`trees.png`。然后，将以下代码放入QML文档中：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you don't declare the top-level `Window` object, `qmlscene` will display
    the top-level Qt Quick item in a window automatically. Note that when writing
    a Qt Quick application driven by the `QQmlApplicationEngine` class, you need to
    declare the `Window` object explicitly.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有声明顶层`Window`对象，`qmlscene`将自动在一个窗口中显示顶层Qt Quick项。请注意，当编写由`QQmlApplicationEngine`类驱动的Qt
    Quick应用程序时，您需要显式声明`Window`对象。
- en: 'When you run the project now, you will see a screen similar to this one:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当您现在运行项目时，您将看到一个类似于这个的屏幕：
- en: '![](img/065bfe56-ccd5-4b71-a0eb-349a2405fd24.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/065bfe56-ccd5-4b71-a0eb-349a2405fd24.png)'
- en: What just happened?
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We set up a very simple scene consisting of three images stacked up to form
    a landscape. Between the background layer (the sky) and the foreground (trees),
    we placed a yellow circle representing the sun. Since we will be moving the sun
    around in a moment, we anchored the center of the object to an empty item without
    physical dimensions so that we can set the sun's position relative to its center.
    We also equipped the scene with a `dayLength` property, which will hold information
    about the length of one day of game time. By default, we set it to 60 seconds
    so that things happen really quickly and we can see the animation's progress without
    waiting. After all things are set correctly, the length of the day can be balanced
    to fit our needs.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置了一个非常简单的场景，由三张图片堆叠形成景观。在背景层（天空）和前景（树木）之间，我们放置了一个代表太阳的黄色圆圈。由于我们很快就会移动太阳，我们将对象的中心锚定到一个没有物理尺寸的空项上，这样我们就可以设置太阳相对于其中心的位置。我们还为场景配备了一个`dayLength`属性，它将保存有关游戏时间一天长度的信息。默认情况下，我们将其设置为60秒，这样事情就会发生得非常快，我们可以看到动画的进度而无需等待。在所有事情都设置正确之后，我们可以调整一天的长度以适应我们的需求。
- en: The graphical design lets us easily manipulate the sun while keeping it behind
    the tree line. Note how the stacking order is implicitly determined by the order
    of elements in the document.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图形设计使我们能够轻松地操作太阳，同时保持它在树线之后。注意堆叠顺序是隐式地由文档中元素的顺序决定的。
- en: Time for action – Animating the sun's horizontal movement
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 动画化太阳的水平移动
- en: The everyday cruise of the sun in the sky starts in the east and continues west
    to hide beneath the horizon in the evening. Let's try to replicate this horizontal
    movement by adding animation to our `sun` object.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 太阳在天空中的日常巡航从东方开始，继续向西，直到在傍晚时分隐藏在地平线之下。让我们通过向我们的`sun`对象添加动画来尝试复制这种水平移动。
- en: 'Open the QML document of our last project. Inside the `root` item, add the
    following declaration:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 打开我们上一个项目的QML文档。在`root`项内部，添加以下声明：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Running the program with such modifications will produce a run with a horizontal
    movement of the sun. The following image is a composition of a number of frames
    of the run:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对程序进行这样的修改后，将产生一个太阳水平移动的运行效果。以下图像是运行过程中多个帧的组合：
- en: '![](img/37a27ca1-c6ad-46c3-9ce6-dbe6356e30c2.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/37a27ca1-c6ad-46c3-9ce6-dbe6356e30c2.png)'
- en: What just happened?
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We introduced a `NumberAnimation` element that is set to animate the `x` property
    of the `sun` object. The animation starts at `0` and lasts until `x` reaches the `root` item's
    width (which is the right edge of the scene). The movement lasts for `dayLength` milliseconds.
    The `running` property of the animation is set to `true` to enable the animation.
    Since we didn't specify otherwise, the motion is linear.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们引入了一个`NumberAnimation`元素，该元素被设置为动画化`sun`对象的`x`属性。动画从`0`开始，直到`x`达到`root`项的宽度（这是场景的右边缘）。移动持续`dayLength`毫秒。动画的`running`属性被设置为`true`以启用动画。由于我们没有指定其他方式，所以运动是线性的。
- en: You may be thinking that the animation runs in the wrong direction—"west" is
    on the left and "east" is on the right, yes? That's true, however, only if the
    observer faces north. If that were the case for our scene, we wouldn't be seeing
    the sun at all—at noon, it crosses the south direction.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为动画运行的方向是错误的——“西”在左边，“东”在右边，对吗？是的，然而，这只在观察者面向北方时才是这样。如果我们的场景是这样的，我们就根本看不到太阳——在正午时分，它会穿越南方方向。
- en: Composing animations
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画组合
- en: The animation we made in the last section looks OK but is not very realistic.
    The sun should rise in the morning, reach its peak sometime before noon, and then,
    sometime later, start setting toward the evening, when it should cross the horizon
    and hide beneath the landscape.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一个部分制作的动画看起来不错，但并不非常逼真。太阳应该在早上升起，在中午之前达到顶峰，然后，在稍后，开始向傍晚方向落下，此时它应该越过地平线并隐藏在地形之下。
- en: 'To achieve such an effect, we can add two more animations for the `y` property
    of the sun. The first animation would start right at the beginning and decrease
    the vertical position of the sun (remember that the vertical geometry axis points
    down, so decreasing the vertical position means the object goes up). The animation
    would be complete at one-third of the day length. We would then need a way to
    wait for some time and then start a second animation that would pull the object
    down toward the ground. Starting and stopping the animation is easy—we can either
    call the `start()` and `stop()` functions on the animation item or directly alter
    the value of the `running` property. Each `Animation` object emits `started()` and `stopped()` signals.
    The delay can be implemented using a timer. We can provide a signal handler for
    the stopped signal of the first animation to trigger a timer to start the other
    one like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这种效果，我们可以为太阳的 `y` 属性添加两个额外的动画。第一个动画将从开始时立即开始，并降低太阳的垂直位置（记住，垂直几何轴指向下方，因此降低垂直位置意味着对象向上移动）。动画将在一天长度的三分之一时完成。然后我们需要一种方法来等待一段时间，然后启动第二个动画，将对象向下拉向地面。启动和停止动画很容易——我们可以在动画项上调用
    `start()` 和 `stop()` 函数，或者直接更改 `running` 属性的值。每个 `Animation` 对象都会发出 `started()`
    和 `stopped()` 信号。延迟可以通过定时器实现。我们可以为第一个动画的停止信号提供一个信号处理程序，以触发定时器来启动另一个，如下所示：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Even ignoring any side problems this would bring (for example, how to stop the
    animation without starting the second one), such an approach couldn't be called
    "declarative", could it?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 即使忽略任何可能带来的副作用（例如，如何在不启动第二个动画的情况下停止动画），这种方法也不能被称为“声明式”，对吧？
- en: Fortunately, similar to what we had in C++, Qt Quick lets us form animation
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，与 C++ 中的情况类似，Qt Quick 允许我们形成动画
- en: 'groups that run either parallel to each other or in sequence. There are the `SequentialAnimation` and `ParallelAnimation` types
    where you can declare any number of child animation elements forming the group.
    To run two animations in parallel, we can declare the following hierarchy of elements:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 运行要么相互并行或按顺序运行的组。有 `SequentialAnimation` 和 `ParallelAnimation` 类型，您可以在其中声明任何数量的子动画元素形成组。要并行运行两个动画，我们可以声明以下元素层次结构：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The same technique can be used to synchronize a larger group of animations,
    even if each component has a different duration:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的技术可以用来同步更大的动画组，即使每个组件的持续时间不同：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The group presented in the snippet consists of three animations. The first
    two animations are executed together as they form a parallel subgroup. One member
    of the group runs twice as long as the other. Only after the whole subgroup completes
    is the third animation started. This can be visualized using a **Unified Modeling
    Language** (**UML**) activity diagram where the size of each activity is proportional
    to the duration of that activity:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 段落中展示的组由三个动画组成。前两个动画作为一个并行子组一起执行。组中的一个成员的运行时间是另一个的两倍。只有当整个子组完成时，第三个动画才开始。这可以通过一个
    **统一建模语言** （**UML**） 活动图来可视化，其中每个活动的尺寸与该活动的持续时间成比例：
- en: '![](img/cb2e67ae-f394-456e-b89f-0d93302f1031.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cb2e67ae-f394-456e-b89f-0d93302f1031.png)'
- en: Time for action – Making the sun rise and set
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动作时间 - 制作日出日落
- en: Let's add vertical movement (animation of the `y` property) to our sun by adding
    a sequence of animations to the QML document. As our new animations will be running
    in parallel to the horizontal animation, we can enclose animations for both directions
    within a single `ParallelAnimation` group. It would work, but in our opinion,
    this will unnecessarily clutter the document. Another way of specifying parallel
    animations is to declare them as separate hierarchies of elements, making each
    animation independent of the other, and that is what we will do here.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过向 QML 文档中添加一系列动画来给我们的太阳添加垂直运动（`y` 属性的动画）。由于我们的新动画将与水平动画并行运行，我们可以将两个方向的动画都包含在一个单独的
    `ParallelAnimation` 组中。这会起作用，但据我们看来，这会不必要地使文档变得杂乱。指定并行动画的另一种方法是声明它们为独立的元素层次结构，使每个动画独立于其他动画，这正是我们将在这里做的。
- en: 'Open our document from the last exercise, and right under the previous animation,
    place the following code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 打开上一练习中的文档，并在上一个动画下方放置以下代码：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Running the program will result in the light source rising in the morning and
    setting in the evening. However, the trajectory of the move seems somewhat awkward:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序将在早晨使光源升起，在傍晚落下。然而，移动的轨迹似乎有些笨拙：
- en: '![](img/7f99c344-bada-4e58-855f-1ad90e001ad2.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7f99c344-bada-4e58-855f-1ad90e001ad2.png)'
- en: What just happened?
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We declared a sequential animation group consisting of three animations, each
    taking one-third of the day length. The first member of the group makes the sun
    go up. The second member, which is an instance of a new element type—`PauseAnimation`—introduces
    a delay equal to its duration. This, in turn, lets the third component start its
    work in the afternoon to pull the sun down toward the horizon.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了一个包含三个动画的顺序动画组，每个动画占用一天长度的三分之一。组中的第一个成员使太阳升起。第二个成员是一个新元素类型——`PauseAnimation`——实例，它引入了一个等于其持续时间的延迟。这反过来又使得第三个组件在下午开始工作，将太阳拉向地平线。
- en: The problem with such a declaration is that the sun moves in a horribly angular
    way, as can be seen in the image.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这种声明的问题在于太阳移动的方式非常角度化，如图像所示。
- en: Non-linear animations
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非线性动画
- en: The reason for the described problem is that our animations are linear. As we
    noted at the beginning of this chapter, linear animations rarely occur in nature,
    which usually makes their use yield a very unrealistic result.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 描述的问题的原因是我们的动画是线性的。正如我们在本章开头所指出的，线性动画在自然界中很少发生，这通常使得它们的使用产生非常不现实的结果。
- en: 'We also said earlier that Qt Quick allows us to use easing curves to perform
    animations along non-linear paths. There are a large number of curves offered.
    Here''s a diagram listing the available non-linear easing curves:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前也提到过，Qt Quick 允许我们使用缓动曲线在非线性路径上执行动画。这里提供了大量的曲线。下面是一个列出可用非线性缓动曲线的图表：
- en: '![](img/a3beebc3-9ef9-47c7-99c7-9e60bfafe57f.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a3beebc3-9ef9-47c7-99c7-9e60bfafe57f.png)'
- en: You can use any of the curves on an element of the `PropertyAnimation` type or
    one derived from it (for example, `NumberAnimation`). This is done using the `easing` property
    group, where you can set the `type` of the curve. Different curve types may further
    be tweaked by setting a number of properties in the `easing` property group, such
    as `amplitude` (for bounce and elastic curves), `overshoot` (for back curves),
    or `period` (for elastic curves).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `PropertyAnimation` 类型或其派生类型（例如，`NumberAnimation`）的任何曲线。这是通过使用 `easing`
    属性组来完成的，其中你可以设置曲线的 `type`。可以通过在 `easing` 属性组中设置多个属性进一步调整不同的曲线类型，例如 `amplitude`（用于弹跳和弹性曲线）、`overshoot`（用于回弹曲线）或
    `period`（用于弹性曲线）。
- en: 'Declaring an animation along an `InOutBounce` path is very easy:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 声明一个沿 `InOutBounce` 路径的动画非常简单：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Time for action – Improving the path of the sun
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 改善太阳的路径
- en: The task at hand will be to improve the animation of the sun so that it behaves
    in a more realistic way. We will do this by adjusting the animations so that the
    object moves over a curved path.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当前任务将是改善太阳的动画，使其表现得更加逼真。我们将通过调整动画，使对象沿着曲线路径移动。
- en: 'In our QML document, replace the previous vertical animation with the following
    one:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 QML 文档中，将之前的垂直动画替换为以下动画：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following picture shows how the sun will now move:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片显示了太阳现在将如何移动：
- en: '![](img/79c81a48-95e9-48f6-9481-9af3d8461be7.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/79c81a48-95e9-48f6-9481-9af3d8461be7.png)'
- en: What just happened?
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: The sequence of three animations (two linear ones and a pause) was replaced
    by another sequence of two animations that follow a path determined by a cubic
    function. This makes our sun rise pretty fast and then slow down to an amount
    almost unnoticeable near the moment when the sun approaches noon. When the first
    animation is finished, the second one reverses the motion, making the sun descend
    very slowly and then increase its velocity as dusk approaches. As a result, the
    farther the sun is from the ground, the slower it seems to move. At the same time,
    the horizontal animation remains linear, as the speed of earth in its motion around
    the sun is practically constant. When we combine the horizontal and vertical animations,
    we get a path that looks very similar to what we can observe in the real world.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 三个动画的序列（两个线性动画和一个暂停）被另一个由三次函数确定的路径的动画序列所取代。这使得我们的太阳升起很快，然后减速到几乎在太阳接近中午时几乎察觉不到的程度。当第一个动画完成后，第二个动画反转运动，使太阳缓慢下降，然后在黄昏临近时增加速度。结果，太阳离地面越远，它看起来移动得越慢。同时，水平动画保持线性，因为地球在其围绕太阳的运动中速度实际上是恒定的。当我们结合水平和垂直动画时，我们得到一条看起来非常类似于我们在现实世界中可以观察到的路径。
- en: Property value sources
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性值来源
- en: From the QML perspective, `Animation` and element types derived from it are
    called **property value sources**. This means they can be attached to a property
    and generate values for it. What is important is that it allows us to use animations
    using a much simpler syntax. Instead of explicitly declaring the target and property
    of an animation, you can attach the animation to a named property of the parent
    object.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从QML的角度来看，`Animation`及其派生类型被称为**属性值源**。这意味着它们可以附加到属性并为其生成值。重要的是，它允许我们使用更简单的语法使用动画。而不是显式声明动画的目标和属性，你可以将动画附加到父对象的命名属性。
- en: 'To do this, instead of specifying `target` and `property` for `Animation`,
    use the `on` keyword, followed by the name of a property name for which the animation
    is to be a value source. For example, to animate the `rotation` property of an
    object with a `NumberAnimation` object, the following code can be used:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，对于`Animation`的`target`和`property`，使用`on`关键字，后跟动画要作为值源的属性名。例如，要使用`NumberAnimation`对象动画化一个对象的`rotation`属性，可以使用以下代码：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It is valid to specify more than one property value source for the same property
    of an object.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个对象的同一属性，可以指定多个属性值源。
- en: Time for action – Adjusting the sun's color
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 调整太阳的颜色
- en: If you look at the sun at dusk or dawn, you will see that it is not yellow but
    becomes red the closer it is to the horizon. Let's teach our object representing
    the sun to do the same by providing a property value source for it.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你黄昏或黎明时分看太阳，你会发现它并不是黄色的，而是越靠近地平线就越变成红色。让我们通过为太阳的表示对象提供一个属性值源来让它做同样的事情。
- en: 'Open the QML document, find the declaration for the `sunVisual` object, and
    extend it with the highlighted part:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 打开QML文档，找到`sunVisual`对象的声明，并用下面的高亮部分扩展它：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: What just happened?
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: An animation was attached to the `color` property of our rectangle modeling
    the visual aspects of the sun. The animation consists of three parts. First, we
    perform a transition from red to yellow using the `ColorAnimation` object. This
    is an `Animation` subtype dedicated to modifying colors. Since the rectangle color
    is not a number, using the `NumberAnimation` object will not work, as the type
    cannot interpolate color values. Therefore, we either have to use the `PropertyAnimation` or
    the  `ColorAnimation`  object. The duration for the animation is set to 20 percent
    of half the day length so that the yellow color is obtained very quickly. The
    second component is a `PauseAnimation` object to provide a delay before the third
    component is executed, which gradually changes the color back to red. For the
    last component, we do not provide a value for the `from` property. This causes
    the animation to be initiated with the value of the property current to the time
    when the animation is executed (in this case, the sun should be yellow).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为模拟太阳视觉特征的矩形对象的`color`属性附加了一个动画。这个动画由三个部分组成。首先，我们使用`ColorAnimation`对象从红色过渡到黄色。这是一个专门用于修改颜色的`Animation`子类型。由于矩形的颜色不是数字，使用`NumberAnimation`对象将不起作用，因为类型无法插值颜色值。因此，我们只能使用`PropertyAnimation`或`ColorAnimation`对象。动画的持续时间设置为半日长度的20%，这样黄色就能很快获得。第二个组件是一个`PauseAnimation`对象，在执行第三个组件之前提供延迟，这个组件逐渐将颜色变回红色。对于最后一个组件，我们没有为`from`属性提供值。这导致动画以动画执行时的属性当前值启动（在这种情况下，太阳应该是黄色的）。
- en: Note that we only had to specify the property name for the top-level animation.
    This particular element is what serves as the property value source, and all descendant
    animation objects "inherit" the target property from that property value source.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们只需要指定顶级动画的属性名。这个特定的元素充当属性值源，所有下级动画对象“继承”目标属性来自该属性值源。
- en: Time for action – Furnishing sun animation
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 装饰太阳动画
- en: The animation of the sun looks almost perfect right now. We can still improve
    it, though. If you look into the sky in the early morning and then again at noon,
    you will note that the sun appears much bigger during sunrise or sunset compared
    to its size when it is at its zenith. We can simulate that effect by scaling the
    object.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 目前太阳的动画看起来几乎是完美的。尽管如此，我们仍然可以改进它。如果你在清晨和中午时分观察天空，你会注意到太阳在日出或日落时比它在顶点时看起来要大得多。我们可以通过缩放对象来模拟这种效果。
- en: 'In our scene document, add another sequential animation that operates on the `scale` property
    of the sun:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景文档中，为太阳的`scale`属性添加另一个顺序动画：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s examine the result again:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次检查结果：
- en: '![](img/483fbc98-cf8f-4e18-b982-1463b56c5260.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/483fbc98-cf8f-4e18-b982-1463b56c5260.png)'
- en: What just happened?
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: 'In this section, we just followed the path set for an earlier declaration—the
    vertical movement of the stellar body influences its perceived size; therefore,
    it seems like a good decision to bind the two animations together. Note that instead
    of specifying a new property value source for the scale, we might have modified
    the original animation and made the scale animation parallel to the animation
    that operates on the `y` property:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们只是遵循了之前声明的路径——恒星体的垂直运动影响其感知大小；因此，将两个动画绑定在一起似乎是一个明智的决定。请注意，我们可能没有为缩放指定新的属性值源，而是修改了原始动画，使缩放动画与操作`y`属性的动画并行：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Have a go hero – Animating the sun's rays
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 英雄尝试——动画太阳光线
- en: 'By now, you should be an animation expert. If you want to try your skills,
    here''s a task for you. The following code can be applied to the `sun` object
    and will display very simple red rays emitted from the sun:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该已经成为一个动画专家了。如果你想尝试你的技能，这里有一个任务给你。以下代码可以应用于`sun`对象，并将显示从太阳发出的非常简单的红色光线：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The result is shown on the following picture:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下图所示：
- en: '![](img/517c197a-240c-4c29-9961-8d5f425ec593.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/517c197a-240c-4c29-9961-8d5f425ec593.png)'
- en: The goal is to animate the rays so that the overall effect looks good and fits
    the tune like style of the scene. Try different animations—rotations, size changes,
    and colors. Apply them to different elements—all rays at once (for example, using
    the `sunRays` identifier) or only particular rectangles generated by the repeater.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是使光线动画看起来整体效果良好，并与场景的调子风格相匹配。尝试不同的动画——旋转、大小变化和颜色。将它们应用于不同的元素——所有光线一次（例如，使用`sunRays`标识符）或仅应用于由重复器生成的特定矩形。
- en: Behaviors
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行为
- en: In the previous chapter, we implemented a dashboard for a racing game where
    we had a number of clocks with needles. We could set values for each clock (for
    example, car speed) and a respective needle would immediately set itself to the
    given value. However, such an approach is unrealistic—in the real world, changes
    of a value happen over time. In our example, the car accelerates from 10 mph to
    50 mph by going through 11 mph, 12 mph, and so on, until after some time it reaches
    the desired value. We call this the **behavior** of a value—it is essentially
    a model that tells how the parameter reaches its destined value. Defining such
    models is a perfect use case for declarative programming. Fortunately, QML exposes
    a `Behavior` element that lets us model behaviors of property changes in Qt Quick.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们实现了一个赛车游戏的仪表盘，其中包含多个带有指针的时钟。我们可以为每个时钟设置值（例如，汽车速度），相应的指针会立即调整到给定的值。然而，这种方法是不现实的——在现实世界中，值的改变是随着时间的推移发生的。在我们的例子中，汽车通过11英里/小时、12英里/小时等逐步加速，直到一段时间后达到期望的值。我们称这为值的**行为**——它本质上是一个模型，告诉参数如何达到其目标值。定义这样的模型是声明性编程的完美用例。幸运的是，QML公开了一个`Behavior`元素，允许我们模拟Qt
    Quick中属性变化的动态行为。
- en: The `Behavior` elements let us associate an animation with a given property
    so that every time the property value is to be changed, it is done by running
    the given animation instead of by making an immediate change to the property value.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`Behavior`元素允许我们将动画与给定的属性关联起来，以便每次属性值需要更改时，它都会通过运行给定的动画而不是直接更改属性值来完成。'
- en: 'Consider a simple scene defined by the following code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码定义的简单场景：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This scene contains a red rectangle anchored to an empty item. Whenever the
    user clicks somewhere within the scene, the empty item is moved there, dragging
    along the rectangle. Let''s see how to use the `Behavior` element to smoothly
    change the position of the empty item. Similar to `Animation` and other property
    value sources, the `Behavior` element can be used with the on-property syntax:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个场景包含一个锚定到空项上的红色矩形。每当用户在场景内点击某处时，空项就会移动到那里，并拖动矩形。让我们看看如何使用`Behavior`元素来平滑地改变空项的位置。类似于`Animation`和其他属性值源，`Behavior`元素可以使用on属性语法：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: By adding the two marked declarations, we define behaviors for the `x` and `y` properties that
    follow animations defined by `NumberAnimation`. We do not include start or end
    values for the animation as these will depend on the initial and final value for
    the property. We also don't set the property name in the animation because by
    default, the property for which the behavior is defined will be used. As a result,
    we get a linear animation of a numerical property from the original value to the
    destined value over the default duration.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加两个标记的声明，我们为`NumberAnimation`定义的行为定义了`x`和`y`属性的行为。我们不包含动画的起始或结束值，因为这些将取决于属性的初始和最终值。我们也没有在动画中设置属性名称，因为默认情况下，定义行为所用的属性将被使用。因此，我们得到一个从原始值到目标值的线性动画，持续时间为默认值。
- en: Using linear animations for real-world objects rarely looks good. Usually, you
    will get much better results if you set an easing curve for the animation so that
    it starts slowly and then gains speed and decelerates just before it is finished.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 对于现实世界中的对象，使用线性动画通常看起来不太好。通常，如果你为动画设置一个缓动曲线，那么它将开始缓慢，然后加速，并在完成前减速，你会得到更好的结果。
- en: 'Animations that you set on behaviors can be as complex as you want:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 设置在行为上的动画可以像你想要的那样复杂：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The behavioral model declared in the last piece of code performs a sequential
    animation. It first changes the color of the rectangle to yellow using the `PropertyAction` element,
    which performs an immediate update of a property value (we will talk about this
    more a bit later). The color will be set back to red after the last step of the
    model. In the meantime, a parallel animation is performed. One of its components
    is a `NumberAnimation` class that executes the actual animation of the `x` property
    of `empty` (since the target and property of the animation are not explicitly
    set). The second component is a sequential animation of the `scale` property of
    the rectangle, which first scales the item up by 50 percent during the first half
    of the animation and then scales it back down in the second half of the animation.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一行代码中声明的行为模型执行一个顺序动画。它首先使用`PropertyAction`元素将矩形的颜色更改为黄色，该元素执行属性值的即时更新（我们稍后会详细讨论这一点）。在模型的最后一步之后，颜色将恢复为红色。同时，执行一个并行动画。其一个组件是一个`NumberAnimation`类，它执行`empty`的`x`属性的动画（因为动画的目标和属性没有明确设置）。第二个组件是矩形的`scale`属性的顺序动画，它在动画的前半部分将项目放大50%，然后在动画的后半部分将其缩小回原始大小。
- en: Time for action – Animating the car dashboard
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 动画汽车仪表板
- en: Let's employ the knowledge we just learned to improve the car dashboard we created
    in the previous chapter. We will use animations to show some realism in the way
    the clocks update their values.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运用刚刚学到的知识来改进我们在上一章中创建的汽车仪表板。我们将使用动画来展示时钟更新值时的逼真效果。
- en: 'Open the dashboard project and navigate to the `main.qml` file. Find the declaration
    of the `Needle` object, which is responsible for visualizing the speed of the
    vehicle. Add the following declaration to the object:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 打开仪表板项目并导航到`main.qml`文件。找到负责可视化车辆速度的`Needle`对象的声明。向该对象添加以下声明：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Repeat the process for the left clock. Set the velocity of the animation to `100`.
    Build and run the project. See how the needles behave when you modify the parameter
    values in spin boxes. Adjust the `velocity` of each animation until you get a
    realistic result.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对左侧时钟重复此过程。将动画速度设置为`100`。构建并运行项目。观察当你修改旋转框中的参数值时，指针的行为。调整每个动画的`velocity`，直到得到逼真的效果。
- en: What just happened?
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We have set the property value sources on needle rotations that are triggered
    whenever a new value for the property is requested. Instead of immediately accepting
    the new value, the `Behavior` element intercepts the request and starts the `SmoothedAnimation` class
    to gradually reach the requested value. The `SmoothedAnimation` class is an animation
    type that animates numeric properties. The speed of the animation is not determined
    by its duration; instead, a `velocity` property is set. This property dictates
    how fast a value is to be changed. However, the animation is using a non-linear
    path—it starts slowly, then accelerates to the given velocity, and, near the end
    of the animation, decelerates in a smooth fashion. This yields an animation that
    is attractive and realistic and, at the same time, is of shorter or longer duration,
    depending on the distance between the starting and ending values.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在需要请求属性新值的针旋转上设置了属性值源。而不是立即接受新值，`Behavior`元素拦截请求并启动`SmoothedAnimation`类来逐渐达到请求的值。`SmoothedAnimation`类是一种动画类型，它动画化数值属性。动画的速度不是由其持续时间决定的；相反，设置了一个`velocity`属性。该属性决定了值改变的速度。然而，动画使用的是非线性路径——它开始缓慢，然后加速到给定的速度，在动画接近结束时以平滑的方式减速。这产生了一种既吸引人又逼真的动画，同时，根据起始值和结束值之间的距离，动画的持续时间可以是较短或较长的。
- en: You can implement custom property value sources by subclassing `QQmlPropertyValueSource` and
    registering the class in the QML engine.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过继承`QQmlPropertyValueSource`并注册该类到 QML 引擎中来实现自定义属性值源。
- en: States
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态
- en: When you look at real-world objects, it is often very easy to define their behavior
    by extracting a number of states the object may take and describing each of the
    states separately. A lamp can be turned either on or off. When it is "on", it
    is emitting light of a given color, but it is not doing that when in the "off"
    state. Dynamics of the object can be defined by describing what happens if the
    object leaves one of the states and enters another one. Considering our lamp example,
    if you turn the lamp on, it doesn't momentarily start emitting light with its
    full power, but the brightness of the light gradually increases to reach its final
    power after a very short period.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当你观察现实世界中的对象时，通常很容易通过提取对象可能采取的几个状态并分别描述每个状态来定义其行为。灯可以打开或关闭。当它是“打开”状态时，它会发出特定颜色的光，但在“关闭”状态下则不会这样做。可以通过描述对象离开一个状态并进入另一个状态时发生的情况来定义对象的行为。以我们的灯为例，如果你打开灯，它不会瞬间以全功率开始发光，而是亮度逐渐增加，在很短的时间内达到最终功率。
- en: Qt Quick supports *state-driven* development by letting us declare states and
    transitions between them for items. The model fits the declarative nature of Qt
    Quick very well.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick 通过允许我们为项目声明状态及其之间的转换来支持*状态驱动*开发。该模型非常适合 Qt Quick 的声明性特性。
- en: 'By default, each item has a single anonymous state, and all properties you
    define take values of the expressions you bind or assign to them imperatively
    based on different conditions. Instead of this, a set of states can be defined
    for the object and for each of the state properties of the object itself; in addition,
    the objects defined within it can be programmed with different values or expressions.
    Our example lamp definition could be similar to this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，每个项目都有一个匿名状态，你定义的所有属性都接受你绑定或基于不同条件强制分配给它们的表达式的值。相反，可以为对象及其每个状态属性定义一组状态；此外，在其中定义的对象可以用不同的值或表达式进行编程。我们的示例灯定义可能与此类似：
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We could, of course, bind the `color` property of `lightsource` to `lamp.lampOn
    ? "yellow" : "transparent"`; instead, we can define an "on" state for the lamp
    and use a `PropertyChanges` element to modify the rectangle color:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '我们当然可以将`lightsource`的`color`属性绑定到`lamp.lampOn ? "yellow" : "transparent"`；相反，我们可以为灯定义一个“打开”状态，并使用`PropertyChanges`元素来修改矩形颜色：'
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Each item has a `state` property that you can read to get the current state,
    but you can also write to it to trigger transition to a given state. By default,
    the `state` property is set to an empty string that represents the anonymous state.
    Note that with the preceding definition, the item has two states—the "on" state
    and the anonymous state (which is used when the lamp is off in this case). Remember
    that state names have to be unique as the `name` parameter is what identifies
    a state in Qt Quick.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 每个项目都有一个`state`属性，你可以读取它来获取当前状态，但你也可以写入它以触发转换到给定的状态。默认情况下，`state`属性被设置为空字符串，表示匿名状态。请注意，根据前面的定义，项目有两个状态——“开启”状态和匿名状态（在这种情况下，当灯关闭时使用）。记住，状态名称必须是唯一的，因为`name`参数是Qt
    Quick中识别状态的方式。
- en: 'To enter a state, we can, of course, use an event handler fired when the value
    of the `lampOn` parameter is modified:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要进入一个状态，我们当然可以使用在`lampOn`参数值修改时触发的事件处理器：
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Such imperative code works, but it can be replaced with a declarative definition
    in the state itself:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的命令式代码可以工作，但可以用状态本身的声明式定义来替换：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Whenever the expression bound to the `when` property evaluates to `true`, the
    state becomes active. If the expression becomes `false`, the object will return
    to the default state or will enter a state for which its own `when` property evaluates
    to `true`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当绑定到`when`属性的表达式评估为`true`时，状态变为活动状态。如果表达式变为`false`，对象将返回默认状态或进入其`when`属性评估为`true`的状态。
- en: 'To define more than one custom state, it is enough to assign a list of state
    definitions to the `states` property:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义多个自定义状态，只需将状态定义列表分配给`states`属性即可：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `PropertyChanges` element is the most often used change in a state definition,
    but it is not the only one. In exactly the same way that the `ParentChange` element
    can assign a different parent to an item and the `AnchorChange` element can update
    anchor definitions, it is also possible to run a script when a state is entered
    using the `StateChangeScript`
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在状态定义中，`PropertyChanges`元素是最常用的更改，但它并非唯一。正如`ParentChange`元素可以为项目分配不同的父元素，以及`AnchorChange`元素可以更新锚定义一样，当进入状态时也可以使用`StateChangeScript`运行脚本。
- en: element. All these element types are used by declaring their instances as children
    in a `State` object.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 元素。所有这些元素类型都是通过在`State`对象中声明它们的实例作为子元素来使用的。
- en: Transitions
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换
- en: The second part of the state machine framework is defining how an object transits
    from one state to another. Similar to the `states` property, all items have a `transitions` 
    property, which takes a list of definitions represented by the `Transition` objects
    and provides information about animations that should be played when a particular
    transition takes place.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 状态机框架的第二部分是定义对象如何从一个状态转换到另一个状态。类似于`states`属性，所有项目都有一个`transitions`属性，它接受一个由`Transition`对象表示的定义列表，并提供有关在特定转换发生时应播放的动画的信息。
- en: A transition is identified by three attributes—the source state, the destination
    state, and a set of animations. Both the source state name (set to the `from` property)
    and the target state name (set to the `to` property) can be empty, in which case
    they should be interpreted as "any". If a `Transition` exists that matches the
    current state change, its animations will be executed. A more concrete transition
    definition (which is one where `from` and/or `to` are explicitly set) has precedence
    over a more generic one.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 转换由三个属性标识——源状态、目标状态和一组动画。源状态名称（设置为`from`属性）和目标状态名称（设置为`to`属性）都可以为空，在这种情况下，它们应解释为“任何”。如果存在一个与当前状态更改匹配的`Transition`，则其动画将被执行。更具体的转换定义（其中`from`和/或`to`被显式设置）比更通用的定义具有优先级。
- en: 'Suppose that we want to animate the opacity of the lamp rectangle from `0` to `1` when
    the lamp is switched on. We can do it as an alternative to manipulating the color.
    Let''s update the lamp definition:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想在灯打开时将灯矩形的透明度从`0`动画到`1`。我们可以作为操作颜色的替代方案来做这件事。让我们更新灯的定义：
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The transition is triggered for any source and any target state—it will be active
    when the lamp goes from the anonymous to the "on" state as well as in the opposite
    direction. It defines a single `NumberAnimation` element that works on `opacity`
    property and lasts for 500 miliseconds. The animation does not define the target
    object; thus, it will be executed for any object that needs updating as part of
    the transition—in the case of the lamp, it will only be the `lightsource` object.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 转换会触发任何源状态和任何目标状态——当灯从匿名状态变为“开启”状态以及相反方向时，它将是活动的。它定义了一个单个的`NumberAnimation`元素，该元素作用于`opacity`属性，持续500毫秒。动画没有定义目标对象；因此，它将为需要作为转换一部分更新的任何对象执行——在灯的情况下，它将仅是`lightsource`对象。
- en: 'If more than one animation is defined in a transition, all animations will
    run in parallel. If you need a sequential animation, you need to explicitly use
    a `SequentialAnimation` element:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在转换中定义了多个动画，所有动画将并行运行。如果您需要顺序动画，您需要显式使用`SequentialAnimation`元素：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: States are a feature of all `Item` types as well as its descendent types. It
    is, however, possible to use states with elements not derived from the `Item` object
    using a `StateGroup` element, which is a self-contained functionality of states
    and transitions with exactly the same interface as what is described here regarding `Item` objects.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 状态是所有`Item`类型及其派生类型的一个特性。然而，使用`StateGroup`元素，可以与未从`Item`对象派生的元素一起使用状态，`StateGroup`是一个包含状态和转换的自包含功能，具有与这里描述的`Item`对象完全相同的接口。
- en: More animation types
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多动画类型
- en: The animation types we discussed earlier are used for modifying values of types
    that can be described using physical metrics (position, sizes, colors, angles).
    However, there are more types available.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论的动画类型用于修改可以使用物理度量描述的类型（位置、大小、颜色、角度）的值。然而，还有更多类型可用。
- en: The first group of special animations consists of the `AnchorAnimation` and 
    `ParentAnimation` elements.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 第一组特殊动画包括`AnchorAnimation`和`ParentAnimation`元素。
- en: The `AnchorAnimation` element is useful if a state change should cause a change
    to defined anchors for an item. Without it, the item would immediately snap into
    its place. By using the `AnchorAnimation` element, we trigger all anchor changes
    to be gradually animated.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`AnchorAnimation`元素在需要状态改变导致项目定义的锚点发生变化时非常有用。没有它，项目会立即跳到其位置。通过使用`AnchorAnimation`元素，我们可以触发所有锚点变化逐渐动画化。'
- en: The `ParentAnimation` element, on the other hand, makes it possible to define
    animations that should be present when an item receives a new parent. This usually
    causes an item to be moved to a different position in the scene. By using the `ParentAnimation` element
    in a state transition, we can define how the item gets into its target position.
    The element can contain any number of child animation elements that will be run
    in parallel during a `ParentChange` element.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`ParentAnimation`元素使得在项目获得新的父元素时定义动画成为可能。这通常会导致项目在场景中移动到不同的位置。通过在状态转换中使用`ParentAnimation`元素，我们可以定义项目如何进入其目标位置。该元素可以包含任何数量的子动画元素，这些元素将在`ParentChange`元素期间并行运行。
- en: The second special group of animations is action animations—`PropertyAction` 
    and `ScriptAction`. These animation types are not stretched in time but perform
    a given one-time action.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 第二组特殊动画是动作动画——`PropertyAction`和`ScriptAction`。这些动画类型不是在时间上拉伸，而是执行给定的一次性动作。
- en: The `PropertyAction` element is a special kind of animation that performs an
    immediate update of a property to a given value. It is usually used as part of
    a more complex animation to modify a property that is not animated. It makes sense
    to use it if a property needs to have a certain value during an animation.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`PropertyAction`元素是一种特殊的动画，它将属性立即更新到给定的值。它通常作为更复杂动画的一部分使用，以修改未动画化的属性。如果属性需要在动画期间具有某个特定值，则使用它是有意义的。'
- en: '`ScriptAction` is an element that allows the execution of an imperative piece
    of code during an animation (usually at its beginning or end).'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScriptAction`是一个元素，允许在动画期间执行一个命令式的代码片段（通常在其开始或结束时）。'
- en: Quick game programming
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速游戏编程
- en: Here, we will go through the process of creating a platform game using Qt Quick.
    It will be a game similar to Benjamin the Elephant from [Chapter 6](ad89bd0a-2ed2-49a8-8701-18449629a1ee.xhtml),
    *Qt Core Essentials.* The player will control a character that will be walking
    through the landscape and collecting coins. The coins will be randomly appearing
    in the world. The character can access highly placed coins by jumping.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将通过使用Qt Quick创建平台游戏的过程。这将是一款类似于第6章中提到的本杰明大象的游戏。[第6章](ad89bd0a-2ed2-49a8-8701-18449629a1ee.xhtml)，*Qt核心基础*。玩家将控制一个角色，该角色将在景观中行走并收集金币。金币将在世界中随机出现。角色可以通过跳跃来获取高处的金币。
- en: Throughout this chapter as well as the previous one, we prepared a number of
    pieces that we will be reusing for this game. The layered scene that was arranged
    when you learned about animations will serve as our game scene. The animated sun
    will represent the passing of time.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章以及上一章中，我们准备了一些零件，我们将为这个游戏重新使用它们。当你学习动画时安排的分层场景将作为我们的游戏场景。动画太阳将代表时间的流逝。
- en: We will guide you through implementing the main features of the game. At the
    end of the chapter, you will have a chance to test your skills by adding more
    game mechanics to our project.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将引导你实现游戏的主要功能。在本章结束时，你将有机会通过添加更多游戏机制来测试你的技能。
- en: Game loops
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏循环
- en: Most games revolve around some kind of game loop. It is usually some kind of
    function that is called repeatedly, and its task is to progress the game—process
    input events, move objects around, calculate and execute actions, check win conditions,
    and so on. Such an approach is very imperative and usually results in a very complex
    function that needs to know everything about everybody (this kind of anti-pattern
    is sometimes called a **god object** pattern). In QML (which powers the Qt Quick
    framework), we aim to separate responsibilities and declare well-defined behaviors
    for particular objects. Therefore, although it is possible to set up a timer that
    will periodically call a game loop function, this is not the best possible approach
    in a declarative world.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数游戏都围绕某种游戏循环展开。这通常是一种被反复调用的函数，其任务是推进游戏——处理输入事件、移动对象、计算并执行动作、检查胜利条件等等。这种做法非常命令式，通常会导致一个非常复杂的函数，需要了解每个人的所有信息（这种反模式有时被称为**神对象**模式）。在QML（为Qt
    Quick框架提供动力）中，我们旨在分离责任并为特定对象声明定义良好的行为。因此，尽管可以设置一个定时器，定期调用游戏循环函数，但这在声明性世界中并不是最佳方法。
- en: Instead, we suggest using a natural time-flow mechanism already present in Qt
    Quick—one that controls the consistency of animations. Remember how we defined
    the sun's travel across the sky at the beginning of this chapter? Instead of setting
    up a timer and moving the object by a calculated number of pixels, we created
    an animation, defined a total running time for it, and let Qt take care of updating
    the object. This has the great benefit of neglecting delays in function execution.
    If you used a timer and some external event introduced a significant delay before
    the timeout function was run, the animation would start lagging behind. When Qt
    Quick animations are used, the framework compensates for such delays, skipping
    some of the frame updates to ensure that the requested animation duration is respected.
    Thanks to that, you will not have to take care of it all by yourself.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们建议使用Qt Quick中已经存在的自然时间流动机制——它控制动画的一致性。还记得我们在本章开头定义太阳在天空中移动的方式吗？我们不是设置一个定时器并通过计算像素数来移动对象，而是创建了一个动画，为它定义了总运行时间，并让Qt负责更新对象。这有一个巨大的好处，就是忽略了函数执行中的延迟。如果你使用定时器，而某些外部事件在超时函数运行之前引入了显著的延迟，动画就会开始落后。当使用Qt
    Quick动画时，框架会补偿这些延迟，跳过一些帧更新，以确保尊重请求的动画持续时间。因此，你将不必自己处理所有这些。
- en: To overcome the second difficult aspect of a game loop—the god object anti-pattern—we
    suggest encapsulating the logic of each item directly in the item itself using
    the states and transitions framework we introduced earlier. If you define an object
    using a natural time flow describing all states it can enter during its lifetime
    and actions causing transitions between states, you will be able to just plop
    the object with its included behavior wherever it is needed and thus easily reuse
    such definitions in different games, reducing the amount of work necessary to
    make the object fit into the game.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服游戏循环的第二个难点——上帝对象反模式，我们建议使用我们之前介绍的状态和转换框架，将每个项目的逻辑直接封装在项目本身中。如果你定义一个对象，使用自然的时间流动描述其在生命周期中可以进入的所有状态以及导致状态转换的动作，你就可以将包含行为的对象随意放置在任何需要的地方，从而在不同游戏中轻松重用此类定义，减少使对象适应游戏所需的工作量。
- en: Input processing
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入处理
- en: 'A usual approach in games is to read input events and call functions responsible
    for actions associated with particular events:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中的一种常见方法是读取输入事件并调用与特定事件相关的动作的函数：
- en: '[PRE25]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This, however, has its drawbacks, one of which is the need to check events at
    even periods of time. This might be hard and is certainly not a declarative approach.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法有其缺点，其中之一是需要检查事件在等时间段内。这可能很困难，而且肯定不是一种声明式方法。
- en: We already know that Qt Quick handles keyboard input via the `Keys` attached
    property. It is possible to craft QML code similar to the one just presented,
    but the problem with such an approach is that the faster the player taps keys
    on the keyboard, the more frequently the character will move, jump, or shoot.
    However, it's possible to overcome this problem, as we'll see as we move on.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道 Qt Quick 通过 `Keys` 附加属性处理键盘输入。可以编写类似于刚才展示的 QML 代码，但这种方法的缺点是，玩家在键盘上按得越快，角色移动、跳跃或射击的频率就越高。然而，我们可以克服这个问题，正如我们将看到的。
- en: Time for action – Character navigation
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 角色导航
- en: 'Create a new QML document and call it `Player.qml`. In the document, place
    the following declarations:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的 QML 文档，并将其命名为 `Player.qml`。在文档中，放置以下声明：
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, open the document containing the main scene definition and declare the
    player character near the end of the document after all the background layers
    have been declared:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开包含主场景定义的文档，并在所有背景层声明之后，在文档的末尾声明玩家角色：
- en: '[PRE27]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: What just happened?
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: The player itself is an empty item with a keyboard focus that handles presses
    of the right, left, and up arrow keys, causing them to manipulate the `x` and `y` coordinates
    of the player. The `x` property has a `Behavior` element set so that the player
    moves smoothly within the scene. Finally, anchored to the player item is the actual
    visualization of the player—our elephant friend.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家本身是一个空的项目，具有键盘焦点，可以处理右箭头键、左箭头键和上箭头键的按下，使它们能够操纵玩家的 `x` 和 `y` 坐标。`x` 属性设置了一个
    `Behavior` 元素，以便玩家在场景中平滑移动。最后，锚定在玩家项目上的是玩家的实际可视化——我们的象朋友。
- en: When the right or left arrow keys are pressed, a new position for the character
    will be calculated and applied. Thanks to the `Behavior` element, the item will
    travel gradually (during one second) to the new position. Keeping the key pressed
    will trigger autorepeat and the handler will be called again. In a similar fashion,
    when the up arrow key is pressed, it will activate a prepared sequential animation
    that will lift the character up by 50 pixels and then move it down again to the
    initial position.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当按下右箭头键或左箭头键时，将计算并应用角色的新位置。多亏了 `Behavior` 元素，项目将逐渐（在一秒内）移动到新位置。保持按键将触发自动重复，处理程序将被再次调用。以类似的方式，当按下上箭头键时，它将激活一个准备好的顺序动画，将角色向上提升
    50 像素，然后再次将其移回初始位置。
- en: This approach works, but we can do better. Let's try something different.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可行，但我们能做得更好。让我们尝试一些不同的方法。
- en: Time for action – Another approach to character navigation
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 另一种角色导航方法
- en: 'Replace the previous key handlers with the following code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下代码替换之前的键处理程序：
- en: '[PRE28]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: What just happened?
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: Instead of performing actions immediately, upon pressing a key, we are now setting
    flags (in a private object) for which direction the character should be moving
    in. In our situation, the right direction has priority over the left direction.
    Setting a flag triggers an animation that tries to move the character toward an
    edge of the scene. Releasing the button will clear the flag and stop the animation.
    Before the animation is started, we are calling the `recalculateDurations()` function,
    which checks how long the animation should last for the character to move at the
    desired speed.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在不是立即执行动作，而是在按下键时设置（在私有对象中）角色应该移动的方向的标志。在我们的情况下，右方向比左方向有优先权。设置标志会触发一个尝试将角色移动到场景边缘的动画。释放按钮将清除标志并停止动画。在动画开始之前，我们调用`recalculateDurations()`函数，该函数检查动画应该持续多长时间，以便角色以期望的速度移动。
- en: If you want to replace keyboard-based input with something else, for example,
    accelerometer or custom buttons, the same principle can be applied. When using
    an accelerometer, you can even control the speed of the player by measuring how
    much the device is tilted. You can additionally store the tilt in the `flags.horizontal` parameter
    and make use of that variable in the `recalculateDurations()` function.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要用其他东西替换基于键盘的输入，例如加速度计或自定义按钮，同样的原则也可以应用。当使用加速度计时，你可以通过测量设备倾斜的程度来控制玩家的速度。你还可以将倾斜存储在`flags.horizontal`参数中，并在`recalculateDurations()`函数中使用该变量。
- en: Have a go hero – Polishing the animation
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试一下英雄 – 精炼动画
- en: What we have done is sufficient for many applications. However, you can try
    controlling the movement even more. As a challenge, try modifying the system in
    such a way that during a jump, inertia keeps the current horizontal direction
    and speed of movement of the character until the end of the jump. If the player
    releases the right or left keys during a jump, the character will stop only after
    the jump is complete.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的工作对于许多应用来说是足够的。然而，你可以尝试进一步控制运动。作为一个挑战，尝试以这种方式修改系统，即在跳跃过程中，惯性保持角色的当前水平方向和移动速度直到跳跃结束。如果玩家在跳跃过程中释放了右键或左键，角色只有在跳跃完成后才会停止。
- en: Despite trying to do everything in a declarative fashion, some actions will
    still require imperative code. If some action is to be executed periodically,
    you can use the `Timer` item to execute a function on demand. Let's go through
    the process of implementing such patterns together.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们试图以声明性方式完成所有事情，但某些操作仍然需要命令式代码。如果某些操作需要定期执行，你可以使用`Timer`项目按需执行一个函数。让我们一起来通过实现这种模式的过程。
- en: Time for action – Generating coins
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 生成硬币
- en: The goal of the game we are trying to implement is to collect coins. We will
    spawn coins now and then in random locations of the scene.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们试图实现的游戏的目的是收集硬币。我们现在将在场景的随机位置生成硬币。
- en: 'Create a new QML Document and call it `Coin.qml`. In the editor, enter the
    following code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的QML文档，并将其命名为`Coin.qml`。在编辑器中，输入以下代码：
- en: '[PRE29]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, open the document where the scene is defined and enter the following
    code somewhere in the scene definition:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开定义场景的文档，并在场景定义中某处输入以下代码：
- en: '[PRE30]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: What just happened?
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: First, we defined a new element type, `Coin`, consisting of a yellow circle
    with a number centered over an empty item. The rectangle has an animation applied
    that rotates the item around a vertical axis, resulting in a pseudo three-dimensional
    effect.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义了一个新的元素类型，`Coin`，它由一个黄色圆圈组成，圆圈中心有一个数字覆盖在空的项目上。矩形应用了一个动画，使项目围绕垂直轴旋转，从而产生一个伪三维效果。
- en: Next, a component able to create instances of a `Coin` element is placed in
    the scene. Then, a `Timer` element is declared that fires every second and spawns
    a new coin at a random location of the scene.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在场景中放置一个能够创建`Coin`元素实例的组件。然后，声明一个每秒触发一次的`Timer`元素，在场景的随机位置生成一个新的硬币。
- en: Sprite animation
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 精灵动画
- en: The player character as well as any other component of the game should be animated.
    If the component is implemented using simple Qt Quick shapes, it is quite easy
    to do by changing the item's properties fluently, using property animations (as
    we did with the `Coin` object). Things get more difficult if a component is complex
    enough that it is easier to draw it in a graphics program and use an image in
    the game instead of trying to recreate the object using Qt Quick items. Then,
    you need a number of images—one for every frame of animation. Images would have
    to keep replacing one another to make a convincing animation.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家角色以及游戏中的任何其他组件都应该具有动画效果。如果组件使用简单的Qt Quick形状实现，则通过流畅地更改项目属性并使用属性动画（就像我们对`Coin`对象所做的那样）来实现动画相当容易。如果组件足够复杂，以至于在图形程序中绘制它并使用游戏中的图像比尝试使用Qt
    Quick项目重新创建对象更容易，那么事情就会变得复杂。在这种情况下，你需要一系列图像——每帧动画一个。图像需要不断替换，以制作出令人信服的动画。
- en: Time for action – Implementing simple character animation
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施简单角色动画的时间
- en: Let's try to make the player character animated in a simple way. In the materials
    that come with this book, you will find a number of images with different walking
    phases for Benjamin the Elephant. You can use them, or you can draw or download
    some other images to be used in place of those provided by us.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试以简单的方式使玩家角色具有动画效果。在这本书附带的材料中，你会找到一些不同行走阶段的Benjamin大象的图像。你可以使用它们，或者你可以绘制或下载一些其他图像来替换我们提供的图像。
- en: Put all images in one directory (for example, `images`) and rename them so that
    they follow a pattern that contains the base animation name followed by a frame
    number, for example, `walking_01`, `walking_02`, `walking_03`, and so on.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有图像放在一个目录中（例如，`images`），并将它们重命名，以便它们遵循包含基本动画名称后跟帧编号的模式，例如，`walking_01`、`walking_02`、`walking_03`，依此类推。
- en: 'Next, open the `Player.qml` document and replace the image element showing
    `elephant.png` with the following code:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开`Player.qml`文档，并将显示`elephant.png`的图像元素替换为以下代码：
- en: '[PRE31]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the root element of `Player.qml`, add the following properties:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Player.qml`的根元素中添加以下属性：
- en: '[PRE32]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Start the program and use the arrow keys to see Benjamin move.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 启动程序并使用箭头键查看Benjamin移动。
- en: What just happened?
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: A number of images were prepared following a common naming pattern containing
    a number. All the images have the same size. This allows us to replace one image
    with another just by changing the value of the `source` property to point to a
    different image. To make it easier, we introduced a property called the `currentFrame` element
    that contains the index of the image to be displayed. We used the `currentFrame` element
    in a string, forming an expression bound to the `source` element of the image.
    To make substituting frames easy, a `NumberAnimation` element was declared to
    modify the values of the `currentFrame` element in a loop from `1` to the number
    of animation frames available (represented by the `frameCount` property) so that
    each frame is shown for 40 milliseconds.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 准备了一系列图像，遵循包含数字的常见命名模式。所有图像都具有相同的大小。这使得我们只需通过更改`source`属性的值来指向不同的图像，就可以替换一个图像。为了简化操作，我们引入了一个名为`currentFrame`的属性，它包含要显示的图像的索引。我们在字符串中使用了`currentFrame`元素，形成一个绑定到图像`source`元素的表达式。为了使帧替换更容易，我们声明了一个`NumberAnimation`元素，以循环方式修改`currentFrame`元素的值，从`1`到可用的动画帧数（由`frameCount`属性表示），以便每帧显示40毫秒。
- en: The animation is playing if the `walking` property evaluates to `true` (based
    on the value of the `flags.horizontal` element in the player object). Finally,
    we use the `mirror` property of the `Image` parameter to flip the image if the
    character is walking left.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`walking`属性评估为`true`（基于玩家对象中`flags.horizontal`元素的值），则动画正在播放。最后，我们使用`Image`参数的`mirror`属性，如果角色向左行走，则翻转图像。
- en: The preceding approach works, but it's not perfect. The complexity of the declaration
    following this pattern grows much faster than required when we want to make movement
    animation more complex (for example, if we want to introduce jumping). This is
    not the only problem, though. Loading images does not happen instantly. The first
    time a particular image is to be used, the animation can stall for a moment while
    the graphics get loaded, which may ruin the user experience. Lastly, it is simply
    messy to have a bunch of pictures here and there for every image animation.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法有效，但并不完美。当我们想要使移动动画更复杂时（例如，如果我们想要引入跳跃），遵循此模式的声明复杂性增长速度比所需的要快得多。但这并不是唯一的问题。加载图像并不立即发生。第一次使用某个特定图像时，动画可能会因为图形加载而暂停片刻，这可能会破坏用户体验。最后，对于每个图像动画，这里那里有一堆图片确实是杂乱无章的。
- en: A solution to this is to use a **sprite sheet**—a set of small images combined
    into a single larger image for better performance. Qt Quick supports sprite sheets
    through its sprite engine that handles loading sequences of sprites from a single
    image, animating them, and transitioning between different sprites.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是使用一个**精灵图**——将一组小图像组合成单个较大的图像，以提高性能。Qt Quick 通过其精灵引擎支持精灵图，该引擎负责从单个图像中加载精灵序列，对它们进行动画处理，并在不同的精灵之间进行转换。
- en: 'In Qt Quick, a sprite sheet can be an image of any type supported by Qt that
    contains an image strip with all frames of the animation. Subsequent frames should
    form a continuous line flowing from left to right and from the top to the bottom
    of the image. However, they do not have to start in the top-left corner of the
    containing image, nor do they have to end in its bottom-right corner—a single
    file can contain many sprites. A sprite is defined by providing the size of a
    single frame in pixels and a frame count. Optionally, you can specify an offset
    from the top-left corner where the first frame of the sprite is to be read from.
    The following diagram can be helpful in visualizing the scheme:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Qt Quick 中，精灵图可以是由 Qt 支持的任何类型的图像，其中包含动画的所有帧的图像条。后续帧应形成一个从左到右、从上到下流动的连续线条。然而，它们不必从包含图像的左上角开始，也不必在右下角结束——一个文件可以包含多个精灵。精灵是通过提供单个帧的大小（以像素为单位）和帧数来定义的。可选地，你可以指定一个偏移量，从该偏移量读取精灵的第一个帧。以下图表可以帮助可视化方案：
- en: '![](img/bed79f67-221f-4f3a-a5e2-c30fb7752839.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bed79f67-221f-4f3a-a5e2-c30fb7752839.png)'
- en: QML offers a `Sprite` element type with a `source` property pointing to the
    URL of the container image, the `frameWidth` and `frameHeight` properties determining
    the size of each frame, and a `frameCount` property defining the number of frames
    in the sprite. Offsetting the image can be achieved by setting values of the `frameX` and `frameY` 
    properties. In addition to this, some additional properties are present; the most
    important three are `frameRate`, `frameDuration,` and `duration`. All these serve
    to determine the pace of the animation. If the `frameRate` element is defined,
    it is interpreted as a number of frames to cycle through per second. If this property
    is not defined, then the  `frameDuration` element kicks in and is treated as a
    period of time in which to display a single frame (thus, it is directly an inverse
    of the `frameRate` element). If this property is not defined as well, the `duration` element
    is used, which carries the duration of the whole animation. You can set any of
    these three properties, but you don't need to set more than one of them.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: QML 提供了一个名为 `Sprite` 的元素类型，它有一个 `source` 属性，指向容器图像的 URL，`frameWidth` 和 `frameHeight`
    属性确定每个帧的大小，以及一个 `frameCount` 属性定义精灵中的帧数。可以通过设置 `frameX` 和 `frameY` 属性的值来实现图像的偏移。除此之外，还有一些额外的属性；最重要的三个是
    `frameRate`、`frameDuration` 和 `duration`。所有这些都有助于确定动画的节奏。如果定义了 `frameRate` 元素，它被解释为每秒循环的帧数。如果没有定义此属性，则
    `frameDuration` 元素生效，并被视为显示单个帧的时间段（因此，它是 `frameRate` 元素的直接倒数）。如果没有定义此属性，则使用 `duration`
    元素，它表示整个动画的持续时间。你可以设置这三个属性中的任何一个，但不需要设置超过一个。
- en: Time for action – Animating characters using sprites
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 使用精灵进行角色动画
- en: Let's wait no further. The task at hand is to replace the manual animation from
    the previous exercise with a sprite sheet animation.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们不再等待。当前的任务是将之前练习中的手动动画替换为精灵图动画。
- en: 'Open the `Player.qml` document, remove the whole image element responsible
    for displaying the player character, and add the following code:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`Player.qml`文档，删除负责显示玩家角色的整个图像元素，并添加以下代码：
- en: '[PRE33]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: What just happened?
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We replaced the previous static image with an ever-changing source with a different
    item. As the `Sprite` parameter is not an `Item` element but a data definition
    of a sprite, we cannot use it in place of the `Image` element. Instead, we will
    use the `AnimatedSprite` element, which is an item that can display a single animated
    sprite defined inline. It even has the same set of properties as the `Sprite` parameter.
    We defined a sprite embedded in `images/sprite.png` with a width of `80` and a
    height of `52` pixels. The sprite consists of seven frames that should be displayed
    at a rate of 10 frames per second. The  `running`
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用不断变化的不同项替换了之前的静态图像。由于`Sprite`参数不是一个`Item`元素，而是一个精灵的数据定义，我们无法用它替换`Image`元素。相反，我们将使用`AnimatedSprite`元素，这是一个可以显示单帧动画精灵的项，它甚至具有与`Sprite`参数相同的属性集。我们在`images/sprite.png`中定义了一个精灵，宽度为`80`像素，高度为`52`像素。该精灵由七个帧组成，应以每秒10帧的速度显示。`running`
- en: property is set up similar to the original `Animation` element. As the  `AnimatedSprite`
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 属性的设置与原始的`Animation`元素类似。作为`AnimatedSprite`，
- en: element does not have a `mirror` property, we emulate it by applying a scale
    transformation that flips the item horizontally if the `player.facingLeft`  expression
    evaluates to `true`. Additionally, we set the `interpolate` property to  `true`,
    which makes the sprite engine calculate smoother transitions between frames.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 元素没有`mirror`属性，我们通过应用一个翻转项水平方向的缩放变换来模拟它，如果`player.facingLeft`表达式评估为`true`。此外，我们设置`interpolate`属性为`true`，这使得精灵引擎在帧之间计算更平滑的过渡。
- en: The result we are left with is similar to an earlier attempt, so if these two
    are similar, why bother using sprites? In many situations, you want more complex
    animation than just a single-frame sequence. What if we want to animate the way
    Benjamin jumps in addition to walking? Embedding more manual animations, although
    possible, would explode the number of internal variables required to keep the
    state of the object. Fortunately, the Qt Quick sprite engine can deal with that.
    The `AnimatedSprite` element we used provides a subset of features of the whole
    framework. By substituting the item with the `SpriteSequence` element, we gain
    access to the full power of sprites. Whilst we're on the subject of `Sprite`,
    we need to tell you about one additional property of the object, a property called `to` that
    contains a map of probabilities of transitioning from the current sprite to another
    one. By stating which sprites the current one migrates to, we create a state machine
    with weighted transitions to other sprites as well as cycling back to the current
    state.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们留下的结果与早期的尝试相似，所以如果这两个相似，为什么还要使用精灵呢？在许多情况下，你想要的动画比单帧序列更复杂。如果我们想除了走路外还要动画化本杰明的跳跃方式怎么办？嵌入更多的手动动画虽然可能，但会爆炸增加保持对象状态所需的内部变量数量。幸运的是，Qt
    Quick精灵引擎可以处理这种情况。我们使用的`AnimatedSprite`元素提供了整个框架的一部分功能。通过用`SpriteSequence`元素替换项目，我们获得了精灵的全部功能。当我们谈论`Sprite`时，我们需要告诉你该对象的一个附加属性，即名为`to`的属性，它包含从当前精灵到另一个精灵的转换概率映射。通过声明当前精灵迁移到的精灵，我们创建了一个具有加权转换到其他精灵以及循环回当前状态的有限状态机。
- en: Transitioning to another sprite is triggered by setting the `goalSprite` property
    on the `SpriteSequence` object. This will cause the sprite engine to traverse
    the graph until it reaches the requested state. It is a great way to fluently
    switch from one animation to another by going through a number of intermediate
    states.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到另一个精灵是通过在`SpriteSequence`对象上设置`goalSprite`属性来触发的。这将导致精灵引擎遍历图直到达到请求的状态。通过经过多个中间状态，这是一种流畅地从一种动画切换到另一种动画的绝佳方式。
- en: Instead of asking the sprite machine to gracefully transit to a given state,
    you can ask it to force an immediate change by calling the `SpriteSequence` class's `jumpTo()` method
    and feeding it the name of the sprite that should start playing.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以不要求精灵机优雅地过渡到给定状态，而是可以通过调用`SpriteSequence`类的`jumpTo()`方法并传入应开始播放的精灵名称来强制立即更改。
- en: The last thing that needs to be clarified is how to actually attach the sprite
    state machine to the `SpriteSequence` class. It is very easy—just assign an array
    of the `Sprite` objects to the `sprites` property.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 需要澄清的最后一件事是如何将精灵状态机实际附加到`SpriteSequence`类。这非常简单——只需将一个`Sprite`对象的数组分配给`sprites`属性。
- en: Time for action – Adding jumping with sprite transitions
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——添加带有精灵过渡的跳跃
- en: Let's replace the `AnimatedSprite` class with the `SpriteSequence` class in
    the Bejamin the Elephant animation, adding a sprite to be played during the jumping
    phase.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在本杰明大象动画中将`AnimatedSprite`类替换为`SpriteSequence`类，为跳跃阶段添加一个要播放的精灵。
- en: 'Open the `Player.qml` file and replace the `AnimatedSprite` object with the
    following code:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`Player.qml`文件，将`AnimatedSprite`对象替换为以下代码：
- en: '[PRE34]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, extend the `jumpAnim` object by adding the highlighted changes:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过添加高亮显示的更改来扩展`jumpAnim`对象：
- en: '[PRE35]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: What just happened?
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: 'The `SpriteSequence` element we have introduced has its `Item` elements-related
    properties set up in the same way as the `AnimatedSprite` element. Apart from
    that, a sprite called "still" was explicitly set as the current one. We defined
    a number of `Sprite` objects as children of the `SpriteSequence` element. This
    is equivalent to assigning those sprites to the `sprites` property of the object.
    The complete state machine that was declared is presented in the following diagram:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们引入的`SpriteSequence`元素具有与`AnimatedSprite`元素相同的`Item`元素相关属性设置。除此之外，一个名为“静止”的精灵被明确设置为当前精灵。我们定义了多个`Sprite`对象作为`SpriteSequence`元素的子元素。这相当于将这些精灵分配给对象的`sprites`属性。以下图表展示了声明的完整状态机：
- en: '![](img/0a13e4c4-79a2-4640-90a6-dc3eb6a47665.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0a13e4c4-79a2-4640-90a6-dc3eb6a47665.png)'
- en: A sprite called "still" has just a single frame representing a situation when
    Benjamin doesn't move. The sprite keeps spinning in the same state due to the
    weighted transition back to the "still" state. The two remaining transitions from
    that state have their weights set to `0`, which means they will never trigger
    spontaneously, but they can be invoked by setting the `goalSprite` property to
    a sprite that can be reached by activating one of those transitions.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为“静止”的精灵只有一个表示本杰明不动的帧。由于加权转换回“静止”状态，精灵保持在该状态下旋转。从该状态剩余的两个转换具有其权重设置为`0`，这意味着它们永远不会自发触发，但可以通过将`goalSprite`属性设置为可以通过激活这些转换之一到达的精灵来调用。
- en: The sequential animation was extended to trigger sprite changes when the elephant
    lifts into the air.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 连续动画被扩展，当大象升空时触发精灵变化。
- en: Have a go hero – Making Benjamin wiggle his tail in anticipation
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试一下英雄——让本杰明在期待中摇尾巴
- en: To practice sprite transitions, your goal is to extend the state machine of
    Benjamin's `SpriteSequence` element to make him wiggle his tail when the elephant
    is standing still. You can find the appropriate sprite in the materials that come
    included with this book. The sprite field is called `wiggling.png`. Implement
    the functionality by making it probable that Benjamin spontaneously goes from
    the "still" state to "wiggling". Pay attention to ensure that the animal stops
    wiggling and starts walking the moment the player activates the right or left
    arrow keys.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 为了练习精灵过渡，你的目标是扩展本杰明的`SpriteSequence`元素的州机，使他当大象站立时摇尾巴。你可以在本书附带的材料中找到合适的精灵。精灵字段称为`wiggling.png`。通过使其从“静止”状态到“摇尾巴”状态的概率性转换来实现此功能。注意确保动物在玩家激活左右箭头键时停止摇尾巴并开始行走。
- en: Time for action – Revisiting parallax scrolling
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——回顾视差滚动
- en: We already discussed the useful technique of parallax scrolling in [Chapter
    6](ad89bd0a-2ed2-49a8-8701-18449629a1ee.xhtml), *Qt Core Essentials*. It gives
    the impression of depth for 2D games by moving multiple layers of background at
    a different speed depending on the assumed distance of the layer from the viewer.
    Let's see how easy it is to apply the same technique in Qt Quick.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第6章](ad89bd0a-2ed2-49a8-8701-18449629a1ee.xhtml)中讨论了有用的视差滚动技术，*Qt核心基础*。它通过根据层与观察者的假设距离以不同速度移动多个背景层，为2D游戏提供了深度感。让我们看看在Qt
    Quick中应用相同技术有多容易。
- en: We will implement parallax scrolling with a set of layers that move in the direction
    opposite to the one the player is moving in. Therefore, we will need a definition
    of the scene and a moving layer.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一组移动方向与玩家移动方向相反的层来实现视差滚动。因此，我们需要定义场景和移动层。
- en: 'Create a new QML File (Qt Quick 2). Call it `ParallaxScene.qml`. The scene
    will encompass the whole game "level" and will expose the position of the player
    to the moving layers. Put the following code in the file:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的QML文件（Qt Quick 2）。将其命名为`ParallaxScene.qml`。场景将包括整个游戏“关卡”，并将玩家的位置暴露给移动层。在文件中放入以下代码：
- en: '[PRE36]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, create another QML file and call it `ParallaxLayer.qml`. Make it contain
    the following definition:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建另一个QML文件，并将其命名为`ParallaxLayer.qml`。让它包含以下定义：
- en: '[PRE37]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, let''s use the two new element types in the main QML document. We''ll
    take elements from the earlier scene definition and make them into different parallax
    layers—the sky, the trees, and the grass:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在主QML文档中使用这两种新的元素类型。我们将从早期的场景定义中提取元素，并将它们制作成不同的视差层——天空、树木和草地：
- en: '[PRE38]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You can now run the game and observe the movement of background layers when
    the player moves around:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以运行游戏，并观察当玩家移动时背景层的运动：
- en: '![](img/9fcfb42b-0234-4492-b97b-79ad5f7f5ec9.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9fcfb42b-0234-4492-b97b-79ad5f7f5ec9.png)'
- en: What just happened?
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: The `ParallaxScene` element we implemented is a moving plane. Its horizontal
    offset depends on the character's current position and the size of the view. The
    range of scroll of the scene is determined by the difference between the scene
    size and the view size—it says how much scrolling we have to do when the character
    moves from the left edge to the right edge of the scene so that it is in view
    all the time. If we multiply that by the distance of the character from the left
    edge of the scene expressed as a fraction of the scene width, we will get the
    needed scene offset in the view (or otherwise speaking, a projection offset of
    the scene).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现的`ParallaxScene`元素是一个移动的平面。其水平偏移量取决于角色的当前位置和视图的大小。场景滚动的范围由场景大小和视图大小的差值决定——它说明了当角色从场景的左侧移动到右侧边缘时，我们需要滚动多少，以便它始终在视图中。如果我们用场景宽度作为分数表示的角色与场景左侧边缘的距离乘以这个值，我们就会得到视图中所需要的场景偏移量（或者换句话说，场景的投影偏移量）。
- en: The second type—`ParallaxLayer`—is also a moving plane. It defines a distance
    factor that represents the relative distance (depth) of the layer behind the foreground,
    which influences how fast the plane should be scrolled compared to the foreground
    (scene). The value of `0` means that the layer should be moving with exactly the
    same speed as the foreground layer. The larger the value, the slower the layer
    moves as compared to the character. The offset value is calculated by dividing
    the character's position in the scene by the factor. Since the foreground layer
    is also moving, we have to take it into consideration when calculating the offset
    for each parallax layer. Thus, we subtract the horizontal position of the scene
    to get the actual layer offset.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种类型——`ParallaxLayer`——也是一个移动的平面。它定义了一个距离因子，表示背景层相对于前景（场景）的相对距离（深度），这影响了平面相对于前景（场景）滚动的速度。`0`的值意味着层应该以与前景层完全相同的速度移动。值越大，层相对于角色的移动速度越慢。偏移值是通过将场景中角色的位置除以因子来计算的。由于前景层也在移动，我们必须在计算每个视差层的偏移量时考虑它。因此，我们从场景的水平位置中减去以获得实际的层偏移量。
- en: Having the layers logically defined, we can add them to the scene. Each layer
    has a physical representation in our case, static images containing textures of
    the sky, trees, and grass. Each layer is defined separately and can live its own
    life, containing static and animated elements that have no influence on remaining
    layers. For example, we put the sun object into the sky layer, so it will move
    along with the sky layer in addition to playing its own animations.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在逻辑上定义了层之后，我们可以将它们添加到场景中。在我们的例子中，每个层都有一个物理表示，包含天空、树木和草地纹理的静态图像。每个层都是单独定义的，可以独立存在，包含静态和动画元素，这些元素对其他层没有影响。例如，我们将太阳对象放入天空层，这样它除了播放自己的动画外，还会随着天空层移动。
- en: Finally, since we no longer have the `root` element, we modified the `coinTimer`
    handler to use the `scene` element instead.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于我们不再有`root`元素，我们修改了`coinTimer`处理程序，以使用`scene`元素代替。
- en: Have a go hero – Vertical parallax sliding
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试一下英雄垂直视差滑动
- en: As an additional exercise, you may want to implement a vertical parallax sliding
    in addition to a horizontal one. Just make your scene bigger and have it expose
    the vertical scroll position in addition to the horizontal one reported by the `currentPos` element.
    Then, just repeat all the calculations for the `y` property of each layer and
    you should be done in no time. Remember that distance factors for `x` and `y` may
    be different.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外的练习，你可能还想实现垂直视差滑动，除了水平滑动。只需让场景更大，并使其除了报告`currentPos`元素的水平滚动位置外，还暴露垂直滚动位置。然后，只需重复对每一层的`y`属性的所有计算，你很快就能完成。记住，`x`和`y`的距离因子可能不同。
- en: Collision detection
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞检测
- en: There is no built-in support for collision detection in Qt Quick, but there
    are three ways of providing such support. First, you can use a ready collision
    system available in a number of 2D physics engines such as Box2D. Secondly, you
    can implement a simple collision system yourself in C++. Lastly, you can do collision
    checking directly in JavaScript by comparing object coordinates and bounding boxes.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick中没有内置的碰撞检测支持，但有三种提供此类支持的方法。首先，你可以使用Box2D等许多2D物理引擎中可用的现成碰撞系统。其次，你可以自己用C++实现一个简单的碰撞系统。最后，你可以通过比较对象坐标和边界框直接在JavaScript中进行碰撞检测。
- en: Our game is very simple; therefore, we will use the last approach. If we had
    a larger number of moving objects involved in our game, we would probably choose
    the second approach. The first approach is best if you have an object of non-rectangular
    shapes that can rotate and bounce off other objects. In this case, having a physics
    engine at hand becomes really useful.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏非常简单；因此，我们将使用最后一种方法。如果我们游戏中涉及更多的移动对象，我们可能会选择第二种方法。如果你有一个可以旋转并从其他对象反弹的非矩形对象，第一种方法是最好的。在这种情况下，有一个物理引擎在手变得非常有用。
- en: Time for action – Collecting coins
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 收集硬币
- en: 'From Qt Creator''s menu, access File — New File or Project. From Qt category,
    choose the JS File template. Call the `collisions.js` file. Put the following
    content into the document:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 从Qt Creator的菜单中，访问文件 - 新文件或项目。从Qt类别中选择JS文件模板。将文件命名为`collisions.js`。将以下内容放入文档中：
- en: '[PRE39]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Create another JS File and call it `coins.js`. Enter the following:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 创建另一个JS文件，并将其命名为`coins.js`。输入以下内容：
- en: '[PRE40]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, open the `main.qml` file and add the following `import` statement:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，打开`main.qml`文件，并添加以下`import`语句：
- en: '[PRE41]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the player object, define the `checkCollisions()` function:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在玩家对象中，定义`checkCollisions()`函数：
- en: '[PRE42]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, modify the `coinTimer` handler to push new coins to the list:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，修改`coinTimer`处理程序，将新的硬币推送到列表中：
- en: '[PRE43]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Lastly, in the same player object, trigger collision detection by handling
    the position changes of the player:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在同一个玩家对象中，通过处理玩家位置的变化来触发碰撞检测：
- en: '[PRE44]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In the `Coin.qml` file, define an animation and a `hit()` function:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Coin.qml`文件中，定义一个动画和一个`hit()`函数：
- en: '[PRE45]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: What just happened?
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: The `collisions.js` file contains functions used to do collision checking. The
    first line of the file is a `.pragma library` statement, noting that this document
    only contains functions and does not contain any mutable object. This statement
    marks the document as a library that can be shared between documents that import
    it. This aids in reduced memory consumption and improved speed, as the engine
    doesn't have to reparse and execute the document each time it is imported.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`collisions.js`文件包含用于进行碰撞检测的函数。文件的第一行是一个`.pragma library`语句，指出该文档只包含函数，不包含任何可变对象。此语句将文档标记为库，可以在导入它的文档之间共享。这有助于减少内存消耗并提高速度，因为引擎不需要在每次导入时重新解析和执行文档。'
- en: The functions defined in the library are really simple. The first one returns
    a bounding rectangle of an object based on its coordinates and the size of its
    children. It assumes that the top-level item is empty and contains children that
    represent the visual aspect of the object. Children coordinates are mapped using
    the `mapToItem` function so that the rectangle returned is expressed in the parent
    item coordinates. The second function does a trivial checking of intersection
    between two bounding rectangles and returns `true` if they intersect and `false` otherwise.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 库中定义的函数非常简单。第一个函数根据对象的坐标和子项的大小返回对象的边界矩形。它假设顶级项为空，并包含代表对象视觉方面的子项。子项坐标使用`mapToItem`函数进行映射，以便返回的矩形以父项坐标表示。第二个函数对两个边界矩形进行简单的交集检查，如果它们相交则返回`true`，否则返回`false`。
- en: The second document keeps a definition of an array of coins. It adds two methods
    to the array object. The first one—`collisionsWith`—performs a collision check
    between any of the items in the array and the given object using functions defined
    in `collisions.js`. That's why we import the library at the start of the document.
    The method returns another array that contains objects intersecting the `player` argument.
    The other method, called `remove`, takes an object or an array of objects and
    removes them from `coins`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个文档保存了一个硬币数组的定义。它向数组对象添加了两个方法。第一个方法——`collisionsWith`——使用在`collisions.js`中定义的函数在数组中的任何项目与给定对象之间执行碰撞检查。这就是为什么我们在文档开头导入库的原因。该方法返回另一个包含与`player`参数相交的对象的数组。另一个方法，称为`remove`，接受一个对象或对象数组，并将它们从`coins`中移除。
- en: The document is not a library; therefore, each document that imports `coins.js` would
    get its own separate copy of the object. Thus, we need to ensure that `coins.js` is
    imported only once in the game so that all references to the objects defined in
    that document relate to the same instance of the object in our program memory.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 该文档不是一个库；因此，每个导入`coins.js`的文档都会得到该对象的独立副本。因此，我们需要确保在游戏中只导入一次`coins.js`，以便该文档中定义的对象的所有引用都与程序内存中对象的同一实例相关。
- en: Our main document imports `coins.js`, which creates the array for storing coin
    objects and makes its auxiliary functions available. This allows the defined 
    `checkCollisions()`  function to retrieve the list of coins colliding with the
    player. For each coin that collides with the player, we execute a `hit()` method;
    as a last step, all colliding coins are removed from the array. Since coins are
    stationary; collision can only occur when the player character enters an area
    occupied by a coin. Therefore, it is enough to trigger collision detection when
    the position of the player character changes—we use the  `onXChanged`  and `onYChanged`
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主要文档导入`coins.js`，它创建用于存储硬币对象的数组，并使其辅助函数可用。这使得定义的`checkCollisions()`函数能够检索与玩家碰撞的硬币列表。对于每个与玩家碰撞的硬币，我们执行一个`hit()`方法；作为最后一步，所有碰撞的硬币都被从数组中移除。由于硬币是静止的；碰撞只能在玩家角色进入硬币占据的区域时发生。因此，当玩家角色的位置改变时触发碰撞检测就足够了——我们使用`onXChanged`和`onYChanged`
- en: handlers.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 处理程序。
- en: As hitting a coin results in removing it from the array, we lose a reference
    to the object. The `hit()` method has to initiate removal of the object from the
    scene. A minimalistic implementation of this function would be to just call the `destroy()` function
    on the object, but we do more—the removal can be made smoother by running a fade-out
    animation on the coin. As a last step, the animation can destroy the object.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 由于击中硬币会导致从数组中移除它，我们失去了对该对象的引用。`hit()`方法必须启动从场景中移除对象的过程。这个函数的最小化实现可能只是调用对象的`destroy()`函数，但我们做得更多——通过在硬币上运行淡出动画可以使移除过程更加平滑。作为最后一步，动画可以销毁对象。
- en: The number of objects we track on the scene is really small, and we simplify
    the shape of each object to a rectangle. This lets us get away with checking collisions
    in JavaScript. For a larger amount of moving objects, custom shapes, and handling
    rotations, it is much better to have a collision system based on C++. The level
    of complexity of such a system depends on your needs.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在场景中跟踪的对象数量非常小，我们将每个对象的形状简化为矩形。这使得我们可以通过JavaScript进行检查碰撞。对于大量移动对象、自定义形状和旋转处理，基于C++的碰撞系统会更好。这种系统的复杂程度取决于您的需求。
- en: Have a go hero – Extending the game
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试一下英雄 - 扩展游戏
- en: You can polish your game development skills by implementing new game mechanics
    in our jumping elephant game. For example, you can introduce a concept of fatigue.
    The more the character jumps, the more tired they get and the slower they begin
    to move and have to rest to regain speed. To make the game more difficult, at
    times moving obstacles can be generated. When the character bumps into any of
    them, they get more and more tired. When the fatigue exceeds a certain level,
    the character dies and the game ends. The heartbeat diagram we previously created
    can be used to represent the character's level of fatigue—the more tired the character
    gets, the faster their heart beats.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在我们的跳跃大象游戏中实现新的游戏机制来磨练您的游戏开发技能。例如，您可以引入疲劳的概念。角色跳得越多，就越累，它们开始移动的速度就越慢，并且需要休息以恢复速度。为了使游戏更具挑战性，有时可以生成移动障碍。当角色撞到任何一个障碍时，它们就会变得越来越累。当疲劳超过一定水平时，角色就会死亡，游戏结束。我们之前创建的心率图可以用来表示角色的疲劳程度——角色越累，心率就越快。
- en: There are many ways these changes can be implemented, and we want to give you
    a level of freedom, so we will not provide a step-by-step guide on how to implement
    a complete game. You already know a lot about Qt Quick, and this is a good opportunity
    to test your skills!
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变化可以通过许多方式实现，我们希望给您一定的自由度，因此我们不会提供如何实现完整游戏的逐步指南。您已经对 Qt Quick 了解很多，这是一个测试您技能的好机会！
- en: Pop quiz
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速问答
- en: Q1\. Which of the following types cannot be used with the special on-property
    syntax?
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. 以下哪种类型不能与特殊的属性语法一起使用？
- en: '`Animation`'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Animation`'
- en: '`Transition`'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Transition`'
- en: '`Behavior`'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Behavior`'
- en: Q2\. Which QML type allows you to configure a sprite animation with transitions
    between multiple states?
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: Q2. 哪种 QML 类型允许您配置具有多个状态之间转换的精灵动画？
- en: '`SpriteSequence`'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SpriteSequence`'
- en: '`Image`'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Image`'
- en: '`AnimatedSprite`'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AnimatedSprite`'
- en: Q3\. Which QML type is able to prevent any instant change of the property's
    value and perform a gradual change of value instead?
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: Q3. 哪种 QML 类型能够防止属性值的即时更改，并执行值的逐渐更改？
- en: '`Timer`'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Timer`'
- en: '`Behavior`'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Behavior`'
- en: '`PropertyAction`'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PropertyAction`'
- en: Summary
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we showed you how to extend your Qt Quick skills to make your
    applications dynamic and attractive. We went through the process of recreating
    and improving a game created earlier in C++ to familiarize you with concepts such
    as collision detection, state-driven objects, and time-based game loops. You are
    now familiar with all the most important concepts required to make games using
    Qt Quick.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们向您展示了如何扩展您的 Qt Quick 技能，使您的应用程序动态且吸引人。我们回顾了将之前用 C++ 创建的游戏重新创建和改进的过程，以便您熟悉碰撞检测、状态驱动对象和时间驱动的游戏循环等概念。您现在已经熟悉了使用
    Qt Quick 制作游戏所需的所有最重要的概念。
- en: In the next chapter, we will turn our attention to techniques that will make
    your games even more visually appealing. We'll explore the built-in graphical
    effects Qt Quick provides. You will also learn to extend Qt Quick with custom
    painted items implemented in C++. This will give you the freedom to create any
    visual effects you have in mind.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将关注使您的游戏更具视觉吸引力的技术。我们将探索 Qt Quick 提供的内置图形效果。您还将学习如何通过在 C++ 中实现的自定义绘制项来扩展
    Qt Quick。这将使您能够创建任何您想象中的视觉效果。
