- en: Using Noise in Shaders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a noise texture using GLM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a seamless noise texture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a cloud-like effect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a wood-grain effect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a disintegration effect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a paint-spatter effect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a rusted metal effect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a night-vision effect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's easy to use shaders to create a smooth-looking surface, but that is not
    always the desired goal. If we want to create realistic-looking objects, we need
    to simulate the imperfections of real surfaces. That includes things such as scratches,
    rust, dents, and erosion. It is somewhat surprising how challenging it can be
    to make surfaces look like they have really been subjected to these natural processes.
    Similarly, we sometimes want to represent natural surfaces such as wood grain
    or natural phenomena such as clouds to be as realistic as possible without giving
    the impression of them being synthetic or exhibiting a repetitive pattern or structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most effects or patterns in nature exhibit a certain degree of randomness and
    non-linearity. Therefore, you might imagine that we could generate them by simply
    using random data. However, random data such as the kind that is generated from
    a pseudo-random number generator is not very useful in computer graphics. There
    are two main reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need data that is repeatable, so that the object will render in the
    same way during each frame of the animation. (We could achieve this by using an
    appropriate seed value for each frame, but that only solves half of the problem.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, in order to model most of these natural phenomena, we actually need
    data that is continuous, but still gives the appearance of randomness. Continuous
    data more accurately represents many of these natural materials and phenomena.
    Purely random data does not have this continuity property. Each value has no dependence
    on the previous value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Thanks to the groundbreaking work of Ken Perlin, we have the concept of **noise**
    (as it applies to computer graphics). His work defined noise as a function that
    has certain qualities such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It is a continuous function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is repeatable (generates the same output from the same input)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be defined for any number of dimensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It does not have any regular patterns and gives the appearance of randomness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Such a noise function is a valuable tool for computer graphics and it can be
    used to create an endless array of interesting effects. For instance, in this
    chapter, we'll use noise to create clouds, wood, disintegration, and other effects.
  prefs: []
  type: TYPE_NORMAL
- en: '**Perlin ****noise** is the noise function originally defined by Ken Perlin
    (see [http://mrl.nyu.edu/~perlin/doc/oscar.html](http://mrl.nyu.edu/~perlin/doc/oscar.html)).
    A full discussion of the details behind Perlin noise is outside the scope of this
    book.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use Perlin noise within a shader, we have the following three main choices:'
  prefs: []
  type: TYPE_NORMAL
- en: We can use the built-in GLSL noise functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can create our own GLSL noise functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use a texture map to store pre-computed noise data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the time of writing this book, the GLSL noise functions are not implemented
    in some of the commercial OpenGL drivers, and therefore cannot be relied upon
    to be available, so I have decided not to use them in this chapter. As creating
    our own noise functions is a bit beyond the scope of this book, and because choice
    three in the preceding list gives the best performance on modern hardware, the
    recipes in this chapter will use the third approach (using a pre-computed noise
    texture).
  prefs: []
  type: TYPE_NORMAL
- en: Many books use a 3D noise texture rather than a 2D one, to provide another dimension
    of noise that is available to the shaders. To keep things simple, and to focus
    on using surface texture coordinates, I've chosen to use a 2D noise texture in
    the recipes within this chapter. If desired, it should be straightforward to extend
    these recipes to use a 3D source of noise.
  prefs: []
  type: TYPE_NORMAL
- en: We'll start out with two recipes that demonstrate how to generate a noise texture
    using GLM. Then, we'll move on to several examples that use noise textures to
    produce natural and artificial effects such as wood grain, clouds, electrical
    interference, splattering, and erosion.
  prefs: []
  type: TYPE_NORMAL
- en: The recipes in this chapter are meant to be a starting point for you to experiment
    with. They are certainly not intended to be the definitive way of implementing
    any of these effects. One
  prefs: []
  type: TYPE_NORMAL
- en: of the best things about computer graphics is the element of creativity. Try
    tweaking the shaders in these recipes to produce similar results and then try
    creating your own effects. Most of all, have fun!
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to the the book *Texturing and Modeling: A Procedural Approach*, by Ken
    Musgrave et al., for more information on the topic.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a noise texture using GLM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create a texture for use as a source of noise, we need some way to generate
    noise values. Implementing a proper noise generator from scratch can be a fairly
    daunting task. Luckily, GLM provides some functions for noise generation that
    are straightforward and easy to use.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll use GLM to generate a 2D texture of noise values created
    using a **Perlin ****noise** generator. GLM can generate 2D, 3D, and 4D Perlin
    noise via the `glm::perlin` function.
  prefs: []
  type: TYPE_NORMAL
- en: It is a common practice to use Perlin noise by summing the values of the noise
    function with increasing frequencies and decreasing amplitudes. Each frequency
    is commonly referred to as an **octave** (double the frequency). For example,
    in the following image, we show the results of the 2D Perlin noise function sampled
    at four different octaves. The sampling frequencies increase from left to right.
  prefs: []
  type: TYPE_NORMAL
- en: 'The leftmost image in the following image is the function sampled at our base
    frequency, and each image to the right shows the function sampled at twice the
    frequency of the one to its left:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/542e5eee-8f2c-4118-a67e-1b00df85a67d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In mathematical terms, if our coherent 2D Perlin noise function is *P(x, y)*,
    then each previous image represents the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cccbbb5d-cded-4734-9220-a2a1afeaba44.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, *i* = 0, 1, 2, and 3 from left to right.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned previously, the common practice is to sum octaves together to
    get the final result. We add each octave to the previous equation, scaling the
    amplitude down by some factor. So, for *N* octaves, we have the following sum:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4e6eb96d-6c33-4855-8aad-34049d09cfcf.png)'
  prefs: []
  type: TYPE_IMG
- en: '*a* and *b* are tuneable constants. The following image shows the sum of 2,
    3, and 4 octaves (left to right) with *a* = 1 and *b* = 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f018bd99-aff3-460d-8ffc-ebd57b5af090.png)'
  prefs: []
  type: TYPE_IMG
- en: Summed noise involving higher octaves will have more high-frequency variation
    than noise involving only lower octaves. However, it is possible to quickly reach
    frequencies that exceed the resolution of the buffer used to store the noise data,
    so care must be taken not to do unnecessary computation.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, it is both an art and a science. The previous equation can be used
    as a starting point; feel free to tweak it until you get the desired effect.
  prefs: []
  type: TYPE_NORMAL
- en: We'll store four noise values in a single 2D texture. We'll store Perlin noise
    with one octave in the first component (red channel), two octaves in the green
    channel, three octaves in the blue channel, and four octaves in the alpha channel.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Make sure that you have the GLM library installed and placed in the include
    path.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a 2D noise texture with GLM, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Include the GLM header that includes the noise functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Generate the noise data using the previous equation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Load the data into an OpenGL texture:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The GLM library provides 2D, 3D, and 4D coherent noise via the `glm::perlin`
    function. It returns a float roughly between -1 and 1\. We start by allocating
    a buffer named `data` to hold the generated noise values.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we loop over each texel and compute the `x` and `y` coordinates (normalized).
    Then, we loop over octaves. Here, we compute the sum of the previous equation,
    storing the first term in the first component, the first two terms in the second,
    and so on. The value is scaled into the range from 0 to 1, then multiplied by
    255 and cast to a byte.
  prefs: []
  type: TYPE_NORMAL
- en: The next few lines of code should be familiar. Texture memory is allocated with
    `glTexStorage2D` and the data is loaded into GPU memory using `glTexSubImage2D`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the array named `data` is deleted, as it is no longer needed.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rather than using unsigned byte values, we could get more resolution in our
    noise data by using a floating-point texture. This might provide better results
    if the effect needs a high degree of fine detail. The preceding code needs relatively
    few changes to achieve this. Just use an internal format of `GL_RGBA32F` instead
    of `GL_RGBA`, use the `GL_FLOAT` type, and don't multiply by 255 when storing
    the noise values in the array.
  prefs: []
  type: TYPE_NORMAL
- en: GLM also provides periodic Perlin noise via an overload of the `glm::perlin`
    function. This makes it easy to create noise textures that tile without seams.
    We'll see how to use this in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `chapter09/noisetex.cpp` file in the example code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For general information about coherent noise, take a look at the book *Graphics **Shaders* by
    Mike Bailey and Steve Cunningham
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Applying **a 2D texture* recipe in [Chapter 5](a5d0db76-6dbb-470d-8685-42ab8ae077b1.xhtml), *Using
    Textures*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a seamless noise texture* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a seamless noise texture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It can be particularly useful to have a noise texture that tiles well. If we
    simply create a noise texture as a finite slice of noise values, then the values
    will not wrap smoothly across the boundaries of the texture. This can cause hard
    edges (seams) to appear in the rendered surface if the texture coordinates extend
    outside of the range of zero to one.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, GLM provides a periodic variant of Perlin noise that can be used
    to create a seamless noise texture.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows an example of regular (left) and periodic (right)
    four-octave Perlin noise. Note that in the left image, the seams are clearly visible,
    while they are hidden in the right image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7be4a130-dfa7-4a19-9a47-198d3b3d780b.png)'
  prefs: []
  type: TYPE_IMG
- en: In this example, we'll modify the code from the previous recipe to produce a
    seamless noise texture.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we'll start with the code from the previous *Creating a noise
    texture using GLM* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modify the code from the previous recipe in the following way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the innermost loop, instead of calling `glm::perlin`, we''ll instead
    call the overload that provides periodic Perlin noise. You will need to replace
    the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace it with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The second parameter to `glm::perlin` determines the period in `x` and `y` of
    the noise values. We use `freq` as the period because we are sampling the noise
    in the range from `0` to `freq` for each octave.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `chapter09/noisetex.cpp` file in the example code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a noise texture using GLM* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a cloud-like effect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create a texture that resembles a sky with clouds, we can use the noise values
    as a blending factor between the sky color and the cloud color. As clouds usually
    have large-scale structure, it makes sense to use low-octave noise. However, the
    large-scale structure often has higher frequency variations, so some contribution
    from higher octave noise may be desired.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows an example of clouds generated by the technique in
    this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/585061c8-f96f-4a78-aeb1-e95f212df5de.png)'
  prefs: []
  type: TYPE_IMG
- en: To create this effect, we take the cosine of the noise value and use the result
    as the blending factor between the cloud color.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Set up your program to generate a seamless noise texture and make it available
    to the shaders through the `NoiseTex` uniform sampler variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two uniforms in the fragment shader that can be assigned from the
    OpenGL program:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SkyColor`: The background sky color'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CloudColor`: The color of the clouds'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To build a shader program that uses a noise texture to create a cloud-like
    effect, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up your vertex shader to pass the texture coordinates to the fragment shader
    via the `TexCoord` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the following code for the fragment shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We start by retrieving the noise value from the noise texture (the `noise` variable).
    The green channel contains two octave noises, so we use the value stored in that
    channel (`noise.g`). Feel free to try out other channels and determine what looks
    right to you.
  prefs: []
  type: TYPE_NORMAL
- en: We use a cosine function to make a sharper transition between the cloud and
    sky color. The noise value will be between zero and one, and the cosine of that
    value will range between -1 and 1, so we add 1.0 and divide by 2.0\. The result
    that is stored in `t` should again range between zero and one. Without this cosine
    transformation, the clouds look a bit too spread out over the sky. However, if
    that is the desired effect, one could remove the cosine and just use the noise
    value directly.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we mix the sky color and the cloud color using the value of `t`. The result
    is used as the final output fragment color.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you desire less clouds and more sky, you could translate and clamp the value
    of `t` prior to using it to mix the cloud and sky colors. For example, you could
    use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This causes the cosine term to shift down (toward negative values), and the
    `clamp` function sets all negative values to zero. This has the effect of increasing
    the amount of sky and decreasing the size and intensity of the clouds.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `chapter09/scenesky.cpp` file in the example code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Further reading on cloud generation: [http://vterrain.org/Atmosphere/Clouds/](http://vterrain.org/Atmosphere/Clouds/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a seamless noise texture* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a wood-grain effect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create the look of wood, we can start by creating a virtual "log" with perfectly
    cylindrical growth rings. Then, we'll take a slice of the log and perturb the
    growth rings using noise from our noise texture.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates our virtual *log*. It is aligned with the
    *y *axis, and extends infinitely in all directions. The growth rings are aligned
    with integer distances from the *y* axis. Each ring is given a darker color, with
    a lighter color in-between rings. Each growth ring spans a narrow distance around
    the integer distances:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4273364f-9fa6-4596-8769-e44db96d8713.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To take a "slice," we''ll simply define a 2D region of the log''s space based
    on the texture coordinates. Initially, the texture coordinates define a square
    region, with coordinates ranging from zero to one. We''ll assume that the region
    is aligned with the x-y plane, so that the *s* coordinate corresponds to *x*,
    the *t* coordinate corresponds to *y*, and the value of *z* is zero. We can then
    transform this region in any way that suits our fancy, to create an arbitrary
    2D slice. After defining the slice, we''ll determine the color based on the distance
    from the *y* axis. However, before doing so, we''ll perturb that distance based
    on a value from the noise texture. The result has a general look that is similar
    to real wood. The following image shows an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d8a0660c-31d6-43ed-920a-74e44a0f07e5.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Set up your program to generate a noise texture and make it available to the
    shaders through the uniform variable `NoiseTex`. There are three uniforms in the
    fragment shader that can be assigned from the OpenGL program. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LightWoodColor`: The lightest wood color'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DarkWoodColor`: The darkest wood color'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Slice`: A matrix that defines the slice of the virtual "log" and transforms
    the default region defined by the texture coordinates to some other arbitrary
    rectangular region'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a shader program that generates a wood-grain effect using a noise
    texture, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up your vertex shader to pass the texture coordinate to the fragment shader
    via the `TexCoord` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the following code for the fragment shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first line of the `main` function within the fragment shader expands the
    texture coordinates to a 3D (homogeneous) value with a *z* coordinate of zero
    (s, t, 0, 1), and then transforms the value via the `Slice` matrix. This matrix
    can scale, translate, and/or rotate the texture coordinates to define the 2D region
    of the virtual *log*.
  prefs: []
  type: TYPE_NORMAL
- en: One way to visualize this is to think of the slice as a 2D unit square embedded
    in the log with its lower-left corner at the origin. The matrix is then used to
    transform that square within the log to define a slice through the log. For example,
    I might just translate the square by (-0.5, -0.5, -0.5) and scale by 20 in *x*
    and *y* to get a slice through the middle of the log.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the distance from the *y* axis is determined by using the built-in `length`
    function (`length(cyl.xz)`). This will be used to determine how close we are to
    a growth ring. The color will be a light wood color if we are between growth rings,
    and a dark color when we are close to a growth ring. However, before determining
    the color, we perturb the distance slightly using a value from our noise texture
    by using the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The next step is just a bit of numerical trickery to determine the color based
    on how close we are to a whole number. We start by taking the fractional part
    of the distance (`fract(dist)`), multiplying by two, subtracting one, and taking
    the absolute value. As `fract(dist)` is a value between zero and one, multiplying
    by two, subtracting one, and taking the absolute value will result in a value
    that is also between zero and one. However, the value will range from 1.0 when
    `dist` is 0.0, to 0.0 when `dist` is 0.5, and back to 1.0 when `dist` is 1.0 (a
    `v` shape).
  prefs: []
  type: TYPE_NORMAL
- en: We then invert the `v` by subtracting from one, and storing the result in `t`.
    Next, we use the `smoothstep` function to create a somewhat sharp transition between
    the light and dark colors. In other words, we want a dark color when `t` is less
    than 0.2, a light color when it is greater than 0.5, and a smooth transition in
    between. The result is used to mix the light and dark colors via the GLSL `mix`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: The `smoothstep( a, b, x )` function works in the following way. It returns
    `0.0` when `x <= a`, `1.0` when `x >= b`, and uses Hermite interpolation between
    0 and 1 when `x` is between `a` and `b`.
  prefs: []
  type: TYPE_NORMAL
- en: The result of all of this is a narrow band of the dark color around integer
    distances, and a light color in-between, with a rapid but smooth transition. Finally,
    we simply apply the final color to the fragment.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A book-matched pair of boards is a pair that is cut from the same log and then
    glued together. The result is a larger board that has symmetry in the grain from
    one side to the other. We can approximate this effect by mirroring the texture
    coordinate. For example, we could use the following in place of the first line
    of the preceding `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following image shows an example of the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb282a0b-77f8-4f56-a01f-10628999a0df.png)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `chapter09/scenewood.cpp` file in the example code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a noise texture using GLM* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a disintegration effect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is straightforward to use the GLSL `discard` keyword in combination with
    noise to simulate erosion or decay. We can simply discard fragments that correspond
    to a noise value that is above or below a certain threshold. The following image
    shows a teapot with this effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fragments are discarded when the noise value corresponding to the texture coordinate
    is outside a certain threshold range:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9a768420-0b98-49df-9d73-909cf90796ff.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Set up your OpenGL program to provide position, normal, and texture coordinates
    to the shader. Make sure that you pass the texture coordinate along to the fragment
    shader. Set up any uniforms needed to implement the shading model of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: Create a seamless noise texture (see *Creating a seamless noise texture*), and
    place it in the appropriate texture channel.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following uniforms are defined in the fragment shader, and should be set
    via the OpenGL program:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NoiseTex`: The noise texture'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LowThreshold`: Fragments are discarded if the noise value is below this value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HighThreshold`: Fragments are discarded if the noise value is above this value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a shader program that provides a disintegration effect, perform the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a vertex shader that sends the texture coordinate to the fragment shader
    via the `TexCoord` output variable. It should also pass the position and normal
    to the fragment shader through the `Position` and `Normal` variables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the following code for the fragment shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The fragment shader starts by retrieving a noise value from the noise texture
    (`NoiseTex`), and storing the result in the `noise` variable. We want noise that
    has a large amount of high-frequency fluctuation, so we choose four-octave noise,
    which is stored in the alpha channel (`noise.a`).
  prefs: []
  type: TYPE_NORMAL
- en: We then discard the fragment if the noise value is below `LowThreshold` or above
    `HighThreshold`. As the `discard` keyword causes the execution of the shader to
    stop, the rest of the shader will not execute if the fragment is discarded.
  prefs: []
  type: TYPE_NORMAL
- en: The discard operation can have a performance impact due to how it might affect
    early depth tests.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we compute the shading model and apply the result to the fragment.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `chapter09/scenedecay.cpp` file in the example code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a seamless noise texture* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a paint-spatter effect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using high-frequency noise, it is easy to create the effect of random spatters
    of paint on the surface of an object. The following image shows an example of
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/87f51c07-6e29-4b3b-85d0-76a84f36df03.png)'
  prefs: []
  type: TYPE_IMG
- en: We use the noise texture to vary the color of the object, with a sharp transition
    between the base color and the paint color. We'll use either the base color or
    paint color as the diffuse reflectivity of the shading model. If the noise value
    is above a certain threshold, we'll use the paint color; otherwise, we'll use
    the base color of the object.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Start with a basic setup for rendering using the Phong shading model (or whatever
    model you prefer). Include texture coordinates and pass them along to the fragment
    shader.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of uniform variables that define the parameters of the paint
    spatters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PaintColor`: The color of the paint spatters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Threshold`: The minimum noise value where a spatter will appear'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a noise texture with high-frequency noise.
  prefs: []
  type: TYPE_NORMAL
- en: Make your noise texture available to the fragment shader via the `NoiseTex` uniform
    sampler variable.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a shader program that generates a paint-spatter effect, perform the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a vertex shader that sends the texture coordinates to the fragment shader
    via the `TexCoord` output variable. It should also pass the position and normal
    to the fragment shader through the variables `Position` and `Normal`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the following code for the fragment shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main function of the fragment shader retrieves a noise value from `NoiseTex` and
    stores it in the `noise` variable. The next two lines set the variable `color`
    to either the base diffuse reflectivity (`Material.Kd`) or `PaintColor`, depending
    on whether or not the noise value is greater than the threshold value (`Threshold`).
    This will cause a sharp transition between the two colors, and the size of the
    spatters will be related to the frequency of the noise.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the Phong shading model is evaluated using `color` as the diffuse reflectivity.
    The result is applied to the fragment.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As indicated in the *Creating a noise texture using GLM* recipe, using lower
    frequency noise will cause the spatters to be larger in size and more spread out.
    A lower threshold will also increase the size without it spreading over the surface,
    but as the threshold gets lower, it starts to look more uniform and less like
    random spattering.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `chapter09/scenepaint.cpp` file in the example code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a seamless noise texture* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a rusted metal effect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe combines a noise texture with the reflection effect covered in [Chapter
    5](a5d0db76-6dbb-470d-8685-42ab8ae077b1.xhtml), *Using Textures* to create a simple
    rusted metal effect.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2c249282-60fa-4e06-9a82-fdb9951af278.png)'
  prefs: []
  type: TYPE_IMG
- en: This technique is very similar to the previous recipe, *Creating a paint-spatter
    effect*.  We'll use our noise texture to modulate the reflection from the teapot.
    If the noise is above a certain threshold, we'll use the rust color, otherwise,
    we'll use the reflected color.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll combine the technique described in the *Simulating reflection with cube
    maps* recipe in [Chapter 5](a5d0db76-6dbb-470d-8685-42ab8ae077b1.xhtml), *Using
    Textures*, with a noise texture. Start with the shaders from that recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the fragment shader, we''ll access our noise texture and if the value is
    below the threshold value `Threshold`, we''ll use the reflected color (from the
    cube map), otherwise, we''ll use a rust color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We start by accessing the noise texture, and store it's value in the variable
    `noise`. The variable `scale` will store a value that is either zero or one. We
    use the `floor` function to set it to zero if the value of `noise` is less than
    `Threshold` and to one otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we access the cube map to get the reflected color and apply a gamma correction.
  prefs: []
  type: TYPE_NORMAL
- en: We compute `rustColor` by mixing `MaterialColor` with a dark color (nearly black)
    using the noise texture as a scale. This should give some additional variation
    in the rust color.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we use `scale` to mix the `cubeMapColor` with `rustColor` and apply
    the result to the fragment.  Since the value of `scale` will be either zero or
    one, we will get a sharp transition between the reflected color and the rust color.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `chapter09/scenerust.cpp` file in the example code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a night-vision effect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Noise can be useful to simulate static or other kinds of electronic interference
    effects. This recipe is a fun example of that. We''ll create the look of night-vision
    goggles with some noise thrown in to simulate some random static in the signal.
    Just for fun, we''ll also outline the scene in the classic *binocular* view. The
    following image shows an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1c83dd2b-fb39-410b-ac67-f8122cb53127.png)'
  prefs: []
  type: TYPE_IMG
- en: We'll apply the night-vision effect as a second pass to the rendered scene.
    The first pass will render the scene to a texture (see [Chapter 5](a5d0db76-6dbb-470d-8685-42ab8ae077b1.xhtml),
    *Using Textures*), and the second pass will apply the night-vision effect.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a **framebuffer object** (**FBO**) for the first pass. Attach a texture
    to the first color attachment of the FBO. For more information on how to do this,
    see [Chapter 5](a5d0db76-6dbb-470d-8685-42ab8ae077b1.xhtml), *Using Textures*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create and assign any uniform variables needed for the shading model. Set the
    following uniforms defined in the fragment shader:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Width`: The width of the viewport in pixels'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Height`: The height of the viewport in pixels'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Radius`: The radius of each circle in the *binocular* effect (in pixels)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RenderTex`: The texture containing the render from the first pass'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NoiseTex`: The noise texture'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RenderPass`: The subroutine uniform used to select the functionality for each
    pass'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a noise texture with high-frequency noise and make it available to the
    shader via `NoiseTex`. Associate the texture with the FBO available via `RenderTex`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a shader program that generates a night-vision effect, perform the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up your vertex shader to pass along the position, normal, and texture coordinates
    via the `Position`, `Normal`, and `TexCoord` variables, respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the following code for the fragment shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the render function of your OpenGL program, perform the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bind to the FBO that you set up for rendering the scene to a texture.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `pass1` subroutine function in the fragment shader via `RenderPass`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Render the scene.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Bind to the default FBO.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `pass2` subroutine function in the fragment shader via `RenderPass`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Draw a single quad that fills the viewport using texture coordinates that range
    from 0 to 1 in each direction.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The fragment shader is broken into two subroutine functions, one for each pass.
    Within the `pass1` function, we simply apply the Phong shading model to the fragment.
    The result is written to the FBO, which contains a texture to be used in the second
    pass.
  prefs: []
  type: TYPE_NORMAL
- en: In the second pass, the `pass2` function is executed. We start by retrieving
    a noise value (`noise`), and the color from the render texture from the first
    pass (`color`). Then, we compute the `luminance` value for the color and store
    that result in the `green` variable. This will eventually be used as the green
    component of the final color.
  prefs: []
  type: TYPE_NORMAL
- en: We use the same texture coordinates here, assuming that the noise texture is
    the same size as the render texture. It would be more space efficient to use a
    smaller noise texture and tile it across the surface.
  prefs: []
  type: TYPE_NORMAL
- en: The next step involves determining whether or not the fragment is inside the
    *binocular* lenses. We compute the distance to the center of the left lens (`dist1`),
    which is located in the viewport halfway from top to bottom and one quarter of
    the way from left to right. The right lens is located at the same vertical location,
    but three quarters of the way from left to right. The distance from the center
    of the right-hand lens is stored in `dist2`. If both `dist1` and `dist2` are greater
    than the radius of the virtual lenses, then we set `green` to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we return the final color, which has only a `green` component; the
    other two are set to zero. The value of `green` is multiplied by the noise value
    in order to add some noise to the image to simulate random interference in the
    signal. We add `0.25` to the noise value and clamp it between zero and one, in
    order to brighten the overall image. I have found that it appears a bit too dark
    if the noise value isn't biased in this way.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It would make this shader even more effective if the noise varied in each frame
    during animation to simulate interference that is constantly changing. We can
    accomplish this roughly by modifying the texture coordinates used to access the
    noise texture in a time-dependent way. See the blog post mentioned in the following *See
    also* section for an example.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `chapter09/scenenightvision.cpp` file in the example code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Rendering to a texture* recipe in [Chapter 5](a5d0db76-6dbb-470d-8685-42ab8ae077b1.xhtml),
    *Using Textures*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a noise texture using GLM* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This recipe was inspired by a blog post by Wojciech Toman (no longer publicly
    available)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
