- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Dynamic Analysis
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态分析
- en: In the intricate world of software development, ensuring the correctness, efficiency,
    and security of code is not just a goal but a necessity. This is particularly
    true in C++ programming, where the power and complexity of the language present
    both opportunities and challenges. One of the most effective approaches to maintaining
    high code quality in C++ is **dynamic code analysis** – a process that scrutinizes
    program behavior as it runs to detect a range of potential issues.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发的错综复杂世界中，确保代码的正确性、效率和安全性不仅是一个目标，更是一种必要性。这在C++编程中尤其如此，因为该语言的力量和复杂性既提供了机会，也带来了挑战。在C++中保持高代码质量的最有效方法之一是**动态代码分析**——这是一个审查程序在运行时行为的过程，以检测一系列潜在问题。
- en: Dynamic code analysis stands in contrast to static analysis, which examines
    source code without executing it. While static analysis is invaluable for catching
    syntax errors, code smells, and certain types of bugs early in the development
    cycle, dynamic analysis delves deeper. It uncovers issues that only manifest during
    the actual execution of the program, such as memory leaks, race conditions, and
    other runtime errors that can lead to crashes, erratic behavior, or security vulnerabilities.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 动态代码分析与静态分析形成对比，后者在执行代码之前检查源代码。虽然静态分析在开发周期早期捕获语法错误、代码异味和某些类型的错误方面非常有价值，但动态分析则更深入。它揭示了仅在程序实际执行过程中才会出现的问题，例如内存泄漏、竞态条件和可能导致崩溃、异常行为或安全漏洞的运行时错误。
- en: 'This chapter aims to explore the landscape of dynamic code analysis tools in
    C++, with a particular focus on some of the most powerful and widely used tools
    in the industry: a suite of compiler-based sanitizers, including **AddressSanitizer**
    (**ASan**), **ThreadSanitizer** (**TSan**), and **UndefinedBehaviorSanitizer**
    (**UBSan**), as well as Valgrind, a versatile tool known for its thorough memory
    debugging capabilities.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在探索C++中动态代码分析工具的领域，特别关注行业中一些最强大和最广泛使用的工具：一套基于编译器的清理器，包括**AddressSanitizer（ASan**）、**ThreadSanitizer（TSan**）和**UndefinedBehaviorSanitizer（UBSan**），以及Valgrind，这是一个以其详尽的内存调试能力而闻名的多功能工具。
- en: Compiler sanitizers, part of the LLVM project and GCC project, offer a range
    of options for dynamic analysis. ASan is remarkable for its ability to detect
    various memory-related errors, TSan excels in identifying race conditions in multi-threaded
    code, and UBSan helps in catching undefined behaviors that can lead to unpredictable
    program behavior. These tools are praised for their efficiency, precision, and
    ease of integration into existing development workflows. Most of them are supported
    by GCC and MSVC as well.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器清理器，作为LLVM项目和GCC项目的一部分，为动态分析提供了一系列选项。ASan因其能够检测各种内存相关错误而著称，TSan在识别多线程代码中的竞态条件方面表现出色，而UBSan有助于捕捉可能导致程序行为不可预测的未定义行为。这些工具因其效率、精确性和易于集成到现有开发工作流程中而受到赞誉。其中大多数都得到了GCC和MSVC的支持。
- en: On the other hand, Valgrind, an instrumentation framework for building dynamic
    analysis tools, shines with its comprehensive memory leak detection and the ability
    to analyze binary executables without requiring source code recompilation. It’s
    a go-to solution for complex scenarios where in-depth memory analysis is paramount,
    albeit at the cost of higher performance overhead.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Valgrind，一个用于构建动态分析工具的仪器框架，凭借其全面的内存泄漏检测和分析二进制可执行文件的能力（无需重新编译源代码），而显得格外耀眼。它是在深入内存分析至关重要的复杂场景下的首选解决方案，尽管这会带来更高的性能开销。
- en: Throughout this chapter, we will delve into each of these tools, understanding
    their strengths, weaknesses, and appropriate use cases. We’ll explore how they
    can be effectively integrated into your C++ development process, and how they
    complement each other to provide a robust framework for ensuring the quality and
    reliability of C++ applications.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入研究这些工具的每一个，了解它们的优点、缺点和适当的用例。我们将探讨如何有效地将它们集成到你的C++开发过程中，以及它们如何相互补充，为确保C++应用程序的质量和可靠性提供一个强大的框架。
- en: By the end of this chapter, you will have a thorough understanding of dynamic
    code analysis in C++, equipped with the knowledge to choose and utilize the right
    tools for your specific development needs, ultimately leading to cleaner, more
    efficient, and reliable C++ code.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将全面理解C++中的动态代码分析，并具备选择和利用适合你特定开发需求工具的知识，最终导致编写更清洁、更高效、更可靠的C++代码。
- en: Compiler-based dynamic code analysis
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于编译器的动态代码分析
- en: 'Compiler-based sanitizers contain two parts: compiler instrumentation and runtime
    diagnostics:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 基于编译器的清理器包含两部分：编译器仪器化和运行时诊断：
- en: '**Compiler instrumentation**: When you compile your C++ code with sanitizers
    enabled, the compiler instruments the generated binary with additional checks.
    These checks are strategically inserted into the code to monitor for specific
    types of errors. For instance, ASan adds code to track memory allocations and
    accesses, enabling it to detect memory misuses such as buffer overflows and memory
    leaks.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编译器仪器化**: 当你使用清理器编译你的 C++ 代码时，编译器会对生成的二进制文件进行额外的检查。这些检查被策略性地插入到代码中，以监控特定类型的错误。例如，ASan
    会添加代码来跟踪内存分配和访问，使其能够检测内存误用，如缓冲区溢出和内存泄漏。'
- en: '**Runtime diagnostics**: As the instrumented program runs, these checks actively
    monitor the program’s behavior. When a sanitizer detects an error (such as a memory
    access violation or a data race), it immediately reports this, often with detailed
    information about the location and nature of the error. This real-time feedback
    is invaluable for identifying and fixing elusive bugs that might be difficult
    to catch through traditional testing.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行时诊断**: 当被仪器化的程序运行时，这些检查会积极监控程序的行为。当一个清理器检测到错误（如内存访问违规或数据竞争）时，它会立即报告，通常还会提供关于错误位置和性质的详细信息。这种实时反馈对于识别和修复难以通过传统测试捕获的隐蔽错误非常有价值。'
- en: 'Despite all compiler teams constantly working on adding new sanitizers and
    improving the existing ones, there are still some limitations to the compiler-based
    sanitizers:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管所有编译器团队都在不断努力添加新的清理器并改进现有的清理器，但基于编译器的清理器仍然存在一些限制：
- en: '**Clang and GCC**: Most sanitizers, including ASan, TSan, and UBSan, are supported
    by both Clang and GCC. This wide support makes them accessible to a large portion
    of the C++ development community, regardless of the preferred compiler.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Clang 和 GCC**: 大多数清理器，包括 ASan、TSan 和 UBSan，都由 Clang 和 GCC 支持。这种广泛的支持使得它们对大量
    C++ 开发社区成员可访问，无论他们偏好的编译器是什么。'
- en: '**Microsoft Visual C++ (MSVC)**: MSVC also supports some sanitizers, though
    the range and capabilities might differ from those in Clang and GCC. For example,
    MSVC has support for ASan, which is useful for Windows-specific C++ development.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Microsoft Visual C++ (MSVC)**: MSVC 也支持一些清理器，尽管其范围和能力可能与 Clang 和 GCC 不同。例如，MSVC
    支持 ASan，这对于 Windows 特定的 C++ 开发很有用。'
- en: '**Cross-platform utility**: The cross-compiler and cross-platform nature of
    these tools mean they can be used in a variety of development environments, from
    Linux and macOS to Windows, enhancing their utility in diverse C++ projects.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跨平台实用工具**: 这些工具的跨编译器和跨平台特性意味着它们可以在各种开发环境中使用，从 Linux 和 macOS 到 Windows，增强了它们在多样化的
    C++ 项目中的实用性。'
- en: ASan
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ASan
- en: ASan is a runtime memory error detector, part of the LLVM compiler infrastructure,
    GCC, and MSVC. It serves as a specialized tool for developers to identify and
    resolve various kinds of memory-related errors, including, but not limited to,
    buffer overflows, dangling pointer accesses, and memory leaks. The tool achieves
    this by instrumenting the code during the compilation process, enabling it to
    monitor memory accesses and allocations at runtime.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: ASan 是一个运行时内存错误检测器，是 LLVM 编译器基础设施、GCC 和 MSVC 的一部分。它作为开发者识别和解决各种内存相关错误的专用工具，包括但不限于缓冲区溢出、悬垂指针访问和内存泄漏。该工具通过在编译过程中对代码进行仪器化来实现这一点，使其能够在运行时监控内存访问和分配。
- en: One of the key strengths of ASan is its ability to provide detailed error reports.
    When a memory error is detected, ASan outputs comprehensive information, including
    the type of error, the memory location involved, and the stack trace. This level
    of detail significantly aids in the debugging process, allowing developers to
    pinpoint the source of the issue quickly.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ASan 的一个关键优势是它能够提供详细的错误报告。当检测到内存错误时，ASan 会输出全面的信息，包括错误类型、涉及的内存位置和堆栈跟踪。这种详细程度大大有助于调试过程，使开发者能够快速定位问题的根源。
- en: Integrating ASan into a C++ development workflow is straightforward. It requires
    minimal changes to the build process, typically involving the addition of a compiler
    flag (`-fsanitize=address`) during compilation. For better results, it makes sense
    to use reasonable performance adda`-O1` or higher. To get nicer stack traces in
    error messages, add `-fno-omit-frame-pointer`. This ease of integration, combined
    with its effectiveness in catching memory errors, makes ASan an indispensable
    tool for developers aiming to enhance the reliability and security of their C++
    applications.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 将 ASan 集成到 C++ 开发工作流程中非常简单。它需要对构建过程进行最小的更改，通常涉及在编译期间添加编译器标志（`-fsanitize=address`）。为了获得更好的结果，使用合理的性能选项（`-O1`
    或更高）是有意义的。为了在错误消息中获得更好的堆栈跟踪，请添加 `-fno-omit-frame-pointer`。这种易于集成的便利性，加上其捕获内存错误的有效性，使
    ASan 成为开发者增强其 C++ 应用程序可靠性和安全性的不可或缺的工具。
- en: Symbolizing reports in ASan
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 ASan 中符号化报告
- en: When using ASan to detect memory errors in C++ applications, it’s crucial to
    symbolize the error reports. Symbolization translates memory addresses and offsets
    in ASan’s output into human-readable function names, file names, and line numbers.
    This process is vital for effective debugging, as it allows developers to easily
    identify where in the source code the memory error occurred.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 ASan 在 C++ 应用程序中检测内存错误时，符号化错误报告至关重要。符号化将 ASan 输出的内存地址和偏移量转换为人类可读的函数名、文件名和行号。这个过程对于有效的调试至关重要，因为它允许开发者轻松地识别内存错误在源代码中的确切位置。
- en: Without symbolization, the ASan report provides less meaningful raw memory addresses,
    making it challenging to trace back to the exact location in the source code where
    the error happened. Symbolized reports, on the other hand, offer clear and actionable
    insights, enabling developers to quickly understand and fix the underlying issues
    in their code.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 没有符号化，ASan 报告提供的是不太有意义的原始内存地址，这使得难以追踪到源代码中错误发生的确切位置。另一方面，符号化报告提供了清晰且可操作的信息，使开发者能够快速理解和修复代码中的潜在问题。
- en: 'The configuration of ASan symbolization is typically automatic, requiring no
    additional steps. However, in some cases, you might need to explicitly set the
    `ASAN_SYMBOLIZER_PATH` environment variable to point to the symbolizer tool. This
    is especially true on non-Linux Unix systems, where additional tools such as `addr2line`
    might be required for symbolization. If it does not work out of the box, please
    go over the following steps to ensure that symbolization is configured correctly:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ASan 符号化的配置通常是自动的，不需要额外的步骤。然而，在某些情况下，你可能需要显式设置 `ASAN_SYMBOLIZER_PATH` 环境变量，以便指向符号化工具。这在非
    Linux Unix 系统上尤其如此，在这些系统上可能需要额外的工具，如 `addr2line`，来进行符号化。如果它不能直接工作，请按照以下步骤进行，以确保符号化配置正确：
- en: '`-g` flag to your compilation command. For instance:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编译命令中使用 `-g` 标志。例如：
- en: '[PRE0]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Compiling with `-g` includes debugging symbols in the binary, which are essential
    for symbolization.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `-g` 编译选项会在二进制文件中包含调试符号，这对于符号化是必不可少的。
- en: '`llvm-symbolizer` tool is in your system’s `PATH`.'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`llvm-symbolizer` 工具位于你的系统 `PATH` 中。'
- en: '`addr2line` (part of GNU Binutils) can be used for symbolizing stack traces.'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`addr2line`（GNU Binutils 的一部分）可用于符号化堆栈跟踪。'
- en: '`ASAN_SYMBOLIZER_PATH` environment variable to point to the symbolizer tool.
    For example:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `ASAN_SYMBOLIZER_PATH` 环境变量指向符号化工具。例如：
- en: '[PRE1]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This explicitly tells ASan which symbolizer to use.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这明确告诉 ASan 使用哪个符号化工具。
- en: '**Running** **your program**:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**运行** **你的程序**：'
- en: Run your compiled program as usual. If a memory error is detected, ASan will
    output a symbolized stack trace.
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照常规运行编译后的程序。如果检测到内存错误，ASan 将输出符号化的堆栈跟踪。
- en: The report will include function names, file names, and line numbers, making
    it easier to locate and address the error in your code.
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 报告将包括函数名、文件名和行号，这使得更容易定位和解决代码中的错误。
- en: Out-of-bounds access
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 越界访问
- en: 'Let us try to catch one of the most critical errors of C++ programming: **out-of-bounds
    access**. This issue spans various segments of memory management – the heap, the
    stack, and global variables, each presenting unique challenges and risks.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试捕捉 C++ 编程中最关键的错误之一：**越界访问**。这个问题跨越了内存管理的各个部分——堆、栈和全局变量，每个部分都提出了独特的挑战和风险。
- en: Out-of-bounds access on the heap
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 堆中的越界访问
- en: 'We begin by exploring out-of-bounds access on the heap, where dynamic memory
    allocation can lead to pointers exceeding the allocated memory boundaries. Consider
    the following example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先探讨堆上的越界访问，动态内存分配可能导致指针超出分配的内存边界。考虑以下示例：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This code snippet demonstrates an out-of-bounds write, attempting to access
    an index that is beyond the allocated range, leading to undefined behavior and
    potential memory corruption.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段演示了越界写入，尝试访问超出分配范围的索引，导致未定义行为和潜在的内存损坏。
- en: 'If we run this code with ASan enabled, we get the following output:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们启用 ASan 运行此代码，我们得到以下输出：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, the report includes a detailed stack trace, highlighting the
    exact location of the error in the source code. This information is invaluable
    for debugging and fixing the issue.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，报告包括详细的堆栈跟踪，突出显示源代码中错误的精确位置。这些信息对于调试和修复问题非常有价值。
- en: Out-of-bounds access on the stack
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 栈上的越界访问
- en: 'Next, we focus on the stack. Here, out-of-bounds accesses often occur with
    local variables due to incorrect indexing or buffer overruns. For example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们关注栈。在这里，由于索引错误或不正确的缓冲区溢出，越界访问通常与局部变量有关。例如：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this case, accessing `stackArray[5]` is out of bounds, as valid indices
    are from `0` to `4`. Such errors can result in crashes or exploitable vulnerabilities.
    The output of ASan for this example is very similar to the previous one:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，访问 `stackArray[5]` 超出了范围，因为有效的索引是从 `0` 到 `4`。此类错误可能导致崩溃或可利用的漏洞。ASan 对此示例的输出与上一个示例非常相似：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Out-of-bounds access to global variables
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 全局变量的越界访问
- en: 'Finally, we examine global variables. These are susceptible to similar risks
    when accessed beyond their defined boundaries:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们检查全局变量。当访问超出其定义边界时，它们也容易受到类似的风险。例如：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, the attempt to write to `globalArray[5]` is an out-of-bounds operation,
    leading to undefined behavior. Since the output of ASan is similar to the previous
    examples, we won’t include it here.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，尝试写入 `globalArray[5]` 的操作是一个越界操作，导致未定义行为。由于 ASan 的输出与之前的示例相似，我们在此不包括它。
- en: Addressing use-after-free vulnerabilities in C++
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决 C++ 中的 Use-After-Free 漏洞
- en: 'In the following section, we will address a critical and often challenging
    issue in C++ programming: **use-after-free vulnerabilities**. This type of error
    occurs when a program continues to use a memory location after it has been freed,
    leading to undefined behavior, program crashes, security vulnerabilities, and
    data corruption. We’ll explore this issue in various contexts, providing insights
    into its identification and prevention.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将解决 C++ 编程中的一个关键且经常具有挑战性的问题：**Use-After-Free 漏洞**。此类错误发生在程序在释放内存后继续使用该内存位置时，导致未定义行为、程序崩溃、安全漏洞和数据损坏。我们将从各种上下文中探讨此问题，提供有关其识别和预防的见解。
- en: Use-after-free in dynamic memory (heap)
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 动态内存（堆）中的 Use-After-Free
- en: 'The most common scenario for use-after-free errors occurs with dynamically
    allocated memory on the heap. Consider the following example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Use-After-Free 错误最常见的情况是在堆上的动态分配内存。考虑以下示例：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this snippet, the memory pointed to by `ptr` is accessed after it has been
    freed with `delete`. This access can lead to unpredictable behavior, as the freed
    memory might be allocated for other purposes or modified by the system.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在此片段中，`ptr` 所指向的内存在使用 `delete` 释放后进行访问。这种访问可能导致不可预测的行为，因为已释放的内存可能被分配用于其他目的或被系统修改。
- en: Use-after-free with object references
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用对象引用的 Use-After-Free
- en: 'Use-after-free can also occur in object-oriented programming, especially when
    dealing with references or pointers to objects that have been destroyed. For instance:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Use-After-Free 也可以在面向对象编程中发生，尤其是在处理已销毁的对象的引用或指针时。例如：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, `ref` refers to an object that has been deleted, and any operation on
    `ref` after the deletion leads to use-after-free.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`ref` 指向一个已被删除的对象，并且在删除后对 `ref` 的任何操作都会导致 Use-After-Free。
- en: Use-After-Free in Complex Data Structures
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在复杂数据结构中的 Use-After-Free
- en: 'Complex data structures, such as linked lists or trees, are also prone to use-after-free
    errors, particularly during deletion or restructuring operations. For example:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂数据结构，如链表或树，也容易发生 Use-After-Free 错误，尤其是在删除或重构操作期间。例如：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this case, `temp` is used after it has been freed, which can lead to serious
    issues, especially if the list is large or part of a critical system component.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'ASan can help in detecting use-after-free errors in C++ programs. For instance,
    if we run the previous example with ASan enabled, we get the following output:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Use-after-return detection in ASan
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Use-after-return** is a type of memory error in C++ programming where a function
    returns a pointer or a reference to a local (stack-allocated) variable. This local
    variable ceases to exist once the function returns, making any subsequent access
    through the returned pointer or reference invalid and dangerous. This can lead
    to undefined behavior and potential security vulnerabilities.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: ASan provides a mechanism to detect use-after-return errors. It can be controlled
    using the `-fsanitize-address-use-after-return` flag during compilation and the
    `ASAN_OPTIONS` environment variable at runtime.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'The following describes the configuration of use-after-return detection:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '`-fsanitize-address-use-after-return=(never|``runtime|always)`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The flag accepts three settings:'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`never`: This disables use-after-return detection'
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`runtime`: This enables detection, but it can be overridden at runtime (default
    setting)'
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`always`: This always enables detection, irrespective of runtime settings'
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ASAN_OPTIONS` environment variable:'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ASAN_OPTIONS=detect_stack_use_after_return=1`'
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ASAN_OPTIONS=detect_stack_use_after_return=0`'
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: On Linux, detection is enabled by default
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of its usage:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '**Compiling with use-after-return** **detection enabled**:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This command compiles `your_file.cpp` with ASan and explicitly enables use-after-return
    detection.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Running with** **detection enabled/disabled**:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To run the program with use-after-return detection enabled (on platforms where
    it’s not the default):'
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To disable detection, even if it was enabled at compile time:'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**Example code** **demonstrating use-after-return**'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'The provided C++ code example demonstrates a use-after-return scenario, which
    is a type of undefined behavior caused by returning a reference to a local variable
    from a function. Let’s analyze the example and understand the implications:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the given code example, the `get_binary_name` function is designed to create
    a local `std::string` object named `name` and return a reference to it. The critical
    issue arises from the fact that `name` is a local variable, which gets destroyed
    as soon as the function scope ends. As a result, the reference that `get_binary_name`
    returns becomes invalid the moment the function exits.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: In the `main` function, this returned reference, now stored in `name`, is used
    to access the string value. However, since `name` refers to a local variable that
    has already been destroyed, using it in this manner leads to undefined behavior.
    This is a classic example of a use-after-return error, where the program attempts
    to access memory that is no longer valid.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: The function’s intended functionality seems to be to return the program’s name.
    However, for this to work correctly, the `name` variable should have a static
    or global lifetime rather than being a local variable confined to the `get_binary_name`
    function. This would ensure that the returned reference remains valid beyond the
    scope of the function, avoiding the use-after-return error.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的预期功能似乎是要返回程序名称。然而，为了正确工作，`name` 变量应该具有静态或全局生命周期，而不是被限制在 `get_binary_name`
    函数中的局部变量。这将确保返回的引用在函数作用域之外仍然有效，避免使用后返回错误。
- en: Modern compilers are equipped with the ability to issue warnings about potentially
    problematic code patterns, such as returning references to local variables. In
    the context of our example, a compiler might flag the return of a local variable
    reference as a warning, signaling a possible use-after-return error.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现代编译器配备了发出关于潜在问题代码模式的警告的能力，例如返回对局部变量的引用。在我们的示例中，编译器可能会将返回局部变量引用标记为警告，表明可能存在使用后返回错误。
- en: However, to effectively demonstrate the capabilities of ASan in catching use-after-return
    errors, it’s sometimes necessary to bypass these compile-time warnings. This can
    be achieved by explicitly disabling the compiler’s warning. For instance, by adding
    the `-Wno-return-local-addr` flag to the compilation command, we can prevent the
    compiler from issuing a warning about returning a local address. Doing so allows
    us to shift the focus from compile-time detection to runtime detection, where
    ASan’s capabilities in identifying use-after-return errors can be more prominently
    displayed and tested. This approach underscores the runtime diagnostic strengths
    of ASan, particularly in cases where compile-time analysis might not be sufficient.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了有效地展示 ASan 捕获使用后返回错误的能力，有时需要绕过这些编译时警告。这可以通过显式禁用编译器的警告来实现。例如，通过在编译命令中添加
    `-Wno-return-local-addr` 标志，我们可以防止编译器发出关于返回局部地址的警告。这样做使我们能够将重点从编译时检测转移到运行时检测，在那里
    ASan 在识别使用后返回错误方面的能力可以更加突出和测试。这种方法强调了 ASan 的运行时诊断优势，尤其是在编译时分析可能不足的情况下。
- en: '**Compiling** **with ASan**'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 ASan 编译**'
- en: 'To compile this program with ASan’s use-after-return detection enabled, you
    would use a command such as the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 ASan 的使用后返回检测编译此程序，您可以使用以下命令：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This command compiles the program with ASan enabled while suppressing the specific
    compiler warning about returning the address of a local variable. Running the
    compiled program will allow ASan to detect and report the use-after-return error
    at runtime:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令在启用 ASan 的同时抑制了关于返回局部变量地址的特定编译器警告。运行编译后的程序将允许 ASan 在运行时检测并报告使用后返回错误：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This example highlights the importance of understanding object lifetimes in
    C++ and how misuse can lead to undefined behavior. While compiler warnings are
    valuable for catching such issues at compile time, tools such as ASan provide
    an additional layer of runtime error detection, which is especially useful in
    complex scenarios where compile-time analysis might not suffice.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子强调了理解 C++ 中对象生命周期的重要性以及误用可能导致未定义行为。虽然编译器警告在编译时捕获此类问题很有价值，但像 ASan 这样的工具提供了额外的运行时错误检测层，这在复杂场景中尤其有用，在这些场景中，编译时分析可能不足以满足需求。
- en: Use-after-return detection
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用后返回检测
- en: The concept of use-after-scope in C++ involves accessing a variable after its
    scope has ended, leading to undefined behavior. This type of error is subtle and
    can be particularly challenging to detect and debug. ASan offers a feature to
    detect use-after-scope errors, which can be enabled using the `-fsanitize-address-use-after-scope`
    compilation flag.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 中使用后作用域的概念涉及在作用域结束后访问变量，导致未定义行为。这种类型的错误很微妙，可能特别难以检测和调试。ASan 提供了一种检测使用后作用域错误的功能，可以使用
    `-fsanitize-address-use-after-scope` 编译标志来启用。
- en: '**Understanding use-after-scope**'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**理解使用后作用域**'
- en: Use-after-scope occurs when a program continues to use a pointer or reference
    to a variable that has gone out of scope. Unlike use-after-return, where the issue
    is with function-local variables, use-after-scope can occur within any scope,
    such as within a block of code, such as an `if` statement or a loop.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用后作用域发生在程序继续使用超出作用域的变量的指针或引用时。与使用后返回不同，后者的问题在于函数局部变量，使用后作用域可以发生在任何作用域内，例如在代码块中，如
    `if` 语句或循环中。
- en: When a variable goes out of scope, its memory location may still hold the old
    data for some time, but this memory can be overwritten at any moment. Accessing
    this memory is undefined behavior and can lead to erratic program behavior or
    crashes.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个变量超出作用域时，其内存位置可能仍然保留旧数据一段时间，但这个内存随时可能被覆盖。访问这个内存是未定义行为，可能导致程序行为异常或崩溃。
- en: '**Configuring ASan for** **use-after-scope detection**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**配置ASan以进行** **超出作用域检测**'
- en: '`-fsanitize-address-use-after-scope`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`-fsanitize-address-use-after-scope`:'
- en: Adding this flag to your compilation command instructs ASan to instrument the
    code to detect use-after-scope errors
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将此标志添加到您的编译命令中，指示ASan对代码进行操作以检测超出作用域错误。
- en: It’s important to note that this detection is not enabled by default and must
    be explicitly enabled
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重要的是要注意，这种检测默认是未启用的，必须显式启用。
- en: '**Example code** **demonstrating use-after-scope**'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例代码** **展示超出作用域**'
- en: 'The provided code snippet demonstrates a classic case of use-after-scope error
    in C++. Let’s analyze the code and understand the issue:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的代码片段展示了C++中超出作用域错误的经典案例。让我们分析代码并了解问题：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the given code snippet, we begin by declaring a `p` pointer without initializing
    it. The function then enters a conditional scope where, if `condition` is true,
    an `x[10]` array is created on the stack. Within this scope, the `p` pointer is
    assigned to point to the start of this array, effectively making `p` point to
    `x`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定的代码片段中，我们首先声明了一个未初始化的`p`指针。然后函数进入一个条件作用域，如果`condition`为真，则在栈上创建一个`x[10]`数组。在这个作用域内，`p`指针被分配为指向这个数组的起始位置，实际上使`p`指向`x`。
- en: The critical issue arises after the conditional block is exited. At this point,
    the `x` array, being local to the `if` block, goes out of scope and is no longer
    valid. However, the `p` pointer still holds the address of where `x` was located.
    When the code attempts to write to this memory location using `*p = 1;`, it is
    trying to access the memory of the now out-of-scope `x` array. This action leads
    to a use-after-scope error, where `p` is dereferenced to access memory that is
    no longer valid within the current scope. This kind of error is a classic example
    of use-after-scope, highlighting the dangers of accessing memory through pointers
    that point to out-of-scope variables.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 关键问题出现在条件块退出之后。此时，作为`if`块局部变量的`x`数组超出作用域，不再有效。然而，`p`指针仍然持有`x`之前所在位置的地址。当代码尝试使用`*p
    = 1;`写入这个内存位置时，它试图访问当前作用域内不再有效的`x`数组内存。这种行为导致了一个超出作用域错误，其中`p`被解引用以访问当前作用域内不再有效的内存。这种错误是超出作用域的经典例子，突出了通过指向超出作用域变量的指针访问内存的危险性。
- en: Accessing memory through a pointer that points to an out-of-scope variable,
    as demonstrated in the provided code snippet, leads to undefined behavior. This
    is because once the `x` variable goes out of scope, the memory location to which
    `p` points becomes indeterminate. The undefined behavior arising from this scenario
    is problematic for several reasons.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通过指向超出作用域变量的指针访问内存，如提供的代码片段所示，会导致未定义行为。这是因为一旦`x`变量超出作用域，`p`指针指向的内存位置就变得不确定。由此场景产生的未定义行为存在几个问题。
- en: Firstly, it poses significant security and stability risks to the program. The
    undefined nature of the behavior means that the program could crash or behave
    unpredictably. Such instability in a program’s execution can have far-reaching
    consequences, particularly in applications where reliability is critical. Furthermore,
    if the memory location previously occupied by `x` gets overwritten by other parts
    of the program, it could potentially lead to security vulnerabilities. These vulnerabilities
    might be exploited to compromise the program or the system on which it is running.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这对程序的安全性和稳定性构成了重大风险。行为的未定义性质意味着程序可能会崩溃或行为不可预测。程序执行中的这种不稳定性可能产生深远的影响，尤其是在可靠性至关重要的应用中。此外，如果`x`之前占用的内存位置被程序的其它部分覆盖，可能会潜在地导致安全漏洞。这些漏洞可能被利用来损害程序或其运行的系统。
- en: In summary, the undefined behavior resulting from accessing memory through pointers
    to out-of-scope variables is a serious concern in software development, necessitating
    careful management of variable scope and memory access patterns to ensure the
    security and stability of the program.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，通过指向超出作用域变量的指针访问内存导致的未定义行为在软件开发中是一个严重的问题，需要仔细管理变量作用域和内存访问模式，以确保程序的安全性和稳定性。
- en: 'To compile the program with ASan’s use-after-scope detection enabled, you would
    use a command such as the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译启用 ASan 使用范围之外检测的程序，你可以使用以下命令之一：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Running the compiled program with these settings enables ASan to detect and
    report use-after-scope errors at runtime.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些设置运行编译后的程序可以启用 ASan 在运行时检测并报告使用范围之外的错误。
- en: Use-after-scope errors can be insidious and difficult to trace due to their
    dependence on the program’s runtime state and memory layout. By enabling use-after-scope
    detection in ASan, developers gain a valuable tool for identifying these errors,
    leading to more robust and reliable C++ applications. Understanding and preventing
    such issues is crucial for writing safe and correct C++ code.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们依赖于程序的运行时状态和内存布局，使用范围之外的错误可能难以察觉和追踪。通过在 ASan 中启用使用范围之外的检测，开发者可以获得一个宝贵的工具，用于识别这些错误，从而创建更健壮和可靠的
    C++ 应用程序。理解和预防此类问题是编写安全且正确 C++ 代码的关键。
- en: Double-free and invalid-free checks in ASan
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 双重释放和无效释放检查在 ASan 中
- en: 'ASan, a part of the LLVM project, provides robust mechanisms to detect and
    diagnose two critical types of memory errors in C++ programs: double free and
    invalid free. These errors are not only common in complex C++ applications but
    can also lead to severe issues such as program crashes, undefined behavior, and
    security vulnerabilities.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ASan 是 LLVM 项目的一部分，提供了强大的机制来检测和诊断 C++ 程序中的两种关键类型的内存错误：双重释放和无效释放。这些错误不仅常见于复杂的
    C++ 应用程序，还可能导致严重的程序崩溃、未定义行为和安全漏洞。
- en: '**Understanding double free and** **invalid free**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**理解双重释放和** **无效释放**'
- en: Understanding double-free and invalid-free errors is essential in managing memory
    in C++ programs effectively.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 理解双重释放和无效释放错误对于有效地管理 C++ 程序中的内存至关重要。
- en: A double-free error occurs when an attempt is made to free a memory block more
    than once using the `delete` or `delete[]` operators. This typically happens when
    the same memory allocation is passed to `delete` or `delete[]` twice. The first
    call to `delete` frees the memory, but the second call attempts to free memory
    that has already been released. This can lead to heap corruption, as the program
    might subsequently modify or reallocate the freed memory for other uses. Double-free
    errors can cause unpredictable behavior in your program, including crashes and
    data corruption.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试使用 `delete` 或 `delete[]` 操作符多次释放内存块时，就会发生双重释放错误。这种情况通常发生在相同的内存分配被两次传递给 `delete`
    或 `delete[]` 的情况下。第一次调用 `delete` 释放了内存，但第二次调用试图释放已经释放的内存。这可能导致堆损坏，因为程序可能会随后修改或重新分配已释放的内存以供其他用途。双重释放错误可能导致程序出现不可预测的行为，包括崩溃和数据损坏。
- en: Invalid-free errors, on the other hand, occur when `delete` or `delete[]` is
    used on a pointer that wasn’t allocated with `new` or `new[]`, or that has already
    been freed. This category includes attempts to free a null pointer, pointers to
    stack memory (which are not dynamically allocated), or pointers to uninitialized
    memory. Like double-free errors, invalid frees can also lead to heap corruption
    and unpredictable program behavior. They are particularly insidious because they
    can corrupt the memory management structures of the C++ runtime, leading to subtle
    and hard-to-diagnose bugs.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当使用 `delete` 或 `delete[]` 操作一个未使用 `new` 或 `new[]` 分配，或已经释放的指针时，就会发生无效释放错误。这一类别包括尝试释放空指针、指向栈内存（这些不是动态分配的）或指向未初始化内存的指针。像双重释放错误一样，无效释放也可能导致堆损坏和不可预测的程序行为。它们尤其危险，因为它们可能会破坏
    C++ 运行时的内存管理结构，导致微妙且难以诊断的错误。
- en: Both of these errors stem from improper handling of dynamic memory, underscoring
    the importance of adhering to best practices in memory management, such as ensuring
    every `new` has a corresponding `delete` and avoiding the reuse of pointers after
    they have been freed.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种错误都源于对动态内存的不当处理，强调了遵守内存管理最佳实践的重要性，例如确保每个 `new` 都有一个相应的 `delete`，并在释放指针后避免其重用。
- en: 'This list outlines the features of ASan’s detection mechanism:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表概述了 ASan 检测机制的功能：
- en: '`delete` operation is performed, ASan checks whether the pointer corresponds
    to a valid, previously allocated, and not-yet-freed memory block.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行 `delete` 操作时，ASan 会检查该指针是否对应一个有效、先前分配且尚未释放的内存块。
- en: '**Error reporting**: If a double-free or invalid-free error is detected, ASan
    aborts the program’s execution and provides a detailed error report. This report
    includes the location in the code where the error occurred, the memory address
    involved, and the allocation history of that memory (if available).'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误报告**：如果检测到双重释放或无效释放错误，ASan 会终止程序的执行并提供详细的错误报告。此报告包括错误发生的代码位置、涉及的内存地址以及该内存的分配历史（如果可用）。'
- en: 'Here is some example code demonstrating double-free errors:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些示例代码演示双重释放错误：
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'ASan would report the following error:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ASan 会报告以下错误：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this example, the same memory pointed to by `ptr` is freed twice, leading
    to a double-free error.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`ptr` 所指向的同一内存被释放了两次，导致双重释放错误。
- en: '**Example code demonstrating** **invalid free**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**演示无效释放的示例代码**'
- en: 'The provided code snippet demonstrates an invalid-free error, which is a type
    of memory management mistake that can occur in C++ programming. Let’s dissect
    the example to understand the issue and its implications:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的代码片段演示了一个无效释放错误，这是一种可能在 C++ 编程中发生的内存管理错误。让我们分析这个例子，了解问题及其影响：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In a given code segment, we start by declaring and initializing a local `int
    local_var = 42;` variable. This creates a stack-allocated integer variable named
    `local_var`. Following this, a pointer assignment is made with `int* ptr = &local_var;`,
    where the `ptr` pointer is set to point to the address of `local_var`. This establishes
    a link between the pointer and the stack-allocated variable.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定的代码段中，我们首先声明并初始化一个局部变量 `int local_var = 42;`。这创建了一个名为 `local_var` 的栈分配整数变量。随后，使用
    `int* ptr = &local_var;` 进行指针赋值，其中 `ptr` 指针被设置为指向 `local_var` 的地址。这建立了指针和栈分配变量之间的联系。
- en: 'However, an issue arises with the subsequent operation: `delete ptr;`. This
    line of code attempts to free the memory pointed to by `ptr`. The problem here
    is that `ptr` is pointing to a stack-allocated variable, `local_var`, rather than
    a dynamically allocated piece of memory from the heap. In C++, the `delete` operator
    is intended to be used exclusively with pointers that have been allocated with
    `new`. Since `local_var` was not allocated with `new` (being a stack-allocated
    variable), using `delete` on `ptr` is invalid and leads to undefined behavior.
    This misuse of the `delete` operator on a non-heap pointer is a common mistake
    that can lead to serious runtime errors in a C++ program.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，后续的操作出现了问题：`delete ptr;`。此行代码试图释放 `ptr` 所指向的内存。问题在于 `ptr` 指向的是栈分配的变量 `local_var`，而不是堆上的动态分配内存。在
    C++ 中，`delete` 操作符仅应与使用 `new` 分配的指针一起使用。由于 `local_var` 没有使用 `new` 分配（它是一个栈分配的变量），在
    `ptr` 上使用 `delete` 是无效的，并导致未定义的行为。在非堆指针上滥用 `delete` 操作符是 C++ 程序中可能导致严重运行时错误的常见错误。
- en: 'Here are some modern compiler warnings:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些现代编译器的警告：
- en: Modern C++ compilers typically issue warnings or errors when `delete` is used
    on a pointer that doesn’t point to dynamically allocated memory, as this is a
    common source of bugs.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代 C++ 编译器通常会在使用 `delete` 操作符对不指向动态分配内存的指针进行操作时发出警告或错误，因为这通常是错误的一个常见来源。
- en: To compile this code without modification and demonstrate ASan’s ability to
    catch such errors, you might need to suppress the compiler warning. This can be
    done by adding the `-Wno-free-nonheap-object` flag to the compilation command.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了在不修改代码的情况下编译此代码并展示 ASan 捕获此类错误的能力，你可能需要抑制编译器警告。这可以通过在编译命令中添加 `-Wno-free-nonheap-object`
    标志来实现。
- en: '**Compiling with ASan for** **invalid-free detection**'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 ASan 编译以进行** **无效释放检测**'
- en: 'To compile the program with ASan to detect the invalid free operation, use
    the following command:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 ASan 编译程序以检测无效释放操作，请使用以下命令：
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This command compiles the program with ASan enabled and suppresses the specific
    compiler warning about freeing non-heap objects. When you run the compiled program,
    ASan will detect and report the invalid free operation:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令以启用 ASan 并抑制关于释放非堆对象的特定编译器警告来编译程序。当你运行编译后的程序时，ASan 将检测并报告无效释放操作：
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The attempt to delete a pointer to a non-heap object, as shown in the example,
    is a misuse of memory management operations in C++. Such practices can lead to
    undefined behavior and can potentially cause crashes or other erratic program
    behavior. ASan serves as a valuable tool in detecting these kinds of errors, contributing
    significantly to the development of robust and error-free C++ applications.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如示例所示，尝试删除指向非堆对象的指针是 C++ 中内存管理操作的误用。这种做法可能导致未定义的行为，并可能引发崩溃或其他异常程序行为。ASan 作为一种宝贵的工具，在检测这类错误方面发挥了重要作用，对开发健壮且无错误的
    C++ 应用程序做出了重大贡献。
- en: Fine-tuning ASan for enhanced control
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**调整 ASan 以增强控制**'
- en: While ASan is a powerful tool for detecting memory errors in C++ programs, there
    are scenarios where its behavior needs to be fine-tuned. This fine-tuning is crucial
    for efficiently managing the analysis process, especially when dealing with complex
    projects that involve external libraries, legacy code, or specific code patterns.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 ASan 是检测 C++ 程序中内存错误的强大工具，但在某些情况下，其行为需要微调。这种微调对于有效地管理分析过程至关重要，尤其是在处理涉及外部库、遗留代码或特定代码模式的复杂项目时。
- en: '**Suppressing warnings from** **external libraries**'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**抑制来自外部库的警告**'
- en: In the context of many projects, the use of external libraries is a common practice.
    However, these libraries, over which you might not have control, can sometimes
    contain memory issues. When running tools such as ASan, these issues within the
    external libraries may get flagged, leading to cluttered diagnostics filled with
    warnings not directly relevant to your project’s code. This can be problematic
    as it may obscure the real issues within your own code base that need attention.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多项目的背景下，使用外部库是一种常见的做法。然而，这些你可能无法控制的库有时可能包含内存问题。当运行 ASan 等工具时，这些外部库中的问题可能会被标记出来，导致诊断信息中充满了与你的项目代码不直接相关的警告。这可能会成为问题，因为它可能会掩盖你自己的代码库中需要关注的真正问题。
- en: To mitigate this, ASan offers a useful feature that allows you to suppress warnings
    specifically coming from these external libraries. This ability to filter out
    irrelevant warnings is valuable in maintaining a clear focus on fixing issues
    that are within the scope of your own code base. The implementation of this feature
    typically involves the use of sanitizer special case lists or specifying certain
    linker flags during the compilation process. These mechanisms provide a means
    to tell ASan to ignore certain paths or patterns in the diagnostics, effectively
    reducing the noise from external sources and aiding in a more targeted and efficient
    debugging process.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减轻这种情况，ASan 提供了一个有用的功能，允许你抑制来自这些外部库的特定警告。这种过滤掉无关警告的能力对于专注于修复自己代码库范围内的问题非常有价值。该功能的实现通常涉及使用
    sanitizer 特殊情况列表或在编译过程中指定某些链接器标志。这些机制提供了一种方法，告诉 ASan 忽略某些路径或模式在诊断中的信息，从而有效地减少外部来源的噪音，并有助于更精确和高效的调试过程。
- en: '**Conditional compilation**'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**条件编译**'
- en: There are scenarios in software development where you might want to include
    specific segments of code only when compiling your program with ASan. This approach
    can be particularly useful for a variety of purposes, such as incorporating additional
    diagnostics or modifying memory allocations to make them more compatible or friendly
    with ASan’s operations.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发中，有些情况下你可能希望在编译程序时仅包含与 ASan 相关的特定代码段。这种方法在多种用途上特别有用，例如，整合额外的诊断信息或修改内存分配以使其更兼容或友好地与
    ASan 的操作。
- en: 'To implement this strategy, you can utilize conditional compilation, a technique
    that includes or excludes parts of the code based on certain conditions. In the
    case of ASan, you can check for its presence using the `__has_feature` macro.
    This macro evaluates at compile-time whether a particular feature (in this case,
    ASan) is available in the current compilation context. If ASan is being used,
    the code within the conditional compilation block will be included in the final
    executable; otherwise, it will be excluded:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这种策略，你可以利用条件编译技术，根据特定条件包含或排除代码的一部分。在 ASan 的情况下，你可以使用 `__has_feature` 宏来检查其是否存在。这个宏在编译时评估当前编译上下文中是否存在特定的功能（在这种情况下，即
    ASan）。如果正在使用 ASan，条件编译块中的代码将被包含在最终的可执行文件中；否则，它将被排除：
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This method of conditional compilation allows developers to tailor their code
    specifically for scenarios where ASan is in use, enhancing the effectiveness of
    the sanitizer and possibly avoiding issues that might arise only in its presence.
    It provides a flexible way to adjust the behavior of the program depending on
    the build configuration, which can be invaluable in complex development environments
    where different configurations are used for development, testing, and production
    stages.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这种条件编译的方法允许开发者针对 ASan 使用的情况专门调整他们的代码，从而提高清理器的有效性，并可能避免仅在 ASan 存在时出现的问题。它提供了一种灵活的方式来根据构建配置调整程序的行为，这在开发、测试和生产阶段使用不同配置的复杂开发环境中非常有价值。
- en: '**Disabling sanitizer for specific lines** **of code**'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**禁用特定代码行的清理器**'
- en: In the course of developing complex software, there are instances where certain
    operations might be intentionally performed, even though they could be flagged
    as errors by ASan. Alternatively, you might have segments of your code base that
    you wish to exclude from ASan’s analysis for specific reasons. This could be due
    to known benign behaviors in your code that ASan might misinterpret as errors,
    or parts of the code where the overhead introduced by ASan is not desirable.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发复杂软件的过程中，有时可能会故意执行某些操作，即使它们可能会被 ASan 标记为错误。或者，你可能希望出于特定原因将代码库的某些部分排除在 ASan
    的分析之外。这可能是由于你的代码中已知的好行为，ASan 可能会错误地将其解释为错误，或者由于 ASan 引入的开销不希望出现在某些代码部分。
- en: To address these scenarios, both GCC and Clang compilers provide a method to
    selectively disable ASan for particular functions or blocks of code. This is achieved
    through the use of the `__attribute__((no_sanitize(“address”)))` attribute. By
    applying this attribute to a function or a specific block of code, you can instruct
    the compiler to omit ASan instrumentation for that particular segment.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应对这些场景，GCC 和 Clang 编译器都提供了一种方法，可以针对特定的函数或代码块选择性地禁用 ASan。这是通过使用 `__attribute__((no_sanitize(“address”)))`
    属性来实现的。通过将此属性应用于函数或特定的代码块，你可以指示编译器省略该特定段落的 ASan 仪器设置。
- en: This feature is particularly useful as it allows for granular control over what
    parts of the code are subject to ASan’s scrutiny. It enables developers to fine-tune
    the balance between thorough error detection and the practical realities of their
    code’s behavior or performance requirements. By judiciously applying this attribute,
    you can ensure that ASan’s analysis is both effective and efficient, focusing
    its efforts where they are most beneficial.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性特别有用，因为它允许对代码的哪些部分受到 ASan 的审查进行细粒度控制。它使开发者能够微调彻底的错误检测与代码行为或性能要求的实际现实之间的平衡。通过审慎地应用此属性，你可以确保
    ASan 的分析既有效又高效，将精力集中在最有益的地方。
- en: '**Utilizing the sanitizer special** **case list**'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**利用清理器特殊案例列表**'
- en: '**Source files and functions (src and fun)**: ASan allows you to suppress error
    reports in specified source files or functions. This is particularly useful when
    you want to ignore certain known issues or third-party code.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**源文件和函数（src 和 fun）**：ASan 允许你在指定的源文件或函数中抑制错误报告。这在你想忽略某些已知问题或第三方代码时特别有用。'
- en: '**Globals and types (global and type)**: Additionally, ASan introduces the
    ability to suppress errors for out-of-bound access to globals with certain names
    and types. This feature is specifically handy for global variables and class/struct
    types, allowing more targeted error suppression.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局变量和类型（global 和 type）**：此外，ASan 引入了抑制对具有特定名称和类型的全局变量越界访问错误的能力。这个特性对于全局变量和类/结构体类型特别有用，允许更精确的错误抑制。'
- en: '**Example of a sanitizer special case** **list entry**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**清理器特殊案例列表的示例条目**'
- en: 'Fine-tuning ASan is an essential aspect of integrating it into a large-scale,
    complex development environment. It allows developers to customize the behavior
    of ASan to fit the specific needs of the project, be it by excluding external
    libraries, conditioning code for ASan builds, or ignoring certain errors to focus
    on more critical issues. By effectively utilizing these fine-tuning capabilities,
    teams can harness the full power of ASan to ensure robust and reliable C++ applications.
    The suppression rules can be set in a textual file as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 微调ASan是将其集成到大型、复杂开发环境中的关键方面。它允许开发者根据项目的具体需求自定义ASan的行为，无论是通过排除外部库、为ASan构建条件化代码，还是忽略某些错误以关注更关键的问题。通过有效利用这些微调能力，团队可以利用ASan的全部力量，确保C++应用程序的稳健和可靠。抑制规则可以按照以下方式设置在文本文件中：
- en: '[PRE25]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This file can then be passed to the runtime via the `ASAN_OPTIONS` environment
    variable, such as `ASAN_OPTIONS=suppressions=path/to/suppressionfile`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件可以通过`ASAN_OPTIONS`环境变量传递给运行时，例如`ASAN_OPTIONS=suppressions=path/to/suppressionfile`。
- en: Performance overhead of ASan
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ASan的性能开销
- en: The use of ASan in detecting memory management issues, such as invalid free
    operations, is highly beneficial in identifying and resolving potential bugs in
    C++ applications. However, it’s important to be aware of the performance implications
    of using ASan.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在检测内存管理问题，如无效的释放操作时，ASan的使用对于识别和解决C++应用程序中潜在的bug非常有益。然而，重要的是要意识到使用ASan的性能影响。
- en: '**Performance impact, limitations,** **and recommendations**'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**性能影响、限制和推荐**'
- en: Integrating ASan into the development and testing process brings with it a certain
    level of performance overhead. Typically, the slowdown introduced by ASan is in
    the region of 2x, meaning a program instrumented with ASan may run approximately
    twice as slowly compared to its non-instrumented version. This increased execution
    time is primarily due to the additional checks and monitoring that ASan performs
    to meticulously detect memory errors. Every memory access, along with each memory
    allocation and deallocation operation, is subject to these checks, inevitably
    resulting in additional CPU cycles being consumed.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 将ASan集成到开发和测试过程中会带来一定程度的性能开销。通常，ASan引入的减速在2倍左右，这意味着经过ASan工具化的程序可能比其非工具化版本慢大约两倍。这种增加的执行时间主要是由于ASan执行的额外检查和监控，以细致地检测内存错误。每次内存访问，以及每次内存分配和释放操作，都受到这些检查的影响，不可避免地导致额外的CPU周期消耗。
- en: 'Given this performance impact, ASan is predominantly utilized during the development
    and testing phases of the software life cycle. This usage pattern represents a
    trade-off: while there is a performance cost to using ASan, the benefits of catching
    and fixing critical memory-related errors early in the development process are
    significant. Early detection of such issues helps in maintaining code quality
    and can substantially reduce the time and resources required for debugging and
    fixing bugs later in the cycle.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种性能影响，ASan主要在软件生命周期的开发和测试阶段使用。这种使用模式代表了一种权衡：虽然使用ASan会有性能成本，但在开发早期阶段捕捉和修复关键内存相关错误的好处是显著的。早期发现这些问题有助于保持代码质量，并且可以显著减少在生命周期后期调试和修复bug所需的时间和资源。
- en: However, deploying ASan-instrumented binaries in a production environment is
    generally not recommended, especially in scenarios where performance is a critical
    factor. The overhead introduced by ASan can impact the application’s responsiveness
    and efficiency. That said, in certain contexts, particularly in applications where
    reliability and security are of paramount importance, and performance considerations
    are secondary, using ASan in a production-like environment for thorough testing
    might be justified. In such cases, the additional assurance of stability and security
    provided by ASan can outweigh the concerns regarding performance degradation.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在生产环境中部署经过ASan工具化的二进制文件通常不推荐，尤其是在性能是关键因素的场景中。ASan引入的开销可能会影响应用程序的响应性和效率。尽管如此，在某些情况下，尤其是在可靠性和安全性至关重要的应用程序中，并且性能考虑是次要的，为了彻底测试，在类似生产环境中使用ASan可能是合理的。在这种情况下，ASan提供的额外稳定性和安全性保障可能超过性能下降的担忧。
- en: 'ASan is supported on the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ASan支持以下平台：
- en: Linux i386/x86_64 (tested on Ubuntu 12.04)
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux i386/x86_64（在Ubuntu 12.04上测试）
- en: macOS 10.7 – 10.11 (i386/x86_64)
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: macOS 10.7 – 10.11 (i386/x86_64)
- en: iOS Simulator
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: iOS Simulator
- en: Android ARM
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android ARM
- en: NetBSD i386/x86_64
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NetBSD i386/x86_64
- en: FreeBSD i386/x86_64 (tested on FreeBSD 11-current)
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FreeBSD i386/x86_64（在FreeBSD 11-current上测试）
- en: Windows 8.1+ (i386/x86_64)
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows 8.1+ (i386/x86_64)
- en: LeakSanitizer (LSan)
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LeakSanitizer (LSan)
- en: '**LSan** is a dedicated memory leak detection tool that is part of the ASan
    suite but can also be used independently. It is specifically designed to identify
    memory leaks in C++ programs – situations where allocated memory is not freed,
    leading to increased memory consumption over time.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**LSan**是ASan套件的一部分的专用内存泄漏检测工具，也可以独立使用。它专门设计用于识别C++程序中的内存泄漏——即未释放分配的内存，导致内存消耗随时间增加。'
- en: Integration with ASan
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与ASan的集成
- en: LSan is often used in conjunction with ASan. When you enable ASan in your build,
    LSan is automatically enabled as well, providing a comprehensive analysis for
    both memory errors and leaks.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: LSan通常与ASan一起使用。当你在你的构建中启用ASan时，LSan也会自动启用，为内存错误和泄漏提供全面的分析。
- en: Standalone mode
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 独立模式
- en: If you wish to use LSan without ASan, you can enable it by compiling your program
    with the `-fsanitize=leak` flag. This is particularly useful when you want to
    focus solely on memory leak detection without the overhead of other address sanitizations.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望在不使用ASan的情况下使用LSan，可以通过编译程序时加上`-fsanitize=leak`标志来启用它。这在只想专注于内存泄漏检测而不想承受其他地址清理开销时特别有用。
- en: Example of memory leak detection
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内存泄漏检测示例
- en: 'Consider the following C++ code with a memory leak:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下具有内存泄漏的C++代码：
- en: '[PRE26]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this example, an array of integers is dynamically allocated and not freed,
    resulting in a memory leak.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，一个整数数组被动态分配但没有释放，导致内存泄漏。
- en: 'When you compile and run this code with LSan, the output might look something
    like this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用LSan编译并运行此代码时，输出可能看起来像这样：
- en: '[PRE27]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This output pinpoints the location and size of the memory leak, aiding in quick
    and effective debugging.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出指出了内存泄漏的位置和大小，有助于快速有效地进行调试。
- en: Platform support
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 平台支持
- en: As of the latest information available, LSan is supported on Linux, macOS, and
    Android. The support can vary based on the toolchain and the version of the compiler
    being used.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 根据最新信息，LSan支持Linux、macOS和Android。支持可能根据工具链和使用的编译器版本而有所不同。
- en: LSan is a valuable tool for C++ developers to identify and resolve memory leaks
    in their applications. Its ability to be used both in conjunction with ASan and
    in standalone mode offers flexibility in addressing specific memory-related issues.
    By integrating LSan into the development and testing process, developers can ensure
    more efficient memory usage and overall improved application stability.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: LSan是C++开发者识别和解决应用程序中内存泄漏的有价值工具。它能够与ASan一起使用，也可以独立使用，这为解决特定的内存相关问题提供了灵活性。通过将LSan集成到开发和测试过程中，开发者可以确保更有效的内存使用和整体的应用程序稳定性。
- en: MemorySanitizer (MSan)
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MemorySanitizer (MSan)
- en: '**MSan** is a dynamic analysis tool, part of the LLVM project, designed to
    detect the use of uninitialized memory in C++ programs. Uninitialized memory use
    is a common source of bugs that can lead to unpredictable behavior, security vulnerabilities,
    and difficult-to-diagnose errors.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**MSan**是一个动态分析工具，是LLVM项目的一部分，旨在检测C++程序中未初始化内存的使用。未初始化内存的使用是导致不可预测行为、安全漏洞和难以诊断的错误等常见错误的原因。'
- en: 'To use MSan, compile your program with the `-fsanitize=memory` flag. This instructs
    the compiler to instrument the code with checks for uninitialized memory usage.
    For example:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用MSan，请使用`-fsanitize=memory`标志编译你的程序。这指示编译器在代码中插入检查未初始化内存使用的检查。例如：
- en: '[PRE28]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Example code demonstrating uninitialized memory usage
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 展示未初始化内存使用的示例代码
- en: 'Consider the following simple C++ example:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下简单的C++示例：
- en: '[PRE29]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this code, the integers are allocated in the heap but not initialized.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，整数是在堆上分配的但未初始化。
- en: 'When compiled and run with MSan, the output might look like this:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当与MSan一起编译和运行时，输出可能看起来像这样：
- en: '[PRE30]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: MSan detects the use of the uninitialized variable and points to the exact location
    in the code where this occurs.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: MSan检测到未初始化变量的使用，并指向代码中发生此情况的精确位置。
- en: 'In this case, a fix can be as simple as initializing the array:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，修复可能只需要初始化数组：
- en: '[PRE31]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Fine-tuning, performance impact, and limitations
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 微调、性能影响和限制
- en: '**Fine-tuning**: MSan’s fine-tuning options are similar to those of ASan. Users
    can refer to the official documentation for detailed customization options.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微调**：MSan的微调选项与ASan类似。用户可以参考官方文档以获取详细的定制选项。'
- en: '**Performance impact**: Typically, using MSan introduces a runtime slowdown
    of about 3x. This overhead is due to the additional checks that MSan performs
    to detect uses of uninitialized memory.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能影响**：通常，使用 MSan 会引入大约 3 倍的运行时减速。这种开销是由于 MSan 执行的额外检查，以检测未初始化内存的使用。'
- en: '**Supported platforms**: MSan is supported on Linux, NetBSD, and FreeBSD. Its
    effectiveness in detecting uninitialized memory usage makes it a powerful tool
    for developers working on these platforms.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持的平台**：MSan 支持 Linux、NetBSD 和 FreeBSD。它在检测未初始化内存使用方面的有效性使其成为在这些平台上工作的开发人员的强大工具。'
- en: '**Limitations**: As with other sanitizers, MSan’s runtime overhead makes it
    most suitable for use in testing environments rather than in production. Additionally,
    MSan requires that the entire program, including all libraries it uses, be instrumented.
    This can be a limitation in cases where source code for certain libraries is not
    available.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**局限性**：与其他清理器一样，MSan 的运行时开销使其最适合用于测试环境，而不是生产环境。此外，MSan 要求整个程序（包括它使用的所有库）都进行仪器化。在无法获得某些库的源代码的情况下，这可能是一个限制。'
- en: MSan is an essential tool for detecting the elusive but potentially critical
    issue of uninitialized memory usage in C++ programs. By providing detailed reports
    on where and how such issues occur, MSan enables developers to identify and fix
    these errors, significantly improving the reliability and security of their applications.
    Integrating MSan into the development and testing phases, despite its performance
    impact, is a prudent step toward ensuring robust software quality.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: MSan 是检测 C++ 程序中难以捉摸但可能至关重要的未初始化内存使用问题的基本工具。通过提供关于此类问题发生位置和方式的详细报告，MSan 使开发人员能够识别和修复这些错误，显著提高其应用程序的可靠性和安全性。尽管其性能影响，但将
    MSan 集成到开发和测试阶段，是一个谨慎的步骤，以确保稳健的软件质量。
- en: TSan
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TSan
- en: In the realm of C++ programming, effectively managing concurrency and multithreading
    is both vital and challenging. Thread-related issues, particularly data races,
    are notoriously difficult to detect and debug. Unlike other bugs that can often
    be uncovered through deterministic testing methods such as unit tests, threading
    issues are elusive and non-deterministic in nature. They may not manifest under
    every run of a program, leading to unpredictable and erratic behavior that can
    be extremely hard to replicate and diagnose.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 编程领域，有效地管理并发和多线程既是关键也是挑战。与线程相关的问题，尤其是数据竞争，臭名昭著地难以检测和调试。与其他可以通过确定性测试方法（如单元测试）发现的错误不同，线程问题本质上是难以捉摸和非确定性的。这些问题可能不会在程序的每次运行中都表现出来，导致不可预测和混乱的行为，这可能非常难以复制和诊断。
- en: The complexity of thread-related issues
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 线程相关问题的复杂性
- en: '**Non-deterministic behavior**: Concurrency issues, including data races, deadlocks,
    and thread leaks, are inherently non-deterministic. This means that they do not
    consistently reproduce under the same conditions, making them elusive and unpredictable.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非确定性行为**：包括数据竞争、死锁和线程泄漏在内的并发问题本质上是非确定性的。这意味着它们在相同条件下并不一致地重现，使它们难以捉摸和不可预测。'
- en: '**Challenges in detection**: Traditional testing methods, including comprehensive
    unit tests, often fail to detect these issues. The outcome of a test involving
    concurrency can vary from one execution to another, depending on factors such
    as timing, thread scheduling, and system load.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检测挑战**：传统的测试方法，包括全面的单元测试，往往无法检测到这些问题。涉及并发的测试结果可能会因时间、线程调度和系统负载等因素而有所不同。'
- en: '**Subtle and severe bugs**: Thread-related bugs can remain dormant, only to
    surface in production under specific conditions, potentially leading to severe
    implications such as data corruption, performance degradation, and system crashes.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微妙且严重的错误**：与线程相关的错误可能处于休眠状态，仅在特定条件下在生产环境中出现，可能导致严重的影响，如数据损坏、性能下降和系统崩溃。'
- en: The necessity of TSan
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TSan 的必要性
- en: Given the inherent challenges in managing concurrency in C++, tools such as
    TSan provided by Clang and GCC become essential. TSan is a sophisticated tool
    designed to detect threading issues, with a particular focus on data races.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 C++ 中管理并发的固有挑战，Clang 和 GCC 提供的 TSan 等工具变得至关重要。TSan 是一个旨在检测线程问题的复杂工具，特别关注数据竞争。
- en: Enabling TSan
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启用 TSan
- en: '`-fsanitize=thread` flag. This instructs Clang and GCC to instrument your code
    for runtime detection of threading issues.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-fsanitize=thread` 标志。这指示 Clang 和 GCC 为运行时检测线程问题对你的代码进行仪器化。'
- en: '**Compilation example**:'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编译示例**：'
- en: '[PRE32]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This command will compile `your_file.cpp` with TSan enabled, ready to detect
    and report threading issues. Note that it is impossible to turn on both thread
    and ASans at the same time.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将使用TSan启用编译`your_file.cpp`，以便检测和报告线程问题。请注意，无法同时开启线程和ASan。
- en: Example of a data race in C++
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C++中的数据竞争示例
- en: 'Consider this simple yet illustrative example:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个简单但具有说明性的例子：
- en: '[PRE33]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, two threads modify the same shared resource without synchronization, leading
    to a data race.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，两个线程在不进行同步的情况下修改相同的共享资源，导致数据竞争。
- en: 'If we build and run this code with TSan enabled, we get the following output:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们启用TSan并构建和运行此代码，我们将得到以下输出：
- en: '[PRE34]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This output from TSan indicates a data race condition in a C++ program. Let’s
    break down the key elements of this report to understand what it’s telling us:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: TSan的此输出表明C++程序中存在数据竞争条件。让我们分析此报告的关键元素，以了解它告诉我们什么：
- en: '`WARNING: ThreadSanitizer:` `data race`).'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WARNING: ThreadSanitizer:` `data race`）。'
- en: '`0x555fd304f154` memory address, which is identified as a global `shared_counter`
    variable.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0x555fd304f154`内存地址，被识别为全局`shared_counter`变量。'
- en: '`increment_counter() /home/user/clang-sanitizers/main.cpp:8`. This means the
    data race read happens in the `increment_counter` function, specifically at *line
    8* of `main.cpp`.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`increment_counter() /home/user/clang-sanitizers/main.cpp:8`。这意味着数据竞争读取发生在`increment_counter`函数中，具体在`main.cpp`的第*8*行。'
- en: The report also provides a stack trace leading up to this read, showing the
    sequence of function calls.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 报告还提供了导致此读取的堆栈跟踪，显示了函数调用的序列。
- en: '`increment_counter` function at *line 8* of `main.cpp`.*   `main.cpp` at *lines
    13* and *14*, respectively). This helps in understanding the program’s flow leading
    to the data race.*   `SUMMARY: ThreadSanitizer: data race /home/user/clang-sanitizers/main.cpp:8`
    `in increment_counter()`.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`increment_counter`函数位于`main.cpp`的第*8*行。*   `main.cpp`在第*13*和*14*行，分别)。这有助于理解导致数据竞争的程序流程。*   `SUMMARY:
    ThreadSanitizer: data race /home/user/clang-sanitizers/main.cpp:8` `in increment_counter()`。'
- en: This concisely points to the function and file where the data race is detected.
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这简要指出了检测到数据竞争的函数和文件。
- en: Fine-tuning, performance impact, limitations, and recommendations for TSan
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TSan的微调、性能影响、限制和建议
- en: TSan typically introduces a runtime slowdown of approximately 5x-15x. This significant
    increase in execution time is due to the comprehensive checks performed by TSan
    to detect data races and other threading issues. Along with the slowdown, TSan
    also increases memory usage, generally by about 5x-10x. This overhead arises from
    the additional data structures TSan uses to monitor thread interactions and identify
    potential race conditions.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: TSan通常引入大约5x-15x的运行时减速。这种显著的执行时间增加是由于TSan执行的综合检查，以检测数据竞争和其他线程问题。除了减速外，TSan还增加了内存使用，通常约为5x-10x。这种开销是由于TSan使用的额外数据结构来监控线程交互和识别潜在的竞争条件。
- en: 'This list outlines the limitations and current state of TSan:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表概述了TSan的限制和当前状态：
- en: '**Beta stage**: TSan is currently in the beta stage. While it has been effective
    in large C++ programs using pthreads, there is no guarantee of its effectiveness
    for every scenario.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Beta阶段**：TSan目前处于Beta阶段。虽然它在使用pthread的大C++程序中已经有效，但无法保证其在每个场景中的有效性。'
- en: '**Supported threading models**: TSan supports C++11 threading when compiled
    with llvm’s libc++. This compatibility includes the threading features introduced
    with the C++11 standard.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持的线程模型**：当使用llvm的libc++编译时，TSan支持C++11线程。这种兼容性包括C++11标准引入的线程功能。'
- en: 'TSan is supported by several operating systems and architectures:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: TSan由多个操作系统和架构支持：
- en: '**Android**: aarch64, x86_64'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Android**：aarch64, x86_64'
- en: '**Darwin (macOS)**: arm64, x86_64'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Darwin (macOS)**：arm64, x86_64'
- en: FreeBSD
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FreeBSD
- en: '**Linux**: aarch64, x86_64, powerpc64, powerpc64le'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Linux**：aarch64, x86_64, powerpc64, powerpc64le'
- en: NetBSD
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NetBSD
- en: Support is mainly focused on 64-bit architectures. The support for 32-bit platforms
    is problematic and not planned.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 主要支持64位架构。对32位平台的支持存在问题，且未计划支持。
- en: Fine-tuning TSan
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 微调TSan
- en: The fine-tuning of TSan is very similar to that of ASan. Users interested in
    detailed fine-tuning options can refer to the official documentation, which provides
    comprehensive guidance on customizing TSan’s behavior to suit specific needs and
    scenarios.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: TSan的微调与ASan的微调非常相似。对详细微调选项感兴趣的用户可以参考官方文档，该文档提供了全面指导，以定制TSan的行为以满足特定需求和场景。
- en: Recommendations for using TSan
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用TSan的建议
- en: Due to the overhead in performance and memory, TSan is ideally used during the
    development and testing phases of a project. Its use in production environments
    should be carefully evaluated against the performance requirements. TSan is particularly
    useful in projects with significant multithreaded components, where the likelihood
    of data races and threading issues is higher. Incorporating TSan into **continuous
    integration** (**CI**) pipelines can help catch threading issues early in the
    development cycle, reducing the risk of these bugs making it into production.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 由于性能和内存开销，TSan 最好在项目的开发和测试阶段使用。在评估性能要求时，应谨慎考虑其在生产环境中的使用。TSan 特别适用于具有大量多线程组件的项目，其中数据竞争和线程问题的可能性更高。将
    TSan 集成到 **持续集成**（**CI**）管道中可以帮助在开发周期早期捕获线程问题，从而降低这些错误进入生产的风险。
- en: TSan is a critical tool for developers dealing with the complexities of concurrency
    in C++. It provides an invaluable service in detecting elusive threading issues
    that traditional testing methods often miss. By integrating TSan into the development
    and testing process, developers can significantly enhance the reliability and
    stability of their multithreaded C++ applications.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: TSan 是处理 C++ 中并发复杂性的开发者的关键工具。它提供了在检测传统测试方法往往忽略的难以捉摸的线程问题时无价的服务。通过将 TSan 集成到开发和测试过程中，开发者可以显著提高其多线程
    C++ 应用程序的可靠性和稳定性。
- en: UBSan
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UBSan
- en: UBSan is a dynamic analysis tool designed to detect undefined behavior in C++
    programs. Undefined behavior, as defined by the C++ standard, refers to code whose
    behavior is not prescribed, leading to unpredictable program execution. This can
    include issues such as integer overflow, division by zero, or misuse of null pointers.
    Undefined behavior can cause erratic program behavior, crashes, and security vulnerabilities.
    However, it is often used by compiler developers to optimize code. UBSan is crucial
    for identifying these problems, which are often subtle and hard to detect through
    standard testing but can cause significant issues in software reliability and
    security.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: UBSan 是一种动态分析工具，旨在检测 C++ 程序中的未定义行为。根据 C++ 标准，未定义行为是指其行为未规定的代码，导致程序执行不可预测。这可能包括整数溢出、除以零或对空指针的误用等问题。未定义行为可能导致程序行为异常、崩溃和安全漏洞。然而，它通常被编译器开发者用于优化代码。UBSan
    对于识别这些问题至关重要，这些问题通常很微妙且难以通过标准测试检测到，但可能在软件可靠性和安全性方面引起重大问题。
- en: Configuring UBSan
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置 UBSan
- en: To use UBSan, compile your program with the `-fsanitize=undefined` flag. This
    instructs the compiler to instrument the code with checks for various forms of
    undefined behavior. These commands compile the program with UBSan enabled using
    either Clang or GCC.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 UBSan，请使用 `-fsanitize=undefined` 标志编译您的程序。这指示编译器使用对各种形式的未定义行为的检查来对代码进行操作。这些命令使用
    Clang 或 GCC 启用 UBSan 编译程序。
- en: Example code demonstrating undefined behavior
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 展示未定义行为的示例代码
- en: 'Consider this simple example:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个简单的例子：
- en: '[PRE35]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In this code, attempting to divide by zero (`10 / x`) is an instance of undefined
    behavior.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，尝试除以零（`10 / x`）是未定义行为的实例。
- en: 'When compiled and run with UBSan, the output might include something like this:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 当与 UBSan 一起编译和运行时，输出可能包括如下内容：
- en: '[PRE36]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: UBSan detects the division by zero and reports the exact location in the code
    where this occurs.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: UBSan 检测到除以零，并报告代码中发生此情况的精确位置。
- en: Fine-tuning, performance impact, and limitations
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 微调、性能影响和限制
- en: '**Fine-tuning**: UBSan provides various options to control its behavior, allowing
    developers to focus on specific kinds of undefined behavior. Users interested
    in detailed customization can refer to the official documentation.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微调**：UBSan 提供了各种选项来控制其行为，允许开发者专注于特定类型的未定义行为。对详细定制感兴趣的用户可以参考官方文档。'
- en: '**Performance impact**: The runtime performance impact of UBSan is generally
    lower compared to tools such as ASan and TSan, but it can vary depending on the
    types of checks enabled. A typical slowdown is usually minimal.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能影响**：与 ASan 和 TSan 等工具相比，UBSan 的运行时性能影响通常较低，但会根据启用的检查类型而变化。典型的减速通常很小。'
- en: '**Supported platforms**: UBSan is supported on major platforms such as Linux,
    macOS, and Windows, making it widely accessible for C++ developers.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持的平台**：UBSan 支持主要平台，如 Linux、macOS 和 Windows，使其对 C++ 开发者广泛可用。'
- en: '**Limitations**: While UBSan is powerful in detecting undefined behavior, it
    cannot catch every instance, especially those that are highly dependent on specific
    program states or hardware configurations.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**局限性**：虽然 UBSan 在检测未定义行为方面非常强大，但它无法捕获每个实例，尤其是那些高度依赖于特定程序状态或硬件配置的实例。'
- en: UBSan is an invaluable tool for C++ developers, aiding in the early detection
    of subtle yet critical issues that can lead to unstable and insecure software.
    Its integration into the development and testing process is a proactive step towards
    ensuring the robustness and reliability of C++ applications. With its minimal
    performance impact and broad platform support, UBSan is a practical addition to
    any C++ developer’s toolkit.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: UBSan 是 C++ 开发者的无价之宝，有助于早期发现可能导致软件不稳定和不安全的微妙但关键问题。将其集成到开发和测试过程中是确保 C++ 应用程序健壮性和可靠性的主动步骤。由于其最小的性能影响和广泛的支持平台，UBSan
    是任何 C++ 开发者工具包的实用补充。
- en: Dynamic code analysis with Valgrind
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Valgrind 进行动态代码分析
- en: '**Valgrind** is a powerful tool for memory debugging, memory leak detection,
    and profiling. It is instrumental in identifying issues such as memory mismanagement
    and access errors, which are common in complex C++ programs. Unlike compiler-based
    tools such as Sanitizers, Valgrind works by running the program in a virtual-machine-like
    environment, checking for memory-related errors.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '**Valgrind** 是一个强大的内存调试、内存泄漏检测和性能分析工具。它在识别内存管理错误和访问错误等常见问题方面至关重要，这些问题在复杂的 C++
    程序中很常见。与基于编译器的工具（如 Sanitizers）不同，Valgrind 通过在类似虚拟机的环境中运行程序来检查内存相关错误。'
- en: Setting up Valgrind
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 Valgrind
- en: Valgrind can typically be installed from your system’s package manager. For
    example, on Ubuntu, you can install it using `sudo apt-get install valgrind`.
    To run a program under Valgrind, use the `valgrind ./your_program` command. This
    command executes your program within the Valgrind environment, where it performs
    its analysis. No special compilation flags are needed for basic memory checking
    with Valgrind, but including debugging symbols with `-g` can help make its output
    more useful.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: Valgrind 通常可以通过您的系统包管理器进行安装。例如，在 Ubuntu 上，您可以使用 `sudo apt-get install valgrind`
    命令进行安装。要在 Valgrind 下运行程序，请使用 `valgrind ./your_program` 命令。此命令在 Valgrind 环境中执行您的程序，并执行其分析。对于
    Valgrind 的基本内存检查，不需要特殊的编译标志，但包含调试符号（使用 `-g`）可以帮助使其输出更有用。
- en: Memcheck – the comprehensive memory debugger
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Memcheck – 全面的内存调试器
- en: '**Memcheck**, the core tool of the Valgrind suite, is a sophisticated memory
    debugger for C++ applications. It combines the functionality of address, memory,
    and LSans, providing a comprehensive analysis of memory usage. Memcheck detects
    memory-related errors such as the use of uninitialized memory, improper use of
    memory allocation and deallocation functions, and memory leaks.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '**Memcheck**，Valgrind 套件的核心工具，是一个针对 C++ 应用的复杂内存调试器。它结合了地址、内存和 LSans 的功能，提供了对内存使用的全面分析。Memcheck
    检测与内存相关的错误，例如使用未初始化的内存、不正确使用内存分配和释放函数以及内存泄漏。'
- en: 'To use Memcheck, no special compilation flags are needed, but compiling with
    debugging information (using `-g`) can enhance the usefulness of Memcheck’s reports.
    Execute your program with Valgrind by using the `valgrind ./your_program` command.
    For detecting memory leaks, add `--leak-check=full` for more detailed information.
    Here is an example command:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Memcheck，不需要特殊的编译标志，但使用带有调试信息（使用 `-g`）的编译可以增强 Memcheck 报告的有用性。通过使用 `valgrind
    ./your_program` 命令执行您的程序。对于检测内存泄漏，添加 `--leak-check=full` 以获取更详细的信息。以下是一个示例命令：
- en: '[PRE37]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Since Memcheck covers a wide range of memory-related issues, I am going to
    show only an example of detecting a memory leak since they are often the hardest
    to detect. Let us consider the following C++ code with a memory leak:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Memcheck 覆盖了广泛的内存相关问题，我将只展示检测内存泄漏的示例，因为它们通常是最难检测的。让我们考虑以下具有内存泄漏的 C++ 代码：
- en: '[PRE38]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Memcheck will detect and report the memory leak, indicating where the memory
    was allocated and that it was not freed:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: Memcheck 将检测并报告内存泄漏，指示内存是在哪里分配的以及它没有被释放：
- en: '[PRE39]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Performance impact, fine-tuning, and limitations
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 性能影响，微调和局限性
- en: It is important to remember that Memcheck can significantly slow down program
    execution, often by 10-30 times, and increase memory usage. This is due to the
    extensive checks performed on each memory operation.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，Memcheck 可以显著减慢程序执行速度，通常慢 10-30 倍，并增加内存使用。这是由于对每个内存操作进行的广泛检查。
- en: Memcheck offers several options to control its behavior. For example, `--track-origins=yes`
    can help find the sources of uninitialized memory use, although it may further
    slow down the analysis.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: Memcheck提供了几个选项来控制其行为。例如，`--track-origins=yes`可以帮助找到未初始化内存使用的来源，尽管这可能会进一步减慢分析速度。
- en: The main limitation of Memcheck is its performance overhead, which makes it
    unsuitable for production environments. Additionally, while it is thorough in
    memory leak detection, it may not catch every instance of uninitialized memory
    use, especially in complex scenarios or when specific compiler optimizations are
    applied.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: Memcheck的主要局限性是其性能开销，这使得它不适合生产环境。此外，尽管它在内存泄漏检测方面非常彻底，但它可能无法捕捉到所有未初始化内存使用的实例，尤其是在复杂场景或应用特定编译器优化时。
- en: Memcheck stands as a vital tool in the C++ developer’s toolkit for memory debugging.
    By providing a detailed analysis of memory errors and leaks, it plays a critical
    role in enhancing the reliability and correctness of C++ applications. Despite
    its performance overhead, Memcheck’s benefits in identifying and resolving memory
    issues make it indispensable for the development and testing phases of software
    development.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: Memcheck是C++开发者工具箱中用于内存调试的重要工具。通过提供对内存错误和泄漏的详细分析，它在提高C++应用程序的可靠性和正确性方面发挥着关键作用。尽管存在性能开销，但Memcheck在识别和解决内存问题方面的好处使其在软件开发的开发和测试阶段变得不可或缺。
- en: Helgrind – threading error detector
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Helgrind – 线程错误检测器
- en: '**Helgrind** is a tool within the Valgrind suite, specifically designed to
    detect synchronization errors in C++ multithreaded applications. It focuses on
    identifying race conditions, deadlocks, and misuses of the pthreads API. Helgrind
    operates by monitoring the interactions between threads, ensuring that shared
    resources are accessed safely and correctly. Its ability to detect threading errors
    makes it comparable to TSan but with a different underlying approach and usage.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '**Helgrind**是Valgrind套件中的一个工具，专门设计用于检测C++多线程应用程序中的同步错误。它专注于识别竞争条件、死锁和对pthreads
    API的误用。Helgrind通过监控线程之间的交互来运行，确保共享资源被安全且正确地访问。它检测线程错误的能力使其与TSan相当，但具有不同的底层方法和用法。'
- en: 'To use Helgrind, you do not need to recompile your program with special flags
    (although compiling with `-g` to include debugging symbols is recommended). Run
    your program with Valgrind using the `--tool=helgrind` option. Here is an example
    command:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Helgrind，你不需要用特殊标志重新编译你的程序（尽管建议使用`-g`标志来包含调试符号）。使用`--tool=helgrind`选项运行你的程序。以下是一个示例命令：
- en: '[PRE40]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let us consider the data race example that we analyzed before with TSan:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑我们之前用TSan分析过的数据竞争示例：
- en: '[PRE41]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Helgrind will detect and report the data race, showing where the threads are
    concurrently modifying `shared_counter` without proper synchronization. In addition
    to identifying data races, Helgrind’s output contains thread creation announcements,
    stack traces, and other details:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: Helgrind将检测并报告数据竞争，显示线程在没有适当同步的情况下并发修改`shared_counter`的位置。除了识别数据竞争外，Helgrind的输出还包含线程创建公告、堆栈跟踪和其他详细信息：
- en: '[PRE42]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Performance impact, fine-tuning, and limitations
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能影响、微调和局限性
- en: Using Helgrind can slow down your program execution significantly (often by
    20x or more) due to the detailed analysis of threading interactions. This makes
    it most suitable for testing environments. Helgrind provides several options to
    customize its behavior, such as controlling the level of checking or ignoring
    certain errors. The primary limitation is the performance overhead, making it
    impractical for use in production. Additionally, Helgrind may produce false positives,
    especially in complex threading scenarios or when using advanced synchronization
    primitives not fully understood by Helgrind.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Helgrind可能会显著减慢你的程序执行速度（通常慢20倍或更多），这是由于对线程交互的详细分析。这使得它最适合测试环境。Helgrind提供了几个选项来自定义其行为，例如控制检查级别或忽略某些错误。其主要局限性是性能开销，这使得它在生产中使用不切实际。此外，Helgrind可能会产生假阳性，尤其是在复杂的线程场景或使用Helgrind不完全理解的先进同步原语时。
- en: Helgrind is an essential tool for developers working with multithreaded C++
    applications, providing insights into challenging concurrency problems. It aids
    in creating more reliable and thread-safe applications by detecting and helping
    to resolve complex synchronization issues. While its use may be limited to development
    and testing phases due to performance overhead, the benefits it offers in enhancing
    the correctness of multithreaded code are invaluable.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: Helgrind 是开发多线程C++应用程序的开发者的重要工具，它提供了对具有挑战性的并发问题的见解。它通过检测和帮助解决复杂的同步问题，有助于创建更可靠和线程安全的应用程序。尽管由于其性能开销，其使用可能仅限于开发和测试阶段，但它为提高多线程代码的正确性提供的益处是无价的。
- en: Other notable tools in the Valgrind suite
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Valgrind套件中的其他知名工具
- en: In addition to Helgrind, the Valgrind suite includes several other tools, each
    with distinct functionalities catering to different aspects of program analysis
    and performance profiling.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Helgrind，Valgrind套件还包括其他几个工具，每个工具都有独特的功能，旨在满足程序分析和性能分析的不同方面。
- en: Data Race Detector (DRD) – a thread error detector
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据竞争检测器（DRD）- 线程错误检测器
- en: '**DRD** is another tool for detecting thread errors, similar to Helgrind. It
    focuses specifically on identifying data races in multithreaded programs. While
    both Helgrind and DRD are designed to detect threading issues, DRD is more optimized
    for detecting data races and generally has a lower performance overhead compared
    to Helgrind. DRD might produce fewer false positives in certain scenarios but
    may not be as thorough as Helgrind in detecting all kinds of synchronization errors.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '**DRD** 是另一个用于检测线程错误的工具，类似于Helgrind。它专注于在多线程程序中识别数据竞争。虽然Helgrind和DRD都旨在检测线程问题，但DRD在检测数据竞争方面进行了优化，通常比Helgrind具有更低的性能开销。在某些情况下，DRD可能产生较少的误报，但在检测所有类型的同步错误方面可能不如Helgrind彻底。'
- en: Cachegrind
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cachegrind
- en: '**Cachegrind** is a cache and branch-prediction profiler. It provides detailed
    information about how your program interacts with the computer’s cache hierarchy
    and the efficiency of branch prediction. This tool is invaluable for optimizing
    program performance, particularly in CPU-bound applications. It helps identify
    inefficient memory access patterns and areas of code that can benefit from optimization
    to improve cache utilization.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '**Cachegrind** 是一个缓存和分支预测分析器。它提供了关于您的程序如何与计算机的缓存层次结构交互以及分支预测效率的详细信息。这个工具对于优化程序性能非常有价值，尤其是在CPU密集型应用程序中。它有助于识别低效的内存访问模式以及可以通过优化来提高缓存利用率的代码区域。'
- en: Callgrind
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Callgrind
- en: '**Callgrind** extends the functionality of Cachegrind by adding call-graph
    generation capabilities. It records the call history among functions in a program,
    allowing developers to analyze the execution flow and identify performance bottlenecks.
    Callgrind is particularly useful for understanding the overall structure and interactions
    in complex applications.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '**Callgrind** 通过添加调用图生成功能扩展了Cachegrind的功能。它记录程序中函数之间的调用历史，使开发者能够分析执行流程并识别性能瓶颈。Callgrind特别适用于理解复杂应用程序的整体结构和交互。'
- en: Massif
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Massif
- en: Massif is a heap profiler that provides insights into a program’s memory usage.
    It helps developers understand and optimize memory consumption, track down memory
    leaks, and identify where and how memory allocation occurs within a program.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: Massif 是一个堆分析器，它提供了关于程序内存使用的见解。它帮助开发者理解和优化内存消耗，追踪内存泄漏，并确定程序中内存分配发生的位置和方式。
- en: Dynamic heap analysis tool (DHAT)
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态堆分析工具（DHAT）
- en: The **DHAT** is focused on profiling heap allocation patterns. It’s particularly
    useful for finding inefficient use of heap memory, such as excessive small allocations
    or short-lived allocations that could be optimized.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '**DHAT** 专注于分析堆分配模式。它特别适用于查找堆内存的低效使用，例如过多的微小分配或可能优化的小型短期分配。'
- en: Each tool in the Valgrind suite offers unique capabilities for analyzing different
    aspects of program performance and behavior. From threading issues to memory usage
    and CPU optimization, these tools provide a comprehensive set of functionalities
    for enhancing the efficiency, reliability, and correctness of C++ applications.
    Their integration into the development and testing process allows developers to
    gain deep insights into their code, leading to well-optimized and robust software
    solutions.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: Valgrind套件中的每个工具都提供了分析程序性能和行为不同方面的独特功能。从线程问题到内存使用和CPU优化，这些工具为增强C++应用程序的效率、可靠性和正确性提供了一套全面的函数。它们集成到开发和测试过程中，使开发者能够深入了解其代码，从而得到优化良好且稳健的软件解决方案。
- en: Summary
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Compiler-based sanitizers and Valgrind bring distinct advantages and challenges
    to the debugging and profiling process.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 基于编译器的清理器和Valgrind在调试和性能分析过程中带来了不同的优势和挑战。
- en: 'Compiler-based tools such as ASan, TSan, and UBSan are generally more accessible
    and easier to integrate into the development workflow. They are “cheaper” in terms
    of the performance overhead they introduce and are relatively straightforward
    to configure and use. These sanitizers are integrated directly into the compilation
    process, making them convenient for developers to employ regularly. Their primary
    advantage lies in their ability to provide immediate feedback during the development
    phase, catching errors and issues as the code is being written and tested. However,
    since these tools perform analysis during runtime, their effectiveness is directly
    tied to the extent of the test coverage. The more comprehensive the tests, the
    more effective the dynamic analysis, as only the executed code paths are analyzed.
    This aspect highlights the importance of thorough testing: the better the test
    coverage, the more issues these tools can potentially uncover.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 基于编译器的工具，如ASan、TSan和UBSan，通常更容易访问，并且更容易集成到开发工作流程中。在引入的性能开销方面，它们“更便宜”，配置和使用相对简单。这些清理器直接集成到编译过程中，使开发者能够经常使用它们。它们的主要优势在于能够在开发阶段提供即时反馈，在编写和测试代码时捕捉错误和问题。然而，由于这些工具在运行时进行分析，其有效性直接与测试覆盖范围的程度相关。测试越全面，动态分析就越有效，因为只有执行的代码路径才会被分析。这一点突出了彻底测试的重要性：测试覆盖范围越好，这些工具可以潜在地揭示的问题就越多。
- en: 'Valgrind, on the other hand, offers a more powerful and thorough analysis,
    capable of detecting a wider range of issues, particularly in memory management
    and threading. Its suite of tools – Memcheck, Helgrind, DRD, Cachegrind, Callgrind,
    Massif, and DHAT – provides a comprehensive analysis of various aspects of program
    performance and behavior. However, this power comes with a cost: Valgrind is generally
    more complex to use and introduces a significant performance overhead compared
    to compiler-based tools. The choice of whether to use Valgrind or a compiler-based
    sanitizer often depends on the specific needs of the project and the issues being
    targeted. While Valgrind’s extensive diagnostics offer deep insights into the
    program, the ease of use and lower performance cost of compiler-based sanitizers
    make them more suitable for regular use in a CI pipeline.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，Valgrind提供了更强大和彻底的分析，能够检测更广泛的问题，尤其是在内存管理和线程方面。其工具套件——Memcheck、Helgrind、DRD、Cachegrind、Callgrind、Massif和DHAT——对程序性能和行为的多方面进行了全面分析。然而，这种力量是有代价的：与基于编译器的工具相比，Valgrind通常更复杂，引入了显著的性能开销。是否使用Valgrind或基于编译器的清理器的选择通常取决于项目的具体需求和要解决的问题。虽然Valgrind的广泛诊断提供了对程序的深入洞察，但基于编译器的清理器的易用性和较低的性能成本使它们更适合在CI管道中常规使用。
- en: In summary, while both compiler-based tools and Valgrind have their place in
    the dynamic analysis landscape, their differences in diagnostics, ease of use,
    and performance impact make them suited to different stages and aspects of the
    software development process. Employing these tools as part of a regular CI pipeline
    is highly recommended, as it allows for the early detection and resolution of
    issues, contributing significantly to the overall quality and robustness of the
    software. The subsequent chapter will delve into tools for measuring test coverage,
    providing insights into how effectively the code base is being tested and thus
    complementing the dynamic analysis process.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，虽然基于编译器的工具和Valgrind在动态分析领域都有其位置，但它们在诊断、易用性和性能影响方面的差异使它们适合软件开发过程的各个阶段和方面。将它们作为常规持续集成（CI）管道的一部分使用是非常推荐的，因为它允许早期检测和解决问题，对软件的整体质量和鲁棒性贡献显著。下一章将深入探讨测量测试覆盖率的工具，提供关于代码库测试有效性的见解，从而补充动态分析过程。
