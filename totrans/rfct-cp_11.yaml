- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dynamic Analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the intricate world of software development, ensuring the correctness, efficiency,
    and security of code is not just a goal but a necessity. This is particularly
    true in C++ programming, where the power and complexity of the language present
    both opportunities and challenges. One of the most effective approaches to maintaining
    high code quality in C++ is **dynamic code analysis** – a process that scrutinizes
    program behavior as it runs to detect a range of potential issues.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic code analysis stands in contrast to static analysis, which examines
    source code without executing it. While static analysis is invaluable for catching
    syntax errors, code smells, and certain types of bugs early in the development
    cycle, dynamic analysis delves deeper. It uncovers issues that only manifest during
    the actual execution of the program, such as memory leaks, race conditions, and
    other runtime errors that can lead to crashes, erratic behavior, or security vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter aims to explore the landscape of dynamic code analysis tools in
    C++, with a particular focus on some of the most powerful and widely used tools
    in the industry: a suite of compiler-based sanitizers, including **AddressSanitizer**
    (**ASan**), **ThreadSanitizer** (**TSan**), and **UndefinedBehaviorSanitizer**
    (**UBSan**), as well as Valgrind, a versatile tool known for its thorough memory
    debugging capabilities.'
  prefs: []
  type: TYPE_NORMAL
- en: Compiler sanitizers, part of the LLVM project and GCC project, offer a range
    of options for dynamic analysis. ASan is remarkable for its ability to detect
    various memory-related errors, TSan excels in identifying race conditions in multi-threaded
    code, and UBSan helps in catching undefined behaviors that can lead to unpredictable
    program behavior. These tools are praised for their efficiency, precision, and
    ease of integration into existing development workflows. Most of them are supported
    by GCC and MSVC as well.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, Valgrind, an instrumentation framework for building dynamic
    analysis tools, shines with its comprehensive memory leak detection and the ability
    to analyze binary executables without requiring source code recompilation. It’s
    a go-to solution for complex scenarios where in-depth memory analysis is paramount,
    albeit at the cost of higher performance overhead.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, we will delve into each of these tools, understanding
    their strengths, weaknesses, and appropriate use cases. We’ll explore how they
    can be effectively integrated into your C++ development process, and how they
    complement each other to provide a robust framework for ensuring the quality and
    reliability of C++ applications.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a thorough understanding of dynamic
    code analysis in C++, equipped with the knowledge to choose and utilize the right
    tools for your specific development needs, ultimately leading to cleaner, more
    efficient, and reliable C++ code.
  prefs: []
  type: TYPE_NORMAL
- en: Compiler-based dynamic code analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Compiler-based sanitizers contain two parts: compiler instrumentation and runtime
    diagnostics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Compiler instrumentation**: When you compile your C++ code with sanitizers
    enabled, the compiler instruments the generated binary with additional checks.
    These checks are strategically inserted into the code to monitor for specific
    types of errors. For instance, ASan adds code to track memory allocations and
    accesses, enabling it to detect memory misuses such as buffer overflows and memory
    leaks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Runtime diagnostics**: As the instrumented program runs, these checks actively
    monitor the program’s behavior. When a sanitizer detects an error (such as a memory
    access violation or a data race), it immediately reports this, often with detailed
    information about the location and nature of the error. This real-time feedback
    is invaluable for identifying and fixing elusive bugs that might be difficult
    to catch through traditional testing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Despite all compiler teams constantly working on adding new sanitizers and
    improving the existing ones, there are still some limitations to the compiler-based
    sanitizers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Clang and GCC**: Most sanitizers, including ASan, TSan, and UBSan, are supported
    by both Clang and GCC. This wide support makes them accessible to a large portion
    of the C++ development community, regardless of the preferred compiler.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microsoft Visual C++ (MSVC)**: MSVC also supports some sanitizers, though
    the range and capabilities might differ from those in Clang and GCC. For example,
    MSVC has support for ASan, which is useful for Windows-specific C++ development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cross-platform utility**: The cross-compiler and cross-platform nature of
    these tools mean they can be used in a variety of development environments, from
    Linux and macOS to Windows, enhancing their utility in diverse C++ projects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ASan
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ASan is a runtime memory error detector, part of the LLVM compiler infrastructure,
    GCC, and MSVC. It serves as a specialized tool for developers to identify and
    resolve various kinds of memory-related errors, including, but not limited to,
    buffer overflows, dangling pointer accesses, and memory leaks. The tool achieves
    this by instrumenting the code during the compilation process, enabling it to
    monitor memory accesses and allocations at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: One of the key strengths of ASan is its ability to provide detailed error reports.
    When a memory error is detected, ASan outputs comprehensive information, including
    the type of error, the memory location involved, and the stack trace. This level
    of detail significantly aids in the debugging process, allowing developers to
    pinpoint the source of the issue quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating ASan into a C++ development workflow is straightforward. It requires
    minimal changes to the build process, typically involving the addition of a compiler
    flag (`-fsanitize=address`) during compilation. For better results, it makes sense
    to use reasonable performance adda`-O1` or higher. To get nicer stack traces in
    error messages, add `-fno-omit-frame-pointer`. This ease of integration, combined
    with its effectiveness in catching memory errors, makes ASan an indispensable
    tool for developers aiming to enhance the reliability and security of their C++
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Symbolizing reports in ASan
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When using ASan to detect memory errors in C++ applications, it’s crucial to
    symbolize the error reports. Symbolization translates memory addresses and offsets
    in ASan’s output into human-readable function names, file names, and line numbers.
    This process is vital for effective debugging, as it allows developers to easily
    identify where in the source code the memory error occurred.
  prefs: []
  type: TYPE_NORMAL
- en: Without symbolization, the ASan report provides less meaningful raw memory addresses,
    making it challenging to trace back to the exact location in the source code where
    the error happened. Symbolized reports, on the other hand, offer clear and actionable
    insights, enabling developers to quickly understand and fix the underlying issues
    in their code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The configuration of ASan symbolization is typically automatic, requiring no
    additional steps. However, in some cases, you might need to explicitly set the
    `ASAN_SYMBOLIZER_PATH` environment variable to point to the symbolizer tool. This
    is especially true on non-Linux Unix systems, where additional tools such as `addr2line`
    might be required for symbolization. If it does not work out of the box, please
    go over the following steps to ensure that symbolization is configured correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-g` flag to your compilation command. For instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compiling with `-g` includes debugging symbols in the binary, which are essential
    for symbolization.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`llvm-symbolizer` tool is in your system’s `PATH`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`addr2line` (part of GNU Binutils) can be used for symbolizing stack traces.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ASAN_SYMBOLIZER_PATH` environment variable to point to the symbolizer tool.
    For example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This explicitly tells ASan which symbolizer to use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Running** **your program**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run your compiled program as usual. If a memory error is detected, ASan will
    output a symbolized stack trace.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The report will include function names, file names, and line numbers, making
    it easier to locate and address the error in your code.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Out-of-bounds access
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let us try to catch one of the most critical errors of C++ programming: **out-of-bounds
    access**. This issue spans various segments of memory management – the heap, the
    stack, and global variables, each presenting unique challenges and risks.'
  prefs: []
  type: TYPE_NORMAL
- en: Out-of-bounds access on the heap
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We begin by exploring out-of-bounds access on the heap, where dynamic memory
    allocation can lead to pointers exceeding the allocated memory boundaries. Consider
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This code snippet demonstrates an out-of-bounds write, attempting to access
    an index that is beyond the allocated range, leading to undefined behavior and
    potential memory corruption.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run this code with ASan enabled, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the report includes a detailed stack trace, highlighting the
    exact location of the error in the source code. This information is invaluable
    for debugging and fixing the issue.
  prefs: []
  type: TYPE_NORMAL
- en: Out-of-bounds access on the stack
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we focus on the stack. Here, out-of-bounds accesses often occur with
    local variables due to incorrect indexing or buffer overruns. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, accessing `stackArray[5]` is out of bounds, as valid indices
    are from `0` to `4`. Such errors can result in crashes or exploitable vulnerabilities.
    The output of ASan for this example is very similar to the previous one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Out-of-bounds access to global variables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Finally, we examine global variables. These are susceptible to similar risks
    when accessed beyond their defined boundaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, the attempt to write to `globalArray[5]` is an out-of-bounds operation,
    leading to undefined behavior. Since the output of ASan is similar to the previous
    examples, we won’t include it here.
  prefs: []
  type: TYPE_NORMAL
- en: Addressing use-after-free vulnerabilities in C++
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the following section, we will address a critical and often challenging
    issue in C++ programming: **use-after-free vulnerabilities**. This type of error
    occurs when a program continues to use a memory location after it has been freed,
    leading to undefined behavior, program crashes, security vulnerabilities, and
    data corruption. We’ll explore this issue in various contexts, providing insights
    into its identification and prevention.'
  prefs: []
  type: TYPE_NORMAL
- en: Use-after-free in dynamic memory (heap)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The most common scenario for use-after-free errors occurs with dynamically
    allocated memory on the heap. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this snippet, the memory pointed to by `ptr` is accessed after it has been
    freed with `delete`. This access can lead to unpredictable behavior, as the freed
    memory might be allocated for other purposes or modified by the system.
  prefs: []
  type: TYPE_NORMAL
- en: Use-after-free with object references
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Use-after-free can also occur in object-oriented programming, especially when
    dealing with references or pointers to objects that have been destroyed. For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, `ref` refers to an object that has been deleted, and any operation on
    `ref` after the deletion leads to use-after-free.
  prefs: []
  type: TYPE_NORMAL
- en: Use-After-Free in Complex Data Structures
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Complex data structures, such as linked lists or trees, are also prone to use-after-free
    errors, particularly during deletion or restructuring operations. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `temp` is used after it has been freed, which can lead to serious
    issues, especially if the list is large or part of a critical system component.
  prefs: []
  type: TYPE_NORMAL
- en: 'ASan can help in detecting use-after-free errors in C++ programs. For instance,
    if we run the previous example with ASan enabled, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Use-after-return detection in ASan
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Use-after-return** is a type of memory error in C++ programming where a function
    returns a pointer or a reference to a local (stack-allocated) variable. This local
    variable ceases to exist once the function returns, making any subsequent access
    through the returned pointer or reference invalid and dangerous. This can lead
    to undefined behavior and potential security vulnerabilities.'
  prefs: []
  type: TYPE_NORMAL
- en: ASan provides a mechanism to detect use-after-return errors. It can be controlled
    using the `-fsanitize-address-use-after-return` flag during compilation and the
    `ASAN_OPTIONS` environment variable at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following describes the configuration of use-after-return detection:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-fsanitize-address-use-after-return=(never|``runtime|always)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The flag accepts three settings:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`never`: This disables use-after-return detection'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`runtime`: This enables detection, but it can be overridden at runtime (default
    setting)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`always`: This always enables detection, irrespective of runtime settings'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ASAN_OPTIONS` environment variable:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ASAN_OPTIONS=detect_stack_use_after_return=1`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ASAN_OPTIONS=detect_stack_use_after_return=0`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: On Linux, detection is enabled by default
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of its usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Compiling with use-after-return** **detection enabled**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This command compiles `your_file.cpp` with ASan and explicitly enables use-after-return
    detection.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Running with** **detection enabled/disabled**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To run the program with use-after-return detection enabled (on platforms where
    it’s not the default):'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'To disable detection, even if it was enabled at compile time:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '**Example code** **demonstrating use-after-return**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The provided C++ code example demonstrates a use-after-return scenario, which
    is a type of undefined behavior caused by returning a reference to a local variable
    from a function. Let’s analyze the example and understand the implications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the given code example, the `get_binary_name` function is designed to create
    a local `std::string` object named `name` and return a reference to it. The critical
    issue arises from the fact that `name` is a local variable, which gets destroyed
    as soon as the function scope ends. As a result, the reference that `get_binary_name`
    returns becomes invalid the moment the function exits.
  prefs: []
  type: TYPE_NORMAL
- en: In the `main` function, this returned reference, now stored in `name`, is used
    to access the string value. However, since `name` refers to a local variable that
    has already been destroyed, using it in this manner leads to undefined behavior.
    This is a classic example of a use-after-return error, where the program attempts
    to access memory that is no longer valid.
  prefs: []
  type: TYPE_NORMAL
- en: The function’s intended functionality seems to be to return the program’s name.
    However, for this to work correctly, the `name` variable should have a static
    or global lifetime rather than being a local variable confined to the `get_binary_name`
    function. This would ensure that the returned reference remains valid beyond the
    scope of the function, avoiding the use-after-return error.
  prefs: []
  type: TYPE_NORMAL
- en: Modern compilers are equipped with the ability to issue warnings about potentially
    problematic code patterns, such as returning references to local variables. In
    the context of our example, a compiler might flag the return of a local variable
    reference as a warning, signaling a possible use-after-return error.
  prefs: []
  type: TYPE_NORMAL
- en: However, to effectively demonstrate the capabilities of ASan in catching use-after-return
    errors, it’s sometimes necessary to bypass these compile-time warnings. This can
    be achieved by explicitly disabling the compiler’s warning. For instance, by adding
    the `-Wno-return-local-addr` flag to the compilation command, we can prevent the
    compiler from issuing a warning about returning a local address. Doing so allows
    us to shift the focus from compile-time detection to runtime detection, where
    ASan’s capabilities in identifying use-after-return errors can be more prominently
    displayed and tested. This approach underscores the runtime diagnostic strengths
    of ASan, particularly in cases where compile-time analysis might not be sufficient.
  prefs: []
  type: TYPE_NORMAL
- en: '**Compiling** **with ASan**'
  prefs: []
  type: TYPE_NORMAL
- en: 'To compile this program with ASan’s use-after-return detection enabled, you
    would use a command such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This command compiles the program with ASan enabled while suppressing the specific
    compiler warning about returning the address of a local variable. Running the
    compiled program will allow ASan to detect and report the use-after-return error
    at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This example highlights the importance of understanding object lifetimes in
    C++ and how misuse can lead to undefined behavior. While compiler warnings are
    valuable for catching such issues at compile time, tools such as ASan provide
    an additional layer of runtime error detection, which is especially useful in
    complex scenarios where compile-time analysis might not suffice.
  prefs: []
  type: TYPE_NORMAL
- en: Use-after-return detection
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The concept of use-after-scope in C++ involves accessing a variable after its
    scope has ended, leading to undefined behavior. This type of error is subtle and
    can be particularly challenging to detect and debug. ASan offers a feature to
    detect use-after-scope errors, which can be enabled using the `-fsanitize-address-use-after-scope`
    compilation flag.
  prefs: []
  type: TYPE_NORMAL
- en: '**Understanding use-after-scope**'
  prefs: []
  type: TYPE_NORMAL
- en: Use-after-scope occurs when a program continues to use a pointer or reference
    to a variable that has gone out of scope. Unlike use-after-return, where the issue
    is with function-local variables, use-after-scope can occur within any scope,
    such as within a block of code, such as an `if` statement or a loop.
  prefs: []
  type: TYPE_NORMAL
- en: When a variable goes out of scope, its memory location may still hold the old
    data for some time, but this memory can be overwritten at any moment. Accessing
    this memory is undefined behavior and can lead to erratic program behavior or
    crashes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Configuring ASan for** **use-after-scope detection**'
  prefs: []
  type: TYPE_NORMAL
- en: '`-fsanitize-address-use-after-scope`:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding this flag to your compilation command instructs ASan to instrument the
    code to detect use-after-scope errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s important to note that this detection is not enabled by default and must
    be explicitly enabled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Example code** **demonstrating use-after-scope**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The provided code snippet demonstrates a classic case of use-after-scope error
    in C++. Let’s analyze the code and understand the issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the given code snippet, we begin by declaring a `p` pointer without initializing
    it. The function then enters a conditional scope where, if `condition` is true,
    an `x[10]` array is created on the stack. Within this scope, the `p` pointer is
    assigned to point to the start of this array, effectively making `p` point to
    `x`.
  prefs: []
  type: TYPE_NORMAL
- en: The critical issue arises after the conditional block is exited. At this point,
    the `x` array, being local to the `if` block, goes out of scope and is no longer
    valid. However, the `p` pointer still holds the address of where `x` was located.
    When the code attempts to write to this memory location using `*p = 1;`, it is
    trying to access the memory of the now out-of-scope `x` array. This action leads
    to a use-after-scope error, where `p` is dereferenced to access memory that is
    no longer valid within the current scope. This kind of error is a classic example
    of use-after-scope, highlighting the dangers of accessing memory through pointers
    that point to out-of-scope variables.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing memory through a pointer that points to an out-of-scope variable,
    as demonstrated in the provided code snippet, leads to undefined behavior. This
    is because once the `x` variable goes out of scope, the memory location to which
    `p` points becomes indeterminate. The undefined behavior arising from this scenario
    is problematic for several reasons.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, it poses significant security and stability risks to the program. The
    undefined nature of the behavior means that the program could crash or behave
    unpredictably. Such instability in a program’s execution can have far-reaching
    consequences, particularly in applications where reliability is critical. Furthermore,
    if the memory location previously occupied by `x` gets overwritten by other parts
    of the program, it could potentially lead to security vulnerabilities. These vulnerabilities
    might be exploited to compromise the program or the system on which it is running.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, the undefined behavior resulting from accessing memory through pointers
    to out-of-scope variables is a serious concern in software development, necessitating
    careful management of variable scope and memory access patterns to ensure the
    security and stability of the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'To compile the program with ASan’s use-after-scope detection enabled, you would
    use a command such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Running the compiled program with these settings enables ASan to detect and
    report use-after-scope errors at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Use-after-scope errors can be insidious and difficult to trace due to their
    dependence on the program’s runtime state and memory layout. By enabling use-after-scope
    detection in ASan, developers gain a valuable tool for identifying these errors,
    leading to more robust and reliable C++ applications. Understanding and preventing
    such issues is crucial for writing safe and correct C++ code.
  prefs: []
  type: TYPE_NORMAL
- en: Double-free and invalid-free checks in ASan
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'ASan, a part of the LLVM project, provides robust mechanisms to detect and
    diagnose two critical types of memory errors in C++ programs: double free and
    invalid free. These errors are not only common in complex C++ applications but
    can also lead to severe issues such as program crashes, undefined behavior, and
    security vulnerabilities.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Understanding double free and** **invalid free**'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding double-free and invalid-free errors is essential in managing memory
    in C++ programs effectively.
  prefs: []
  type: TYPE_NORMAL
- en: A double-free error occurs when an attempt is made to free a memory block more
    than once using the `delete` or `delete[]` operators. This typically happens when
    the same memory allocation is passed to `delete` or `delete[]` twice. The first
    call to `delete` frees the memory, but the second call attempts to free memory
    that has already been released. This can lead to heap corruption, as the program
    might subsequently modify or reallocate the freed memory for other uses. Double-free
    errors can cause unpredictable behavior in your program, including crashes and
    data corruption.
  prefs: []
  type: TYPE_NORMAL
- en: Invalid-free errors, on the other hand, occur when `delete` or `delete[]` is
    used on a pointer that wasn’t allocated with `new` or `new[]`, or that has already
    been freed. This category includes attempts to free a null pointer, pointers to
    stack memory (which are not dynamically allocated), or pointers to uninitialized
    memory. Like double-free errors, invalid frees can also lead to heap corruption
    and unpredictable program behavior. They are particularly insidious because they
    can corrupt the memory management structures of the C++ runtime, leading to subtle
    and hard-to-diagnose bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Both of these errors stem from improper handling of dynamic memory, underscoring
    the importance of adhering to best practices in memory management, such as ensuring
    every `new` has a corresponding `delete` and avoiding the reuse of pointers after
    they have been freed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This list outlines the features of ASan’s detection mechanism:'
  prefs: []
  type: TYPE_NORMAL
- en: '`delete` operation is performed, ASan checks whether the pointer corresponds
    to a valid, previously allocated, and not-yet-freed memory block.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error reporting**: If a double-free or invalid-free error is detected, ASan
    aborts the program’s execution and provides a detailed error report. This report
    includes the location in the code where the error occurred, the memory address
    involved, and the allocation history of that memory (if available).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is some example code demonstrating double-free errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'ASan would report the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the same memory pointed to by `ptr` is freed twice, leading
    to a double-free error.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example code demonstrating** **invalid free**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The provided code snippet demonstrates an invalid-free error, which is a type
    of memory management mistake that can occur in C++ programming. Let’s dissect
    the example to understand the issue and its implications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In a given code segment, we start by declaring and initializing a local `int
    local_var = 42;` variable. This creates a stack-allocated integer variable named
    `local_var`. Following this, a pointer assignment is made with `int* ptr = &local_var;`,
    where the `ptr` pointer is set to point to the address of `local_var`. This establishes
    a link between the pointer and the stack-allocated variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, an issue arises with the subsequent operation: `delete ptr;`. This
    line of code attempts to free the memory pointed to by `ptr`. The problem here
    is that `ptr` is pointing to a stack-allocated variable, `local_var`, rather than
    a dynamically allocated piece of memory from the heap. In C++, the `delete` operator
    is intended to be used exclusively with pointers that have been allocated with
    `new`. Since `local_var` was not allocated with `new` (being a stack-allocated
    variable), using `delete` on `ptr` is invalid and leads to undefined behavior.
    This misuse of the `delete` operator on a non-heap pointer is a common mistake
    that can lead to serious runtime errors in a C++ program.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some modern compiler warnings:'
  prefs: []
  type: TYPE_NORMAL
- en: Modern C++ compilers typically issue warnings or errors when `delete` is used
    on a pointer that doesn’t point to dynamically allocated memory, as this is a
    common source of bugs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To compile this code without modification and demonstrate ASan’s ability to
    catch such errors, you might need to suppress the compiler warning. This can be
    done by adding the `-Wno-free-nonheap-object` flag to the compilation command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compiling with ASan for** **invalid-free detection**'
  prefs: []
  type: TYPE_NORMAL
- en: 'To compile the program with ASan to detect the invalid free operation, use
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This command compiles the program with ASan enabled and suppresses the specific
    compiler warning about freeing non-heap objects. When you run the compiled program,
    ASan will detect and report the invalid free operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The attempt to delete a pointer to a non-heap object, as shown in the example,
    is a misuse of memory management operations in C++. Such practices can lead to
    undefined behavior and can potentially cause crashes or other erratic program
    behavior. ASan serves as a valuable tool in detecting these kinds of errors, contributing
    significantly to the development of robust and error-free C++ applications.
  prefs: []
  type: TYPE_NORMAL
- en: Fine-tuning ASan for enhanced control
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: While ASan is a powerful tool for detecting memory errors in C++ programs, there
    are scenarios where its behavior needs to be fine-tuned. This fine-tuning is crucial
    for efficiently managing the analysis process, especially when dealing with complex
    projects that involve external libraries, legacy code, or specific code patterns.
  prefs: []
  type: TYPE_NORMAL
- en: '**Suppressing warnings from** **external libraries**'
  prefs: []
  type: TYPE_NORMAL
- en: In the context of many projects, the use of external libraries is a common practice.
    However, these libraries, over which you might not have control, can sometimes
    contain memory issues. When running tools such as ASan, these issues within the
    external libraries may get flagged, leading to cluttered diagnostics filled with
    warnings not directly relevant to your project’s code. This can be problematic
    as it may obscure the real issues within your own code base that need attention.
  prefs: []
  type: TYPE_NORMAL
- en: To mitigate this, ASan offers a useful feature that allows you to suppress warnings
    specifically coming from these external libraries. This ability to filter out
    irrelevant warnings is valuable in maintaining a clear focus on fixing issues
    that are within the scope of your own code base. The implementation of this feature
    typically involves the use of sanitizer special case lists or specifying certain
    linker flags during the compilation process. These mechanisms provide a means
    to tell ASan to ignore certain paths or patterns in the diagnostics, effectively
    reducing the noise from external sources and aiding in a more targeted and efficient
    debugging process.
  prefs: []
  type: TYPE_NORMAL
- en: '**Conditional compilation**'
  prefs: []
  type: TYPE_NORMAL
- en: There are scenarios in software development where you might want to include
    specific segments of code only when compiling your program with ASan. This approach
    can be particularly useful for a variety of purposes, such as incorporating additional
    diagnostics or modifying memory allocations to make them more compatible or friendly
    with ASan’s operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement this strategy, you can utilize conditional compilation, a technique
    that includes or excludes parts of the code based on certain conditions. In the
    case of ASan, you can check for its presence using the `__has_feature` macro.
    This macro evaluates at compile-time whether a particular feature (in this case,
    ASan) is available in the current compilation context. If ASan is being used,
    the code within the conditional compilation block will be included in the final
    executable; otherwise, it will be excluded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This method of conditional compilation allows developers to tailor their code
    specifically for scenarios where ASan is in use, enhancing the effectiveness of
    the sanitizer and possibly avoiding issues that might arise only in its presence.
    It provides a flexible way to adjust the behavior of the program depending on
    the build configuration, which can be invaluable in complex development environments
    where different configurations are used for development, testing, and production
    stages.
  prefs: []
  type: TYPE_NORMAL
- en: '**Disabling sanitizer for specific lines** **of code**'
  prefs: []
  type: TYPE_NORMAL
- en: In the course of developing complex software, there are instances where certain
    operations might be intentionally performed, even though they could be flagged
    as errors by ASan. Alternatively, you might have segments of your code base that
    you wish to exclude from ASan’s analysis for specific reasons. This could be due
    to known benign behaviors in your code that ASan might misinterpret as errors,
    or parts of the code where the overhead introduced by ASan is not desirable.
  prefs: []
  type: TYPE_NORMAL
- en: To address these scenarios, both GCC and Clang compilers provide a method to
    selectively disable ASan for particular functions or blocks of code. This is achieved
    through the use of the `__attribute__((no_sanitize(“address”)))` attribute. By
    applying this attribute to a function or a specific block of code, you can instruct
    the compiler to omit ASan instrumentation for that particular segment.
  prefs: []
  type: TYPE_NORMAL
- en: This feature is particularly useful as it allows for granular control over what
    parts of the code are subject to ASan’s scrutiny. It enables developers to fine-tune
    the balance between thorough error detection and the practical realities of their
    code’s behavior or performance requirements. By judiciously applying this attribute,
    you can ensure that ASan’s analysis is both effective and efficient, focusing
    its efforts where they are most beneficial.
  prefs: []
  type: TYPE_NORMAL
- en: '**Utilizing the sanitizer special** **case list**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source files and functions (src and fun)**: ASan allows you to suppress error
    reports in specified source files or functions. This is particularly useful when
    you want to ignore certain known issues or third-party code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Globals and types (global and type)**: Additionally, ASan introduces the
    ability to suppress errors for out-of-bound access to globals with certain names
    and types. This feature is specifically handy for global variables and class/struct
    types, allowing more targeted error suppression.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Example of a sanitizer special case** **list entry**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fine-tuning ASan is an essential aspect of integrating it into a large-scale,
    complex development environment. It allows developers to customize the behavior
    of ASan to fit the specific needs of the project, be it by excluding external
    libraries, conditioning code for ASan builds, or ignoring certain errors to focus
    on more critical issues. By effectively utilizing these fine-tuning capabilities,
    teams can harness the full power of ASan to ensure robust and reliable C++ applications.
    The suppression rules can be set in a textual file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This file can then be passed to the runtime via the `ASAN_OPTIONS` environment
    variable, such as `ASAN_OPTIONS=suppressions=path/to/suppressionfile`.
  prefs: []
  type: TYPE_NORMAL
- en: Performance overhead of ASan
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The use of ASan in detecting memory management issues, such as invalid free
    operations, is highly beneficial in identifying and resolving potential bugs in
    C++ applications. However, it’s important to be aware of the performance implications
    of using ASan.
  prefs: []
  type: TYPE_NORMAL
- en: '**Performance impact, limitations,** **and recommendations**'
  prefs: []
  type: TYPE_NORMAL
- en: Integrating ASan into the development and testing process brings with it a certain
    level of performance overhead. Typically, the slowdown introduced by ASan is in
    the region of 2x, meaning a program instrumented with ASan may run approximately
    twice as slowly compared to its non-instrumented version. This increased execution
    time is primarily due to the additional checks and monitoring that ASan performs
    to meticulously detect memory errors. Every memory access, along with each memory
    allocation and deallocation operation, is subject to these checks, inevitably
    resulting in additional CPU cycles being consumed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given this performance impact, ASan is predominantly utilized during the development
    and testing phases of the software life cycle. This usage pattern represents a
    trade-off: while there is a performance cost to using ASan, the benefits of catching
    and fixing critical memory-related errors early in the development process are
    significant. Early detection of such issues helps in maintaining code quality
    and can substantially reduce the time and resources required for debugging and
    fixing bugs later in the cycle.'
  prefs: []
  type: TYPE_NORMAL
- en: However, deploying ASan-instrumented binaries in a production environment is
    generally not recommended, especially in scenarios where performance is a critical
    factor. The overhead introduced by ASan can impact the application’s responsiveness
    and efficiency. That said, in certain contexts, particularly in applications where
    reliability and security are of paramount importance, and performance considerations
    are secondary, using ASan in a production-like environment for thorough testing
    might be justified. In such cases, the additional assurance of stability and security
    provided by ASan can outweigh the concerns regarding performance degradation.
  prefs: []
  type: TYPE_NORMAL
- en: 'ASan is supported on the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Linux i386/x86_64 (tested on Ubuntu 12.04)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: macOS 10.7 – 10.11 (i386/x86_64)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: iOS Simulator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android ARM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NetBSD i386/x86_64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FreeBSD i386/x86_64 (tested on FreeBSD 11-current)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows 8.1+ (i386/x86_64)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LeakSanitizer (LSan)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**LSan** is a dedicated memory leak detection tool that is part of the ASan
    suite but can also be used independently. It is specifically designed to identify
    memory leaks in C++ programs – situations where allocated memory is not freed,
    leading to increased memory consumption over time.'
  prefs: []
  type: TYPE_NORMAL
- en: Integration with ASan
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: LSan is often used in conjunction with ASan. When you enable ASan in your build,
    LSan is automatically enabled as well, providing a comprehensive analysis for
    both memory errors and leaks.
  prefs: []
  type: TYPE_NORMAL
- en: Standalone mode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you wish to use LSan without ASan, you can enable it by compiling your program
    with the `-fsanitize=leak` flag. This is particularly useful when you want to
    focus solely on memory leak detection without the overhead of other address sanitizations.
  prefs: []
  type: TYPE_NORMAL
- en: Example of memory leak detection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider the following C++ code with a memory leak:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this example, an array of integers is dynamically allocated and not freed,
    resulting in a memory leak.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you compile and run this code with LSan, the output might look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This output pinpoints the location and size of the memory leak, aiding in quick
    and effective debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Platform support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As of the latest information available, LSan is supported on Linux, macOS, and
    Android. The support can vary based on the toolchain and the version of the compiler
    being used.
  prefs: []
  type: TYPE_NORMAL
- en: LSan is a valuable tool for C++ developers to identify and resolve memory leaks
    in their applications. Its ability to be used both in conjunction with ASan and
    in standalone mode offers flexibility in addressing specific memory-related issues.
    By integrating LSan into the development and testing process, developers can ensure
    more efficient memory usage and overall improved application stability.
  prefs: []
  type: TYPE_NORMAL
- en: MemorySanitizer (MSan)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**MSan** is a dynamic analysis tool, part of the LLVM project, designed to
    detect the use of uninitialized memory in C++ programs. Uninitialized memory use
    is a common source of bugs that can lead to unpredictable behavior, security vulnerabilities,
    and difficult-to-diagnose errors.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use MSan, compile your program with the `-fsanitize=memory` flag. This instructs
    the compiler to instrument the code with checks for uninitialized memory usage.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Example code demonstrating uninitialized memory usage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider the following simple C++ example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In this code, the integers are allocated in the heap but not initialized.
  prefs: []
  type: TYPE_NORMAL
- en: 'When compiled and run with MSan, the output might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: MSan detects the use of the uninitialized variable and points to the exact location
    in the code where this occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, a fix can be as simple as initializing the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Fine-tuning, performance impact, and limitations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Fine-tuning**: MSan’s fine-tuning options are similar to those of ASan. Users
    can refer to the official documentation for detailed customization options.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance impact**: Typically, using MSan introduces a runtime slowdown
    of about 3x. This overhead is due to the additional checks that MSan performs
    to detect uses of uninitialized memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Supported platforms**: MSan is supported on Linux, NetBSD, and FreeBSD. Its
    effectiveness in detecting uninitialized memory usage makes it a powerful tool
    for developers working on these platforms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Limitations**: As with other sanitizers, MSan’s runtime overhead makes it
    most suitable for use in testing environments rather than in production. Additionally,
    MSan requires that the entire program, including all libraries it uses, be instrumented.
    This can be a limitation in cases where source code for certain libraries is not
    available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MSan is an essential tool for detecting the elusive but potentially critical
    issue of uninitialized memory usage in C++ programs. By providing detailed reports
    on where and how such issues occur, MSan enables developers to identify and fix
    these errors, significantly improving the reliability and security of their applications.
    Integrating MSan into the development and testing phases, despite its performance
    impact, is a prudent step toward ensuring robust software quality.
  prefs: []
  type: TYPE_NORMAL
- en: TSan
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the realm of C++ programming, effectively managing concurrency and multithreading
    is both vital and challenging. Thread-related issues, particularly data races,
    are notoriously difficult to detect and debug. Unlike other bugs that can often
    be uncovered through deterministic testing methods such as unit tests, threading
    issues are elusive and non-deterministic in nature. They may not manifest under
    every run of a program, leading to unpredictable and erratic behavior that can
    be extremely hard to replicate and diagnose.
  prefs: []
  type: TYPE_NORMAL
- en: The complexity of thread-related issues
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Non-deterministic behavior**: Concurrency issues, including data races, deadlocks,
    and thread leaks, are inherently non-deterministic. This means that they do not
    consistently reproduce under the same conditions, making them elusive and unpredictable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Challenges in detection**: Traditional testing methods, including comprehensive
    unit tests, often fail to detect these issues. The outcome of a test involving
    concurrency can vary from one execution to another, depending on factors such
    as timing, thread scheduling, and system load.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subtle and severe bugs**: Thread-related bugs can remain dormant, only to
    surface in production under specific conditions, potentially leading to severe
    implications such as data corruption, performance degradation, and system crashes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The necessity of TSan
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Given the inherent challenges in managing concurrency in C++, tools such as
    TSan provided by Clang and GCC become essential. TSan is a sophisticated tool
    designed to detect threading issues, with a particular focus on data races.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling TSan
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`-fsanitize=thread` flag. This instructs Clang and GCC to instrument your code
    for runtime detection of threading issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compilation example**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This command will compile `your_file.cpp` with TSan enabled, ready to detect
    and report threading issues. Note that it is impossible to turn on both thread
    and ASans at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Example of a data race in C++
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider this simple yet illustrative example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Here, two threads modify the same shared resource without synchronization, leading
    to a data race.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we build and run this code with TSan enabled, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This output from TSan indicates a data race condition in a C++ program. Let’s
    break down the key elements of this report to understand what it’s telling us:'
  prefs: []
  type: TYPE_NORMAL
- en: '`WARNING: ThreadSanitizer:` `data race`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0x555fd304f154` memory address, which is identified as a global `shared_counter`
    variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`increment_counter() /home/user/clang-sanitizers/main.cpp:8`. This means the
    data race read happens in the `increment_counter` function, specifically at *line
    8* of `main.cpp`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The report also provides a stack trace leading up to this read, showing the
    sequence of function calls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`increment_counter` function at *line 8* of `main.cpp`.*   `main.cpp` at *lines
    13* and *14*, respectively). This helps in understanding the program’s flow leading
    to the data race.*   `SUMMARY: ThreadSanitizer: data race /home/user/clang-sanitizers/main.cpp:8`
    `in increment_counter()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This concisely points to the function and file where the data race is detected.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Fine-tuning, performance impact, limitations, and recommendations for TSan
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TSan typically introduces a runtime slowdown of approximately 5x-15x. This significant
    increase in execution time is due to the comprehensive checks performed by TSan
    to detect data races and other threading issues. Along with the slowdown, TSan
    also increases memory usage, generally by about 5x-10x. This overhead arises from
    the additional data structures TSan uses to monitor thread interactions and identify
    potential race conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'This list outlines the limitations and current state of TSan:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Beta stage**: TSan is currently in the beta stage. While it has been effective
    in large C++ programs using pthreads, there is no guarantee of its effectiveness
    for every scenario.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Supported threading models**: TSan supports C++11 threading when compiled
    with llvm’s libc++. This compatibility includes the threading features introduced
    with the C++11 standard.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'TSan is supported by several operating systems and architectures:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Android**: aarch64, x86_64'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Darwin (macOS)**: arm64, x86_64'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FreeBSD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Linux**: aarch64, x86_64, powerpc64, powerpc64le'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NetBSD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support is mainly focused on 64-bit architectures. The support for 32-bit platforms
    is problematic and not planned.
  prefs: []
  type: TYPE_NORMAL
- en: Fine-tuning TSan
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The fine-tuning of TSan is very similar to that of ASan. Users interested in
    detailed fine-tuning options can refer to the official documentation, which provides
    comprehensive guidance on customizing TSan’s behavior to suit specific needs and
    scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Recommendations for using TSan
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Due to the overhead in performance and memory, TSan is ideally used during the
    development and testing phases of a project. Its use in production environments
    should be carefully evaluated against the performance requirements. TSan is particularly
    useful in projects with significant multithreaded components, where the likelihood
    of data races and threading issues is higher. Incorporating TSan into **continuous
    integration** (**CI**) pipelines can help catch threading issues early in the
    development cycle, reducing the risk of these bugs making it into production.
  prefs: []
  type: TYPE_NORMAL
- en: TSan is a critical tool for developers dealing with the complexities of concurrency
    in C++. It provides an invaluable service in detecting elusive threading issues
    that traditional testing methods often miss. By integrating TSan into the development
    and testing process, developers can significantly enhance the reliability and
    stability of their multithreaded C++ applications.
  prefs: []
  type: TYPE_NORMAL
- en: UBSan
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: UBSan is a dynamic analysis tool designed to detect undefined behavior in C++
    programs. Undefined behavior, as defined by the C++ standard, refers to code whose
    behavior is not prescribed, leading to unpredictable program execution. This can
    include issues such as integer overflow, division by zero, or misuse of null pointers.
    Undefined behavior can cause erratic program behavior, crashes, and security vulnerabilities.
    However, it is often used by compiler developers to optimize code. UBSan is crucial
    for identifying these problems, which are often subtle and hard to detect through
    standard testing but can cause significant issues in software reliability and
    security.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring UBSan
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To use UBSan, compile your program with the `-fsanitize=undefined` flag. This
    instructs the compiler to instrument the code with checks for various forms of
    undefined behavior. These commands compile the program with UBSan enabled using
    either Clang or GCC.
  prefs: []
  type: TYPE_NORMAL
- en: Example code demonstrating undefined behavior
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider this simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In this code, attempting to divide by zero (`10 / x`) is an instance of undefined
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'When compiled and run with UBSan, the output might include something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: UBSan detects the division by zero and reports the exact location in the code
    where this occurs.
  prefs: []
  type: TYPE_NORMAL
- en: Fine-tuning, performance impact, and limitations
  prefs: []
  type: TYPE_NORMAL
- en: '**Fine-tuning**: UBSan provides various options to control its behavior, allowing
    developers to focus on specific kinds of undefined behavior. Users interested
    in detailed customization can refer to the official documentation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance impact**: The runtime performance impact of UBSan is generally
    lower compared to tools such as ASan and TSan, but it can vary depending on the
    types of checks enabled. A typical slowdown is usually minimal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Supported platforms**: UBSan is supported on major platforms such as Linux,
    macOS, and Windows, making it widely accessible for C++ developers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Limitations**: While UBSan is powerful in detecting undefined behavior, it
    cannot catch every instance, especially those that are highly dependent on specific
    program states or hardware configurations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UBSan is an invaluable tool for C++ developers, aiding in the early detection
    of subtle yet critical issues that can lead to unstable and insecure software.
    Its integration into the development and testing process is a proactive step towards
    ensuring the robustness and reliability of C++ applications. With its minimal
    performance impact and broad platform support, UBSan is a practical addition to
    any C++ developer’s toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic code analysis with Valgrind
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Valgrind** is a powerful tool for memory debugging, memory leak detection,
    and profiling. It is instrumental in identifying issues such as memory mismanagement
    and access errors, which are common in complex C++ programs. Unlike compiler-based
    tools such as Sanitizers, Valgrind works by running the program in a virtual-machine-like
    environment, checking for memory-related errors.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Valgrind
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Valgrind can typically be installed from your system’s package manager. For
    example, on Ubuntu, you can install it using `sudo apt-get install valgrind`.
    To run a program under Valgrind, use the `valgrind ./your_program` command. This
    command executes your program within the Valgrind environment, where it performs
    its analysis. No special compilation flags are needed for basic memory checking
    with Valgrind, but including debugging symbols with `-g` can help make its output
    more useful.
  prefs: []
  type: TYPE_NORMAL
- en: Memcheck – the comprehensive memory debugger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Memcheck**, the core tool of the Valgrind suite, is a sophisticated memory
    debugger for C++ applications. It combines the functionality of address, memory,
    and LSans, providing a comprehensive analysis of memory usage. Memcheck detects
    memory-related errors such as the use of uninitialized memory, improper use of
    memory allocation and deallocation functions, and memory leaks.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use Memcheck, no special compilation flags are needed, but compiling with
    debugging information (using `-g`) can enhance the usefulness of Memcheck’s reports.
    Execute your program with Valgrind by using the `valgrind ./your_program` command.
    For detecting memory leaks, add `--leak-check=full` for more detailed information.
    Here is an example command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Since Memcheck covers a wide range of memory-related issues, I am going to
    show only an example of detecting a memory leak since they are often the hardest
    to detect. Let us consider the following C++ code with a memory leak:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Memcheck will detect and report the memory leak, indicating where the memory
    was allocated and that it was not freed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Performance impact, fine-tuning, and limitations
  prefs: []
  type: TYPE_NORMAL
- en: It is important to remember that Memcheck can significantly slow down program
    execution, often by 10-30 times, and increase memory usage. This is due to the
    extensive checks performed on each memory operation.
  prefs: []
  type: TYPE_NORMAL
- en: Memcheck offers several options to control its behavior. For example, `--track-origins=yes`
    can help find the sources of uninitialized memory use, although it may further
    slow down the analysis.
  prefs: []
  type: TYPE_NORMAL
- en: The main limitation of Memcheck is its performance overhead, which makes it
    unsuitable for production environments. Additionally, while it is thorough in
    memory leak detection, it may not catch every instance of uninitialized memory
    use, especially in complex scenarios or when specific compiler optimizations are
    applied.
  prefs: []
  type: TYPE_NORMAL
- en: Memcheck stands as a vital tool in the C++ developer’s toolkit for memory debugging.
    By providing a detailed analysis of memory errors and leaks, it plays a critical
    role in enhancing the reliability and correctness of C++ applications. Despite
    its performance overhead, Memcheck’s benefits in identifying and resolving memory
    issues make it indispensable for the development and testing phases of software
    development.
  prefs: []
  type: TYPE_NORMAL
- en: Helgrind – threading error detector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Helgrind** is a tool within the Valgrind suite, specifically designed to
    detect synchronization errors in C++ multithreaded applications. It focuses on
    identifying race conditions, deadlocks, and misuses of the pthreads API. Helgrind
    operates by monitoring the interactions between threads, ensuring that shared
    resources are accessed safely and correctly. Its ability to detect threading errors
    makes it comparable to TSan but with a different underlying approach and usage.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use Helgrind, you do not need to recompile your program with special flags
    (although compiling with `-g` to include debugging symbols is recommended). Run
    your program with Valgrind using the `--tool=helgrind` option. Here is an example
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us consider the data race example that we analyzed before with TSan:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Helgrind will detect and report the data race, showing where the threads are
    concurrently modifying `shared_counter` without proper synchronization. In addition
    to identifying data races, Helgrind’s output contains thread creation announcements,
    stack traces, and other details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Performance impact, fine-tuning, and limitations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using Helgrind can slow down your program execution significantly (often by
    20x or more) due to the detailed analysis of threading interactions. This makes
    it most suitable for testing environments. Helgrind provides several options to
    customize its behavior, such as controlling the level of checking or ignoring
    certain errors. The primary limitation is the performance overhead, making it
    impractical for use in production. Additionally, Helgrind may produce false positives,
    especially in complex threading scenarios or when using advanced synchronization
    primitives not fully understood by Helgrind.
  prefs: []
  type: TYPE_NORMAL
- en: Helgrind is an essential tool for developers working with multithreaded C++
    applications, providing insights into challenging concurrency problems. It aids
    in creating more reliable and thread-safe applications by detecting and helping
    to resolve complex synchronization issues. While its use may be limited to development
    and testing phases due to performance overhead, the benefits it offers in enhancing
    the correctness of multithreaded code are invaluable.
  prefs: []
  type: TYPE_NORMAL
- en: Other notable tools in the Valgrind suite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to Helgrind, the Valgrind suite includes several other tools, each
    with distinct functionalities catering to different aspects of program analysis
    and performance profiling.
  prefs: []
  type: TYPE_NORMAL
- en: Data Race Detector (DRD) – a thread error detector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**DRD** is another tool for detecting thread errors, similar to Helgrind. It
    focuses specifically on identifying data races in multithreaded programs. While
    both Helgrind and DRD are designed to detect threading issues, DRD is more optimized
    for detecting data races and generally has a lower performance overhead compared
    to Helgrind. DRD might produce fewer false positives in certain scenarios but
    may not be as thorough as Helgrind in detecting all kinds of synchronization errors.'
  prefs: []
  type: TYPE_NORMAL
- en: Cachegrind
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Cachegrind** is a cache and branch-prediction profiler. It provides detailed
    information about how your program interacts with the computer’s cache hierarchy
    and the efficiency of branch prediction. This tool is invaluable for optimizing
    program performance, particularly in CPU-bound applications. It helps identify
    inefficient memory access patterns and areas of code that can benefit from optimization
    to improve cache utilization.'
  prefs: []
  type: TYPE_NORMAL
- en: Callgrind
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Callgrind** extends the functionality of Cachegrind by adding call-graph
    generation capabilities. It records the call history among functions in a program,
    allowing developers to analyze the execution flow and identify performance bottlenecks.
    Callgrind is particularly useful for understanding the overall structure and interactions
    in complex applications.'
  prefs: []
  type: TYPE_NORMAL
- en: Massif
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Massif is a heap profiler that provides insights into a program’s memory usage.
    It helps developers understand and optimize memory consumption, track down memory
    leaks, and identify where and how memory allocation occurs within a program.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic heap analysis tool (DHAT)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **DHAT** is focused on profiling heap allocation patterns. It’s particularly
    useful for finding inefficient use of heap memory, such as excessive small allocations
    or short-lived allocations that could be optimized.
  prefs: []
  type: TYPE_NORMAL
- en: Each tool in the Valgrind suite offers unique capabilities for analyzing different
    aspects of program performance and behavior. From threading issues to memory usage
    and CPU optimization, these tools provide a comprehensive set of functionalities
    for enhancing the efficiency, reliability, and correctness of C++ applications.
    Their integration into the development and testing process allows developers to
    gain deep insights into their code, leading to well-optimized and robust software
    solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Compiler-based sanitizers and Valgrind bring distinct advantages and challenges
    to the debugging and profiling process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compiler-based tools such as ASan, TSan, and UBSan are generally more accessible
    and easier to integrate into the development workflow. They are “cheaper” in terms
    of the performance overhead they introduce and are relatively straightforward
    to configure and use. These sanitizers are integrated directly into the compilation
    process, making them convenient for developers to employ regularly. Their primary
    advantage lies in their ability to provide immediate feedback during the development
    phase, catching errors and issues as the code is being written and tested. However,
    since these tools perform analysis during runtime, their effectiveness is directly
    tied to the extent of the test coverage. The more comprehensive the tests, the
    more effective the dynamic analysis, as only the executed code paths are analyzed.
    This aspect highlights the importance of thorough testing: the better the test
    coverage, the more issues these tools can potentially uncover.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Valgrind, on the other hand, offers a more powerful and thorough analysis,
    capable of detecting a wider range of issues, particularly in memory management
    and threading. Its suite of tools – Memcheck, Helgrind, DRD, Cachegrind, Callgrind,
    Massif, and DHAT – provides a comprehensive analysis of various aspects of program
    performance and behavior. However, this power comes with a cost: Valgrind is generally
    more complex to use and introduces a significant performance overhead compared
    to compiler-based tools. The choice of whether to use Valgrind or a compiler-based
    sanitizer often depends on the specific needs of the project and the issues being
    targeted. While Valgrind’s extensive diagnostics offer deep insights into the
    program, the ease of use and lower performance cost of compiler-based sanitizers
    make them more suitable for regular use in a CI pipeline.'
  prefs: []
  type: TYPE_NORMAL
- en: In summary, while both compiler-based tools and Valgrind have their place in
    the dynamic analysis landscape, their differences in diagnostics, ease of use,
    and performance impact make them suited to different stages and aspects of the
    software development process. Employing these tools as part of a regular CI pipeline
    is highly recommended, as it allows for the early detection and resolution of
    issues, contributing significantly to the overall quality and robustness of the
    software. The subsequent chapter will delve into tools for measuring test coverage,
    providing insights into how effectively the code base is being tested and thus
    complementing the dynamic analysis process.
  prefs: []
  type: TYPE_NORMAL
