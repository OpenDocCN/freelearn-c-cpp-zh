- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: General-Purpose Timers (TIM)
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用定时器（TIM）
- en: In this chapter, we will delve into the **general-purpose timers** (**TIM**)
    found in the STM32F411 microcontroller. Unlike the SysTick timer, these timer
    peripherals are unique to STM32 microcontrollers and offer a range of capabilities
    essential for various applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨STM32F411微控制器中发现的**通用定时器**（**TIM**）。与SysTick定时器不同，这些定时器外设是STM32微控制器独有的，并提供了各种应用所需的基本功能。
- en: We will begin by discussing the common uses of timers, providing a foundation
    for understanding their importance in embedded systems. Following this, we will
    explore the specific characteristics of the timers on STM32 microcontrollers.
    This includes understanding the timer clock source, the mechanics of prescaling,
    and a detailed look at the commonly used timer registers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先讨论定时器的常见用途，为理解它们在嵌入式系统中的重要性打下基础。随后，我们将探讨STM32微控制器上定时器的特定特性。这包括理解定时器时钟源、预分频的机制以及详细查看常用的定时器寄存器。
- en: In the latter part of the chapter, we will put theory into practice by developing
    a timer driver and applying the knowledge we’ve gained to create functional and
    efficient code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后半部分，我们将通过开发定时器驱动程序并将所学知识应用于创建功能性和高效的代码来将理论付诸实践。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Introduction to timers and their uses
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定时器和它们的应用简介
- en: Common use cases of timers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定时器的常见用例
- en: STM32 timers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: STM32定时器
- en: Developing the timer driver
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定时器驱动程序的开发
- en: By the end of this chapter, you will have a good understanding of STM32 timers
    and how to develop drivers for them, enhancing your ability to utilize these peripherals
    effectively in your projects.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将很好地理解STM32定时器及其驱动程序的开发，这将增强您在项目中有效利用这些外设的能力。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming](https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码示例都可以在GitHub上找到：[https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming](https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming)。
- en: Introduction to timers and their uses
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定时器和它们的应用简介
- en: Timers are crucial components in embedded systems, serving essential functions
    in a wide array of applications. In this section, we will explore the concept
    of timers, their types, and their various applications.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 定时器是嵌入式系统中的关键组件，在广泛的领域中发挥着基本功能。在本节中，我们将探讨定时器的概念、类型及其各种应用。
- en: The question is, *What* *are timers?*
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，**定时器是什么**？
- en: Timers are hardware peripherals found in microcontrollers that **count clock
    pulses**. **These pulses can be used to measure time intervals, generate precise
    delays, or trigger events at specific intervals**. Timers can operate in several
    modes, including **counting up**, **counting down**, and generating **Pulse Width
    Modulation** (**PWM**) signals.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 定时器是微控制器中发现的硬件外设，用于**计数时钟脉冲**。**这些脉冲可以用来测量时间间隔、生成精确的延迟或在特定间隔触发事件**。定时器可以以多种模式运行，包括**向上计数**、**向下计数**和生成**脉冲宽度调制**（**PWM**）信号。
- en: The choice between using the SysTick timer and general-purpose timers on STM32
    microcontrollers comes down to the complexity and precision of your timing needs.
    While the SysTick timer is great for simple system timing tasks such as generating
    periodic interrupts or creating delays, it’s limited in flexibility and features,
    as it’s often dedicated to **real-time operating system** (**RTOS**) ticks. On
    the other hand, general-purpose timers, as we have just discussed, offer far more
    versatility, with the ability to handle complex tasks such as PWM generation,
    input capture, and output compare. They also support multiple channels for concurrent
    timing events and provide advanced functionalities such as precise frequency measurement
    and low-power operation.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在STM32微控制器上使用SysTick定时器与通用定时器之间的选择取决于您对定时需求的复杂性和精度。虽然SysTick定时器非常适合简单的系统定时任务，例如生成周期性中断或创建延迟，但它灵活性有限，功能也有限，因为它通常被用于**实时操作系统**（**RTOS**）的滴答。另一方面，正如我们刚才讨论的，通用定时器提供了更多的多功能性，能够处理如PWM生成、输入捕获和输出比较等复杂任务。它们还支持多个通道以并发处理定时事件，并提供如精确频率测量和低功耗操作等高级功能。
- en: Let’s explore some typical use cases to illustrate the importance of timers.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些典型用例来探讨定时器的重要性。
- en: Common use cases of timers
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定时器的常见用例
- en: Let’s start with timers for time interval measurement.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从计时器开始，用于时间间隔测量。
- en: Time interval measurement
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时间间隔测量
- en: One common use of timers is in ultrasonic sensors for distance measurement,
    widely used in robotics, automotive parking systems, and obstacle detection.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 计时器的一个常见用途是在超声波传感器中进行距离测量，广泛应用于机器人、汽车停车系统和障碍物检测。
- en: 'Timers play a vital role in the operation of these sensors. Here’s how they
    work:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 计时器在这些传感器的操作中起着至关重要的作用。以下是它们的工作原理：
- en: The microcontroller sends a trigger signal to the ultrasonic sensor, causing
    it to emit an ultrasonic pulse.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 微控制器向超声波传感器发送触发信号，使其发出超声波脉冲。
- en: The sensor waits for the echo of the pulse to return after bouncing off an object.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 传感器等待脉冲在撞击物体后返回的回声。
- en: A timer starts counting when the pulse is emitted and stops when the echo is
    received.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计时器在发出脉冲时开始计数，在接收到回声时停止计数。
- en: The time interval measured by the timer is used to calculate the distance to
    the object based on the speed of sound.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计时器测量的时间间隔用于根据声速计算到物体的距离。
- en: By accurately measuring the time interval between sending the pulse and receiving
    the echo, the system can determine the distance to objects, enabling precise navigation
    and obstacle avoidance.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通过精确测量发送脉冲和接收回声之间的时间间隔，系统可以确定到物体的距离，从而实现精确导航和避障。
- en: Timers are also essential for generating precise delays, such as in the refresh
    mechanism of **light-emitting diode** (**LED**) matrix displays.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 计时器对于生成精确的延迟也非常重要，例如在**发光二极管（LED**）矩阵显示屏的刷新机制中。
- en: Delay generation
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 延迟生成
- en: In embedded systems, LED matrix displays are used for various applications,
    including digital signage, scoreboards, and simple graphical displays. To display
    images or text, the microcontroller needs to refresh the display at a precise
    rate to ensure smooth visuals.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌入式系统中，LED矩阵显示屏用于各种应用，包括数字标牌、计分板和简单的图形显示。为了显示图像或文本，微控制器需要以精确的速率刷新显示，以确保平滑的视觉效果。
- en: 'Over here, the following happens:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，发生以下情况：
- en: The microcontroller drives an LED matrix display and needs to refresh the display
    rows sequentially.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微控制器驱动一个LED矩阵显示屏，需要依次刷新显示行。
- en: A timer generates precise delays to control the time each row is activated before
    moving to the next row.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计时器生成精确的延迟来控制每一行激活的时间，以便移动到下一行。
- en: For example, the timer might be set to generate a delay of 1 millisecond between
    switching rows.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，计时器可能被设置为在切换行之间生成1毫秒的延迟。
- en: This ensures that each row is displayed for a consistent period, maintaining
    a stable and flicker-free image.
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这确保了每一行都能以一致的时间显示，保持稳定且无闪烁的图像。
- en: Now, let’s see an example of how timers can be used for triggering events in
    embedded systems.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看计时器在嵌入式系统中触发事件的一个示例。
- en: Event trigger
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件触发
- en: Periodic data sampling from sensors is important for applications such as environmental
    monitoring and **industrial process control** (**IPC**). A timer can be used to
    trigger the **analog-to-digital converter** (**ADC**) at specific intervals to
    ensure consistent data sampling.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 从传感器进行周期性数据采样对于环境监测和**工业过程控制（IPC**）等应用非常重要。计时器可以用来在特定间隔触发**模数转换器（ADC**），以确保一致的数据采样。
- en: 'Over here, the following happens:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，发生以下情况：
- en: The microcontroller is connected to an environmental sensor (for example, a
    temperature or humidity sensor) that outputs an analog signal
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微控制器连接到一个环境传感器（例如，温度或湿度传感器），该传感器输出模拟信号
- en: A general-purpose timer is configured to trigger the ADC conversion periodically
    (for example, every 100 milliseconds)
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用计时器被配置为定期触发ADC转换（例如，每100毫秒一次）
- en: The ADC is set up to use the timer trigger option, automatically starting a
    conversion at each timer event
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ADC被设置为使用计时器触发选项，在每次计时器事件自动开始转换。
- en: The main loop of the microcontroller regularly checks for completed ADC conversions
    and processes the data
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微控制器的主循环定期检查完成的ADC转换并处理数据。
- en: In the next section, we will focus on the features and characteristics of STM32
    timers.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将重点关注STM32计时器的特性和特点。
- en: STM32 timers
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: STM32计时器
- en: 'The timers in STM32 microcontrollers are classified into two main categories:
    **general-purpose timers** and **advanced timers**.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: STM32微控制器中的计时器分为两大类：**通用计时器**和**高级计时器**。
- en: Introduction to general-purpose timers and advanced timers
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用计时器和高级计时器简介
- en: General-purpose timers are highly versatile and can be used for a variety of
    applications, whereas advanced timers offer more sophisticated features than general-purpose
    timers, making them suitable for high-precision and complex timing tasks.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通用定时器非常通用，可用于各种应用，而高级定时器比通用定时器提供更复杂的功能，使其适合高精度和复杂的定时任务。
- en: In the STM32F411 microcontroller, timers **TIM2**, **TIM3**, **TIM4**, **TIM5**,
    **TIM9**, **TIM10**, and **TIM11** are general-purpose timers, whereas **TIM1**
    is an advanced timer.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在STM32F411微控制器中，定时器**TIM2**、**TIM3**、**TIM4**、**TIM5**、**TIM9**、**TIM10**和**TIM11**是通用定时器，而**TIM1**是高级定时器。
- en: 'Key features of the general-purpose timers include the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通用定时器的主要特性包括以下内容：
- en: '**Counter size**: They feature 16-bit counters for TIM3 and TIM4 and 32-bit
    counters for TIM2 and TIM5, capable of operating in up, down, or up/down auto-reload
    modes'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计数器大小**：它们具有TIM3和TIM4的16位计数器以及TIM2和TIM5的32位计数器，能够以向上、向下或上/下自动重载模式运行'
- en: '**Prescaler**: They are equipped with a 16-bit programmable prescaler, which
    allows us to divide the counter-clock frequency by any factor ranging from 1 to
    65,536'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预分频器**：它们配备了一个16位可编程预分频器，允许我们将计数器时钟频率除以从1到65,536的任何因子'
- en: '**Channels**: They offer up to four independent channels'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通道**：它们提供多达四个独立通道'
- en: '**Synchronization**: The timers can synchronize with external signals and interconnect
    with multiple timers, enhancing flexibility and coordination in complex applications'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**同步**：定时器可以与外部信号同步，并与多个定时器互连，增强了在复杂应用中的灵活性和协调性'
- en: '**Interrupt/direct memory access (DMA) generation**: The timers can generate
    interrupts or DMA requests based on various events, including counter overflow/underflow,
    counter initialization, trigger events, input capture, and output compare'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中断/直接内存访问（DMA）生成**：定时器可以根据各种事件生成中断或DMA请求，包括计数器溢出/下溢、计数器初始化、触发事件、输入捕获和输出比较'
- en: '**Encoder support**: These timers also support incremental (quadrature) encoders
    and Hall-sensor circuitry, making them suitable for precise positioning applications'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编码器支持**：这些定时器还支持增量（正交）编码器和霍尔传感器电路，使其适用于精确定位应用'
- en: 'The advanced timer, TIM1, has a 16-bit counter size. Apart from the difference
    in counter size, it shares all the features of the general-purpose timers with
    the following additional features:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 高级定时器TIM1具有16位计数器大小。除了计数器大小的差异外，它还具备通用定时器的所有功能，并具有以下附加功能：
- en: '**Complementary outputs**: Support for complementary outputs with programmable
    dead-time insertion'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**互补输出**：支持具有可编程死区插入的互补输出'
- en: '**Repetition counter**: Allows updating the timer registers only after a specific
    number of counter cycles'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重复计数器**：允许在特定的计数周期数之后才更新定时器寄存器'
- en: '**Break input**: It has the ability to put the timer’s output signals into
    a reset or known state upon activation'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断开输入**：它能够在激活时将定时器的输出信号置于复位或已知状态'
- en: Before we start analyzing some of the key registers provided in the reference
    manual, let’s first understand how STM32 timers work.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始分析参考手册中提供的一些关键寄存器之前，让我们首先了解STM32定时器的工作原理。
- en: How STM32 timers work
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何使用STM32定时器
- en: The core of the timer is the 16-bit/32-bit counter and its associated auto-reload
    register. The counter can count upward or downward, and its clock can be divided
    by a prescaler. We can read from and write to the counter, auto-reload register,
    and prescaler register even while the counter is running.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 定时器的核心是16位/32位计数器和其相关的自动重载寄存器。计数器可以向上或向下计数，其时钟可以被预分频器除以。即使在计数器运行时，我们也可以从计数器、自动重载寄存器和预分频寄存器中读取和写入。
- en: 'The time-base unit includes the following registers:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 时基单元包括以下寄存器：
- en: '`TIMx_CNT`)'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TIMx_CNT`'
- en: '`TIMx_PSC`)'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TIMx_PSC`'
- en: '`TIMx_ARR`)'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TIMx_ARR`'
- en: The prescaler register (`TIMx_PSC`) divides the timer’s input clock frequency
    by a programmable value between 1 and 65,536\. This allows for slower counting
    rates to accommodate longer timing intervals.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 预分频寄存器（`TIMx_PSC`）将定时器的输入时钟频率除以1到65,536之间的可编程值。这允许以较慢的计数速率来适应更长的定时间隔。
- en: The auto-reload register (`TIMx_ARR`) defines the value at which the counter
    resets to zero in up-counting mode or to the auto-reload value in down-counting
    mode. We use it to set the period of the timer.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 自动重载寄存器（`TIMx_ARR`）定义了计数器在向上计数模式下重置为零或在下计数模式下重置到自动重载值的值。我们使用它来设置定时器的周期。
- en: Apart from the registers in the time-base unit, the timer peripheral also includes
    control registers (`TIMx_CR1`, `TIMx_CR2`, and so on) for configuring the various
    operational parameters, such as enabling the counter, setting the counting direction,
    and configuring `TIMx_SR`) indicates the status of the timer, such as whether
    a UEV has occurred and other auxiliary registers for controlling the timer, among
    other things.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 除了时基单元中的寄存器外，定时器外设还包括控制寄存器（`TIMx_CR1`、`TIMx_CR2`等），用于配置各种操作参数，例如启用计数器、设置计数方向以及配置`TIMx_SR`）表示定时器的状态，例如是否发生了UEV以及其他用于控制定时器的辅助寄存器，等等。
- en: 'As we mentioned earlier, the timer has two counting modes: up-counting mode
    and down-counting mode. Let’s break them down:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，定时器有两种计数模式：向上计数模式和向下计数模式。让我们来分解它们：
- en: '`TIMx_ARR`) and generates a UEV on overflow'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TIMx_ARR`）并在溢出时生成UEV'
- en: '**Down-counting mode**:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**向下计数模式**：'
- en: The counter counts down from the auto-reload value to 0 and generates a UEV
    on underflow
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 计数器从自动重载值向下计数到0，并在下溢时生成UEV
- en: 'The next question that arises is: *What exactly is* *a UEV?*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来出现的问题是：*UEV究竟是什么？*
- en: 'Let’s break this down:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下：
- en: In simple terms, it is when the timeout should occur
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简而言之，这是超时应该发生的时候
- en: When the counter reaches the auto-reload value or 0 (based on the count mode),
    a UEV occurs
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当计数器达到自动重载值或0（根据计数模式）时，发生UEV
- en: This event can trigger an interrupt or a DMA request and set the `TIMx_SR`)
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个事件可以触发中断或DMA请求并设置`TIMx_SR`）
- en: UEVs can also be generated manually by setting the `TIMx_EGR`)
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UEV也可以通过设置`TIMx_EGR`）手动生成
- en: Now that we know what a UEV is, let’s understand how timer clock prescaling
    is achieved; this will enable us to accurately calculate the timing for UEVs.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了UEV是什么，让我们了解定时器时钟预分频是如何实现的；这将使我们能够准确地计算UEV的定时。
- en: Timer clock prescaling
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定时器时钟预分频
- en: 'We use prescaling to reduce the high-frequency system clock to a lower frequency
    suitable for driving the timer. *Figure 9**.1* illustrates the process of timer
    clock pre-scaling in our STM32 microcontroller, showing how the system clock (`SYSCLK`)
    is divided down to drive the timer counters (`TIMx_CNT`) through a series of prescalers:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用预分频将高频系统时钟降低到适合驱动定时器的较低频率。*图 9**.1* 展示了我们的STM32微控制器中定时器时钟预分频的过程，显示了系统时钟（`SYSCLK`）如何通过一系列预分频器分频以驱动定时器计数器（`TIMx_CNT`）：
- en: '![Figure 9.1: Timer clock prescaling](img/B21914_09_1.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.1：定时器时钟预分频](img/B21914_09_1.jpg)'
- en: 'Figure 9.1: Timer clock prescaling'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1：定时器时钟预分频
- en: 'Let’s explain each component and step involved in this process:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释这个过程中涉及的每个组件和步骤：
- en: '**System** **clock (SYSCLK)**'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统时钟（SYSCLK**）'
- en: This is the main system clock that drives the microcontroller. It serves as
    the initial clock source for all subsequent operations.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是驱动微控制器的主系统时钟。它作为所有后续操作的初始时钟源。
- en: '`SYSCLK` frequency by a factor of 1, 2, 4, 8, 16, 64, 128, 256, or 512\. The
    resulting clock signal is referred to as **HCLK** (AHB clock).'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SYSCLK`频率以1、2、4、8、16、64、128、256或512的因子分频。得到的时钟信号被称为**HCLK**（AHB时钟）。'
- en: '**High-performance Bus** **Clock (HCLK)**'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高性能总线时钟（HCLK**）'
- en: This is the clock signal generated after the AHB prescaler. It is used to drive
    the core and the system bus.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是经过AHB预分频器生成的时钟信号。它用于驱动核心和系统总线。
- en: '**Advanced Peripheral Bus (****APB) prescalers**'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高级外设总线（APB）预分频器**'
- en: '**APB1 prescaler**: This further divides HCLK to generate the clock for the
    APB1 peripheral bus. The division factors available are 1, 2, 4, 8, and 16.'
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**APB1预分频器**：这进一步将HCLK分频以生成APB1外设总线的时钟。可用的分频因子是1、2、4、8和16。'
- en: '**APB2 prescaler**: Similar to the APB1 prescaler but used for the APB2 peripheral
    bus. It also divides HCLK by factors of 1, 2, 4, 8, and 16.'
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**APB2预分频器**：类似于APB1预分频器，但用于APB2外设总线。它也以1、2、4、8和16的因子分频HCLK。'
- en: '**Timer** **prescaler (TIMx_PSC)**'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定时器预分频器（TIMx_PSC**）'
- en: Each timer has its own prescaler register that can divide the APB1 or APB2 clock
    further by any value between 1 and 65,535\. This flexibility allows for precise
    control over the timer’s counting rate.
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个定时器都有自己的预分频寄存器，可以将APB1或APB2时钟进一步分频，分频值在1到65,535之间。这种灵活性允许对定时器的计数速率进行精确控制。
- en: '`TIMx_PSC`. The rate at which this counter increments or decrements depends
    on the combined division effect of the previous prescalers.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TIMx_PSC`。这个计数器增加或减少的速率取决于之前预分频器的组合分频效果。'
- en: The prescalers directly influence the rate at which the timer counter (`TIMx_CNT`)
    increments or decrements. While the other prescalers (AHB and APB) are shared
    among all peripherals on the same bus, `TIMx_PSC` prescaler, we can precisely
    control the resolution and period of that specific timer without affecting other
    peripherals.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 预分频器直接影响定时器计数器（`TIMx_CNT`）增加或减少的速率。虽然其他预分频器（AHB和APB）在相同总线上共享所有外设，但`TIMx_PSC`预分频器，我们可以精确控制特定定时器的分辨率和周期，而不会影响其他外设。
- en: Now, let’s learn how to compute a UEV.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何计算UEV。
- en: Computing a UEV
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算UEV
- en: A UEV occurs when the timer counter reaches the value set in the auto-reload
    register (`TIMx_ARR`) in up-counting mode. Calculating this event is crucial for
    determining the timer’s period and ensuring it operates at the desired frequency.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当定时器计数器在向上计数模式下达到自动重载寄存器（`TIMx_ARR`）中设置的值时，就会发生UEV。计算此事件对于确定定时器的周期并确保其以期望的频率运行至关重要。
- en: 'We can derive the frequency of the UEV with the following formula:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下公式推导UEV的频率：
- en: Update Event Frequency = ![<math ><mrow><mstyle scriptlevel="+1"><mfrac><mrow><mi>T</mi><mi>i</mi><mi>m</mi><mi>e</mi><mi>r</mi><mi>C</mi><mi>l</mi><mi>o</mi><mi>c</mi><mi>k</mi></mrow><mrow><mfenced
    open="(" close=")"><mrow><mi>P</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>c</mi><mi>a</mi><mi>l</mi><mi>e</mi><mi>r</mi><mo>+</mo><mn>1</mn></mrow></mfenced><mi
    mathvariant="normal">X</mi><mo>(</mo><mi>P</mi><mi>e</mi><mi>r</mi><mi>i</mi><mi>o</mi><mi>d</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow></mfrac></mstyle></mrow></math>](img/1.png)
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 更新事件频率 = ![<math ><mrow><mstyle scriptlevel="+1"><mfrac><mrow><mi>T</mi><mi>i</mi><mi>m</mi><mi>e</mi><mi>r</mi><mi>C</mi><mi>l</mi><mi>o</mi><mi>c</mi><mi>k</mi></mrow><mrow><mfenced
    open="(" close=")"><mrow><mi>P</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>c</mi><mi>a</mi><mi>l</mi><mi>e</mi><mi>r</mi><mo>+</mo><mn>1</mn></mrow></mfenced><mi
    mathvariant="normal">X</mi><mo>(</mo><mi>P</mi><mi>e</mi><mi>r</mi><mi>i</mi><mi>o</mi><mi>d</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow></mfrac></mstyle></mrow></math>](img/1.png)
- en: 'Here, we have the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有以下内容：
- en: '`SYSCLK` when using the default clock configuration (in a bare-metal setup)
    on the NUCLEO-F411 development board.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用默认时钟配置（裸机设置）的NUCLEO-F411开发板上，`SYSCLK`。
- en: '`TIMx_PSC` register.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TIMx_PSC`寄存器。'
- en: '`TIMx_ARR` register.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TIMx_ARR`寄存器。'
- en: 'Let’s see an example. Let’s say we have the following parameters:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子。假设我们有以下参数：
- en: '**Timer clock (APB1 clock)**: 16 MHz'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定时器时钟（APB1时钟）**：16 MHz'
- en: '**Prescaler (TIMx_PSC** **value)**: 15999'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预分频器（TIMx_PSC** **值**）：15999'
- en: '**Period (TIMx_ARR** **value):** 499'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**周期（TIMx_ARR** **值）**：499'
- en: 'This means we have the following values:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们有以下值：
- en: The timer clock is 16,000,000 Hz
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定时器时钟为16,000,000 Hz
- en: The `TIMx_PSC` register is set to 15999, but since the prescaler divides the
    clock by the value plus one, we use 15999 + 1 = 16000
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TIMx_PSC`寄存器设置为15999，但由于预分频器将时钟除以值加一，我们使用15999 + 1 = 16000'
- en: The `TIMx_ARR` register is set to 499, but since the period counts to the value
    plus one, we use 499 + 1 = 500
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TIMx_ARR`寄存器设置为499，但由于周期计数到值加一，我们使用499 + 1 = 500'
- en: 'Plugging these values into our formula, we get the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些值代入我们的公式，我们得到以下结果：
- en: Update Event Frequency =![<math ><mrow><mstyle scriptlevel="+1"><mfrac><mn>16,000,000</mn><mrow><mfenced
    open="(" close=")"><mrow><mn>15999</mn><mo>+</mo><mn>1</mn></mrow></mfenced><mi
    mathvariant="normal">X</mi><mo>(</mo><mn>499</mn><mo>+</mo><mn>1</mn><mo>)</mo></mrow></mfrac></mstyle></mrow></math>](img/2.png)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 更新事件频率 =![<math ><mrow><mstyle scriptlevel="+1"><mfrac><mn>16,000,000</mn><mrow><mfenced
    open="(" close=")"><mrow><mn>15999</mn><mo>+</mo><mn>1</mn></mrow></mfenced><mi
    mathvariant="normal">X</mi><mo>(</mo><mn>499</mn><mo>+</mo><mn>1</mn><mo>)</mo></mrow></mfrac></mstyle></mrow></math>](img/2.png)
- en: =![<math ><mrow><mstyle scriptlevel="+1"><mfrac><mn>16,000,000</mn><mn>8000000</mn></mfrac></mstyle></mrow></math>](img/3.png)
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '![<math ><mrow><mstyle scriptlevel="+1"><mfrac><mn>16,000,000</mn><mn>8000000</mn></mfrac></mstyle></mrow></math>](img/3.png)'
- en: = 2Hz
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: = 2Hz
- en: This means the UEV occurs at a frequency of **2 Hz, or twice every second**.
    This concludes this section. In the next section, we will develop our timer driver.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着UEV以**2 Hz的频率发生，或每秒两次**。本节到此结束。在下一节中，我们将开发我们的定时器驱动程序。
- en: Developing the timer driver
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发定时器驱动程序
- en: In this section, we will apply the knowledge gained about the TIM peripheral
    to develop a driver for generating delays.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将应用关于TIM外设的知识来开发一个生成延迟的驱动程序。
- en: First, create a copy of your previous project in your IDE, following the steps
    outlined in earlier chapters. Rename this copied project `GTIM`. Next, create
    a new file named `tim.c` in the `Src` folder and another file named `tim.h` in
    the `Inc` folder.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在您的IDE中创建您之前项目的副本，按照前面章节中概述的步骤进行。将此复制的项目重命名为`GTIM`。接下来，在`Src`文件夹中创建一个名为`tim.c`的新文件，并在`Inc`文件夹中创建一个名为`tim.h`的新文件。
- en: 'Our goal is to develop a driver that initializes TIM2 to generate a 1 Hz timeout.
    Populate your `tim.c` file with the following code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是开发一个驱动程序，初始化TIM2以生成1 Hz的超时。在`tim.c`文件中填充以下代码：
- en: '[PRE0]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s break it down:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下：
- en: '[PRE1]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `TIM2EN` instance is defined as `(1U<<0)`, which sets bit 0\. This is used
    to enable the clock for TIM2.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`TIM2EN`实例定义为`(1U<<0)`，这设置了位0。这用于启用TIM2的时钟。'
- en: 'The `CR1_CEN` instance is defined as `(1U<<0)`, which also sets bit 0\. This
    is used to enable the counter in the TIM2 control register 1 (`CR1`):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`CR1_CEN`实例定义为`(1U<<0)`，这也设置了位0。这用于在TIM2控制寄存器1（`CR1`）中启用计数器：'
- en: '[PRE2]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This line enables the clock for TIM2 by setting the appropriate bit in the
    APB1 peripheral clock enable register (`RCC->APB1ENR`):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码通过在APB1外设时钟使能寄存器（`RCC->APB1ENR`）中设置适当的位来启用TIM2的时钟：
- en: '[PRE3]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The prescaler value is set to 1599\. The prescaler divides the input clock
    frequency (16 MHz) by (1599 + 1), resulting in a 10,000 Hz (10 kHz) timer clock:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 预分频器值设置为1599。预分频器将输入时钟频率（16 MHz）除以（1599 + 1），结果为10,000 Hz（10 kHz）的定时器时钟：
- en: '[PRE4]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The auto-reload value is set to 9999\. This means the timer will count from
    0 to 9999, creating a period of 10,000 ticks. Since the timer clock is 10 kHz,
    counting 10,000 ticks results in 1 second (10,000 / 10,000 Hz = 1 s):'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 自动重载值设置为9999。这意味着定时器将从0计数到9999，形成一个10,000次的周期。由于定时器时钟为10 kHz，计数10,000次将产生1秒（10,000
    / 10,000 Hz = 1 s）：
- en: '[PRE5]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This line resets the timer counter to 0\. It ensures that the counting starts
    from 0 when the timer is enabled:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码将定时器计数器重置为0。它确保定时器启用时计数从0开始：
- en: '[PRE6]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This line enables the timer by setting the `CEN` (Counter Enable) bit in the
    TIM2 control register 1 (`CR1`). This starts the timer, and it begins counting
    based on the configured prescaler and auto-reload values.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码通过在TIM2控制寄存器1（`CR1`）中设置`CEN`（计数器使能）位来启用定时器。这启动了定时器，并开始根据配置的预分频器和自动重载值进行计数。
- en: 'In summary, our code accomplishes the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们的代码实现了以下功能：
- en: Enables the clock for TIM2.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用TIM2的时钟。
- en: Sets a prescaler value to divide the input clock to 10 kHz.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个预分频器值，将输入时钟除以10 kHz。
- en: Sets an auto-reload value to make the timer count up to 10,000, creating a 1-second
    period.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个自动重载值，使定时器计数到10,000，形成一个1秒的周期。
- en: Clears the timer counter.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清除定时器计数器。
- en: Enables the timer.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用定时器。
- en: Our next task is to populate the `tim.h` file.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的任务是填充`tim.h`文件。
- en: 'Here is the code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是代码：
- en: '[PRE7]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following line defines a `SR_UIF` macro that sets the 0th bit (least significant
    bit) to 1:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行定义了一个`SR_UIF`宏，将第0位（最低有效位）设置为1：
- en: '[PRE8]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This bit represents the UIF in the SR of the timer. When the timer overflows
    or reaches the auto-reload value, this flag is set, indicating a UEV. We will
    need to access this bit in the `main.c` file.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此位代表定时器状态寄存器（`SR`）中的UIF。当定时器溢出或达到自动重载值时，此标志被设置，表示UEV。我们将在`main.c`文件中访问此位。
- en: We are now ready to test inside `main.c`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已准备好在`main.c`中进行测试。
- en: 'Update your `main.c` file as shown next:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下所示更新您的`main.c`文件：
- en: '[PRE9]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this code, we initialize the LED and TIM2 to toggle the LED at a 1 Hz frequency.
    The code works by waiting for the timer’s UIF to be set, indicating that 1 second
    has passed, then toggling the LED and clearing the UIF to repeat the process.
    This cycle continues indefinitely in the main loop, resulting in the LED toggling
    every second.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们初始化LED和TIM2，以1 Hz的频率切换LED。代码通过等待定时器的UIF被设置，表示已过去1秒，然后切换LED并清除UIF以重复此过程。此循环在主循环中无限期地继续，导致LED每秒切换一次。
- en: Summary
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the general-purpose timers (TIM) in the STM32F411
    microcontroller, which are distinct from the SysTick timer and offer a variety
    of features crucial for embedded systems applications. We began by discussing
    the fundamental uses of timers, emphasizing their importance in tasks such as
    time interval measurement, delay generation, and event triggering.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了STM32F411微控制器中的通用定时器（TIM），它们与SysTick定时器不同，为嵌入式系统应用提供了各种关键功能。我们首先讨论了定时器的基本用途，强调了它们在时间间隔测量、延迟生成和事件触发等任务中的重要性。
- en: We then learned about the specifics of STM32 timers, detailing their classification
    into general-purpose and advanced timers.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后了解了STM32定时器的具体细节，详细说明了它们分为通用定时器和高级定时器。
- en: Next, we examined the workings of STM32 timers, focusing on key registers such
    as the counter register (`TIMx_CNT`), prescaler register (`TIMx_PSC`), and auto-reload
    register (`TIMx_ARR`). We explained how the timer’s clock prescaling mechanism
    reduces the system clock to a suitable frequency for the timer and how this affects
    the timer’s operation.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查了STM32计时器的运作原理，重点关注计数器寄存器（`TIMx_CNT`）、预分频器寄存器（`TIMx_PSC`）和自动重载寄存器（`TIMx_ARR`）。我们解释了计时器的时钟预分频机制如何将系统时钟降低到适合计时器的频率，以及这如何影响计时器的操作。
- en: We also provided a practical example of computing UEV frequency, demonstrating
    how to calculate the period and frequency of the timer based on the prescaler
    and auto-reload values.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还提供了一个计算UEV频率的实际示例，展示了如何根据预分频器和自动重载值计算计时器的周期和频率。
- en: Finally, we applied the theoretical knowledge by developing a timer driver for
    TIM2 to generate a 1 Hz timeout. In the next chapter, we will learn about another
    useful peripheral.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过为TIM2开发计时器驱动程序来应用理论知识，以生成1 Hz的超时。在下一章中，我们将学习另一个有用的外围设备。
