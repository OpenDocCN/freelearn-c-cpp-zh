- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: General-Purpose Timers (TIM)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will delve into the **general-purpose timers** (**TIM**)
    found in the STM32F411 microcontroller. Unlike the SysTick timer, these timer
    peripherals are unique to STM32 microcontrollers and offer a range of capabilities
    essential for various applications.
  prefs: []
  type: TYPE_NORMAL
- en: We will begin by discussing the common uses of timers, providing a foundation
    for understanding their importance in embedded systems. Following this, we will
    explore the specific characteristics of the timers on STM32 microcontrollers.
    This includes understanding the timer clock source, the mechanics of prescaling,
    and a detailed look at the commonly used timer registers.
  prefs: []
  type: TYPE_NORMAL
- en: In the latter part of the chapter, we will put theory into practice by developing
    a timer driver and applying the knowledge we’ve gained to create functional and
    efficient code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to timers and their uses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common use cases of timers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: STM32 timers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing the timer driver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a good understanding of STM32 timers
    and how to develop drivers for them, enhancing your ability to utilize these peripherals
    effectively in your projects.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming](https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming).
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to timers and their uses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Timers are crucial components in embedded systems, serving essential functions
    in a wide array of applications. In this section, we will explore the concept
    of timers, their types, and their various applications.
  prefs: []
  type: TYPE_NORMAL
- en: The question is, *What* *are timers?*
  prefs: []
  type: TYPE_NORMAL
- en: Timers are hardware peripherals found in microcontrollers that **count clock
    pulses**. **These pulses can be used to measure time intervals, generate precise
    delays, or trigger events at specific intervals**. Timers can operate in several
    modes, including **counting up**, **counting down**, and generating **Pulse Width
    Modulation** (**PWM**) signals.
  prefs: []
  type: TYPE_NORMAL
- en: The choice between using the SysTick timer and general-purpose timers on STM32
    microcontrollers comes down to the complexity and precision of your timing needs.
    While the SysTick timer is great for simple system timing tasks such as generating
    periodic interrupts or creating delays, it’s limited in flexibility and features,
    as it’s often dedicated to **real-time operating system** (**RTOS**) ticks. On
    the other hand, general-purpose timers, as we have just discussed, offer far more
    versatility, with the ability to handle complex tasks such as PWM generation,
    input capture, and output compare. They also support multiple channels for concurrent
    timing events and provide advanced functionalities such as precise frequency measurement
    and low-power operation.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore some typical use cases to illustrate the importance of timers.
  prefs: []
  type: TYPE_NORMAL
- en: Common use cases of timers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s start with timers for time interval measurement.
  prefs: []
  type: TYPE_NORMAL
- en: Time interval measurement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One common use of timers is in ultrasonic sensors for distance measurement,
    widely used in robotics, automotive parking systems, and obstacle detection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Timers play a vital role in the operation of these sensors. Here’s how they
    work:'
  prefs: []
  type: TYPE_NORMAL
- en: The microcontroller sends a trigger signal to the ultrasonic sensor, causing
    it to emit an ultrasonic pulse.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The sensor waits for the echo of the pulse to return after bouncing off an object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A timer starts counting when the pulse is emitted and stops when the echo is
    received.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The time interval measured by the timer is used to calculate the distance to
    the object based on the speed of sound.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By accurately measuring the time interval between sending the pulse and receiving
    the echo, the system can determine the distance to objects, enabling precise navigation
    and obstacle avoidance.
  prefs: []
  type: TYPE_NORMAL
- en: Timers are also essential for generating precise delays, such as in the refresh
    mechanism of **light-emitting diode** (**LED**) matrix displays.
  prefs: []
  type: TYPE_NORMAL
- en: Delay generation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In embedded systems, LED matrix displays are used for various applications,
    including digital signage, scoreboards, and simple graphical displays. To display
    images or text, the microcontroller needs to refresh the display at a precise
    rate to ensure smooth visuals.
  prefs: []
  type: TYPE_NORMAL
- en: 'Over here, the following happens:'
  prefs: []
  type: TYPE_NORMAL
- en: The microcontroller drives an LED matrix display and needs to refresh the display
    rows sequentially.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A timer generates precise delays to control the time each row is activated before
    moving to the next row.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, the timer might be set to generate a delay of 1 millisecond between
    switching rows.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This ensures that each row is displayed for a consistent period, maintaining
    a stable and flicker-free image.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, let’s see an example of how timers can be used for triggering events in
    embedded systems.
  prefs: []
  type: TYPE_NORMAL
- en: Event trigger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Periodic data sampling from sensors is important for applications such as environmental
    monitoring and **industrial process control** (**IPC**). A timer can be used to
    trigger the **analog-to-digital converter** (**ADC**) at specific intervals to
    ensure consistent data sampling.
  prefs: []
  type: TYPE_NORMAL
- en: 'Over here, the following happens:'
  prefs: []
  type: TYPE_NORMAL
- en: The microcontroller is connected to an environmental sensor (for example, a
    temperature or humidity sensor) that outputs an analog signal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A general-purpose timer is configured to trigger the ADC conversion periodically
    (for example, every 100 milliseconds)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ADC is set up to use the timer trigger option, automatically starting a
    conversion at each timer event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main loop of the microcontroller regularly checks for completed ADC conversions
    and processes the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will focus on the features and characteristics of STM32
    timers.
  prefs: []
  type: TYPE_NORMAL
- en: STM32 timers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The timers in STM32 microcontrollers are classified into two main categories:
    **general-purpose timers** and **advanced timers**.'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to general-purpose timers and advanced timers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: General-purpose timers are highly versatile and can be used for a variety of
    applications, whereas advanced timers offer more sophisticated features than general-purpose
    timers, making them suitable for high-precision and complex timing tasks.
  prefs: []
  type: TYPE_NORMAL
- en: In the STM32F411 microcontroller, timers **TIM2**, **TIM3**, **TIM4**, **TIM5**,
    **TIM9**, **TIM10**, and **TIM11** are general-purpose timers, whereas **TIM1**
    is an advanced timer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Key features of the general-purpose timers include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Counter size**: They feature 16-bit counters for TIM3 and TIM4 and 32-bit
    counters for TIM2 and TIM5, capable of operating in up, down, or up/down auto-reload
    modes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prescaler**: They are equipped with a 16-bit programmable prescaler, which
    allows us to divide the counter-clock frequency by any factor ranging from 1 to
    65,536'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Channels**: They offer up to four independent channels'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Synchronization**: The timers can synchronize with external signals and interconnect
    with multiple timers, enhancing flexibility and coordination in complex applications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interrupt/direct memory access (DMA) generation**: The timers can generate
    interrupts or DMA requests based on various events, including counter overflow/underflow,
    counter initialization, trigger events, input capture, and output compare'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Encoder support**: These timers also support incremental (quadrature) encoders
    and Hall-sensor circuitry, making them suitable for precise positioning applications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The advanced timer, TIM1, has a 16-bit counter size. Apart from the difference
    in counter size, it shares all the features of the general-purpose timers with
    the following additional features:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Complementary outputs**: Support for complementary outputs with programmable
    dead-time insertion'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Repetition counter**: Allows updating the timer registers only after a specific
    number of counter cycles'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Break input**: It has the ability to put the timer’s output signals into
    a reset or known state upon activation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we start analyzing some of the key registers provided in the reference
    manual, let’s first understand how STM32 timers work.
  prefs: []
  type: TYPE_NORMAL
- en: How STM32 timers work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The core of the timer is the 16-bit/32-bit counter and its associated auto-reload
    register. The counter can count upward or downward, and its clock can be divided
    by a prescaler. We can read from and write to the counter, auto-reload register,
    and prescaler register even while the counter is running.
  prefs: []
  type: TYPE_NORMAL
- en: 'The time-base unit includes the following registers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TIMx_CNT`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TIMx_PSC`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TIMx_ARR`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The prescaler register (`TIMx_PSC`) divides the timer’s input clock frequency
    by a programmable value between 1 and 65,536\. This allows for slower counting
    rates to accommodate longer timing intervals.
  prefs: []
  type: TYPE_NORMAL
- en: The auto-reload register (`TIMx_ARR`) defines the value at which the counter
    resets to zero in up-counting mode or to the auto-reload value in down-counting
    mode. We use it to set the period of the timer.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the registers in the time-base unit, the timer peripheral also includes
    control registers (`TIMx_CR1`, `TIMx_CR2`, and so on) for configuring the various
    operational parameters, such as enabling the counter, setting the counting direction,
    and configuring `TIMx_SR`) indicates the status of the timer, such as whether
    a UEV has occurred and other auxiliary registers for controlling the timer, among
    other things.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we mentioned earlier, the timer has two counting modes: up-counting mode
    and down-counting mode. Let’s break them down:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TIMx_ARR`) and generates a UEV on overflow'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Down-counting mode**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The counter counts down from the auto-reload value to 0 and generates a UEV
    on underflow
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next question that arises is: *What exactly is* *a UEV?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s break this down:'
  prefs: []
  type: TYPE_NORMAL
- en: In simple terms, it is when the timeout should occur
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the counter reaches the auto-reload value or 0 (based on the count mode),
    a UEV occurs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This event can trigger an interrupt or a DMA request and set the `TIMx_SR`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UEVs can also be generated manually by setting the `TIMx_EGR`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we know what a UEV is, let’s understand how timer clock prescaling
    is achieved; this will enable us to accurately calculate the timing for UEVs.
  prefs: []
  type: TYPE_NORMAL
- en: Timer clock prescaling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We use prescaling to reduce the high-frequency system clock to a lower frequency
    suitable for driving the timer. *Figure 9**.1* illustrates the process of timer
    clock pre-scaling in our STM32 microcontroller, showing how the system clock (`SYSCLK`)
    is divided down to drive the timer counters (`TIMx_CNT`) through a series of prescalers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1: Timer clock prescaling](img/B21914_09_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.1: Timer clock prescaling'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explain each component and step involved in this process:'
  prefs: []
  type: TYPE_NORMAL
- en: '**System** **clock (SYSCLK)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is the main system clock that drives the microcontroller. It serves as
    the initial clock source for all subsequent operations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`SYSCLK` frequency by a factor of 1, 2, 4, 8, 16, 64, 128, 256, or 512\. The
    resulting clock signal is referred to as **HCLK** (AHB clock).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**High-performance Bus** **Clock (HCLK)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is the clock signal generated after the AHB prescaler. It is used to drive
    the core and the system bus.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Advanced Peripheral Bus (****APB) prescalers**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**APB1 prescaler**: This further divides HCLK to generate the clock for the
    APB1 peripheral bus. The division factors available are 1, 2, 4, 8, and 16.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**APB2 prescaler**: Similar to the APB1 prescaler but used for the APB2 peripheral
    bus. It also divides HCLK by factors of 1, 2, 4, 8, and 16.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Timer** **prescaler (TIMx_PSC)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each timer has its own prescaler register that can divide the APB1 or APB2 clock
    further by any value between 1 and 65,535\. This flexibility allows for precise
    control over the timer’s counting rate.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`TIMx_PSC`. The rate at which this counter increments or decrements depends
    on the combined division effect of the previous prescalers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The prescalers directly influence the rate at which the timer counter (`TIMx_CNT`)
    increments or decrements. While the other prescalers (AHB and APB) are shared
    among all peripherals on the same bus, `TIMx_PSC` prescaler, we can precisely
    control the resolution and period of that specific timer without affecting other
    peripherals.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s learn how to compute a UEV.
  prefs: []
  type: TYPE_NORMAL
- en: Computing a UEV
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A UEV occurs when the timer counter reaches the value set in the auto-reload
    register (`TIMx_ARR`) in up-counting mode. Calculating this event is crucial for
    determining the timer’s period and ensuring it operates at the desired frequency.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can derive the frequency of the UEV with the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: Update Event Frequency = ![<math ><mrow><mstyle scriptlevel="+1"><mfrac><mrow><mi>T</mi><mi>i</mi><mi>m</mi><mi>e</mi><mi>r</mi><mi>C</mi><mi>l</mi><mi>o</mi><mi>c</mi><mi>k</mi></mrow><mrow><mfenced
    open="(" close=")"><mrow><mi>P</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>c</mi><mi>a</mi><mi>l</mi><mi>e</mi><mi>r</mi><mo>+</mo><mn>1</mn></mrow></mfenced><mi
    mathvariant="normal">X</mi><mo>(</mo><mi>P</mi><mi>e</mi><mi>r</mi><mi>i</mi><mi>o</mi><mi>d</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow></mfrac></mstyle></mrow></math>](img/1.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SYSCLK` when using the default clock configuration (in a bare-metal setup)
    on the NUCLEO-F411 development board.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TIMx_PSC` register.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TIMx_ARR` register.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s see an example. Let’s say we have the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Timer clock (APB1 clock)**: 16 MHz'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prescaler (TIMx_PSC** **value)**: 15999'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Period (TIMx_ARR** **value):** 499'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This means we have the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: The timer clock is 16,000,000 Hz
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `TIMx_PSC` register is set to 15999, but since the prescaler divides the
    clock by the value plus one, we use 15999 + 1 = 16000
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `TIMx_ARR` register is set to 499, but since the period counts to the value
    plus one, we use 499 + 1 = 500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Plugging these values into our formula, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Update Event Frequency =![<math ><mrow><mstyle scriptlevel="+1"><mfrac><mn>16,000,000</mn><mrow><mfenced
    open="(" close=")"><mrow><mn>15999</mn><mo>+</mo><mn>1</mn></mrow></mfenced><mi
    mathvariant="normal">X</mi><mo>(</mo><mn>499</mn><mo>+</mo><mn>1</mn><mo>)</mo></mrow></mfrac></mstyle></mrow></math>](img/2.png)
  prefs: []
  type: TYPE_NORMAL
- en: =![<math ><mrow><mstyle scriptlevel="+1"><mfrac><mn>16,000,000</mn><mn>8000000</mn></mfrac></mstyle></mrow></math>](img/3.png)
  prefs: []
  type: TYPE_NORMAL
- en: = 2Hz
  prefs: []
  type: TYPE_NORMAL
- en: This means the UEV occurs at a frequency of **2 Hz, or twice every second**.
    This concludes this section. In the next section, we will develop our timer driver.
  prefs: []
  type: TYPE_NORMAL
- en: Developing the timer driver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will apply the knowledge gained about the TIM peripheral
    to develop a driver for generating delays.
  prefs: []
  type: TYPE_NORMAL
- en: First, create a copy of your previous project in your IDE, following the steps
    outlined in earlier chapters. Rename this copied project `GTIM`. Next, create
    a new file named `tim.c` in the `Src` folder and another file named `tim.h` in
    the `Inc` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our goal is to develop a driver that initializes TIM2 to generate a 1 Hz timeout.
    Populate your `tim.c` file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break it down:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `TIM2EN` instance is defined as `(1U<<0)`, which sets bit 0\. This is used
    to enable the clock for TIM2.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CR1_CEN` instance is defined as `(1U<<0)`, which also sets bit 0\. This
    is used to enable the counter in the TIM2 control register 1 (`CR1`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This line enables the clock for TIM2 by setting the appropriate bit in the
    APB1 peripheral clock enable register (`RCC->APB1ENR`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The prescaler value is set to 1599\. The prescaler divides the input clock
    frequency (16 MHz) by (1599 + 1), resulting in a 10,000 Hz (10 kHz) timer clock:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The auto-reload value is set to 9999\. This means the timer will count from
    0 to 9999, creating a period of 10,000 ticks. Since the timer clock is 10 kHz,
    counting 10,000 ticks results in 1 second (10,000 / 10,000 Hz = 1 s):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This line resets the timer counter to 0\. It ensures that the counting starts
    from 0 when the timer is enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This line enables the timer by setting the `CEN` (Counter Enable) bit in the
    TIM2 control register 1 (`CR1`). This starts the timer, and it begins counting
    based on the configured prescaler and auto-reload values.
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, our code accomplishes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Enables the clock for TIM2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sets a prescaler value to divide the input clock to 10 kHz.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sets an auto-reload value to make the timer count up to 10,000, creating a 1-second
    period.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clears the timer counter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enables the timer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our next task is to populate the `tim.h` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following line defines a `SR_UIF` macro that sets the 0th bit (least significant
    bit) to 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This bit represents the UIF in the SR of the timer. When the timer overflows
    or reaches the auto-reload value, this flag is set, indicating a UEV. We will
    need to access this bit in the `main.c` file.
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to test inside `main.c`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update your `main.c` file as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we initialize the LED and TIM2 to toggle the LED at a 1 Hz frequency.
    The code works by waiting for the timer’s UIF to be set, indicating that 1 second
    has passed, then toggling the LED and clearing the UIF to repeat the process.
    This cycle continues indefinitely in the main loop, resulting in the LED toggling
    every second.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the general-purpose timers (TIM) in the STM32F411
    microcontroller, which are distinct from the SysTick timer and offer a variety
    of features crucial for embedded systems applications. We began by discussing
    the fundamental uses of timers, emphasizing their importance in tasks such as
    time interval measurement, delay generation, and event triggering.
  prefs: []
  type: TYPE_NORMAL
- en: We then learned about the specifics of STM32 timers, detailing their classification
    into general-purpose and advanced timers.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we examined the workings of STM32 timers, focusing on key registers such
    as the counter register (`TIMx_CNT`), prescaler register (`TIMx_PSC`), and auto-reload
    register (`TIMx_ARR`). We explained how the timer’s clock prescaling mechanism
    reduces the system clock to a suitable frequency for the timer and how this affects
    the timer’s operation.
  prefs: []
  type: TYPE_NORMAL
- en: We also provided a practical example of computing UEV frequency, demonstrating
    how to calculate the period and frequency of the timer based on the prescaler
    and auto-reload values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we applied the theoretical knowledge by developing a timer driver for
    TIM2 to generate a 1 Hz timeout. In the next chapter, we will learn about another
    useful peripheral.
  prefs: []
  type: TYPE_NORMAL
