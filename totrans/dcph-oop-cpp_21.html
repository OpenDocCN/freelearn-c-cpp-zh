<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-313"><a id="_idTextAnchor920"/>21</h1>
<h1 id="_idParaDest-314"><a id="_idTextAnchor921"/>Making C++ Safer</h1>
<p><a id="_idTextAnchor922"/>This bonus chapter will add insight into what we can do as C++ programmers to make the language as safe as possible in our everyday usage. We have progressed from basic language features to our core interest of OO programming with C++, to additional useful language features and libraries (exceptions, operator overloading, templates, and STL), to design patterns to give us a knowledge base to solve recurring types of OO programming problems. At every point along the way, we’ve seen that C++ requires extra care on our part to avoid tricky and potentially problematic programming situations. C++ is a language that will allow us to do anything, but with this power comes the need for guidelines to ensure our programming follows safe practices. After all, our goal is to create programs that will run successfully without errors and, additionally, be easy to maintain. The ability of C++ to do anything needs to be paired with sound practices to simply make C++ safer.</p>
<p>The goal of this chapter is to revisit topics that we have covered in previous chapters, reviewing them with an eye toward safety. We will also incorporate topics strongly related to ones we have seen previously. This chapter is not meant to cover wholly new topics or previous topics in great depth, but to provide a grouping of safer programming practices and the encouragement to seek further information on each topic as needed. Some of these topics can encompass entire chapters (or books) themselves!</p>
<p>In this bonus chapter, we will cover selected popular programming conventions to meet our safety challenge:</p>
<ul>
<li>Revisiting smart pointers (unique, shared, and weak), as well as a complementary idiom (RAII)</li>
<li>Using modern <code>for</code> loops (range-based, for-each) to avoid common errors</li>
<li>Adding type safety: usage of <code>auto</code> instead of explicit typing</li>
<li>Preferring usage of STL types for simple containers (<code>std::vector</code>, and so on)</li>
<li>Utilizing <code>const</code> appropriately to ensure non-modification of select items</li>
<li>Understanding thread safety issues</li>
<li>Considering core programming guideline essentials, such as preferring initialization to assignment, or choosing only one of <code>virtual</code>, <code>override</code>, or <code>final</code></li>
<li>Adopting C++ core programming guidelines for safety (build and assemble one, if necessary)</li>
<li>Understanding resources for programming safety in C++ </li>
</ul>
<p>By the end of this chapter, you will understand some of the current industry standards and concerns for programming safely in C++. This chapter is not meant to be a comprehensive list of all safety concerns and practices in C++, but to showcase the types of issues you will need to become mindful of as a successful C++ programmer. In some cases, you may desire to investigate a topic more deeply to gain a more thorough level of competence and proficiency. Adding safety to your C++ programming will make you a more valuable programmer, as your code will be more reliable and have more longevity and success.</p>
<p>Let’s round out our programming skillset by considering how we can make C++ safer.</p>
<h1 id="_idParaDest-315"><a id="_idTextAnchor923"/>Technical requirements</h1>
<p>Online code for full program examples can be found in the following GitHub URL: <a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter21">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter21</a>. Each full program example can be found in the GitHub repository under the appropriate chapter heading (subdirectory) in a file that corresponds to the chapter number, followed by a dash, followed by the example number in the chapter at hand. For example, the first full program in this chapter can be found in the subdirectory <code>Chapter21</code> in a file named <code>Chp21-Ex1.cpp</code> under the aforementioned GitHub directory. Some programs are in applicable subdirectories as indicated in the examples. </p>
<p>The CiA video for this chapter can be viewed at: <a href="https://bit.ly/3wpOG6b">https://bit.ly/3wpOG6b</a>.</p>
<h1 id="_idParaDest-316"><a id="_idTextAnchor924"/><a id="_idTextAnchor925"/><a id="_idTextAnchor926"/>Revisiting smart pointers</h1>
<p>Throughout the book, we have developed a reasonable<a id="_idIndexMarker1325"/> understanding of how to use raw or native C++ pointers, including the associated memory allocation and deallocation for heap instances. We have persevered through native C++ pointers because they are pervasive in existing C++ code. Having knowledge of how to properly utilize native pointers is essential in working with the volume of existing C++ code currently in use. But, for newly created code, there is a safer way to manipulate heap memory.</p>
<p>We have seen that dynamic memory management<a id="_idIndexMarker1326"/> with native pointers is a lot of work! Especially when there may be multiple pointers to the same chunk of memory. We’ve talked about reference counting to shared resources (such as heap memory) and mechanisms for deleting memory when all instances are done with the shared memory. We also know that memory deallocation can easily be overlooked, leading to memory leakage.</p>
<p>We have also seen, firsthand, that errors with native pointers can be costly. Our programs can end abruptly when we dereference memory we don’t intend to access, or when we dereference uninitialized native pointers (interpreting the memory to contain a valid address and meaningful data at that address—neither of which are actually valid). Pointer arithmetic to walk through memory can be laden with errors by an otherwise adept programmer. When a memory error is made, pointer or heap memory misuse are often the culprits. </p>
<p>Certainly, using references can ease the burden of many errors with native pointers. But references can still point to dereferenced heap memory that someone forgets to deallocate. For these and many other reasons, smart pointers have become popular in C++ with the primary purpose of making C++ safer. </p>
<p>We’ve talked about smart pointers in previous chapters and have seen them in action with our pImpl pattern (using <code>unique_ptr</code>). But there are more types of smart pointers for us to review in addition to unique: shared and weak. Let’s also make a programming premise (a future style guide addition) to prefer smart pointers in our newly created code to native pointers for the purpose and value of pointer safety.</p>
<p>Recall that a <strong class="bold">smart pointer</strong> is a small wrapper class that encapsulates a raw or native pointer, ensuring that the pointer it contains is automatically deleted when the wrapper object goes out of scope. The Standard C++ Library implementations of <em class="italic">unique</em>, <em class="italic">shared</em>, and <em class="italic">weak</em> smart pointers use templates to create a specific category of smart pointer for any data type. </p>
<p>Though we could devote an entire chapter to each type of smart pointer in depth, we will review each type briefly as a starting point to encourage their usage in newly created code to support our goal of making C++ safer. </p>
<p>Now, let’s revisit each type of smart pointer, one by one.</p>
<h2 id="_idParaDest-317">Using smart pointers – uniqu<a id="_idTextAnchor927"/>e</h2>
<p>Recall that a <code>unique_ptr</code> in the Standard<a id="_idIndexMarker1327"/> C++ Library, is a type<a id="_idIndexMarker1328"/> of smart pointer that encapsulates exclusive ownership and access to a given heap memory resource. A <code>unique_ptr</code> cannot be duplicated; the owner of a <code>unique_ptr</code> will have sole use of that pointer. Owners of unique pointers can choose to move these pointers to other resources, but the repercussions are that the original resource will no longer contain <code>unique_ptr</code>. Recall that we must use <code>#include &lt;memory&gt;</code> to include the definition for <code>unique_ptr</code>.</p>
<p>Here is a very simple example illustrating how to create unique pointers. This example can be found in our GitHub repository:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter21/Chp21-Ex1.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter21/Chp21-Ex1.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include "Person.h"
using std::cout;   // preferred to: using namespace std;
using std::endl;
<strong class="bold">using std::unique_ptr;</strong>
<strong class="bold">// We will create unique pointers, with and without using</strong>
<strong class="bold">// the make_unique (safe wrapper) interface</strong>
int main()
{
    <strong class="bold">unique_ptr&lt;int&gt; p1(new int(100));</strong>
    cout &lt;&lt; *p1 &lt;&lt; endl;
    <strong class="bold">unique_ptr&lt;Person&gt; pers1(new Pe<a id="_idTextAnchor928"/>r<a id="_idTextAnchor929"/>son("Renee",</strong>
<strong class="bold">                             "Alexander",'K', "Dr.<a id="_idTextAnchor930"/>"));</strong>
    (*pers1).Print();      // or use: pers1-&gt;Print();
<strong class="bold">    unique_ptr&lt;Person&gt; pers2;</strong> // currently uninitialized
<strong class="bold">    pers2 = move(pers1);</strong><strong class="bold">   </strong>// take over another unique
                           // pointer's resource
    pers2-&gt;Print();        // or use: (*pers2).Print();  
    <strong class="bold">// make_unique provides a safe wrapper, eliminating</strong>
<strong class="bold">    // obvious use of heap allocation with new()</strong>
    <strong class="bold">auto pers3 = make_unique&lt;Person&gt;("Giselle", "LeBrun",</strong>
                                      <strong class="bold">'R', "Ms.");</strong>
    pers3-&gt;Print();        
    return 0;
}</pre>
<p>First, notice that because<a id="_idIndexMarker1329"/> we included <code>using std::unique_ptr;</code>, we did not need<a id="_idIndexMarker1330"/> to qualify <code>unique_ptr</code> or <code>make_unique</code> with <code>std::</code> in the unique pointer declarations. In this small program, we create several unique pointers, starting with one to point to an integer, <code>p1</code>, and one to point to an instance of a <code>Person</code>, <code>pers1</code>. Each of these variables has exclusive use of the heap memory each points to because we are using unique pointers. </p>
<p>Next, we introduce a unique pointer, <code>pers2</code>, that takes over the memory originally allocated and linked to <code>pers1</code> using <code>pers2 = move(pers1);</code>. The original variable no longer has access to this memory. Note that though we could have allocated <code>pers2</code> to have its own, unique heap memory, we instead chose to demonstrate how to allow one unique pointer to relinquish its memory to another unique pointer using <code>move()</code>. Changing the ownership of unique pointers with <code>move()</code> is typical, as unique pointers cannot be copied (because that would allow two or more pointers to share the same memory and, therefore, not be unique!) </p>
<p>Finally, we create another<a id="_idIndexMarker1331"/> unique pointer, <code>pers3</code>, that utilizes <code>make_unique</code> as a wrapper<a id="_idIndexMarker1332"/> to allocate the heap memory for the unique pointer that <code>pers3</code> will represent. The preference for using <code>make_unique</code> is that the call to <code>new()</code> will be made internally, on our behalf. Additionally, any exceptions thrown during the construction of the object will be handled for us, as will any call to <code>delete()</code>, should the underlying <code>new()</code> not complete successfully and a call to <code>delete()</code> is then warranted. </p>
<p>The heap memory will be managed for us automatically; this is one of the benefits of using a smart pointer. </p>
<p>Here is the output for our <code>unique_ptr</code> example:</p>
<pre>100
Dr. Renee K. Alexander
Dr. Renee K. Alexander
Ms. Giselle LeBrun
Person destructor
Person destructor</pre>
<p>Under the hood, the destructor will automatically be called for each object pointed to by a smart pointer, when the memory is no longer utilized. In the case of this example, the destructor for each <code>Person</code> object is called on our behalf when the local objects in <code>main()</code> go out of scope and are popped off the stack. Note that our <code>Person</code> destructor contains a <code>cout</code> statement so that we can visualize that there are only two <code>Person</code> objects destructed. Here, the destructed <code>Person</code> objects represent the instance taken over by <code>pers2</code> (from <code>pers1</code>) via the <code>move()</code> statement, and the <code>pers3</code> object that was created using the <code>make_unique</code> wrapper.</p>
<p>Next, let’s add examples using shared and weak smart po<a id="_idTextAnchor931"/>inters.</p>
<h2 id="_idParaDest-318"><a id="_idTextAnchor932"/>Using smart pointers – shared</h2>
<p>A <code>shared_ptr</code> in the<a id="_idIndexMarker1333"/> Standard C++ Library, is<a id="_idIndexMarker1334"/> a type of smart pointer that permits shared ownership of and access to a given resource. The last shared pointer to the resource in question will trigger the destruction and memory deallocation of the resource. Shared pointers can be used in multithreaded applications; however, race conditions may occur if non-constant member functions are used to modify the shared resource. Since shared pointers only provide reference counting, we will need to enlist additional library methods to solve these issues (alleviating race conditions, synchronizing access to critical regions of code, and so on). The Standard C++ Library, for example, provides overloaded atomic methods to lock, store, and compare the underlying data pointed to by a shared pointer.</p>
<p>We have seen many example<a id="_idIndexMarker1335"/> programs that could take advantage of shared pointers. For example, we utilized associations between the <code>Course</code> and <code>Student</code> classes – a given student is associated with many courses and a given course is associated with many students. Clearly, multiple <code>Student</code> instances may point to the same <code>Course</code> instance, and vice versa. </p>
<p>Previously, with raw pointers, it was the programmer’s responsibility to employ reference counting. In contrast, using shared pointers, the internal reference counter is atomically incremented and decremented in support of both pointer and thread safety. </p>
<p>Dereferencing a shared pointer is nearly as fast as dereferencing a raw pointer; however, because a shared pointer represents a wrapped pointer in a class, constructing and copying a shared pointer is more expensive. However, we are interested in making C++ safer, so we will simply note this very minor performance expense and move forward.</p>
<p>Let’s take a look at a very simple example using <code>shared_ptr</code>. This example can be found in our GitHub repository:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter21/Chp21-Ex2.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter21/Chp21-Ex2.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include "Person.h"
using std::cout;   // preferred to: using namespace std;
using std::endl;
<strong class="bold">using std::shared_ptr;</strong>
int main()
{
<strong class="bold">    shared_ptr&lt;int&gt; p1 = std::make_shared&lt;int&gt;(100);</strong>
    // alternative to preferred, previous line of code:
    // shared_ptr&lt;int&gt; p1(new int(100));
<strong class="bold">    shared_ptr&lt;int&gt; p2;</strong>// currently uninitialized (caution)
    p2 = p1; // p2 now shares the same memory as p1
    cout &lt;&lt; *p1 &lt;&lt; " " &lt;&lt; *p2 &lt;&lt; endl;
    <strong class="bold">shared_ptr&lt;Person&gt; pers1 = std::make_shared&lt;Person&gt;</strong>
                          <strong class="bold">("Gabby", "Doone", 'A', "Miss");</strong>
    // alternative to preferred, previous lines of code:
    // shared_ptr&lt;Person&gt; pers1(<a id="_idTextAnchor933"/>new Person("Gabby",
    //                              "Doone",'A', "Miss"));
    <strong class="bold">shared_ptr&lt;Person&gt; pers2 = pers1;</strong>  // ini<a id="_idTextAnchor934"/>tialized
    pers1-&gt;Print();   // or use: (*pers1).Print();
    pers2-&gt;Print();   
    pers1-&gt;ModifyTitle("Dr."); // changes shared instance
    pers2-&gt;Print();   
    cout &lt;&lt; "Number of references: " &lt;&lt; <strong class="bold">pers1.use_count()</strong>;
    return 0;
}</pre>
<p>In the aforementioned program, we create<a id="_idIndexMarker1336"/> four shared pointers – two to point<a id="_idIndexMarker1337"/> to the same integer (<code>p1</code> and <code>p2</code>) and two to point to the same instance of <code>Person</code> (<code>pers1</code> and <code>pers2</code>). Each of these variables may change the specific shared memory they point to because we are using shared pointers (which allow such a reassignment). A change to the shared memory through <code>pers1</code>, for example, will be reflected should we then review the (shared) memory through pointer <code>pers2</code>; both variables point to the same memory location.</p>
<p>The heap memory will again be managed for us automatically as a benefit of using smart pointers. In this example, the memory will be destructed and deleted when the last reference to the memory is removed. Notice that reference counting is done on our behalf and that we can access this information using <code>use_count()</code>.</p>
<p>Let us notice something interesting about the previous example. Notice the mixed use of <code>-&gt;</code> and <code>.</code> notation with shared pointer variables <code>pers1</code> and <code>pers2</code>. For example, we utilize <code>pers1-&gt;Print();</code> and yet we also utilize <code>pers1.use_count()</code>. This is no mistake and reveals the wrapper implementation of the smart pointer. With that in mind, we know that <code>use_count()</code> is a method of <code>shared_ptr</code>. Our shared pointers <code>pers1</code> and <code>pers2</code> are each declared as instances of <code>shared_ptr</code> (definitely not using raw C++ pointers with the symbol <code>*</code>). Hence, dot notation is appropriate to access method <code>use_count()</code>. Yet, we are using <code>-&gt;</code> notation to access <code>pers1-&gt;Print();</code>. Here, recall that this notation is equivalent to <code>(*pers1).Print();</code>. Both <code>operator*</code> and <code>operator-&gt;</code> in the <code>shared_ptr</code> class are overloaded to delegate to the wrapped, raw pointer contained within the smart pointer. Hence, we may utilize standard pointer notation to access <code>Person</code> methods (through the safely wrapped raw pointer).</p>
<p>Here is the output for our <code>shared_ptr</code> pointer example:</p>
<pre>100 100
Miss Gabby Doone
Miss Gabby Doone
Dr. Gabby Doone
Number of references: 2
Person destructor</pre>
<p>Shared pointers<a id="_idIndexMarker1338"/> seem like a wonderful way to ensure that memory resources<a id="_idIndexMarker1339"/> pointed to by multiple pointers are properly managed. Overall, this is true. However, there are situations with circular dependencies such that shared pointers simply cannot release their memory – another pointer is always pointing to the memory in question. This happens when a cycle of memory is orphaned; that is, when no outside shared pointers point <em class="italic">into</em> the circular connection. In such unique cases, we might actually (and counterintuitively) mismanage memory with shared pointers. In these situations, we can elicit help from a weak pointer to help us break the cycle. </p>
<p>With that in mind, let’s next take a look at weak s<a id="_idTextAnchor935"/>mart pointers.</p>
<h2 id="_idParaDest-319"><a id="_idTextAnchor936"/>Using smart pointers – weak</h2>
<p>A <code>weak_ptr</code> in the Standard<a id="_idIndexMarker1340"/> C++ Library, is a type of smart pointer<a id="_idIndexMarker1341"/> that does not take ownership of a given resource; instead, the weak pointer acts as an observer. Weak pointers can be used to help break a circular connection that may exist between shared pointers; that is, situations where the destruction of a shared resource would otherwise never occur. Here, a weak pointer is inserted into the chain to break the circular dependency that shared pointers alone might otherwise create. </p>
<p>As an example, imagine<a id="_idIndexMarker1342"/> our <code>Student</code> and <code>Course</code> dependencies from our initial programming examples utilizing association, or from our more complex program illustrating the Observer pattern. Each contains pointer data members of the associated object types, effectively creating a potential circular dependency. Now, should an outside (from the circle) shared pointer exist, such as an external list of courses or an external list of students, the exclusive circular dependency scenario may not arise. In this case, for example, the master list of courses (the external pointer, separate from any circular dependency existing between the associated objects) will provide the means to cancel a course, leading to its eventual destruction.</p>
<p>Likewise in our example, an external set of students comprising the university’s student body can provide an external pointer to the potentially circular shared pointer scenario resulting from the association between <code>Student</code> and <code>Course</code>. Yet in both of these cases, work will need to be done to remove a canceled course from a student’s course list (or remove a dropped student from a course’s student list). The removal of the associations in this scenario reflects accurately managing a student’s schedule or a course’s attendance list. Nonetheless, we can imagine scenarios where a circular connection may exist without an outside handle to the links (unlike the aforementioned scenario, which has outside links into the circle).</p>
<p>In the case where a circular<a id="_idIndexMarker1343"/> dependency exists (with no outside influences), we will need<a id="_idIndexMarker1344"/> to downgrade one of the shared pointers to a weak pointer. A weak pointer will not control the lifetime of the resource that it points to.</p>
<p>A weak pointer to a resource cannot access the resource directly. This is because operators <code>*</code> and <code>-&gt;</code> are not overloaded in the <code>weak_ptr</code> class. You will need to convert the weak pointer to a shared pointer in order to access methods of the (wrapped) pointer type. One way to do this is to apply the <code>lock()</code> method to a weak pointer, as the return value is a shared pointer whose contents are locked with a semaphore to ensure mutual exclusivity to t<a id="_idTextAnchor937"/>he shared resource.</p>
<p>Let’s take a look at a very simple example using <code>weak_ptr</code>. This example can be found on our GitHub:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter21/Chp21-Ex3.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter21/Chp21-Ex3.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include "Person.h"
using std::cout;   // preferred to: using namespace std;
using std::endl;
<strong class="bold">using std::weak_ptr;</strong>
<strong class="bold">using std::shared_ptr;</strong>
int main()
{
    // construct the resource using a shared pointer
    <strong class="bold">shared_ptr</strong>&lt;Person&gt; pers1 = <strong class="bold">std::make_shared</strong>&lt;Person&gt;
                           ("Gabby", "Doone", 'A', "Miss");
    pers1-&gt;Print(); // or alternatively: (*pers1).Print();
    // Downgrade resource to a weak pointer
    <strong class="bold">weak_ptr&lt;Person&gt; wpers1(pers1);</strong> 
    // weak pointer cannot access the resource; 
    // must convert to a shared pointer to do so
    // wpers1-&gt;Print();   // not allowed! operator-&gt; is not
                          // overloaded in weak_ptr class
    cout &lt;&lt; "# references: " &lt;&lt; pers1.use_count() &lt;&lt; endl;
    cout &lt;&lt; "# references: " &lt;&lt; wpers1.use_count() &lt;&lt; endl;
    // establish a new shared pointer to the resource
    <strong class="bold">shared_ptr</strong>&lt;Person&gt; pers2 = <strong class="bold">wpers1.lock()</strong>;  
    pers2-&gt;Print();
   <a id="_idTextAnchor938"/> pers2-&gt;ModifyTitle("Dr.");   // modify the resource
    pers2-&gt;Print();
    cout &lt;&lt; "# references: " &lt;&lt; pers1.use_count() &lt;&lt; endl;
    cout &lt;&lt; "# references: " &lt;&lt; <strong class="bold">wpers1.use_count()</strong> &lt;&lt; endl;
    cout &lt;&lt; "# references: " &lt;&lt; pers2.use_count() &lt;&lt; endl;
    return 0;
}</pre>
<p>In the aforementioned<a id="_idIndexMarker1345"/> program, we allocate our resource using a shared<a id="_idIndexMarker1346"/> pointer in <code>pers1</code>. Now, let us imagine we had a reason in our program to downgrade our resource to a weak pointer – perhaps we would like to insert a weak pointer to break an otherwise cycle of shared pointers. Using <code>weak_ptr&lt;Person&gt; wpers1(pers1);</code>, we establish a weak pointer to this resource. Notice that we cannot use <code>wpers1</code> to call <code>Print();</code>. This is because <code>operator-&gt;</code> and <code>operator*</code> have not been overloaded in the <code>weak_ptr</code> class. </p>
<p>We print out <code>use_count()</code> for each of <code>pers1</code> and <code>wpers1</code> to notice that each shows a value of <code>1</code>. That is, there is only one non-weak pointer controlling the resource in question (the weak pointer may temporarily hold the resource, but cannot modify it). </p>
<p>Now, imagine that we would like to convert the resource pointed to by <code>wpers1</code> on-demand to another shared pointer, so that we may access the resource. We can do so by first gaining a lock on the weak pointer; <code>lock()</code> will return a shared pointer whose contents are protected by a semaphore. We assign this value to <code>pers2</code>. We then call <code>pers2-&gt;ModifyTitle("Dr.");</code> on the resource using the shared pointer.  </p>
<p>Finally, we print out <code>use_count()</code> from the perspective of each of <code>pers1</code>, <code>wpers1</code>, and <code>pers2</code>. In each case, the reference count will be <code>2</code>, as there are two non-weak pointers referencing the shared resource. The weak pointer does not contribute to the reference count of that resource, which is exactly how weak pointers can help break a chain of circular dependencies. By inserting a weak pointer into the dependency loop, the reference count to the shared resource will not be affected by the weak pointer’s presence. This strategy allows the resource to be deleted when only the weak pointer to the resource remains (and the reference count is <code>0</code>). </p>
<p>The heap memory will again be managed for us automatically as a benefit of using smart pointers. In this example, the memory will be destructed and deleted when the last reference to the memory is removed. Again, note that the weak pointer did not contribute a reference to this count. We can see from the <code>cout</code> statement in the <code>Person</code> destructor that only one ins<a id="_idTextAnchor939"/>tance was destructed.</p>
<p>Here is the output for our <code>weak_ptr</code> pointer example:</p>
<pre>Miss Gabby Doone
# references: 1
# references: 1
Miss Gabby Doone
Dr. Gabby Doone
# references: 2
# references: 2
# references: 2
Person destructor</pre>
<p>In this section, we’ve reviewed<a id="_idIndexMarker1347"/> and added to the basics regarding smart pointers. However, there<a id="_idIndexMarker1348"/> could be a chapter easily spent on each type of smart pointer. Nonetheless, hopefully, you have enough comfort with the essentials to begin to include a variety of smart pointers in your code and investigate each type further as your need arises. </p>
<h2 id="_idParaDest-320"><a id="_idTextAnchor940"/>Exploring a complementary idea – RAII</h2>
<p>A programming idiom<a id="_idIndexMarker1349"/> that complements smart pointers (as well as other concepts) is <code>move()</code> operation.</p>
<p>Many C++ class libraries follow RAII for resource management, such as <code>std::string</code> and <code>std::vector</code>. These classes follow the idiom in that their constructors acquire the necessary resources (heap memory), and release the resources automatically in their destructors. The user of these classes is not required to explicitly release any memory for the container itself. In these class libraries, RAII as a technique is used to manage these resources, even though the heap memory is not managed using smart pointers. Instead, the concepts of RAII are encapsulated and hidden within the class implementations themselves.</p>
<p>When we implemented<a id="_idIndexMarker1350"/> our own smart pointers in <a href="B19087_20.xhtml#_idTextAnchor876"><em class="italic">Chapter 20</em></a>, <em class="italic">Removing Implementation Details Using the pImpl Pattern</em>, we used RAII, without knowing it, to ensure the allocation of the heap resource within our constructor and the release of the resource in our destructor. The smart pointers implemented in the Standard C++ Library (<code>std::unique_ptr</code>, <code>std::shared_ptr</code>, and <code>std::weak_ptr</code>) embrace this idiom as well. Embracing RAII by using classes employing this idiom (or by adding it yourself to classes when this is not possible), can help ensure code is safer and easier to maintain. Because of the safety and robustness that this idiom adds to code, savvy developers urge us to embrace RAII as one of the most important practices and features available in C++.</p>
<p>Next in our effort to make C++ safer, let’s consider several easy C++ features we can easily embrace to ensure our coding is more robust.</p>
<h1 id="_idParaDest-321">Embracing additional C++ <a id="_idTextAnchor941"/>features promoting safety</h1>
<p>As we have seen through 20 previous<a id="_idIndexMarker1351"/> chapters of programming, C++ is an extensive language. We know that C++ has great power and that we can do nearly anything in C++. As object-oriented C++ programmers, we have seen how to adopt OO designs, with the goal of making our code more easily maintainable.</p>
<p>We have also gained a lot of experience utilizing raw (native) pointers in C++, primarily because raw pointers are very pervasive in existing code. You truly need experience and facility in using native pointers for when the need arises. In gaining this experience, we have seen firsthand the pitfalls we may encounter with mismanagement of heap memory – our programs may have crashed, we may have leaked memory, overwritten memory accidentally, left dangling pointers, and so on. Our first order of business in this chapter was to prefer using smart pointers in newly created code – to promote safety in C++. </p>
<p>Now, we will explore<a id="_idIndexMarker1352"/> other areas of C++ that we can similarly employ safer features. We have seen these various features throughout the book; it is important to establish a guideline that select language features promote safety in C++. Just because we can do anything in C++ doesn’t mean that we should routinely include features in our repertoire that have a high level of misuse associated with them. Applications that continually crash (or crash even once) are unacceptable. Certainly, we have noted no-nos throughout the book. Here, let’s point out language features that are worth embracing to further our goal of making C++ safer, leaving our applications more robust and more easily maintainable.</p>
<p>Let’s start by reviewing simple items we can incorporate into our everyday code.</p>
<h2 id="_idParaDest-322"><a id="_idTextAnchor942"/>Revisiting range for loops</h2>
<p>C++ has a variety of looping constructs<a id="_idIndexMarker1353"/> that we have seen throughout the book. One common error that occurs when processing a complete set of items is correctly keeping track of how many items are in the set, especially when this counter is used as a basis to loop through all items in the set. Processing too many elements when our set is stored as an array, for example, could lead our code to raise an exception unnecessarily (or worse, could lead our program to crash). </p>
<p>Rather than relying on a <code>MAX</code> value to conduct our looping for all elements in a set, it is more desirable to loop through every item in the set in a way that doesn’t count on the programmer correctly remembering this upper loop value. Instead, for each item in the set, let’s do some sort of processing. A for-each loop answers this need quite nicely.</p>
<p>One common error that occurs when processing a non-complete set of items is correctly keeping track of how many items are currently in the set. For example, a <code>Course</code> may have a maximum number of students permitted. Yet, as of today, only half of the potential <code>Student</code> slots are filled. When we peruse the list of students enrolled in the course, we need to ensure we are processing only the filled student spots (that is, the current number of students). Processing all maximum student spots would clearly be an error and could lead our program to crash. In this scenario, we must use care to iterate only over the currently utilized <code>Student</code> spots in the <code>Course</code>, either through using logic to exit a loop when appropriate or by selecting a container type whose current size represents the complete size of the set to be iterated upon (with no empty <em class="italic">to be filled</em> spots); the latter scenario making a for-each loop an ideal choice. </p>
<p>Also, what if we rely on looping<a id="_idIndexMarker1354"/> based upon a <code>currentNumStudents</code> counter? This may be better than a <code>MAX</code> value in cases as previously illustrated, but what if we’ve not kept that counter correctly updated? We’re subject to an error on this as well. Again, combining a container class where the number of entries represents the current number of entries with a for-each type of loop can ensure that we process the complete, current grouping in a less error-prone manner.</p>
<p>Now that we have revisited modern and more safe looping styles, let’s embrace <code>auto</code> to ensure type safety. We will then see an example incorporating these collective feature<a id="_idTextAnchor943"/>s.</p>
<h2 id="_idParaDest-323"><a id="_idTextAnchor944"/>Using auto for type safety</h2>
<p>Many situations arise<a id="_idIndexMarker1355"/> in which using <code>auto</code> makes coding easier with respect<a id="_idIndexMarker1356"/> to variable declarations, including loop iterators. Additionally, using <code>auto</code> instead of explicit typing can ensure type safety. </p>
<p>Choosing to use <code>auto</code> is a simple way to declare a variable that has a complicated type. Using <code>auto</code> can also ensure that the best type is chosen for a given variable and that implicit conversion will not occur. </p>
<p>We can use <code>auto</code> as a placeholder for types in a variety of situations, allowing the compiler to deduce what is needed in a particular situation. We can even use <code>auto</code> as a return type for a function in many cases. Using <code>auto</code> allows our code to appear more generic and can complement templates as an alternative to genericizing a type. We can pair <code>auto</code> with <code>const</code>, and also pair these qualifiers with references; note that these qualifiers <em class="italic">combined</em> cannot be extrapolated with <code>auto</code> and must be specified individually by the programmer. Additionally, <code>auto</code> cannot also be used with qualifiers augmenting a type, such as <code>long</code> or <code>short</code>, nor can it be used with <code>volatile</code>. Though outside the scope of our book, <code>auto</code> can be utilized with lambda expressions. </p>
<p>Of course, using <code>auto</code> has a few drawbacks. For example, if the programmer doesn’t understand the type of object being created, the programmer may anticipate the compiler to select a certain type, and yet another (unexpected) type is deduced. This may create subtle errors in your code. For example, if you have overloaded functions for both the type you think <code>auto</code> will select and for the type the compiler actually deduces the <code>auto</code> declaration to be, you may call a different function than anticipated! Certainly, this may mostly be due to the programmer not fully understanding the context of usage at hand when inserting the <code>auto</code> keyword. Another drawback is when the programmer uses <code>auto</code> just to force the code to compile, without truly working through the syntax at hand and thinking about how the code should be written. </p>
<p>Now that we have<a id="_idIndexMarker1357"/> revisited adding <code>auto</code> to our code, let’s revisit embracing<a id="_idIndexMarker1358"/> STL in our everyday code. We will then see an example incorporating these collective features.</p>
<h2 id="_idParaDest-324"><a id="_idTextAnchor945"/>Preferring STL for simple containers</h2>
<p>The Standard Template<a id="_idIndexMarker1359"/> Library, as we’ve seen<a id="_idIndexMarker1360"/> in <a href="B19087_14.xhtml#_idTextAnchor595"><em class="italic">Chapter 14</em></a>, <em class="italic">Understanding STL Basics</em>, includes a very complete and robust set of container classes th<a id="_idTextAnchor946"/>at are widely utilized in C++ code. Using these well-tested components instead of native C++ mechanisms (such as an array of pointers) to collect like items can add robustness and reliability to our code. The memory management is eased on our behalf (eliminating many potential errors). </p>
<p>The STL, by using templates to implement its large variety of container classes, allows its containers to be used generically for any data type our programs may encounter. By comparison, had we utilized native C++ mechanisms, it is likely that we may have tied our implementation to a specific class type, such as an array of pointers to <code>Student</code>. Certainly, we could have implemented an array of pointers to a templatized type, but why do so when such a nice variety of well-tested containers are readily available for our use?</p>
<p>STL containers also avoid using <code>new()</code> and <code>delete()</code> for memory management, choosing to use allocators to improve efficiency for STL’s underlying memory management. For example, a vector, stack, or queue may grow and shrink in size. Rather than allocating the maximum number of elements you may anticipate (which may be both difficult to estimate or inefficient to over-allocate for typical usage that does not reach the maximum), a certain buffer size or a number of elements may be allocated under the hood up front. This initial allocation allows multiple additions to the container without a resize necessary for each new addition to the set (as might otherwise be done to avoid over-allocation). Only when the underlying container’s internal allocation (or buffer) size exceeds the pre-allocated amount will an internal reallocation be necessary (unknown to the user of the container). The expense of an internal reallocation, or a <em class="italic">move</em>, is the allocation of a larger piece of memory, copying from the original memory to the larger piece, and then the release of the original memory. The STL works to fine-tune, under the hood, the internal allocations to balance typical usage needs versus costly reallocation that might otherwise be performed. </p>
<p>Now that we have revisited<a id="_idIndexMarker1361"/> preferring STL in our code, let’s revisit<a id="_idIndexMarker1362"/> applying <code>const</code> when necessary to ensure code isn’t modified unless we so intend it to be. We will wrap up this section with an example illustrating all of the key sa<a id="_idTextAnchor947"/><a id="_idTextAnchor948"/>fety points featured in this section.</p>
<h2 id="_idParaDest-325"><a id="_idTextAnchor949"/>Applying const as needed</h2>
<p>Applying the <code>const</code> qualifier to objects<a id="_idIndexMarker1363"/> is an easy way to indicate that instances<a id="_idIndexMarker1364"/> that should not be modified are not, in fact, modified. We may recall that <code>const</code> instances may only call <code>const</code> member functions. And that <code>const</code> member functions may not modify any part of the object calling the method (<code>this</code>). Remembering to utilize this simple qualifier can ensure that this chain of checkpoints occurs for objects that we truly do not intend to modify.</p>
<p>With that in mind, remember that <code>const</code> can be utilized in parameter lists, to qualify objects and methods. Using <code>const</code> adds readability to the objects and methods it qualifies as well as adding the valuable enforcement of read-only objects and methods. Let’s remember to use <code>const</code> as needed! </p>
<p>Now, let’s take a look at how we can use each of these easily added C++ features that contribute to safer programming. This example revisits preferred looping styles, using <code>auto</code> for type safety, using the STL for simple contain<a id="_idTextAnchor950"/>ers, and applying <code>const</code> as appropriate. This example can be found in our GitHub repository:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter21/Chp21-Ex4.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter21/Chp21-Ex4.cpp</a></p>
<pre class="source-code">
<strong class="bold">#include &lt;vector&gt;  </strong>
<strong class="bold">using std::vector;  </strong>
// Assume additional #include/using as typically included
// Assume classes Pe<a id="_idTextAnchor951"/>rson, Student are as typically defined
// In this const member function, no part of 'this' will
// be modified. Student::Print() can be called by const
// instances of Student, including const iterators 
void Student::Print() <strong class="bold">const</strong>
{   // need to use access functions as these data members
    // are defined in Person as private
    cout &lt;&lt; GetTitle() &lt;&lt; " " &lt;&lt; GetFirstName() &lt;&lt; " ";
    cout &lt;&lt; GetMiddleInitial() &lt;&lt; ". " &lt;&lt; GetLastName();
    cout &lt;&lt; " with id: " &lt;&lt; studentId &lt;&lt; " GPA: ";
    cout &lt;&lt; setprecision(3) &lt;&lt;  " " &lt;&lt; gpa;
    cout &lt;&lt; " Course: " &lt;&lt; currentCourse &lt;&lt; endl;
}
int main()
{   // Utilize STL::vector instead of more native C++ data
    // structures (such as an array of pointers to Student)
    // There's less chance for us to make an error with
    // memory alloca<a id="_idTextAnchor952"/>tion, deallocation, deep copies, etc.
    <strong class="bold">vector&lt;Student&gt; studentBody;  </strong>
    studentBody.push_back(Student("Hana", "Sato", 'U', 
                           "Miss", 3.8, "C++", "178PSU"));
    studentBody.push_back(Student("Sam", "Kato", 'B', 
                           "Mr.", 3.5, "C++", "272PSU"));
    studentBody.push_back(Student("Giselle", "LeBrun", 'R',
                           "Ms.", 3.4, "C++", "299TU"));
    // Notice that our first loop uses traditional notation
    // to loop through each element of the vector.
    // Compare this loop to next loop using an iterator and
    // also to the preferred range-for loop further beyond
    // Note: had we used MAX instead of studentBody.size(),
    // we'd have a potential error – what if MAX isn't the
    // same as studentBody.size()? 
    for (int i = 0; i &lt; studentBody.size(); i++)   
        studentBody1[i].Print();  
    // Notice auto keyword simplifies iterator declaration
    // However, an iterator is still not the most
    // preferred looping mec<a id="_idTextAnchor953"/>hanism. 
    // Note, iterator type is: vector&lt;Student&gt;::iterator
    // the use of auto replaces this type, simplifying as: 
    for (<strong class="bold">auto</strong> iter = studentBody.begin(); 
              iter != studentBody.end(); iter++)
        (*iter).EarnPhD();
    // Preferred range-for loop 
    // Uses auto to simplify type and const to ensure no
    // modification. As a const iterator, student may only
    // call const member fns on the set it iterates thru
    for (<strong class="bold">const</strong> <strong class="bold">auto</strong> &amp;student : studentBody)
        student.Print();
    return 0;
}</pre>
<p>In the aforementioned program, we initially notice<a id="_idIndexMarker1365"/> that we have included<a id="_idIndexMarker1366"/> the use of <code>std::vector</code> from C++’s STL. Further in <code>main()</code>, we notice the instantiation of a vector using <code>vector&lt;Student&gt; studentBody;</code>. Utilizing this well-tested container class certainly adds robustness to our code versus managing a dynamically sized array ourselves. </p>
<p>Next, notice the specification of a constant member function <code>void Student::Print() const;</code>. Here, the <code>const</code> qualification ensures that no part of the object invoking this method (<code>this</code>) will be able to be modified. Furthermore, should any <code>const</code> instances exist, they will be able to invoke <code>Student::Print()</code> as the <code>const</code> qualification guarantees this method to be safe (that is, read-only) for <code>const</code> instances to utilize. </p>
<p>Next, we notice three looping styles and mechanisms, progressing from least to most safe in style. The first loop cycles through each element in the loop with a traditional style <code>for</code> loop. What if we had used <code>MAX</code> for the looping condition instead of <code>studentBody.size()</code>? We might have tried to process more elements than are currently in the container; this type of oversight can be error-prone. </p>
<p>The second loop utilizes an iterator and the <code>auto</code> keyword to make the type specification easier (and hence safer) for the iterator itself. Iterators, though well defined, are still not the preferred looping mechanism. A subtlety from the increment in the second statement in the <code>for</code> statement can also lead to inefficiency. Consider, for example, the pre versus post increment in the statement that is executed before the loop condition is retested (that is, <code>++iter</code>). Had this been <code>iter++</code>, the code would be less efficient. This is because <code>iter</code> is an object and the pre-increment returns a reference to the object, whereas the post-increment returns a temporary object (what is created and destroyed with each loop iteration). The post-increment also utilizes an overloaded function, so the compiler cannot optimize its usage. </p>
<p>Finally, we see the preferred and safest looping mechanism, featuring a range-for loop combined with <code>auto</code> for the iterator specification (to simplify the type declaration). The use of <code>auto</code> replaces <code>vector&lt;Student&gt;::iterator</code> as the type for <code>iter</code>. Any time there is an ease in notation, there is also less room for error. Also, notice the use of <code>const</code> added to the iterator declaration to ensure that the loop will only call non-modifiable methods on each instance iterated upon; this is an example of an additional, appropriate safety feature we can employ in our code. </p>
<p>Here is the output for our aforementioned program:</p>
<pre>Miss Hana U. Sato with id: 178PSU GPA:  3.8 Course: C++
Mr. Sam B. Kato with id: 272PSU GPA:  3.5 Course: C++
Ms. Giselle R. LeBrun with id: 299TU GPA:  3.4 Course: C++
Everyone to earn a PhD
Dr. Hana U. Sato with id: 178PSU GPA:  3.8 Course: C++
Dr. Sam B. Kato with id: 272PSU GPA:  3.5 Course: C++
Dr. Giselle R. LeBrun with id: 299TU GPA:  3.4 Course: C++</pre>
<p>We have now revisited several <a id="_idIndexMarker1367"/>straightforward C++ language features that can easily <a id="_idIndexMarker1368"/>be embraced to promote safety in our everyday coding practices. Using range-for loops provides code simplification and removes dependencies from often incorrect upper limits of loop iteration. Embracing <code>auto</code> simplifies variable declarations, including within loop iterators, and can help ensure type safety versus explicit typing. Using well-tested STL components can add robustness, reliability, and familiarity to our code. Finally, applying <code>const</code> to data and methods is an easy way to ensure data is not modified unintentionally. Each of these principles is easy to employ and adds value to our code by adding to its overall safety.</p>
<p>Next, let’s consider how understanding thread safety can contribute to <a id="_idTextAnchor954"/>making C++ safer.</p>
<h1 id="_idParaDest-326"><a id="_idTextAnchor955"/>Considering thread safety</h1>
<p>Multithreaded programming<a id="_idIndexMarker1369"/> in C++ is an entire book unto itself. Nonetheless, we have mentioned several situations throughout the book that potentially require the consideration of thread safety. It is worth re-iterating these topics to provide an overview of the issues you may encounter in various niches of C++ programming. </p>
<p>A program may be comprised<a id="_idIndexMarker1370"/> of multiple threads, each of which may potentially compete against one another to access a shared resource. For example, a shared resource could be a file, socket, region of shared memory, or output buffer. Each thread accessing<a id="_idIndexMarker1371"/> the shared resource needs to have carefully coordinated (known as mutually exclusive) access to the resource. </p>
<p>Imagine, for example, if two threads wanted to write output to your screen. If each thread could access the output buffer associated with <code>cout</code> without waiting for the other to complete a cohesive statement, the output would be a garbled mess of random letters and symbols. Clearly, synchronized access to a shared resource is important!</p>
<p>Thread safety involves understanding atomic actions, mutual exclusion, locks, synchronization, and so on—all of which are aspects of multithreaded programming. </p>
<p>Let’s begin with an over<a id="_idTextAnchor956"/>view of threads and multithreaded programming.</p>
<h2 id="_idParaDest-327"><a id="_idTextAnchor957"/>Multithreaded programming overview</h2>
<p>A <strong class="bold">thread</strong> is a separate flow of control within<a id="_idIndexMarker1372"/> a process, conceptually working<a id="_idIndexMarker1373"/> like a subprocess (or further subdivision of a process) within a given<a id="_idIndexMarker1374"/> process. Threads are sometimes referred to as <em class="italic">threads of control</em>. Applications that have many threads<a id="_idIndexMarker1375"/> of control are known as <strong class="bold">multithreaded applications</strong>. </p>
<p>In uniprocessor environments, threads give the appearance that multiple tasks are running concurrently. Just as with processes, threads are swapped in and out of the CPU quickly to appear to the user that they are being processed simultaneously (though they aren’t). In a shared, multiprocessor environment, the use of threads within an application can significantly speed up processing and allow parallel computing to be realized. Even in a uniprocessor system, threads can actually (and perhaps counterintuitively) speed up a process, in that one thread may run while waiting for the I/O of another thread to complete. </p>
<p>Threads related by the tasks they are performing may find themselves in similar methods of a class simultaneously. If each thread is working on a distinct dataset (such as a distinct <code>this</code> pointer, even if working within the same method), there is generally no need to synchronize access to those methods. For example, imagine <code>s1.EarnPhd();</code> and <code>s2.EarnPhD();</code>. Here, two separate instances are in the same method (possibly concurrently). However, the datasets worked upon in each method differ – in the first scenario, <code>s1</code> will bind to <code>this</code>; in the second scenario, <code>s2</code> will bind to <code>this</code>. There is most likely no overlap in shared data between the two instances. However, if these methods are accessing static data (that is shared by all instances of a given class, such as a <code>numStudents</code> data member), synchronization to the critical pieces of code accessing the shared memory regions will be required. Traditionally, system-dependent locks or semaphores are added around data or functions that require mutual exclusivity to critical regions of code.</p>
<p>Multithreaded programming<a id="_idIndexMarker1376"/> in C++ is available through a variety of commercial or public domain multithreading libraries. Additionally, the Standard C++ Library features thread support in a variety of capacities including using <code>std::condition_variable</code> for thread synchronization, <code>std::mutex</code> to ensure mutual exclusivity of critical resources (by avoiding race conditions), and <code>std::semaphore</code> to model resource counting. By instantiating a <code>std::thread</code> object and becoming proficient with the aforementioned features, we can add multithreaded programming using an established C++ library. Additionally, the <code>std::atomic</code> template can be added to a type to establish it as an atomic type and ensure type-safe synchronization. The <code>std::exception_ptr</code> type allows the transport of exceptions between coordinating threads. Overall, there are many thread library features to consider; this is a vast topic.</p>
<p>The details for multithreaded programming are beyond the scope of this book; however, we can discuss scenarios within this book that may be augmented to require the knowledge of using threads. Let’s revisit some of those situations.</p>
<h2 id="_idParaDest-328"><a id="_idTextAnchor958"/>Multithreaded programming scenarios</h2>
<p>There are many programming<a id="_idIndexMarker1377"/> scenarios that can benefit from the use of multithreaded programming. We will just mention a few that extend the ideas we have covered in this book.</p>
<p>The Observer pattern may certainly be employed in multithreaded programming scenarios! In these instances, care must be used in the <code>Update()</code> and <code>Notify()</code> methods of <code>Observer</code> and <code>Subject</code>, respectively, to add synchronization and locking mechanisms. </p>
<p>Smart pointers, such as <code>shared_ptr</code> and <code>weak_ptr</code>, can be used in multithreaded applications<a id="_idIndexMarker1378"/> and already include the means to lock and synchronize access to shared resources via reference counting (and with the use of atomic library methods).</p>
<p>Objects related through association may arise with multithreaded programming or through shared memory regions. Any time access is conducted through a shared resource using multithreaded programming, mutexes (locks) should be employed to ensure mutual exclusivity to those shared resources.</p>
<p>Objects throwing exceptions that need to communicate with one another will need to include synchronization within catcher blocks or delegate exceptions to the <code>main()</code> program thread. Employing worker threads to communicate with the <code>main()</code> program thread is a typical design model. Utilizing shared memory is a means to store the data that will need to be shared between threads coordinating with a <code>throw</code> and <code>catch</code> of the exception itself. An instance of <code>std::exception_ptr</code> can be utilized with <code>std::current_exception()</code> to store an instance needing to be shared. This shared instance (between threads) can be rethrown to a participating thread using <code>std::rethrow_exception()</code>. </p>
<p>Multithreaded programming is a fascinating topic unto itself and requires in-depth understanding to utilize safely in C++. We’ve revisited a few areas in which thread safety considerations may complement areas we have covered in this book. It is highly recommended to delve deeply into thread safety in C++ before embarking on adding multithreaded programming to your code. </p>
<p>Next, let’s move forward to investigate how programming guidelines can add a necessary level of safety to C++ programming. </p>
<h1 id="_idParaDest-329"><a id="_idTextAnchor959"/>Utilizing core programming guidelines</h1>
<p>Programming guidelines<a id="_idIndexMarker1379"/> are much more than a set of conventions to indicate how many spaces to indent or naming conventions for variables, functions, classes, data members, and member functions. A modern programming guideline is a covenant between programmers within an organization to create code adhering to specific standards, with the largest goal to provide robust and easily extensible code by following these common standards. The bottom line is that most of the conventions contained within a programming guideline are simply to make programming in C++ safer. </p>
<p>The consensus<a id="_idIndexMarker1380"/> of what comprises a C++ programming guideline may vary from organization to organization, but there are many resources available (including from standards committees) to provide examples and direction.</p>
<p>Let’s move forward to examine a sampling of programming guide essentials and then discuss adopting a core set of guidelines, as well as understanding resources widely available for programming safely in C++.</p>
<h2 id="_idParaDest-330"><a id="_idTextAnchor960"/>Examining guideline essentials</h2>
<p>Let’s start by examining<a id="_idIndexMarker1381"/> a sampling of meaningful conventions<a id="_idIndexMarker1382"/> to follow from a typical C++ programming guideline. We have examined many of these programming issues throughout the book, yet it is useful to review a few items to provide a starting point for choosing conventions to promote C++ safety.</p>
<h3>Preferring initialization over assignment</h3>
<p>Always choose initialization, whenever<a id="_idIndexMarker1383"/> possible, over assignment. It’s simply more efficient and safer! Use in-class initialization or the member initialization list. When assignment is used after initialization, it can be less efficient. Imagine, for example, a member object that is default constructed, only to quickly overwrite its values with more suitable values via assignment in the body of the constructor. It would have been more efficient to utilize the member initialization list to initialize this member object via an alternate constructor. </p>
<p>Also, neglecting to give each piece of memory an initial value can cost us dearly in terms of safety – memory in C++ is not clean, so it is truly inappropriate to interpret whatever is in an uninitialized variable (or data member) as valid. Accessing an uninitialized value is an undefined behavior. We truly never know what is lurking in uninitialized memory, but we know it is never the correct value to be used as an initializer!</p>
<p>Let’s review preferred initialization with a small program. This example can be found in our GitHub:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter21/Chp21-Ex5.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter21/Chp21-Ex5.cpp</a></p>
<pre class="source-code">
class Person
{
private: 
   string firstName; <strong class="bold">// str mbrs are default constructed so</strong>
   string lastName;  <strong class="bold">// w<a id="_idTextAnchor961"/>e don't need in-class initializers</strong>
   <strong class="bold">char middleInitial = '\0';  // in-class initialization</strong>
   string title;  
protected: 
   void ModifyTitle(const string &amp;); 
public:
   Person() = default;   // default constructor
   Person(const string &amp;, const string &amp;, char, 
          const string &amp;);  
   // use default copy constructor and default destructor
   // inline function definitions
   const string &amp;GetFirstName() const { return firstName; }
   const string &amp;GetLastName() const { return lastName; }
   const string &amp;GetTitle() const { return title; } 
   <a id="_idTextAnchor962"/>c<a id="_idTextAnchor963"/>har GetMiddleInitial() const { return middleInitial; }
};
// With in-class initialization, it often not necessary to
// write the default constructor yourself – there's often
// nothing remaining to initialize!
// alternate constructor
<strong class="bold">// Note use of member init list to initialize data members</strong>
Person::Person(const string &amp;fn, const string &amp;ln, char mi,
               const string &amp;t)<strong class="bold">: firstName(fn),</strong>
               <strong class="bold">lastName(ln), middleInitial(mi), title(t)</strong>
{
    // no need to assign values in body o<a id="_idTextAnchor964"/>f method –
    // initialization has handled everything!
}</pre>
<p>Examining the preceding<a id="_idIndexMarker1384"/> code, we notice that the <code>Person</code> class uses in-class initialization to set the <code>middleInitial</code> data member to the null character (<code>'\0'</code>). For each instance of <code>Person</code>, <code>middleInitial</code> will be set to the null character prior to any constructor call that further initializes the instance in question. Notice that the other data members in the class are all of type <code>string</code>. Because <code>string</code> is a class itself, these data members are actually member objects of type <code>string</code> and will be default constructed, appropriately initializing each of these string members. </p>
<p>Next, notice that we opted not to provide a default (no argument) constructor, allowing the system-supplied default constructor to be linked in for us. In-class initialization, coupled with the appropriate member object initialization of the <code>string</code> members, left no additional initialization necessary for new <code>Person</code> instances, and hence no need for a programmer-specified default constructor. </p>
<p>Finally, notice our use of the member initialization list in the alternate constructor for <code>Person</code>. Here, each data member is set with an appropriate value from the parameter list of this method. Notice that every data member is set via initialization, leaving no assignments necessary in the body of the alternate constructor. </p>
<p>Our preceding code follows the popular code guideline: whenever possible, always opt to set values via initialization versus assignment. Knowing that each data member has an appropriate value during construction leads us to provide a safer code. Initialization is also more efficient than assignment. </p>
<p>Now, let’s consider another core C++ guideline relating to virtual functions.</p>
<h3>Choosing one of virtual, override, or final</h3>
<p>Polymorphism is a wonderful concept<a id="_idIndexMarker1385"/> that C++ easily supports<a id="_idIndexMarker1386"/> with the use of virtual<a id="_idIndexMarker1387"/> functions. We learned in <a href="B19087_07.xhtml#_idTextAnchor366"><em class="italic">Chapter 7</em></a>, <em class="italic">Utilizing Dynamic Binding through Polymorphism</em>, that the keyword <code>virtual</code> is used to indicate a polymorphic operation – an operation that may be overridden by derived classes with a preferred method. Derived classes are not obligated to override a polymorphic operation (virtual function) by providing a new method, but may find it meaningful to do so. </p>
<p>When a derived class chooses to override a virtual function introduced by a base class with a new method, the overridden method may use both the keywords <code>virtual</code> and <code>override</code> in the signature of the method. However, it is a convention to use only <code>override</code> at this overridden (derived class) level. </p>
<p>When a virtual function is introduced in the hierarchy, it may be desirable at some point to indicate that a certain method is the <em class="italic">final</em> implementation of this operation. That is, the operation in question may no longer be overridden. We know that it is appropriate to apply the <code>final</code> specifier to the virtual function at this level of the hierarchy to indicate that a given method may no longer be overridden. Though we may also include the keyword <code>virtual</code> at this level as well, it is recommended to only utilize <code>final</code>. </p>
<p>To sum up, when specifying a virtual function, only choose one label at each level: <code>virtual</code>, <code>override</code>, or <code>final</code> – even though the keyword <code>virtual</code> can be added to complement <code>override</code> and <code>final</code>. By doing so, it will be much clearer if the virtual function at hand is newly introduced (<code>virtual</code>), an overridden method of a virtual function (<code>override</code>), or the final method of a virtual function (<code>final</code>). Clarity causes fewer errors to occur and that helps make C++ safer.</p>
<p>Let’s review the preferred keyword usage with virtual functions with a program segment. The complete example can be found in our GitHub repository:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter21/Chp21-Ex6.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter21/Chp21-Ex6.cpp</a></p>
<pre class="source-code">
class Person
{
private: 
    string firstName;
    string lastName;
    char middleInitial = '\0';  // in-class initialization
    string title;  // Mr., Ms., Mrs., Miss, Dr., etc.
protected:
    void ModifyTitle(const string &amp;); 
public:
    Person() = default;   // default constructor
    Person(const string &amp;, const string &amp;, char, 
           const string &amp;); 
    <strong class="bold">virtual</strong> ~Person();  // virtual destructor
    const string &amp;GetFirstName() const 
        { return firstName; } 
    const string &amp;GetLastName() const { return lastName; }
    const string &amp;GetTitle() const { return title; } 
    char GetMiddleInitial() const { return middleInitial; }
    <strong class="bold">virtual</strong> void Print() const; // polymorphic operations
    <strong class="bold">virtual</strong> void IsA() const;   // introduced at this level
    <strong class="bold">virtual</strong> void Greeting(const string &amp;) const;
};
// Assume the non-inline member functions for Person 
// follow and are as we are accustomed to seeing
class Student: public Person
{
private: 
    float gpa = 0.0;   // in-class initialization
    string currentCourse;
    const string studentId; 
    static int numStudents;  // static data member
public:
    Student();  // default constructor
    Student(const string &amp;, const string &amp;, char, 
            const string &amp;, float, const string &amp;, 
            const string &amp;); 
    Student(const Student &amp;);  // copy constructor
    ~Student() <strong class="bold">override</strong>;  // virtual destructor
    void EarnPhD();  
    // inline function definitions
    float GetGpa() const { return gpa; }
    const string &amp;GetCurrentCourse() const
        { return currentCourse; }
    const string &amp;GetStudentId() const 
        { return studentId; }
    void SetCurrentCourse(const string &amp;); // proto. only
  
    // In the derived class, keyword virtual is optional, 
    // and not currently recommended. Use override instead.
    void Print() const <strong class="bold">final</strong>; // override is optional here
    void IsA() const <strong class="bold">override</strong>;
    // note, we choose not to redefine (override):
    // Person::Greeting(const string &amp;) const
    static int GetNumberStudents(); // static mbr. function
};
// definition for static data member 
int Student::numStudents = 0;  // notice initial value of 0
// Assume the non-inline, non-static member functions for
// Students follow and are as we are accustomed to seeing</pre>
<p>In the preceding<a id="_idIndexMarker1388"/> example, we see our <code>Person</code> class<a id="_idIndexMarker1389"/> that we have carried<a id="_idIndexMarker1390"/> forward throughout the book. As a base class, notice that <code>Person</code> specifies polymorphic operations of <code>Print()</code>, <code>IsA()</code>, and <code>Greeting()</code>, as well as the destructor using the <code>virtual</code> keyword. These operations are intended to be overridden by a derived class with more suitable methods (not including the destructor), but are not required to be overridden should the derived class find the base class implementation suitable.</p>
<p>In the derived class, <code>Student</code>, we override <code>IsA()</code> with a more suitable method. Notice that we use <code>override</code> in the signature of this function, though we could have also included <code>virtual</code>. Next, notice that we have chosen not to override <code>Greeting()</code> at the <code>Student</code> level; we can assume that <code>Student</code> finds the implementation in <code>Person</code> acceptable. Also notice that the destructor is overridden to provide the entry point to the destruction chain. Recall with a destructor that not only is the derived class destructor called, but the base class destructor will also be called (implicitly as the last line of code in the derived class destructor), allowing the object’s full destruction sequence to properly commence. </p>
<p>Finally, notice that <code>Print()</code> has been overridden as <code>final</code> in <code>Student</code>. Though we could have added <code>override</code> to the signature of this function as well, we choose to only utilize <code>final</code> per the recommended coding convention.</p>
<p>Now, let’s look at another typical element in a typical C++ programming set of guidelines, relating to smart pointers.</p>
<h3>Preferring smart pointers in new code</h3>
<p>We have utilized<a id="_idIndexMarker1391"/> many native (raw) C++ pointers in this book, as you will undoubtedly be asked to immerse yourself in existing code in which they are plentiful. Having native pointer experience and facility will make you a safer programmer when asked to step into situations that use native pointers. </p>
<p>However, for safety’s sake, most programming guides will recommend using smart pointers exclusively in newly created code. After all, their use adds little overhead and can help eliminate many of the potential pitfalls of managing heap memory by the programmer. Smart pointers also aid in exception safety. For example, exception handling implies that the expected flow of code may be interrupted at nearly any time, leading to potential memory leaks with traditional pointer usage. Smart pointers can alleviate some of this burden and provide for exception safety. </p>
<p>Using smart pointers is so important in original code that this point is worth repeating: choosing smart pointers over native pointers leads to safer and far easier to maintain code in C++. The code will also be easier to write, eliminating the need for many destructors, automatically blocking undesired copies and assignment (<code>unique_ptr</code>), and so on. With that in mind, whenever possible, choose smart pointers in newly created code.</p>
<p>We’ve seen smart pointers in this book as well as native pointers. Now, you can choose to use smart pointers in the new code that you create – this is highly recommended. Certainly, there may be some scenarios when this is not possible; perhaps you are creating new code that interfaces heavily with existing native pointer code and need to utilize the same data structures. Nonetheless, you can strive to use smart pointers, when possible, yet you have the flexibility and experience to understand the vast amounts of existing code, libraries, and online examples that exist utilizing native pointers. </p>
<p>What could be better for safety than to have the facility of smart pointers for your original code, paired with the knowledge of native pointers to use only when necessary?</p>
<p>There are many examples of programming guidelines that can be easily followed to make your code safer. The aforementioned examples are just a few of many to illustrate the types of practices<a id="_idIndexMarker1392"/> you will expect to see in a set of essential C++ programming guidelines.</p>
<p>Now, let’s consider how we can assemble or adopt core programming guidelines to help make our code safer.</p>
<h2 id="_idParaDest-331"><a id="_idTextAnchor965"/>Adopting a programming guideline</h2>
<p>Whether you build or assemble<a id="_idIndexMarker1393"/> a set of programming guidelines yourself or adhere to a set governed by an organization you are a member of, adopting a core set of C++ programming guidelines is crucial to ensure your code is as safe and robust as possible, translating to more easily maintainable code. </p>
<p>Guidelines should always remain fluid as the language evolves. Let’s next consider resources for finding core C++ programming guidelines to either follow directly or to revisit incrementally to improve the accepted guidelines within your organization. </p>
<h2 id="_idParaDest-332"><a id="_idTextAnchor966"/>Understanding resources for programming safely in C++</h2>
<p>There are many online resources<a id="_idIndexMarker1394"/> for programming guidelines in C++. The essential resource, however, is the <em class="italic">ISO C++ Core Guidelines</em>, assembled primarily by Bjarne Stroustrup and Herb Sutter, which can be found at the following GitHub URL: <a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md">https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md</a>. Their collective goal is to help programmers use modern C++ safely and more effectively. </p>
<p>Selected market sectors may have guidelines imposed upon them to obtain or ensure certification<a id="_idIndexMarker1395"/> within an industry. For example, <strong class="bold">MISRA</strong> is a set of C++ coding standards for the <strong class="bold">Motor Industry Software Reliability Association</strong>; MISRA has also been adopted as a standard across other industries, such as for medical systems. Another coding standard, developed<a id="_idIndexMarker1396"/> for embedded systems, is <strong class="bold">CERT</strong>, developed at <strong class="bold">Carnegie Mellon University</strong> (<strong class="bold">CMU</strong>). Once an acronym for <strong class="bold">Computer Emergency Response Team</strong>, CERT is now a registered trademark of CMU. CERT has been adopted in many financial sectors as well. <strong class="bold">JSF AV C++</strong> (<strong class="bold">Joint Strike Fighter Air Vehicle C++</strong>) is a C++ coding standard used<a id="_idIndexMarker1397"/> in the aerospace engineering domain, developed by Lockheed Martin, to ensure error-free code for safety-critical systems. </p>
<p>Undoubtedly, each organization you join as a contributor will have a base set of programming guidelines for all programmers in the group to follow. If not, a wise move will be to suggest employing a core set of C++ programming guidelines. After all, you will need to help maintain your own code<a id="_idIndexMarker1398"/> as well as the code of your colleagues; a uniform and expected set of st<a id="_idTextAnchor967"/><a id="_idTextAnchor968"/>andards will make this endeavor manageable for everyone involved.</p>
<h1 id="_idParaDest-333"><a id="_idTextAnchor969"/>Summary</h1>
<p>In this bonus chapter, we have added to our objective of becoming indispensable C++ programmers by understanding the importance of programming safely in C++. After all, our primary goal is to create robust and easily maintainable code. Incorporating safe programming practices will help us achieve this goal. </p>
<p>We have reviewed concepts seen throughout the book, as well as related ideas that culminate in adopting a set of core programming guidelines to ensure safer coding practices.</p>
<p>First, we reviewed smart pointers, examining three types from the Standard C++ Library, namely <code>unique_ptr</code>, <code>shared_ptr</code>, and <code>weak_ptr</code>. We understand that these classes employ the RAII idiom by providing wrappers to allocate and deallocate heap memory safely on our behavior in well-tested standard library classes. We put forth a guideline: always prefer smart pointers in newly created code. </p>
<p>Next, we reiterated a variety of programming practices that we have seen throughout the book that we can employ to make our coding safer overall. For example, preferring for-each style loops and using <code>auto</code> for type safety. Also, using STL containers versus less robust native mechanisms, and also adding the <code>const</code> qualifier for data and methods to ensure read-only access when so needed. These practices are examples (among many) that can help ensure our code is as safe as possible. </p>
<p>Next, we introduced multithreaded programming in C++ and reviewed programming scenarios we have seen previously that may benefit from the use of threads. We also took a look ahead at the classes available in the Standard C++ Library in support of multithreaded programming, including those that provide synchronization, mutex locks, semaphores, and creating atomic types.</p>
<p>Finally, we examined programming guideline essentials to better understand rules that may be beneficial in a C++ core programming guide. For example, we reviewed preferring initialization over the assignment, virtual function usage with regard to the keywords <code>virtual</code>, <code>override</code>, and <code>final</code>, as well as previously examined topics from this chapter. We talked about the importance of adopting a comprehensive set of core programming guidelines for C++ as well as resources to find sample guidelines used as industry standards.</p>
<p>Understanding how to make C++ safer as you apply the many features covered in the book will undoubtedly make you a more valuable programmer. You now have core language skills plus a very solid understanding of OOP in C++ (essential concepts and how to implement them in C++ with either direct language support or using programming techniques). We have augmented your skills with knowledge of exception handling, friends, operator overloading, templates, STL basics, and testing OO classes and components. We have also embraced core design patterns, delving into each pattern with comprehensive programming examples. Finally in this chapter, we have reviewed how to safely put together the knowledge you have learned by choosing to employ safer programming practices at each available opportunity.</p>
<p>As we wrap up our bonus chapter together, you are now ready to journey further on your own, applying C++ to many new and existing applications. You are ready to create safe, robust, and easy to maintain code. I am sincerely hopeful that you are as intrigued by C++ as I am. Once again, let’s get programming!</p>
</div>
</div>

<div><div><h1 id="_idParaDest-334"><a id="_idTextAnchor970"/>Assessments</h1>
<p>The programming solution for each chapter’s questions can be found in our GitHub repository at the following URL: <a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main</a>. Each full program solution can be found in our GitHub repository in the subdirectory Assessments , and then under the appropriate chapter heading (subdirectory, such as <code>Chapter01</code>), in a file that corresponds to the chapter number, followed by a dash, followed by the solution number in the chapter at hand. For example, the solution for <em class="italic">Question 3</em> in <a href="B19087_01.xhtml#_idTextAnchor016"><em class="italic">Chapter 1</em></a>, <em class="italic">Understanding Basic C++ Assumptions</em>, can be found in the subdirectory <code>Assessments/Chapter01</code> in a file named <code>Chp1-Q3.cpp</code> under the aforementioned GitHub directory.</p>
<p>The written responses for non-programming questions can be found in the following sections, organized by chapter, as well as in the aforementioned GitHub in the appropriate Assessments subdirectory for a given chapter. For example, <code>Assessments/Chapter01/Chp1-WrittenQs.pdf</code> will contain the answers to the non-programming solutions for <a href="B19087_01.xhtml#_idTextAnchor016"><em class="italic">Chapter 1</em></a>, <em class="italic">Understanding Basic C++ Assumptions</em>. Should an exercise have a programming portion and a follow-up question to the program, the answer to the follow-up question may be found both in the next sections (as well as in the aforementioned <code>.pdf </code>file) and in a comment at the top of the programming solution in GitHub (as it may be appropriate to review the solution in order to fully understand the answer to the follow-up question).</p>
<h1 id="_idParaDest-335"><a id="_idTextAnchor971"/>Chapter 1, Understanding Basic C++ Assumptions</h1>
<ol>
<li>A <code>flush</code> may be useful, rather than and <code>endl</code>, for clearing the contents of a buffer associated with <code>cout</code> for the situations where you do not wish the cursor to be advanced to the next line for output. Recall, an <code>endl</code> manipulator is merely a newline character plus a buffer flush.</li>
<li>Choosing a pre versus a post increment for a variable, such as <code>++i</code> (versus <code>i++</code>) will have an impact on the code when used in conjunction with a compound expression. A typical example would be <code>result = array[i++];</code> versus <code>result = array[++i];</code>. With the post-increment (<code>i++</code>) the contents of <code>array[i]</code> will be assigned to <code>result</code> and then <code>i</code> is incremented. With the pre-increment, <code>i</code> is first incremented and then <code>result</code> will have the value of <code>array[i]</code> (that is, using the new value of <code>i</code> as an index).</li>
<li>Please see <a id="_idTextAnchor972"/><code>Assessments/Chapter01/Chp1-Q3.cpp</code> in the GitHub repository.</li>
</ol>
<h1 id="_idParaDest-336"><a id="_idTextAnchor973"/>Chapter 2, Adding Language Necessities</h1>
<ol>
<li value="1"><a id="_idTextAnchor974"/>The signature of a function is the function’s name plus its type and number of arguments (no return type). This relates to name mangling as the signature helps the compiler provide a unique, internal name for each function. For example, <code>void Print(int, float);</code> may have mangled name of <code>Print_int_float();</code>. This facilitates overloaded functions by giving each function a unique name so that when a call is made, it is evident by the internal function name as to which function is being invoked. </li>
<li>a – d. Please see <code>Assessments/Chapter02/Chp2-Q2.cpp</code> in the <a id="_idTextAnchor975"/>GitHub repository.</li>
</ol>
<h1 id="_idParaDest-337"><a id="_idTextAnchor976"/>Chapter 3, Indirect Addressing: Pointers</h1>
<ol>
<li value="1">a – f. Please see <code>Assessments/Chapter03/Chp3-Q1.cpp</code> in the GitHub repository.</li>
</ol>
<p>d. (follow-up question) <code>Print(Student)</code> is less efficient than <code>Print(const Student *)</code> as the initial version of this function passes an entire object on the stack, whereas the overloaded version passes only a pointer on the stack.</p>
<ol>
<li value="2">Assuming we have an existing pointer to an object of type <code>Student</code>, such as: <code>Student *s0 = new Student</code>; (this <code>Student</code> is not yet initialized with data)</li>
</ol>
<p>a. <code>const Student *s1;</code> (does not require initialization)</p>
<p>b. <code>Student *const s2 = s0;</code> (requires initialization)</p>
<p>c. <code>const Student *const s3 = s0;</code> (also requires initialization)</p>
<ol>
<li value="3"><a id="_idTextAnchor977"/>Passing an argument of type <code>const Student *</code> to <code>Print()</code> would allow a pointer to a <code>Student</code> to be passed into <code>Print()</code> for speed, yet the object pointed to could not be dereferenced and modified. Yet passing a <code>Student * const</code> as a parameter to <code>Print()</code> would not make sense because a copy of the pointer would be passed to <code>Print()</code>. Marking that copy additionally as <code>const</code> (meaning not allowing changing where the pointer points) would then be meaningless, as disallowing a <em class="italic">copy</em> of a pointer to be changed has no effect on the original pointer itself. The original pointer was never in jeopardy of its address being changed within the function.</li>
<li>There are many programming situations that might use a dynamically allocated 3-D array. For example, if an image is stored in a 2-D array, a collection of images might be stored in a 3-D array. Having a dynamically allocated 3-D array allows for any number of images to be read in from a filesystem and stored internally. Of course, you’d need to know how many images you’ll be reading in before making the 3-D array allocation. For example, a 3-D array might hold 30 images, where 30 is the third dimension to collect the images in a set. To conceptualize a 4-D array, perhaps you would like to organize sets of the aforementioned 3-D arrays. </li>
</ol>
<p>For example, perhaps you have a set of 31 images for the month of January. That set of January images is a 3-D array (2-D for the image and the third dimension for the set of 31 images comprising January). You may wish to do the same for every month. Rather than having separate 3-D array variables for each month’s image set, we can create a fourth dimension to collect the years’ worth of data into one set. The fourth dimension would have an element for each of the 12 months of the year. How about a 5-D array? You can extend this image idea by making the fifth dimension a way to collect various years of data, such as collecting images for a century (fifth dimension). Now we have images organized by century, then organized by year, then month, then by image (the image requiring the first two dimensions).</p>
<h1 id="_idParaDest-338"><a id="_idTextAnchor978"/>Chapter 4, Indirect Addressing: References</h1>
<ol>
<li value="1">a – c. Please see <code>Assessments/Chapter04/Chp4-Q1.cpp</code> in the GitHub repository.</li>
</ol>
<p>c. (follow-up question) Pointer variables need not only call the version of <code>ReadData(Student *)</code> that accepts a pointer to a <code>Student</code> and reference variables need not only call the version of <code>ReadData(Student &amp;)</code> that accepts a reference to a <code>Student</code>. For example, a pointer variable may be dereferenced with <code>*</code> and then call the version that accepts a reference. Likewise, a reference variable may have its address taken using <code>&amp;</code> and then call the version that accepts a pointer (though this is less commonly done). You simply need to make the data types match with respect to what you are passing and what the function expects. </p>
<h1 id="_idParaDest-339"><a id="_idTextAnchor979"/>Chapter 5, Exploring Classes in Detail</h1>
<ol>
<li value="1">a – e. Please see <code>Assessments/Chapter05/Chp5-Q1.cpp</code> in the GitHub repository.</li>
</ol>
<h1 id="_idParaDest-340"><a id="_idTextAnchor980"/>Chapter 6, Implementing Hierarchies with Single Inheritance</h1>
<ol>
<li value="1">a – d. Please see <code>Assessments/Chapter06/Chp6-Q1.cpp</code> in the GitHub repository.</li>
<li>a – c. (Optional) Please see <code>Chapter06/Assessments/Chp6-Q2.cpp</code> in the GitHub repository.</li>
</ol>
<h1 id="_idParaDest-341"><a id="_idTextAnchor981"/>Chapter 7, Utilizing Dynamic Binding through Polymorphism</h1>
<ol>
<li value="1">a – e. <a id="_idTextAnchor982"/>Please see <a id="_idTextAnchor983"/><code>Assessments/Chapter07/Chp7-Q1.cpp</code> in the GitHub repository.</li>
</ol>
<h1 id="_idParaDest-342"><a id="_idTextAnchor984"/>Chapter 8, Mastering Abstract Classes</h1>
<ol>
<li value="1">a – d. Please see <code>Assessments/Chapter08/Chp8-Q1.cpp</code> in the GitHub repository.</li>
</ol>
<p>e. Depending on your implementation, your <code>Shape</code> class may or may not be considered an interface class. If your implementation is an abstract class that contains no data members and only abstract methods (pure virtual functions), your <code>Shape</code> implementation is considered an interface class. If your <code>Shape</code> class, however, stores <code>area</code> as a data member once it has been calculated by the overridden <code>Area()</code> method in the derived classes, it is then just an abstract base class.</p>
<h1 id="_idParaDest-343"><a id="_idTextAnchor985"/><a id="_idTextAnchor986"/>Chapter 9, Exploring Multiple Inheritance</h1>
<ol>
<li value="1">Please see <code>Assessments/Chapter09/Chp9-Q1.cpp</code> in the GitHub repository.</li>
</ol>
<p>a. There is one <code>LifeForm</code> subobject.</p>
<p>b. The <code>LifeForm</code> constructor and destructor are each invoked once. </p>
<p>c. The default constructor for <code>LifeForm</code> would be invoked if the specification of an alternate constructor of <code>LifeForm(1000)</code> was removed from the member initialization list of the <code>Centaur</code> constructor.</p>
<ol>
<li value="2">Please see the <code>Assessments/Chapter09/Chp9-Q2.cpp</code> in the GitHub repository.</li>
</ol>
<p>a. There are two <code>LifeForm</code> sub-objects.</p>
<p>b. The <code>LifeForm</code> constructor and destructor are each invoked twice. </p>
<h1 id="_idParaDest-344"><a id="_idTextAnchor987"/>Chapter 10, Implementing Association, Aggregation, and Composition</h1>
<ol>
<li value="1"><a id="_idTextAnchor988"/>Please see <code>Assessments/Chapter10/Chp10-Q1.cpp</code> in the GitHub repository.</li>
</ol>
<p>(follow-up question) Once you have overloaded a constructor that accepts a <code>University &amp;</code> as a parameter, this version may be invoked using a <code>University *</code> by first dereferencing the pointer to the <code>University</code> within the constructor call (to make a referenceable object).</p>
<ol>
<li value="2">a – f. Please see <code>Assessments/Chapter10/Chp10-Q2.cpp</code> in the GitHub repository.</li>
<li>a – b. (optional) Please see <code>Assessments/Chapter10/Chp10-Q3.cpp</code> in the GitHub repository.</li>
</ol>
<h1 id="_idParaDest-345"><a id="_idTextAnchor989"/>Chapter 11, Handling Exceptions</h1>
<ol>
<li value="1">a – c. Please see <code>Assessments/Chapter11/Chp11-Q1.cpp</code> in the GitHub repository.</li>
</ol>
<h1 id="_idParaDest-346"><a id="_idTextAnchor990"/>Chapter 12, Friends and Operator Overloading</h1>
<ol>
<li value="1">Please see <code>Assessments/Chapter12/Chp12-Q1.cpp</code> in the GitHub repository.</li>
<li>Please see <code>Assessments/Chapter12/Chp12-Q2.cpp</code> in the GitHub repository.</li>
<li>Please see <code>Assessments/Chapter12/Chp12-Q3.cpp</code> in the GitHub repository.</li>
</ol>
<h1 id="_idParaDest-347"><a id="_idTextAnchor991"/>Chapter 13, Working with Templates</h1>
<ol>
<li value="1">a – b. Please see <code>Assessments/Chapter13/Chp13-Q1.cpp</code> in the GitHub repository.</li>
<li>Please see <code>Assessments/Chapter13/Chp13-Q2.cpp</code> in the GitHub repository.</li>
</ol>
<h1 id="_idParaDest-348"><a id="_idTextAnchor992"/>Chapter 14, Understanding STL Basics</h1>
<ol>
<li value="1">a – b. Please see <code>Assessments/Chapter14/Chp14-Q1.cpp</code> in the GitHub repository.</li>
<li><a id="_idTextAnchor993"/>Please see <code>Assessments/Chapter14/Chp14-Q2.cpp</code> in the GitHub repository.</li>
<li>Please see <code>Assessments/Chapter14/Chp14-Q3.cpp</code> in the GitHub repository.</li>
<li><a id="_idTextAnchor994"/>Please see <code>Assessments/Chapter14/Chp14-Q4.cpp</code> in the GitHub repository.</li>
</ol>
<h1 id="_idParaDest-349"><a id="_idTextAnchor995"/>Chapter 15, Testing Classes and Components</h1>
<ol>
<li value="1">a. Your classes follow orthodox canonical class form if they each include a (user-specified) default constructor, copy constructor, overloaded assignment operator, and a virtual destructor. Your classes additionally follow extended canonical class form if they also include a move copy constructor and an overloaded move assignment operator.</li>
</ol>
<p>b. Your class will be considered robust if it follows canonical class form and ensures that all instances of a class have the means to be fully constructed. Testing a class can ensure robustness.</p>
<ol>
<li value="2">a – c. Please see <code>Assessments/Chapter15/Chp15-Q2.cpp</code> in the GitHub repository.</li>
<li>Please see <code>Assessments/Chapter15/Chp15-Q3.cpp</code> in the GitHub repository.</li>
</ol>
<h1 id="_idParaDest-350"><a id="_idTextAnchor996"/>Chapter 16, Using the Observer Pattern</h1>
<ol>
<li value="1">a – b. Please see <code>Assessments/Chapter16/Chp16-Q1.cpp</code> in the GitHub repository.</li>
<li>Other examples which may easily incorporate the Observer pattern include any application requiring customers to receive notification of backordered products that they desire. For example, many people may wish to receive the Covid-19 vaccine and wish to be on a waiting list at a vaccine distribution site. Here, a <code>VaccineDistributionSite</code> (the subject of interest) can be inherited from <code>Subject</code> and contain a list of <code>Person</code> objects, where <code>Person</code> inherits from <code>Observer</code>. The <code>Person</code> objects will contain a pointer to the <code>VaccineDistributionSite</code>. Once enough supply for the vaccine exists at a given <code>VaccineDistributionSite</code> (that is, a distribution event has occurred), <code>Notify()</code> can be called to update the <code>Observer</code> instances (people on the waitlist). Each <code>Observer</code> will be sent an <code>Update()</code>, which will be the means to allow that person to schedule an appointment. If the <code>Update()</code> returns success and the <code>Person</code> has been scheduled for an appointment, the <code>Observer</code> can release itself from the waiting list with the <code>Subject</code>.</li>
</ol>
<h1 id="_idParaDest-351"><a id="_idTextAnchor997"/>Chapter 17, Applying the Factory Pattern</h1>
<ol>
<li value="1">a – b. Please see <code>Assessments/Chapter17/Chp17-Q1.cpp</code> in the GitHub repository.</li>
<li>Other examples which may easily incorporate the Factory Method pattern include many types of applications in which various derived classes may need to be instantiated based upon the specific values provided at construction. For example, a payroll application may require various types of <code>Employee</code> instances, such as <code>Manager</code>, <code>Engineer</code>, <code>Vice-President</code>, and so on. A factory method can provide a way to instantiate the various types of <code>Employee</code> based on the information provided when the <code>Employee</code> is hired. The Factory Method pattern is a pattern that can be applied to many types of applications.</li>
</ol>
<h1 id="_idParaDest-352"><a id="_idTextAnchor998"/>Chapter 18, Applying the Adapter Pattern</h1>
<ol>
<li value="1">a – b. Please see <code>Assessments/Chapter18/Chp18-Q1.cpp</code> in the GitHub repository.</li>
<li><a id="_idTextAnchor999"/>Other examples which may easily incorporate the Adapter pattern include many examples of repurposing existing, well tested non-OO code to provide an OO interface (that is, a wrapper type of Adapter). Other examples include creating an Adapter to convert a formerly used class into a currently needed class (again with the idea of reusing previously created and well-tested components). An example is to adapt a <code>Car</code> class that has been previously used to represent gasoline engine cars into a class that models an <code>ElectricCar</code>.</li>
</ol>
<h1 id="_idParaDest-353"><a id="_idTextAnchor1000"/>Chapter 19, Using the Singleton Pattern</h1>
<ol>
<li value="1">a – c. Please see <code>Assessments/Chapter19/Chp19-Q1.cpp</code> in the GitHub repository.</li>
<li>We cannot label the <code>static instance()</code> method as virtual in <code>Singleton</code> and override it in <code>President</code>, simply because static methods can never be virtual. They are statically bound, and never receive a <code>this</code> pointer. Also, the signature may need to be different (and no one likes an un-intentional function hiding situation).</li>
<li><a id="_idTextAnchor1001"/>Other examples which may easily incorporate the Singleton pattern include creating a Singleton <code>CEO</code> of a company, a Singleton <code>TreasuryDepartment</code> for a country, or a Singleton <code>Queen</code> of a nation. Each of these Singleton instances offers the opportunity to establish a registry to keep track of multiple Singleton objects. That is, many countries may have a single <code>Queen</code>. In this case, the registry would allow not just one Singleton per object type, but one Singleton per other qualifiers, such as <em class="italic">nation</em>. This is an example of the rare case in which more than one Singleton object of a given type can occur (but always a controlled number of such objects).</li>
</ol>
<h1 id="_idParaDest-354"><a id="_idTextAnchor1002"/>Chapter 20, Removing Implementation Details Using the pImpl Pattern</h1>
<ol>
<li value="1"><a id="_idTextAnchor1003"/>Please see <code>Assessments/Chapter20/Chp20-Q1.cpp</code> in the GitHub repository.</li>
<li>Please see <code>Assessments/Chapter20/Chp20-Q2.cpp</code> in the GitHub repository.</li>
</ol>
<p>(follow-up question) In this chapter, simply inheriting <code>Student</code> from the <code>Person</code> class that embraces the pImpl pattern presents no logistical difficulties. Additionally, modifying the <code>Student</code> class to also employ the pImpl pattern and utilize a unique pointer is more challenging. Various approaches may run across various difficulties, including dealing with inline functions, down-casting, avoiding explicit calls to the underlying implementation, or requiring back pointers to help invoke virtual functions. Please see the online solution for details.</p>
<ol>
<li value="3">Other examples which may easily incorporate the pImpl pattern for relative implementation independence include creating generic GUI components, such as for <code>Window</code>, <code>Scrollbar</code>, <code>Textbox</code>, and so on, for various platforms (derived classes). The implementation details can easily be hidden. Another example could be proprietary commercial classes in which the developer wishes to hide the implementation details that might otherwise be seen in a header file. </li>
</ol>
</div>
</div></body></html>