["```cpp\nQT       += core gui \n\nTARGET = desktop-gallery \nTEMPLATE = app \n\nSOURCES += main.cpp\\ \n        MainWindow.cpp \n\nHEADERS  += MainWindow.h \n\nFORMS    += MainWindow.ui \n\nwin32:CONFIG(release, debug|release): LIBS += -L$$OUT_PWD/../gallery-core/release/ -lgallery-core \nelse:win32:CONFIG(debug, debug|release): LIBS += -L$$OUT_PWD/../gallery-core/debug/ -lgallery-core \nelse:unix: LIBS += -L$$OUT_PWD/../gallery-core/ -lgallery-core \n\nINCLUDEPATH += $$PWD/../gallery-core \nDEPENDPATH += $$PWD/../gallery-core \n\n```", "```cpp\nLIBS += -L<pathToLibrary> -l<libraryName> \n\n```", "```cpp\nTEMPLATE = subdirs \n\nSUBDIRS += \\ \n    gallery-core \\ \n    gallery-desktop \n\ngallery-desktop.depends = gallery-core \n\n```", "```cpp\nRESOURCES += resource.qrc \n\n```", "```cpp\n<RCC> \n    <qresource prefix=\"/\"> \n        <file>icons/album-add.png</file> \n        <file>icons/album-delete.png</file> \n        <file>icons/album-edit.png</file> \n        <file>icons/back-to-gallery.png</file> \n        <file>icons/photo-add.png</file> \n        <file>icons/photo-delete.png</file> \n        <file>icons/photo-next.png</file> \n        <file>icons/photo-previous.png</file> \n    </qresource> \n</RCC> \n\n```", "```cpp\n#include <QWidget> \n#include <QItemSelectionModel> \n\nnamespace Ui { \nclass AlbumListWidget; \n} \n\nclass AlbumModel; \n\nclass AlbumListWidget : public QWidget \n{ \n    Q_OBJECT \n\npublic: \n    explicit AlbumListWidget(QWidget *parent = 0); \n    ~AlbumListWidget(); \n\n    void setModel(AlbumModel* model); \n    void setSelectionModel(QItemSelectionModel* selectionModel); \n\nprivate slots: \n    void createAlbum(); \n\nprivate: \n    Ui::AlbumListWidget* ui; \n    AlbumModel* mAlbumModel; \n}; \n\n```", "```cpp\n#include \"AlbumListWidget.h\" \n#include \"ui_AlbumListWidget.h\" \n\n#include <QInputDialog> \n\n#include \"AlbumModel.h\" \n\nAlbumListWidget::AlbumListWidget(QWidget *parent) : \n    QWidget(parent), \n    ui(new Ui::AlbumListWidget), \n    mAlbumModel(nullptr) \n{ \n    ui->setupUi(this); \n\n    connect(ui->createAlbumButton, &QPushButton::clicked, \n            this, &AlbumListWidget::createAlbum); \n} \n\nAlbumListWidget::~AlbumListWidget() \n{ \n    delete ui; \n} \n\nvoid AlbumListWidget::setModel(AlbumModel* model) \n{ \n    mAlbumModel = model; \n    ui->albumList->setModel(mAlbumModel); \n} \n\nvoid AlbumListWidget::setSelectionModel(QItemSelectionModel* selectionModel) \n{ \n    ui->albumList->setSelectionModel(selectionModel); \n} \n\n```", "```cpp\nvoid AlbumListWidget::createAlbum() \n{ \n    if(!mAlbumModel) { \n        return; \n    } \n\n    bool ok; \n    QString albumName = QInputDialog::getText(this, \n                            \"Create a new Album\", \n                            \"Choose an name\", \n                            QLineEdit::Normal, \n                            \"New album\", \n                            &ok); \n\n    if (ok && !albumName.isEmpty()) { \n        Album album(albumName); \n        QModelIndex createdIndex = mAlbumModel->addAlbum(album); \n        ui->albumList->setCurrentIndex(createdIndex); \n    } \n} \n\n```", "```cpp\n#include <QIdentityProxyModel> \n#include <QHash> \n#include <QPixmap> \n\nclass PictureModel; \n\nclass ThumbnailProxyModel : public QIdentityProxyModel \n{ \npublic: \n    ThumbnailProxyModel(QObject* parent = 0); \n\n    QVariant data(const QModelIndex& index, int role) const override; \n    void setSourceModel(QAbstractItemModel* sourceModel) override; \n    PictureModel* pictureModel() const; \n\nprivate: \n    void generateThumbnails(const QModelIndex& startIndex, int count); \n    void reloadThumbnails(); \n\nprivate: \n   QHash<QString, QPixmap*> mThumbnails; \n\n}; \n\n```", "```cpp\nconst unsigned int THUMBNAIL_SIZE = 350; \n... \nvoid ThumbnailProxyModel::generateThumbnails( \n                                            const QModelIndex& startIndex, int count) \n{ \n    if (!startIndex.isValid()) { \n        return; \n    } \n\n    const QAbstractItemModel* model = startIndex.model(); \n    int lastIndex = startIndex.row() + count; \n    for(int row = startIndex.row(); row < lastIndex; row++) { \n        QString filepath = model->data(model->index(row, 0),  \n                                                   PictureModel::Roles::FilePathRole).toString(); \n        QPixmap pixmap(filepath); \n        auto thumbnail = new QPixmap(pixmap \n                                     .scaled(THUMBNAIL_SIZE, THUMBNAIL_SIZE, \n                                             Qt::KeepAspectRatio, \n                                             Qt::SmoothTransformation)); \n        mThumbnails.insert(filepath, thumbnail); \n    } \n} \n\n```", "```cpp\nvoid ThumbnailProxyModel::reloadThumbnails() \n{ \n    qDeleteAll(mThumbnails); \n    mThumbnails.clear(); \n    generateThumbnails(index(0, 0), rowCount()); \n} \n\n```", "```cpp\nvoid ThumbnailProxyModel::setSourceModel(QAbstractItemModel* sourceModel) \n{ \n    QIdentityProxyModel::setSourceModel(sourceModel); \n    if (!sourceModel) { \n        return; \n    } \n\n    connect(sourceModel, &QAbstractItemModel::modelReset,  \n                  [this] { \n        reloadThumbnails(); \n    }); \n\n    connect(sourceModel, &QAbstractItemModel::rowsInserted,  \n                 [this] (const QModelIndex& parent, int first, int last) { \n        generateThumbnails(index(first, 0), last - first + 1); \n    }); \n} \n\n```", "```cpp\nQVariant ThumbnailProxyModel::data(const QModelIndex& index, int role) const \n{ \n    if (role != Qt::DecorationRole) { \n        return QIdentityProxyModel::data(index, role); \n    } \n\n    QString filepath = sourceModel()->data(index,  \n                                 PictureModel::Roles::FilePathRole).toString(); \n    return *mThumbnails[filepath]; \n} \n\n```", "```cpp\nPictureModel* ThumbnailProxyModel::pictureModel() const \n{ \n    return static_cast<PictureModel*>(sourceModel()); \n} \n\n```", "```cpp\n#include <QWidget> \n#include <QModelIndex> \n\nnamespace Ui { \nclass AlbumWidget; \n} \n\nclass AlbumModel; \nclass PictureModel; \nclass QItemSelectionModel; \nclass ThumbnailProxyModel; \n\nclass AlbumWidget : public QWidget \n{ \n    Q_OBJECT \n\npublic: \n    explicit AlbumWidget(QWidget *parent = 0); \n    ~AlbumWidget(); \n\n    void setAlbumModel(AlbumModel* albumModel); \n    void setAlbumSelectionModel(QItemSelectionModel* albumSelectionModel); \n    void setPictureModel(ThumbnailProxyModel* pictureModel); \n    void setPictureSelectionModel(QItemSelectionModel* selectionModel); \n\nsignals: \n    void pictureActivated(const QModelIndex& index); \n\nprivate slots: \n    void deleteAlbum(); \n    void editAlbum(); \n    void addPictures(); \n\nprivate: \n    void clearUi(); \n    void loadAlbum(const QModelIndex& albumIndex); \n\nprivate: \n    Ui::AlbumWidget* ui; \n    AlbumModel* mAlbumModel; \n    QItemSelectionModel* mAlbumSelectionModel; \n\n    ThumbnailProxyModel* mPictureModel; \n    QItemSelectionModel* mPictureSelectionModel; \n}; \n\n```", "```cpp\n#include \"AlbumWidget.h\" \n#include \"ui_AlbumWidget.h\" \n\n#include <QInputDialog> \n#include <QFileDialog> \n\n#include \"AlbumModel.h\" \n#include \"PictureModel.h\" \n\nAlbumWidget::AlbumWidget(QWidget *parent) : \n    QWidget(parent), \n    ui(new Ui::AlbumWidget), \n    mAlbumModel(nullptr), \n    mAlbumSelectionModel(nullptr), \n    mPictureModel(nullptr), \n    mPictureSelectionModel(nullptr) \n{ \n    ui->setupUi(this); \n    clearUi(); \n\n    ui->thumbnailListView->setSpacing(5); \n    ui->thumbnailListView->setResizeMode(QListView::Adjust); \n    ui->thumbnailListView->setFlow(QListView::LeftToRight); \n    ui->thumbnailListView->setWrapping(true); \n\n    connect(ui->thumbnailListView, &QListView::doubleClicked, \n            this, &AlbumWidget::pictureActivated); \n\n    connect(ui->deleteButton, &QPushButton::clicked, \n            this, &AlbumWidget::deleteAlbum); \n\n    connect(ui->editButton, &QPushButton::clicked, \n            this, &AlbumWidget::editAlbum); \n\n    connect(ui->addPicturesButton, &QPushButton::clicked, \n            this, &AlbumWidget::addPictures); \n} \n\nAlbumWidget::~AlbumWidget() \n{ \n    delete ui; \n} \n\n```", "```cpp\nvoid AlbumWidget::setAlbumModel(AlbumModel* albumModel) \n{ \n    mAlbumModel = albumModel; \n\n    connect(mAlbumModel, &QAbstractItemModel::dataChanged, \n        [this] (const QModelIndex &topLeft) { \n            if (topLeft == mAlbumSelectionModel->currentIndex()) { \n                loadAlbum(topLeft); \n            } \n    }); \n} \n\nvoid AlbumWidget::setAlbumSelectionModel(QItemSelectionModel* albumSelectionModel) \n{ \n    mAlbumSelectionModel = albumSelectionModel; \n\n    connect(mAlbumSelectionModel, \n            &QItemSelectionModel::selectionChanged, \n            [this] (const QItemSelection &selected) { \n                if (selected.isEmpty()) { \n                    clearUi(); \n                    return; \n                } \n                loadAlbum(selected.indexes().first()); \n    }); \n} \n\n```", "```cpp\nvoid AlbumWidget::setPictureModel(PictureModel* pictureModel) \n{ \n    mPictureModel = pictureModel; \n    ui->thumbnailListView->setModel(mPictureModel); \n} \n\nvoid AlbumWidget::setPictureSelectionModel(QItemSelectionModel* selectionModel) \n{ \n    ui->thumbnailListView->setSelectionModel(selectionModel); \n} \n\n```", "```cpp\nvoid AlbumWidget::deleteAlbum() \n{ \n    if (mAlbumSelectionModel->selectedIndexes().isEmpty()) { \n        return; \n    } \n    int row = mAlbumSelectionModel->currentIndex().row(); \n    mAlbumModel->removeRow(row); \n\n    // Try to select the previous album \n    QModelIndex previousModelIndex = mAlbumModel->index(row - 1, \n        0); \n    if(previousModelIndex.isValid()) { \n        mAlbumSelectionModel->setCurrentIndex(previousModelIndex, \n             QItemSelectionModel::SelectCurrent); \n        return; \n    } \n\n    // Try to select the next album \n    QModelIndex nextModelIndex = mAlbumModel->index(row, 0); \n    if(nextModelIndex.isValid()) { \n        mAlbumSelectionModel->setCurrentIndex(nextModelIndex, \n            QItemSelectionModel::SelectCurrent); \n        return; \n    } \n} \n\n```", "```cpp\nvoid AlbumWidget::editAlbum() \n{ \n    if (mAlbumSelectionModel->selectedIndexes().isEmpty()) { \n        return; \n    } \n\n    QModelIndex currentAlbumIndex =  \n        mAlbumSelectionModel->selectedIndexes().first(); \n\n    QString oldAlbumName = mAlbumModel->data(currentAlbumIndex, \n        AlbumModel::Roles::NameRole).toString(); \n\n    bool ok; \n    QString newName = QInputDialog::getText(this, \n                                            \"Album's name\", \n                                            \"Change Album name\", \n                                            QLineEdit::Normal, \n                                            oldAlbumName, \n                                            &ok); \n\n    if (ok && !newName.isEmpty()) { \n        mAlbumModel->setData(currentAlbumIndex, \n                             newName, \n                             AlbumModel::Roles::NameRole); \n    } \n} \n\n```", "```cpp\nvoid AlbumWidget::addPictures() \n{ \n    QStringList filenames = \n        QFileDialog::getOpenFileNames(this, \n            \"Add pictures\", \n             QDir::homePath(), \n            \"Picture files (*.jpg *.png)\"); \n\n    if (!filenames.isEmpty()) { \n        QModelIndex lastModelIndex; \n        for (auto filename : filenames) { \n            Picture picture(filename); \n            lastModelIndex = mPictureModelâpictureModel()->addPicture(picture); \n        } \n        ui->thumbnailListView->setCurrentIndex(lastModelIndex); \n    } \n} \n\n```", "```cpp\nvoid AlbumWidget::clearUi() \n{ \n    ui->albumName->setText(\"\"); \n    ui->deleteButton->setVisible(false); \n    ui->editButton->setVisible(false); \n    ui->addPicturesButton->setVisible(false); \n} \n\nvoid AlbumWidget::loadAlbum(const QModelIndex& albumIndex) \n{ \n    mPictureModel->pictureModel()->setAlbumId(mAlbumModel->data(albumIndex, \n        AlbumModel::Roles::IdRole).toInt()); \n\n    ui->albumName->setText(mAlbumModel->data(albumIndex, \n        Qt::DisplayRole).toString()); \n\n    ui->deleteButton->setVisible(true); \n    ui->editButton->setVisible(true); \n    ui->addPicturesButton->setVisible(true); \n} \n\n```", "```cpp\n#include <QStyledItemDelegate> \n\nclass PictureDelegate : public QStyledItemDelegate \n{ \n    Q_OBJECT \npublic: \n    PictureDelegate(QObject* parent = 0); \n\n    void paint(QPainter* painter, const QStyleOptionViewItem& \n        option, const QModelIndex& index) const override; \n\n    QSize sizeHint(const QStyleOptionViewItem& option, \n        const QModelIndex& index) const override; \n}; \n\n```", "```cpp\n#include \"PictureDelegate.h\" \n\n#include <QPainter> \n\nconst unsigned int BANNER_HEIGHT = 20; \nconst unsigned int BANNER_COLOR = 0x303030; \nconst unsigned int BANNER_ALPHA = 200; \nconst unsigned int BANNER_TEXT_COLOR = 0xffffff; \nconst unsigned int HIGHLIGHT_ALPHA = 100; \n\nPictureDelegate::PictureDelegate(QObject* parent) : \n    QStyledItemDelegate(parent) \n{ \n} \n\nvoid PictureDelegate::paint(QPainter* painter, const QStyleOptionViewItem& option, const QModelIndex& index) const \n{ \n    painter->save(); \n\n    QPixmap pixmap = index.model()->data(index, \n        Qt::DecorationRole).value<QPixmap>(); \n    painter->drawPixmap(option.rect.x(), option.rect.y(), pixmap); \n\n    QRect bannerRect = QRect(option.rect.x(), option.rect.y(), \n        pixmap.width(), BANNER_HEIGHT); \n    QColor bannerColor = QColor(BANNER_COLOR); \n    bannerColor.setAlpha(BANNER_ALPHA); \n    painter->fillRect(bannerRect, bannerColor); \n\n    QString filename = index.model()->data(index, \n        Qt::DisplayRole).toString(); \n    painter->setPen(BANNER_TEXT_COLOR); \n    painter->drawText(bannerRect, Qt::AlignCenter, filename); \n\n    if (option.state.testFlag(QStyle::State_Selected)) { \n        QColor selectedColor = option.palette.highlight().color(); \n        selectedColor.setAlpha(HIGHLIGHT_ALPHA); \n        painter->fillRect(option.rect, selectedColor); \n    } \n\n    painter->restore(); \n} \n\n```", "```cpp\nQSize PictureDelegate::sizeHint(const QStyleOptionViewItem& /*option*/, const QModelIndex& index) const \n{ \n    const QPixmap& pixmap = index.model()->data(index, \n        Qt::DecorationRole).value<QPixmap>(); \n    return pixmap.size(); \n} \n\n```", "```cpp\nAlbumWidget::AlbumWidget(QWidget *parent) : \n    QWidget(parent), \n    ui(new Ui::AlbumWidget), \n    mAlbumModel(nullptr), \n    mAlbumSelectionModel(nullptr), \n    mPictureModel(nullptr), \n    mPictureSelectionModel(nullptr) \n{ \n    ui->setupUi(this); \n    clearUi(); \n\n    ui->thumbnailListView->setSpacing(5); \n    ui->thumbnailListView->setResizeMode(QListView::Adjust); \n    ui->thumbnailListView->setFlow(QListView::LeftToRight); \n    ui->thumbnailListView->setWrapping(true); \n    ui->thumbnailListView->setItemDelegate( \n        new PictureDelegate(this)); \n    ... \n} \n\n```", "```cpp\n#include <QWidget> \n#include <QItemSelection> \n\nnamespace Ui { \nclass PictureWidget; \n} \n\nclass PictureModel; \nclass QItemSelectionModel; \nclass ThumbnailProxyModel; \n\nclass PictureWidget : public QWidget \n{ \n    Q_OBJECT \n\npublic: \n    explicit PictureWidget(QWidget *parent = 0); \n    ~PictureWidget(); \n    void setModel(ThumbnailProxyModel* model); \n    void setSelectionModel(QItemSelectionModel* selectionModel); \n\nsignals: \n    void backToGallery(); \n\nprotected: \n    void resizeEvent(QResizeEvent* event) override; \n\nprivate slots: \n    void deletePicture(); \n    void loadPicture(const QItemSelection& selected); \n\nprivate: \n    void updatePicturePixmap(); \n\nprivate: \n    Ui::PictureWidget* ui; \n    ThumbnailProxyModel* mModel; \n    QItemSelectionModel* mSelectionModel; \n    QPixmap mPixmap; \n}; \n\n```", "```cpp\nvoid PictureWidget::resizeEvent(QResizeEvent* event) \n{ \n    QWidget::resizeEvent(event); \n    updatePicturePixmap(); \n} \n\nvoid PictureWidget::updatePicturePixmap() \n{ \n    if (mPixmap.isNull()) { \n        return; \n    } \n    ui->pictureLabel->setPixmap(mPixmap.scaled(ui->pictureLabel->size(), Qt::KeepAspectRatio)); \n} \n\n```", "```cpp\n#include <QMainWindow> \n#include <QStackedWidget> \n\nnamespace Ui { \nclass MainWindow; \n} \n\nclass GalleryWidget; \nclass PictureWidget; \n\nclass MainWindow : public QMainWindow \n{ \n    Q_OBJECT \n\npublic: \n    explicit MainWindow(QWidget *parent = 0); \n    ~MainWindow(); \n\npublic slots: \n    void displayGallery(); \n    void displayPicture(const QModelIndex& index); \n\nprivate: \n    Ui::MainWindow *ui; \n    GalleryWidget* mGalleryWidget; \n    PictureWidget* mPictureWidget; \n    QStackedWidget* mStackedWidget; \n}; \n\n```", "```cpp\nui->setupUi(this); \n\nAlbumModel* albumModel = new AlbumModel(this); \nQItemSelectionModel* albumSelectionModel = \n    new QItemSelectionModel(albumModel, this); \nmGalleryWidget->setAlbumModel(albumModel); \nmGalleryWidget->setAlbumSelectionModel(albumSelectionModel); \n\n```", "```cpp\nPictureModel* pictureModel = new PictureModel(*albumModel, this); \nThumbnailProxyModel* thumbnailModel = new ThumbnailProxyModel(this); thumbnailModel->setSourceModel(pictureModel); \n\nQItemSelectionModel* pictureSelectionModel = \n    new QItemSelectionModel(pictureModel, this); \n\nmGalleryWidget->setPictureModel(thumbnailModel); \nmGalleryWidget->setPictureSelectionModel(pictureSelectionModel); \nmPictureWidget->setModel(thumbnailModel); \nmPictureWidget->setSelectionModel(pictureSelectionModel); \n\n```", "```cpp\nconnect(mGalleryWidget, &GalleryWidget::pictureActivated, \n        this, &MainWindow::displayPicture); \n\nconnect(mPictureWidget, &PictureWidget::backToGallery, \n        this, &MainWindow::displayGallery); \n\n```", "```cpp\nmStackedWidget->addWidget(mGalleryWidget); \nmStackedWidget->addWidget(mPictureWidget); \ndisplayGallery(); \n\nsetCentralWidget(mStackedWidget); \n\n```", "```cpp\nvoid MainWindow::displayGallery() \n{ \n    mStackedWidget->setCurrentWidget(mGalleryWidget); \n} \n\nvoid MainWindow::displayPicture(const QModelIndex& /*index*/) \n{ \n    mStackedWidget->setCurrentWidget(mPictureWidget); \n} \n\n```"]