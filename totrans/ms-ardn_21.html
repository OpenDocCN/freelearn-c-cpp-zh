<html><head></head><body>
        

                            
                    <h1 class="header-title">Bluetooth Classic</h1>
                
            
            
                
<p>Bluetooth LE, which we saw in <a href="7695319d-e0ba-4f5e-91c6-0d96bc9f4ad0.xhtml" target="_blank">Chapter 20</a>, <em>Bluetooth LE</em>, is an excellent choice when we need two devices to communicate wirelessly in short data bursts and where power consumption is a concern. There have been changes with Bluetooth LE with versions 4.2 and 5.0. That make it more appealing for devices that need to transfer large amounts of data or even stream data. However, there is another Bluetooth technology that has been doing this for very successfully for many years, this technology is known as Bluetooth Classic. While the name may imply that this technology is out of date, don't let the name fool you as Bluetooth Classic is used in many Bluetooth devices, and until there are more Bluetooth 5.0 modules available for the Arduino that also support some of the newer features, Bluetooth Classic will remain an excellent choice when we need to transfer large amounts of data between two devices.</p>
<p>In this chapter, you will learn:</p>
<ul>
<li>What the version numbers of Bluetooth Classic mean</li>
<li>How the Bluetooth radio works</li>
<li>The network topology of a Bluetooth network</li>
<li>How to use the HC-05 Bluetooth module</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>Bluetooth is a wireless technology standard that is used by two devices to transmit or receive data over short distances using a 2.4GHz wireless connection. While the design goal of Bluetooth LE was to create a low-power wireless protocol, Bluetooth Classic had different design goals. Bluetooth Classic was created by engineers that work at Ericsson Mobile in Lund, Sweden, as a wireless alternative to serial (RS232) cables. This meant that this new protocol would be required to transmit large amounts of data, or even stream data, over short distances.</p>
<p>The Bluetooth Classic specifications are managed by the <strong>Bluetooth Special Interest Group</strong> (<strong>Bluetooth SIG</strong>) as part of the Bluetooth core specifications. As we mentioned in <a href="7695319d-e0ba-4f5e-91c6-0d96bc9f4ad0.xhtml" target="_blank">Chapter 20</a>, <em>Bluetooth LE</em>, you can find information about both Bluetooth LE and Bluetooth Classic by downloading the specifications form from the Bluetooth SIG site at <a href="https://www.bluetooth.com">https://www.bluetooth.com</a>.</p>
<p>At first, it may seem strange to cover the newer technology (Bluetooth LE 4.0) prior to covering the older technology (Bluetooth Classic). The reason Bluetooth LE was covered first is that you will find that it is appropriate to use it in the more significant majority of projects that you will be creating with the Arduino, as most projects will want to send short bursts of data, which is what Bluetooth LE is designed for. Bluetooth LE is also easier to integrate with smartphones using Bluetooth LE because every smartphone OS has an easy to use and well documented Bluetooth LE API, which is not the case for Bluetooth Classic. For the cases where you will want to stream data or share large amounts of data between two custom devices, Bluetooth Classic may be more appropriate.</p>
<p>When purchasing a Bluetooth Classic module for your project, you will have a choice of three different Bluetooth versions. These versions are:</p>
<ul>
<li><strong>Bluetooth 2.0 + EDR</strong>: The core specifications for this version were released in 2004. This update to the Bluetooth core specifications contained a number of minor improvements to the Bluetooth standard. The only significant improvement was <strong>EDR</strong> (<strong>Enhanced Data Rate</strong>), which increased the data transfer rate to 3Mbits/sec from 1Mbits/sec. The name of the standard reads Bluetooth 2.0 + EDR, which means that the EDR feature is optional. The HC-05 Bluetooth module that we will be using for this chapter is Bluetooth 2.0, compatible which means it does not include the EDR feature. For the vast majority of projects that you will build with the Arduino, Bluetooth 2.0-compatible modules will be fine and are actually preferable since we are able to avoid the secure pairing feature that was introduced with Bluetooth 2.1. While the new pairing feature may be called Simple Secure Pairing, it usually requires human interaction for the pairing process, which we may want to avoid since a lot of Arduino projects do not have the input capabilities to do this.</li>
<li><strong>Bluetooth 2.1 + EDR</strong>: The core specifications for this version was released in 2007. This version of the Bluetooth core specifications also offered a number of improvements on the previous version, with the featured improvement being the introduction of <strong>SSP</strong> (<strong>Simple Secure Pairing</strong>). SSP overhauled the pairing process, making it both simple and more secure.</li>
<li><strong>Bluetooth 3.0 + HS</strong>: The core specifications for this version were released in 2009. The HS in the specification name stands for High Speed. Bluetooth 3.0 + HS can have a theoretical data transfer speed of 24 Mbits/sec, however the data is not transmitted over a Bluetooth connection. When in high-speed mode the data is actually transmitted over an 801.11 (Wi-Fi) connection. The Bluetooth link is only used to negotiate and establish the Wi-Fi connection. As with the Bluetooth 2.X + EDR specification, the HS feature is optional, and you will see devices that only meet the Bluetooth 3.0 standard.</li>
</ul>
<p>As with Bluetooth LE, to really understand when to use Bluetooth Classic we need to understand the technology itself, so let's dive into in a bit more.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Bluetooth radio</h1>
                
            
            
                
<p>The range of a Bluetooth radio is dependent on the class. The following chart shows the range of a Bluetooth radio by the class:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Class</strong></p>
</td>
<td>
<p><strong>Power (mW)</strong></p>
</td>
<td>
<p><strong>Power (dBm)</strong></p>
</td>
<td>
<p><strong>Range in meters</strong></p>
</td>
</tr>
<tr>
<td>
<p>1</p>
</td>
<td>
<p>100</p>
</td>
<td>
<p>20</p>
</td>
<td>
<p>~100</p>
</td>
</tr>
<tr>
<td>
<p>2</p>
</td>
<td>
<p>2.5</p>
</td>
<td>
<p>4</p>
</td>
<td>
<p>~10</p>
</td>
</tr>
<tr>
<td>
<p>3</p>
</td>
<td>
<p>1</p>
</td>
<td>
<p>0</p>
</td>
<td>
<p>~1</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>As with any radio technology the area surrounding the radio has a substantial effect on the range of the radio. The range listed in the previous chart is the theoretical maximum range with ideal conditions. The typical range is usually less than this theoretical maximum range.</p>
<p>Where the Bluetooth LE radio operates from 2,402 MHz to 2,480 MHz with each channel being 2 MHz apart, the Bluetooth Classic radio uses 79 channels from 2,402 MHz to 2,480 MHz with each channel being 1 MHz apart. As with Bluetooth LE, the Bluetooth Classic radio uses frequency hopping, where the radio changes channels 1,600 times a second, to reduce interference.</p>
<p>With Bluetooth LE, the radio continuously turns itself off to reduce power, Bluetooth Classic does not do this. This makes the Bluetooth LE radio technology better at short bursts of data with low power while the Bluetooth Classic radio is better at transmitting large amounts of data or data streaming because the radio is continuously on.</p>
<p>All Bluetooth devices have a unique 48-bit address that is assigned to the Bluetooth radio by the manufacturer. The upper half of the address (the most significant 24 bits) is known as the <strong>Organizationally Unique Identifier</strong> and consists of two parts. These parts are the <strong>Non-Significant Address</strong> (<strong>NAP</strong>) and the <strong>Upper Address Part</strong> (<strong>UAP</strong>).</p>
<p>The NAP is the first 16 bits of the address and is used in frequency hopping synchronization. The UAP is the next 8 bits and is assigned to the radio manufacturer by the IEEE organization.</p>
<p>The last 24-bits of the address is known as the <strong>Lower Address Part</strong> (<strong>LAP</strong>). The LAP is assigned by the manufacturer to identify the radio uniquely. The following diagram shows how the Bluetooth address is made up:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/4aeb2940-c65e-438e-8855-71499af8f2d7.png" style="width:25.92em;height:8.67em;"/></p>
<p>Now let's look that the network topology for Bluetooth Classic.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Network topology</h1>
                
            
            
                
<p>The topology of a Bluetooth Classic piconet is very similar to the topology of a Bluetooth LE network where one device acts as a master and the other devices act as slaves to the master. In a Bluetooth Classic piconet, one master can have up to seven slaves for a total of eight devices in the piconet. The following diagram shows a Bluetooth classic piconet:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/b9fe22df-97db-48f3-a094-143fa3824def.png" style="width:12.67em;height:12.75em;"/></p>
<p>Piconets can interact with other piconets to form what is known as scatternets. A scatternet is one where the master of one piconet acts as a slave in another piconet. This does allow devices in one piconet to share data with devices in other piconets; however, this does require complex synchronization and bandwidth sharing, making these networks more complex and less efficient. It is good to know that we can create scatternets, but it is something that, in my experience, is rarely used.</p>
<p>There is a lot more to Bluetooth than what is described here; however, for the vast majority of use cases you will want to use Bluetooth LE as described in <a href="7695319d-e0ba-4f5e-91c6-0d96bc9f4ad0.xhtml" target="_blank">Chapter 20</a>, <em>Bluetooth LE</em>. With the Arduino, we would use Bluetooth Classic when we want to connect two devices and stream data between them. Let's look at how we would do this with three projects. For the first project we will configure the Bluetooth modules, the second project we will learn how to send and receive data from the Bluetooth module, and in the third project, we will see how we can stream data from one radio to another. We will start off by looking at the components that we will need for these projects.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Components needed</h1>
                
            
            
                
<p>For these projects you will need the following items:</p>
<ul>
<li>Two Arduino Uno or compatible boards</li>
<li>Two HC-05 Bluetooth modules</li>
<li>One Joystick breakout module for the Arduino</li>
<li>Jumper wires</li>
<li>Breadboard</li>
</ul>
<p>Now let's look at the circuit diagram for our project.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Circuit diagrams</h1>
                
            
            
                
<p>In this chapter, we will be writing code for three projects. In the first project we will be configuring the Bluetooth modules, in the second project we will create an application that will send data, in byte format, from one Bluetooth radio to another and in the last project we will attach a joystick to one of the Arduinos and stream the joystick position to the other Arduino through the Bluetooth connection. The following shows the circuit diagram for our projects:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/b5ecaaaf-a9c5-44e3-8b5d-b8f4c7a51393.png" style="width:41.58em;height:48.00em;"/></p>
<p>The two Arduino circuits are completely isolated from each other, therefore they do not need a common ground. Both HC-06 Bluetooth modules are connected to the Arduino in the same way where the VCC pin on the HC-06 Bluetooth module is connected to 5V out, and the GND pin is connected to the ground out on the Arduino. The key pin on the Bluetooth module is connected to the digital 9 pin on the Arduino, the RX pin is connected to the digital 10 pin, and the TX pin is connected to the digital 11 pin.</p>
<p>We will want to connect a joystick breakout module to one of the Arduinos. To do this, we will want to connect the VCC pin on the breakout board to the 5V out on the Arduino and the GND pin to the ground out on the Arduino. We will connect the SEK or SW pin, depending on your joystick module, to the digital 2 pin on the Arduino. Finally, we will connect the HOR or <em>x </em>axis pin on the breakout board to the Analog 0 pin on the Arduino and the VER or <em>y </em>axis pin to the Analog 1 pin.</p>
<p>Now let's look start with our projects.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Project 1 – configuring the Bluetooth modules</h1>
                
            
            
                
<p>To communicate with the HC-05 Bluetooth module, we will use the same <kbd>SoftwareSerial</kbd> library that we used in <a href="7695319d-e0ba-4f5e-91c6-0d96bc9f4ad0.xhtml" target="_blank">Chapter 20</a>, <em>Bluetooth LE</em>. The code that is used to communicate is very similar between the HM-10 (Bluetooth LE) and the HC-05 (Bluetooth Classic). How the two radios transmit and receive the data is a lot different, therefore understanding how the radios work and what they should be used for will define when to use the different technologies.</p>
<p>For this first project, we will be writing an application that will allow us to configure the Bluetooth modules. This code will start off exactly as we did with the Bluetooth LE code by including the <kbd>SoftwareSerial</kbd> library and creating an instance of the <kbd>SoftwareSerial</kbd> type. The following code shows how to do this:</p>
<pre>#include &lt;SoftwareSerial.h&gt;<br/>SoftwareSerial HC05(10, 11);<br/>bool addNewLine = false;</pre>
<p>The first line includes the <kbd>SoftwareSerial</kbd> library and the second line creates an instance of the type. The Boolean variable in the last line will be used to tell the application when to add a new line in the serial console.</p>
<p>Now we need to add code to the <kbd>setup()</kbd> function that will configure the serial console and the <kbd>SoftwareSerial</kbd> instance. The following code shows the <kbd>setup()</kbd> function for this first project:</p>
<pre>void setup()<br/>{<br/>  Serial.begin(9600);<br/>  pinMode(9,OUTPUT);<br/>  digitalWrite(9,HIGH);<br/>  HC05.begin(38400);<br/>  Serial.println("Connected to HC-05.  Try connecting from any device or issue AT commands");<br/>}</pre>
<p>This code starts off by setting up the serial console with a baud rate of <kbd>9600</kbd> and then define that the digital 9 pin will be an output pin and set it to high. The digital 9 pin is connected to the key pin on the HC-05. We pull this pin high to enable the Bluetooth module. We then configure the <kbd>HC05</kbd> instance of the <kbd>SoftwareSerial</kbd> type with a baud rate of <kbd>38400</kbd> and print a message to the serial console letting the user know that everything is configured and ready to go.</p>
<p>You will note, in this first project we set the baud rate of the <kbd>SoftwareSerial</kbd> instance to <kbd>38400</kbd> because we are configuring the Bluetooth module. In the next two projects, we set the baud rate to <kbd>9600</kbd> because we will be sending and receiving data to/from the Bluetooth module.</p>
<p>In the <kbd>loop()</kbd> function, just like in the Bluetooth LE code, we will take any input from the Bluetooth module and print it to the serial console and any input from the serial console we will send out through the Bluetooth module. The following code will do this:</p>
<pre>void loop()<br/>{<br/>  if (HC05.available())<br/>  {<br/>    if (addNewLine) {<br/>      Serial.write("\r\n");<br/>      addNewLine = false;<br/>    }<br/>    Serial.write(HC05.read());<br/>  }<br/><br/>  if (Serial.available())<br/>  {<br/>    HC05.write(Serial.read());<br/>    addNewLine = true;<br/>  }<br/>}</pre>
<p>In this function, the first thing we do is to see if there is any data available from the <kbd>HC05</kbd> <kbd>SoftwareSerial</kbd> instance (the Bluetooth module) by using the <kbd>available()</kbd> function. If there is data available we check to see if we need to add a new line to the serial console by checking the <kbd>addNewLine</kbd> Boolean variable. If we need to add a new line, we write a carriage return and line feed to the serial console and then set the <kbd>addNewLine</kbd> Boolean variable to <kbd>false</kbd>. We then write the data that was received from the Bluetooth module to the serial console.</p>
<p>Next, we check to see if there is any data available from the serial console, also using the <kbd>available()</kbd> function and if so we write that data to the Bluetooth module which is then transmitted to the connected device. We also set the <kbd>addNewLine</kbd> Boolean variable to true, so that the next time data is received from the connected device, we will add a carriage return and line feed to the serial console.</p>
<p>Before we plug the Arduino and run this code, we will need to set the HC-05 Bluetooth module into configuration mode. To do this, we will need to press and hold down the button on the Bluetooth module and then plug the Arduino into the computer giving power to the Bluetooth module. In just a couple of seconds, the light on the Bluetooth module will start to blink very slowly; the light will be on for two seconds and then turn off for two seconds. Once the light starts to blink, we can release the button, and the Bluetooth module is ready to be configured.</p>
<p>To configure the Bluetooth module, we issue AT commands similar to how we did it with the Bluetooth LE module. To send an AT command, you would use the following format:</p>
<pre><strong>Set item: AT+{command}{new setting}</strong><br/><strong>Query item: AT+{command}?</strong></pre>
<p>To set an item, you type in the letters AT followed by the plus sign, the command and the new setting without any spaces. For example, to set the role of the Bluetooth module to a salve role we would issue the following command:</p>
<pre><strong>at+role0</strong></pre>
<div><strong>Note</strong>: AT commands are case insensitive.</div>
<p>To query the item, we would type in the letters <kbd>at</kbd> followed by the plus sign, the command and then a question mark. For example, to query the role of the Bluetooth module, we would use the following command:</p>
<pre><strong>at+role?</strong></pre>
<p>To issue the command, we type the command into the input box on the serial console and press <em>Enter</em>. We will need to set the serial console to add both an NL (new line) and a CR (carriage return). The following screenshot shows how to issue an AT command:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/2e21481a-3e96-407a-b53d-df53fac17ba4.png" style="width:56.50em;height:26.75em;"/></p>
<p>After we type in the <kbd>at+role?</kbd> command, we press the <em>Enter</em> key or the Send button to send the command to the Bluetooth module. The Bluetooth module will respond with the results of the query, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/71003801-57d4-45e0-92a5-8b9fc754b50f.png" style="width:54.67em;height:25.92em;"/></p>
<p>Before we configure the modules, let's look at some of the commands that we can issue to the HC-05 Bluetooth module.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Test command</h1>
                
            
            
                
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Command</strong></p>
</td>
<td>
<p><strong>Response</strong></p>
</td>
<td>
<p><strong>Parameters</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>AT</kbd></p>
<p> </p>
</td>
<td>
<p><kbd>OK</kbd></p>
<p> </p>
</td>
<td>
<p>None</p>
<p> </p>
</td>
<td>
<p>This is a test command that can be used to test the</p>
<p>connection to the Bluetooth module.</p>
</td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">Reset command</h1>
                
            
            
                
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Command</strong></p>
</td>
<td>
<p><strong>Response</strong></p>
</td>
<td>
<p><strong>Parameters</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>AT+RESET</kbd></p>
<p> </p>
</td>
<td>
<p><kbd>OK</kbd></p>
<p> </p>
</td>
<td>
<p>None</p>
<p> </p>
</td>
<td>
<p>This command will reset the Bluetooth module.</p>
<p> </p>
</td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">Query firmware</h1>
                
            
            
                
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Command</strong></p>
</td>
<td>
<p><strong>Response</strong></p>
</td>
<td>
<p><strong>Parameters</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>AT+VERSION?</kbd></p>
<p> </p>
</td>
<td>
<p><kbd>+VERSION:&lt;Param&gt;</kbd></p>
<p> </p>
</td>
<td>
<p>None</p>
<p> </p>
</td>
<td>
<p>Returns the version of the firmware on the</p>
<p>HC-05 Bluetooth module.</p>
</td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">Restore defaults</h1>
                
            
            
                
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Command</strong></p>
</td>
<td>
<p><strong>Response</strong></p>
</td>
<td>
<p><strong>Parameters</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>AT+ORGL</kbd></p>
<p> </p>
</td>
<td>
<p><kbd>OK</kbd></p>
<p> </p>
</td>
<td>
<p>None</p>
<p> </p>
</td>
<td>
<p>Restores the HC-05 Bluetooth module to the</p>
<p>default settings.</p>
</td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">Query module address</h1>
                
            
            
                
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Command</strong></p>
</td>
<td>
<p><strong>Response</strong></p>
</td>
<td>
<p><strong>Parameters</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>AT+ADDR?</kbd></p>
<p> </p>
</td>
<td>
<p><kbd>+ADDR:&lt;Param&gt;</kbd></p>
<p> </p>
</td>
<td>
<p>None</p>
<p> </p>
</td>
<td>
<p>Returns the address of the HC-05 Bluetooth</p>
<p>module.</p>
</td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">Set/Query module mode</h1>
                
            
            
                
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Command</strong></p>
</td>
<td>
<p><strong>Response</strong></p>
</td>
<td>
<p><strong>Parameters</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>AT+ROLE?</kbd></p>
<p> </p>
</td>
<td>
<p><kbd>+ROLE:&lt;Param&gt;</kbd></p>
<p> </p>
</td>
<td>
<p><kbd>0</kbd> Slave</p>
<p><kbd>1</kbd> Master</p>
</td>
<td>
<p>Queries the role of the HC-05 Bluetooth module.</p>
<p> </p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Command</strong></p>
</td>
<td>
<p><strong>Response</strong></p>
</td>
<td>
<p><strong>Parameters</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>AT+ROLE=&lt;Param&gt;</kbd></p>
<p> </p>
</td>
<td>
<p><kbd>OK</kbd></p>
<p> </p>
</td>
<td>
<p><kbd>0</kbd> Slave</p>
<p><kbd>1</kbd> Master</p>
</td>
<td>
<p>Sets the role of the HC-05 Bluetooth module.</p>
<p> </p>
</td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">Set/Query UART parameters</h1>
                
            
            
                
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Command</strong></p>
</td>
<td>
<p><strong>Response</strong></p>
</td>
<td>
<p><strong>Parameters</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>AT+UART?</kbd></p>
<p> </p>
</td>
<td>
<p><kbd>+UART:&lt;Param1&gt;, &lt;Param2&gt;,<br/>
&lt;Param3&gt;</kbd></p>
<p> </p>
</td>
<td>
<p><kbd>Param1</kbd> = Baud Rate</p>
<p><kbd>Param2</kbd> = Stop Bit</p>
<p><kbd>Param3</kbd> = Parity</p>
</td>
<td>
<p>Queries the UART</p>
<p>parameters.</p>
<p> </p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Command</strong></p>
</td>
<td>
<p><strong>Response</strong></p>
</td>
<td>
<p><strong>Parameters</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>AT+UART=&lt;Param1&gt;, &lt;Param2&gt;,<br/>
&lt;Param3&gt;</kbd></p>
<p> </p>
</td>
<td>
<p><kbd>OK</kbd></p>
<p> </p>
</td>
<td>
<p><kbd>Param1</kbd> = Baud Rate</p>
<p><kbd>Param2</kbd> = Stop Bit</p>
<p><kbd>Param3</kbd> = Parity</p>
</td>
<td>
<p>Sets the UART</p>
<p>parameters.</p>
</td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">Set/Query connection mode</h1>
                
            
            
                
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Command</strong></p>
</td>
<td>
<p><strong>Response</strong></p>
</td>
<td>
<p><strong>Parameters</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>AT+CMODE?</kbd></p>
<p> </p>
</td>
<td>
<p><kbd>+UART:&lt;Param&gt;</kbd></p>
<p> </p>
</td>
<td>
<p><kbd>0</kbd> Connect to Fixed Address</p>
<p><kbd>1</kbd> Connect to any address</p>
<p><kbd>2</kbd> Slave-loop</p>
</td>
<td>
<p>Queries the connection mode of</p>
<p>the HC-05 Bluetooth module.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Command</strong></p>
</td>
<td>
<p><strong>Response</strong></p>
</td>
<td>
<p><strong>Parameters</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>AT+CMODE=&lt;Param&gt;</kbd></p>
<p> </p>
</td>
<td>
<p><kbd>OK</kbd></p>
<p> </p>
</td>
<td>
<p><kbd>0</kbd> Connect to Fixed Address</p>
<p><kbd>1</kbd> Connect to any address</p>
<p><kbd>2</kbd> Slave-loop</p>
</td>
<td>
<p>Sets the connection mode for</p>
<p>the HC-05 Bluetooth module.</p>
</td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">Set/Query bind address</h1>
                
            
            
                
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Command</strong></p>
</td>
<td>
<p><strong>Response</strong></p>
</td>
<td>
<p><strong>Parameters</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>AT+BIND?</kbd></p>
<p> </p>
</td>
<td>
<p><kbd>+BIND:&lt;Param&gt;</kbd></p>
<p> </p>
</td>
<td>
<p>None</p>
<p> </p>
</td>
<td>
<p>Queries the address that the module is configured</p>
<p>to bind to.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Command</strong></p>
</td>
<td>
<p><strong>Response</strong></p>
</td>
<td>
<p><strong>Parameters</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>AT+BIND=&lt;Param&gt;</kbd></p>
<p> </p>
</td>
<td>
<p><kbd>OK</kbd></p>
<p> </p>
</td>
<td>
<p>Fixed address</p>
<p> </p>
</td>
<td>
<p>Sets the address to bind to.</p>
<p> </p>
</td>
</tr>
</tbody>
</table>
<p>Now that we have seen most of the AT commands let's configure the two Bluetooth modules. We are going to need to configure one of the Bluetooth modules as the master and the other one as a slave. For the purposes of the next two projects, I configured the Bluetooth module that is connected to the same Arduino as the joystick as the slave. This, however, is not necessary and either module can be the master or slave.</p>
<p>Let's start off by configuring the slave device. To do this connect one of the Arduinos to the computer, run the application that we wrote at the beginning of this section and then run through the command that we will outline in the next few paragraphs.</p>
<p>The first thing we will want to do is to issue the test <kbd>AT</kbd> command to the Bluetooth module. The module should respond back with an <kbd>OK</kbd> message. If you do not get a response back, check to make sure that the serial console is configured to send both the NL and CR. If you receive an error response, try issuing the <kbd>AT</kbd> command again.</p>
<p>Now that we are sure that the serial monitor and the Bluetooth module are talking, we will want to see what the UART settings are currently set to for this module. To do this send the <kbd>AT+UART?</kbd> command. For the examples in this chapter, we are going to assume that the UART settings are 9600 Baud, 0 stop bits, and 0 parity. If this is not how your module is configured then issue the following command:</p>
<pre><strong>AT+UART=9600,0,0</strong></pre>
<p>The next thing we want to do is to set the role of the device to a slave role. To do this, we issue the following command:</p>
<pre><strong>AT+ROLE=0</strong></pre>
<p>Finally, we will want to retrieve the address of this Bluetooth module. The following command will retrieve the address:</p>
<pre><strong>AT+ADDR?</strong></pre>
<p>Make sure the address is written down because we will be using it when we configure the master device.</p>
<p>The commands that we ran to configure the slave module are:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Command</strong></p>
</td>
<td>
<p><strong>Response</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>AT</kbd></p>
</td>
<td>
<p><kbd>OK</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>AT+UART?</kbd></p>
</td>
<td>
<p><kbd>+UART:9600,0,0</kbd> (if not, set it to this)</p>
</td>
</tr>
<tr>
<td>
<p><kbd>AT+ROLE=0</kbd></p>
</td>
<td>
<p><kbd>OK</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>AT+ADDR?</kbd></p>
</td>
<td>
<p><kbd>+ADDR:{address}</kbd></p>
</td>
</tr>
</tbody>
</table>
<p class="mce-root"/>
<p>Now let's configure the master. To do this, connect the other Arduino to the computer (remember to press and hold the button as you power up the module), run the code we wrote at the beginning of this section and issue the commands that we will go through in the next few paragraphs.</p>
<p>As with the slave device, the first thing we will want to do is to issue the <kbd>AT</kbd> command to the Bluetooth module. The module should respond back with an <kbd>OK</kbd> message. If you do not get a response back, check to make sure that the serial console is configured to send both the NL and CR. If you receive an error response, try issuing the <kbd>AT</kbd> command again.</p>
<p>Now we will want to see what the UART settings are for the module. To do this send the <kbd>AT+UART?</kbd> command. For the examples in this chapter, we are going to assume that the UART settings are 9600 Baud, 0 stop bits, and 0 parity. If this is not how your module is configured then issue the following command:</p>
<pre><strong>AT+UART=9600,0,0</strong></pre>
<p>The next thing we want to do is to set the role of the device to a master role. To do this, we issue the following command:</p>
<pre><strong>AT+ROLE=1</strong></pre>
<p>Now we will want to set the connection mode to connect to a fixed address (mode 0). To do this issue the following command:</p>
<pre><strong>AT+CMODE=0</strong></pre>
<p>Since we are telling the Bluetooth module to connect to a fixed address, we need to give it the address of the slave device we need it to connect to.</p>
<p>To do this, issue the following command:</p>
<pre><strong>AT+BIND=????,??,??????</strong></pre>
<p>The question marks are the address of the slave device. When we queried the address of the slave device the address was returned separated with colons like this, <kbd>98d3:31:300e42</kbd>. When entering the address in the <kbd>BIND</kbd> command, the address needs to be separated by commas like this <kbd>98d3,31,300e42</kbd>.</p>
<p>The commands that we used to configure the master device are:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Command</strong></p>
</td>
<td>
<p><strong>Response</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>AT</kbd></p>
</td>
<td>
<p><kbd>OK</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>AT+UART?</kbd></p>
</td>
<td>
<p><kbd>+UART:9600,0,0</kbd> (if not, set it to this)</p>
</td>
</tr>
<tr>
<td>
<p><kbd>AT+ROLE=1</kbd></p>
</td>
<td>
<p><kbd>OK</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>AT+CMODE=0</kbd></p>
</td>
<td>
<p><kbd>OK</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>AT+BIND=????,??,??????</kbd> (question marks are the address of the slave device)</p>
</td>
<td>
<p><kbd>OK</kbd></p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Now if we reset both devices by recycling the power, the two Bluetooth modules should connect. Start off by recycling the power on the slave device, and you will see the LED blinking rapidly. Then recycle the power on the master and once the two devices connect the LED on both devices will blink rapidly twice, then turn off for two seconds and then repeat. This light sequence indicates that the two devices are connected.</p>
<p>If the devices do not connect, the most common mistake that is made is to type in the wrong address in the <kbd>AT+BIND</kbd> command. I would start off by checking that by running the <kbd>AT+BIND?</kbd> command and verifying the address is correct. If that is correct, then verify the <kbd>AT+CMODE</kbd>, and <kbd>AT+ROLE</kbd> commands ran properly by running the <kbd>AT+CMODE?</kbd> and <kbd>AT+ROLE?</kbd> commands. Now that we have the two Bluetooth modules connected let's go on to project two.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Project 2 – serial connection, sending data</h1>
                
            
            
                
<p>For this project, in order to see the data going from one device to the other, you will need two computers. One connected to the master device and one connected to the slave device. If you do not have two computers, it is still worth reading through this section to understand the protocol that we are creating because we will be using the same protocol for the third project as well.</p>
<p>When we are streaming data or sending large amounts of variable length data, we need some way to tell the receiving device where a new message starts and where it ends. Luckily for us, there are built-in ASCII codes that allow for this. The <kbd>0x01</kbd> <strong>SOH</strong> (<strong>Start Of Heading</strong>) and the <kbd>0x04</kbd> <strong>EOT</strong> (<strong>End Of Transmission</strong>) codes can be used to tell the receiving device when a message starts and when it ends.</p>
<p>In this project and the next one, the protocol that we will define is when the receiving device receives a <kbd>0x01</kbd> ASCII character, it will know that a new message has started. When it receives a <kbd>0x04</kbd> ASCII character, it will know that the message has ended and everything between the <kbd>0x01</kbd> and the <kbd>0x04</kbd> characters are the message itself.</p>
<p>If you are not familiar with ASCII codes, the following chart shows the ASCII chart:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/b021a1bb-fa89-4560-947b-5e88de99afef.png" style="width:60.00em;height:25.33em;"/></p>
<p>Basically, when we transmit character data between two Bluetooth Classic devices, we are actually sending the ASCII codes. For example, if we send the word "Dog," we are actually sending three bytes of data, which are <kbd>0x44</kbd> (D), <kbd>0x111</kbd> (o), and <kbd>0x67</kbd> (g). With the protocol that we are defining, if we send the word Dog, we would send five bytes of data because we need to start with the <kbd>0x01</kbd> character and end with the <kbd>0x04</kbd> character. The five bytes that we would send would be <kbd>0x01</kbd>, <kbd>0x44</kbd>, <kbd>0x111</kbd>, <kbd>0x67</kbd> and <kbd>0x04</kbd>.</p>
<p>Now let's look at the code to send and receive the messages between the two Bluetooth modules. This code will run on both the master and the slave devices. We will start off by including the <kbd>SoftwareSerial</kbd> library in the project and creating an instance of the <kbd>SoftwareSerial</kbd> type. The following code does this:</p>
<pre>#include &lt;SoftwareSerial.h&gt;<br/>SoftwareSerial HC05(10, 11);// RX | TX<br/>bool newMessage = true;</pre>
<p>The first line includes the <kbd>SoftwareSerial</kbd> library in the project, and then the next line creates an instance of the <kbd>SoftwareSerial</kbd> type. The third line creates a global variable that will define when a new message is started.</p>
<p>Now we will need to configure the serial console and the <kbd>HC05</kbd> <kbd>SoftwareSerial</kbd> instance in the <kbd>setup()</kbd> method. The following code will do this:</p>
<pre>void setup()<br/>{<br/>  Serial.begin(9600);<br/>  pinMode(9,OUTPUT);<br/>  digitalWrite(9,HIGH);<br/>  HC05.begin(9600);<br/>  Serial.println("Connected to HC-05. ");<br/>}</pre>
<p>In this code, we start off by configuring the serial console with a baud rate of 9600. We then define that the digital 9 pin will be an output pin and set it to high. The digital 9 pin is connected to the key pin on the HC-05 Bluetooth module. We pull this pin high to enable it. We configure the <kbd>HC05</kbd> instance of the <kbd>SoftwareSerial</kbd> type with a baud rate of 9600 and then print a message to the serial console letting the user know that everything is configured and ready to go.</p>
<p>The <kbd>loop()</kbd> function will need to monitor both the serial console and the <kbd>HC05</kbd> <kbd>SoftwareSerial</kbd> instance for new data coming in. If it receives new data from the serial console, it will need to transmit it out through the Bluetooth module, and if it receives new data from the Bluetooth module, it will need to display the data in the serial console. The following code does this:</p>
<pre>void loop()<br/>{<br/>  if (HC05.available())<br/>  {<br/>    byte val = HC05.read();<br/>    Serial.write(val);<br/>    if (val == 0x04)<br/>    {<br/>      Serial.write("\r\n");<br/>    }<br/>  }<br/>  if (Serial.available())<br/>  {<br/>    if (newMessage)<br/>    {<br/>      HC05.write(0x01);<br/>      newMessage = false;<br/>    }<br/>    char val = Serial.read();<br/>    if (val == '~')<br/>    {<br/>      HC05.write(0x04);<br/>      newMessage = true;<br/>    }<br/>    else<br/>    {<br/>      HC05.write(val);
    }<br/>  }<br/>}</pre>
<p>In this function, we check to see if there is any data available from the <kbd>HC05</kbd> <kbd>SoftwareSerial</kbd> instance and if so, it is read into the <kbd>val</kbd> variable. The <kbd>val</kbd> variable is then written to the serial console. We then see if the <kbd>val</kbd> variable is equal to <kbd>0x04</kbd> and if so we write a carriage return and line feed to the serial console because that particular message has ended.</p>
<p>Now we check to see if there is any data available from the serial console and if so, we check to see if we are starting a new message by checking if the <kbd>newMessage</kbd> variable is equal to <kbd>true</kbd>. If the <kbd>newMessage</kbd> variable is equal to <kbd>true</kbd>, we write a <kbd>0x01</kbd> character to the <kbd>HC05</kbd> <kbd>SoftwareSerial</kbd> instance and then set the <kbd>newMessage</kbd> variable to <kbd>false</kbd>. We then read the character from the serial console and see if it is equal to the tilde (<kbd>~</kbd>) character. We are going to use the tilde character to specify that the message has ended therefore when the user types in a tilde we will write the <kbd>0x04</kbd> character to the <kbd>HC05</kbd> <kbd>SoftwareSerial</kbd> instance and set the <kbd>newMessage</kbd> variable to <kbd>true</kbd> because this particular message has ended. If the character does not equal a tilde, we write the character to the <kbd>SoftwareSerial</kbd> instance.</p>
<p>Now if we run this code on both the master and slave device, whatever we type into the serial console on one device will be transmitted to the other device through the Bluetooth modules. The message will continue to be printed on one line of the serial console until the user types in a tilde signifying the end of the message.</p>
<p>Transmitting text back and forth is good but we can do that with Bluetooth LE as we saw in <a href="7695319d-e0ba-4f5e-91c6-0d96bc9f4ad0.xhtml" target="_blank">Chapter 20</a>, <em>Bluetooth LE</em>. Let's do something that is a bit more useful by looking at how this can be used as a remote control by connecting an Arduino joystick module to one of the devices and streaming the joystick position to the other device.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Project 3 – joystick remote control</h1>
                
            
            
                
<p>If you have not connected the joystick breakout module to one of the Arduino's you will need to do it before you start this project. Once the joystick breakout module is connected to the Arduino, we will write the code that will read the position of the joystick and transmit it to the other Arduino via the HC-05 Bluetooth modules; however, before we do this we need to figure out the protocol that we are going to use.</p>
<p>For this example, we will use the same protocol that we used in the previous project, where the message will start off with a <kbd>0x01</kbd> byte and end with a <kbd>0x04</kbd> byte and everything in between is the message itself. The message itself will contain two bytes, one that indicates the <em>x</em> position of the joystick and one that indicates the <em>y</em> position. Therefore, a complete transmission will contain a total of four bytes likes this:</p>
<pre>0x01 - Start of header<br/>0xDD - X position (221 decimal)<br/>0xDD - Y position (221 decimal)<br/>0x04 - End of transmission</pre>
<p>Now that we have the protocol that will be used to transmit the joystick position from one Arduino to the other let's begin by writing the code that will run on the Arduino that the joystick breakout module is connected to. The position of the joystick is read through the two analog pins that are connected to it. We also need to bring the SEL pin, which is connected to the digital 2 pin, high.</p>
<p>The first thing we will need to do in the code is to include the <kbd>SoftwareSerial</kbd> library for the Bluetooth module, create an instance of the <kbd>SoftwareSerial</kbd> type and define the pins that the joystick module is connected to. The following code will do this:</p>
<pre>#include &lt;SoftwareSerial.h&gt;<br/>#define SW_PIN 2 // digital pin Joystick<br/>#define BT_PIN 9 // digital pin Bluetooth<br/>#define X_PIN 0  // analog pin<br/>#define Y_PIN 1  // analog pin<br/><br/>SoftwareSerial HC05(10, 11);</pre>
<p>In this code, we define the SEL pin for the joystick to be the digital 2 pin, the key pin on the Bluetooth module to be the digital 9 pin and the <em>x</em>/<em>y</em> axes to be the analog 0 and 1 pins.</p>
<p>In the <kbd>setup()</kbd> function we will need bring both the <kbd>SW_PIN</kbd> and the <kbd>BT_PIN</kbd> high and initialize both the serial console and the instance of the <kbd>SoftwareSerial</kbd> instance. Here is the code for the <kbd>setup()</kbd> function:</p>
<pre>void setup()<br/>{<br/>  pinMode(BT_PIN,OUTPUT);<br/>  digitalWrite(BT_PIN,HIGH);<br/>  pinMode(SW_PIN,OUTPUT);<br/>  digitalWrite(SW_PIN,HIGH);<br/>  HC05.begin(9600);<br/>  Serial.begin(9600);<br/>  Serial.println("Connected to HC05.");<br/>}</pre>
<p>This code should look very familiar by now. The first four lines initialize the digital pins and pull them high. The next two lines initialize the <kbd>SoftwareSerial</kbd> instance and the serial console with baud rates of 9600. Finally, a message is printed to the serial console letting the user know that everything is ready to go.</p>
<p>In our <kbd>loop()</kbd> function, we will need to read the position of the joystick and then write the message to the Bluetooth module. The following code will do this:</p>
<pre>void loop()<br/>{<br/>  int xpos = analogRead(X_PIN) / 4;<br/>  int ypos = analogRead(Y_PIN) / 4;<br/>  HC05.write(0x01);<br/>  HC05.write(xpos);<br/>  HC05.write(ypos);<br/>  HC05.write(0x04);<br/>  delay(500);<br/>}</pre>
<p>The first two lines read the <em>x</em> and <em>y</em> axes of the joystick module. When reading an analog pin the values that are returned range from 0 to 1024; however, we only want to send a single byte to represent the position of the joystick. A single byte can have a range from 0 to 255, therefore we divide the value from the analog read by <kbd>4</kbd>.</p>
<p>After we retrieve the values for the <em>x</em> and <em>y</em> axes of the joystick, we need to send the message through the Bluetooth module with these values. The next four lines of code writes a <kbd>0x01</kbd> (SOH), the value of the <em>x</em> axis, the value of the <em>y </em>axis and finally a <kbd>0x04</kbd> (EOT). After the message is sent, we pause for 500 milliseconds and then loops back.</p>
<p>Now that we have the code that will run on the Arduino that the joystick is connected to, we need to write the code that will run on the Arduino that will receive the data. This code will need to start off by including the <kbd>SoftwareSerial</kbd> library for the Bluetooth module and create an instance of the <kbd>SoftwareSerial</kbd> type. We will also need to define a buffer that will be used to store the data as it comes in through the Bluetooth module. The following code will do this:</p>
<pre>#include &lt;SoftwareSerial.h&gt;<br/>#define MAXBUF 255<br/>#define BT_PIN 9 // digital pin Bluetooth<br/>SoftwareSerial HC05(10, 11);<br/>byte buf[MAXBUF];</pre>
<p>This code starts off by including the <kbd>SoftwareSerial</kbd> library and then defines the max size for the input buffer, which is <kbd>255</kbd>. While we could limit the size of the buffer to four because we know that each message will be four bytes in size, we always want to have extra space in the buffer, especially with wireless communication, in case the message gets messed up in transmission. If this was a production system, I would probably limit the size of the buffer to 12 or 16 bytes.</p>
<p>We define that the key pin on the Bluetooth module is connected to the digital 9 pin on the Arduino. We then create an instance of the <kbd>SoftwareSerial</kbd> type and a <kbd>byte</kbd> array for the input buffer.</p>
<p>In the <kbd>setup()</kbd> function we will initialize the serial console and the <kbd>SoftwareSerial</kbd> instance. We will also need to pull the key pin for that Bluetooth module high. The following code does this:</p>
<pre>void setup()<br/>{<br/>  Serial.begin(9600);<br/>  pinMode(BT_PIN,OUTPUT);<br/>  digitalWrite(BT_PIN,HIGH);<br/>  HC05.begin(9600);<br/>  Serial.println("Connected to HC05");<br/>}</pre>
<p>Now in the <kbd>loop()</kbd> function we will want to continuously read the input from the Bluetooth module until we receive and EOT (<kbd>0x04</kbd>) byte. As we read the data in, it will be stored in the byte array and once the <kbd>0x04</kbd> byte is read in we will print out the message and then loop back. Here is the code for the <kbd>loop()</kbd> function:</p>
<pre>void loop()<br/>{<br/>  memset(buf, 0, MAXBUF);<br/>  int counter = 0;<br/>  while (counter &lt; MAXBUF)<br/>  {<br/>    if (HC05.available())<br/>    {<br/>      byte val = HC05.read();<br/>      buf[counter] = val;<br/>      counter++;<br/>      if (val == 0x04)<br/>      {<br/>        break;<br/>      }<br/>    }<br/>  }<br/>  for(int i=0; i&lt;counter; i++)<br/>  {<br/>    Serial.print(buf[i]);<br/>    Serial.print(" ");<br/>  }<br/>  Serial.println(" ");<br/>}</pre>
<p>This function starts off by using the <kbd>memset()</kbd> function to initialize the buffer with all zeros. We then create an integer variable that will count how many bytes are read in.</p>
<p>A <kbd>while</kbd> loop is used to continuously loop until the maximum number of bytes have been read. Within the <kbd>while</kbd> loop, we use the <kbd>available()</kbd> function from the <kbd>HC05</kbd> <kbd>SoftwareSerial</kbd> instance to see if there are any values to read from the Bluetooth module. If there is a value to read, we use the <kbd>read()</kbd> function to read the value in, store it in the <kbd>buf</kbd> byte array and increments the counter. We then check to see if the value that was read in is equal to <kbd>0x04</kbd> and if so we use the <kbd>break</kbd> statement to break out of the <kbd>while</kbd> loop.</p>
<p>Finally, we create a <kbd>for</kbd> loop that will loop through the values in the buffer and print them to the serial console. If we execute the code on both Arduinos and move the joystick around, we will see output similar to the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/82c6a280-e172-4231-9b8b-54cf6aca98dd.png" style="width:85.17em;height:28.83em;"/></p>
<p>As we can see from the output, each message starts with the <kbd>0x01</kbd> byte and ends with the <kbd>0x04</kbd> byte. In between these two bytes are the joystick position on the <em>x</em> axis and the <em>y</em> axis.</p>
<p>We know that the packets are supposed to be four bytes in length. In a production environment we would want to toss out any messages that were not four bytes in length because we know that if the message is not four bytes in length, then the message got messed up in transmission.</p>
<p>We could also use a checksum to ensure that the message was received correctly. A checksum is some value that is calculated using the data that is sent. One of the easiest ways to generate a checksum is to add up all of the data bytes, storing the value in a byte that will cause the value to wrap around when it is greater than 255. Here is an example of a function that would generate a checksum:</p>
<pre>byte checksum(byte *bytes, int buf_size)<br/>{<br/>  byte checksum = 0;<br/>  for (int i=0; i&lt; buf_size; i++)<br/>  {<br/>    checksum += bytes[i];<br/>  }<br/>  return checksum;<br/>}</pre>
<p>This function takes a pointer to a <kbd>byte</kbd> array and the size of the array as parameters. It then loops through the array and adds each byte to the checksum and then returns the value. A byte can have a maximum value of 255, therefore once the value gets above 255 the value will loop around. For example, if the checksum byte had a value of 252 and a value of 10 was added to it, the checksum value would then be 7. We could then send the checksum before the <kbd>0x04</kbd> value, and the device that receives the message could verify the message integrity by calculating the checksum on the receiving end and verifying that the two values match.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we learned a lot about Bluetooth Classic, starting with a brief introduction on how the radio works and the network topology for Bluetooth Classic connections. We demonstrated how we could configure the Bluetooth HC-05 Bluetooth module as both a slave and master. We also saw how we could configure the Bluetooth modules to connect to each other on startup automatically. Finally, we saw how we could stream data from one device to another using Bluetooth classic.</p>
<p>In <a href="7695319d-e0ba-4f5e-91c6-0d96bc9f4ad0.xhtml" target="_blank">Chapter 20</a>, <em>Bluetooth LE</em>, and this chapter we looked at two different Bluetooth technologies, but the question may still be when to use which one. When we have a use case that defines that we want one device to ask another device for information periodically, like a weather station, we generally want to use Bluetooth LE. When we want to stream data from one device to another without waiting for the receiving device to ask for it, we generally want to use Bluetooth Classic.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Over the course of this book, we have looked at many different items from a microcontroller to sensors and from motors to wireless communication modules. The idea was to expose you to a number of different items to hopefully give you ideas for your own projects. The best thing about the Arduino, is the projects that you do are only limited by your imagination, so start imagining what super awesome projects you can do and then create them.</p>


            

            
        
    </body></html>