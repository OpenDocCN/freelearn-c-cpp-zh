["```cpp\n$ cmake . && cmake —build .\n```", "```cpp\n#include <fmt/core.h>\n#include <spdlog/sinks/basic_file_sink.h>\n#include <spdlog/sinks/stdout_color_sinks.h>\n#include <spdlog/spdlog.h>\n#include <chrono>\n#include <iostream>\n#include <mutex>\n#include <thread>\nusing namespace std::chrono_literals;\n```", "```cpp\nuint32_t counter1{};\nstd::mutex mtx1;\nuint32_t counter2{};\nstd::mutex mtx2;\n```", "```cpp\nauto console_sink = std::make_shared<\n         spdlog::sinks::stdout_color_sink_mt>();\nconsole_sink->set_level(spdlog::level::debug);\nauto file_sink = std::make_shared<\n         spdlog::sinks::basic_file_sink_mt>(\"logging.log\",\n                                            true);\nfile_sink->set_level(spdlog::level::info);\nspdlog::logger logger(\"multi_sink\",\n         {console_sink, file_sink});\nlogger.set_pattern(\n         \"%Y-%m-%d %H:%M:%S.%f - Thread %t [%l] : %v\");\nlogger.set_level(spdlog::level::debug);\n```", "```cpp\nauto increase_and_swap = [&]() {\n    logger.info(\"Incrementing both counters...\");\n    counter1++;\n    counter2++;\n    logger.info(\"Swapping counters...\");\n    std::swap(counter1, counter2);\n};\n```", "```cpp\nauto worker1 = [&]() {\n    logger.debug(\"Entering worker1\");\n    logger.info(\"Locking mtx1...\");\n    std::lock_guard<std::mutex> lock1(mtx1);\n    logger.info(\"Mutex mtx1 locked\");\n    std::this_thread::sleep_for(100ms);\n    logger.info(\"Locking mtx2...\");\n    std::lock_guard<std::mutex> lock2(mtx2);\n    logger.info(\"Mutex mtx2 locked\");\n    increase_and_swap();\n    logger.debug(\"Leaving worker1\");\n};\nauto worker2 = [&]() {\n    logger.debug(\"Entering worker2\");\n    logger.info(\"Locking mtx2...\");\n    std::lock_guard<std::mutex> lock2(mtx2);\n    logger.info(\"Mutex mtx2 locked\");\n    std::this_thread::sleep_for(100ms);\n    logger.info(\"Locking mtx1...\");\n    std::lock_guard<std::mutex> lock1(mtx1);\n    logger.info(\"Mutex mtx1 locked\");\n    increase_and_swap();\n    logger.debug(\"Leaving worker2\");\n};\nlogger.debug(\"Starting main function...\");\nstd::thread t1(worker1);\nstd::thread t2(worker2);\nt1.join();\nt2.join();\n```", "```cpp\n2024-09-04 23:39:54.484005 - Thread 38984 [debug] : Starting main function...\n2024-09-04 23:39:54.484106 - Thread 38985 [debug] : Entering worker1\n2024-09-04 23:39:54.484116 - Thread 38985 [info] : Locking mtx1...\n2024-09-04 23:39:54.484136 - Thread 38986 [debug] : Entering worker2\n2024-09-04 23:39:54.484151 - Thread 38986 [info] : Locking mtx2...\n2024-09-04 23:39:54.484160 - Thread 38986 [info] : Mutex mtx2 locked\n2024-09-04 23:39:54.484146 - Thread 38985 [info] : Mutex mtx1 locked\n2024-09-04 23:39:54.584250 - Thread 38986 [info] : Locking mtx1...\n2024-09-04 23:39:54.584255 - Thread 38985 [info] : Locking mtx2...\n```", "```cpp\n$ gdb <program> --args <args>\n```", "```cpp\n$ gdb –p <PID>\n```", "```cpp\n$ gdb <program> <coredump>\n```", "```cpp\n$ dprintf <location>, <format>, <args>\n```", "```cpp\n$ dprintf 25, \"x = %d\\n\", x if x > 5\n```", "```cpp\n#include <chrono>\n#include <mutex>\n#include <thread>\nusing namespace std::chrono_literals;\nint main() {\n    std::mutex mtx1, mtx2;\n    std::thread t1([&]() {\n        std::lock_guard lock1(mtx1);\n        std::this_thread::sleep_for(100ms);\n        std::lock_guard lock2(mtx2);\n    });\n    std::thread t2([&]() {\n        std::lock_guard lock2(mtx2);\n        std::this_thread::sleep_for(100ms);\n        std::lock_guard lock1(mtx1);\n    });\n    t1.join();\n    t2.join();\n    return 0;\n}\n```", "```cpp\n$ g++ -o test –g -O0 --fno-omit-frame-pointer test.cpp\n```", "```cpp\n$ ./test\n```", "```cpp\n$ ps aux | grep test\n```", "```cpp\n$ gdb –p <pid>\n```", "```cpp\nptrace: Operation not permitted.\n```", "```cpp\n$ sudo sysctl -w kernel.yama.ptrace_scope=0\n```", "```cpp\n(gdb) info threads\n  Id   Target Id                                Frame\n* 1    Thread 0x79d1f3883740 (LWP 14428) \"test\" 0x000079d1f3298d61 in __futex_abstimed_wait_common64 (private=128, cancel=true, abstime=0x0, op=265, expected=14429, futex_word=0x79d1f3000990)\n    at ./nptl/futex-internal.c:57\n  2    Thread 0x79d1f26006c0 (LWP 14430) \"test\" futex_wait (private=0, expected=2, futex_word=0x7fff5e406b00) at ../sysdeps/nptl/futex-internal.h:146\n  3    Thread 0x79d1f30006c0 (LWP 14429) \"test\" futex_wait (private=0, expected=2, futex_word=0x7fff5e406b30) at ../sysdeps/nptl/futex-internal.h:146\n```", "```cpp\n(gdb) info thread 1 3\n```", "```cpp\n(gdb) bt\n#0  0x000079d1f3298d61 in __futex_abstimed_wait_common64 (private=128, cancel=true, abstime=0x0, op=265, expected=14429, futex_word=0x79d1f3000990) at ./nptl/futex-internal.c:57\n#5  0x000061cbaf1174fd in main () at 11x18-debug_deadlock.cpp:22\n```", "```cpp\n(gdb) thread 2\n[Switching to thread 2 (Thread 0x79d1f26006c0 (LWP 14430))]\n```", "```cpp\n(gdb) bt\n#0  futex_wait (private=0, expected=2, futex_word=0x7fff5e406b00) at ../sysdeps/nptl/futex-internal.h:146\n#2  0x000079d1f32a00f1 in lll_mutex_lock_optimized (mutex=0x7fff5e406b00) at ./nptl/pthread_mutex_lock.c:48\n#7  0x000061cbaf1173fa in operator() (__closure=0x61cbafd64418) at 11x18-debug_deadlock.cpp:19\n```", "```cpp\n(gdb) thread apply 1 3 bt\n```", "```cpp\n(gdb) set scheduler-locking <on/off>\n```", "```cpp\n(gdb) show scheduler-locking\n```", "```cpp\n(gdb) thread apply all bt\nThread 3 (Thread 0x79d1f30006c0 (LWP 14429) \"test\"):\n#0  futex_wait (private=0, expected=2, futex_word=0x7fff5e406b30) at ../sysdeps/nptl/futex-internal.h:146\n#5  0x000061cbaf117e20 in std::mutex::lock (this=0x7fff5e406b30) at /usr/include/c++/14/bits/std_mutex.h:113\n#7  0x000061cbaf117334 in operator() (__closure=0x61cbafd642b8) at 11x18-debug_deadlock.cpp:13\nThread 2 (Thread 0x79d1f26006c0 (LWP 14430) \"test\"):\n#0  futex_wait (private=0, expected=2, futex_word=0x7fff5e406b00) at ../sysdeps/nptl/futex-internal.h:146\n#5  0x000061cbaf117e20 in std::mutex::lock (this=0x7fff5e406b00) at /usr/include/c++/14/bits/std_mutex.h:113\n#7  0x000061cbaf1173fa in operator() (__closure=0x61cbafd64418) at 11x18-debug_deadlock.cpp:19\n```", "```cpp\n(gdb) break <linespec> thread <id> if <condition>\n```", "```cpp\n(gdb) break test.cpp:11 thread 2\n```", "```cpp\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <iostream>\n#include <mutex>\n#include <thread>\nusing namespace std::chrono_literals;\nstatic int g_value = 0;\nstatic std::mutex g_mutex;\nvoid func1() {\n    const std::lock_guard<std::mutex> lock(g_mutex);\n    for (int i = 0; i < 10; ++i) {\n        int old_value = g_value;\n        int incr = (rand() % 10);\n        g_value += incr;\n        assert(g_value == old_value + incr);\n        std::this_thread::sleep_for(10ms);\n    }\n}\nvoid func2() {\n    for (int i = 0; i < 10; ++i) {\n        int old_value = g_value;\n        int incr = (rand() % 10);\n        g_value += (rand() % 10);\n        assert(g_value == old_value + incr);\n        std::this_thread::sleep_for(10ms);\n    }\n}\nint main() {\n    std::thread t1(func1);\n    std::thread t2(func2);\n    t1.join();\n    t2.join();\n    return 0;\n}\n```", "```cpp\n$ g++ -o test -g -O0 test\n$ gdb ./test\n```", "```cpp\ntest: test.cpp:29: void func2(): Assertion `g_value == old_value + incr' failed.\nThread 3 \"test\" received signal SIGABRT, Aborted.\n```", "```cpp\n$ rr record <program> --args <args>\n$ rr replay\n```", "```cpp\n$ rr record test\nrr: Saving execution to trace directory `/home/user/.local/share/rr/test-1'.\n```", "```cpp\n[FATAL src/PerfCounters.cc:349:start_counter()] rr needs /proc/sys/kernel/perf_event_paranoid <= 3, but it is 4.\nChange it to <= 3.\nConsider putting 'kernel.perf_event_paranoid = 3' in /etc/sysctl.d/10-rr.conf.\n```", "```cpp\n$ sudo sysctl kernel.perf_event_paranoid=1\n```", "```cpp\n$ rr replay\n```", "```cpp\n$ rr replay -e\n```", "```cpp\n(rr) set exec-direction reverse\n```", "```cpp\n(rr) set exec-direction forward\n```", "```cpp\nboost::asio::awaitable<void> echo(tcp::socket socket) {\n    char data[1024];\n    while (true) {\n        std::cout << \"Reading data from socket...\\n\";//L12\n        std::size_t bytes_read = co_await\n            socket.async_read_some(\n                boost::asio::buffer(data),\n                             boost::asio::use_awaitable);\n        /* .... */\n        co_await boost::asio::async_write(socket,\n                boost::asio::buffer(data, bytes_read),\n                boost::asio::use_awaitable);\n    }\n}\nboost::asio::awaitable<void>\nlistener(boost::asio::io_context& io_context,\n         unsigned short port) {\n    tcp::acceptor acceptor(io_context,\n                           tcp::endpoint(tcp::v4(), port));\n    while (true) {\n        std::cout << \"Accepting connections...\\n\";  // L45\n        tcp::socket socket = co_await\n            acceptor.async_accept(\n                boost::asio::use_awaitable);\n        boost::asio::co_spawn(io_context,\n            echo(std::move(socket)),\n            boost::asio::detached);\n    }\n}\n/* main function */\n```", "```cpp\n$ g++ --std=c++20 -ggdb -O0 --fno-omit-frame-pointer -lboost_system  test.cpp -o test\n```", "```cpp\n$ gdb –q ./test\n(gdb) b 12\n(gdb) b 45\n```", "```cpp\n(gdb) set print pretty on\n```"]