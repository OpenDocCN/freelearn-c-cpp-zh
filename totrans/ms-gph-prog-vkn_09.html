<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-140"><a id="_idTextAnchor143"/>9</h1>
<h1 id="_idParaDest-141"><a id="_idTextAnchor144"/>Implementing Variable Rate Shading</h1>
<p>In this chapter, we are going to implement a technique that has become quite popular recently: variable rate shading. This technique allows developers to specify at which rate to shade individual pixels while maintaining the same perceived visual quality. This approach allows us to reduce the time taken for some rendering passes, and the time savings can be used to implement more features or render at higher resolutions.</p>
<p>Vulkan provides multiple options to integrate this technique into an application, and we are going to provide an overview of all of them. This feature is provided through an extension that is supported only on recent hardware, but it’s possible to implement it manually using compute shaders. We won’t cover this option here, but we are going to point you to the relevant resources in the <em class="italic">Further </em><em class="italic">reading</em> section.</p>
<p>In this chapter, we’ll cover the following main topics:</p>
<ul>
<li>Introducing variable rate shading</li>
<li>Implementing variable rate shading using the Vulkan API</li>
<li>Using specialization constants to configure compute shaders</li>
</ul>
<h1 id="_idParaDest-142"><a id="_idTextAnchor145"/>Technical requirements</h1>
<p>The code for this chapter can be found at the following URL: <a href="https://github.com/PacktPublishing/Mastering-Graphics-Programming-with-Vulkan/tree/main/source/chapter9">https://github.com/PacktPublishing/Mastering-Graphics-Programming-with-Vulkan/tree/main/source/chapter9</a>.</p>
<h1 id="_idParaDest-143"><a id="_idTextAnchor146"/>Introducing variable rate shading</h1>
<p><strong class="bold">Variable rate shading</strong> (<strong class="bold">VRS</strong>) is a <a id="_idIndexMarker485"/>technique that allows developers to control the rate at which fragments are shaded. When this feature is disabled, all fragments are shaded using a 1x1 rate, meaning that the fragment shader will run for all fragments in the image.</p>
<p>With the introduction of <strong class="bold">virtual reality</strong> (<strong class="bold">VR</strong>) headsets, developers have started to investigate ways to reduce the amount of time it takes to render a frame. This is crucial, not only because VR requires rendering two frames (one for the right eye and one for the left) but also because VR is quite sensitive to frame latency, and higher frame rates are required to avoid users experiencing motion sickness.</p>
<p>One technique that was developed is called <strong class="bold">foveated rendering</strong>: the idea is to render the center of the image at full rate while lowering the quality outside the center. Developers have noticed that users are focused primarily on the central region of the image and don’t notice the lower quality in the surrounding area.</p>
<p>It turns out that this approach can be generalized outside of VR. For this reason, APIs such as DirectX® and Vulkan have added support for this feature natively.</p>
<p>With this more general approach, it’s possible to specify multiple shading rates for individual fragments. The rates that are usually recommended are 1x1, 1x2, 2x1, and 2x2. While it might be possible to adopt higher shading rates, it usually leads to a visible artifact in the final frame.</p>
<p>As we mentioned, a 1x1 rate implies that the fragment shader will run for all fragments within an image, and there are no time savings. This is the default behavior when VRS is not enabled.</p>
<p>A rate of 1x2 or 2x1 means that two fragments will be shaded by a single fragment shader<a id="_idIndexMarker486"/> invocation, and the computed value is applied to both fragments. Likewise, with a 2x2 shading rate, a single fragment invocation will compute and apply a single value to four fragments.</p>
<h2 id="_idParaDest-144"><a id="_idTextAnchor147"/>Determining the shading rate</h2>
<p>There are <a id="_idIndexMarker487"/>multiple options to choose the shading rate for individual fragments, and the one we have implemented is to run an edge detection filter based on luminance after the lighting pass.</p>
<p>The idea is to reduce the shading rate in the areas of the image where luminance is uniform and use a full rate in transition areas. This approach works because the human eye is more susceptible to noticing changes in those areas compared to ones that have more uniform values.</p>
<p>The filter we have used is the traditional Sobel filter in a 3x3 configuration. For each fragment, we compute two values:</p>
<div><div><img alt="Figure 9.1 – The filters used to approximate the x and y derivative for a given fragment (source: Wikipedia –https://en.wikipedia.org/wiki/Sobel_operator)" height="175" src="img/B18395_09_01.jpg" width="1116"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – The filters used to approximate the x and y derivative for a given fragment (source: Wikipedia –https://en.wikipedia.org/wiki/Sobel_operator)</p>
<p>We then compute the final derivative value with the following formula:</p>
<div><div><img alt="Figure 9.2 – The formula to approximate the derivative value (source: Wikipedia –https://en.wikipedia.org/wiki/Sobel_operator)" height="86" src="img/B18395_09_02.jpg" width="359"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – The formula to approximate the derivative value (source: Wikipedia –https://en.wikipedia.org/wiki/Sobel_operator)</p>
<p>Let’s apply the <a id="_idIndexMarker488"/>Sobel filter to the following image:</p>
<div><div><img alt="Figure 9.3 – The rendered frame after the lighting pass" height="678" src="img/B18395_09_03.jpg" width="1088"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – The rendered frame after the lighting pass</p>
<p>It gives us the following shading rate mask:</p>
<div><div><img alt="Figure 9.4 – The computed shading rate mask" height="788" src="img/B18395_09_04.jpg" width="1269"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – The computed shading rate mask</p>
<p>In our implementation, we are going to use a full 1x1 rate for fragments that have a <code>G</code> value (as computed by the formula in <em class="italic">Figure 9</em><em class="italic">.2</em>) greater than <code>0.1</code>. These are the black pixels in <em class="italic">Figure 9</em><em class="italic">.4</em>.</p>
<p>For fragments whose <code>G</code> value is below <code>0.1</code>, we are going to use a 2x2 rate, and these fragments are the red pixels in the screenshot in <em class="italic">Figure 9</em><em class="italic">.4</em>. We will explain how the values in the mask are computed in the next section.</p>
<p>In this<a id="_idIndexMarker489"/> section, we have introduced the concepts behind variable rate shading and provided the details for our implementation. In the next section, we will demonstrate how to implement this feature using the Vulkan API.</p>
<h1 id="_idParaDest-145"><a id="_idTextAnchor148"/>Integrating variable rate shading using Vulkan</h1>
<p>As we <a id="_idIndexMarker490"/>mentioned in the previous <a id="_idIndexMarker491"/>section, the fragment shading rate functionality is provided through the <code>VK_KHR_fragment_shading_rate</code> extension. As with other option extensions, make sure the device you are using supports it before calling the related APIs.</p>
<p>Vulkan provides three methods to control the shading rate:</p>
<ul>
<li>Per draw</li>
<li>Per primitive</li>
<li>Using an image attachment for a render pass</li>
</ul>
<p>To use a custom shading rate per draw, there are two options. We can pass a <code>VkPipelineFragmentShadingRateStateCreateInfoKHR</code> structure when creating a pipeline, or we can call <code>vkCmdSetFragmentShadingRateKHR</code> at runtime.</p>
<p>This approach is useful when we know in advance that some draws can be performed at a lower rate without affecting quality. This could include the sky or objects we know are far away from the camera.</p>
<p>It’s also possible to provide a shading rate per primitive. This is accomplished by populating the <code>PrimitiveShadingRateKHR</code> built-in shader variable from a vertex or mesh shader.</p>
<p>This can be useful if, for instance, we have determined we can use a lower level of details in the mesh shader and a lower rate to render that particular primitive.</p>
<p>For <a id="_idIndexMarker492"/>our <a id="_idIndexMarker493"/>implementation, we decided to use the third approach as it is more flexible for our use case. As we mentioned in the previous section, we first need to compute the variable rate shading mask. This is done using a compute shader that populates the shading rate image.</p>
<p>We start by populating a table that is shared within a shader invocation:</p>
<pre class="source-code">
shared float local_image_data[ LOCAL_DATA_SIZE ][
   LOCAL_DATA_SIZE ];
local_image_data[ local_index.y ][ local_index.x ] = 
   luminance( texelFetch( global_textures[ 
   color_image_index ], global_index, 0 ).rgb ); 
barrier();</pre>
<p>Each entry in the table contains the luminance value for the fragment for this shader invocation.</p>
<p>We used this approach to reduce the number of texture reads we needed to perform. If each shader thread had to read the values it needs individually, we would need eight texture reads. With this solution, only one read per thread is needed.</p>
<p>There is a caveat for the threads of the fragments on the border of the region we are processing. With each shader invocation, we process 16x16 fragments, but because of how the Sobel filter works, we need to fill an 18x18 table. For the threads on the border, we need to do some extra processing to make sure the table is fully filled. We have omitted the code here for brevity.</p>
<p>Notice that we have to use the <code>barrier()</code> method to guarantee that all threads within this workgroup have completed their write. Without this call, threads will compute the wrong value, as the table will not be filled correctly.</p>
<p>Next, we<a id="_idIndexMarker494"/> compute <a id="_idIndexMarker495"/>the value of the derivative for a given fragment:</p>
<pre class="source-code">
float dx = local_image_data[ local_index.y - 1 ][
    local_index.x - 1 ] - local_image_data[
    local_index.y - 1 ][ local_index.x + 1 ] +
    2 * local_image_data[ local_index.y ][
    local_index.x - 1 ] -
    2 * local_image_data[ local_index.y ][
    local_index.x + 1 ] +
    local_image_data[ local_index.y + 1][
    local_index.x - 1 ] -
    local_image_data[ local_index.y + 1 ][
    local_index.x + 1 ];
float dy = local_image_data[ local_index.y - 1 ][
    local_index.x - 1 ] +
    2 * local_image_data[ local_index.y - 1 ][
    local_index.x ] +
    local_image_data[ local_index.y - 1 ][
    local_index.x + 1 ] -
    local_image_data[ local_index.y + 1 ][
    local_index.x - 1 ] -
    2 * local_image_data[ local_index.y + 1 ][
    local_index.x ] -
    local_image_data[ local_index.y + 1 ][
    local_index.x + 1 ];
float d = pow( dx, 2 ) + pow( dy, 2 );</pre>
<p>This is simply applying <a id="_idIndexMarker496"/>the <a id="_idIndexMarker497"/>formula we introduced in the previous section. Now that we have computed the derivative, we need to store the shading rate for this fragment:</p>
<pre class="source-code">
uint rate = 1 &lt;&lt; 2 | 1;
if ( d &gt; 0.1 ) {
    rate = 0;
}
imageStore( global_uimages_2d[ fsr_image_index ], ivec2(
    gl_GlobalInvocationID.xy ), uvec4( rate, 0, 0, 0 ) );</pre>
<p>The rate is computed following the formula from the Vulkan specification:</p>
<pre class="source-code">
size_w = 2^( ( texel / 4 ) &amp; 3 )
size_h = 2^( texel &amp; 3 )</pre>
<p>In our case, we are computing the <code>texel</code> value in the previous formula. We are setting the exponent (<code>0</code> or <code>1</code>) for the <code>x</code> and <code>y</code> shading rates and storing the value in the shading rate image.</p>
<p>Once the shading rate image has been filled, we can use it to provide the shading rate for the render pass for the next frame. Before using this image, we need to transition it to the correct layout:</p>
<pre class="source-code">
VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_
    KHR</pre>
<p>We also need to use a new pipeline stage:</p>
<pre class="source-code">
VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR</pre>
<p>There are a few options to use the newly created shading rate image as part of a render pass. The <code>VkSubpassDescription2</code> structure can be extended by a <code>VkFragmentShadingRateAttachmentInfoKHR</code> structure, which specifies which attachment<a id="_idIndexMarker498"/> to<a id="_idIndexMarker499"/> use as the fragment shading rate. Since we aren’t using the <code>RenderPass2</code> extension just yet, we opted to extend our existing dynamic rendering implementation.</p>
<p>We have to extend the <code>VkRenderingInfoKHR</code> structure using the following code:</p>
<pre class="source-code">
VkRenderingFragmentShadingRateAttachmentInfoKHR
shading_rate_info {
    VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING
        _RATE_ATTACHMENT_INFO_KHR };
shading_rate_info.imageView = texture-&gt;vk_image_view;
shading_rate_info.imageLayout =
    VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE
        _ATTACHMENT_OPTIMAL_KHR;
shading_rate_info.shadingRateAttachmentTexelSize = { 1, 1 };
rendering_info.pNext = ( void* )&amp;shading_rate_info;</pre>
<p>And that’s it! The shader used for rendering doesn’t require any modifications.</p>
<p>In this section, we have detailed the changes required to our rendering code to make use of a shading rate image. We have also provided the implementation of the compute shader that implements an edge detection algorithm based on the Sobel filter.</p>
<p>The result of this algorithm is then used to determine the shading rate for each fragment.</p>
<p>In the next section, we <a id="_idIndexMarker500"/>are going to <a id="_idIndexMarker501"/>introduce specialization constants, a Vulkan feature that allows us to control the workgroup size of compute shaders for optimal performance.</p>
<h1 id="_idParaDest-146"><a id="_idTextAnchor149"/>Taking advantage of specialization constants</h1>
<p><strong class="bold">Specialization constants</strong> are a <a id="_idIndexMarker502"/>Vulkan feature that allows developers to define constant values when creating a pipeline. This is particularly useful when the same shader is needed for multiple use cases that differ only for some constant values, for example, materials. This is a more elegant solution compared to pre-processor definitions as they can be dynamically controlled at runtime without having to recompile the shaders.</p>
<p>In our case, we want to be able to control the workgroup size of compute shaders based on the hardware we are running to obtain the best performance:</p>
<ol>
<li>The first step in the implementation is to determine whether a shader uses specialization constants. We now identify any variables that have been decorated with the following type when parsing the shader SPIR-V:<pre class="source-code">
case ( SpvDecorationSpecId ):</pre><pre class="source-code">
{</pre><pre class="source-code">
    id.binding = data[ word_index + 3 ];</pre><pre class="source-code">
    break;</pre><pre class="source-code">
}</pre></li>
<li>When parsing all the variables, we now save the specialization constants’ details so that they can be<a id="_idIndexMarker503"/> used when compiling a pipeline that uses this shader:<pre class="source-code">
switch ( id.op ) {</pre><pre class="source-code">
    case ( SpvOpSpecConstantTrue ):</pre><pre class="source-code">
    case ( SpvOpSpecConstantFalse ):</pre><pre class="source-code">
    case ( SpvOpSpecConstant ):</pre><pre class="source-code">
    case ( SpvOpSpecConstantOp ):</pre><pre class="source-code">
    case ( SpvOpSpecConstantComposite ):</pre><pre class="source-code">
    {</pre><pre class="source-code">
        Id&amp; id_spec_binding = ids[ id.type_index ];</pre><pre class="source-code">
SpecializationConstant&amp; </pre><pre class="source-code">
   specialization_constant = parse_result-&gt; </pre><pre class="source-code">
   specialization_constants[ </pre><pre class="source-code">
   parse_result-&gt; </pre><pre class="source-code">
   specialization_constants_count </pre><pre class="source-code">
   ]; </pre><pre class="source-code">
        specialization_constant.binding =</pre><pre class="source-code">
            id_spec_binding.binding;</pre><pre class="source-code">
        specialization_constant.byte_stride =</pre><pre class="source-code">
            id.width / 8;</pre><pre class="source-code">
        specialization_constant.default_value =</pre><pre class="source-code">
            id.value;</pre><pre class="source-code">
        SpecializationName&amp; specialization_name =</pre><pre class="source-code">
         parse_result-&gt;specialization_names[</pre><pre class="source-code">
             parse_result-&gt;</pre><pre class="source-code">
             specialization_constants_count ];</pre><pre class="source-code">
        raptor::StringView::copy_to(</pre><pre class="source-code">
            id_spec_binding.name,</pre><pre class="source-code">
                 specialization_name.name, 32 );</pre><pre class="source-code">
        ++parse_result-&gt;</pre><pre class="source-code">
            specialization_constants_count;</pre><pre class="source-code">
        break;</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
<li>Now that we<a id="_idIndexMarker504"/> have the specialization constants’ information, we can change their values when creating a pipeline. We start by filling a <code>VkSpecializationInfo</code> structure:<pre class="source-code">
VkSpecializationInfo specialization_info;</pre><pre class="source-code">
VkSpecializationMapEntry specialization_entries[</pre><pre class="source-code">
    spirv::k_max_specialization_constants ];</pre><pre class="source-code">
u32 specialization_data[</pre><pre class="source-code">
    spirv::k_max_specialization_constants ];</pre><pre class="source-code">
specialization_info.mapEntryCount = shader_state-&gt;</pre><pre class="source-code">
    parse_result-&gt;specialization_constants_count;</pre><pre class="source-code">
specialization_info.dataSize = shader_state-&gt;</pre><pre class="source-code">
    parse_result-&gt;specialization_constants_count *</pre><pre class="source-code">
        sizeof( u32 );</pre><pre class="source-code">
specialization_info.pMapEntries =</pre><pre class="source-code">
    specialization_entries;</pre><pre class="source-code">
specialization_info.pData = specialization_data;</pre></li>
<li>We then set <a id="_idIndexMarker505"/>the value for each specialization constant entry:<pre class="source-code">
for ( u32 i = 0; i &lt; shader_state-&gt;parse_result-&gt;</pre><pre class="source-code">
    specialization_constants_count; ++i ) {</pre><pre class="source-code">
    const spirv::SpecializationConstant&amp;</pre><pre class="source-code">
        specialization_constant = shader_state-&gt;</pre><pre class="source-code">
            parse_result-&gt;</pre><pre class="source-code">
                specialization_constants[ i ];</pre><pre class="source-code">
    cstring specialization_name = shader_state-&gt;</pre><pre class="source-code">
        parse_result-&gt;specialization_names[ i ].name;</pre><pre class="source-code">
    VkSpecializationMapEntry&amp; specialization_entry =</pre><pre class="source-code">
        specialization_entries[ i ];</pre><pre class="source-code">
    if ( strcmp(specialization_name, "SUBGROUP_SIZE")</pre><pre class="source-code">
        == 0 ) {</pre><pre class="source-code">
                   specialization_entry.constantID =</pre><pre class="source-code">
                      specialization_constant.binding;</pre><pre class="source-code">
        specialization_entry.size = sizeof( u32 );</pre><pre class="source-code">
        specialization_entry.offset = i * sizeof( u32 );</pre><pre class="source-code">
        specialization_data[ i ] = subgroup_size;</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
</ol>
<p>In our case, we are looking for a variable named <code>SUBGROUP_SIZE</code>. The final step is to store the specialization constant details in the shader stage structure that will be used when creating the pipeline:</p>
<pre class="source-code">
shader_stage_info.pSpecializationInfo =
    &amp;specialization_info;</pre>
<p>During compilations, the driver and compiler will override the existing value in the shader with the one we specified.</p>
<p>In this section, we have illustrated how to take advantage of specialization constants to modify shader behavior at runtime. We detailed the changes we made to identify specialization<a id="_idIndexMarker506"/> constants when parsing the SPIR-V binary. We then highlighted the new code required to override a specialization constant value when creating a pipeline.</p>
<h1 id="_idParaDest-147"><a id="_idTextAnchor150"/>Summary</h1>
<p>In this chapter, we introduced the variable rate shading technique. We gave a brief overview of this approach and how it can be used to improve the performance of some rendering passes without a loss in perceived quality. We also explained the edge detection algorithm used to determine the shading rate for each fragment.</p>
<p>In the next section, we illustrated the changes necessary to enable and use this feature with the Vulkan API. We detailed the options available to change the shading rate at the draw, primitive, and render pass level. We then explained the implementation of the edge detection algorithm using a compute shader and how the result is used to generate the shading rate image.</p>
<p>In the last section, we introduced specialization constants, a mechanism provided by the Vulkan API to modify shader constant values at compile time. We illustrated how this feature can be used to control the group size of compute shaders for optimal performance based on the device our code is running on.</p>
<p>In the next chapter, we will introduce volumetric effects into our scene. This technique allows us to set the mood of the environment and can be used to direct the attention of the player to a particular area.</p>
<h1 id="_idParaDest-148"><a id="_idTextAnchor151"/>Further reading</h1>
<p>We only gave a brief overview of the Vulkan APIs for variable rate shading. We recommend reading the specification for further details: <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.xhtml#primsrast-fragment-shading-rate">https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.xhtml#primsrast-fragment-shading-rate</a>.</p>
<p>Most of the resources available online seem to be focused on the DirectX API, but the same approach can be translated to Vulkan. This blog post provides some details on the benefits of VRS: <a href="https://devblogs.microsoft.com/directx/variable-rate-shading-a-scalpel-in-a-world-of-sledgehammers/">https://devblogs.microsoft.com/directx/variable-rate-shading-a-scalpel-in-a-world-of-sledgehammers/</a>.</p>
<p>These two videos provide in-depth details on integrating VRS into existing game engines. The section on how to implement VRS using compute shader is particularly interesting:</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=pPyN9r5QNbs">https://www.youtube.com/watch?v=pPyN9r5QNbs</a></li>
<li><a href="https://www.youtube.com/watch?v=Sswuj7BFjGo">https://www.youtube.com/watch?v=Sswuj7BFjGo</a></li>
</ul>
<p>This article illustrates how VRS can also have other use cases, for instance, to accelerate raytracing: <a href="https://interplayoflight.wordpress.com/2022/05/29/accelerating-raytracing-using-software-vrs/">https://interplayoflight.wordpress.com/2022/05/29/accelerating-raytracing-using-software-vrs/</a>.</p>
</div>
</div></body></html>