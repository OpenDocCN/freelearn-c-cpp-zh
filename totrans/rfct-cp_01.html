<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-14"><a id="_idTextAnchor013"/>1</h1>
<h1 id="_idParaDest-15"><a id="_idTextAnchor014"/>Coding Standards in C++</h1>
<p>In this chapter, we will delve into the world of clean code and examine its crucial role in successful software projects. We will discuss the concept of technical debt and how poor-quality code can contribute to its accumulation. Additionally, we will explore the often undervalued practices of code <a id="_idIndexMarker000"/>formatting and documentation, which <a id="_idIndexMarker001"/>are crucial for maintaining a manageable and effective code base. Through this chapter, we will understand that clean code is not just nice to have but a necessity for any project.</p>
<p>We will discuss the importance of coding standards and introduce common conventions and best practices used in the C++ community. By the end of this chapter, you will better understand what clean code is, why it is essential, and why documenting code is crucial.</p>
<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/>The difference between good code and bad code</h1>
<p>There is no <a id="_idIndexMarker002"/>strict definition of good or clean code. Moreover, no automatic tool can measure the quality of code. There are linters, code checkers, and other analyzers that can help to make code better. These tools are very valuable and highly recommended, but not sufficient. Artificial Intelligence may take over and develop code for us, but in the end, its measurement of code quality will be based on our human ideas of good code.</p>
<p>Programming languages were initially developed to provide an interface between machines and developers; however, with the growth of software products’ complexity, it becomes clear that nowadays, it is mostly a way of communicating ideas and intentions between developers. It is a well-known fact that developers spend ten times more time reading the code than writing it. It means that to be efficient, we must do our best to make the reading easier. The most successful way to make this process efficient is to make the code predictable or, even better, boring. By boring, I mean code that the reader looks at and knows what to expect from it regarding functionality, performance, and side effects. The following example illustrates an interface for a class retrieving objects from a database:</p>
<pre class="source-code">
class Database {
public:
  template&lt;typename T&gt;
  std::optional&lt;T&gt; get(const Id&amp; id) const;
  template&lt;typename T&gt;
  std::optional&lt;T&gt; get(const std::string&amp; name) const;
};</pre>
<p>It <a id="_idIndexMarker003"/>supports two lookup modes, by <code>id</code> and by <code>name</code>; it is not supposed to change the internal state of the <code>Database</code> object because of the <code>const</code> modifier; and it can only do read operations against the database instance. It is boring, but it meets basic expectations. Imagine how surprising it can be to find out during critical bug investigation that on each read operation, it does an update operation and sometimes a delete operation?</p>
<p>As readers can see, a few key factors can distinguish good code and bad code. Good code is typically well written, easy to read, and efficient. It follows the conventions and standards of the C++ language and is organized in a logical and consistent manner. Good code is also well documented, often with clear comments explaining the purpose and function of things that are not obvious from reading only the code.</p>
<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>Why coding standards are important</h1>
<p>Coding standards <a id="_idIndexMarker004"/>are important for several reasons. First and foremost, they help to <a id="_idIndexMarker005"/>minimize <em class="italic">technical debt</em>. Technical debt, also <a id="_idIndexMarker006"/>known as “code debt,” is a metaphor that describes the cost of maintaining and modifying code that is not well designed or well written. Just as financial debt incurs interest and requires ongoing payments, technical debt incurs additional costs in the form of the time and effort needed to maintain and modify poorly designed code.</p>
<p>Technical debt can accumulate in many ways, such as through hacky or quick-fix solutions to problems <a id="_idIndexMarker007"/>or by ignoring best practices or coding standards. As technical debt accumulates, it can become increasingly difficult and time-consuming to modify and maintain the code, which can negatively impact the efficiency and effectiveness of a development team.</p>
<p>In order to<a id="_idIndexMarker008"/> manage technical debt carefully, it is essential to try to avoid accumulating too much of it, as it can become a significant burden on a development team. Strategies for managing technical debt include regularly refactoring code to improve its design and maintainability, following best practices and coding standards, and actively seeking out opportunities to improve the quality of the code. Overall, managing technical debt is an important aspect of good code design and development and can help to ensure that code is efficient, reliable, and easy to work with.</p>
<p>Coding standards help to ensure the quality and consistency of code. By establishing a set of guidelines and conventions for writing code, coding standards help to ensure that code is well written, easy to read, and easy to understand. This makes it easier for others to maintain and update the code and helps to prevent errors and bugs.</p>
<p>In addition, they help to improve the efficiency of code. By following established conventions and best practices, programmers can write code that is more efficient and performs better. This can save time and resources and help ensure that code is scalable and can handle large amounts of data and traffic.</p>
<p>Furthermore, coding standards promote collaboration and teamwork among programmers. By establishing a common set of guidelines and conventions, coding standards make it easier for teams of programmers to work together on a project. This allows better communication and coordination and helps to ensure that everyone is on the same page and working towards the same goals.</p>
<p>Coding standards often promote the interoperability and portability of code. By following a standardized set of conventions, code written by one programmer can be easily understood and used by another programmer. This allows code to be more easily integrated into larger projects and helps to ensure that it can be used on a variety of different platforms and operating systems.</p>
<p>The C++ programming language is probably one of the richest languages in terms of features. It started as <em class="italic">C with classes</em>, providing object-oriented support with high performance and almost complete compatibility with C; later on, template metaprogramming was introduced, and Stepanov and Lee developed the Standard Template Library, nowadays known as the C++ Standard Library. Modern C++ (C++11 and newer versions) provides extensive support for multiple programming paradigms, including procedural, object-oriented, generic, and functional programming. It offers features such as lambda expressions, range-based <code>for</code> loops, smart pointers, and type inference that enable functional programming techniques. Additionally, C++ provides support for<a id="_idIndexMarker009"/> object-oriented programming concepts such as inheritance, encapsulation, and polymorphism. It also offers template metaprogramming, which enables generic programming and allows compile-time optimizations. Furthermore, C++ provides concurrency support with features such as threads, atomic types, and futures, making it easier to write concurrent and parallel code. This flexibility is key to the strength of the language but often leads to problems with maintainability.</p>
<p>A developer has to understand the concepts of the paradigms we’ve mentioned, how to use them together, and how they eventually affect the performance of the code. This is when coding standards can help to explain the complexity of the code base.</p>
<p>All these factors make coding guidelines the bare minimum that a modern C++ project should have to attain a quality standard.</p>
<h2 id="_idParaDest-18"><a id="_idTextAnchor017"/>Code convention</h2>
<p>Contrary to <a id="_idIndexMarker010"/>languages such as Python, Go, Java, and many others, C++ does not have a common code convention.</p>
<p>There are several popular coding conventions for the C++ programming language. Here are some common conventions that are widely followed:</p>
<ul>
<li><code>total_cost</code> or <code>customer_name</code>. Class variables often have prefixes or suffixes to distinguish them from other variables, such as <code>m_user_count</code> or <code>user_count_</code>. Functions may be named using <em class="italic">camelCase</em>, with the first letter of each word (apart from the first word) capitalized, such as <code>calculateTotalCost</code> or <code>getCustomerName</code>. Classes may be named using <em class="italic">PascalCase</em>, with the first letter of each word capitalized, such as <code>Customer</code> or <code>Invoice</code>.</li>
<li><strong class="bold">Commenting</strong>: Commenting conventions<a id="_idIndexMarker012"/> specify how to write and format comments in code. Comments are used to provide explanations and documentation for code and should be clear and concise. It is often recommended to use inline comments to explain specific lines of code, as well as block comments to provide an overview of a code block or function.</li>
<li><code>for</code> loop or <code>if</code> statement, to visually indicate the structure of the code. Formatting policy often covers asterisk (<code>*</code>) and ampersand (<code>&amp;</code>) alignment in pointers and references (e.g., <code>int* ptr</code> versus <code>int *ptr</code> or <code>Socket &amp;socket</code> versus <code>Socket&amp; socket</code>), curly braces position (same line, next line, or context dependent). This book covers aspects of automated formatting in <a href="B19606_13.xhtml#_idTextAnchor260"><em class="italic">Chapter 13</em></a>.</li>
<li><code>goto</code> operators.</li>
</ul>
<p>It is<a id="_idIndexMarker015"/> important to note that there may be variations in coding conventions between different organizations and teams. It is important to follow the conventions that your team or organization establishes or to define your own conventions if none are specified.</p>
<p>It can be tedious to develop a coding convention; some companies prefer to use an existing one and adapt it to their needs. In the C++ programming language, there are several popular code standards that are widely followed by developers. These standards aim to improve the readability, maintainability, and overall quality of C++ code.</p>
<p>One common code <a id="_idIndexMarker016"/>standard for C++ is the C++ Core Guidelines (<a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines</a>), which were developed by Bjarne Stroustrup, the creator of C++, and a group of experts from industry and academia. The guidelines cover a wide range of topics, including naming conventions, commenting, formatting, and coding style.</p>
<p>Another <a id="_idIndexMarker017"/>popular code standard for C++ is the Google C++ Style Guide (<a href="https://google.github.io/styleguide/cppguide.html">https://google.github.io/styleguide/cppguide.html</a>), which is used by many <a id="_idIndexMarker018"/>software companies, including Google. The guide provides guidelines for naming conventions, commenting, formatting, and coding style, as well as recommendations for using specific C++ features and libraries.</p>
<p>In addition to these widely followed standards, there are also many other code standards that have been developed by individual organizations and teams, for example, LLVM Coding Standards, WebKit, and Mozilla’s style guides.</p>
<p>If a project conforms with a specific code convention, it is easier to read it, and as a bonus, the code base becomes more <em class="italic">grepable</em>. Consider needing to find the places where a variable called <code>request_id</code> is assigned. It can be easily achieved via the <code>grep</code> utility:</p>
<pre class="source-code">
$ grep -rn "request_id = " .
./RequestHandler.cpp:25: request_id = new_request_id;
./RequestHandler.cpp:122: request_id = request.getId();</pre>
<p>Code reviewers used to spend hours catching and commenting on inconsistencies with code format during peer review. Luckily, today we have tools such as Clang-Tidy and Clang-Format that allow us to ensure the consistency of the code format automatically via code editors<a id="_idIndexMarker019"/> and <strong class="bold">continuous integration</strong> (<strong class="bold">CI</strong>). We will dive deeper into their configuration later in this book in <a href="B19606_10.xhtml#_idTextAnchor184"><em class="italic">Chapter 10</em></a>.</p>
<h2 id="_idParaDest-19"><a id="_idTextAnchor018"/>Language features limitations</h2>
<p>C++ is a powerful <a id="_idIndexMarker020"/>language; as we know, great power comes with great responsibility. It is not easy for engineers, especially those who have not spent decades writing C++ code, to grasp the complexity of the language. As a result, some companies decide to limit the features used in their projects. The<a id="_idIndexMarker021"/> limitations may include a ban for multiple inheritance, usage of exceptions, and minimal usage of macros, templates, and specific third-party libraries. Additionally, the regulations may come from the use of legacy libraries. For example, if most of the code does not support C++ exceptions, it might be a bad idea to add them to new pieces of code without a prior understanding of the outcome.</p>
<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/>General guidelines</h2>
<p>It is always<a id="_idIndexMarker022"/> a good idea to have general guidelines for a project. The guidelines often cover the preferred way of working on the project:</p>
<ul>
<li>Usage of raw pointers, if allowed</li>
<li>How values are returned from getters and provided to setters (by value or reference)</li>
<li>Use of code comments:<ul><li>Are comments allowed in general?</li><li>Usage of strategic and tactical comments</li><li>Comment style: free, Doxygen, and so on</li></ul></li>
</ul>
<p>Coding standards are necessary to help ensure code quality, consistency, interoperability, portability, efficiency, and collaboration. By following coding standards, programmers can write better code that is easier to understand, maintain, and use and works better and more efficiently.</p>
<h1 id="_idParaDest-21"><a id="_idTextAnchor020"/>Readability, efficiency, maintainability, and usability</h1>
<p>Readability, efficiency, maintainability, and usability are all critical factors to consider when writing code.</p>
<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>Readability</h2>
<p>Readability <a id="_idIndexMarker023"/>refers to the ease with which a human reader can understand a piece of code. Well-written code is easy to read, with clear and concise statements that are organized in a logical and consistent manner. This becomes very important if we consider that developers spend ten times more time reading code than writing it.</p>
<p>Let’s take a look at the following piece of code:</p>
<pre class="source-code">
class Employee {
public:
  std::string get_name();
  std::string surname();
  uint64_t getId() const;
};</pre>
<p>This example is an exaggerated example of code not following any code convention. A developer using the <code>Employee</code> class can understand that all three methods are getters. However, the differences in the names make the user spend more time understanding the code or trying to understand the reasoning behind the names. Do the methods have different names because programmers did not care about the uniformity of the class? Or because, for example, methods without the <code>get</code> prefix are simple getters, and ones that contain the <code>get</code> prefix fetch the data from a file or a database?</p>
<p>Additionally, do the methods without <code>const</code> change the object’s state (via caching, for example), or is it a mistake? Do you see how many questions can be raised? They can be answered only when a developer jumps into the corresponding implementation, which means time is wasted. Making the code look uniform across the code base helps developers to understand the meanings and complications of classes, methods, and functions by looking at their declarations in the header files or even via autocompletion in modern code editors.</p>
<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>Efficiency</h2>
<p>Efficiency refers <a id="_idIndexMarker024"/>to the ability of a piece of code to perform its intended tasks in an efficient manner. Efficient code uses few resources, such as time and memory, to accomplish a task, and is able to handle large amounts of data and traffic without slowing down or crashing. By improving the efficiency of code, programmers can save time and resources and can ensure that their code is scalable and can handle the demands of a growing user base.</p>
<p>There are<a id="_idIndexMarker025"/> surefire ways to optimize C++ code, such as passing read-only parameters by constant reference to avoid unnecessary copying, or using the character-overloaded version of <code>std::string::find</code> when looking for a single character to avoid string a creation:</p>
<pre class="source-code">
my_string.find('A');
my_string.find("A");</pre>
<p>However, the more systematic way to achieve and maintain code efficiency is to follow the Pareto principle. This principle, when applied to software engineering, says that roughly 20% of the code does 80% of the work. For example, usually, there is no need to optimize the code parsing config files on startup of a background daemon because it happens only once during the program’s lifetime. However, it might be important to avoid copying large data structures in the main flow. The optimal way to improve the efficiency includes picking this 20% of performance-critical code and adding benchmarks for it. The benchmarks are expected to run as part of the CI process to make sure that no degradation is introduced.</p>
<p>Additionally, end-to-end testing can measure the overall performance of the application. This book discusses the best practices of writing unit tests and end-to-end tests in <a href="B19606_13.xhtml#_idTextAnchor260"><em class="italic">Chapter 13</em></a>. It is important to note that the automated tools cannot replace an engineer doing code reviews for the new code, mainly because there is no tool that can find the 20% of the code that does 80% of the work.</p>
<h2 id="_idParaDest-24"><a id="_idTextAnchor023"/>Maintainability</h2>
<p>Maintainability <a id="_idIndexMarker026"/>refers to the ease with which a piece of code can be updated and modified over time. Well-written code is easy to maintain, with clear and well-documented code that is organized in a logical and consistent manner. By improving the maintainability of code, programmers can make it easier for others to update and modify their code and can ensure that their code remains relevant and useful over time. Ideally, while developing new components, developers should think about the current problems the code is solving and the future usage and extension of the code. For example, while developing support for a data provider, it might be useful to ask whether the provider is going to be the only one supported. If not, it might be helpful to think about the standard features of data providers and extract them in an abstract <a id="_idIndexMarker027"/>base class. Here’s an example:</p>
<pre class="source-code">
class BaseDataProvider {
public:
  BaseDataProvider() = default;
  BaseDataProvider(const BaseDataProvider&amp;) = delete;
  BaseDataProvider(BaseDataProvider&amp;&amp;) = default;
  BaseDataProvider&amp; operator = (const BaseDataProvider&amp;) =
    delete;
  BaseDataProvider&amp; operator = (BaseDataProvider&amp;&amp;) =
    default;
  virtual ~BaseDataProvider() = default;
  virtual Data getData() const = 0;
};
class NetworkDataProvider : public BaseDataProvider {
public:
  NetworkDataProvider(const Endpoint&amp; endpoint);
  Data getData() const override;
};
class FileDataProvider : public BaseDataProvider {
public:
  FileDataProvider(const std::string&amp; filename);
  Data getData() const override;
};</pre>
<p>In this<a id="_idIndexMarker028"/> example, the <code>DataProvider</code> class is an abstract base class that defines the interface for providing data. The <code>NetworkDataProvider</code> and <code>FileDataProvider</code> classes are derived from <code>DataProvider</code> and override the <code>getData</code> virtual function to provide the specific implementation for reading data from a file or a network endpoint, respectively. This design makes it easy to add new data sources by simply creating a new class derived from <code>DataProvider</code> and providing the appropriate implementation for the <code>getData</code> virtual function.</p>
<p>It is clear from the example that the base interface may include not only the functionality but also the copy-move policy of the object. Later, the user code can receive the data provider(s) with reference to the base class and be agnostic to the type of provider, as shown in the following snippet:</p>
<pre class="source-code">
class DataParser {
public:
  DataParser(const BaseDataProvider&amp; provider);
  void parse();
};</pre>
<p>Additionally, this inheritance can be used for mocking data providers while creating unit tests for <code>DataParser</code>. Unit tests are covered in detail in <a href="B19606_13.xhtml#_idTextAnchor260"><em class="italic">Chapter 13</em></a>.</p>
<p>On a side note, it is crucial not to make code overcomplicated, or to be ready for any change. Otherwise, the need to make everything extendable may lead to monsters such as the following snippet:</p>
<pre class="source-code">
#define BASE_CLASS(TYPE)                 \
  template &lt;typename T&gt;                  \
  class TYPE {                           \
  public:                                \
    T value;                             \
    TYPE(T val) : value(val) {}          \
  };
#define DERIVED_CLASS(TYPE, BASE)        \
  template &lt;typename T&gt;                  \
  class TYPE : public BASE&lt;T&gt; {          \
  public:                                \
    TYPE(T val) : BASE&lt;T&gt;(val) {}        \
    T getValue() { return value; } \
  };
BASE_CLASS(Base);
DERIVED_CLASS(Derived, Base);
int main() {
  Derived&lt;int&gt; obj(5);
  std::cout &lt;&lt; obj.getValue() &lt;&lt; std::endl;
  return 0;
}</pre>
<p>This class <a id="_idIndexMarker029"/>hierarchy is unnecessarily complicated because it uses almost every C++ feature: inheritance, templates, and macros. While using inheritance with templates is a common practice, macros are seen as an anti-pattern nowadays. In this example, the <code>Derived</code> class adds very little additional functionality compared to the <code>Base</code> class, and it would be more straightforward to simply add the <code>getValue</code> method directly to the <code>Base</code> class. Using inheritance and templates can be useful in certain situations, but it’s important to use them appropriately and not overuse them. Macros can be particularly difficult to understand and maintain because they are expanded by the preprocessor before the code is compiled, so<a id="_idIndexMarker030"/> it can be hard to see what the actual code looks like. It’s generally better to use functions or template functions instead of macros whenever possible.</p>
<p>If the probability of extension is low, keeping its structure simple and close to basic needs is better. How do you decide what approach to take? Well, calm consideration and code review is the way to find out.</p>
<h2 id="_idParaDest-25"><a id="_idTextAnchor024"/>Usability</h2>
<p>Usability <a id="_idIndexMarker031"/>refers to the ease with which a piece of code can be used by others. Well-written code is easy to use, with clear and intuitive interfaces and documentation that make it easy for others to understand and use the code. By improving the usability of code, programmers can make their code more accessible and useful to others and can ensure that their code is widely adopted and used.</p>
<p>Overall, readability, efficiency, maintainability, and usability are all important factors to consider when writing code. By improving these factors, programmers can write better code that is easier to understand, maintain, and use.</p>
<h1 id="_idParaDest-26"><a id="_idTextAnchor025"/>Summary</h1>
<p>In this chapter, you learned about the concept of good and bad code. Good code is well written, efficient, and easy to understand and maintain. It follows coding standards and best practices and is less prone to errors. On the other hand, bad code is poorly written, inefficient, and difficult to understand and maintain.</p>
<p>The chapter also introduced the concept of technical debt, which refers to the accumulation of poor-quality code that needs to be refactored or rewritten. Technical debt can be costly and time-consuming to fix and can hinder the development of new features or functionality.</p>
<p>The importance of code standards was also emphasized in the chapter. Code standards are guidelines or rules that dictate how code should be written, formatted, and structured. Adhering to code standards helps to ensure that code is consistent, easy to understand, and maintainable. It also makes it easier for multiple developers to work on the same code base and helps to prevent errors and bugs.</p>
<p>Overall, the chapter emphasized the importance of writing good quality code and adhering to code standards in order to avoid technical debt and ensure the long-term success and maintainability of a software project.</p>
<p>In the next chapter, we will dive into the world of software design principles. Specifically, we will focus on the SOLID principles, a set of guidelines that aim to improve the design of software systems by making them more maintainable, flexible, and scalable. Each of the principles will be explained in detail in the next chapter, along with examples of how they can be applied to real-world software development scenarios.</p>
</div>
</body></html>