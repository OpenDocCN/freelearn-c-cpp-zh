<html><head></head><body>
<div id="_idContainer005">
<h1 class="chapter-number" id="_idParaDest-14"><a id="_idTextAnchor013"/><span class="koboSpan" id="kobo.1.1">1</span></h1>
<h1 id="_idParaDest-15"><a id="_idTextAnchor014"/><span class="koboSpan" id="kobo.2.1">Coding Standards in C++</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In this chapter, we will delve into the world of clean code and examine its crucial role in successful software projects. </span><span class="koboSpan" id="kobo.3.2">We will discuss the concept of technical debt and how poor-quality code can contribute to its accumulation. </span><span class="koboSpan" id="kobo.3.3">Additionally, we will explore the often undervalued practices of code </span><a id="_idIndexMarker000"/><span class="koboSpan" id="kobo.4.1">formatting and documentation, which </span><a id="_idIndexMarker001"/><span class="koboSpan" id="kobo.5.1">are crucial for maintaining a manageable and effective code base. </span><span class="koboSpan" id="kobo.5.2">Through this chapter, we will understand that clean code is not just nice to have but a necessity for </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">any project.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">We will discuss the importance of coding standards and introduce common conventions and best practices used in the C++ community. </span><span class="koboSpan" id="kobo.7.2">By the end of this chapter, you will better understand what clean code is, why it is essential, and why documenting code </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">is crucial.</span></span></p>
<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/><span class="koboSpan" id="kobo.9.1">The difference between good code and bad code</span></h1>
<p><span class="koboSpan" id="kobo.10.1">There is no </span><a id="_idIndexMarker002"/><span class="koboSpan" id="kobo.11.1">strict definition of good or clean code. </span><span class="koboSpan" id="kobo.11.2">Moreover, no automatic tool can measure the quality of code. </span><span class="koboSpan" id="kobo.11.3">There are linters, code checkers, and other analyzers that can help to make code better. </span><span class="koboSpan" id="kobo.11.4">These tools are very valuable and highly recommended, but not sufficient. </span><span class="koboSpan" id="kobo.11.5">Artificial Intelligence may take over and develop code for us, but in the end, its measurement of code quality will be based on our human ideas of </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">good code.</span></span></p>
<p><span class="koboSpan" id="kobo.13.1">Programming languages were initially developed to provide an interface between machines and developers; however, with the growth of software products’ complexity, it becomes clear that nowadays, it is mostly a way of communicating ideas and intentions between developers. </span><span class="koboSpan" id="kobo.13.2">It is a well-known fact that developers spend ten times more time reading the code than writing it. </span><span class="koboSpan" id="kobo.13.3">It means that to be efficient, we must do our best to make the reading easier. </span><span class="koboSpan" id="kobo.13.4">The most successful way to make this process efficient is to make the code predictable or, even better, boring. </span><span class="koboSpan" id="kobo.13.5">By boring, I mean code that the reader looks at and knows what to expect from it regarding functionality, performance, and side effects. </span><span class="koboSpan" id="kobo.13.6">The following example illustrates an interface for a class retrieving objects from </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">a database:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.15.1">
class Database {
public:
  template&lt;typename T&gt;
  std::optional&lt;T&gt; get(const Id&amp; id) const;
  template&lt;typename T&gt;
  std::optional&lt;T&gt; get(const std::string&amp; name) const;
};</span></pre>
<p><span class="koboSpan" id="kobo.16.1">It </span><a id="_idIndexMarker003"/><span class="koboSpan" id="kobo.17.1">supports two lookup modes, by </span><strong class="source-inline"><span class="koboSpan" id="kobo.18.1">id</span></strong><span class="koboSpan" id="kobo.19.1"> and by </span><strong class="source-inline"><span class="koboSpan" id="kobo.20.1">name</span></strong><span class="koboSpan" id="kobo.21.1">; it is not supposed to change the internal state of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.22.1">Database</span></strong><span class="koboSpan" id="kobo.23.1"> object because of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.24.1">const</span></strong><span class="koboSpan" id="kobo.25.1"> modifier; and it can only do read operations against the database instance. </span><span class="koboSpan" id="kobo.25.2">It is boring, but it meets basic expectations. </span><span class="koboSpan" id="kobo.25.3">Imagine how surprising it can be to find out during critical bug investigation that on each read operation, it does an update operation and sometimes a </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">delete operation?</span></span></p>
<p><span class="koboSpan" id="kobo.27.1">As readers can see, a few key factors can distinguish good code and bad code. </span><span class="koboSpan" id="kobo.27.2">Good code is typically well written, easy to read, and efficient. </span><span class="koboSpan" id="kobo.27.3">It follows the conventions and standards of the C++ language and is organized in a logical and consistent manner. </span><span class="koboSpan" id="kobo.27.4">Good code is also well documented, often with clear comments explaining the purpose and function of things that are not obvious from reading only </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">the code.</span></span></p>
<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/><span class="koboSpan" id="kobo.29.1">Why coding standards are important</span></h1>
<p><span class="koboSpan" id="kobo.30.1">Coding standards </span><a id="_idIndexMarker004"/><span class="koboSpan" id="kobo.31.1">are important for several reasons. </span><span class="koboSpan" id="kobo.31.2">First and foremost, they help to </span><a id="_idIndexMarker005"/><span class="koboSpan" id="kobo.32.1">minimize </span><em class="italic"><span class="koboSpan" id="kobo.33.1">technical debt</span></em><span class="koboSpan" id="kobo.34.1">. </span><span class="koboSpan" id="kobo.34.2">Technical debt, also </span><a id="_idIndexMarker006"/><span class="koboSpan" id="kobo.35.1">known as “code debt,” is a metaphor that describes the cost of maintaining and modifying code that is not well designed or well written. </span><span class="koboSpan" id="kobo.35.2">Just as financial debt incurs interest and requires ongoing payments, technical debt incurs additional costs in the form of the time and effort needed to maintain and modify poorly </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">designed code.</span></span></p>
<p><span class="koboSpan" id="kobo.37.1">Technical debt can accumulate in many ways, such as through hacky or quick-fix solutions to problems </span><a id="_idIndexMarker007"/><span class="koboSpan" id="kobo.38.1">or by ignoring best practices or coding standards. </span><span class="koboSpan" id="kobo.38.2">As technical debt accumulates, it can become increasingly difficult and time-consuming to modify and maintain the code, which can negatively impact the efficiency and effectiveness of a </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">development team.</span></span></p>
<p><span class="koboSpan" id="kobo.40.1">In order to</span><a id="_idIndexMarker008"/><span class="koboSpan" id="kobo.41.1"> manage technical debt carefully, it is essential to try to avoid accumulating too much of it, as it can become a significant burden on a development team. </span><span class="koboSpan" id="kobo.41.2">Strategies for managing technical debt include regularly refactoring code to improve its design and maintainability, following best practices and coding standards, and actively seeking out opportunities to improve the quality of the code. </span><span class="koboSpan" id="kobo.41.3">Overall, managing technical debt is an important aspect of good code design and development and can help to ensure that code is efficient, reliable, and easy to </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">work with.</span></span></p>
<p><span class="koboSpan" id="kobo.43.1">Coding standards help to ensure the quality and consistency of code. </span><span class="koboSpan" id="kobo.43.2">By establishing a set of guidelines and conventions for writing code, coding standards help to ensure that code is well written, easy to read, and easy to understand. </span><span class="koboSpan" id="kobo.43.3">This makes it easier for others to maintain and update the code and helps to prevent errors </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">and bugs.</span></span></p>
<p><span class="koboSpan" id="kobo.45.1">In addition, they help to improve the efficiency of code. </span><span class="koboSpan" id="kobo.45.2">By following established conventions and best practices, programmers can write code that is more efficient and performs better. </span><span class="koboSpan" id="kobo.45.3">This can save time and resources and help ensure that code is scalable and can handle large amounts of data </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">and traffic.</span></span></p>
<p><span class="koboSpan" id="kobo.47.1">Furthermore, coding standards promote collaboration and teamwork among programmers. </span><span class="koboSpan" id="kobo.47.2">By establishing a common set of guidelines and conventions, coding standards make it easier for teams of programmers to work together on a project. </span><span class="koboSpan" id="kobo.47.3">This allows better communication and coordination and helps to ensure that everyone is on the same page and working towards the </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">same goals.</span></span></p>
<p><span class="koboSpan" id="kobo.49.1">Coding standards often promote the interoperability and portability of code. </span><span class="koboSpan" id="kobo.49.2">By following a standardized set of conventions, code written by one programmer can be easily understood and used by another programmer. </span><span class="koboSpan" id="kobo.49.3">This allows code to be more easily integrated into larger projects and helps to ensure that it can be used on a variety of different platforms and </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">operating systems.</span></span></p>
<p><span class="koboSpan" id="kobo.51.1">The C++ programming language is probably one of the richest languages in terms of features. </span><span class="koboSpan" id="kobo.51.2">It started as </span><em class="italic"><span class="koboSpan" id="kobo.52.1">C with classes</span></em><span class="koboSpan" id="kobo.53.1">, providing object-oriented support with high performance and almost complete compatibility with C; later on, template metaprogramming was introduced, and Stepanov and Lee developed the Standard Template Library, nowadays known as the C++ Standard Library. </span><span class="koboSpan" id="kobo.53.2">Modern C++ (C++11 and newer versions) provides extensive support for multiple programming paradigms, including procedural, object-oriented, generic, and functional programming. </span><span class="koboSpan" id="kobo.53.3">It offers features such as lambda expressions, range-based </span><strong class="source-inline"><span class="koboSpan" id="kobo.54.1">for</span></strong><span class="koboSpan" id="kobo.55.1"> loops, smart pointers, and type inference that enable functional programming techniques. </span><span class="koboSpan" id="kobo.55.2">Additionally, C++ provides support for</span><a id="_idIndexMarker009"/><span class="koboSpan" id="kobo.56.1"> object-oriented programming concepts such as inheritance, encapsulation, and polymorphism. </span><span class="koboSpan" id="kobo.56.2">It also offers template metaprogramming, which enables generic programming and allows compile-time optimizations. </span><span class="koboSpan" id="kobo.56.3">Furthermore, C++ provides concurrency support with features such as threads, atomic types, and futures, making it easier to write concurrent and parallel code. </span><span class="koboSpan" id="kobo.56.4">This flexibility is key to the strength of the language but often leads to problems </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">with maintainability.</span></span></p>
<p><span class="koboSpan" id="kobo.58.1">A developer has to understand the concepts of the paradigms we’ve mentioned, how to use them together, and how they eventually affect the performance of the code. </span><span class="koboSpan" id="kobo.58.2">This is when coding standards can help to explain the complexity of the </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">code base.</span></span></p>
<p><span class="koboSpan" id="kobo.60.1">All these factors make coding guidelines the bare minimum that a modern C++ project should have to attain a </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">quality standard.</span></span></p>
<h2 id="_idParaDest-18"><a id="_idTextAnchor017"/><span class="koboSpan" id="kobo.62.1">Code convention</span></h2>
<p><span class="koboSpan" id="kobo.63.1">Contrary to </span><a id="_idIndexMarker010"/><span class="koboSpan" id="kobo.64.1">languages such as Python, Go, Java, and many others, C++ does not have a common </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">code convention.</span></span></p>
<p><span class="koboSpan" id="kobo.66.1">There are several popular coding conventions for the C++ programming language. </span><span class="koboSpan" id="kobo.66.2">Here are some common conventions that are </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">widely followed:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.68.1">Naming conventions</span></strong><span class="koboSpan" id="kobo.69.1">: Naming </span><a id="_idIndexMarker011"/><span class="koboSpan" id="kobo.70.1">conventions specify how to name variables, functions, classes, and other code elements in a descriptive manner. </span><span class="koboSpan" id="kobo.70.2">For example, variables may be named using lowercase letters, with words separated by underscores, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.71.1">total_cost</span></strong><span class="koboSpan" id="kobo.72.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">customer_name</span></strong><span class="koboSpan" id="kobo.74.1">. </span><span class="koboSpan" id="kobo.74.2">Class variables often have prefixes or suffixes to distinguish them from other variables, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.75.1">m_user_count</span></strong><span class="koboSpan" id="kobo.76.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">user_count_</span></strong><span class="koboSpan" id="kobo.78.1">. </span><span class="koboSpan" id="kobo.78.2">Functions may be named using </span><em class="italic"><span class="koboSpan" id="kobo.79.1">camelCase</span></em><span class="koboSpan" id="kobo.80.1">, with the first letter of each word (apart from the first word) capitalized, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">calculateTotalCost</span></strong><span class="koboSpan" id="kobo.82.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">getCustomerName</span></strong><span class="koboSpan" id="kobo.84.1">. </span><span class="koboSpan" id="kobo.84.2">Classes may be named using </span><em class="italic"><span class="koboSpan" id="kobo.85.1">PascalCase</span></em><span class="koboSpan" id="kobo.86.1">, with the first letter of each word capitalized, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">Customer</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.88.1">or </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">Invoice</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.91.1">Commenting</span></strong><span class="koboSpan" id="kobo.92.1">: Commenting conventions</span><a id="_idIndexMarker012"/><span class="koboSpan" id="kobo.93.1"> specify how to write and format comments in code. </span><span class="koboSpan" id="kobo.93.2">Comments are used to provide explanations and documentation for code and should be clear and concise. </span><span class="koboSpan" id="kobo.93.3">It is often recommended to use inline comments to explain specific lines of code, as well as block comments to provide an overview of a code block </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">or function.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.95.1">Formatting</span></strong><span class="koboSpan" id="kobo.96.1">: Formatting conventions</span><a id="_idIndexMarker013"/><span class="koboSpan" id="kobo.97.1"> specify how to format code for readability and consistency. </span><span class="koboSpan" id="kobo.97.2">This may include conventions for indentation, spacing, line breaks, and other elements of code layout. </span><span class="koboSpan" id="kobo.97.3">For example, it is common to indent code blocks, such as those inside a </span><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">for</span></strong><span class="koboSpan" id="kobo.99.1"> loop or </span><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">if</span></strong><span class="koboSpan" id="kobo.101.1"> statement, to visually indicate the structure of the code. </span><span class="koboSpan" id="kobo.101.2">Formatting policy often covers asterisk (</span><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">*</span></strong><span class="koboSpan" id="kobo.103.1">) and ampersand (</span><strong class="source-inline"><span class="koboSpan" id="kobo.104.1">&amp;</span></strong><span class="koboSpan" id="kobo.105.1">) alignment in pointers and references (e.g., </span><strong class="source-inline"><span class="koboSpan" id="kobo.106.1">int* ptr</span></strong><span class="koboSpan" id="kobo.107.1"> versus </span><strong class="source-inline"><span class="koboSpan" id="kobo.108.1">int *ptr</span></strong><span class="koboSpan" id="kobo.109.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">Socket &amp;socket</span></strong><span class="koboSpan" id="kobo.111.1"> versus </span><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">Socket&amp; socket</span></strong><span class="koboSpan" id="kobo.113.1">), curly braces position (same line, next line, or context dependent). </span><span class="koboSpan" id="kobo.113.2">This book covers aspects of automated formatting in </span><a href="B19606_13.xhtml#_idTextAnchor260"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.114.1">Chapter 13</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.115.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.116.1">Coding style:</span></strong><span class="koboSpan" id="kobo.117.1"> Coding style conventions </span><a id="_idIndexMarker014"/><span class="koboSpan" id="kobo.118.1">specify how to write and structure code for clarity and readability. </span><span class="koboSpan" id="kobo.118.2">This may include conventions for variable declarations, control flow, and other elements of code structure, such as how variables are passed to functions (by value, reference, or pointer) and the usage of specific language features, such as exceptions and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">goto</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.120.1"> operators.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.121.1">It is</span><a id="_idIndexMarker015"/><span class="koboSpan" id="kobo.122.1"> important to note that there may be variations in coding conventions between different organizations and teams. </span><span class="koboSpan" id="kobo.122.2">It is important to follow the conventions that your team or organization establishes or to define your own conventions if none </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">are specified.</span></span></p>
<p><span class="koboSpan" id="kobo.124.1">It can be tedious to develop a coding convention; some companies prefer to use an existing one and adapt it to their needs. </span><span class="koboSpan" id="kobo.124.2">In the C++ programming language, there are several popular code standards that are widely followed by developers. </span><span class="koboSpan" id="kobo.124.3">These standards aim to improve the readability, maintainability, and overall quality of </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">C++ code.</span></span></p>
<p><span class="koboSpan" id="kobo.126.1">One common code </span><a id="_idIndexMarker016"/><span class="koboSpan" id="kobo.127.1">standard for C++ is the C++ Core Guidelines (</span><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines"><span class="koboSpan" id="kobo.128.1">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines</span></a><span class="koboSpan" id="kobo.129.1">), which were developed by Bjarne Stroustrup, the creator of C++, and a group of experts from industry and academia. </span><span class="koboSpan" id="kobo.129.2">The guidelines cover a wide range of topics, including naming conventions, commenting, formatting, and </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">coding style.</span></span></p>
<p><span class="koboSpan" id="kobo.131.1">Another </span><a id="_idIndexMarker017"/><span class="koboSpan" id="kobo.132.1">popular code standard for C++ is the Google C++ Style Guide (</span><a href="https://google.github.io/styleguide/cppguide.html"><span class="koboSpan" id="kobo.133.1">https://google.github.io/styleguide/cppguide.html</span></a><span class="koboSpan" id="kobo.134.1">), which is used by many </span><a id="_idIndexMarker018"/><span class="koboSpan" id="kobo.135.1">software companies, including Google. </span><span class="koboSpan" id="kobo.135.2">The guide provides guidelines for naming conventions, commenting, formatting, and coding style, as well as recommendations for using specific C++ features </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">and libraries.</span></span></p>
<p><span class="koboSpan" id="kobo.137.1">In addition to these widely followed standards, there are also many other code standards that have been developed by individual organizations and teams, for example, LLVM Coding Standards, WebKit, and Mozilla’s </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">style guides.</span></span></p>
<p><span class="koboSpan" id="kobo.139.1">If a project conforms with a specific code convention, it is easier to read it, and as a bonus, the code base becomes more </span><em class="italic"><span class="koboSpan" id="kobo.140.1">grepable</span></em><span class="koboSpan" id="kobo.141.1">. </span><span class="koboSpan" id="kobo.141.2">Consider needing to find the places where a variable called </span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">request_id</span></strong><span class="koboSpan" id="kobo.143.1"> is assigned. </span><span class="koboSpan" id="kobo.143.2">It can be easily achieved via the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">grep</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.145.1"> utility:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.146.1">
$ grep -rn "request_id = " .
</span><span class="koboSpan" id="kobo.146.2">./RequestHandler.cpp:25: request_id = new_request_id;
./RequestHandler.cpp:122: request_id = request.getId();</span></pre>
<p><span class="koboSpan" id="kobo.147.1">Code reviewers used to spend hours catching and commenting on inconsistencies with code format during peer review. </span><span class="koboSpan" id="kobo.147.2">Luckily, today we have tools such as Clang-Tidy and Clang-Format that allow us to ensure the consistency of the code format automatically via code editors</span><a id="_idIndexMarker019"/><span class="koboSpan" id="kobo.148.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.149.1">continuous integration</span></strong><span class="koboSpan" id="kobo.150.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.151.1">CI</span></strong><span class="koboSpan" id="kobo.152.1">). </span><span class="koboSpan" id="kobo.152.2">We will dive deeper into their configuration later in this book in </span><a href="B19606_10.xhtml#_idTextAnchor184"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.153.1">Chapter 10</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.154.1">.</span></span></p>
<h2 id="_idParaDest-19"><a id="_idTextAnchor018"/><span class="koboSpan" id="kobo.155.1">Language features limitations</span></h2>
<p><span class="koboSpan" id="kobo.156.1">C++ is a powerful </span><a id="_idIndexMarker020"/><span class="koboSpan" id="kobo.157.1">language; as we know, great power comes with great responsibility. </span><span class="koboSpan" id="kobo.157.2">It is not easy for engineers, especially those who have not spent decades writing C++ code, to grasp the complexity of the language. </span><span class="koboSpan" id="kobo.157.3">As a result, some companies decide to limit the features used in their projects. </span><span class="koboSpan" id="kobo.157.4">The</span><a id="_idIndexMarker021"/><span class="koboSpan" id="kobo.158.1"> limitations may include a ban for multiple inheritance, usage of exceptions, and minimal usage of macros, templates, and specific third-party libraries. </span><span class="koboSpan" id="kobo.158.2">Additionally, the regulations may come from the use of legacy libraries. </span><span class="koboSpan" id="kobo.158.3">For example, if most of the code does not support C++ exceptions, it might be a bad idea to add them to new pieces of code without a prior understanding of </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">the outcome.</span></span></p>
<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/><span class="koboSpan" id="kobo.160.1">General guidelines</span></h2>
<p><span class="koboSpan" id="kobo.161.1">It is always</span><a id="_idIndexMarker022"/><span class="koboSpan" id="kobo.162.1"> a good idea to have general guidelines for a project. </span><span class="koboSpan" id="kobo.162.2">The guidelines often cover the preferred way of working on </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">the project:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.164.1">Usage of raw pointers, </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">if allowed</span></span></li>
<li><span class="koboSpan" id="kobo.166.1">How values are returned from getters and provided to setters (by value </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">or reference)</span></span></li>
<li><span class="koboSpan" id="kobo.168.1">Use of </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">code comments:</span></span><ul><li><span class="koboSpan" id="kobo.170.1">Are comments allowed </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">in general?</span></span></li><li><span class="koboSpan" id="kobo.172.1">Usage of strategic and </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">tactical comments</span></span></li><li><span class="koboSpan" id="kobo.174.1">Comment style: free, Doxygen, and </span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">so on</span></span></li></ul></li>
</ul>
<p><span class="koboSpan" id="kobo.176.1">Coding standards are necessary to help ensure code quality, consistency, interoperability, portability, efficiency, and collaboration. </span><span class="koboSpan" id="kobo.176.2">By following coding standards, programmers can write better code that is easier to understand, maintain, and use and works better and </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">more efficiently.</span></span></p>
<h1 id="_idParaDest-21"><a id="_idTextAnchor020"/><span class="koboSpan" id="kobo.178.1">Readability, efficiency, maintainability, and usability</span></h1>
<p><span class="koboSpan" id="kobo.179.1">Readability, efficiency, maintainability, and usability are all critical factors to consider when </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">writing code.</span></span></p>
<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/><span class="koboSpan" id="kobo.181.1">Readability</span></h2>
<p><span class="koboSpan" id="kobo.182.1">Readability </span><a id="_idIndexMarker023"/><span class="koboSpan" id="kobo.183.1">refers to the ease with which a human reader can understand a piece of code. </span><span class="koboSpan" id="kobo.183.2">Well-written code is easy to read, with clear and concise statements that are organized in a logical and consistent manner. </span><span class="koboSpan" id="kobo.183.3">This becomes very important if we consider that developers spend ten times more time reading code than </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">writing it.</span></span></p>
<p><span class="koboSpan" id="kobo.185.1">Let’s take a look at the following piece </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">of code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.187.1">
class Employee {
public:
  std::string get_name();
  std::string surname();
  uint64_t getId() const;
};</span></pre>
<p><span class="koboSpan" id="kobo.188.1">This example is an exaggerated example of code not following any code convention. </span><span class="koboSpan" id="kobo.188.2">A developer using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">Employee</span></strong><span class="koboSpan" id="kobo.190.1"> class can understand that all three methods are getters. </span><span class="koboSpan" id="kobo.190.2">However, the differences in the names make the user spend more time understanding the code or trying to understand the reasoning behind the names. </span><span class="koboSpan" id="kobo.190.3">Do the methods have different names because programmers did not care about the uniformity of the class? </span><span class="koboSpan" id="kobo.190.4">Or because, for example, methods without the </span><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">get</span></strong><span class="koboSpan" id="kobo.192.1"> prefix are simple getters, and ones that contain the </span><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">get</span></strong><span class="koboSpan" id="kobo.194.1"> prefix fetch the data from a file or </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">a database?</span></span></p>
<p><span class="koboSpan" id="kobo.196.1">Additionally, do the methods without </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">const</span></strong><span class="koboSpan" id="kobo.198.1"> change the object’s state (via caching, for example), or is it a mistake? </span><span class="koboSpan" id="kobo.198.2">Do you see how many questions can be raised? </span><span class="koboSpan" id="kobo.198.3">They can be answered only when a developer jumps into the corresponding implementation, which means time is wasted. </span><span class="koboSpan" id="kobo.198.4">Making the code look uniform across the code base helps developers to understand the meanings and complications of classes, methods, and functions by looking at their declarations in the header files or even via autocompletion in modern </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">code editors.</span></span></p>
<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/><span class="koboSpan" id="kobo.200.1">Efficiency</span></h2>
<p><span class="koboSpan" id="kobo.201.1">Efficiency refers </span><a id="_idIndexMarker024"/><span class="koboSpan" id="kobo.202.1">to the ability of a piece of code to perform its intended tasks in an efficient manner. </span><span class="koboSpan" id="kobo.202.2">Efficient code uses few resources, such as time and memory, to accomplish a task, and is able to handle large amounts of data and traffic without slowing down or crashing. </span><span class="koboSpan" id="kobo.202.3">By improving the efficiency of code, programmers can save time and resources and can ensure that their code is scalable and can handle the demands of a growing </span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">user base.</span></span></p>
<p><span class="koboSpan" id="kobo.204.1">There are</span><a id="_idIndexMarker025"/><span class="koboSpan" id="kobo.205.1"> surefire ways to optimize C++ code, such as passing read-only parameters by constant reference to avoid unnecessary copying, or using the character-overloaded version of </span><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">std::string::find</span></strong><span class="koboSpan" id="kobo.207.1"> when looking for a single character to avoid string </span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">a creation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.209.1">
my_string.find('A');
my_string.find("A");</span></pre>
<p><span class="koboSpan" id="kobo.210.1">However, the more systematic way to achieve and maintain code efficiency is to follow the Pareto principle. </span><span class="koboSpan" id="kobo.210.2">This principle, when applied to software engineering, says that roughly 20% of the code does 80% of the work. </span><span class="koboSpan" id="kobo.210.3">For example, usually, there is no need to optimize the code parsing config files on startup of a background daemon because it happens only once during the program’s lifetime. </span><span class="koboSpan" id="kobo.210.4">However, it might be important to avoid copying large data structures in the main flow. </span><span class="koboSpan" id="kobo.210.5">The optimal way to improve the efficiency includes picking this 20% of performance-critical code and adding benchmarks for it. </span><span class="koboSpan" id="kobo.210.6">The benchmarks are expected to run as part of the CI process to make sure that no degradation </span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">is introduced.</span></span></p>
<p><span class="koboSpan" id="kobo.212.1">Additionally, end-to-end testing can measure the overall performance of the application. </span><span class="koboSpan" id="kobo.212.2">This book discusses the best practices of writing unit tests and end-to-end tests in </span><a href="B19606_13.xhtml#_idTextAnchor260"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.213.1">Chapter 13</span></em></span></a><span class="koboSpan" id="kobo.214.1">. </span><span class="koboSpan" id="kobo.214.2">It is important to note that the automated tools cannot replace an engineer doing code reviews for the new code, mainly because there is no tool that can find the 20% of the code that does 80% of </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">the work.</span></span></p>
<h2 id="_idParaDest-24"><a id="_idTextAnchor023"/><span class="koboSpan" id="kobo.216.1">Maintainability</span></h2>
<p><span class="koboSpan" id="kobo.217.1">Maintainability </span><a id="_idIndexMarker026"/><span class="koboSpan" id="kobo.218.1">refers to the ease with which a piece of code can be updated and modified over time. </span><span class="koboSpan" id="kobo.218.2">Well-written code is easy to maintain, with clear and well-documented code that is organized in a logical and consistent manner. </span><span class="koboSpan" id="kobo.218.3">By improving the maintainability of code, programmers can make it easier for others to update and modify their code and can ensure that their code remains relevant and useful over time. </span><span class="koboSpan" id="kobo.218.4">Ideally, while developing new components, developers should think about the current problems the code is solving and the future usage and extension of the code. </span><span class="koboSpan" id="kobo.218.5">For example, while developing support for a data provider, it might be useful to ask whether the provider is going to be the only one supported. </span><span class="koboSpan" id="kobo.218.6">If not, it might be helpful to think about the standard features of data providers and extract them in an abstract </span><a id="_idIndexMarker027"/><span class="koboSpan" id="kobo.219.1">base class. </span><span class="koboSpan" id="kobo.219.2">Here’s </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">an example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.221.1">
class BaseDataProvider {
public:
  BaseDataProvider() = default;
  BaseDataProvider(const BaseDataProvider&amp;) = delete;
  BaseDataProvider(BaseDataProvider&amp;&amp;) = default;
  BaseDataProvider&amp; operator = (const BaseDataProvider&amp;) =
    delete;
  BaseDataProvider&amp; operator = (BaseDataProvider&amp;&amp;) =
    default;
  virtual ~BaseDataProvider() = default;
  virtual Data getData() const = 0;
};
class NetworkDataProvider : public BaseDataProvider {
public:
  NetworkDataProvider(const Endpoint&amp; endpoint);
  Data getData() const override;
};
class FileDataProvider : public BaseDataProvider {
public:
  FileDataProvider(const std::string&amp; filename);
  Data getData() const override;
};</span></pre>
<p><span class="koboSpan" id="kobo.222.1">In this</span><a id="_idIndexMarker028"/><span class="koboSpan" id="kobo.223.1"> example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">DataProvider</span></strong><span class="koboSpan" id="kobo.225.1"> class is an abstract base class that defines the interface for providing data. </span><span class="koboSpan" id="kobo.225.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">NetworkDataProvider</span></strong><span class="koboSpan" id="kobo.227.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">FileDataProvider</span></strong><span class="koboSpan" id="kobo.229.1"> classes are derived from </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">DataProvider</span></strong><span class="koboSpan" id="kobo.231.1"> and override the </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">getData</span></strong><span class="koboSpan" id="kobo.233.1"> virtual function to provide the specific implementation for reading data from a file or a network endpoint, respectively. </span><span class="koboSpan" id="kobo.233.2">This design makes it easy to add new data sources by simply creating a new class derived from </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">DataProvider</span></strong><span class="koboSpan" id="kobo.235.1"> and providing the appropriate implementation for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">getData</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.237.1">virtual function.</span></span></p>
<p><span class="koboSpan" id="kobo.238.1">It is clear from the example that the base interface may include not only the functionality but also the copy-move policy of the object. </span><span class="koboSpan" id="kobo.238.2">Later, the user code can receive the data provider(s) with reference to the base class and be agnostic to the type of provider, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">following snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.240.1">
class DataParser {
public:
  DataParser(const BaseDataProvider&amp; provider);
  void parse();
};</span></pre>
<p><span class="koboSpan" id="kobo.241.1">Additionally, this inheritance can be used for mocking data providers while creating unit tests for </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">DataParser</span></strong><span class="koboSpan" id="kobo.243.1">. </span><span class="koboSpan" id="kobo.243.2">Unit tests are covered in detail in </span><a href="B19606_13.xhtml#_idTextAnchor260"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.244.1">Chapter 13</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.245.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.246.1">On a side note, it is crucial not to make code overcomplicated, or to be ready for any change. </span><span class="koboSpan" id="kobo.246.2">Otherwise, the need to make everything extendable may lead to monsters such as the </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">following snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.248.1">
#define BASE_CLASS(TYPE)                 \
  template &lt;typename T&gt;                  \
  class TYPE {                           \
  public:                                \
    T value;                             \
    TYPE(T val) : value(val) {}          \
  };
#define DERIVED_CLASS(TYPE, BASE)        \
  template &lt;typename T&gt;                  \
  class TYPE : public BASE&lt;T&gt; {          \
  public:                                \
    TYPE(T val) : BASE&lt;T&gt;(val) {}        \
    T getValue() { return value; } \
  };
BASE_CLASS(Base);
DERIVED_CLASS(Derived, Base);
int main() {
  Derived&lt;int&gt; obj(5);
  std::cout &lt;&lt; obj.getValue() &lt;&lt; std::endl;
  return 0;
}</span></pre>
<p><span class="koboSpan" id="kobo.249.1">This class </span><a id="_idIndexMarker029"/><span class="koboSpan" id="kobo.250.1">hierarchy is unnecessarily complicated because it uses almost every C++ feature: inheritance, templates, and macros. </span><span class="koboSpan" id="kobo.250.2">While using inheritance with templates is a common practice, macros are seen as an anti-pattern nowadays. </span><span class="koboSpan" id="kobo.250.3">In this example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">Derived</span></strong><span class="koboSpan" id="kobo.252.1"> class adds very little additional functionality compared to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">Base</span></strong><span class="koboSpan" id="kobo.254.1"> class, and it would be more straightforward to simply add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">getValue</span></strong><span class="koboSpan" id="kobo.256.1"> method directly to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">Base</span></strong><span class="koboSpan" id="kobo.258.1"> class. </span><span class="koboSpan" id="kobo.258.2">Using inheritance and templates can be useful in certain situations, but it’s important to use them appropriately and not overuse them. </span><span class="koboSpan" id="kobo.258.3">Macros can be particularly difficult to understand and maintain because they are expanded by the preprocessor before the code is compiled, so</span><a id="_idIndexMarker030"/><span class="koboSpan" id="kobo.259.1"> it can be hard to see what the actual code looks like. </span><span class="koboSpan" id="kobo.259.2">It’s generally better to use functions or template functions instead of macros </span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">whenever possible.</span></span></p>
<p><span class="koboSpan" id="kobo.261.1">If the probability of extension is low, keeping its structure simple and close to basic needs is better. </span><span class="koboSpan" id="kobo.261.2">How do you decide what approach to take? </span><span class="koboSpan" id="kobo.261.3">Well, calm consideration and code review is the way to </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">find out.</span></span></p>
<h2 id="_idParaDest-25"><a id="_idTextAnchor024"/><span class="koboSpan" id="kobo.263.1">Usability</span></h2>
<p><span class="koboSpan" id="kobo.264.1">Usability </span><a id="_idIndexMarker031"/><span class="koboSpan" id="kobo.265.1">refers to the ease with which a piece of code can be used by others. </span><span class="koboSpan" id="kobo.265.2">Well-written code is easy to use, with clear and intuitive interfaces and documentation that make it easy for others to understand and use the code. </span><span class="koboSpan" id="kobo.265.3">By improving the usability of code, programmers can make their code more accessible and useful to others and can ensure that their code is widely adopted </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">and used.</span></span></p>
<p><span class="koboSpan" id="kobo.267.1">Overall, readability, efficiency, maintainability, and usability are all important factors to consider when writing code. </span><span class="koboSpan" id="kobo.267.2">By improving these factors, programmers can write better code that is easier to understand, maintain, </span><span class="No-Break"><span class="koboSpan" id="kobo.268.1">and use.</span></span></p>
<h1 id="_idParaDest-26"><a id="_idTextAnchor025"/><span class="koboSpan" id="kobo.269.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.270.1">In this chapter, you learned about the concept of good and bad code. </span><span class="koboSpan" id="kobo.270.2">Good code is well written, efficient, and easy to understand and maintain. </span><span class="koboSpan" id="kobo.270.3">It follows coding standards and best practices and is less prone to errors. </span><span class="koboSpan" id="kobo.270.4">On the other hand, bad code is poorly written, inefficient, and difficult to understand </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">and maintain.</span></span></p>
<p><span class="koboSpan" id="kobo.272.1">The chapter also introduced the concept of technical debt, which refers to the accumulation of poor-quality code that needs to be refactored or rewritten. </span><span class="koboSpan" id="kobo.272.2">Technical debt can be costly and time-consuming to fix and can hinder the development of new features </span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">or functionality.</span></span></p>
<p><span class="koboSpan" id="kobo.274.1">The importance of code standards was also emphasized in the chapter. </span><span class="koboSpan" id="kobo.274.2">Code standards are guidelines or rules that dictate how code should be written, formatted, and structured. </span><span class="koboSpan" id="kobo.274.3">Adhering to code standards helps to ensure that code is consistent, easy to understand, and maintainable. </span><span class="koboSpan" id="kobo.274.4">It also makes it easier for multiple developers to work on the same code base and helps to prevent errors </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">and bugs.</span></span></p>
<p><span class="koboSpan" id="kobo.276.1">Overall, the chapter emphasized the importance of writing good quality code and adhering to code standards in order to avoid technical debt and ensure the long-term success and maintainability of a </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">software project.</span></span></p>
<p><span class="koboSpan" id="kobo.278.1">In the next chapter, we will dive into the world of software design principles. </span><span class="koboSpan" id="kobo.278.2">Specifically, we will focus on the SOLID principles, a set of guidelines that aim to improve the design of software systems by making them more maintainable, flexible, and scalable. </span><span class="koboSpan" id="kobo.278.3">Each of the principles will be explained in detail in the next chapter, along with examples of how they can be applied to real-world software </span><span class="No-Break"><span class="koboSpan" id="kobo.279.1">development scenarios.</span></span></p>
</div>
</body></html>