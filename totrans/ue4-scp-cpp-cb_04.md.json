["```cpp\n// MyFirstActor.h\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyFirstActor.generated.h\"\n\nUCLASS()\nclass CHAPTER_04_API AMyFirstActor : public AActor\n{\n  GENERATED_BODY()\n\npublic: \n  // Sets default values for this actor's properties\n  AMyFirstActor();\n\nprotected:\n  // Called when the game starts or when spawned\n  virtual void BeginPlay() override;\n\npublic: \n  // Called every frame\n  virtual void Tick(float DeltaTime) override;\n\n};\n\n// MyFirstActor.cpp\n\n#include \"MyFirstActor.h\"\n\n// Sets default values\nAMyFirstActor::AMyFirstActor()\n{\n   // Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it.\n  PrimaryActorTick.bCanEverTick = true;\n\n}\n\n// Called when the game starts or when spawned\nvoid AMyFirstActor::BeginPlay()\n{\n  Super::BeginPlay();\n\n}\n\n// Called every frame\nvoid AMyFirstActor::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n\n}\n```", "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/GameModeBase.h\"\n#include \"UECookbookGameModeBase.generated.h\"\n\n/**\n * \n */\nUCLASS()\nclass CHAPTER_04_API AUECookbookGameModeBase : public AGameModeBase\n{\n  GENERATED_BODY()\n\npublic:\n virtual void BeginPlay() override; \n};\n```", "```cpp\n#include \"UECookbookGameModeBase.h\"\n#include \"MyFirstActor.h\" // AMyFirstActor\n\nvoid AUECookbookGameModeBase::BeginPlay()\n{\n  // Call the parent class version of this function\n  Super::BeginPlay();\n\n  // Displays a red message on the screen for 10 seconds\n  GEngine->AddOnScreenDebugMessage(-1, 10, FColor::Red, \n                                   TEXT(\"Actor Spawning\")); \n\n  // Spawn an instance of the AMyFirstActor class at the\n  //default location.\n  FTransform SpawnLocation;\n  GetWorld()->SpawnActor<AMyFirstActor>\n                             (AMyFirstActor::StaticClass(), \n                              SpawnLocation);\n}\n```", "```cpp\n//Warrior.h\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Warrior.generated.h\"\n\nUCLASS()\nclass CHAPTER_04_API AWarrior : public AActor\n{\n  GENERATED_BODY()\n\npublic: \n  // Sets default values for this actor's properties\n  AWarrior();\n\n // Name of the Actor\n UPROPERTY(EditAnywhere, BlueprintReadWrite, \n Category = Properties) \n FString Name; \n\n // Returns message containing the Name property\n UFUNCTION(BlueprintCallable, Category = Properties) \n FString ToString(); \n\nprotected:\n  // Called when the game starts or when spawned\n  virtual void BeginPlay() override;\n\npublic: \n  // Called every frame\n  virtual void Tick(float DeltaTime) override;\n\n};\n\n// Warrior.cpp\n\n#include \"Warrior.h\"\n\n// Sets default values\nAWarrior::AWarrior()\n{\n   // Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it.\n  PrimaryActorTick.bCanEverTick = true;\n\n}\n\n// Called when the game starts or when spawned\nvoid AWarrior::BeginPlay()\n{\n  Super::BeginPlay();\n\n}\n\n// Called every frame\nvoid AWarrior::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n\n}\n\nFString AWarrior::ToString() \n{ \n return FString::Printf(TEXT(\"An instance of AWarrior: %s\"), *Name); \n} \n```", "```cpp\nUCLASS()\nclass CHAPTER_04_API AUECookbookGameModeBase : public AGameModeBase\n{\n  GENERATED_BODY()\n\npublic:\n  virtual void BeginPlay() override; \n\n UPROPERTY() \n AMyFirstActor* SpawnedActor; \n\n UFUNCTION() \n void DestroyActorFunction(); \n};\n```", "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/GameModeBase.h\"\n#include \"MyFirstActor.h\"\n#include \"UECookbookGameModeBase.generated.h\"\n```", "```cpp\n#include \"UECookbookGameModeBase.h\"\n#include \"MyFirstActor.h\" // AMyFirstActor\n\nvoid AUECookbookGameModeBase::BeginPlay()\n{\n  // Call the parent class version of this function\n  Super::BeginPlay();\n\n  // Displays a red message on the screen for 10 seconds\n  GEngine->AddOnScreenDebugMessage(-1, 10, FColor::Red, \n                   TEXT(\"Actor Spawning\")); \n\n  // Spawn an instance of the AMyFirstActor class at the\n  // default location.\n  FTransform SpawnLocation;\n SpawnedActor = GetWorld()->SpawnActor<AMyFirstActor>( \n                             AMyFirstActor::StaticClass(), \n                             SpawnLocation);\n}\n```", "```cpp\nFTimerHandle Timer; \nGetWorldTimerManager().SetTimer(Timer, this, \n                   &AUECookbookGameModeBase::DestroyActorFunction, 10);\n```", "```cpp\nvoid AUECookbookGameModeBase::DestroyActorFunction() \n{ \n  if (SpawnedActor != nullptr) \n  { \n    // Displays a red message on the screen for 10 seconds\n    GEngine->AddOnScreenDebugMessage(-1, 10, FColor::Red, \n                                     TEXT(\"Actor Destroyed\")); \n    SpawnedActor->Destroy(); \n  } \n} \n```", "```cpp\nUPROPERTY() \nAMyFirstActor* SpawnedActor; \nUFUNCTION() \nvoid DestroyActorFunction(); \n```", "```cpp\nSpawnedActor = GetWorld()->SpawnActor<AMyFirstActor> \n (AMyFirstActor::StaticClass(), SpawnLocation);\n```", "```cpp\nFTimerHandle Timer; \nGetWorldTimerManager().SetTimer(Timer, this, \n &AUE4CookbookGameMode::DestroyActorFunction, 10);\n```", "```cpp\nvoid AUE4CookbookGameMode::DestroyActorFunction() \n{ \n  if (SpawnedActor != nullptr) \n  {\n     // Then we know that SpawnedActor is valid\n  }\n} \n```", "```cpp\nSpawnedActor->Destroy();\n```", "```cpp\n// Called when the game starts or when spawned\nvoid AWarrior::BeginPlay()\n{\n  Super::BeginPlay();\n\n // Will destroy this object in 10 seconds\n SetLifeSpan(10); \n\n}\n```", "```cpp\nUPROPERTY() \nUStaticMeshComponent* Mesh; \n```", "```cpp\n// Sets default values\nAMyFirstActor::AMyFirstActor()\n{\n   // Set this actor to call Tick() every frame. You can turn\n   // this off to improve performance if you don't need it.\n  PrimaryActorTick.bCanEverTick = true;\n\n  // Creates a StaticMeshComponent on this object and assigns\n  // Mesh to it\n  Mesh = CreateDefaultSubobject<UStaticMeshComponent>\n         (\"BaseMeshComponent\");\n}\n```", "```cpp\nUPROPERTY() \nUStaticMeshComponent* Mesh; \n```", "```cpp\n// Sets default values\nAMyFirstActor::AMyFirstActor()\n{\n   // Set this actor to call Tick() every frame. You can turn this off \n  // to improve performance if you don't need it.\n  PrimaryActorTick.bCanEverTick = true;\n\n  // Creates a StaticMeshComponent on this object and assigns Mesh \n  // to it\n  Mesh = CreateDefaultSubobject<UStaticMeshComponent>\n       (\"BaseMeshComponent\");\n\n auto MeshAsset = ConstructorHelpers::FObjectFinder<UStaticMesh>\n                   (TEXT(\"StaticMesh'/Engine/BasicShapes/Cube.Cube'\"));  // Check if the MeshAsset is valid before setting it\n if (MeshAsset.Object != nullptr)\n {\n Mesh->SetStaticMesh(MeshAsset.Object); \n }\n\n} \n```", "```cpp\nConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset = \n ConstructorHelpers::FObjectFinder<UStaticMesh>(TEXT(\"Static\n Mesh'/Engine/BasicShapes/Cube.Cube'\"));\n```", "```cpp\nUCLASS()\nclass CHAPTER_04_API AMyGameStateBase : public AGameStateBase\n{\n    GENERATED_BODY()\n\npublic:\n // Constructor to initialize CurrentScore\n AMyGameStateBase(); \n\n // Will set the CurrentScore variable\n UFUNCTION() \n void SetScore(int32 NewScore); \n\n // Getter\n UFUNCTION() \n int32 GetScore(); \n\nprivate: \n UPROPERTY() \n int32 CurrentScore; \n\n};\n```", "```cpp\n#include \"MyGameStateBase.h\"\n\nAMyGameStateBase::AMyGameStateBase()\n{\n CurrentScore = 0;\n}\n\nint32 AMyGameStateBase::GetScore()\n{\n return CurrentScore;\n}\n\nvoid AMyGameStateBase::SetScore(int32 NewScore)\n{\n CurrentScore = NewScore;\n}\n```", "```cpp\n//MyGameStateBase.h \n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/GameStateBase.h\"\n#include \"MyGameStateBase.generated.h\"\n\n/**\n * \n */\nUCLASS()\nclass CHAPTER_04_API AMyGameStateBase : public AGameStateBase\n{\n    GENERATED_BODY()\n\npublic:\n    // Constructor to initialize CurrentScore\n    AMyGameStateBase(); \n\n    // Will set the CurrentScore variable\n    UFUNCTION() \n    void SetScore(int32 NewScore); \n\n    // Getter\n    UFUNCTION() \n    int32 GetScore(); \n\nprivate: \n    UPROPERTY() \n    int32 CurrentScore; \n\n};\n\n//MyGameState.cpp \n#include \"MyGameStateBase.h\"\n\nAMyGameStateBase::AMyGameStateBase()\n{\n  CurrentScore = 0;\n}\n\nint32 AMyGameStateBase::GetScore()\n{\n  return CurrentScore;\n}\n\nvoid AMyGameStateBase::SetScore(int32 NewScore)\n{\n  CurrentScore = NewScore;\n}\n\n```", "```cpp\nAMyGameState(); \n```", "```cpp\nAMyGameState::AMyGameState() \n{ \n  CurrentScore = 0; \n} \n```", "```cpp\nUPROPERTY() \nint32 CurrentScore; \n```", "```cpp\nUCLASS()\nclass CHAPTER_04_API AHierarchyActor : public AActor\n{\n    GENERATED_BODY()\n\npublic: \n    // Sets default values for this actor's properties\n    AHierarchyActor();\n\n UPROPERTY(VisibleAnywhere) \n USceneComponent* Root; \n\n UPROPERTY(VisibleAnywhere) \n USceneComponent* ChildSceneComponent; \n\n UPROPERTY(VisibleAnywhere) \n UStaticMeshComponent* BoxOne; \n\n UPROPERTY(VisibleAnywhere) \n UStaticMeshComponent* BoxTwo; \n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic: \n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\n};\n```", "```cpp\n// Sets default values\nAHierarchyActor::AHierarchyActor()\n{\n    // Set this actor to call Tick() every frame. You can turn this\n    // off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = true;\n\n // Create four subobjects\n Root = CreateDefaultSubobject<USceneComponent>(\"Root\"); \n ChildSceneComponent = CreateDefaultSubobject<USceneComponent>\n                          (\"ChildSceneComponent\"); \n BoxOne = CreateDefaultSubobject<UStaticMeshComponent>(\"BoxOne\"); \n BoxTwo = CreateDefaultSubobject<UStaticMeshComponent>(\"BoxTwo\");\n\n // Get a reference to the cube mesh\n auto MeshAsset = ConstructorHelpers::FObjectFinder<UStaticMesh>\n                   (TEXT(\"StaticMesh'/Engine/BasicShapes/Cube.Cube'\"));\n\n // Give both boxes a mesh\n if (MeshAsset.Object != nullptr)\n {\n BoxOne->SetStaticMesh(MeshAsset.Object);\n BoxTwo->SetStaticMesh(MeshAsset.Object);\n }\n\n RootComponent = Root;\n\n // Set up the object's hierarchy\n BoxOne->AttachTo(Root);\n BoxTwo->AttachTo(ChildSceneComponent);\n\n ChildSceneComponent->AttachTo(Root);\n\n // Offset and scale the child from the root\n ChildSceneComponent->SetRelativeTransform(\n FTransform(FRotator(0, 0, 0), \n FVector(250, 0, 0), \n FVector(0.1f))\n );\n\n}\n```", "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"RandomMovementComponent.generated.h\"\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass CHAPTER_04_API URandomMovementComponent : public UActorComponent\n{\n    GENERATED_BODY()\n\npublic: \n    // Sets default values for this component's properties\n    URandomMovementComponent();\n\n UPROPERTY()\n float MovementRadius;\n\nprotected:\n    // Called when the game starts\n    virtual void BeginPlay() override;\n\npublic: \n    // Called every frame\n    virtual void TickComponent(float DeltaTime, ELevelTick \n    TickType, FActorComponentTickFunction* ThisTickFunction) \n    override;\n\n};\n\n```", "```cpp\n// Sets default values for this component's properties\nURandomMovementComponent::URandomMovementComponent()\n{\n    // Set this component to be initialized when the game\n    // starts, and to be ticked every frame. You can turn\n    // these features\n    // off to improve performance if you don't need them.\n    PrimaryComponentTick.bCanEverTick = true;\n\n    // ...\n    MovementRadius = 5;\n}\n```", "```cpp\n// Called every frame\nvoid URandomMovementComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n    Super::TickComponent(DeltaTime, TickType,\n    ThisTickFunction);\n\n    // ...\n AActor* Parent = GetOwner(); \n\n if (Parent) \n { \n // Find a new position for the object to go to\n auto NewPos = Parent->GetActorLocation() + \n FVector\n ( \n FMath::FRandRange(-1, 1) * \n                      MovementRadius, \n FMath::FRandRange(-1, 1) *\n                      MovementRadius, \n FMath::FRandRange(-1, 1) *\n                      MovementRadius\n );\n // Update the object's position\n Parent->SetActorLocation( NewPos ); \n } \n}\n```", "```cpp\nUCLASS( ClassGroup=(Custom), \n meta=(BlueprintSpawnableComponent) )\n```", "```cpp\nUPROPERTY() \nfloat MovementRadius; \n```", "```cpp\nMovementRadius = 5; \n```", "```cpp\n    AActor* Parent = GetOwner(); \n\n    if (Parent) \n    { \n        // Find a new position for the object to go to\n        auto NewPos = Parent->GetActorLocation() + \n                      FVector\n                      ( \n                      FMath::FRandRange(-1, 1) * MovementRadius, \n                      FMath::FRandRange(-1, 1) * MovementRadius, \n                      FMath::FRandRange(-1, 1) * MovementRadius\n                      );\n        // Update the object's position\n        Parent->SetActorLocation( NewPos ); \n    } \n```", "```cpp\n#include \"CoreMinimal.h\"\n#include \"Components/SceneComponent.h\"\n#include \"ActorSpawnerComponent.generated.h\"\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass CHAPTER_04_API UActorSpawnerComponent : public USceneComponent\n{\n  GENERATED_BODY()\n\npublic: \n  // Sets default values for this component's properties\n  UActorSpawnerComponent();\n\n // Will spawn actor when called\n UFUNCTION(BlueprintCallable, Category=Cookbook)\n void Spawn();\n\n UPROPERTY(EditAnywhere)\n TSubclassOf<AActor> ActorToSpawn;\n\nprotected:\n  // Called when the game starts\n  virtual void BeginPlay() override;\n\npublic: \n  // Called every frame\n  virtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n};\n```", "```cpp\nvoid UActorSpawnerComponent::Spawn()\n{\n    UWorld* TheWorld = GetWorld();\n    if (TheWorld != nullptr)\n    {\n        FTransform ComponentTransform(this->GetComponentTransform());\n        TheWorld->SpawnActor(ActorToSpawn,&ComponentTransform);\n    }\n}\n```", "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"InventoryComponent.generated.h\"\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass CHAPTER_04_API UInventoryComponent : public UActorComponent\n{\n    GENERATED_BODY()\n\npublic: \n    // Sets default values for this component's properties\n    UInventoryComponent();\n\n UPROPERTY()\n TArray<AInventoryActor*> CurrentInventory;\n\n UFUNCTION()\n int32 AddToInventory(AInventoryActor* ActorToAdd);\n\n UFUNCTION()\n void RemoveFromInventory(AInventoryActor* ActorToRemove);\n\nprotected:\n    // Called when the game starts\n    virtual void BeginPlay() override;\n\npublic: \n    // Called every frame\n    virtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n\n};\n```", "```cpp\nint32 UInventoryComponent::AddToInventory(AInventoryActor* ActorToAdd)\n{\n    return CurrentInventory.Add(ActorToAdd);\n}\n\nvoid UInventoryComponent::RemoveFromInventory(AInventoryActor* ActorToRemove)\n{\n    CurrentInventory.Remove(ActorToRemove);\n}\n```", "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Components/ActorComponent.h\"\n#include \"InventoryActor.h\"\n#include \"InventoryComponent.generated.h\"\n\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass CHAPTER_04_API UInventoryComponent : public UActorComponent\n```", "```cpp\nUCLASS()\nclass CHAPTER_04_API AInventoryActor : public AStaticMeshActor\n{\n  GENERATED_BODY()\n\npublic:\n virtual void PickUp();\n virtual void PutDown(FTransform TargetLocation);\n\n};\n```", "```cpp\nvoid AInventoryActor::PickUp() \n{ \n  SetActorTickEnabled(false); \n  SetActorHiddenInGame(true); \n  SetActorEnableCollision(false); \n} \n\nvoid AInventoryActor::PutDown(FTransform TargetLocation) \n{ \n  SetActorTickEnabled(true); \n  SetActorHiddenInGame(false); \n  SetActorEnableCollision(true); \n  SetActorLocation(TargetLocation.GetLocation()); \n} \n```", "```cpp\nAInventoryActor::AInventoryActor()\n    :Super()\n{\n    PrimaryActorTick.bCanEverTick = true;\n    auto MeshAsset = ConstructorHelpers::FObjectFinder<UStaticMesh>(TEXT(\"StaticMesh'/Engine/BasicShapes/Cube.Cube'\"));\n\n    if (MeshAsset.Object != nullptr)\n    {\n        GetStaticMeshComponent()->SetStaticMesh(MeshAsset.Object);\n        GetStaticMeshComponent()->SetCollisionProfileName( UCollisionProfile::Pawn_ProfileName);\n    }\n\n    GetStaticMeshComponent()->SetMobility(EComponentMobility::Movable);\n\n    SetActorEnableCollision(true);\n}\n```", "```cpp\n#include \"InventoryActor.h\"\n#include \"ConstructorHelpers.h\"\n#include \"Engine/CollisionProfile.h\"\n```", "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"InventoryComponent.h\"\n#include \"InventoryActor.h\"\n#include \"InventoryCharacter.generated.h\"\n\nUCLASS()\nclass CHAPTER_04_API AInventoryCharacter : public ACharacter\n```", "```cpp\nUCLASS()\nclass CHAPTER_04_API AInventoryCharacter : public ACharacter\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this character's properties\n    AInventoryCharacter();\n\n UPROPERTY()\n UInventoryComponent* MyInventory;\n\n UFUNCTION()\n void DropItem();\n\n UFUNCTION()\n void TakeItem(AInventoryActor* InventoryItem);\n\n UFUNCTION()\n virtual void NotifyHit(class UPrimitiveComponent* MyComp,\n AActor* Other, class UPrimitiveComponent* OtherComp, \n        bool bSelfMoved, FVector HitLocation, FVector\n        HitNormal, FVector NormalImpulse, const FHitResult&\n        Hit) override;\n\n UFUNCTION()\n void MoveForward(float AxisValue);\n void MoveRight(float AxisValue);\n void PitchCamera(float AxisValue);\n void YawCamera(float AxisValue);\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic: \n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\n    // Called to bind functionality to input\n    virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\nprivate:\n FVector MovementInput;\n FVector CameraInput;\n\n};\n```", "```cpp\nAInventoryCharacter::AInventoryCharacter()\n{\n    // Set this character to call Tick() every frame. You can turn this \n    // off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = true;\n\n    MyInventory = CreateDefaultSubobject<UInventoryComponent>(\"MyInventory\");\n}\n```", "```cpp\n// Called to bind functionality to input\nvoid AInventoryCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n    Super::SetupPlayerInputComponent(PlayerInputComponent);\n\n    PlayerInputComponent->BindAction(\"DropItem\", \n                                     EInputEvent::IE_Pressed, this, \n                                     &AInventoryCharacter::DropItem);\n\n    // Movement\n    PlayerInputComponent->BindAxis(\"MoveForward\", this, \n                                    &AInventoryCharacter::MoveForward);\n    PlayerInputComponent->BindAxis(\"MoveRight\", this, \n                                      &AInventoryCharacter::MoveRight);\n    PlayerInputComponent->BindAxis(\"CameraPitch\", this, \n                                    &AInventoryCharacter::PitchCamera);\n    PlayerInputComponent->BindAxis(\"CameraYaw\", this, \n                                      &AInventoryCharacter::YawCamera);\n}\n```", "```cpp\nvoid AInventoryCharacter::DropItem()\n{\n    if (MyInventory->CurrentInventory.Num() == 0)\n    {\n        return;\n    }\n    AInventoryActor* Item = MyInventory->CurrentInventory.Last();\n    MyInventory->RemoveFromInventory(Item);\n\n    FVector ItemOrigin;\n    FVector ItemBounds;\n    Item->GetActorBounds(false, ItemOrigin, ItemBounds);\n\n    FTransform PutDownLocation = GetTransform() + FTransform(RootComponent->GetForwardVector() * ItemBounds.GetMax());\n\n    Item->PutDown(PutDownLocation);\n}\n\nvoid AInventoryCharacter::NotifyHit(class UPrimitiveComponent* MyComp, AActor* Other, class UPrimitiveComponent* OtherComp, bool bSelfMoved, FVector HitLocation, FVector HitNormal, FVector NormalImpulse, const FHitResult& Hit)\n{\n    AInventoryActor* InventoryItem = Cast<AInventoryActor>(Other);\n    if (InventoryItem != nullptr)\n    {\n        TakeItem(InventoryItem);\n    }\n\n}\n\nvoid AInventoryCharacter::TakeItem(AInventoryActor* InventoryItem)\n{\n    InventoryItem->PickUp();\n    MyInventory->AddToInventory(InventoryItem);\n}\n\n//Movement\nvoid AInventoryCharacter::MoveForward(float AxisValue)\n{\n    MovementInput.X = FMath::Clamp<float>(AxisValue, -1.0f, 1.0f);\n}\n\nvoid AInventoryCharacter::MoveRight(float AxisValue)\n{\n    MovementInput.Y = FMath::Clamp<float>(AxisValue, -1.0f, 1.0f);\n}\n\nvoid AInventoryCharacter::PitchCamera(float AxisValue)\n{\n    CameraInput.Y = AxisValue;\n}\n\nvoid AInventoryCharacter::YawCamera(float AxisValue)\n{\n    CameraInput.X = AxisValue;\n}\n```", "```cpp\n// Called every frame\nvoid AInventoryCharacter::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n\n    if (!MovementInput.IsZero())\n    {\n        MovementInput *= 100;\n\n        //Scale our movement input axis values by 100 units\n        // per second\n        FVector InputVector = FVector(0, 0, 0);\n        InputVector += GetActorForwardVector()* MovementInput.X * \n        DeltaTime;\n        InputVector += GetActorRightVector()* MovementInput.Y * \n        DeltaTime;\n        /* GEngine->AddOnScreenDebugMessage(-1, 1, \n                FColor::Red, \n                FString::Printf(TEXT(\"x- %f, y - %f, z - %f\"), \n             InputVector.X, InputVector.Y, InputVector.Z)); */\n    }\n\n    if (!CameraInput.IsNearlyZero())\n    {\n        FRotator NewRotation = GetActorRotation();\n        NewRotation.Pitch += CameraInput.Y;\n        NewRotation.Yaw += CameraInput.X;\n\n        APlayerController* MyPlayerController = \n        Cast<APlayerController>(GetController());\n        if (MyPlayerController != nullptr)\n        {\n            MyPlayerController->AddYawInput(CameraInput.X);\n            MyPlayerController->AddPitchInput(CameraInput.Y);\n        }\n        SetActorRotation(NewRotation);\n    }\n}\n```", "```cpp\n#include \"InventoryCharacter.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n```", "```cpp\n#include \"Chapter_04GameModeBase.h\"\n#include \"InventoryCharacter.h\"\n\nAChapter_04GameModeBase::AChapter_04GameModeBase()\n{\n DefaultPawnClass = AInventoryCharacter::StaticClass();\n}\n```", "```cpp\nUCLASS()\nclass CHAPTER_04_API AChapter_04GameModeBase : public AGameModeBase\n{\n    GENERATED_BODY()\n    AChapter_04GameModeBase();\n};\n```", "```cpp\nUCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\nclass CHAPTER_04_API UOrbitingMovementComponent : public USceneComponent\n{\n  GENERATED_BODY()\n\npublic: \n  // Sets default values for this component's properties\n  UOrbitingMovementComponent();\n\n UPROPERTY()\n bool RotateToFaceOutwards;\n\n UPROPERTY()\n float RotationSpeed;\n\n UPROPERTY()\n float OrbitDistance;\n\n float CurrentValue;\n\nprotected:\n  // Called when the game starts\n  virtual void BeginPlay() override;\n\npublic: \n  // Called every frame\n  virtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;\n```", "```cpp\n// Sets default values for this component's properties\nUOrbitingMovementComponent::UOrbitingMovementComponent()\n{\n    // Set this component to be initialized when the game\n    // starts, and to be ticked every frame. You can turn\n    // these features off to improve performance if you\n    // don't need them.\n    PrimaryComponentTick.bCanEverTick = true;\n\n    // ...\n RotationSpeed = 5; \n OrbitDistance = 100; \n CurrentValue = 0; \n RotateToFaceOutwards = true; \n}\n```", "```cpp\n// Called every frame\nvoid UOrbitingMovementComponent::TickComponent(float DeltaTime, \n                                               ELevelTick TickType, \n                                         FActorComponentTickFunction* \n                                         ThisTickFunction)\n{\n    Super::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n    // ...\n    float CurrentValueInRadians = FMath::DegreesToRadians<float>(\n CurrentValue);\n\n SetRelativeLocation(\n FVector(OrbitDistance * FMath::Cos(CurrentValueInRadians), \n OrbitDistance * FMath::Sin(CurrentValueInRadians), \n RelativeLocation.Z)\n );\n\n if (RotateToFaceOutwards)\n {\n FVector LookDir = (RelativeLocation).GetSafeNormal();\n FRotator LookAtRot = LookDir.Rotation();\n SetRelativeRotation(LookAtRot);\n }\n\n CurrentValue = FMath::Fmod(CurrentValue + (RotationSpeed * \n                               DeltaTime), 360);\n}\n```", "```cpp\nUCLASS()\nclass CHAPTER_04_API ABarracks : public AActor\n{\n    GENERATED_BODY()\n\npublic: \n    // Sets default values for this actor's properties\n    ABarracks();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic: \n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\n UPROPERTY() \n UStaticMeshComponent* BuildingMesh; \n\n UPROPERTY() \n UParticleSystemComponent* SpawnPoint; \n\n UPROPERTY() \n UClass* UnitToSpawn; \n\n UPROPERTY() \n float SpawnInterval; \n\n UFUNCTION() \n void SpawnUnit(); \n\n UFUNCTION() \n void EndPlay(const EEndPlayReason::Type EndPlayReason) override; \n\n UPROPERTY() \n FTimerHandle SpawnTimerHandle; \n\n};\n```", "```cpp\n#include \"Barracks.h\"\n#include \"Particles/ParticleSystemComponent.h\"\n#include \"BarracksUnit.h\"\n\n// Sets default values\nABarracks::ABarracks()\n{\n    // Set this actor to call Tick() every frame. You can turn\n    // this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = true;\n\n BuildingMesh = CreateDefaultSubobject<UStaticMeshComponent>(\n \"BuildingMesh\");\n\n SpawnPoint = CreateDefaultSubobject<UParticleSystemComponent>(\n \"SpawnPoint\"); \n\n SpawnInterval = 10; \n\n auto MeshAsset = ConstructorHelpers::FObjectFinder<UStaticMesh>(\n TEXT(\"Static    \n                      Mesh'/Engine/BasicShapes/Cube.Cube'\")); \n\n if (MeshAsset.Object != nullptr) \n { \n BuildingMesh->SetStaticMesh(MeshAsset.Object); \n } \n\n auto ParticleSystem = \n    ConstructorHelpers::FObjectFinder<UParticleSystem>\n    (TEXT(\"ParticleSystem'/Engine/Tutorial/SubEditors/TutorialAssets  \n    /TutorialParticleSystem.TutorialParticleSystem'\")); \n\n if (ParticleSystem.Object != nullptr) \n { \n SpawnPoint->SetTemplate(ParticleSystem.Object); \n } \n\n SpawnPoint->SetRelativeScale3D(FVector(0.5, 0.5, 0.5)); \n UnitToSpawn = ABarracksUnit::StaticClass(); \n}\n```", "```cpp\n// Called when the game starts or when spawned\nvoid ABarracks::BeginPlay()\n{\n    Super::BeginPlay();\n\n RootComponent = BuildingMesh; \n SpawnPoint->AttachTo(RootComponent); \n SpawnPoint->SetRelativeLocation(FVector(150, 0, 0)); \n GetWorld()->GetTimerManager().SetTimer(SpawnTimerHandle, \n this, &ABarracks::SpawnUnit, SpawnInterval, true);\n}\n```", "```cpp\nvoid ABarracks::SpawnUnit() \n{ \n  FVector SpawnLocation = SpawnPoint->GetComponentLocation(); \n  GetWorld()->SpawnActor(UnitToSpawn, &SpawnLocation); \n}\n```", "```cpp\nvoid ABarracks::EndPlay(const EEndPlayReason::Type \n EndPlayReason) \n{ \n  Super::EndPlay(EndPlayReason); \n  GetWorld()->GetTimerManager().ClearTimer(SpawnTimerHandle); \n} \n```", "```cpp\nUPROPERTY() \nUParticleSystemComponent* VisualRepresentation; \n```", "```cpp\n#include \"Particles/ParticleSystemComponent.h\"\n```", "```cpp\nVisualRepresentation = \n CreateDefaultSubobject<UParticleSystemComponent>(\"SpawnPoin\n t\");auto ParticleSystem =\n ConstructorHelpers::FObjectFinder<UParticleSystem>(TEXT(\"Pa\n rticleSystem'/Engine/Tutorial/SubEditors/TutorialAssets/Tut\n orialParticleSystem.TutorialParticleSystem'\")); \nif (ParticleSystem.Object != nullptr) \n{ \n  SpawnPoint->SetTemplate(ParticleSystem.Object); \n} \nSpawnPoint->SetRelativeScale3D(FVector(0.5, 0.5, 0.5)); \nSpawnCollisionHandlingMethod = \n ESpawnActorCollisionHandlingMethod::AlwaysSpawn;\n```", "```cpp\nvoid ABarracksUnit::BeginPlay() \n{ \n  Super::BeginPlay(); \n  SpawnPoint->AttachTo(RootComponent); \n}\n```", "```cpp\nSetActorLocation(GetActorLocation() + FVector(10, 0, 0)); \n```"]