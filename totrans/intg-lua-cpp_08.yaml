- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Abstracting a C++ Type Exporter
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to export a C++ class to Lua as a user-defined
    type. An instance of the class is exported to Lua to serve as the prototype for
    the type.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: The exercise from the previous chapter required you to create a factory class
    for the type. However, with that requirement, each type needs its own factory
    class.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to implement a general C++ type exporter
    so that you can use it as the factory class for any C++ type, without redoing
    the work.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the factory implementation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing a type exporter
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stubbing the type exporter
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining `LuaModuleDef`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Re-implementing `luaNew`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are you flexible enough?
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can access the source code for this chapter here: [https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter08](https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter08).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the factory implementation
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will review the exercise from the previous chapter. The solution this book
    has adopted requires progressive and minimal changes. It also leads naturally
    to the feature covered in this chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: If you have not implemented your own solution and are willing to stop here for
    a moment, this is another chance to give it a shot. Many technologies are simple
    in explanation but hard to grasp. The best way to understand them is to review
    and practice them, hands-on, again and again until you get an "aha" moment.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will review a solution. The focus is on the changes and key concepts.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Defining the factory
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make a factory, we only need to change `Destinations.h` and `Destinations.cc`.
    In your preferred IDE, you can open the `end` project for *Chapter 7* and the
    `begin` project for this chapter to check the differences.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us first look at the header file for the factory class declaration. You
    can find the following declarations in `Destinations.h` in the `begin` project
    for this chapter:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The change from the previous chapter is that we are creating a factory class
    named `DestinationsFactory`, which implements the `LuaModule` interface. In fact,
    we are moving the `LuaModule` implementation from `Destinations` to `DestinationsFactory`
    so that the `Destinations` type does not know anything about Lua. This is one
    of the benefits of a factory class. The system can be better layered.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Did you know?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: If you use Linux or Mac, you can also use the `diff` `Chapter07/end/Destinations.h
    Chapter08/begin/Destinations.h`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will review the factory implementation.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the factory
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The factory only has two member functions, which are implemented as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, instead of `REGS`, `luaRegs` returns `FACTORY_REGS`, which is defined
    as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This means, now, we only export a single function, `luaNew`, to Lua.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: As explained in *Chapter 6*, the Lua library expects the last entry to be `{NULL,
    NULL}` to mark the end of the array. This is a typical technique for C-based libraries
    because they usually get a pointer to an item as the input for an array and need
    to figure out where the array ends.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, delete `luaNew` from `REGS` so that it looks like the following list:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Previously, `REGS` served two purposes:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: The `__index` metatable for new instances created from Lua. This is done in
    `luaNew` with `luaL_setfuncs(L,` `REGS.data(), 0)`.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The registered Lua module, which is a plain Lua table. This is done with a call
    to `LuaExecutor::registerModule`.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, `REGS` only serves the first purpose and gives the second responsibility
    to `FACTORY_REGS`. This is yet another structural improvement.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: These are all the changes we need to create a factory. You can read the complete
    source code that you get from GitHub. However, there is not much code change,
    right? We were just moving things around, and we now have a different object-creation
    mechanism.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Now, based on this factory concept, we are ready to move on to the main focus
    of this chapter. From now on, you can use the `begin` project as the basis for
    development. Let us start to design a general C++ type exporter.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Designing a type exporter
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, let us define our scope. We want to generalize the factory we have just
    made and make it work with any C++ class – that is, the C++ class still needs
    to implement and provide the `lua_CFunction` wrappers in some way. It is possible
    to automate the creation of those wrappers, but that would require implementing
    a heavy C++ template library, which is not strictly related to Lua and is out
    of the scope of this book.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: With the scope defined, let us make some high-level designs.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a design pattern
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we talk about making something *general* in C++, usually it means we need
    to use templates. To work with our Lua executor, we need to export `LuaModule`.
    So, we need to implement the exporter as a template class that can provide `LuaModule`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: How can we provide `LuaModule`? We can make the exporter inherit from the `LuaModule`
    interface, or make one of its member functions return `LuaModule`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the popular design patterns for the latter option is the **Builder**
    pattern. This can be demonstrated with the following pseudo-code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: A builder usually has many functions to customize different properties for the
    thing it creates, alongside a `build` function to create the final object.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'Since our goal is to help with object creation alone, like in the factory exercise,
    and not to customize the object, the *Builder* pattern is overkill. We will choose
    the vanilla C++ inheritance. The exporter type can be defined as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is a template class. It will export C++ type `T` as `LuaModule`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Now, let us stub the exporter.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Stubbing the exporter
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have two major considerations for the design of the exporter. First, it is
    `LuaModule`, so it needs to implement its pure virtual functions. Second, we want
    it to resemble what we implemented in the factory exercise, which means we have
    a pretty good idea of what to return in the `luaRegs` virtual function implementation.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us get started. Add a new file named `LuaModuleExporter.hpp` and define
    the `LuaModuleExporter` class, as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This makes the exporter a final class and prevents it from being copy-constructed.
    Because the purpose of the exporter is to provide `LuaModule` and we do not have
    logic for it to get passed around by value, adding some restrictions can prevent
    bugs in the future. We achieve this by assigning the `delete` keyword to the copy
    constructor. We also want to control the object creation, so we make the constructor
    private. This has another effect – you cannot use `new operator` to create instances
    of the class.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the implementation for `LuaModule` as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is straightforward. On the Lua module level, we only want to export one
    function to create concrete objects. So, we will only register `luaNew`. The name
    of the module needs to be passed in. We will find a way when we implement the
    details.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Thus, we have a stub for our exporter. This is a system-level design contract.
    Now, let us write the test code to see how it should be used.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the C++ test code
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In `main.cpp`, write the `main` function as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Compared with the previous chapter, the only difference is how `LuaModule` is
    created. Now, it is created with `LuaModuleExporter<Destinations>::make()`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the project should compile. When you run it, it should not crash
    on the C++ side; although, at this stage, it will not be able to do anything meaningful,
    and you should see an error message from Lua.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will see what Lua code we need.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the Lua test script
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Write `script.lua` exactly as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We used this code snippet in the previous chapter. This will help to validate
    whether we will get the same result later in this chapter.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Next, let us start to make the exporter work.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Defining LuaModuleDef
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we need to provide the name of the module and then the `__index` metatable.
    Finally, we need to provide a name for the metatable. Recall that in `Destinations.cc`,
    the name of the metatable is hardcoded as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, this needs to be passed to the exporter. Let us define a structure for
    the aforementioned three pieces of information. In `LuaModule.h`, add the following
    declaration:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This defines `moduleName` and `moduleRegs`. The metatable name is based on the
    module name, with `".Metatable"` appended to it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Note that this structure is also templated. This indicates that a definition
    is for a certain C++ type. We will use the template later in this chapter.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can pass this structure to the exporter.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Using LuaModuleDef
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In `LuaModuleExporter.hpp`, accept an instance of `LuaModuleDef` during exporter
    creation. Rewrite the related code as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The changes are as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: We added a private member variable, `luaModuleDef`
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We added an argument of type `LuaModuleDef` to `make` and the private constructor
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We changed `luaName` to return `luaModuleDef.moduleName`
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We deleted the private member variable, `name`, introduced during stubbing
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we can define `LuaModuleDef` for the `Destinations` class.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Destinations.h`, delete the declaration for `DestinationsFactory` and add
    the following code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In `Destinations.cpp`, delete all implementations for `DestinationsFactory`
    and add the following code after the anonymous namespace:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, in `main.cpp`, change the module creation code to the following statement:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This pumps `LuaModuleDef` for the `Destinations` class into the exporter. Make
    sure that the project can compile.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will fill in the rest of the missing pieces to make the exporter really
    work.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Re-implementing luaNew
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because we will store `LuaModuleDef` in `LuaModuleExporter`, to access it, we
    need to find the instance of `LuaModuleExporter`. Let us first implement a helper
    function for this.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the exporter is also `LuaModule`, it already has an upvalue mechanism,
    implemented in *Chapter 6*. `LuaModule::pushLuaUpvalues` will push the pointer
    to the `LuaModule` instance as an upvalue. To retrieve it, we can add the following
    function:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is the same as the `getObj` function in *Chapter 6*, but now, it is a static
    member function.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'With a way to access the exporter instance from the static member functions,
    we can write `LuaModuleExporter::luaNew` as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is actually copied from `Destinations.cc`. The changes, besides using `T`
    `typename` instead of the hardcoded class name, are highlighted in the preceding
    code. You can see that they are all about pumping `LuaModuleDef`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: If you have forgotten how `luaNew` works, you can check the previous chapter,
    where there are figures to show how the Lua stack changes as well.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let us implement the stub for `LuaModuleExporter::luaDelete` as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`luaDelete` is registered as the `__gc` metamethod in `luaNew`.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Do you remember?
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: As explained in the previous chapter, we set `luaDelete` as the finalizer for
    the user data created in `luaNew`. During the Lua garbage collection process,
    the finalizer will be called, with an argument as the user data reference.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: You can also delete `REGS`, `FACTORY_REGS`, `luaNew`, and `luaDelete` in `Destinations.cc`.
    They are not used anymore.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can test the exporter. Execute the project. If you have done everything
    correctly, you should see the following output:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We have not really changed the test code from the previous chapter, except for
    how the `Destinations` class gets exported to Lua.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: If you have encountered any errors, do not feel discouraged. This is the most
    complex chapter in this book, and we need to implement code correctly in multiple
    files to make it work. Trace back your steps and fix the error. You can do it!
    Also, in GitHub, there are multiple checkpoint projects for this chapter, which
    you can refer to. As previously mentioned, we will not automate the generation
    of the `lua_CFunction` wrappers. Generalization also needs a limit.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: But, let us check how general our implementation is.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Are you flexible enough?
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To answer this question, let us rewrite `script.lua` as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Yes, the new requirement is that, in the Lua code, when creating the `Destinations`
    objects, we can provide an initial list of unvisited places.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: This means that we need to support parameterized object creation.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Can our exporter support this? This should be a common use case.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Now is a good time to ponder over life, get a cup of coffee, or whatever. We
    are almost near the end of *Part 3* of this book.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'If you recall, our object creation code is as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As a seasoned C++ programmer, you may think that, because `std::make_unique<T>`
    can forward its arguments to the constructor of `T`, there must be a way to make
    `LuaModuleExporter<T>::make` do the same. Right, but the magic of `std::make_unique<T>`
    is at C++ compile time. So, how would you handle that when the arguments are passed
    in Lua code after the C++ code has been compiled?
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Worry not. Let us explore the **factory method** design pattern. A factory method
    is a contract defined as a method or an interface to create and return an object.
    However, how the object is created is not important and not part of the contract.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how it works, let us implement one for `LuaModuleDef`. Add another member
    variable, named `createInstance`, as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This is a bit of advanced C++ usage. Therefore, it is important that you take
    the following into account:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '`createInstance` is declared as a member variable but not as a member function.
    This is because you can simply assign the member variable a different value during
    object construction to achieve a different behavior, but with a member function,
    you need to create a subclass to override the behavior. *We should prefer composition
    over inheritance whenever* *we can.*'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`createInstance` is of type `std::function`. With this type, you can use the
    variable as if it were a function. If you are more familiar with Lua in this regard,
    you’ll understand that a named Lua function is also a variable. Here, we want
    to achieve the same effect. `T *(lua_State *)` is the type of the function. It
    means that the function expects one argument of type `lua_State*` and will return
    a pointer to type `T`. You can check the C++ reference manual to learn more about
    `std::function`.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we provide a default implementation as a C++ lambda. This lambda simply
    creates an instance in the heap without any constructor parameter.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To use this factory method, change `LuaModuleExporter::luaNew`, as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We have changed from new `T()` to `luaModuleDef.createInstance(L)`, and it still
    does the same thing.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: However, note that we no longer create the object in `LuaModuleExporter`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to answer the question, yes, we are flexible enough.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: On modern C++
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: In 1998, C++ was standardized for the first time as C++98\. It saw little change
    until 2011, with C++11\. Since then, C++ has quickly adopted modern programming
    techniques in language specification. Lambdas and `std::function` are just two
    of the many examples. If you know some other languages (for example, Java), you
    can make some analogies (lamdba and functional interface), although the syntaxes
    are different. I implemented `LuaModuleDef` this way instead of using a more traditional
    method to show you some examples of modern C++ features. This is the future, and
    I encourage you to explore modern C++ in more detail. People working with Java,
    Kotlin, and Swift use such techniques by default. You can play an important role
    here by adopting these new techniques and helping C++ to catch up.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Destinations.cc`, change the `LuaModuleDef` instance as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This initializes the `createInstance` field with the provided lambda, rather
    than the default lambda. The new lambda does similar things to the `luaWish` wrapper.
    The beauty of this is that you have full control over this lambda. You can create
    another constructor for the `Destinations` class and simply invoke the new constructor.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'We can test the project with the new Lua script. You should see the following
    output:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see, `Shanghai` and `Tokyo` have been added to the unvisited list.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Even further design improvement
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: We are creating objects in `LuaModuleDef` but destroying them in `LuaModuleExporter`,
    and our use case does not involve transferring object ownership. For a better
    design, the same class should destroy the objects it creates, which we will implement
    in the next chapter.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: This time, for real, we have finished.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we implemented a general C++ module exporter, mainly for the
    object creation part. This ensures that you can implement complex object creation
    logic once and reuse it with many C++ classes. Also, this chapter marks the end
    of *Part 3*, *How to Call C++* *from Lua*.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, we will recap the different communication mechanisms
    between Lua and C++ and explore them further.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is an open exercise. You can write a new C++ class, or find one from your
    work in the past, and then export it to Lua with `LuaModuleExporter`. Try to provide
    an interesting `createInstance` implementation as well.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Part 4 – Advanced Topics
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By this point of the book, you will have learned all the common mechanisms to
    integrate Lua with C++.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: In this part, you will recap what you have learned, which will also serve as
    a source for quick reference. You will also learn how to implement a standalone
    C++ module that can be loaded by Lua, as a dynamic loadable library. Then, you
    will learn some advanced memory management techniques and how to implement multithreading
    with Lua.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，你将回顾你所学的知识，这也可以作为快速参考的来源。你还将学习如何实现一个可以被Lua加载的独立C++模块，作为一个可动态加载的库。然后，你将学习一些高级内存管理技术以及如何使用Lua实现多线程。
- en: 'This part comprises the following chapters:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包括以下章节：
- en: '*Chapter 9*, *Recapping Lua-C++ Communication Mechanisms*'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第9章*，*回顾Lua-C++通信机制*'
- en: '*Chapter 10*, *Managing Resources*'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第10章*，*管理资源*'
- en: '*Chapter 11*, *Multithreading with Lua*'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第11章*，*使用Lua进行多线程*'
