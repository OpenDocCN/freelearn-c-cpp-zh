- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Abstracting a C++ Type Exporter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to export a C++ class to Lua as a user-defined
    type. An instance of the class is exported to Lua to serve as the prototype for
    the type.
  prefs: []
  type: TYPE_NORMAL
- en: The exercise from the previous chapter required you to create a factory class
    for the type. However, with that requirement, each type needs its own factory
    class.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to implement a general C++ type exporter
    so that you can use it as the factory class for any C++ type, without redoing
    the work.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the factory implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing a type exporter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stubbing the type exporter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining `LuaModuleDef`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Re-implementing `luaNew`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are you flexible enough?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can access the source code for this chapter here: [https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter08](https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter08).'
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the factory implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will review the exercise from the previous chapter. The solution this book
    has adopted requires progressive and minimal changes. It also leads naturally
    to the feature covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: If you have not implemented your own solution and are willing to stop here for
    a moment, this is another chance to give it a shot. Many technologies are simple
    in explanation but hard to grasp. The best way to understand them is to review
    and practice them, hands-on, again and again until you get an "aha" moment.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will review a solution. The focus is on the changes and key concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the factory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make a factory, we only need to change `Destinations.h` and `Destinations.cc`.
    In your preferred IDE, you can open the `end` project for *Chapter 7* and the
    `begin` project for this chapter to check the differences.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us first look at the header file for the factory class declaration. You
    can find the following declarations in `Destinations.h` in the `begin` project
    for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The change from the previous chapter is that we are creating a factory class
    named `DestinationsFactory`, which implements the `LuaModule` interface. In fact,
    we are moving the `LuaModule` implementation from `Destinations` to `DestinationsFactory`
    so that the `Destinations` type does not know anything about Lua. This is one
    of the benefits of a factory class. The system can be better layered.
  prefs: []
  type: TYPE_NORMAL
- en: Did you know?
  prefs: []
  type: TYPE_NORMAL
- en: If you use Linux or Mac, you can also use the `diff` `Chapter07/end/Destinations.h
    Chapter08/begin/Destinations.h`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will review the factory implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the factory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The factory only has two member functions, which are implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, instead of `REGS`, `luaRegs` returns `FACTORY_REGS`, which is defined
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This means, now, we only export a single function, `luaNew`, to Lua.
  prefs: []
  type: TYPE_NORMAL
- en: As explained in *Chapter 6*, the Lua library expects the last entry to be `{NULL,
    NULL}` to mark the end of the array. This is a typical technique for C-based libraries
    because they usually get a pointer to an item as the input for an array and need
    to figure out where the array ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, delete `luaNew` from `REGS` so that it looks like the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Previously, `REGS` served two purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: The `__index` metatable for new instances created from Lua. This is done in
    `luaNew` with `luaL_setfuncs(L,` `REGS.data(), 0)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The registered Lua module, which is a plain Lua table. This is done with a call
    to `LuaExecutor::registerModule`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, `REGS` only serves the first purpose and gives the second responsibility
    to `FACTORY_REGS`. This is yet another structural improvement.
  prefs: []
  type: TYPE_NORMAL
- en: These are all the changes we need to create a factory. You can read the complete
    source code that you get from GitHub. However, there is not much code change,
    right? We were just moving things around, and we now have a different object-creation
    mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Now, based on this factory concept, we are ready to move on to the main focus
    of this chapter. From now on, you can use the `begin` project as the basis for
    development. Let us start to design a general C++ type exporter.
  prefs: []
  type: TYPE_NORMAL
- en: Designing a type exporter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, let us define our scope. We want to generalize the factory we have just
    made and make it work with any C++ class – that is, the C++ class still needs
    to implement and provide the `lua_CFunction` wrappers in some way. It is possible
    to automate the creation of those wrappers, but that would require implementing
    a heavy C++ template library, which is not strictly related to Lua and is out
    of the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: With the scope defined, let us make some high-level designs.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a design pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we talk about making something *general* in C++, usually it means we need
    to use templates. To work with our Lua executor, we need to export `LuaModule`.
    So, we need to implement the exporter as a template class that can provide `LuaModule`.
  prefs: []
  type: TYPE_NORMAL
- en: How can we provide `LuaModule`? We can make the exporter inherit from the `LuaModule`
    interface, or make one of its member functions return `LuaModule`.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the popular design patterns for the latter option is the **Builder**
    pattern. This can be demonstrated with the following pseudo-code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: A builder usually has many functions to customize different properties for the
    thing it creates, alongside a `build` function to create the final object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since our goal is to help with object creation alone, like in the factory exercise,
    and not to customize the object, the *Builder* pattern is overkill. We will choose
    the vanilla C++ inheritance. The exporter type can be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This is a template class. It will export C++ type `T` as `LuaModule`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let us stub the exporter.
  prefs: []
  type: TYPE_NORMAL
- en: Stubbing the exporter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have two major considerations for the design of the exporter. First, it is
    `LuaModule`, so it needs to implement its pure virtual functions. Second, we want
    it to resemble what we implemented in the factory exercise, which means we have
    a pretty good idea of what to return in the `luaRegs` virtual function implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us get started. Add a new file named `LuaModuleExporter.hpp` and define
    the `LuaModuleExporter` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This makes the exporter a final class and prevents it from being copy-constructed.
    Because the purpose of the exporter is to provide `LuaModule` and we do not have
    logic for it to get passed around by value, adding some restrictions can prevent
    bugs in the future. We achieve this by assigning the `delete` keyword to the copy
    constructor. We also want to control the object creation, so we make the constructor
    private. This has another effect – you cannot use `new operator` to create instances
    of the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the implementation for `LuaModule` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is straightforward. On the Lua module level, we only want to export one
    function to create concrete objects. So, we will only register `luaNew`. The name
    of the module needs to be passed in. We will find a way when we implement the
    details.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, we have a stub for our exporter. This is a system-level design contract.
    Now, let us write the test code to see how it should be used.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the C++ test code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In `main.cpp`, write the `main` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Compared with the previous chapter, the only difference is how `LuaModule` is
    created. Now, it is created with `LuaModuleExporter<Destinations>::make()`.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the project should compile. When you run it, it should not crash
    on the C++ side; although, at this stage, it will not be able to do anything meaningful,
    and you should see an error message from Lua.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will see what Lua code we need.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the Lua test script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Write `script.lua` exactly as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We used this code snippet in the previous chapter. This will help to validate
    whether we will get the same result later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let us start to make the exporter work.
  prefs: []
  type: TYPE_NORMAL
- en: Defining LuaModuleDef
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we need to provide the name of the module and then the `__index` metatable.
    Finally, we need to provide a name for the metatable. Recall that in `Destinations.cc`,
    the name of the metatable is hardcoded as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, this needs to be passed to the exporter. Let us define a structure for
    the aforementioned three pieces of information. In `LuaModule.h`, add the following
    declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This defines `moduleName` and `moduleRegs`. The metatable name is based on the
    module name, with `".Metatable"` appended to it.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this structure is also templated. This indicates that a definition
    is for a certain C++ type. We will use the template later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can pass this structure to the exporter.
  prefs: []
  type: TYPE_NORMAL
- en: Using LuaModuleDef
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In `LuaModuleExporter.hpp`, accept an instance of `LuaModuleDef` during exporter
    creation. Rewrite the related code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The changes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We added a private member variable, `luaModuleDef`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We added an argument of type `LuaModuleDef` to `make` and the private constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We changed `luaName` to return `luaModuleDef.moduleName`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We deleted the private member variable, `name`, introduced during stubbing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we can define `LuaModuleDef` for the `Destinations` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Destinations.h`, delete the declaration for `DestinationsFactory` and add
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In `Destinations.cpp`, delete all implementations for `DestinationsFactory`
    and add the following code after the anonymous namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in `main.cpp`, change the module creation code to the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This pumps `LuaModuleDef` for the `Destinations` class into the exporter. Make
    sure that the project can compile.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will fill in the rest of the missing pieces to make the exporter really
    work.
  prefs: []
  type: TYPE_NORMAL
- en: Re-implementing luaNew
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because we will store `LuaModuleDef` in `LuaModuleExporter`, to access it, we
    need to find the instance of `LuaModuleExporter`. Let us first implement a helper
    function for this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the exporter is also `LuaModule`, it already has an upvalue mechanism,
    implemented in *Chapter 6*. `LuaModule::pushLuaUpvalues` will push the pointer
    to the `LuaModule` instance as an upvalue. To retrieve it, we can add the following
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This is the same as the `getObj` function in *Chapter 6*, but now, it is a static
    member function.
  prefs: []
  type: TYPE_NORMAL
- en: 'With a way to access the exporter instance from the static member functions,
    we can write `LuaModuleExporter::luaNew` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This is actually copied from `Destinations.cc`. The changes, besides using `T`
    `typename` instead of the hardcoded class name, are highlighted in the preceding
    code. You can see that they are all about pumping `LuaModuleDef`.
  prefs: []
  type: TYPE_NORMAL
- en: If you have forgotten how `luaNew` works, you can check the previous chapter,
    where there are figures to show how the Lua stack changes as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let us implement the stub for `LuaModuleExporter::luaDelete` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`luaDelete` is registered as the `__gc` metamethod in `luaNew`.'
  prefs: []
  type: TYPE_NORMAL
- en: Do you remember?
  prefs: []
  type: TYPE_NORMAL
- en: As explained in the previous chapter, we set `luaDelete` as the finalizer for
    the user data created in `luaNew`. During the Lua garbage collection process,
    the finalizer will be called, with an argument as the user data reference.
  prefs: []
  type: TYPE_NORMAL
- en: You can also delete `REGS`, `FACTORY_REGS`, `luaNew`, and `luaDelete` in `Destinations.cc`.
    They are not used anymore.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can test the exporter. Execute the project. If you have done everything
    correctly, you should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We have not really changed the test code from the previous chapter, except for
    how the `Destinations` class gets exported to Lua.
  prefs: []
  type: TYPE_NORMAL
- en: If you have encountered any errors, do not feel discouraged. This is the most
    complex chapter in this book, and we need to implement code correctly in multiple
    files to make it work. Trace back your steps and fix the error. You can do it!
    Also, in GitHub, there are multiple checkpoint projects for this chapter, which
    you can refer to. As previously mentioned, we will not automate the generation
    of the `lua_CFunction` wrappers. Generalization also needs a limit.
  prefs: []
  type: TYPE_NORMAL
- en: But, let us check how general our implementation is.
  prefs: []
  type: TYPE_NORMAL
- en: Are you flexible enough?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To answer this question, let us rewrite `script.lua` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Yes, the new requirement is that, in the Lua code, when creating the `Destinations`
    objects, we can provide an initial list of unvisited places.
  prefs: []
  type: TYPE_NORMAL
- en: This means that we need to support parameterized object creation.
  prefs: []
  type: TYPE_NORMAL
- en: Can our exporter support this? This should be a common use case.
  prefs: []
  type: TYPE_NORMAL
- en: Now is a good time to ponder over life, get a cup of coffee, or whatever. We
    are almost near the end of *Part 3* of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you recall, our object creation code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As a seasoned C++ programmer, you may think that, because `std::make_unique<T>`
    can forward its arguments to the constructor of `T`, there must be a way to make
    `LuaModuleExporter<T>::make` do the same. Right, but the magic of `std::make_unique<T>`
    is at C++ compile time. So, how would you handle that when the arguments are passed
    in Lua code after the C++ code has been compiled?
  prefs: []
  type: TYPE_NORMAL
- en: Worry not. Let us explore the **factory method** design pattern. A factory method
    is a contract defined as a method or an interface to create and return an object.
    However, how the object is created is not important and not part of the contract.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how it works, let us implement one for `LuaModuleDef`. Add another member
    variable, named `createInstance`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a bit of advanced C++ usage. Therefore, it is important that you take
    the following into account:'
  prefs: []
  type: TYPE_NORMAL
- en: '`createInstance` is declared as a member variable but not as a member function.
    This is because you can simply assign the member variable a different value during
    object construction to achieve a different behavior, but with a member function,
    you need to create a subclass to override the behavior. *We should prefer composition
    over inheritance whenever* *we can.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`createInstance` is of type `std::function`. With this type, you can use the
    variable as if it were a function. If you are more familiar with Lua in this regard,
    you’ll understand that a named Lua function is also a variable. Here, we want
    to achieve the same effect. `T *(lua_State *)` is the type of the function. It
    means that the function expects one argument of type `lua_State*` and will return
    a pointer to type `T`. You can check the C++ reference manual to learn more about
    `std::function`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we provide a default implementation as a C++ lambda. This lambda simply
    creates an instance in the heap without any constructor parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To use this factory method, change `LuaModuleExporter::luaNew`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We have changed from new `T()` to `luaModuleDef.createInstance(L)`, and it still
    does the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: However, note that we no longer create the object in `LuaModuleExporter`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to answer the question, yes, we are flexible enough.
  prefs: []
  type: TYPE_NORMAL
- en: On modern C++
  prefs: []
  type: TYPE_NORMAL
- en: In 1998, C++ was standardized for the first time as C++98\. It saw little change
    until 2011, with C++11\. Since then, C++ has quickly adopted modern programming
    techniques in language specification. Lambdas and `std::function` are just two
    of the many examples. If you know some other languages (for example, Java), you
    can make some analogies (lamdba and functional interface), although the syntaxes
    are different. I implemented `LuaModuleDef` this way instead of using a more traditional
    method to show you some examples of modern C++ features. This is the future, and
    I encourage you to explore modern C++ in more detail. People working with Java,
    Kotlin, and Swift use such techniques by default. You can play an important role
    here by adopting these new techniques and helping C++ to catch up.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Destinations.cc`, change the `LuaModuleDef` instance as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This initializes the `createInstance` field with the provided lambda, rather
    than the default lambda. The new lambda does similar things to the `luaWish` wrapper.
    The beauty of this is that you have full control over this lambda. You can create
    another constructor for the `Destinations` class and simply invoke the new constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can test the project with the new Lua script. You should see the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `Shanghai` and `Tokyo` have been added to the unvisited list.
  prefs: []
  type: TYPE_NORMAL
- en: Even further design improvement
  prefs: []
  type: TYPE_NORMAL
- en: We are creating objects in `LuaModuleDef` but destroying them in `LuaModuleExporter`,
    and our use case does not involve transferring object ownership. For a better
    design, the same class should destroy the objects it creates, which we will implement
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: This time, for real, we have finished.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we implemented a general C++ module exporter, mainly for the
    object creation part. This ensures that you can implement complex object creation
    logic once and reuse it with many C++ classes. Also, this chapter marks the end
    of *Part 3*, *How to Call C++* *from Lua*.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, we will recap the different communication mechanisms
    between Lua and C++ and explore them further.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is an open exercise. You can write a new C++ class, or find one from your
    work in the past, and then export it to Lua with `LuaModuleExporter`. Try to provide
    an interesting `createInstance` implementation as well.
  prefs: []
  type: TYPE_NORMAL
- en: Part 4 – Advanced Topics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By this point of the book, you will have learned all the common mechanisms to
    integrate Lua with C++.
  prefs: []
  type: TYPE_NORMAL
- en: In this part, you will recap what you have learned, which will also serve as
    a source for quick reference. You will also learn how to implement a standalone
    C++ module that can be loaded by Lua, as a dynamic loadable library. Then, you
    will learn some advanced memory management techniques and how to implement multithreading
    with Lua.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part comprises the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 9*, *Recapping Lua-C++ Communication Mechanisms*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 10*, *Managing Resources*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 11*, *Multithreading with Lua*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
