["```cpp\n    int age = 42;\n    int attendance = 96321; \n    ```", "```cpp\n    unsigned int length = 32;\n    short year = 2023; // same as short int\n    unsigned long long filesize = 3'758'096'384; \n    ```", "```cpp\n    std::size_t items = arr.size(); \n    ```", "```cpp\n    double price = 4.99;\n    float temperature = 36.5;\n    long double pi = 3.14159265358979323846264338327950288419716939937510L; \n    ```", "```cpp\n1 == sizeof(char) <= sizeof(short) <= sizeof(int) <= sizeof(long) <= sizeof(long long) \n```", "```cpp\nstd::int8_t x = 42;\nstd::cout << x << '\\n'; // [1] prints *\nstd::int16_t y = 42;\nstd::cout << y << '\\n'; // [2] prints 42 \n```", "```cpp\nauto a = 4'234'871'523ll;        // 4234871523\nauto b = 0xBAAD'F00D;            // 3131961357\nauto c = 00'12'34;               // 668\nauto d = 0b1011'01011'0001'1001; // 46361 \n```", "```cpp\nauto e = 1'2'3'4'5; \n```", "```cpp\n    // example 1\n    template<typename T, typename Iter>\n    T minimum(Iter const start, Iter const end) // finds the\n     // minimum value\n     // in a range\n    {\n      T minval = std::numeric_limits<T>::max();\n      for (auto i = start; i < end; ++i)\n      {\n        if (*i < minval)\n          minval = *i;\n      }\n      return minval;\n    }\n    // example 2\n    int range[std::numeric_limits<char>::max() + 1] = { 0 };\n    // example 3\n    switch(get_value())\n    {\n      case std::numeric_limits<int>::min():\n      // do something\n    break;\n    } \n    ```", "```cpp\n    auto n = 42;\n    std::bitset<std::numeric_limits<decltype(n)>::digits>\n       bits { static_cast<unsigned long long>(n) }; \n    ```", "```cpp\ntemplate <typename T>\nvoid print_type_properties()\n{\n  std::cout\n    << \"min=\"\n    << std::numeric_limits<T>::min()        << '\\n'\n    << \"max=\"\n    << std::numeric_limits<T>::max()        << '\\n'\n    << \"bits=\"\n    << std::numeric_limits<T>::digits       << '\\n'\n    << \"decdigits=\"\n    << std::numeric_limits<T>::digits10     << '\\n'\n    << \"integral=\"\n    << std::numeric_limits<T>::is_integer   << '\\n'\n    << \"signed=\"\n    << std::numeric_limits<T>::is_signed    << '\\n'\n    << \"exact=\"\n    << std::numeric_limits<T>::is_exact     << '\\n'\n    << \"infinity=\"\n    << std::numeric_limits<T>::has_infinity << '\\n';\n} \n```", "```cpp\nmin=0\nmax=65535\nbits=16\ndecdigits=4\nintegral=1\nsigned=0\nexact=1\ninfinity=0 \n```", "```cpp\nmin=-2147483648\nmax=2147483647\nbits=31\ndecdigits=9\nintegral=1\nsigned=1\nexact=1\ninfinity=0 \n```", "```cpp\nmin=2.22507e-308\nmax=1.79769e+308\nbits=53\ndecdigits=15\nintegral=0\nsigned=1\nexact=0\ninfinity=1 \n```", "```cpp\n    auto si = std::to_string(42);      // si=\"42\"\n    auto sl = std::to_string(42L);     // sl=\"42\"\n    auto su = std::to_string(42u);     // su=\"42\"\n    auto sd = std::to_wstring(42.0);   // sd=L\"42.000000\"\n    auto sld = std::to_wstring(42.0L); // sld=L\"42.000000\" \n    ```", "```cpp\n    auto i1 = std::stoi(\"42\");                  // i1 = 42\n    auto i2 = std::stoi(\"101010\"L, nullptr, 2); // i2 = 42\n    auto i3 = std::stoi(\"052\", nullptr, 8);     // i3 = 42\n    auto i4 = std::stoi(\"0x2A\"L, nullptr, 16);  // i4 = 42 \n    ```", "```cpp\n    // d1 = 123.45000000000000\n    auto d1 = std::stod(\"123.45\");\n    // d2 = 123.45000000000000\n    auto d2 = std::stod(\"1.2345e+2\");\n    // d3 = 123.44999980926514\n    auto d3 = std::stod(\"0xF.6E6666p3\"); \n    ```", "```cpp\nint of these two functions:\n```", "```cpp\nstd::string to_string(int value);\nstd::wstring to_wstring(int value); \n```", "```cpp\nint stoi(const std::string& str, std::size_t* pos = 0, int base = 10);\nint stoi(const std::wstring& str, std::size_t* pos = 0, int base = 10); \n```", "```cpp\nauto i1 = std::stoi(\"42\");             // i1 = 42\nauto i2 = std::stoi(\"   42\");          // i2 = 42\nauto i3 = std::stoi(\"   42fortytwo\");  // i3 = 42\nauto i4 = std::stoi(\"+42\");            // i4 = 42\nauto i5 = std::stoi(\"-42\");            // i5 = -42 \n```", "```cpp\nauto i6 = std::stoi(\"052\", nullptr, 8);      // i6 = 42\nauto i7 = std::stoi(\"052\", nullptr, 0);      // i7 = 42\nauto i8 = std::stoi(\"0x2A\", nullptr, 16);    // i8 = 42\nauto i9 = std::stoi(\"0x2A\", nullptr, 0);     // i9 = 42\nauto i10 = std::stoi(\"101010\", nullptr, 2); // i10 = 42\nauto i11 = std::stoi(\"22\", nullptr, 20);    // i11 = 42\nauto i12 = std::stoi(\"-22\", nullptr, 20);  // i12 = -42\nauto pos = size_t{ 0 };\nauto i13 = std::stoi(\"42\", &pos);      // i13 = 42,  pos = 2\nauto i14 = std::stoi(\"-42\", &pos);     // i14 = -42, pos = 3\nauto i15 = std::stoi(\"  +42dec\", &pos);// i15 = 42,  pos = 5 \n```", "```cpp\n    try\n    {\n      auto i16 = std::stoi(\"\");\n    }\n    catch (std::exception const & e)\n    {\n      // prints \"invalid stoi argument\"\n      std::cout << e.what() << '\\n';\n    } \n    ```", "```cpp\n    try\n    {\n      // OK\n    auto i17 = std::stoll(\"12345678901234\");\n      // throws std::out_of_range\n    auto i18 = std::stoi(\"12345678901234\");\n    }\n    catch (std::exception const & e)\n    {\n      // prints \"stoi argument out of range\"\n      std::cout << e.what() << '\\n';\n    } \n    ```", "```cpp\nauto d1 = std::stod(\"123.45\");         // d1 =  123.45000000000000\nauto d2 = std::stod(\"+123.45\");        // d2 =  123.45000000000000\nauto d3 = std::stod(\"-123.45\");        // d3 = -123.45000000000000\nauto d4 = std::stod(\"  123.45\");       // d4 =  123.45000000000000\nauto d5 = std::stod(\"  -123.45abc\");   // d5 = -123.45000000000000\nauto d6 = std::stod(\"1.2345e+2\");      // d6 =  123.45000000000000\nauto d7 = std::stod(\"0xF.6E6666p3\");   // d7 =  123.44999980926514\nauto d8 = std::stod(\"INF\");            // d8 = inf\nauto d9 = std::stod(\"-infinity\");      // d9 = -inf\nauto d10 = std::stod(\"NAN\");           // d10 = nan\nauto d11 = std::stod(\"-nanabc\");       // d11 = -nan \n```", "```cpp\n    char c = 'C';\n    const char* s = \"C++\";\n    std::cout << c <<  s << '\\n'; \n    ```", "```cpp\n    wchar_t c = L'Ʃ';\n    const wchar_t* s = L\"δῆμος\";\n    std::wcout << c << s << '\\n'; \n    ```", "```cpp\n    char8_t c = u8'A';\n    const char8_t* s = u8\"Æthelflæd\"; \n    ```", "```cpp\n    char16_t c = u'Æ';\n    const char16_t* s = u\"Æthelflæd\"; \n    ```", "```cpp\n    char32_t c = U'![](img/4th_GLYPS.png)';\n    const char32_t* s = U\"![](img/3rd_GLYPS.png)\"; \n    ```", "```cpp\nstd::cout << std::is_same_v<char, signed char> << '\\n';   // prints 0\nstd::cout << std::is_same_v<char, unsigned char> << '\\n'; // prints 0 \n```", "```cpp\nvoid f(char) {}\nvoid f(signed char) {}\nvoid f(unsigned char) {} \n```", "```cpp\nstd::string s = \"demo\"; \n```", "```cpp\nauto is used didactically to explain the deduction rules):\n```", "```cpp\nauto c1 = 'a';     // char\nauto c2 = L'b';    // wchar_t\nauto c3 = u8'c';   // char until C++20, char8_t in C++20\nauto c4 = u'd';    // char16_t\nauto c5 = U'e';    // char32_t\nauto sa1 = \"a\";    // const char*\nauto sa2 = L\"a\";   // const wchar_t*\nauto sa3 = u8\"a\";  // const char* until C++20\n// const char8_t* in C++20\nauto sa4 = u\"a\";   // const char16_t*\nauto sa5 = U\"a\";   // const char32_t* \n```", "```cpp\nusing namespace std::string_literals;\nauto s1 = \"a\"s;    // std::string\nauto s2 = L\"a\"s;   // std::wstring\nauto s3 = u8\"a\"s;  // std::u8string\nauto s4 = u\"a\"s;   // std::u16string\nauto s5 = U\"a\"s;   // std::u32string \n```", "```cpp\nstd::u16string hb = u\"Harald Bluetooth \\u16BC\\u16d2\"; // ![](img/1ST_GLYPS.png)\nstd::u32string eh = U\"Egyptian hieroglyphs \\U00013000 \\U000131B2\"; // ![](img/2nd_GLYPS.png) \n```", "```cpp\nstd::u16string hb = u\"Harald Bluetooth \\N{Runic Letter Long-Branch-Hagall H}\\N{Runic Letter Berkanan Beorc Bjarkan B}\";\nstd::u32string eh = U\"Egyptian hieroglyphs \\N{EGYPTIAN HIEROGLYPH A001} \\N{EGYPTIAN HIEROGLYPH M003A}\"; \n```", "```cpp\nstd::u32string eh = U\"Egyptian hieroglyphs \\u{13000} \\u{131B2}\"; // ![](img/2nd_GLYPS.png) \n```", "```cpp\n    std::cout << \"C++\\n\"; \n    ```", "```cpp\n    std::cout << \"Erling Håland\\n\";\n    std::cout << \"Thomas Müller\\n\";\n    std::cout << \"Στέφανος Τσιτσιπάς\\n\";\n    std::string monkeys = \"![](img/3rd_GLYPS.png)\";\n    std::cout << monkeys << '\\n'; \n    ```", "```cpp\n    std::cout << reinterpret_cast<const char*>(u8\"Στέφανος Τσιτσιπάς\\n\"); \n    ```", "```cpp\n    SetConsoleOutputCP(CP_UTF8);\n    std::cout << reinterpret_cast<const char*>(u8\"Erling Håland\\n\");\n    std::cout << reinterpret_cast<const char*>(u8\"Thomas Müller\\n\");\n    std::cout << reinterpret_cast<const char*>(u8\"Στέφανος Τσιτσιπάς\\n\");\n    std::cout << reinterpret_cast<const char*>(u8\"![](img/3rd_GLYPS.png)\\n\"); \n    ```", "```cpp\n    auto mode = _setmode(_fileno(stdout), _O_U16TEXT);\n    std::wcout << L\"Erling Håland\\n\";\n    std::wcout << L\"Thomas Müller\\n\";\n    std::wcout << L\"Στέφανος Τσιτσιπάς\\n\";\n    _setmode(_fileno(stdout), mode); \n    ```", "```cpp\nchar c = 224;\nfor (int codepage = 1250; codepage <= 1258; codepage++)\n{\n   SetConsoleOutputCP(codepage);\n   std::cout << c << ' ';\n} \n```", "```cpp\nstd::cout << \"Στέφανος Τσιτσιπάς\"; \n```", "```cpp\n    std::locale utf8(\"\");\n    std::wcout.imbue(utf8);\n    std::wcout << L\"Στέφανος Τσιτσιπάς\\n\"; \n    ```", "```cpp\n    std::locale utf8(\"en_US.UTF-8\");\n    std::wcout.imbue(utf8);\n    std::wcout << L\"Στέφανος Τσιτσιπάς\\n\"; \n    ```", "```cpp\nSetConsoleOutputCP(CP_UTF8);\nstd::cout << reinterpret_cast<const char*>(u8\"Erling Håland\\n\");\nstd::cout << reinterpret_cast<const char*>(u8\"Thomas Müller\\n\");\nstd::cout << reinterpret_cast<const char*>(u8\"Στέφανος Τσιτσιπάς\\n\");\nstd::u8string monkeys = u8\"![](img/3rd_GLYPS.png)\\n\";\nstd::cout << reinterpret_cast<const char*>(monkeys.c_str()); \n```", "```cpp\nauto mode = _setmode(_fileno(stdout), _O_U16TEXT);\nstd::wcout << L\"Erling Håland\\n\";\nstd::wcout << L\"Thomas Müller\\n\";\nstd::wcout << L\"Στέφανος Τσιτσιπάς\\n\";\n_setmode(_fileno(stdout), mode); \n```", "```cpp\nstd::cout << reinterpret_cast<const char*>(u8\"Erling Håland\\n\"); \n```", "```cpp\n    #include <random> \n    ```", "```cpp\n    std::random_device rd{}; \n    ```", "```cpp\n    auto mtgen = std::mt19937{ rd() }; \n    ```", "```cpp\n    auto ud = std::uniform_int_distribution<>{ 1, 6 }; \n    ```", "```cpp\n    for(auto i = 0; i < 20; ++i)\n      auto number = ud(mtgen); \n    ```", "```cpp\nauto mtgen = std::mt19937 {};\nfor (auto i = 0; i < 10; ++i)\n  std::cout << mtgen() << '\\n'; \n```", "```cpp\nauto seed = std::chrono::high_resolution_clock::now()\n            .time_since_epoch()\n            .count();\nauto mtgen = std::mt19937{ static_cast<unsigned int>(seed) }; \n```", "```cpp\nstd::random_device rd;\nauto mtgen = std::mt19937 {rd()}; \n```", "```cpp\nvoid generate_and_print(std::function<int(void)> gen,\n int const iterations = 10000)\n{\n  // map to store the numbers and their repetition\nauto data = std::map<int, int>{};\n  // generate random numbers\nfor (auto n = 0; n < iterations; ++n)\n    ++data[gen()];\n  // find the element with the most repetitions\nauto max = std::max_element(\n             std::begin(data), std::end(data),\n             [](auto kvp1, auto kvp2) {\n    return kvp1.second < kvp2.second; });\n  // print the bars\nfor (auto i = max->second / 200; i > 0; --i)\n  {\n    for (auto kvp : data)\n    {\n      std::cout\n        << std::fixed << std::setprecision(1) << std::setw(3)\n        << (kvp.second / 200 >= i ? (char)219 : ' ');\n    }\n    std::cout << '\\n';\n  }\n  // print the numbers\nfor (auto kvp : data)\n  {\n    std::cout\n      << std::fixed << std::setprecision(1) << std::setw(3)\n      << kvp.first;\n  }\n  std::cout << '\\n';\n} \n```", "```cpp\nstd::random_device rd{};\nauto mtgen = std::mt19937{ rd() };\nauto ud = std::uniform_int_distribution<>{ 1, 6 };\ngenerate_and_print([&mtgen, &ud]() {return ud(mtgen); }); \n```", "```cpp\nstd::random_device rd{};\nauto mtgen = std::mt19937{ rd() };\nauto nd = std::normal_distribution<>{ 5, 2 };\ngenerate_and_print(\n  [&mtgen, &nd]() {\n    return static_cast<int>(std::round(nd(mtgen))); }); \n```", "```cpp\n    std::random_device rd; \n    ```", "```cpp\n    std::array<int, std::mt19937::state_size> seed_data {};\n    std::generate(std::begin(seed_data), std::end(seed_data),\n                  std::ref(rd)); \n    ```", "```cpp\n    std::seed_seq seq(std::begin(seed_data), std::end(seed_data)); \n    ```", "```cpp\n    auto eng = std::mt19937{ seq }; \n    ```", "```cpp\n    auto dist = std::uniform_real_distribution<>{ 0, 1 }; \n    ```", "```cpp\n    T operator \"\" _suffix(unsigned long long int);\n    T operator \"\" _suffix(long double);\n    T operator \"\" _suffix(char);\n    T operator \"\" _suffix(wchar_t);\n    T operator \"\" _suffix(char8_t); // since C++20\n    T operator \"\" _suffix(char16_t);\n    T operator \"\" _suffix(char32_t);\n    T operator \"\" _suffix(char const *, std::size_t);\n    T operator \"\" _suffix(wchar_t const *, std::size_t);\n    T operator \"\" _suffix(char8_t const *, std::size_t); // C++20\n    T operator \"\" _suffix(char16_t const *, std::size_t);\n    T operator \"\" _suffix(char32_t const *, std::size_t); \n    ```", "```cpp\n    namespace compunits\n    {\n      constexpr size_t operator \"\" _KB(unsigned long long const size)\n      {\n        return static_cast<size_t>(size * 1024);\n      }\n    }\n    auto size{ 4_KB };         // size_t size = 4096;\n    using byte = unsigned char;\n    auto buffer = std::array<byte, 1_KB>{}; \n    ```", "```cpp\n    enum class unit { kilogram, liter, meter, piece, }; \n    ```", "```cpp\n    template <unit U>\n    class quantity\n    {\n      const double amount;\n    public:\n      constexpr explicit quantity(double const a) : amount(a)\n      {}\n      explicit operator double() const { return amount; }\n    }; \n    ```", "```cpp\n    template <unit U>\n    constexpr quantity<U> operator+(quantity<U> const &q1,\n                                    quantity<U> const &q2)\n    {\n      return quantity<U>(static_cast<double>(q1) +\n                         static_cast<double>(q2));\n    }\n    template <unit U>\n    constexpr quantity<U> operator-(quantity<U> const &q1,\n                                    quantity<U> const &q2)\n    {\n      return quantity<U>(static_cast<double>(q1) –\n                         static_cast<double>(q2));\n    } \n    ```", "```cpp\n    namespace unit_literals\n    {\n      constexpr quantity<unit::kilogram> operator \"\" _kg(\n          long double const amount)\n      {\n        return quantity<unit::kilogram> { static_cast<double>(amount) };\n      }\n      constexpr quantity<unit::kilogram> operator \"\" _kg(\n          unsigned long long const amount)\n      {\n        return quantity<unit::kilogram> { static_cast<double>(amount) };\n      }\n      constexpr quantity<unit::liter> operator \"\" _l(\n          long double const amount)\n      {\n        return quantity<unit::liter> { static_cast<double>(amount) };\n      }\n      constexpr quantity<unit::meter> operator \"\" _m(\n          long double const amount)\n      {\n        return quantity<unit::meter> { static_cast<double>(amount) };\n      }\n      constexpr quantity<unit::piece> operator \"\" _pcs(\n          unsigned long long const amount)\n      {\n        return quantity<unit::piece> { static_cast<double>(amount) };\n      }\n    } \n    ```", "```cpp\nusing namespace units;\nusing namespace unit_literals;\nauto q1{ 1_kg };    // OK\nauto q2{ 4.5_kg };  // OK\nauto q3{ q1 + q2 }; // OK\nauto q4{ q2 - q1 }; // OK\n// error, cannot add meters and pieces\nauto q5{ 1.0_m + 1_pcs };\n// error, cannot have an integer number of liters\nauto q6{ 1_l };\n// error, can only have an integer number of pieces\nauto q7{ 2.0_pcs} \n```", "```cpp\n    using namespace std::string_literals;\n    auto s1{  \"text\"s }; // std::string\n    auto s2{ L\"text\"s }; // std::wstring\n    auto s3{ u\"text\"s }; // std::u16string\n    auto s4{ U\"text\"s }; // std::u32string\n    using namespace std::string_view_literals;\n    auto s5{ \"text\"sv }; // std::string_view \n    ```", "```cpp\n    using namespace std::chrono_literals;\n    // std::chrono::duration<long long>\n    auto timer {2h + 42min + 15s}; \n    ```", "```cpp\n    using namespace std::chrono_literals;\n    auto year { 2020y }; // std::chrono::year\n    auto day { 15d };    // std::chrono::day \n    ```", "```cpp\n    using namespace std::complex_literals;\n    auto c{ 12.0 + 4.5i }; // std::complex<double> \n    ```", "```cpp\n    T operator \"\" _suffix(const char*);\n    template<char...> T operator \"\" _suffix(); \n    ```", "```cpp\nnamespace binary\n{\n  using byte8  = unsigned char;\n  using byte16 = unsigned short;\n  using byte32 = unsigned int;\n  namespace binary_literals\n  {\n    namespace binary_literals_internals\n    {\n      template <typename CharT, char... bits>\n      struct binary_struct;\n      template <typename CharT, char... bits>\n      struct binary_struct<CharT, '0', bits...>\n      {\n        static constexpr CharT value{\n          binary_struct<CharT, bits...>::value };\n      };\n      template <typename CharT, char... bits>\n      struct binary_struct<CharT, '1', bits...>\n      {\n        static constexpr CharT value{\n          static_cast<CharT>(1 << sizeof...(bits)) |\n          binary_struct<CharT, bits...>::value };\n      };\n      template <typename CharT>\n      struct binary_struct<CharT>\n      {\n        static constexpr CharT value{ 0 };\n      };\n    }\n    template<char... bits>\n    constexpr byte8 operator\"\"_b8()\n    {\n      static_assert(\n        sizeof...(bits) <= 8,\n        \"binary literal b8 must be up to 8 digits long\");\n      return binary_literals_internals::\n                binary_struct<byte8, bits...>::value;\n    }\n    template<char... bits>\n    constexpr byte16 operator\"\"_b16()\n    {\n      static_assert(\n        sizeof...(bits) <= 16,\n        \"binary literal b16 must be up to 16 digits long\");\n      return binary_literals_internals::\n                binary_struct<byte16, bits...>::value;\n    }\n    template<char... bits>\n    constexpr byte32 operator\"\"_b32()\n    {\n      static_assert(\n        sizeof...(bits) <= 32,\n        \"binary literal b32 must be up to 32 digits long\");\n      return binary_literals_internals::\n                binary_struct<byte32, bits...>::value;\n    }\n  }\n} \n```", "```cpp\ntemplate <typename CharT, char... bits>\nstruct binary_struct; \n```", "```cpp\ntemplate <typename CharT, char... bits>\nstruct binary_struct<CharT, '0', bits...>\n{\n  static constexpr CharT value{ binary_struct<CharT, bits...>::value };\n};\ntemplate <typename CharT, char... bits>\nstruct binary_struct<CharT, '1', bits...>\n{\n  static constexpr CharT value{\n    static_cast<CharT>(1 << sizeof...(bits)) |\n    binary_struct<CharT, bits...>::value };\n}; \n```", "```cpp\ntemplate <typename CharT>\nstruct binary_struct<CharT>\n{\n  static constexpr CharT value{ 0 };\n}; \n```", "```cpp\nusing namespace binary;\nusing namespace binary_literals;\nauto b1 = 1010_b8;\nauto b2 = 101010101010_b16;\nauto b3 = 101010101010101010101010_b32; \n```", "```cpp\n// binary literal b8 must be up to 8 digits long\nauto b4 = 0011111111_b8;\n// binary literal b16 must be up to 16 digits long\nauto b5 = 001111111111111111_b16;\n// binary literal b32 must be up to 32 digits long\nauto b6 = 0011111111111111111111111111111111_b32; \n```", "```cpp\n    auto filename {R\"(C:\\Users\\Marius\\Documents\\)\"s};\n    auto pattern {R\"((\\w+)=(\\d+)$)\"s};\n    auto sqlselect {\n      R\"(SELECT *\n      FROM Books\n      WHERE Publisher='Packtpub'\n      ORDER BY PubDate DESC)\"s}; \n    ```", "```cpp\n    auto text{ R\"!!(This text contains both \"( and )\".)!!\"s };\n    std::cout << text << '\\n'; \n    ```", "```cpp\nauto filename1 {R\"(C:\\Users\\Marius\\Documents\\)\"s};\nauto filename2 {R\"(C:\\\\Users\\\\Marius\\\\Documents\\\\)\"s};\n// prints C:\\Users\\Marius\\Documents\\\nstd::cout << filename1 << '\\n';\n// prints C:\\\\Users\\\\Marius\\\\Documents\\\\\nstd::cout << filename2 << '\\n'; \n```", "```cpp\nauto t1{ LR\"(text)\"  };  // const wchar_t*\nauto t2{ u8R\"(text)\" };  // const char* until C++20\n // const char8_t* in C++20\nauto t3{ uR\"(text)\"  };  // const char16_t*\nauto t4{ UR\"(text)\"  };  // const char32_t*\nauto t5{ LR\"(text)\"s  }; // std::wstring\nauto t6{ u8R\"(text)\"s }; // std::string until C++20\n // std::u8string in C++20\nauto t7{ uR\"(text)\"s  }; // std::u16string\nauto t8{ UR\"(text)\"s  }; // std::u32string \n```", "```cpp\ntemplate <typename CharT>\nusing tstring =\n  std::basic_string<CharT, std::char_traits<CharT>,\n                    std::allocator<CharT>>;\ntemplate <typename CharT>\nusing tstringstream =\n  std::basic_stringstream<CharT, std::char_traits<CharT>,\n                          std::allocator<CharT>>; \n```", "```cpp\n    template<typename CharT>\n    inline tstring<CharT> to_upper(tstring<CharT> text)\n    {\n      std::transform(std::begin(text), std::end(text),\n                     std::begin(text), toupper);\n      return text;\n    }\n    template<typename CharT>\n    inline tstring<CharT> to_lower(tstring<CharT> text)\n    {\n      std::transform(std::begin(text), std::end(text),\n                     std::begin(text), tolower);\n      return text;\n    } \n    ```", "```cpp\n    template<typename CharT>\n    inline tstring<CharT> reverse(tstring<CharT> text)\n    {\n      std::reverse(std::begin(text), std::end(text));\n      return text;\n    } \n    ```", "```cpp\n    template<typename CharT>\n    inline tstring<CharT> trim(tstring<CharT> const & text)\n    {\n      auto first{ text.find_first_not_of(' ') };\n      auto last{ text.find_last_not_of(' ') };\n      return text.substr(first, (last - first + 1));\n    }\n    template<typename CharT>\n    inline tstring<CharT> trimleft(tstring<CharT> const & text)\n    {\n      auto first{ text.find_first_not_of(' ') };\n      return text.substr(first, text.size() - first);\n    }\n    template<typename CharT>\n    inline tstring<CharT> trimright(tstring<CharT> const & text)\n    {\n      auto last{ text.find_last_not_of(' ') };\n      return text.substr(0, last + 1);\n    } \n    ```", "```cpp\n    template<typename CharT>\n    inline tstring<CharT> trim(tstring<CharT> const & text,\n                               tstring<CharT> const & chars)\n    {\n      auto first{ text.find_first_not_of(chars) };\n      auto last{ text.find_last_not_of(chars) };\n      return text.substr(first, (last - first + 1));\n    }\n    template<typename CharT>\n    inline tstring<CharT> trimleft(tstring<CharT> const & text,\n                                   tstring<CharT> const & chars)\n    {\n      auto first{ text.find_first_not_of(chars) };\n      return text.substr(first, text.size() - first);\n    }\n    template<typename CharT>\n    inline tstring<CharT> trimright(tstring<CharT> const &text,\n                                    tstring<CharT> const &chars)\n    {\n      auto last{ text.find_last_not_of(chars) };\n      return text.substr(0, last + 1);\n    } \n    ```", "```cpp\n    template<typename CharT>\n    inline tstring<CharT> remove(tstring<CharT> text,\n                                 CharT const ch)\n    {\n      auto start = std::remove_if(\n                      std::begin(text), std::end(text),\n                      [=](CharT const c) {return c == ch; });\n      text.erase(start, std::end(text));\n      return text;\n    } \n    ```", "```cpp\n    template<typename CharT>\n    inline std::vector<tstring<CharT>> split\n      (tstring<CharT> text, CharT const delimiter)\n    {\n      auto sstr = tstringstream<CharT>{ text };\n      auto tokens = std::vector<tstring<CharT>>{};\n      auto token = tstring<CharT>{};\n      while (std::getline(sstr, token, delimiter))\n      {\n        if (!token.empty()) tokens.push_back(token);\n      }\n      return tokens;\n    } \n    ```", "```cpp\nauto ut{ string_library::to_upper(\"this is not UPPERCASE\"s) };\n// ut = \"THIS IS NOT UPPERCASE\"\nauto lt{ string_library::to_lower(\"THIS IS NOT lowercase\"s) };\n// lt = \"this is not lowercase\" \n```", "```cpp\nauto rt{string_library::reverse(\"cookbook\"s)}; // rt = \"koobkooc\" \n```", "```cpp\nauto text1{\"   this is an example   \"s};\nauto t1{ string_library::trim(text1) };\n// t1 = \"this is an example\"\nauto t2{ string_library::trimleft(text1) };\n// t2 = \"this is an example   \"\nauto t3{ string_library::trimright(text1) };\n// t3 = \"   this is an example\" \n```", "```cpp\nauto chars1{\" !%\\n\\r\"s};\nauto text3{\"!!  this % needs a lot\\rof trimming  !\\n\"s};\nauto t7{ string_library::trim(text3, chars1) };\n// t7 = \"this % needs a lot\\rof trimming\"\nauto t8{ string_library::trimleft(text3, chars1) };\n// t8 = \"this % needs a lot\\rof trimming  !\\n\"\nauto t9{ string_library::trimright(text3, chars1) };\n// t9 = \"!!  this % needs a lot\\rof trimming\" \n```", "```cpp\nauto text4{\"must remove all * from text**\"s};\nauto t10{ string_library::remove(text4, '*') };\n// t10 = \"must remove all  from text\"\nauto t11{ string_library::remove(text4, '!') };\n// t11 = \"must remove all * from text**\" \n```", "```cpp\nauto text5{\"this text will be split   \"s};\nauto tokens1{ string_library::split(text5, ' ') };\n// tokens1 = {\"this\", \"text\", \"will\", \"be\", \"split\"}\nauto tokens2{ string_library::split(\"\"s, ' ') };\n// tokens2 = {} \n```", "```cpp\nstd::string text = \"The Lord of the Rings\";\nif(text.starts_with(\"The\")) {}\nif(text.ends_with(\"Rings\")) {}\nif(text.contains(\"Lord\")) {} \n```", "```cpp\n    #include <regex>\n    #include <string>\n    using namespace std::string_literals; \n    ```", "```cpp\n    auto pattern {R\"(^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}$)\"s}; \n    ```", "```cpp\n    auto rx = std::regex{pattern}; \n    ```", "```cpp\n    auto rx = std::regex{pattern, std::regex_constants::icase}; \n    ```", "```cpp\n    auto valid = std::regex_match(\"marius@domain.com\"s, rx); \n    ```", "```cpp\n^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}$ \n```", "```cpp\nbool is_valid_email_format(std::string const & email)\n{\n  auto pattern {R\"(^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}$)\"s};\n  auto rx = std::regex{ pattern };\n  return std::regex_match(email, rx);\n} \n```", "```cpp\nauto ltest = [](std::string const & email)\n{\n  std::cout << std::setw(30) << std::left\n            << email << \" : \"\n            << (is_valid_email_format(email) ?\n                \"valid format\" : \"invalid format\")\n            << '\\n';\n};\nltest(\"JOHN.DOE@DOMAIN.COM\"s);         // valid format\nltest(\"JOHNDOE@DOMAIL.CO.UK\"s);        // valid format\nltest(\"JOHNDOE@DOMAIL.INFO\"s);         // valid format\nltest(\"J.O.H.N_D.O.E@DOMAIN.INFO\"s);   // valid format\nltest(\"ROOT@LOCALHOST\"s);              // invalid format\nltest(\"john.doe@domain.com\"s);         // invalid format \n```", "```cpp\nbool is_valid_email_format(std::string const & email)\n{\n  auto rx = std::regex{\n    R\"(^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}$)\"s,\n    std::regex_constants::icase};\n  return std::regex_match(email, rx);\n} \n```", "```cpp\ntemplate <typename CharT>\nusing tstring = std::basic_string<CharT, std::char_traits<CharT>,\n                                  std::allocator<CharT>>;\ntemplate <typename CharT>\nbool is_valid_format(tstring<CharT> const & pattern,\n                     tstring<CharT> const & text)\n{\n  auto rx = std::basic_regex<CharT>{ pattern, std::regex_constants::icase };\n  return std::regex_match(text, rx);\n} \n```", "```cpp\nbool is_valid_email_format_w(std::wstring const & text)\n{\n  return is_valid_format(\n    LR\"(^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}$)\"s,\n    text);\n}\nauto ltest2 = [](auto const & email)\n{\n  std::wcout << std::setw(30) << std::left\n     << email << L\" : \"\n     << (is_valid_email_format_w(email) ? L\"valid\" : L\"invalid\")\n     << '\\n';\n};\nltest2(L\"JOHN.DOE@DOMAIN.COM\"s);       // valid\nltest2(L\"JOHNDOE@DOMAIL.CO.UK\"s);      // valid\nltest2(L\"JOHNDOE@DOMAIL.INFO\"s);       // valid\nltest2(L\"J.O.H.N_D.O.E@DOMAIN.INFO\"s); // valid\nltest2(L\"ROOT@LOCALHOST\"s);            // invalid\nltest2(L\"john.doe@domain.com\"s);       // valid \n```", "```cpp\nstd::tuple<bool, std::string, std::string, std::string>\nis_valid_email_format_with_result(std::string const & email)\n{\n  auto rx = std::regex{\n    R\"(^([A-Z0-9._%+-]+)@([A-Z0-9.-]+)\\.([A-Z]{2,})$)\"s,\n    std::regex_constants::icase };\n  auto result = std::smatch{};\n  auto success = std::regex_match(email, result, rx);\n  return std::make_tuple(\n    success,\n    success ? result[1].str() : \"\"s,\n    success ? result[2].str() : \"\"s,\n    success ? result[3].str() : \"\"s);\n} \n```", "```cpp\nauto ltest3 = [](std::string const & email)\n{\n  auto [valid, localpart, hostname, dnslabel] =\n    is_valid_email_format_with_result(email);\n  std::cout << std::setw(30) << std::left\n     << email << \" : \"\n     << std::setw(10) << (valid ? \"valid\" : \"invalid\")\n     << \"local=\" << localpart\n     << \";domain=\" << hostname\n     << \";dns=\" << dnslabel\n     << '\\n';\n};\nltest3(\"JOHN.DOE@DOMAIN.COM\"s);\nltest3(\"JOHNDOE@DOMAIL.CO.UK\"s);\nltest3(\"JOHNDOE@DOMAIL.INFO\"s);\nltest3(\"J.O.H.N_D.O.E@DOMAIN.INFO\"s);\nltest3(\"ROOT@LOCALHOST\"s);\nltest3(\"john.doe@domain.com\"s); \n```", "```cpp\n    typedef basic_regex<char>    regex;\n    typedef basic_regex<wchar_t> wregex; \n    ```", "```cpp\n    typedef sub_match<const char *>            csub_match;\n    typedef sub_match<const wchar_t *>         wcsub_match;\n    typedef sub_match<string::const_iterator>  ssub_match;\n    typedef sub_match<wstring::const_iterator> wssub_match; \n    ```", "```cpp\n    typedef match_results<const char *>            cmatch;\n    typedef match_results<const wchar_t *>         wcmatch;\n    typedef match_results<string::const_iterator>  smatch;\n    typedef match_results<wstring::const_iterator> wsmatch; \n    ```", "```cpp\n#remove # to uncomment a line\ntimeout=120\nserver = 127.0.0.1\n#retrycount=3 \n```", "```cpp\nauto text {\n  R\"(\n    #remove # to uncomment a line\n    timeout=120\n    server = 127.0.0.1\n    #retrycount=3\n  )\"s}; \n```", "```cpp\n    #include <regex>\n    #include <string>\n    using namespace std::string_literals; \n    ```", "```cpp\n    auto pattern {R\"(^(?!#)(\\w+)\\s*=\\s*([\\w\\d]+[\\w\\d._,\\-:]*)$)\"s}; \n    ```", "```cpp\n    auto rx = std::regex{pattern}; \n    ```", "```cpp\n    auto match = std::smatch{};\n    if (std::regex_search(text, match, rx))\n    {\n      std::cout << match[1] << '=' << match[2] << '\\n';\n    } \n    ```", "```cpp\n    auto end = std::sregex_iterator{};\n    for (auto it=std::sregex_iterator{ std::begin(text),\n                                       std::end(text), rx };\n         it != end; ++it)\n    {\n      std::cout << '\\'' << (*it)[1] << \"'='\"\n                << (*it)[2] << '\\'' << '\\n';\n    } \n    ```", "```cpp\n    auto end = std::sregex_token_iterator{};\n    for (auto it = std::sregex_token_iterator{\n                      std::begin(text), std::end(text), rx };\n         it != end; ++it)\n    {\n      std::cout << *it << '\\n';\n    } \n    ```", "```cpp\n^(?!#)(\\w+)\\s*=\\s*([\\w\\d]+[\\w\\d._,\\-:]*)$ \n```", "```cpp\nauto end = std::sregex_token_iterator{};\nfor (auto it = std::sregex_token_iterator{ std::begin(text),\n               std::end(text), rx, 1 };\n     it != end; ++it)\n{\n  std::cout << *it << '\\n';\n} \n```", "```cpp\nauto end = std::sregex_token_iterator{};\nfor (auto it = std::sregex_token_iterator{ std::begin(text),\n               std::end(text), rx, -1 };\n     it != end; ++it)\n{\n  std::cout << *it << '\\n';\n} \n```", "```cpp\n    #include <regex>\n    #include <string>\n    using namespace std::string_literals; \n    ```", "```cpp\n    auto text{\"abc aa bca ca bbbb\"s};\n    auto rx = std::regex{ R\"(\\b[a|b|c]{3}\\b)\"s };\n    auto newtext = std::regex_replace(text, rx, \"---\"s); \n    ```", "```cpp\n    auto text{ \"bancila, marius\"s };\n    auto rx = std::regex{ R\"((\\w+),\\s*(\\w+))\"s };\n    auto newtext = std::regex_replace(text, rx, \"$2 $1\"s); \n    ```", "```cpp\nauto text{ \"abc aa bca ca bbbb\"s };\nauto rx = std::regex{ R\"(\\b[a|b|c]{3}\\b)\"s };\nauto newtext = std::regex_replace(text, rx, \"---\"s,\n                 std::regex_constants::format_first_only); \n```", "```cpp\nauto text{\"this is a example with a error\"s};\nauto rx = std::regex{R\"(\\ba ((a|e|i|u|o)\\w+))\"s};\nauto newtext = std::regex_replace(text, rx, \"an $1\"); \n```", "```cpp\nauto text{\"today is 1.06.2023!!\"s};\nauto rx = std::regex{R\"((\\d{1,2})(\\.|-|/)(\\d{1,2})(\\.|-|/)(\\d{4}))\"s};\n// today is 2023.06.1!!\nauto newtext1 = std::regex_replace(text, rx, R\"($5$4$3$2$1)\");\n// today is [today is ][1.06.2023][!!]!!\nauto newtext2 = std::regex_replace(text, rx, R\"([$`][$&][$'])\"); \n```", "```cpp\nstd::string_view get_filename(std::string_view str)\n{\n  auto const pos1 {str.find_last_of('')};\n  auto const pos2 {str.find_last_of('.')};\n  return str.substr(pos1 + 1, pos2 - pos1 - 1);\n}\nchar const file1[] {R\"(c:\\test\\example1.doc)\"};\nauto name1 = get_filename(file1);\nstd::string file2 {R\"(c:\\test\\example2)\"};\nauto name2 = get_filename(file2);\nauto name3 = get_filename(std::string_view{file1, 16}); \n```", "```cpp\nstd::string get_filename(std::string const & str)\n{\n  auto const pos1 {str.find_last_of('\\\\')};\n  auto const pos2 {str.find_last_of('.')};\n  return str.substr(pos1 + 1, pos2 - pos1 - 1);\n}\nauto name1 = get_filename(R\"(c:\\test\\example1.doc)\"); // example1\nauto name2 = get_filename(R\"(c:\\test\\example2)\");     // example2\nif(get_filename(R\"(c:\\test\\_sample_.tmp)\").front() == '_') {} \n```", "```cpp\ntypedef basic_string_view<char>     string_view;\ntypedef basic_string_view<wchar_t>  wstring_view;\ntypedef basic_string_view<char16_t> u16string_view;\ntypedef basic_string_view<char32_t> u32string_view; \n```", "```cpp\nstd::string_view sv{ \"demo\" };\nstd::string s{ sv }; \n```", "```cpp\nstd::string_view trim_view(std::string_view str)\n{\n  auto const pos1{ str.find_first_not_of(\" \") };\n  auto const pos2{ str.find_last_not_of(\" \") };\n  str.remove_suffix(str.length() - pos2 - 1);\n  str.remove_prefix(pos1);\n  return str;\n}\nauto sv1{ trim_view(\"sample\") };\nauto sv2{ trim_view(\"  sample\") };\nauto sv3{ trim_view(\"sample  \") };\nauto sv4{ trim_view(\"  sample  \") };\nstd::string s1{ sv1 };\nstd::string s2{ sv2 };\nstd::string s3{ sv3 };\nstd::string s4{ sv4 }; \n```", "```cpp\n    auto text = std::format(\"{} is {}\", \"John\", 42); \n    ```", "```cpp\n    auto text = std::format(\"{0} is {1}\", \"John\", 42); \n    ```", "```cpp\n    auto text = std::format(\"{0} hex is {0:08X}\", 42);\n    auto now = std::chrono::system_clock::now();\n    auto date = std::format(\"Today is {:%Y-%m-%d}\", now);\n    std::cout << date << '\\n'; \n    ```", "```cpp\n    std::vector<char> buf;\n    std::format_to(std::back_inserter(buf), \"{} is {}\", \"John\", 42); \n    ```", "```cpp\n    auto size = std::formatted_size(\"{} is {}\", \"John\", 42);\n    std::vector<char> buf(size);\n    std::format_to(buf.data(), \"{} is {}\", \"John\", 42); \n    ```", "```cpp\n    char buf[100];\n    auto result = std::format_to_n(buf, sizeof(buf), \"{} is {}\", \"John\", 42); \n    ```", "```cpp\n    std::print(\"The answer is {}\", 42); \n    ```", "```cpp\n    std::println(\"The answer is {}\", 42);\n    std::FILE* stream = std::fopen(\"demo.txt\", \"w\");\n    if (stream)\n    {\n       std::println(stream, \"The answer is {}\", 42);\n       std::fclose(stream);\n    } \n    ```", "```cpp\ntemplate<class... Args>\nstd::string format(std::string_view fmt, const Args&... args);\ntemplate<class OutputIt, class... Args>\nOutputIt format_to(OutputIt out,\n                   std::string_view fmt, const Args&... args);\ntemplate<class OutputIt, class... Args>\nstd::format_to_n_result<OutputIt>\nformat_to_n(OutputIt out, std::iter_difference_t<OutputIt> n,\n            std::string_view fmt, const Args&... args); \n```", "```cpp\nfill-and-align(optional) sign(optional) #(optional) 0(optional) width(optional) precision(optional) L(optional) type(optional) \n```", "```cpp\n    auto t1 = std::format(\"{:5}\", 42);    // \"   42\"\n    auto t2 = std::format(\"{:5}\", 'x');   // \"x    \"\n    auto t3 = std::format(\"{:*<5}\", 'x'); // \"x****\"\n    auto t4 = std::format(\"{:*>5}\", 'x'); // \"****x\"\n    auto t5 = std::format(\"{:*^5}\", 'x'); // \"**x**\"\n    auto t6 = std::format(\"{:5}\", true);  // \"true \" \n    ```", "```cpp\n    auto t7 = std::format(\"{0:},{0:+},{0:-},{0: }\", 42);\n    // \"42,+42,42, 42\"\n    auto t8 = std::format(\"{0:},{0:+},{0:-},{0: }\", -42);\n    // \"-42,-42,-42,-42\" \n    ```", "```cpp\nauto t9  = std::format(\"{:+05d}\", 42); // \"+0042\"\nauto t10 = std::format(\"{:#05x}\", 42); // \"0x02a\"\nauto t11 = std::format(\"{:<05}\", -42); // \"-42  \" \n```", "```cpp\nfill-and-align(optional) width(optional) precision(optional) chrono-spec(optional) \n```", "```cpp\nstd::println(\"The answer is {}\", 42);\nstd::println(stdout, \"The answer is {}\", 42); \n```", "```cpp\nstd::println(\"The answer is {}\", 42);\nstd::print(\"The answer is {}\\n\", 42); \n```", "```cpp\nstruct employee\n{\n   int         id;\n   std::string firstName;\n   std::string lastName;\n}; \n```", "```cpp\ntemplate <>\nstruct std::formatter<employee>\n{\n   constexpr auto parse(format_parse_context& ctx)\n {\n      return ctx.begin();\n   }\n   auto format(employee const & e, format_context& ctx) const \n {\n      return std::format_to(ctx.out(),\n                            \"[{}] {} {}\",\n                            e.id, e.firstName, e.lastName);\n   }\n}; \n```", "```cpp\nemployee e{ 42, \"John\", \"Doe\" };\nauto s1 = std::format(\"{}\", e);   // [42] John Doe\nauto s2 = std::format(\"{:L}\", e); // error \n```", "```cpp\ntemplate<>\nstruct std::formatter<employee>\n{\n   constexpr auto parse(std::format_parse_context& ctx)\n {\n      auto iter = begin(ctx);\n      while(iter != ctx.end() && *iter != '}')\n      {\n         switch (*iter)\n         {\n         case 'L': lexicographic_order = true; break;\n         case 'u': uppercase = true; break;\n         case 'l': lowercase = true; break;\n         }\n         ++iter;\n      }\n      return iter;\n   }\n   auto format(employee const& e, std::format_context& ctx) const\n {\n      if (lexicographic_order)\n         return std::format_to(ctx.out(), \n                               \"[{}] {}, {}\", \n                               e.id, \n                               text_format(e.lastName), \n                               text_format(e.firstName));\n      return std::format_to(ctx.out(), \n                            \"[{}] {} {}\", \n                            e.id, \n                            text_format(e.firstName),\n                            text_format(e.lastName));\n   }\nprivate:\n   bool lexicographic_order = false;\n   bool uppercase = false;\n   bool lowercase = false;\n\n   constexpr std::string text_format(std::string text) const\n {\n      if(lowercase)\n         std::transform(text.begin(), text.end(), text.begin(),                         ::tolower);\n      else if(uppercase)\n         std::transform(text.begin(), text.end(), text.begin(),                         ::toupper);\n      return text;\n   }\n}; \n```", "```cpp\nauto s1 = std::format(\"{}\", e);     // [42] John Doe\nauto s2 = std::format(\"{:L}\", e);   // [42] Doe, John\nauto s3 = std::format(\"{:u}\", e);   // [42] JOHN DOE\nauto s4 = std::format(\"{:lL}\", e);  // [42] doe, john\n// uppercase ignored when lowercase also specified\nauto s5 = std::format(\"{:ulL}\", e); // [42] doe, john \n```", "```cpp\nauto s6 = std::format(\"{0} = {0:L}\", e);\n// [42] John Doe = [42] Doe, John \n```", "```cpp\nauto s7 = std::format(\"{:A}\", e);   // [42] John Doe \n```", "```cpp\ntemplate<>\nstruct std::formatter<employee> : std::formatter<char const*>\n{\n   auto format(employee const& e, std::format_context& ctx) const\n {\n      return std::format_to(ctx.out(), \"[{}] {} {}\",\n                            e.id, e.firstName, e.lastName);\n   }\n}; \n```"]