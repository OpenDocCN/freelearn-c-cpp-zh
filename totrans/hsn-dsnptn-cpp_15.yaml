- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Policy-Based Design
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Policy-based design is one of the most well-known C++ patterns. Since the introduction
    of the standard template library in 1998, few new ideas have been more influential
    on the way we design C++ programs than the invention of policy-based design.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: A policy-based design is all about flexibility, extensibility, and customization.
    It is a way to design software that can evolve and can be adapted to the changing
    needs, some of which could not even be anticipated at the time when the initial
    design was conceived. A well-designed policy-based system can remain unchanged
    at the structural level for many years, and serve the changing needs and new requirements
    without compromise.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, it is also a way to build software that could do all of those
    things if only there was someone who could figure out how it works. The aim of
    this chapter is to teach you to design and understand the systems of the former
    kind while avoiding the excesses that lead to the disasters of the latter one.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Strategy pattern and policy-based design
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compile time policies in C++
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementations of policy-based classes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Guidelines for the use of policies
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The example code for this chapter can be found at the following GitHub link:
    [https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP_Second_Edition/tree/master/Chapter15](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP_Second_Edition/tree/master/Chapter15).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Strategy pattern and policy-based design
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The classic Strategy pattern is a behavioral design pattern that enables the
    runtime selection of a specific algorithm for a particular behavior, usually from
    a predefined family of algorithms. This pattern is also known as the *policy pattern*;
    the name predates its application to generic programming in C++. The aim of the
    Strategy pattern is to allow for more flexibility in the design.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: In the classic object-oriented Strategy pattern, the decision about which specific
    algorithm to use is deferred until runtime.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: As is the case with many classic patterns, the generic programming in C++ applies
    the same approach to algorithm selection at compile time - it allows for compile-time
    customization of specific aspects of the system behavior by selecting from a family
    of related, compatible algorithms. We will now learn the basics of implementing
    classes with policies in C++, then proceed to study more complex and varied approaches
    to policy-based design.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Foundations of policy-based design
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Strategy pattern should be considered whenever we design a system that does
    certain operations, but the exact implementation of these operations is uncertain,
    varied, or can change after the system is implemented - in other words, when we
    know the answer to *what the system must do*, but not *how*. Similarly, the compile-time
    strategy (or a policy) is a way to implement a class that has a specific function
    (*what*), but there is more than one way to implement that function (*how*).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, we will design a smart pointer class to illustrate
    different ways to use policies. A smart pointer has many other required and optional
    features besides policies, and we will not cover all of them - for a complete
    implementation of a smart pointer, you will be referred to such examples as the
    C++ standard smart pointers (`unique_ptr` and `shared_ptr`), Boost smart pointers,
    or the Loki smart pointer ([http://loki-lib.sourceforge.net/](http://loki-lib.sourceforge.net/)).
    The material presented in this chapter will help you to understand the choices
    made by the implementers of these libraries, as well as how to design their own
    policy-based classes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'A very minimal initial implementation of a smart pointer may look like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This pointer has a constructor from the raw pointer of the same type and the
    usual (for a pointer) operators, that is, `*` and `->`. The most interesting part
    here is the destructor - when the pointer is destroyed, it automatically deletes
    the object as well (it is not necessary to check the pointer for the `null` value
    before deleting it; the `operator delete` is required to accept a null pointer
    and do nothing). It follows, therefore, that the expected use of this smart pointer
    is as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is a basic example of the RAII class. The RAII object - the smart pointer,
    in our case - owns the resource (the constructed object) and releases (deletes)
    it when the owning object itself is deleted. The common applications, which were
    considered in detail in [*Chapter 5*](B19262_05.xhtml#_idTextAnchor199), *A Comprehensive
    Look at RAII*, focus on ensuring that the object that was constructed in the scope
    is deleted when the program exits this scope, no matter how the latter is accomplished
    (for example, if an exception is thrown somewhere in the middle of the code, the
    RAII destructor guarantees that the object is destroyed).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'Two more member functions of the smart pointer are noted, not for their implementation,
    but for their absence - the pointer is made non-copyable as both its copy constructor
    and the assignment operator are disabled. This detail, which is sometimes overlooked,
    is of crucial importance for any RAII class - since the destructor of the pointer
    deletes the owned object, there should never be two smart pointers that point
    to, and will attempt to delete, the same object. On the other hand, moving the
    pointer is a valid operation: it transfers the ownership from the old pointer
    to the new one. Move constructor is necessary for factory functions to work (at
    least prior to C++17).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: The pointer we have here is functional, but the implementation is constraining.
    In particular, it can own and delete only an object that was constructed with
    the standard `operator new`, and only a single object. While it could capture
    a pointer that was obtained from a custom `operator new` or a pointer to an array
    of elements, it does not properly delete such objects.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: We could implement a different smart pointer for objects that are created on
    a user-defined heap, and another one for objects that are created in client-managed
    memory, and so on, one for every type of object construction with its corresponding
    way of deletion. Most of the code for these pointers would be duplicated - they
    are all pointers, and the entire pointer-like API will have to be copied into
    every class. We can observe that all of these different classes are, fundamentally,
    of the same kind - the answer to the question *what is this type?* is always the
    same - *it’s a* *smart pointer*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'The only difference is in how the deletion is implemented. This common intent
    with a difference in one particular aspect of the behavior suggests the use of
    the Strategy pattern. We can implement a more general smart pointer where the
    details of how to handle the deletion of the object are delegated to one of any
    number of deletion policies:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The deletion policy is an additional template parameter, and an object of the
    type of the deletion policy is passed to the constructor of the smart pointer
    (by default, such an object is default-constructed). The deletion policy object
    is stored in the smart pointer and is used in its destructor to delete the object
    that’s being pointed to by the pointer.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'Care must be taken when implementing copy and move constructors for such policy-based
    classes: it is very easy to forget that the policy also needs to be moved or copied
    to the new object. In our case, copying is disabled, but move operations are supported.
    They must move not just the pointer itself but also the policy object. We do this
    as we would any other class: by moving the object (moving pointers is more involved
    since they are built-in types, but all classes are assumed to handle their own
    move operations correctly or delete them). In the assignment operator, remember
    that the current object owned by the pointer must be deleted by the corresponding,
    i.e. old, policy; only then do we move the policy from the right-hand side of
    the assignment.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'The only requirement on the deletion policy type is that it should be callable
    - the policy is invoked, just like a function with one argument, and the pointer
    to the object that must be deleted. For example, the behavior of our original
    pointer that called `operator delete` on the object can be replicated with the
    following deletion policy:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To use this policy, we must specify its type when constructing the smart pointer,
    and, optionally, pass an object of this type to the constructor, although in this
    case, the default constructed object will work fine:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In C++17, the **constructor template argument deduction (CTAD)** can usually
    deduce the template parameters:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If the deletion policy does not match the object type, a syntax error will
    be reported for the invalid call to `operator()`. This is usually undesirable:
    the error message is not particularly friendly, and, in general, the requirements
    on the policy have to be inferred from the use of the policy throughout the template
    (our policy has only one requirement, but this is our first and simplest policy).
    A good practice for writing classes with policies is to verify and document all
    requirements on the policy explicitly and in one place. In C++20, this can be
    done with concepts:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Before C++20, we can accomplish the same result with compile-time asserts:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Even in C++20, you may prefer the assert error messages. Both options accomplish
    the same goal: they verify that the policies meet all requirements and also express
    these requirements in a readable way and in one place in the code. It is up to
    you whether to include “movable” in these requirements: strictly speaking, the
    policy needs to be movable only if you need to move the smart pointer itself.
    It is reasonable to allow non-movable policies and require move operations only
    if they are needed.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'Other deletion policies are needed for objects that were allocated in different
    ways. For example, if an object is created on a user-given heap object whose interface
    includes the member functions `allocate()` and `deallocate()` to, respectively,
    allocate and free memory, we can use the following heap deletion policy:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'On the other hand, if an object is constructed in some memory that is managed
    separately by the caller, then only the destructor of the object needs to be called:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We mentioned earlier that, because the policy is used as a callable entity,
    `deletion_policy_(p_)`, it can be of any type that can be called like a function.
    That includes the actual function:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'A template instantiation is also a function and can be used in the same way:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Of all the possible deletion policies, one is often the most commonly used.
    In most programs, it will likely be deletion by the default `operator delete`
    function. If this is so, it makes sense to avoid specifying this one policy every
    time it’s used and make it the default:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, our policy-based smart pointer can be used in exactly the same way as
    the original version, with only one deletion option:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, the second template parameter is left to its default value, `DeleteByOperator<C>`,
    and a default constructed object of this type is passed to the constructor as
    the default second argument.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, I must caution you against a subtle mistake that could be made
    when implementing such policy-based classes. Note that the policy object is captured
    in the constructor of the smart pointer by a `const` reference:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `const` reference here is important since a non-const reference cannot
    be bound to a temporary object (we will consider the r-value references later
    in this section). However, the policy is stored in the object itself by value,
    and, thus, a copy of the policy object must be made:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'It may be tempting to avoid the copy and capture the policy by reference in
    the smart pointer as well:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In some cases, this will even work, for example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'However, it won’t work for the default way to create smart pointers or any
    other smart pointer that is initialized with a temporary policy object:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This code will compile. Unfortunately, it is incorrect - the temporary `DeleteByOperator<C>`
    object is constructed just before the `SmartPtr` constructor is called, but is
    destroyed at the end of the statement. The reference inside the `SmartPtr` object
    is left dangling. At first glance, this should not surprise anyone - of course,
    the temporary object does not outlive the statement in which it was created -
    it is deleted at the closing semicolon at the latest. A reader who is more versed
    in subtle language details may ask - *doesn’t the standard specifically extend
    the lifetime of a temporary bound to a constant reference?* Indeed, it does; for
    example:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this code fragment, the temporary object `C()` is not deleted at the end
    of the sentence, but only at the end of the lifetime of the reference to which
    it is bound. So, why didn’t the same trick work for our deletion policy object?
    The answer is, it sort of did - the temporary object that was created when the
    argument to the constructor was evaluated and bound to the `const` reference argument
    was not destroyed for the lifetime of that reference, which is the duration of
    the constructor call. Actually, it would not have been destroyed anyway - all
    temporary objects that are created during the evaluation of the function arguments
    are deleted at the end of the sentence containing the function call, that is,
    at the closing semicolon. The function, in our case, is the constructor of the
    object, and so the lifetime of the temporaries spans the entire call to the constructor.
    It does not, however, extend to the lifetime of the object - the `const` reference
    member of the object is not bound to the temporary object, but to the constructor
    parameter, which itself is a `const` reference.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: The lifetime extension works only once - the reference bound to a temporary
    object extends its lifetime. Another reference that’s bound to the first one does
    nothing else and may be left dangling if the object is destroyed (the **address
    sanitizer** (**ASAN**) of GCC and CLANG helps to find such bugs). Therefore, if
    the policy object needs to be stored as a data member of the smart pointer, it
    has to be copied.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, policy objects are small, and copying them is trivial. However, sometimes,
    a policy object may have a non-trivial internal state that is expensive to copy.
    You could also imagine a policy object that is non-copyable. In these cases, it
    may make sense to move the argument object into the data member object. This is
    easy to do if we declare an overload that is similar to a move constructor:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As we said, the policy objects are usually small, so copying them is rarely
    an issue. If you do need both constructors, make sure that only one has default
    arguments, so the call to a constructor with no arguments or with no policy argument
    is not ambiguous.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: We now have a smart pointer class that has been implemented once, but whose
    deletion implementation can be customized at compile time by specifying the deletion
    policy. We could even add a new deletion policy that did not exist at the time
    the class was designed, and it will work as long as it conforms to the same calling
    interface. Next, we will consider different ways to implement policy objects.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Implementation of policies
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we learned how to implement the simplest policy object.
    The policy can be of any type as long as it conforms to the interface convention,
    and is stored in the class as a data member. The policy object is most commonly
    generated by a template; however, it could be a regular, non-template, object
    that’s specific to a particular pointer type, or even a function. The use of the
    policy was limited to a specific behavioral aspect, such as the deletion of the
    object owned by the smart pointer.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several ways in which such policies can be implemented and used.
    First of all, let’s review the declaration of a smart pointer with a deletion
    policy:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, let’s look at how we can construct a smart pointer object:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'One disadvantage of this design jumps out at once - the type `C` is mentioned
    four times in the definition of the object `p` - it must be consistent in all
    four places, or the code will not compile. C++17 allows us to simplify the definition
    somewhat:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, the constructor is used to deduce the parameters of the `class` template
    from the constructor arguments, in a manner similar to that of function templates.
    There are still two mentions of the type `C` that must be consistent.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'One alternative implementation that works for stateless policies as well as
    for policy objects whose internal state does not depend on the types of the primary
    template (in our case, the type `T` of the `SmartPtr` template) is to make the
    policy itself a non-template object but give it a template member function. For
    example, the `DeleteByOperator` policy is stateless (the object has no data members)
    and can be implemented without a class template:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This is a non-template object, so it does not need a type parameter. The member
    function template is instantiated on the type of object that needs to be deleted
    - the type is deduced by the compiler. Since the type of the policy object is
    always the same, we do not have to worry about specifying consistent types when
    creating the smart pointer object:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This object can be used by our smart pointer as it is, with no changes to the
    `SmartPtr` template, although we may want to change the default template argument:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'A more complex policy, such as the heap deletion policy, can still be implemented
    using this approach:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This policy has an internal state - the reference to the heap - but nothing
    in this policy object depends on the type `T` of the object we need to delete,
    except for the `operator()` member function. Therefore, the policy does not need
    to be parameterized by the object type.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Since the main template, `SmartPtr`, did not have to be changed when we converted
    our policies from class templates to non-template classes with template member
    functions, there is no reason why we cannot use both types of policies with the
    same class. Indeed, any of the template class policies from the previous subsection
    would still work, so we can have some deletion policies implemented as classes
    and others as class templates. The latter is useful when the policy has data members
    whose type depends on the object type of the smart pointer.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'If the policies are implemented as class templates, we have to specify the
    correct type to instantiate the policy for use with each specific policy-based
    class. In many cases, this is a very repetitive process - the same type is used
    to parameterize the main template and its policies. We can get the compiler to
    do this job for us if we use the entire template and not its particular instantiation
    as a policy:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Note the syntax for the second template parameter - `template <typename> class
    DeletionPolicy`. This is known as a *template template* parameter - the parameter
    of a template is itself a template. The `class` keyword is necessary in C++14
    and earlier; in C++17, it can be replaced with `typename`. To use this parameter,
    we need to instantiate it with some type; in our case, it is the main template
    type parameter `T`. This ensures the consistency of the object type in the primary
    smart pointer template and its policies, although the constructor argument still
    must be constructed with the correct type:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Again, in C++17, the class template parameters can be deduced by the constructor;
    this works for template template parameters as well:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The template template parameters seem like an attractive alternative to the
    regular type parameters when the types are instantiated from a template anyway.
    Why don’t we always use them? First of all, as you can see, they are somewhat
    less flexible than template class parameters: they save typing in the common case
    when the policy is a template with the same first argument as the class itself,
    but they don’t work in any other case (the policy may be a non-template or a template
    that requires more than one argument). The other issue is that, as written, the
    template template parameter has one significant limitation - the number of template
    parameters has to match the specification precisely, including the default arguments.
    In other words, let’s say I have the following template:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This template cannot be used as a parameter of the preceding smart pointer
    - it has two template parameters, while we only specified only one in the declaration
    of `SmartPtr` (a parameter with a default value is still a parameter). This limitation
    is easy to work around: all we have to do is define the template template parameter
    as a variadic template:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now the deletion policy template can have any number of type parameters as long
    as they have default values (`DeletionPolicy<T>` is what we use in the `SmartPtr`
    and it has to compile). In contrast, we can use an instantiation of the `DeleteHeap`
    template for a smart pointer where the `DeletionPolicy` is a type parameter, not
    a template template parameter - we just need a class, and `DeleteHeap<int, MyHeap>`
    will do as good as any.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have always captured the policy object as a data member of the policy-based
    class. This approach to integrating classes into a larger class is known as **composition**.
    There are other ways in which the primary template can get access to the customized
    behavior algorithms provided by the policies, which we will consider next.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Use of policy objects
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All of our examples until now have stored the policy object as a data member
    of the class. This is generally the preferred way of storing the policies, but
    it has one significant downside - a data member always has a non-zero size. Consider
    our smart pointer with one of the deletion policies:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Note that the policy object has no data members. However, the size of the object
    is not zero, but one byte (we can verify that by printing the value of `sizeof(DeleteByOperator<int>)`).
    This is necessary because every object in a C++ program must have a unique address:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: When two objects are laid out consecutively in memory, the difference between
    their addresses is the size of the first object (plus padding, if necessary).
    To prevent both the `d1` and `d2` objects from residing at the same address, the
    standard mandates that their size is at least one byte.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: When used as a data member of another class, an object will occupy at least
    as much space as its size requires, which in our case, is one byte. Assuming that
    the pointer takes 8 bytes, the entire object is, therefore, 9 bytes long. But
    the size of an object also has to be padded to the nearest value that meets the
    alignment requirements - if the address of the pointer has to be aligned on 8
    bytes, the object can be either 8 bytes or 16 bytes, but not in-between. So, adding
    an empty policy object to the class ends up changing its size from 8 bytes to
    16 bytes. This is purely a waste of memory and is often undesirable, especially
    for objects that are created in large numbers, such as pointers. It is not possible
    to coax the compiler into creating a data member of zero size; the standard forbids
    it. But there is another way in which policies can be used without the overhead.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'The alternative to composition is inheritance - we can use the policy as a
    base class for the primary class:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This approach relies on a particular optimization - if a base class is empty
    (has no non-static data members), it can be completely optimized out of the layout
    of the derived class. This is known as the `SmartPtr` class is only as large as
    necessary to hold its data members - in our case, 8 bytes.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: When using inheritance for policies, the choice must be made between public
    or private inheritance. Usually, the policies are used to provide an implementation
    for a particular aspect of behavior. Such inheritance for implementation is expressed
    through private inheritance. In some cases, a policy may be used to change the
    public interface of the class; in this case, public inheritance should be used.
    For the deletion policy, we are not changing the interface of the class - the
    smart pointer always deletes the object at the end of its life; the only question
    is how. Therefore, the deletion policy should use private inheritance.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: While the deletion policy using the `operator delete` is stateless, some policies
    have data members that must be preserved from the object given to the constructor.
    Therefore, in general, the base class policy should be initialized from the constructor
    argument by copying or moving it into the base class, similarly to the way we
    initialized the data members. The base classes are always initialized on the member
    initialization list before the data members of the derived class. Finally, the
    `base_type::function_name()` syntax can be used to call a member function of a
    base class; in our case, `DeletionPolicy::operator()(p_)`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance or composition are the two choices for integrating the policy class
    into the primary class. In general, the composition should be preferred, unless
    there is a reason to use inheritance. We have already seen one such reason - the
    empty base class optimization. Inheritance is also a necessary choice if we want
    to affect the public interface of the class.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'Our smart pointer is, so far, missing several important features that are commonly
    found in most smart pointer implementations. One such feature is the ability to
    release the pointer, that is, to prevent the automatic destruction of the object
    from taking place. This can be useful if, in some cases, the object is destroyed
    by some other means, or, alternatively, if the lifetime of the object needs to
    be extended and its ownership is passed to another resource-owning object. We
    can easily add this feature to our smart pointer:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, we can call `p.release()` on our smart pointer, and the destructor will
    do nothing. We can hard-code the release feature into the pointer, but sometimes
    you may want to enforce the deletion as it is done in the pointer, with no release.
    This calls for making the release feature optional, controlled by another policy.
    We can add a `ReleasePolicy` template parameter to control whether the `release()`
    member function is present, but what should it do? We could, of course, move the
    implementation of `SmartPtr::release()` into the policy:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, the `SmartPtr` implementation only has to call `ReleasePolicy::release(p_)`
    to delegate the appropriate handling of `release()` to the policy. But what is
    the appropriate handling if we do not want to support the release functionality?
    Our no-release policy can simply do nothing, but this is misleading - the user
    has the expectation that, if `release()` was called, the object would not be destroyed.
    We could assert at runtime and terminate the program. This converts a logic error
    on the part of the programmer - trying to release a no-release smart pointer -
    into a runtime error. The best way would be for the `SmartPtr` class to not have
    the `release()` member function at all if it is not wanted. This way, the incorrect
    code would be impossible to compile. The only way to do this is to make the policy
    inject a new public member function into the public interface of the primary template.
    This can be accomplished using public inheritance:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now, if the release policy has a public member function called `release()`,
    then so does the `SmartPtr` class.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'This solves the interface problem. Now, there is a small matter of implementation.
    The `release()` member function has now moved into the policy class, but it must
    operate on the data member `p_` of the parent class. One way to do this would
    be to pass a reference to this pointer from the derived class to the base policy
    class during construction. This is an ugly implementation - it wastes 8 bytes
    of memory to store a reference to a data member that is almost “right there,”
    which is stored in the derived class right next to the base class itself. A much
    better way is to cast from the base class to the correct derived class. Of course,
    for this to work, the base class needs to know what the correct derived class
    is. The solution to this problem is the **Curiously Recurring Template Pattern**
    (**CRTP**) that we studied in this book: the policy should be a template (so we
    will need a template template parameter) that is instantiated on the derived class
    type.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'This way, the `SmartPtr` class is both the derived class of the release policy
    and the template parameter of it:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note that the `ReleasePolicy` template is specialized with the concrete instantiation
    of the `SmartPtr` template, including all its policies, and including the `ReleasePolicy`
    itself.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the release policy knows the type of the derived class and can cast itself
    to that type. This case is always safe because the correct derived class is guaranteed
    by construction:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The template parameter `P` will be substituted with the type of the smart pointer.
    Once the smart pointer publicly inherits from the release policy, the public member
    function, `release()`, of the policy is inherited and becomes a part of the smart
    pointer public interface.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'The last detail concerning the implementation of the release policy has to
    do with the access. As we’ve written so far, the data member `p_` is private in
    the `SmartPtr` class and cannot be accessed by its base classes directly. The
    solution to this is to declare the corresponding base class to be a friend of
    the derived class:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note that inside the body of the `SmartPtr` class, we do not need to repeat
    all the template parameters. The shorthand `SmartPtr` refers to the currently
    instantiated template. This does not extend to the part of the class declaration
    before the opening brace of the class, so we had to repeat the template parameters
    when specifying the policy as a base class.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'The no-release policy is just as easy to write:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: There is no `release()` function here, so an attempt to call `release()` on
    a smart pointer with this policy will not compile. This solves our stated requirement
    to have a `release()` public member function only when it makes sense to call
    one. The policy-based design is a complex pattern, and it is rare to be limited
    to just one way to do something. There is another way to accomplish the same objective,
    we are going to study it later in this chapter, in the section, *Using policies
    to control the* *public interface*.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: There is yet another way in which policy objects can sometimes be used. This
    applies only to policies that have no internal state in any version of the policy,
    by design. For example, our deletion policies are sometimes stateless, but the
    one with the reference to the caller’s heap is not, so this is a policy that is
    not always stateless. The release policy can always be considered stateless; there
    is no reason for us to add a data member to it, but it is constrained to be used
    through public inheritance because its primary effect is to inject a new public
    member function.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider another aspect of behavior that we may want to customize - debugging
    or logging. For debugging purposes, it may be convenient to print when an object
    is owned by a smart pointer and when it is deleted. We could add a debugging policy
    to the smart pointer to support this. The debug policy has to do only one thing,
    and that is to print something when a smart pointer is constructed or destroyed.
    It does not need access to the smart pointer if we pass the value of the pointer
    to the printing function. Therefore, we can make the print functions static in
    the debug policy and not store this policy in the smart pointer class at all:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'For simplicity, we have omitted the release policy, but multiple policies are
    easy to combine. The debugging policy implementation is straightforward:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We have chosen to implement the policy as a non-template class with template
    static member functions. Alternatively, we could have implemented it as a template,
    parametrized with the object type `T`. The no-debug version of the policy, which
    is the default, is even simpler. It must have the same functions defined, but
    they don’t do anything:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We can expect the compiler to inline the empty template functions at the call
    site and optimize the entire call away since no code needs to be generated.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Note that by choosing this implementation of policies, we made a somewhat restrictive
    design decision - all versions of the debug policy must be stateless. We may,
    in time, come to regret this decision if we need to, for example, store a custom
    output stream inside a debug policy, instead of the default `std::cout`. But even
    in that case, only the implementation of the smart pointer class will have to
    change - the client code will continue to work with no changes.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: We have considered three different ways to incorporate the policy objects into
    the policy-based class - by composition, by inheritance (public or private), and
    by compile-time incorporation only, where the policy object does not need to be
    stored inside the main object at runtime. We will now move on to more advanced
    techniques for policy-based design.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Advanced policy-based design
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The techniques we have introduced in the previous section form the foundation
    of policy-based design - policies can be classes, template instantiations, or
    templates (used by template template parameters). The policy classes can be composed,
    inherited, or used statically at compile time. If a policy needs to know the type
    of the primary policy-based class, the CRTP can be used. The rest is largely variations
    on the same theme, as well as tricky ways to combine several techniques to accomplish
    something new. We will now consider some of these more advanced techniques.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Policies for constructors
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Policies can be used to customize almost any aspect of the implementation, as
    well as to alter the class interface. However, there are unique challenges that
    arise when we attempt to customize class constructors using policies.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let’s consider another limitation of our current smart pointer.
    As it stands so far, the object owned by the smart pointer is always deleted when
    the smart pointer is deleted. If the smart pointer supports release, then we can
    call the `release()` member function and be wholly responsible for the deletion
    of the object. But how are we going to ensure this deletion? The most likely way
    is, we will let another smart pointer own it:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This approach is verbose and error-prone - we temporarily let two pointers own
    the same object. If something were to happen at this moment that causes both pointers
    to be deleted, we would destroy the same object twice. We also have to remember
    to always release one of these pointers, but only one. We should take the higher-level
    view of the problem - we are trying to pass the ownership of the object from one
    smart pointer to another.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'The better way to do this is by moving the first pointer into the second:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now, the first pointer is left in the moved-from state, which we can define
    (the only requirement is that the destructor call must be valid). We choose to
    define it to be a pointer that does not own any object, that is, a pointer in
    the released state. The second pointer receives the ownership of the object and
    will delete it in due time.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'To support this functionality, we must implement the move constructor. However,
    there may be a reason to sometimes prevent the transfer of ownership. Therefore,
    we may want to have both movable and non-movable pointers. This calls for yet
    another policy to control whether moving is supported:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'For simplicity, we have reverted to just one other policy - the deletion policy.
    The other policies we have considered can be added alongside the new `MovePolicy`.
    The deletion policy can be implemented in any of the ways we have learned already.
    Since it is likely to benefit from the empty base optimization, we will stay with
    the inheritance-based implementation for it. The move policy can be implemented
    in several different ways, but inheritance is probably the easiest:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: With both policies integrated using private inheritance, we now have a derived
    object with several base classes. Such multiple inheritance is fairly common in
    policy-based design in C++, and should not alarm you. This technique is sometimes
    known as *mix-in* since the implementation of the derived class is *mixed* from
    the pieces provided by the base classes. In C++, the term *mix-in* is also used
    to refer to a totally different inheritance scheme that is related to the CRTP,
    so the use of this term often creates confusion (in most object-oriented languages,
    *mix-in* unambiguously refers to the application of multiple inheritance that
    we can see here).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'The new feature in our smart pointer class is the move constructor. The move
    constructor is unconditionally present in the `SmartPtr` class. However, its implementation
    requires that all base classes be movable. This gives us a way to disable move
    support with a non-movable move policy:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The movable policy is much simpler:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We can now construct a movable pointer and a non-movable pointer:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: An attempt to move a non-movable pointer does not compile because one of the
    base classes, `MoveForbidden`, is non-movable (does not have a move constructor).
    Note that the moved-from pointer `p` in the preceding example can be safely deleted,
    but cannot be used in any other way. In particular, it cannot be dereferenced.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'While we are dealing with movable pointers, it would make sense to provide
    a move assignment operator as well:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note the check for the self-assignment. Unlike the copy assignment, which is
    required to do nothing for self-assignment, the move assignment is less constrained
    by the standard. The only certain requirement is that the self-move should always
    leave an object in a well-defined state (the moved-from state is an example of
    such a state). A no-op self-move is not required but is valid as well. Also, note
    the way in which the base classes are move-assigned - the easiest way is to invoke
    the move assignment operator of each base class directly. There is no need to
    cast the derived class `that` to each of the base types - this is an implicitly
    performed cast. We must not forget to set the moved-from pointer to `nullptr`,
    otherwise, the object owned by these pointers will be deleted twice.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: For simplicity, we have ignored all of the policies we introduced earlier. This
    is fine – not all designs need everything to be controlled by a policy, and, in
    any case, it is quite straightforward to combine multiple policies. However, it
    is a good opportunity to point out that different policies are sometimes related
    - for example, if we use both a release policy and a move policy, the use of a
    movable move policy strongly suggests that the object must support release (a
    released pointer is similar to a moved-from pointer). Using template metaprogramming,
    we can force such dependence between the policies, if need be.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that a policy that needs to disable or enable constructors does not automatically
    have to be used as a base class - move assignment or construction also moves all
    data members, and, therefore, a non-movable data member will disable the move
    operations just as well. The more important reason to use inheritance here is
    the empty base class optimization: if we introduced a `MovePolicy` data member
    into our class, it would double the object size from 8 to 16 bytes on a 64-bit
    machine.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: We have considered making our pointers movable. But what about copying? So far,
    we have disallowed copying outright - both the copy constructor and the copy assignment
    operator are deleted in our smart pointer from the very beginning. This makes
    sense so far - we do not want to have two smart pointers own the same object and
    delete it twice. But there is another type of ownership where the copy operation
    makes perfect sense - the shared ownership, such as what’s implemented by a reference-counting
    shared pointer. With this type of pointer, copying the pointer is allowed, and
    both pointers now equally own the pointed-to object. A reference count is maintained
    to count how many pointers to the same object exist in the program. When the very
    last pointer owning a particular object is deleted, so is the object itself, since
    there are no more references to it.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several ways to implement a reference-counted shared pointer, but
    let’s start with the design of the class and its policies. We still need a deletion
    policy, and it makes sense to have a single policy control the move and copy operations.
    For simplicity, we will again limit ourselves to just the policies we are currently
    exploring:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The copy operations are no longer unconditionally deleted. Both the copy and
    the move constructor are provided (the two assignment operators are omitted for
    brevity, but should be implemented in the same way it was done earlier).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: The deletion of the object in the destructor of the smart pointer is no longer
    unconditional - in the case of the reference-counted pointer, the copying policy
    maintains the reference count and knows when there is only one copy of the smart
    pointer for a particular object.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'The smart pointer class itself provides the requirements for the policy classes.
    The no-move, no-copy policy must disallow all copy and move operations:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In addition to that, the non-copyable smart pointer always deletes the object
    it owns in its destructor, so the `must_delete()` member function should always
    return `true`. Note that this function must be implemented by all copying policies,
    even if it is trivial, otherwise, the smart pointer class will not compile. However,
    we can fully expect the compiler to optimize the call away and unconditionally
    call the destructor when this policy is used.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'The move-only policy is similar to the movable policy we had earlier, but now
    we must explicitly enable the move operations and disable the copy operations:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Again, the deletion is unconditional (the pointer inside the smart pointer object
    can be null if the object was moved, but this does not prevent us from calling
    `operator delete` on it). This policy allows the move constructor and the move
    assignment operator to compile; the `SmartPtr` class provides the correct implementation
    for these operations, and no additional support from the policy is required.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'The reference-counting copying policy is much more complex. Here, we have to
    decide on the shared pointer implementation. The simplest implementation allocates
    the reference counter in a separate memory allocation, which is managed by the
    copying policy. Let’s start with a reference-counted copying policy that does
    not allow move operations:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: When a smart pointer with this copying policy is constructed, a new reference
    counter is allocated and initialized to one (we have one smart pointer pointing
    to the particular object - the one we are now constructing). When a smart pointer
    is copied, so are all its base classes, including the copy policy. The copy constructor
    of this policy simply increments the reference count. When a smart pointer is
    deleted, the reference count is decremented. The very last smart pointer to be
    deleted also deletes the count itself. The copying policy also controls when the
    pointed-to object is deleted - it happens when the reference count reaches one,
    which means that we are about to delete the very last pointer for this object.
    It is, of course, very important to make sure that the counter is not deleted
    before the `must_delete()` function is called. This is guaranteed to be true since
    the destructors of the base classes run after the destructor of the derived class
    - the derived class of the last smart pointer will see the counter value of one
    and will delete the object; then, the destructor of the copying policy will decrement
    the counter once more, see it drop to zero, and delete the counter itself.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'With this policy, we can implement shared ownership of an object:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, we have two pointers to the same object, with the reference count of two.
    The object is deleted when the last of the two pointers is, assuming that no more
    copies are created beforehand. The smart pointer is copyable, but not movable:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In general, once reference-counted copying is supported, there is probably
    no reason to disallow move operations, unless they are simply not needed (in which
    case, the no-move implementation can be slightly more efficient). To support the
    move, we must give some thought to the moved-from state of the reference-counting
    policy – clearly, it must not decrement the reference counter when it is deleted,
    since a moved-from pointer no longer owns the object. The simplest way is to reset
    the pointer to the reference counter so that it is no longer accessible from the
    copying policy, but then the copying policy must support the special case of a
    null counter pointer:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Finally, a reference-counting copying policy must support the assignment operations
    as well. These are implemented similarly to the copy or move constructors (but
    take care to use the left-hand-side policies for the deletion of the left-hand-side
    objects before assigning the new values to the policies).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: As you have seen, some of the policy implementations can get pretty complex,
    and their interactions are even more so. Fortunately, the policy-based design
    is particularly well-suited for writing testable objects. This application of
    policy-based design is so important that it deserves special mention.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Policies for test
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will now show the reader how to use policy-based design to write better tests.
    In particular, policies can be used to make the code more testable by means of
    unit tests. This can be done by substituting a special test-only version of a
    policy instead of the regular one. Let us demonstrate this with the example of
    the reference-counting policy from the previous subsection.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'The main challenge of that policy is, of course, maintaining the correct reference
    count. We can easily develop some tests that should exercise all of the corner
    cases of reference counting:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The hard part is actually testing that all of this code works the way it is
    supposed to. We know what the reference count should be, but we have no way of
    checking what it really is (adding the public function `count()` to the smart
    pointer solves that problem, but it is the least of the difficulties). We know
    when the object is supposed to be deleted, but it is hard to verify that it actually
    was. We will probably get a crash if we delete the object twice, but even that
    is not certain. It is even harder to catch the case when the object is not deleted
    at all. A sanitizer can find such issues, at least if we use standard memory management,
    but they are not available in all environments and, unless the tests are designed
    to be run with the sanitizer, can produce very noisy output.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, we can use policies to give our tests a window into the internal
    working of the object. For example, if we did not implement a public `count()`
    method in all our reference-counting policies, we can create a testable wrapper
    for the reference-counting policy:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Note that we had to change the `count_` data member from private to protected
    in the main copy policy. We could also declare the test policy a friend, but then
    we would have to do this for every new test policy. Now, we can actually implement
    our tests:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Similarly, we can create an instrumented deletion policy that checks whether
    the object will be deleted, or record in some external logging object that it
    was actually deleted and test that the deletion was properly logged. We would
    need to instrument our smart pointer implementation to make calls to the debugging
    or testing policy:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Both debug and production (non-debug) policies must have all the methods referenced
    in the class, but the empty methods of the non-debug policy are going to be inlined
    and optimized down to nothing.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The debug policies vary, the basic ones simply log all debuggable events:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The more complex policies can validate that the internal state of the objects
    is consistent with the requirements and that the class invariants are maintained.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'By now, the reader has likely noticed that the declarations of the policy-based
    objects can be quite long:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This is one of the most frequently observed problems with policy-based design,
    and we should consider some ways to mitigate this problem.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Policy adapters and aliases
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perhaps the most obvious drawback of the policy-based design is the way we
    have to declare the concrete objects - specifically, the long list of policies
    that must be repeated every time. Judicious use of default parameters helps to
    simplify the most commonly used cases. For example, let us look at the following
    long declaration:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Sometimes, this can be reduced to the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'This can be done if the defaults represent the most common case of a movable
    non-debug pointer that uses the `operator delete`. However, what is the point
    of adding the policies if we are not going to use them? A well-thought-out order
    of policy parameters helps to make the more common policy combinations shorter.
    For example, if the most common variation is the deletion policy, then a new pointer
    with a different deletion policy and default remaining policies can be declared
    without repeating the policies we do not need to change:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This still leaves the problem of the less commonly used policies. Also, policies
    are often added later as additional features must be added to the design. These
    policies are almost always added to the end of the parameter list. To do otherwise
    would require rewriting every bit of code where a policy-based class is declared
    to reorder its parameters. However, the late-coming policies are not necessarily
    less often used, and this evolution of the design may lead to a case where many
    policy arguments have to be explicitly written, even at their default values,
    so that one of the trailing arguments can be changed.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: While there is no general solution to this problem within the confines of the
    traditional policy-based design, in practice, there are often few commonly used
    groups of policies, and then there are some frequent variations. For example,
    most of our smart pointers may be using `operator delete` and support move and
    release, but we frequently need to alternate between the debug and non-debug versions.
    This can be accomplished by creating adapters that convert a class with many policies
    to a new interface that exposes only the policies we want to change often and
    pins the rest of the policies to their commonly used values. Any large design
    will likely need more than one such adapter, as the commonly used sets of policies
    can vary.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way to write such an adapter is with the `using` alias:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The other option is to use inheritance:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This creates a derived class template that pins some of the parameters of the
    base class template while leaving the rest parameterized. The entire public interface
    of the base class is inherited, but some care needs to be taken about the constructors
    of the base class. By default, they are not inherited, and so the newly derived
    class will have the default compiler-generated constructors. This is probably
    not something we want, so we have to bring the base class constructors (and possibly
    the assignment operators) into the derived class:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The `using` alias is definitely easier to write and maintain, but the derived
    class adapter offers more flexibility if it is necessary to also adapt some of
    the member functions, nested types, etc.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now use the new adapter when we need a smart pointer with the preset
    policies, but quickly change the debug policy:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: As we said from the beginning, the most common application of policies is to
    select a specific implementation for some aspect of the behavior of the class.
    Sometimes, such variations in the implementation are reflected in the public interface
    of the class as well - some operations may make sense only for some implementations,
    and not for others, and the best way to make sure that an operation that is not
    compatible with the implementation is not invoked is to simply not provide it.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Now, let us revisit the issue of selectively enabling parts of the public interface
    using policies.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Using policies to control the public interface
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have previously used policies to control the public interface in one of two
    ways - first, we were able to inject a public member function by inheriting from
    a policy. This approach is reasonably flexible and powerful, but has two drawbacks
    - first, once we inherit publicly from a policy, we have no control over what
    interface gets injected - every public member function of the policy becomes a
    part of the derived class interface. Second, to implement anything useful this
    way, we have to let the policy class cast itself to the derived class, and then
    it has to have access to all of the data members and possibly other policies of
    the class. The second approach we tried relied on a particular property of the
    constructors - to copy or move a class, we have to copy or move all of its base
    classes or data members; if one of them is non-copyable or non-movable, the entire
    constructor will fail to compile. Unfortunately, it usually fails with a rather
    non-obvious syntax error - nothing as straightforward as *no copy constructor
    found in this object.* We can extend this technique to other member functions,
    for example, to assignment operators, but it gets uglier.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now learn a more direct way to manipulate the public interface of a
    policy-based class. First of all, let’s differentiate between conditionally disabling
    existing member functions and adding new ones. The former is reasonable and generally
    safe: if a particular implementation cannot support certain operations offered
    by the interface, they should not be offered in the first place. The latter is
    dangerous as it allows for the essentially arbitrary and uncontrolled extension
    of the public interface of the class. Therefore, we will focus on providing the
    interface for all possible intended uses of a policy-based class, and then disabling
    parts of that interface when they do not make sense for some choice of policies.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: There is already a facility in the C++ language to selectively enable and disable
    member functions. Prior to C++20, this facility is most commonly implemented through
    concepts (if they are available) or `std::enable_if`, but the foundation behind
    it is the SFINAE idiom that we studied in [*Chapter 7*](B19262_07.xhtml#_idTextAnchor314),
    *SFINAE, Concepts, and Overload Resolution Management*. In C++20, the much more
    powerful concepts can replace `std::enable_if` in many cases.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate the use of SFINAE to let the policies selectively enable a member
    function, we’re going to reimplement the policy controlling the public `release()`
    member function. We have done this once already in this chapter by inheriting
    from a `ReleasePolicy` that may or may not provide the `release()` member function;
    if one is provided, CRTP had to be used to implement it. We are now going to do
    the same but using C++20 concepts.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'As we just said, a policy that relies on SFINAE and concepts cannot add any
    new member functions to the interface of a class; it can only disable some of
    them. Therefore, the first step is to add the `release()` function to the `SmartPtr`
    class itself:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Right now, it is always enabled, so we need to conditionally enable it using
    some property of the `ReleasePolicy`. Since this policy controls a single behavior,
    all we need is a constant value that tells us whether the release feature should
    be supported:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Now, we need to conditionally enable the `release()` member function with a
    constraint:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: That’s all we need in C++20\. Note that we did not need to inherit from `ReleasePolicy`
    because there is nothing in it except for a constant value. We also do not need
    to move or copy this policy, for the same reason.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Before C++20 and concepts, we have to use `std::enable_if` to enable or disable
    a particular member function - in general, the expression `std::enable_if<value,
    type>` will compile and yield the specified `type` if the `value` is `true` (it
    must be a compile-time, or `constexpr`, Boolean value). If the `value` is `false`,
    the type substitution fails (no type result is produced). The proper use for this
    template metafunction is in an SFINAE context, where the failure of type substitution
    does not result in a compilation error, but simply disables the function that
    causes the failure (to be more precise, it removes it from the overload resolution
    set).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'The policies themselves do not have to change at all: both SFINAE and constraints
    need a `constexpr bool` value. What changes is the expression used to disable
    a member function. It is tempting to write it simply as:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Unfortunately, this is not going to work: for the `NoRelease` policy, this
    fails to compile even if we do not try to call `release()`. The reason is that
    SFINAE works only when template parameter substitution is done (`release()` function
    must be a template, and, furthermore, the potential substitution failure has to
    occur during the substitution of template parameters. We do not need any template
    parameters to declare `release()`, but we have to introduce a dummy one to use
    SFINAE:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: We have seen such “fake templates” when we were describing the “concept utilities”
    – a way to mimic concepts before C++20 – in [*Chapter 7*](B19262_07.xhtml#_idTextAnchor314)*,
    SFINAE, Concepts, and Overload Resolution Management*. Now we have a template
    type parameter; the fact that it is never going to be used and is always set to
    its default value changes nothing. The conditional expression in the return type
    uses this template parameter (never mind that the part of the expression that
    depends on the parameter can never fail). Therefore, we are now within the SFINAE
    rules.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to disable a member function selectively, we can revisit
    the conditionally enabled constructors to see how we can enable and disable constructors
    as well.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'In C++20, the answer is “exactly the same way.” We need a policy with a `constexpr`
    Boolean value and a `restrict` constraint to disable any constructor:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'We can use this policy to constrain any member function, constructors included:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Prior to C++20, we have to use SFINAE. The one complication here is that the
    constructors have no return type and we have to hide the SFINAE test somewhere
    else. In addition, we again have to make the constructor a template. We can use
    a dummy template parameter again:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'If you use the concept utilities from [*Chapter 7*](B19262_07.xhtml#_idTextAnchor314)*,
    SFINAE, Concepts, and Overload Resolution Management*, the code is going to look
    simpler and more straightforward, although a dummy template parameter is still
    needed:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Now that we have a fully general way to enable or disable specific member functions
    that work for constructors as well, the reader may be wondering, what was the
    point of introducing the earlier way? Firstly, for simplicity - the `enable_if`
    expression has to be used in the right context, and the compiler errors that are
    generated if anything is even slightly wrong are not pretty. On the other hand,
    the notion that a non-copyable base class makes the entire derived class non-copyable
    is very basic and works every time. This technique can even be used in C++03,
    where SFINAE is much more limited and even harder to get to work correctly.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we have already seen that sometimes policies need to add member variables
    to the class instead of (or in addition to) member functions. Our reference-counting
    pointer is a perfect example: if one of the policies provides reference counting,
    it must also contain the count. Member variables cannot be restricted with constraints,
    so they have to come from the base policy class.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'Yet another reason to at least know the way to inject public member functions
    through policies is that sometimes the `enable_if` alternative requires that the
    entire set of possible functions be declared in the primary class template, and
    then some can be selectively disabled. Sometimes, that set of functions is self-contradicting
    and cannot be present all at once. An example is a set of conversion operators.
    Right now, our smart pointer cannot be converted back into a raw pointer. We could
    enable such conversions and require them to be explicit, or allow implicit conversions:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The conversion operators are defined as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'We already decided that we do not want these operators to be unconditionally
    present; instead, we want them controlled by a raw conversion policy. Let us start
    with the same approach we used the last time for a policy that enables a member
    function:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Again, we will write C++20 code first, where we can restrict both the explicit
    and the implicit operators using constraints:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'For completeness, we also provided conversions to a `const` raw pointer. Note
    that in C++20, there is a simpler way to provide these operators using the conditional
    explicit specifier (another C++20 feature):'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Prior to C++20, we can attempt to enable one of these operators using `std::enable_if`
    and SFINAE, again based on a conversion policy. The problem is, we cannot declare
    both implicit and explicit conversion to the same type, even if one is later disabled.
    These operators cannot be in the same overload set to begin with:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'If we want to have the option to select one of these operators in our smart
    pointer class, we have to have them generated by the base class policy. Since
    the policy needs to be aware of the smart pointer type, we have to use the CRTP
    again. Here is a set of policies to control the conversion from smart pointers
    to raw pointers:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'These policies add the desired public member function operators to the derived
    class. Since they are templates that need to be instantiated with the derived
    class type, the conversion policy is a template template parameter, and its use
    follows the CRTP:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Once again, note the use of the template template parameter: the template parameter
    `ConversionPolicy` is not a type but a template. When inheriting from an instantiation
    of this policy, we have to write the complete type of our `SmartPtr` class, with
    all its template arguments. We made the conversion policy a template of two arguments
    (the second one is the object type `T`). We could also deduce the type `T` from
    the first template parameter (the smart pointer type), it’s largely a matter of
    style.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: 'The selected conversion policy adds its public interface, if any, to that of
    the derived class. One policy adds a set of explicit conversion operators, while
    the other one provides implicit conversions. Just like in the earlier CRTP example,
    the base class needs access to the private data members of the derived class.
    We can either grant friendship to the entire template (and every instantiation
    of it) or, more verbosely, to the specific instantiation used as the base class
    for each smart pointer:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: We have learned several different ways to implement new policies. Sometimes,
    the challenge comes in reusing the ones we already have. The next section shows
    one way to do it.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Rebinding policies
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have already seen, the policy lists can get quite long. Often, we want
    to change just one policy and create a class *just like that other one, but with
    a small change.* There are at least two ways to do this.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'The first way is very general but somewhat verbose. The first step is to expose
    the template parameters as aliases, inside the primary template. This is a good
    practice, anyway - without such aliases, it is very difficult to find out, at
    compile time, what a template parameter was in case we ever need to use it outside
    of the template. For example, we have a smart pointer, and we want to know what
    the deletion policy was. The easiest way, by far, is with some help from the smart
    pointer class itself:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Note that we’re using two different types of aliases here - for the regular
    template parameters such as `DeletionPolicy`, we can use a `using` alias. For
    a template template parameter, we have to use the template alias, sometimes called
    template `typedef` - to reproduce the same policy with another smart pointer,
    we need to know the template itself, not the template instantiation, such as `ConversionPolicy<SmartPtr,
    T>`. Now, if we need to create another smart pointer with some of the same policies,
    we can simply query the policies of the original object:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Now, `p2` and `p1` have exactly the same type. There is, of course, an easier
    way to accomplish that. But the point is, we could alter any one of the types
    in the list and keep the rest, and get a pointer just like `p1`, *except for one
    change.* For example, the pointer `p2` has the same policies but points to a `double`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'The latter turns out to be a pretty common case, and there is a way to facilitate
    the *rebinding* or a template to a different type while keeping the rest of the
    arguments intact. To do this, the primary template and all its policies need to
    support such rebinding:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The `rebind` alias defines a new template that has only one parameter - the
    type we can change. The rest of the parameters come from the primary template
    itself. Some of these parameters are types that also depend on the primary type
    `T`, and themselves need rebinding (in our example, the deletion policy). By choosing
    not to rebind the copy/move policy, we impose a requirement that none of these
    policies depend on the primary type, otherwise this policy, too, needs to be rebound.
    Finally, the template conversion policy does not need rebinding - we have access
    to the entire template here, so it will be instantiated with the new primary type.
    We can now use the rebinding mechanism to create a *similar* pointer type:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: If we have direct access to the smart pointer type, we can use it for rebinding
    (for example, in a template context). Otherwise, we can get the type from a variable
    of this type using `decltype()`. The pointer `q` has the same policies as `p`
    but points to a `double`, and the type-dependent policies such as the deletion
    policy have been updated accordingly.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: We have covered the main ways in which the policies can be implemented and used
    to customize policy-based classes. It is now time to review what we have learned
    and state some general guidelines for the use of policy-based designs.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Recommendations and guidelines
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The policy-based design allows for exceptional flexibility in the creation of
    finely customizable classes. Sometimes, this flexibility and power become the
    enemy of a good design. In this section, we will review the strengths and weaknesses
    of the policy-based design and come up with some general recommendations.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Strengths of the policy-based design
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main advantages of the policy-based design are flexibility and extensibility
    of the design. At a high level, these are the same benefits the Strategy pattern
    offers, only realized at compile-time. The policy-based design allows the programmer
    to select, at compile time, one of several algorithms for each specific task or
    operation performed by the system. Since the only constraints on the algorithms
    are the requirements on the interface that binds them into the rest of the system,
    it is equally possible to extend the system by writing new policies for the customizable
    operations.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: At a high level, the policy-based design allows the software system to be built
    from components. At a high level, this is hardly a novel idea, certainly not limited
    to policy-based design. The focus of the policy-based design is the use of components
    to define behavior and the implementation of individual classes. There is some
    similarity between policies and callbacks - both allow a user-specified action
    to be taken when a particular event takes place. However, the policies are much
    more general than callbacks - while a callback is a function, policies are entire
    classes, with multiple functions and, possibly, a non-trivial internal state.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在高层次上，基于策略的设计允许软件系统由组件构建。在高层次上，这几乎不是一个新颖的想法，当然也不限于基于策略的设计。基于策略设计的重点是使用组件来定义行为和实现单个类。策略和回调之间有一些相似之处——两者都允许在特定事件发生时执行用户指定的操作。然而，策略比回调更通用——回调是一个函数，而策略是整个类，具有多个函数，可能还有非平凡的内部状态。
- en: These general concepts translate into a unique set of advantages for the design,
    mostly centered around the ideas of flexibility and extensibility. With the overall
    structure of the system and its high-level components determined by the high-level
    design, the policies allow for a variety of low-level customizations within the
    constraints that were imposed by the original design. Policies can extend the
    class interface (add public member functions), implement or extend the state of
    the class (add data members), and specify implementations (add private member
    functions). The original design, in setting the overall structure of the classes
    and their interactions, in effect authorizes each policy to have one or more of
    these roles.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这些通用概念转化为设计的一套独特优势，主要围绕灵活性和可扩展性。由于系统的整体结构和其高级组件由高级设计确定，因此策略允许在原始设计强加的约束内进行各种低级定制。策略可以扩展类接口（添加公共成员函数），实现或扩展类的状态（添加数据成员），并指定实现（添加私有成员函数）。原始设计在设定类的整体结构和它们之间的交互时，实际上授权每个策略拥有这些角色中的一个或多个。
- en: The result is an extensible system that can be modified to address evolving
    requirements, even ones that have not been anticipated or known at the time when
    the system was designed. The overall architecture remains stable, while the selection
    of possible policies and the constraints on their interfaces offers a systematic,
    disciplined way to modify and extend the software.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个可扩展的系统，可以修改以应对不断变化的需求，甚至包括在系统设计时未预见或未知的那些需求。整体架构保持稳定，而可能策略的选择及其接口的约束提供了一种系统化、规范化的方式来修改和扩展软件。
- en: Disadvantages of policy-based design
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于策略设计的缺点
- en: 'The first problem with the policy-based design that comes to mind is the one
    we have already encountered - declarations of policy-based classes with a specific
    set of policies are extremely verbose, especially if one of the policies at the
    end of the list has to be changed. Consider the declaration of a smart pointer
    with all of the policies we have implemented in this chapter, put together:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到基于策略的设计的第一个问题，是我们已经遇到的问题——具有特定策略集的基于策略类的声明非常冗长，尤其是如果列表末尾的策略需要更改的话。考虑一下声明一个智能指针，其中包含我们在本章中实现的所有策略，合并在一起：
- en: '[PRE97]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: That’s just for a smart pointer - a class with a fairly simple interface and
    limited functionality. Even though it is unlikely that someone will need one pointer
    with all of these customization possibilities, the policy-based classes tend to
    have a lot of policies. This problem may be the most evident, but it is actually
    not the worst. The template aliases help to give concise names to the few policy
    combinations that are actually used by a particular application. In the template
    context, the types of smart pointers used as function arguments are deduced and
    do not need to be explicitly specified. In regular code, `auto` can be used to
    save a lot of typing and also make the code more robust - when the complex type
    declarations that must be consistent are replaced with an automatic way to generate
    these consistent types, the errors caused by typing something slightly different
    in two different places disappear (in general, if there is a recipe to make the
    compiler generate correct-by-construction code, use it).
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: The much more significant, if slightly less visible, problem is that all of
    these policy-based types with different policies are actually different types.
    Two smart pointers that point to the same object type but have different deletion
    policies are different types. Two smart pointers that are otherwise the same but
    have different copying policies are different types. Why is that a problem? Consider
    a function that is called to work on an object that is passed into the function
    using a smart pointer. This function does not copy the smart pointer, so it should
    not matter what the copying policy is - it is never used. And yet, what should
    the argument type be? There is no one type that can accommodate all smart pointers,
    even the ones with very similar functionality.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: There are several possible solutions here. The most straightforward one is to
    make all functions that use policy-based types into templates. This does simplify
    the coding, and it reduces code duplication (at least the source code duplication),
    but it has its own downsides - the machine code becomes larger since there are
    multiple copies of every function, and all template code must be in the header
    files.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: The other option is to erase the policy types. We saw the type erasure technique
    in [*Chapter 6*](B19262_06.xhtml#_idTextAnchor266), *Understanding Type Erasure*.
    Type erasure solves the problem of having many similar types - we could make all
    smart pointers, regardless of their policies, be of the same type (only to the
    extent that the policies determine the implementation and not the public interface,
    of course). However, this comes at a very high cost.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: One of the main drawbacks of the templates in general, and the policy-based
    design, in particular, is that templates provide a zero-overhead abstraction -
    we can express our programs in terms of convenient high-level abstractions and
    concepts, but the compiler strips it all away, inlines all of the templates, and
    generates the minimum necessary code. Type erasure not only negates this advantage
    but has the opposite effect - it adds a very high overhead of memory allocations
    and indirect function calls.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: The last option is to avoid using policy-based types, at least for some operations.
    Sometimes, this choice carries a little extra cost - for example, a function that
    needs to operate on an object but not delete or own it should take the object
    by reference instead of a smart pointer (see [*Chapter 3*](B19262_03.xhtml#_idTextAnchor110),
    *Memory and Ownership*). In addition to clearly expressing the fact that the function
    is not going to own the object, this neatly solves the problem of what type the
    argument should be - the reference is the same type, no matter which smart pointer
    it came from. This is, however, a limited approach - more often than not, we do
    need to operate on the entire policy-based objects, which are usually much more
    complex than a simple pointer (for example, custom containers are often implemented
    using policies).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: The final disadvantage is the general complexity of the policy-based types,
    although such claims should be made with care - the important question is, complexity
    compared to what? Policy-based designs are usually invoked to solve complex design
    problems where a family of similar types serves the same overall purpose (*what*),
    but does so in slightly different ways (*how)*. This leads us to the recommendations
    on the use of policies.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Guidelines for policy-based designs
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The guidelines for policy-based designs boil down to managing the complexity
    and making sure the ends justify the means - the flexibility of the design and
    the elegance of the resulting solutions should justify the complexity of the implementation
    and its use.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Since most of the complexity comes from the increasing number of policies, this
    is the focus of most of the guidelines. Some policies end up putting together
    very different types that happen to have a similar implementation. The goal of
    such a policy-based type is to reduce code duplication. While a worthwhile objective,
    this is generally not a good enough reason to expose a multitude of disparate
    policy options to the end user of the type. If two different types or type families
    happen to have similar implementations, that implementation can be factored out.
    The private, hidden, implementation-only part of the design can itself use policies
    if it makes the implementation easier.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: However, these hidden policies should not be selected by the client - the client
    should specify the types that make sense in the application and the policies that
    customize the visible behavior. From these types and policies, the implementation
    can derive additional types as needed. This is no different than calling a common
    function to, say, find the minimum element in a sequence from several different
    unrelated algorithms that all happen to need that operation. The common code is
    not duplicated, but neither is it exposed to the user.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: So, when should a policy-based type be broken up into two or more pieces? A
    good way to look at it is to ask whether the primary type, with a particular set
    of policies, has a good specific name that describes it. For example, a non-copyable
    owning pointer, movable or not, is a *unique pointer -* there is only one such
    pointer for each object at any given time. This is true for any deletion or conversion
    policy.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, a reference-counted pointer is a *shared pointer,* again,
    with any choice of other policies. This suggests that our one smart pointer to
    end all smart pointers would be, perhaps, better split into two - a non-copyable
    unique pointer and a copyable shared pointer. We still get some code reuse because
    the deletion policy, for example, is common to both pointer types, and does not
    have to be implemented twice. This is, indeed, the choice the C++ standard makes.
    The `std::unique_ptr` has only one policy, the deletion policy. The `std::shared_ptr`
    also has the same policy and can use the same policy objects, but it is type-erased,
    so all shared pointers to a particular object are of one type.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 'But what about other policies? Here, we come to the second guideline - the
    policies that restrict the use of the class should be justified by the cost of
    possible errors that are caused by the incorrect use they are trying to prevent.
    For example, do we really need a non-movable policy? On the one hand, it could
    prevent a programming error if the ownership of the object absolutely must not
    be transferred. On the other hand, in many cases, the programmer will simply change
    the code to use a movable pointer. Also, we are forced to use movable pointers
    to return them by value from factory functions. However, a non-copyable policy
    is often justified and should be the default. For example, there are good reasons
    to make most containers non-copyable by default: copying a large collection of
    data is almost always the result of sloppy coding, usually when passing arguments
    to functions.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, while it is probably desirable to prevent implicit casting to the
    raw pointer as a matter of basic coding discipline, there is always a way to convert
    the smart pointer to the raw one explicitly - if nothing else, `&*p` should always
    work. Again, the benefits of the carefully restricted interface probably do not
    justify adding this policy. However, it makes a great compact learning example
    for a set of techniques that can be used to create more complex and more useful
    policies, and so the time we spent learning how this policy works is entirely
    justified.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: When a policy affecting the public interface is justified, we have to make a
    choice between a constraint-based policy that restricts the existing member functions
    and a CRTP-based policy that adds them. As a rule, a design that relies on constraints
    is preferable, even prior to C++20 where we have to use the “pseudo-concepts.”
    However, this approach cannot be used to add member variables to the class, only
    member functions.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Another way to look at the question of what the right set of policies is and
    what policies should be broken up into separate groups is to go back to the fundamental
    strength of the policy-based design - the composability of the behavior expressed
    by different policies. If we have a class with four different policies, each of
    which can have four different implementations, that is 256 different versions
    of the class. It is, of course, unlikely that we will need all 256\. But the point
    is, at the time when we implement the class, we do not know which of these versions
    we will actually need later. We could make a guess and implement only a few most
    likely ones. If we are wrong, this will result in much code duplication and copy-pasting.
    With the policy-based design, we have the potential to implement any combination
    of the behavior, without actually having to write them all explicitly up front.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand this strength of policy-based designs, we can use it
    to evaluate a particular set of policies - do they need to be composable? Would
    we ever need to combine them in different ways? If some policies always come in
    certain combinations or groups, this calls for automatically deducing these policies
    from one primary user-specified policy. On the other hand, a set of largely independent
    policies that can be combined arbitrarily is probably a good set of policies.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Another way to address some of the weaknesses of policy-based design is to try
    and accomplish the same goal by different means. There is no substitute for the
    entirety of the capabilities offered by the policies - the Strategy pattern is
    there for a reason. However, there are alternative patterns that offer somewhat
    superficial similarities and may be used to solve some of the same problems as
    the policy-based design addresses. We will see one such alternative in [*Chapter
    16*](B19262_16.xhtml#_idTextAnchor739), *Adapters and Decorators* when we talk
    about decorators. It is not as general, but when it works, it can provide all
    the advantages of the policies, in particular, the composability, without some
    of the problems.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have studied, extensively, the applications of the Strategy
    pattern (also known as the policy pattern) to C++ generic programming. The combination
    of the two gives rise to one of the most powerful tools in the arsenal of a C++
    programmer - the policy-based design of classes. This approach provides great
    flexibility by allowing us to compose the behavior of the class from many building
    blocks, or policies, each of which is responsible for a particular aspect of the
    behavior.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: We have learned different ways to implement policies - these can be templates,
    classes with template member functions, classes with static functions, and even
    classes with constant values. Just as varied are the ways that we can use policies
    through composition, inheritance, or direct access to static members. Policy parameters
    can be types or templates, each with its own advantages and limitations.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: A tool as powerful as the policy-based design is also easily misused or applied
    in poor judgment. Often, such situations arise from the gradual evolution of the
    software toward more and more complexity. To mitigate such mischance, we have
    provided a set of guidelines and recommendations that focus on the key advantages
    that the policy-based design offers to the programmer and suggested the techniques
    and constraints that maximize such advantages.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will consider a more limited design pattern that can
    sometimes be used to mimic the policy-based approach, without some of its drawbacks.
    This chapter is dedicated to the Decorator pattern and the more general Adapter
    pattern. Both are sort of C++ magic tricks - they make an object appear as something
    it’s not.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the Strategy pattern?
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is the Strategy pattern implemented at compile time using C++ generic programming?
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What types can be used as policies?
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can policies be integrated into the primary template?
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Should I use policies with public member functions or policies with constraint
    variables?
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the main drawbacks of policy-based design?
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
