- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mastering Iterators with std::vector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will gain a deeper exploration of `std::vector`, focusing
    on the intricacies of iteration. This chapter equips us with the knowledge to
    handle the ins and outs of vector traversal. Mastering these core areas bolsters
    the efficiency and reliability of one’s C++ code and provides insights into the
    underpinnings of dynamic array behavior, which is critical for effective C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Types of iterators in the STL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic iteration techniques with `std::vector`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `std::begin` and `std::end`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding iterator requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Range-based `for` loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom iterator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code in this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
  prefs: []
  type: TYPE_NORMAL
- en: Types of iterators in the STL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the **Standard Template Library** (**STL**), iterators play a pivotal role
    by connecting algorithms to containers. They provide a means for developers to
    traverse, access, and potentially modify the elements of a container. Iterators
    are essential tools for efficient data manipulation in the STL. However, they
    aren’t uniform in their functionalities. The STL delineates iterators into five
    primary types, each offering varying access and control over the elements. This
    section will get into these iterator types, elaborating on their distinct capabilities
    and uses.
  prefs: []
  type: TYPE_NORMAL
- en: Input iterators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Input iterators (*LegacyInputIterator*) are the starting point in exploring
    iterator types. They represent the foundational category of iterators. As their
    name implies, input iterators focus on reading and progressing through elements.
    They enable developers to advance to the subsequent element in the container and
    retrieve its value. It’s crucial to note that revisiting the prior element is
    impossible after moving an input iterator forward, and modifying the present element
    is not permitted. This iterator category is often employed in algorithms that
    require data processing without modification.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a simple example using `std::vector` and its input iterator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use `std::vector<int>::const_iterator` as the input iterator
    to traverse the vector and print its elements. We’re following the principles
    of the input iterator by not modifying the elements or moving the iterator backward.
    It is important to note that we cannot change the element or go back to the previous
    element with the input iterator.
  prefs: []
  type: TYPE_NORMAL
- en: Output iterators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we will look into output iterators (*LegacyOutputIterator*). Although
    they bear similarities to input iterators, they serve a different primary function:
    writing to elements. Output iterators facilitate assignment to the elements they
    reference. However, directly reading these elements through the iterator is not
    supported. They are commonly utilized in algorithms designed to produce and populate
    a sequence of values within a container.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example demonstrating the use of output iterators with `std::vector`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `std::back_inserter` is an output iterator adapter designed
    to work with containers like `std::vector`. It allows you to *write* or push new
    values to the back of the vector. We use the `std::generate_n` algorithm to generate
    and insert the numbers. This pattern perfectly encapsulates the *write-only* characteristic
    of output iterators. We don’t use the output iterator to read. For reading, we
    use a regular iterator.
  prefs: []
  type: TYPE_NORMAL
- en: Forward iterators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the basics behind us, let’s move on to the forward iterators (*LegacyForwardIterator*).
    Forward iterators combine the capabilities of both input iterators and output
    iterators. Thus, they support reading, writing, and—as the name implies—always
    moving forward. Forward iterators never reverse their direction. Their versatility
    makes them well-suited for many algorithms that operate on singly linked lists
    (i.e., `std::forward_list`).
  prefs: []
  type: TYPE_NORMAL
- en: '`std::forward_list` is explicitly designed for singly linked lists, making
    it the ideal candidate for illustrating forward iterators.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a simple code example to illustrate their use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the example output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This code initializes a `std::forward_list`, uses a forward iterator to traverse
    and display its elements, and then increments each element by 1, demonstrating
    the reading and writing capabilities of the forward iterator.
  prefs: []
  type: TYPE_NORMAL
- en: Reverse iterators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, you might find the need to traverse the vector in reverse. Enter
    `rbegin()` and `rend()`. These functions return reverse iterators that start at
    the end of the vector and conclude at the beginning. Such backward traversal can
    be handy in specific algorithms and data-processing tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Note the reverse iterator is technically an iterator adaptor. `std::reverse_iterator`
    is classified as an iterator adaptor. It takes a given iterator, which should
    either be a *LegacyBidirectionalIterator,* or comply with the `bidirectional_iterator`
    criteria introduced from C++20 onwards, and reverses its direction. When given
    a bidirectional iterator, `std::reverse_iterator` yields a new iterator that traverses
    the sequence in the opposite direction—from the end to the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: Bidirectional iterators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Continuing, we address bidirectional iterators (*LegacyBidirectionalIterator*).
    These iterators permit traversal in both forward and backward directions within
    a container. Inheriting all functionalities of forward iterators, they introduce
    the ability to move in the reverse direction. Their design is particularly beneficial
    for data structures such as doubly linked lists, where bidirectional traversal
    is frequently required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example using `std::list` and its bidirectional iterators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the example output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we create a `std::list` of integers. We then demonstrate bidirectional
    iteration by first traversing the list in a forward direction using a regular
    iterator and then in reverse using a reverse iterator.
  prefs: []
  type: TYPE_NORMAL
- en: Random access iterators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Concluding our iterator categorization, we introduce the random access iterators
    (*LegacyRandomAccessIterator* and *LegacyContiguousIterator*). These iterators
    represent the highest versatility, enabling more than just sequential access.
    With random access iterators, developers can move forward by multiple steps, retreat
    backward, or access elements directly without sequential traversal. Such capabilities
    make them highly suitable for data structures such as arrays or vectors, which
    allow direct element access.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example showcasing the flexibility and capabilities of random access
    iterators with `std::vector`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This example demonstrates the various capabilities of random access iterators.
    We start with direct access, then jump positions, leap back, calculate distances,
    and even access elements in a non-linear manner.
  prefs: []
  type: TYPE_NORMAL
- en: It is vital to understand that the choice of iterator type is not arbitrary.
    Each one is designed with specific use cases in mind, and choosing the right one
    can significantly enhance the efficiency and elegance of your C++ code. When working
    with STL algorithms and containers, having a solid grasp of the different iterator
    types and their functionalities is paramount. This knowledge not only streamlines
    the coding process but also aids in debugging and optimizing the performance of
    your applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In exploring the STL’s iterators, we’ve learned the six core types: input,
    output, forward, reverse, bidirectional, and random access. Recognizing each type’s
    unique functions is vital for efficient C++ programming, as it affects how we
    traverse and interact with STL containers. Grasping these differences is not just
    academic; it’s practical. It enables us to choose the right iterator for tasks,
    such as using random access iterators with `std::vector` for their rapid element
    access capability.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll apply this knowledge, where we’ll see iteration in
    action, emphasize the use of constant iterators for read-only purposes, and underscore
    the adaptability of iterators across various containers, setting the stage for
    robust and versatile code development.
  prefs: []
  type: TYPE_NORMAL
- en: Basic iteration techniques with std::vector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we understand the different types of iterators available, let’s explore
    the essential concept of iterating over data structures. Iteration is a fundamental
    technique in programming that allows developers to access and manipulate each
    element in a data structure efficiently. Specifically for `std::vector`, iteration
    is crucial due to its dynamic nature and widespread use in C++ applications. By
    mastering iteration, you can harness the full potential of `std::vector`, enabling
    operations such as searching, sorting, and modifying elements with precision and
    ease. This section aims to deepen your understanding of why iteration is a crucial
    skill in managing and utilizing data structures effectively, setting the stage
    for more advanced applications in your programs.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating over std::vector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the powerful features of `std::vector` is its ability to allow seamless
    traversal of its elements. Whether you’re accessing individual elements or looping
    through each one, understanding the iterative capabilities of `std::vector` is
    crucial. Iteration is fundamental to numerous operations in programming, from
    data processing to algorithmic transformations. As you journey through this section,
    you’ll become well acquainted with how to traverse vectors in C++ efficiently
    and effectively.
  prefs: []
  type: TYPE_NORMAL
- en: At the heart of iteration in the C++ STL is the concept of iterators. Think
    of iterators as sophisticated pointers, guiding you through each element in a
    container, such as our beloved `std::vector`. Armed with iterators, one can move
    forward, backward, jump to the start or the end, and access the content they point
    to, making them indispensable tools in your C++ toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: Basic iteration using iterators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every `std::vector` provides a set of member functions that return iterators.
    The two primary ones are `begin()` and `end()`. While we’ll dive deeper into these
    functions in the next section, understand that `begin()` returns an iterator pointing
    to the first element, and `end()` returns an iterator pointing just *past* the
    last element.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, to traverse a vector named `values`, you would typically use
    a loop, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this code example, `it` is an iterator that moves through each element in
    values. The loop continues until `it` reaches the position indicated by `values.end()`.
  prefs: []
  type: TYPE_NORMAL
- en: Using constant iterators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you’re sure you won’t modify the elements during iteration, it is good
    practice to use constant iterators. They ensure that the elements remain immutable
    during traversal.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you’re a museum guide showing visitors the precious artifacts. You want
    them to appreciate and understand the history, but you wouldn’t want them to touch
    or modify these delicate items. Similarly, in programming, there are scenarios
    where you’d like to traverse a collection, showcasing (or reading) its contents
    but not altering them. This is where constant iterators come into play.
  prefs: []
  type: TYPE_NORMAL
- en: 'To employ a constant iterator, `std::vector` provides the `cbegin()` and `cend()`
    member functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Benefits of iteration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Why is iteration so pivotal? By effectively iterating over vectors, you can
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Process data**: Whether normalizing data, filtering it, or performing any
    transformation, iteration is at the core of these operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Search operations**: Looking for a particular element? Iteration allows you
    to comb through each item, checking against a condition or a value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sort`, `find`, and `transform`, require iterators to specify the range they
    operate on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The versatility and efficiency of `std::vector` iteration make it a prime choice
    for developers. While arrays also allow for traversal, vectors offer dynamic size,
    robustness against overflows, and integration with the rest of the C++ STL, making
    them a preferred choice in many scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, mastering iteration with `std::vector` is foundational to becoming
    proficient in C++. By understanding how to traverse this dynamic array, you unlock
    a wide range of capabilities, enabling you to harness the power of algorithms,
    efficiently process data, and craft robust, performant software. You’ll build
    a deeper understanding of other vector utilities as we progress, solidifying your
    knowledge and skills in this vibrant language.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ve navigated `std::vector` traversal with iterators, learning
    to access elements sequentially and utilize constant iterators for read-only operations.
    Understanding these techniques is critical for crafting flexible and optimized
    C++ code compatible with various container types. Iteration is a cornerstone of
    data manipulation in the STL; mastering it is essential for harnessing the library’s
    full potential.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we turn to the *Using std::begin and std::end* section to further our
    iterator knowledge. We’ll uncover how these functions standardize the initiation
    and conclusion of iterations across different containers, paving the way for more
    versatile and decoupled code.
  prefs: []
  type: TYPE_NORMAL
- en: Using std::begin and std::end
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you discover more use cases for `std::vector`, you’ll encounter situations
    where it is advantageous, or even necessary, to venture beyond member functions.
    Here’s where non-member functions, specifically `std::begin` and `std::end`, step
    into the spotlight. These two functions are handy and offer a more generic way
    to access the beginning and end of a container, including but not limited to `std::vector`.
  prefs: []
  type: TYPE_NORMAL
- en: Why the distinction, you might ask? Aren’t there member functions such as `vector::begin()`
    and `vector::end()`? Indeed, there are. However, the beauty of the non-member
    `std::begin` and `std::end` is their broader applicability across different container
    types, making your code more flexible and adaptable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Vectors in C++ offer a potent blend of dynamic memory and continuous storage,
    making them indispensable in many coding scenarios. But to truly leverage their
    potential, understanding their interaction with iterators is crucial. While the
    spotlight often shines on the `begin()` and `end()` member functions, there are
    two versatile actors behind the curtains: `std::begin` and `std::end`.'
  prefs: []
  type: TYPE_NORMAL
- en: When working with C++ containers, the `std::begin` function might seem like
    another way to start iterating through a container. However, it comes with its
    own set of marvels. While it primarily fetches an iterator pointing to the first
    element of a container, its application isn’t limited to vectors alone.
  prefs: []
  type: TYPE_NORMAL
- en: When you pass `std::vector` to `std::begin`, it is like having a backstage pass.
    Behind the scenes, the function smoothly delegates the task by calling the vector’s
    `begin()` member function. This intuitive behavior ensures that the transition
    remains seamless even as you venture into generic programming.
  prefs: []
  type: TYPE_NORMAL
- en: Mirroring its counterpart, `std::end` is more than just a function that returns
    an iterator pointing past the last element. It’s a testament to C++’s commitment
    to consistency. Just as `std::begin` relies on `begin()`, when you engage with
    `std::end`, it subtly and efficiently calls upon the container’s `end()` member
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'And here’s the true magic: while these non-member functions shine with `std::vector`,
    they are not constrained by it. Their generic nature means they play well with
    various containers, from traditional arrays to lists, making them indispensable
    tools for those seeking adaptability in their code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example that demonstrates the utility of the `std::begin`
    and `std::end` non-member functions in contrast to their member counterparts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In this preceding example, we notice the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We have a `displayElements` generic function that takes any container and uses
    the `std::begin` and `std::end` non-member functions to iterate over its elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We then create three containers: a `std::vector`, a `std::list`, and a `std::array.`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We call `displayElements` for each container to display its elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `std::begin` and `std::end`, our `displayElements` function is versatile
    and works across different container types. This would not have been as straightforward
    if we relied solely on member functions such as `vector::begin()` and `vector::end()`,
    emphasizing the power and flexibility of non-member functions.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine being handed a toolkit that promises not just efficiency but also adaptability.
    That’s what `std::vector` offers, complemented beautifully by functions such as
    `std::begin` and `std::end`. They’re not just functions but gateways to more type-agnostic
    memory management and iteration.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve seen how `std::begin` and `std::end` elevate our code by extending iteration
    capabilities to all STL containers, not just `std::vector`. Embracing these non-member
    functions is key to crafting container-independent, reusable code—a pillar for
    versatile algorithm implementation in C++. Understanding this distinction is fundamental
    for employing iterators effectively across the STL.
  prefs: []
  type: TYPE_NORMAL
- en: Looking ahead, the next section will guide us through the nuances of iterator
    categories and their essentials. This insight is pivotal for aligning algorithms
    with appropriate iterator capabilities, reflecting the depth of C++’s type system
    and its close ties with pointer semantics.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding iterator requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Iterators in C++ serve as a consistent interface to various data structures,
    such as containers and, since C++20, ranges. The iterator library supplies definitions
    for iterators and associated traits, adaptors, and utility functions.
  prefs: []
  type: TYPE_NORMAL
- en: Given that iterators extend the idea of pointers, they inherently adopt many
    pointer semantics in C++. Consequently, any function template accepting iterators
    can also seamlessly work with regular pointers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Iterators are categorized into six types: *LegacyInputIterator*, *LegacyOutputIterator*,
    *LegacyForwardIterator*, *LegacyBidirectionalIterator*, *LegacyRandomAccessIterator*,
    and *LegacyContiguousIterator*. Instead of being determined by their intrinsic
    types, these categories are distinguished by the operations they support. As an
    illustration, pointers accommodate all the operations defined for *LegacyRandomAccessIterator*,
    allowing them to be utilized wherever a *LegacyRandomAccessIterator* is required.'
  prefs: []
  type: TYPE_NORMAL
- en: These iterator categories, except for *LegacyOutputIterator*, can be arranged
    hierarchically. More versatile iterator categories, such as *LegacyRandomAccessIterator*,
    encompass the capabilities of the less powerful ones, such as *LegacyInputIterator*.
    If an iterator conforms to any of these categories and also meets the criteria
    for *LegacyOutputIterator*, it’s termed a mutable iterator, capable of input and
    output functions. Iterators that aren’t mutable are referred to as constant iterators.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discovered the critical role of iterators as the unifying
    interface for C++ data structures, including containers and ranges. We examined
    how the iterator library in C++ defines iterator types, associated traits, adaptors,
    and utility functions, providing a standardized way to traverse these structures.
  prefs: []
  type: TYPE_NORMAL
- en: We learned that iterators extend pointer semantics, allowing any function template
    that accepts iterators to work seamlessly with pointers. We further explored the
    hierarchy of iterator categories—*LegacyInputIterator*, *LegacyOutputIterator*,
    *LegacyForwardIterator*, *LegacyBidirectionalIterator*, *LegacyRandomAccessIterator*,
    and *LegacyContiguousIterator*. These categories are defined not by their types
    but by the operations they support, with more advanced iterators inheriting the
    capabilities of the simpler ones.
  prefs: []
  type: TYPE_NORMAL
- en: This knowledge is crucial for us as it informs our choice of iterator based
    on the operations we need to perform. Understanding the requirements and capabilities
    of each iterator category enables us to write more efficient and robust code,
    as we can choose the least powerful iterator that satisfies our needs, thereby
    avoiding unnecessary performance overhead.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, titled *Range-based for loops in C++*, we will transition
    from the theoretical underpinnings of iterators to practical application by learning
    how to use range-based `for` loops to iterate over `std::vector`. We will understand
    how these loops utilize `std::begin` and `std::end` under the hood, providing
    a more intuitive and error-resistant method for element access and modification.
  prefs: []
  type: TYPE_NORMAL
- en: Range-based for loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In C++, range-based `for` loops provide a concise and practical mechanism for
    iterating over containers such as `std::vector`. Armed with knowledge about `std::vector`
    operations and the `std::begin` and `std::end` functions, it’s evident that range-based
    `for` loops offer a streamlined traversal technique.
  prefs: []
  type: TYPE_NORMAL
- en: Traditional iteration over a vector necessitates declaring an iterator, initializing
    it to the container’s start, and updating it to progress to the end. Although
    this method works, it requires careful management and is prone to errors. Range-based
    `for` loops present a more efficient solution.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of range-based for loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following code demonstrates the basic structure of a range-based `for`
    loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this example, every integer within the `numbers` vector is printed. This
    approach eliminates the need for explicit iterators and manual loop boundary definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Underlying mechanism
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Internally, the range-based `for` loop leverages the `begin()` and `end()` functions
    to navigate the container. The loop successively retrieves each item from the
    container, assigning it to the loop variable (`num` in this case).
  prefs: []
  type: TYPE_NORMAL
- en: This approach simplifies the iteration process, allowing developers to concentrate
    on operations to perform on each element rather than the retrieval process.
  prefs: []
  type: TYPE_NORMAL
- en: When to use range-based for loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Range-based `for` loops are particularly beneficial in the following situations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`for` loops are optimal for complete vector traversal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Direct iterator access isn’t necessary**: These loops are excellent for displaying
    or altering elements. However, traditional loops are more appropriate if access
    to the iterator itself is required (e.g., for mid-traversal element insertion
    or deletion).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`for` loops succinctly express the intention to operate on every container
    element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying elements during iteration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For scenarios where vector element modification is needed during iteration,
    it’s essential to use a reference as the loop variable, which is shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this case, each integer within the numbers vector is multiplied by two. Without
    the reference `(&)`, the loop would alter a copied element, leaving the original
    vector untouched.
  prefs: []
  type: TYPE_NORMAL
- en: Range-based `for` loops are a testament to C++’s ongoing development, striking
    a balance between performance and readability. They grant developers a direct
    way to navigate containers, enhancing code clarity and minimizing potential mistakes.
    As you progress in C++, it’s crucial to understand the available tools and select
    the most fitting ones for your tasks. A thorough grasp of `std::vector` functions
    and capabilities ensures effective utilization in diverse situations.
  prefs: []
  type: TYPE_NORMAL
- en: This section highlighted range-based for loops’ advantages in iterating through
    STL containers, emphasizing their readability and minimized error potential compared
    to traditional `for` loops. Utilizing `std::begin` and `std::end`, these loops
    streamline the iteration process, letting us concentrate on the element-level
    logic. They are optimal when direct iterator control isn’t needed, exemplifying
    modern C++’s emphasis on high-level abstractions for efficiency and clarity.
  prefs: []
  type: TYPE_NORMAL
- en: Moving forward, the *Creating a custom iterator* section will utilize our iterators
    for advanced abstraction, data transformation, or filtered data views. We’ll explore
    the technical requirements and how to align our custom iterators with the STL’s
    categorization.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom iterator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the beauties of C++ is its flexibility, empowering developers to mold
    the language to suit their needs. This flexibility doesn’t stop with built-in
    functionality for container iteration. While `std::vector` comes with its set
    of built-in iterators, nothing is stopping us from creating our own. But why might
    we want to?
  prefs: []
  type: TYPE_NORMAL
- en: The appeal of custom iterators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s examine the reasons you’d want to implement a custom iterator:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Enhanced abstraction**: Consider a vector storing a matrix in a flat format.
    Wouldn’t it be more intuitive to iterate through rows or columns rather than individual
    elements? Custom iterators can facilitate this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data transformation**: Perhaps you wish to iterate through the vector but
    retrieve transformed data, like the squared values of each element. Instead of
    changing the data before or during retrieval, a custom iterator can abstract this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::vector`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom STL iterator might seem like an arduous task, but with the
    proper guidance, it is a breeze! At its core, an iterator is a fancy pointer—a
    guide that escorts you through the elements of a container. To make your iterator
    play well with the STL, there are certain member functions you’ll need to implement.
  prefs: []
  type: TYPE_NORMAL
- en: Core requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The exact set of these functions varies based on the type of iterator you’re
    creating, but some are common across the board.
  prefs: []
  type: TYPE_NORMAL
- en: '`value_type`: Denotes the type of the element the iterator points to.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`difference_type`: Represents the distance between two iterators.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`pointer` and `reference`: Define the iterator’s pointer and reference types.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`iterator_category`: Classifies the iterator into categories such as input,
    output, forward, bidirectional, or random access. Each category has its unique
    characteristics, making iterators versatile and fun!'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`operator*`: The dereference operator, granting access to the element your
    iterator points to.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`operator++`: The increment operators! These move your iterator forward (either
    in pre-increment or post-increment style).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`operator==` and `operator!=`: Equipped with these, your iterators can be compared,
    letting algorithms know if they’ve reached the end or need to keep going.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Iterator categories and their specialties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Iterators come in different flavors; each flavor (or category) has unique requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '`operator*`, `operator++`, `operator==`, and `operator!=`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`operator*` and `operator++`*   **Forward iterators**: They combine input and
    output iterators—reading, writing, and always moving forward.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Essential**: All the core requirements*   `operator--` to step back*   `std::vector`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`operator+`, `operator-`, `operator+=`, `operator-=`, `operator[]`, and relational
    operators such as `operator<`, `operator<=`, `operator>`, and `operator>=`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A random access iterator in C++ is one of the most potent iterator categories
    and requires several functions and operators to be fully compatible with STL algorithms
    and containers.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here’s a list of functions and operators you’d typically implement for a random
    access iterator:'
  prefs: []
  type: TYPE_NORMAL
- en: '`iterator_category` (should be set to `std::random_access_iterator_tag`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value_type`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`difference_type`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pointer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reference`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`operator*()` (dereference operator)*   `operator->()` (arrow operator)*   `operator++()`
    (prefix increment)*   `operator++(int)` (postfix increment)*   `operator--()`
    (prefix decrement)*   `operator--(int)` (postfix decrement)*   `ptrdiff_t`):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`operator+(difference_type)` (move iterator forward by some amount)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`operator-(difference_type)` (move iterator backward by some amount)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`operator+=(difference_type)` (increment iterator by some amount)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`operator-=(difference_type)` (decrement iterator by some amount)*   `operator-(const
    RandomAccessIteratorType&)`*   `operator[](difference_type)`*   `operator==` (equality)*   `operator!=`
    (inequality)*   `operator<` (less than)*   `operator<=` (less than or equal to)*   `operator>`
    (greater than)*   `operator>=` (greater than or equal to)*   **Swap** (sometimes
    useful, though not strictly required for the iterator itself):'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A swap function to swap two iterators
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Not all of these will always be applicable, especially if the underlying data
    structure has limitations or the iterator’s specific usage case doesn’t require
    all these operations. However, for full compatibility with STL’s random access
    iterators, this is the complete set of functions and operators you’d want to consider
    implementing.
  prefs: []
  type: TYPE_NORMAL
- en: A custom iterator example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s create a custom iterator for `std::vector<int>` that, when dereferenced,
    returns the square of the value in the vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'When run, this code will output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The iterators in the code can be used very similarly to a built-in array or
    `std::vector` iterators but with the unique functionality of squaring values when
    dereferenced.
  prefs: []
  type: TYPE_NORMAL
- en: Custom iterator challenges and use cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating a custom iterator isn’t just about understanding your data or use
    case; it is also about grappling with some challenges:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Complexity**: Crafting an iterator requires adherence to certain iterator
    concepts. Different requirements must be met whether it is an input, forward,
    bidirectional, or random access iterator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`push_back` or `erase`. Ensuring the custom iterator remains valid is essential
    for safe and predictable behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance overhead**: With added functionality can come extra computation.
    Ensuring that the iterator’s overhead doesn’t negate its benefits is crucial.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Illustrative use cases of custom iterators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To wrap our minds around the idea, let’s briefly look at a couple of scenarios
    where custom iterators shine:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::vector` might store pixel data linearly for an image. A custom iterator
    could facilitate iteration by rows, channels, or even regions of interest.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::vector<char>`, an iterator could be designed to jump from word to word
    or sentence to sentence, ignoring whitespace and punctuation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Statistical sampling**: An iterator might sample every *n*th element for
    large datasets stored in vectors, providing a quick overview without traversing
    each element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom iterator involves adhering to specific conventions and defining
    a set of required operators to give it the behavior of an iterator.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows us how to create a custom iterator for extracting
    the alpha channel from a bitmap stored in `std::vector`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We’ve defined an `RGBA` struct in this example to represent the color. We then
    create a custom `AlphaIterator` iterator to navigate the alpha channel. Next,
    the iterator uses the underlying `std::vector<RGBA>::iterator`, but exposes only
    the alpha channel when dereferenced. Finally, the `main` function demonstrates
    using this iterator to print alpha values.
  prefs: []
  type: TYPE_NORMAL
- en: 'This custom iterator adheres to the conventions of a C++ input iterator, making
    it usable with various algorithms and range-based `for` loops. The `AlphaIterator`
    class in the example demonstrates a custom input iterator’s basic structure and
    behavior in C++. Here’s a breakdown of the key member functions and their significance
    for STL compatibility:'
  prefs: []
  type: TYPE_NORMAL
- en: '`iterator_category`: Defines the type/category of the iterator. It helps algorithms
    determine the operations supported by the iterator. Here, it is defined as `std::input_iterator_tag`,
    indicating it is an input iterator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value_type`: The data type that can be read from the underlying container.
    Here, it is `uint8_t` representing the alpha channel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`difference_type`: Used to represent the result of subtracting two iterators.
    Commonly used in random access iterators.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pointer` and `reference`: The pointer and reference types to `value_type`.
    They give direct access to the value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`explicit AlphaIterator`(`std::vector<RGBA>::iterator itr`): This constructor
    is essential to initialize the iterator with an instance of the underlying `std::vector`
    iterator.*   `reference operator*()`: The dereference operator returns a reference
    to the current item in the sequence. For this iterator, it returns a reference
    to the alpha channel of the RGBA value.*   `AlphaIterator& operator++()`: The
    pre-increment operator advances the iterator to the next element.*   `AlphaIterator
    operator++(int)`: The post-increment operator advances the iterator to the next
    element but returns an iterator to the current element before the increment. This
    behavior is needed for constructs such as `it++`.*   `bool operator==(const AlphaIterator&
    other) const`: Checks whether two iterators point to the same position. This is
    crucial for comparison and to determine the end of a sequence.*   `bool operator!=(const
    AlphaIterator& other) const`: The opposite of the previous one: this checks whether
    two iterators are not equal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These member functions and type aliases are essential to make the iterator compatible
    with the STL and enable its seamless use with various STL algorithms and constructs.
    They define the fundamental interface and semantics required for a functioning
    input iterator.
  prefs: []
  type: TYPE_NORMAL
- en: Additional operations would be required for iterators with more capabilities
    (such as bidirectional or random access). But for the input iterator demonstrated
    in the `AlphaIterator`, the preceding are the core components.
  prefs: []
  type: TYPE_NORMAL
- en: This section covered custom iterators and understanding their creation for specific
    needs such as data abstraction, transformation, and filtering. Learning to define
    essential type aliases and implement key operators is crucial in extending the
    functionality of `std::vector`. This knowledge lets us customize data interaction,
    ensuring our code meets the unique domain requirements with precision.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have comprehensively explored the role and usage of iterators
    as they apply to one of the most versatile containers in the C++ STL. We started
    by discussing the various types of iterators available in the STL—input, output,
    forward, reverse, bidirectional, and random access—and their specific applications
    and support operations.
  prefs: []
  type: TYPE_NORMAL
- en: We then moved on to practical iteration techniques, detailing how to traverse
    `std::vector` effectively using standard and constant iterators. We underscored
    the importance of choosing the correct type of iterator for the task at hand to
    write clean, efficient, and error-resistant code.
  prefs: []
  type: TYPE_NORMAL
- en: The section on using `std::begin` and `std::end` expanded our toolkit, showing
    how these non-member functions can make our code more flexible by not being tightly
    bound to container types. We also covered the requirements and categorization
    of iterators, essential knowledge for understanding the STL’s inner workings,
    and implementing custom iterators.
  prefs: []
  type: TYPE_NORMAL
- en: Range-based `for` loops were introduced as a modern C++ feature that simplifies
    iteration by abstracting the details of iterator management. We learned when and
    how to use these loops to their fullest potential, particularly noting the ease
    with which they allow the modification of elements during iteration.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we tackled the advanced topic of creating custom iterators. We discovered
    the motivations behind this, such as providing more intuitive navigation or presenting
    a filtered data view. We examined the core requirements, challenges, and use cases
    for custom iterators, rounding out our understanding of how they can be tailored
    to fit specialized needs.
  prefs: []
  type: TYPE_NORMAL
- en: While the standard iterators provided with `std::vector` cover many use cases,
    they’re not the end of the story. Custom iterators offer an avenue to stretch
    the boundaries of what’s possible with iteration, tailor-fitting traversal logic
    to specific needs. The complexity of crafting reliable custom iterators is not
    to be underestimated. As we close this chapter, remember that custom iterators
    can be powerful tools in the right hands. You can make informed decisions about
    when and how to wield them with a solid understanding of their workings.
  prefs: []
  type: TYPE_NORMAL
- en: The knowledge gained in this chapter is beneficial as it enables the creation
    of more sophisticated, robust, and performant C++ applications. Understanding
    and utilizing iterators effectively allows us to harness the full power of `std::vector`
    and write container-agnostic and highly optimized algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: The upcoming chapter, *Mastering Memory and Allocators with std::vector*, builds
    upon our existing knowledge and directs our focus toward memory efficiency, a
    critical aspect of high-performance C++ programming. We will continue to emphasize
    the practical, real-world applications of these concepts, ensuring that the content
    remains valuable and directly applicable to our work as intermediate-level C++
    developers.
  prefs: []
  type: TYPE_NORMAL
