- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Mastering Iterators with std::vector
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 掌握 std::vector 中的迭代器
- en: In this chapter, we will gain a deeper exploration of `std::vector`, focusing
    on the intricacies of iteration. This chapter equips us with the knowledge to
    handle the ins and outs of vector traversal. Mastering these core areas bolsters
    the efficiency and reliability of one’s C++ code and provides insights into the
    underpinnings of dynamic array behavior, which is critical for effective C++.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更深入地探索 `std::vector`，重点关注迭代的复杂性。本章将使我们掌握处理向量遍历的方方面面。掌握这些核心领域可以增强 C++
    代码的效率和可靠性，并深入了解动态数组行为的基础，这对于有效使用 C++ 至关重要。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Types of iterators in the STL
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: STL 中的迭代器类型
- en: Basic iteration techniques with `std::vector`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::vector` 的基本迭代技术
- en: Using `std::begin` and `std::end`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::begin` 和 `std::end`
- en: Understanding iterator requirements
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解迭代器要求
- en: Range-based `for` loops
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于范围的 `for` 循环
- en: Creating a custom iterator
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义迭代器
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code in this chapter can be found on GitHub:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码可以在 GitHub 上找到：
- en: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
- en: Types of iterators in the STL
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: STL 中的迭代器类型
- en: In the **Standard Template Library** (**STL**), iterators play a pivotal role
    by connecting algorithms to containers. They provide a means for developers to
    traverse, access, and potentially modify the elements of a container. Iterators
    are essential tools for efficient data manipulation in the STL. However, they
    aren’t uniform in their functionalities. The STL delineates iterators into five
    primary types, each offering varying access and control over the elements. This
    section will get into these iterator types, elaborating on their distinct capabilities
    and uses.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **标准模板库**（**STL**）中，迭代器通过连接算法和容器发挥着关键作用。它们为开发者提供了一种遍历、访问以及可能修改容器中元素的手段。迭代器是
    STL 中高效数据操作的基本工具。然而，它们的函数并不统一。STL 将迭代器划分为五种主要类型，每种类型提供不同的访问和控制元素的能力。本节将深入探讨这些迭代器类型，详细阐述它们的独特功能和用途。
- en: Input iterators
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入迭代器
- en: Input iterators (*LegacyInputIterator*) are the starting point in exploring
    iterator types. They represent the foundational category of iterators. As their
    name implies, input iterators focus on reading and progressing through elements.
    They enable developers to advance to the subsequent element in the container and
    retrieve its value. It’s crucial to note that revisiting the prior element is
    impossible after moving an input iterator forward, and modifying the present element
    is not permitted. This iterator category is often employed in algorithms that
    require data processing without modification.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 输入迭代器（*LegacyInputIterator*）是探索迭代器类型的起点。它们代表了迭代器的基础类别。正如其名称所暗示的，输入迭代器专注于读取和遍历元素。它们使开发者能够前进到容器中的下一个元素并检索其值。需要注意的是，在移动输入迭代器之后，无法回退到先前元素，并且不允许修改当前元素。这个迭代器类别通常用于需要数据处理但不修改数据的算法中。
- en: 'The following is a simple example using `std::vector` and its input iterator:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用 `std::vector` 及其输入迭代器的简单示例：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, we use `std::vector<int>::const_iterator` as the input iterator
    to traverse the vector and print its elements. We’re following the principles
    of the input iterator by not modifying the elements or moving the iterator backward.
    It is important to note that we cannot change the element or go back to the previous
    element with the input iterator.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们使用 `std::vector<int>::const_iterator` 作为输入迭代器遍历向量并打印其元素。我们遵循输入迭代器的原则，不修改元素或移动迭代器向后。需要注意的是，使用输入迭代器无法更改元素或回到前一个元素。
- en: Output iterators
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输出迭代器
- en: 'Next, we will look into output iterators (*LegacyOutputIterator*). Although
    they bear similarities to input iterators, they serve a different primary function:
    writing to elements. Output iterators facilitate assignment to the elements they
    reference. However, directly reading these elements through the iterator is not
    supported. They are commonly utilized in algorithms designed to produce and populate
    a sequence of values within a container.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨输出迭代器（*LegacyOutputIterator*）。尽管它们与输入迭代器有相似之处，但它们的主要功能不同：向元素写入。输出迭代器简化了对它们引用的元素的赋值。然而，通过迭代器直接读取这些元素是不支持的。它们通常用于设计用于在容器内生成和填充值序列的算法。
- en: 'Here’s an example demonstrating the use of output iterators with `std::vector`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个使用`std::vector`演示输出迭代器使用的例子：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code, `std::back_inserter` is an output iterator adapter designed
    to work with containers like `std::vector`. It allows you to *write* or push new
    values to the back of the vector. We use the `std::generate_n` algorithm to generate
    and insert the numbers. This pattern perfectly encapsulates the *write-only* characteristic
    of output iterators. We don’t use the output iterator to read. For reading, we
    use a regular iterator.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`std::back_inserter`是一个输出迭代器适配器，用于与`std::vector`等容器一起工作。它允许你向向量的末尾*写入*或推送新的值。我们使用`std::generate_n`算法生成并插入数字。这种模式完美地封装了输出迭代器的*只写*特性。我们不使用输出迭代器来读取。对于读取，我们使用常规迭代器。
- en: Forward iterators
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正向迭代器
- en: With the basics behind us, let’s move on to the forward iterators (*LegacyForwardIterator*).
    Forward iterators combine the capabilities of both input iterators and output
    iterators. Thus, they support reading, writing, and—as the name implies—always
    moving forward. Forward iterators never reverse their direction. Their versatility
    makes them well-suited for many algorithms that operate on singly linked lists
    (i.e., `std::forward_list`).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握基础知识之后，让我们继续前进，了解正向迭代器（*LegacyForwardIterator*）。正向迭代器结合了输入迭代器和输出迭代器的功能。因此，它们支持读取、写入，并且正如其名称所暗示的——始终向前移动。正向迭代器永远不会改变其方向。它们的通用性使它们非常适合许多在单链表（即`std::forward_list`）上操作的计算算法。
- en: '`std::forward_list` is explicitly designed for singly linked lists, making
    it the ideal candidate for illustrating forward iterators.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::forward_list`是专门为单链表设计的，因此它是展示正向迭代器的理想选择。'
- en: 'Here’s a simple code example to illustrate their use:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个简单的代码示例来说明它们的使用：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here is the example output:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是示例输出：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This code initializes a `std::forward_list`, uses a forward iterator to traverse
    and display its elements, and then increments each element by 1, demonstrating
    the reading and writing capabilities of the forward iterator.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码初始化了一个`std::forward_list`，使用正向迭代器遍历并显示其元素，然后递增每个元素1，展示了正向迭代器的读取和写入能力。
- en: Reverse iterators
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反向迭代器
- en: Sometimes, you might find the need to traverse the vector in reverse. Enter
    `rbegin()` and `rend()`. These functions return reverse iterators that start at
    the end of the vector and conclude at the beginning. Such backward traversal can
    be handy in specific algorithms and data-processing tasks.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能需要以相反的顺序遍历向量。这时就出现了`rbegin()`和`rend()`。这些函数返回反向迭代器，它们从向量的末尾开始，到开头结束。这种反向遍历在特定的算法和数据处理的任务中可能很有用。
- en: Note the reverse iterator is technically an iterator adaptor. `std::reverse_iterator`
    is classified as an iterator adaptor. It takes a given iterator, which should
    either be a *LegacyBidirectionalIterator,* or comply with the `bidirectional_iterator`
    criteria introduced from C++20 onwards, and reverses its direction. When given
    a bidirectional iterator, `std::reverse_iterator` yields a new iterator that traverses
    the sequence in the opposite direction—from the end to the beginning.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，反向迭代器在技术上是一个迭代器适配器。`std::reverse_iterator`被分类为迭代器适配器。它接受一个给定的迭代器，该迭代器应该是*LegacyBidirectionalIterator*，或者从C++20开始遵守`bidirectional_iterator`标准。它反转其方向。当给定一个双向迭代器时，`std::reverse_iterator`产生一个新的迭代器，以相反的方向遍历序列——从末尾到开头。
- en: Bidirectional iterators
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 双向迭代器
- en: Continuing, we address bidirectional iterators (*LegacyBidirectionalIterator*).
    These iterators permit traversal in both forward and backward directions within
    a container. Inheriting all functionalities of forward iterators, they introduce
    the ability to move in the reverse direction. Their design is particularly beneficial
    for data structures such as doubly linked lists, where bidirectional traversal
    is frequently required.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 继续讨论，我们处理双向迭代器（*LegacyBidirectionalIterator*）。这些迭代器允许在容器内向前和向后遍历。继承所有正向迭代器的功能，它们引入了反向移动的能力。它们的设计特别有利于需要频繁双向遍历的数据结构，如双向链表。
- en: 'Here’s an example using `std::list` and its bidirectional iterators:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个使用 `std::list` 和其双向迭代器的例子：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here is the example output:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是示例输出：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, we create a `std::list` of integers. We then demonstrate bidirectional
    iteration by first traversing the list in a forward direction using a regular
    iterator and then in reverse using a reverse iterator.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个整数 `std::list`。然后，我们通过首先使用常规迭代器向前遍历列表，然后使用反向迭代器反向遍历，来演示双向迭代。
- en: Random access iterators
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 随机访问迭代器
- en: Concluding our iterator categorization, we introduce the random access iterators
    (*LegacyRandomAccessIterator* and *LegacyContiguousIterator*). These iterators
    represent the highest versatility, enabling more than just sequential access.
    With random access iterators, developers can move forward by multiple steps, retreat
    backward, or access elements directly without sequential traversal. Such capabilities
    make them highly suitable for data structures such as arrays or vectors, which
    allow direct element access.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的迭代器分类中，我们介绍了随机访问迭代器（*LegacyRandomAccessIterator* 和 *LegacyContiguousIterator*）。这些迭代器代表了最高的通用性，不仅允许顺序访问。使用随机访问迭代器，开发者可以向前移动多个步骤，向后退，或直接访问元素而不需要顺序遍历。这些功能使它们非常适合允许直接元素访问的数据结构，如数组或向量。
- en: 'Here’s an example showcasing the flexibility and capabilities of random access
    iterators with `std::vector`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个展示随机访问迭代器（`std::vector`）的灵活性和能力的例子：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This example demonstrates the various capabilities of random access iterators.
    We start with direct access, then jump positions, leap back, calculate distances,
    and even access elements in a non-linear manner.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了随机访问迭代器的各种功能。我们开始于直接访问，然后跳过位置，跳跃回退，计算距离，甚至以非线性的方式访问元素。
- en: It is vital to understand that the choice of iterator type is not arbitrary.
    Each one is designed with specific use cases in mind, and choosing the right one
    can significantly enhance the efficiency and elegance of your C++ code. When working
    with STL algorithms and containers, having a solid grasp of the different iterator
    types and their functionalities is paramount. This knowledge not only streamlines
    the coding process but also aids in debugging and optimizing the performance of
    your applications.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 理解迭代器类型的选择并非任意选择至关重要。每个迭代器都是针对特定的用例设计的，选择正确的一个可以显著提高您 C++ 代码的效率和优雅性。当与 STL 算法和容器一起工作时，对不同的迭代器类型及其功能有扎实的掌握至关重要。这种知识不仅简化了编码过程，还有助于调试和优化应用程序的性能。
- en: 'In exploring the STL’s iterators, we’ve learned the six core types: input,
    output, forward, reverse, bidirectional, and random access. Recognizing each type’s
    unique functions is vital for efficient C++ programming, as it affects how we
    traverse and interact with STL containers. Grasping these differences is not just
    academic; it’s practical. It enables us to choose the right iterator for tasks,
    such as using random access iterators with `std::vector` for their rapid element
    access capability.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索 STL 的迭代器时，我们学习了六种核心类型：输入、输出、正向、反向、双向和随机访问。认识到每种类型的独特功能对于高效的 C++ 编程至关重要，因为它影响我们如何遍历和与
    STL 容器交互。掌握这些差异不仅具有学术意义，而且具有实践意义。它使我们能够为任务选择正确的迭代器，例如使用 `std::vector` 的随机访问迭代器，以利用其快速元素访问能力。
- en: In the next section, we’ll apply this knowledge, where we’ll see iteration in
    action, emphasize the use of constant iterators for read-only purposes, and underscore
    the adaptability of iterators across various containers, setting the stage for
    robust and versatile code development.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将应用这些知识，我们将看到迭代在实际中的应用，强调使用常量迭代器进行只读目的，并强调迭代器在各种容器中的适应性，为编写健壮和通用的代码奠定基础。
- en: Basic iteration techniques with std::vector
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 std::vector 的基本迭代技术
- en: Now that we understand the different types of iterators available, let’s explore
    the essential concept of iterating over data structures. Iteration is a fundamental
    technique in programming that allows developers to access and manipulate each
    element in a data structure efficiently. Specifically for `std::vector`, iteration
    is crucial due to its dynamic nature and widespread use in C++ applications. By
    mastering iteration, you can harness the full potential of `std::vector`, enabling
    operations such as searching, sorting, and modifying elements with precision and
    ease. This section aims to deepen your understanding of why iteration is a crucial
    skill in managing and utilizing data structures effectively, setting the stage
    for more advanced applications in your programs.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了可用的不同类型的迭代器，让我们来探索遍历数据结构的基本概念。迭代是编程中的一个基本技术，允许开发者高效地访问和操作数据结构中的每个元素。特别是对于
    `std::vector`，由于其动态特性和在 C++ 应用程序中的广泛使用，迭代至关重要。通过掌握迭代，你可以充分利用 `std::vector` 的潜力，实现诸如搜索、排序和精确轻松地修改元素等操作。本节旨在加深你对为什么迭代是有效管理和利用数据结构的关键技能的理解，为你在程序中更高级的应用打下基础。
- en: Iterating over std::vector
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遍历 `std::vector`
- en: One of the powerful features of `std::vector` is its ability to allow seamless
    traversal of its elements. Whether you’re accessing individual elements or looping
    through each one, understanding the iterative capabilities of `std::vector` is
    crucial. Iteration is fundamental to numerous operations in programming, from
    data processing to algorithmic transformations. As you journey through this section,
    you’ll become well acquainted with how to traverse vectors in C++ efficiently
    and effectively.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::vector` 的一个强大功能是它允许无缝遍历其元素。无论你是访问单个元素还是遍历每一个元素，理解 `std::vector` 的迭代能力至关重要。迭代是编程中许多操作的基础，从数据处理到算法转换。随着你进入本节，你将熟悉如何在
    C++ 中高效且有效地遍历向量。'
- en: At the heart of iteration in the C++ STL is the concept of iterators. Think
    of iterators as sophisticated pointers, guiding you through each element in a
    container, such as our beloved `std::vector`. Armed with iterators, one can move
    forward, backward, jump to the start or the end, and access the content they point
    to, making them indispensable tools in your C++ toolkit.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: C++ STL 中迭代的核心概念是迭代器。将迭代器想象成高级指针，引导你遍历容器中的每个元素，例如我们钟爱的 `std::vector`。有了迭代器，你可以向前、向后移动，跳转到开始或结束位置，并访问它们所指向的内容，这使得它们成为你的
    C++ 工具箱中不可或缺的工具。
- en: Basic iteration using iterators
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用迭代器进行基本迭代
- en: Every `std::vector` provides a set of member functions that return iterators.
    The two primary ones are `begin()` and `end()`. While we’ll dive deeper into these
    functions in the next section, understand that `begin()` returns an iterator pointing
    to the first element, and `end()` returns an iterator pointing just *past* the
    last element.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `std::vector` 都提供了一组成员函数，这些函数返回迭代器。其中两个主要的是 `begin()` 和 `end()`。虽然我们将在下一节深入探讨这些函数，但请理解
    `begin()` 返回一个指向第一个元素的迭代器，而 `end()` 返回一个指向最后一个元素之后的迭代器。
- en: 'For instance, to traverse a vector named `values`, you would typically use
    a loop, as shown in the following code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要遍历名为 `values` 的向量，你通常会使用循环，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this code example, `it` is an iterator that moves through each element in
    values. The loop continues until `it` reaches the position indicated by `values.end()`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码示例中，`it` 是一个迭代器，它遍历 `values` 中的每个元素。循环会一直继续，直到 `it` 达到 `values.end()` 指示的位置。
- en: Using constant iterators
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用常量迭代器
- en: When you’re sure you won’t modify the elements during iteration, it is good
    practice to use constant iterators. They ensure that the elements remain immutable
    during traversal.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当你确定在迭代过程中不会修改元素时，使用常量迭代器是一种良好的做法。它们确保在遍历过程中元素保持不变。
- en: Imagine you’re a museum guide showing visitors the precious artifacts. You want
    them to appreciate and understand the history, but you wouldn’t want them to touch
    or modify these delicate items. Similarly, in programming, there are scenarios
    where you’d like to traverse a collection, showcasing (or reading) its contents
    but not altering them. This is where constant iterators come into play.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你是一名博物馆导游，向游客展示珍贵的文物。你希望他们欣赏和理解历史，但你不希望他们触摸或修改这些脆弱的物品。同样，在编程中，也有你希望遍历集合、展示（或读取）其内容但不更改它们的情况。这就是常量迭代器发挥作用的地方。
- en: 'To employ a constant iterator, `std::vector` provides the `cbegin()` and `cend()`
    member functions:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用常量迭代器，`std::vector` 提供了 `cbegin()` 和 `cend()` 成员函数：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Benefits of iteration
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代的好处
- en: 'Why is iteration so pivotal? By effectively iterating over vectors, you can
    do the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么迭代如此关键？通过有效地遍历向量，你可以做以下事情：
- en: '**Process data**: Whether normalizing data, filtering it, or performing any
    transformation, iteration is at the core of these operations.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理数据**：无论是规范化数据、过滤它还是执行任何转换，迭代都是这些操作的核心。'
- en: '**Search operations**: Looking for a particular element? Iteration allows you
    to comb through each item, checking against a condition or a value.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**搜索操作**：寻找特定元素？迭代允许你逐个检查每个项目，与条件或值进行比较。'
- en: '`sort`, `find`, and `transform`, require iterators to specify the range they
    operate on.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sort`、`find` 和 `transform` 需要迭代器来指定它们操作的范围。'
- en: The versatility and efficiency of `std::vector` iteration make it a prime choice
    for developers. While arrays also allow for traversal, vectors offer dynamic size,
    robustness against overflows, and integration with the rest of the C++ STL, making
    them a preferred choice in many scenarios.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::vector` 迭代的灵活性和效率使其成为开发者的首选选择。虽然数组也允许遍历，但向量提供了动态大小、对溢出的鲁棒性以及与 C++ STL
    的集成，这使得它们在许多场景下成为首选。'
- en: In conclusion, mastering iteration with `std::vector` is foundational to becoming
    proficient in C++. By understanding how to traverse this dynamic array, you unlock
    a wide range of capabilities, enabling you to harness the power of algorithms,
    efficiently process data, and craft robust, performant software. You’ll build
    a deeper understanding of other vector utilities as we progress, solidifying your
    knowledge and skills in this vibrant language.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，掌握 `std::vector` 的迭代是成为熟练的 C++ 开发者的基础。通过了解如何遍历这个动态数组，你将解锁一系列功能，使你能够利用算法的力量，高效地处理数据，并构建强大、高效的软件。随着我们不断深入，你将更深入地了解其他向量工具，从而巩固你在这一充满活力的语言中的知识和技能。
- en: In this section, we’ve navigated `std::vector` traversal with iterators, learning
    to access elements sequentially and utilize constant iterators for read-only operations.
    Understanding these techniques is critical for crafting flexible and optimized
    C++ code compatible with various container types. Iteration is a cornerstone of
    data manipulation in the STL; mastering it is essential for harnessing the library’s
    full potential.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们使用迭代器导航 `std::vector` 遍历，学习按顺序访问元素并利用常量迭代器进行只读操作。理解这些技术对于编写灵活和优化的与各种容器类型兼容的
    C++ 代码至关重要。迭代是 STL 中数据操作的基础；掌握它是发挥库全部潜力的关键。
- en: Next, we turn to the *Using std::begin and std::end* section to further our
    iterator knowledge. We’ll uncover how these functions standardize the initiation
    and conclusion of iterations across different containers, paving the way for more
    versatile and decoupled code.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们转向“使用 std::begin 和 std::end”部分，以进一步扩展我们对迭代器的知识。我们将揭示这些函数如何在不同容器中标准化迭代的开始和结束，为更灵活和松耦合的代码铺平道路。
- en: Using std::begin and std::end
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 std::begin 和 std::end
- en: As you discover more use cases for `std::vector`, you’ll encounter situations
    where it is advantageous, or even necessary, to venture beyond member functions.
    Here’s where non-member functions, specifically `std::begin` and `std::end`, step
    into the spotlight. These two functions are handy and offer a more generic way
    to access the beginning and end of a container, including but not limited to `std::vector`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你对 `std::vector` 的用例了解更多，你将遇到一些情况，在这些情况下，超越成员函数是有利或甚至是必要的。这就是非成员函数，特别是 `std::begin`
    和 `std::end` 走到聚光灯下的地方。这两个函数非常实用，提供了一种更通用的方式来访问容器的开始和结束，包括但不限于 `std::vector`。
- en: Why the distinction, you might ask? Aren’t there member functions such as `vector::begin()`
    and `vector::end()`? Indeed, there are. However, the beauty of the non-member
    `std::begin` and `std::end` is their broader applicability across different container
    types, making your code more flexible and adaptable.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么会有这种区别，你可能会问？难道没有像 `vector::begin()` 和 `vector::end()` 这样的成员函数吗？确实有。然而，非成员
    `std::begin` 和 `std::end` 的美妙之处在于它们在不同容器类型中的更广泛适用性，这使得你的代码更加灵活和适应性强。
- en: 'Vectors in C++ offer a potent blend of dynamic memory and continuous storage,
    making them indispensable in many coding scenarios. But to truly leverage their
    potential, understanding their interaction with iterators is crucial. While the
    spotlight often shines on the `begin()` and `end()` member functions, there are
    two versatile actors behind the curtains: `std::begin` and `std::end`.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: C++中的向量提供了一种强大的动态内存和连续存储的结合，使它们在许多编码场景中变得不可或缺。但要真正利用它们的潜力，了解它们与迭代器的交互至关重要。虽然`begin()`和`end()`成员函数经常成为焦点，但幕后还有两个多才多艺的演员：`std::begin`和`std::end`。
- en: When working with C++ containers, the `std::begin` function might seem like
    another way to start iterating through a container. However, it comes with its
    own set of marvels. While it primarily fetches an iterator pointing to the first
    element of a container, its application isn’t limited to vectors alone.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用C++容器时，`std::begin`函数可能看起来是另一种开始遍历容器的方法。然而，它带来了一整套奇迹。虽然它主要获取指向容器第一个元素的迭代器，但其应用并不限于向量。
- en: When you pass `std::vector` to `std::begin`, it is like having a backstage pass.
    Behind the scenes, the function smoothly delegates the task by calling the vector’s
    `begin()` member function. This intuitive behavior ensures that the transition
    remains seamless even as you venture into generic programming.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将`std::vector`传递给`std::begin`时，就像拥有了一张后台通行证。幕后，该函数通过调用向量的`begin()`成员函数来平滑地委派任务。这种直观的行为确保了即使在进入泛型编程时，过渡仍然无缝。
- en: Mirroring its counterpart, `std::end` is more than just a function that returns
    an iterator pointing past the last element. It’s a testament to C++’s commitment
    to consistency. Just as `std::begin` relies on `begin()`, when you engage with
    `std::end`, it subtly and efficiently calls upon the container’s `end()` member
    function.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 与其对应物相呼应，`std::end`不仅仅是一个返回指向最后一个元素之后迭代器的函数。它是C++对一致性承诺的见证。正如`std::begin`依赖于`begin()`一样，当你与`std::end`交互时，它巧妙而高效地调用了容器的`end()`成员函数。
- en: 'And here’s the true magic: while these non-member functions shine with `std::vector`,
    they are not constrained by it. Their generic nature means they play well with
    various containers, from traditional arrays to lists, making them indispensable
    tools for those seeking adaptability in their code.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 而这里的真正魔法在于：尽管这些非成员函数在`std::vector`中表现出色，但它们并不受其限制。它们的泛型特性意味着它们可以很好地与各种容器协同工作，从传统的数组到列表，使它们成为那些寻求代码适应性的不可或缺的工具。
- en: 'Let’s look at an example that demonstrates the utility of the `std::begin`
    and `std::end` non-member functions in contrast to their member counterparts:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个示例，它展示了`std::begin`和`std::end`非成员函数在对比其成员对应物时的实用性：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this preceding example, we notice the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个先前的例子中，我们注意到以下几点：
- en: We have a `displayElements` generic function that takes any container and uses
    the `std::begin` and `std::end` non-member functions to iterate over its elements.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个`displayElements`泛型函数，它接受任何容器并使用`std::begin`和`std::end`非成员函数来遍历其元素。
- en: 'We then create three containers: a `std::vector`, a `std::list`, and a `std::array.`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们创建了三个容器：一个`std::vector`，一个`std::list`和一个`std::array`。
- en: We call `displayElements` for each container to display its elements.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为每个容器调用`displayElements`以显示其元素。
- en: Using `std::begin` and `std::end`, our `displayElements` function is versatile
    and works across different container types. This would not have been as straightforward
    if we relied solely on member functions such as `vector::begin()` and `vector::end()`,
    emphasizing the power and flexibility of non-member functions.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`std::begin`和`std::end`，我们的`displayElements`函数是多才多艺的，并且可以在不同的容器类型上工作。如果我们仅仅依赖于如`vector::begin()`和`vector::end()`这样的成员函数，这将不会那么简单，这强调了非成员函数的强大和灵活性。
- en: Imagine being handed a toolkit that promises not just efficiency but also adaptability.
    That’s what `std::vector` offers, complemented beautifully by functions such as
    `std::begin` and `std::end`. They’re not just functions but gateways to more type-agnostic
    memory management and iteration.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你被 handed 一个承诺不仅效率高而且适应性强的工具箱。这就是`std::vector`提供的，而`std::begin`和`std::end`等函数则完美地补充了这一点。它们不仅仅是函数，而是通往更类型无关的内存管理和遍历的门户。
- en: We’ve seen how `std::begin` and `std::end` elevate our code by extending iteration
    capabilities to all STL containers, not just `std::vector`. Embracing these non-member
    functions is key to crafting container-independent, reusable code—a pillar for
    versatile algorithm implementation in C++. Understanding this distinction is fundamental
    for employing iterators effectively across the STL.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到`std::begin`和`std::end`如何通过扩展迭代能力到所有STL容器（而不仅仅是`std::vector`）来提升我们的代码。拥抱这些非成员函数是构建容器无关、可重用代码的关键——这是C++中灵活算法实现的一个支柱。理解这一区别对于在STL中有效地使用迭代器至关重要。
- en: Looking ahead, the next section will guide us through the nuances of iterator
    categories and their essentials. This insight is pivotal for aligning algorithms
    with appropriate iterator capabilities, reflecting the depth of C++’s type system
    and its close ties with pointer semantics.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 展望未来，下一节将引导我们了解迭代器类别及其基本要素的细微差别。这种洞察对于将算法与适当的迭代器能力相匹配至关重要，反映了C++的类型系统的深度及其与指针语义的紧密联系。
- en: Understanding iterator requirements
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解迭代器要求
- en: Iterators in C++ serve as a consistent interface to various data structures,
    such as containers and, since C++20, ranges. The iterator library supplies definitions
    for iterators and associated traits, adaptors, and utility functions.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: C++中的迭代器为各种数据结构提供了一个一致的接口，例如容器，以及自C++20以来，范围。迭代器库提供了迭代器和相关特性、适配器和实用函数的定义。
- en: Given that iterators extend the idea of pointers, they inherently adopt many
    pointer semantics in C++. Consequently, any function template accepting iterators
    can also seamlessly work with regular pointers.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于迭代器扩展了指针的概念，它们在C++中本质上采用了许多指针语义。因此，任何接受迭代器的函数模板也可以无缝地与常规指针一起工作。
- en: 'Iterators are categorized into six types: *LegacyInputIterator*, *LegacyOutputIterator*,
    *LegacyForwardIterator*, *LegacyBidirectionalIterator*, *LegacyRandomAccessIterator*,
    and *LegacyContiguousIterator*. Instead of being determined by their intrinsic
    types, these categories are distinguished by the operations they support. As an
    illustration, pointers accommodate all the operations defined for *LegacyRandomAccessIterator*,
    allowing them to be utilized wherever a *LegacyRandomAccessIterator* is required.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器被分为六种类型：*LegacyInputIterator*、*LegacyOutputIterator*、*LegacyForwardIterator*、*LegacyBidirectionalIterator*、*LegacyRandomAccessIterator*和*LegacyContiguousIterator*。这些类别不是由它们的内在类型决定的，而是由它们支持的运算来区分。例如，指针可以执行为*LegacyRandomAccessIterator*定义的所有运算，因此可以在需要*LegacyRandomAccessIterator*的地方使用。
- en: These iterator categories, except for *LegacyOutputIterator*, can be arranged
    hierarchically. More versatile iterator categories, such as *LegacyRandomAccessIterator*,
    encompass the capabilities of the less powerful ones, such as *LegacyInputIterator*.
    If an iterator conforms to any of these categories and also meets the criteria
    for *LegacyOutputIterator*, it’s termed a mutable iterator, capable of input and
    output functions. Iterators that aren’t mutable are referred to as constant iterators.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这些迭代器类别（除了*LegacyOutputIterator*）可以按层次排列。更通用的迭代器类别，如*LegacyRandomAccessIterator*，包含了较不强大类别（如*LegacyInputIterator*）的能力。如果一个迭代器符合这些类别中的任何一个，并且也满足*LegacyOutputIterator*的标准，则称为可变迭代器，能够执行输入和输出函数。不可变的迭代器被称为常量迭代器。
- en: In this section, we discovered the critical role of iterators as the unifying
    interface for C++ data structures, including containers and ranges. We examined
    how the iterator library in C++ defines iterator types, associated traits, adaptors,
    and utility functions, providing a standardized way to traverse these structures.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们发现了迭代器作为C++数据结构（包括容器和范围）统一接口的关键作用。我们探讨了C++中的迭代器库如何定义迭代器类型、相关特性、适配器和实用函数，提供了一种标准化的方式来遍历这些结构。
- en: We learned that iterators extend pointer semantics, allowing any function template
    that accepts iterators to work seamlessly with pointers. We further explored the
    hierarchy of iterator categories—*LegacyInputIterator*, *LegacyOutputIterator*,
    *LegacyForwardIterator*, *LegacyBidirectionalIterator*, *LegacyRandomAccessIterator*,
    and *LegacyContiguousIterator*. These categories are defined not by their types
    but by the operations they support, with more advanced iterators inheriting the
    capabilities of the simpler ones.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解到迭代器扩展了指针语义，允许任何接受迭代器的函数模板与指针无缝工作。我们进一步探讨了迭代器类别的层次结构——*LegacyInputIterator*、*LegacyOutputIterator*、*LegacyForwardIterator*、*LegacyBidirectionalIterator*、*LegacyRandomAccessIterator*
    和 *LegacyContiguousIterator*。这些类别不是由它们的类型定义的，而是由它们支持的运算定义的，更高级的迭代器继承了简单迭代器的功能。
- en: This knowledge is crucial for us as it informs our choice of iterator based
    on the operations we need to perform. Understanding the requirements and capabilities
    of each iterator category enables us to write more efficient and robust code,
    as we can choose the least powerful iterator that satisfies our needs, thereby
    avoiding unnecessary performance overhead.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这项知识对我们至关重要，因为它告诉我们根据需要执行的操作来选择迭代器。了解每个迭代器类别的需求和功能使我们能够编写更高效和健壮的代码，因为我们可以选择满足我们需求的最弱迭代器，从而避免不必要的性能开销。
- en: In the next section, titled *Range-based for loops in C++*, we will transition
    from the theoretical underpinnings of iterators to practical application by learning
    how to use range-based `for` loops to iterate over `std::vector`. We will understand
    how these loops utilize `std::begin` and `std::end` under the hood, providing
    a more intuitive and error-resistant method for element access and modification.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将从迭代器的理论基础过渡到实际应用，通过学习如何使用基于范围的 `for` 循环来迭代 `std::vector`，我们将了解这些循环如何在底层使用
    `std::begin` 和 `std::end`，提供了一种更直观且更不易出错的元素访问和修改方法。
- en: Range-based for loops
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于范围的 for 循环
- en: In C++, range-based `for` loops provide a concise and practical mechanism for
    iterating over containers such as `std::vector`. Armed with knowledge about `std::vector`
    operations and the `std::begin` and `std::end` functions, it’s evident that range-based
    `for` loops offer a streamlined traversal technique.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，基于范围的 `for` 循环为迭代容器如 `std::vector` 提供了一种简洁实用的机制。凭借对 `std::vector` 操作和
    `std::begin` 以及 `std::end` 函数的了解，很明显，基于范围的 `for` 循环提供了一种简化的遍历技术。
- en: Traditional iteration over a vector necessitates declaring an iterator, initializing
    it to the container’s start, and updating it to progress to the end. Although
    this method works, it requires careful management and is prone to errors. Range-based
    `for` loops present a more efficient solution.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在向量上使用传统的迭代需要声明一个迭代器，将其初始化为容器的开始位置，并更新它以进步到末尾。虽然这种方法可行，但它需要仔细的管理，并且容易出错。基于范围的
    `for` 循环提供了一个更有效的解决方案。
- en: Overview of range-based for loops
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于范围的 for 循环概述
- en: 'The following code demonstrates the basic structure of a range-based `for`
    loop:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了基于范围的 `for` 循环的基本结构：
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this example, every integer within the `numbers` vector is printed. This
    approach eliminates the need for explicit iterators and manual loop boundary definitions.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`numbers` 向量中的每个整数都被打印出来。这种方法消除了显式迭代器和手动循环边界定义的需要。
- en: Underlying mechanism
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内在机制
- en: Internally, the range-based `for` loop leverages the `begin()` and `end()` functions
    to navigate the container. The loop successively retrieves each item from the
    container, assigning it to the loop variable (`num` in this case).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，基于范围的 `for` 循环利用 `begin()` 和 `end()` 函数来导航容器。循环依次从容器中检索每个项目，并将其分配给循环变量（在这种情况下为
    `num`）。
- en: This approach simplifies the iteration process, allowing developers to concentrate
    on operations to perform on each element rather than the retrieval process.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法简化了迭代过程，使开发者能够专注于对每个元素执行的操作，而不是检索过程。
- en: When to use range-based for loops
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用基于范围的 for 循环
- en: 'Range-based `for` loops are particularly beneficial in the following situations:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 基于范围的 `for` 循环在以下情况下特别有益：
- en: '`for` loops are optimal for complete vector traversal.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for` 循环对于完整向量遍历是最优的。'
- en: '**Direct iterator access isn’t necessary**: These loops are excellent for displaying
    or altering elements. However, traditional loops are more appropriate if access
    to the iterator itself is required (e.g., for mid-traversal element insertion
    or deletion).'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**直接迭代器访问不是必需的**：这些循环非常适合显示或修改元素。然而，如果需要访问迭代器本身（例如，在遍历过程中插入或删除元素），则传统的循环更为合适。'
- en: '`for` loops succinctly express the intention to operate on every container
    element.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for` 循环简洁地表达了操作每个容器元素的意图。'
- en: Modifying elements during iteration
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在迭代过程中修改元素
- en: 'For scenarios where vector element modification is needed during iteration,
    it’s essential to use a reference as the loop variable, which is shown in the
    following code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在迭代过程中需要修改向量元素的场景，使用引用作为循环变量是至关重要的，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this case, each integer within the numbers vector is multiplied by two. Without
    the reference `(&)`, the loop would alter a copied element, leaving the original
    vector untouched.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，numbers 向量中的每个整数都乘以二。如果没有引用 `(&)`，循环将改变复制的元素，而原始向量保持不变。
- en: Range-based `for` loops are a testament to C++’s ongoing development, striking
    a balance between performance and readability. They grant developers a direct
    way to navigate containers, enhancing code clarity and minimizing potential mistakes.
    As you progress in C++, it’s crucial to understand the available tools and select
    the most fitting ones for your tasks. A thorough grasp of `std::vector` functions
    and capabilities ensures effective utilization in diverse situations.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 基于范围的 `for` 循环是 C++ 持续发展的证明，它在性能和可读性之间取得了平衡。它们为开发者提供了直接导航容器的途径，增强了代码的清晰度并最小化了潜在的错误。随着你在
    C++ 中的进步，理解可用的工具并选择最适合你任务的工具至关重要。对 `std::vector` 函数和功能的彻底掌握确保了在多种情况下有效利用。
- en: This section highlighted range-based for loops’ advantages in iterating through
    STL containers, emphasizing their readability and minimized error potential compared
    to traditional `for` loops. Utilizing `std::begin` and `std::end`, these loops
    streamline the iteration process, letting us concentrate on the element-level
    logic. They are optimal when direct iterator control isn’t needed, exemplifying
    modern C++’s emphasis on high-level abstractions for efficiency and clarity.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 本节强调了基于范围的 `for` 循环在迭代 STL 容器时的优势，强调了其可读性和与传统 `for` 循环相比最小化的错误潜力。利用 `std::begin`
    和 `std::end`，这些循环简化了迭代过程，让我们能够专注于元素级别的逻辑。它们在不需要直接迭代器控制时是最优的，这体现了现代 C++ 对高效和清晰的高层抽象的重视。
- en: Moving forward, the *Creating a custom iterator* section will utilize our iterators
    for advanced abstraction, data transformation, or filtered data views. We’ll explore
    the technical requirements and how to align our custom iterators with the STL’s
    categorization.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，*创建自定义迭代器*这一部分将利用我们的迭代器进行高级抽象、数据转换或过滤数据视图。我们将探讨技术要求以及如何使我们的自定义迭代器与 STL 的分类保持一致。
- en: Creating a custom iterator
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义迭代器
- en: One of the beauties of C++ is its flexibility, empowering developers to mold
    the language to suit their needs. This flexibility doesn’t stop with built-in
    functionality for container iteration. While `std::vector` comes with its set
    of built-in iterators, nothing is stopping us from creating our own. But why might
    we want to?
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 的一个美丽之处在于其灵活性，赋予开发者根据需要塑造语言的能力。这种灵活性不仅限于容器迭代的内置功能。虽然 `std::vector` 附带了一组内置迭代器，但没有任何阻止我们创建自己的。但我们为什么想要这样做呢？
- en: The appeal of custom iterators
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义迭代器的吸引力
- en: 'Let’s examine the reasons you’d want to implement a custom iterator:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看你为什么想要实现一个自定义迭代器：
- en: '**Enhanced abstraction**: Consider a vector storing a matrix in a flat format.
    Wouldn’t it be more intuitive to iterate through rows or columns rather than individual
    elements? Custom iterators can facilitate this.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强抽象**：考虑一个以扁平格式存储矩阵的向量。通过行或列而不是单个元素来迭代是否更直观？自定义迭代器可以促进这一点。'
- en: '**Data transformation**: Perhaps you wish to iterate through the vector but
    retrieve transformed data, like the squared values of each element. Instead of
    changing the data before or during retrieval, a custom iterator can abstract this.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据转换**：也许你希望迭代向量，但检索转换后的数据，如每个元素的平方值。而不是在检索前后或期间更改数据，自定义迭代器可以抽象这一点。'
- en: '`std::vector`.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::vector`.'
- en: Creating a custom STL iterator might seem like an arduous task, but with the
    proper guidance, it is a breeze! At its core, an iterator is a fancy pointer—a
    guide that escorts you through the elements of a container. To make your iterator
    play well with the STL, there are certain member functions you’ll need to implement.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自定义 STL 迭代器可能看起来是一项艰巨的任务，但有了适当的指导，它就变得轻而易举！在其核心，迭代器是一个高级指针——一个引导你通过容器元素的向导。为了让你的迭代器与
    STL 稳定地协同工作，你需要实现某些成员函数。
- en: Core requirements
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 核心要求
- en: The exact set of these functions varies based on the type of iterator you’re
    creating, but some are common across the board.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数的确切集合取决于你创建的迭代器类型，但其中一些是通用的。
- en: '`value_type`: Denotes the type of the element the iterator points to.'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`value_type`：表示迭代器指向的元素类型。'
- en: '`difference_type`: Represents the distance between two iterators.'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`difference_type`：表示两个迭代器之间的距离。'
- en: '`pointer` and `reference`: Define the iterator’s pointer and reference types.'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`pointer` 和 `reference`：定义迭代器的指针和引用类型。'
- en: '`iterator_category`: Classifies the iterator into categories such as input,
    output, forward, bidirectional, or random access. Each category has its unique
    characteristics, making iterators versatile and fun!'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`iterator_category`：将迭代器分类为输入、输出、前向、双向或随机访问等类别。每个类别都有其独特的特征，使迭代器变得灵活且有趣！'
- en: '`operator*`: The dereference operator, granting access to the element your
    iterator points to.'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`operator*`：解引用运算符，允许访问迭代器指向的元素。'
- en: '`operator++`: The increment operators! These move your iterator forward (either
    in pre-increment or post-increment style).'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`operator++`：增量运算符！这些运算符将你的迭代器向前移动（无论是前缀增量还是后缀增量风格）。'
- en: '`operator==` and `operator!=`: Equipped with these, your iterators can be compared,
    letting algorithms know if they’ve reached the end or need to keep going.'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`operator==` 和 `operator!=`：装备了这些，你的迭代器可以进行比较，让算法知道它们是否到达了末尾或需要继续前进。'
- en: Iterator categories and their specialties
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代器类别及其特性
- en: 'Iterators come in different flavors; each flavor (or category) has unique requirements:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器有多种风味；每种风味（或类别）都有独特的要求：
- en: '`operator*`, `operator++`, `operator==`, and `operator!=`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`operator*`, `operator++`, `operator==`, 和 `operator!=`'
- en: '`operator*` and `operator++`*   **Forward iterators**: They combine input and
    output iterators—reading, writing, and always moving forward.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`operator*` 和 `operator++`*   **前向迭代器**：它们结合输入和输出迭代器——读取、写入，并且始终向前移动。'
- en: '**Essential**: All the core requirements*   `operator--` to step back*   `std::vector`.'
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基本要求**：所有核心要求*   `operator--` 以步退*   `std::vector`。'
- en: '`operator+`, `operator-`, `operator+=`, `operator-=`, `operator[]`, and relational
    operators such as `operator<`, `operator<=`, `operator>`, and `operator>=`'
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`operator+`, `operator-`, `operator+=`, `operator-=`, `operator[]`, 和关系运算符如
    `operator<`, `operator<=`, `operator>`, 和 `operator>=`'
- en: A random access iterator in C++ is one of the most potent iterator categories
    and requires several functions and operators to be fully compatible with STL algorithms
    and containers.
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: C++ 中的随机访问迭代器是功能最强大的迭代器类别之一，需要几个函数和运算符才能完全与 STL 算法和容器兼容。
- en: 'Here’s a list of functions and operators you’d typically implement for a random
    access iterator:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个为随机访问迭代器通常实现的函数和运算符列表：
- en: '`iterator_category` (should be set to `std::random_access_iterator_tag`)'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iterator_category` (应设置为 `std::random_access_iterator_tag`)'
- en: '`value_type`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value_type`'
- en: '`difference_type`'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`difference_type`'
- en: '`pointer`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pointer`'
- en: '`reference`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reference`'
- en: '`operator*()` (dereference operator)*   `operator->()` (arrow operator)*   `operator++()`
    (prefix increment)*   `operator++(int)` (postfix increment)*   `operator--()`
    (prefix decrement)*   `operator--(int)` (postfix decrement)*   `ptrdiff_t`):'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`operator*()` (解引用运算符)*   `operator->()` (箭头运算符)*   `operator++()` (前缀增量)*   `operator++(int)`
    (后缀增量)*   `operator--()` (前缀减量)*   `operator--(int)` (后缀减量)*   `ptrdiff_t`):'
- en: '`operator+(difference_type)` (move iterator forward by some amount)'
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`operator+(difference_type)` (通过某些数量向前移动迭代器)'
- en: '`operator-(difference_type)` (move iterator backward by some amount)'
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`operator-(difference_type)` (通过某些数量向后移动迭代器)'
- en: '`operator+=(difference_type)` (increment iterator by some amount)'
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`operator+=(difference_type)` (通过某些数量增加迭代器)'
- en: '`operator-=(difference_type)` (decrement iterator by some amount)*   `operator-(const
    RandomAccessIteratorType&)`*   `operator[](difference_type)`*   `operator==` (equality)*   `operator!=`
    (inequality)*   `operator<` (less than)*   `operator<=` (less than or equal to)*   `operator>`
    (greater than)*   `operator>=` (greater than or equal to)*   **Swap** (sometimes
    useful, though not strictly required for the iterator itself):'
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`operator-=(difference_type)`（按某些量递减迭代器）*   `operator-(const RandomAccessIteratorType&)`*   `operator[](difference_type)`*   `operator==`（相等）*   `operator!=`（不等）*   `operator<`（小于）*   `operator<=`（小于或等于）*   `operator>`（大于）*   `operator>=`（大于或等于）*   **交换**（有时很有用，但不是迭代器本身的严格要求）：'
- en: A swap function to swap two iterators
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于交换两个迭代器的交换函数
- en: Not all of these will always be applicable, especially if the underlying data
    structure has limitations or the iterator’s specific usage case doesn’t require
    all these operations. However, for full compatibility with STL’s random access
    iterators, this is the complete set of functions and operators you’d want to consider
    implementing.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有这些总是适用，特别是如果底层数据结构有限制或迭代器的特定使用场景不需要所有这些操作。然而，为了与STL的随机访问迭代器完全兼容，这是你想要考虑实现的一组完整函数和运算符。
- en: A custom iterator example
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义迭代器示例
- en: 'Let’s create a custom iterator for `std::vector<int>` that, when dereferenced,
    returns the square of the value in the vector:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为`std::vector<int>`创建一个自定义迭代器，当解引用时，返回向量中值的平方：
- en: '[PRE12]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When run, this code will output the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行此代码时，将输出以下内容：
- en: '[PRE13]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The iterators in the code can be used very similarly to a built-in array or
    `std::vector` iterators but with the unique functionality of squaring values when
    dereferenced.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中的迭代器可以非常类似于内置数组或`std::vector`迭代器使用，但在解引用时具有平方值的独特功能。
- en: Custom iterator challenges and use cases
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义迭代器的挑战和用例
- en: 'Creating a custom iterator isn’t just about understanding your data or use
    case; it is also about grappling with some challenges:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自定义迭代器不仅仅是理解你的数据或用例；它还涉及到应对一些挑战：
- en: '**Complexity**: Crafting an iterator requires adherence to certain iterator
    concepts. Different requirements must be met whether it is an input, forward,
    bidirectional, or random access iterator.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂性**：构建迭代器需要遵循某些迭代器概念。根据它是输入迭代器、正向迭代器、双向迭代器还是随机访问迭代器，必须满足不同的要求。'
- en: '`push_back` or `erase`. Ensuring the custom iterator remains valid is essential
    for safe and predictable behavior.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`push_back`或`erase`。确保自定义迭代器保持有效对于安全且可预测的行为至关重要。'
- en: '**Performance overhead**: With added functionality can come extra computation.
    Ensuring that the iterator’s overhead doesn’t negate its benefits is crucial.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能开销**：随着功能的增加，可能会带来额外的计算。确保迭代器的开销不会抵消其好处是至关重要的。'
- en: Illustrative use cases of custom iterators
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义迭代器的说明性用例
- en: 'To wrap our minds around the idea, let’s briefly look at a couple of scenarios
    where custom iterators shine:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这个概念，让我们简要地看看几个自定义迭代器大放异彩的场景：
- en: '`std::vector` might store pixel data linearly for an image. A custom iterator
    could facilitate iteration by rows, channels, or even regions of interest.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::vector`可能以线性方式存储图像的像素数据。自定义迭代器可以促进按行、通道或甚至感兴趣区域进行迭代。'
- en: '`std::vector<char>`, an iterator could be designed to jump from word to word
    or sentence to sentence, ignoring whitespace and punctuation.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::vector<char>`，迭代器可以被设计成从单词跳到单词或从句子跳到句子，忽略空白和标点符号。'
- en: '**Statistical sampling**: An iterator might sample every *n*th element for
    large datasets stored in vectors, providing a quick overview without traversing
    each element.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**统计抽样**：对于存储在向量中的大数据集，迭代器可能会采样每*n*个元素，从而在不遍历每个元素的情况下提供快速概述。'
- en: Creating a custom iterator involves adhering to specific conventions and defining
    a set of required operators to give it the behavior of an iterator.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自定义迭代器需要遵循特定的约定并定义一组必需的运算符，以赋予它迭代器的行为。
- en: 'The following code shows us how to create a custom iterator for extracting
    the alpha channel from a bitmap stored in `std::vector`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何为从存储在`std::vector`中的位图中提取alpha通道创建自定义迭代器：
- en: '[PRE14]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We’ve defined an `RGBA` struct in this example to represent the color. We then
    create a custom `AlphaIterator` iterator to navigate the alpha channel. Next,
    the iterator uses the underlying `std::vector<RGBA>::iterator`, but exposes only
    the alpha channel when dereferenced. Finally, the `main` function demonstrates
    using this iterator to print alpha values.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们定义了一个 `RGBA` 结构体来表示颜色。然后我们创建了一个自定义的 `AlphaIterator` 迭代器来导航 alpha 通道。接下来，迭代器使用底层的
    `std::vector<RGBA>::iterator`，但在解引用时仅暴露 alpha 通道。最后，`main` 函数演示了使用此迭代器打印 alpha
    值。
- en: 'This custom iterator adheres to the conventions of a C++ input iterator, making
    it usable with various algorithms and range-based `for` loops. The `AlphaIterator`
    class in the example demonstrates a custom input iterator’s basic structure and
    behavior in C++. Here’s a breakdown of the key member functions and their significance
    for STL compatibility:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 此自定义迭代器遵循 C++ 输入迭代器的约定，使其可用于各种算法和基于范围的 `for` 循环。示例中的 `AlphaIterator` 类演示了 C++
    中自定义输入迭代器的基本结构和行为。以下是关键成员函数及其对 STL 兼容性的重要性的分解：
- en: '`iterator_category`: Defines the type/category of the iterator. It helps algorithms
    determine the operations supported by the iterator. Here, it is defined as `std::input_iterator_tag`,
    indicating it is an input iterator.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iterator_category`：定义迭代器的类型/类别。它帮助算法确定迭代器支持的操作。在此处，它定义为 `std::input_iterator_tag`，表示它是一个输入迭代器。'
- en: '`value_type`: The data type that can be read from the underlying container.
    Here, it is `uint8_t` representing the alpha channel.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value_type`：可以从底层容器中读取的数据类型。在此处，它是表示 alpha 通道的 `uint8_t`。'
- en: '`difference_type`: Used to represent the result of subtracting two iterators.
    Commonly used in random access iterators.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`difference_type`：用于表示两个迭代器相减的结果。通常用于随机访问迭代器。'
- en: '`pointer` and `reference`: The pointer and reference types to `value_type`.
    They give direct access to the value.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pointer` 和 `reference`：指向 `value_type` 的指针和引用类型。它们提供了对值的直接访问。'
- en: '`explicit AlphaIterator`(`std::vector<RGBA>::iterator itr`): This constructor
    is essential to initialize the iterator with an instance of the underlying `std::vector`
    iterator.*   `reference operator*()`: The dereference operator returns a reference
    to the current item in the sequence. For this iterator, it returns a reference
    to the alpha channel of the RGBA value.*   `AlphaIterator& operator++()`: The
    pre-increment operator advances the iterator to the next element.*   `AlphaIterator
    operator++(int)`: The post-increment operator advances the iterator to the next
    element but returns an iterator to the current element before the increment. This
    behavior is needed for constructs such as `it++`.*   `bool operator==(const AlphaIterator&
    other) const`: Checks whether two iterators point to the same position. This is
    crucial for comparison and to determine the end of a sequence.*   `bool operator!=(const
    AlphaIterator& other) const`: The opposite of the previous one: this checks whether
    two iterators are not equal.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`explicit AlphaIterator`(`std::vector<RGBA>::iterator itr`): 此构造函数对于使用底层 `std::vector`
    迭代器的实例初始化迭代器至关重要。*   `reference operator*()`：解引用运算符返回序列中当前项的引用。对于此迭代器，它返回 RGBA
    值的 alpha 通道的引用。*   `AlphaIterator& operator++()`：前置增量运算符将迭代器向前推进到下一个元素。*   `AlphaIterator
    operator++(int)`：后置增量运算符将迭代器向前推进到下一个元素，但在增量之前返回当前元素的迭代器。这种行为对于 `it++` 等构造是必需的。*   `bool
    operator==(const AlphaIterator& other) const`：检查两个迭代器是否指向相同的位置。这对于比较和确定序列的末尾至关重要。*   `bool
    operator!=(const AlphaIterator& other) const`：前一个操作的相反：此操作检查两个迭代器是否不相等。'
- en: These member functions and type aliases are essential to make the iterator compatible
    with the STL and enable its seamless use with various STL algorithms and constructs.
    They define the fundamental interface and semantics required for a functioning
    input iterator.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这些成员函数和类型别名对于使迭代器与 STL 兼容以及能够无缝使用各种 STL 算法和构造至关重要。它们定义了功能输入迭代器所需的基本接口和语义。
- en: Additional operations would be required for iterators with more capabilities
    (such as bidirectional or random access). But for the input iterator demonstrated
    in the `AlphaIterator`, the preceding are the core components.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有更多功能（如双向或随机访问）的迭代器，可能需要额外的操作。但对于在 `AlphaIterator` 中演示的输入迭代器，上述内容是核心组件。
- en: This section covered custom iterators and understanding their creation for specific
    needs such as data abstraction, transformation, and filtering. Learning to define
    essential type aliases and implement key operators is crucial in extending the
    functionality of `std::vector`. This knowledge lets us customize data interaction,
    ensuring our code meets the unique domain requirements with precision.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这一节涵盖了自定义迭代器及其为特定需求（如数据抽象、转换和过滤）的创建。学会定义基本类型别名和实现关键运算符对于扩展 `std::vector` 的功能至关重要。这种知识使我们能够定制数据交互，确保我们的代码以精确的方式满足独特的领域需求。
- en: Summary
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have comprehensively explored the role and usage of iterators
    as they apply to one of the most versatile containers in the C++ STL. We started
    by discussing the various types of iterators available in the STL—input, output,
    forward, reverse, bidirectional, and random access—and their specific applications
    and support operations.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们全面探讨了迭代器在 C++ STL 中最灵活的容器之一的角色和用法。我们首先讨论了 STL 中可用的各种迭代器类型——输入、输出、正向、反向、双向和随机访问——以及它们的特定应用和支持操作。
- en: We then moved on to practical iteration techniques, detailing how to traverse
    `std::vector` effectively using standard and constant iterators. We underscored
    the importance of choosing the correct type of iterator for the task at hand to
    write clean, efficient, and error-resistant code.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们转向了实用的迭代技术，详细说明了如何使用标准迭代器和常量迭代器有效地遍历 `std::vector`。我们强调了选择正确的迭代器类型来完成手头任务的重要性，以编写干净、高效且具有容错能力的代码。
- en: The section on using `std::begin` and `std::end` expanded our toolkit, showing
    how these non-member functions can make our code more flexible by not being tightly
    bound to container types. We also covered the requirements and categorization
    of iterators, essential knowledge for understanding the STL’s inner workings,
    and implementing custom iterators.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `std::begin` 和 `std::end` 的章节中，我们扩展了我们的工具箱，展示了这些非成员函数如何通过不紧密绑定到容器类型来使我们的代码更加灵活。我们还涵盖了迭代器的需求和分类，这是理解
    STL 内部工作原理和实现自定义迭代器所必需的基本知识。
- en: Range-based `for` loops were introduced as a modern C++ feature that simplifies
    iteration by abstracting the details of iterator management. We learned when and
    how to use these loops to their fullest potential, particularly noting the ease
    with which they allow the modification of elements during iteration.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 基于范围的 `for` 循环被引入作为一种现代 C++ 功能，它通过抽象迭代器管理的细节来简化迭代。我们学习了何时以及如何充分利用这些循环，特别是它们在迭代过程中修改元素时的便捷性。
- en: Finally, we tackled the advanced topic of creating custom iterators. We discovered
    the motivations behind this, such as providing more intuitive navigation or presenting
    a filtered data view. We examined the core requirements, challenges, and use cases
    for custom iterators, rounding out our understanding of how they can be tailored
    to fit specialized needs.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了创建自定义迭代器的进阶主题。我们发现了背后的动机，例如提供更直观的导航或展示过滤后的数据视图。我们检查了自定义迭代器的核心要求、挑战和用例，从而完善了我们对其如何定制以满足特定需求的理解。
- en: While the standard iterators provided with `std::vector` cover many use cases,
    they’re not the end of the story. Custom iterators offer an avenue to stretch
    the boundaries of what’s possible with iteration, tailor-fitting traversal logic
    to specific needs. The complexity of crafting reliable custom iterators is not
    to be underestimated. As we close this chapter, remember that custom iterators
    can be powerful tools in the right hands. You can make informed decisions about
    when and how to wield them with a solid understanding of their workings.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然与 `std::vector` 一起提供的标准迭代器覆盖了许多用例，但这并不是故事的终结。自定义迭代器提供了一条途径，可以扩展迭代可能性的边界，将遍历逻辑定制到特定需求。制作可靠的自定义迭代器的复杂性不容小觑。在我们结束这一章时，请记住，在正确的人手中，自定义迭代器可以是强大的工具。你可以通过对其工作原理的深入了解，做出关于何时以及如何使用它们的明智决策。
- en: The knowledge gained in this chapter is beneficial as it enables the creation
    of more sophisticated, robust, and performant C++ applications. Understanding
    and utilizing iterators effectively allows us to harness the full power of `std::vector`
    and write container-agnostic and highly optimized algorithms.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中获得的知识是有益的，因为它使我们能够创建更复杂、更健壮和性能更优的 C++ 应用程序。有效地理解和利用迭代器使我们能够充分利用 `std::vector`
    的全部功能，并编写容器无关且高度优化的算法。
- en: The upcoming chapter, *Mastering Memory and Allocators with std::vector*, builds
    upon our existing knowledge and directs our focus toward memory efficiency, a
    critical aspect of high-performance C++ programming. We will continue to emphasize
    the practical, real-world applications of these concepts, ensuring that the content
    remains valuable and directly applicable to our work as intermediate-level C++
    developers.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 即将到来的章节，*使用 std::vector 精通内存和分配器*，建立在我们的现有知识之上，并将我们的关注点引向内存效率，这是高性能 C++ 编程的一个关键方面。我们将继续强调这些概念的实际、现实世界的应用，确保内容保持价值，并直接适用于我们作为中级
    C++ 开发者的工作。
