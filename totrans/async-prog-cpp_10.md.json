["```cpp\n#include <iostream>\n#include <boost/cobalt.hpp>\nboost::cobalt::main co_main(int argc, char* argv[]) {\n    std::cout << \"Hello Boost.Cobalt\\n\";\n    co_return 0;\n}\n```", "```cpp\n    target_link_libraries(${EXEC_NAME} Boost::cobalt)\n    ```", "```cpp\n    cobalt::task<int> async_task() {\n        // your code here\n        // …\n        return 0;\n    }\n    int main() {\n        // main function code\n        // …\n        return cobalt::run(async_code();\n    }\n    ```", "```cpp\n#include <chrono>\n#include <iostream>\n#include <boost/cobalt.hpp>\nusing namespace std::chrono_literals;\nusing namespace boost;\ncobalt::generator<int> basic_generator()\n{\n    std::this_thread::sleep_for(1s);\n    co_yield 1;\n    std::this_thread::sleep_for(1s);\n    co_return 0;\n}\ncobalt::main co_main(int argc, char* argv[]) {\n    auto g = basic_generator();\n    std::cout << co_await g << std::endl;\n    std::cout << co_await g << std::endl;\n    co_return 0;\n}\n```", "```cpp\ntemplate<typename Yield, typename Push = void>\nstruct generator\n```", "```cpp\n#include <chrono>\n#include <iostream>\n#include <boost/cobalt.hpp>\nusing namespace std::chrono_literals;\nusing namespace boost;\ncobalt::generator<int, int> square_generator(int x){\n    while (x != 0) {\n        x = co_yield x * x;\n    }\n    co_return 0;\n}\ncobalt::main co_main(int argc, char* argv[]){\n    auto g = square_generator(10);\n    std::cout << co_await g(4) << std::endl;\n    std::cout << co_await g(12) << std::endl;\n    std::cout << co_await g(0) << std::endl;\n    co_return 0;\n}\n```", "```cpp\nauto g = square_generator(10);\n```", "```cpp\nstd::cout << co_await g(4) << std::endl;\n```", "```cpp\n#include <iostream>\n#include <boost/cobalt.hpp>\nboost::cobalt::generator<int, int> square_generator() {\n    auto x = co_await boost::cobalt::this_coro::initial;\n    while (x != 0) {\n        x = co_yield x * x;\n    }\n    co_return 0;\n}\nboost::cobalt::main co_main(int, char*[]) {\n    auto g = square_generator();\n    std::cout << co_await g(4) << std::endl;\n    std::cout << co_await g(10) << std::endl;\n    std::cout << co_await g(12) << std::endl;\n    std::cout << co_await g(0) << std::endl;\n    co_return 0;\n}\n```", "```cpp\n    auto g = square_generator();\n    ```", "```cpp\n    auto x = co_await boost::cobalt::this_coro::initial;\n    ```", "```cpp\n    std::cout << co_await g(10) << std::endl;\n    ```", "```cpp\nboost::cobalt::generator<int, int> fibonacci_term() {\n    auto fibonacci = [](int n) {\n        if (n < 2) {\n            return n;\n        }\n        int f0 = 0;\n        int f1 = 1;\n        int f;\n        for (int i = 2; i <= n; ++i) {\n            f = f0 + f1;\n            f0 = f1;\n            f1 = f;\n        }\n        return f;\n    };\n    auto x = co_await boost::cobalt::this_coro::initial;\n    while (x != -1) {\n        x = co_yield fibonacci(x);\n    }\n    co_return 0;\n }\n```", "```cpp\nauto x = co_await boost::cobalt::this_coro::initial;\n```", "```cpp\nwhile (x != -1) {\n        x = co_yield fibonacci(x);\n    }\n```", "```cpp\nboost::cobalt::generator<int> fibonacci_sequence() {\n    int f0 = 0;\n    int f1 = 1;\n    int f = 0;\n    while (true) {\n        co_yield f0;\n        f = f0 + f1;\n        f0 = f1;\n        f1 = f;\n    }\n}\n```", "```cpp\n#include <iostream>\n#include <random>\n#include <boost/cobalt.hpp>\nboost::cobalt::promise<int> random_number(int min, int max) {\n    std::random_device rd;\n    std::mt19937 gen(rd());\n    std::uniform_int_distribution<> dist(min, max);\n    co_return dist(gen);\n}\nboost::cobalt::promise<int> random(int min, int max) {\n    int res = co_await random_number(min, max);\n    co_return res;\n}\nboost::cobalt::main co_main(int, char*[]) {\n    for (int i = 0; i < 10; ++i) {\n        auto r = random(1, 100);\n        std::cout << \"random number between 1 and 100: \"\n                  << co_await r << std::endl;\n    }\n    co_return 0;\n}\n```", "```cpp\nboost::cobalt::promise<std::vector<int>> random_vector(int min, int max, int n) {\n    std::vector<int> rv(n);\n    for (int i = 0; i < n; ++i) {\n        rv[i] = co_await random_number(min, max);\n    }\n    co_return rv;\n}\n```", "```cpp\nauto v = random_vector(1, 100, 20);\nfor (int n : v.get()) {\n    std::cout << n << \" \";\n}\nstd::cout << std::endl;\n```", "```cpp\n#include <chrono>\n#include <iostream>\n#include <thread>\n#include <boost/cobalt.hpp>\nvoid sleep(){\n    std::this_thread::sleep_for(std::chrono::seconds(2));\n}\nboost::cobalt::promise<int> eager_promise(){\n    std::cout << \"Eager promise started\\n\";\n    sleep();\n    std::cout << \"Eager promise done\\n\";\n    co_return 1;\n}\nboost::cobalt::task<int> lazy_task(){\n    std::cout << \"Lazy task started\\n\";\n    sleep();\n    std::cout << \"Lazy task done\\n\";\n    co_return 2;\n}\nboost::cobalt::main co_main(int, char*[]){\n    std::cout << \"Calling eager_promise...\\n\";\n    auto promise_result = eager_promise();\n    std::cout << \"Promise called, but not yet awaited.\\n\";\n    std::cout << \"Calling lazy_task...\\n\";\n    auto task_result = lazy_task();\n    std::cout << \"Task called, but not yet awaited.\\n\";\n    std::cout << \"Awaiting both results...\\n\";\n    int promise_value = co_await promise_result;\n    std::cout << \"Promise value: \" << promise_value\n              << std::endl;\n    int task_value = co_await task_result;\n    std::cout << \"Task value: \" << task_value\n              << std::endl;\n    co_return 0;\n}\n```", "```cpp\nCalling eager_promise...\nEager promise started\nEager promise done\nPromise called, but not yet awaited.\n```", "```cpp\nCalling lazy_task...\nTask called, but not yet awaited.\n```", "```cpp\nAwaiting both results...\nPromise value: 1\n```", "```cpp\nLazy task started\nLazy task done\nTask value: 2\n```", "```cpp\n#include <iostream>\n#include <boost/cobalt.hpp>\n#include <boost/asio.hpp>\nboost::cobalt::promise<void> producer(boost::cobalt::channel<int>& ch) {\n    for (int i = 1; i <= 10; ++i) {\n        std::cout << \"Producer waiting for request\\n\";\n        co_await ch.write(i);\n        std::cout << \"Producing value \" << i << std::endl;\n    }\n    std::cout << \"Producer end\\n\";\n    ch.close();\n    co_return;\n}\nboost::cobalt::main co_main(int, char*[]) {\n    boost::cobalt::channel<int> ch;\n    auto p = producer(ch);\n    while (ch.is_open()) {\n        std::cout << \"Consumer waiting for next number \\n\";\n        std::this_thread::sleep_for(std::chrono::seconds(5));\n        auto n = co_await ch.read();\n        std::cout << \"Consuming value \" << n << std::endl;\n        std::cout << n * n << std::endl;\n    }\n    co_await p;\n    co_return 0;\n}\n```", "```cpp\nProducer waiting for request\nConsumer waiting for next number\nProducing value 1\nProducer waiting for request\nConsuming value 1\n1\nConsumer waiting for next number\nProducing value 2\nProducer waiting for request\nConsuming value 2\n4\nConsumer waiting for next number\nProducing value 3\nProducer waiting for request\nConsuming value 3\n9\nConsumer waiting for next number\n```", "```cpp\nauto n = co_await ch.read();\n```", "```cpp\nco_await ch.write(i);\n```", "```cpp\nboost::cobalt::promise<std::chrono::milliseconds::rep> process(std::chrono::milliseconds ms) {\n    if (ms > std::chrono::milliseconds(5000)) {\n        throw std::runtime_error(\"delay throw\");\n    }\n    boost::asio::steady_timer tmr{ co_await boost::cobalt::this_coro::executor, ms };\n    co_await tmr.async_wait(boost::cobalt::use_op);\n    co_return ms.count();\n}\n```", "```cpp\nauto result = co_await boost::cobalt::join(process(100ms),\n                                           process(200ms),\n                                           process(300ms));\nstd::cout << \"First coroutine finished in: \"\n          <<  std::get<0>(result) << \"ms\\n\";\nstd::cout << \"Second coroutine took finished in: \"\n          <<  std::get<1>(result) << \"ms\\n\";\nstd::cout << \"Third coroutine took finished in: \"\n         <<  std::get<2>(result) << \"ms\\n\";\n```", "```cpp\ntry {\n    auto result throw = co_await\n    boost::cobalt::join(process(100ms),\n                        process(20000ms),\n                        process(300ms));\n}\ncatch (...) {\n    std::cout << \"An exception was thrown\\n\";\n}\n```", "```cpp\ntry\n    auto result throw =\n    boost::cobalt::co_await lt::gather(process(100ms),\n                                       process(20000ms),\n                                       process(300ms));\n    if (std::get<0>(result throw).has value()) {\n        std::cout << \"First coroutine took: \"\n                  <<  *std::get<0>(result throw)\n                  << \"msec\\n\";\n    }\n    else {\n        std::cout << \"First coroutine threw an exception\\n\";\n    }\n    if (std::get<1>(result throw).has value()) {\n        std::cout << \"Second coroutine took: \"\n                  <<  *std::get<1>(result throw)\n                  << \"msec\\n\";\n    }\n    else {\n        std::cout << \"Second coroutine threw an exception\\n\";\n    }\n    if (std::get<2>(result throw).has value()) {\n        std::cout << \"Third coroutine took: \"\n                  <<  *std::get<2>(result throw)\n                  << \"msec\\n\";\n    }\n    else {\n        std::cout << \"Third coroutine threw an exception\\n\";\n    }\n}\ncatch (...) {\n    // this is never reached because gather doesn't throw exceptions\n    std::cout << \"An exception was thrown\\n\";\n}\n```"]