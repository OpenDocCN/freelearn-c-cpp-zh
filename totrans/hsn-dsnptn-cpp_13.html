<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-227"><a id="_idTextAnchor596"/>13</h1>
<h1 id="_idParaDest-228"><a id="_idTextAnchor597"/>Virtual Constructors and Factories</h1>
<p>In C++, any member function of any class, including its destructor, can be made virtual - any member function except one—the constructor. Without virtual functions, the exact type of object on which the member function is invoked is known at compile time. Therefore, the type of object that is constructed is always known at compile time, at the point of the constructor call. Nonetheless, we often need to construct objects whose type is not known until runtime. This chapter describes several related patterns and idioms that address this design problem in various ways, including the Factory pattern.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Why there is no way to make a constructor virtual</li>
<li>How to use the Factory pattern to defer the choice of the constructed object type until compile time</li>
<li>Using C++ idioms to construct and copy objects polymorphically</li>
</ul>
<h1 id="_idParaDest-229"><a id="_idTextAnchor598"/><a id="_idTextAnchor599"/>Technical requirements</h1>
<p>The example code for this chapter can be found at the following GitHub link: <a href="https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP_Second_Edition/tree/master/Chapter13">https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP_Second_Edition/tree/master/Chapter13</a>.<a id="_idTextAnchor600"/></p>
<h1 id="_idParaDest-230"><a id="_idTextAnchor601"/>Why constructors cannot be virtual</h1>
<p>We already understand how polymorphism works—when a virtual function is called through a pointer or a reference to the base class, that pointer or reference is used to access the v-pointer in the class. The v-pointer<a id="_idIndexMarker710"/> is used to identify the true type of the object, that is, the type that the object was created with. It could be the base class itself, or any one of the derived classes. The member function on that object is actually called. So, why can’t the same be done for constructors? Let’s investigate this<a id="_idTextAnchor602"/>.<a id="_idTextAnchor603"/></p>
<h2 id="_idParaDest-231"><a id="_idTextAnchor604"/>When does an object get its type?</h2>
<p>It is pretty easy to<a id="_idIndexMarker711"/> understand why the process that we described previously cannot work for creating <em class="italic">virtual constructors</em>. First of all, it is evident from the description of the preceding process—as a part of it, we <em class="italic">identify the type that the object was created with</em>. That can only happen after the object is constructed—before construction, we don’t have an object of this type yet, just some uninitialized memory. Another way to look at it is this—before the virtual function is dispatched to the correct type, the v-pointer needs to be looked up. Who puts the right value into the v-pointer? Considering that the v-pointer uniquely identifies the type of object, it can only be initialized during construction. This implies that it wasn’t initialized before construction. But if it wasn’t initialized, it can’t be used to dispatch virtual function calls. And so again, we realize that constructors cannot be virtual.</p>
<p>For derived classes in the hierarchy, the process of establishing the type is even more complex. We can try to observe the type of an object as it is being constructed. The easiest way to do this is to use the <code>typeid</code> operator, which returns information about the object’s type, including the name of the type:</p>
<pre class="source-code">
// Example 01
#include &lt;iostream&gt;
#include &lt;typeinfo&gt;
using std::cout;
using std::endl;
template &lt;typename T&gt;
auto type(T&amp;&amp; t) { return typeid(t).name(); }
class A {
  public:
  A() { cout &lt;&lt; "A::A(): " &lt;&lt; type(*this) &lt;&lt; endl; }
  virtual
  ~A() { cout &lt;&lt; "A::~A(): " &lt;&lt; type(*this) &lt;&lt; endl; }
};
class B : public A {
  public:
  B() { cout &lt;&lt; "B::B(): " &lt;&lt; type(*this) &lt;&lt; endl; }
  ~B() { cout &lt;&lt; "B::~B(): " &lt;&lt; type(*this) &lt;&lt; endl; }
};
class C : public B {
  public:
  C() { cout &lt;&lt; "C::C(): " &lt;&lt; type(*this) &lt;&lt; endl; }
  ~C() { cout &lt;&lt; "C::~C(): " &lt;&lt; type(*this) &lt;&lt; endl; }
};
int main() {
  C c;
}</pre>
<p>Running this program produces the following result:</p>
<pre class="console">
A::A(): 1A
B::B(): 1B
C::C(): 1C
C::~C(): 1C
B::~B(): 1B
A::~A(): 1A</pre>
<p>The type<a id="_idIndexMarker712"/> name returned by the <code>std::typeinfo::name()</code> call is the so-called mangled type name—it’s the internal name that the compiler uses to identify types, instead of human-readable names such as <code>class A</code>. If you want to know the unmangled type, you can use a demangler such as the <code>c++filt</code> program that comes with GCC:</p>
<pre class="console">
$ c++filt -t 1A
A</pre>
<p>We can also <a id="_idIndexMarker713"/>write a small C++ function to demangle type names, but the way to do it varies from one compiler to another (there is no portable version). For example, this is what you would write for GCC:</p>
<pre class="source-code">
// Example 2
#include &lt;cxxabi.h&gt;
template &lt;typename T&gt; auto type(T&amp;&amp; p) {
  int r;
  std::string name;
  char* mangled_name =
    abi::__cxa_demangle(typeid(p).name(), 0, 0, &amp;r);
  name += mangled_name;
  ::free(mangled_name);
  return name;
}</pre>
<p>Note that the demangler function returns a C string (a <code>char*</code> pointer) that must be explicitly freed by the caller. The program now prints demangled names such as <code>A</code>, <code>B</code>, and <code>C</code>. This is enough for our use, but in some cases, you might notice that the type is not printed exactly as it should be:</p>
<pre class="source-code">
class A {
  public:
  void f() const { cout &lt;&lt; type(*this) &lt;&lt; endl; }
};
...
C c;
c.f();</pre>
<p>If we call <a id="_idIndexMarker714"/>the function <code>f()</code>,  the type is reported as <code>C</code> but not <code>const C</code> as we might expect (the object is <code>const</code> inside a <code>const</code> member function). This is because the <code>typeid</code> operator removed the <code>const</code> and <code>volatile</code> qualifiers as well as any references from the type. To print those, you have to figure them out by yourself:</p>
<pre class="source-code">
// Example 03
template &lt;typename T&gt; auto type(T&amp;&amp; p) {
  std::string name;
  using TT = std::remove_reference_t&lt;T&gt;;
  if (std::is_const&lt;TT&gt;::value) name += "const ";
  if (std::is_volatile&lt;TT&gt;::value) name += "volatile ";
  int r;
  name += abi::__cxa_demangle(typeid(p).name(), 0, 0, &amp;r);
  return name;
}</pre>
<p>Regardless of how you choose to print the types, how many objects were constructed in these examples? The source code says just one, the <code>c</code> object of type <code>C</code>:</p>
<pre class="source-code">
int main() {
  C c;
}</pre>
<p>The runtime output says three, that is, one of each type. Both answers are correct—when an object of type <code>C</code> is constructed, the base class, <code>A</code>, has to be constructed first, and so its constructor is called. Then, the intermediate base class, <code>B</code>, is constructed, and only then will <code>C</code> be. The destructors are executed in reverse order. The type of the object inside its constructor or destructor, as reported by the <code>typeid</code> operator, is the same as the type of object whose constructor or destructor is running.</p>
<p>It appears that the type, as indicated by the virtual pointer, is changing during the construction! That is, of course, assuming that the <code>typeid</code> operator returns the dynamic type, the type indicated by the virtual pointer, and not the static type that can be determined at compile time. The standard says that this is, indeed, the case. Does this mean that, if we called the same virtual method from each constructor, we would really be calling three different <a id="_idIndexMarker715"/>overrides of this method? It’s easy enough to find out:</p>
<pre class="source-code">
// Example 04
class A {
  public:
  A() { whoami(); }
  virtual ~A() { whoami(); }
  virtual void whoami() const {
    std::cout &lt;&lt; "A::whoami" &lt;&lt; std::endl;
  }
};
class B : public A {
  public:
  B() { whoami(); }
  ~B() { whoami(); }
  void whoami() const override {
    std::cout &lt;&lt; "B::whoami" &lt;&lt; std::endl;
  }
};
class C : public B {
  public:
  C() { whoami(); }
  ~C() { whoami(); }
  void whoami() const override {
    std::cout &lt;&lt; "C::whoami" &lt;&lt; std::endl;
  }
};
int main() {
  C c;
  c.whoami();
}</pre>
<p>Now, we will create the <a id="_idIndexMarker716"/>object of type <code>C</code>, and the call to <code>whoami()</code> after the creation confirms it – the dynamic type of the object is <code>C</code>. That was true from the beginning of the construction process; we asked the compiler to construct one object of type <code>C</code>, but the dynamic type of the object changed during construction:</p>
<pre class="console">
A::whoami
B::whoami
C::whoami
C::whoami
C::whoami
B::whoami
A::whoami</pre>
<p>It is clear that the virtual pointer value has changed as the construction of the object progressed. In the beginning, it was identifying the object type as <code>A</code>, even though the final type is <code>C</code>. Is this because we created the object on the stack? Would it be any different if the object was created on the heap? We can easily find out:</p>
<pre class="source-code">
C* c = new C;
c-&gt;whoami();
delete c;</pre>
<p>Running the modified program produces exactly the same results as the original.</p>
<p>Another reason that the constructor cannot be virtual, or, more generally, why the type of the object being constructed has to be known at compile time at the point of construction, is that the compiler has to know how much memory to allocate for the object. The amount of memory is determined by the size of the type, that is, by the <code>sizeof</code> operator. The result of <code>sizeof(C)</code> is a compile-time constant, so the amount of memory allocated for the new object is always known at compile time. This is true whether we create the object on the stack or on the heap.</p>
<p>The bottom line is this—if the program creates an object of the <code>T</code> type, somewhere in the code there is an explicit call to the <code>T::T</code> constructor. After that, we can hide the <code>T</code> type in the rest of the program, for example, by accessing the object through a base class pointer, or by erasing the type (see <a href="B19262_06.xhtml#_idTextAnchor266"><em class="italic">Chapter 6</em></a>, <em class="italic">Understanding Type Erasure</em>). But there has to be at least one explicit mention of the <code>T</code> type in the code, and that is at the point of construction.</p>
<p>On the one hand, we now <a id="_idIndexMarker717"/>have a very reasonable explanation of why constructing objects can never be polymorphic. On the other hand, this does nothing to address a design challenge that may require constructing an object whose type is not known at compile time. Consider designing a game—a player can recruit or summon any number of adventurers for their party and build settlements and cities. It would be reasonable to have a separate class for each creature kind and each building type, but then we have to construct an object of one of these types when an adventurer joins the party, or a building is erected, and until the player selects it, the game cannot know which object to construct.</p>
<p>As usual in software, the solution involves adding another level of indi<a id="_idTextAnchor605"/>r<a id="_idTextAnchor606"/>ection.</p>
<h1 id="_idParaDest-232"><a id="_idTextAnchor607"/>The Factory pattern</h1>
<p>The problem we <a id="_idIndexMarker718"/>are faced with, that is, how to decide at runtime to create an object of a particular type, is obviously a very common design problem. Design patterns are the solutions for just such problems, and there is a pattern for this problem as well—it’s called the Factory pattern. The Factory pattern is a creational pattern, and it provides solutions for several related problems—how to delegate the decision of which object to create to a derived class, how to create objects using a separate factory method, and so on. We will review these variations of the Factory pattern one by one, starting with the basic factor<a id="_idTextAnchor608"/>y<a id="_idTextAnchor609"/> method.</p>
<h2 id="_idParaDest-233"><a id="_idTextAnchor610"/>The basics of the Factory method</h2>
<p>In its simplest <a id="_idIndexMarker719"/>form, the factory method constructs an object of a type that’s specified at runtime:</p>
<pre class="source-code">
class Base { ... };
class Derived : public Base { ... };
Base* p = ClassFactory(type_identifier, ... arguments );</pre>
<p>How do we identify at runtime which object to create? We need a runtime identifier for each type that the factory can create. In the simplest case, the list of these types is known at compile time.</p>
<p>Consider a game design where a player selects the type of building to construct from a menu. The program has a list of buildings that can be constructed, each represented by an object, with an identifier for each one:</p>
<pre class="source-code">
// Example 05
enum Buildings {
  FARM, FORGE, MILL, GUARDHOUSE, KEEP, CASTLE
};
class Building {
  public:
  virtual ~Building() {}
};
class Farm : public Building { ... };
class Forge : public Building { ... };</pre>
<p>When the player selects the building type, the corresponding identifier value is also selected by the game program. Now, the program can construct the building using the factory method:</p>
<pre class="source-code">
Building* new_farm = MakeBuilding(FARM);</pre>
<p>Note that the<a id="_idIndexMarker720"/> factory takes the type identifier argument and returns the pointer to the base class. The returned object should have the type that corresponds to the type identifier. How is the factory implemented? Remember the conclusion of the last section—somewhere in the program, every object has to be explicitly constructed with its true type. The Factory pattern does not remove this requirement; it merely hides the place where the construction happens:</p>
<pre class="source-code">
// Example 05
Building* MakeBuilding(Buildings building_type) {
  switch (building_type) {
    case FARM: return new Farm;
    case FORGE: return new Forge;
    ...
  }
}</pre>
<p>The correspondence between the type identifier and the object type is encoded in the <code>switch</code> statement inside the factory. The return type has to be the same for all types that are constructed by the factory since there is only one factory method, and its type is declared at compile time. In the simplest case, it is the base class pointer, although if you follow the modern memory ownership idioms described in <a href="B19262_03.xhtml#_idTextAnchor110"><em class="italic">Chapter 3</em></a>, <em class="italic">Memory and Ownership</em>, of this book, the factory should return a unique pointer to the base class, <code>std::unique_ptr&lt;Building&gt;</code>.</p>
<pre class="source-code">
// Example 06:
class Building {
  public:
  enum Type {FARM, FORGE, ...};
  virtual ~Building() {}
  auto MakeBuilding(Type building_type);
};
auto Building::MakeBuilding(Type building_type) {
  using result_t = std::unique_ptr&lt;Building&gt;;
  switch (building_type) {
    case FARM: return result_t{new Farm};
    case FORGE: return result_t{new Forge};
    ...
  }
}</pre>
<p>In rare cases when the<a id="_idIndexMarker721"/> shared ownership is really needed, the shared pointer, <code>std::shared_ptr&lt;Building&gt;</code>, can be constructed by moving the object from the unique pointer (but this is the decision to be made by the caller, not the factory itself).</p>
<p>The other design choice that we made here (independently of using the owning pointer) is to move the type identifiers and the factory function into the base class. This is useful for encapsulation and to keep all related code and types closer together.</p>
<p>This is the basic form of the factory method. There are many variations that make it more suitable for a particular problem. We will review some of these vari<a id="_idTextAnchor611"/>a<a id="_idTextAnchor612"/>tions here.</p>
<h2 id="_idParaDest-234"><a id="_idTextAnchor613"/>Factory clarification</h2>
<p>Note that <a id="_idIndexMarker722"/>there is some ambiguity in the use of the term “factory method.” In this chapter, we use it to describe the function that creates objects of different types based on some run-time information. There is another, not related, design pattern that is sometimes introduced with the same name: instead of constructing different classes, this pattern constructs the same class but in different ways. Here is a brief example: suppose we have a class to represent a point on a plain. The point is described by its coordinates, <code>x</code> and <code>y</code>:</p>
<pre class="source-code">
class Point {
  double x_ {};
  double y_ {};
  public:
  Point(double x, double y) : x_(x), y_(y) {}
};</pre>
<p>So far, so good. But the same point can be described using, for example, polar coordinates. Because these are two ways to describe the same point, we do not need a separate class, but we may want a new constructor that creates a cartesian point from the specified polar coordinates:</p>
<pre class="source-code">
class Point() {
  ...
  Point(double r, double angle);
};</pre>
<p>But this is not going to work: the new constructor and the original constructor from <code>x</code> and <code>y</code> both take exactly the same arguments, so there is no way for the overload resolution to figure out which one you meant. One solution is to use different types for quantities that are measured in different units (length and angle, in our case). But they have to be truly different types, not just aliases. Sometimes, such a unit template library is just what you need, but if you’re staying with doubles, you need some other way of invoking different constructors based on the caller’s intent and not just the arguments.</p>
<p>One way to handle this problem is to switch to factory construction. Instead of using the constructors, we will construct all <code>Point</code> objects using static factory methods. Note that the constructor itself is <a id="_idIndexMarker723"/>usually made private when using this approach:</p>
<pre class="source-code">
// Example 07
class Point {
  double x_ {};
  double y_ {};
  Point(double x, double y) : x_(x), y_(y) {}
  public:
  static Point new_cartesian(double x, double y) {
    return Point(x, y);
  }
  static Point new_polar(double r, double phi) {
    return Point(r*std::cos(phi), r*std::sin(phi));
  }
};
Point p1(Point::new_cartesian(3, 4));
Point p2(Point::new_polar(5, 0.927295));</pre>
<p>This design works, but in<a id="_idIndexMarker724"/> modern C++, the more popular alternative is to use multiple constructors and disambiguate them with uniquely defined type tags:</p>
<pre class="source-code">
// Example 08
class Point {
  double x_ {};
  double y_ {};
  public:
  struct cartesian_t {} static constexpr cartesian {};
  Point(cartesian_t, double x, double y) : x_(x), y_(y) {}
  struct polar_t {} static constexpr polar {};
  Point(polar_t, double r, double phi) :
    Point(cartesian, r*std::cos(phi), r*std::sin(phi)) {}
};
Point p1(Point::cartesian, 3, 4);
Point p2(Point::polar, 5, 0.927295);</pre>
<p>In this example, we create two unique types, <code>Point::polar_t</code> and <code>Point::cartesian_t</code>, along with the corresponding variables, and use them as tags to specify what kind of construction we want. The constructor overloads are no longer ambiguous since each one has a unique first parameter type. Delegating constructors makes this approach even more attractive.</p>
<p>While the use of<a id="_idIndexMarker725"/> static functions to construct objects of the same type in different ways is sometimes called a factory method, it can also be seen as a variant of the builder pattern (especially when, instead of static methods, we use a separate builder class with similar methods). In any case, the more modern pattern – using tags – can replace both of these patterns. Having clarified the terminology, let us return to the original problem of constructing objects of different types based on run-time information.</p>
<h2 id="_idParaDest-235"><a id="_idTextAnchor614"/>Arguments for factory methods</h2>
<p>In our simple <a id="_idIndexMarker726"/>example, the constructor took no arguments. Passing arguments to the constructor presents a bit of a problem if the constructors of different types have different parameters—after all, the <code>MakeBuilding()</code> function has to be declared with some specific parameters. One option that appears straightforward is to make the factory a variadic template and simply forward the arguments to each constructor. The straightforward implementation might look like this:</p>
<pre class="source-code">
// Example 09
template &lt;typename... Args&gt;
auto Building::MakeBuilding(Type type, Args&amp;&amp;... args) {
  using result_t = std::unique_ptr&lt;Building&gt;;
  switch (type) {
    case FARM: return
      result_t{new Farm(std::forward&lt;Args&gt;(args)...)};
    case FORGE: return
      result_t{new Forge(std::forward&lt;Args&gt;(args)...)};
    ...
  }
}</pre>
<p>This code might even<a id="_idIndexMarker727"/> compile for a while, but, sooner or later, you are going to run into the following error. Let us give the two classes we build some constructor arguments:</p>
<pre class="source-code">
// Example 09
class Farm : public Building {
  public:
  explicit Farm(double size);
};
class Forge : public Building {
  public:
  static constexpr size_t weaponsmith = 0x1;
  static constexpr size_t welder = 0x2;
  static constexpr size_t farrier = 0x4;
  Forge(size_t staff, size_t services);
};
std::unique_ptr&lt;Building&gt; forge =
  Building::MakeBuilding(Building::FORGE, 2,
    Forge::weaponsmith | Forge::welder | Forge::farrier);</pre>
<p>The <code>Forge</code> class uses a bitmask as flags to mark which services are provided at the forge (a simple and efficient solution to handle a small number of non-exclusive options). For example, if <code>(services &amp; Forge::farrier)</code> is <code>true</code>, one of the 2 craftsmen working at the forge can shoe horses. Simple, elegant, and … doesn’t compile.</p>
<p>The compiler error will mention that there is no matching constructor for the <code>Farm</code> class that could be used to construct a <code>Farm</code> from two integers. But we are not trying to construct a <code>Farm</code>! This error gets everybody sooner or later. The problem is that, at compile-time, it is impossible to be sure that we are not trying to construct a <code>Farm</code>: that is a run-time decision. The function <code>MakeBuilding()</code> must compile, which means its entire implementation must compile, including the line starting with <code>case FARM</code>. Your first thought might be to replace the <code>switch</code> statement with <code>if constexpr</code>, but that’s not going to work because the condition we use to select which class to build is not <code>constexpr</code>, it’s a run-time value – that’s the whole point of the factory pattern.</p>
<p>Trying to <a id="_idIndexMarker728"/>construct a <code>Farm</code> with the arguments meant for a <code>Forge</code> is an error. However, it is a run-time error, and it can only be detected at run time. This still leaves us with the problem of how to make valid the code we never want to run. The problem is that the Farm doesn’t have a constructor we could use for all the wrong arguments (but hopefully never will). The easiest workaround is to provide one:</p>
<pre class="source-code">
// Example 09
class Farm : public Building {
  public:
  explicit Farm(...) { abort(); }
  ...
};</pre>
<p>We have to do the same for all types we may construct with our factory. The variadic function constructor is an “overload of the last resort” – it is selected only if no other overload matches the arguments. Since it matches any arguments, the compilation errors will be gone, replaced by run-time errors if something does go wrong in the program. Why not simply add this constructor to the base class? We could, but base class constructors are not visible in derived classes without a <code>using</code> statement, so we still have to add something to every derived class.</p>
<p>Having to modify every class just so it can be used with the factory creation pattern is definitely a disadvantage, especially since the new constructor could be used anywhere, not just in the factory function (with unfortunate consequences). As usual, with one more layer of indirection, we could solve this problem as well by introducing an overloaded template for constructing our objects:</p>
<pre class="source-code">
// Example 10
template &lt;typename T, typename... Args&gt;
auto new_T(Args&amp;&amp;... args) -&gt;
  decltype(T(std::forward&lt;Args&gt;(args)...))* {
  return new T(std::forward&lt;Args&gt;(args)...);
}
template &lt;typename T&gt;
T* new_T(...) { abort(); return nullptr; }
template &lt;typename... Args&gt;
auto Building::MakeBuilding(Type type, Args&amp;&amp;... args) {
  using result_t = std::unique_ptr&lt;Building&gt;;
  switch (type) {
    case FARM: return
      result_t{new_T&lt;Farm&gt;(std::forward&lt;Args&gt;(args)...)};
    case FORGE: return
      result_t{new_T&lt;Forge&gt;(std::forward&lt;Args&gt;(args)...)};
    ...
  }
}</pre>
<p>The good news is<a id="_idIndexMarker729"/> that now we do not need to modify any of the classes: any factory call with the correct arguments compiles and is forwarded to the right constructor, while any attempt to create an object with the wrong arguments is a run-time error. The bad news is that any attempt to create an object with the wrong arguments is a run-time error. That includes the dead code we never plan to run (such as creating a <code>Farm</code> with <code>Forge</code>’s arguments), but it also includes any mistakes we could make when calling the factory.</p>
<p>If the variadic template solution looks much less attractive once you start implementing it, there is a simpler option: create a parameter object with the hierarchy matching the hierarchy of the objects we create. Let’s assume that, in our game, the player can select upgrades for each building to be constructed. The user interface will have to offer building-specific options, of course, and the results of the user selections are stored in a building-specific object:</p>
<pre class="source-code">
// Example 11
struct BuildingSpec {
  virtual Building::Type type() const = 0;
};
struct FarmSpec : public BuildingSpec {
  Building::Type type() const override {
    return Building::FARM;
  }
  bool with_pasture;
  int number_of_stalls;
};
struct ForgeSpec : public BuildingSpec {
  Building::Type type() const override {
    return Building::FORGE;
  }
  bool magic_forge;
  int number_of_apprentices;
};</pre>
<p>Note that we<a id="_idIndexMarker730"/> included the type identifier with the argument object, there is no reason to call the factory method with two arguments that must always correctly match each other; it only creates the possibility of an error occurring. This way, we are guaranteed that the type identifier and the arguments match in every factory call:</p>
<pre class="source-code">
// Example 11
auto Building::MakeBuilding(const BuildingSpec&amp; spec) {
  using result_t = std::unique_ptr&lt;Building&gt;;
  switch (spec.type()) {
    case FARM: return result_t{
      new Farm(static_cast&lt;const FarmSpec&amp;&gt;(spec))};
    case FORGE: return result_t{
      new Forge(static_cast&lt;const ForgeSpec&amp;&gt;(spec))};
    ...
  }
}</pre>
<p>Note that the <a id="_idIndexMarker731"/>factory pattern often works well with the named arguments pattern we saw in <a href="B19262_09.xhtml#_idTextAnchor406"><em class="italic">Chapter 9</em></a>, <em class="italic">Named Arguments, Method Chaining, and the Builder Pattern</em> to avoid having to specify long argument lists. The spec objects themselves become the options objects we can use to specify named arguments:</p>
<pre class="source-code">
// Example 11
class FarmSpec {
  ...
  bool with_pasture {};
  int number_of_stalls {};
  FarmSpec() = default;
  FarmSpec&amp; SetPasture(bool with_pasture) {
    this-&gt;with_pasture = with_pasture;
    return *this;
  }
  FarmSpec&amp; SetStalls(int number_of_stalls) {
    this-&gt;number_of_stalls = number_of_stalls;
    return *this;
  }
};
struct ForgeSpec : public BuildingSpec {
  ...
  bool magic_forge {};
  int number_of_apprentices {};
  ForgeSpec() = default;
  ForgeSpec&amp; SetMagic(bool magic_forge) {
    this-&gt;magic_forge = magic_forge;
    return *this;
  }
  ForgeSpec&amp; SetApprentices(int number_of_apprentices) {
    this-&gt;number_of_apprentices = number_of_apprentices;
    return *this;
  }
};
...
std::unique_ptr&lt;Building&gt; farm =
  Building::MakeBuilding(FarmSpec()
                         .SetPasture(true)
                         .SetStalls(2));
std::unique_ptr&lt;Building&gt; forge =
  Building::MakeBuilding(ForgeSpec()
                         .SetMagic(false)
                         .SetApprentices(4));</pre>
<p>This technique can be <a id="_idIndexMarker732"/>combined with some of the other factory variations that are shown in the following sections so that we can pass arguments when the cons<a id="_idTextAnchor615"/><a id="_idTextAnchor616"/>tructors require them.</p>
<h2 id="_idParaDest-236"><a id="_idTextAnchor617"/>Dynamic type registry</h2>
<p>So far, we have <a id="_idIndexMarker733"/>assumed that the complete list of the types is known at compile time and can be encoded in the type identifier correspondence table (implemented with a switch statement, in our example). The former requirement is unavoidable in the scope of the entire program: since every constructor call is explicit somewhere, the total list of types that can be constructed is known at compile time. However, our solution is more constrained than that—we have a list of all types that are hard-coded in the factory method. No additional derived classes can be created without also adding them to the factory. Sometimes, this restriction is not as bad as it appears—for example, the list of buildings in the game may not change very often, and even when it does, there is a complete list that must be manually updated for the right menu to be generated, the pictures and sounds to appear in the right places, and so on.</p>
<p>Nonetheless, one of the advantages of the hierarchical designs is that derived classes can be added later without modifying any of the code written to operate on the hierarchy. The new virtual function simply plugs into the existing control flow and provides the necessary customized behavior. We can implement the same idea for the factory constructor.</p>
<p>First of all, each derived class has to be responsible for constructing itself. This is necessary because, as we have already learned, the explicit call to the constructor has to be written somewhere. If it’s not in the generic code, it has to be a part of the code that is added when a new derived class is created. For example, we can have a static factory function:</p>
<pre class="source-code">
class Forge : public Building {
  public:
  static Building* MakeBuilding() { return new Forge; }
};</pre>
<p>Second, the list of the types has to be extensible at runtime instead of being fixed at compile time. We could still use an <code>enum</code>, but then it would have to be updated every time a new derived class is added. Alternatively, we could assign each derived class an integer identifier at runtime, making sure that the identifiers are unique. Either way, we need a map of these identifiers to the factory functions, and it cannot be a <code>switch</code> statement or anything else that is fixed at compile time. The map has to be extensible. We could use <code>std::map</code> for this, but, if the type identifiers are integers, we can also use a <code>std::vector</code> of function pointers indexed by the type identifier:</p>
<pre class="source-code">
class Building;
using BuildingFactory = Building*(*)();
std::vector&lt;BuildingFactory&gt; building_registry;</pre>
<p>Now, to register a new type, we just need to generate a new identifier and add the corresponding factory function to the vector:</p>
<pre class="source-code">
size_t building_type_count = 0;
void RegisterBuilding(BuildingFactory factory) {
  building_registry.push_back(factory));
  ++building_type_count;
}</pre>
<p>This <a id="_idIndexMarker734"/>registration machinery can be encapsulated in the base class itself:</p>
<pre class="source-code">
// Example 12
class Building {
  static size_t building_type_count;
  using BuildingFactory = Building* (*)();
  static std::vector&lt;BuildingFactory&gt; registry;
  public:
  static size_t (BuildingFactory factory) {
    registry.push_back(factory);
    return building_type_count++;
  }
  static auto MakeBuilding(size_t building_type) {
    BuildingFactory RegisterBuilding factory =
        registry[building_type];
    return std::unique_ptr&lt;Building&gt;(factory());
  }
};
std::vector&lt;Building::BuildingFactory&gt; Building::registry;
size_t Building::building_type_count = 0;</pre>
<p>This base<a id="_idIndexMarker735"/> class has the factory function table and the count of registered derived types as static data members. It also has two static functions: one to register new types and one to construct an object of one of the types registered with the class. Note that the registration function returns the type identifier it has associated with the factory function. We are going to use this momentarily.</p>
<p>Now, we just need to add every new building type to the registry. This is done in two steps—first, we need to add a registration method to every building class, like so:</p>
<pre class="source-code">
class Forge : public Building {
  public:
  static void Register() {
    RegisterBuilding(Forge::MakeBuilding);
  }
};</pre>
<p>Second, we need to arrange for all <code>Register()</code> methods to be called before the game begins and make sure we know the right identifier for every building type. This is where the value returned by the <code>RegisterBuilding()</code> function becomes important because we are going to store it as the type identifier inside the class itself:</p>
<pre class="source-code">
// Example 12
class Forge : public Building {
  public:
  static void Register() {
    RegisterBuilding(Forge::MakeBuilding);
  }
  static const size_t type_tag;
};
const size_t Forge::type_tag =
  RegisterBuilding(Forge::MakeBuilding);</pre>
<p>The registration happens during the initialization of the static variables, sometime before <code>main()</code> is started.</p>
<p>The factory<a id="_idIndexMarker736"/> functions do not have to be static member functions: anything that can be invoked via a function pointer will work. For example, we could use a lambda without captures:</p>
<pre class="source-code">
// Example 12
class Farm : public Building {
  public:
  static const size_t type_tag;
};
const size_t Farm::type_tag =
  RegisterBuilding([]()-&gt;Building* { return new Farm; });</pre>
<p>We have to explicitly specify the return type because the function pointer type is defined as a function with no argument that returns <code>Building*</code>, while the lambda is deduced as a function returning <code>Farm*</code> unless we cast the return value or specify the return type.</p>
<p>Now, a call to <code>Building::MakeBuilding(tag)</code> will construct an object of the type that’s registered with the identifier <code>tag</code>. The value of the tag – the type identifier – is stored as a static member in every class, so we don’t have to know what it is and can’t make a mistake:</p>
<pre class="source-code">
std::unique_ptr&lt;Building&gt; farm =
  Building::MakeBuilding(Farm::type_tag);
std::unique_ptr&lt;Building&gt; forge =
  Building::MakeBuilding(Forge::type_tag);</pre>
<p>In our solution, the correspondence between the identifier values and the types is not known until runtime—we cannot say what building has the ID of 5 until we run the program. Usually, we do not need to know that since the right value is automatically stored in each class.</p>
<p>Note that<a id="_idIndexMarker737"/> this implementation is very similar to the code that the compilers generate for true virtual functions—virtual function calls are done through function pointers that are stored in tables and accessed by means of a unique identifier (the virtual pointer). The main difference is that the unique identifier is the static data member associated with each type. Nonetheless, this is as close to a <em class="italic">virtual constructor</em> as you can get.</p>
<p>There are many variants of this dynamic type registry pattern. In some cases, it is preferable to explicitly specify the type identifiers instead of generating them at the program startup time. In particular, readable names such as “farm” and “forge” can be useful. In this case, instead of a vector, we can store the factory function pointers in a <code>std::map</code> container indexed by strings (<code>std::map&lt;std::string, BuildingFactory&gt;</code>).</p>
<p>Another modification is to allow more general callable objects as factory functions. We can generalize the <code>BuildingFactory</code> type by using <code>std::function</code> instead of the function pointer:</p>
<pre class="source-code">
using BuildingFactory = std::function&lt;Building*()&gt;;</pre>
<p>We can still register and use static factory methods as factories for our derived classes, but we can also use lambdas and custom functors:</p>
<pre class="source-code">
// Example 13
class Forge : public Building {
  public:
  static const size_t type_tag;
};
class ForgeFactory {
  public:
  Building* operator()() const { return new Forge; }
};
const size_t Forge::type_tag =
  RegisterBuilding(ForgeFactory{});</pre>
<p>The <a id="_idIndexMarker738"/>implementation of these dynamic factories, whether it is done with a function pointer or a more general std::function, strongly resembles the type erasure pattern we have explored in <a href="B19262_06.xhtml#_idTextAnchor266"><em class="italic">Chapter 6</em></a>, <em class="italic">Understanding Type Erasure</em>. The concrete type of object to construct is embedded in the code of the function or functor whose declaration makes no mention of these types. This allows us to store these functions in a single function table or map. Other implementations of type erasure from <a href="B19262_06.xhtml#_idTextAnchor266"><em class="italic">Chapter 6</em></a>, <em class="italic">Understanding Type Erasure</em>, can be used as well.</p>
<p>For simplicity, we did not use any arguments for our factory methods. We did, however, explore the options for passing arguments in the previous section. The variadic templates do not work well with function pointers (we have to declare the signature of the factory function upfront), so the most likely pattern for passing arguments is going to be the parameter spec object:</p>
<pre class="source-code">
// Example 14
struct BuildingSpec {};
class Building {
  ...
  using BuildingFactory =
    Building* (*)(const BuildingSpec&amp;);
  static auto MakeBuilding(size_t building_type,
                           const BuildingSpec&amp; spec) {
    BuildingFactory factory = registry[building_type];
    return std::unique_ptr&lt;Building&gt;(factory(spec));
  }
};
struct FarmSpec : public BuildingSpec {
  bool with_pasture {};
  int number_of_stalls {};
  FarmSpec() = default;
  FarmSpec&amp; SetPasture(bool with_pasture) {
    this-&gt;with_pasture = with_pasture;
    return *this;
  }
  FarmSpec&amp; SetStalls(int number_of_stalls) {
    this-&gt;number_of_stalls = number_of_stalls;
    return *this;
  }
};
class Farm : public Building {
  public:
  explicit Farm(const FarmSpec&amp; spec);
  ...
};
const size_t Farm::type_tag = RegisterBuilding(
  [](const BuildingSpec&amp; spec)-&gt;Building* {
    return new Farm(static_cast&lt;const FarmSpec&amp;&gt;(spec));
  });
struct ForgeSpec : public BuildingSpec { ... };
class Forge : public Building { ... };
std::unique_ptr&lt;Building&gt; farm =
  Building::MakeBuilding(FarmSpec()
                         .SetPasture(true)
                         .SetStalls(2));
std::unique_ptr&lt;Building&gt; forge =
  Building::MakeBuilding(ForgeSpec()
                         .SetMagic(false)
                         .SetApprentices(4));</pre>
<p>In all of our <a id="_idIndexMarker739"/>factory constructors so far, the decision about which object to construct was driven by the external input to the program, and the construction was done by the same factory method (possibly using delegation to the derived classes). We will now see a different variant of the factory, which is used to address <a id="_idTextAnchor618"/>a<a id="_idTextAnchor619"/> slightly different scenario.</p>
<h2 id="_idParaDest-237"><a id="_idTextAnchor620"/>Polymorphic factory</h2>
<p>Consider a <a id="_idIndexMarker740"/>slightly different problem—imagine that, in our game, each building produces a unit of some kind, and the type of the unit is uniquely associated with the type of the building. The Castle recruits knights, the Wizard Tower trains mages, and the Spider Mound produces giant spiders. Now, our generic code not only constructs a building of the type that is selected at runtime but also creates new units whose types are also not known at compile time. We already have the building factory. We could implement the Unit factory in a similar way, where every building has a unique unit identifier associated with it. But this design exposes the correspondence between the units and the buildings to the rest of the program, and that is really not necessary—each building knows how to build the <em class="italic">right</em> unit; there is no reason for the rest of the program to know it too.</p>
<p>This design challenge calls for a slightly different factory—the factory method determines that a unit is created, but exactly which unit is decided by the building. This is the Template pattern in action, combined with the Factory pattern—the overall design is the Factory, but <a id="_idIndexMarker741"/>the unit type is customized by the derived classes:</p>
<pre class="source-code">
// Example 15
class Unit {};
class Knight : public Unit { ... };
class Mage : public Unit { ... };
class Spider : public Unit { ... };
class Building {
  public:
  virtual Unit* MakeUnit() const = 0;
};
class Castle : public Building {
  public:
  Knight* MakeUnit() const { return new Knight; }
};
class Tower : public Building {
  public:
  Mage* MakeUnit() const { return new Mage; }
};
class Mound : public Building {
  public:
  Spider* MakeUnit() const { return new Spider; }
};</pre>
<p>Each building has a factory for creating the corresponding unit, and we can access these factory methods through the base class <code>Building</code>:</p>
<pre class="source-code">
std::vector&lt;std::unique_ptr&lt;Building&gt;&gt; buildings;
std::vector&lt;std::unique_ptr&lt;Unit&gt;&gt; units;
for (const auto&amp; b : buildings) {
  units.emplace_back(b-&gt;MakeUnit());
}</pre>
<p>The factory that uses polymorphism and is accessed via a virtual function in the base class – usually a pure virtual function – is known as the Abstract Factory pattern.</p>
<p>The factory methods for the buildings themselves are not shown in this example—the Unit factory can coexist with any of the building factory implementations we have learned (the source code example that accompanies this chapter uses the building factory from Example 12). The generic code that constructs units from buildings is written once and does not need to change when new derived classes for buildings and units are added.</p>
<p>Note that the return types of all <code>MakeUnit()</code> functions are different. Nonetheless, they are all overrides of the same virtual <code>Building::MakeUnit()</code> function. These are known as the <em class="italic">covariant return types</em>—the return type of the override method may be a derived class of the return type of the overridden method. In our case, return types match the class types, but in general, this is not required. Any base and derived classes can be used as covariant types, even if they come from a different hierarchy. However, only such types can be covariant, and, other than that exception, the return type of the override must match the base class virtual function.</p>
<p>The strict<a id="_idIndexMarker742"/> rules for covariant return types present some problems when we try and make factories return anything other than a raw pointer. For example, let’s assume that we want to return <code>std::unique_ptr</code> instead of the raw pointer. But, unlike <code>Unit*</code> and <code>Knight*</code>, <code>std::unique_ptr&lt;Unit&gt;</code> and <code>std::unique_ptr&lt;Knight&gt;</code> are not covariant types and cannot be used as return types for a virtual method and its override.</p>
<p>We will consider solutions for this, and several other C++-specific problems related to fact<a id="_idTextAnchor621"/>o<a id="_idTextAnchor622"/>ry methods, in the next section.</p>
<h1 id="_idParaDest-238"><a id="_idTextAnchor623"/>Factory-like patterns in C++</h1>
<p>There are many variations of the<a id="_idIndexMarker743"/> basic Factory patterns used in C++ to address specific design needs and constraints. In this section, we will consider several of them. This is by no means an exclusive list of factory-like patterns in C++, but understanding these variants should prepare the reader for combining the techniques that they have learned from this book to address various design chall<a id="_idTextAnchor624"/>e<a id="_idTextAnchor625"/>nges related to object factories.</p>
<h2 id="_idParaDest-239"><a id="_idTextAnchor626"/>Polymorphic copy</h2>
<p>So far, we have considered <a id="_idIndexMarker744"/>factory alternatives to the object constructor—either the default constructor or one of the constructors with arguments. However, a similar pattern can be applied to the copy constructor—we have an object, and we want to make a copy.</p>
<p>This is a similar problem in many ways—we have an object that’s accessed through the base class pointer, and we want to call its copy constructor. For the reasons we discussed earlier, not the least of which is that the compiler needs to know how much memory to allocate, the actual constructor call has to be done on the statically determined type. However, the control flow that gets us to a particular constructor call can be determined at runtime, and that, again, calls for an application of the Factory pattern.</p>
<p>The factory<a id="_idIndexMarker745"/> method we will use to implement a polymorphic copy is somewhat similar to the Unit factory example from the previous section—the actual construction has to be done by each derived class, and the derived class knows what type of object to construct. The base class implements the control flow that dictates that someone’s copy will be constructed, and the derived class customizes the construction part:</p>
<pre class="source-code">
// Example 16
class Base {
  public:
  virtual Base* clone() const = 0;
};
class Derived : public Base {
  public:
  Derived* clone() const override {
    return new Derived(*this);
  }
};
Base* b0 = ... get an object somewhere ...
Base* b1 = b-&gt;clone();</pre>
<p>We can use the typeid operator (possibly with the demangling function we used earlier in this chapter) to verify that the pointer <code>b1</code> does indeed point to a <code>Derived</code> object.</p>
<p>We have just implemented polymorphic copying using inheritance. Earlier, in <a href="B19262_06.xhtml#_idTextAnchor266"><em class="italic">Chapter 6</em></a>, <em class="italic">Understanding Type Erasure</em>, we have seen another way to copy objects whose type was known at construction time but later lost (or erased). The two approaches are not fundamentally different: when implementing type-erased copying, we built a virtual table ourselves. In this chapter, we had the compiler do it for us. The preferred implementation in any particular case will depend mostly on what else is going on in the code around it.</p>
<p>Note that, once <a id="_idIndexMarker746"/>again, we are using covariant return types, and, therefore, are limited to the raw pointers. Let’s say that we want to return unique pointers instead. Since only the raw pointers to the base and derived types are considered covariant, we have to always return the unique pointer to the base class:</p>
<pre class="source-code">
class Base {
  public:
  virtual std::unique_ptr&lt;Base&gt; clone() const = 0;
};
class Derived : public Base {
  public:
  std::unique_ptr&lt;Base&gt; clone() const override {
    return std::unique_ptr&lt;Base&gt;(new Derived(*this));
  }
};
std::unique_ptr&lt;Base&gt; b(... make an object ...);
std::unique_ptr&lt;Base&gt; b1 = b-&gt;clone();</pre>
<p>In many <a id="_idIndexMarker747"/>cases, this is not a significant limitation. Sometimes, however, it can lead to unnecessary conversions and casts. If returning a smart pointer to the exact type is important, there is another version of th<a id="_idTextAnchor627"/>i<a id="_idTextAnchor628"/>s pattern that we will consider next.</p>
<h2 id="_idParaDest-240"><a id="_idTextAnchor629"/>CRTP Factory and return types</h2>
<p>The only way we<a id="_idIndexMarker748"/> could return <code>std::unique_ptr&lt;Derived&gt;</code> from the factory copy constructor of the derived class is to make the <a id="_idIndexMarker749"/>virtual <code>clone()</code> method of the base class return the same type. But this is impossible, at least if we have more than one derived class—for each derived class, we would need the return type of <code>Base::clone()</code> to be that class. But there is only one <code>Base::clone()</code>! Or is there? Fortunately, in C++, we have an easy way of making many out of one—the templates. If we template the base class, we could make the base of each derived class return the right type. But to do this, we need the base class to somehow know the type of the class that will be derived from it. Of course, there is a pattern for that, too—in C++, it is called the<a id="_idIndexMarker750"/> Curiously Recurring Template Pattern, which we looked at in <a href="B19262_08.xhtml#_idTextAnchor360"><em class="italic">Chapter 8</em></a>, <em class="italic">The Curiously Recurring Template Pattern</em>. Now, we can combine the CRTP and the Factory patterns:</p>
<pre class="source-code">
// Example 18
template &lt;typename Derived&gt; class Base {
  public:
  virtual std::unique_ptr&lt;Derived&gt; clone() const = 0;
};
class Derived : public Base&lt;Derived&gt; {
  public:
  std::unique_ptr&lt;Derived&gt; clone() const override {
    return std::unique_ptr&lt;Derived&gt;(new Derived(*this));
  }
};
std::unique_ptr&lt;Derived&gt; b0(new Derived);
std::unique_ptr&lt;Derived&gt; b1 = b0-&gt;clone();</pre>
<p><code>auto</code> return types make <a id="_idIndexMarker751"/>writing code like this significantly less<a id="_idIndexMarker752"/> verbose. In this book, we generally don’t use them to make it clear which function returns what.</p>
<p>The template parameter of the <code>Base</code> class is one of the classes derived from it, hence the naming. If you wish, you can even enforce this restriction with a static assert:</p>
<pre class="source-code">
template &lt;typename Derived&gt; class Base {
  public:
  virtual std::unique_ptr&lt;Derived&gt; clone() const = 0;
  Base() {
    static_assert(std::is_base_of_v&lt;Base, Derived&gt;;
  }
};</pre>
<p>The reason we had to hide the static assert in the class constructor is that within the declaration of the class itself, the type <code>Derived</code> is incomplete.</p>
<p>Note that, since the <code>Base</code> class now knows the type of the derived class, we don’t even need the <code>clone()</code> method to be virtual:</p>
<pre class="source-code">
// Example 19
template &lt;typename Derived&gt; class Base {
  public:
  std::unique_ptr&lt;Derived&gt; clone() const {
    return std::unique_ptr&lt;Derived&gt;(
      new Derived(*static_cast&lt;const Derived*&gt;(this)));
  }
};
class Derived : public Base&lt;Derived&gt; { ... };</pre>
<p>There are<a id="_idIndexMarker753"/> significant downsides to this method, at<a id="_idIndexMarker754"/> least regarding the way we have implemented it so far. First of all, we had to make the base class a template, which means that we no longer have a common pointer type to use in our general code (or we have to make an even wider use of templates). Second, this approach only works if no more classes are derived from the <code>Derived</code> class, because the type of the base class does not track the second derivation—only the one that instantiated the <code>Base</code> template. Overall, except for the specific cases where it is very important to return the exact type instead of the base type, this approach cannot be recommended.</p>
<p>On the other <a id="_idIndexMarker755"/>hand, there are some attractive features <a id="_idIndexMarker756"/>of this implementation that we may want to preserve. Specifically, we got rid of the multiple copies of the <code>clone()</code> function, one per each derived class, and got a template to generate them for us automatically. In the next section, we will show you how to retain that useful feature of the CRTP implementation, even if we have to give up on extending the notion of <em class="italic">covariant return types</em> to c<a id="_idTextAnchor630"/>o<a id="_idTextAnchor631"/>ver smart pointers by playing template tricks.</p>
<h2 id="_idParaDest-241"><a id="_idTextAnchor632"/>CRTP for Factory implementation</h2>
<p>We have mentioned <a id="_idIndexMarker757"/>several times by now that, while CRTP is sometimes used as a design instrument, it is just as likely to be used as an implementation technique. We will now focus on using CRTP to avoid writing the <code>clone()</code> function in every derived class. This is not just done to reduce typing—the more code is written—especially very similar code that gets copied and modified—the more likely you are to make an error. We have already seen how to use CRTP to generate a version of <code>clone()</code> for every derived class automatically. We just don’t want to give up the common (non-template) base class to do so. We don’t really have to do so if we delegate the cloning to the special base class that handles only that:</p>
<pre class="source-code">
// Example 20
class Base {
  public:
  virtual Base* clone() const = 0;
};
template &lt;typename Derived&gt; class Cloner : public Base {
  public:
  Base* clone() const {
    return new Derived(*static_cast&lt;const Derived*&gt;(this));
  }
};
class Derived : public Cloner&lt;Derived&gt; {
  ...
};
Base* b0(new Derived);
Base* b1 = b0-&gt;clone();</pre>
<p>Here, for simplicity, we went back to returning raw pointers, although we could also return <code>std::unique_ptr&lt;Base&gt;</code>. What we cannot do is return <code>Derived*</code> since, at the time when the template for the <code>Cloner</code> is parsed, it is not known that <code>Derived</code> is always derived from <code>Base</code>.</p>
<p>This design allows us to derive any number of classes from <code>Base</code>, indirectly through <code>Cloner</code>, and not have to write another <code>clone()</code> function ever again. It still has the limitation that, if we derive another class from <code>Derived</code>, it will not be copied correctly. In many designs, this is not an issue—enlightened self-interest should guide you to avoid deep hierarchies and make all classes be one of two kinds: abstract base classes that are never instantiated, and concrete classes that are derived from one of these base <a id="_idTextAnchor633"/>classes, but never from <a id="_idIndexMarker758"/>another concrete class.</p>
<h2 id="_idParaDest-242"><a id="_idTextAnchor634"/>Factory and Builder</h2>
<p>So far, we have been using <a id="_idIndexMarker759"/>mostly factory functions, or, more generally, functors such as lambdas. In practice, it is just as likely that we will need a factory class. This usually happens because the run-time information needed to construct an object is more complex than just the type identifier and a few arguments. These are the same reasons we may choose to use the Builder pattern to create objects, so a factory class can also be viewed as a builder class with a factory method used to create the concrete objects. The Unit factory we have seen earlier in this chapter is an example of such a pattern: the Building class and all of its derived classes act like a builder for the unit objects (and the fact that the building objects themselves are created by another factory only serves as yet another demonstration that even a simple piece of code can rarely be reduced to a single pattern). In that case, however, we had a special motive for using the factory class: each derived building class constructs its own unit objects.</p>
<p>Let us now consider a more common case for using a factory class: the overall complexity of the run-time data that goes into deciding which class to construct and how, as well as the non-trivial amount of code we need to do so. While it is possible to handle it all with a factory function and some global objects, it would be a poor design, lacking in cohesion and encapsulation. It is going to be error-prone and difficult to maintain. It is much better to encapsulate all related code and data into one class or a small number of related classes.</p>
<p>For this <a id="_idIndexMarker760"/>example, we are going to tackle the very common (and still very challenging) serialization/deserialization problem. In our case, we have a number of objects derived from the same base class. We want to implement the framework necessary to serialize them by writing them into a file and then restoring the objects from this file. In this final example of the chapter, we are going to combine several methods we have learned to design and implement the factory.</p>
<p>We are going to start with the base class. The base class is going to utilize the dynamic type registry we learned earlier. Also, it is going to declare a pure virtual <code>Serialize()</code> function that every derived class needs to implement to serialize itself into a file:</p>
<pre class="source-code">
// Example 21
class SerializerBase {
  static size_t type_count;
  using Factory = SerializerBase* (*)(std::istream&amp; s);
  static std::vector&lt;Factory&gt; registry;
  protected:
  virtual void Serialize(std::ostream&amp; s) const = 0;
  public:
  virtual ~SerializerBase() {}
  static size_t RegisterType(Factory factory) {
    registry.push_back(factory);
    return type_count++;
  }
  static auto Deserialize(size_t type, std::istream&amp; s) {
    Factory factory = registry[type];
    return std::unique_ptr&lt;SerializerBase&gt;(factory(s));
  }
};
std::vector&lt;SerializerBase::Factory&gt;
  SerializerBase::registry;
size_t SerializerBase::type_count = 0;</pre>
<p>Any derived<a id="_idIndexMarker761"/> class needs to implement the <code>Serialize()</code> function as well as register the deserialization function:</p>
<pre class="source-code">
// Example 21
class Derived1 : public SerializerBase {
  int i_;
  public:
  Derived1(int i) : i_(i) {...}
  void Serialize(std::ostream&amp; s) const override {
    s &lt;&lt; type_tag &lt;&lt; " " &lt;&lt; i_ &lt;&lt; std::endl;
  }
  static const size_t type_tag;
};
const size_t Derived1::type_tag =
  RegisterType([](std::istream&amp; s)-&gt;SerializerBase* {
    int i; s &gt;&gt; i; return new Derived1(i); });</pre>
<p>Only the derived class itself has the information about its state, what must be saved in order to<a id="_idIndexMarker762"/> reconstitute the object, and how to do so. In our example, the serialization is always done in the <code>Serialize()</code> function, while the deserialization is done in the lambda we register with the type registry. Needless to say, the two must be consistent with each other. There are template-based tricks that can ensure this consistency, but they aren’t relevant to the factory construction we are studying now.</p>
<p>We have the serialization part handled – all we need to do is call Serialize on any object we have:</p>
<pre class="source-code">
std::ostream S ... – construct the stream as needed
Derived1 d(42);
d.Serialize(S);</pre>
<p>The deserialization itself is not particularly hard (most of the work is done by the derived classes), but there is enough boilerplate code there to justify a factory class. A factory object will read the entire file and deserialize (re-create) all objects recorded there. There are, of course, many options for the destination of such objects. Since we are constructing objects whose types are not known at compile-time, we have to access them through the base class pointers. For example, we can store them in a container of unique pointers:</p>
<pre class="source-code">
// Example 21
class DeserializerFactory {
  std::istream&amp; s_;
  public:
  explicit DeserializerFactory(std::istream&amp; s) : s_(s) {}
  template &lt;typename It&gt;
  void Deserialize(It iter) {
    while (true) {
      size_t type;
      s_ &gt;&gt; type;
      if (s_.eof()) return;
      iter = SerializerBase::Deserialize(type, s_);
    }
  }
};</pre>
<p>This<a id="_idIndexMarker763"/> factory reads the entire file, line by line. First, it reads just the type identifier (which each object must write during serialization). Based on that identifier, it dispatches the rest of the deserialization process to the correct function registered for the corresponding type. The factory uses an inserter iterator (such as a back-inserter) to store all deserialized objects in a container:</p>
<pre class="source-code">
// Example 21
std::vector&lt;std::unique_ptr&lt;SerializerBase&gt;&gt; v;
DeserializerFactory F(S);
F.Deserialize(std::back_inserter(v));</pre>
<p>With this approach, we can handle any class derived from SerializerBase, as long as we can come up with a way to write it into a file and restore it. We can handle a more complex state and constructors with multiple arguments:</p>
<pre class="source-code">
// Example 21
class Derived2 : public SerializerBase {
  double x_, y_;
  public:
  Derived2(double x, double y) : x_(x), y_(y) {...}
  void Serialize(std::ostream&amp; s) const override {
    s &lt;&lt; type_tag &lt;&lt; " " &lt;&lt; x_ &lt;&lt; " " &lt;&lt; y_ &lt;&lt; std::endl;
  }
  static const size_t type_tag;
};
const size_t Derived2::type_tag =
  RegisterType([](std::istream&amp; s)-&gt;SerializerBase* {
    double x, y; s &gt;&gt; x &gt;&gt; y;
    return new Derived2(x, y);
});</pre>
<p>We can<a id="_idIndexMarker764"/> equally easily deal with classes that have multiple constructors as long as we know how a particular object should be constructed again:</p>
<pre class="source-code">
// Example 21
class Derived3 : public SerializerBase {
  bool integer_;
  int i_ {};
  double x_ {};
  public:
  Derived3(int i) : integer_(true), i_(i) {...}
  Derived3(double x) : integer_(false), x_(x) {...}
  void Serialize(std::ostream&amp; s) const override {
    s &lt;&lt; type_tag &lt;&lt; " " &lt;&lt; integer_ &lt;&lt; " ";
    if (integer_) s &lt;&lt; i_; else s &lt;&lt; x_;
    s &lt;&lt; std::endl;
  }
  static const size_t type_tag;
};
const size_t Derived3::type_tag =
  RegisterType([](std::istream&amp; s)-&gt;SerializerBase* {
    bool integer; s &gt;&gt; integer;
    if (integer) {
      int i; s &gt;&gt; i; return new Derived3(i);
    } else {
      double x; s &gt;&gt; x; return new Derived3(x);
  }
});</pre>
<p>There are <a id="_idIndexMarker765"/>many more variations of the factory pattern in C++. If you understood the explanations and followed through with the examples in this chapter, none of these alte<a id="_idTextAnchor635"/>rnatives should present a particular challenge for you.</p>
<h1 id="_idParaDest-243"><a id="_idTextAnchor636"/>Summary</h1>
<p>In this chapter, we have learned why constructors cannot be made virtual, and what to do when we really want a virtual constructor anyway. We have learned how to construct and copy objects whose type becomes known at runtime by using the Factory pattern and one of its variations. We also explored several implementations of the Factory constructor that differ in the way that the code is organized and that the behavior is delegated to different components of the system, and compared their advantages and trade-offs. We have also seen how multiple design patterns interact with each other.</p>
<p>While in C++, the constructor has to be invoked with the true type of the object to construct—always—this does not mean that the application code has to specify the complete type. The Factory pattern allows us to write code that specifies the type indirectly, using an identifier that is associated with the type elsewhere (<em class="italic">create an object of the third kind</em>), or an associated object type (<em class="italic">create a unit that goes with this building type</em>), or even the same type (<em class="italic">make me a copy of this, whatever </em><em class="italic">it is</em>).</p>
<p>The next design pattern we will study in the following chapter is the Template Method pattern, one of the classic object-oriented patterns that, in C++, has addition<a id="_idTextAnchor637"/>a<a id="_idTextAnchor638"/>l implications for the way we design class hierarchies.</p>
<h1 id="_idParaDest-244"><a id="_idTextAnchor639"/>Questions</h1>
<ol>
<li>Why does C++ not allow a virtual constructor?</li>
<li>What is the Factory pattern?</li>
<li>How do you use the Factory pattern to achieve the effect of a virtual constructor?</li>
<li>How do you achieve the effect of a virtual copy constructor?</li>
<li>How do you use the Template and Factory patterns together?</li>
<li>How do you use the Builder and the Factory patterns together?</li>
</ol>
</div>
</body></html>