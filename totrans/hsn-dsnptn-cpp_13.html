<html><head></head><body>
<div id="_idContainer029">
<h1 class="chapter-number" id="_idParaDest-227"><a id="_idTextAnchor596"/><span class="koboSpan" id="kobo.1.1">13</span></h1>
<h1 id="_idParaDest-228"><a id="_idTextAnchor597"/><span class="koboSpan" id="kobo.2.1">Virtual Constructors and Factories</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In C++, any member function of any class, including its destructor, can be made virtual - any member function except one—the constructor. </span><span class="koboSpan" id="kobo.3.2">Without virtual functions, the exact type of object on which the member function is invoked is known at compile time. </span><span class="koboSpan" id="kobo.3.3">Therefore, the type of object that is constructed is always known at compile time, at the point of the constructor call. </span><span class="koboSpan" id="kobo.3.4">Nonetheless, we often need to construct objects whose type is not known until runtime. </span><span class="koboSpan" id="kobo.3.5">This chapter describes several related patterns and idioms that address this design problem in various ways, including the </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">Factory pattern.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">The following topics will be covered in </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">Why there is no way to make a </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">constructor virtual</span></span></li>
<li><span class="koboSpan" id="kobo.9.1">How to use the Factory pattern to defer the choice of the constructed object type until </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">compile time</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Using C++ idioms to construct and copy </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">objects polymorphically</span></span></li>
</ul>
<h1 id="_idParaDest-229"><a id="_idTextAnchor598"/><a id="_idTextAnchor599"/><span class="koboSpan" id="kobo.13.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.14.1">The example code for this chapter can be found at the following GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">link: </span></span><a href="https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP_Second_Edition/tree/master/Chapter13"><span class="No-Break"><span class="koboSpan" id="kobo.16.1">https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP_Second_Edition/tree/master/Chapter13</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.17.1">.</span></span><a id="_idTextAnchor600"/></p>
<h1 id="_idParaDest-230"><a id="_idTextAnchor601"/><span class="koboSpan" id="kobo.18.1">Why constructors cannot be virtual</span></h1>
<p><span class="koboSpan" id="kobo.19.1">We already understand how polymorphism works—when a virtual function is called through a pointer or a reference to the base class, that pointer or reference is used to access the v-pointer in the class. </span><span class="koboSpan" id="kobo.19.2">The v-pointer</span><a id="_idIndexMarker710"/><span class="koboSpan" id="kobo.20.1"> is used to identify the true type of the object, that is, the type that the object was created with. </span><span class="koboSpan" id="kobo.20.2">It could be the base class itself, or any one of the derived classes. </span><span class="koboSpan" id="kobo.20.3">The member function on that object is actually called. </span><span class="koboSpan" id="kobo.20.4">So, why can’t the same be done for constructors? </span><span class="koboSpan" id="kobo.20.5">Let’s </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">investigate this</span><a id="_idTextAnchor602"/><span class="koboSpan" id="kobo.22.1">.</span></span><a id="_idTextAnchor603"/></p>
<h2 id="_idParaDest-231"><a id="_idTextAnchor604"/><span class="koboSpan" id="kobo.23.1">When does an object get its type?</span></h2>
<p><span class="koboSpan" id="kobo.24.1">It is pretty easy to</span><a id="_idIndexMarker711"/><span class="koboSpan" id="kobo.25.1"> understand why the process that we described previously cannot work for creating </span><em class="italic"><span class="koboSpan" id="kobo.26.1">virtual constructors</span></em><span class="koboSpan" id="kobo.27.1">. </span><span class="koboSpan" id="kobo.27.2">First of all, it is evident from the description of the preceding process—as a part of it, we </span><em class="italic"><span class="koboSpan" id="kobo.28.1">identify the type that the object was created with</span></em><span class="koboSpan" id="kobo.29.1">. </span><span class="koboSpan" id="kobo.29.2">That can only happen after the object is constructed—before construction, we don’t have an object of this type yet, just some uninitialized memory. </span><span class="koboSpan" id="kobo.29.3">Another way to look at it is this—before the virtual function is dispatched to the correct type, the v-pointer needs to be looked up. </span><span class="koboSpan" id="kobo.29.4">Who puts the right value into the v-pointer? </span><span class="koboSpan" id="kobo.29.5">Considering that the v-pointer uniquely identifies the type of object, it can only be initialized during construction. </span><span class="koboSpan" id="kobo.29.6">This implies that it wasn’t initialized before construction. </span><span class="koboSpan" id="kobo.29.7">But if it wasn’t initialized, it can’t be used to dispatch virtual function calls. </span><span class="koboSpan" id="kobo.29.8">And so again, we realize that constructors cannot </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">be virtual.</span></span></p>
<p><span class="koboSpan" id="kobo.31.1">For derived classes in the hierarchy, the process of establishing the type is even more complex. </span><span class="koboSpan" id="kobo.31.2">We can try to observe the type of an object as it is being constructed. </span><span class="koboSpan" id="kobo.31.3">The easiest way to do this is to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.32.1">typeid</span></strong><span class="koboSpan" id="kobo.33.1"> operator, which returns information about the object’s type, including the name of </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">the type:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.35.1">
// Example 01
#include &lt;iostream&gt;
#include &lt;typeinfo&gt;
using std::cout;
using std::endl;
template &lt;typename T&gt;
auto type(T&amp;&amp; t) { return typeid(t).name(); }
class A {
  public:
  A() { cout &lt;&lt; "A::A(): " &lt;&lt; type(*this) &lt;&lt; endl; }
  virtual
  ~A() { cout &lt;&lt; "A::~A(): " &lt;&lt; type(*this) &lt;&lt; endl; }
};
class B : public A {
  public:
  B() { cout &lt;&lt; "B::B(): " &lt;&lt; type(*this) &lt;&lt; endl; }
  ~B() { cout &lt;&lt; "B::~B(): " &lt;&lt; type(*this) &lt;&lt; endl; }
};
class C : public B {
  public:
  C() { cout &lt;&lt; "C::C(): " &lt;&lt; type(*this) &lt;&lt; endl; }
  ~C() { cout &lt;&lt; "C::~C(): " &lt;&lt; type(*this) &lt;&lt; endl; }
};
int main() {
  C c;
}</span></pre>
<p><span class="koboSpan" id="kobo.36.1">Running this program produces the </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">following result:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.38.1">
A::A(): 1A
B::B(): 1B
C::C(): 1C
C::~C(): 1C
B::~B(): 1B
A::~A(): 1A</span></pre>
<p><span class="koboSpan" id="kobo.39.1">The type</span><a id="_idIndexMarker712"/><span class="koboSpan" id="kobo.40.1"> name returned by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.41.1">std::typeinfo::name()</span></strong><span class="koboSpan" id="kobo.42.1"> call is the so-called mangled type name—it’s the internal name that the compiler uses to identify types, instead of human-readable names such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.43.1">class A</span></strong><span class="koboSpan" id="kobo.44.1">. </span><span class="koboSpan" id="kobo.44.2">If you want to know the unmangled type, you can use a demangler such as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.45.1">c++filt</span></strong><span class="koboSpan" id="kobo.46.1"> program that comes </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">with GCC:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.48.1">
$ c++filt -t 1A
A</span></pre>
<p><span class="koboSpan" id="kobo.49.1">We can also </span><a id="_idIndexMarker713"/><span class="koboSpan" id="kobo.50.1">write a small C++ function to demangle type names, but the way to do it varies from one compiler to another (there is no portable version). </span><span class="koboSpan" id="kobo.50.2">For example, this is what you would write </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">for GCC:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.52.1">
// Example 2
#include &lt;cxxabi.h&gt;
template &lt;typename T&gt; auto type(T&amp;&amp; p) {
  int r;
  std::string name;
  char* mangled_name =
    abi::__cxa_demangle(typeid(p).name(), 0, 0, &amp;r);
  name += mangled_name;
  ::free(mangled_name);
  return name;
}</span></pre>
<p><span class="koboSpan" id="kobo.53.1">Note that the demangler function returns a C string (a </span><strong class="source-inline"><span class="koboSpan" id="kobo.54.1">char*</span></strong><span class="koboSpan" id="kobo.55.1"> pointer) that must be explicitly freed by the caller. </span><span class="koboSpan" id="kobo.55.2">The program now prints demangled names such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.56.1">A</span></strong><span class="koboSpan" id="kobo.57.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.58.1">B</span></strong><span class="koboSpan" id="kobo.59.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.60.1">C</span></strong><span class="koboSpan" id="kobo.61.1">. </span><span class="koboSpan" id="kobo.61.2">This is enough for our use, but in some cases, you might notice that the type is not printed exactly as it </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">should be:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.63.1">
class A {
  public:
  void f() const { cout &lt;&lt; type(*this) &lt;&lt; endl; }
};
...
</span><span class="koboSpan" id="kobo.63.2">C c;
c.f();</span></pre>
<p><span class="koboSpan" id="kobo.64.1">If we call </span><a id="_idIndexMarker714"/><span class="koboSpan" id="kobo.65.1">the function </span><strong class="source-inline"><span class="koboSpan" id="kobo.66.1">f()</span></strong><span class="koboSpan" id="kobo.67.1">,  the type is reported as </span><strong class="source-inline"><span class="koboSpan" id="kobo.68.1">C</span></strong><span class="koboSpan" id="kobo.69.1"> but not </span><strong class="source-inline"><span class="koboSpan" id="kobo.70.1">const C</span></strong><span class="koboSpan" id="kobo.71.1"> as we might expect (the object is </span><strong class="source-inline"><span class="koboSpan" id="kobo.72.1">const</span></strong><span class="koboSpan" id="kobo.73.1"> inside a </span><strong class="source-inline"><span class="koboSpan" id="kobo.74.1">const</span></strong><span class="koboSpan" id="kobo.75.1"> member function). </span><span class="koboSpan" id="kobo.75.2">This is because the </span><strong class="source-inline"><span class="koboSpan" id="kobo.76.1">typeid</span></strong><span class="koboSpan" id="kobo.77.1"> operator removed the </span><strong class="source-inline"><span class="koboSpan" id="kobo.78.1">const</span></strong><span class="koboSpan" id="kobo.79.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.80.1">volatile</span></strong><span class="koboSpan" id="kobo.81.1"> qualifiers as well as any references from the type. </span><span class="koboSpan" id="kobo.81.2">To print those, you have to figure them out </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">by yourself:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.83.1">
// Example 03
template &lt;typename T&gt; auto type(T&amp;&amp; p) {
  std::string name;
  using TT = std::remove_reference_t&lt;T&gt;;
  if (std::is_const&lt;TT&gt;::value) name += "const ";
  if (std::is_volatile&lt;TT&gt;::value) name += "volatile ";
  int r;
  name += abi::__cxa_demangle(typeid(p).name(), 0, 0, &amp;r);
  return name;
}</span></pre>
<p><span class="koboSpan" id="kobo.84.1">Regardless of how you choose to print the types, how many objects were constructed in these examples? </span><span class="koboSpan" id="kobo.84.2">The source code says just one, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">c</span></strong><span class="koboSpan" id="kobo.86.1"> object of </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">type </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">C</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.90.1">
int main() {
  C c;
}</span></pre>
<p><span class="koboSpan" id="kobo.91.1">The runtime output says three, that is, one of each type. </span><span class="koboSpan" id="kobo.91.2">Both answers are correct—when an object of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">C</span></strong><span class="koboSpan" id="kobo.93.1"> is constructed, the base class, </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">A</span></strong><span class="koboSpan" id="kobo.95.1">, has to be constructed first, and so its constructor is called. </span><span class="koboSpan" id="kobo.95.2">Then, the intermediate base class, </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">B</span></strong><span class="koboSpan" id="kobo.97.1">, is constructed, and only then will </span><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">C</span></strong><span class="koboSpan" id="kobo.99.1"> be. </span><span class="koboSpan" id="kobo.99.2">The destructors are executed in reverse order. </span><span class="koboSpan" id="kobo.99.3">The type of the object inside its constructor or destructor, as reported by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">typeid</span></strong><span class="koboSpan" id="kobo.101.1"> operator, is the same as the type of object whose constructor or destructor </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">is running.</span></span></p>
<p><span class="koboSpan" id="kobo.103.1">It appears that the type, as indicated by the virtual pointer, is changing during the construction! </span><span class="koboSpan" id="kobo.103.2">That is, of course, assuming that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.104.1">typeid</span></strong><span class="koboSpan" id="kobo.105.1"> operator returns the dynamic type, the type indicated by the virtual pointer, and not the static type that can be determined at compile time. </span><span class="koboSpan" id="kobo.105.2">The standard says that this is, indeed, the case. </span><span class="koboSpan" id="kobo.105.3">Does this mean that, if we called the same virtual method from each constructor, we would really be calling three different </span><a id="_idIndexMarker715"/><span class="koboSpan" id="kobo.106.1">overrides of this method? </span><span class="koboSpan" id="kobo.106.2">It’s easy enough to </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">find out:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.108.1">
// Example 04
class A {
  public:
  A() { whoami(); }
  virtual ~A() { whoami(); }
  virtual void whoami() const {
    std::cout &lt;&lt; "A::whoami" &lt;&lt; std::endl;
  }
};
class B : public A {
  public:
  B() { whoami(); }
  ~B() { whoami(); }
  void whoami() const override {
    std::cout &lt;&lt; "B::whoami" &lt;&lt; std::endl;
  }
};
class C : public B {
  public:
  C() { whoami(); }
  ~C() { whoami(); }
  void whoami() const override {
    std::cout &lt;&lt; "C::whoami" &lt;&lt; std::endl;
  }
};
int main() {
  C c;
  c.whoami();
}</span></pre>
<p><span class="koboSpan" id="kobo.109.1">Now, we will create the </span><a id="_idIndexMarker716"/><span class="koboSpan" id="kobo.110.1">object of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.111.1">C</span></strong><span class="koboSpan" id="kobo.112.1">, and the call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">whoami()</span></strong><span class="koboSpan" id="kobo.114.1"> after the creation confirms it – the dynamic type of the object is </span><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">C</span></strong><span class="koboSpan" id="kobo.116.1">. </span><span class="koboSpan" id="kobo.116.2">That was true from the beginning of the construction process; we asked the compiler to construct one object of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">C</span></strong><span class="koboSpan" id="kobo.118.1">, but the dynamic type of the object changed </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">during construction:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.120.1">
A::whoami
B::whoami
C::whoami
C::whoami
C::whoami
B::whoami
A::whoami</span></pre>
<p><span class="koboSpan" id="kobo.121.1">It is clear that the virtual pointer value has changed as the construction of the object progressed. </span><span class="koboSpan" id="kobo.121.2">In the beginning, it was identifying the object type as </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">A</span></strong><span class="koboSpan" id="kobo.123.1">, even though the final type is </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">C</span></strong><span class="koboSpan" id="kobo.125.1">. </span><span class="koboSpan" id="kobo.125.2">Is this because we created the object on the stack? </span><span class="koboSpan" id="kobo.125.3">Would it be any different if the object was created on the heap? </span><span class="koboSpan" id="kobo.125.4">We can easily </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">find out:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.127.1">
C* c = new C;
c-&gt;whoami();
delete c;</span></pre>
<p><span class="koboSpan" id="kobo.128.1">Running the modified program produces exactly the same results as </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">the original.</span></span></p>
<p><span class="koboSpan" id="kobo.130.1">Another reason that the constructor cannot be virtual, or, more generally, why the type of the object being constructed has to be known at compile time at the point of construction, is that the compiler has to know how much memory to allocate for the object. </span><span class="koboSpan" id="kobo.130.2">The amount of memory is determined by the size of the type, that is, by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">sizeof</span></strong><span class="koboSpan" id="kobo.132.1"> operator. </span><span class="koboSpan" id="kobo.132.2">The result of </span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">sizeof(C)</span></strong><span class="koboSpan" id="kobo.134.1"> is a compile-time constant, so the amount of memory allocated for the new object is always known at compile time. </span><span class="koboSpan" id="kobo.134.2">This is true whether we create the object on the stack or on </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">the heap.</span></span></p>
<p><span class="koboSpan" id="kobo.136.1">The bottom line is this—if the program creates an object of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">T</span></strong><span class="koboSpan" id="kobo.138.1"> type, somewhere in the code there is an explicit call to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.139.1">T::T</span></strong><span class="koboSpan" id="kobo.140.1"> constructor. </span><span class="koboSpan" id="kobo.140.2">After that, we can hide the </span><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">T</span></strong><span class="koboSpan" id="kobo.142.1"> type in the rest of the program, for example, by accessing the object through a base class pointer, or by erasing the type (see </span><a href="B19262_06.xhtml#_idTextAnchor266"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.143.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.144.1">, </span><em class="italic"><span class="koboSpan" id="kobo.145.1">Understanding Type Erasure</span></em><span class="koboSpan" id="kobo.146.1">). </span><span class="koboSpan" id="kobo.146.2">But there has to be at least one explicit mention of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">T</span></strong><span class="koboSpan" id="kobo.148.1"> type in the code, and that is at the point </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">of construction.</span></span></p>
<p><span class="koboSpan" id="kobo.150.1">On the one hand, we now </span><a id="_idIndexMarker717"/><span class="koboSpan" id="kobo.151.1">have a very reasonable explanation of why constructing objects can never be polymorphic. </span><span class="koboSpan" id="kobo.151.2">On the other hand, this does nothing to address a design challenge that may require constructing an object whose type is not known at compile time. </span><span class="koboSpan" id="kobo.151.3">Consider designing a game—a player can recruit or summon any number of adventurers for their party and build settlements and cities. </span><span class="koboSpan" id="kobo.151.4">It would be reasonable to have a separate class for each creature kind and each building type, but then we have to construct an object of one of these types when an adventurer joins the party, or a building is erected, and until the player selects it, the game cannot know which object </span><span class="No-Break"><span class="koboSpan" id="kobo.152.1">to construct.</span></span></p>
<p><span class="koboSpan" id="kobo.153.1">As usual in software, the solution involves adding another level </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">of indi</span><a id="_idTextAnchor605"/><span class="koboSpan" id="kobo.155.1">r</span><a id="_idTextAnchor606"/><span class="koboSpan" id="kobo.156.1">ection.</span></span></p>
<h1 id="_idParaDest-232"><a id="_idTextAnchor607"/><span class="koboSpan" id="kobo.157.1">The Factory pattern</span></h1>
<p><span class="koboSpan" id="kobo.158.1">The problem we </span><a id="_idIndexMarker718"/><span class="koboSpan" id="kobo.159.1">are faced with, that is, how to decide at runtime to create an object of a particular type, is obviously a very common design problem. </span><span class="koboSpan" id="kobo.159.2">Design patterns are the solutions for just such problems, and there is a pattern for this problem as well—it’s called the Factory pattern. </span><span class="koboSpan" id="kobo.159.3">The Factory pattern is a creational pattern, and it provides solutions for several related problems—how to delegate the decision of which object to create to a derived class, how to create objects using a separate factory method, and so on. </span><span class="koboSpan" id="kobo.159.4">We will review these variations of the Factory pattern one by one, starting with the basic </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">factor</span><a id="_idTextAnchor608"/><span class="koboSpan" id="kobo.161.1">y</span><a id="_idTextAnchor609"/><span class="koboSpan" id="kobo.162.1"> method.</span></span></p>
<h2 id="_idParaDest-233"><a id="_idTextAnchor610"/><span class="koboSpan" id="kobo.163.1">The basics of the Factory method</span></h2>
<p><span class="koboSpan" id="kobo.164.1">In its simplest </span><a id="_idIndexMarker719"/><span class="koboSpan" id="kobo.165.1">form, the factory method constructs an object of a type that’s specified </span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">at runtime:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.167.1">
class Base { ... </span><span class="koboSpan" id="kobo.167.2">};
class Derived : public Base { ... </span><span class="koboSpan" id="kobo.167.3">};
Base* p = ClassFactory(type_identifier, ... </span><span class="koboSpan" id="kobo.167.4">arguments );</span></pre>
<p><span class="koboSpan" id="kobo.168.1">How do we identify at runtime which object to create? </span><span class="koboSpan" id="kobo.168.2">We need a runtime identifier for each type that the factory can create. </span><span class="koboSpan" id="kobo.168.3">In the simplest case, the list of these types is known at </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">compile time.</span></span></p>
<p><span class="koboSpan" id="kobo.170.1">Consider a game design where a player selects the type of building to construct from a menu. </span><span class="koboSpan" id="kobo.170.2">The program has a list of buildings that can be constructed, each represented by an object, with an identifier for </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">each one:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.172.1">
// Example 05
enum Buildings {
  FARM, FORGE, MILL, GUARDHOUSE, KEEP, CASTLE
};
class Building {
  public:
  virtual ~Building() {}
};
class Farm : public Building { ... </span><span class="koboSpan" id="kobo.172.2">};
class Forge : public Building { ... </span><span class="koboSpan" id="kobo.172.3">};</span></pre>
<p><span class="koboSpan" id="kobo.173.1">When the player selects the building type, the corresponding identifier value is also selected by the game program. </span><span class="koboSpan" id="kobo.173.2">Now, the program can construct the building using the </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">factory method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.175.1">
Building* new_farm = MakeBuilding(FARM);</span></pre>
<p><span class="koboSpan" id="kobo.176.1">Note that the</span><a id="_idIndexMarker720"/><span class="koboSpan" id="kobo.177.1"> factory takes the type identifier argument and returns the pointer to the base class. </span><span class="koboSpan" id="kobo.177.2">The returned object should have the type that corresponds to the type identifier. </span><span class="koboSpan" id="kobo.177.3">How is the factory implemented? </span><span class="koboSpan" id="kobo.177.4">Remember the conclusion of the last section—somewhere in the program, every object has to be explicitly constructed with its true type. </span><span class="koboSpan" id="kobo.177.5">The Factory pattern does not remove this requirement; it merely hides the place where the </span><span class="No-Break"><span class="koboSpan" id="kobo.178.1">construction happens:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.179.1">
// Example 05
Building* MakeBuilding(Buildings building_type) {
  switch (building_type) {
    case FARM: return new Farm;
    case FORGE: return new Forge;
    ...
</span><span class="koboSpan" id="kobo.179.2">  }
}</span></pre>
<p><span class="koboSpan" id="kobo.180.1">The correspondence between the type identifier and the object type is encoded in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">switch</span></strong><span class="koboSpan" id="kobo.182.1"> statement inside the factory. </span><span class="koboSpan" id="kobo.182.2">The return type has to be the same for all types that are constructed by the factory since there is only one factory method, and its type is declared at compile time. </span><span class="koboSpan" id="kobo.182.3">In the simplest case, it is the base class pointer, although if you follow the modern memory ownership idioms described in </span><a href="B19262_03.xhtml#_idTextAnchor110"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.183.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.184.1">, </span><em class="italic"><span class="koboSpan" id="kobo.185.1">Memory and Ownership</span></em><span class="koboSpan" id="kobo.186.1">, of this book, the factory should return a unique pointer to the base </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">class, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">std::unique_ptr&lt;Building&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">.</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.190.1">
// Example 06:
class Building {
  public:
  enum Type {FARM, FORGE, ...};
  virtual ~Building() {}
  auto MakeBuilding(Type building_type);
};
auto Building::MakeBuilding(Type building_type) {
  using result_t = std::unique_ptr&lt;Building&gt;;
  switch (building_type) {
    case FARM: return result_t{new Farm};
    case FORGE: return result_t{new Forge};
    ...
</span><span class="koboSpan" id="kobo.190.2">  }
}</span></pre>
<p><span class="koboSpan" id="kobo.191.1">In rare cases when the</span><a id="_idIndexMarker721"/><span class="koboSpan" id="kobo.192.1"> shared ownership is really needed, the shared pointer, </span><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">std::shared_ptr&lt;Building&gt;</span></strong><span class="koboSpan" id="kobo.194.1">, can be constructed by moving the object from the unique pointer (but this is the decision to be made by the caller, not the </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">factory itself).</span></span></p>
<p><span class="koboSpan" id="kobo.196.1">The other design choice that we made here (independently of using the owning pointer) is to move the type identifiers and the factory function into the base class. </span><span class="koboSpan" id="kobo.196.2">This is useful for encapsulation and to keep all related code and types </span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">closer together.</span></span></p>
<p><span class="koboSpan" id="kobo.198.1">This is the basic form of the factory method. </span><span class="koboSpan" id="kobo.198.2">There are many variations that make it more suitable for a particular problem. </span><span class="koboSpan" id="kobo.198.3">We will review some of these </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">vari</span><a id="_idTextAnchor611"/><span class="koboSpan" id="kobo.200.1">a</span><a id="_idTextAnchor612"/><span class="koboSpan" id="kobo.201.1">tions here.</span></span></p>
<h2 id="_idParaDest-234"><a id="_idTextAnchor613"/><span class="koboSpan" id="kobo.202.1">Factory clarification</span></h2>
<p><span class="koboSpan" id="kobo.203.1">Note that </span><a id="_idIndexMarker722"/><span class="koboSpan" id="kobo.204.1">there is some ambiguity in the use of the term “factory method.” </span><span class="koboSpan" id="kobo.204.2">In this chapter, we use it to describe the function that creates objects of different types based on some run-time information. </span><span class="koboSpan" id="kobo.204.3">There is another, not related, design pattern that is sometimes introduced with the same name: instead of constructing different classes, this pattern constructs the same class but in different ways. </span><span class="koboSpan" id="kobo.204.4">Here is a brief example: suppose we have a class to represent a point on a plain. </span><span class="koboSpan" id="kobo.204.5">The point is described by its coordinates, </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">x</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.206.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">y</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.209.1">
class Point {
  double x_ {};
  double y_ {};
  public:
  Point(double x, double y) : x_(x), y_(y) {}
};</span></pre>
<p><span class="koboSpan" id="kobo.210.1">So far, so good. </span><span class="koboSpan" id="kobo.210.2">But the same point can be described using, for example, polar coordinates. </span><span class="koboSpan" id="kobo.210.3">Because these are two ways to describe the same point, we do not need a separate class, but we may want a new constructor that creates a cartesian point from the specified </span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">polar coordinates:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.212.1">
class Point() {
  ...
</span><span class="koboSpan" id="kobo.212.2">  Point(double r, double angle);
};</span></pre>
<p><span class="koboSpan" id="kobo.213.1">But this is not going to work: the new constructor and the original constructor from </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">x</span></strong><span class="koboSpan" id="kobo.215.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">y</span></strong><span class="koboSpan" id="kobo.217.1"> both take exactly the same arguments, so there is no way for the overload resolution to figure out which one you meant. </span><span class="koboSpan" id="kobo.217.2">One solution is to use different types for quantities that are measured in different units (length and angle, in our case). </span><span class="koboSpan" id="kobo.217.3">But they have to be truly different types, not just aliases. </span><span class="koboSpan" id="kobo.217.4">Sometimes, such a unit template library is just what you need, but if you’re staying with doubles, you need some other way of invoking different constructors based on the caller’s intent and not just </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">the arguments.</span></span></p>
<p><span class="koboSpan" id="kobo.219.1">One way to handle this problem is to switch to factory construction. </span><span class="koboSpan" id="kobo.219.2">Instead of using the constructors, we will construct all </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">Point</span></strong><span class="koboSpan" id="kobo.221.1"> objects using static factory methods. </span><span class="koboSpan" id="kobo.221.2">Note that the constructor itself is </span><a id="_idIndexMarker723"/><span class="koboSpan" id="kobo.222.1">usually made private when using </span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">this approach:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.224.1">
// Example 07
class Point {
  double x_ {};
  double y_ {};
  Point(double x, double y) : x_(x), y_(y) {}
  public:
  static Point new_cartesian(double x, double y) {
    return Point(x, y);
  }
  static Point new_polar(double r, double phi) {
    return Point(r*std::cos(phi), r*std::sin(phi));
  }
};
Point p1(Point::new_cartesian(3, 4));
Point p2(Point::new_polar(5, 0.927295));</span></pre>
<p><span class="koboSpan" id="kobo.225.1">This design works, but in</span><a id="_idIndexMarker724"/><span class="koboSpan" id="kobo.226.1"> modern C++, the more popular alternative is to use multiple constructors and disambiguate them with uniquely defined </span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">type tags:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.228.1">
// Example 08
class Point {
  double x_ {};
  double y_ {};
  public:
  struct cartesian_t {} static constexpr cartesian {};
  Point(cartesian_t, double x, double y) : x_(x), y_(y) {}
  struct polar_t {} static constexpr polar {};
  Point(polar_t, double r, double phi) :
    Point(cartesian, r*std::cos(phi), r*std::sin(phi)) {}
};
Point p1(Point::cartesian, 3, 4);
Point p2(Point::polar, 5, 0.927295);</span></pre>
<p><span class="koboSpan" id="kobo.229.1">In this example, we create two unique types, </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">Point::polar_t</span></strong><span class="koboSpan" id="kobo.231.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">Point::cartesian_t</span></strong><span class="koboSpan" id="kobo.233.1">, along with the corresponding variables, and use them as tags to specify what kind of construction we want. </span><span class="koboSpan" id="kobo.233.2">The constructor overloads are no longer ambiguous since each one has a unique first parameter type. </span><span class="koboSpan" id="kobo.233.3">Delegating constructors makes this approach even </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">more attractive.</span></span></p>
<p><span class="koboSpan" id="kobo.235.1">While the use of</span><a id="_idIndexMarker725"/><span class="koboSpan" id="kobo.236.1"> static functions to construct objects of the same type in different ways is sometimes called a factory method, it can also be seen as a variant of the builder pattern (especially when, instead of static methods, we use a separate builder class with similar methods). </span><span class="koboSpan" id="kobo.236.2">In any case, the more modern pattern – using tags – can replace both of these patterns. </span><span class="koboSpan" id="kobo.236.3">Having clarified the terminology, let us return to the original problem of constructing objects of different types based on </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">run-time information.</span></span></p>
<h2 id="_idParaDest-235"><a id="_idTextAnchor614"/><span class="koboSpan" id="kobo.238.1">Arguments for factory methods</span></h2>
<p><span class="koboSpan" id="kobo.239.1">In our simple </span><a id="_idIndexMarker726"/><span class="koboSpan" id="kobo.240.1">example, the constructor took no arguments. </span><span class="koboSpan" id="kobo.240.2">Passing arguments to the constructor presents a bit of a problem if the constructors of different types have different parameters—after all, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">MakeBuilding()</span></strong><span class="koboSpan" id="kobo.242.1"> function has to be declared with some specific parameters. </span><span class="koboSpan" id="kobo.242.2">One option that appears straightforward is to make the factory a variadic template and simply forward the arguments to each constructor. </span><span class="koboSpan" id="kobo.242.3">The straightforward implementation might look </span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.244.1">
// Example 09
template &lt;typename... </span><span class="koboSpan" id="kobo.244.2">Args&gt;
auto Building::MakeBuilding(Type type, Args&amp;&amp;... </span><span class="koboSpan" id="kobo.244.3">args) {
  using result_t = std::unique_ptr&lt;Building&gt;;
  switch (type) {
    case FARM: return
      result_t{new Farm(std::forward&lt;Args&gt;(args)...)};
    case FORGE: return
      result_t{new Forge(std::forward&lt;Args&gt;(args)...)};
    ...
</span><span class="koboSpan" id="kobo.244.4">  }
}</span></pre>
<p><span class="koboSpan" id="kobo.245.1">This code might even</span><a id="_idIndexMarker727"/><span class="koboSpan" id="kobo.246.1"> compile for a while, but, sooner or later, you are going to run into the following error. </span><span class="koboSpan" id="kobo.246.2">Let us give the two classes we build some </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">constructor arguments:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.248.1">
// Example 09
class Farm : public Building {
  public:
  explicit Farm(double size);
};
class Forge : public Building {
  public:
  static constexpr size_t weaponsmith = 0x1;
  static constexpr size_t welder = 0x2;
  static constexpr size_t farrier = 0x4;
  Forge(size_t staff, size_t services);
};
std::unique_ptr&lt;Building&gt; forge =
  Building::MakeBuilding(Building::FORGE, 2,
    Forge::weaponsmith | Forge::welder | Forge::farrier);</span></pre>
<p><span class="koboSpan" id="kobo.249.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">Forge</span></strong><span class="koboSpan" id="kobo.251.1"> class uses a bitmask as flags to mark which services are provided at the forge (a simple and efficient solution to handle a small number of non-exclusive options). </span><span class="koboSpan" id="kobo.251.2">For example, if </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">(services &amp; Forge::farrier)</span></strong><span class="koboSpan" id="kobo.253.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">true</span></strong><span class="koboSpan" id="kobo.255.1">, one of the 2 craftsmen working at the forge can shoe horses. </span><span class="koboSpan" id="kobo.255.2">Simple, elegant, and … </span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">doesn’t compile.</span></span></p>
<p><span class="koboSpan" id="kobo.257.1">The compiler error will mention that there is no matching constructor for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">Farm</span></strong><span class="koboSpan" id="kobo.259.1"> class that could be used to construct a </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">Farm</span></strong><span class="koboSpan" id="kobo.261.1"> from two integers. </span><span class="koboSpan" id="kobo.261.2">But we are not trying to construct a </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">Farm</span></strong><span class="koboSpan" id="kobo.263.1">! </span><span class="koboSpan" id="kobo.263.2">This error gets everybody sooner or later. </span><span class="koboSpan" id="kobo.263.3">The problem is that, at compile-time, it is impossible to be sure that we are not trying to construct a </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">Farm</span></strong><span class="koboSpan" id="kobo.265.1">: that is a run-time decision. </span><span class="koboSpan" id="kobo.265.2">The function </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">MakeBuilding()</span></strong><span class="koboSpan" id="kobo.267.1"> must compile, which means its entire implementation must compile, including the line starting with </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">case FARM</span></strong><span class="koboSpan" id="kobo.269.1">. </span><span class="koboSpan" id="kobo.269.2">Your first thought might be to replace the </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">switch</span></strong><span class="koboSpan" id="kobo.271.1"> statement with </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">if constexpr</span></strong><span class="koboSpan" id="kobo.273.1">, but that’s not going to work because the condition we use to select which class to build is not </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">constexpr</span></strong><span class="koboSpan" id="kobo.275.1">, it’s a run-time value – that’s the whole point of the </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">factory pattern.</span></span></p>
<p><span class="koboSpan" id="kobo.277.1">Trying to </span><a id="_idIndexMarker728"/><span class="koboSpan" id="kobo.278.1">construct a </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">Farm</span></strong><span class="koboSpan" id="kobo.280.1"> with the arguments meant for a </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">Forge</span></strong><span class="koboSpan" id="kobo.282.1"> is an error. </span><span class="koboSpan" id="kobo.282.2">However, it is a run-time error, and it can only be detected at run time. </span><span class="koboSpan" id="kobo.282.3">This still leaves us with the problem of how to make valid the code we never want to run. </span><span class="koboSpan" id="kobo.282.4">The problem is that the Farm doesn’t have a constructor we could use for all the wrong arguments (but hopefully never will). </span><span class="koboSpan" id="kobo.282.5">The easiest workaround is to </span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">provide one:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.284.1">
// Example 09
class Farm : public Building {
  public:
  explicit Farm(...) { abort(); }
  ...
</span><span class="koboSpan" id="kobo.284.2">};</span></pre>
<p><span class="koboSpan" id="kobo.285.1">We have to do the same for all types we may construct with our factory. </span><span class="koboSpan" id="kobo.285.2">The variadic function constructor is an “overload of the last resort” – it is selected only if no other overload matches the arguments. </span><span class="koboSpan" id="kobo.285.3">Since it matches any arguments, the compilation errors will be gone, replaced by run-time errors if something does go wrong in the program. </span><span class="koboSpan" id="kobo.285.4">Why not simply add this constructor to the base class? </span><span class="koboSpan" id="kobo.285.5">We could, but base class constructors are not visible in derived classes without a </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">using</span></strong><span class="koboSpan" id="kobo.287.1"> statement, so we still have to add something to every </span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">derived class.</span></span></p>
<p><span class="koboSpan" id="kobo.289.1">Having to modify every class just so it can be used with the factory creation pattern is definitely a disadvantage, especially since the new constructor could be used anywhere, not just in the factory function (with unfortunate consequences). </span><span class="koboSpan" id="kobo.289.2">As usual, with one more layer of indirection, we could solve this problem as well by introducing an overloaded template for constructing </span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">our objects:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.291.1">
// Example 10
template &lt;typename T, typename... </span><span class="koboSpan" id="kobo.291.2">Args&gt;
auto new_T(Args&amp;&amp;... </span><span class="koboSpan" id="kobo.291.3">args) -&gt;
  decltype(T(std::forward&lt;Args&gt;(args)...))* {
  return new T(std::forward&lt;Args&gt;(args)...);
}
template &lt;typename T&gt;
T* new_T(...) { abort(); return nullptr; }
template &lt;typename... </span><span class="koboSpan" id="kobo.291.4">Args&gt;
auto Building::MakeBuilding(Type type, Args&amp;&amp;... </span><span class="koboSpan" id="kobo.291.5">args) {
  using result_t = std::unique_ptr&lt;Building&gt;;
  switch (type) {
    case FARM: return
      result_t{new_T&lt;Farm&gt;(std::forward&lt;Args&gt;(args)...)};
    case FORGE: return
      result_t{new_T&lt;Forge&gt;(std::forward&lt;Args&gt;(args)...)};
    ...
</span><span class="koboSpan" id="kobo.291.6">  }
}</span></pre>
<p><span class="koboSpan" id="kobo.292.1">The good news is</span><a id="_idIndexMarker729"/><span class="koboSpan" id="kobo.293.1"> that now we do not need to modify any of the classes: any factory call with the correct arguments compiles and is forwarded to the right constructor, while any attempt to create an object with the wrong arguments is a run-time error. </span><span class="koboSpan" id="kobo.293.2">The bad news is that any attempt to create an object with the wrong arguments is a run-time error. </span><span class="koboSpan" id="kobo.293.3">That includes the dead code we never plan to run (such as creating a </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">Farm</span></strong><span class="koboSpan" id="kobo.295.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">Forge</span></strong><span class="koboSpan" id="kobo.297.1">’s arguments), but it also includes any mistakes we could make when calling </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">the factory.</span></span></p>
<p><span class="koboSpan" id="kobo.299.1">If the variadic template solution looks much less attractive once you start implementing it, there is a simpler option: create a parameter object with the hierarchy matching the hierarchy of the objects we create. </span><span class="koboSpan" id="kobo.299.2">Let’s assume that, in our game, the player can select upgrades for each building to be constructed. </span><span class="koboSpan" id="kobo.299.3">The user interface will have to offer building-specific options, of course, and the results of the user selections are stored in a </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">building-specific object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.301.1">
// Example 11
struct BuildingSpec {
  virtual Building::Type type() const = 0;
};
struct FarmSpec : public BuildingSpec {
  Building::Type type() const override {
    return Building::FARM;
  }
  bool with_pasture;
  int number_of_stalls;
};
struct ForgeSpec : public BuildingSpec {
  Building::Type type() const override {
    return Building::FORGE;
  }
  bool magic_forge;
  int number_of_apprentices;
};</span></pre>
<p><span class="koboSpan" id="kobo.302.1">Note that we</span><a id="_idIndexMarker730"/><span class="koboSpan" id="kobo.303.1"> included the type identifier with the argument object, there is no reason to call the factory method with two arguments that must always correctly match each other; it only creates the possibility of an error occurring. </span><span class="koboSpan" id="kobo.303.2">This way, we are guaranteed that the type identifier and the arguments match in every </span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">factory call:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.305.1">
// Example 11
auto Building::MakeBuilding(const BuildingSpec&amp; spec) {
  using result_t = std::unique_ptr&lt;Building&gt;;
  switch (spec.type()) {
    case FARM: return result_t{
      new Farm(static_cast&lt;const FarmSpec&amp;&gt;(spec))};
    case FORGE: return result_t{
      new Forge(static_cast&lt;const ForgeSpec&amp;&gt;(spec))};
    ...
</span><span class="koboSpan" id="kobo.305.2">  }
}</span></pre>
<p><span class="koboSpan" id="kobo.306.1">Note that the </span><a id="_idIndexMarker731"/><span class="koboSpan" id="kobo.307.1">factory pattern often works well with the named arguments pattern we saw in </span><a href="B19262_09.xhtml#_idTextAnchor406"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.308.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.309.1">, </span><em class="italic"><span class="koboSpan" id="kobo.310.1">Named Arguments, Method Chaining, and the Builder Pattern</span></em><span class="koboSpan" id="kobo.311.1"> to avoid having to specify long argument lists. </span><span class="koboSpan" id="kobo.311.2">The spec objects themselves become the options objects we can use to specify </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">named arguments:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.313.1">
// Example 11
class FarmSpec {
  ...
</span><span class="koboSpan" id="kobo.313.2">  bool with_pasture {};
  int number_of_stalls {};
  FarmSpec() = default;
  FarmSpec&amp; SetPasture(bool with_pasture) {
    this-&gt;with_pasture = with_pasture;
    return *this;
  }
  FarmSpec&amp; SetStalls(int number_of_stalls) {
    this-&gt;number_of_stalls = number_of_stalls;
    return *this;
  }
};
struct ForgeSpec : public BuildingSpec {
  ...
</span><span class="koboSpan" id="kobo.313.3">  bool magic_forge {};
  int number_of_apprentices {};
  ForgeSpec() = default;
  ForgeSpec&amp; SetMagic(bool magic_forge) {
    this-&gt;magic_forge = magic_forge;
    return *this;
  }
  ForgeSpec&amp; SetApprentices(int number_of_apprentices) {
    this-&gt;number_of_apprentices = number_of_apprentices;
    return *this;
  }
};
...
</span><span class="koboSpan" id="kobo.313.4">std::unique_ptr&lt;Building&gt; farm =
  Building::MakeBuilding(FarmSpec()
                         .SetPasture(true)
                         .SetStalls(2));
std::unique_ptr&lt;Building&gt; forge =
  Building::MakeBuilding(ForgeSpec()
                         .SetMagic(false)
                         .SetApprentices(4));</span></pre>
<p><span class="koboSpan" id="kobo.314.1">This technique can be </span><a id="_idIndexMarker732"/><span class="koboSpan" id="kobo.315.1">combined with some of the other factory variations that are shown in the following sections so that we can pass arguments when the cons</span><a id="_idTextAnchor615"/><a id="_idTextAnchor616"/><span class="koboSpan" id="kobo.316.1">tructors </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">require them.</span></span></p>
<h2 id="_idParaDest-236"><a id="_idTextAnchor617"/><span class="koboSpan" id="kobo.318.1">Dynamic type registry</span></h2>
<p><span class="koboSpan" id="kobo.319.1">So far, we have </span><a id="_idIndexMarker733"/><span class="koboSpan" id="kobo.320.1">assumed that the complete list of the types is known at compile time and can be encoded in the type identifier correspondence table (implemented with a switch statement, in our example). </span><span class="koboSpan" id="kobo.320.2">The former requirement is unavoidable in the scope of the entire program: since every constructor call is explicit somewhere, the total list of types that can be constructed is known at compile time. </span><span class="koboSpan" id="kobo.320.3">However, our solution is more constrained than that—we have a list of all types that are hard-coded in the factory method. </span><span class="koboSpan" id="kobo.320.4">No additional derived classes can be created without also adding them to the factory. </span><span class="koboSpan" id="kobo.320.5">Sometimes, this restriction is not as bad as it appears—for example, the list of buildings in the game may not change very often, and even when it does, there is a complete list that must be manually updated for the right menu to be generated, the pictures and sounds to appear in the right places, and </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">so on.</span></span></p>
<p><span class="koboSpan" id="kobo.322.1">Nonetheless, one of the advantages of the hierarchical designs is that derived classes can be added later without modifying any of the code written to operate on the hierarchy. </span><span class="koboSpan" id="kobo.322.2">The new virtual function simply plugs into the existing control flow and provides the necessary customized behavior. </span><span class="koboSpan" id="kobo.322.3">We can implement the same idea for the </span><span class="No-Break"><span class="koboSpan" id="kobo.323.1">factory constructor.</span></span></p>
<p><span class="koboSpan" id="kobo.324.1">First of all, each derived class has to be responsible for constructing itself. </span><span class="koboSpan" id="kobo.324.2">This is necessary because, as we have already learned, the explicit call to the constructor has to be written somewhere. </span><span class="koboSpan" id="kobo.324.3">If it’s not in the generic code, it has to be a part of the code that is added when a new derived class is created. </span><span class="koboSpan" id="kobo.324.4">For example, we can have a static </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">factory function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.326.1">
class Forge : public Building {
  public:
  static Building* MakeBuilding() { return new Forge; }
};</span></pre>
<p><span class="koboSpan" id="kobo.327.1">Second, the list of the types has to be extensible at runtime instead of being fixed at compile time. </span><span class="koboSpan" id="kobo.327.2">We could still use an </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">enum</span></strong><span class="koboSpan" id="kobo.329.1">, but then it would have to be updated every time a new derived class is added. </span><span class="koboSpan" id="kobo.329.2">Alternatively, we could assign each derived class an integer identifier at runtime, making sure that the identifiers are unique. </span><span class="koboSpan" id="kobo.329.3">Either way, we need a map of these identifiers to the factory functions, and it cannot be a </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">switch</span></strong><span class="koboSpan" id="kobo.331.1"> statement or anything else that is fixed at compile time. </span><span class="koboSpan" id="kobo.331.2">The map has to be extensible. </span><span class="koboSpan" id="kobo.331.3">We could use </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">std::map</span></strong><span class="koboSpan" id="kobo.333.1"> for this, but, if the type identifiers are integers, we can also use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">std::vector</span></strong><span class="koboSpan" id="kobo.335.1"> of function pointers indexed by the </span><span class="No-Break"><span class="koboSpan" id="kobo.336.1">type identifier:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.337.1">
class Building;
using BuildingFactory = Building*(*)();
std::vector&lt;BuildingFactory&gt; building_registry;</span></pre>
<p><span class="koboSpan" id="kobo.338.1">Now, to register a new type, we just need to generate a new identifier and add the corresponding factory function to </span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">the vector:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.340.1">
size_t building_type_count = 0;
void RegisterBuilding(BuildingFactory factory) {
  building_registry.push_back(factory));
  ++building_type_count;
}</span></pre>
<p><span class="koboSpan" id="kobo.341.1">This </span><a id="_idIndexMarker734"/><span class="koboSpan" id="kobo.342.1">registration machinery can be encapsulated in the base </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">class itself:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.344.1">
// Example 12
class Building {
  static size_t building_type_count;
  using BuildingFactory = Building* (*)();
  static std::vector&lt;BuildingFactory&gt; registry;
  public:
  static size_t (BuildingFactory factory) {
    registry.push_back(factory);
    return building_type_count++;
  }
  static auto MakeBuilding(size_t building_type) {
    BuildingFactory RegisterBuilding factory =
        registry[building_type];
    return std::unique_ptr&lt;Building&gt;(factory());
  }
};
std::vector&lt;Building::BuildingFactory&gt; Building::registry;
size_t Building::building_type_count = 0;</span></pre>
<p><span class="koboSpan" id="kobo.345.1">This base</span><a id="_idIndexMarker735"/><span class="koboSpan" id="kobo.346.1"> class has the factory function table and the count of registered derived types as static data members. </span><span class="koboSpan" id="kobo.346.2">It also has two static functions: one to register new types and one to construct an object of one of the types registered with the class. </span><span class="koboSpan" id="kobo.346.3">Note that the registration function returns the type identifier it has associated with the factory function. </span><span class="koboSpan" id="kobo.346.4">We are going to use </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">this momentarily.</span></span></p>
<p><span class="koboSpan" id="kobo.348.1">Now, we just need to add every new building type to the registry. </span><span class="koboSpan" id="kobo.348.2">This is done in two steps—first, we need to add a registration method to every building class, </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.350.1">
class Forge : public Building {
  public:
  static void Register() {
    RegisterBuilding(Forge::MakeBuilding);
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.351.1">Second, we need to arrange for all </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">Register()</span></strong><span class="koboSpan" id="kobo.353.1"> methods to be called before the game begins and make sure we know the right identifier for every building type. </span><span class="koboSpan" id="kobo.353.2">This is where the value returned by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">RegisterBuilding()</span></strong><span class="koboSpan" id="kobo.355.1"> function becomes important because we are going to store it as the type identifier inside the </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">class itself:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.357.1">
// Example 12
class Forge : public Building {
  public:
  static void Register() {
    RegisterBuilding(Forge::MakeBuilding);
  }
  static const size_t type_tag;
};
const size_t Forge::type_tag =
  RegisterBuilding(Forge::MakeBuilding);</span></pre>
<p><span class="koboSpan" id="kobo.358.1">The registration happens during the initialization of the static variables, sometime before </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">main()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.360.1">is started.</span></span></p>
<p><span class="koboSpan" id="kobo.361.1">The factory</span><a id="_idIndexMarker736"/><span class="koboSpan" id="kobo.362.1"> functions do not have to be static member functions: anything that can be invoked via a function pointer will work. </span><span class="koboSpan" id="kobo.362.2">For example, we could use a lambda </span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">without captures:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.364.1">
// Example 12
class Farm : public Building {
  public:
  static const size_t type_tag;
};
const size_t Farm::type_tag =
  RegisterBuilding([]()-&gt;Building* { return new Farm; });</span></pre>
<p><span class="koboSpan" id="kobo.365.1">We have to explicitly specify the return type because the function pointer type is defined as a function with no argument that returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">Building*</span></strong><span class="koboSpan" id="kobo.367.1">, while the lambda is deduced as a function returning </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">Farm*</span></strong><span class="koboSpan" id="kobo.369.1"> unless we cast the return value or specify the </span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">return type.</span></span></p>
<p><span class="koboSpan" id="kobo.371.1">Now, a call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">Building::MakeBuilding(tag)</span></strong><span class="koboSpan" id="kobo.373.1"> will construct an object of the type that’s registered with the identifier </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">tag</span></strong><span class="koboSpan" id="kobo.375.1">. </span><span class="koboSpan" id="kobo.375.2">The value of the tag – the type identifier – is stored as a static member in every class, so we don’t have to know what it is and can’t make </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">a mistake:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.377.1">
std::unique_ptr&lt;Building&gt; farm =
  Building::MakeBuilding(Farm::type_tag);
std::unique_ptr&lt;Building&gt; forge =
  Building::MakeBuilding(Forge::type_tag);</span></pre>
<p><span class="koboSpan" id="kobo.378.1">In our solution, the correspondence between the identifier values and the types is not known until runtime—we cannot say what building has the ID of 5 until we run the program. </span><span class="koboSpan" id="kobo.378.2">Usually, we do not need to know that since the right value is automatically stored in </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">each class.</span></span></p>
<p><span class="koboSpan" id="kobo.380.1">Note that</span><a id="_idIndexMarker737"/><span class="koboSpan" id="kobo.381.1"> this implementation is very similar to the code that the compilers generate for true virtual functions—virtual function calls are done through function pointers that are stored in tables and accessed by means of a unique identifier (the virtual pointer). </span><span class="koboSpan" id="kobo.381.2">The main difference is that the unique identifier is the static data member associated with each type. </span><span class="koboSpan" id="kobo.381.3">Nonetheless, this is as close to a </span><em class="italic"><span class="koboSpan" id="kobo.382.1">virtual constructor</span></em><span class="koboSpan" id="kobo.383.1"> as you </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">can get.</span></span></p>
<p><span class="koboSpan" id="kobo.385.1">There are many variants of this dynamic type registry pattern. </span><span class="koboSpan" id="kobo.385.2">In some cases, it is preferable to explicitly specify the type identifiers instead of generating them at the program startup time. </span><span class="koboSpan" id="kobo.385.3">In particular, readable names such as “farm” and “forge” can be useful. </span><span class="koboSpan" id="kobo.385.4">In this case, instead of a vector, we can store the factory function pointers in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">std::map</span></strong><span class="koboSpan" id="kobo.387.1"> container indexed by strings (</span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">std::map&lt;std::string, BuildingFactory&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.390.1">Another modification is to allow more general callable objects as factory functions. </span><span class="koboSpan" id="kobo.390.2">We can generalize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">BuildingFactory</span></strong><span class="koboSpan" id="kobo.392.1"> type by using </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">std::function</span></strong><span class="koboSpan" id="kobo.394.1"> instead of the </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">function pointer:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.396.1">
using BuildingFactory = std::function&lt;Building*()&gt;;</span></pre>
<p><span class="koboSpan" id="kobo.397.1">We can still register and use static factory methods as factories for our derived classes, but we can also use lambdas and </span><span class="No-Break"><span class="koboSpan" id="kobo.398.1">custom functors:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.399.1">
// Example 13
class Forge : public Building {
  public:
  static const size_t type_tag;
};
class ForgeFactory {
  public:
  Building* operator()() const { return new Forge; }
};
const size_t Forge::type_tag =
  RegisterBuilding(ForgeFactory{});</span></pre>
<p><span class="koboSpan" id="kobo.400.1">The </span><a id="_idIndexMarker738"/><span class="koboSpan" id="kobo.401.1">implementation of these dynamic factories, whether it is done with a function pointer or a more general std::function, strongly resembles the type erasure pattern we have explored in </span><a href="B19262_06.xhtml#_idTextAnchor266"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.402.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.403.1">, </span><em class="italic"><span class="koboSpan" id="kobo.404.1">Understanding Type Erasure</span></em><span class="koboSpan" id="kobo.405.1">. </span><span class="koboSpan" id="kobo.405.2">The concrete type of object to construct is embedded in the code of the function or functor whose declaration makes no mention of these types. </span><span class="koboSpan" id="kobo.405.3">This allows us to store these functions in a single function table or map. </span><span class="koboSpan" id="kobo.405.4">Other implementations of type erasure from </span><a href="B19262_06.xhtml#_idTextAnchor266"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.406.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.407.1">, </span><em class="italic"><span class="koboSpan" id="kobo.408.1">Understanding Type Erasure</span></em><span class="koboSpan" id="kobo.409.1">, can be used </span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">as well.</span></span></p>
<p><span class="koboSpan" id="kobo.411.1">For simplicity, we did not use any arguments for our factory methods. </span><span class="koboSpan" id="kobo.411.2">We did, however, explore the options for passing arguments in the previous section. </span><span class="koboSpan" id="kobo.411.3">The variadic templates do not work well with function pointers (we have to declare the signature of the factory function upfront), so the most likely pattern for passing arguments is going to be the parameter </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">spec object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.413.1">
// Example 14
struct BuildingSpec {};
class Building {
  ...
</span><span class="koboSpan" id="kobo.413.2">  using BuildingFactory =
    Building* (*)(const BuildingSpec&amp;);
  static auto MakeBuilding(size_t building_type,
                           const BuildingSpec&amp; spec) {
    BuildingFactory factory = registry[building_type];
    return std::unique_ptr&lt;Building&gt;(factory(spec));
  }
};
struct FarmSpec : public BuildingSpec {
  bool with_pasture {};
  int number_of_stalls {};
  FarmSpec() = default;
  FarmSpec&amp; SetPasture(bool with_pasture) {
    this-&gt;with_pasture = with_pasture;
    return *this;
  }
  FarmSpec&amp; SetStalls(int number_of_stalls) {
    this-&gt;number_of_stalls = number_of_stalls;
    return *this;
  }
};
class Farm : public Building {
  public:
  explicit Farm(const FarmSpec&amp; spec);
  ...
</span><span class="koboSpan" id="kobo.413.3">};
const size_t Farm::type_tag = RegisterBuilding(
  [](const BuildingSpec&amp; spec)-&gt;Building* {
    return new Farm(static_cast&lt;const FarmSpec&amp;&gt;(spec));
  });
struct ForgeSpec : public BuildingSpec { ... </span><span class="koboSpan" id="kobo.413.4">};
class Forge : public Building { ... </span><span class="koboSpan" id="kobo.413.5">};
std::unique_ptr&lt;Building&gt; farm =
  Building::MakeBuilding(FarmSpec()
                         .SetPasture(true)
                         .SetStalls(2));
std::unique_ptr&lt;Building&gt; forge =
  Building::MakeBuilding(ForgeSpec()
                         .SetMagic(false)
                         .SetApprentices(4));</span></pre>
<p><span class="koboSpan" id="kobo.414.1">In all of our </span><a id="_idIndexMarker739"/><span class="koboSpan" id="kobo.415.1">factory constructors so far, the decision about which object to construct was driven by the external input to the program, and the construction was done by the same factory method (possibly using delegation to the derived classes). </span><span class="koboSpan" id="kobo.415.2">We will now see a different variant of the factory, which is used to address </span><a id="_idTextAnchor618"/><span class="koboSpan" id="kobo.416.1">a</span><a id="_idTextAnchor619"/><span class="koboSpan" id="kobo.417.1"> slightly </span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">different scenario.</span></span></p>
<h2 id="_idParaDest-237"><a id="_idTextAnchor620"/><span class="koboSpan" id="kobo.419.1">Polymorphic factory</span></h2>
<p><span class="koboSpan" id="kobo.420.1">Consider a </span><a id="_idIndexMarker740"/><span class="koboSpan" id="kobo.421.1">slightly different problem—imagine that, in our game, each building produces a unit of some kind, and the type of the unit is uniquely associated with the type of the building. </span><span class="koboSpan" id="kobo.421.2">The Castle recruits knights, the Wizard Tower trains mages, and the Spider Mound produces giant spiders. </span><span class="koboSpan" id="kobo.421.3">Now, our generic code not only constructs a building of the type that is selected at runtime but also creates new units whose types are also not known at compile time. </span><span class="koboSpan" id="kobo.421.4">We already have the building factory. </span><span class="koboSpan" id="kobo.421.5">We could implement the Unit factory in a similar way, where every building has a unique unit identifier associated with it. </span><span class="koboSpan" id="kobo.421.6">But this design exposes the correspondence between the units and the buildings to the rest of the program, and that is really not necessary—each building knows how to build the </span><em class="italic"><span class="koboSpan" id="kobo.422.1">right</span></em><span class="koboSpan" id="kobo.423.1"> unit; there is no reason for the rest of the program to know </span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">it too.</span></span></p>
<p><span class="koboSpan" id="kobo.425.1">This design challenge calls for a slightly different factory—the factory method determines that a unit is created, but exactly which unit is decided by the building. </span><span class="koboSpan" id="kobo.425.2">This is the Template pattern in action, combined with the Factory pattern—the overall design is the Factory, but </span><a id="_idIndexMarker741"/><span class="koboSpan" id="kobo.426.1">the unit type is customized by the </span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">derived classes:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.428.1">
// Example 15
class Unit {};
class Knight : public Unit { ... </span><span class="koboSpan" id="kobo.428.2">};
class Mage : public Unit { ... </span><span class="koboSpan" id="kobo.428.3">};
class Spider : public Unit { ... </span><span class="koboSpan" id="kobo.428.4">};
class Building {
  public:
  virtual Unit* MakeUnit() const = 0;
};
class Castle : public Building {
  public:
  Knight* MakeUnit() const { return new Knight; }
};
class Tower : public Building {
  public:
  Mage* MakeUnit() const { return new Mage; }
};
class Mound : public Building {
  public:
  Spider* MakeUnit() const { return new Spider; }
};</span></pre>
<p><span class="koboSpan" id="kobo.429.1">Each building has a factory for creating the corresponding unit, and we can access these factory methods through the base </span><span class="No-Break"><span class="koboSpan" id="kobo.430.1">class </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">Building</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.433.1">
std::vector&lt;std::unique_ptr&lt;Building&gt;&gt; buildings;
std::vector&lt;std::unique_ptr&lt;Unit&gt;&gt; units;
for (const auto&amp; b : buildings) {
  units.emplace_back(b-&gt;MakeUnit());
}</span></pre>
<p><span class="koboSpan" id="kobo.434.1">The factory that uses polymorphism and is accessed via a virtual function in the base class – usually a pure virtual function – is known as the Abstract </span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">Factory pattern.</span></span></p>
<p><span class="koboSpan" id="kobo.436.1">The factory methods for the buildings themselves are not shown in this example—the Unit factory can coexist with any of the building factory implementations we have learned (the source code example that accompanies this chapter uses the building factory from Example 12). </span><span class="koboSpan" id="kobo.436.2">The generic code that constructs units from buildings is written once and does not need to change when new derived classes for buildings and units </span><span class="No-Break"><span class="koboSpan" id="kobo.437.1">are added.</span></span></p>
<p><span class="koboSpan" id="kobo.438.1">Note that the return types of all </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">MakeUnit()</span></strong><span class="koboSpan" id="kobo.440.1"> functions are different. </span><span class="koboSpan" id="kobo.440.2">Nonetheless, they are all overrides of the same virtual </span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">Building::MakeUnit()</span></strong><span class="koboSpan" id="kobo.442.1"> function. </span><span class="koboSpan" id="kobo.442.2">These are known as the </span><em class="italic"><span class="koboSpan" id="kobo.443.1">covariant return types</span></em><span class="koboSpan" id="kobo.444.1">—the return type of the override method may be a derived class of the return type of the overridden method. </span><span class="koboSpan" id="kobo.444.2">In our case, return types match the class types, but in general, this is not required. </span><span class="koboSpan" id="kobo.444.3">Any base and derived classes can be used as covariant types, even if they come from a different hierarchy. </span><span class="koboSpan" id="kobo.444.4">However, only such types can be covariant, and, other than that exception, the return type of the override must match the base class </span><span class="No-Break"><span class="koboSpan" id="kobo.445.1">virtual function.</span></span></p>
<p><span class="koboSpan" id="kobo.446.1">The strict</span><a id="_idIndexMarker742"/><span class="koboSpan" id="kobo.447.1"> rules for covariant return types present some problems when we try and make factories return anything other than a raw pointer. </span><span class="koboSpan" id="kobo.447.2">For example, let’s assume that we want to return </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">std::unique_ptr</span></strong><span class="koboSpan" id="kobo.449.1"> instead of the raw pointer. </span><span class="koboSpan" id="kobo.449.2">But, unlike </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">Unit*</span></strong><span class="koboSpan" id="kobo.451.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">Knight*</span></strong><span class="koboSpan" id="kobo.453.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">std::unique_ptr&lt;Unit&gt;</span></strong><span class="koboSpan" id="kobo.455.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">std::unique_ptr&lt;Knight&gt;</span></strong><span class="koboSpan" id="kobo.457.1"> are not covariant types and cannot be used as return types for a virtual method and </span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">its override.</span></span></p>
<p><span class="koboSpan" id="kobo.459.1">We will consider solutions for this, and several other C++-specific problems related to fact</span><a id="_idTextAnchor621"/><span class="koboSpan" id="kobo.460.1">o</span><a id="_idTextAnchor622"/><span class="koboSpan" id="kobo.461.1">ry methods, in the </span><span class="No-Break"><span class="koboSpan" id="kobo.462.1">next section.</span></span></p>
<h1 id="_idParaDest-238"><a id="_idTextAnchor623"/><span class="koboSpan" id="kobo.463.1">Factory-like patterns in C++</span></h1>
<p><span class="koboSpan" id="kobo.464.1">There are many variations of the</span><a id="_idIndexMarker743"/><span class="koboSpan" id="kobo.465.1"> basic Factory patterns used in C++ to address specific design needs and constraints. </span><span class="koboSpan" id="kobo.465.2">In this section, we will consider several of them. </span><span class="koboSpan" id="kobo.465.3">This is by no means an exclusive list of factory-like patterns in C++, but understanding these variants should prepare the reader for combining the techniques that they have learned from this book to address various design chall</span><a id="_idTextAnchor624"/><span class="koboSpan" id="kobo.466.1">e</span><a id="_idTextAnchor625"/><span class="koboSpan" id="kobo.467.1">nges related to </span><span class="No-Break"><span class="koboSpan" id="kobo.468.1">object factories.</span></span></p>
<h2 id="_idParaDest-239"><a id="_idTextAnchor626"/><span class="koboSpan" id="kobo.469.1">Polymorphic copy</span></h2>
<p><span class="koboSpan" id="kobo.470.1">So far, we have considered </span><a id="_idIndexMarker744"/><span class="koboSpan" id="kobo.471.1">factory alternatives to the object constructor—either the default constructor or one of the constructors with arguments. </span><span class="koboSpan" id="kobo.471.2">However, a similar pattern can be applied to the copy constructor—we have an object, and we want to make </span><span class="No-Break"><span class="koboSpan" id="kobo.472.1">a copy.</span></span></p>
<p><span class="koboSpan" id="kobo.473.1">This is a similar problem in many ways—we have an object that’s accessed through the base class pointer, and we want to call its copy constructor. </span><span class="koboSpan" id="kobo.473.2">For the reasons we discussed earlier, not the least of which is that the compiler needs to know how much memory to allocate, the actual constructor call has to be done on the statically determined type. </span><span class="koboSpan" id="kobo.473.3">However, the control flow that gets us to a particular constructor call can be determined at runtime, and that, again, calls for an application of the </span><span class="No-Break"><span class="koboSpan" id="kobo.474.1">Factory pattern.</span></span></p>
<p><span class="koboSpan" id="kobo.475.1">The factory</span><a id="_idIndexMarker745"/><span class="koboSpan" id="kobo.476.1"> method we will use to implement a polymorphic copy is somewhat similar to the Unit factory example from the previous section—the actual construction has to be done by each derived class, and the derived class knows what type of object to construct. </span><span class="koboSpan" id="kobo.476.2">The base class implements the control flow that dictates that someone’s copy will be constructed, and the derived class customizes the </span><span class="No-Break"><span class="koboSpan" id="kobo.477.1">construction part:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.478.1">
// Example 16
class Base {
  public:
  virtual Base* clone() const = 0;
};
class Derived : public Base {
  public:
  Derived* clone() const override {
    return new Derived(*this);
  }
};
Base* b0 = ... </span><span class="koboSpan" id="kobo.478.2">get an object somewhere ...
</span><span class="koboSpan" id="kobo.478.3">Base* b1 = b-&gt;clone();</span></pre>
<p><span class="koboSpan" id="kobo.479.1">We can use the typeid operator (possibly with the demangling function we used earlier in this chapter) to verify that the pointer </span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">b1</span></strong><span class="koboSpan" id="kobo.481.1"> does indeed point to a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">Derived</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.483.1"> object.</span></span></p>
<p><span class="koboSpan" id="kobo.484.1">We have just implemented polymorphic copying using inheritance. </span><span class="koboSpan" id="kobo.484.2">Earlier, in </span><a href="B19262_06.xhtml#_idTextAnchor266"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.485.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.486.1">, </span><em class="italic"><span class="koboSpan" id="kobo.487.1">Understanding Type Erasure</span></em><span class="koboSpan" id="kobo.488.1">, we have seen another way to copy objects whose type was known at construction time but later lost (or erased). </span><span class="koboSpan" id="kobo.488.2">The two approaches are not fundamentally different: when implementing type-erased copying, we built a virtual table ourselves. </span><span class="koboSpan" id="kobo.488.3">In this chapter, we had the compiler do it for us. </span><span class="koboSpan" id="kobo.488.4">The preferred implementation in any particular case will depend mostly on what else is going on in the code </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">around it.</span></span></p>
<p><span class="koboSpan" id="kobo.490.1">Note that, once </span><a id="_idIndexMarker746"/><span class="koboSpan" id="kobo.491.1">again, we are using covariant return types, and, therefore, are limited to the raw pointers. </span><span class="koboSpan" id="kobo.491.2">Let’s say that we want to return unique pointers instead. </span><span class="koboSpan" id="kobo.491.3">Since only the raw pointers to the base and derived types are considered covariant, we have to always return the unique pointer to the </span><span class="No-Break"><span class="koboSpan" id="kobo.492.1">base class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.493.1">
class Base {
  public:
  virtual std::unique_ptr&lt;Base&gt; clone() const = 0;
};
class Derived : public Base {
  public:
  std::unique_ptr&lt;Base&gt; clone() const override {
    return std::unique_ptr&lt;Base&gt;(new Derived(*this));
  }
};
std::unique_ptr&lt;Base&gt; b(... </span><span class="koboSpan" id="kobo.493.2">make an object ...);
std::unique_ptr&lt;Base&gt; b1 = b-&gt;clone();</span></pre>
<p><span class="koboSpan" id="kobo.494.1">In many </span><a id="_idIndexMarker747"/><span class="koboSpan" id="kobo.495.1">cases, this is not a significant limitation. </span><span class="koboSpan" id="kobo.495.2">Sometimes, however, it can lead to unnecessary conversions and casts. </span><span class="koboSpan" id="kobo.495.3">If returning a smart pointer to the exact type is important, there is another version of th</span><a id="_idTextAnchor627"/><span class="koboSpan" id="kobo.496.1">i</span><a id="_idTextAnchor628"/><span class="koboSpan" id="kobo.497.1">s pattern that we will </span><span class="No-Break"><span class="koboSpan" id="kobo.498.1">consider next.</span></span></p>
<h2 id="_idParaDest-240"><a id="_idTextAnchor629"/><span class="koboSpan" id="kobo.499.1">CRTP Factory and return types</span></h2>
<p><span class="koboSpan" id="kobo.500.1">The only way we</span><a id="_idIndexMarker748"/><span class="koboSpan" id="kobo.501.1"> could return </span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">std::unique_ptr&lt;Derived&gt;</span></strong><span class="koboSpan" id="kobo.503.1"> from the factory copy constructor of the derived class is to make the </span><a id="_idIndexMarker749"/><span class="koboSpan" id="kobo.504.1">virtual </span><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">clone()</span></strong><span class="koboSpan" id="kobo.506.1"> method of the base class return the same type. </span><span class="koboSpan" id="kobo.506.2">But this is impossible, at least if we have more than one derived class—for each derived class, we would need the return type of </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">Base::clone()</span></strong><span class="koboSpan" id="kobo.508.1"> to be that class. </span><span class="koboSpan" id="kobo.508.2">But there is only one </span><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">Base::clone()</span></strong><span class="koboSpan" id="kobo.510.1">! </span><span class="koboSpan" id="kobo.510.2">Or is there? </span><span class="koboSpan" id="kobo.510.3">Fortunately, in C++, we have an easy way of making many out of one—the templates. </span><span class="koboSpan" id="kobo.510.4">If we template the base class, we could make the base of each derived class return the right type. </span><span class="koboSpan" id="kobo.510.5">But to do this, we need the base class to somehow know the type of the class that will be derived from it. </span><span class="koboSpan" id="kobo.510.6">Of course, there is a pattern for that, too—in C++, it is called the</span><a id="_idIndexMarker750"/><span class="koboSpan" id="kobo.511.1"> Curiously Recurring Template Pattern, which we looked at in </span><a href="B19262_08.xhtml#_idTextAnchor360"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.512.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.513.1">, </span><em class="italic"><span class="koboSpan" id="kobo.514.1">The Curiously Recurring Template Pattern</span></em><span class="koboSpan" id="kobo.515.1">. </span><span class="koboSpan" id="kobo.515.2">Now, we can combine the CRTP and the </span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">Factory patterns:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.517.1">
// Example 18
template &lt;typename Derived&gt; class Base {
  public:
  virtual std::unique_ptr&lt;Derived&gt; clone() const = 0;
};
class Derived : public Base&lt;Derived&gt; {
  public:
  std::unique_ptr&lt;Derived&gt; clone() const override {
    return std::unique_ptr&lt;Derived&gt;(new Derived(*this));
  }
};
std::unique_ptr&lt;Derived&gt; b0(new Derived);
std::unique_ptr&lt;Derived&gt; b1 = b0-&gt;clone();</span></pre>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">auto</span></strong><span class="koboSpan" id="kobo.519.1"> return types make </span><a id="_idIndexMarker751"/><span class="koboSpan" id="kobo.520.1">writing code like this significantly less</span><a id="_idIndexMarker752"/><span class="koboSpan" id="kobo.521.1"> verbose. </span><span class="koboSpan" id="kobo.521.2">In this book, we generally don’t use them to make it clear which function </span><span class="No-Break"><span class="koboSpan" id="kobo.522.1">returns what.</span></span></p>
<p><span class="koboSpan" id="kobo.523.1">The template parameter of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">Base</span></strong><span class="koboSpan" id="kobo.525.1"> class is one of the classes derived from it, hence the naming. </span><span class="koboSpan" id="kobo.525.2">If you wish, you can even enforce this restriction with a </span><span class="No-Break"><span class="koboSpan" id="kobo.526.1">static assert:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.527.1">
template &lt;typename Derived&gt; class Base {
  public:
  virtual std::unique_ptr&lt;Derived&gt; clone() const = 0;
  Base() {
    static_assert(std::is_base_of_v&lt;Base, Derived&gt;;
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.528.1">The reason we had to hide the static assert in the class constructor is that within the declaration of the class itself, the type </span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">Derived</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.530.1">is incomplete.</span></span></p>
<p><span class="koboSpan" id="kobo.531.1">Note that, since the </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">Base</span></strong><span class="koboSpan" id="kobo.533.1"> class now knows the type of the derived class, we don’t even need the </span><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">clone()</span></strong><span class="koboSpan" id="kobo.535.1"> method to </span><span class="No-Break"><span class="koboSpan" id="kobo.536.1">be virtual:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.537.1">
// Example 19
template &lt;typename Derived&gt; class Base {
  public:
  std::unique_ptr&lt;Derived&gt; clone() const {
    return std::unique_ptr&lt;Derived&gt;(
      new Derived(*static_cast&lt;const Derived*&gt;(this)));
  }
};
class Derived : public Base&lt;Derived&gt; { ... </span><span class="koboSpan" id="kobo.537.2">};</span></pre>
<p><span class="koboSpan" id="kobo.538.1">There are</span><a id="_idIndexMarker753"/><span class="koboSpan" id="kobo.539.1"> significant downsides to this method, at</span><a id="_idIndexMarker754"/><span class="koboSpan" id="kobo.540.1"> least regarding the way we have implemented it so far. </span><span class="koboSpan" id="kobo.540.2">First of all, we had to make the base class a template, which means that we no longer have a common pointer type to use in our general code (or we have to make an even wider use of templates). </span><span class="koboSpan" id="kobo.540.3">Second, this approach only works if no more classes are derived from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">Derived</span></strong><span class="koboSpan" id="kobo.542.1"> class, because the type of the base class does not track the second derivation—only the one that instantiated the </span><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">Base</span></strong><span class="koboSpan" id="kobo.544.1"> template. </span><span class="koboSpan" id="kobo.544.2">Overall, except for the specific cases where it is very important to return the exact type instead of the base type, this approach cannot </span><span class="No-Break"><span class="koboSpan" id="kobo.545.1">be recommended.</span></span></p>
<p><span class="koboSpan" id="kobo.546.1">On the other </span><a id="_idIndexMarker755"/><span class="koboSpan" id="kobo.547.1">hand, there are some attractive features </span><a id="_idIndexMarker756"/><span class="koboSpan" id="kobo.548.1">of this implementation that we may want to preserve. </span><span class="koboSpan" id="kobo.548.2">Specifically, we got rid of the multiple copies of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.549.1">clone()</span></strong><span class="koboSpan" id="kobo.550.1"> function, one per each derived class, and got a template to generate them for us automatically. </span><span class="koboSpan" id="kobo.550.2">In the next section, we will show you how to retain that useful feature of the CRTP implementation, even if we have to give up on extending the notion of </span><em class="italic"><span class="koboSpan" id="kobo.551.1">covariant return types</span></em><span class="koboSpan" id="kobo.552.1"> to c</span><a id="_idTextAnchor630"/><span class="koboSpan" id="kobo.553.1">o</span><a id="_idTextAnchor631"/><span class="koboSpan" id="kobo.554.1">ver smart pointers by playing </span><span class="No-Break"><span class="koboSpan" id="kobo.555.1">template tricks.</span></span></p>
<h2 id="_idParaDest-241"><a id="_idTextAnchor632"/><span class="koboSpan" id="kobo.556.1">CRTP for Factory implementation</span></h2>
<p><span class="koboSpan" id="kobo.557.1">We have mentioned </span><a id="_idIndexMarker757"/><span class="koboSpan" id="kobo.558.1">several times by now that, while CRTP is sometimes used as a design instrument, it is just as likely to be used as an implementation technique. </span><span class="koboSpan" id="kobo.558.2">We will now focus on using CRTP to avoid writing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">clone()</span></strong><span class="koboSpan" id="kobo.560.1"> function in every derived class. </span><span class="koboSpan" id="kobo.560.2">This is not just done to reduce typing—the more code is written—especially very similar code that gets copied and modified—the more likely you are to make an error. </span><span class="koboSpan" id="kobo.560.3">We have already seen how to use CRTP to generate a version of </span><strong class="source-inline"><span class="koboSpan" id="kobo.561.1">clone()</span></strong><span class="koboSpan" id="kobo.562.1"> for every derived class automatically. </span><span class="koboSpan" id="kobo.562.2">We just don’t want to give up the common (non-template) base class to do so. </span><span class="koboSpan" id="kobo.562.3">We don’t really have to do so if we delegate the cloning to the special base class that handles </span><span class="No-Break"><span class="koboSpan" id="kobo.563.1">only that:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.564.1">
// Example 20
class Base {
  public:
  virtual Base* clone() const = 0;
};
template &lt;typename Derived&gt; class Cloner : public Base {
  public:
  Base* clone() const {
    return new Derived(*static_cast&lt;const Derived*&gt;(this));
  }
};
class Derived : public Cloner&lt;Derived&gt; {
  ...
</span><span class="koboSpan" id="kobo.564.2">};
Base* b0(new Derived);
Base* b1 = b0-&gt;clone();</span></pre>
<p><span class="koboSpan" id="kobo.565.1">Here, for simplicity, we went back to returning raw pointers, although we could also return </span><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">std::unique_ptr&lt;Base&gt;</span></strong><span class="koboSpan" id="kobo.567.1">. </span><span class="koboSpan" id="kobo.567.2">What we cannot do is return </span><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">Derived*</span></strong><span class="koboSpan" id="kobo.569.1"> since, at the time when the template for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.570.1">Cloner</span></strong><span class="koboSpan" id="kobo.571.1"> is parsed, it is not known that </span><strong class="source-inline"><span class="koboSpan" id="kobo.572.1">Derived</span></strong><span class="koboSpan" id="kobo.573.1"> is always derived </span><span class="No-Break"><span class="koboSpan" id="kobo.574.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">Base</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.576.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.577.1">This design allows us to derive any number of classes from </span><strong class="source-inline"><span class="koboSpan" id="kobo.578.1">Base</span></strong><span class="koboSpan" id="kobo.579.1">, indirectly through </span><strong class="source-inline"><span class="koboSpan" id="kobo.580.1">Cloner</span></strong><span class="koboSpan" id="kobo.581.1">, and not have to write another </span><strong class="source-inline"><span class="koboSpan" id="kobo.582.1">clone()</span></strong><span class="koboSpan" id="kobo.583.1"> function ever again. </span><span class="koboSpan" id="kobo.583.2">It still has the limitation that, if we derive another class from </span><strong class="source-inline"><span class="koboSpan" id="kobo.584.1">Derived</span></strong><span class="koboSpan" id="kobo.585.1">, it will not be copied correctly. </span><span class="koboSpan" id="kobo.585.2">In many designs, this is not an issue—enlightened self-interest should guide you to avoid deep hierarchies and make all classes be one of two kinds: abstract base classes that are never instantiated, and concrete classes that are derived from one of these base </span><a id="_idTextAnchor633"/><span class="koboSpan" id="kobo.586.1">classes, but never from </span><a id="_idIndexMarker758"/><span class="koboSpan" id="kobo.587.1">another </span><span class="No-Break"><span class="koboSpan" id="kobo.588.1">concrete class.</span></span></p>
<h2 id="_idParaDest-242"><a id="_idTextAnchor634"/><span class="koboSpan" id="kobo.589.1">Factory and Builder</span></h2>
<p><span class="koboSpan" id="kobo.590.1">So far, we have been using </span><a id="_idIndexMarker759"/><span class="koboSpan" id="kobo.591.1">mostly factory functions, or, more generally, functors such as lambdas. </span><span class="koboSpan" id="kobo.591.2">In practice, it is just as likely that we will need a factory class. </span><span class="koboSpan" id="kobo.591.3">This usually happens because the run-time information needed to construct an object is more complex than just the type identifier and a few arguments. </span><span class="koboSpan" id="kobo.591.4">These are the same reasons we may choose to use the Builder pattern to create objects, so a factory class can also be viewed as a builder class with a factory method used to create the concrete objects. </span><span class="koboSpan" id="kobo.591.5">The Unit factory we have seen earlier in this chapter is an example of such a pattern: the Building class and all of its derived classes act like a builder for the unit objects (and the fact that the building objects themselves are created by another factory only serves as yet another demonstration that even a simple piece of code can rarely be reduced to a single pattern). </span><span class="koboSpan" id="kobo.591.6">In that case, however, we had a special motive for using the factory class: each derived building class constructs its own </span><span class="No-Break"><span class="koboSpan" id="kobo.592.1">unit objects.</span></span></p>
<p><span class="koboSpan" id="kobo.593.1">Let us now consider a more common case for using a factory class: the overall complexity of the run-time data that goes into deciding which class to construct and how, as well as the non-trivial amount of code we need to do so. </span><span class="koboSpan" id="kobo.593.2">While it is possible to handle it all with a factory function and some global objects, it would be a poor design, lacking in cohesion and encapsulation. </span><span class="koboSpan" id="kobo.593.3">It is going to be error-prone and difficult to maintain. </span><span class="koboSpan" id="kobo.593.4">It is much better to encapsulate all related code and data into one class or a small number of </span><span class="No-Break"><span class="koboSpan" id="kobo.594.1">related classes.</span></span></p>
<p><span class="koboSpan" id="kobo.595.1">For this </span><a id="_idIndexMarker760"/><span class="koboSpan" id="kobo.596.1">example, we are going to tackle the very common (and still very challenging) serialization/deserialization problem. </span><span class="koboSpan" id="kobo.596.2">In our case, we have a number of objects derived from the same base class. </span><span class="koboSpan" id="kobo.596.3">We want to implement the framework necessary to serialize them by writing them into a file and then restoring the objects from this file. </span><span class="koboSpan" id="kobo.596.4">In this final example of the chapter, we are going to combine several methods we have learned to design and implement </span><span class="No-Break"><span class="koboSpan" id="kobo.597.1">the factory.</span></span></p>
<p><span class="koboSpan" id="kobo.598.1">We are going to start with the base class. </span><span class="koboSpan" id="kobo.598.2">The base class is going to utilize the dynamic type registry we learned earlier. </span><span class="koboSpan" id="kobo.598.3">Also, it is going to declare a pure virtual </span><strong class="source-inline"><span class="koboSpan" id="kobo.599.1">Serialize()</span></strong><span class="koboSpan" id="kobo.600.1"> function that every derived class needs to implement to serialize itself into </span><span class="No-Break"><span class="koboSpan" id="kobo.601.1">a file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.602.1">
// Example 21
class SerializerBase {
  static size_t type_count;
  using Factory = SerializerBase* (*)(std::istream&amp; s);
  static std::vector&lt;Factory&gt; registry;
  protected:
  virtual void Serialize(std::ostream&amp; s) const = 0;
  public:
  virtual ~SerializerBase() {}
  static size_t RegisterType(Factory factory) {
    registry.push_back(factory);
    return type_count++;
  }
  static auto Deserialize(size_t type, std::istream&amp; s) {
    Factory factory = registry[type];
    return std::unique_ptr&lt;SerializerBase&gt;(factory(s));
  }
};
std::vector&lt;SerializerBase::Factory&gt;
  SerializerBase::registry;
size_t SerializerBase::type_count = 0;</span></pre>
<p><span class="koboSpan" id="kobo.603.1">Any derived</span><a id="_idIndexMarker761"/><span class="koboSpan" id="kobo.604.1"> class needs to implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">Serialize()</span></strong><span class="koboSpan" id="kobo.606.1"> function as well as register the </span><span class="No-Break"><span class="koboSpan" id="kobo.607.1">deserialization function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.608.1">
// Example 21
class Derived1 : public SerializerBase {
  int i_;
  public:
  Derived1(int i) : i_(i) {...}
  void Serialize(std::ostream&amp; s) const override {
    s &lt;&lt; type_tag &lt;&lt; " " &lt;&lt; i_ &lt;&lt; std::endl;
  }
  static const size_t type_tag;
};
const size_t Derived1::type_tag =
  RegisterType([](std::istream&amp; s)-&gt;SerializerBase* {
    int i; s &gt;&gt; i; return new Derived1(i); });</span></pre>
<p><span class="koboSpan" id="kobo.609.1">Only the derived class itself has the information about its state, what must be saved in order to</span><a id="_idIndexMarker762"/><span class="koboSpan" id="kobo.610.1"> reconstitute the object, and how to do so. </span><span class="koboSpan" id="kobo.610.2">In our example, the serialization is always done in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">Serialize()</span></strong><span class="koboSpan" id="kobo.612.1"> function, while the deserialization is done in the lambda we register with the type registry. </span><span class="koboSpan" id="kobo.612.2">Needless to say, the two must be consistent with each other. </span><span class="koboSpan" id="kobo.612.3">There are template-based tricks that can ensure this consistency, but they aren’t relevant to the factory construction we are </span><span class="No-Break"><span class="koboSpan" id="kobo.613.1">studying now.</span></span></p>
<p><span class="koboSpan" id="kobo.614.1">We have the serialization part handled – all we need to do is call Serialize on any object </span><span class="No-Break"><span class="koboSpan" id="kobo.615.1">we have:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.616.1">
std::ostream S ... </span><span class="koboSpan" id="kobo.616.2">– construct the stream as needed
Derived1 d(42);
d.Serialize(S);</span></pre>
<p><span class="koboSpan" id="kobo.617.1">The deserialization itself is not particularly hard (most of the work is done by the derived classes), but there is enough boilerplate code there to justify a factory class. </span><span class="koboSpan" id="kobo.617.2">A factory object will read the entire file and deserialize (re-create) all objects recorded there. </span><span class="koboSpan" id="kobo.617.3">There are, of course, many options for the destination of such objects. </span><span class="koboSpan" id="kobo.617.4">Since we are constructing objects whose types are not known at compile-time, we have to access them through the base class pointers. </span><span class="koboSpan" id="kobo.617.5">For example, we can store them in a container of </span><span class="No-Break"><span class="koboSpan" id="kobo.618.1">unique pointers:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.619.1">
// Example 21
class DeserializerFactory {
  std::istream&amp; s_;
  public:
  explicit DeserializerFactory(std::istream&amp; s) : s_(s) {}
  template &lt;typename It&gt;
  void Deserialize(It iter) {
    while (true) {
      size_t type;
      s_ &gt;&gt; type;
      if (s_.eof()) return;
      iter = SerializerBase::Deserialize(type, s_);
    }
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.620.1">This</span><a id="_idIndexMarker763"/><span class="koboSpan" id="kobo.621.1"> factory reads the entire file, line by line. </span><span class="koboSpan" id="kobo.621.2">First, it reads just the type identifier (which each object must write during serialization). </span><span class="koboSpan" id="kobo.621.3">Based on that identifier, it dispatches the rest of the deserialization process to the correct function registered for the corresponding type. </span><span class="koboSpan" id="kobo.621.4">The factory uses an inserter iterator (such as a back-inserter) to store all deserialized objects in </span><span class="No-Break"><span class="koboSpan" id="kobo.622.1">a container:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.623.1">
// Example 21
std::vector&lt;std::unique_ptr&lt;SerializerBase&gt;&gt; v;
DeserializerFactory F(S);
F.Deserialize(std::back_inserter(v));</span></pre>
<p><span class="koboSpan" id="kobo.624.1">With this approach, we can handle any class derived from SerializerBase, as long as we can come up with a way to write it into a file and restore it. </span><span class="koboSpan" id="kobo.624.2">We can handle a more complex state and constructors with </span><span class="No-Break"><span class="koboSpan" id="kobo.625.1">multiple arguments:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.626.1">
// Example 21
class Derived2 : public SerializerBase {
  double x_, y_;
  public:
  Derived2(double x, double y) : x_(x), y_(y) {...}
  void Serialize(std::ostream&amp; s) const override {
    s &lt;&lt; type_tag &lt;&lt; " " &lt;&lt; x_ &lt;&lt; " " &lt;&lt; y_ &lt;&lt; std::endl;
  }
  static const size_t type_tag;
};
const size_t Derived2::type_tag =
  RegisterType([](std::istream&amp; s)-&gt;SerializerBase* {
    double x, y; s &gt;&gt; x &gt;&gt; y;
    return new Derived2(x, y);
});</span></pre>
<p><span class="koboSpan" id="kobo.627.1">We can</span><a id="_idIndexMarker764"/><span class="koboSpan" id="kobo.628.1"> equally easily deal with classes that have multiple constructors as long as we know how a particular object should be </span><span class="No-Break"><span class="koboSpan" id="kobo.629.1">constructed again:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.630.1">
// Example 21
class Derived3 : public SerializerBase {
  bool integer_;
  int i_ {};
  double x_ {};
  public:
  Derived3(int i) : integer_(true), i_(i) {...}
  Derived3(double x) : integer_(false), x_(x) {...}
  void Serialize(std::ostream&amp; s) const override {
    s &lt;&lt; type_tag &lt;&lt; " " &lt;&lt; integer_ &lt;&lt; " ";
    if (integer_) s &lt;&lt; i_; else s &lt;&lt; x_;
    s &lt;&lt; std::endl;
  }
  static const size_t type_tag;
};
const size_t Derived3::type_tag =
  RegisterType([](std::istream&amp; s)-&gt;SerializerBase* {
    bool integer; s &gt;&gt; integer;
    if (integer) {
      int i; s &gt;&gt; i; return new Derived3(i);
    } else {
      double x; s &gt;&gt; x; return new Derived3(x);
  }
});</span></pre>
<p><span class="koboSpan" id="kobo.631.1">There are </span><a id="_idIndexMarker765"/><span class="koboSpan" id="kobo.632.1">many more variations of the factory pattern in C++. </span><span class="koboSpan" id="kobo.632.2">If you understood the explanations and followed through with the examples in this chapter, none of these alte</span><a id="_idTextAnchor635"/><span class="koboSpan" id="kobo.633.1">rnatives should present a particular challenge </span><span class="No-Break"><span class="koboSpan" id="kobo.634.1">for you.</span></span></p>
<h1 id="_idParaDest-243"><a id="_idTextAnchor636"/><span class="koboSpan" id="kobo.635.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.636.1">In this chapter, we have learned why constructors cannot be made virtual, and what to do when we really want a virtual constructor anyway. </span><span class="koboSpan" id="kobo.636.2">We have learned how to construct and copy objects whose type becomes known at runtime by using the Factory pattern and one of its variations. </span><span class="koboSpan" id="kobo.636.3">We also explored several implementations of the Factory constructor that differ in the way that the code is organized and that the behavior is delegated to different components of the system, and compared their advantages and trade-offs. </span><span class="koboSpan" id="kobo.636.4">We have also seen how multiple design patterns interact with </span><span class="No-Break"><span class="koboSpan" id="kobo.637.1">each other.</span></span></p>
<p><span class="koboSpan" id="kobo.638.1">While in C++, the constructor has to be invoked with the true type of the object to construct—always—this does not mean that the application code has to specify the complete type. </span><span class="koboSpan" id="kobo.638.2">The Factory pattern allows us to write code that specifies the type indirectly, using an identifier that is associated with the type elsewhere (</span><em class="italic"><span class="koboSpan" id="kobo.639.1">create an object of the third kind</span></em><span class="koboSpan" id="kobo.640.1">), or an associated object type (</span><em class="italic"><span class="koboSpan" id="kobo.641.1">create a unit that goes with this building type</span></em><span class="koboSpan" id="kobo.642.1">), or even the same type (</span><em class="italic"><span class="koboSpan" id="kobo.643.1">make me a copy of this, whatever </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.644.1">it is</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.645.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.646.1">The next design pattern we will study in the following chapter is the Template Method pattern, one of the classic object-oriented patterns that, in C++, has addition</span><a id="_idTextAnchor637"/><span class="koboSpan" id="kobo.647.1">a</span><a id="_idTextAnchor638"/><span class="koboSpan" id="kobo.648.1">l implications for the way we design </span><span class="No-Break"><span class="koboSpan" id="kobo.649.1">class hierarchies.</span></span></p>
<h1 id="_idParaDest-244"><a id="_idTextAnchor639"/><span class="koboSpan" id="kobo.650.1">Questions</span></h1>
<ol>
<li><span class="koboSpan" id="kobo.651.1">Why does C++ not allow a </span><span class="No-Break"><span class="koboSpan" id="kobo.652.1">virtual constructor?</span></span></li>
<li><span class="koboSpan" id="kobo.653.1">What is the </span><span class="No-Break"><span class="koboSpan" id="kobo.654.1">Factory pattern?</span></span></li>
<li><span class="koboSpan" id="kobo.655.1">How do you use the Factory pattern to achieve the effect of a </span><span class="No-Break"><span class="koboSpan" id="kobo.656.1">virtual constructor?</span></span></li>
<li><span class="koboSpan" id="kobo.657.1">How do you achieve the effect of a virtual </span><span class="No-Break"><span class="koboSpan" id="kobo.658.1">copy constructor?</span></span></li>
<li><span class="koboSpan" id="kobo.659.1">How do you use the Template and Factory </span><span class="No-Break"><span class="koboSpan" id="kobo.660.1">patterns together?</span></span></li>
<li><span class="koboSpan" id="kobo.661.1">How do you use the Builder and the Factory </span><span class="No-Break"><span class="koboSpan" id="kobo.662.1">patterns together?</span></span></li>
</ol>
</div>
</body></html>