# 第3章。你的第一个游戏 – 桌面冰球

*我们将构建一个桌面冰球游戏，以介绍使用Cocos2d-x构建项目的所有主要方面。这包括设置项目的配置、加载图像、加载声音、为多个屏幕分辨率构建游戏以及管理触摸事件。*

*哦，你还需要叫一个朋友。这是一个双人游戏。继续吧，我在这里等你。*

到本章结束时，你将知道：

+   如何构建仅适用于iPad的游戏

+   如何启用多点触控

+   如何支持视网膜和非视网膜显示屏

+   如何加载图像和声音

+   如何播放音效

+   如何创建精灵

+   如何扩展Cocos2d-x的`Sprite`类

+   如何创建标签并更新它们

不再拖延...让我们开始吧。

# 游戏配置

游戏将具有以下特点：

+   由于是双人游戏，它必须支持多点触控

+   由于是双人游戏，它必须在大型屏幕上玩

+   由于我们想利用这一点，它必须支持视网膜显示屏

+   由于我是在纵向模式下构建的艺术品，它必须仅在纵向模式下播放

所以让我们创建我们的项目！

# 行动时间 – 创建你的游戏项目

我将首先在Xcode中构建游戏，然后展示如何将项目带到Eclipse，但文件夹结构保持不变，所以你可以使用任何你想要的IDE，这里的说明将是相同的：

1.  打开终端，创建一个名为`AirHockey`的新Cocos2d-x项目，使用C++作为其主要语言。我把我的保存在桌面上，所以我要输入的命令看起来像这样：

    [PRE0]

1.  一旦创建项目，导航到其`proj.ios_mac`文件夹，双击`AirHockey.xcodeproj`文件。（对于Eclipse，你可以遵循我们创建`HelloWorld`项目时采取的相同步骤来导入项目。）

1.  在**项目导航器**中选择顶部项目，并确保选择了**iOS**目标，通过导航到**通用** | **部署信息**，设置目标设备为**iPad**，并将**设备方向**设置为**纵向**和**颠倒**。![行动时间 – 创建你的游戏项目](img/00007.jpeg)

1.  保存你的项目更改。

## *刚才发生了什么？*

你创建了一个针对iPad的Cocos2d-x项目，你现在可以设置它，使用我之前描述的其余配置。

所以我们现在就来做。

# 行动时间 – 制定规则

我们将更新`RootViewController.mm`文件。

1.  前往`ios`文件夹中的`RootViewController.mm`，查找`shouldAutorotateToInterfaceOrientation`方法。将方法内的行更改为：

    [PRE1]

1.  在`supportedInterfaceOrientations`方法下方几行，更改条件`to`内的行：

    [PRE2]

## *刚才发生了什么？*

我们刚刚告诉`RootViewController`，我们希望我们的应用程序在任何两种支持的纵向模式中运行。

# 支持视网膜显示屏

现在让我们将图像添加到我们的项目中。

# 行动时间 – 添加图像文件

首先，我们下载这个项目的资源，然后我们在 Xcode 中添加它们。

1.  前往本书的 **支持** 页面 ([www.packtpub.com/support](http://www.packtpub.com/support)) 并下载 `4198_03_RESOURCES.zip` 文件。在里面，您应该找到三个名为 `hd`、`sd` 和 `fonts` 的文件夹。

1.  前往您的 `Project` 文件夹，即您系统中的实际文件夹。将三个文件夹拖到项目中的 `Resources` 文件夹内。

1.  返回 Xcode。在项目导航面板中选择 `Resources` 文件夹。然后转到 **文件** | **将文件添加到 AirHockey**。

1.  在 **文件** 窗口中，导航到 `Resources` 文件夹并选择 `sd`、`hd` 和 `fonts` 文件夹。

1.  这非常重要：确保 **为任何添加的文件夹创建文件夹引用** 已选中。同时确保您已选择 **AirHockey** 作为目标。确保 **复制项目到目标...** 也已选中。

1.  点击 **添加**。

## *发生了什么？*

您已添加了您 Air Hockey 游戏所需的必要图像文件。它们有两种版本：一种是针对视网膜显示屏（高清）的，另一种是针对非视网膜显示屏（标准定义）的。确保只添加到实际文件夹的引用非常重要；这样，Xcode 才能将两个具有相同名称的文件分别放在项目的每个文件夹中；每个文件夹一个。我们还添加了游戏中将使用的字体。

现在，让我们告诉 Cocos2d-x 去哪里查找正确的文件。

# 是时候添加视网膜支持了

这次我们将处理 `AppDelegate.cpp` 类：

1.  前往 `AppDelegate.cpp` (您可以在 `Classes` 文件夹中找到它)。在 `applicationDidFinishLaunching` 方法中，在 `director->setAnimationInterval(1.0 / 60)` 行下面，添加以下行：

    [PRE3]

1.  保存文件。

## *发生了什么？*

可以写一本关于这个主题的整本书，尽管在这个第一个例子中，我们有一个非常简单的实现，说明如何支持多个屏幕尺寸，因为我们只针对 iPad。这里我们说的是：“嘿 `AppDelegate`，我为 768 x 1024 屏幕设计了这款游戏。”

所有用于定位和字体大小的值都是针对该屏幕尺寸选择的。如果屏幕更大，请确保您从 `hd` 文件夹中获取文件，并更改您将乘以所有定位和字体大小的比例。如果屏幕大小与我为游戏设计的相同，请使用 `sd` 文件夹中的文件，并将比例设置为 1。 (Android 为此增加了更多的复杂性，但我们在本书的后面会处理这个问题。)

`FileUtils` 将首先在 `Resources` | `sd` (或 `hd`) 中查找您为游戏加载的每个文件。如果在那里找不到，它将尝试在 `Resources` 中查找它们。这是一件好事，因为两个版本共享的文件可能只添加到项目中的 `Resources` 里面一次。我们现在就会这样做，添加声音文件。

# 添加声音效果

这个游戏有两个声音效果文件。您可以在之前下载的相同 `.zip` 文件中找到它们。

# 行动时间 - 添加声音文件

假设你已经有从下载的资源中获取的声音文件，让我们将它们添加到项目中。

1.  将两个`.wav`文件拖到你的`Project`文件夹内的`Resources`文件夹中。

1.  然后转到Xcode，在文件导航面板中选择`Resources`文件夹，并选择**文件** | **将文件添加到AirHockey**。

1.  确保选择了**AirHockey**目标。

1.  再次转到`AppDelegate.cpp`。在顶部，添加以下`include`语句：

    [PRE4]

1.  然后在`USING_NS_CC`宏（用于`using namespace cocos2d`）下方添加：

    [PRE5]

1.  然后在上一节中添加的行下面，在`applicationDidFinishLaunching`中添加以下行：

    [PRE6]

## *发生了什么？*

通过`CocosDenshion`的`preloadEffect`方法，你成功预加载了文件以及实例化和初始化`SimpleAudioEngine`。这一步总是会消耗你的应用程序的处理能力，因此最好尽早完成。

到现在为止，你的游戏文件夹结构应该看起来像这样：

![发生了什么？](img/00008.jpeg)

# 扩展Sprite

不，`Sprite`没有问题。我只是选择了一个需要从其一些精灵中获取更多信息的游戏。在这种情况下，我们想要存储精灵的位置以及游戏当前迭代完成后它将去的位置。我们还需要一个辅助方法来获取精灵的半径。

那么，让我们创建我们的`GameSprite`类。

# 行动时间 - 添加GameSprite.cpp

从这里开始，我们将在Xcode中创建任何新的类，但如果你记得更新`Make`文件，你同样可以在Eclipse中轻松完成。我将在本章后面展示如何做到这一点。

1.  在Xcode中，选择`Classes`文件夹，然后转到**文件** | **新建** | **文件**，导航到**iOS** | **源**选择**C++ 文件**。

1.  命名为`GameSprite`并确保选择了**也创建一个头文件**选项。

1.  选择新的`GameSprite.h`接口文件，并用以下代码替换那里的代码：

    [PRE7]

## *发生了什么？*

在接口中，我们声明该类是公共`Sprite`类的子类。

然后我们添加了三个合成属性。在Cocos2d-x中，这些是用于创建获取器和设置器的宏。你声明类型、受保护的变量名以及将附加到`get`和`set`方法的单词。因此，在第一个`CC_SYNTHESIZE`方法中，将创建`getNextPosition`和`setNextPosition`方法来处理`_nextPosition`受保护变量中的`Point`值。

我们还为我们的类添加了构造函数和析构函数，以及实例化的通用静态方法。这个方法接收一个参数，即精灵使用的图像文件名。我们通过覆盖`Sprite`中的`setPosition`并添加我们的辅助方法半径的声明来完成。

下一步是实现我们的新类。

# 行动时间 - 实现GameSprite

头文件处理完毕后，我们只需要实现我们的方法。

1.  选择`GameSprite.cpp`文件，让我们开始类的实例化逻辑：

    [PRE8]

1.  接下来，我们需要重写`Node`方法的`setPosition`。我们需要确保每次更改精灵的位置时，新的值也会被`_nextPosition`使用：

    [PRE9]

1.  最后，我们实现了我们的新方法来检索精灵的半径，我们将其确定为纹理宽度的一半：

    [PRE10]

## *发生了什么？*

事情只在静态方法中开始。我们创建一个新的`GameSprite`类，然后调用其上的`initWithFile`。这是从其超类继承的`GameSprite`方法；它返回一个布尔值，表示该操作是否成功。静态方法通过返回`autorelease`版本的`GameSprite`对象结束。

`setPosition`的重写确保当精灵被放置在某个位置时，`_nextPosition`也会接收到位置信息。并且辅助的`radius`方法返回精灵纹理宽度的二分之一。

## 尝试一下，英雄

将半径方法更改为接口中的内联方法，并从实现文件中删除它。

# 实际的游戏场景

最后，我们将看到我们的所有工作，并从中获得一些乐趣。但首先，让我们删除`HelloWorldScene`类（包括头文件和实现文件）。你会在项目中遇到一些错误，所以让我们修复这些错误。

在`AppDelegate.cpp`中的两行必须更改对类的引用。继续将引用更改为`GameLayer`类。

我们将创建那个类。

# 行动时间 – 编码GameLayer接口

`GameLayer`是我们游戏中的主要容器。

1.  按照步骤将新文件添加到你的`Classes`文件夹中。这是一个名为`GameLayer`的C++文件。

1.  选择你的`GameLayer.h`。在第一个`define`预处理器命令下方，添加：

    [PRE11]

1.  我们定义了球门的宽度（以像素为单位）。

1.  接下来，添加我们的精灵和得分文本标签的声明：

    [PRE12]

    我们有两个玩家的`GameSprite`对象（看起来奇怪的称为mallets），以及球（称为puck）。我们将两个玩家存储在Cocos2d-x的`Vector`中。我们还有两个文本标签来显示每个玩家的得分。

1.  声明一个变量来存储屏幕大小。我们将大量使用它进行定位：

    [PRE13]

1.  添加变量以存储得分信息，并添加一个方法来更新屏幕上的这些得分：

    [PRE14]

1.  最后，让我们添加我们的方法：

    [PRE15]

有构造函数和析构函数方法，然后是`Layer init`方法，最后是触摸事件处理程序和我们的循环方法`update`。这些触摸事件处理程序将被添加到我们的类中，以处理用户触摸开始、在屏幕上移动以及结束时的情况。

## *发生了什么？*

`GameLayer`是我们的游戏。它包含我们需要控制和更新的所有精灵的引用，以及所有游戏数据。

在类实现中，所有逻辑都开始于`init`方法内部。

# 行动时间 – 实现init()

在`init()`内部，我们将构建游戏屏幕，引入游戏所需的全部精灵和标签：

1.  因此，在调用超类`Layer::init`方法的`if`语句之后，我们添加：

    [PRE16]

1.  我们创建一个向量来存储两个玩家，初始化得分值，并从单例、无所不知的`Director`中获取屏幕大小。我们将使用屏幕大小来相对定位所有精灵。接下来，我们将创建第一个精灵。它使用图像文件名创建，`FileUtils`将负责从正确的文件夹中加载：

    [PRE17]

1.  习惯使用相对值定位精灵，而不是绝对值，这样我们可以支持更多的屏幕尺寸。并且，欢迎`Vec2`类型定义，它用于创建点；你将在Cocos2d-x中经常看到它。

1.  我们通过将精灵作为子节点添加到我们的`GameLayer`（球场精灵不需要是`GameSprite`）来完成。

1.  接下来，我们将使用我们全新的`GameSprite`类，仔细地在屏幕上定位对象：

    [PRE18]

1.  我们将使用`Label`类的`createWithTTF`静态方法创建TTF标签，传递初始字符串值（`0`）和字体文件路径。然后我们将定位和旋转标签：

    [PRE19]

1.  然后，我们将`GameLayer`变成一个多点触摸事件监听器，并告诉`Director`事件分发器`GameLayer`希望监听这些事件。最后，我们按照以下方式安排游戏的主循环：

    [PRE20]

## *发生了什么？*

你为冰球游戏创建了游戏屏幕，使用你自己的精灵和标签。一旦所有元素都添加完毕，游戏屏幕应该看起来像这样：

![发生了什么？](img/00009.jpeg)

现在我们已经准备好处理玩家的屏幕触摸了。

# 行动时间 – 处理多点触摸

在这个游戏中，我们需要实现三种方法来处理触摸事件。每个方法都接收一个参数，即一个`Touch`对象的向量：

1.  因此，添加我们的`onTouchesBegan`方法：

    [PRE21]

    如果你还记得，每个`GameSprite`都有一个`_touch`属性。

    因此，我们遍历触摸事件，获取它们在屏幕上的位置，遍历向量中的玩家，并确定触摸是否落在某个玩家身上。如果是，我们将触摸存储在玩家的`_touch`属性中（来自`GameSprite`类）。

    对于`onTouchesMoved`和`onTouchesEnded`，也会重复类似的过程，所以你可以复制粘贴代码，只需替换`_players`数组循环内的内容即可。

1.  在`TouchesMoved`中，当我们遍历玩家时，我们这样做：

    [PRE22]

    我们检查存储在玩家中的`_touch`属性是否是当前正在移动的。如果是，我们使用触摸的当前位置更新玩家的位置，但我们会检查新位置是否有效：玩家不能移动到屏幕外，也不能进入对手的球场。我们还更新玩家的移动向量；当我们将玩家与冰球碰撞时，我们需要这个向量。该向量基于玩家的位移。

1.  在`onTouchesEnded`中，我们添加以下内容：

    [PRE23]

如果这个触摸是刚刚结束的，我们清除玩家内部存储的 `_touch` 属性。玩家也会停止移动，因此其向量被设置为 `0`。注意，我们不再需要触摸的位置；所以在 `TouchesEnded` 中可以跳过这部分逻辑。

## *发生了什么？*

当你实现多触控逻辑时，这基本上是你必须做的：将单个触摸存储在数组或单个精灵中，这样你可以继续跟踪这些触摸。

现在，对于游戏的核心和灵魂——主循环。

# 是时候添加我们的主循环了

这是我们的游戏的核心——`update` 方法：

1.  我们将使用一点摩擦力更新冰球的速率（`0.98f`）。如果没有发生碰撞，我们将存储迭代结束时冰球的下一个位置：

    [PRE24]

1.  接下来是碰撞。我们将检查每个球员精灵和球之间的碰撞：

    [PRE25]

    通过球和球员之间的距离来检查碰撞。以下图示说明了两个条件将触发碰撞：

    ![是时候添加我们的主循环了](img/00010.jpeg)

1.  如果球和球员之间的距离等于两个精灵半径之和，或者小于两个精灵半径之和，则存在碰撞：

    [PRE26]

1.  我们使用平方半径值，这样我们就不需要使用昂贵的平方根计算来获取距离值。所以前一个条件语句中的所有值都是平方的，包括距离。

1.  这些条件既检查球员的当前位置也检查其下一个位置，这样球在迭代之间“穿过”球员精灵的风险就小了。

1.  如果发生碰撞，我们获取球和球员的向量的幅度，并使用这个力将球推开。在这种情况下，我们更新球的下一个位置，并通过 `SimpleAudioEngine` 单例播放一个好听的声音效果（别忘了包含 `SimpleAudioEngine.h` 头文件并声明我们使用 `CocosDenshion` 命名空间）：

    [PRE27]

1.  接下来，我们将检查球和屏幕边缘之间的碰撞。如果是这样，我们将球移回球场，并在这里播放我们的音效：

    [PRE28]

1.  在球场的顶部和底部两侧，我们检查球是否通过我们之前定义的 `GOAL_WIDTH` 属性没有穿过任何一个球门，如下所示：

    [PRE29]

1.  我们最终更新球的信息，如果球穿过了球门（鼓声响起）：

    [PRE30]

1.  我们调用我们的辅助方法来得分，并且现在我们知道游戏中每个元素 `nextPosition` 的值，我们完成更新，放置所有元素：

    [PRE31]

## *发生了什么？*

我们刚刚构建了游戏的主循环。每当你的游戏玩法依赖于精确的碰撞检测时，你无疑会应用类似的逻辑：现在的位置，下一个位置，碰撞检查，如果发生碰撞，则调整下一个位置。然后我们使用我们的辅助方法完成游戏。

现在剩下的只是更新分数。

# 是时候采取行动——更新分数

是时候在游戏中输入最后一个方法了。

1.  我们首先播放一个漂亮的进球效果，并停止我们的球：

    [PRE32]

1.  然后我们更新得分的玩家的分数，在这个过程中更新分数标签。并且球移动到刚刚得分的玩家的球场：

    [PRE33]

    玩家被移动到他们的原始位置，并且他们的 `_touch` 属性被清除：

    [PRE34]

## *发生了什么？*

好吧，猜猜看！你刚刚完成了你的第一个 Cocos2d-x 游戏。我们以快速的速度完成了第一个游戏，但我们在过程中几乎触及了 Cocos2d-x 游戏开发的每一个领域。

如果你现在点击 **运行**，你应该能够玩游戏。如果你在运行本章的源代码时遇到任何问题，你也应该找到游戏的完整版本。

是时候将这个游戏带到 Android 平台上了！

# 是时候采取行动——在 Android 上运行游戏

是时候将游戏部署到 Android 平台上了。

1.  按照从 `HelloWorld` 示例中的说明来将游戏导入到 Eclipse 中。

1.  导航到 `proj.android` 文件夹，在文本编辑器中打开 `AndroidManifest.xml` 文件。然后，转到 `jni` 文件夹，在文本编辑器中打开 `Android.mk` 文件。

1.  在 `AndroidManifest.xml` 文件中，编辑 `activity` 标签中的以下行：

    [PRE35]

1.  通过在 `supports-screens` 标签中添加这些行，你可以仅针对平板电脑进行目标定位：

    [PRE36]

1.  虽然如果你只想针对平板电脑，你可能还希望针对 SDK 的后续版本，如下所示：

    [PRE37]

1.  接下来，让我们编辑 make 文件，所以打开 `Android.mk` 文件，并编辑 `LOCAL_SRC_FILES` 中的行，使其读取：

    [PRE38]

1.  保存它并运行你的应用程序（别忘了连接一个 Android 设备，在这种情况下，如果你使用了这里解释的设置，那么是一个平板电脑）。

## *发生了什么？*

就这样！你还可以在 Eclipse 中编辑这些文件。

当你在命令行中构建 Cocos2d-x 项目时，你会看到一个消息说 `hellocpp` 目标正在重命名。但我认为这仍然是构建脚本中的错误，通常在 make 文件和文件夹结构中纠正它会带来更大的麻烦。所以现在，坚持使用 `Android.mk` 中的奇怪命名的 `hellocpp`。

## 英雄，试试看

对代码进行任何修改。例如，添加一个额外的标签，然后从 Eclipse 重新发布。你可能发现在这个 IDE 中与项目一起工作比 Xcode 快。

很遗憾，迟早，Eclipse 会抛出它臭名昭著的脾气。如果你在导航器中打开了多个项目，常见的问题之一是其中一个或多个项目报告错误，例如**找不到java.lang.Object类文件**或**无法解析java.lang.Object类型**。养成在打开 Eclipse 后立即清理项目并构建它的习惯，只保留打开的活动项目，但即使这样也可能失败。解决方案？重启 Eclipse，或者更好的方法是，从导航器（但不是从磁盘！）中删除项目，然后重新导入它。是的，我知道。欢迎来到 Eclipse！

# 摘要

你现在知道了如何添加精灵和标签，以及如何添加对两种屏幕分辨率的支持以及多点触控的支持。除了传递一个图像文件名之外，还有许多创建精灵的方法，我将在接下来的游戏中展示这些示例。

在这本书中，`LabelTTF` 将不会使用得太多。通常，它们适用于大量文本和不太频繁更新的文本；从现在起，我们将使用位图字体。

那么，让我们继续进行下一款游戏和动画。我保证不会让你打太多字。你应该让你的朋友帮你打字！
