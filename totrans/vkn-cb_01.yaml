- en: Instance and Devices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实例和设备
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Downloading Vulkan SDK
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载 Vulkan SDK
- en: Enabling validation layers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用验证层
- en: Connecting with a Vulkan Loader library
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 Vulkan Loader 库连接
- en: Preparing for loading Vulkan API functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备加载 Vulkan API 函数
- en: Loading function exported from a Vulkan Loader library
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载从 Vulkan Loader 库导出的函数
- en: Loading global-level functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载全局级函数
- en: Checking available Instance extensions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查可用的实例扩展
- en: Creating a Vulkan Instance
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 Vulkan 实例
- en: Loading instance-level functions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载实例级函数
- en: Enumerating available physical devices
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列举可用的物理设备
- en: Checking available device extensions
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查可用的设备扩展
- en: Getting features and properties of a physical device
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取物理设备的功能和属性
- en: Checking available queue families and their properties
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查可用的队列家族及其属性
- en: Selecting the index of a queue family with the desired capabilities
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择具有所需功能的队列家族的索引
- en: Creating a logical device
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建逻辑设备
- en: Loading device-level functions
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载设备级函数
- en: Getting a device queue
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取设备队列
- en: Creating a logical device with geometry shaders and graphics and compute queues
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用几何着色器和图形以及计算队列创建逻辑设备
- en: Destroying a logical device
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 销毁逻辑设备
- en: Destroying a Vulkan Instance
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 销毁 Vulkan 实例
- en: Releasing a Vulkan Loader library
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 释放 Vulkan Loader 库
- en: Introduction
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'Vulkan is a new graphics API developed by the Khronos Consortium. It is perceived
    as a successor to the OpenGL: it is open source and cross-platform. However, as
    it is possible to use Vulkan on different types of devices and operating systems,
    there are some differences in the basic setup code we need to create in order
    to use Vulkan in our application.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Vulkan 是由 Khronos Consortium 开发的新图形 API。它被视为 OpenGL 的继任者：它是开源的且跨平台的。然而，由于 Vulkan
    可以在不同的设备和操作系统上使用，我们需要创建一些基本设置代码，以便在我们的应用程序中使用 Vulkan。
- en: In this chapter, we will cover topics that are specific to using Vulkan on Microsoft
    Windows and Ubuntu Linux operating systems. We will learn Vulkan basics such as downloading
    the **Software Development Kit** (**SDK**) and setting **validation layers,**
    which enable us to debug the applications that use the Vulkan API. We will start
    using the **Vulkan Loader** library, load all the Vulkan API functions, create
    a Vulkan Instance, and select the device our work will be executed on.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍特定于在 Microsoft Windows 和 Ubuntu Linux 操作系统上使用 Vulkan 的主题。我们将学习 Vulkan
    基础知识，例如下载 **软件开发工具包**（**SDK**）和设置 **验证层**，这些验证层使我们能够调试使用 Vulkan API 的应用程序。我们将开始使用
    **Vulkan Loader** 库，加载所有 Vulkan API 函数，创建一个 Vulkan 实例，并选择我们的工作将在其上执行设备。
- en: Downloading Vulkan's SDK
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载 Vulkan 的 SDK
- en: To start developing applications using the Vulkan API, we need to download a
    SDK and use some of its resources in our application.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用 Vulkan API 开发应用程序，我们需要下载一个 SDK 并在我们的应用程序中使用其一些资源。
- en: Vulkan's SDK can be found at [https://vulkan.lunarg.com](https://vulkan.lunarg.com/).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Vulkan 的 SDK 可以在 [https://vulkan.lunarg.com](https://vulkan.lunarg.com/) 找到。
- en: Getting ready
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Before we can execute any application that uses the Vulkan API, we also need
    to install a graphics drivers that supports the Vulkan API. These can be found
    on a graphics hardware vendor's site.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够执行任何使用 Vulkan API 的应用程序之前，我们还需要安装支持 Vulkan API 的图形驱动程序。这些可以在图形硬件供应商的网站上找到。
- en: How to do it...
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'On the Windows operating system family:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 操作系统家族中：
- en: Go to [https://vulkan.lunarg.com](https://vulkan.lunarg.com/).
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 [https://vulkan.lunarg.com](https://vulkan.lunarg.com/)。
- en: Scroll to the bottom of the page and choose WINDOWS operating system.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将页面滚动到最底部并选择 WINDOWS 操作系统。
- en: Download and save the SDK installer file.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载并保存 SDK 安装程序文件。
- en: Run the installer and select the destination at which you want to install the
    SDK. By default, it is installed to a `C:\VulkanSDK\<version>\` folder.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行安装程序并选择您想要安装 SDK 的目标位置。默认情况下，它被安装到 `C:\VulkanSDK\<version>\` 文件夹中。
- en: When the installation is finished, open the folder in which the Vulkan SDK was
    installed and then open the `RunTimeInstaller` sub-folder. Execute `VulkanRT-<version>-Installer`
    file. This will install the latest version of the Vulkan Loader.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，打开 Vulkan SDK 安装文件夹，然后打开 `RunTimeInstaller` 子文件夹。执行 `VulkanRT-<version>-Installer`
    文件。这将安装最新的 Vulkan Loader 版本。
- en: Once again, go to the folder in which the SDK was installed and open the `Include\vulkan`
    sub-folder. Copy the `vk_platform.h` and `vulkan.h` header files to the project
    folder of the application you want to develop. We will call these two files *Vulkan
    header files*.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，前往 SDK 安装的文件夹，并打开 `Include\vulkan` 子文件夹。将 `vk_platform.h` 和 `vulkan.h` 头文件复制到您想要开发的应用的工程文件夹中。我们将这两个文件称为
    *Vulkan 头文件*。
- en: 'On the Linux operating system family:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 操作系统系列中：
- en: 'Update system packages by running the following commands:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令更新系统包：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To be able to build and execute Vulkan samples from the SDK, install additional
    development packages by running the following command:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要能够从 SDK 中构建和执行 Vulkan 示例，通过运行以下命令安装额外的开发包：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Go to [https://vulkan.lunarg.com](https://vulkan.lunarg.com).
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 [https://vulkan.lunarg.com](https://vulkan.lunarg.com)。
- en: Scroll to the bottom of the page and choose LINUX operating system.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动到页面底部并选择 LINUX 操作系统。
- en: Download the Linux package for the SDK and save it in the desired folder.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载 SDK 的 Linux 包并将其保存到所需的文件夹中。
- en: Open Terminal and change the current directory to the folder to which the SDK
    package was downloaded.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，将当前目录更改为 SDK 软件包下载的文件夹。
- en: 'Change the access permissions to the downloaded file by executing the following
    command:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令更改下载文件的访问权限：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Run the downloaded SDK package installer file with the following command:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行下载的 SDK 软件包安装程序文件：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Change the current directory to the `VulkanSDK/<version>` folder that was created
    by the SDK package installer.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前目录更改为由 SDK 软件包安装程序创建的 `VulkanSDK/<version>` 文件夹。
- en: 'Set up environment variables by executing the following command:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令设置环境变量：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Change the current directory to the `x86_64/include/vulkan` folder.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前目录更改为 `x86_64/include/vulkan` 文件夹。
- en: Copy `vk_platform.h` and `vulkan.h` header files to the project folder of the
    application you want to develop. We will call these two files *Vulkan header files*.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `vk_platform.h` 和 `vulkan.h` 头文件复制到您想要开发的应用的工程文件夹中。我们将这两个文件称为 *Vulkan 头文件*。
- en: Restart the computer for the changes to take effect.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启动计算机以使更改生效。
- en: How it works...
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The SDK contains resources needed to create applications using the Vulkan API.
    Vulkan header files (the `vk_platform.h` and `vulkan.h` files) need to be included
    in the source code of our application so we can use the Vulkan API functions,
    structures, enumerations, and so on, inside the code.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: SDK 包含创建使用 Vulkan API 的应用程序所需的资源。Vulkan 头文件（`vk_platform.h` 和 `vulkan.h` 文件）需要包含在我们的应用程序源代码中，这样我们就可以在代码中使用
    Vulkan API 函数、结构、枚举等。
- en: The Vulkan Loader (`vulkan-1.dll` file on Windows, `libvulkan.so.1` file on
    Linux systems) is a dynamic library responsible for exposing Vulkan API functions
    and forwarding them to the graphics driver. We connect with it in our application
    and load Vulkan API functions from it.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Vulkan 加载器（Windows 上的 `vulkan-1.dll` 文件，Linux 系统上的 `libvulkan.so.1` 文件）是一个动态库，负责公开
    Vulkan API 函数并将它们转发给图形驱动程序。我们在应用中与之连接，并从其中加载 Vulkan API 函数。
- en: See also
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下配方：
- en: '*Enabling validation layers*'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*启用验证层*'
- en: '*Connecting with a Vulkan Loader library*'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*连接到 Vulkan 加载器库*'
- en: '*Releasing a Vulkan Loader library*'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*释放 Vulkan 加载器库*'
- en: Enabling validation layers
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用验证层
- en: The Vulkan API was designed with performance in mind. One way to increase its
    performance is to lower state and error checking performed by the driver. This
    is one of the reasons Vulkan is called a "thin API" or "thin driver," it is a
    minimal abstraction of the hardware, which is required for the API to be portable
    across multiple hardware vendors and device types (high-performance desktop computers,
    mobile phones, and integrated and low-power embedded systems).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Vulkan API 是以性能为设计理念的。提高其性能的一种方法是通过降低驱动程序执行的状态和错误检查。这也是为什么 Vulkan 被称为“瘦 API”或“瘦驱动”的原因之一，它是对硬件的最小抽象，这使得
    API 能够跨多个硬件供应商和设备类型（高性能桌面计算机、移动电话、集成和低功耗嵌入式系统）移植。
- en: However, this approach makes creating applications with the Vulkan API much
    more difficult, compared to the traditional high-level APIs such as OpenGL. It's
    because very little feedback is given to developers by the driver, as it expects
    that programmers will correctly use the API and abide by rules defined in the
    Vulkan specification.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与传统的传统高级 API（如 OpenGL）相比，这种方法使得使用 Vulkan API 创建应用程序变得更加困难。这是因为驱动程序向开发者提供的反馈非常有限，因为它期望程序员会正确使用
    API 并遵守 Vulkan 规范中定义的规则。
- en: To mitigate this problem, Vulkan was also designed to be a layered API. The
    lowest layer, the core, is the **Vulkan API** itself, which communicates with
    the **Driver,** allowing us to program the **Hardware** (as seen in the preceding
    diagram). On top of it (between the **Application** and the **Vulkan API**), developers
    can enable additional layers, to ease the debugging process.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减轻这个问题，Vulkan 也被设计成一个分层 API。最低层，核心，就是 **Vulkan API** 本身，它与 **驱动程序** 通信，使我们能够编程
    **硬件**（如前图所示）。在其之上（在 **应用程序** 和 **Vulkan API** 之间），开发者可以启用额外的层，以简化调试过程。
- en: '![](img/image_01_001.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_01_001.png)'
- en: How to do it...
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'On the Windows operating system family:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 操作系统家族中：
- en: Go to the folder in which the SDK was installed and then open the `Config` sub-directory.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 SDK 安装文件夹，然后打开 `Config` 子目录。
- en: Copy the `vk_layer_settings.txt` file into the directory of the executable you
    want to debug (into a folder of an application you want to execute).
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `vk_layer_settings.txt` 文件复制到要调试的可执行文件目录中（要执行的应用程序文件夹中）。
- en: 'Create an environment variable named `VK_INSTANCE_LAYERS`:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `VK_INSTANCE_LAYERS` 的环境变量：
- en: Open the command-line console (Command Prompt/`cmd.exe`).
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令行控制台（命令提示符/`cmd.exe`）。
- en: 'Type the following:'
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下内容：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 3\. Close the console.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 关闭控制台。
- en: Re-open the command prompt once again.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次重新打开命令提示符。
- en: Change the current directory to the folder of the application you want to execute.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前目录更改为要执行的应用程序文件夹。
- en: Run the application; potential warnings or errors will be displayed in the standard
    output of the command prompt.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序；潜在警告或错误将在命令提示符的标准输出中显示。
- en: 'On the Linux operating system family:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 操作系统家族中：
- en: Go to the folder in which the SDK was installed and then open the `Config` sub-directory.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 SDK 安装文件夹，然后打开 `Config` 子目录。
- en: Copy the `vk_layer_settings.txt` file into the directory of the executable you
    want to debug (into a folder of an application you want to execute).
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `vk_layer_settings.txt` 文件复制到要调试的可执行文件目录中（要执行的应用程序文件夹中）。
- en: 'Create an environment variable named `VK_INSTANCE_LAYERS`:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `VK_INSTANCE_LAYERS` 的环境变量：
- en: Open the Terminal window.
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端窗口。
- en: 'Type the following:'
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下内容：
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Run the application; potential warnings or errors will be displayed in the standard
    output of the Terminal window.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序；潜在警告或错误将在终端窗口的标准输出中显示。
- en: How it works...
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Vulkan validation layers contain a set of libraries which help find potential
    problems in created applications. Their debugging capabilities include, but are
    not limited to, validating parameters passed to Vulkan functions, validating texture
    and render target formats, tracking Vulkan objects and their lifetime and usage,
    and checking for potential memory leaks or dumping (displaying/printing) Vulkan
    API function calls. These functionalities are enabled by different validation
    layers, but most of them are gathered into a single layer called `VK_LAYER_LUNARG_standard_validation`
    which is enabled in this recipe. Examples of names of other layers include `VK_LAYER_LUNARG_swapchain`,
    `VK_LAYER_LUNARG_object_tracker`, `VK_LAYER_GOOGLE_threading`, or `VK_LAYER_LUNARG_api_dump,`
    among others. Multiple layers can be enabled at the same time, in a similar way
    as presented here in the recipe. Just assign the names of the layers you want
    to activate to the `VK_INSTANCE_LAYERS` environment variable. If you are a Windows
    OS user, remember to separate them with a semicolon, as in the example:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Vulkan 验证层包含一组库，这些库有助于在创建的应用程序中找到潜在问题。它们的调试功能包括但不限于验证传递给 Vulkan 函数的参数、验证纹理和渲染目标格式、跟踪
    Vulkan 对象及其生命周期和用法，以及检查潜在的内存泄漏或转储（显示/打印）Vulkan API 函数调用。这些功能由不同的验证层启用，但大多数都汇集到一个名为
    `VK_LAYER_LUNARG_standard_validation` 的单个层中，该层在本食谱中启用。其他层的名称示例包括 `VK_LAYER_LUNARG_swapchain`、`VK_LAYER_LUNARG_object_tracker`、`VK_LAYER_GOOGLE_threading`
    或 `VK_LAYER_LUNARG_api_dump` 等。可以同时启用多个层，方法与这里在食谱中展示的类似。只需将您想要激活的层的名称分配给 `VK_INSTANCE_LAYERS`
    环境变量。如果您是 Windows 操作系统用户，请记住用分号分隔它们，如下例所示：
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you are a Linux OS user, separate them with a colon. Here is an example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是 Linux 操作系统用户，请用冒号分隔它们。以下是一个示例：
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The environment variable named `VK_INSTANCE_LAYERS` can be also set with other
    OS specific ways such as, advanced operating system settings on Windows or `/etc/environment`
    on Linux.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 命名为 `VK_INSTANCE_LAYERS` 的环境变量也可以通过其他操作系统特定的方式设置，例如，在 Windows 上的高级操作系统设置或 Linux
    上的 `/etc/environment`。
- en: The preceding examples enable validation layers globally, for all applications,
    but they can also be enabled only for our own application, in its source code
    during Instance creation. However, this approach requires us to recompile the
    whole program every time we want to enable or disable different layers. So, it
    is easier to enable them using the preceding recipe. This way, we also won't forget
    to disable them when we want to ship the final version of our application. To
    disable validation layers, we just have to delete `VK_INSTANCE_LAYERS` environment
    variable.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例使验证层在全局范围内对所有应用程序生效，但它们也可以仅对我们自己的应用程序生效，在其源代码中创建实例时启用。然而，这种方法要求我们每次想要启用或禁用不同的层时都要重新编译整个程序。因此，使用上述方法启用它们更容易。这样，我们也不会忘记在发布应用程序的最终版本时禁用它们。要禁用验证层，我们只需删除
    `VK_INSTANCE_LAYERS` 环境变量。
- en: Validation layers should not be enabled in the released (shipped) version of
    the applications as they may drastically decrease performance.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 验证层不应在发布（发货）的应用程序的版本中启用，因为它们可能会大幅降低性能。
- en: For a full list of available validation layers, please refer to the documentation,
    which can be found in the `Documentation` sub-folder of the directory in which
    the Vulkan SDK was installed.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有关可用的所有验证层的完整列表，请参阅文档，这些文档可以在安装 Vulkan SDK 的目录中的 `Documentation` 子目录中找到。
- en: See also
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Downloading Vulkan''s SDK*'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*下载 Vulkan 的 SDK*'
- en: '*Connecting with a Vulkan Loader library*'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*连接到 Vulkan 加载器库*'
- en: '*Releasing a Vulkan Loader library*'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*释放 Vulkan 加载器库*'
- en: Connecting with a Vulkan Loader library
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到 Vulkan 加载器库
- en: Support for the Vulkan API is implemented by the graphics-hardware vendor and
    provided through graphics drivers. Each vendor can implement it in any dynamic
    library they choose, and can even change it with the driver update.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Vulkan API 的支持由图形硬件供应商实现，并通过图形驱动程序提供。每个供应商都可以选择任何动态库来实现它，甚至可以在驱动程序更新中更改它。
- en: That's why, along with the drivers, Vulkan Loader is also installed. We can
    also install it from the folder in which the SDK was installed. It allows developers
    to access Vulkan API entry points, through a `vulkan-1.dll` library on Windows
    OS or `libvulkan.so.1` library on Linux OS, no matter what driver, from what vendor,
    is installed.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，除了驱动程序之外，Vulkan 加载库也被安装。我们也可以从 SDK 安装文件夹中安装它。它允许开发者通过 Windows OS 上的 `vulkan-1.dll`
    库或 Linux OS 上的 `libvulkan.so.1` 库访问 Vulkan API 的入口点，无论安装了什么驱动程序，来自哪个供应商。
- en: 'Vulkan Loader is responsible for transmitting Vulkan API calls to an appropriate
    graphics driver. On a given computer, there may be more hardware components that
    support Vulkan, but with Vulkan Loader, we don''t need to wonder which driver
    we should use, or which library we should connect with to be able to use Vulkan.
    Developers just need to know the name of a Vulkan library: `vulkan-1.dll` on Windows
    or `libvulkan.so.1` on Linux. When we want to use Vulkan in our application, we
    just need to connect with it in our code (load it).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Vulkan 加载库负责将 Vulkan API 调用传输到适当的图形驱动程序。在给定的计算机上，可能有更多支持 Vulkan 的硬件组件，但有了 Vulkan
    加载库，我们就不需要猜测应该使用哪个驱动程序，或者应该连接哪个库才能使用 Vulkan。开发者只需要知道 Vulkan 库的名称：Windows 上的 `vulkan-1.dll`
    或 Linux 上的 `libvulkan.so.1`。当我们想在应用程序中使用 Vulkan 时，我们只需在代码中连接它（加载它）。
- en: On Windows OS, Vulkan Loader library is called `vulkan-1.dll`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows OS 上，Vulkan 加载库被命名为 `vulkan-1.dll`。
- en: On Linux OS, Vulkan Loader library is called `libvulkan.so.1`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux OS 上，Vulkan 加载库被命名为 `libvulkan.so.1`。
- en: How to do it...
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'On the Windows operating system family:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 操作系统家族中：
- en: Prepare a variable of type `HMODULE` named `vulkan_library`.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个名为 `vulkan_library` 的 `HMODULE` 类型的变量。
- en: Call `LoadLibrary( "vulkan-1.dll" )` and store the result of this operation
    in a `vulkan_library` variable.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `LoadLibrary( "vulkan-1.dll" )` 并将此操作的返回结果存储在 `vulkan_library` 变量中。
- en: Confirm that this operation has been successful by checking if a value of a
    `vulkan_library` variable is different than `nullptr`.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过检查 `vulkan_library` 变量的值是否不同于 `nullptr` 来确认此操作已成功执行。
- en: 'On the Linux operating system family:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 操作系统家族中：
- en: Prepare a variable of type `void*` named `vulkan_library`.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个名为 `vulkan_library` 的 `void*` 类型的变量。
- en: Call `dlopen( "libvulkan.so.1", RTLD_NOW )` and store the result of this operation
    in a `vulkan_library` variable.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `dlopen( "libvulkan.so.1", RTLD_NOW )` 并将此操作的返回结果存储在 `vulkan_library` 变量中。
- en: Confirm that this operation has been successful by checking if a value of a
    `vulkan_library` variable is different than `nullptr`.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过检查 `vulkan_library` 变量的值是否不同于 `nullptr` 来确认此操作已成功执行。
- en: How it works...
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`LoadLibrary()` is a function available on Windows operating systems. `dlopen()`
    is a function available on Linux operating systems. They both load (open) a specified
    dynamic-link library into a memory space of our application. This way we can load
    (acquire pointers of) functions implemented and exported from a given library
    and use them in our application.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoadLibrary()` 是 Windows 操作系统上可用的一项功能。`dlopen()` 是 Linux 操作系统上可用的一项功能。它们两者都将指定的动态链接库加载（打开）到我们的应用程序的内存空间中。这样我们就可以加载（获取）从给定库实现并导出的函数，并在我们的应用程序中使用它们。'
- en: 'In the case of a function exported from a Vulkan API, in which we are, of course,
    most interested, we load a `vulkan-1.dll` library on Windows or `libvulkan.so.1`
    library on Linux as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们最感兴趣的从 Vulkan API 导出的函数的情况下，我们按照以下方式在 Windows 上加载 `vulkan-1.dll` 库或在 Linux
    上加载 `libvulkan.so.1` 库：
- en: '[PRE9]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: After a successful call, we can load a Vulkan-specific function for acquiring
    the addresses of all other Vulkan API procedures.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功调用之后，我们可以加载一个用于获取所有其他 Vulkan API 程序地址的特定于 Vulkan 的函数。
- en: See also
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下配方：
- en: '*Downloading Vulkan SDK*'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*下载 Vulkan SDK*'
- en: '*Enabling validation layers*'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*启用验证层*'
- en: '*Releasing a Vulkan Loader library*'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*释放 Vulkan 加载库*'
- en: Preparing for loading Vulkan API functions
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备加载 Vulkan API 函数
- en: When we want to use Vulkan API in our application, we need to acquire procedures
    specified in the Vulkan documentation. In order to do that, we can add a dependency
    to the Vulkan Loader library, statically link with it in our project, and use
    function prototypes defined in the `vulkan.h` header file. The second approach
    is to disable the function prototypes defined in the `vulkan.h` header file and
    load function pointers dynamically in our application.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想在应用程序中使用Vulkan API时，我们需要获取Vulkan文档中指定的过程。为了做到这一点，我们可以在项目中添加对Vulkan加载器库的依赖，将其静态链接到我们的项目中，并使用`vulkan.h`头文件中定义的函数原型。第二种方法是禁用`vulkan.h`头文件中定义的函数原型，并在我们的应用程序中动态加载函数指针。
- en: The first approach is little bit easier, but it uses functions defined directly
    in the Vulkan Loader library. When we perform operations on a given device, Vulkan
    Loader needs to redirect function calls to the proper implementation based on
    the handle of the device we provide as an argument. This redirection takes some
    time, and thus impacts performance.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法稍微简单一些，但它使用的是直接在Vulkan加载器库中定义的函数。当我们对一个给定的设备执行操作时，Vulkan加载器需要根据我们提供的作为参数的设备句柄将函数调用重定向到适当的实现。这种重定向需要一些时间，从而影响性能。
- en: The second option requires more work on the application side, but allows us
    to skip the preceding redirection (jump) and save some performance. It is performed
    by loading functions directly from the device we want to use. This way, we can
    also choose only the subset of Vulkan functions if we don't need them all.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法需要在应用程序方面做更多的工作，但允许我们跳过前面的重定向（跳转）并节省一些性能。这是通过直接从我们想要使用的设备中加载函数来实现的。这样，如果我们不需要所有功能，我们还可以选择只使用Vulkan函数的子集。
- en: In this book, the second approach is presented, as this gives developers more
    control over the things that are going in their applications. To dynamically load
    functions from a Vulkan Loader library, it is convenient to wrap the names of
    all Vulkan API functions into a set of simple macros and divide declarations,
    definitions and function loading into multiple files.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，介绍了第二种方法，因为它让开发者能够更好地控制应用程序中的事情。为了从Vulkan加载器库中动态加载函数，将所有Vulkan API函数的名称包装成一组简单的宏，并将声明、定义和函数加载分成多个文件是很方便的。
- en: How to do it...
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Define the `VK_NO_PROTOTYPES` preprocessor definition in the project: do this
    in the project properties (when using development environments such as Microsoft
    Visual Studio or Qt Creator), or by using the `#define VK_NO_PROTOTYPES` preprocessor
    directive just before the `vulkan.h` file is included in the source code of our
    application.'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目中定义`VK_NO_PROTOTYPES`预处理器定义：在项目属性中进行此操作（当使用Microsoft Visual Studio或Qt Creator等开发环境时），或者通过在源代码中包含`vulkan.h`文件之前使用`#define
    VK_NO_PROTOTYPES`预处理器指令。
- en: Create a new file, named `ListOfVulkanFunctions.inl`.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ListOfVulkanFunctions.inl`的新文件。
- en: 'Type the following contents into the file:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容输入到文件中：
- en: '[PRE10]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Create a new header file, named `VulkanFunctions.h`.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`VulkanFunctions.h`的新头文件。
- en: 'Insert the following contents into the file:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容插入到文件中：
- en: '[PRE11]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Create a new file with a source code named `VulkanFunctions.cpp`.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`VulkanFunctions.cpp`的新源代码文件。
- en: 'Insert the following contents into the file:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容插入到文件中：
- en: '[PRE12]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works...
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The preceding set of files may seem unnecessary, or even overwhelming, at first.
    `VulkanFunctions.h` and `VulkanFunctions.cpp` files are used to declare and define
    variables in which we will store pointers to Vulkan API functions. Declarations
    and definitions are done through a convenient macro definition and an inclusion
    of a `ListOfVulkanFunctions.inl` file. We will update this file and add the names
    of many Vulkan functions, from various levels. This way, we don't need to repeat
    the names of functions multiple times, in multiple places, which helps us avoid
    making mistakes and typos. We can just write the required names of Vulkan functions
    only once, in the `ListOfVulkanFunctions.inl` file, and include it when it's needed.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这一系列文件一开始可能看起来是不必要的，甚至令人不知所措。`VulkanFunctions.h`和`VulkanFunctions.cpp`文件用于声明和定义我们将存储指向Vulkan
    API函数的指针的变量。声明和定义是通过方便的宏定义和包含`ListOfVulkanFunctions.inl`文件来完成的。我们将更新此文件并添加许多来自不同级别的Vulkan函数的名称。这样，我们就不需要在多个地方多次重复函数名称，这有助于我们避免犯错误和打字错误。我们只需在`ListOfVulkanFunctions.inl`文件中一次写入所需的Vulkan函数名称，并在需要时包含它。
- en: How do we know the types of variables for storing pointers to Vulkan API functions?
    It's quite simple. The type of each function's prototype is derived directly from
    the function's name. When a function is named `<name>`, its type is `PFN_<name>`.
    For example, a function that creates an image is called `vkCreateImage()`, so
    the type of this function is `PFN_vkCreateImage`. That's why macros defined in
    the presented set of files have just one parameter for function name, from which
    the type can be easily derived.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何知道用于存储指向 Vulkan API 函数指针的变量的类型？这很简单。每个函数的原型类型直接从函数名称派生。当一个函数被命名为 `<name>`
    时，其类型是 `PFN_<name>`。例如，创建图像的函数被命名为 `vkCreateImage()`，因此这个函数的类型是 `PFN_vkCreateImage`。这就是为什么在提供的文件集中定义的宏只有一个参数，即函数名称，可以从它轻松地推导出类型。
- en: Last, but not least, remember that declarations and definitions of variables,
    in which we will store addresses of the Vulkan functions, should be placed inside
    a namespace, a class, or a structure. This is because, if they are made global,
    this could lead to problems on some operating systems. It's better to remember
    about namespaces and increase the portability of our code.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，但同样重要的是，记住我们将存储 Vulkan 函数地址的变量声明和定义应该放在命名空间、类或结构体内部。这是因为，如果它们被设置为全局的，这可能会在某些操作系统上导致问题。记住命名空间并增加我们代码的可移植性会更好。
- en: Place declarations and definitions of variables containing Vulkan API function
    pointers inside a structure, class, or namespace.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 将包含 Vulkan API 函数指针的变量声明和定义放在结构体、类或命名空间内。
- en: Now that we are prepared, we can start loading Vulkan functions.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了，我们可以开始加载 Vulkan 函数。
- en: See also
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Loading function exported from a Vulkan Loader library*'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*加载从 Vulkan Loader 库导出的函数*'
- en: '*Loading global-level functions*'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*加载全局级函数*'
- en: '*Loading instance-level functions*'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*加载实例级函数*'
- en: '*Loading device-level functions*'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*加载设备级函数*'
- en: Loading functions exported from a Vulkan Loader library
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载从 Vulkan Loader 库导出的函数
- en: When we load (connect with) a Vulkan Loader library, we need to load its functions
    to be able to use the Vulkan API in our application. Unfortunately, different
    operating systems have different ways of acquiring the addresses of functions
    exported from dynamic libraries (`.dll` files on Windows or `.so` files on Linux).
    However, the Vulkan API strives to be portable across many operating systems.
    So, to allow developers to load all functions available in the API, no matter
    what operating system they are targeting, Vulkan introduced a function which can
    be used to load all other Vulkan API functions. However, this one single function
    can only be loaded in an OS specific way.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们加载（连接）Vulkan Loader 库时，我们需要加载其函数才能在我们的应用程序中使用 Vulkan API。不幸的是，不同的操作系统有不同的方式来获取从动态库（Windows
    上的 `.dll` 文件或 Linux 上的 `.so` 文件）导出的函数的地址。然而，Vulkan API 力求跨许多操作系统实现可移植性。因此，为了允许开发者加载
    API 中可用的所有函数，无论他们针对的是哪个操作系统，Vulkan 引入了一个可以用来加载所有其他 Vulkan API 函数的函数。然而，这个单一函数只能以操作系统特定的方式加载。
- en: How to do it...
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'On the Windows operating system family:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 操作系统家族中：
- en: Create a variable of type `PFN_vkGetInstanceProcAddr` named `vkGetInstanceProcAddr`.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `vkGetInstanceProcAddr` 的 `PFN_vkGetInstanceProcAddr` 类型的变量。
- en: Call `GetProcAddress( vulkan_library, "vkGetInstanceProcAddr" )`, cast the result
    of this operation onto a `PFN_vkGetInstanceProcAddr` type, and store it in the `vkGetInstanceProcAddr`
    variable.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `GetProcAddress( vulkan_library, "vkGetInstanceProcAddr" )`，将此操作的返回结果转换为
    `PFN_vkGetInstanceProcAddr` 类型，并将其存储在 `vkGetInstanceProcAddr` 变量中。
- en: Confirm that this operation succeeded by checking if a value of the `vkGetInstanceProcAddr`
    variable does not equal to `nullptr`.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过检查 `vkGetInstanceProcAddr` 变量的值是否不等于 `nullptr` 来确认此操作是否成功。
- en: 'On the Linux operating system family:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 操作系统家族中：
- en: Create a variable of type `PFN_vkGetInstanceProcAddr` named `vkGetInstanceProcAddr`.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `vkGetInstanceProcAddr` 的 `PFN_vkGetInstanceProcAddr` 类型的变量。
- en: Call `dlsym( vulkan_library, "vkGetInstanceProcAddr" )`, cast the result of
    this operation onto a `PFN_vkGetInstanceProcAddr` type, and store it in the `vkGetInstanceProcAddr`
    variable.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `dlsym( vulkan_library, "vkGetInstanceProcAddr" )`，将此操作的返回结果转换为 `PFN_vkGetInstanceProcAddr`
    类型，并将其存储在 `vkGetInstanceProcAddr` 变量中。
- en: Confirm that this operation succeeded by checking if a value of the `vkGetInstanceProcAddr`
    variable does not equal to `nullptr`.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过检查 `vkGetInstanceProcAddr` 变量的值是否不等于 `nullptr` 来确认此操作是否成功。
- en: How it works...
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`GetProcAddress()` is a function available on Windows operating systems. `dlsym()`
    is a function available on Linux operating systems. They both acquire an address
    of a specified function from an already loaded dynamic-link library. The only
    function that must be publicly exported from all Vulkan implementations is called
    `vkGetInstanceProcAddr()`. It allows us to load any other Vulkan function in a
    way that is independent of the operating system we are working on.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetProcAddress()` 是在 Windows 操作系统上可用的函数。`dlsym()` 是在 Linux 操作系统上可用的函数。它们都从已加载的动态链接库中获取指定函数的地址。所有
    Vulkan 实现必须公开导出的唯一函数称为 `vkGetInstanceProcAddr()`。它允许我们以与操作系统无关的方式加载任何其他 Vulkan
    函数。'
- en: To ease and automate the process of loading multiple Vulkan functions, and to
    lower the probability of making mistakes, we should wrap the processes of declaring,
    defining, and loading functions into a set of convenient macro definitions, as
    described in the *Preparing for loading Vulkan API functions* recipe. This way,
    we can keep all Vulkan API functions in just one file which contains a list of
    macro-wrapped names of all Vulkan functions. We can then include this single file
    in multiple places and get use of the C/C++ preprocessor. By redefining macros,
    we can declare and define the variables in which we will store function pointers,
    and we can also load all of them.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化并自动化加载多个 Vulkan 函数的过程，并降低出错的可能性，我们应该将声明、定义和加载函数的过程封装成一组方便的宏定义，如 *准备加载 Vulkan
    API 函数* 食谱中所述。这样，我们就可以将所有 Vulkan API 函数保存在一个文件中，该文件包含所有 Vulkan 函数的宏封装名称列表。然后我们可以将此单个文件包含在多个位置，并利用
    C/C++ 预处理器。通过重新定义宏，我们可以声明和定义我们将存储函数指针的变量，也可以加载所有这些函数。
- en: 'Here is the updated fragment of the `ListOfVulkanFunctions.inl` file:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `ListOfVulkanFunctions.inl` 文件更新的片段：
- en: '[PRE13]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The rest of the files (`VulkanFunctions.h` and `VulkanFunctions.h`) remain
    unchanged. Declarations and definitions are automatically performed with preprocessor
    macros. However, we still need to load functions exported from the Vulkan Loader
    library. The implementation of the preceding recipe may look as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的文件（`VulkanFunctions.h` 和 `VulkanFunctions.h`）保持不变。声明和定义是通过预处理器宏自动执行的。然而，我们仍然需要加载从
    Vulkan Loader 库导出的函数。前一个食谱的实现可能如下所示：
- en: '[PRE14]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: First we define a macro that is responsible for acquiring an address of a `vkGetInstanceProcAddr()`
    function. It gets it from the library represented by the `vulkan_library` variable,
    casts the result of this operation onto a `PFN_kGetInstanceProcAddr` type, and
    stores it in a variable named `vkGetInstanceProcAddr`. After that, the macro checks
    whether the operation succeeded, and displays the proper message on screen in
    the case of a failure.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义一个负责获取 `vkGetInstanceProcAddr()` 函数地址的宏。它从表示为 `vulkan_library` 变量的库中获取它，将此操作的结果转换为
    `PFN_kGetInstanceProcAddr` 类型，并将其存储在名为 `vkGetInstanceProcAddr` 的变量中。之后，该宏检查操作是否成功，并在失败的情况下在屏幕上显示适当的消息。
- en: All the preprocessor "magic" is done when the `ListOfVulkanFunctions.inl` file
    is included and the preceding operations are performed for each function defined
    in this file. In this case, it is performed for only the `vkGetInstanceProcAddr()`
    function, but the same behavior is achieved for functions from other levels.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 所有预处理器“魔法”都是在包含 `ListOfVulkanFunctions.inl` 文件并执行此文件中定义的每个函数的前置操作时完成的。在这种情况下，它仅针对
    `vkGetInstanceProcAddr()` 函数执行，但对于其他级别的函数也能达到相同的行为。
- en: Now, when we have a function loading function, we can acquire pointers to other
    Vulkan procedures in an OS-independent way.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们有一个函数加载函数时，我们可以以操作系统无关的方式获取其他 Vulkan 程序的指针。
- en: See also
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中以下食谱：
- en: '*Connecting with a Vulkan Loader library*'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*与 Vulkan Loader 库连接*'
- en: '*Preparing for loading Vulkan API functions*'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*准备加载 Vulkan API 函数*'
- en: '*Loading global-level functions*'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*加载全局级别的函数*'
- en: '*Loading instance-level functions*'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*加载实例级别的函数*'
- en: '*Loading device-level functions*'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*加载设备级别的函数*'
- en: Loading global-level functions
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载全局级别的函数
- en: We have acquired a `vkGetInstanceProcAddr()` function, through which we can
    load all other Vulkan API entry points in an OS-independent way.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经获取了一个 `vkGetInstanceProcAddr()` 函数，通过它可以以操作系统无关的方式加载所有其他 Vulkan API 入口点。
- en: Vulkan functions can be divided into three levels, which are **g****lobal**,
    **instance**, and **device**. Device-level functions are used to perform typical
    operations such as drawing, shader-modules creation, image creation, or data copying.
    Instance-level functions allow us to create **logical devices**. To do all this,
    and to load device and instance-level functions, we need to create an Instance.
    This operation is performed with global-level functions, which we need to load
    first.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Vulkan 函数可以分为三个级别，分别是 **全局**、**实例** 和 **设备**。设备级别函数用于执行典型的操作，如绘图、着色器模块创建、图像创建或数据复制。实例级别函数允许我们创建
    **逻辑设备**。为了完成所有这些，并加载设备和实例级别函数，我们需要创建一个实例。这个操作是通过全局级别函数执行的，我们首先需要加载这些函数。
- en: How to do it...
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Create a variable of type `PFN_vkEnumerateInstanceExtensionProperties` named
    `vkEnumerateInstanceExtensionProperties`.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `vkEnumerateInstanceExtensionProperties` 的 `PFN_vkEnumerateInstanceExtensionProperties`
    类型的变量。
- en: Create a variable of type `PFN_vkEnumerateInstanceLayerProperties` named `vkEnumerateInstanceLayerProperties`.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `vkEnumerateInstanceLayerProperties` 的 `PFN_vkEnumerateInstanceLayerProperties`
    类型的变量。
- en: Create a variable of type `PFN_vkCreateInstance` named `vkCreateInstance`.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `vkCreateInstance` 的 `PFN_vkCreateInstance` 类型的变量。
- en: Call `vkGetInstanceProcAddr( nullptr, "vkEnumerateInstanceExtensionProperties"
    )`, cast the result of this operation onto the `PFN_vkEnumerateInstanceExtensionProperties`
    type, and store it in a `vkEnumerateInstanceExtensionProperties` variable.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `vkGetInstanceProcAddr( nullptr, "vkEnumerateInstanceExtensionProperties"
    )`，将此操作的输出转换为 `PFN_vkEnumerateInstanceExtensionProperties` 类型，并将其存储在 `vkEnumerateInstanceExtensionProperties`
    变量中。
- en: Call `vkGetInstanceProcAddr( nullptr, "vkEnumerateInstanceLayerProperties" )`,
    cast the result of this operation onto the `PFN_vkEnumerateInstanceLayerProperties`
    type, and store it in a `vkEnumerateInstanceLayerProperties` variable.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `vkGetInstanceProcAddr( nullptr, "vkEnumerateInstanceLayerProperties" )`，将此操作的输出转换为
    `PFN_vkEnumerateInstanceLayerProperties` 类型，并将其存储在 `vkEnumerateInstanceLayerProperties`
    变量中。
- en: Call `vkGetInstanceProcAddr( nullptr, "vkCreateInstance" )`, cast the result
    of this operation onto a `PFN_vkCreateInstance` type, and store it in the `vkCreateInstance`
    variable.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `vkGetInstanceProcAddr( nullptr, "vkCreateInstance" )`，将此操作的输出转换为 `PFN_vkCreateInstance`
    类型，并将其存储在 `vkCreateInstance` 变量中。
- en: Confirm that the operation succeeded by checking whether, values of all the
    preceding variables are not equal to `nullptr`.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过检查所有前面的变量值是否不等于 `nullptr` 来确认操作是否成功。
- en: How it works...
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In Vulkan, there are only three global-level functions: `vkEnumerateInstanceExtensionProperties()`,
    `vkEnumerateInstanceLayerProperties()`, and `vkCreateInstance()`. They are used
    during Instance creation to check, what instance-level extensions and layers are
    available and to create the Instance itself.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vulkan 中，只有三个全局级别函数：`vkEnumerateInstanceExtensionProperties()`、`vkEnumerateInstanceLayerProperties()`
    和 `vkCreateInstance()`。它们在实例创建期间用于检查可用的实例级别扩展和层，并创建实例本身。
- en: 'The process of acquiring global-level functions is similar to the loading function
    exported from the Vulkan Loader. That''s why the most convenient way is to add
    the names of global-level functions to the `ListOfVulkanFunctions.inl` file as
    follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 获取全局级别函数的过程与从 Vulkan Loader 导出的加载函数类似。这就是为什么最方便的方法是将全局级别函数的名称添加到 `ListOfVulkanFunctions.inl`
    文件中，如下所示：
- en: '[PRE15]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We don''t need to change the `VulkanFunctions.h` and `VulkanFunctions.h` files,
    but we still need to implement the preceding recipe and load global-level functions
    as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要更改 `VulkanFunctions.h` 和 `VulkanFunctions.h` 文件，但我们仍然需要实现前面的食谱，并按如下方式加载全局级别函数：
- en: '[PRE16]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: A custom `GLOBAL_LEVEL_VULKAN_FUNCTION` macro takes the function name and provides
    it to a `vkGetInstanceProcAddr()` function. It tries to load the given function
    and, in the case of a failure, returns `nullptr`. Any result returned by the `vkGetInstanceProcAddr()`
    function is cast onto a `PFN_<name>` type and stored in a proper variable.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 一个自定义的 `GLOBAL_LEVEL_VULKAN_FUNCTION` 宏接受函数名称并将其提供给 `vkGetInstanceProcAddr()`
    函数。它尝试加载给定的函数，如果失败，则返回 `nullptr`。`vkGetInstanceProcAddr()` 函数返回的任何结果都将转换为 `PFN_<name>`
    类型并存储在适当的变量中。
- en: In the case of a failure, a message is displayed so the user knows which function
    couldn't be loaded.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果失败，将显示一条消息，以便用户知道哪个函数无法加载。
- en: See also
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Preparing for loading Vulkan API functions*'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*准备加载 Vulkan API 函数*'
- en: '*Loading function exported from a Vulkan Loader library*'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*加载从 Vulkan Loader 库导出的函数*'
- en: '*Loading instance-level functions*'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*加载实例级别函数*'
- en: '*Loading device-level functions*'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*加载设备级函数*'
- en: Checking available Instance extensions
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查可用的实例扩展
- en: Vulkan Instance gathers per application state and allows us to create a logical
    device on which almost all operations are performed. Before we can create an Instance
    object, we should think about the instance-level extensions we want to enable.
    An example of one of the most important instance-level extensions are swapchain
    related extensions, which are used to display images on screen.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Vulkan 实例收集每个应用程序的状态，并允许我们创建一个逻辑设备，几乎所有操作都在这个设备上执行。在我们能够创建实例对象之前，我们应该考虑我们想要启用的实例级扩展。其中最重要的实例级扩展之一是与交换链相关的扩展，这些扩展用于在屏幕上显示图像。
- en: Extensions in Vulkan, as opposed to OpenGL, are enabled explicitly. We can't
    create a Vulkan Instance and request extensions that are not supported, because
    the Instance creation operation will fail. That's why we need to check which extensions
    are supported on a given hardware platform.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 与 OpenGL 不同，Vulkan 中的扩展是显式启用的。我们不能创建一个不支持的扩展的 Vulkan 实例，因为实例创建操作将失败。这就是为什么我们需要检查在给定的硬件平台上支持哪些扩展。
- en: How to do it...
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Prepare a variable of type `uint32_t` named `extensions_count`.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个名为 `extensions_count` 的 `uint32_t` 类型的变量。
- en: Call `vkEnumerateInstanceExtensionProperties( nullptr, &extensions_count, nullptr
    )`. All parameters should be set to `nullptr`, except for the second parameter,
    which should point to the `extensions_count` variable.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `vkEnumerateInstanceExtensionProperties( nullptr, &extensions_count, nullptr
    )`。所有参数都应设置为 `nullptr`，除了第二个参数，它应指向 `extensions_count` 变量。
- en: If a function call is successful, the total number of available instance-level
    extensions will be stored in the `extensions_count` variable.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果函数调用成功，总可用实例级扩展的数量将存储在 `extensions_count` 变量中。
- en: Prepare a storage for the list of extension properties. It must contain elements
    of type `VkExtensionProperties`. The best solution is to use a `std::vector` container.
    Call it `available_extensions`.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为扩展属性列表准备一个存储空间。它必须包含类型为 `VkExtensionProperties` 的元素。最佳解决方案是使用 `std::vector`
    容器。可以将其命名为 `available_extensions`。
- en: Resize the vector to be able to hold at least the `extensions_count` elements.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整向量的大小，以便至少可以容纳 `extensions_count` 个元素。
- en: Call `vkEnumerateInstanceExtensionProperties( nullptr, &extensions_count, &available_extensions[0]
    )`. The first parameter is once again set to `nullptr`; the second parameter should
    point to the `extensions_count` variable; the third parameter must point to an
    array of at least `extensions_count` elements of type `VkExtensionProperties`.
    Here, in the third parameter, provide an address of the first element of the `available_extensions`
    vector.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `vkEnumerateInstanceExtensionProperties( nullptr, &extensions_count, &available_extensions[0]
    )`。第一个参数再次设置为 `nullptr`；第二个参数应指向 `extensions_count` 变量；第三个参数必须指向一个至少包含 `extensions_count`
    个元素的 `VkExtensionProperties` 类型的数组。在这里，在第三个参数中，提供 `available_extensions` 向量第一个元素的地址。
- en: If the function returns successfully, the `available_extensions` vector variable
    will contain a list of all extensions supported on a given hardware platform.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果函数返回成功，`available_extensions` 向量变量将包含在给定硬件平台上支持的所有扩展的列表。
- en: How it works...
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Code that acquires instance-level extensions can be divided into two stages.
    First we get the total number of available extensions as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 获取实例级扩展的代码可以分为两个阶段。首先，我们获取可用扩展的总数，如下所示：
- en: '[PRE17]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When called with the last parameter set to `nullptr`, the `vkEnumerateInstanceExtensionProperties()`
    function stores the number of available extensions in the variable pointed to
    in the second parameter. This way, we know how many extensions are on a given
    platform and how much space we need to be able to store parameters for all of
    them.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当最后一个参数设置为 `nullptr` 时，`vkEnumerateInstanceExtensionProperties()` 函数将可用扩展的数量存储在第二个参数指向的变量中。这样，我们就知道在给定平台上有多少扩展，以及我们需要多少空间来存储所有这些扩展的参数。
- en: 'When we are ready to acquire extensions'' properties, we can call the same
    function once again. This time the last parameter should point to the prepared
    space (an array of `VkExtensionProperties` elements, or a vector, in our case)
    in which these properties will be stored:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们准备好获取扩展属性时，我们可以再次调用该函数。这次最后一个参数应指向准备好的空间（一个 `VkExtensionProperties` 元素数组，或者在我们的情况下是一个向量），其中将存储这些属性：
- en: '[PRE18]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The pattern of calling the same function twice is common in Vulkan. There are
    multiple functions, which store the number of elements returned in the query when
    their last argument is set to `nullptr`. When their last element points to an
    appropriate variable, they return the data itself.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vulkan 中，调用同一函数两次的模式很常见。有多个函数，当它们的最后一个参数设置为 `nullptr` 时，它们会存储查询返回的元素数量。当它们的最后一个元素指向一个适当的变量时，它们会返回数据本身。
- en: Now that we have the list, we can look through it and check whether the extensions
    we would like to enable are available on a given platform.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这个列表，我们可以查看它并检查我们想要启用的扩展是否在给定的平台上可用。
- en: See also
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的以下配方：
- en: '*Checking available device extensions*'
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*检查可用的设备扩展*'
- en: The following recipe in [Chapter 2](45eb1180-672a-4745-bd85-f13c7bb658b7.xhtml), *Image
    Presentation:*
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [第2章](45eb1180-672a-4745-bd85-f13c7bb658b7.xhtml) 中的以下配方，*图像展示*：
- en: '*Creating a Vulkan Instance with WSI extensions enabled*'
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建启用了 WSI 扩展的 Vulkan 实例*'
- en: Creating a Vulkan Instance
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Vulkan 实例
- en: A Vulkan Instance is an object that gathers the state of an application. It
    encloses information such as an application name, name and version of an engine
    used to create an application, or enabled instance-level extensions and layers.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Vulkan 实例是一个收集应用程序状态的对象。它包含诸如应用程序名称、用于创建应用程序的引擎名称和版本，或启用的实例级扩展和层等信息。
- en: Through the Instance, we can also enumerate available physical devices and create
    logical devices on which typical operations such as image creation or drawing
    are performed. So, before we proceed with using the Vulkan API, we need to create
    a new Instance object.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实例，我们还可以枚举可用的物理设备并在其上创建逻辑设备，在这些设备上执行典型的操作，如图像创建或绘图。因此，在我们使用 Vulkan API 之前，我们需要创建一个新的实例对象。
- en: How to do it...
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Prepare a variable of type `std::vector<char const *>` named `desired_extensions`.
    Store the names of all extensions you want to enable in the `desired_extensions`
    variable.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个名为 `desired_extensions` 的 `std::vector<char const *>` 类型的变量。将所有想要启用的扩展的名称存储在
    `desired_extensions` 变量中。
- en: Create a variable of type `std::vector<VkExtensionProperties>` named `available_extensions`.
    Acquire the list of all available extensions and store it in the `available_extensions`
    variable (refer to the *Checking available Instance extensions* recipe).
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `available_extensions` 的 `std::vector<VkExtensionProperties>` 类型的变量。获取所有可用扩展的列表并将其存储在
    `available_extensions` 变量中（参考 *Checking available Instance extensions* 配方）。
- en: Make sure that the name of each extension from the `desired_extensions` variable
    is also present in the `available_extensions` variable.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保从 `desired_extensions` 变量中每个扩展的名称也存在于 `available_extensions` 变量中。
- en: 'Prepare a variable of type `VkApplicationInfo` named `application_info`. Assign
    the following values for members of the `application_info` variable:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个名为 `application_info` 的 `VkApplicationInfo` 类型的变量。为 `application_info` 变量的成员分配以下值：
- en: '`VK_STRUCTURE_TYPE_APPLICATION_INFO` value for `sType`.'
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`VK_STRUCTURE_TYPE_APPLICATION_INFO` 的 `sType` 值。'
- en: '`nullptr` value for `pNext`.'
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`pNext` 的 `nullptr` 值。'
- en: Name of your application for `pApplicationName`.
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序名称为 `pApplicationName`。
- en: Version of your application for the `applicationVersion` structure member; do
    that by using `VK_MAKE_VERSION` macro and specifying major, minor, and patch values
    in it.
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序版本的 `applicationVersion` 结构成员；通过使用 `VK_MAKE_VERSION` 宏并指定其中的主要、次要和补丁值来实现。
- en: Name of the engine used to create an application for `pEngineName`.
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于创建应用程序的引擎名称为 `pEngineName`。
- en: Version of the engine used to create an application for `engineVersion`; do
    that by using `VK_MAKE_VERSION` macro.
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于创建应用程序的引擎版本为 `engineVersion` 的版本；通过使用 `VK_MAKE_VERSION` 宏来实现。
- en: '`VK_MAKE_VERSION( 1, 0, 0 )` for `apiVersion`.'
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`VK_MAKE_VERSION( 1, 0, 0 )` 用于 `apiVersion`。'
- en: 'Create a variable of type `VkInstanceCreateInfo` named `instance_create_info`.
    Assign the following values for members of the `instance_create_info` variable:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `instance_create_info` 的 `VkInstanceCreateInfo` 类型的变量。为 `instance_create_info`
    变量的成员分配以下值：
- en: '`VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO` value for `sType`.'
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO` 的 `sType` 值。'
- en: '`nullptr` value for `pNext`.'
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`pNext` 的 `nullptr` 值。'
- en: '`0` value for `flags`.'
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`flags` 的 `0` 值。'
- en: Pointer to the `application_info` variable in `pApplicationInfo`.
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指向 `application_info` 变量的 `pApplicationInfo` 指针。
- en: '`0` value for `enabledLayerCount`.'
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`enabledLayerCount` 的 `0` 值。'
- en: '`nullptr` value for `ppEnabledLayerNames`.'
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ppEnabledLayerNames` 的 `nullptr` 值。'
- en: Number of elements of the `desired_extensions` vector for `enabledExtensionCount`.
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`desired_extensions` 向量的元素数量为 `enabledExtensionCount`。'
- en: Pointer to the first element of the `desired_extensions` vector (or `nullptr`
    if is empty) for `ppEnabledExtensionNames`.
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指向`desired_extensions`向量第一个元素的指针（如果为空，则为`nullptr`）用于`ppEnabledExtensionNames`。
- en: Create a variable of type `VkInstance` named `instance`.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`instance`的`VkInstance`类型的变量。
- en: Call the `vkCreateInstance( &instance_create_info, nullptr, &instance )` function.
    Provide a pointer to the `instance_create_info` variable in the first parameter,
    a `nullptr` value in the second, and a pointer to the `instance` variable in the
    third parameter.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`vkCreateInstance( &instance_create_info, nullptr, &instance )`函数。在第一个参数中提供一个指向`instance_create_info`变量的指针，在第二个参数中提供一个`nullptr`值，在第三个参数中提供一个指向`instance`变量的指针。
- en: Make sure the operation was successful by checking whether the value returned
    by the `vkCreateInstance()` function call is equal to `VK_SUCCESS`.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过检查`vkCreateInstance()`函数调用返回的值是否等于`VK_SUCCESS`来确保操作成功。
- en: How it works...
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To create an Instance, we need to prepare some information. First, we need
    to create an array of names of instance-level extensions that we would like to
    enable. Next, we need to check if they are supported on a given hardware. This
    is done by acquiring the list of all available instance-level extensions and checking
    if it contains the names of all the extensions we want to enable:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建实例，我们需要准备一些信息。首先，我们需要创建一个包含我们想要启用的实例级扩展名称的数组。接下来，我们需要检查它们是否在给定的硬件上受支持。这是通过获取所有可用实例级扩展的列表并检查它是否包含我们想要启用的所有扩展的名称来完成的：
- en: '[PRE19]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we need to create a variable in which we will provide information about
    our application, such as its name and version, the name and version of an engine
    used to create an application, and the version of a Vulkan API we want to use
    (right now only the first version is supported by the API):'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个变量，我们将在此变量中提供有关我们的应用程序的信息，例如其名称和版本、用于创建应用程序的引擎的名称和版本，以及我们想要使用的Vulkan
    API的版本（目前API只支持第一个版本）：
- en: '[PRE20]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The pointer to the `application_info` variable in the preceding code sample
    is provided in a second variable with the actual parameters used to create an
    Instance. In it, apart from the previously mentioned pointer, we provide information
    about the number and names of extensions we want to enable, and also the number
    and names of layers we want to enable. Neither extensions nor layers are required
    to create a valid Instance object and we can skip them. However, there are very
    important extensions, without which it will be hard to create a fully functional
    application, so it is recommended to use them. Layers may be safely omitted. Following
    is the sample code preparing a variable used to define Instance parameters:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，`application_info`变量的指针通过一个包含用于创建实例的实际参数的第二个变量提供。在其中，除了之前提到的指针外，我们还提供了我们想要启用的扩展的数量和名称，以及我们想要启用的层和名称。扩展和层都不是创建有效的实例对象所必需的，我们可以跳过它们。然而，有一些非常重要的扩展，没有它们将很难创建一个功能齐全的应用程序，因此建议使用它们。层可以安全地省略。以下是为定义实例参数的变量准备示例代码：
- en: '[PRE21]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, when we have prepared the preceding data, we can create an Instance
    object. This is done with the `vkCreateInstance()` function. Its first parameter
    must point to the variable of type `VkInstanceCreateInfo`. The third parameter
    must point to a variable of type `VkInstance`. The created Instance handle will
    be stored in it. The second parameter is very rarely used: It may point to a variable
    of type `VkAllocationCallbacks`, in which allocator callback functions are defined.
    These functions control the way host memory is allocated and are mainly used for
    debugging purposes. Most of the time, the second parameter defining allocation
    callbacks can be set to `nullptr`:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当我们准备好了前面的数据后，我们可以创建一个实例对象。这是通过`vkCreateInstance()`函数完成的。其第一个参数必须指向类型为`VkInstanceCreateInfo`的变量。第三个参数必须指向类型为`VkInstance`的变量。创建的实例句柄将存储在其中。第二个参数很少使用：它可能指向一个类型为`VkAllocationCallbacks`的变量，在其中定义了分配器回调函数。这些函数控制主机内存的分配，主要用于调试目的。大多数情况下，定义分配回调的第二个参数可以设置为`nullptr`：
- en: '[PRE22]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: See also
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Checking available Instance extensions*'
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*检查可用的实例扩展*'
- en: '*Destroying a Vulkan Instance*'
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*销毁Vulkan实例*'
- en: 'The following recipe in [Chapter 2](45eb1180-672a-4745-bd85-f13c7bb658b7.xhtml),
    *Image Presentation*:'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第2章](45eb1180-672a-4745-bd85-f13c7bb658b7.xhtml)的以下食谱中，*图像呈现*：
- en: '*Creating a Vulkan Instance with WSI extensions enabled*'
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*启用WSI扩展的Vulkan实例创建*'
- en: Loading instance-level functions
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载实例级函数
- en: We have created a Vulkan Instance object. The next step is to enumerate physical
    devices, choose one of them, and create a logical device from it. These operations
    are performed with instance-level functions, of which we need to acquire the addresses.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个 Vulkan 实例对象。下一步是枚举物理设备，从中选择一个，并从它创建一个逻辑设备。这些操作是通过实例级函数执行的，我们需要获取它们的地址。
- en: How to do it...
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Take the handle of a created Vulkan Instance. Provide it in a variable of type
    `VkInstance` named `instance`.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取已创建的 Vulkan 实例的句柄。将其提供在名为 `instance` 的 `VkInstance` 类型变量中。
- en: Choose the name (denoted as `<function name>`) of an instance-level function
    you want to load.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择您想要加载的实例级函数的名称（表示为 `<function name>`）。
- en: Create a variable of type `PFN_<function name>` named `<function name>`.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `<function name>` 的 `PFN_<function name>` 类型的变量。
- en: Call `vkGetInstanceProcAddr( instance, "<function name>" )`. Provide a handle
    for the created Instance in the first parameter and a function name in the second.
    Cast the result of this operation onto a `PFN_<function name>` type and store
    it in a `<function name>` variable.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `vkGetInstanceProcAddr( instance, "<function name>" )`。在第一个参数中提供一个创建的实例的句柄，在第二个参数中提供一个函数名。将此操作的结果转换为
    `PFN_<function name>` 类型，并将其存储在 `<function name>` 变量中。
- en: Confirm that this operation succeeded by checking if a value of a `<function
    name>` variable is not equal to `nullptr`.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过检查 `<function name>` 变量的值是否不等于 `nullptr` 来确认此操作是否成功。
- en: How it works...
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Instance-level functions are used mainly for operations on physical devices.
    There are multiple instance-level functions, with `vkEnumeratePhysicalDevices()`,
    `vkGetPhysicalDeviceProperties()`, `vkGetPhysicalDeviceFeatures()`, `vkGetPhysicalDeviceQueueFamilyProperties()`,
    `vkCreateDevice()`, `vkGetDeviceProcAddr()`, `vkDestroyInstance()` or `vkEnumerateDeviceExtensionProperties()`
    among them. However, this list doesn't include all instance-level functions.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 实例级函数主要用于对物理设备进行操作。其中包含多个实例级函数，如 `vkEnumeratePhysicalDevices()`、`vkGetPhysicalDeviceProperties()`、`vkGetPhysicalDeviceFeatures()`、`vkGetPhysicalDeviceQueueFamilyProperties()`、`vkCreateDevice()`、`vkGetDeviceProcAddr()`、`vkDestroyInstance()`
    或 `vkEnumerateDeviceExtensionProperties()` 等。然而，这个列表并不包括所有实例级函数。
- en: How can we tell if a function is instance- or device-level? All device-level
    functions have their first parameter of type `VkDevice`, `VkQueue`, or `VkCommandBuffer`.
    So, if a function doesn't have such a parameter and is not from the global level,
    it is from an instance level. As mentioned previously, instance-level functions
    are used for manipulating with physical devices, checking their properties, abilities
    and, creating logical devices.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何判断一个函数是实例级还是设备级？所有设备级函数的第一个参数类型为 `VkDevice`、`VkQueue` 或 `VkCommandBuffer`。因此，如果一个函数没有这样的参数，并且不是全局级别的，那么它就是实例级的。如前所述，实例级函数用于操作物理设备，检查它们的属性、能力，并创建逻辑设备。
- en: Remember that extensions can also introduce new functions. You need to add their
    functions to the function loading code in order to be able to use the extension
    in the application. However, you shouldn't load functions introduced by a given
    extension without enabling the extension first during Instance creation. If these
    functions are not supported on a given platform, loading them will fail (it will
    return a null pointer).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，扩展也可以引入新的功能。您需要将它们的函数添加到功能加载代码中，以便能够在应用程序中使用扩展。然而，在实例创建期间，您不应该在没有启用扩展的情况下加载由特定扩展引入的函数。如果这些函数在特定平台上不受支持，加载它们将失败（它将返回一个空指针）。
- en: 'So, in order to load instance-level functions, we should update the `ListOfVulkanFunctions.inl`
    file as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了加载实例级函数，我们应该按照以下方式更新 `ListOfVulkanFunctions.inl` 文件：
- en: '[PRE23]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding code, we added the names of several (but not all) instance-level
    functions. Each of them is wrapped into an `INSTANCE_LEVEL_VULKAN_FUNCTION` or
    an `INSTANCE_LEVEL_VULKAN_FUNCTION_FROM_EXTENSION` macro, and is placed between
    `#ifndef` and the `#undef` preprocessor definitions.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们添加了几个（但不是所有）实例级函数的名称。每个函数都被包装在 `INSTANCE_LEVEL_VULKAN_FUNCTION` 或
    `INSTANCE_LEVEL_VULKAN_FUNCTION_FROM_EXTENSION` 宏中，并放置在 `#ifndef` 和 `#undef` 预处理器定义之间。
- en: 'To implement the instance-level functions loading recipe using the preceding
    macros, we should write the following code:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用前面的宏实现实例级函数加载配方，我们应该编写以下代码：
- en: '[PRE24]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The preceding macro calls a `vkGetInstanceProcAddr()` function. It's the same
    function used to load global-level functions, but this time, the handle of a Vulkan
    Instance is provided in the first parameter. This way, we can load functions that
    can work properly only when an Instance object is created.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的宏调用了一个`vkGetInstanceProcAddr()`函数。这是用于加载全局级函数的相同函数，但这次，在第一个参数中提供了Vulkan实例的句柄。这样，我们可以加载只有在实例对象创建时才能正常工作的函数。
- en: This function returns a pointer to the function whose name is provided in the
    second parameter. The returned value is of type `void*`, which is why it is then
    cast onto a type appropriate for a function we acquire the address of.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数返回一个指向第二参数中提供的函数名称的指针。返回值是`void*`类型，这就是为什么它随后被转换为一个适合我们获取地址的函数类型。
- en: The type of a given function's prototype is defined based on its name, with
    a `PFN_` before it. So, in the example, the type of the `vkEnumeratePhysicalDevices()`
    function's prototype will be defined as `PFN_vkEnumeratePhysicalDevices`.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 给定函数的原型类型是根据其名称定义的，在其名称前有一个`PFN_`前缀。因此，在示例中，`vkEnumeratePhysicalDevices()`函数的原型类型将被定义为`PFN_vkEnumeratePhysicalDevices`。
- en: If the `vkGetInstanceProcAddr()` function cannot find an address of the requested
    procedure, it returns `nullptr`. That's why we should perform a check and log
    the appropriate message in case of any problems.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`vkGetInstanceProcAddr()`函数找不到请求的过程的地址，它将返回`nullptr`。这就是为什么我们应该进行检查，并在出现任何问题时记录适当的消息。
- en: 'The next step is to load functions that are introduced by extensions. Our function
    loading code acquires pointers of all functions that are specified with a proper
    macro in the `ListOfVulkanFunctions.inl` file, but we can''t provide extension-specific
    functions in the same way, because they can be loaded only when appropriate extensions
    are enabled. When we don''t enable any extension, only the core Vulkan API functions
    can be loaded. That''s why we need to distinguish core API functions from extension-specific
    functions. We also need to know which extensions are enabled and which function
    comes from which extension. That''s why a separate macro is used for functions
    introduced by extensions. Such a macro specifies a function name, but also the
    name of an extension in which a given function is specified. To load such functions,
    we can use the following code:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是加载由扩展引入的函数。我们的函数加载代码获取了在`ListOfVulkanFunctions.inl`文件中用适当宏指定的所有函数的指针，但我们不能以相同的方式提供特定于扩展的函数，因为它们只能在适当的扩展启用时加载。当我们没有启用任何扩展时，只能加载核心Vulkan
    API函数。这就是为什么我们需要区分核心API函数和特定于扩展的函数。我们还需要知道哪些扩展被启用，以及哪个函数来自哪个扩展。这就是为什么为扩展引入的函数使用了一个单独的宏。这样的宏指定了一个函数名称，但也指定了一个给定函数被指定的扩展的名称。为了加载这样的函数，我们可以使用以下代码：
- en: '[PRE25]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`enabled_extensions` is a variable of type `std::vector<char const *>`, which
    contains the names of all enabled instance-level extensions. We iterate over all
    its elements and check whether the name of a given extension matches the name
    of an extension that introduces the provided function. If it does, we load the
    function in the same way as a normal core API function. Otherwise, we skip the
    pointer-loading code. If we don''t enable the given extension, we can''t load
    functions introduced by it.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`enabled_extensions`是一个类型为`std::vector<char const *>`的变量，它包含所有启用实例级扩展的名称。我们遍历其所有元素，检查给定扩展的名称是否与引入提供函数的扩展的名称匹配。如果是，我们将以与正常核心API函数相同的方式加载该函数。否则，我们跳过指针加载代码。如果我们没有启用给定的扩展，我们就无法加载它引入的函数。'
- en: See also
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Preparing for loading Vulkan API functions*'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*准备加载Vulkan API函数*'
- en: '*Loading function exported from a Vulkan Loader library*'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从Vulkan加载器库中加载导出的函数*'
- en: '*Loading global-level functions*'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*加载全局级函数*'
- en: '*Loading device-level functions*'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*加载设备级函数*'
- en: Enumerating available physical devices
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出可用的物理设备
- en: 'Almost all the work in Vulkan is performed on logical devices: we create resources
    on them, manage their memory, record command buffers created from them, and submit
    commands for processing to their queues. In our application, logical devices represent
    physical devices for which a set of features and extensions were enabled. To create
    a logical device, we need to select one of the physical devices available on a
    given hardware platform. How do we know how many and what physical devices are
    available on a given computer? We need to enumerate them.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有的Vulkan工作都是在逻辑设备上完成的：我们在它们上创建资源，管理它们的内存，记录从它们创建的命令缓冲区，并将处理命令提交给它们的队列。在我们的应用程序中，逻辑设备代表那些已启用一组特性和扩展的物理设备。要创建一个逻辑设备，我们需要在给定的硬件平台上选择一个物理设备。我们如何知道在给定的计算机上有多少个以及哪些物理设备可用？我们需要枚举它们。
- en: How to do it...
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Take the handle of a created Vulkan Instance. Provide it through a variable
    of type `VkInstance` named `instance`.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取创建的Vulkan实例的句柄。通过一个名为`instance`的`VkInstance`类型变量提供它。
- en: Prepare a variable of type `uint32_t` named `devices_count`.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个名为`devices_count`的`uint32_t`类型变量。
- en: Call `vkEnumeratePhysicalDevices( instance, &devices_count, nullptr )`. In the
    first parameter, provide a handle of the Vulkan Instance; in second, provide a
    pointer to the `devices_count` variable, and leave the third parameter set to
    `nullptr` right now.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`vkEnumeratePhysicalDevices(instance, &devices_count, nullptr)`。在第一个参数中，提供一个Vulkan实例的句柄；在第二个参数中，提供一个指向`devices_count`变量的指针，并将第三个参数现在设置为`nullptr`。
- en: If a function call is successful, the `devices_count` variable will contain
    the total number of available physical devices.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果函数调用成功，`devices_count`变量将包含可用物理设备总数。
- en: Prepare storage for the list of physical devices. The best solution is to use
    a variable of type `std::vector` with elements of type `VkPhysicalDevice`. Call
    it `available_devices`.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备物理设备列表的存储空间。最好的解决方案是使用一个名为`available_devices`的`std::vector`变量，其元素类型为`VkPhysicalDevice`。调用它`available_devices`。
- en: Resize the vector to be able to hold at least the `devices_count` elements.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整向量的大小，以便至少可以容纳`devices_count`个元素。
- en: Call `vkEnumeratePhysicalDevices( instance, &devices_count, &available_devices[0]
    )`. Again, the first parameter should be set to the handle of a Vulkan Instance
    object, the second parameter should still point to the `extensions_count` variable,
    and the third parameter must point to an array of at least `devices_count` elements
    of type `VkPhysicalDevice`. Here, in the third parameter, provide an address of
    the first element of an `available_devices` vector.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`vkEnumeratePhysicalDevices(instance, &devices_count, &available_devices[0])`。再次，第一个参数应设置为Vulkan实例对象的句柄，第二个参数应仍然指向`devices_count`变量，第三个参数必须指向一个至少包含`devices_count`个`VkPhysicalDevice`元素的数组。在这里，在第三个参数中，提供一个指向`available_devices`向量第一个元素的地址。
- en: If the function returns successfully, the `available_devices` vector will contain
    a list of all physical devices installed on a given hardware platform that supports
    a Vulkan API.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果函数调用成功，`available_devices`向量将包含在给定硬件平台上安装的所有支持Vulkan API的物理设备的列表。
- en: How it works...
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Enumerating the available physical devices operation is divided into two stages:
    First, we check how many physical devices are available on any given hardware.
    This is done by calling the `vkEnumeratePhysicalDevices()` function with the last
    parameter set to `nullptr`, as follows:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 可用物理设备的枚举操作分为两个阶段：首先，我们检查在任意给定的硬件上可用的物理设备数量。这是通过调用`vkEnumeratePhysicalDevices()`函数并设置最后一个参数为`nullptr`来完成的，如下所示：
- en: '[PRE26]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This way, we know how many devices are supporting Vulkan and how much storage
    we need to prepare for their handles. When we are ready and have prepared enough
    space, we can go to the second stage and get the actual handles of physical devices.
    This is done with the call of the same `vkEnumeratePhysicalDevices()` function,
    but this time, the last parameter must point to an array of `VkPhysicalDevice`
    elements:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就知道有多少设备支持Vulkan以及我们需要为它们的句柄准备多少存储空间。当我们准备就绪并且已经准备了足够的空间时，我们可以进入第二阶段，获取物理设备的实际句柄。这是通过调用相同的`vkEnumeratePhysicalDevices()`函数来完成的，但这次，最后一个参数必须指向一个`VkPhysicalDevice`元素的数组：
- en: '[PRE27]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When the call is successful, the prepared storage is filled with the handles
    of physical devices installed on any computer on which our application is executed.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用成功时，准备好的存储空间将被填充上安装在我们应用程序执行的任何计算机上的物理设备的句柄。
- en: Now that we have the list of devices, we can look through it and check the properties
    of each device, check operations we can perform on it, and see what extensions
    are supported by it.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了设备列表，我们可以查看它，并检查每个设备的属性，检查我们可以对其执行的操作，并查看它支持哪些扩展。
- en: See also
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 本章以下食谱：
- en: '*Loading instance-level functions*'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*加载实例级函数*'
- en: '*Checking available device extensions*'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*检查可用的设备扩展*'
- en: '*Checking available queue families and their properties*'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*检查可用的队列家族及其属性*'
- en: '*Creating a logical device*'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建逻辑设备*'
- en: Checking available device extensions
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查可用的设备扩展
- en: 'Some Vulkan features we would like to use, require us to explicitly enable
    certain extensions (contrary to OpenGL, in which extensions were automatically/implicitly
    enabled). There are two kinds, or two levels, of extensions: Instance-level and
    device-level. Like Instance extensions, device extensions are enabled during logical
    device creation. We can''t ask for a device extension if it is not supported by
    a given physical device or we won''t be able to create a logical device for it.
    So, before we start creating a logical device, we need to make sure that all requested
    extensions are supported by a given physical device, or we need to search for
    another device that supports them all.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望使用的某些 Vulkan 功能要求我们显式启用某些扩展（与自动/隐式启用的 OpenGL 相反）。有两种或两个级别的扩展：实例级和设备级。与实例扩展一样，设备扩展在逻辑设备创建期间启用。如果某个物理设备不支持设备扩展，我们无法为其创建逻辑设备。因此，在我们开始创建逻辑设备之前，我们需要确保所有请求的扩展都由给定的物理设备支持，或者我们需要寻找支持它们的另一个设备。
- en: How to do it...
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Take one of the physical device handles returned by the `vkEnumeratePhysicalDevices()`
    function and store it in a variable of type `VkPhysicalDevice` called `physical_device`.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取 `vkEnumeratePhysicalDevices()` 函数返回的一个物理设备句柄，并将其存储在一个名为 `physical_device`
    的 `VkPhysicalDevice` 类型变量中。
- en: Prepare a variable of type `uint32_t` named `extensions_count`.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个名为 `extensions_count` 的 `uint32_t` 类型变量。
- en: 'Call `vkEnumerateDeviceExtensionProperties( physical_device, nullptr, &extensions_count,
    nullptr )`. In the first parameter, provide the handle of a physical device available
    on a given hardware platform: the `physical_device` variable; the second and last
    parameters should be set to `nullptr`, and the third parameter should point to
    the `extensions_count` variable.'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `vkEnumerateDeviceExtensionProperties( physical_device, nullptr, &extensions_count,
    nullptr )`。在第一个参数中，提供给定硬件平台上可用的物理设备的句柄：`physical_device` 变量；第二个和最后一个参数应设置为 `nullptr`，第三个参数应指向
    `extensions_count` 变量。
- en: If a function call is successful, the `extensions_count` variable will contain
    the total number of available device-level extensions.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果函数调用成功，`extensions_count` 变量将包含所有可用的设备级扩展的总数。
- en: Prepare the storage for the list of extension properties. The best solution
    is to use a variable of type `std::vector` with elements of type `VkExtensionProperties`.
    Call it `available_extensions`.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为扩展属性列表准备存储空间。最佳方案是使用一个元素类型为 `VkExtensionProperties` 的 `std::vector` 类型的变量。将其命名为
    `available_extensions`。
- en: Resize the vector to be able to hold at least the `extensions_count` elements.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将向量的大小调整为至少可以容纳 `extensions_count` 个元素。
- en: Call `vkEnumerateDeviceExtensionProperties( physical_device, nullptr, &extensions_count,
    &available_extensions[0] )`. However, this time, replace the last parameter with
    a pointer to the first element of an array with elements of type `VkExtensionProperties`.
    This array must have enough space to contain at least `extensions_count` elements.
    Here, provide a pointer to the first element of the `available_extensions` variable.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `vkEnumerateDeviceExtensionProperties( physical_device, nullptr, &extensions_count,
    &available_extensions[0] )`。然而，这次，将最后一个参数替换为指向一个元素类型为 `VkExtensionProperties`
    的数组第一个元素的指针。这个数组必须有足够的空间来容纳至少 `extensions_count` 个元素。在这里，提供指向 `available_extensions`
    变量第一个元素的指针。
- en: If the function returns successfully, the `available_extensions` vector will
    contain a list of all extensions supported by a given physical device.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果函数调用成功，`available_extensions` 向量将包含给定物理设备支持的所有扩展的列表。
- en: How it works...
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The process of acquiring the list of supported device-level extensions can
    be divided into two stages: Firstly, we check how many extensions are supported
    by a given physical device. This is done by calling a function named `vkEnumerateDeviceExtensionProperties()`
    and setting its last parameter to `nullptr` as follows:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 获取支持设备级扩展列表的过程可以分为两个阶段：首先，我们检查给定物理设备支持多少扩展。这是通过调用名为`vkEnumerateDeviceExtensionProperties()`的函数并设置其最后一个参数为`nullptr`来完成的：
- en: '[PRE28]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Secondly, we need to prepare an array that will be able to store enough elements
    of type `VkExtensionProperties`. In the example, we create a vector variable and
    resize it so it has the `extensions_count` number of elements. In the second `vkEnumerateDeviceExtensionProperties()`
    function call, we provide an address of the first element of the `available_extensions`
    variable. When the call is successful, the variable will be filled with properties
    (names and versions) of all extensions supported by a given physical device.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们需要准备一个数组，该数组能够存储足够类型的`VkExtensionProperties`元素。在示例中，我们创建了一个向量变量，并将其调整大小，使其具有`extensions_count`数量的元素。在第二个`vkEnumerateDeviceExtensionProperties()`函数调用中，我们提供了`available_extensions`变量第一个元素的地址。当调用成功时，该变量将填充所有由给定物理设备支持的扩展的属性（名称和版本）。
- en: '[PRE29]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Once again, we can see the pattern of calling the same function twice: The
    first call (with the last parameter set to `nullptr`) informs us of the number
    of elements returned by the second call. The second call (with the last parameter
    pointing to an array of `VkExtensionProperties` elements) returns the requested
    data, in this case device extensions, which we can iterate over and check whether
    the extensions we are interested in are available on a given physical device.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们可以看到调用同一函数两次的模式：第一次调用（最后一个参数设置为`nullptr`）通知我们第二次调用返回的元素数量。第二次调用（最后一个参数指向一个`VkExtensionProperties`元素数组）返回所需的数据，在这种情况下是设备扩展，我们可以遍历并检查我们感兴趣的扩展是否在给定物理设备上可用。
- en: See also
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中以下食谱：
- en: '*Checking available Instance extensions*'
  id: totrans-350
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*检查可用的实例扩展*'
- en: '*Enumerating available physical devices*'
  id: totrans-351
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*枚举可用的物理设备*'
- en: The following recipe in [Chapter 2](45eb1180-672a-4745-bd85-f13c7bb658b7.xhtml),
    *Image Presentation:*
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下[第2章](45eb1180-672a-4745-bd85-f13c7bb658b7.xhtml)中的食谱，*图像展示：*
- en: '*Creating a logical device with WSI extensions enabled*'
  id: totrans-353
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建启用WSI扩展的逻辑设备*'
- en: Getting features and properties of a physical device
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取物理设备的特性和属性
- en: When we create a Vulkan-enabled application, it can be executed on many different
    devices. It may be a desktop computer, a notebook, or a mobile phone. Each such
    device may have a different configuration, and may contain different graphics
    hardware that provide different performance, or, more importantly, different capabilities.
    A given computer may have more than one graphics card installed. So, in order
    to find a device that suits our needs, and is able to perform operations we want
    to implement in our code, we should check not only how many devices there are,
    but also, to be able to properly choose one of them, we need to check what the
    capabilities of each device are.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个启用Vulkan的应用程序时，它可以在许多不同的设备上执行。这可能是一台台式计算机、一台笔记本电脑或一部移动电话。每种这样的设备可能具有不同的配置，并且可能包含不同的图形硬件，提供不同的性能，或者，更重要的是，不同的功能。一台计算机可能安装了多个显卡。因此，为了找到满足我们需求且能够执行我们想在代码中实现的操作的设备，我们不仅需要检查有多少设备，而且为了能够正确选择其中一个，我们还需要检查每个设备的特性。
- en: How to do it...
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Prepare the handle of the physical device returned by the `vkEnumeratePhysicalDevices()`
    function. Store it in a variable of type `VkPhysicalDevice` named `physical_device`.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备由`vkEnumeratePhysicalDevices()`函数返回的物理设备句柄。将其存储在名为`physical_device`的`VkPhysicalDevice`类型的变量中。
- en: Create a variable of type `VkPhysicalDeviceFeatures` named `device_features`.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`device_features`的`VkPhysicalDeviceFeatures`类型的变量。
- en: Create a second variable of type `VkPhysicalDeviceProperties` named `device_properties`.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`device_properties`的`VkPhysicalDeviceProperties`类型的第二个变量。
- en: To get the list of features supported by a given device ,call `vkGetPhysicalDeviceFeatures(
    physical_device, &device_features )`. Set the handle of the physical device returned
    by the
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获取给定设备的支持功能列表，调用`vkGetPhysicalDeviceFeatures( physical_device, &device_features
    )`。设置由返回的物理设备句柄。
- en: '`vkEnumeratePhysicalDevices()` function for the first parameter. The second
    parameter must point to the `device_features` variable.'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`vkEnumeratePhysicalDevices()` 函数的第一个参数。第二个参数必须指向 `device_features` 变量。'
- en: To acquire the properties of a given physical device call the `vkGetPhysicalDeviceProperties(
    physical_device, &device_properties )` function. Provide the handle of the physical
    device in the first argument. This handle must have been returned by the `vkEnumeratePhysicalDevices()`
    function. The second parameter must be a pointer to a `device_properties` variable.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获取给定物理设备的功能，请调用 `vkGetPhysicalDeviceProperties( physical_device, &device_properties
    )` 函数。在第一个参数中提供物理设备的句柄。这个句柄必须是由 `vkEnumeratePhysicalDevices()` 函数返回的。第二个参数必须是指向
    `device_properties` 变量的指针。
- en: How it works...
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Here you can find an implementation of the preceding recipe:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里你可以找到前面菜谱的实现：
- en: '[PRE30]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This code, while short and simple, gives us much information about the graphics
    hardware on which we can perform operations using the Vulkan API.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码虽然简短简单，但为我们提供了关于可以使用 Vulkan API 执行操作所依赖的图形硬件的大量信息。
- en: 'The `VkPhysicalDeviceProperties` structure contains general information about
    a given physical device. Through it, we can check the name of the device, the version
    of a driver, and a supported version of a Vulkan API. We can also check the type
    of a device: Whether it is an **integrated** device (built into a main processor)
    or a **discrete** (dedicated) graphics card, or maybe even a CPU itself. We can
    also read the limitations (limits) of a given hardware, for example, how big images
    (textures) can be created on it, how many buffers can be used in shaders, or we
    can check the upper limit of vertex attributes used during drawing operations.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '`VkPhysicalDeviceProperties` 结构体包含了关于给定物理设备的一般信息。通过它，我们可以检查设备的名称、驱动程序的版本以及支持的
    Vulkan API 版本。我们还可以检查设备的类型：它是否是一个**集成**设备（集成在主处理器中）或一个**独立**（专用）的显卡，或者甚至是一个 CPU
    本身。我们还可以读取给定硬件的限制（限制），例如，可以在其上创建多大的图像（纹理），在着色器中可以使用多少缓冲区，或者我们可以检查绘图操作期间使用的顶点属性的上限。'
- en: The `VkPhysicalDeviceFeatures` structure lists additional features that may
    be supported by the given hardware, but are not required by the core Vulkan specification.
    Features include items such as **geometry** and **tessellation** shaders, **depth
    clamp** and **bias**, **multiple viewports**, or **wide lines**. You may wonder
    why geometry and tessellation shaders are on the list. Graphics hardware has supported
    these features for many years now. However, don't forget that the Vulkan API is
    portable and can be supported on many different hardware platforms, not only high-end
    PCs, but also mobile phones or even dedicated, portable devices, which should
    be as power efficient as possible. That's why these performance-hungry features
    are not in the core specification. This allows for some driver flexibility and,
    more importantly, power efficiency and lower memory consumption.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '`VkPhysicalDeviceFeatures` 结构体列出了给定硬件可能支持但不是核心 Vulkan 规范要求的附加功能。功能包括诸如**几何**和**细分**着色器、**深度裁剪**和**偏移**、**多个视口**或**宽线**等项目。你可能想知道为什么几何和细分着色器会在列表上。图形硬件已经支持这些功能多年了。然而，不要忘记
    Vulkan API 是可移植的，并且可以在许多不同的硬件平台上得到支持，不仅限于高端 PC，还包括移动电话甚至专用、便携式设备，这些设备应该尽可能节能。这就是为什么这些性能需求高的功能不在核心规范中。这允许某些驱动程序具有灵活性，更重要的是，提高能效和降低内存消耗。'
- en: There is one additional thing you should know about the physical device features.
    Like extensions, they are not enabled by default and can't be used just like that.
    They must be implicitly enabled during the logical device creation. We can't request
    all features during this operation, because if there is any feature that is not
    supported, the logical device creation process will fail. If we are interested
    in a specific feature, we need to check if it is available and specify it during
    the creation of a logical device. If the feature is not supported, we can't use
    such a feature on this device and we need to look for another device that supports
    it.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 关于物理设备功能，还有一件额外的事情你应该知道。像扩展一样，它们默认是未启用的，不能直接使用。它们必须在逻辑设备创建期间隐式启用。我们无法在此操作中请求所有功能，因为如果存在任何不支持的功能，逻辑设备创建过程将失败。如果我们对某个特定功能感兴趣，我们需要检查它是否可用，并在创建逻辑设备时指定它。如果该功能不受支持，我们无法在此设备上使用该功能，我们需要寻找支持它的其他设备。
- en: If we want to enable all features supported by a given physical device, we just
    need to query for the available features and provide the acquired data during
    logical device creation.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想启用给定物理设备支持的所有功能，我们只需查询可用的功能，并在创建逻辑设备时提供获取的数据。
- en: See also
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Creating a logical device*'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建逻辑设备*'
- en: '*Creating a logical device with geometry shaders, graphics, and compute queues*'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建具有几何着色器、图形和计算队列的逻辑设备*'
- en: Checking available queue families and their properties
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查可用的队列家族及其属性
- en: 'In Vulkan, when we want to perform operations on hardware, we submit them to
    queues. The operations within a single queue are processed one after another,
    in the same order they were submitted--that''s why it''s called a **queue**. However,
    operations submitted to different queues are processed independently (if we need,
    we can synchronize them):'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vulkan中，当我们想在硬件上执行操作时，我们将它们提交到队列。单个队列中的操作按提交的顺序依次处理--这就是为什么它被称为**队列**。然而，提交到不同队列的操作是独立处理的（如果需要，我们可以同步它们）：
- en: '![](img/image_01_002.png)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_01_002.png)'
- en: Different queues may represent different parts of the hardware, and thus may
    support different kinds of operations. Not all operations may be performed on
    all queues.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的队列可能代表硬件的不同部分，因此可能支持不同类型的操作。并非所有操作都可以在所有队列上执行。
- en: Queues with the same capabilities are grouped into families. A device may expose
    any number of queue families, and each family may contain one or more queues.
    To check what operations can be performed on the given hardware, we need to query
    the properties of all queue families.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 具有相同能力的队列被分组到家族中。一个设备可以暴露任意数量的队列家族，每个家族可以包含一个或多个队列。为了检查可以在给定硬件上执行哪些操作，我们需要查询所有队列家族的属性。
- en: How to do it...
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Take one of the physical device handles returned by the `vkEnumeratePhysicalDevices()`
    function and store it in a variable of type `VkPhysicalDevice` called `physical_device`.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取`vkEnumeratePhysicalDevices()`函数返回的物理设备句柄之一，并将其存储在名为`physical_device`的类型为`VkPhysicalDevice`的变量中。
- en: Prepare a variable of type `uint32_t` named `queue_families_count`.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个名为`queue_families_count`的类型为`uint32_t`的变量。
- en: Call `vkGetPhysicalDeviceQueueFamilyProperties( physical_device, &queue_families_count,
    nullptr )`. Provide the handle of a physical device in the first parameter; the
    second parameter should point to the `queue_families_count` variable, and the
    final parameter should be set to `nullptr`.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`vkGetPhysicalDeviceQueueFamilyProperties( physical_device, &queue_families_count,
    nullptr )`。第一个参数提供一个物理设备的句柄；第二个参数应指向`queue_families_count`变量，最后一个参数应设置为`nullptr`。
- en: After the successful call, the `queue_families_count` variable will contain
    the number of all queue families exposed by a given physical device.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成功调用后，`queue_families_count`变量将包含由给定物理设备暴露的所有队列家族的数量。
- en: Prepare a storage for the list of queue families and their properties. A very
    convenient solution is to use a variable of type `std::vector`. Its elements must
    be of type `VkQueueFamilyProperties`. Call the variable `queue_families`.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为队列家族及其属性列表准备存储空间。一个非常方便的解决方案是使用类型为`std::vector`的变量。其元素必须是类型为`VkQueueFamilyProperties`。将变量命名为`queue_families`。
- en: Resize the vector to be able to hold at least the `queue_families_count` elements.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将向量的大小调整为至少可以容纳`queue_families_count`个元素。
- en: Call `vkGetPhysicalDeviceQueueFamilyProperties( physical_device, &queue_families_count,
    &queue_families[0] )`. The first and second argument should be the same as in
    the previous call; the last parameter should point to the first element of the `queue_families`
    vector.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`vkGetPhysicalDeviceQueueFamilyProperties( physical_device, &queue_families_count,
    &queue_families[0] )`。第一个和第二个参数应与上一个调用相同；最后一个参数应指向`queue_families`向量的第一个元素。
- en: To be sure that everything went okay, check that the `queue_families_count`
    variable is greater than zero. If successful, the properties of all queue families
    will be stored in the `queue_families` vector.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保一切顺利，请检查`queue_families_count`变量是否大于零。如果成功，所有队列家族的属性将存储在`queue_families`向量中。
- en: How it works...
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The implementation of the preceding recipe, similarly to other queries, can
    be divided into two stages: Firstly, we acquire information about the total number
    of queue families available on a given physical device. This is done by calling
    a `vkGetPhysicalDeviceQueueFamilyProperties()` function, with the last argument
    set to `nullptr`:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他查询类似，先前的食谱实现可以分为两个阶段：首先，我们获取有关给定物理设备上可用的队列家族总数的信息。这是通过调用一个 `vkGetPhysicalDeviceQueueFamilyProperties()`
    函数来完成的，最后一个参数设置为 `nullptr`：
- en: '[PRE31]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Secondly, when we know how many queue families there are, we can prepare sufficient
    memory to be able to store the properties of all of them. In the presented example,
    we create a variable of type `std::vector` with `VkQueueFamilyProperties` elements
    and resize it to the value returned by the first query. After that, we perform
    a second `vkGetPhysicalDeviceQueueFamilyProperties()` function call, with the
    last parameter pointing to the first element of the created vector. In this vector,
    the parameters of all available queue families will be stored.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，当我们知道有多少个队列家族时，我们可以准备足够的内存来存储所有这些队列家族的属性。在所提供的示例中，我们创建了一个类型为 `std::vector`
    的变量，其元素为 `VkQueueFamilyProperties`，并将其调整大小为第一次查询返回的值。之后，我们执行第二次 `vkGetPhysicalDeviceQueueFamilyProperties()`
    函数调用，最后一个参数指向创建的向量的第一个元素。在这个向量中，将存储所有可用队列家族的参数。
- en: '[PRE32]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The most important information we can get from properties is the types of operations
    that can be performed by the queues in a given family. Types of operations supported
    by queues are divided into:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从属性中获取的最重要信息是给定家族中队列可以执行的操作类型。队列支持的操作类型分为：
- en: '**Graphics**: For creating graphics pipelines and drawing'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图形**: 用于创建图形管道和绘制'
- en: '**Compute**: For creating compute pipelines and dispatching compute shaders'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计算**: 用于创建计算管道和调度计算着色器'
- en: '**Transfer**: Used for very fast memory-copying operations'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传输**: 用于非常快速的内存复制操作'
- en: '**Sparse**: Allows for additional memory management features'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**稀疏**: 允许额外的内存管理功能'
- en: Queues from the given family may support more than one type of operation. There
    may also be a situation where different queue families support exactly the same
    types of operation.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 给定家族的队列可能支持多种操作类型。也可能存在不同队列家族支持完全相同类型的操作的情况。
- en: Family properties also inform us about the number of queues that are available
    in the given family, about the timestamp support (for time measurements), and
    the granularity of image transfer operations (how small parts of image can be
    specified during copy/blit operations).
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 家族属性还告诉我们给定家族中可用的队列数量、时间戳支持（用于时间测量）以及图像传输操作的粒度（在复制/复制操作期间可以指定图像的小部分）。
- en: With the knowledge of the number of queue families, their properties, and the
    available number of queues in each family, we can prepare for logical device creation.
    All this information is needed, because we don't create queues by ourselves. We
    just request them during logical device creation, for which we must specify how
    many queues are needed and from which families. When a device is created, queues
    are created automatically along with it. We just need to acquire the handles of
    all requested queues.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 通过了解队列家族的数量、它们的属性以及每个家族中可用的队列数量，我们可以为逻辑设备创建做准备。所有这些信息都是必需的，因为我们不是自己创建队列。我们只是在逻辑设备创建期间请求它们，我们必须指定需要多少个队列以及来自哪些家族。当创建设备时，队列会自动与其一起创建。我们只需要获取所有请求队列的句柄。
- en: See also
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Selecting index of a queue family with desired capabilities*'
  id: totrans-404
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*选择具有所需功能的队列家族索引*'
- en: '*Creating a logical device*'
  id: totrans-405
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建逻辑设备*'
- en: '*Getting a device queue*'
  id: totrans-406
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*获取设备队列*'
- en: '*Creating a logical device with geometry shaders, graphics, and compute queues*'
  id: totrans-407
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用几何着色器、图形和计算队列创建逻辑设备*'
- en: 'The following recipe in [Chapter 2](45eb1180-672a-4745-bd85-f13c7bb658b7.xhtml),
    *Image Presentation*:'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第2章](45eb1180-672a-4745-bd85-f13c7bb658b7.xhtml)中的以下食谱，*图像呈现*：'
- en: '*Selecting a queue family that supports presentation to a given surface*'
  id: totrans-409
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*选择支持向给定表面呈现的队列家族*'
- en: Selecting the index of a queue family with the desired capabilities
  id: totrans-410
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择具有所需功能的队列家族索引
- en: Before we can create a logical device, we need to think about what operations
    we want to perform on it, because this will affect our choice of a queue family
    (or families) from which we want to request queues.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够创建逻辑设备之前，我们需要考虑我们想要在它上执行哪些操作，因为这会影响我们从其中请求队列的队列家族（或家族）的选择。
- en: For simple use cases, a single queue from a family that supports graphics operations
    should be enough. More advanced scenarios will require graphics and compute operations
    to be supported, or even an additional transfer queue for very fast memory copying.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的用例，一个支持图形操作的家族的单个队列应该足够。更高级的场景将需要支持图形和计算操作，或者甚至需要一个额外的传输队列以实现非常快速的内存复制。
- en: In this recipe, we will look at how to search for a queue family that supports
    the desired type of operations.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探讨如何搜索支持所需操作类型的队列家族。
- en: How to do it...
  id: totrans-414
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Take one of the physical device handles returned by the `vkEnumeratePhysicalDevices()`
    function and store it in a variable of type `VkPhysicalDevice` called `physical_device`.
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取 `vkEnumeratePhysicalDevices()` 函数返回的物理设备句柄之一，并将其存储在名为 `physical_device` 的
    `VkPhysicalDevice` 类型变量中。
- en: Prepare a variable of type `uint32_t` named `queue_family_index`. In it, we
    will store an index of a queue family that supports selected types of operations.
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个名为 `queue_family_index` 的 `uint32_t` 类型变量。我们将在此存储支持所选操作类型的队列家族的索引。
- en: Create a bit field variable of type `VkQueueFlags` named `desired_capabilities`.
    Store the desired types of operations in the `desired_capabilities` variables--it
    can be a logical `OR` operation of any of the `VK_QUEUE_GRAPHICS_BIT`, `VK_QUEUE_COMPUTE_BIT`,
    `VK_QUEUE_TRANSFER_BIT` or `VK_QUEUE_SPARSE_BINDING_BIT` values.
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `desired_capabilities` 的 `VkQueueFlags` 类型的位字段变量。将所需的操作类型存储在 `desired_capabilities`
    变量中——它可以是 `VK_QUEUE_GRAPHICS_BIT`、`VK_QUEUE_COMPUTE_BIT`、`VK_QUEUE_TRANSFER_BIT`
    或 `VK_QUEUE_SPARSE_BINDING_BIT` 中的任何一个值的逻辑“或”操作。
- en: Create a variable of type `std::vector` with `VkQueueFamilyProperties` elements
    named `queue_families`.
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `queue_families` 的 `std::vector` 类型变量，其元素为 `VkQueueFamilyProperties`。
- en: Check the number of available queue families and acquire their properties as
    described in the *Checking available queue families and their properties* recipe.
    Store the results of this operation in the `queue_families` variable.
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照在 *检查可用的队列家族及其属性* 菜谱中描述的方法检查可用的队列家族数量并获取它们的属性。将此操作的成果存储在 `queue_families`
    变量中。
- en: Loop over all elements of the `queue_families` vector using a variable of type
    `uint32_t` named `index`.
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用名为 `index` 的 `uint32_t` 类型变量遍历 `queue_families` 向量的所有元素。
- en: 'For each element of the `queue_families` variable:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 `queue_families` 变量的每个元素：
- en: Check if the number of queues (indicated by the `queueCount` member) in the
    current element is greater than zero.
  id: totrans-422
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查当前元素中的队列数量（由 `queueCount` 成员指示）是否大于零。
- en: Check if the logical `AND` operation of the `desired_capabilities` variable
    and the `queueFlags` member of the currently iterated element is not equal to
    zero.
  id: totrans-423
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查 `desired_capabilities` 变量和当前迭代元素 `queueFlags` 成员之间的逻辑“与”操作是否不等于零。
- en: If both checks are positive, store the value of an `index` variable (current
    loop iteration) in the `queue_family_index` variable, and finish iterating.
  id: totrans-424
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果两个检查都为正，将 `index` 变量（当前循环迭代）的值存储在 `queue_family_index` 变量中，并完成迭代。
- en: Repeat steps from **7.1** to **7.3** until all elements of the `queue_families`
    vector are viewed.
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复从 **7.1** 到 **7.3** 的步骤，直到查看 `queue_families` 向量的所有元素。
- en: How it works...
  id: totrans-426
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'First, we acquire the properties of queue families available on a given physical
    device. This is the operation described in the *Checking available queue families
    and their properties* recipe. We store the results of the query in the `queue_families`
    variable, which is of `std::vector` type with `VkQueueFamilyProperties` elements:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们获取给定物理设备上可用的队列家族属性。这是在 *检查可用的队列家族及其属性* 菜谱中描述的操作。我们将查询结果存储在 `queue_families`
    变量中，该变量是具有 `VkQueueFamilyProperties` 元素的 `std::vector` 类型：
- en: '[PRE33]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, we start inspecting all elements of a `queue_families` vector:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们开始检查 `queue_families` 向量的所有元素：
- en: '[PRE34]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Each element of the `queue_families` vector represents a separate queue family.
    Its `queueCount` member contains the number of queues available in a given family.
    The `queueFlags` member is a bit field, in which each bit represents a different
    type of operation. If a given bit is set, it means that the corresponding type
    of operation is supported by the given queue family. We can check for any combination
    of supported operations, but we may need to search for separate queues for every
    type of operation. This solely depends on the hardware support and the Vulkan
    API driver.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '`queue_families` 向量的每个元素代表一个单独的队列家族。其 `queueCount` 成员包含给定家族中可用的队列数量。`queueFlags`
    成员是一个位字段，其中每个位代表不同类型的操作。如果某个位被设置，则表示相应的操作类型由给定的队列家族支持。我们可以检查任何支持的组合操作，但我们可能需要为每种操作类型分别搜索单独的队列。这完全取决于硬件支持和
    Vulkan API 驱动程序。'
- en: To be sure that the data we have acquired is correct, we also check if each
    family exposes at least one queue.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们所获得的数据是正确的，我们还检查每个家族是否至少暴露一个队列。
- en: More advanced real-life scenarios would require us to store the total number
    of queues exposed in each family. This is because we may want to request more
    than one queue, but we can't request more queues than are available in a given
    family. In simple use cases, one queue from a given family is enough.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 更高级的现实场景可能需要我们存储每个家族暴露的队列总数。这是因为我们可能想要请求多个队列，但我们不能请求比给定家族中可用的队列更多的队列。在简单用例中，一个给定家族中的一个队列就足够了。
- en: See also
  id: totrans-434
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Checking available queue families and their properties*'
  id: totrans-436
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*检查可用的队列家族及其属性*'
- en: '*Creating a logical device*'
  id: totrans-437
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建逻辑设备*'
- en: '*Getting a device queue*'
  id: totrans-438
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*获取设备队列*'
- en: '*Creating a logical device with geometry shader, graphics, and compute queues*'
  id: totrans-439
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建具有几何着色器、图形和计算队列的逻辑设备*'
- en: 'The following recipe in [Chapter 2](45eb1180-672a-4745-bd85-f13c7bb658b7.xhtml),
    *Image Presentation*:'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下食谱在[第2章](45eb1180-672a-4745-bd85-f13c7bb658b7.xhtml)，*图像展示*：
- en: '*Selecting a queue family that supports the presentation to a given surface*'
  id: totrans-441
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*选择支持向给定表面展示的队列家族*'
- en: Creating a logical device
  id: totrans-442
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建逻辑设备
- en: 'The logical device is one the most important objects created in our application.
    It represents real hardware, along with all the extensions and features enabled
    for it and all the queues requested from it:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑设备是我们应用程序中创建的最重要对象之一。它代表真实硬件，以及为其启用的所有扩展和功能，以及从其请求的所有队列：
- en: '![](img/image_01_003.png)'
  id: totrans-444
  prefs: []
  type: TYPE_IMG
  zh: '![img/image_01_003.png](img/image_01_003.png)'
- en: The logical device allows us to perform almost all the work typically done in
    rendering applications, such as creating images and buffers, setting the pipeline
    state, or loading shaders. The most important ability it gives us is recording
    commands (such as issuing draw calls or dispatching computational work) and submitting
    them to queues, where they are executed and processed by the given hardware. After
    such execution, we acquire the results of the submitted operations. These can
    be a set of values calculated by compute shaders, or other data (not necessarily
    an image) generated by draw calls. All this is performed on a logical device,
    so now we will look at how to create one.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑设备使我们能够执行渲染应用程序中通常执行的所有工作，例如创建图像和缓冲区、设置管线状态或加载着色器。它赋予我们最重要的能力是记录命令（例如发出绘制调用或调度计算工作）并将它们提交到队列中，在那里它们由指定的硬件执行和处理。在执行之后，我们获取提交操作的结果。这些可以是计算着色器计算的一组值，或者由绘制调用生成的其他数据（不一定是图像）。所有这些都是在逻辑设备上执行的，因此现在我们将探讨如何创建一个。
- en: Getting ready
  id: totrans-446
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, we will use a variable of a custom structure type. The type
    is called `QueueInfo` and is defined as follows:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将使用自定义结构类型的变量。该类型称为 `QueueInfo`，其定义如下：
- en: '[PRE35]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In a variable of this type, we will store information about the queues we want
    to request for a given logical device. The data contains an index of a family
    from which we want the queues to be created, the total number of queues requested
    from this family, and the list of priorities assigned to each queue. As the number
    of priorities must be equal to the number of queues requested from a given family,
    the total number of queues we request from a given family is equal to the number
    of elements in the `Priorities` vector.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 在此类变量中，我们将存储关于我们想要请求的给定逻辑设备的队列信息。数据包含我们想要从哪个家族创建队列的索引，从这个家族请求的总队列数，以及分配给每个队列的优先级列表。由于优先级的数量必须等于从给定家族请求的队列数，因此我们从给定家族请求的总队列数等于`Priorities`向量中的元素数。
- en: How to do it...
  id: totrans-450
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Based on the features, limits, available extensions and supported types of operations,
    choose one of the physical devices acquired using the `vkEnumeratePhysicalDevices()`
    function call (refer to *Enumerating available physical devices* recipe). Take
    its handle and store it in a variable of type `VkPhysicalDevice` called `physical_device`.
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据特征、限制、可用扩展和支持的操作类型，选择使用`vkEnumeratePhysicalDevices()`函数调用获取的一个物理设备（参考*枚举可用物理设备*配方）。获取其句柄并将其存储在名为`physical_device`的`VkPhysicalDevice`类型变量中。
- en: Prepare a list of device extensions you want to enable. Store the names of the
    desired extensions in a variable of type `std::vector<char const *>` named `desired_extensions`.
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个你想启用的设备扩展列表。将所需扩展的名称存储在名为`desired_extensions`的`std::vector<char const *>`类型变量中。
- en: Create a variable of type `std::vector<VkExtensionProperties>` named `available_extensions`.
    Acquire the list of all available extensions and store it in the `available_extensions`
    variable (refer to *Checking available device extensions* recipe).
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`available_extensions`的`std::vector<VkExtensionProperties>`类型变量。获取所有可用扩展的列表并将其存储在`available_extensions`变量中（参考*检查可用设备扩展*配方）。
- en: Make sure that the name of each extension from the `desired_extensions` variable
    is also present in the `available_extensions` variable.
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保从`desired_extensions`变量中每个扩展的名称也存在于`available_extensions`变量中。
- en: Create a variable of type `VkPhysicalDeviceFeatures` named `desired_features`.
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`desired_features`的`VkPhysicalDeviceFeatures`类型的变量。
- en: Acquire a set of features supported by a physical device represented by the `physical_device`
    handle and store it in the `desired_features` variable (refer to *Getting features
    and properties of a physical device* recipe).
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取由`physical_device`句柄表示的物理设备支持的一组特征，并将其存储在`desired_features`变量中（参考*获取物理设备的特征和属性*配方）。
- en: Make sure that all the required features are supported by a given physical device
    represented by the `physical_device` variable. Do that by checking if the corresponding
    members of the acquired `desired_features` structure are set to one. Clear the
    rest of the `desired_features` structure members (set them to zero).
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保由`physical_device`变量表示的给定物理设备支持所有必需的特征。通过检查获取的`desired_features`结构中的相应成员是否设置为1来实现。清除`desired_features`结构中的其余成员（将它们设置为0）。
- en: 'Based on the properties (supported types of operations), prepare a list of
    queue families, from which queues should be requested. Prepare a number of queues
    that should be requested from each selected queue family. Assign a priority for
    each queue in a given family: A floating point value from `0.0f` to `1.0f` (multiple
    queues may have the same priority value). Create a `std::vector` variable named
    `queue_infos` with elements of a custom type `QueueInfo`. Store the indices of
    queue families and a list of priorities in the `queue_infos` vector, the size
    of `Priorities` vector should be equal to the number of queues from each family.'
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据属性（支持的操作类型），准备一个队列家族列表，从这些家族请求队列。为每个选定的队列家族准备要请求的队列数量。为给定家族中的每个队列分配一个优先级：一个从`0.0f`到`1.0f`的浮点值（多个队列可能具有相同的优先级值）。创建一个名为`queue_infos`的`std::vector`变量，其元素为自定义类型`QueueInfo`。在`queue_infos`向量中存储队列家族的索引和优先级列表，`Priorities`向量的大小应等于每个家族的队列数。
- en: 'Create a variable of type `std::vector<VkDeviceQueueCreateInfo>` named `queue_create_infos`.
    For each queue family stored in the `queue_infos` variable, add a new element
    to the `queue_create_infos` vector. Assign the following values for members of
    a new element:'
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`queue_create_infos`的`std::vector<VkDeviceQueueCreateInfo>`类型变量。对于存储在`queue_infos`变量中的每个队列家族，向`queue_create_infos`向量中添加一个新元素。为新元素分配以下值：
- en: '`VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO` value for `sType`.'
  id: totrans-460
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sType`的值为`VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO`。'
- en: '`nullptr` value for `pNext`.'
  id: totrans-461
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`pNext`的值为`nullptr`。'
- en: '`0` value for `flags`.'
  id: totrans-462
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`flags`的值为`0`。'
- en: Index of a queue family for `queueFamilyIndex`.
  id: totrans-463
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 队列家族的索引用于`queueFamilyIndex`。
- en: Number of queues requested from a given family for `queueCount`.
  id: totrans-464
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从给定家族请求的队列数量用于`queueCount`。
- en: Pointer to the first element of a list of priorities of queues from a given
    family for `pQueuePriorities`.
  id: totrans-465
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指向给定家族队列优先级列表的第一个元素的指针用于`pQueuePriorities`。
- en: 'Create a variable of type `VkDeviceCreateInfo` named `device_create_info`.
    Assign the following values for members of a `device_create_info` variable:'
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个类型为`VkDeviceCreateInfo`的变量，命名为`device_create_info`。为`device_create_info`变量的成员分配以下值：
- en: '`VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO` value for `sType`.'
  id: totrans-467
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sType`的值为`VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO`。'
- en: '`nullptr` value for `pNext`.'
  id: totrans-468
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`pNext`的值为`nullptr`。'
- en: '`0` value for `flags`.'
  id: totrans-469
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`flags`的值为`0`。'
- en: Number of elements of the `queue_create_infos` vector variable for `queueCreateInfoCount`.
  id: totrans-470
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`queue_create_infos`向量变量的元素数量用于`queueCreateInfoCount`。'
- en: Pointer to the first element of the `queue_create_infos` vector variable in
    `pQueueCreateInfos`.
  id: totrans-471
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指向`pQueueCreateInfos`中`queue_create_infos`向量变量的第一个元素的指针。
- en: '`0` value for `enabledLayerCount`.'
  id: totrans-472
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`enabledLayerCount`的值为`0`。'
- en: '`nullptr` value for `ppEnabledLayerNames`.'
  id: totrans-473
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ppEnabledLayerNames`的值为`nullptr`。'
- en: Number of elements of the `desired_extensions` vector variable in `enabledExtensionCount`.
  id: totrans-474
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`desired_extensions`向量变量的元素数量用于`enabledExtensionCount`。'
- en: Pointer to the first element of the `desired_extensions` vector variable (or
    `nullptr` if it is empty) in `ppEnabledExtensionNames`.
  id: totrans-475
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指向`ppEnabledExtensionNames`中`desired_extensions`向量变量的第一个元素（如果为空，则为`nullptr`）。
- en: Pointer to the `desired_features` variable in `pEnabledFeatures`.
  id: totrans-476
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指向`pEnabledFeatures`中`desired_features`变量的指针。
- en: Create a variable of type `VkDevice` named `logical_device`.
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个类型为`VkDevice`的变量，命名为`logical_device`。
- en: Call `vkCreateDevice( physical_device, &device_create_info, nullptr, &logical_device
    )`. Provide a handle of the physical device in the first argument, a pointer to
    the `device_create_info` variable in the second argument, a `nullptr` value in
    the third argument, and a pointer to the `logical_device` variable in the final
    argument.
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`vkCreateDevice(physical_device, &device_create_info, nullptr, &logical_device)`。在第一个参数中提供物理设备的句柄，在第二个参数中提供`device_create_info`变量的指针，在第三个参数中使用`nullptr`值，在最后一个参数中提供`logical_device`变量的指针。
- en: Make sure the operation succeeded by checking that the value returned by the
    `vkCreateDevice()` function call is equal to `VK_SUCCESS`.
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过检查`vkCreateDevice()`函数调用返回的值是否等于`VK_SUCCESS`来确保操作成功。
- en: How it works...
  id: totrans-480
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To create a logical device, we need to prepare a considerable amount of data.
    First we need to acquire the list of extensions that are supported by a given
    physical device, and then we need check that all the extensions we want to enable
    can be found in the list of supported extensions. Similar to Instance creation,
    we can''t create a logical device with extensions that are not supported. Such
    an operation will fail:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建逻辑设备，我们需要准备相当多的数据。首先，我们需要获取给定物理设备支持的扩展列表，然后我们需要检查我们想要启用的所有扩展是否都包含在支持的扩展列表中。类似于实例创建，我们不能使用不支持扩展来创建逻辑设备。这样的操作将失败：
- en: '[PRE36]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Next we prepare a vector variable named `queue_create_infos` that will contain
    information about queues and queue families we want to request for a logical device.
    Each element of this vector is of type `VkDeviceQueueCreateInfo`. The most important
    information it contains is an index of the queue family and the number of queues
    requested for that family. We can't have two elements in the vector that refer
    to the same queue family.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们准备一个名为`queue_create_infos`的向量变量，它将包含我们想要请求的逻辑设备的相关队列和队列家族信息。这个向量中的每个元素都是`VkDeviceQueueCreateInfo`类型。它包含的最重要信息是队列家族的索引和请求该家族的队列数量。向量中不能有两个元素指向同一个队列家族。
- en: 'In the `queue_create_infos` vector variable, we also provide information about
    queue priorities. Each queue in a given family may have a different priority:
    A floating-point value between `0.0f` and `1.0f`, with higher values indicating
    higher priority. This means that hardware will try to schedule operations performed
    on multiple queues based on this priority, and may assign more processing time
    to queues with higher priorities. However, this is only a hint and it is not guaranteed.
    It also doesn''t influence queues from other devices:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `queue_create_infos` 向量变量中，我们还提供了有关队列优先级的信息。给定家族中的每个队列可能具有不同的优先级：一个介于 `0.0f`
    和 `1.0f` 之间的浮点值，值越大表示优先级越高。这意味着硬件将尝试根据此优先级调度在多个队列上执行的操作，并且可能会为具有更高优先级的队列分配更多处理时间。然而，这只是一个提示，并不能保证。它也不会影响来自其他设备的队列：
- en: '[PRE37]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `queue_create_infos` vector variable is provided to another variable of
    type `VkDeviceCreateInfo`. In this variable, we store information about the number
    of different queue families from which we request queues for a logical device,
    number and names of enabled layers, and extensions we want to enable for a device,
    and also features we want to use.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '`queue_create_infos` 向量变量被提供给一个类型为 `VkDeviceCreateInfo` 的变量。在这个变量中，我们存储了有关我们请求逻辑设备队列的不同队列家族数量的信息，启用层和名称的数量，以及我们想要为设备启用的扩展，以及我们想要使用的功能。'
- en: Layers and extensions are not required for the device to work properly, but
    there are quite useful extensions, which must be enabled if we want to display
    Vulkan-generated images on screen.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 层和扩展不是设备正常工作的必需品，但有一些非常有用的扩展，如果我们想在屏幕上显示由Vulkan生成的图像，则必须启用它们。
- en: 'Features are also not necessary, as the core Vulkan API gives us plenty of
    features to be able to generate beautiful images or perform complicated calculations.
    If we don''t want to enable any feature, we can provide a `nullptr` value for
    the `pEnabledFeatures` member, or provide a variable filled with zeros. However,
    if we want to use more advanced features, such as **geometry** or **tessellation**
    shaders, we need to enable them by providing a pointer to a proper variable, previously
    acquiring the list of supported features, and making sure the ones we need are
    available. Unnecessary features can (and even should) be disabled, because there
    are some features that may impact performance. This situation is very rare, but
    it''s good to bear this in mind. In Vulkan, we should do and use only those things
    that need to be done and used:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 功能也不是必需的，因为核心Vulkan API为我们提供了足够的功能，使我们能够生成美丽的图像或执行复杂的计算。如果我们不想启用任何功能，我们可以为 `pEnabledFeatures`
    成员提供一个 `nullptr` 值，或者提供一个填充为零的变量。然而，如果我们想使用更高级的功能，例如**几何**或**细分**着色器，我们需要通过提供一个指向适当变量的指针来启用它们，之前获取支持的功能列表，并确保我们需要的那些是可用的。不必要的功能可以（甚至应该）被禁用，因为有些功能可能会影响性能。这种情况非常罕见，但最好记住这一点。在Vulkan中，我们应该只做和只使用需要做和需要使用的事情：
- en: '[PRE38]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `device_create_info` variable is provided to the `vkCreateDevice()` function,
    which creates a logical device. To be sure that the operation succeeded, we need
    to check that the value returned by the `vkCreateDevice()` function call is equal
    to `VK_SUCCESS`. If it is, the handle of a created logical device is stored in
    the variable pointed to by the final argument of the function call:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '`device_create_info` 变量被提供给 `vkCreateDevice()` 函数，该函数创建一个逻辑设备。为了确保操作成功，我们需要检查
    `vkCreateDevice()` 函数调用返回的值是否等于 `VK_SUCCESS`。如果是，创建的逻辑设备的句柄将被存储在函数调用最后一个参数所指向的变量中：'
- en: '[PRE39]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: See also
  id: totrans-492
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Enumerating available physical devices*'
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*枚举可用的物理设备*'
- en: '*Checking available device extensions*'
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*检查可用的设备扩展*'
- en: '*Getting features and properties of a physical device*'
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*获取物理设备的特性和属性*'
- en: '*Checking available queue families and their properties*'
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*检查可用的队列家族及其属性*'
- en: '*Selecting the index of a queue family with the desired capabilities*'
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*选择具有所需功能的队列家族的索引*'
- en: '*Destroying a logical device*'
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*摧毁逻辑设备*'
- en: Loading device-level functions
  id: totrans-500
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载设备级函数
- en: We have created a logical device on which we can perform any desired operations,
    such as rendering a 3D scene, calculating collisions of objects in a game, or
    processing video frames. These operations are performed with device-level functions,
    but they are not available until we acquire them.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个逻辑设备，我们可以在这个设备上执行任何所需的操作，例如渲染3D场景、计算游戏中的物体碰撞或处理视频帧。这些操作是通过设备级函数执行的，但它们在我们获取它们之前是不可用的。
- en: How to do it...
  id: totrans-502
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Take the handle of a created logical device object. Store it in a variable of
    type `VkDevice` named `logical_device`.
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取创建的逻辑设备对象的句柄。将其存储在类型为 `VkDevice` 的变量 `logical_device` 中。
- en: Choose the name (denoted as `<function name>`) of a device-level function you
    want to load.
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你想要加载的设备级函数的名称（表示为 `<function name>`）。
- en: For each device-level function that will be loaded, create a variable of type
    `PFN_<function name>` named `<function name>`.
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个将要加载的设备级功能，创建一个类型为 `PFN_<function name>` 的变量，命名为 `<function name>`。
- en: Call `vkGetDeviceProcAddr( device, "<function name>" )`, in which you provide
    the handle of created logical device in the first argument and the name of the
    function in the second argument. Cast the result of this operation onto a `PFN_<function
    name>` type and store it in a `<function name>` variable.
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `vkGetDeviceProcAddr( device, "<function name>" )`，其中你提供创建的逻辑设备句柄作为第一个参数，函数名称作为第二个参数。将此操作的结果转换为
    `PFN_<function name>` 类型，并存储在 `<function name>` 变量中。
- en: Confirm that the operation succeeded by checking that the value of a `<function
    name>` variable is not equal to `nullptr`.
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过检查 `<function name>` 变量的值是否不等于 `nullptr` 来确认操作是否成功。
- en: How it works...
  id: totrans-508
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Almost all the typical work done in 3D rendering applications is performed using
    device-level functions. They are used to create buffers, images, samplers, or
    shaders. We use device-level functions to create pipeline objects, synchronization
    primitives, framebuffers, and many other resources. And, most importantly, they
    are used to record operations that are later submitted (using device-level functions
    too) to queues, where these operations are processed by the hardware. This all
    is done with device-level functions.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有在 3D 渲染应用程序中完成的典型工作都是使用设备级函数来完成的。它们用于创建缓冲区、图像、采样器或着色器。我们使用设备级函数来创建管线对象、同步原语、帧缓冲区以及许多其他资源。最重要的是，它们用于记录随后提交（也使用设备级函数）到队列中的操作，这些操作由硬件处理。所有这些操作都是通过设备级函数完成的。
- en: 'Device-level functions, like all other Vulkan functions, can be loaded using
    the `vkGetInstanceProcAddr()` function, but this approach is not optimal. Vulkan
    is designed to be a flexible API. It gives the option to perform operations on
    multiple devices in a single application, but when we call the `vkGetInstanceProcAddr()`
    function, we can''t provide any parameter connected with the logical device. So,
    the function pointer returned by this function can''t be connected with the device
    on which we want to perform the given operation. This device may not even exist
    at the time the `vkGetInstanceProcAddr()` function is called. That''s why the
    `vkGetInstanceProcAddr()` function returns a dispatch function which, based on
    its arguments, calls the implementation of a function, that is proper for a given
    logical device. However, this jump has a performance cost: It''s very small, but
    it nevertheless takes some processor time to call the right function.'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 设备级函数，就像所有其他 Vulkan 函数一样，可以使用 `vkGetInstanceProcAddr()` 函数来加载，但这种方法并不理想。Vulkan
    被设计成一个灵活的 API。它提供了在单个应用程序中执行多个设备操作的选择，但当我们调用 `vkGetInstanceProcAddr()` 函数时，我们不能提供与逻辑设备相关的任何参数。因此，该函数返回的函数指针无法与我们要在其实际执行给定操作的设备相关联。这个设备在调用
    `vkGetInstanceProcAddr()` 函数时可能甚至不存在。这就是为什么 `vkGetInstanceProcAddr()` 函数返回一个调度函数，该函数根据其参数调用适合给定逻辑设备的函数实现。然而，这种跳跃有性能成本：它非常小，但仍然需要一些处理器时间来调用正确的函数。
- en: 'If we want to avoid this unnecessary jump and acquire function pointers corresponding
    directly to a given device, we should do that by using a `vkGetDeviceProcAddr()`.
    This way, we can avoid the intermediate function call and improve the performance
    of our application. Such an approach also has some drawbacks: We need to acquire
    function pointers for each device created in an application. If we want to perform
    operations on many different devices, we need a separate list of function pointers
    for each logical device. We can''t use functions acquired from one device  to
    perform operations on a different device. But using C++ language''s preprocessor,
    it is quite easy to acquire function pointers specific to a given device:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要避免这种不必要的跳跃并获取直接对应于给定设备的函数指针，我们应该通过使用 `vkGetDeviceProcAddr()` 来实现。这样，我们可以避免中间函数调用并提高我们应用程序的性能。这种做法也有一些缺点：我们需要为应用程序中创建的每个设备获取函数指针。如果我们想在许多不同的设备上执行操作，我们需要为每个逻辑设备准备一个单独的函数指针列表。我们不能使用从一个设备获取的函数在另一个设备上执行操作。但是，使用
    C++ 语言的预处理器，获取特定于给定设备的函数指针相当容易：
- en: '![](img/image_01_004.png)'
  id: totrans-512
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_01_004.png)'
- en: How do we know if a function is from the device-level and not from the global
    or instance-level? The first argument of device-level functions is of type `VkDevice`,
    `VkQueue`, or `VkCommandBuffer`. Most of the functions that will be introduced
    from now on are from the device level.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何知道一个函数来自设备级别而不是全局或实例级别？设备级别函数的第一个参数是 `VkDevice`、`VkQueue` 或 `VkCommandBuffer`
    类型。从现在开始介绍的大部分函数都属于设备级别。
- en: 'To load device-level functions, we should update the `ListOfVulkanFunctions.inl`
    file as follows:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载设备级别函数，我们应该按照以下方式更新 `ListOfVulkanFunctions.inl` 文件：
- en: '[PRE40]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the preceding code, we added, names of multiple device-level functions. Each
    of them is wrapped into a `DEVICE_LEVEL_VULKAN_FUNCTION` macro (if it is defined
    in the core API) or a `DEVICE_LEVEL_VULKAN_FUNCTION_FROM_EXTENSION` macro (if
    it is introduced by an extension), and is placed between proper `#ifndef` and
    `#undef` preprocessor directives. The list is, of course, incomplete, as there
    are too many functions to present them all here.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们添加了多个设备级别函数的名称。每个函数都被 `DEVICE_LEVEL_VULKAN_FUNCTION` 宏（如果它在核心 API
    中定义）或 `DEVICE_LEVEL_VULKAN_FUNCTION_FROM_EXTENSION` 宏（如果它由扩展引入）包装，并放置在适当的 `#ifndef`
    和 `#undef` 预处理器指令之间。当然，这个列表是不完整的，因为函数太多，无法在这里全部展示。
- en: Remember that we shouldn't load functions introduced by a given extension without
    first enabling the extension during the logical device creation. If an extension
    is not supported, its functions are not available and the operation of loading
    them will fail. That's why, similarly to loading instance-level functions, we
    need to divide function-loading code into two blocks.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们不应该在没有首先在逻辑设备创建期间启用扩展的情况下加载由给定扩展引入的函数。如果扩展不受支持，其函数不可用，加载它们的操作将失败。这就是为什么，类似于加载实例级别函数，我们需要将函数加载代码分成两个块。
- en: 'First, to implement the device-level core API functions loading using the preceding
    macros, we should write the following code:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为了使用前面的宏实现设备级别核心 API 函数的加载，我们应该编写以下代码：
- en: '[PRE41]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In this code sample, we create a macro that, for each occurrence of a `DEVICE_LEVEL_VULKAN_FUNCTION()`
    definition found in the `ListOfVulkanFunctions.inl` file, calls a `vkGetDeviceProcAddr()`
    function and provides the name of a procedure we want to load. The result of this
    operation is cast onto an appropriate type and stored in a variable with exactly
    the same name as the name of the acquired function. Upon failure, any additional
    information is displayed on screen.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码示例中，我们创建了一个宏，该宏对于在 `ListOfVulkanFunctions.inl` 文件中找到的每个 `DEVICE_LEVEL_VULKAN_FUNCTION()`
    定义，调用 `vkGetDeviceProcAddr()` 函数，并提供我们想要加载的过程名称。此操作的结果被转换为适当的数据类型，并存储在一个与获取到的函数名称完全相同的变量中。如果失败，任何附加信息都会显示在屏幕上。
- en: 'Next, we need to load functions introduced by extensions. These extensions
    must have been enabled during logical device creation:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要加载由扩展引入的函数。这些扩展必须在逻辑设备创建期间已启用：
- en: '[PRE42]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the preceding code, we define the macro which iterates over all enabled extensions.
    They are defined in a variable of type `std::vector<char const *>` named `enabled_extensions`.
    In each loop iteration, the name of the enabled extension from the vector is compared
    with the name of an extension specified for a given function. If they match, the
    function pointer is loaded; if not, the given function is skipped as we can't
    load functions from un-enabled extensions.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义了一个宏，该宏遍历所有启用的扩展。它们定义在一个名为 `enabled_extensions` 的 `std::vector<char
    const*>` 类型的变量中。在每次循环迭代中，从向量中比较启用的扩展名称与为给定函数指定的扩展名称。如果它们匹配，则加载函数指针；如果不匹配，则跳过给定的函数，因为我们无法从未启用的扩展中加载函数。
- en: See also
  id: totrans-524
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Preparing for loading Vulkan API functions*'
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*准备加载 Vulkan API 函数*'
- en: '*Loading function exported from a Vulkan Loader library*'
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*加载从 Vulkan 加载库导出的函数*'
- en: '*Loading global-level functions*'
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*加载全局级别的函数*'
- en: '*Loading instance-level functions*'
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*加载实例级别的函数*'
- en: Getting a device queue
  id: totrans-530
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取设备队列
- en: 'In Vulkan, in order to harness the processing power of a given device, we need
    to submit operations to the device''s queues. Queues are not created explicitly
    by an application. They are requested during device creation: We check what families
    are available and how many queues each family contains. We can ask only for the
    subset of available queues from existing queue families, and we can''t request
    more queues than the given family exposes.'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vulkan 中，为了利用给定设备的处理能力，我们需要向设备的队列提交操作。队列不是由应用程序显式创建的。它们在设备创建期间请求：我们检查哪些族可用以及每个族包含多少队列。我们只能请求现有队列族中可用队列的子集，并且我们不能请求比给定族公开的队列更多的队列。
- en: Requested queues are created automatically along with the logical device. We
    don't manage them and create them explicitly. We can't destroy them either; they
    are also destroyed with a logical device. To use them and to be able to submit
    any work to the device's queues, we just need to acquire their handles.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 请求的队列将与逻辑设备自动创建。我们不需要管理它们，也不需要显式创建它们。我们也不能销毁它们；它们也会与逻辑设备一起销毁。为了使用它们并能够向设备的队列提交任何工作，我们只需要获取它们的句柄。
- en: How to do it...
  id: totrans-533
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Take the handle of a created logical device object. Store it in a variable of
    type `VkDevice` named `logical_device`.
  id: totrans-534
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取创建的逻辑设备对象的句柄。将其存储在名为 `logical_device` 的 `VkDevice` 类型变量中。
- en: Take the index of one of the queue families that was provided during the logical
    device creation in a `queueFamilyIndex` member of a structure of type `VkDeviceQueueCreateInfo`.
    Store it in a variable of type `uint32_t` named `queue_family_index`.
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `VkDeviceQueueCreateInfo` 结构的 `queueFamilyIndex` 成员中获取在逻辑设备创建期间提供的队列族索引。将其存储在名为
    `queue_family_index` 的 `uint32_t` 类型变量中。
- en: 'Take the index of one of the queues requested for a given queue family: The
    index must be smaller than the total number of queues requested for a given family
    in a `queueCount` member of the `VkDeviceQueueCreateInfo` structure. Store the
    index in a variable of type `uint32_t` named `queue_index`.'
  id: totrans-536
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取请求的队列族中的一个队列的索引：该索引必须小于 `VkDeviceQueueCreateInfo` 结构的 `queueCount` 成员中请求的给定族的总队列数。将索引存储在名为
    `queue_index` 的 `uint32_t` 类型变量中。
- en: Prepare a variable of type `VkQueue` named `queue`.
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个名为 `queue` 的 `VkQueue` 类型变量。
- en: Call `vkGetDeviceQueue( logical_device, queue_family_index, queue_index, &queue
    )`. Provide a handle to the created logical device in the first argument; the
    second argument must be equal to the selected queue family index; the third argument
    must contain a number of one of the queues requested for a given family; then,
    in the final parameter, provide a pointer to the `queue` variable. A handle to
    the device queue will be stored in this variable.
  id: totrans-538
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `vkGetDeviceQueue(logical_device, queue_family_index, queue_index, &queue)`。在第一个参数中提供创建的逻辑设备的句柄；第二个参数必须等于所选的队列族索引；第三个参数必须包含请求给定族中的一个队列的数量；然后，在最后一个参数中提供一个指向
    `queue` 变量的指针。设备队列的句柄将存储在这个变量中。
- en: Repeat steps 2 to 5 for all queues requested from all queue families.
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对所有请求的所有队列族重复步骤 2 到 5。
- en: How it works...
  id: totrans-540
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Code that acquires the handle of a given queue is very simple:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 获取给定队列句柄的代码非常简单：
- en: '[PRE43]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We provide a handle to the created logical device, an index of the queue family,
    and an index of the queue requested for a given family. We must provide one of
    the family indices that were provided during logical device creation. This means
    that we can't acquire the handle of a queue from a family that wasn't specified
    during the logical device creation. Similarly, we can only provide an index of
    a queue that is smaller than the total number of queues requested from a given
    family.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供创建的逻辑设备的句柄、队列族的索引以及请求给定族中的队列索引。我们必须提供一个在逻辑设备创建期间提供的族索引之一。这意味着我们不能从在逻辑设备创建期间未指定的族中获取队列的句柄。同样，我们只能提供一个小于给定族请求的队列总数的队列索引。
- en: 'Let''s imagine the following situation: A given physical device supports five
    queues in the queue family No. 3\. During logical device creation, we request
    only two queues from this queue family No. 3\. So here, when we call the `vkGetDeviceQueue()`
    function, we must provide the value 3 as the queue family index. For the queue
    index, we can provide only values 0 and 1.'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象以下情况：一个给定的物理设备在队列族 No. 3 中支持五个队列。在创建逻辑设备期间，我们只从这个队列族 No. 3 中请求两个队列。因此，当我们调用
    `vkGetDeviceQueue()` 函数时，我们必须提供值 3 作为队列族索引。对于队列索引，我们只能提供 0 和 1 的值。
- en: The handle of the requested queue is stored in a variable to which we provide
    a pointer in the final argument of the `vkGetDeviceQueue()` function call. We
    can ask for a handle of the same queue multiple times. This call doesn't create
    queues--they are created implicitly during logical device creation. Here, we just
    ask for the handle of an existing queue, so we can do it multiple times (although
    it may not make much sense to do so).
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 请求的队列句柄存储在一个变量中，我们在`vkGetDeviceQueue()`函数调用的最后一个参数中提供这个变量的指针。我们可以多次请求同一个队列的句柄。这个调用不会创建队列——它们在逻辑设备创建过程中隐式创建。在这里，我们只是请求一个现有队列的句柄，因此我们可以多次这样做（尽管这样做可能没有太多意义）。
- en: See also
  id: totrans-546
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下配方：
- en: '*Checking available queue families and their properties*'
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*检查可用的队列家族及其属性*'
- en: '*Selecting the index of a queue family with the desired capabilities*'
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*选择具有所需功能的队列家族索引*'
- en: '*Creating a logical device*'
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建逻辑设备*'
- en: '*Creating a logical device with geometry shaders, graphics, and compute queues*'
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建具有几何着色器、图形和计算队列的逻辑设备*'
- en: Creating a logical device with geometry shaders, graphics, and compute queues
  id: totrans-552
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建具有几何着色器、图形和计算队列的逻辑设备
- en: In Vulkan, when we create various objects, we need to prepare many different
    structures that describe the creation process itself, but they may also require
    other objects to be created.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vulkan中，当我们创建各种对象时，我们需要准备许多不同的结构来描述创建过程本身，但它们可能还需要创建其他对象。
- en: 'A logical device is no different: We need to enumerate physical devices, check
    their properties and supported queue families, and prepare a `VkDeviceCreateInfo`
    structure that requires much more information.'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑设备也不例外：我们需要枚举物理设备，检查它们的属性和受支持的队列家族，并准备一个需要更多信息的`VkDeviceCreateInfo`结构。
- en: To organize these operations, we will present a sample recipe that creates a
    logical device from one of the available physical devices that support geometry
    shaders, and both graphics and compute queues.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 为了组织这些操作，我们将展示一个示例配方，它从一个支持几何着色器和图形以及计算队列的可用物理设备中创建一个逻辑设备。
- en: How to do it...
  id: totrans-556
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Prepare a variable of type `VkDevice` named `logical_device`.
  id: totrans-557
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个名为`logical_device`的`VkDevice`类型的变量。
- en: Create two variables of type `VkQueue`, one named `graphics_queue` and one named
    `compute_queue`.
  id: totrans-558
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个名为`graphics_queue`和`compute_queue`的`VkQueue`类型的变量。
- en: Create a variable of type `std::vector<VkPhysicalDevice>` named `physical_devices`.
  id: totrans-559
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`physical_devices`的`std::vector<VkPhysicalDevice>`类型的变量。
- en: Get the list of all physical devices available on a given platform and store
    it in the `physical_devices` vector (refer to the *Enumerating available physical
    devices* recipe).
  id: totrans-560
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取给定平台上所有可用物理设备的列表并将其存储在`physical_devices`向量中（参考*枚举可用物理设备*配方）。
- en: 'For each physical device from the `physical_devices` vector:'
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`physical_devices`向量中的每个物理设备：
- en: Create a variable of type `VkPhysicalDeviceFeatures` named `device_features`.
  id: totrans-562
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`device_features`的`VkPhysicalDeviceFeatures`类型的变量。
- en: Acquire the list of features supported by a given physical device and store
    it in the `device_features` variable.
  id: totrans-563
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取给定物理设备支持的特性的列表并将其存储在`device_features`变量中。
- en: Check whether the `geometryShader` member of the `device_features` variable
    is equal to `VK_TRUE` (is not `0`). If it is, reset all the other members of the `device_features`
    variable (set their values to zero); if it is not, start again with another physical
    device.
  id: totrans-564
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`device_features`变量的`geometryShader`成员是否等于`VK_TRUE`（不是`0`）。如果是，则重置`device_features`变量的所有其他成员（将它们的值设置为零）；如果不是，则从另一个物理设备重新开始。
- en: Create two variables of type `uint32_t` named `graphics_queue_family_index`
    and `compute_queue_family_index`.
  id: totrans-565
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个名为`graphics_queue_family_index`和`compute_queue_family_index`的`uint32_t`类型的变量。
- en: Acquire indices of queue families that support graphics and compute operations,
    and store them in the `graphics_queue_family_index` and `compute_queue_family_index`
    variables, respectively (refer to the *Selecting index of a queue family with
    desired capabilities* recipe). If any of these operations is not supported, search
    for another physical device.
  id: totrans-566
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取支持图形和计算操作的队列家族的索引，并将它们分别存储在`graphics_queue_family_index`和`compute_queue_family_index`变量中（参考*选择具有所需功能的队列家族索引*配方）。如果这些操作中的任何一个不受支持，则寻找另一个物理设备。
- en: Create a variable of type `std::vector` with elements of type `QueueInfo` (refer
    to *Creating a logical device* recipe). Name this variable `requested_queues`.
  id: totrans-567
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含`QueueInfo`类型元素的`std::vector`变量（参考*创建逻辑设备*配方）。将此变量命名为`requested_queues`。
- en: Store the `graphics_queue_family_index` variable and one-element vector of `floats`
    with a `1.0f` value in the `requested_queues` variable. If a value of the `compute_queue_family_index`
    variable is different than the value of the `graphics_queue_family_index` variable,
    add another element to the `requested_queues` vector, with the `compute_queue_family_index`
    variable and a one-element vector of `floats` with `1.0f` value.
  id: totrans-568
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`graphics_queue_family_index`变量和一个包含`1.0f`值的单元素`floats`向量存储在`requested_queues`变量中。如果`compute_queue_family_index`变量的值与`graphics_queue_family_index`变量的值不同，则向`requested_queues`向量添加另一个元素，包含`compute_queue_family_index`变量和一个包含`1.0f`值的单元素`floats`向量。
- en: Create a logical device using the `physical_device`, `requested_queues`, `device_features`
    and `logical_device` variables (refer to the *Creating a logical device* recipe).
    If this operation failed, repeat the preceding operations with another physical
    device.
  id: totrans-569
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`physical_device`、`requested_queues`、`device_features`和`logical_device`变量创建一个逻辑设备（参考*创建逻辑设备*配方）。如果此操作失败，请使用另一个物理设备重复前面的操作。
- en: If the logical device was successfully created, load the device-level functions
    (refer to the *Loading device-level functions* recipe). Get the handle of the
    queue from the `graphics_queue_family_index` family and store it in the `graphics_queue`
    variable. Get the queue from the `compute_queue_family_index` family and store
    it in the `compute_queue` variable.
  id: totrans-570
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果逻辑设备创建成功，加载设备级别的函数（参考*加载设备级别的函数*配方）。从`graphics_queue_family_index`家族获取队列句柄并将其存储在`graphics_queue`变量中。从`compute_queue_family_index`家族获取队列并将其存储在`compute_queue`变量中。
- en: How it works...
  id: totrans-571
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To start the process of creating a logical device, we need to acquire the handles
    of all physical devices available on a given computer:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始创建逻辑设备的流程，我们需要获取给定计算机上所有可用物理设备的句柄：
- en: '[PRE44]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Next we need to loop through all available physical devices. For each such
    device, we need to acquire its features. This will give us the information about
    whether a given physical device supports geometry shaders:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要遍历所有可用的物理设备。对于每个这样的设备，我们需要获取其特性。这将告诉我们给定的物理设备是否支持几何着色器：
- en: '[PRE45]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: If geometry shaders are supported, we can reset all the other members of a returned
    list of features. We will provide this list during the logical device creation,
    but we don't want to enable any other feature. In this example, geometry shaders
    are the only additional feature we want to use.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 如果支持几何着色器，我们可以重置返回的特征列表中的所有其他成员。我们将在创建逻辑设备时提供此列表，但我们不想启用任何其他功能。在这个例子中，几何着色器是我们想要使用的唯一附加功能。
- en: 'Next we need to check if a given physical device exposes queue families that
    support graphics and compute operations. This may be just one single family or
    two separate families. We acquire the indices of such queue families:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要检查给定的物理设备是否公开支持图形和计算操作的队列家族。这可能是一个单一的家族或两个不同的家族。我们获取此类队列家族的索引：
- en: '[PRE46]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Next, we need to prepare a list of queue families, from which we want to request
    queues. We also need to assign priorities to each queue from each family:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要准备一个队列家族列表，从中我们想要请求队列。我们还需要为每个家族中的每个队列分配优先级：
- en: '[PRE47]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If graphics and compute queue families have the same index, we request only
    one queue from one queue family. If they are different, we need to request two
    queues: One from the graphics family and one from the compute family.'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 如果图形和计算队列家族具有相同的索引，我们只从一个队列家族请求一个队列。如果它们不同，我们需要请求两个队列：一个来自图形家族，一个来自计算家族。
- en: 'We are ready to create a logical device for which we provide the prepared data.
    Upon success, we can the load device-level functions and acquire the handles of
    the requested queues:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备创建一个逻辑设备，并为它提供准备好的数据。成功后，我们可以加载设备级别的函数并获取请求队列的句柄：
- en: '[PRE48]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: See also
  id: totrans-584
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下配方：
- en: '*Enumerating available physical devices*'
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*枚举可用的物理设备*'
- en: '*Getting features and properties of a physical device*'
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*获取物理设备的特性和属性*'
- en: '*Selecting the index of a queue family with the desired capabilities*'
  id: totrans-588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*选择具有所需功能的队列家族索引*'
- en: '*Creating a logical device*'
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建逻辑设备*'
- en: '*Loading device-level functions*'
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*加载设备级别的函数*'
- en: '*Getting a device queue*'
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*获取设备队列*'
- en: '*Destroying a logical device*'
  id: totrans-592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*销毁逻辑设备*'
- en: Destroying a logical device
  id: totrans-593
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 销毁逻辑设备
- en: After we have finished and we want to quit the application, we should clean
    up after ourselves. Despite the fact that all the resources should be destroyed
    automatically by the driver when the Vulkan Instance is destroyed, we should also
    do this explicitly in the application to follow good programming guidelines. The
    order of destroying resources should be opposite to the order in which they were
    created.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成之后并想要退出应用程序时，我们应该清理我们的工作。尽管在销毁 Vulkan 实例时，所有资源应该由驱动程序自动销毁，但我们也应该在应用程序中显式地这样做，以遵循良好的编程指南。销毁资源的顺序应该与它们创建的顺序相反。
- en: Resources should be released in the reverse order to the order of their creation.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 资源应该按照它们创建的相反顺序释放。
- en: In this chapter, the logical device was the last created object, so it will
    be destroyed first.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，逻辑设备是最后创建的对象，因此它将首先被销毁。
- en: How to do it...
  id: totrans-597
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Take the handle of the logical device that was created and stored in a variable
    of type `VkDevice` named `logical_device`.
  id: totrans-598
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取存储在名为 `logical_device` 的 `VkDevice` 类型变量中的逻辑设备句柄。
- en: Call `vkDestroyDevice( logical_device, nullptr )`; provide the `logical_device`
    variable in the first argument, and a `nullptr` value in the second.
  id: totrans-599
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `vkDestroyDevice( logical_device, nullptr )`; 在第一个参数中提供 `logical_device`
    变量，在第二个参数中提供一个 `nullptr` 值。
- en: For safety reasons, assign the `VK_NULL_HANDLE` value to the `logical_device`
    variable.
  id: totrans-600
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了安全起见，将 `VK_NULL_HANDLE` 值赋给 `logical_device` 变量。
- en: How it works...
  id: totrans-601
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The implementation of the logical device-destroying recipe is very straightforward:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 实现逻辑设备销毁的步骤非常直接：
- en: '[PRE49]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: First, we need to check if the logical device handle is valid, because, we shouldn't
    destroy objects that weren't created. Then, we destroy the device with the `vkDestroyDevice()`
    function call and we assign the `VK_NULL_HANDLE` value to the variable in which
    the logical device handle was stored. We do this just in case--if there is a mistake
    in our code, we won't destroy the same object twice.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要检查逻辑设备句柄是否有效，因为我们不应该销毁尚未创建的对象。然后，我们使用 `vkDestroyDevice()` 函数调用销毁设备，并将
    `VK_NULL_HANDLE` 值赋给存储逻辑设备句柄的变量。我们这样做是为了以防万一——如果我们的代码中存在错误，我们不会两次销毁同一个对象。
- en: Remember that, when we destroy a logical device, we can't use device-level functions
    acquired from it.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当我们销毁逻辑设备时，我们不能使用从它获得的设备级函数。
- en: See also
  id: totrans-606
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The recipe *Creating a logical device* in this chapter
  id: totrans-607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*创建逻辑设备*步骤
- en: Destroying a Vulkan Instance
  id: totrans-608
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 销毁 Vulkan 实例
- en: After all the other resources are destroyed, we can destroy the Vulkan Instance.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 在销毁所有其他资源之后，我们可以销毁 Vulkan 实例。
- en: How to do it...
  id: totrans-610
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Take the handle of the created Vulkan Instance object stored in a variable of
    type `VkInstance` named `instance`.
  id: totrans-611
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取存储在名为 `instance` 的 `VkInstance` 类型变量中的已创建 Vulkan 实例对象的句柄。
- en: Call `vkDestroyInstance( instance, nullptr )`, provide the `instance` variable
    as the first argument and a `nullptr` value as the second argument.
  id: totrans-612
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `vkDestroyInstance( instance, nullptr )`，将 `instance` 变量作为第一个参数，将 `nullptr`
    值作为第二个参数。
- en: For safety reasons, assign the `VK_NULL_HANDLE` value to the `instance` variable.
  id: totrans-613
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了安全起见，将 `VK_NULL_HANDLE` 值赋给 `instance` 变量。
- en: How it works...
  id: totrans-614
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Before we close the application, we should make sure that all the created resources
    are released. The Vulkan Instance is destroyed with the following code:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们关闭应用程序之前，我们应该确保所有创建的资源都已释放。以下代码销毁 Vulkan 实例：
- en: '[PRE50]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: See also
  id: totrans-617
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The recipe *Creating a Vulkan Instance* in this chapter
  id: totrans-618
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*创建 Vulkan 实例*步骤
- en: Releasing a Vulkan Loader library
  id: totrans-619
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布 Vulkan 加载器库
- en: Libraries that are loaded dynamically must be explicitly closed (released).
    To be able to use Vulkan in our application, we opened the Vulkan Loader (a `vulkan-1.dll`
    library on Windows, or `libvulkan.so.1` library on Linux). So, before we can close
    the application, we should free it.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 动态加载的库必须显式关闭（释放）。为了能够在我们的应用程序中使用 Vulkan，我们打开了 Vulkan 加载器（Windows 上的 `vulkan-1.dll`
    库，或 Linux 上的 `libvulkan.so.1` 库）。因此，在我们关闭应用程序之前，我们应该释放它。
- en: How to do it...
  id: totrans-621
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'On the Windows operating system family:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 操作系统系列中：
- en: Take the variable of type `HMODULE` named `vulkan_library`, in which the handle
    of a loaded Vulkan Loader was stored (refer to the *Connecting with a Vulkan Loader
    library* recipe).
  id: totrans-623
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取存储在名为 `vulkan_library` 的 `HMODULE` 类型变量中的已加载 Vulkan 加载器句柄（参见*连接到 Vulkan 加载器库*步骤）。
- en: Call `FreeLibrary( vulkan_library )` and provide the `vulkan_library` variable
    in the only argument.
  id: totrans-624
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `FreeLibrary( vulkan_library )` 并提供 `vulkan_library` 变量作为唯一参数。
- en: For safety reasons, assign the `nullptr` value to the `vulkan_library` variable.
  id: totrans-625
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了安全起见，将 `nullptr` 值分配给 `vulkan_library` 变量。
- en: 'On the Linux operating system family:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 操作系统家族中：
- en: Take the variable of type `void*` named `vulkan_library` in which the handle
    of a loaded Vulkan Loader was stored (refer to *Connecting with a Vulkan Loader
    library* recipe).
  id: totrans-627
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用名为 `vulkan_library` 的 `void*` 类型的变量，其中存储了已加载的 Vulkan Loader 的句柄（参考 *连接到 Vulkan
    Loader 库* 菜谱）。
- en: Call `dlclose( vulkan_library )`, provide the `vulkan_library` variable in the
    only argument.
  id: totrans-628
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `dlclose( vulkan_library )`，将 `vulkan_library` 变量作为唯一参数提供。
- en: For safety reasons, assign the `nullptr` value to the `vulkan_library` variable.
  id: totrans-629
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了安全起见，将 `nullptr` 值分配给 `vulkan_library` 变量。
- en: How it works...
  id: totrans-630
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: On the Windows operating system family, dynamic libraries are opened using the `LoadLibrary()`
    function. Such libraries must be closed (released) by calling the `FreeLibrary()`
    function to which the handle of a previously opened library must be provided.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 操作系统家族中，使用 `LoadLibrary()` 函数打开动态库。这些库必须通过调用 `FreeLibrary()` 函数来关闭（释放），其中必须提供先前打开的库的句柄。
- en: 'On the Linux operating system family, dynamic libraries are opened using the `dlopen()`
    function. Such libraries must be closed (released) by calling the `dlclose()`
    function, to which the handle of a previously opened library must be provided:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 操作系统家族中，使用 `dlopen()` 函数打开动态库。这些库必须通过调用 `dlclose()` 函数来关闭（释放），其中必须提供先前打开的库的句柄：
- en: '[PRE51]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: See also
  id: totrans-634
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The recipe *Connecting with a Vulkan Loader library* in this chapter
  id: totrans-635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的菜谱 *连接到 Vulkan Loader 库*
