<html><head></head><body>
		<div><h1 id="_idParaDest-135"><a id="_idTextAnchor138"/><em class="italic">Chapter 5</em>: Collisions, Sound, and End Conditions – Making the Game Playable</h1>
			<p>This is the final phase of the first project. By the end of this chapter, you will have your first completed game. Once you have Timber!!! up and running, be sure to read the last section of this chapter as it will suggest ways to make the game better.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Adding the rest of the sprites</li>
				<li>Handling the player input</li>
				<li>Animating the flying log</li>
				<li>Handling death</li>
				<li>Adding sound effects</li>
				<li>Adding features and improving Timber!!!</li>
			</ul>
			<h1 id="_idParaDest-136"><a id="_idTextAnchor139"/>Preparing the player (and other sprites)</h1>
			<p>Let's add the code for the player's sprite as well as a few more sprites and textures at the same time. The following, quite large, block of code also adds a gravestone sprite for when the player gets squashed, an axe sprite to chop with, and a log sprite that can whiz away each time the player chops.</p>
			<p>Notice that, after the <code>spritePlayer</code> object, we declare a <code>side</code> variable, <code>playerSide</code>, to keep track of where the player is currently standing. Furthermore, we add some extra variables for the <code>spriteLog </code>object, including <code>logSpeedX</code>, <code>logSpeedY</code>, and <code>logActive</code>, to store how fast the log will move and whether it is currently moving. The <code>spriteAxe</code> also has two related <code>float</code> constant variables to remember where the ideal pixel position is on both the left and the right.</p>
			<p>Add the following block of code just before the <code>while(window.isOpen())</code> code, like we have done so often before. Note that all of the code in the following block is new, not just the highlighted code. I haven't provided any extra context for this block of code as the <code>while(window.isOpen())</code> should be easy to identify. The highlighted code is the code we have just discussed.</p>
			<p>Add the entirety of the following code, just before the <code>while(window.isOpen())</code> line, and make a mental note of the highlighted lines we briefly discussed. It will make the rest of this chapter's code easier to understand:</p>
			<pre>// Prepare the player
Texture texturePlayer;
texturePlayer.loadFromFile("graphics/player.png");
Sprite spritePlayer;
spritePlayer.setTexture(texturePlayer);
spritePlayer.setPosition(580, 720);
<strong class="bold">// The player starts on the left</strong>
<strong class="bold">side playerSide = side::LEFT;</strong>
// Prepare the gravestone
Texture textureRIP;
textureRIP.loadFromFile("graphics/rip.png");
Sprite spriteRIP;
spriteRIP.setTexture(textureRIP);
spriteRIP.setPosition(600, 860);
// Prepare the axe
Texture textureAxe;
textureAxe.loadFromFile("graphics/axe.png");
Sprite spriteAxe;
spriteAxe.setTexture(textureAxe);
spriteAxe.setPosition(700, 830);
<strong class="bold">// Line the axe up with the tree</strong>
<strong class="bold">const float AXE_POSITION_LEFT = 700;</strong>
<strong class="bold">const float AXE_POSITION_RIGHT = 1075;</strong>
// Prepare the flying log
Texture textureLog;
textureLog.loadFromFile("graphics/log.png");
Sprite spriteLog;
spriteLog.setTexture(textureLog);
spriteLog.setPosition(810, 720);
<strong class="bold">// Some other useful log related variables</strong>
<strong class="bold">bool logActive = false;</strong>
<strong class="bold">float logSpeedX = 1000;</strong>
<strong class="bold">float logSpeedY = -1500;</strong></pre>
			<p>In the preceding code, we added quite a few new variables. They are hard to explain in full until we get to where we actually use them, but here is an overview of what they will be used for. There is a variable of the <code>side</code> enumeration type called <code>playerSide</code> that is initialized to <code>left</code>. This will track which side of the tree the player is on. </p>
			<p>There are two <code>const float</code> values that determine the horizontal position the axe will be drawn at, depending on whether the player is on the left-or right-hand side of the tree.</p>
			<p>There are also three variables to help to keep control of the log as it is chopped and flies off of the tree, <code>bool</code> to determine whether the log is in motion (<code>logActive</code>) and two <code>float</code> values to hold the horizontal and vertical speeds of the log.</p>
			<p>Now, we can draw all of our new sprites.</p>
			<h1 id="_idParaDest-137"><a id="_idTextAnchor140"/>Drawing the player and other sprites</h1>
			<p>Before we add the code to move the player and use all of our new sprites, let's draw them. We are doing it this way so that as we add code to update/change/move them, we will be able to see what is happening.</p>
			<p>Add the following highlighted code to draw the four new sprites:</p>
			<pre>// Draw the tree
window.draw(spriteTree);
<strong class="bold">// Draw the player</strong>
<strong class="bold">window.draw(spritePlayer);</strong>
<strong class="bold">// Draw the axe</strong>
<strong class="bold">window.draw(spriteAxe);</strong>
<strong class="bold">// Draw the flying log</strong>
<strong class="bold">window.draw(spriteLog);</strong>
<strong class="bold">// Draw the gravestone</strong>
<strong class="bold">window.draw(spriteRIP);</strong>
// Draw the bee
window.draw(spriteBee);</pre>
			<p>The preceding code passes our four new sprites, one after the other, to the <code>draw</code> function.</p>
			<p>Run the game and you will see our new sprites in the scene:</p>
			<div><div><img src="img/B14278_05_01.jpg" alt=""/>
				</div>
			</div>
			<p>We are really close to a working game now. The next task is to write some code to allow the player to control what happens.</p>
			<h1 id="_idParaDest-138"><a id="_idTextAnchor141"/>Handling the player's input</h1>
			<p>A few different things depend on the movement of the player, as follows: </p>
			<ul>
				<li>When to show the axe</li>
				<li>When to begin animating the log </li>
				<li>When to move all of the branches down </li>
			</ul>
			<p>Therefore, it makes sense to set up keyboard handling for the player who's chopping. Once this is done, we can put all of the features we just mentioned into the same part of the code.</p>
			<p>Let's think for a moment about how we detect keyboard presses. Each frame, we test whether a particular keyboard key is currently being held down. If it is, we take action. If the <em class="italic">Esc</em> key is being held down, we quit the game, and if the <em class="italic">Enter</em> key is being held down, we restart the game. So far, this has been sufficient for our needs.</p>
			<p>There is, however, a problem with this approach when we try and handle the chopping of the tree. The problem has always been there; it just didn't matter until now. Depending on how powerful your PC is, the game loop could be executing thousands of times per second. Each and every pass through the game loop that a key is held down, it is detected, and the related code will execute.</p>
			<p>So, actually, every time you press <em class="italic">Enter</em> to restart the game, you are most likely restarting it well in excess of a hundred times. This is because even the briefest of presses will last a significant fraction of a second. You can verify this by running the game and holding down the <em class="italic">Enter</em> key. Note that the time-bar doesn't move. This is because the game is being restarted over and over again, hundreds or even thousands of times a second.</p>
			<p>If we don't use a different approach for the player chopping, then just one attempted chop will bring the entire tree down in a mere fraction of a second. We need to be a bit more sophisticated. What we will do is allow the player to chop, and then when they do so, disable the code that detects a key press. We will then detect when the player removes their finger from a key and then reenable the detection of key presses. Here are the steps laid out clearly:</p>
			<ol>
				<li>Wait for the player to use the left or right arrow keys to chop a log.</li>
				<li>When the player chops, disable key press detection.</li>
				<li>Wait for the player to remove their finger from a key.</li>
				<li>Reenable chop detection.</li>
				<li>Repeat from step 1.</li>
			</ol>
			<p>This might sound complicated but, with SFML's help, this will be straightforward. Let's implement this now, one step at a time.</p>
			<p>Add the following highlighted line of code, which declares a <code>bool</code> variable called <code>acceptInput</code>, which will be used to determine when to listen for chops and when to ignore them:</p>
			<pre>float logSpeedX = 1000;
float logSpeedY = -1500;
<strong class="bold">// Control the player input</strong>
<strong class="bold">bool acceptInput = false;</strong>
while (window.isOpen())
{</pre>
			<p>Now that we have our Boolean set up, we can move on to the next step.</p>
			<h2 id="_idParaDest-139"><a id="_idTextAnchor142"/>Handling setting up a new game</h2>
			<p>So that we're ready to handle chops, add the following highlighted code to the <code>if</code> block that starts a new game:</p>
			<pre>/*
****************************************
Handle the players input
****************************************
*/
if (Keyboard::isKeyPressed(Keyboard::Escape))
{
    window.close();
}
// Start the game
if (Keyboard::isKeyPressed(Keyboard::Return))
{
    paused = false;
    // Reset the time and the score
    score = 0;
    timeRemaining = 6;
<strong class="bold">    // Make all the branches disappear -</strong>
<strong class="bold">    // starting in the second position</strong>
<strong class="bold">    for (int i = 1; i &lt; NUM_BRANCHES; i++)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        branchPositions[i] = side::NONE;</strong>
<strong class="bold">    }</strong>
<strong class="bold">    // Make sure the gravestone is hidden</strong>
<strong class="bold">    spriteRIP.setPosition(675, 2000);</strong>
<strong class="bold">    // Move the player into position</strong>
<strong class="bold">    spritePlayer.setPosition(580, 720);</strong>
<strong class="bold">    acceptInput = true;</strong>
}
/*
****************************************
Update the scene
****************************************
*/</pre>
			<p>In the previous code, we are using a <code>for</code> loop to prepare the tree with no branches. This is fair to the player because, if the game started with a branch right above their head, it would be considered unsporting. Then, we simply move the gravestone off of the screen and the player into their starting location on the left. The last thing the preceding code does is set <code>acceptInput</code> to <code>true</code>. </p>
			<p>We are now ready to receive chopping key presses.</p>
			<h2 id="_idParaDest-140"><a id="_idTextAnchor143"/>Detecting the player chopping</h2>
			<p>Now, we can handle the left and right cursor key presses. Add this simple <code>if</code> block, which only executes when <code>acceptInput</code> is <code>true</code>:</p>
			<pre>// Start the game
if (Keyboard::isKeyPressed(Keyboard::Return))
{
    paused = false;
    // Reset the time and the score
    score = 0;
    timeRemaining = 5;
    // Make all the branches disappear
    for (int i = 1; i &lt; NUM_BRANCHES; i++)
    {
        branchPositions[i] = side::NONE;
    }
    // Make sure the gravestone is hidden
    spriteRIP.setPosition(675, 2000);
    // Move the player into position
    spritePlayer.setPosition(675, 660);
    acceptInput = true;
}
<strong class="bold">// Wrap the player controls to</strong>
<strong class="bold">// Make sure we are accepting input</strong>
<strong class="bold">if (acceptInput)</strong>
<strong class="bold">{</strong>
<strong class="bold">    // More code here next...</strong>
<strong class="bold">}</strong>
/*
****************************************
Update the scene
****************************************
*/</pre>
			<p>Now, inside the <code>if</code> block that we just coded, add the following highlighted code to handle what happens when the player presses the right cursor key on the keyboard:</p>
			<pre>// Wrap the player controls to
// Make sure we are accepting input
if (acceptInput)
{
    // More code here next...
    
<strong class="bold">    // First handle pressing the right cursor key</strong>
<strong class="bold">    if (Keyboard::isKeyPressed(Keyboard::Right))</strong>
<strong class="bold">    {</strong>
<strong class="bold">        // Make sure the player is on the right</strong>
<strong class="bold">        playerSide = side::RIGHT;</strong>
<strong class="bold">        </strong>
<strong class="bold">        score ++;</strong>
<strong class="bold">        // Add to the amount of time remaining</strong>
<strong class="bold">        timeRemaining += (2 / score) + .15;</strong>
<strong class="bold">        spriteAxe.setPosition(AXE_POSITION_RIGHT,</strong>
<strong class="bold">            spriteAxe.getPosition().y);</strong>
<strong class="bold">        spritePlayer.setPosition(1200, 720);</strong>
<strong class="bold">        // Update the branches</strong>
<strong class="bold">        updateBranches(score);</strong>
<strong class="bold">        </strong>
<strong class="bold">        // Set the log flying to the left</strong>
<strong class="bold">        spriteLog.setPosition(810, 720);</strong>
<strong class="bold">        logSpeedX = -5000;</strong>
<strong class="bold">        logActive = true;</strong>
<strong class="bold">        acceptInput = false;</strong>
<strong class="bold">    }</strong>
<strong class="bold">    // Handle the left cursor key</strong>
}</pre>
			<p>Quite a bit is happening in that preceding code, so let's go through it: </p>
			<ul>
				<li>First, we detect whether the player has chopped on the right-hand side of the tree. If they have, then we set <code>playerSide</code> to <code>side::RIGHT</code>. We will respond to the value of <code>playerSide</code> later in the code. Then, we add one to the score with <code>score ++</code>. </li>
				<li>The next line of code is slightly mysterious, but all that is happening is we are adding to the amount of time remaining. We are rewarding the player for taking action. The problem for the player, however, is that the higher the score gets, the less additional time is added on. You can play with this formula to make the game easier or harder.</li>
				<li>Then, the axe is moved into its right-hand-side position with <code>spriteAxe.setPosition</code> and the player sprite is moved into its right-hand-position as well.</li>
				<li>Next, we call <code>updateBranches</code> to move all the branches down one place and spawn a new random branch (or space) at the top of the tree.</li>
				<li>Then, <code>spriteLog</code> is moved into its starting position, camouflaged against the tree, and its <code>speedX</code> variable is set to a negative number so that it whizzes off to the left. Also, <code>logActive</code> is set to <code>true</code> so that the log moving code that we will write soon animates the log each frame.</li>
				<li>Finally, <code>acceptInput</code> is set to <code>false</code>. At this point, no more chops can be made by the player. We have solved the problem of the presses being detected too frequently, and we will see how we can reenable chopping soon.</li>
			</ul>
			<p>Now, still inside the <code>if(acceptInput)</code> block that we just coded, add the following highlighted code to handle what happens when the player presses the left cursor key on the keyboard:</p>
			<pre>    // Handle the left cursor key
<strong class="bold">    if (Keyboard::isKeyPressed(Keyboard::Left))</strong>
<strong class="bold">    {</strong>
<strong class="bold">        // Make sure the player is on the left</strong>
<strong class="bold">        playerSide = side::LEFT;</strong>
<strong class="bold">        score++;</strong>
<strong class="bold">        // Add to the amount of time remaining</strong>
<strong class="bold">        timeRemaining += (2 / score) + .15;</strong>
<strong class="bold">        spriteAxe.setPosition(AXE_POSITION_LEFT,</strong>
<strong class="bold">            spriteAxe.getPosition().y);</strong>
<strong class="bold">        spritePlayer.setPosition(580, 720);</strong>
<strong class="bold">        // update the branches</strong>
<strong class="bold">        updateBranches(score);</strong>
<strong class="bold">        // set the log flying</strong>
<strong class="bold">        spriteLog.setPosition(810, 720);</strong>
<strong class="bold">        logSpeedX = 5000;</strong>
<strong class="bold">        logActive = true;</strong>
<strong class="bold">        acceptInput = false;</strong>
<strong class="bold">    }</strong>
}</pre>
			<p>The previous code is just the same as the code that handles the right-hand-side chop, except that the sprites are positioned differently and the <code>logSpeedX</code> variable is set to a positive value so that the log whizzes to the right.</p>
			<p>Now, we can code what happens when a keyboard key is released.</p>
			<h2 id="_idParaDest-141"><a id="_idTextAnchor144"/>Detecting a key being released</h2>
			<p>To make the preceding code work beyond the first chop, we need to detect when the player releases a key and then set <code>acceptInput</code> back to <code>true</code>.</p>
			<p>This is slightly different to the key handling we have seen so far. SFML has two different ways of detecting keyboard input from the player. We have already seen the first way when we handled the <em class="italic">Enter</em> key, and it is dynamic and instantaneous, which is exactly what we need to respond immediately to a key press.</p>
			<p>The following code uses the method of detecting when a key is released. Enter the following highlighted code at the top of the <code>Handle the players input</code> section and then we will go through it:</p>
			<pre>/*
****************************************
Handle the players input
****************************************
*/
<strong class="bold">Event event;</strong>
<strong class="bold">while (window.pollEvent(event))</strong>
<strong class="bold">{</strong>
<strong class="bold">    if (event.type == Event::KeyReleased &amp;&amp; !paused)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        // Listen for key presses again</strong>
<strong class="bold">        acceptInput = true;</strong>
<strong class="bold">        // hide the axe</strong>
<strong class="bold">        spriteAxe.setPosition(2000,</strong>
<strong class="bold">            spriteAxe.getPosition().y);</strong>
<strong class="bold">    }</strong>
<strong class="bold">}</strong>
if (Keyboard::isKeyPressed(Keyboard::Escape))
{
    window.close();
}</pre>
			<p>In the preceding code, we declare an object of the <code>Event</code> type called <code>event</code>. Then, we call the <code>window.pollEvent</code> function, passing in our new object, <code>event</code>. The <code>pollEvent</code> function puts data into the <code>event</code> object that describes an operating system event. This could be a key press, key release, mouse movement, mouse click, game controller action, or something that happened to the window itself (resized, moved, and so on).</p>
			<p>The reason that we wrap our code in a <code>while</code> loop is because there might be many events stored in a queue. The <code>window.pollEvent</code> function will load them, one at a time, into <code>event</code>. With each pass through the loop, we will see whether we are interested in the current event and respond if we are. When <code>window.pollEvent</code> returns <code>false</code>, that means there are no more events in the queue and the <code>while</code> loop will exit.</p>
			<p>This <code>if</code> condition <code>(event.type == Event::KeyReleased &amp;&amp; !paused)</code> executes when both a key has been released and the game is not paused.</p>
			<p>Inside the <code>if</code> block, we set <code>acceptInput</code> back to <code>true</code> and hide the axe sprite off screen.</p>
			<p>You can now run the game and gaze in awe at the moving tree, swinging axe, and animated player. It won't, however, squash the player, and the log doesn't move yet when chopped.</p>
			<p>Let's move on to making the log move.</p>
			<h2 id="_idParaDest-142"><a id="_idTextAnchor145"/>Animating the chopped logs and the axe</h2>
			<p>When the player chops, <code>logActive</code> is set to <code>true</code>, so we can wrap some code in a block that only executes when <code>logActive</code> is <code>true</code>. Furthermore, each chop sets <code>logSpeedX</code> to either a positive or negative number, so the log is ready to start flying away from the tree in the correct direction.</p>
			<p>Add the following highlighted code right after where we update the branch sprites:</p>
			<pre>    // update the branch sprites
    for (int i = 0; i &lt; NUM_BRANCHES; i++)
    {
        float height = i * 150;
        if (branchPositions[i] == side::LEFT)
        {
            // Move the sprite to the left side
            branches[i].setPosition(610, height);
            // Flip the sprite round the other way
            branches[i].setRotation(180);
        }
        else if (branchPositions[i] == side::RIGHT)
        {
            // Move the sprite to the right side
            branches[i].setPosition(1330, height);
            // Flip the sprite round the other way
            branches[i].setRotation(0);
        }
        else
        {
            // Hide the branch
            branches[i].setPosition(3000, height);
        }
    }
<strong class="bold">    // Handle a flying log</strong>
<strong class="bold">    if (logActive)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        spriteLog.setPosition(</strong>
<strong class="bold">            spriteLog.getPosition().x + </strong>
<strong class="bold">            (logSpeedX * dt.asSeconds()),</strong>
<strong class="bold">            </strong>
<strong class="bold">        spriteLog.getPosition().y + </strong>
<strong class="bold">            (logSpeedY * dt.asSeconds()));</strong>
<strong class="bold">        // Has the log reached the right hand edge?</strong>
<strong class="bold">        if (spriteLog.getPosition().x &lt; -100 ||</strong>
<strong class="bold">            spriteLog.getPosition().x &gt; 2000)</strong>
<strong class="bold">        {</strong>
<strong class="bold">            // Set it up ready to be a whole new log next frame</strong>
<strong class="bold">            logActive = false;</strong>
<strong class="bold">            spriteLog.setPosition(810, 720);</strong>
<strong class="bold">        }</strong>
<strong class="bold">    }</strong>
} // End if(!paused)
/*
****************************************
Draw the scene
****************************************
*/</pre>
			<p>The code sets the position of the sprite by getting its current horizontal and vertical location with <code>getPosition</code> and then adding to it using <code>logSpeedX</code> and <code>logSpeedY</code>, respectively, multiplied by <code>dt.asSeconds</code>.</p>
			<p>After the log sprite has been moved each frame, the code uses an <code>if</code> block to see whether the sprite has disappeared out of view on either the left or the right. If it has, the log is moved back to its starting point, ready for the next chop.</p>
			<p>If you run the game now, you will be able to see the log flying off to the appropriate side of the screen:</p>
			<div><div><img src="img/B14278_05_02.jpg" alt=""/>
				</div>
			</div>
			<p>Now, let's move on to a more sensitive subject.</p>
			<h1 id="_idParaDest-143"><a id="_idTextAnchor146"/>Handling death</h1>
			<p>Every game must end badly with either the player running out of time (which we have already handled) or getting squashed by a branch.</p>
			<p>Detecting the player getting squashed is really simple. All we want to know is: does the last branch in the <code>branchPositions</code> array equal <code>playerSide</code>? If it does, the player is dead.</p>
			<p>Add the following highlighted code that detects and executes when the player is squashed by a branch. We will talk about it later:</p>
			<pre>    // Handle a flying log
    if (logActive)
    {
        spriteLog.setPosition(
            spriteLog.getPosition().x + 
                (logSpeedX * dt.asSeconds()),
            
        spriteLog.getPosition().y + 
            (logSpeedY * dt.asSeconds()));
        // Has the log reached the right-hand edge?
        if (spriteLog.getPosition().x &lt; -100 ||
            spriteLog.getPosition().x &gt; 2000)
        {
            // Set it up ready to be a whole new cloud next frame
            logActive = false;
            spriteLog.setPosition(800, 600);
        }
    }
<strong class="bold">    // has the player been squished by a branch?</strong>
<strong class="bold">    if (branchPositions[5] == playerSide)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        // death</strong>
<strong class="bold">        paused = true;</strong>
<strong class="bold">        acceptInput = false;</strong>
<strong class="bold">        </strong>
<strong class="bold">        // Draw the gravestone</strong>
<strong class="bold">        spriteRIP.setPosition(525, 760);</strong>
<strong class="bold">        // hide the player</strong>
<strong class="bold">        spritePlayer.setPosition(2000, 660);</strong>
<strong class="bold">        // Change the text of the message</strong>
<strong class="bold">        messageText.setString("SQUISHED!!");</strong>
<strong class="bold">        // Center it on the screen</strong>
<strong class="bold">        FloatRect textRect = messageText.getLocalBounds();</strong>
<strong class="bold">        messageText.setOrigin(textRect.left +</strong>
<strong class="bold">            textRect.width / 2.0f,</strong>
<strong class="bold">            textRect.top + textRect.height / 2.0f);</strong>
<strong class="bold">        messageText.setPosition(1920 / 2.0f,</strong>
<strong class="bold">            1080 / 2.0f);</strong>
<strong class="bold">    }</strong>
} // End if(!paused)
/*
****************************************
Draw the scene
****************************************
*/</pre>
			<p>The first thing the preceding code does, after the player's demise, is set <code>paused</code> to <code>true</code>. Now, the loop will complete this frame and won't run the update part of the loop again until a new game is started by the player.</p>
			<p>Then, we move the gravestone into position, near where the player was standing, and hide the player sprite off screen.</p>
			<p>We set the String of <code>messageText</code> to <code>"Squished!!"</code> and then use the usual technique to center it on the screen.</p>
			<p>You can now run the game and play it for real. The following screenshot shows the player's final score and their gravestone, as well as the <strong class="bold">SQUISHED </strong>message:</p>
			<div><div><img src="img/B14278_05_03.jpg" alt=""/>
				</div>
			</div>
			<p>There is just one more problem to deal with. Is it just me, or is it a little bit quiet?</p>
			<h1 id="_idParaDest-144"><a id="_idTextAnchor147"/>Simple sound FX</h1>
			<p>In this section, we will add three sounds. Each sound will be played on a particular game event, that is, a simple thud sound whenever the player chops, a gloomy losing sound when the player runs out of time, and a retro crushing sound when the player is squashed to death.</p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor148"/>How SFML sound works</h2>
			<p>SFML plays sound effects using two different classes. The first class is the <code>SoundBuffer</code> class. This is the class that holds the actual audio data from the sound file. It is <code>SoundBuffer</code> that is responsible for loading the <code>.wav</code> files into the PC's RAM in a format that can be played without any further decoding work.</p>
			<p>When we write code for the sound effects in a minute, we will see that, once we have a <code>SoundBuffer</code> object with our sound stored in it, we will then create another object of the <code>Sound</code> type. We can then associate this <code>Sound</code> object with a <code>SoundBuffer</code> object. Then, at the appropriate moment in our code, we will be able to call the <code>play</code> function of the appropriate <code>Sound</code> object.</p>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor149"/>When to play the sounds</h2>
			<p>As we will see very soon, the C++ code to load and play sounds is really simple. What we need to consider, however, is <em class="italic">when</em> we call the <code>play</code> function, where in our code will we put the function calls to <code>play</code>? Let's see:</p>
			<ul>
				<li>The chop sound can be called from the key presses of the left and right cursor keys.</li>
				<li>The death sound can be played from the <code>if</code> block that detects that a tree has mangled the player.</li>
				<li>The out of time sound can be played from the <code>if</code> block which detects whether <code>timeRemaining</code> is less than zero.</li>
			</ul>
			<p>Now, we can write our sound code.</p>
			<h2 id="_idParaDest-147"><a id="_idTextAnchor150"/>Adding the sound code</h2>
			<p>First, we will add another <code>#include</code> directive to make the SFML sound-related classes available. Add the following highlighted code:</p>
			<pre>#include &lt;sstream&gt;
#include &lt;SFML/Graphics.hpp&gt;
<strong class="bold">#include &lt;SFML/Audio.hpp&gt;</strong>
using namespace sf;</pre>
			<p>Now, we will declare three different <code>SoundBuffer</code> objects, load three different sound files into them, and associate three different objects of the <code>Sound</code> type with the related objects of the <code>SoundBuffer</code> type. Add the following highlighted code:</p>
			<pre>// Control the player input
bool acceptInput = false;
<strong class="bold">// Prepare the sounds</strong>
<strong class="bold">// The player chopping sound</strong>
<strong class="bold">SoundBuffer chopBuffer;</strong>
<strong class="bold">chopBuffer.loadFromFile("sound/chop.wav");</strong>
<strong class="bold">Sound chop;</strong>
<strong class="bold">chop.setBuffer(chopBuffer);</strong>
<strong class="bold">// The player has met his end under a branch</strong>
<strong class="bold">SoundBuffer deathBuffer;</strong>
<strong class="bold">deathBuffer.loadFromFile("sound/death.wav");</strong>
<strong class="bold">Sound death;</strong>
<strong class="bold">death.setBuffer(deathBuffer);</strong>
<strong class="bold">// Out of time</strong>
<strong class="bold">SoundBuffer ootBuffer;</strong>
<strong class="bold">ootBuffer.loadFromFile("sound/out_of_time.wav");</strong>
<strong class="bold">Sound outOfTime;</strong>
<strong class="bold">outOfTime.setBuffer(ootBuffer);</strong>
while (window.isOpen())
{</pre>
			<p>Now, we can play our first sound effect. Add the following single line of code to the <code>if</code> block, which detects that the player has pressed the right cursor key:</p>
			<pre>// Wrap the player controls to
// Make sure we are accepting input
if (acceptInput)
{
    // More code here next...
    
    // First handle pressing the right cursor key
    if (Keyboard::isKeyPressed(Keyboard::Right))
    {
        // Make sure the player is on the right
        playerSide = side::RIGHT;
        
        score++;
        timeRemaining += (2 / score) + .15;
        spriteAxe.setPosition(AXE_POSITION_RIGHT,
            spriteAxe.getPosition().y);
        spritePlayer.setPosition(1120, 660);
        // update the branches
        updateBranches(score);
        
        // set the log flying to the left
        spriteLog.setPosition(800, 600);
        logSpeedX = -5000;
        logActive = true;
        acceptInput = false;
<strong class="bold">        // Play a chop sound</strong>
<strong class="bold">        chop.play();</strong>
    }</pre>
			<p class="callout-heading">Tip</p>
			<p class="callout">Add exactly the same code at the end of the next block of code that starts with <code>if (Keyboard::isKeyPressed(Keyboard::Left))</code> to make a chopping sound when the player chops on the left-hand side of the tree.</p>
			<p>Find the code that deals with the player running out of time and add the following highlighted code to play the out of time-related sound effect:</p>
			<pre>if (timeRemaining &lt;= 0.f) {
    // Pause the game
    paused = true;
    // Change the message shown to the player
    messageText.setString("Out of time!!");
    //Reposition the text based on its new size
    FloatRect textRect = messageText.getLocalBounds();
    messageText.setOrigin(textRect.left +
        textRect.width / 2.0f,
        textRect.top +
        textRect.height / 2.0f);
    messageText.setPosition(1920 / 2.0f, 1080 / 2.0f);
<strong class="bold">    // Play the out of time sound</strong>
<strong class="bold">    outOfTime.play();</strong>
}</pre>
			<p>Finally, to play the death sound when the player is squished, add the following highlighted code to the <code>if</code> block, which executes when the bottom branch is on the same side as the player:</p>
			<pre>// has the player been squished by a branch?
if (branchPositions[5] == playerSide)
{
    // death
    paused = true;
    acceptInput = false;
    
    // Draw the gravestone
    spriteRIP.setPosition(675, 660);
    // hide the player
    spritePlayer.setPosition(2000, 660);
    messageText.setString("SQUISHED!!");
    FloatRect textRect = messageText.getLocalBounds();
    messageText.setOrigin(textRect.left +
        textRect.width / 2.0f,
        textRect.top + textRect.height / 2.0f);
    messageText.setPosition(1920 / 2.0f, 1080 / 2.0f);
<strong class="bold">    // Play the death sound</strong>
<strong class="bold">    death.play();</strong>
}</pre>
			<p>That's it! We have finished the first game. Let's discuss some possible enhancements before we move on to the second project.</p>
			<h1 id="_idParaDest-148"><a id="_idTextAnchor151"/>Improving the game and the code</h1>
			<p>Take a look at these suggested enhancements for the Timber!!! project. You can see the enhancements in action in the <code>Runnable</code> folder of the download bundle:</p>
			<ul>
				<li><code>sstream</code> code in a block that only executes occasionally. After all, we don't need to update the score thousands of times a second!</li>
				<li><strong class="bold">Debugging console:</strong> Let's add some more text so that we can see the current frame rate. Like the score, we don't need to update this too often. Once every hundred frames will do.</li>
				<li><strong class="bold">Add more trees to the background:</strong> Simply add some more tree sprites and draw them in whatever position looks good (some nearer the camera and some further away).</li>
				<li><code>RectangleShape</code> objects behind the score and the FPS counter. Black with a bit of transparency will look quite good.</li>
				<li><strong class="bold">Make the cloud code more efficient:</strong> As we alluded to a few times already, we can use our knowledge of arrays to make the cloud code a lot shorter.</li>
			</ul>
			<p>Take a look at the game in action with extra trees, clouds, and a transparent background for the text:</p>
			<div><div><img src="img/B14278_05_04.jpg" alt=""/>
				</div>
			</div>
			<p>To see the code for these enhancements, take a look in the <code>Timber Enhanced Version </code>folder of the download bundle.</p>
			<h1 id="_idParaDest-149"><a id="_idTextAnchor152"/>Summary</h1>
			<p>In this chapter, we added the finishing touches and graphics to the Timber!!! game. If, prior to this book, you had never coded a single line of C++, then you can give yourself a big pat on the back. In just five modest chapters, you have gone from zero knowledge to a working game.</p>
			<p>However, we will not be congratulating ourselves for too long because, in the next chapter, we will move straight on to some slightly more hardcore C++. While the next game, a simple Pong game, in some ways is simpler than Timber!!, learning about writing our own classes will prepare us for building more complicated and fuller-featured games.</p>
			<h1 id="_idParaDest-150"><a id="_idTextAnchor153"/>FAQ</h1>
			<p>Q) I admit that the arrays solution for the clouds was more efficient. But do we really need three separate arrays—one for active, one for speed, and one for the sprite itself?</p>
			<p>A) If we look at the properties/variables that various objects have, for example, <code>Sprite</code> objects, we will see they are numerous. Sprites have position, color, size, rotation, and more as well. But it would be just perfect if they had <code>active</code>, <code>speed</code>, and perhaps some more. The problem is that the coders at SFML can't possibly predict all of the ways that we will want to use their <code>Sprite</code> class. Fortunately, we can make our own classes. We could make a class called <code>Cloud</code> that has a Boolean for <code>active</code> and <code>int</code> for speed. We can even give our <code>Cloud</code> class an SFML <code>Sprite</code> object. We could then simplify our cloud code even further. We will look at designing our own classes in the next chapter.</p>
		</div>
	</body></html>