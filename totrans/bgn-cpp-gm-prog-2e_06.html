<html><head></head><body>
		<div id="_idContainer053">
			<h1 id="_idParaDest-135"><a id="_idTextAnchor138"/><em class="italic">Chapter 5</em>: Collisions, Sound, and End Conditions – Making the Game Playable</h1>
			<p>This is the final phase of the first project. By the end of this chapter, you will have your first completed game. Once you have Timber!!! up and running, be sure to read the last section of this chapter as it will suggest ways to make the game better.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Adding the rest of the sprites</li>
				<li>Handling the player input</li>
				<li>Animating the flying log</li>
				<li>Handling death</li>
				<li>Adding sound effects</li>
				<li>Adding features and improving Timber!!!</li>
			</ul>
			<h1 id="_idParaDest-136"><a id="_idTextAnchor139"/>Preparing the player (and other sprites)</h1>
			<p>Let's add the code for the player's sprite as well as a few more sprites and textures at the same time. The following, quite large, block of code also adds a gravestone sprite for when the player gets squashed, an axe sprite to chop with, and a log sprite that can whiz away each time the player chops.</p>
			<p>Notice that, after the <strong class="source-inline">spritePlayer</strong> object, we declare a <strong class="source-inline">side</strong> variable, <strong class="source-inline">playerSide</strong>, to keep track of where the player is currently standing. Furthermore, we add some extra variables for the <strong class="source-inline">spriteLog </strong>object, including <strong class="source-inline">logSpeedX</strong>, <strong class="source-inline">logSpeedY</strong>, and <strong class="source-inline">logActive</strong>, to store how fast the log will move and whether it is currently moving. The <strong class="source-inline">spriteAxe</strong> also has two related <strong class="source-inline">float</strong> constant variables to remember where the ideal pixel position is on both the left and the right.</p>
			<p>Add the following block of code just before the <strong class="source-inline">while(window.isOpen())</strong> code, like we have done so often before. Note that all of the code in the following block is new, not just the highlighted code. I haven't provided any extra context for this block of code as the <strong class="source-inline">while(window.isOpen())</strong> should be easy to identify. The highlighted code is the code we have just discussed.</p>
			<p>Add the entirety of the following code, just before the <strong class="source-inline">while(window.isOpen())</strong> line, and make a mental note of the highlighted lines we briefly discussed. It will make the rest of this chapter's code easier to understand:</p>
			<p class="source-code">// Prepare the player</p>
			<p class="source-code">Texture texturePlayer;</p>
			<p class="source-code">texturePlayer.loadFromFile("graphics/player.png");</p>
			<p class="source-code">Sprite spritePlayer;</p>
			<p class="source-code">spritePlayer.setTexture(texturePlayer);</p>
			<p class="source-code">spritePlayer.setPosition(580, 720);</p>
			<p class="source-code"><strong class="bold">// The player starts on the left</strong></p>
			<p class="source-code"><strong class="bold">side playerSide = side::LEFT;</strong></p>
			<p class="source-code">// Prepare the gravestone</p>
			<p class="source-code">Texture textureRIP;</p>
			<p class="source-code">textureRIP.loadFromFile("graphics/rip.png");</p>
			<p class="source-code">Sprite spriteRIP;</p>
			<p class="source-code">spriteRIP.setTexture(textureRIP);</p>
			<p class="source-code">spriteRIP.setPosition(600, 860);</p>
			<p class="source-code">// Prepare the axe</p>
			<p class="source-code">Texture textureAxe;</p>
			<p class="source-code">textureAxe.loadFromFile("graphics/axe.png");</p>
			<p class="source-code">Sprite spriteAxe;</p>
			<p class="source-code">spriteAxe.setTexture(textureAxe);</p>
			<p class="source-code">spriteAxe.setPosition(700, 830);</p>
			<p class="source-code"><strong class="bold">// Line the axe up with the tree</strong></p>
			<p class="source-code"><strong class="bold">const float AXE_POSITION_LEFT = 700;</strong></p>
			<p class="source-code"><strong class="bold">const float AXE_POSITION_RIGHT = 1075;</strong></p>
			<p class="source-code">// Prepare the flying log</p>
			<p class="source-code">Texture textureLog;</p>
			<p class="source-code">textureLog.loadFromFile("graphics/log.png");</p>
			<p class="source-code">Sprite spriteLog;</p>
			<p class="source-code">spriteLog.setTexture(textureLog);</p>
			<p class="source-code">spriteLog.setPosition(810, 720);</p>
			<p class="source-code"><strong class="bold">// Some other useful log related variables</strong></p>
			<p class="source-code"><strong class="bold">bool logActive = false;</strong></p>
			<p class="source-code"><strong class="bold">float logSpeedX = 1000;</strong></p>
			<p class="source-code"><strong class="bold">float logSpeedY = -1500;</strong></p>
			<p>In the preceding code, we added quite a few new variables. They are hard to explain in full until we get to where we actually use them, but here is an overview of what they will be used for. There is a variable of the <strong class="source-inline">side</strong> enumeration type called <strong class="source-inline">playerSide</strong> that is initialized to <strong class="source-inline">left</strong>. This will track which side of the tree the player is on. </p>
			<p>There are two <strong class="source-inline">const float</strong> values that determine the horizontal position the axe will be drawn at, depending on whether the player is on the left-or right-hand side of the tree.</p>
			<p>There are also three variables to help to keep control of the log as it is chopped and flies off of the tree, <strong class="source-inline">bool</strong> to determine whether the log is in motion (<strong class="source-inline">logActive</strong>) and two <strong class="source-inline">float</strong> values to hold the horizontal and vertical speeds of the log.</p>
			<p>Now, we can draw all of our new sprites.</p>
			<h1 id="_idParaDest-137"><a id="_idTextAnchor140"/>Drawing the player and other sprites</h1>
			<p>Before we add the code to move the player and use all of our new sprites, let's draw them. We are doing it this way so that as we add code to update/change/move them, we will be able to see what is happening.</p>
			<p>Add the following highlighted code to draw the four new sprites:</p>
			<p class="source-code">// Draw the tree</p>
			<p class="source-code">window.draw(spriteTree);</p>
			<p class="source-code"><strong class="bold">// Draw the player</strong></p>
			<p class="source-code"><strong class="bold">window.draw(spritePlayer);</strong></p>
			<p class="source-code"><strong class="bold">// Draw the axe</strong></p>
			<p class="source-code"><strong class="bold">window.draw(spriteAxe);</strong></p>
			<p class="source-code"><strong class="bold">// Draw the flying log</strong></p>
			<p class="source-code"><strong class="bold">window.draw(spriteLog);</strong></p>
			<p class="source-code"><strong class="bold">// Draw the gravestone</strong></p>
			<p class="source-code"><strong class="bold">window.draw(spriteRIP);</strong></p>
			<p class="source-code">// Draw the bee</p>
			<p class="source-code">window.draw(spriteBee);</p>
			<p>The preceding code passes our four new sprites, one after the other, to the <strong class="source-inline">draw</strong> function.</p>
			<p>Run the game and you will see our new sprites in the scene:</p>
			<div>
				<div id="_idContainer049" class="IMG---Figure">
					<img src="image/B14278_05_01.jpg" alt=""/>
				</div>
			</div>
			<p>We are really close to a working game now. The next task is to write some code to allow the player to control what happens.</p>
			<h1 id="_idParaDest-138"><a id="_idTextAnchor141"/>Handling the player's input</h1>
			<p>A few different things depend on the movement of the player, as follows: </p>
			<ul>
				<li>When to show the axe</li>
				<li>When to begin animating the log </li>
				<li>When to move all of the branches down </li>
			</ul>
			<p>Therefore, it makes sense to set up keyboard handling for the player who's chopping. Once this is done, we can put all of the features we just mentioned into the same part of the code.</p>
			<p>Let's think for a moment about how we detect keyboard presses. Each frame, we test whether a particular keyboard key is currently being held down. If it is, we take action. If the <em class="italic">Esc</em> key is being held down, we quit the game, and if the <em class="italic">Enter</em> key is being held down, we restart the game. So far, this has been sufficient for our needs.</p>
			<p>There is, however, a problem with this approach when we try and handle the chopping of the tree. The problem has always been there; it just didn't matter until now. Depending on how powerful your PC is, the game loop could be executing thousands of times per second. Each and every pass through the game loop that a key is held down, it is detected, and the related code will execute.</p>
			<p>So, actually, every time you press <em class="italic">Enter</em> to restart the game, you are most likely restarting it well in excess of a hundred times. This is because even the briefest of presses will last a significant fraction of a second. You can verify this by running the game and holding down the <em class="italic">Enter</em> key. Note that the time-bar doesn't move. This is because the game is being restarted over and over again, hundreds or even thousands of times a second.</p>
			<p>If we don't use a different approach for the player chopping, then just one attempted chop will bring the entire tree down in a mere fraction of a second. We need to be a bit more sophisticated. What we will do is allow the player to chop, and then when they do so, disable the code that detects a key press. We will then detect when the player removes their finger from a key and then reenable the detection of key presses. Here are the steps laid out clearly:</p>
			<ol>
				<li>Wait for the player to use the left or right arrow keys to chop a log.</li>
				<li>When the player chops, disable key press detection.</li>
				<li>Wait for the player to remove their finger from a key.</li>
				<li>Reenable chop detection.</li>
				<li>Repeat from step 1.</li>
			</ol>
			<p>This might sound complicated but, with SFML's help, this will be straightforward. Let's implement this now, one step at a time.</p>
			<p>Add the following highlighted line of code, which declares a <strong class="source-inline">bool</strong> variable called <strong class="source-inline">acceptInput</strong>, which will be used to determine when to listen for chops and when to ignore them:</p>
			<p class="source-code">float logSpeedX = 1000;</p>
			<p class="source-code">float logSpeedY = -1500;</p>
			<p class="source-code"><strong class="bold">// Control the player input</strong></p>
			<p class="source-code"><strong class="bold">bool acceptInput = false;</strong></p>
			<p class="source-code">while (window.isOpen())</p>
			<p class="source-code">{</p>
			<p>Now that we have our Boolean set up, we can move on to the next step.</p>
			<h2 id="_idParaDest-139"><a id="_idTextAnchor142"/>Handling setting up a new game</h2>
			<p>So that we're ready to handle chops, add the following highlighted code to the <strong class="source-inline">if</strong> block that starts a new game:</p>
			<p class="source-code">/*</p>
			<p class="source-code">****************************************</p>
			<p class="source-code">Handle the players input</p>
			<p class="source-code">****************************************</p>
			<p class="source-code">*/</p>
			<p class="source-code">if (Keyboard::isKeyPressed(Keyboard::Escape))</p>
			<p class="source-code">{</p>
			<p class="source-code">    window.close();</p>
			<p class="source-code">}</p>
			<p class="source-code">// Start the game</p>
			<p class="source-code">if (Keyboard::isKeyPressed(Keyboard::Return))</p>
			<p class="source-code">{</p>
			<p class="source-code">    paused = false;</p>
			<p class="source-code">    // Reset the time and the score</p>
			<p class="source-code">    score = 0;</p>
			<p class="source-code">    timeRemaining = 6;</p>
			<p class="source-code"><strong class="bold">    // Make all the branches disappear -</strong></p>
			<p class="source-code"><strong class="bold">    // starting in the second position</strong></p>
			<p class="source-code"><strong class="bold">    for (int i = 1; i &lt; NUM_BRANCHES; i++)</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        branchPositions[i] = side::NONE;</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code"><strong class="bold">    // Make sure the gravestone is hidden</strong></p>
			<p class="source-code"><strong class="bold">    spriteRIP.setPosition(675, 2000);</strong></p>
			<p class="source-code"><strong class="bold">    // Move the player into position</strong></p>
			<p class="source-code"><strong class="bold">    spritePlayer.setPosition(580, 720);</strong></p>
			<p class="source-code"><strong class="bold">    acceptInput = true;</strong></p>
			<p class="source-code">}</p>
			<p class="source-code">/*</p>
			<p class="source-code">****************************************</p>
			<p class="source-code">Update the scene</p>
			<p class="source-code">****************************************</p>
			<p class="source-code">*/</p>
			<p>In the previous code, we are using a <strong class="source-inline">for</strong> loop to prepare the tree with no branches. This is fair to the player because, if the game started with a branch right above their head, it would be considered unsporting. Then, we simply move the gravestone off of the screen and the player into their starting location on the left. The last thing the preceding code does is set <strong class="source-inline">acceptInput</strong> to <strong class="source-inline">true</strong>. </p>
			<p>We are now ready to receive chopping key presses.</p>
			<h2 id="_idParaDest-140"><a id="_idTextAnchor143"/>Detecting the player chopping</h2>
			<p>Now, we can handle the left and right cursor key presses. Add this simple <strong class="source-inline">if</strong> block, which only executes when <strong class="source-inline">acceptInput</strong> is <strong class="source-inline">true</strong>:</p>
			<p class="source-code">// Start the game</p>
			<p class="source-code">if (Keyboard::isKeyPressed(Keyboard::Return))</p>
			<p class="source-code">{</p>
			<p class="source-code">    paused = false;</p>
			<p class="source-code">    // Reset the time and the score</p>
			<p class="source-code">    score = 0;</p>
			<p class="source-code">    timeRemaining = 5;</p>
			<p class="source-code">    // Make all the branches disappear</p>
			<p class="source-code">    for (int i = 1; i &lt; NUM_BRANCHES; i++)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        branchPositions[i] = side::NONE;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    // Make sure the gravestone is hidden</p>
			<p class="source-code">    spriteRIP.setPosition(675, 2000);</p>
			<p class="source-code">    // Move the player into position</p>
			<p class="source-code">    spritePlayer.setPosition(675, 660);</p>
			<p class="source-code">    acceptInput = true;</p>
			<p class="source-code">}</p>
			<p class="source-code"><strong class="bold">// Wrap the player controls to</strong></p>
			<p class="source-code"><strong class="bold">// Make sure we are accepting input</strong></p>
			<p class="source-code"><strong class="bold">if (acceptInput)</strong></p>
			<p class="source-code"><strong class="bold">{</strong></p>
			<p class="source-code"><strong class="bold">    // More code here next...</strong></p>
			<p class="source-code"><strong class="bold">}</strong></p>
			<p class="source-code">/*</p>
			<p class="source-code">****************************************</p>
			<p class="source-code">Update the scene</p>
			<p class="source-code">****************************************</p>
			<p class="source-code">*/</p>
			<p>Now, inside the <strong class="source-inline">if</strong> block that we just coded, add the following highlighted code to handle what happens when the player presses the right cursor key on the keyboard:</p>
			<p class="source-code">// Wrap the player controls to</p>
			<p class="source-code">// Make sure we are accepting input</p>
			<p class="source-code">if (acceptInput)</p>
			<p class="source-code">{</p>
			<p class="source-code">    // More code here next...</p>
			<p class="source-code">    </p>
			<p class="source-code"><strong class="bold">    // First handle pressing the right cursor key</strong></p>
			<p class="source-code"><strong class="bold">    if (Keyboard::isKeyPressed(Keyboard::Right))</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        // Make sure the player is on the right</strong></p>
			<p class="source-code"><strong class="bold">        playerSide = side::RIGHT;</strong></p>
			<p class="source-code"><strong class="bold">        </strong></p>
			<p class="source-code"><strong class="bold">        score ++;</strong></p>
			<p class="source-code"><strong class="bold">        // Add to the amount of time remaining</strong></p>
			<p class="source-code"><strong class="bold">        timeRemaining += (2 / score) + .15;</strong></p>
			<p class="source-code"><strong class="bold">        spriteAxe.setPosition(AXE_POSITION_RIGHT,</strong></p>
			<p class="source-code"><strong class="bold">            spriteAxe.getPosition().y);</strong></p>
			<p class="source-code"><strong class="bold">        spritePlayer.setPosition(1200, 720);</strong></p>
			<p class="source-code"><strong class="bold">        // Update the branches</strong></p>
			<p class="source-code"><strong class="bold">        updateBranches(score);</strong></p>
			<p class="source-code"><strong class="bold">        </strong></p>
			<p class="source-code"><strong class="bold">        // Set the log flying to the left</strong></p>
			<p class="source-code"><strong class="bold">        spriteLog.setPosition(810, 720);</strong></p>
			<p class="source-code"><strong class="bold">        logSpeedX = -5000;</strong></p>
			<p class="source-code"><strong class="bold">        logActive = true;</strong></p>
			<p class="source-code"><strong class="bold">        acceptInput = false;</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code"><strong class="bold">    // Handle the left cursor key</strong></p>
			<p class="source-code">}</p>
			<p>Quite a bit is happening in that preceding code, so let's go through it: </p>
			<ul>
				<li>First, we detect whether the player has chopped on the right-hand side of the tree. If they have, then we set <strong class="source-inline">playerSide</strong> to <strong class="source-inline">side::RIGHT</strong>. We will respond to the value of <strong class="source-inline">playerSide</strong> later in the code. Then, we add one to the score with <strong class="source-inline">score ++</strong>. </li>
				<li>The next line of code is slightly mysterious, but all that is happening is we are adding to the amount of time remaining. We are rewarding the player for taking action. The problem for the player, however, is that the higher the score gets, the less additional time is added on. You can play with this formula to make the game easier or harder.</li>
				<li>Then, the axe is moved into its right-hand-side position with <strong class="source-inline">spriteAxe.setPosition</strong> and the player sprite is moved into its right-hand-position as well.</li>
				<li>Next, we call <strong class="source-inline">updateBranches</strong> to move all the branches down one place and spawn a new random branch (or space) at the top of the tree.</li>
				<li>Then, <strong class="source-inline">spriteLog</strong> is moved into its starting position, camouflaged against the tree, and its <strong class="source-inline">speedX</strong> variable is set to a negative number so that it whizzes off to the left. Also, <strong class="source-inline">logActive</strong> is set to <strong class="source-inline">true</strong> so that the log moving code that we will write soon animates the log each frame.</li>
				<li>Finally, <strong class="source-inline">acceptInput</strong> is set to <strong class="source-inline">false</strong>. At this point, no more chops can be made by the player. We have solved the problem of the presses being detected too frequently, and we will see how we can reenable chopping soon.</li>
			</ul>
			<p>Now, still inside the <strong class="source-inline">if(acceptInput)</strong> block that we just coded, add the following highlighted code to handle what happens when the player presses the left cursor key on the keyboard:</p>
			<p class="source-code">    // Handle the left cursor key</p>
			<p class="source-code"><strong class="bold">    if (Keyboard::isKeyPressed(Keyboard::Left))</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        // Make sure the player is on the left</strong></p>
			<p class="source-code"><strong class="bold">        playerSide = side::LEFT;</strong></p>
			<p class="source-code"><strong class="bold">        score++;</strong></p>
			<p class="source-code"><strong class="bold">        // Add to the amount of time remaining</strong></p>
			<p class="source-code"><strong class="bold">        timeRemaining += (2 / score) + .15;</strong></p>
			<p class="source-code"><strong class="bold">        spriteAxe.setPosition(AXE_POSITION_LEFT,</strong></p>
			<p class="source-code"><strong class="bold">            spriteAxe.getPosition().y);</strong></p>
			<p class="source-code"><strong class="bold">        spritePlayer.setPosition(580, 720);</strong></p>
			<p class="source-code"><strong class="bold">        // update the branches</strong></p>
			<p class="source-code"><strong class="bold">        updateBranches(score);</strong></p>
			<p class="source-code"><strong class="bold">        // set the log flying</strong></p>
			<p class="source-code"><strong class="bold">        spriteLog.setPosition(810, 720);</strong></p>
			<p class="source-code"><strong class="bold">        logSpeedX = 5000;</strong></p>
			<p class="source-code"><strong class="bold">        logActive = true;</strong></p>
			<p class="source-code"><strong class="bold">        acceptInput = false;</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code">}</p>
			<p>The previous code is just the same as the code that handles the right-hand-side chop, except that the sprites are positioned differently and the <strong class="source-inline">logSpeedX</strong> variable is set to a positive value so that the log whizzes to the right.</p>
			<p>Now, we can code what happens when a keyboard key is released.</p>
			<h2 id="_idParaDest-141"><a id="_idTextAnchor144"/>Detecting a key being released</h2>
			<p>To make the preceding code work beyond the first chop, we need to detect when the player releases a key and then set <strong class="source-inline">acceptInput</strong> back to <strong class="source-inline">true</strong>.</p>
			<p>This is slightly different to the key handling we have seen so far. SFML has two different ways of detecting keyboard input from the player. We have already seen the first way when we handled the <em class="italic">Enter</em> key, and it is dynamic and instantaneous, which is exactly what we need to respond immediately to a key press.</p>
			<p>The following code uses the method of detecting when a key is released. Enter the following highlighted code at the top of the <strong class="source-inline">Handle the players input</strong> section and then we will go through it:</p>
			<p class="source-code">/*</p>
			<p class="source-code">****************************************</p>
			<p class="source-code">Handle the players input</p>
			<p class="source-code">****************************************</p>
			<p class="source-code">*/</p>
			<p class="source-code"><strong class="bold">Event event;</strong></p>
			<p class="source-code"><strong class="bold">while (window.pollEvent(event))</strong></p>
			<p class="source-code"><strong class="bold">{</strong></p>
			<p class="source-code"><strong class="bold">    if (event.type == Event::KeyReleased &amp;&amp; !paused)</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        // Listen for key presses again</strong></p>
			<p class="source-code"><strong class="bold">        acceptInput = true;</strong></p>
			<p class="source-code"><strong class="bold">        // hide the axe</strong></p>
			<p class="source-code"><strong class="bold">        spriteAxe.setPosition(2000,</strong></p>
			<p class="source-code"><strong class="bold">            spriteAxe.getPosition().y);</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code"><strong class="bold">}</strong></p>
			<p class="source-code">if (Keyboard::isKeyPressed(Keyboard::Escape))</p>
			<p class="source-code">{</p>
			<p class="source-code">    window.close();</p>
			<p class="source-code">}</p>
			<p>In the preceding code, we declare an object of the <strong class="source-inline">Event</strong> type called <strong class="source-inline">event</strong>. Then, we call the <strong class="source-inline">window.pollEvent</strong> function, passing in our new object, <strong class="source-inline">event</strong>. The <strong class="source-inline">pollEvent</strong> function puts data into the <strong class="source-inline">event</strong> object that describes an operating system event. This could be a key press, key release, mouse movement, mouse click, game controller action, or something that happened to the window itself (resized, moved, and so on).</p>
			<p>The reason that we wrap our code in a <strong class="source-inline">while</strong> loop is because there might be many events stored in a queue. The <strong class="source-inline">window.pollEvent</strong> function will load them, one at a time, into <strong class="source-inline">event</strong>. With each pass through the loop, we will see whether we are interested in the current event and respond if we are. When <strong class="source-inline">window.pollEvent</strong> returns <strong class="source-inline">false</strong>, that means there are no more events in the queue and the <strong class="source-inline">while</strong> loop will exit.</p>
			<p>This <strong class="source-inline">if</strong> condition <strong class="source-inline">(event.type == Event::KeyReleased &amp;&amp; !paused)</strong> executes when both a key has been released and the game is not paused.</p>
			<p>Inside the <strong class="source-inline">if</strong> block, we set <strong class="source-inline">acceptInput</strong> back to <strong class="source-inline">true</strong> and hide the axe sprite off screen.</p>
			<p>You can now run the game and gaze in awe at the moving tree, swinging axe, and animated player. It won't, however, squash the player, and the log doesn't move yet when chopped.</p>
			<p>Let's move on to making the log move.</p>
			<h2 id="_idParaDest-142"><a id="_idTextAnchor145"/>Animating the chopped logs and the axe</h2>
			<p>When the player chops, <strong class="source-inline">logActive</strong> is set to <strong class="source-inline">true</strong>, so we can wrap some code in a block that only executes when <strong class="source-inline">logActive</strong> is <strong class="source-inline">true</strong>. Furthermore, each chop sets <strong class="source-inline">logSpeedX</strong> to either a positive or negative number, so the log is ready to start flying away from the tree in the correct direction.</p>
			<p>Add the following highlighted code right after where we update the branch sprites:</p>
			<p class="source-code">    // update the branch sprites</p>
			<p class="source-code">    for (int i = 0; i &lt; NUM_BRANCHES; i++)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        float height = i * 150;</p>
			<p class="source-code">        if (branchPositions[i] == side::LEFT)</p>
			<p class="source-code">        {</p>
			<p class="source-code">            // Move the sprite to the left side</p>
			<p class="source-code">            branches[i].setPosition(610, height);</p>
			<p class="source-code">            // Flip the sprite round the other way</p>
			<p class="source-code">            branches[i].setRotation(180);</p>
			<p class="source-code">        }</p>
			<p class="source-code">        else if (branchPositions[i] == side::RIGHT)</p>
			<p class="source-code">        {</p>
			<p class="source-code">            // Move the sprite to the right side</p>
			<p class="source-code">            branches[i].setPosition(1330, height);</p>
			<p class="source-code">            // Flip the sprite round the other way</p>
			<p class="source-code">            branches[i].setRotation(0);</p>
			<p class="source-code">        }</p>
			<p class="source-code">        else</p>
			<p class="source-code">        {</p>
			<p class="source-code">            // Hide the branch</p>
			<p class="source-code">            branches[i].setPosition(3000, height);</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code"><strong class="bold">    // Handle a flying log</strong></p>
			<p class="source-code"><strong class="bold">    if (logActive)</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        spriteLog.setPosition(</strong></p>
			<p class="source-code"><strong class="bold">            spriteLog.getPosition().x + </strong></p>
			<p class="source-code"><strong class="bold">            (logSpeedX * dt.asSeconds()),</strong></p>
			<p class="source-code"><strong class="bold">            </strong></p>
			<p class="source-code"><strong class="bold">        spriteLog.getPosition().y + </strong></p>
			<p class="source-code"><strong class="bold">            (logSpeedY * dt.asSeconds()));</strong></p>
			<p class="source-code"><strong class="bold">        // Has the log reached the right hand edge?</strong></p>
			<p class="source-code"><strong class="bold">        if (spriteLog.getPosition().x &lt; -100 ||</strong></p>
			<p class="source-code"><strong class="bold">            spriteLog.getPosition().x &gt; 2000)</strong></p>
			<p class="source-code"><strong class="bold">        {</strong></p>
			<p class="source-code"><strong class="bold">            // Set it up ready to be a whole new log next frame</strong></p>
			<p class="source-code"><strong class="bold">            logActive = false;</strong></p>
			<p class="source-code"><strong class="bold">            spriteLog.setPosition(810, 720);</strong></p>
			<p class="source-code"><strong class="bold">        }</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code">} // End if(!paused)</p>
			<p class="source-code">/*</p>
			<p class="source-code">****************************************</p>
			<p class="source-code">Draw the scene</p>
			<p class="source-code">****************************************</p>
			<p class="source-code">*/</p>
			<p>The code sets the position of the sprite by getting its current horizontal and vertical location with <strong class="source-inline">getPosition</strong> and then adding to it using <strong class="source-inline">logSpeedX</strong> and <strong class="source-inline">logSpeedY</strong>, respectively, multiplied by <strong class="source-inline">dt.asSeconds</strong>.</p>
			<p>After the log sprite has been moved each frame, the code uses an <strong class="source-inline">if</strong> block to see whether the sprite has disappeared out of view on either the left or the right. If it has, the log is moved back to its starting point, ready for the next chop.</p>
			<p>If you run the game now, you will be able to see the log flying off to the appropriate side of the screen:</p>
			<div>
				<div id="_idContainer050" class="IMG---Figure">
					<img src="image/B14278_05_02.jpg" alt=""/>
				</div>
			</div>
			<p>Now, let's move on to a more sensitive subject.</p>
			<h1 id="_idParaDest-143"><a id="_idTextAnchor146"/>Handling death</h1>
			<p>Every game must end badly with either the player running out of time (which we have already handled) or getting squashed by a branch.</p>
			<p>Detecting the player getting squashed is really simple. All we want to know is: does the last branch in the <strong class="source-inline">branchPositions</strong> array equal <strong class="source-inline">playerSide</strong>? If it does, the player is dead.</p>
			<p>Add the following highlighted code that detects and executes when the player is squashed by a branch. We will talk about it later:</p>
			<p class="source-code">    // Handle a flying log</p>
			<p class="source-code">    if (logActive)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        spriteLog.setPosition(</p>
			<p class="source-code">            spriteLog.getPosition().x + </p>
			<p class="source-code">                (logSpeedX * dt.asSeconds()),</p>
			<p class="source-code">            </p>
			<p class="source-code">        spriteLog.getPosition().y + </p>
			<p class="source-code">            (logSpeedY * dt.asSeconds()));</p>
			<p class="source-code">        // Has the log reached the right-hand edge?</p>
			<p class="source-code">        if (spriteLog.getPosition().x &lt; -100 ||</p>
			<p class="source-code">            spriteLog.getPosition().x &gt; 2000)</p>
			<p class="source-code">        {</p>
			<p class="source-code">            // Set it up ready to be a whole new cloud next frame</p>
			<p class="source-code">            logActive = false;</p>
			<p class="source-code">            spriteLog.setPosition(800, 600);</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code"><strong class="bold">    // has the player been squished by a branch?</strong></p>
			<p class="source-code"><strong class="bold">    if (branchPositions[5] == playerSide)</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        // death</strong></p>
			<p class="source-code"><strong class="bold">        paused = true;</strong></p>
			<p class="source-code"><strong class="bold">        acceptInput = false;</strong></p>
			<p class="source-code"><strong class="bold">        </strong></p>
			<p class="source-code"><strong class="bold">        // Draw the gravestone</strong></p>
			<p class="source-code"><strong class="bold">        spriteRIP.setPosition(525, 760);</strong></p>
			<p class="source-code"><strong class="bold">        // hide the player</strong></p>
			<p class="source-code"><strong class="bold">        spritePlayer.setPosition(2000, 660);</strong></p>
			<p class="source-code"><strong class="bold">        // Change the text of the message</strong></p>
			<p class="source-code"><strong class="bold">        messageText.setString("SQUISHED!!");</strong></p>
			<p class="source-code"><strong class="bold">        // Center it on the screen</strong></p>
			<p class="source-code"><strong class="bold">        FloatRect textRect = messageText.getLocalBounds();</strong></p>
			<p class="source-code"><strong class="bold">        messageText.setOrigin(textRect.left +</strong></p>
			<p class="source-code"><strong class="bold">            textRect.width / 2.0f,</strong></p>
			<p class="source-code"><strong class="bold">            textRect.top + textRect.height / 2.0f);</strong></p>
			<p class="source-code"><strong class="bold">        messageText.setPosition(1920 / 2.0f,</strong></p>
			<p class="source-code"><strong class="bold">            1080 / 2.0f);</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code">} // End if(!paused)</p>
			<p class="source-code">/*</p>
			<p class="source-code">****************************************</p>
			<p class="source-code">Draw the scene</p>
			<p class="source-code">****************************************</p>
			<p class="source-code">*/</p>
			<p>The first thing the preceding code does, after the player's demise, is set <strong class="source-inline">paused</strong> to <strong class="source-inline">true</strong>. Now, the loop will complete this frame and won't run the update part of the loop again until a new game is started by the player.</p>
			<p>Then, we move the gravestone into position, near where the player was standing, and hide the player sprite off screen.</p>
			<p>We set the String of <strong class="source-inline">messageText</strong> to <strong class="source-inline">"Squished!!"</strong> and then use the usual technique to center it on the screen.</p>
			<p>You can now run the game and play it for real. The following screenshot shows the player's final score and their gravestone, as well as the <strong class="bold">SQUISHED </strong>message:</p>
			<div>
				<div id="_idContainer051" class="IMG---Figure">
					<img src="image/B14278_05_03.jpg" alt=""/>
				</div>
			</div>
			<p>There is just one more problem to deal with. Is it just me, or is it a little bit quiet?</p>
			<h1 id="_idParaDest-144"><a id="_idTextAnchor147"/>Simple sound FX</h1>
			<p>In this section, we will add three sounds. Each sound will be played on a particular game event, that is, a simple thud sound whenever the player chops, a gloomy losing sound when the player runs out of time, and a retro crushing sound when the player is squashed to death.</p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor148"/>How SFML sound works</h2>
			<p>SFML plays sound effects using two different classes. The first class is the <strong class="source-inline">SoundBuffer</strong> class. This is the class that holds the actual audio data from the sound file. It is <strong class="source-inline">SoundBuffer</strong> that is responsible for loading the <strong class="source-inline">.wav</strong> files into the PC's RAM in a format that can be played without any further decoding work.</p>
			<p>When we write code for the sound effects in a minute, we will see that, once we have a <strong class="source-inline">SoundBuffer</strong> object with our sound stored in it, we will then create another object of the <strong class="source-inline">Sound</strong> type. We can then associate this <strong class="source-inline">Sound</strong> object with a <strong class="source-inline">SoundBuffer</strong> object. Then, at the appropriate moment in our code, we will be able to call the <strong class="source-inline">play</strong> function of the appropriate <strong class="source-inline">Sound</strong> object.</p>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor149"/>When to play the sounds</h2>
			<p>As we will see very soon, the C++ code to load and play sounds is really simple. What we need to consider, however, is <em class="italic">when</em> we call the <strong class="source-inline">play</strong> function, where in our code will we put the function calls to <strong class="source-inline">play</strong>? Let's see:</p>
			<ul>
				<li>The chop sound can be called from the key presses of the left and right cursor keys.</li>
				<li>The death sound can be played from the <strong class="source-inline">if</strong> block that detects that a tree has mangled the player.</li>
				<li>The out of time sound can be played from the <strong class="source-inline">if</strong> block which detects whether <strong class="source-inline">timeRemaining</strong> is less than zero.</li>
			</ul>
			<p>Now, we can write our sound code.</p>
			<h2 id="_idParaDest-147"><a id="_idTextAnchor150"/>Adding the sound code</h2>
			<p>First, we will add another <strong class="source-inline">#include</strong> directive to make the SFML sound-related classes available. Add the following highlighted code:</p>
			<p class="source-code">#include &lt;sstream&gt;</p>
			<p class="source-code">#include &lt;SFML/Graphics.hpp&gt;</p>
			<p class="source-code"><strong class="bold">#include &lt;SFML/Audio.hpp&gt;</strong></p>
			<p class="source-code">using namespace sf;</p>
			<p>Now, we will declare three different <strong class="source-inline">SoundBuffer</strong> objects, load three different sound files into them, and associate three different objects of the <strong class="source-inline">Sound</strong> type with the related objects of the <strong class="source-inline">SoundBuffer</strong> type. Add the following highlighted code:</p>
			<p class="source-code">// Control the player input</p>
			<p class="source-code">bool acceptInput = false;</p>
			<p class="source-code"><strong class="bold">// Prepare the sounds</strong></p>
			<p class="source-code"><strong class="bold">// The player chopping sound</strong></p>
			<p class="source-code"><strong class="bold">SoundBuffer chopBuffer;</strong></p>
			<p class="source-code"><strong class="bold">chopBuffer.loadFromFile("sound/chop.wav");</strong></p>
			<p class="source-code"><strong class="bold">Sound chop;</strong></p>
			<p class="source-code"><strong class="bold">chop.setBuffer(chopBuffer);</strong></p>
			<p class="source-code"><strong class="bold">// The player has met his end under a branch</strong></p>
			<p class="source-code"><strong class="bold">SoundBuffer deathBuffer;</strong></p>
			<p class="source-code"><strong class="bold">deathBuffer.loadFromFile("sound/death.wav");</strong></p>
			<p class="source-code"><strong class="bold">Sound death;</strong></p>
			<p class="source-code"><strong class="bold">death.setBuffer(deathBuffer);</strong></p>
			<p class="source-code"><strong class="bold">// Out of time</strong></p>
			<p class="source-code"><strong class="bold">SoundBuffer ootBuffer;</strong></p>
			<p class="source-code"><strong class="bold">ootBuffer.loadFromFile("sound/out_of_time.wav");</strong></p>
			<p class="source-code"><strong class="bold">Sound outOfTime;</strong></p>
			<p class="source-code"><strong class="bold">outOfTime.setBuffer(ootBuffer);</strong></p>
			<p class="source-code">while (window.isOpen())</p>
			<p class="source-code">{</p>
			<p>Now, we can play our first sound effect. Add the following single line of code to the <strong class="source-inline">if</strong> block, which detects that the player has pressed the right cursor key:</p>
			<p class="source-code">// Wrap the player controls to</p>
			<p class="source-code">// Make sure we are accepting input</p>
			<p class="source-code">if (acceptInput)</p>
			<p class="source-code">{</p>
			<p class="source-code">    // More code here next...</p>
			<p class="source-code">    </p>
			<p class="source-code">    // First handle pressing the right cursor key</p>
			<p class="source-code">    if (Keyboard::isKeyPressed(Keyboard::Right))</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // Make sure the player is on the right</p>
			<p class="source-code">        playerSide = side::RIGHT;</p>
			<p class="source-code">        </p>
			<p class="source-code">        score++;</p>
			<p class="source-code">        timeRemaining += (2 / score) + .15;</p>
			<p class="source-code">        spriteAxe.setPosition(AXE_POSITION_RIGHT,</p>
			<p class="source-code">            spriteAxe.getPosition().y);</p>
			<p class="source-code">        spritePlayer.setPosition(1120, 660);</p>
			<p class="source-code">        // update the branches</p>
			<p class="source-code">        updateBranches(score);</p>
			<p class="source-code">        </p>
			<p class="source-code">        // set the log flying to the left</p>
			<p class="source-code">        spriteLog.setPosition(800, 600);</p>
			<p class="source-code">        logSpeedX = -5000;</p>
			<p class="source-code">        logActive = true;</p>
			<p class="source-code">        acceptInput = false;</p>
			<p class="source-code"><strong class="bold">        // Play a chop sound</strong></p>
			<p class="source-code"><strong class="bold">        chop.play();</strong></p>
			<p class="source-code">    }</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Add exactly the same code at the end of the next block of code that starts with <strong class="source-inline">if (Keyboard::isKeyPressed(Keyboard::Left))</strong> to make a chopping sound when the player chops on the left-hand side of the tree.</p>
			<p>Find the code that deals with the player running out of time and add the following highlighted code to play the out of time-related sound effect:</p>
			<p class="source-code">if (timeRemaining &lt;= 0.f) {</p>
			<p class="source-code">    // Pause the game</p>
			<p class="source-code">    paused = true;</p>
			<p class="source-code">    // Change the message shown to the player</p>
			<p class="source-code">    messageText.setString("Out of time!!");</p>
			<p class="source-code">    //Reposition the text based on its new size</p>
			<p class="source-code">    FloatRect textRect = messageText.getLocalBounds();</p>
			<p class="source-code">    messageText.setOrigin(textRect.left +</p>
			<p class="source-code">        textRect.width / 2.0f,</p>
			<p class="source-code">        textRect.top +</p>
			<p class="source-code">        textRect.height / 2.0f);</p>
			<p class="source-code">    messageText.setPosition(1920 / 2.0f, 1080 / 2.0f);</p>
			<p class="source-code"><strong class="bold">    // Play the out of time sound</strong></p>
			<p class="source-code"><strong class="bold">    outOfTime.play();</strong></p>
			<p class="source-code">}</p>
			<p>Finally, to play the death sound when the player is squished, add the following highlighted code to the <strong class="source-inline">if</strong> block, which executes when the bottom branch is on the same side as the player:</p>
			<p class="source-code">// has the player been squished by a branch?</p>
			<p class="source-code">if (branchPositions[5] == playerSide)</p>
			<p class="source-code">{</p>
			<p class="source-code">    // death</p>
			<p class="source-code">    paused = true;</p>
			<p class="source-code">    acceptInput = false;</p>
			<p class="source-code">    </p>
			<p class="source-code">    // Draw the gravestone</p>
			<p class="source-code">    spriteRIP.setPosition(675, 660);</p>
			<p class="source-code">    // hide the player</p>
			<p class="source-code">    spritePlayer.setPosition(2000, 660);</p>
			<p class="source-code">    messageText.setString("SQUISHED!!");</p>
			<p class="source-code">    FloatRect textRect = messageText.getLocalBounds();</p>
			<p class="source-code">    messageText.setOrigin(textRect.left +</p>
			<p class="source-code">        textRect.width / 2.0f,</p>
			<p class="source-code">        textRect.top + textRect.height / 2.0f);</p>
			<p class="source-code">    messageText.setPosition(1920 / 2.0f, 1080 / 2.0f);</p>
			<p class="source-code"><strong class="bold">    // Play the death sound</strong></p>
			<p class="source-code"><strong class="bold">    death.play();</strong></p>
			<p class="source-code">}</p>
			<p>That's it! We have finished the first game. Let's discuss some possible enhancements before we move on to the second project.</p>
			<h1 id="_idParaDest-148"><a id="_idTextAnchor151"/>Improving the game and the code</h1>
			<p>Take a look at these suggested enhancements for the Timber!!! project. You can see the enhancements in action in the <strong class="source-inline">Runnable</strong> folder of the download bundle:</p>
			<ul>
				<li><strong class="bold">Speed up the code:</strong> There is a part of our code that is slowing down our game. It doesn't matter for this simple game, but we can speed things up by putting the <strong class="source-inline">sstream</strong> code in a block that only executes occasionally. After all, we don't need to update the score thousands of times a second!</li>
				<li><strong class="bold">Debugging console:</strong> Let's add some more text so that we can see the current frame rate. Like the score, we don't need to update this too often. Once every hundred frames will do.</li>
				<li><strong class="bold">Add more trees to the background:</strong> Simply add some more tree sprites and draw them in whatever position looks good (some nearer the camera and some further away).</li>
				<li><strong class="bold">Improve the visibility of the HUD text:</strong> We can draw simple <strong class="source-inline">RectangleShape</strong> objects behind the score and the FPS counter. Black with a bit of transparency will look quite good.</li>
				<li><strong class="bold">Make the cloud code more efficient:</strong> As we alluded to a few times already, we can use our knowledge of arrays to make the cloud code a lot shorter.</li>
			</ul>
			<p>Take a look at the game in action with extra trees, clouds, and a transparent background for the text:</p>
			<div>
				<div id="_idContainer052" class="IMG---Figure">
					<img src="image/B14278_05_04.jpg" alt=""/>
				</div>
			</div>
			<p>To see the code for these enhancements, take a look in the <strong class="source-inline">Timber Enhanced Version </strong>folder of the download bundle.</p>
			<h1 id="_idParaDest-149"><a id="_idTextAnchor152"/>Summary</h1>
			<p>In this chapter, we added the finishing touches and graphics to the Timber!!! game. If, prior to this book, you had never coded a single line of C++, then you can give yourself a big pat on the back. In just five modest chapters, you have gone from zero knowledge to a working game.</p>
			<p>However, we will not be congratulating ourselves for too long because, in the next chapter, we will move straight on to some slightly more hardcore C++. While the next game, a simple Pong game, in some ways is simpler than Timber!!, learning about writing our own classes will prepare us for building more complicated and fuller-featured games.</p>
			<h1 id="_idParaDest-150"><a id="_idTextAnchor153"/>FAQ</h1>
			<p>Q) I admit that the arrays solution for the clouds was more efficient. But do we really need three separate arrays—one for active, one for speed, and one for the sprite itself?</p>
			<p>A) If we look at the properties/variables that various objects have, for example, <strong class="source-inline">Sprite</strong> objects, we will see they are numerous. Sprites have position, color, size, rotation, and more as well. But it would be just perfect if they had <strong class="source-inline">active</strong>, <strong class="source-inline">speed</strong>, and perhaps some more. The problem is that the coders at SFML can't possibly predict all of the ways that we will want to use their <strong class="source-inline">Sprite</strong> class. Fortunately, we can make our own classes. We could make a class called <strong class="source-inline">Cloud</strong> that has a Boolean for <strong class="source-inline">active</strong> and <strong class="source-inline">int</strong> for speed. We can even give our <strong class="source-inline">Cloud</strong> class an SFML <strong class="source-inline">Sprite</strong> object. We could then simplify our cloud code even further. We will look at designing our own classes in the next chapter.</p>
		</div>
	</body></html>