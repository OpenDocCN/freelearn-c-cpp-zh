<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Space Rocks</h1>
                
            
            <article>
                
<p class="calibre2">By now, you should be getting more comfortable with working in Godot; adding nodes, creating scripts, modifying properties in the <span class="calibre5">Inspector</span>, and so on. As you progress through this book, you won't be forced to rehash the basics again and again. If you find yourself stuck, or feeling like you don't quite remember how something is done, feel free to jump back to a previous project where it was explained in more detail. As you repeat the more common actions in Godot, they will start to feel more and more familiar. At the same time, each chapter will introduce you to more nodes and techniques to expand your understanding of Godot's features.</p>
<p class="calibre2">In this next project, you'll make a space shooter game similar to the arcade classic Asteroids. The player will control a ship that can rotate and move in any direction. The goal will be to avoid the floating <em class="calibre17">space rocks</em> and shoot them with the ship's laser. Refer to the following screenshot:</p>
<div class="cdpaligncenter1"><img src="../images/00077.jpeg" class="calibre93"/></div>
<p class="calibre2">You will learn about the following key topics in this project:</p>
<ul class="calibre10">
<li class="calibre11">Physics using <kbd class="calibre12">RigidBody2D</kbd></li>
<li class="calibre11">Finite State Machines</li>
<li class="calibre11"><span>Building a dynamic, scalable UI</span></li>
<li class="calibre11">Sound and music</li>
<li class="calibre11">Particle effects</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Project setup</h1>
                
            
            <article>
                
<p class="calibre2">Create a new project and download the project assets from <a href="https://github.com/PacktPublishing/Godot-Game-Engine-Projects/releases" class="calibre9">https://github.com/PacktPublishing/Godot-Game-Engine-Projects/releases</a>.</p>
<p class="calibre2">For this project, you'll set up custom input actions using the <span class="calibre5">Input Map</span>. Using this feature, y<span class="calibre5">ou can define custom events and assign different keys, mouse events, or other inputs to them. This allows for more flexibility in designing your game, as your code can be written to respond to the <kbd class="calibre12">jump</kbd> input, for example, without needing to know exactly what input the user pressed to make the event happen. This allows you to make the same code work on different devices, even if they have different hardware. In addition, since many gamers expect to be able to customize a game's inputs, this enables you to provide that option to the user as well.</span></p>
<p class="calibre2">To set up the inputs for this game, open <span class="calibre5">Project</span> | <span class="calibre5">Project Settings</span> and select the <span class="calibre5">Input Map</span> tab.</p>
<p class="calibre2">You'll need to create four new input actions: <kbd class="calibre12">rotate_left</kbd>, <kbd class="calibre12">rotate_right</kbd>, <kbd class="calibre12">thrust</kbd>, and <kbd class="calibre12">shoot</kbd>. Type the name of each action into the <span class="calibre5">Action</span> box and click <span class="calibre5">Add</span>. Then, for each action, click the <span class="calibre5">+</span> button and select the type of input to assign. For example, to allow the player to use both the arrow keys and the popular WASD alternative, the setup will look like this:</p>
<div class="cdpaligncenter1"><img src="../images/00078.jpeg" class="calibre94"/></div>
<p class="calibre2">If you have a gamepad or other controller connected to your computer, you can also add its inputs to the actions in the same way. Note: we're only considering button-style inputs at this stage, so while you'll be able to use a d-pad for this project, using an analog joystick would require changes to the project's code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Rigid body physics</h1>
                
            
            <article>
                
<p class="calibre2">In game development, <span class="calibre5">you often need to know when two objects in the game space intersect or come into contact. This is known as </span><em class="calibre17">collision detection</em><span class="calibre5">. When a collision is detected, you typically want something to happen. This is known as </span><em class="calibre17">collision response</em><span class="calibre5">.</span></p>
<p class="calibre2">Godot offers three kinds of physics bodies, grouped under the <kbd class="calibre12">PhysicsBody2D</kbd> object type:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre12">StaticBody2D</kbd>: A static body is one that is not moved by the physics engine. It participates in collision detection, but does not move in response to the collision. This type of body is most often used for objects that are part of the environment or do not need to have any dynamic behavior, such as walls or the ground.</li>
</ul>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre12">RigidBody2D</kbd>: This <span>is the physics body in Godot that provides simulated physics. This means that you don't control a </span><kbd class="calibre12">RigidBody2D</kbd><span> directly. Instead, you apply forces to it (gravity, impulses, and so on) and Godot's built-in physics engine calculates the resultant movement, including collisions, bouncing, rotating, and other effects.</span></li>
</ul>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre12">KinematicBody2D</kbd>: This body type provides collision detection, but no physics. All movement must be implemented in code, and you must implement any collision response yourself. Kinematic bodies are most often used for player characters or other actors that require <em class="calibre20">arcade-style</em> physics rather than realistic simulation.</li>
</ul>
<p class="calibre2">Understanding when to use a particular physics body type is a big part of building your game. Using the right node can simplify your development, while trying to force the wrong node to do the job can lead to frustration and poor results. As you work with each type of body, you'll come to learn their pros and cons and get a feel for when they can help build what you need.</p>
<p class="calibre2">In this project, you'll be using the <kbd class="calibre12">RigidBody2D</kbd> node for the player ship as well as the <em class="calibre17">space rocks</em> themselves. You'll learn about the other body types in later chapters.</p>
<p class="calibre2">Individual <kbd class="calibre12">RigidBody2D</kbd> nodes have many properties you can use to customize their behavior, such as <kbd class="calibre12">Mass</kbd>, <kbd class="calibre12">Friction</kbd>, or <kbd class="calibre12">Bounce</kbd>. These properties can be set in the <span class="calibre5">Inspector</span>:</p>
<div class="cdpaligncenter1"><img src="../images/00079.jpeg" class="calibre95"/></div>
<p class="calibre2">Rigid bodies are also affected by the world's properties, which can be set in the <span class="calibre5">Project Settings</span> under <span class="calibre5">Physics</span> | <span class="calibre5">2D</span>. These settings apply to all bodies in the world. Refer to the following screenshot:</p>
<div class="cdpaligncenter1"><img src="../images/00080.jpeg" class="calibre96"/></div>
<p class="calibre2">In most cases, you won't need to modify these settings. However, note that by default, gravity has a value of <kbd class="calibre12">98</kbd> and a direction of <kbd class="calibre12">(0, 1)</kbd> (downward). If you want to change the world gravity, you can do that here. You should also be aware of the last two properties, <span class="calibre5">Default Linear Damp</span> and <span class="calibre5">Default Angular Damp</span>. These properties control how quickly a body will lose forward speed and rotation speed, respectively. Setting them to lower values will make the world feel frictionless, while using larger values will feel like your objects are moving through mud.</p>
<div class="packt_infobox"><kbd class="calibre51">Area2D</kbd> nodes can also be used to affect rigid body physics by using the <span class="calibre24">Space Override</span> property. Custom gravity and damping values will then be applied to any bodies that enter the area.</div>
<p class="calibre2"><span class="calibre5">Since this game will be taking place in outer space, gravity won't be needed, so set <span class="calibre5">Default Gravity</span> to </span><kbd class="calibre12">0</kbd><span class="calibre5">. You can leave the other settings as they are.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Player ship</h1>
                
            
            <article>
                
<p class="calibre2">The player ship is the heart of the game. Most of the code you'll write for this project will be about making the ship work. It will be controlled in the classic Asteroids style, with left/right rotation and forward thrust. It will also detect the shoot input to allow the player to fire the laser and destroy the floating rocks.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Body setup and physics</h1>
                
            
            <article>
                
<p class="calibre2">Create a new scene and add a <kbd class="calibre12">RigidBody2D</kbd> named <kbd class="calibre12">Player</kbd> as the root node, with <kbd class="calibre12">Sprite</kbd> and <kbd class="calibre12">CollisionShape2D</kbd> children. Add the <kbd class="calibre12">res://assets/player_ship.png</kbd> image to the <span class="calibre5">Texture</span> property of the <kbd class="calibre12">Sprite</kbd>. The ship image is quite large, so set the <span class="calibre5">Scale</span> property of the <kbd class="calibre12">Sprite</kbd> to <kbd class="calibre12">(0.5, 0.5)</kbd>and its <span class="calibre5">Rotation</span> to <kbd class="calibre12">90</kbd>.</p>
<div class="packt_infobox">The image for the ship is drawn pointing upwards. In Godot, a rotation of <kbd class="calibre51">0</kbd> degrees points to the right (along the <em class="calibre55">x</em> axis). This means you need to set the <span class="calibre24">Rotation</span> of the <kbd class="calibre51">Sprite</kbd> node to <kbd class="calibre51">90</kbd> so it will match the body's direction.</div>
<p class="calibre2">In the <span class="calibre5">Shape</span> property of <kbd class="calibre12"><span>CollisionShape2D</span></kbd>, add a <kbd class="calibre12">CircleShape2D</kbd> and scale it to cover the image as closely as possible (remember not to move the rectangular size handles):</p>
<div class="cdpaligncenter1"><img src="../images/00081.jpeg" class="calibre97"/></div>
<p class="calibre2">Save the scene. When working on larger-scale projects, it is recommended to organize your scenes and scripts into folders based on each game object. For example, if you make a <kbd class="calibre12">player</kbd> folder, you can save player-related files there. This makes it easier to find and modify your files rather than having them all together in a single folder. While this project is relatively small, it's a good habit to adopt as your projects grow in size and complexity.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">State machines</h1>
                
            
            <article>
                
<p class="calibre2">The player ship can be in a number of different states during gameplay. For example, when <em class="calibre17">alive,</em> the ship is visible and can be controlled by the player, but is vulnerable to being hit by rocks. On the other hand, when <em class="calibre17">invulnerable, </em>the ship should appear semi-transparent and immune to damage.</p>
<p class="calibre2">One way that programmers often handle situations like this is to add Boolean flag variables to the code. For example, the <kbd class="calibre12">invulnerable</kbd> flag is set to <kbd class="calibre12">true</kbd> when the player spawns, or when the <kbd class="calibre12">alive</kbd> flag is set to <kbd class="calibre12">false</kbd> when the player is dead. However, this can lead to errors and strange situations where both the <kbd class="calibre12">alive</kbd> and <kbd class="calibre12">invulnerable</kbd> flags are set to <kbd class="calibre12">true</kbd> at the same time. What happens when a rock hits the player in this situation? The two states are mutually exclusive, so this shouldn't be allowed to happen.</p>
<p class="calibre2">One solution to this problem is to use a <strong class="calibre4">Finite State Machine</strong> (<strong class="calibre4">FSM</strong>). When using an FSM, an entity can only be in one state at a given time. To design your FSM, you define some number of states and what events or actions can cause a transition from one state to another.</p>
<p class="calibre2">The following diagram outlines the FSM for the player ship:</p>
<div class="cdpaligncenter1"><img src="../images/00082.jpeg" class="calibre98"/></div>
<p class="calibre2">There are four states, and the arrows indicate what transitions are allowed, as well as what event triggers the transition. By checking the current state, you can decide what the player is allowed to do. For example, in the <strong class="calibre4">DEAD</strong> state, don't allow input, or in the <strong class="calibre4">INVULNERABLE</strong> state, don't allow shooting.</p>
<p class="calibre2">Advanced FSM implementations can become quite complex, and the details are beyond the scope of this book (see the <a href="" class="calibre9">Appendix</a> for further reading). In the purest sense, you technically won't be creating a true FSM, but f<span class="calibre5">or the purposes of this project, it will be sufficient to illustrate the concept and keep you from running into the Boolean flag problem.</span></p>
<p class="calibre2">Add a script to the <kbd class="calibre12">Player</kbd> node and start by creating the skeleton of the FSM implementation:</p>
<pre class="calibre18">extends RigidBody2D<br class="title-page-name"/><br class="title-page-name"/>enum {INIT, ALIVE, INVULNERABLE, DEAD}<br class="title-page-name"/>var state = null</pre>
<p class="calibre2">An <kbd class="calibre12">enum</kbd> (short for enumeration) is a convenient way to create a set of constants. The <kbd class="calibre12">enum</kbd> statement in the preceding code snippet is equivalent to the following code:</p>
<pre class="calibre18">const INIT = 0<br class="title-page-name"/>const ALIVE = 1<br class="title-page-name"/>const INVULNERABLE = 2<br class="title-page-name"/>const DEAD = 3</pre>
<p class="calibre2">You can also assign a name to an <kbd class="calibre12">enum</kbd>, which is useful when you have more than one collection of constants in a single script. For example:</p>
<pre class="calibre18">enum States {INIT, ALIVE}<br class="title-page-name"/><br class="title-page-name"/>var state = States.INIT</pre>
<p class="calibre2">However, this isn't needed in this script, as you'll only be using the one <kbd class="calibre12">enum</kbd> to track the ship's states.</p>
<p class="calibre2">Next, create the <kbd class="calibre12">change_state</kbd> function to handle state transitions:</p>
<pre class="calibre18">func _ready():<br class="title-page-name"/>    change_state(ALIVE)<br class="title-page-name"/> <br class="title-page-name"/>func change_state(new_state):<br class="title-page-name"/>    match new_state:<br class="title-page-name"/>        INIT:<br class="title-page-name"/>            $CollisionShape2D.disabled = true<br class="title-page-name"/>        ALIVE:<br class="title-page-name"/>            $CollisionShape2D.disabled = false<br class="title-page-name"/>        INVULNERABLE:<br class="title-page-name"/>            $CollisionShape2D.disabled = true<br class="title-page-name"/>        DEAD:<br class="title-page-name"/>            $CollisionShape2D.disabled = true<br class="title-page-name"/>    state = new_state</pre>
<p class="calibre2">Whenever you need to change the state of the player, you'll call the <kbd class="calibre12">change_state()</kbd> function and pass it the value of the new state. Then, by using a <kbd class="calibre12">match</kbd> statement, you can execute whatever code should accompany the transition to the new state. To illustrate this, the <kbd class="calibre12">CollisionShape2D</kbd> is being enabled/disabled by the <kbd class="calibre12">new_state</kbd> value. In <kbd class="calibre12">_ready()</kbd>, you specify the initial state—currently <kbd class="calibre12">ALIVE</kbd> so that you can test, but you'll change it to <kbd class="calibre12">INIT</kbd> later.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Controls</h1>
                
            
            <article>
                
<p class="calibre2">Add the following variables to the script:</p>
<pre class="calibre18">export (int) var engine_power<br class="title-page-name"/>export (int) var spin_power<br class="title-page-name"/> <br class="title-page-name"/>var thrust = Vector2()<br class="title-page-name"/>var rotation_dir = 0</pre>
<p class="calibre2"><kbd class="calibre12">engine_power</kbd> and <kbd class="calibre12">spin_power</kbd> control how fast the ship can accelerate and turn. In the Inspector, set them to <kbd class="calibre12">500</kbd> and <kbd class="calibre12">15000</kbd>, respectively. <kbd class="calibre12">thrust</kbd> will represent the force being applied by the ship's engine: either <kbd class="calibre12">(0, 0)</kbd> when coasting, or a vector with the length of <kbd class="calibre12">engine_power</kbd> when powered on. <kbd class="calibre12">rotation_dir</kbd> will represent what direction the ship is turning in and apply a torque, or rotational force.</p>
<p class="calibre2">By default, the physics settings provide some <em class="calibre17">damping</em>, which reduces a body's velocity and spin. In space, there's no friction, so for realism there shouldn't be any damping at all. However, for an arcade-style feel, it's preferable that the ship should stop when you let go of the keys. In the <span class="calibre5">Inspector</span>, set the player's <span class="calibre5">Linear</span>/<span class="calibre5">Damp</span> to <kbd class="calibre12">1</kbd> and its <span class="calibre5">Angular</span>/<span class="calibre5">Damp</span> to <kbd class="calibre12">5</kbd>.</p>
<p class="calibre2">The next step is to detect the input and move the ship:</p>
<pre class="calibre18">func _process(delta):<br class="title-page-name"/>    get_input()<br class="title-page-name"/> <br class="title-page-name"/>func get_input():<br class="title-page-name"/>    thrust = Vector2()<br class="title-page-name"/>    if state in [DEAD, INIT]:<br class="title-page-name"/>        return<br class="title-page-name"/>    if Input.is_action_pressed("thrust"):<br class="title-page-name"/>        thrust = Vector2(engine_power, 0)<br class="title-page-name"/>    rotation_dir = 0<br class="title-page-name"/>    if Input.is_action_pressed("rotate_right"):<br class="title-page-name"/>        rotation_dir += 1<br class="title-page-name"/>    if Input.is_action_pressed("rotate_left"):<br class="title-page-name"/>        rotation_dir -= 1<br class="title-page-name"/><br class="title-page-name"/>func _physics_process(delta):<br class="title-page-name"/>    set_applied_force(thrust.rotated(rotation))<br class="title-page-name"/>    set_applied_torque(spin_power * rotation_dir)<br class="title-page-name"/><br class="title-page-name"/></pre>
<p class="calibre2">The <kbd class="calibre12">get_input()</kbd> function captures the key actions and sets the ship's thrust on or off, and the rotation direction (<kbd class="calibre12">rotation_dir</kbd>) to a positive or negative value (representing clockwise or counter-clockwise rotation). This function is called every frame in <kbd class="calibre12">_process()</kbd>. Note that if the state is <kbd class="calibre12">INIT</kbd> or <kbd class="calibre12">DEAD</kbd>, <kbd class="calibre12">get_input()</kbd> will exit by using <kbd class="calibre12">return</kbd> before checking for key actions.</p>
<p class="calibre2">When using physics bodies, their movement and related functions should be called in <kbd class="calibre12">_physics_process()</kbd>. Here, you can use <kbd class="calibre12">set_applied_force()</kbd> to apply the engine thrust in whatever direction the ship is facing. Then, you can use <kbd class="calibre12">set_applied_torque()</kbd> to cause the ship to rotate.</p>
<p class="calibre2">Play the scene and you should be able to fly around freely.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Screen wrap</h1>
                
            
            <article>
                
<p class="calibre2">Another feature of classic 2D arcade games is <em class="calibre17">screen wrap</em>. If the player goes off one side of the screen, they <em class="calibre17">appear</em> on the other side. In practice, you teleport or instantaneously change the ship's position to the opposite side. Add the following <span class="calibre5">to the class variables at the top of the script:</span></p>
<pre class="calibre18">var screensize = Vector2() </pre>
<p class="calibre2">And add this to <kbd class="calibre12">_ready()</kbd>:</p>
<pre class="calibre18">screensize = get_viewport().get_visible_rect().size</pre>
<p class="calibre2">Later, the game's main script will handle setting <kbd class="calibre12">screensize</kbd> for all of the game's objects, but for now, this will allow you to test the screen wrapping with just the player scene.</p>
<p class="calibre2">When first approaching this problem, you might think you could use the body's <kbd class="calibre12">position</kbd> property and, if it exceeds the bounds of the screen, set it to the opposite side. However, when using <kbd class="calibre12">RigidBody2D</kbd>, you can't directly set its <kbd class="calibre12">position</kbd>, because that would conflict with the movement that the physics engine is calculating. A common mistake is to try adding something like this to <kbd class="calibre12">_physics_process()</kbd>:</p>
<pre class="calibre18">func _physics_process(delta):<br class="title-page-name"/>    if position.x &gt; screensize.x:<br class="title-page-name"/>        position.x = 0<br class="title-page-name"/>    if position.x &lt; 0:<br class="title-page-name"/>        position.x = screensize.x<br class="title-page-name"/>    if position.y &gt; screensize.y:<br class="title-page-name"/>        position.y = 0<br class="title-page-name"/>    if position.y &lt; 0:<br class="title-page-name"/>        position.y = screensize.y<br class="title-page-name"/>    set_applied_force(thrust.rotated(rotation))<br class="title-page-name"/>    set_applied_torque(rotation_dir * spin_thrust)</pre>
<p class="calibre2">This will fail, trapping the player on the edge of the screen (and occasionally <em class="calibre17">glitching</em> unpredictably at the corners). So, why doesn't this work? The Godot documentation recommends <kbd class="calibre12">_physics_process()</kbd> for physics-related code—it even has <em class="calibre17">physics</em> in the name. It makes sense at first glance that this should work correctly.</p>
<p class="calibre2">In fact, the correct way to solve this problem is <em class="calibre17">not</em> to use <kbd class="calibre12">_physics_process()</kbd>.</p>
<p class="calibre2">To quote the <kbd class="calibre12">RigidBody2D</kbd> docs:</p>
<div class="packt_quote">"You should not change a RigidBody2D's position or linear_velocity every frame or even very often. If you need to directly affect the body's state, use _integrate_forces, which allows you to directly access the physics state."</div>
<p class="calibre2">And in the description for <kbd class="calibre12">_integrate_forces()</kbd>:</p>
<div class="packt_quote">"(It) Allows you to read and safely modify the simulation state for the object. Use this instead of _physics_process if you need to directly change the body's position or other physics properties. (emphasis added)"</div>
<p class="calibre2">The answer is to change the physics callback to <kbd class="calibre12">_integrate_forces()</kbd>, which gives you access to the body's <kbd class="calibre12">Physics2DDirectBodyState</kbd>. This is a Godot object containing a great deal of useful information about the current physics state of the body. In the case of location, the key piece of information is the body's <kbd class="calibre12">Transform2D</kbd>.</p>
<p class="calibre2">A <em class="calibre17">transform</em> is a matrix representing one or more transformations in 2D space such as translation, rotation, and/or scaling. The translation (that is, position) information is found by accessing the <kbd class="calibre12">origin</kbd> property of the <kbd class="calibre12"><span>Transform2D</span></kbd>.</p>
<p class="calibre2">Using this information, you can implement the wrap around effect by changing <kbd class="calibre12">_physics_process()</kbd> to <kbd class="calibre12">_integrate_forces()</kbd> and altering the transform's origin:</p>
<pre class="calibre18">func _integrate_forces(physics_state):<br class="title-page-name"/>    set_applied_force(thrust.rotated(rotation))<br class="title-page-name"/>    set_applied_torque(spin_power * rotation_dir)<br class="title-page-name"/>    var xform = physics_state.get_transform()<br class="title-page-name"/>    if xform.origin.x &gt; screensize.x:<br class="title-page-name"/>        xform.origin.x = 0<br class="title-page-name"/>    if xform.origin.x &lt; 0:<br class="title-page-name"/>        xform.origin.x = screensize.x<br class="title-page-name"/>    if xform.origin.y &gt; screensize.y:<br class="title-page-name"/>        xform.origin.y = 0<br class="title-page-name"/>    if xform.origin.y &lt; 0:<br class="title-page-name"/>        xform.origin.y = screensize.y<br class="title-page-name"/>    physics_state.set_transform(xform)</pre>
<p class="calibre2">Note that the function's argument name has been changed to <kbd class="calibre12">physics_state</kbd> from its default: <kbd class="calibre12">state</kbd>. This is to prevent any possible confusion with the already existing <kbd class="calibre12">state</kbd> variable, which tracks what FSM state the player is currently assigned to.</p>
<p class="calibre2">Run the scene again and check that everything is working as expected. Make sure you try wrapping around in all four directions. A common mistake is to accidentally flip a greater-than or less-than sign, so check that first if you're having a problem with one or more screen edges.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Shooting</h1>
                
            
            <article>
                
<p class="calibre2">Now, it's time to give your ship some weapons. When pressing the <kbd class="calibre12">shoot</kbd> action, a bullet should be spawned at the front of the ship and travel in a straight line until it exits the screen. Then, the gun isn't allowed to fire again until a small amount of time has passed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Bullet scene</h1>
                
            
            <article>
                
<p class="calibre2">This is the node setup for the bullet:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre12">Area2D</kbd> (named <kbd class="calibre12">Bullet</kbd>)</li>
<li class="calibre11"><kbd class="calibre12">Sprite</kbd></li>
<li class="calibre11"><kbd class="calibre12">CollisionShape2D</kbd></li>
<li class="calibre11"><kbd class="calibre12">VisibilityNotifier2D</kbd></li>
</ul>
<p class="calibre2">Use <kbd class="calibre12">res://assets/laser.png</kbd> from the assets folder for the texture of the <kbd class="calibre12">Sprite</kbd>, and a <kbd class="calibre12">CapsuleShape2D</kbd> for the collision shape. You'll have to set the <span class="calibre5">Rotation</span> of the <kbd class="calibre12">CollisionShape2D</kbd> to <kbd class="calibre12">90</kbd> so that it will fit correctly. You should also scale the <kbd class="calibre12">Sprite</kbd> down to half size (<kbd class="calibre12">(0.5, 0.5)</kbd>).</p>
<p class="calibre2">Add the following script to the <kbd class="calibre12">Bullet</kbd> node:</p>
<pre class="calibre18">extends Area2D<br class="title-page-name"/><br class="title-page-name"/>export (int) var speed<br class="title-page-name"/>var velocity = Vector2()<br class="title-page-name"/><br class="title-page-name"/>func start(pos, dir):<br class="title-page-name"/>    position = pos<br class="title-page-name"/>    rotation = dir<br class="title-page-name"/>    velocity = Vector2(speed, 0).rotated(dir)<br class="title-page-name"/> <br class="title-page-name"/>func _process(delta):<br class="title-page-name"/>    position += velocity * delta</pre>
<p class="calibre2"><br class="calibre6"/>
Set the exported <kbd class="calibre12">speed</kbd> property to <kbd class="calibre12">1000</kbd>.</p>
<p class="calibre2">The <kbd class="calibre12">VisibilityNotifier2D</kbd> is a node that can inform you (using signals) whenever a node becomes visible/invisible. You can use this to automatically delete a bullet when it goes off screen. Connect the <kbd class="calibre12">screen_exited</kbd> signal of <kbd class="calibre12">VisibilityNotifier2D</kbd> and add this:</p>
<pre class="calibre18">func _on_VisibilityNotifier2D_screen_exited():<br class="title-page-name"/>    queue_free()</pre>
<p class="calibre2">Finally, connect the bullet's <kbd class="calibre12">body_entered</kbd> signal so that you can detect when the bullet hits a rock. The bullet doesn't need to <em class="calibre17">know</em> anything about rocks, just that it has hit something. When you create the rocks, you'll add them to a group called <kbd class="calibre12">rocks</kbd> and give them an <kbd class="calibre12">explode()</kbd> method:</p>
<pre class="calibre18">func _on_Bullet_body_entered( body ):<br class="title-page-name"/>    if body.is_in_group('rocks'):<br class="title-page-name"/>        body.explode()<br class="title-page-name"/>        queue_free()</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Firing bullets</h1>
                
            
            <article>
                
<p class="calibre2">Now, you need instances of the bullet to be created whenever the player fires. However, if you make the bullet a child of the player, then it will move and rotate along with the player instead of moving independently. Instead, the bullet should be added as a child of the main scene. One way to do this would be to use <kbd class="calibre12">get_parent().add_child()</kbd>, since the <kbd class="calibre12">Main</kbd> scene will be the parent of the player when the game is running. However, this would mean you could no longer run the <kbd class="calibre12">Player</kbd> scene by itself like you have been doing, because <kbd class="calibre12">get_parent()</kbd> would produce an error. Or, if in the <kbd class="calibre12">Main</kbd> scene you decided to arrange things differently, making the player a child of some other node, the bullet wouldn't be added where you expect.</p>
<div class="packt_tip"><span class="calibre24">In general, it is a bad idea to write code that assumes a fixed tree layout. Especially try to avoid using </span><kbd class="calibre51">get_parent()</kbd><span class="calibre24"> if at all possible. You may find it difficult to think this way at first, but it will result in a much more modular design and prevent some common mistakes.</span></div>
<p class="calibre2">Instead, the player will <em class="calibre17">give</em> the bullet to the main scene using a signal. In this way, the <kbd class="calibre12">Player</kbd> scene doesn't need to <em class="calibre17">know</em> anything about how the <kbd class="calibre12">Main</kbd> scene is set up, or even if the <kbd class="calibre12">Main</kbd> scene exists. Producing the bullet and handing it off is the <kbd class="calibre12">Player</kbd> object's only responsibility.</p>
<p class="calibre2">Add a <kbd class="calibre12">Position2D</kbd> node to the player and name it <kbd class="calibre12">Muzzle</kbd>. This will mark the <em class="calibre17">muzzle</em> of the gun—the location where the bullet will spawn. Set its <span class="calibre5">Position</span> to <kbd class="calibre12">(50, 0)</kbd> to place it directly in front of the ship.</p>
<p class="calibre2">Next, add a <kbd class="calibre12">Timer</kbd> node named <kbd class="calibre12">GunTimer</kbd>. This will provide a <em class="calibre17">cooldown</em> to the gun, preventing a new bullet from firing until a certain amount of time has passed. Check the <span class="calibre5">One Shot</span> and <span class="calibre5">Autoplay</span> boxes.</p>
<p class="calibre2">Add these new variables to the player's script:</p>
<pre class="calibre18">signal shoot<br class="title-page-name"/> <br class="title-page-name"/>export (PackedScene) var Bullet<br class="title-page-name"/>export (float) var fire_rate<br class="title-page-name"/> <br class="title-page-name"/>var can_shoot = true</pre>
<p class="calibre2">Drag the <kbd class="calibre12">Bullet.tscn</kbd> onto the new <span class="calibre5">Bullet</span> property in the <span class="calibre5">Inspector</span>, and set the <span class="calibre5">Fire Rate</span> to <kbd class="calibre12">0.25</kbd> (this value is in seconds).</p>
<p class="calibre2">Add this to <kbd class="calibre12">_ready()</kbd>:</p>
<pre class="calibre18">$GunTimer.wait_time = fire_rate</pre>
<p class="calibre2">And this to <kbd class="calibre12">get_input()</kbd>:</p>
<pre class="calibre18">if Input.is_action_pressed("shoot") and can_shoot:<br class="title-page-name"/>    shoot()</pre>
<p class="calibre2">Now, create the <kbd class="calibre12">shoot()</kbd> function, which will handle creating the bullet(s):</p>
<pre class="calibre18">func shoot():<br class="title-page-name"/>    if state == INVULNERABLE:<br class="title-page-name"/>        return<br class="title-page-name"/>    emit_signal("shoot", Bullet, $Muzzle.global_position, rotation)<br class="title-page-name"/>    can_shoot = false<br class="title-page-name"/>    $GunTimer.start()</pre>
<p class="calibre2">When emitting the <kbd class="calibre12">shoot</kbd> signal, you pass the <kbd class="calibre12">Bullet</kbd> itself plus its starting position and direction. Then, you disable shooting with the <kbd class="calibre12">can_shoot</kbd> flag and start the <kbd class="calibre12">GunTimer</kbd>. To allow the gun to shoot again, connect the <kbd class="calibre12">timeout</kbd> signal of the <kbd class="calibre12">GunTimer</kbd>:</p>
<pre class="calibre18">func _on_GunTimer_timeout():<br class="title-page-name"/>    can_shoot = true</pre>
<p class="calibre2">Now, make your Main scene. Add a <kbd class="calibre12">Node</kbd> named <kbd class="calibre12">Main</kbd> and a <kbd class="calibre12">Sprite</kbd> named <kbd class="calibre12">Background</kbd>. Use <kbd class="calibre12">res://assets/space_background.png</kbd> as the Texture<em class="calibre17">.</em> Add an instance of the <kbd class="calibre12">Player</kbd> to the scene.</p>
<p class="calibre2"><span class="calibre5">Add a script to </span><kbd class="calibre12">Main</kbd><span class="calibre5">, then </span>connect the <kbd class="calibre12">Player</kbd> node's <kbd class="calibre12">shoot</kbd> signal, and add the following to the created function:</p>
<pre class="calibre18">func _on_Player_shoot(bullet, pos, dir):<br class="title-page-name"/>    var b = bullet.instance()<br class="title-page-name"/>    b.start(pos, dir)<br class="title-page-name"/>    add_child(b)</pre>
<p class="calibre2">Play the <kbd class="calibre12">Main</kbd> scene and test that you can fly and shoot.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Rocks</h1>
                
            
            <article>
                
<p class="calibre2">The goal of the game is to destroy the floating space rocks, so, now that you can shoot, it's time to add them. Like the ship, the rocks will also be <kbd class="calibre12">RigidBody2D</kbd>, which will make them travel in a straight line at a steady speed unless disturbed. They'll also <span class="calibre5">bounce off each other in a realistic fashion.</span> To make things more interesting, rocks will start out large and, when you shoot them, break into multiple smaller rocks.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Scene setup</h1>
                
            
            <article>
                
<p class="calibre2">Start a new scene by making a <kbd class="calibre12">RigidBody2D</kbd>, naming it <kbd class="calibre12">Rock</kbd>, and adding a <kbd class="calibre12">Sprite</kbd> using the <kbd class="calibre12">res://assets/rock.png</kbd> texture. Add a <kbd class="calibre12">CollisionShape2D</kbd>, but <em class="calibre17">don't</em> add a shape to it yet. Because you'll be spawning different-sized rocks, the collision shape will need to be set in the code and adjusted to the correct size.</p>
<p class="calibre2">Set the <span class="calibre5">Bounce</span> property of the <kbd class="calibre12">Rock</kbd> to <kbd class="calibre12">1</kbd> and both <span class="calibre5">Linear</span>/<span class="calibre5">Damp</span> and <span class="calibre5">Angular</span>/<span class="calibre5">Damp</span> to <kbd class="calibre12">0</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Variable size</h1>
                
            
            <article>
                
<p class="calibre2">Attach a script and define the member variables:</p>
<pre class="calibre18">extends RigidBody2D<br class="title-page-name"/><br class="title-page-name"/>var screensize = Vector2()<br class="title-page-name"/>var size<br class="title-page-name"/>var radius<br class="title-page-name"/>var scale_factor = 0.2</pre>
<p class="calibre2">The <kbd class="calibre12">Main</kbd> script will handle spawning new rocks, both at the beginning of a level as well as the smaller rocks that will appear after a large one explodes. A large rock will have a <kbd class="calibre12">size</kbd> of <kbd class="calibre12">3</kbd> and break into rocks of size <kbd class="calibre12">2</kbd>, and so on. The <kbd class="calibre12">scale_factor</kbd> is multiplied by <kbd class="calibre12">size</kbd> to set the sprite's scale, the collision radius, and so on. You can adjust it later to change how big each category of rock is.</p>
<p class="calibre2">All of this will be set by the <kbd class="calibre12">start()</kbd> method:</p>
<pre class="calibre18">func start(pos, vel, _size):<br class="title-page-name"/>    position = pos<br class="title-page-name"/>    size = _size<br class="title-page-name"/>    mass = 1.5 * size<br class="title-page-name"/>    $Sprite.scale = Vector2(1, 1) * scale_factor * size<br class="title-page-name"/>    radius = int($Sprite.texture.get_size().x / 2 * scale_factor * size)<br class="title-page-name"/>    var shape = CircleShape2D.new()<br class="title-page-name"/>    shape.radius = radius<br class="title-page-name"/>    $CollisionShape2D.shape = shape<br class="title-page-name"/>    linear_velocity = vel<br class="title-page-name"/>    angular_velocity = rand_range(-1.5, 1.5)</pre>
<p class="calibre2">Here is where you calculate the correct collision shape based on the rock's <kbd class="calibre12">size</kbd> and add it to the <kbd class="calibre12">CollisionShape2D</kbd>. Note that since <kbd class="calibre12">size</kbd> is already in use as a class variable, you can use <kbd class="calibre12">_size</kbd> for the function argument.</p>
<p class="calibre2">The rocks also need to wrap around the screen, so use the same technique you used for the <kbd class="calibre12">Player</kbd>:</p>
<pre class="calibre18">func _integrate_forces(physics_state):<br class="title-page-name"/>    var xform = physics_state.get_transform()<br class="title-page-name"/>    if xform.origin.x &gt; screensize.x + radius:<br class="title-page-name"/>       xform.origin.x = 0 - radius<br class="title-page-name"/>    if xform.origin.x &lt; 0 - radius:<br class="title-page-name"/>       xform.origin.x = screensize.x + radius<br class="title-page-name"/>    if xform.origin.y &gt; screensize.y + radius:<br class="title-page-name"/>       xform.origin.y = 0 - radius<br class="title-page-name"/>    if xform.origin.y &lt; 0 - radius:<br class="title-page-name"/>       xform.origin.y = screensize.y + radius<br class="title-page-name"/>    physics_state.set_transform(xform)</pre>
<p class="calibre2">The difference here is that including the body's <kbd class="calibre12">radius</kbd> results in smoother-looking teleportation. The rock will appear to fully exit the screen before entering at the opposite side. You may want to do the same thing with the player ship. Try it and see which effect you like better.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Instancing</h1>
                
            
            <article>
                
<p class="calibre2">When new rocks are spawned, the main scene will need to pick a random start location. To do this, you could use some geometry to pick a random point along the perimeter of the screen, but instead you can take advantage of yet another Godot node type. You'll draw a path around the edge of the screen, and the script will pick a random location along the path. Add a <kbd class="calibre12">Path2D</kbd> node and name it <kbd class="calibre12">RockPath</kbd>. When you click on the <kbd class="calibre12">Path2D</kbd>, you will see some new buttons appear at the top of the editor:</p>
<div class="cdpaligncenter1"><img src="../images/00083.gif" class="calibre99"/></div>
<p class="calibre2">Select the middle one (<span class="calibre5">Add Point</span>) to draw the path by clicking to add the points shown. To make the points align, make sure <span class="calibre5">Snap to grid</span> is checked. This option is found under the <span class="calibre5">Snapping Options</span> button to the left of the <kbd class="calibre12">Lock</kbd> button. It appears as a series of three vertical dots. Refer to the following screenshot:</p>
<div class="cdpaligncenter1"><img src="../images/00084.jpeg" class="calibre100"/></div>
<p class="calibre2">Draw the points in the order shown in the following screenshot. After clicking the fourth point, click the <span class="calibre5">Close Curve</span> button (<strong class="calibre4">5</strong>) and your path will be complete:</p>
<div class="cdpaligncenter1"><img src="../images/00085.jpeg" class="calibre101"/></div>
<p class="calibre2">Now that the path is defined, add a <kbd class="calibre12">PathFollow2D</kbd> node as a child of <kbd class="calibre12">RockPath</kbd> and name it <kbd class="calibre12">RockSpawn</kbd>. This node's purpose is to automatically follow a path as it moves, using its <kbd class="calibre12">set_offset()</kbd> method. The higher the offset, the further along the path it goes. Since our path is closed, it will loop around if the offset value is bigger than the path's length.</p>
<p class="calibre2">Next, add a <kbd class="calibre12">Node</kbd> and name it <kbd class="calibre12">Rocks</kbd>. This node will serve as a container to hold all the rocks. By checking its number of children, you can tell if there are any rocks remaining.</p>
<p class="calibre2">Now, add this to <kbd class="calibre12">Main.gd</kbd>:</p>
<pre class="calibre18">export (PackedScene) var Rock<br class="title-page-name"/><br class="title-page-name"/>func _ready():<br class="title-page-name"/>    randomize()<br class="title-page-name"/>    screensize = get_viewport().get_visible_rect().size<br class="title-page-name"/>    $Player.screensize = screensize<br class="title-page-name"/>    for i in range(3):<br class="title-page-name"/>        spawn_rock(3)</pre>
<p class="calibre2">The script starts by getting the <kbd class="calibre12">screensize</kbd> and passing that to the <kbd class="calibre12">Player</kbd>. Then, it spawns three rocks of size <kbd class="calibre12">3</kbd> using <kbd class="calibre12">spawn_rock()</kbd>, which is defined in the following code. Don't forget to drag <kbd class="calibre12">Rock.tscn</kbd> onto the <span class="calibre5">Rock</span> property in the <span class="calibre5">Inspector</span>:</p>
<pre class="calibre18">func spawn_rock(size, pos=null, vel=null):<br class="title-page-name"/>    if !pos:<br class="title-page-name"/>        $RockPath/RockSpawn.set_offset(randi())<br class="title-page-name"/>        pos = $RockPath/RockSpawn.position<br class="title-page-name"/>    if !vel:<br class="title-page-name"/>        vel = Vector2(1, 0).rotated(rand_range(0, 2*PI)) * rand_range(100, 150)<br class="title-page-name"/>    var r = Rock.instance()<br class="title-page-name"/>    r.screensize = screensize<br class="title-page-name"/>    r.start(pos, vel, size)<br class="title-page-name"/>    $Rocks.add_child(r)</pre>
<p class="calibre2">This function will serve two purposes. When called with only a size parameter, it picks a random position along the <kbd class="calibre12">RockPath</kbd> and a random velocity. However, if those values are also provided, it will use them instead. This will let you spawn the smaller rocks at the location of the explosion.</p>
<p class="calibre2">Run the game and you should see three rocks floating around. However, your bullets don't affect them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Exploding rocks</h1>
                
            
            <article>
                
<p class="calibre2">The <kbd class="calibre12">Bullet</kbd> is checking for bodies in the <kbd class="calibre12">rocks</kbd> group, so in the <kbd class="calibre12">Rock</kbd> scene, click on the <span class="calibre5">Node</span> tab and choose <span class="calibre5">Groups</span>. Type <kbd class="calibre12">rocks</kbd> and click <span class="calibre5">Add</span>:</p>
<div class="cdpaligncenter1"><img src="../images/00086.jpeg" class="calibre102"/></div>
<p class="calibre2">Now, if you run the game and shoot a rock, you'll see an error message because the bullet is trying to call the rock's <kbd class="calibre12">explode()</kbd> method, which you haven't defined yet. This method needs to do three things:</p>
<ul class="calibre10">
<li class="calibre11">Remove the rock</li>
<li class="calibre11">Play an explosion animation</li>
<li class="calibre11">Notify <kbd class="calibre12">Main</kbd> to spawn new, smaller rocks</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Explosion scene</h1>
                
            
            <article>
                
<p class="calibre2">The explosion will be a separate scene, which you can add to the <kbd class="calibre12">Rock</kbd> and later to the <kbd class="calibre12">Player</kbd>. It will contain two nodes:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre12">Sprite</kbd> (named <kbd class="calibre12">Explosion</kbd>)</li>
<li class="calibre11"><kbd class="calibre12">AnimationPlayer</kbd></li>
</ul>
<p class="calibre2">For the sprite's <span class="calibre5">Texture</span>, use <kbd class="calibre12">res://assets/explosion.png</kbd>. You'll notice that this is a sprite sheet—an image made up of 64 smaller images laid out in a grid pattern. These images are the individual frames of the animation. You'll often find animations packaged this way, and Godot's <kbd class="calibre12">Sprite</kbd> node supports using them as individual frames.</p>
<p class="calibre2">In the Inspector, find the sprite's <span class="calibre5">Animation</span> section. Set the <span class="calibre5">Vframes</span> and <span class="calibre5">Hframes</span> both to <kbd class="calibre12">8</kbd>. This will <em class="calibre17">slice</em> the sprite sheet into its individual images. You can verify this by changing the <span class="calibre5">Frame</span> property to different values between <kbd class="calibre12">0</kbd> and <kbd class="calibre12">63</kbd>. Make sure to set <span class="calibre5">Frames</span> back to <kbd class="calibre12">0</kbd> when finished:</p>
<div class="cdpaligncenter1"><img src="../images/00087.jpeg" class="calibre103"/></div>
<p class="calibre2"><span class="calibre5">The </span><kbd class="calibre12">AnimationPlayer</kbd><span class="calibre5"> can be used to animate any property of any node. </span>You'll use the <kbd class="calibre12">AnimationPlayer</kbd> to change the <span class="calibre5">Frame</span> property over time. Start by clicking on the node and you'll see the <span class="calibre5">Animation</span> panel open at the bottom, as shown in the following screenshot:</p>
<div class="cdpaligncenter1"><img src="../images/00088.jpeg" class="calibre104"/></div>
<p class="calibre2">Click the <span class="calibre5">New Animation</span> button and name it <kbd class="calibre12">explosion</kbd>. Set the <span class="calibre5">Length</span> to <kbd class="calibre12">0.64</kbd> and the <span class="calibre5">Step</span> to <kbd class="calibre12">0.01</kbd>. Now, click on the <kbd class="calibre12">Sprite</kbd> node and you'll notice that each property in the <span class="calibre5">Inspector</span> now has a key button next to it. Each time you click on the key, you create a keyframe in the current animation. The key button next to the <span class="calibre5">Frame</span> property also has a <kbd class="calibre12">+</kbd> symbol on it, indicating that it will automatically increment the value when you add a key frame.</p>
<p class="calibre2">Click the key and confirm that you want to create a new animation track. Note that the <span class="calibre5">Frame</span> property has incremented to <kbd class="calibre12">1</kbd>. Click the key button repeatedly until you have reached the final frame (<kbd class="calibre12">63</kbd>).</p>
<p class="calibre2">Click the <span class="calibre5">Play</span> button in the <span class="calibre5">Animation</span> panel to see the animation being played.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Adding to Rock</h1>
                
            
            <article>
                
<p class="calibre2">In the <kbd class="calibre12">Rock</kbd> scene, add an instance of <kbd class="calibre12">Explosion</kbd> and add this line to <kbd class="calibre12">start()</kbd>:</p>
<pre class="calibre18">$Explosion.scale = Vector2(0.75, 0.75) * size</pre>
<p class="calibre2">This will ensure that the explosion is scaled to match the rock's size.</p>
<p class="calibre2">Add a signal called <kbd class="calibre12">exploded</kbd> at the top of the script, then add the <kbd class="calibre12">explode()</kbd> function, which will be called when the bullet hits the rock:</p>
<pre class="calibre18">func explode():<br class="title-page-name"/>    layers = 0<br class="title-page-name"/>    $Sprite.hide()<br class="title-page-name"/>    $Explosion/AnimationPlayer.play("explosion")<br class="title-page-name"/>    emit_signal("exploded", size, radius, position, linear_velocity)<br class="title-page-name"/>    linear_velocity = Vector2()<br class="title-page-name"/>    angular_velocity = 0</pre>
<p class="calibre2">The <kbd class="calibre12">layers</kbd> property ensures that the explosion will be drawn on top of the other sprites on the screen. Then, you will send a signal that will let <kbd class="calibre12">Main</kbd> know to spawn new rocks. This signal also needs to pass the necessary data so that the new rocks will have the right properties.</p>
<p class="calibre2">When the animation finishes playing, the <kbd class="calibre12">AnimationPlayer</kbd> will emit a signal. To connect it, you need to make the <kbd class="calibre12">AnimationPlayer</kbd> node visible. Right-click on the instanced <span class="calibre5">Explosion</span> and select <span class="calibre5">Editable Children</span>, then select the <kbd class="calibre12">AnimationPlayer</kbd> and connect its <kbd class="calibre12">animation_finished</kbd> signal. Make sure to select the <kbd class="calibre12">Rock</kbd> in the <span class="calibre5">Connect to Node</span> section. The end of the animation means it is safe to delete the rock:</p>
<pre class="calibre18">func _on_AnimationPlayer_animation_finished( name ):<br class="title-page-name"/>    queue_free()</pre>
<p class="calibre2">Now, test the game and check that you can see explosions when you shoot the rocks. At this point, your rock scene should look like this:</p>
<div class="cdpaligncenter1"><img src="../images/00089.jpeg" class="calibre105"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Spawning smaller rocks</h1>
                
            
            <article>
                
<p class="calibre2">The <kbd class="calibre12">Rock</kbd> is emitting the signal, but it needs to be connected in <kbd class="calibre12">Main</kbd>. You can't use the <span class="calibre5">Node</span> tab to connect it, because the <kbd class="calibre12">Rock</kbd> instances are being created in code. Signals can be connected in code as well. Add this line to the end of <kbd class="calibre12">spawn_rock()</kbd>:</p>
<pre class="calibre18">r.connect('exploded', self, '_on_Rock_exploded')</pre>
<p class="calibre2">This connects the rock's signal to a function in <kbd class="calibre12">Main</kbd> called <kbd class="calibre12">_on_Rock_exploded()</kbd>. Create that function, which will be called whenever a rock sends its <kbd class="calibre12">exploded</kbd> signal:</p>
<pre class="calibre18">func _on_Rock_exploded(size, radius, pos, vel):<br class="title-page-name"/>    if size &lt;= 1:<br class="title-page-name"/>        return<br class="title-page-name"/>    for offset in [-1, 1]:<br class="title-page-name"/>        var dir = (pos - $Player.position).normalized().tangent() * offset<br class="title-page-name"/>        var newpos = pos + dir * radius<br class="title-page-name"/>        var newvel = dir * vel.length() * 1.1<br class="title-page-name"/>        spawn_rock(size - 1, newpos, newvel)</pre>
<p class="calibre2">In this function, two new rocks are created unless the rock that was just destroyed was the smallest size it can be. The <kbd class="calibre12">offset</kbd> loop variable will ensure that they spawn and travel in opposite directions (that is, one will be the negative of the other). The <kbd class="calibre12">dir</kbd> variable finds the vector between the player and the rock, then uses <kbd class="calibre12">tangent()</kbd> to find the perpendicular to that vector. This ensures that the new rocks travel away from the player:</p>
<div class="cdpaligncenter1"><img src="../images/00090.jpeg" class="calibre106"/></div>
<p class="calibre2">Play the game once again and check that everything is working as expected.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">UI</h1>
                
            
            <article>
                
<p class="calibre2">Creating a game UI can be very complex, or at least time-consuming. Precisely placing individual elements and ensuring they work on different-sized screens and devices is the least interesting part of game development for many programmers. Godot provides a wide variety of Control nodes to assist in this process. Learning how to use the various Control nodes will help lessen the pain of creating your game's UI.</p>
<p class="calibre2">For this game, you don't need a very complex UI. The game needs to provide the following information and interactions:</p>
<ul class="calibre10">
<li class="calibre11">Start button</li>
<li class="calibre11">Status message (Get Ready or Game Over)</li>
<li class="calibre11">Score</li>
<li class="calibre11">Lives counter</li>
</ul>
<p class="calibre2">The following is a preview of what you will be able to create:</p>
<div class="cdpaligncenter1"><img src="../images/00091.jpeg" class="calibre107"/></div>
<p class="calibre2">Create a new scene, and add a <kbd class="calibre12">CanvasLayer</kbd> with the name <kbd class="calibre12">HUD</kbd> as its root node. The UI will be built on this layer by using Godot's <kbd class="calibre12">Control</kbd> <span class="calibre5">Layout</span> features.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Layout</h1>
                
            
            <article>
                
<p class="calibre2">Godot's <kbd class="calibre12">Control</kbd> nodes include a number of specialized containers. These nodes can be nested inside each other to create the precise layout you need. For example, a <kbd class="calibre12">MarginContainer</kbd> will automatically add padding around its contents, while <kbd class="calibre12">HBoxContainer</kbd> and <kbd class="calibre12">VBoxContainer</kbd> organize their contents in rows or columns, respectively.</p>
<p class="calibre2">Start by adding a <kbd class="calibre12">MarginContainer</kbd>, which will hold the score and lives counter. Under the <span class="calibre5">Layout</span> menu, select <span class="calibre5">Top Wide</span>. Then, scroll down to the <span class="calibre5">Custom Constants</span> section and set all four margins to <kbd class="calibre12">20</kbd>.</p>
<p class="calibre2">Next, add an <kbd class="calibre12">HBoxContainer</kbd>, which will hold the score counter on the left and the lives counter on the right. Under this container, add a <kbd class="calibre12">Label</kbd> (name it <kbd class="calibre12">ScoreLabel</kbd>) and another <kbd class="calibre12">HBoxContainer</kbd> (name it <kbd class="calibre12">LivesCounter</kbd>).</p>
<p class="calibre2">Set the <kbd class="calibre12">ScoreLabel</kbd> <span class="calibre5">Text</span> to <kbd class="calibre12">0</kbd> and, under <kbd class="calibre12">Size Flags</kbd>, set <span class="calibre5">Horizontal</span> to <span class="calibre5">Fill</span>, <span class="calibre5">Expand</span>. Under <span class="calibre5">Custom Fonts</span>, add a <kbd class="calibre12">DynamicFont</kbd> like you did in <a href="part0022.html#KVCC0-5809b3bef8d2453086d97dfad17b2ee2" class="calibre9">Chapter 1</a>, <em class="calibre17">Introduction</em>, using <kbd class="calibre12">res://assets/kenvector_future_thin.ttf</kbd> from the <kbd class="calibre12">assets</kbd> folder and setting the size to <kbd class="calibre12">64</kbd>.</p>
<p class="calibre2">Under the <kbd class="calibre12">LivesCounter</kbd>, add a <kbd class="calibre12">TextureRect</kbd> and name it <kbd class="calibre12">L1</kbd>. Drag <kbd class="calibre12">res://assets/player_small.png</kbd> into the <span class="calibre5">Texture</span> property and set the <span class="calibre5">Stretch Mode</span> to <span class="calibre5">Keep Aspect Centered</span>. Make sure you have the <kbd class="calibre12">L1</kbd> node selected and press Duplicate (<em class="calibre17">Ctrl</em> + <em class="calibre17">D</em>) two times to create <kbd class="calibre12">L2</kbd> and <kbd class="calibre12">L3</kbd> (they'll be named automatically). During the game, the <kbd class="calibre12">HUD</kbd> will show/hide these three textures to indicate how many lives the user has left.</p>
<p class="calibre2">In a larger, more complicated UI, you could save this section as its own scene and embed it in other sections of the UI. However, this game only needs a few more pieces for its UI, so it's fine to combine them all in one scene.</p>
<p class="calibre2">As a child of the <kbd class="calibre12">HUD</kbd> node, add a <kbd class="calibre12">TextureButton</kbd> (named <kbd class="calibre12">StartButton</kbd>), a <kbd class="calibre12">Label</kbd> (named <kbd class="calibre12">MessageLabel</kbd>), and a <kbd class="calibre12">Timer</kbd> (named <kbd class="calibre12">MessageTimer</kbd>).</p>
<p class="calibre2">In the <kbd class="calibre12">res://assets</kbd> folder, there are two textures for the <kbd class="calibre12">StartButton</kbd>, one normal (<kbd class="calibre12">play_button.png</kbd>) and one to show when the mouse is hovering over it (<kbd class="calibre12">play_button_h.png</kbd>). Drag these to the <span class="calibre5">Textures</span>/<span class="calibre5">Normal</span> and <span class="calibre5">Textures</span>/<span class="calibre5">Hover</span> properties, respectively. In the <span class="calibre5">Layout</span> menu, choose <span class="calibre5">Center</span>.</p>
<p class="calibre2">For the <kbd class="calibre12">MessageLabel</kbd>, make sure you set the font first before specifying the layout, or it won't be centered properly. You can use the same settings you used for the <kbd class="calibre12">ScoreLabel</kbd>. After setting the font, set the layout to <span class="calibre5">Full Rect</span>.</p>
<p class="calibre2">Finally, set the <span class="calibre5">One Shot</span> property of <kbd class="calibre12"><span>MessageTimer</span></kbd> to <span class="calibre5">On</span> and its <span class="calibre5">Wait Time</span> to <kbd class="calibre12">2</kbd>.</p>
<p class="calibre2">When finished, your UI's scene tree should look like this:</p>
<div class="cdpaligncenter1"><img src="../images/00092.jpeg" class="calibre108"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">UI functions</h1>
                
            
            <article>
                
<p class="calibre2">You've completed the UI layout, so now let's add a script to <kbd class="calibre12">HUD</kbd> so you can add the functionality:</p>
<pre class="calibre18">extends CanvasLayer<br class="title-page-name"/><br class="title-page-name"/>signal start_game<br class="title-page-name"/><br class="title-page-name"/>onready var lives_counter = [$MarginContainer/HBoxContainer/LivesCounter/L1,<br class="title-page-name"/>                             $MarginContainer/HBoxContainer/LivesCounter/L2,<br class="title-page-name"/>                             $MarginContainer/HBoxContainer/LivesCounter/L3]</pre>
<p class="calibre2">The <kbd class="calibre12">start_game</kbd> signal will be emitted when the player clicks the <kbd class="calibre12">StartButton</kbd>. The <kbd class="calibre12">lives_counter</kbd> variable is an array holding references to the three life counter images. The names are fairly long, so make sure to let the editor's autocomplete fill them in for you to avoid mistakes.</p>
<p class="calibre2">Next, you need functions to handle updating the displayed information:</p>
<pre class="calibre18">func show_message(message):<br class="title-page-name"/>    $MessageLabel.text = message<br class="title-page-name"/>    $MessageLabel.show()<br class="title-page-name"/>    $MessageTimer.start()<br class="title-page-name"/> <br class="title-page-name"/>func update_score(value):<br class="title-page-name"/>    $MarginContainer/MarginContainer/HBoxContainer/ScoreLabel.text = str(value)<br class="title-page-name"/> <br class="title-page-name"/>func update_lives(value):<br class="title-page-name"/>    for item in range(3):<br class="title-page-name"/>        lives_counter[item].visible = value &gt; item</pre>
<p class="calibre2">Each function will be called when a value changes to update the display.</p>
<p class="calibre2">Next, add a function to handle the <kbd class="calibre12">Game Over</kbd> state:</p>
<pre class="calibre18">func game_over():<br class="title-page-name"/>    show_message("Game Over")<br class="title-page-name"/>    yield($MessageTimer, "timeout")<br class="title-page-name"/>    $StartButton.show()</pre>
<p class="calibre2">Now, connect the <kbd class="calibre12">pressed</kbd> signal of the <kbd class="calibre12">StartButton</kbd> so that it can emit the signal to <kbd class="calibre12">Main</kbd>:</p>
<pre class="calibre18">func _on_StartButton_pressed():<br class="title-page-name"/>    $StartButton.hide()<br class="title-page-name"/>    emit_signal("start_game")</pre>
<p class="calibre2">Finally, connect the <kbd class="calibre12">timeout</kbd> signal of <kbd class="calibre12">MessageTimer</kbd> so that it can hide the message:</p>
<pre class="calibre18">func _on_MessageTimer_timeout():<br class="title-page-name"/>    $MessageLabel.hide()<br class="title-page-name"/>    $MessageLabel.text = ''</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Main scene code</h1>
                
            
            <article>
                
<p class="calibre2">Now, you can add an instance of the <kbd class="calibre12">HUD</kbd> to the <kbd class="calibre12">Main</kbd> scene. Add the following variables to <kbd class="calibre12">Main.gd</kbd>:</p>
<pre class="calibre18">var level = 0<br class="title-page-name"/>var score = 0<br class="title-page-name"/>var playing = false</pre>
<p class="calibre2">These will track the named quantities. The following code will handle starting a new game:</p>
<pre class="calibre18">func new_game():<br class="title-page-name"/>    for rock in $Rocks.get_children():<br class="title-page-name"/>        rock.queue_free()<br class="title-page-name"/>    level = 0<br class="title-page-name"/>    score = 0<br class="title-page-name"/>    $HUD.update_score(score)<br class="title-page-name"/>    $Player.start()<br class="title-page-name"/>    $HUD.show_message("Get Ready!")<br class="title-page-name"/>    yield($HUD/MessageTimer, "timeout")<br class="title-page-name"/>    playing = true<br class="title-page-name"/>    new_level()</pre>
<p class="calibre2">First, you need to make sure that you remove any existing rocks that are left over from the previous game and initialize the variables. Don't worry about the <kbd class="calibre12">start()</kbd> function on the player; you'll add that soon.</p>
<p class="calibre2">After showing the <kbd class="calibre12">"Get Ready!"</kbd> message, you will use <kbd class="calibre12">yield</kbd> to wait for the message to disappear before actually starting the level:</p>
<pre class="calibre18">func new_level():<br class="title-page-name"/>    level += 1<br class="title-page-name"/>    $HUD.show_message("Wave %s" % level)<br class="title-page-name"/>    for i in range(level):<br class="title-page-name"/>        spawn_rock(3)</pre>
<p class="calibre2">This function will be called every time the level changes. It announces the level number and spawns a number of rocks to match. Note—since you initialized <kbd class="calibre12">level</kbd> to <kbd class="calibre12">0,</kbd> this will set it to <kbd class="calibre12">1</kbd> for the first level.</p>
<p class="calibre2">To detect whether the level has ended, you continually check how many children the <kbd class="calibre12">Rocks</kbd> node has:</p>
<pre class="calibre18">func _process(delta):<br class="title-page-name"/>    if playing and $Rocks.get_child_count() == 0:<br class="title-page-name"/>        new_level()</pre>
<p class="calibre2">Now, you need to connect the HUD's <kbd class="calibre12">start_game</kbd> signal (emitted when the Play button is pressed) to the <kbd class="calibre12">new_game()</kbd> function. Select the <kbd class="calibre12">HUD</kbd>, click on the <span class="calibre5">Node</span> tab, and connect the <kbd class="calibre12">start_game</kbd> signal. Set <span class="calibre5">Make Function</span> to <span class="calibre5">Off</span> and type <kbd class="calibre12">new_game</kbd> in the <span class="calibre5">Method In Node</span> field.</p>
<p class="calibre2">Next, add the following function to handle what happens when the game ends:</p>
<pre class="calibre18">func game_over():<br class="title-page-name"/>    playing = false<br class="title-page-name"/>    $HUD.game_over()</pre>
<p class="calibre2">Play the game and check that pressing the Play button starts the game. Note that the <kbd class="calibre12">Player</kbd> is currently stuck in the <kbd class="calibre12">INIT</kbd> state, so you can't fly around yet—the <kbd class="calibre12">Player</kbd> doesn't know the game has started.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Player code</h1>
                
            
            <article>
                
<p class="calibre2">Add a new signal and a new variable to <kbd class="calibre12">Player.gd</kbd>:</p>
<pre class="calibre18">signal lives_changed<br class="title-page-name"/><br class="title-page-name"/>var lives = 0 setget set_lives</pre>
<p class="calibre2">The <kbd class="calibre12">setget</kbd> statement in GDScript allows you to specify a function that will be called whenever the value of a given variable is changed. This means that when <kbd class="calibre12">lives</kbd> decreases, you can emit a signal to let the <kbd class="calibre12">HUD</kbd> know it needs to update the display:</p>
<pre class="calibre18">func set_lives(value):<br class="title-page-name"/>    lives = value<br class="title-page-name"/>    emit_signal("lives_changed", lives)</pre>
<p class="calibre2">The <kbd class="calibre12">start()</kbd> function is called by <kbd class="calibre12">Main</kbd> when a new game starts:</p>
<pre class="calibre18">func start():<br class="title-page-name"/>    $Sprite.show()<br class="title-page-name"/>    self.lives = 3<br class="title-page-name"/>    change_state(ALIVE)</pre>
<div class="packt_infobox">When using <kbd class="calibre51">setget</kbd>, if you access the variable locally (in the local script), you must put <kbd class="calibre51">self.</kbd> in front of the variable name. If you don't, the <kbd class="calibre51">setget</kbd> function will not be called.</div>
<p class="calibre2">Now, you need to connect this signal from the <kbd class="calibre12">Player</kbd> to the <kbd class="calibre12">update_lives</kbd> method in the <kbd class="calibre12">HUD</kbd>. In <kbd class="calibre12">Main</kbd>, click on the <kbd class="calibre12">Player</kbd> instance and find its <kbd class="calibre12">lives_changed</kbd> signal in the <span class="calibre5">Node</span> tab. Click <span class="calibre5">Connect</span>, and in the connection window, under <span class="calibre5">Connect to Node</span>, choose the <kbd class="calibre12">HUD</kbd>. For <span class="calibre5">Method In Node</span>, type <kbd class="calibre12">update_lives</kbd>. Make sure you have <span class="calibre5">Make Function</span> off, and click <span class="calibre5">Connect</span>, as shown in the following screenshot:</p>
<div class="cdpaligncenter1"><img src="../images/00093.jpeg" class="calibre109"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Game over</h1>
                
            
            <article>
                
<p class="calibre2">In this section, you'll make the player detect when it is hit by rocks, add an invulnerability feature, and end the game when the player runs out of lives.</p>
<p class="calibre2">Add an instance of the <kbd class="calibre12">Explosion</kbd> to the <kbd class="calibre12">Player</kbd>, as well as a <kbd class="calibre12">Timer</kbd> node (named <kbd class="calibre12">InvulnerabilityTimer</kbd>). In the <span class="calibre5">Inspector</span>, set the <span class="calibre5">Wait Time</span> of <kbd class="calibre12"><span>InvulnerabilityTimer</span></kbd> to <kbd class="calibre12">2</kbd> and its <span class="calibre5">One Shot</span> to <span class="calibre5">On</span>. Add this to the top of <kbd class="calibre12">Player.gd</kbd>:</p>
<pre class="calibre18">signal dead</pre>
<p class="calibre2">This signal will notify the <kbd class="calibre12">Main</kbd> scene that the player has run out of lives and the game is over. Before that, however, you need to update the state machine to do a little more with each state:</p>
<pre class="calibre18">func change_state(new_state):<br class="title-page-name"/>    match new_state:<br class="title-page-name"/>        INIT:<br class="title-page-name"/>            $CollisionShape2D.disabled = true<br class="title-page-name"/>            $Sprite.modulate.a = 0.5<br class="title-page-name"/>        ALIVE:<br class="title-page-name"/>            $CollisionShape2D.disabled = false<br class="title-page-name"/>            $Sprite.modulate.a = 1.0<br class="title-page-name"/>        INVULNERABLE:<br class="title-page-name"/>            $CollisionShape2D.disabled = true<br class="title-page-name"/>            $Sprite.modulate.a = 0.5<br class="title-page-name"/>            $InvulnerabilityTimer.start()<br class="title-page-name"/>        DEAD:<br class="title-page-name"/>            $CollisionShape2D.disabled = true<br class="title-page-name"/>            $Sprite.hide()<br class="title-page-name"/>            linear_velocity = Vector2()<br class="title-page-name"/>            emit_signal("dead")<br class="title-page-name"/>    state = new_state</pre>
<p class="calibre2"><br class="calibre6"/>
The <kbd class="calibre12">modulate.a</kbd> property of a sprite sets its alpha channel (transparency). Setting it to <kbd class="calibre12">0.5</kbd> makes it semi-transparent, while <kbd class="calibre12">1.0</kbd> is solid. </p>
<p class="calibre2">After entering the <kbd class="calibre12">INVULNERABLE</kbd> state, you start the <kbd class="calibre12">InvulnerabilityTimer</kbd>. Connect its <kbd class="calibre12">timeout</kbd> signal:</p>
<pre class="calibre18">func _on_InvulnerabilityTimer_timeout():<br class="title-page-name"/>    change_state(ALIVE)</pre>
<p class="calibre2">Also, connect the <kbd class="calibre12">animation_finished</kbd> signal from the <kbd class="calibre12">Explosion</kbd> animation like you did in the <kbd class="calibre12">Rock</kbd> scene:</p>
<pre class="calibre18">func _on_AnimationPlayer_animation_finished( name ):<br class="title-page-name"/>    $Explosion.hide()</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Detecting collisions between physics bodies</h1>
                
            
            <article>
                
<p class="calibre2">When you fly around, the player ship bounces off the rocks, because both bodies are <kbd class="calibre12">RigidBody2D</kbd> nodes. However, if you want to make something happen when two rigid bodies collide, you need to enable contact monitoring. Select the <kbd class="calibre12">Player</kbd> node and in the Inspector, set <span class="calibre5">Contact Monitoring</span> to <span class="calibre5">On</span>. By default, no contacts are reported, so you must also set <span class="calibre5">Contacts Reported</span> to <kbd class="calibre12">1</kbd>. Now, the body will emit a signal when it contacts another body. Click on the <span class="calibre5">Node</span> tab and connect the <kbd class="calibre12">body_entered</kbd> signal:</p>
<pre class="calibre18">func _on_Player_body_entered( body ):<br class="title-page-name"/>    if body.is_in_group('rocks'):<br class="title-page-name"/>        body.explode()<br class="title-page-name"/>        $Explosion.show()<br class="title-page-name"/>        $Explosion/AnimationPlayer.play("explosion")<br class="title-page-name"/>        self.lives -= 1<br class="title-page-name"/>        if lives &lt;= 0:<br class="title-page-name"/>            change_state(DEAD)<br class="title-page-name"/>        else:<br class="title-page-name"/>            change_state(INVULNERABLE)</pre>
<p class="calibre2">Now, go to the <kbd class="calibre12">Main</kbd> scene and connect the Player's <kbd class="calibre12">dead</kbd> signal to the <kbd class="calibre12">game_over()</kbd> function. Play the game and try running into a rock. Your ship should explode, become invulnerable (for two seconds), and lose one life. Check that the game ends if you get hit three times.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Pausing the game</h1>
                
            
            <article>
                
<p class="calibre2">Many games require some sort of pause mode to allow the player to take a break in the action. In Godot, pausing is a function of the scene tree and can be set using <kbd class="calibre12">get_tree().paused = true</kbd>. When the <kbd class="calibre12">SceneTree</kbd> is paused, three things happen:</p>
<ul class="calibre10">
<li class="calibre11">The physics thread stops running</li>
<li class="calibre11"><kbd class="calibre12">_process</kbd> and <kbd class="calibre12">_physics_process</kbd> are no longer called, so no code in those methods is run</li>
<li class="calibre11"><kbd class="calibre12">_input</kbd> and <kbd class="calibre12">_input_event</kbd> are also not called</li>
</ul>
<p class="calibre2">When the pause mode is triggered, every node in the running game can react accordingly, based on how you've configured it. This behavior is set via the node's <span class="calibre5">Pause</span>/<span class="calibre5">Mode</span> property, which you'll find all the way at the bottom of the Inspector list.</p>
<p class="calibre2">The pause mode can be set to three values: <kbd class="calibre12">INHERIT</kbd> (the default value), <kbd class="calibre12">STOP</kbd>, and <kbd class="calibre12">PROCESS</kbd>. <kbd class="calibre12">STOP</kbd> means the node will cease processing while the tree is paused, while <kbd class="calibre12">PROCESS</kbd> sets the node to continue running, ignoring the paused state of the tree. Because it would be very tedious to set this property on every node in the whole game, <kbd class="calibre12">INHERIT</kbd> lets the node use the same pause mode as its parent.</p>
<p class="calibre2">Open the <span class="calibre5">Input Map</span> tab (in <span class="calibre5">Project Settings</span>) and create a new input action called <kbd class="calibre12">pause</kbd>. Choose a key you'd like to use to toggle pause mode; for example, P is a good choice.</p>
<p class="calibre2">Next, add the following function to <kbd class="calibre12">Main.gd</kbd> to respond to the input action:</p>
<pre class="calibre18">func _input(event):<br class="title-page-name"/>    if event.is_action_pressed('pause'):<br class="title-page-name"/>        if not playing:<br class="title-page-name"/>            return<br class="title-page-name"/>    get_tree().paused = not get_tree().paused<br class="title-page-name"/>    if get_tree().paused:<br class="title-page-name"/>        $HUD/MessageLabel.text = "Paused"<br class="title-page-name"/>        $HUD/MessageLabel.show()<br class="title-page-name"/>    else:<br class="title-page-name"/>        $HUD/MessageLabel.text = ""<br class="title-page-name"/>        $HUD/MessageLabel.hide()</pre>
<p class="calibre2">If you ran the game now, you'd have a problem—all nodes are paused, including <kbd class="calibre12">Main</kbd>. This means that since it isn't processing <kbd class="calibre12">_input</kbd>, it can't detect the input again to unpause the game! To fix this, you need to set the <span class="calibre5">Pause</span>/<span class="calibre5">Mode</span> of <kbd class="calibre12">Main</kbd> to <kbd class="calibre12">PROCESS</kbd>. Now, you have the opposite problem: all the nodes below <kbd class="calibre12">Main</kbd> inherit this setting. This is fine for most of the nodes, but you need to set the mode to <kbd class="calibre12">STOP</kbd> on these three nodes: <kbd class="calibre12">Player</kbd>, <kbd class="calibre12">Rocks</kbd>, and <kbd class="calibre12">HUD</kbd>. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Enemies</h1>
                
            
            <article>
                
<p class="calibre2">Space is filled with more dangers than just rocks. In this section, you'll create an enemy spaceship that will periodically appear and shoot at the player.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Following a path</h1>
                
            
            <article>
                
<p class="calibre2">When the enemy appears, it should follow a path across the screen. To keep it from looking too repetitive, you can create multiple paths and randomly choose one when the enemy starts.</p>
<p class="calibre2">Create a new scene and add a <kbd class="calibre12">Node</kbd>. Name it <kbd class="calibre12">EnemyPaths</kbd> and save the scene. To draw the path, add a <kbd class="calibre12">Path2D</kbd> node. As you saw earlier, this node allows you to draw a series of connected points. When you add the node, a new menu bar appears:</p>
<div class="cdpaligncenter1"><img class="alignnone6" src="../images/00094.jpeg"/></div>
<p class="calibre2">These buttons let you draw and modify the path's points. Click the one with the <span class="calibre5">+</span> symbol to add points. Click to start the path somewhere just outside the game window (the bluish-purple rectangle), and then click a few more points to create a curve. Don't worry about making it smooth just yet:</p>
<div class="cdpaligncenter1"><img class="alignnone7" src="../images/00095.jpeg"/></div>
<p class="calibre2">When the enemy ship follows the path, it will not look very smooth when it hits the sharp corners. To smooth the curve, click the second button in the path toolbar (its tooltip says <span class="calibre5">Select Control Points</span>). Now, if you click and drag any of the curve's points, you will add a control point that allows you to angle and curve the line. Smoothing the preceding line results in something like this:</p>
<div class="cdpaligncenter1"><img class="alignnone8" src="../images/00096.jpeg"/></div>
<p class="calibre2">Add a few more <kbd class="calibre12">Path2D</kbd> nodes to the scene and draw the paths however you like. Adding loops and curves rather than straight lines will make the enemy look more dynamic (and make it harder to hit). Remember that the first point you click will be the start of the path, so make sure to place them on different sides of the screen, for variety. Here are three example paths:</p>
<div class="cdpaligncenter1"><img class="alignnone9" src="../images/00097.jpeg"/></div>
<p class="calibre2">Save the scene. You'll add this to the enemy's scene to give it the paths it can follow.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Enemy scene</h1>
                
            
            <article>
                
<p class="calibre2">Create a new scene for the Enemy, using an <kbd class="calibre12">Area2D</kbd> as its root node. Add a <kbd class="calibre12">Sprite</kbd> and use <kbd class="calibre12">res://assets/enemy_saucer.png</kbd> as its <span class="calibre5">Texture</span>. Set the <span class="calibre5">Animation</span>/<span class="calibre5">HFrames</span> to <kbd class="calibre12">3</kbd> so that you can choose between the different-colored ships:</p>
<div class="cdpaligncenter1"><img class="alignnone10" src="../images/00098.jpeg"/></div>
<p class="calibre2">As you've done before, add a <kbd class="calibre12">CollisionShape2D</kbd> and give it a <kbd class="calibre12">CircleShape2D</kbd> scaled to cover the sprite image. Next, add an instance of the <kbd class="calibre12">EnemyPaths</kbd> scene and an <kbd class="calibre12">AnimationPlayer</kbd>. In the <kbd class="calibre12">AnimationPlayer</kbd>, you'll need two animations: one to make the saucer spin as it moves, and the other to create a flash effect when the saucer is hit:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="calibre1">Rotate animation</strong>: Add a new animation named <kbd class="calibre12">rotate</kbd> and set its <em class="calibre20"><span>Length</span></em><span> to</span> <kbd class="calibre12">3</kbd><span>. Add a keyframe for the</span> <kbd class="calibre12">Sprite</kbd> <span>Transform</span>/<span>Rotation Degrees</span><span> property after setting it to</span> <kbd class="calibre12">0</kbd><span>, then drag the play bar to the end and add a keyframe with the rotation set to</span> <kbd class="calibre12">360</kbd><span>. Click the <span>Loop</span> button and the <span>Autoplay</span> button.</span></li>
</ul>
<ul class="calibre10">
<li class="calibre11"><strong class="calibre1">Hit animation</strong>: Add a second animation named <kbd class="calibre12">flash</kbd>. Set its <em class="calibre20"><span>Length</span></em><span> to</span> <kbd class="calibre12">0.25</kbd> <span>and the</span> <em class="calibre20"><span>Step</span></em><span> to</span> <kbd class="calibre12">0.01</kbd><span>. The property you'll be animating is the</span> Sprite<span>'s</span> <span>Modulate</span> <span>(found under</span> <em class="calibre20"><span>Visibility</span></em><span>). Add a keyframe for</span> <span>Modulate</span><span> to create the track, then move the scrubber to</span> <kbd class="calibre12">0.04</kbd> <span>and change the <span>Modulate</span> color to red. Move forward another</span> <kbd class="calibre12">0.04</kbd> <span>and change the color back to white. </span></li>
</ul>
<p class="calibre2">Repeat this process two more times so that you have three flashes in total.</p>
<p class="calibre2"><span class="calibre5">Add an instance of the <kbd class="calibre12">Explosion</kbd> scene as you did with the other objects. Also, like you did with the rocks, connect the explosion's <kbd class="calibre12">AnimationPlayer</kbd> <kbd class="calibre12">animation_finished</kbd> signal and set it to delete the enemy when the explosion finishes:</span></p>
<pre class="calibre18">func _on_AnimationPlayer_animation_finished(anim_name):<br class="title-page-name"/>    queue_free()</pre>
<p class="calibre2">Next, add a <kbd class="calibre12">Timer</kbd> node called <kbd class="calibre12">GunTimer</kbd> that will control how often the enemy shoots at the player. Set its <span class="calibre5">Wait Time</span> to <kbd class="calibre12">1.5</kbd> and <span class="calibre5">Autostart</span> to <kbd class="calibre12">On</kbd>. Connect its <kbd class="calibre12">timeout</kbd> signal, but leave the code reading <kbd class="calibre12">pass</kbd> for now.</p>
<p class="calibre2">Finally, click on the <kbd class="calibre12">Area2D</kbd> and the <span class="calibre5">Node</span> tab and add it to a group called <kbd class="calibre12">enemies</kbd>. As with the rocks, this will give you a way to identify the object, even if there are multiple enemies on the screen at the same time.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Moving the Enemy</h1>
                
            
            <article>
                
<p class="calibre2">Attach a script to the <kbd class="calibre12">Enemy</kbd> scene. To begin, you'll make the code that will select a path and move the enemy along it:</p>
<pre class="calibre18">extends Area2D<br class="title-page-name"/><br class="title-page-name"/>signal shoot<br class="title-page-name"/><br class="title-page-name"/>export (PackedScene) var Bullet<br class="title-page-name"/>export (int) var speed = 150<br class="title-page-name"/>export (int) var health = 3<br class="title-page-name"/><br class="title-page-name"/>var follow<br class="title-page-name"/>var target = null<br class="title-page-name"/><br class="title-page-name"/>func _ready():<br class="title-page-name"/>    $Sprite.frame = randi() % 3<br class="title-page-name"/>    var path = $EnemyPaths.get_children()[randi() % $EnemyPaths.get_child_count()]<br class="title-page-name"/>    follow = PathFollow2D.new()<br class="title-page-name"/>    path.add_child(follow)<br class="title-page-name"/>    follow.loop = false</pre>
<p class="calibre2">A <kbd class="calibre12">PathFollow2D</kbd> node is one that can automatically move along a parent <kbd class="calibre12">Path2D</kbd>. By default, it is set to loop around the path, so you need to manually set the property to <kbd class="calibre12">false</kbd>.</p>
<p class="calibre2">The next step is to move along the path:</p>
<pre class="calibre18">func _process(delta):<br class="title-page-name"/>    follow.offset += speed * delta<br class="title-page-name"/>    position = follow.global_position<br class="title-page-name"/>    if follow.unit_offset &gt; 1:<br class="title-page-name"/>        queue_free()</pre>
<p class="calibre2">You can detect the end of the path when <kbd class="calibre12">offset</kbd> is greater than the total path length. However, it's more straightforward to use <kbd class="calibre12">unit_offset</kbd>, which varies from zero to one over the length of the path.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Spawning enemies</h1>
                
            
            <article>
                
<p class="calibre2">Open the <kbd class="calibre12">Main</kbd> scene and add a <kbd class="calibre12">Timer</kbd> node called <kbd class="calibre12">EnemyTimer</kbd>. Set its <span class="calibre5">One Shot</span> property to <kbd class="calibre12">On</kbd>. Then, in <kbd class="calibre12">Main.gd</kbd>, add a variable to reference your enemy scene (drag it into the <span class="calibre5">Inspector</span> after saving the script):</p>
<pre class="calibre18">export (PackedScene) var Enemy</pre>
<p class="calibre2">Add the following code to <kbd class="calibre12">new_level()</kbd>:</p>
<pre class="calibre18">$EnemyTimer.wait_time = rand_range(5, 10)<br class="title-page-name"/>$EnemyTimer.start()</pre>
<p class="calibre2">Connect the <kbd class="calibre12">EnemyTimer</kbd> <kbd class="calibre12">timeout</kbd> signal, and add the following:</p>
<pre class="calibre18">func _on_EnemyTimer_timeout():<br class="title-page-name"/>    var e = Enemy.instance()<br class="title-page-name"/>    add_child(e)<br class="title-page-name"/>    e.target = $Player<br class="title-page-name"/>    e.connect('shoot', self, '_on_Player_shoot')<br class="title-page-name"/>    $EnemyTimer.wait_time = rand_range(20, 40)<br class="title-page-name"/>    $EnemyTimer.start()</pre>
<p class="calibre2">This code instances the enemy whenever the <kbd class="calibre12">EnemyTimer</kbd> times out. When you add shooting to the enemy, it will use the same process you used for the <kbd class="calibre12">Player</kbd>, so you can reuse the same bullet-spawning function, which is <kbd class="calibre12">_on_Player_shoot()</kbd>.</p>
<p class="calibre2">Play the game, and you should see a flying saucer appear that will fly along one of your paths.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Enemy shooting and collisions</h1>
                
            
            <article>
                
<p class="calibre2">The enemy needs to shoot at the player as well as react when hit by the player or the player's bullets.</p>
<p class="calibre2">Open the <kbd class="calibre12">Bullet</kbd> scene and choose <span class="calibre5">Save Scene As</span> to save it as <kbd class="calibre12">EnemyBullet.tscn</kbd> (afterwards, don't forget to rename the root node as well). Remove the script by selecting the root node and clicking the <span class="calibre5">Clear the script</span> button:</p>
<div class="cdpaligncenter1"><img src="../images/00099.jpeg" class="calibre110"/> </div>
<p class="calibre2">You also need to disconnect the signal connections by clicking the <span class="calibre5">Node</span> tab and choosing <span class="calibre5">Disconnect</span>:</p>
<div class="cdpaligncenter1"><img src="../images/00100.jpeg" class="calibre111"/></div>
<p class="calibre2">There is also a different texture in the <kbd class="calibre12">assets</kbd> folder you can use to make the enemy bullet appear distinct from the player's.</p>
<p class="calibre2">The script will be very much the same as the regular bullet. Connect the area's <kbd class="calibre12">body_entered</kbd> signal and the <kbd class="calibre12">screen_exited</kbd> signal of <kbd class="calibre12">VisibilityNotifier2D</kbd>:</p>
<pre class="calibre18">extends Area2D<br class="title-page-name"/><br class="title-page-name"/>export (int) var speed<br class="title-page-name"/><br class="title-page-name"/>var velocity = Vector2()<br class="title-page-name"/><br class="title-page-name"/>func start(_position, _direction):<br class="title-page-name"/>    position = _position<br class="title-page-name"/>    velocity = Vector2(speed, 0).rotated(_direction)<br class="title-page-name"/>    rotation = _direction<br class="title-page-name"/><br class="title-page-name"/>func _process(delta):<br class="title-page-name"/>    position += velocity * delta<br class="title-page-name"/><br class="title-page-name"/>func _on_EnemyBullet_body_entered(body):<br class="title-page-name"/>    queue_free()<br class="title-page-name"/><br class="title-page-name"/>func _on_VisibilityNotifier2D_screen_exited():<br class="title-page-name"/>    queue_free()</pre>
<p class="calibre2">For now, the bullet won't do any damage to the player. You'll be adding a shield to the player in the next section, so you can add that at the same time.</p>
<p class="calibre2">Save the scene and drag it into the <span class="calibre5">Bullet</span> property on the <kbd class="calibre12">Enemy</kbd>. </p>
<p class="calibre2">In <kbd class="calibre12">Enemy.gd</kbd>, add the <kbd class="calibre12">shoot</kbd> function:</p>
<pre class="calibre18">func shoot():<br class="title-page-name"/>    var dir = target.global_position - global_position<br class="title-page-name"/>    dir = dir.rotated(rand_range(-0.1, 0.1)).angle()<br class="title-page-name"/>    emit_signal('shoot', Bullet, global_position, dir)</pre>
<p class="calibre2">First, you must find the vector pointing to the player's position, then add a little bit of randomness to it so that the bullets don't follow exactly the same path.</p>
<p class="calibre2">For an extra challenge, you can make the enemy shoot in <em class="calibre17">pulses</em>, or multiple rapid shots:</p>
<pre class="calibre18">func shoot_pulse(n, delay):<br class="title-page-name"/>    for i in range(n):<br class="title-page-name"/>        shoot()<br class="title-page-name"/>        yield(get_tree().create_timer(delay), 'timeout')</pre>
<p class="calibre2">This function creates a given number of bullets with <kbd class="calibre12">delay</kbd> time between them. You can use this whenever the <kbd class="calibre12">GunTimer</kbd> triggers a shot:</p>
<pre class="calibre18">func _on_GunTimer_timeout():<br class="title-page-name"/>    shoot_pulse(3, 0.15)</pre>
<p class="calibre2">This will shoot a pulse of <kbd class="calibre12">3</kbd> bullets with <kbd class="calibre12">0.15</kbd> seconds between them. Tough to dodge!</p>
<p class="calibre2">Next, the enemy needs to take damage when it's hit by a shot from the player. It will flash using the animation you made, and then explode when its health reaches <kbd class="calibre12">0</kbd>. </p>
<p class="calibre2">Add these functions to <kbd class="calibre12">Enemy.gd</kbd>:</p>
<pre class="calibre18">func take_damage(amount):<br class="title-page-name"/>    health -= amount<br class="title-page-name"/>    $AnimationPlayer.play('flash')<br class="title-page-name"/>    if health &lt;= 0:<br class="title-page-name"/>        explode()<br class="title-page-name"/>    yield($AnimationPlayer, 'animation_finished')<br class="title-page-name"/>    $AnimationPlayer.play('rotate')<br class="title-page-name"/><br class="title-page-name"/>func explode():<br class="title-page-name"/>    speed = 0<br class="title-page-name"/>    $GunTimer.stop()<br class="title-page-name"/>    $CollisionShape2D.disabled = true<br class="title-page-name"/>    $Sprite.hide()<br class="title-page-name"/>    $Explosion.show()<br class="title-page-name"/>    $Explosion/AnimationPlayer.play("explosion")<br class="title-page-name"/>    $ExplodeSound.play()</pre>
<p class="calibre2">Also, connect the area's <kbd class="calibre12">body_entered</kbd> signal so the enemy will explode if the player runs into it:</p>
<pre class="calibre18">func _on_Enemy_body_entered(body):<br class="title-page-name"/>    if body.name == 'Player':<br class="title-page-name"/>        pass<br class="title-page-name"/>    explode()</pre>
<p class="calibre2">Again, you're waiting for the player shield to add the damage to the player, so leave the <kbd class="calibre12">pass</kbd> placeholder there for now.</p>
<p class="calibre2"><span class="calibre5">Right now, the </span>player<span class="calibre5">'s bullet is only detecting physics bodies because its </span><kbd class="calibre12">body_entered</kbd><span class="calibre5"> signal is connected. However, the enemy is an </span><kbd class="calibre12">Area2D</kbd><span class="calibre5">, so it will not trigger that signal. To detect the enemy, you need to also connect the  </span><kbd class="calibre12">area_entered</kbd><span class="calibre5"> signal:</span></p>
<pre class="calibre18">func _on_Bullet_area_entered(area):<br class="title-page-name"/>    if area.is_in_group('enemies'):<br class="title-page-name"/>        area.take_damage(1)<br class="title-page-name"/>    queue_free()</pre>
<p class="calibre2">Try playing the game again and you'll be doing battle with an aggressive alien opponent! Verify that all the collision combinations are being handled. Also note that the enemy's bullets can be blocked by rocks—maybe you can hide behind them for cover!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Additional features</h1>
                
            
            <article>
                
<p class="calibre2">The structure of the game is complete. You can start the game, play it through, and when it ends, play again. In this section, you'll add some additional effects and features to the game to improve the gameplay experience. Effects is a broad term and can mean many different techniques, but in this case, you'll specifically address three things:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="calibre1">Sound effects and music: </strong>Audio is very often overlooked, but can be a very effective part of game design. Good sound improves the <em class="calibre20">feel</em> of the game. Bad or annoying sounds can create boredom or frustration. You'll add some action-packed background music, and some sound effects for several actions in the game.</li>
</ul>
<ul class="calibre10">
<li class="calibre11"><strong class="calibre1">Particles: </strong>Particle effects are images, usually small, that are generated in large numbers and animated by a particle system. They can be used for a countless number of impressive visual effects. Godot's particle system is quite powerful; too powerful to fully explore here, but you'll learn enough to get started experimenting with it.</li>
</ul>
<ul class="calibre10">
<li class="calibre11"><strong class="calibre1">Player shield: </strong>If you're finding the game too hard, especially on higher levels where there are a lot of rocks, adding a shield to the player will greatly increase your chances of survival. You can also make larger rocks do more damage to the shield than smaller ones. You'll also make a nice display bar on the HUD to show the player's remaining shield level.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Sound/music</h1>
                
            
            <article>
                
<p class="calibre2">In the <kbd class="calibre12">res://assets/sounds</kbd> folder are several audio files containing different sounds in the <span class="calibre5">OggVorbis</span> format. By default, Godot sets <kbd class="calibre12">.ogg</kbd> files to loop when imported. In the case of <kbd class="calibre12">explosion.ogg</kbd>, <kbd class="calibre12">laser_blast.ogg</kbd>, and <kbd class="calibre12">levelup.ogg</kbd>, you don't want the sounds to loop, so you need to change the import settings for those files. To do this, select the file in the <span class="calibre5">FileSystem</span> dock, and then click the <span class="calibre5">Import</span> tab located next to the <span class="calibre5">Scene</span> tab on the right-hand side of the editor window. Uncheck the box next to <span class="calibre5">Loop</span> and click <span class="calibre5">Reimport</span>. Do this for each of the three sounds. Refer to the following screenshot:</p>
<div class="cdpaligncenter1"><img src="../images/00101.jpeg" class="calibre112"/></div>
<p class="calibre2">To play a sound, it needs to be loaded by an <kbd class="calibre12">AudioStreamPlayer</kbd> node. Add two of these nodes to the <kbd class="calibre12">Player</kbd> scene, naming them <kbd class="calibre12">LaserSound</kbd> and <kbd class="calibre12">EngineSound</kbd>. Drag the respective sound into each node's <span class="calibre5">Stream</span> property in the <span class="calibre5">Inspector</span>. To play the sound when shooting, add the following line to <kbd class="calibre12">shoot()</kbd> in <kbd class="calibre12">Player.gd</kbd>:</p>
<pre class="calibre18">$LaserSound.play()</pre>
<p class="calibre2">Play the game and try shooting. If you find the sound a bit too loud, you can adjust the <span class="calibre5">Volume Db</span> property. Try a value of <kbd class="calibre12">-10</kbd>.</p>
<p class="calibre2">The engine sound works a little differently. It needs to play when the thrust is on, but if you try to just <kbd class="calibre12">play()</kbd> the sound in the <kbd class="calibre12">get_input()</kbd> function, it will restart the sound every frame as long as you have the input pressed. This doesn't sound good, so you only want to start playing the sound if it isn't already playing. Here is the relevant section from the <kbd class="calibre12">get_input()</kbd> function:</p>
<pre class="calibre18">if Input.is_action_pressed("thrust"):<br class="title-page-name"/>    thrust = Vector2(engine_power, 0)<br class="title-page-name"/>    if not $EngineSound.playing:<br class="title-page-name"/>        $EngineSound.play()<br class="title-page-name"/> else:<br class="title-page-name"/>     $EngineSound.stop()</pre>
<p class="calibre2">Note that a problem can occur—if the player dies while holding down the thrust key, the engine sound will remain stuck on. This can be solved by adding <kbd class="calibre12">$EngineSound.stop()</kbd> to the <kbd class="calibre12">DEAD</kbd> state in <kbd class="calibre12">change_state()</kbd>.</p>
<p class="calibre2">In the <kbd class="calibre12">Main</kbd> scene, add three more <kbd class="calibre12">AudioStreamPlayer</kbd> nodes: <kbd class="calibre12">ExplodeSound</kbd>, <kbd class="calibre12">LevelupSound</kbd>, and <kbd class="calibre12">Music</kbd>. In their <span class="calibre5">Stream</span> properties, drop <kbd class="calibre12">explosion.ogg</kbd>, <kbd class="calibre12">levelup.ogg</kbd>, and <kbd class="calibre12">Funky-Gameplay_Looping.ogg</kbd>.</p>
<p class="calibre2">Add <kbd class="calibre12">$ExplodeSound.play()</kbd> as the first line of <kbd class="calibre12">_on_Rock_exploded()</kbd>, and add <kbd class="calibre12">$LevelupSound.play()</kbd> to <kbd class="calibre12">new_level()</kbd>.</p>
<p class="calibre2">To start/stop the music, add <kbd class="calibre12">$Music.play()</kbd> to <kbd class="calibre12">new_game()</kbd> and <kbd class="calibre12">$Music.stop()</kbd> to <kbd class="calibre12">game_over()</kbd>.</p>
<p class="calibre2">The Enemy also needs an <kbd class="calibre12">ExplodeSound</kbd> and a <kbd class="calibre12">ShootSound</kbd>. You can use the same explosion as the player, but there is an <kbd class="calibre12">enemy_laser.wav</kbd> sound to use for the shot.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Particles</h1>
                
            
            <article>
                
<p class="calibre2">The player ship's thrust is a perfect use for particles, creating a streaming flame from the engine. Add a <kbd class="calibre12">Particles2D</kbd> node to the <kbd class="calibre12">Player</kbd> scene and name it <kbd class="calibre12">Exhaust</kbd>. You might want to zoom in on the ship image while you're doing this part.</p>
<p class="calibre2">When first created, the <kbd class="calibre12">Particles2D</kbd> node has a warning: <em class="calibre17">A material to process the particles is not assigned</em>. Particles will not be emitted until you assign a <kbd class="calibre12">Process Material</kbd> in the Inspector. Two types of materials are possible: <kbd class="calibre12">ShaderMaterial</kbd> and <kbd class="calibre12">ParticlesMaterial</kbd>. <kbd class="calibre12">ShaderMaterial</kbd> allows you to write shader code in a GLSL-like language, while <kbd class="calibre12">ParticlesMaterial</kbd> is configured in the <span class="calibre5">Inspector</span>. Next to <span class="calibre5">Particles Material</span>, click the down-arrow and choose <span class="calibre5">New ParticlesMaterial</span>.</p>
<p class="calibre2">You'll see a line of white dots streaming down from the center of the player ship. Your challenge now is to turn those into an exhaust flame.</p>
<p class="calibre2">There are a very large number of properties to choose from when configuring particles, especially under <kbd class="calibre12">ParticlesMaterial</kbd>. Before starting on that, set these properties of the <kbd class="calibre12">Particles2D</kbd>:</p>
<ul class="calibre10">
<li class="calibre11"><span>Amount</span>: <kbd class="calibre12">25</kbd></li>
<li class="calibre11"><span>Transform</span>/<span>Position</span><em class="calibre20">: </em><kbd class="calibre12">(-28, 0)</kbd></li>
<li class="calibre11"><span>Transform</span>/<span>Rotation</span>: <kbd class="calibre12">180</kbd></li>
<li class="calibre11"><span>Visibility</span>/<span>Show Behind Parent</span>: <kbd class="calibre12">On</kbd></li>
</ul>
<p class="calibre2">Now, click on the <kbd class="calibre12">ParticlesMaterial</kbd>. This is where you'll find the majority of the properties that affect the particles' behavior. Start with <span class="calibre5">Emission Shape</span>—change it to <span class="calibre5">Box</span>. This will reveal <span class="calibre5">Box Extents</span>, which should be set to <kbd class="calibre12">(1, 5, 1)</kbd>. Now, the particles are emitted over a small area instead of a single point.</p>
<p class="calibre2">Next, set <span class="calibre5">Spread</span>/<span class="calibre5">Spread</span> to <kbd class="calibre12">0</kbd> and <span class="calibre5">Gravity</span>/<span class="calibre5">Gravity</span> to <kbd class="calibre12">(0, 0, 0)</kbd>. Now, the particles aren't falling or spreading out, but they are moving very slowly.</p>
<p class="calibre2">The next property is <span class="calibre5">Initial Velocity</span>. Set <span class="calibre5">Velocity</span> to <kbd class="calibre12">400</kbd>. Then, scroll down to <span class="calibre5">Scale</span> and set it to <kbd class="calibre12">8</kbd>.</p>
<p class="calibre2">To make the size change over time, you can set a <span class="calibre5">Scale Curve</span>. Click on <span class="calibre5">New CurveTexture</span> and click on it. A new panel labeled <span class="calibre5">Curve</span> will appear. The left-hand dot represents the starting scale, and the right-hand dot represents the end. Drag the right-hand dot down until your curve looks something like this:</p>
<div class="cdpaligncenter1"><img src="../images/00102.jpeg" class="calibre113"/></div>
<p class="calibre2">Now, the particles are shrinking as they age. Click the left arrow at the top of the <span class="calibre5">Inspector</span> to go back to the previous section.</p>
<p class="calibre2">The final section to adjust is <span class="calibre5">Color</span>. To make the particles appear like a flame, the particles should start out a bright orange-yellow and shift to red while fading out. In the <span class="calibre5">Color Ramp</span> property, click on <span class="calibre5">New GradientTexture</span>. Then, in the <span class="calibre5">Gradient</span> property, choose <span class="calibre5">New Gradient</span>:</p>
<div class="cdpaligncenter1"><img src="../images/00103.jpeg" class="calibre114"/></div>
<p class="calibre2">The sliders labeled <span class="calibre5">1</span> and <span class="calibre5">2</span> select the starting and ending colors, while <span class="calibre5">3</span> shows what color is set on the currently selected slider. Click on slider <span class="calibre5">1</span> and then click <span class="calibre5">3</span> to choose an orange color, then click on slider <span class="calibre5">2</span> and set it to a deep red.</p>
<p class="calibre2">Now that we can see what the particles are doing, they are lasting far too long. Go back to the <kbd class="calibre12">Exhaust</kbd> node and change the <span class="calibre5">Lifetime</span> to <kbd class="calibre12">0.1</kbd>.</p>
<p class="calibre2">Hopefully, your ship's exhaust looks somewhat like a flame. If it doesn't, feel free to adjust the <kbd class="calibre12">ParticlesMaterial</kbd> properties until you are happy with it.</p>
<p class="calibre2">Now that the ship's <kbd class="calibre12">Exhaust</kbd> is configured, it needs to be turned on/off based on the player input. Go to the player script and add <kbd class="calibre12">$Exhaust.emitting = false</kbd> at the beginning of <kbd class="calibre12">get_input()</kbd>. Then, add <kbd class="calibre12">$Exhaust.emitting = true</kbd> under the <kbd class="calibre12">if</kbd> statement that checks for thrust input.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Enemy trail</h1>
                
            
            <article>
                
<p class="calibre2">You can also use particles to make a trail effect behind the enemy. Add a <kbd class="calibre12">Particles2D</kbd> to the enemy scene and set the properties as follows:</p>
<ul class="calibre10">
<li class="calibre11"><span>Amount</span>: <kbd class="calibre12">20</kbd></li>
<li class="calibre11"><span>Local Coords</span>: <kbd class="calibre12">Off</kbd></li>
<li class="calibre11"><span>Texture</span>: <kbd class="calibre12">res://assets/corona.png</kbd></li>
<li class="calibre11"><span>Show Behind Parent</span>: <kbd class="calibre12">On</kbd></li>
</ul>
<p class="calibre2">Note that the effect texture you're using is white on a black background. This image needs its blend mode changed. To do this, on the particle node, find the <span class="calibre5">Material</span> property (it is in the <kbd class="calibre12">CanvasItem</kbd> section). Select <span class="calibre5">New CanvasItemMaterial</span> and, in the resulting material, change the <span class="calibre5">Blend Mode</span> to <kbd class="calibre12">Add</kbd>.</p>
<p class="calibre2">Now, create a <kbd class="calibre12">ParticlesMaterial</kbd> like you did previously, and use these settings:</p>
<ul class="calibre10">
<li class="calibre11"><span>Emission Shape</span>:<br class="title-page-name"/>
<ul class="calibre115">
<li class="calibre11"><span>Shape</span>: <span>Box</span></li>
<li class="calibre11"><span>Box Extents</span>: (<kbd class="calibre12">25</kbd>, <kbd class="calibre12">25</kbd>, <kbd class="calibre12">1</kbd>)</li>
</ul>
</li>
<li class="calibre11"><span>Spread</span>: <kbd class="calibre12">25</kbd></li>
<li class="calibre11"><span>Gravity</span>: (0, 0, 0)</li>
</ul>
<p class="calibre2">Now, create a <kbd class="calibre12">ScaleCurve</kbd> like you did for the player exhaust. This time, make the curve look something like the following:</p>
<div class="cdpaligncenter1"><img src="../images/00104.jpeg" class="calibre116"/></div>
<p class="calibre2">Try running the game and see how it looks. Feel free to tinker with the settings until you have something you like.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Player shield</h1>
                
            
            <article>
                
<p class="calibre2">In this section, you'll add a shield to the player and a display element to the <kbd class="calibre12">HUD</kbd> showing the current shield level. </p>
<p class="calibre2">First, add the following to the top of the <kbd class="calibre12">Player.gd</kbd> script:</p>
<pre class="calibre18">signal shield_changed<br class="title-page-name"/><br class="title-page-name"/>export (int) var max_shield<br class="title-page-name"/>export (float) var shield_regen<br class="title-page-name"/><br class="title-page-name"/>var shield = 0 setget set_shield</pre>
<p class="calibre2">The <kbd class="calibre12">shield</kbd> variable will work similarly to <kbd class="calibre12">lives</kbd>, emitting a signal to the <kbd class="calibre12">HUD</kbd> whenever it changes. Save the script and set <kbd class="calibre12">max_shield</kbd> to <kbd class="calibre12">100</kbd> and <kbd class="calibre12">shield_regen</kbd> to <kbd class="calibre12">5</kbd> in the <span class="calibre5">Inspector</span>.</p>
<p class="calibre2">Next, add the following function, which handles changing the shield's value:</p>
<pre class="calibre18">func set_shield(value):<br class="title-page-name"/>    if value &gt; max_shield:<br class="title-page-name"/>        value = max_shield<br class="title-page-name"/>    shield = value<br class="title-page-name"/>    emit_signal("shield_changed", shield/max_shield)<br class="title-page-name"/>    if shield &lt;= 0:<br class="title-page-name"/>        self.lives -= 1</pre>
<p class="calibre2">Also, since some things, such as regeneration, may add to the shield's value, you need to make sure it doesn't go above the maximum allowed value. Then, when you send the <kbd class="calibre12">shield_changed</kbd> signal, you pass the ratio of <kbd class="calibre12">shield/max_shield</kbd>. This way, the HUD's display doesn't need to know anything about the actual values, just the shield's relative state.</p>
<p class="calibre2">Add this line to <kbd class="calibre12">start()</kbd> and to <kbd class="calibre12">set_lives()</kbd>:</p>
<pre class="calibre18">    self.shield = max_shield</pre>
<p class="calibre2">Hitting a rock will damage the shield, and bigger rocks should do more damage:</p>
<pre class="calibre18">func _on_Player_body_entered( body ):<br class="title-page-name"/>    if body.is_in_group('rocks'):<br class="title-page-name"/>        body.explode()<br class="title-page-name"/>        $Explosion.show()<br class="title-page-name"/>        $Explosion/AnimationPlayer.play("explosion")<br class="title-page-name"/>        self.shield -= body.size * 25</pre>
<p class="calibre2">The enemy's bullets should also do damage, so make this change to <kbd class="calibre12">EnemyBullet.gd</kbd>:</p>
<pre class="calibre18">func _on_EnemyBullet_body_entered(body):<br class="title-page-name"/>    if body.name == 'Player':<br class="title-page-name"/>        body.shield -= 15<br class="title-page-name"/>    queue_free()</pre>
<p class="calibre2">Also, running into the enemy should damage the player, so update this in <kbd class="calibre12">Enemy.gd</kbd>:</p>
<pre class="calibre18">func _on_Enemy_body_entered(body):<br class="title-page-name"/>    if body.name == 'Player':<br class="title-page-name"/>        body.shield -= 50<br class="title-page-name"/>        explode()</pre>
<p class="calibre2">The last addition to the player script is to regenerate the shield each frame. Add this line to <kbd class="calibre12">_process()</kbd>:</p>
<pre class="calibre18">    self.shield += shield_regen * delta</pre>
<p class="calibre2">The next step is to add the display element to the <kbd class="calibre12">HUD</kbd>. Rather than display the shield's value in a <kbd class="calibre12">Label</kbd>, you'll use a <kbd class="calibre12">TextureProgress</kbd> node. This is a <kbd class="calibre12">Control</kbd> node that is a type of <kbd class="calibre12">ProgressBar</kbd>: a node that displays a given value as a filled bar. The <kbd class="calibre12">TextureProgress</kbd> node allows you to assign a texture to be used for the bar's display.</p>
<p class="calibre2">In the existing <kbd class="calibre12">HBoxContainer</kbd>, add <kbd class="calibre12">TextureRect</kbd> and <kbd class="calibre12">TextureProgress</kbd>. Place them after the <kbd class="calibre12">ScoreLabel</kbd> and before the <kbd class="calibre12">LivesCounter</kbd>. Change the name of the <kbd class="calibre12">TextureProgress</kbd> to <span class="calibre5">ShieldBar</span>. Your node setup should look like this:</p>
<div class="cdpaligncenter1"><img src="../images/00105.jpeg" class="calibre117"/></div>
<p class="calibre2">Drag the <kbd class="calibre12">res://assets/shield_gold.png</kbd> texture into the <em class="calibre17">Texture</em> property of <kbd class="calibre12">TextureRect</kbd>. This will be an icon indicating what the bar is displaying.</p>
<p class="calibre2">The <span class="calibre5">ShieldBar</span> has three texture properties: Under, Over, and Progress. Progress is the texture that will be displayed as the bar's value. Drag <kbd class="calibre12">res://assets/barHorizontal_green_mid 200.png</kbd> into this property. The other two texture properties allow you to customize the appearance by setting an image to be drawn below or above the progress texture. Drag <kbd class="calibre12">res://assets/glassPanel_200.png</kbd> into the <em class="calibre17">Over</em> texture property.</p>
<p class="calibre2">In the <em class="calibre17">Range</em> section, you can set the numeric properties of the bar. <span class="calibre5">Min Value</span> and <span class="calibre5">Max Value</span> should be set to <kbd class="calibre12">0</kbd> and <kbd class="calibre12">100</kbd>, as this bar will be showing the percentage value of the shield, not its raw value. Value is the property that controls the currently displayed fill value. Change it to <kbd class="calibre12">75</kbd> to see the bar partly filled. Also, set its <span class="calibre5">Horizontal</span> size flags to <span class="calibre5">Fill</span>, <span class="calibre5">Expand</span>.</p>
<p class="calibre2">Now, you can update the HUD script to control the shield bar. Add these variables at the top:</p>
<pre class="calibre18">onready var ShieldBar = $MarginContainer/HBoxContainer/ShieldBar<br class="title-page-name"/>var red_bar = preload("res://assets/barHorizontal_red_mid 200.png")<br class="title-page-name"/>var green_bar = preload("res://assets/barHorizontal_green_mid 200.png")<br class="title-page-name"/>var yellow_bar = preload("res://assets/barHorizontal_yellow_mid 200.png")</pre>
<p class="calibre2">In addition to the green bar texture, you also have red and yellow bars in the <kbd class="calibre12">assets</kbd> folder. This will allow you to change the shield's color as the value decreases. Loading the textures in this way makes them easier to access later in the script when you want to assign the appropriate image to the <kbd class="calibre12">TextureProgress</kbd> node: </p>
<pre class="calibre18">func update_shield(value):<br class="title-page-name"/>    ShieldBar.texture_progress = green_bar<br class="title-page-name"/>    if value &lt; 40:<br class="title-page-name"/>        ShieldBar.texture_progress = red_bar<br class="title-page-name"/>    elif value &lt; 70:<br class="title-page-name"/>        ShieldBar.texture_progress = yellow_bar<br class="title-page-name"/>    ShieldBar.value = value</pre>
<p class="calibre2">Lastly, click on the <kbd class="calibre12">Main</kbd> scene's <kbd class="calibre12">Player</kbd> node and connect the <kbd class="calibre12">shield_changed</kbd> signal to the <kbd class="calibre12">update_shield()</kbd> function you just created. Run the game and verify that you can see the shield and that it is working. You may want to increase or decrease the regeneration rate to adjust it to a speed you like.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">In this chapter, you learned how to work with <kbd class="calibre12">RigidBody2D</kbd> nodes and learned more about how Godot's physics works. You also implemented a basic Finite State Machine—something you'll find more and more useful as your projects grow larger. You saw how <kbd class="calibre12">Container</kbd> nodes help organize and keep UI nodes aligned. Finally, you added some sound effects and got your first taste of advanced visual effects by using the <kbd class="calibre12">AnimationPlayer</kbd> and <kbd class="calibre12">Particles2D</kbd> nodes.</p>
<p class="calibre2">You also created a number of game objects using the standard Godot hierarchies, such as <kbd class="calibre12">CollisionShapes</kbd> being attached to <kbd class="calibre12">CollisionObjects</kbd>. At this point, some of these node configurations should be starting to look familiar to you. </p>
<p class="calibre2">Before moving on, look through the project again. Play it. Make sure you understand what each scene is doing, and read through the scripts to review how everything connects together. </p>
<p class="calibre2">In the next chapter, you'll learn about kinematic bodies, and use them to create a side-scrolling platform game.</p>


            </article>

            
        </section>
    </body></html>