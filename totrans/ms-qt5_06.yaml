- en: Chapter 6.  Even Qt Deserves a Slice of Raspberry Pi
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章. 即使Qt也值得在树莓派上拥有一片天地
- en: In the previous chapter, we created a QML UI targeted at Android and iOS. We
    will continue our journey in the embedded world by discovering how we can deploy
    a Qt application on a Raspberry Pi. The example project to illustrate this topic
    will be a snake game using the Qt3D modules. The player will control a snake trying
    to eat apples to get as big as possible.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们创建了一个针对Android和iOS的QML UI。我们将继续在嵌入式世界中的旅程，探索我们如何在树莓派上部署Qt应用程序。本主题的示例项目将是一个使用Qt3D模块的蛇游戏。玩家将控制一条蛇，试图吃苹果以变得尽可能大。
- en: 'In this chapter, you will learn:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习：
- en: The architecture of the Qt3D modules
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt3D模块的架构
- en: The basic principles of cross-compilation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨编译的基本原则
- en: How to build your own Qt Creator kit to compile and deploy your game on a Raspberry
    Pi
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何构建自己的Qt Creator工具包以在树莓派上编译和部署你的游戏
- en: How to handle the differences and limitations of various platforms (desktop,
    Raspberry Pi)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何处理各种平台（桌面、树莓派）的差异和限制
- en: The Factory design pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂设计模式
- en: How to write a complete game engine using JavaScript and QML
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用JavaScript和QML编写完整的游戏引擎
- en: The usage of the QML Profiler
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: QML分析器的使用
- en: Discovering Qt3D
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Qt3D
- en: 'The example project of this chapter will rely on 3D rendering. For this, we
    will use Qt3D. This part of the framework is divided into various Qt modules that
    enable the application to have a near-real time simulation of a 3D environment.
    Built on OpenGL, Qt3D offers a high-level API to describe complex scenes without
    having to resort to writing low-level OpenGL instructions. Qt3D supports the following
    basic features:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例项目将依赖于3D渲染。为此，我们将使用Qt3D。框架的这一部分被划分为各种Qt模块，使应用程序能够实现接近实时模拟的3D环境。建立在OpenGL之上，Qt3D提供了一个高级API来描述复杂的场景，而无需编写低级OpenGL指令。Qt3D支持以下基本功能：
- en: 2D and 3D rendering for C++ and Qt Quick
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++和Qt Quick的2D和3D渲染
- en: Meshes
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网格
- en: Materials
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 材质
- en: GLSL shaders
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GLSL着色器
- en: Shadow mapping
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阴影映射
- en: Deferred rendering
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟渲染
- en: Instance rendering
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例渲染
- en: Uniform Buffer Object
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常量缓冲区对象
- en: 'All these features are implemented in the **ECS** (**entity component system**)
    architecture. Each mesh, material, or shader that you define is a component. The
    aggregation of these components makes an entity. If you wanted to draw a 3D red
    apple, you would need the following components:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些功能都是在**ECS**（**实体组件系统**）架构中实现的。你定义的每个网格、材质或着色器都是一个组件。这些组件的聚合形成一个实体。如果你想绘制一个3D红色苹果，你需要以下组件：
- en: A mesh component, holding the vertices of your apple
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网格组件，持有你的苹果的顶点
- en: A material component, applying a texture on the mesh or coloring it
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 材质组件，将纹理应用到网格或为其上色
- en: 'These two components will then be regrouped to define the entity Apple. You
    see here the two parts of the ECS: entities and components. The overall architecture
    looks like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个组件将被重新组合以定义实体Apple。你在这里可以看到ECS的两个部分：实体和组件。整体架构看起来像这样：
- en: '![Discovering Qt3D](img/image00389.jpeg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![探索Qt3D](img/image00389.jpeg)'
- en: Each of these components can be regrouped in aspects. An aspect is a "slice"
    of multiple components working on the same part (rendering, audio, logic, and
    physics). When the graph of all your entities is processed by the Qt3D engine,
    each layer of aspects is processed sequentially.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件可以根据方面重新分组。方面是多个组件在同一部分（渲染、音频、逻辑和物理）上工作的“切片”。当Qt3D引擎处理所有实体的图时，每个方面的层会依次处理。
- en: 'The underlying approach is to favor composition over inheritance. In a game,
    an entity (an apple, a player, an enemy) can have various states during its life
    cycle: spawning, animating for a given state, dying animation, and so on. Using
    inheritance to describe these states will lead to a nerve-wracking tree: `AppleSpawn`, `AppleAnimationShiny`, `AppleDeath`,
    and so on. It would become quickly unmaintainable. Any modification to a class
    could have huge impact on many other classes and the number of possible combinations
    of states would get out of hand. Saying that a state is simply a component for
    a given entity, gives the flexibility to easily swap components and still keep
    the entity abstraction; an apple `Entity` element is still an apple, even though
    it is using the `AnimationShiny``Component` instead of the `AnimationSpawn``Component`.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的方法是优先考虑组合而非继承。在游戏中，一个实体（一个苹果、一个玩家、一个敌人）在其生命周期中可以有多种状态：生成、为给定状态进行动画、死亡动画等等。使用继承来描述这些状态会导致一个令人头疼的树状结构：`AppleSpawn`、`AppleAnimationShiny`、`AppleDeath`等等。这会很快变得难以维护。对任何类的任何修改都可能对许多其他类产生巨大影响，并且可能的状态组合数量会失控。说一个状态只是给定实体的一个组件，这给了我们灵活性，可以轻松地交换组件，同时仍然保持实体抽象；一个苹果`Entity`元素仍然是苹果，即使它使用的是`AnimationShiny`组件而不是`AnimationSpawn`组件。
- en: 'Let''s see how to define a basic `Entity` element in QML. Imagine that this
    is the apple we have been talking about. The `Apple.qml` file would look like
    this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在QML中定义一个基本的`Entity`元素。想象这是我们一直在谈论的苹果。`Apple.qml`文件看起来会是这样：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In a very few lines, you describe every aspect of the `Entity` element:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在非常少的几行代码中，你描述了`Entity`元素的各个方面：
- en: '`Entity`: This is the root object of the file; it follows the same QML pattern
    we studied in [Chapter 5](part0048.xhtml#aid-1DOR02 "Chapter 5.  Dominating the
    Mobile UI"), *Dominating the Mobile UI*.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Entity`：这是文件的根对象；它遵循我们在[第5章](part0048.xhtml#aid-1DOR02 "第5章。掌握移动UI")，*掌握移动UI*中研究的相同的QML模式。'
- en: '`PhongMaterial`: This defines how the surface will be rendered. Here, it uses
    the Phong shading technique to achieve smooth surfaces. It inherits `QMaterial`,
    which is the base class for all the material classes.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PhongMaterial`：这定义了表面将如何渲染。在这里，它使用Phong着色技术来实现平滑表面。它继承自`QMaterial`，这是所有材质类的基类。'
- en: '`CuboidMesh`: This defines what type of mesh will be used. It inherits `QGeometryRenderer`,
    which also gives the ability to load custom models (exported from 3D modeling
    software).'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CuboidMesh`：这定义了将使用哪种类型的网格。它继承自`QGeometryRenderer`，这也赋予了加载自定义模型（从3D建模软件导出）的能力。'
- en: '`Transform`: This defines the transformation matrix of the component. It can
    customize the translation, scale, and position of the `Entity` element.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Transform`：这定义了组件的变换矩阵。它可以自定义`Entity`元素的平移、缩放和位置。'
- en: '`Position`: This is a property to expose `transform.translation` for a given
    caller/parent. This might quickly become handy if we want to move the apple around.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Position`：这是一个属性，用于暴露给定调用者/父对象的`transform.translation`。如果我们想移动苹果，这可能会很快变得很有用。'
- en: '`Components`: This is the array containing all the IDs of all the components
    for the `Entity` element.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Components`：这是一个数组，包含`Entity`元素所有组件的所有ID。'
- en: 'If we want to make this `Apple` a child of another `Entity`, it is simply a
    matter of defining the Apple inside this new `Entity` element. Let''s call it `World.qml`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想将这个`Apple`变成另一个`Entity`的子对象，我们只需在这个新的`Entity`元素内部定义苹果即可。让我们称它为`World.qml`：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, the `World Entity` has no visual representation; we want it to be the
    root of our 3D scene. It only contains the `Apple` we defined earlier. The *x*, *y*, *z*
    coordinates of the apple are relative to the parent. When the parent makes a translation,
    the same translation will be applied to the apple.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`World Entity`没有视觉表示；我们希望它是我们3D场景的根。它只包含我们之前定义的`Apple`。苹果的`x`、`y`、`z`坐标相对于父对象。当父对象进行平移时，相同的平移也会应用到苹果上。
- en: This is how the hierarchy of entities/components is defined. If you write your
    Qt3D code in C++, the same logic applies to the equivalent C++ classes (`QEntity`, `QComponent`,
    and so on).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是定义实体/组件层次结构的方法。如果你用C++编写Qt3D代码，相同的逻辑也适用于等效的C++类（`QEntity`、`QComponent`等等）。
- en: Because we decided to use the `World.qml` file as the root of our scene, it
    has to define how the scene will be rendered. The Qt3D rendering algorithm is
    data-driven. In other words, there is a clear separation between *what* should
    be rendered (the tree of entities and components) and *how* it should be rendered.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们决定使用`World.qml`文件作为场景的根，所以它必须定义场景将如何渲染。Qt3D渲染算法是数据驱动的。换句话说，存在一个清晰的分离，即*应该渲染什么*（实体和组件的树）以及*如何渲染*。
- en: The *how* relies on a similar tree structure using `framegraph`. In Qt Quick,
    a single method of rendering is used and it covers the 2D drawing. On the other
    hand, in 3D, the need for flexible rendering makes it necessary to decouple the
    rendering techniques.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*如何*渲染依赖于使用`framegraph`的类似树结构。在Qt Quick中，使用单一的渲染方法，它涵盖了2D绘图。另一方面，在3D中，灵活渲染的需求使得解耦渲染技术成为必要。'
- en: 'Consider this example: you play a game where you control your avatar and you
    encounter a mirror. The same 3D scene must be rendered from multiple viewports.
    If the rendering technique is fixed, this poses multiple problems: which viewport
    should be drawn first? Is it possible to parallelize the rendering of the viewports
    in the GPU? What if we need to make multiple passes for the rendering?'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个例子：你玩一个游戏，游戏中你控制你的角色并遇到了一面镜子。必须从多个视图中渲染相同的3D场景。如果渲染技术是固定的，这会带来多个问题：应该先绘制哪个视口？能否在GPU中并行渲染视口？如果我们需要多次渲染呢？
- en: In this code snippet, we use the traditional OpenGL rendering technique with
    the `ForwardRenderer` tree, where each object is rendered directly on the back
    buffer, one at a time. Qt3D offers the possibility to choose the renderer (`ForwardRenderer`, `DeferredRenderer`,
    and so on) and configure how the scene should be rendered.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们使用传统的OpenGL渲染技术，通过`ForwardRenderer`树，其中每个对象都是直接在后缓冲区上渲染，一次一个。Qt3D提供了选择渲染器（`ForwardRenderer`、`DeferredRenderer`等）并配置场景应如何渲染的可能性。
- en: OpenGL typically uses the double-buffering technique to render its content.
    The front-buffer is what is displayed on the screen and the back-buffer is where
    the scene is being rendered. When the back-buffer is ready, the two buffers are
    swapped.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL通常使用双缓冲技术来渲染其内容。前缓冲区是显示在屏幕上的内容，后缓冲区是场景正在渲染的地方。当后缓冲区准备好后，两个缓冲区就会交换。
- en: 'One last thing to notice at the top of each `Entity` element is that we specified
    the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个`Entity`元素顶部需要注意的最后一点是，我们指定了以下内容：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'There are only Qt3D modules in the import section. Qt3D classes do not inherit
    `Item` so cannot be directly mixed with QML components. This inheritance tree
    of the basic Qt3D building blocks is:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 导入部分只有Qt3D模块。Qt3D类不继承`Item`，因此不能直接与QML组件混合。这个基本Qt3D构建块继承树如下：
- en: '![Discovering Qt3D](img/image00390.jpeg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![探索Qt3D](img/image00390.jpeg)'
- en: The `QNode` class is the base class of all Qt3D node classes. It relies on the `QObject`
    class to define the parenting relationship. Each `QNode` class instance also adds
    a unique `id` variable, which allows it to be recognized from other instances.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`QNode`类是所有Qt3D节点类的基类。它依赖于`QObject`类来定义父子关系。每个`QNode`类实例还添加了一个唯一的`id`变量，这使得它可以被识别为其他实例。'
- en: 'Even though `QNode` cannot be mixed with Qt Quick types, they can be added
    to a `Q3DScene` element (or `Scene3D` in QML), which serves as the canvas for
    Qt3D content and can be added to a Qt Quick `Item`. Adding `World.qml` to a scene
    is as simple as this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 即使`QNode`不能与Qt Quick类型混合，但它们可以被添加到`Q3DScene`元素（或在QML中的`Scene3D`），它作为Qt3D内容的画布，并可以被添加到Qt
    Quick的`Item`中。将`World.qml`添加到场景就像这样简单：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `Scene3D` element includes a `World` instance and defines common Qt Quick
    properties (`anchors`, `focus`).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`Scene3D`元素包含一个`World`实例并定义了常见的Qt Quick属性（`anchors`、`focus`）。'
- en: Configuring Qt for your Raspberry Pi
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为你的树莓派配置Qt
- en: 'This project targets a new embedded platform: the Raspberry Pi. Qt officially
    supports the Raspberry Pi 2, but we got the project running without any trouble
    on a Raspberry Pi 3\. If you do not have one of these devices, it might be nonetheless
    interesting to read this section to know how the cross-compilation works and how
    to configure your own kit in Qt Creator. The rest of the chapter will work on
    a Desktop platform anyway.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目针对一个新的嵌入式平台：树莓派。Qt官方支持树莓派2，但我们没有遇到任何麻烦地在树莓派3上运行了项目。如果你没有这些设备之一，尽管如此，阅读这一节了解交叉编译的工作原理以及如何在Qt
    Creator中配置自己的工具包可能仍然很有趣。无论如何，本章的其余部分将在桌面平台上运行。
- en: Before diving into the Raspberry Pi configuration, let's take a step back to
    understand our aim. Your computer is probably running on an x86 CPU architecture.
    This means that every program you run will be executed with the x86 instructions
    set of your CPU. In Qt Creator, this translates to your available kits. A kit
    must match your target platform. On startup, Qt Creator searches for available
    kits in your computer and loads them for you.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入到树莓派配置之前，让我们退一步来理解我们的目标。你的电脑可能运行在x86 CPU架构上。这意味着你运行的每个程序都将使用你CPU的x86指令集执行。在Qt
    Creator中，这转化为你的可用套件。一个套件必须匹配你的目标平台。在启动时，Qt Creator会在你的电脑上搜索可用的套件，并为你加载它们。
- en: 'In [Chapter 5](part0048.xhtml#aid-1DOR02 "Chapter 5.  Dominating the Mobile
    UI"), *Dominating the Mobile UI*, we targeted different platforms: Android and
    iOS. These platforms are running on a different CPU instruction set: ARM. Luckily,
    the people behind Qt automatically configured for us the necessary nuts and bolts
    to make it work.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](part0048.xhtml#aid-1DOR02 "第5章。掌握移动UI")中，*掌握移动UI*，我们针对不同的平台：Android和iOS。这些平台运行在不同的CPU指令集：ARM。幸运的是，Qt背后的团队为我们自动配置了必要的组件，使其能够工作。
- en: The Raspberry Pi also runs on ARM but it is not ready for Qt by default. We
    have to prepare it before playing with it in Qt Creator. Note that the following
    commands are run from a Linux box, but you should be able to run them from Mac
    or Windows with Cygwin.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派也运行在ARM上，但默认情况下并不适用于Qt。在Qt Creator中玩耍之前，我们必须先准备它。请注意，以下命令是在Linux盒子上运行的，但你应该能够使用Cygwin在Mac或Windows上运行它们。
- en: Note
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please follow the complete guide to prepare your Raspberry Pi for Qt at [https://wiki.qt.io/RaspberryPi2EGLFS](https://wiki.qt.io/RaspberryPi2EGLFS),
    or simply download a precompiled bundle from [http://www.qtrpi.com](http://www.qtrpi.com).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 请遵循完整的指南来准备你的树莓派以用于Qt，请参阅[https://wiki.qt.io/RaspberryPi2EGLFS](https://wiki.qt.io/RaspberryPi2EGLFS)，或者简单地从[http://www.qtrpi.com](http://www.qtrpi.com)下载预编译的捆绑包。
- en: 'The complete Raspberry Pi installation guide is outside the scope of the book.
    It is interesting nonetheless to sum up the main steps:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的树莓派安装指南超出了本书的范围。尽管如此，总结主要步骤仍然很有趣：
- en: Add development packages to the Raspberry Pi.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将开发包添加到树莓派中。
- en: Retrieve the complete toolchain, including the cross-compiler that will be executed
    from your machine.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取完整的工具链，包括将在你的机器上执行的交叉编译器。
- en: Create a `sysroot` folder on your machine that will mirror the necessary directories
    from the Raspberry Pi.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的机器上创建一个`sysroot`文件夹，它将镜像树莓派上必要的目录。
- en: Compile Qt with the cross-compiler in the `sysroot` folder.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`sysroot`文件夹中使用交叉编译器编译Qt。
- en: Synchronize this `sysroot` with the Raspberry Pi.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个`sysroot`与树莓派同步。
- en: A `sysroot` is simply a directory containing a minimal filesystem for a given
    platform. It typically contains the `/usr/lib` and `/usr/include` directories.
    Having this directory on your machine enables the cross-compiler to properly compile
    and link the output binary without being executed from the Raspberry Pi.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`sysroot`只是一个包含给定平台最小文件系统的目录。它通常包含`/usr/lib`和`/usr/include`目录。在你的机器上拥有这个目录使得交叉编译器能够正确编译和链接输出二进制文件，而无需从树莓派上执行。'
- en: All these steps are done to avoid compiling anything directly on the Raspberry
    Pi. Being a low-powered device, the execution of any compilation would take a
    very, very long time. Compiling Qt on a Raspberry Pi would easily take more than
    40 hours. Knowing this, the time spent on configuring the cross-compiler seems
    much easier to bear.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些步骤都是为了避免在树莓派上直接编译任何东西。作为一个低功耗设备，任何编译的执行都会花费非常非常长的时间。在树莓派上编译Qt可能需要超过40小时。了解这一点后，配置交叉编译器所花费的时间似乎更容易承受。
- en: 'The `qopenglwidget` example mentioned in the wiki should be properly running
    before proceeding. Once this has been done, we have to cross-compile a few more
    Qt modules to have our project running:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在wiki中提到的`qopenglwidget`示例在继续之前应该能够正常运行。一旦完成，我们必须交叉编译一些更多的Qt模块，以便我们的项目能够运行：
- en: '`Qtdeclarative`: This model is used to access Qt Quick'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Qtdeclarative`：这个模型用于访问Qt Quick'
- en: '`qt3d`: This model is used to construct a 3D world'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`qt3d`：这个模型用于构建3D世界'
- en: '`qtquickcontrols`: This model is used to include interesting controls (Label)'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`qtquickcontrols`：这个模型用于包含有趣的控件（标签）'
- en: '`qtquickcontrols2`: This model is used to make some new layouts available'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`qtquickcontrols2`：这个模型用于提供一些新的布局'
- en: 'For each of these modules, execute the following commands (from your `~/raspi`
    directory):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些模块中的每一个，执行以下命令（从你的`~/raspi`目录）：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Tip
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can speed up the compilation by adding the parameter `-j` (or `--jobs`)
    to `make`. The `make` command will try to parallelize the compilations jobs over
    your CPU cores, if you have four cores, use `make -j 4`, eight cores, `make -j
    8`, and so on.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在 `make` 中添加参数 `-j`（或 `--jobs`）来加快编译速度。`make` 命令将尝试并行化编译任务，如果您的 CPU 有四个核心，使用
    `make -j 4`，八个核心，`make -j 8`，依此类推。
- en: 'When everything has been compiled, synchronize your `sysroot` directory again
    with:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有内容都编译完成后，再次使用以下命令同步您的 `sysroot` 目录：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the previous command, you must replace the `IP` with the real Raspberry Pi
    address.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的命令中，你必须将 `IP` 替换为实际的树莓派地址。
- en: 'The Raspberry Pi is ready to execute our Qt code. However, we have to create
    our own kit in Qt Creator to be able to compile and deploy our program on it.
    A kit is composed of the following parts:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派已准备好执行我们的 Qt 代码。然而，我们必须在 Qt Creator 中创建自己的工具包，以便能够编译和部署我们的程序。一个工具包由以下部分组成：
- en: A **compiler** that will compile your code using the CPU instruction set of
    the target platform
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**编译器**，它将使用目标平台的 CPU 指令集编译您的代码。
- en: A **debugger** that will know the instruction set of the target platform to
    properly break and read the memory content
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个能够了解目标平台指令集的**调试器**，以便正确地中断并读取内存内容。
- en: A **Qt version** compiled for the targeted platform to compile and link your
    binary to the target platform's shared objects
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为目标平台编译和链接您的二进制文件而编译的**Qt 版本**。
- en: A **device** to which Qt Creator can connect to deploy and execute your program
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**设备**，Qt Creator 可以连接到以部署和执行您的程序。
- en: 'We will start with the compiler. In Qt Creator:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从编译器开始。在 Qt Creator 中：
- en: Go to **Tools** | **Options** | **Build & Run** | **Compilers**.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**工具** | **选项** | **构建和运行** | **编译器**。
- en: Click on **Add** |**GCC**.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**添加** | **GCC**。
- en: Browse to `~/raspi/tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian/bin/arm-linux-gnueabihf-g++`.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览到`~/raspi/tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian/bin/arm-linux-gnueabihf-g++`。
- en: Rename the compiler to `Rpi GCC`.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将编译器重命名为`Rpi GCC`。
- en: 'This strange binary name makes it easier for Qt to parse the **ABI** (**application
    binary interface**) to find out the platform architecture, file format, and so
    on. It should look like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个奇怪的二进制名称使得 Qt 更容易解析 **ABI**（**应用程序二进制接口**），以找出平台架构、文件格式等。它应该看起来像这样：
- en: '![Configuring Qt for your Raspberry Pi](img/image00391.jpeg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![为您的树莓派配置 Qt](img/image00391.jpeg)'
- en: Now for the debugger. As we said earlier, we are building this project from
    a Linux box (Ubuntu). Cross-compilation and embedded development tend to be easier
    on Linux but you should be able to do the same on a Windows or Mac with a few
    additional steps.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是调试器的时间。正如我们之前所说的，我们是从 Linux 箱子（Ubuntu）构建这个项目的。交叉编译和嵌入式开发在 Linux 上通常更容易，但您应该能够在
    Windows 或 Mac 上通过一些额外的步骤完成相同的工作。
- en: 'On Ubuntu Linux, just install a multi-architecture `gdb` with the command `sudo
    apt-get install gdb-multiarch`. In Qt Creator, add this new debugger in the **Debuggers**
    tab:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ubuntu Linux 上，只需使用命令`sudo apt-get install gdb-multiarch`安装多架构的 `gdb`。在 Qt
    Creator 中，在**调试器**选项卡中添加这个新的调试器：
- en: '![Configuring Qt for your Raspberry Pi](img/image00392.jpeg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![为您的树莓派配置 Qt](img/image00392.jpeg)'
- en: 'Next, add the cross-compiled Qt explained on the wiki page in the **Qt Versions**
    tab. Click on **Add** and browse to `~/raspi/qt5/bin/qmake`. This is the resulting
    Qt Version:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在**Qt 版本**选项卡中添加在维基页面上解释的交叉编译 Qt。点击**添加**并浏览到`~/raspi/qt5/bin/qmake`。这是生成的
    Qt 版本：
- en: '![Configuring Qt for your Raspberry Pi](img/image00393.jpeg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![为您的树莓派配置 Qt](img/image00393.jpeg)'
- en: 'We are almost there! Before building the kit, we simply have to configure Raspberry
    Pi device access. In **Options** | **Devices**, follow this procedure:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了！在构建工具包之前，我们只需配置 Raspberry Pi 设备访问。在**选项** | **设备**中，按照以下步骤操作：
- en: Click on **Add..** | **Generic Linux Device** | **Start Wizard**.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**添加..** | **通用 Linux 设备** | **开始向导**。
- en: The name will be `Rpi 2` (or 3 if you have one).
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 名称将是 `Rpi 2`（如果你有，则为 3）。
- en: Enter the IP address of your device (indeed, you have to be connected to your
    local network!).
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入您的设备 IP 地址（是的，您必须连接到您的本地网络！）。
- en: The default username is **pi**.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认用户名是**pi**。
- en: The default password is "raspberry".
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认密码是 "raspberry"。
- en: Click on **Next** to test the connection to the device.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**下一步**以测试与设备的连接。
- en: 'If everything went well, this is your new device:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，这就是您的新设备：
- en: '![Configuring Qt for your Raspberry Pi](img/image00394.jpeg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![为您的树莓派配置 Qt](img/image00394.jpeg)'
- en: 'Finally, the kit will compose all these parts into a valid Qt Creator platform.
    Go back to **Build & Run** | **Kits**. From here you simply have to point to each
    of the parts we built previously. Here is the resulting kit:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，套件将把所有这些部分组合成一个有效的Qt Creator平台。回到**构建和运行** | **套件**。从这里，您只需指向我们之前构建的每个部分。以下是生成的套件：
- en: '![Configuring Qt for your Raspberry Pi](img/image00395.jpeg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![配置Qt以适用于您的Raspberry Pi](img/image00395.jpeg)'
- en: Note that the **Sysroot** filed should point to the `sysroot` folder we previously
    created at `~/raspi/sysroot`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，**Sysroot**字段应指向我们之前在`~/raspi/sysroot`中创建的`sysroot`文件夹。
- en: Tip
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you click on the button to the right of **Name**, you can choose a custom
    picture for a kit, such as the Raspberry Pi logo.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您点击**名称**右侧的按钮，您可以为一套件选择自定义图片，例如Raspberry Pi标志。
- en: Everything is now ready to make an awesome snake game.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切准备就绪，可以制作一个精彩的蛇形游戏。
- en: Creating an entry point for your Qt3D code
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为您的Qt3D代码创建一个入口点。
- en: 'For those who did not play the snake game in their youth, here is a quick reminder
    of the gameplay:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些在年轻时没有玩过蛇形游戏的人来说，这里有一个关于游戏玩法的小提醒：
- en: You control a snake moving in an empty area
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您控制着在一个空旷区域移动的蛇。
- en: This area is surrounded by walls
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个区域被墙壁包围。
- en: An apple spawns randomly in the game area
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏区域内随机生成一个苹果。
- en: If the snake eats the apple, it grows and you gain a point. Right after, another
    apple spawns in the game area
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果蛇吃到了苹果，它会变长，并且您会得到一分。之后，游戏区域中会再次生成一个苹果。
- en: If the snake touches a wall or a part of its own body, you lose
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果蛇碰到墙壁或其自身的任何一部分，您就会失败。
- en: 'The goal is to eat as many apples as possible to have the highest score. The
    longer the snake, the harder it will become to avoid the wall and its own tail.
    Oh, and the snake goes faster and faster each time it eats an apple. The architecture
    of the game will be the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是吃尽可能多的苹果以获得最高分。蛇越长，避开墙壁和自身尾巴就越困难。哦，而且每次蛇吃苹果时，它都会变得越来越快。游戏架构将是以下这样：
- en: All the game items will be defined using Qt3D in QML
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有游戏项目都将使用Qt3D在QML中定义。
- en: All the game logic will be done in JavaScript, which will communicate with the
    QML elements
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有游戏逻辑都将使用JavaScript完成，它将与QML元素通信。
- en: We will keep the 2D feel of the original snake game by placing the camera above
    the game area but we will spice things up with 3D models and some shaders.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过将相机放置在游戏区域上方来保持原始蛇形游戏的2D感觉，但我们将通过3D模型和一些着色器来增加趣味性。
- en: 'Alright, we spent an awful lot of pages preparing for this moment. It is now
    time to begin the snake project. Create a new **Qt Quick Controls Application**
    named `ch06-snake`. In the project details:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们花费了大量页面来准备这一刻。现在是时候开始蛇形项目了。创建一个名为`ch06-snake`的新**Qt Quick Controls应用程序**。在项目详情中：
- en: Select **Qt 5.6** for the **minimal required Qt version** field.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**最小所需Qt版本**字段中选择**Qt 5.6**。
- en: Uncheck **With ui.qml file**.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消选中**带有ui.qml文件**。
- en: Uncheck **Enable native styling**.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消选中**启用本地样式**。
- en: 'Click on **Next** and select the following kits:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**下一步**并选择以下套件：
- en: RaspberryPi 2
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: RaspberryPi 2
- en: '**Desktop**'
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**桌面**'
- en: Click on **Next** | **Finish**.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**下一步** | **完成**。
- en: 'We have to add the Qt3D modules. Modify `ch06-snake.pro` like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须添加Qt3D模块。按照如下方式修改`ch06-snake.pro`：
- en: '[PRE6]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We have to prepare the entry point of the application to have a proper OpenGL
    context with which Qt3D can work. Open and update `main.cpp` like so:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须准备应用程序的入口点，以便拥有一个适当的OpenGL上下文，Qt3D可以在此上下文中工作。按照如下方式打开并更新`main.cpp`：
- en: '[PRE7]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The idea is to configure a `QSurfaceFormat` to properly handle OpenGL and to
    give it to a custom `QQuickView view`. This `view` will use this format to paint
    itself.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 想法是配置一个`QSurfaceFormat`以正确处理OpenGL，并将其提供给自定义的`QQuickView view`。这个`view`将使用此格式来绘制自己。
- en: The `qputenv("QT3D_GLSL100_WORKAROUND", "")` instruction is a workaround related
    to Qt3D shaders on some embedded Linux devices, such as the Raspberry Pi. It will
    enable a separate GLSL 1.00 snippet for the lights required by some embedded devices.
    If you do not use this workaround, you will get a black screen and will not be
    able to properly run the project on Raspberry Pi.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`qputenv("QT3D_GLSL100_WORKAROUND", "")`指令是与某些嵌入式Linux设备（如Raspberry Pi）上的Qt3D着色器相关的绕过方法。它将为一些嵌入式设备所需的灯光启用一个单独的GLSL
    1.00片段。如果您不使用此绕过方法，您将得到一个黑色屏幕，并且无法在Raspberry Pi上正确运行项目。'
- en: Tip
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The details of the Qt3d lights workaround are here:[https://codereview.qt-project.org/#/c/143136/](https://codereview.qt-project.org/#/c/143136/).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Qt3d灯光绕过细节在此：[https://codereview.qt-project.org/#/c/143136/](https://codereview.qt-project.org/#/c/143136/)。
- en: We chose to handle the view using Qt Quick. Another approach would be to create
    a C++ class that inherits `QMainWindow` and make it the parent of the QML content.
    This approach can be found in many Qt3D example projects. Both are valid and work.
    You tend to write more code with the `QMainWindow` approach, but it allows you
    to create 3D scenes with C++ only.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择使用 Qt Quick 来处理视图。另一种方法是为 `QMainWindow` 创建一个 C++ 类，使其成为 QML 内容的父类。这种方法可以在许多
    Qt3D 示例项目中找到。两种方法都是有效的并且可以工作。你倾向于使用 `QMainWindow` 方法编写更多的代码，但它允许你仅使用 C++ 创建 3D
    场景。
- en: 'Note that `view` from the `main.cpp` file tries to load a `main.qml` file.
    You can see it coming; here is the `main.qml`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`main.cpp` 文件中的 `view` 尝试加载一个 `main.qml` 文件。你可以看到它正在加载；以下是 `main.qml`：
- en: '[PRE8]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here we define the **HUD** (**heads up display**) at the top of the screen,
    where the score (the number of apples eaten) will be displayed. Note that we bound
    the Escape key to the `Qt.quit()` signal. This signal is connected in `main.cpp`
    to the `QGuiApplication::quit()` signal to quit the application.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了屏幕顶部的 **HUD**（**抬头显示**），其中将显示得分（吃掉苹果的数量）。注意，我们将 Esc 键绑定到了 `Qt.quit()`
    信号。这个信号在 `main.cpp` 中连接到了 `QGuiApplication::quit()` 信号，以便退出应用程序。
- en: 'The QML context is now ready to welcome Qt3D content. Modify `main.qml` like
    so:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: QML 上下文现在已准备好欢迎 Qt3D 内容。按照如下方式修改 `main.qml`：
- en: '[PRE9]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `Scene3D` element takes all the available space below the `hud` object.
    It takes the focus of the window to be able to intercept keyboard events. It also
    enables the input aspect to let the Qt3D engine process keyboard events in its
    graph traversal.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`Scene3D` 元素占据了 `hud` 对象下面的所有可用空间。它获取窗口的焦点，以便能够拦截键盘事件。它还启用了输入方面，以便 Qt3D 引擎在其图遍历中处理键盘事件。'
- en: Setting up the scene
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置场景
- en: 'We can now start writing Qt3D code. The first step is to define the root of
    the scene. Create a new file named `GameArea.qml`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始编写 Qt3D 代码了。第一步是定义场景的根。创建一个名为 `GameArea.qml` 的新文件：
- en: '[PRE10]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The first thing we do is create a camera and position it. Remember that, in
    OpenGL, the coordinates follow the thumb on your right hand points left!:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先做的事情是创建一个相机并将其定位。记住，在 OpenGL 中，坐标遵循你右手拇指指向的左侧！：
- en: '![Setting up the scene](img/image00396.jpeg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![设置场景](img/image00396.jpeg)'
- en: 'By placing the camera at `Qt.vector3d(x, y, 33)`, we make it come "out of the
    screen" to be able to express our yet-to-be-created entitiy''s coordinates with
    the simple `x`, `y` axis. The `upVector: Qt.vector3d(0.0, 1.0, 0.0)` specifies
    the up vector of the camera,  in our case it is the `Y` axis. Finally, we point
    at `Qt.vector(x, y, 0)`, meaning the center of the screen.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '通过将相机放置在 `Qt.vector3d(x, y, 33)`，我们使其“从屏幕中出来”，以便能够用简单的 `x`、`y` 轴来表示我们尚未创建的实体的坐标。`upVector:
    Qt.vector3d(0.0, 1.0, 0.0)` 指定了相机的向上向量，在我们的例子中是 `Y` 轴。最后，我们指向 `Qt.vector(x, y,
    0)`，意味着屏幕的中心。'
- en: The overall goal is to simplify coordinate expression. By positioning the camera
    this way, placing an object at the coordinate 0, 0 will put it in the bottom-left
    part of the window, whereas the coordinates 50, 28 mean the top-right part of
    the window.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 总体目标是简化坐标表达。通过这种方式定位相机，将对象放置在坐标 0, 0 将使其位于窗口的左下角，而坐标 50, 28 则意味着窗口的右上角。
- en: 'We also configure `RenderSettings` with a `ForwardRendered` that defines two
    properties:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用一个 `ForwardRendered` 配置 `RenderSettings`，它定义了两个属性：
- en: '`clearColor`: This property `Qt.rgba(0, 0, 0, 1)` means that the background
    will be pitch-black'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clearColor`：这个属性 `Qt.rgba(0, 0, 0, 1)` 表示背景将是漆黑一片'
- en: '`camera`: This property is used to determine the viewport to be rendered'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`camera`：这个属性用于确定要渲染的视口'
- en: 'The scene is ready to be rendered, but we need to handle user input, namely
    the keyboard. To capture keyboard events, modify `GameArea.qml` to look like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 场景已准备好渲染，但我们需要处理用户输入，即键盘。为了捕获键盘事件，将 `GameArea.qml` 修改如下：
- en: '[PRE11]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `KeyboardDevice` element is in charge of dispatching key events to the active `KeyboardHandler`,
    namely `input`. The `KeyboardHandler` component is attached to the controller
    and the `onPressed()` function will be called each time a key is pressed. The `KeyboardHandler`
    is a component; therefore it needs to be added to the list of components for `GameArea`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`KeyboardDevice` 元素负责将按键事件分发到活动的 `KeyboardHandler`，即 `input`。`KeyboardHandler`
    组件附加到控制器上，并且每次按键时都会调用 `onPressed()` 函数。`KeyboardHandler` 是一个组件；因此它需要被添加到 `GameArea`
    的组件列表中。'
- en: 'The last missing part of `GameArea` is preapring the engine execution (initialization
    and update):'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameArea` 最后缺失的部分是准备引擎执行（初始化和更新）：'
- en: '[PRE12]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here we mix Qt Quick elements with Qt3D. Due to possible name collisions, we
    have to import the module using the alias `QQ2`. We already met `Component.onCompleted`
    in [Chapter 5](part0048.xhtml#aid-1DOR02 "Chapter 5.  Dominating the Mobile UI"), *Dominating
    the Mobile UI*. Its job will be to start the game engine and start the `timer`
    defined right after.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们混合了Qt Quick元素和Qt3D。由于可能存在名称冲突，我们必须使用别名`QQ2`导入模块。我们已经在[第5章](part0048.xhtml#aid-1DOR02
    "第5章。掌握移动UI")，*掌握移动UI*中遇到了`Component.onCompleted`。它的任务将是启动游戏引擎并启动定义在后面的`timer`。
- en: This `timer` variable will repeat every 80 milliseconds (as defined in the `initialTimeInterval`
    property) and call the engine's `update()` function. This function will be covered
    when we build the engine code, later in this chapter. The goal is to emulate the
    original snake game as closely as possible. The whole game logic will be updated
    at this interval and not at the normal frame refresh interval. After each call
    to `update()`, the snake will advance. As a result, the snake's movement will
    not be smooth but rather jerky. This is clearly a design choice we made to have
    a retro-gaming feeling.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`timer`变量将每80毫秒（如`initialTimeInterval`属性中定义的）重复一次，并调用引擎的`update()`函数。当我们构建引擎代码时，这个函数将在本章后面被介绍。目标是尽可能接近地模拟原始的蛇游戏。整个游戏逻辑将在这个间隔更新，而不是在正常的帧刷新间隔。每次调用`update()`后，蛇将前进。因此，蛇的移动不会是平滑的，而是断断续续的。这显然是我们为了获得复古游戏感觉而做出的设计选择。
- en: 'Each time the snake eats an apple, two things happen:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 每当蛇吃到一个苹果时，会发生两件事：
- en: The `interval` of the timer will be reduced by the engine (accessed by the `timerInterval`
    property).
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计时器的`interval`将由引擎（通过`timerInterval`属性访问）减少。
- en: The snake will grow. Its initial size is defined in the `intialSnakeSize` property.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蛇会生长。它的初始大小由`intialSnakeSize`属性定义。
- en: Reducing the timer interval will make the snake advance faster until it becomes
    very hard to manage its direction.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 减少计时器间隔会使蛇移动得更快，直到很难控制其方向。
- en: Assembling your Qt3D entities
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组装你的Qt3D实体
- en: 'We will now proceed to create the building blocks of the game, each in the
    form of an `Entity` element:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将开始创建游戏的基本构建块，每个都是以`Entity`元素的形式：
- en: '`Wall`: This represents the limit of where the snake cannot go'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Wall`：这代表蛇不能去的极限'
- en: '`SnakePart`: This represents a part of the snake''s body'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SnakePart`：这代表蛇身体的一部分'
- en: '`Apple`: This represents the apple (no way!) spawned at a random location'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Apple`：这代表在随机位置生成的苹果（不可能！）'
- en: '`Background`: This represents a good-looking background behind the snake and
    the apple'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Background`：这代表蛇和苹果后面的漂亮背景'
- en: 'Each entity will be placed on a grid handled by the engine and will have a
    type identifier to make it easier to find. To factorize these properties, let''s
    create a parent QML file named `GameEntity.qml`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 每个实体都将放置在由引擎处理的网格上，并将有一个类型标识符，以便更容易找到。为了将这些属性归一化，让我们创建一个名为`GameEntity.qml`的父QML文件：
- en: '[PRE13]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This `Entity` element only defines a `type` property and a `gridPosition` property
    , which will be used by the engine to lay out the content on the grid.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Entity`元素只定义了一个`type`属性和一个`gridPosition`属性，这些将由引擎用于在网格上布局内容。
- en: 'The first item we will build is the `Wall.qml` file:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建的第一个项目是`Wall.qml`文件：
- en: '[PRE14]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, the `Wall` type does not have any visual representation. Because
    we target a Raspberry Pi device, we have to be very careful with the CPU/GPU consumption.
    The game area will be a grid where each cell contains an instance of one of our
    entities. The snake will be surrounded by `Wall` instances. The Raspberry Pi is
    much slower than your average computer, to the extent that the game would become
    unbearably slow if we displayed all the walls.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`Wall`类型没有任何视觉表示。因为我们针对的是树莓派设备，我们必须非常小心CPU/GPU的消耗。游戏区域将是一个网格，其中每个单元格包含我们实体中的一个实例。蛇将被`Wall`实例所包围。树莓派的运行速度远低于普通电脑，如果显示所有墙壁，游戏将变得难以忍受地慢。
- en: To address this issue, the walls are invisible. They will be placed outside
    the visible viewport and the borders of the window will act as the visual limit
    of the snake. Of course, if you do not target the Raspberry Pi, but rather your
    computer, it is fine to display the walls and make them look fancier than just
    nothing.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，墙壁是看不见的。它们将被放置在可见视口之外，窗口的边缘将作为蛇的视觉极限。当然，如果你不是针对树莓派，而是你的电脑，显示墙壁并使它们看起来比什么都没有更华丽是可以的。
- en: 'The next `Entity` element we will implement is `SnakePart.qml`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要实现的下一个`Entity`元素是`SnakePart.qml`：
- en: '[PRE15]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If added to the `GameArea` scene, the `SnakePart` block will display a single
    green cube. The `SnakePart` block is not the complete snake, rather a part of
    its body. Remember that the snake grows each time it eats an apple. Growing means
    adding a new instance of `SnakePart` to a list of `SnakePart`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果添加到`GameArea`场景中，`SnakePart`块将显示一个单独的绿色立方体。`SnakePart`块不是完整的蛇，而是其身体的一部分。记住，蛇每次吃苹果时都会增长。增长意味着将一个新的`SnakePart`实例添加到`SnakePart`列表中。
- en: 'Let''s proceed with the `Apple.qml`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续使用`Apple.qml`：
- en: '[PRE16]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This snippet starts with introducing more complex yet easy-to-use features of
    Qt3D, namely a custom mesh and a texture applied to it. Qt3D supports the Wavefront
    `obj` format to load custom meshes. Here we added a home-cooked apple to the `.qrc`
    file of the application and we just have to provide the path to this resource
    to load it.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段首先介绍了Qt3D更复杂但易于使用的功能，即自定义网格及其上的纹理。Qt3D支持Wavefront `obj`格式来加载自定义网格。在这里，我们将一个自制的苹果添加到应用程序的`.qrc`文件中，我们只需提供这个资源的路径来加载它。
- en: The same principle is applied for the `DiffuseMapMaterial` element. We added
    a custom texture and added it as a source of the component.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的原则也应用于`DiffuseMapMaterial`元素。我们添加了一个自定义纹理，并将其作为组件的源添加。
- en: As you can see, the `Entity` definition and its components look very much the
    same. Yet we effortlessly traded a Qt3D `CuboidMesh` with a custom model.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`Entity`定义及其组件看起来非常相似。然而，我们轻松地将Qt3D的`CuboidMesh`与自定义模型交换。
- en: 'We will push things even further with `Background.qml`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`Background.qml`进一步推进：
- en: '[PRE17]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `Background` block will be displayed behind the snake and the apple. At
    first sight, this entity looks very much like `SnakePart`. However, `Material`
    is not a Qt3D class. It is a custom defined `Material` that relies on shaders.
    Let''s see `MaterialBackground.qml`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`Background`块将在蛇和苹果后面显示。乍一看，这个实体非常像`SnakePart`。然而，`Material`不是一个Qt3D类。它是一个自定义定义的`Material`，依赖于着色器。让我们看看`MaterialBackground.qml`：'
- en: '[PRE18]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you are not familiar with shaders, we can summarize them in the following
    statement: shaders are computer programs written in a C-style syntax that are
    executed by the GPU. Data from your logic will be fed by the CPU and made available
    to the GPU memory where your shaders will run. Here we manipulate two types of
    shader:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉着色器，我们可以用以下语句来概括它们：着色器是使用C风格语法编写的计算机程序，由GPU执行。你的逻辑数据将由CPU提供，并使GPU内存中的着色器可用。在这里，我们操作两种类型的着色器：
- en: '**Vertex shader**, which is executed on each vertex of the source of your mesh'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顶点着色器**，它在你的网格源中的每个顶点上执行'
- en: '**Fragment**, which is executed on each pixel to produce the final rendering'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**片段着色器**，它在每个像素上执行以生成最终渲染'
- en: By being executed on the GPU, these shaders utilize the huge parallelization
    power of the GPU (which is orders-of-magnitude higher than your CPU). It enables
    modern games to have such stunning visual rendering. Covering shaders and the
    OpenGL pipeline is beyond the scope of this book (you can fill several bookshelves
    on this subject alone). We will limit ourselves to showing you how you can use
    shaders in Qt3D.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在GPU上执行，这些着色器利用了GPU巨大的并行化能力（这比你的CPU高几个数量级）。它使得现代游戏能够拥有如此惊人的视觉效果。涵盖着色器和OpenGL管道超出了本书的范围（仅此主题就可以填满几个书架）。我们将限制自己向您展示如何在Qt3D中使用着色器。
- en: Note
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to delve into OpenGL or sharpen your skills with shaders, we recommend
    the *OpenGL SuperBible*, by Graham Sellers, Richard S Wright Jr., and Nicholas
    Haemel.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想深入研究OpenGL或提高你的着色器技能，我们推荐Graham Sellers、Richard S Wright Jr.和Nicholas Haemel合著的《OpenGL
    SuperBible》。
- en: Qt3D supports shaders in a very convenient way. Simply add your shader file
    to the `.qrc` resource file and load it in the `effect` property of a given `Material`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Qt3D以非常方便的方式支持着色器。只需将你的着色器文件添加到`.qrc`资源文件中，并在给定`Material`的`effect`属性中加载它。
- en: In this snippet, we specify that this shader `Technique` should be run only
    on OpenGL 3.2\. This is indicated in the `graphicsApiFilter` block. This version
    of OpenGL targets your desktop machine. Because the performance gap between your
    desktop and your Raspberry Pi is very marked, we have the ability to execute different
    shaders depending on the platform.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们指定这个着色器`Technique`只应在OpenGL 3.2上运行。这由`graphicsApiFilter`块指示。这个版本的OpenGL针对你的桌面机器。因为你的桌面和树莓派之间的性能差距非常明显，所以我们有能力根据平台执行不同的着色器。
- en: 'Thus, here is the Raspberry Pi-compatible technique:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，以下是树莓派兼容的技术：
- en: '[PRE19]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You just have to add it to the `techniques` property of the `Material`. Note
    that the targeted OpenGL version is OpenGLES 2.0, which will run fine on your
    Raspberry Pi and even your iOS/Android phone.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需将其添加到`Material`的`techniques`属性中。请注意，目标OpenGL版本是OpenGLES 2.0，它可以在你的树莓派上运行得很好，甚至可以在你的iOS/Android手机上运行。
- en: 'A last thing to cover is how parameters can be passed to shaders. Here is an
    example:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要讨论的是如何将参数传递给着色器。以下是一个例子：
- en: '[PRE20]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `score` variable will be accessible in the shader with this simple section.
    Please take a look at the source code for the chapter to see the complete content
    of this `Material` element. We had the fun of writing a shader displaying a moving
    and glowing wave over a grass texture.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`score`变量将通过这个简单的部分在着色器中可访问。请查看该章节的源代码以查看此`Material`元素的完整内容。我们编写了一个着色器的乐趣，它可以在草地纹理上显示移动和发光的波浪。'
- en: 'The only fixed element of the game is the background. We can directly add it
    to `GameArea.qml`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中唯一固定的元素是背景。我们可以直接将其添加到`GameArea.qml`：
- en: '[PRE21]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `Background` element is positioned to cover the whole visible area behind
    the snake and the apple. Being defined inside `GameArea`, it will be automatically
    added to the entity/component tree and will be drawn right away.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`Background`元素被定位以覆盖蛇和苹果后面的整个可见区域。由于它定义在`GameArea`内部，它将被自动添加到实体/组件树中，并立即绘制。'
- en: Preparing the board game
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备游戏板
- en: 'Even if our game has a 3D representation, we will implement 2D gameplay like
    the original snake game. Our game items are born, will live, and die in a 2D area.
    Like chess, this board will be composed of rows and columns. But in our snake
    game, each square can be:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们的游戏有3D的表现形式，我们也会实现像原始贪吃蛇游戏那样的2D游戏玩法。我们的游戏物品将在一个2D区域内诞生、生存和死亡。就像棋盘一样，这个板将由行和列组成。但在我们的贪吃蛇游戏中，每个方块都可以是：
- en: An apple
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个苹果
- en: A snake
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一条蛇
- en: A wall
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一堵墙
- en: Empty
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空的
- en: 'Here is an example of a board representation from the point of view of the
    engine:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是引擎视角下板表示的一个例子：
- en: '![Preparing the board game](img/image00397.jpeg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![准备游戏板](img/image00397.jpeg)'
- en: This is a small 10x8 board; even if the size does not matter, you will be able
    to define a bigger one. Your game, your rules! We have walls (**W**) surrounding
    the game area. An apple (**A**) is spawned at 7x2\. Finally, we have a snake (**S**)
    beginning at 3x4 and ending at 5x5.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个10x8的小板；即使大小不重要，你也将能够定义一个更大的板。你的游戏，你的规则！我们的游戏区域周围有墙壁（**W**）。一个苹果（**A**）在7x2的位置生成。最后，我们有一条蛇（**S**），从3x4开始，到5x5结束。
- en: 'It is time to create our board class. Please create a JS file called `board.js`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候创建我们的板类了。请创建一个名为`board.js`的JS文件：
- en: '[PRE22]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This object constructor function required three parameters. The `columnCount`
    and `rowCount` parameters will help you to choose the board dimension. The last
    parameter, `blockSize`, is the size of a board square in the OpenGL world. For
    example, we can set `blockSize` to 10\. In this case, the apple in 7x2 on the
    board we be displayed with `x = 70` and `y = 20` in the OpenGL world. In this
    chapter, we will use a `blockSize` of 1, so the board coordinates match OpenGL
    coordinates.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象构造函数需要三个参数。`columnCount`和`rowCount`参数将帮助您选择板的尺寸。最后一个参数`blockSize`是OpenGL世界中板方块的尺寸。例如，我们可以将`blockSize`设置为10。在这种情况下，7x2的苹果在板上的显示将是OpenGL世界中的`x
    = 70`和`y = 20`。在本章中，我们将使用`blockSize`为1，因此板坐标与OpenGL坐标匹配。
- en: 'Let''s add some utility functions to `board.js`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`board.js`中添加一些实用函数：
- en: '[PRE23]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Defining a class in JavaScript can be disturbing for a C++ developer. Every
    JavaScript object has a prototype object to which you can add functions. We are
    using it to add class methods to `Board`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中定义一个类可能会让C++开发者感到困扰。每个JavaScript对象都有一个原型对象，你可以向其中添加函数。我们正在使用它来向`Board`添加类方法。
- en: 'Here is a summary of the purpose of each function of the `Board` class:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`Board`类每个函数目的的总结：
- en: '`init()`: This function initializes all array values to the `null` value'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init()`: 这个函数将所有数组值初始化为`null`值'
- en: '`index()`: This function returns the array index from column/row coordinates'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index()`: 这个函数从列/行坐标返回数组索引'
- en: '`setData()`: This function assigns the `data` value on the board from column/row
    coordinates'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setData()`: 这个函数将根据列/行坐标在板上分配`data`值'
- en: '`at()`: This function retrieves the `data` value in an array from column/row
    coordinates'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`at()`: 这个函数从列/行坐标检索数组中的`data`值'
- en: Please note that, in our case, a `null` square means an empty square.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在我们的情况下，一个`null`方块表示一个空方块。
- en: Crafting entities from the factory
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从工厂创建实体
- en: 'Now that we have a board to receive items, we will create the game items factory.
    The factory is a design pattern that allows us to create an object without exposing
    the creation logic to the caller. This factory can be seen as a helper class that
    will handle all the dirty tasks required when you want to create a new game item
    from JavaScript. Do you remember `GameEntity.qml`? It is the parent class of `Apple.qml`, `Snake.qml`,
    and `Wall.qml`. The factory will be able to create a specific entity for a given
    a type and coordinates. We will use the property type to identify an entity kind.
    Here is the factory pattern schema used in our snake game:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个接收项目的棋盘，我们将创建游戏项目工厂。工厂是一种设计模式，它允许我们创建一个对象，而不向调用者暴露创建逻辑。这个工厂可以被视为一个辅助类，它将处理当你想从
    JavaScript 中创建一个新的游戏项目时所需的全部脏活累活。你还记得 `GameEntity.qml` 吗？它是 `Apple.qml`、`Snake.qml`
    和 `Wall.qml` 的父类。工厂将能够根据给定的类型和坐标创建特定的实体。我们将使用属性类型来识别实体种类。以下是我们在蛇形游戏中使用的工厂模式架构：
- en: '![Crafting entities from the factory](img/image00398.jpeg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![从工厂创建实体](img/image00398.jpeg)'
- en: 'We can now create the `factory.js` file, which begins like this:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以创建一个名为 `factory.js` 的文件，其内容如下：
- en: '[PRE24]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: First of all, we define all the game entity types. In our case we have apple,
    snake, and wall types. Then, we create game item components from QML files. These
    components will be use by the factory to dynamically create new game entities.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义所有游戏实体类型。在我们的例子中，我们有苹果、蛇和墙壁类型。然后，我们从 QML 文件中创建游戏项目组件。这些组件将由工厂用于动态创建新的游戏实体。
- en: 'We can now add the constructor and a `removeAllEntities()` utility function
    to remove all instantiated entities:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以添加构造函数和一个 `removeAllEntities()` 工具函数来删除所有实例化的实体：
- en: '[PRE25]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This factory has three member variables:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工厂有三个成员变量：
- en: A reference to the game `board` described in the previous section
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对上一节中描述的游戏 `board` 的引用
- en: A reference to the `parentEntity` variable, that is, the game area
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对 `parentEntity` 变量的引用，即游戏区域
- en: An `entities` array that keeps a reference to created items
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个保存已创建项目引用的 `entities` 数组
- en: The `removeAllEntities()` function will remove the items from their parent (that
    is, the game area) and create a new empty entities array. This ensures that old
    entities are deleted by the garbage collector.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`removeAllEntities()` 函数将从其父级（即游戏区域）中删除项目，并创建一个新的空 `entities` 数组。这确保了旧实体被垃圾回收器删除。'
- en: 'Let''s add the core function `createGameEnity()` in the factory:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在工厂中添加核心函数 `createGameEnity()`：
- en: '[PRE26]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, the caller provides an entity `type` and board coordinates (`column`
    and `row`). The first part is a switch to select the correct QML component. Once
    we have the component, we can call `component.createObject()` to create an instance
    of this component. The parent of this new component will be `this.parentEntity`,
    in our case, `GameArea`. Then, we can update the board, update the entity position,
    and add this new entity in the `entities` array.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，调用者提供了一个实体 `type` 和棋盘坐标（`column` 和 `row`）。第一部分是一个开关，用于选择正确的 QML 组件。一旦我们有了组件，我们就可以调用
    `component.createObject()` 来创建该组件的一个实例。这个新组件的父级将是 `this.parentEntity`，在我们的例子中，是
    `GameArea`。然后，我们可以更新棋盘，更新实体位置，并将这个新实体添加到 `entities` 数组中。
- en: 'The last thing to do is to update our QML game entities with the proper factory
    type. Please open `Apple.qml` and update the file like this:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一件要做的事情是更新我们的 QML 游戏实体以正确的工厂类型。请打开 `Apple.qml` 并按照以下方式更新文件：
- en: '[PRE27]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You can now update `Snake.qml` with the `Factory.SNAKE_TYPE` type and `Wall.qml`
    with the `Factory.WALL_TYPE` type.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以更新 `Snake.qml` 中的 `Factory.SNAKE_TYPE` 类型，以及 `Wall.qml` 中的 `Factory.WALL_TYPE`
    类型。
- en: Building a snake engine in JavaScript
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 JavaScript 中构建蛇形引擎
- en: It is time to get your hands dirty. Let's see how to create an engine in JavaScript
    to manage a snake game using our board, our factory, and the power of QML.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候动手实践了。让我们看看如何使用我们的棋盘、我们的工厂和 QML 的力量在 JavaScript 中创建一个管理蛇形游戏的引擎。
- en: 'Please create a new `engine.js` file with the following snippet:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 请创建一个新的 `engine.js` 文件，包含以下代码片段：
- en: '[PRE28]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The first lines are the Qt way to import a JavaScript file from another JavaScript
    file. Then, we can easily instantiate a `factory` variable and a 50x29 `board`
    variable. The `snake` array contains all the snake game items instantiated. This
    array will be useful to move our snake. Finally, the `direction` variable is a
    2d vector handling the current snake direction.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 前几行是 Qt 从另一个 JavaScript 文件中导入 JavaScript 文件的方式。然后，我们可以轻松实例化一个 `factory` 变量和一个
    50x29 的 `board` 变量。`snake` 数组包含所有实例化的蛇形游戏项目。这个数组将有助于移动我们的蛇。最后，`direction` 变量是一个处理当前蛇方向的
    2d 向量。
- en: 'This is the first function of our engine:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的引擎的第一个函数：
- en: '[PRE29]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This gives you a summary of what is done when we start the engine:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们总结了启动引擎时所做的操作：
- en: Initialize the engine.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化引擎。
- en: Create the initial snake.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建初始蛇。
- en: Create walls surrounding the game area.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建围绕游戏区域的墙壁。
- en: Spawn the first apple.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成第一个苹果。
- en: Switch the `GameArea` state to `PLAY`.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`GameArea`状态切换到`PLAY`。
- en: 'Let''s begin with the `initEngine()` function:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`initEngine()`函数开始：
- en: '[PRE30]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This function initializes and resets all the variables. The first task is to
    set the `GameArea` timer interval to its initial value. Each time the snake eats
    an apple, this interval is reduced, increasing the game speed and thus the snake's
    movement speed. Logically, we reset the score of the player to `0`. Then we initialize
    the factory, giving the board and `gameRoot` references. The `gameRoot` refers
    to the `GameArea`; this entity will be the parent of all items instantiated by
    the factory. Then, we remove all the existing entities from the factory and call
    the board's `init()` function to clear the board. Finally, we set a default direction
    for the snake. The vector `-1,0` means that the snake will begin moving to the
    left. If you want the snake to start moving up, you can set the vector to `0,
    1`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数初始化并重置所有变量。第一个任务是设置`GameArea`计时器的初始值。每次蛇吃到一个苹果，这个间隔就会减少，从而增加游戏速度和蛇的移动速度。从逻辑上讲，我们将玩家的分数重置为`0`。然后我们初始化工厂，提供板和`gameRoot`引用。`gameRoot`指的是`GameArea`；这个实体将是工厂实例化所有项目的父项。然后，我们从工厂中移除所有现有实体，并调用板的`init()`函数来清除板。最后，我们为蛇设置一个默认方向。向量`-1,0`意味着蛇将开始向左移动。如果你想让蛇向上移动，可以将向量设置为`0,
    1`。
- en: 'The next function is creating the snake:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个函数是创建蛇：
- en: '[PRE31]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: No big deal here, we reset and initialize the `snake` array. The first snake
    item will be created at 25x12\. We then proceed to create as many snake items
    as we need to spawn a snake with the correct initial size. Please note that other
    snake items will be created to the right of the first item (26x12, 27x12, and
    so on). You can see how easy it is to call our factory and request a new snake
    item instance.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有太大的问题，我们重置并初始化`snake`数组。第一个蛇项将在25x12处创建。然后我们继续创建我们需要的蛇项以生成具有正确初始大小的蛇。请注意，其他蛇项将创建在第一个项的右侧（26x12，27x12，等等）。你可以看到调用我们的工厂并请求新的蛇项实例是多么容易。
- en: 'Let''s add the `createWalls()` function to `engine.js`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`engine.js`中添加`createWalls()`函数：
- en: '[PRE32]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The first loop creates the top and bottom walls. The second loop creates the
    left and right walls. The indexes of the second loop are different from the first
    one to avoid creating the corners twice.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个循环创建顶部和底部墙壁。第二个循环创建左侧和右侧墙壁。第二个循环的索引与第一个不同，以避免两次创建角落。
- en: 'Let''s see now how to implement the `spawnApple()` function in `engine.js`:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何在`engine.js`中实现`spawnApple()`函数：
- en: '[PRE33]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The first step is to find an empty square. The while loop will generate a random
    board position and check whether a square is empty. As soon as an empty square
    is found, we request the factory to create an apple entity at this position. Finally,
    we reduce the `timerInverval` value of `GameArea` to speed up the game.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是找到一个空方格。while循环将生成一个随机的板位置并检查一个方格是否为空。一旦找到一个空方格，我们就请求工厂在这个位置创建一个苹果实体。最后，我们减少`GameArea`的`timerInterval`值以加快游戏速度。
- en: 'We will now add some utility functions related to the snake position in `engine.js`:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将在`engine.js`中添加一些与蛇位置相关的实用函数：
- en: '[PRE34]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `setPosition()` function handles all the necessary tasks when we want to
    move a game item. We first assign the game item to the correct board square, then
    we update the `gridPosition` property (from `GameEntity`) but also the OpenGL `position.x`
    and `position.y`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`setPosition()`函数处理当我们想要移动一个游戏项时所需的所有必要任务。我们首先将游戏项分配到正确的板方格，然后更新`gridPosition`属性（从`GameEntity`），但也更新OpenGL的`position.x`和`position.y`。'
- en: 'The second function, `moveSnake()`, moves the snake to an adjacent square.
    Let''s dissect all the steps performed by this function:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个函数`moveSnake()`将蛇移动到相邻的方格。让我们分析这个函数执行的所有步骤：
- en: The `snake` is our global array containing all the snake items. The `pop()`
    method removes and returns the last element that we store in the `last` variable.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`snake`是我们包含所有蛇项的全局数组。`pop()`方法移除并返回我们存储在`last`变量中的最后一个元素。'
- en: The `last` variable contains the snake's tail's grid position. We set this board
    square to `null`; that means an empty square for us.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`last`变量包含蛇尾的网格位置。我们将此板方格设置为`null`；对我们来说这意味着一个空方格。'
- en: The `last` variable is now put on the adjacent square requested by the caller.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`last` 变量现在放置在调用者请求的相邻方块上。'
- en: The `last` variable is finally inserted at the beginning of the `snake` array.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`last` 变量最终插入到 `snake` 数组的开始处。'
- en: 'The next schema illustrates the `moveSnake()` process when a snake is moving
    on the left. We also name snake items with a letter to visualize how the tail
    becomes the head, simulating a moving snake:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个图例展示了蛇在左侧移动时 `moveSnake()` 的过程。我们还用字母命名蛇项，以可视化尾巴变成头部，模拟移动的蛇：
- en: '![Building a snake engine in JavaScript](img/image00399.jpeg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![在JavaScript中构建蛇形引擎](img/image00399.jpeg)'
- en: 'Now that we can move our snake, we must handle key events to move the snake
    in the correct direction. Please add this new function to `engine.js`:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够移动我们的蛇，我们必须处理按键事件以正确地移动蛇。请将此新函数添加到 `engine.js`：
- en: '[PRE35]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In this game, we use the `I-J-K-L` keys to update the snake direction vector.
    Like the original snake game, you can't reverse your direction. A check is performed
    to avoid this behavior. Please notice that pressing the `R` key will call `start()`
    and so restart the game. We will see soon how to bind this function with the QML
    keyboard controller.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个游戏中，我们使用 `I-J-K-L` 键来更新蛇的方向向量。就像原始的蛇形游戏一样，你不能改变方向。会进行一次检查以避免这种行为。请注意，按下 `R`
    键将调用 `start()` 并重新开始游戏。我们很快就会看到如何将此功能与 QML 键盘控制器绑定。
- en: 'Here we are, the last (but not least) function, the `update()` function of `engine.js`:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 到这里，我们来到了最后一个（但不是最不重要的）函数，即 `engine.js` 的 `update()` 函数：
- en: '[PRE36]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This function will be called at regular intervals by QML. As you can see, if
    the `gameRoot` (that is `GameArea`) `state` variable equals `GAMEOVER`, this function
    does nothing and returns immediately. Then, three important steps are performed:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将由 QML 以固定间隔调用。正如你所见，如果 `gameRoot`（即 `GameArea`）的 `state` 变量等于 `GAMEOVER`，此函数将不执行任何操作并立即返回。然后，执行三个重要步骤：
- en: Retrieve the grid position of the snake's head in `headPosition`.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `headPosition` 中检索蛇头的网格位置。
- en: Process where the snake goes using the `direction` vector in `newPosition`.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `newPosition` 中的 `direction` 向量确定蛇的移动路径。
- en: Put the item where the snake is going in `itemOnNewPosition`.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目放置在蛇将要移动的位置 `itemOnNewPosition`。
- en: 'The second part of the `update()` function is the following snippet:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`update()` 函数的第二部分如下所示：'
- en: '[PRE37]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If the snake is going to an empty square (`itemOnNewPosition` is `null`), it
    is alright and we only move the snake to `newPosition`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果蛇要移动到一个空方块（`itemOnNewPosition` 是 `null`），这是可以的，我们只需将蛇移动到 `newPosition`。
- en: 'If the square is not empty, we must apply the correct rule depending on the
    item type. If the next square is a snake part or a wall, we update the state to
    `GAMEOVER`. On the other hand, if the next square is an apple, several steps are
    performed:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果方块不为空，我们必须根据项目类型应用正确的规则。如果下一个方块是蛇的一部分或墙壁，我们将状态更新为 `GAMEOVER`。另一方面，如果下一个方块是苹果，将执行以下几个步骤：
- en: Detach the apple item from `GameArea`, setting its parent to `null`.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `GameArea` 中移除苹果项，将其父级设置为 `null`。
- en: Remove the apple from the board, setting the board square to `null`.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从板上移除苹果，将方块设置为 `null`。
- en: Grow the snake, creating a snake part at the beginning of the `snake` array.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让蛇变长，在 `snake` 数组的开始处创建一个蛇的部分。
- en: Spawn a new apple in a random empty square.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个随机的空方块中生成一个新的苹果。
- en: Increment the score.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增加分数。
- en: 'Our snake engine is now complete. The last step is to call some engine functions
    from QML. Please update `GameArea.qml`:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的蛇形引擎现在已经完成。最后一步是从 QML 调用一些引擎函数。请更新 `GameArea.qml`：
- en: '[PRE38]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You can already play the game. If you eat an apple, the snake grows and you
    get one point. When you hit yourself or a wall, the game state switches to `GAMEOVER`
    and the game stops. Finally, if you press the `R` key, the game restarts. The
    game looks like the next screenshot on to null Raspberry Pi:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以玩游戏了。如果你吃了一个苹果，蛇会变长，你得到一分。当你撞到自己或墙壁时，游戏状态切换到 `GAMEOVER`，游戏停止。最后，如果你按下 `R`
    键，游戏将重新开始。游戏看起来就像下面的截图所示，在 Raspberry Pi 上：
- en: '![Building a snake engine in JavaScript](img/image00400.jpeg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![在JavaScript中构建蛇形引擎](img/image00400.jpeg)'
- en: Varying the HUD with QML states
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 QML 状态改变 HUD
- en: 'We will now create a "Game Over" HUD, displayed when you lose the game. Create
    a new file `GameOverItem.qml`:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将创建一个 "游戏结束" HUD，在游戏失败时显示。创建一个新的文件 `GameOverItem.qml`：
- en: '[PRE39]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Let''s examine the items of this Game Over screen:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查这个游戏结束屏幕的元素：
- en: A black rectangle filling the entire screen with an `opacity` value of 75%.
    As a consequence, the game area will still be visible at 25% behind the game over
    screen.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个黑色矩形，填充整个屏幕，具有 75% 的不透明度值。因此，游戏区域在“游戏结束”屏幕后面仍然可见，占 25%。
- en: A `gameOverLabel` label displaying the text "Game Over". This is a traditional
    video game message but you can edit this label with text such as "Loser!" or "Too
    bad!".
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个显示文本“游戏结束”的 `gameOverLabel` 标签。这是一个传统的视频游戏消息，但你可以用“失败！”或“太糟糕了！”等文本编辑此标签。
- en: A dynamic `scoreLabel` label that will display the final score.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个动态的 `scoreLabel` 标签，将显示最终得分。
- en: A label explaining to the player how he can restart the game.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个标签，解释玩家如何重新开始游戏。
- en: Please notice that, when the visibility of the root item changes, the `scoreLabel`
    text is updated with the current `score` variable from `main.qml`.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当根项目的可见性改变时，`scoreLabel` 文本会更新为 `main.qml` 中的当前 `score` 变量。
- en: 'Qt Quick provides an interesting feature related to UI states. You can define
    several states for an item and describe the behaviors for each state. We will
    now use this feature and our `GameOverItem` in a new file called `OverlayItem.qml`:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick 提供了一个与 UI 状态相关的有趣功能。你可以为项目定义几个状态并描述每个状态的行为。我们现在将使用这个功能以及我们的 `GameOverItem`
    在一个名为 `OverlayItem.qml` 的新文件中：
- en: '[PRE40]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You can see that the `states` element is an `Item` property. By default, the `states`
    element contains an empty string state. Here we are defining two `State` items
    named `PLAY` and `GAMEOVER`. We are using the same naming convention as in `engine.js`.
    Afterwards we can bind property values to a state. In our case, when the state
    is `GAMEOVER`, we set the visibility to `true` for this `OverlayItem` and its `GameOverItem`.
    Otherwise, for the state `PLAY`, we hide it.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，`states` 元素是一个 `Item` 属性。默认情况下，`states` 元素包含一个空字符串状态。在这里，我们定义了两个名为 `PLAY`
    和 `GAMEOVER` 的 `State` 项目。我们使用与 `engine.js` 中相同的命名约定。之后，我们可以将属性值绑定到状态。在我们的案例中，当状态是
    `GAMEOVER` 时，我们将此 `OverlayItem` 和其 `GameOverItem` 的可见性设置为 `true`。否则，对于状态 `PLAY`，我们将其隐藏。
- en: 'The overlay HUD and its "Game Over" screen are ready to be used. Please update
    your `mail.qml` with the following snippet:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖层 HUD 和其“游戏结束”屏幕已准备好使用。请更新你的 `mail.qml`，如下所示：
- en: '[PRE41]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Our `OverlayItem` element fits the screen and is not visible by default. Like
    a C++ Qt Widgets signal/slot connection, you can perform a QML connection. The
    target property contains the item that will send the signal. Then you can use
    the QML slot syntax:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `OverlayItem` 元素适合屏幕，默认情况下不可见。就像 C++ Qt Widgets 信号/槽连接一样，你可以执行 QML 连接。目标属性包含将发送信号的项。然后你可以使用
    QML 槽语法：
- en: '[PRE42]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In our case, the target is `gameArea`. This item contains the `state` variable,
    so we can be notified when the state variable is updated using `onStateChanged`.
    Then, we switch the state of `OverlayItem`. This assignation will trigger all `ProperyChanged`
    defined in `OverlayItem` element and display or hide our `GameOverItem`.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，目标是 `gameArea`。这个项目包含 `state` 变量，因此我们可以使用 `onStateChanged` 通知状态变量更新。然后，我们切换
    `OverlayItem` 的状态。这个赋值将触发 `OverlayItem` 元素中定义的所有 `ProperyChanged`，并显示或隐藏我们的 `GameOverItem`。
- en: 'You can now lose the game and enjoy your Game Over overlay:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以输掉游戏并享受你的“游戏结束”覆盖层：
- en: '![Varying the HUD with QML states](img/image00401.jpeg)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![使用 QML 状态调整 HUD](img/image00401.jpeg)'
- en: Profiling your QML application
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能分析你的 QML 应用程序
- en: 'Qt Creator provides a QML profiler to collect useful data on your application
    during the runtime. You can use it on a desktop and also on a remote target such
    as our Raspberry Pi. Let''s check that your debug build configuration allows QML
    debugging and profiling. Click on **Projects** | **Rpi 2** | **Build**. Then you
    can click on **Details** of **qmake** from **Build Steps**. You should also check
    it for your desktop kit:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Creator 提供了一个 QML 分析器，可以在应用程序运行时收集有用的数据。你可以在桌面和远程目标（如我们的树莓派）上使用它。让我们检查你的调试构建配置是否允许
    QML 调试和性能分析。点击 **项目** | **Rpi 2** | **构建**。然后你可以点击 **构建步骤** 中的 **qmake** 的 **详细信息**。你也应该检查你的桌面工具包：
- en: '![Profiling your QML application](img/image00402.jpeg)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![性能分析你的 QML 应用程序](img/image00402.jpeg)'
- en: 'By default, data is only sent from target to host when you stop profiling.
    You can flush data periodically: **Tools** | **Options** | **Analyser** | **QML
    Profiler**.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，只有当你停止性能分析时，数据才会从目标发送到主机。你可以定期刷新数据：**工具** | **选项** | **分析器** | **QML 性能分析器**。
- en: Keep in mind that flushing data while profiling frees memory on the target device
    but takes time. Thus, it can affect your profiling result and analysis.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在性能分析时刷新数据可以在目标设备上释放内存，但会花费时间。因此，它可能会影响你的性能分析结果和分析。
- en: 'While we are using Qt Creator kits, we can start the QML profiler in the same
    way for desktops or remote devices. Switch to a kit and click on **Analyze** | **QML
    Profiler** to start the QML profiling. If you are profiling an application running
    on your desktop, Qt Creator starts your software with an argument such as this:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用Qt Creator套件时，我们可以以相同的方式在桌面或远程设备上启动QML分析器。切换到套件并点击**分析** | **QML分析器**以启动QML分析。如果你正在分析在桌面运行的程序，Qt
    Creator将使用如下参数启动你的软件：
- en: '[PRE43]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If you''re profiling an application on a remote device (such as a Raspberry
    Pi), Qt Creator uses a TCP socket to retrieve data, adding an argument such as
    this:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在分析远程设备（如树莓派）上的应用程序，Qt Creator使用TCP套接字检索数据，添加如下参数：
- en: '[PRE44]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'For both targets, the QML profiler will afterwards try to connect to your application.
    Another way to start the QML profiler on a remote device is to start the application
    yourself with the `-qmljsdebugger` argument, for example:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 对于两个目标，QML分析器之后将尝试连接到你的应用程序。在远程设备上启动QML分析器的另一种方法是使用`-qmljsdebugger`参数启动应用程序，例如：
- en: '[PRE45]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Then, you can click on **Analyze** | **QML Profiler (External)**. Select your
    remote kit (such as Rpi 2), set the **port** to `3768`, and click on **OK**.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以点击**分析** | **QML分析器（外部）**。选择你的远程套件（例如Rpi 2），将**端口**设置为`3768`，然后点击**确定**。
- en: 'Great, the QML profiler is started, a new toolbar appears. You can play the
    game for a few seconds and click on the **Stop** button from the QML Profiler
    toolbar. Then the QML profiler processes data and displays something like this:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，QML分析器已启动，出现了一个新的工具栏。你可以玩几秒钟的游戏，然后从QML分析器工具栏中点击**停止**按钮。然后QML分析器处理数据并显示类似以下内容：
- en: '![Profiling your QML application](img/image00403.jpeg)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![分析你的QML应用程序](img/image00403.jpeg)'
- en: 'Let''s begin analyzing the top buttons from left to right:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从左到右开始分析顶部按钮：
- en: Start QML profiler.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动QML分析器。
- en: Stop the application and the QML profiler.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止应用程序和QML分析器。
- en: Enable/disable profiling. You can also select an event to capture.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用/禁用分析。你也可以选择一个事件来捕获。
- en: Discard data to clean your profiling session.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 丢弃数据以清理你的分析会话。
- en: Search timeline event notes.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索时间线事件备注。
- en: Hide or show event categories.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 隐藏或显示事件类别。
- en: '**Elapsed** indicates the session duration.'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**已用时间**表示会话持续时间。'
- en: '**Views** hides or shows the **Timeline**, **Statistics**, and **Flamegraph**
    tabs.'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**视图**隐藏或显示**时间线**、**统计信息**和**火焰图**选项卡。'
- en: To learn to use the QML profiler, we will take a real case. Restarting the game
    is a little slow on the Raspberry Pi. Let's find with the QML profiler what requires
    several seconds to restart the game!
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 为了学习如何使用QML分析器，我们将用一个实际案例。在树莓派上重启游戏有点慢。让我们用QML分析器找出需要几秒钟才能重启游戏的原因！
- en: 'Please follow this operational mode to gather data from the QML profiler:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 请遵循此操作模式以从QML分析器收集数据：
- en: Select the Raspberry Pi kit.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择树莓派套件。
- en: Start the QML profiler.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动QML分析器。
- en: Wait for the snake to hit a wall.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待蛇撞到墙壁。
- en: Press the  ***R*** key to restart the game.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下**R**键重启游戏。
- en: Wait for the game to restart and the snake to move again.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待游戏重启和蛇再次移动。
- en: Stop the QML profiler.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止QML分析器。
- en: 'Let''s begin our investigation using the **timeline** tab. This view displays
    a chronological view of events, grouped by event type. The JavaScript row dissects
    your code and displays useful information. You can click on an item to get some
    details. Identify in the timeline when you restart the game. The JavaScript row
    can be read as a call stack, from top to bottom:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用**时间线**选项卡开始我们的调查。此视图显示事件的按时间顺序视图，按事件类型分组。JavaScript行分解你的代码并显示有用的信息。你可以点击一个项目以获取一些详细信息。在时间线中识别你重启游戏的时间点。JavaScript行可以读作从上到下的调用堆栈：
- en: '![Profiling your QML application](img/image00404.jpeg)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![分析你的QML应用程序](img/image00404.jpeg)'
- en: 'In our case, we restarted the game around 3.5 seconds after the application
    started. Here is the stack with durations provided by the QML profiler. Here is
    the stack with durations provided by the QML profiler. Let''s track all functions
    called when we restart the game pressing the R key:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们这个案例中，我们在应用程序启动后大约3.5秒重启了游戏。以下是QML分析器提供的带有持续时间的堆栈。以下是QML分析器提供的带有持续时间的堆栈。让我们追踪当我们按下R键重启游戏时调用的所有函数：
- en: The `onPressed()` function from `GameArea.qml`
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自`GameArea.qml`的`onPressed()`函数
- en: The `handleKetEvent()` function from `engine.js`
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自`engine.js`的`handleKetEvent()`函数
- en: The `start()` function from `engine.js` at 4.2 seconds
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在4.2秒的`engine.js`中的`start()`函数
- en: '`initEngine()` at 80 ms'
  id: totrans-362
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initEngine()`在80毫秒'
- en: '`createSnake()` at 120 ms'
  id: totrans-363
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`createSnake()`在120毫秒'
- en: '`createWalls()` at 4.025 seconds!'
  id: totrans-364
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`createWalls()` 在 4.025 秒！'
- en: Here we are, `createWalls()` takes ~4 seconds on the Raspberry Pi when we restart
    the game.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 到这里了，`createWalls()` 在我们重启游戏时在 Raspberry Pi 上需要大约 4 秒钟。
- en: 'Let''s switch to the **Statistics** view:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们切换到 **统计** 视图：
- en: '![Profiling your QML application](img/image00405.jpeg)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![分析您的 QML 应用程序](img/image00405.jpeg)'
- en: The **Statistics** view displays numbers concerning the call count of an event.
    An event can be a QML binding, creation, signal triggered, or a JavaScript function.
    The bottom part shows QML callers and callees.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '**统计**视图显示有关事件调用次数的数字。事件可以是 QML 绑定、创建、信号触发或 JavaScript 函数。底部部分显示 QML 调用者和被调用者。'
- en: A caller is the source of a change in a binding. For example, the JS function
    `createWalls()` is a caller.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 调用者是绑定中变化的来源。例如，JS 函数 `createWalls()` 是一个调用者。
- en: A callee is the affected item that a binding triggers. For example, the QML
    item `Wall.qml` is a callee.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 被调用者是绑定影响的受影响项。例如，QML 项 `Wall.qml` 是一个被调用者。
- en: Once again, `createWalls()` requesting many factory item creation seems responsible
    for the slow restart of the game on Raspberry Pi.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，`createWalls()` 请求许多工厂项创建似乎负责 Raspberry Pi 上游戏缓慢重启。
- en: 'Take a look at the last view of the QML profiler, the **Flamegraph**:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 看看 QML 分析器的最后一个视图，**火焰图**：
- en: '![Profiling your QML application](img/image00406.jpeg)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
  zh: '![分析您的 QML 应用程序](img/image00406.jpeg)'
- en: The **Flamegraph** view is a compact summary of your QML and JavaScript code
    while running the game. You can see the call count and the amount of time relative
    to the total duration. Like the **Timeline** view, you can see the call stack
    but from bottom to top!
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '**火焰图** 视图是您在运行游戏时 QML 和 JavaScript 代码的紧凑总结。您可以看到调用次数和相对于总时间的持续时间。像 **时间轴**
    视图一样，您可以看到调用栈，但自下而上！'
- en: Again, the profiler indicates `createWalls()`  is a heavy function. On a profiling
    session of 10 seconds with one game restart, 77% of the time is spent in `engine.createWalls()`.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，分析器表明 `createWalls()` 是一个耗时的函数。在一个持续 10 秒钟的剖析会话中，有 77% 的时间花在 `engine.createWalls()`
    上。
- en: 'You will now be able to profile a QML application. You can try to edit the
    code to speed up the restart. Here are some hints:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您将能够分析一个 QML 应用程序。您可以尝试编辑代码以加快重启速度。以下是一些提示：
- en: Create the walls only once at application startup; do not delete and recreate
    them on each restart.
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用程序启动时仅创建墙壁一次；不要在每次重启时删除和重新创建它们。
- en: 'Implement a common design pattern in video games: an object pool of preloaded
    items. Request a wall when needed, and return the wall to the pool when you do
    not use it.'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在视频游戏中实现一个常见的模式：预加载项的对象池。当需要时请求墙壁，当不再使用时将其返回到池中。
- en: Summary
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discovered how to use the Qt3D module. You also learned
    how to configure Qt Creator to create a new kit for an embedded Linux device.
    Your Raspberry Pi can now run your Qt applications. We created a snake game using
    QML views and an engine in JavaScript. We also covered the Factory design pattern
    to easily create new game items from the engine. Finally, you are now able to
    investigate the bad behavior of QML software using the powerful QML profiler.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们发现了如何使用 Qt3D 模块。您还学习了如何配置 Qt Creator 以创建用于嵌入式 Linux 设备的新套件。您的 Raspberry
    Pi 现在可以运行您的 Qt 应用程序了。我们使用 QML 视图和 JavaScript 引擎创建了一个蛇形游戏。我们还介绍了工厂设计模式，以便从引擎中轻松创建新的游戏项。最后，您现在可以使用强大的
    QML 分析器调查 QML 软件的糟糕行为。
- en: Even if Qt is a powerful framework, sometimes you need to use a third-party
    library. In the next chapter, we will see how to integrate the OpenCV library
    into your Qt application.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 Qt 是一个强大的框架，有时您也需要使用第三方库。在下一章中，我们将看到如何将 OpenCV 库集成到您的 Qt 应用程序中。
