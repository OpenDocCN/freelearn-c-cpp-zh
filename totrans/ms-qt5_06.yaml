- en: Chapter 6.  Even Qt Deserves a Slice of Raspberry Pi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we created a QML UI targeted at Android and iOS. We
    will continue our journey in the embedded world by discovering how we can deploy
    a Qt application on a Raspberry Pi. The example project to illustrate this topic
    will be a snake game using the Qt3D modules. The player will control a snake trying
    to eat apples to get as big as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: The architecture of the Qt3D modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basic principles of cross-compilation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to build your own Qt Creator kit to compile and deploy your game on a Raspberry
    Pi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to handle the differences and limitations of various platforms (desktop,
    Raspberry Pi)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Factory design pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to write a complete game engine using JavaScript and QML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The usage of the QML Profiler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discovering Qt3D
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The example project of this chapter will rely on 3D rendering. For this, we
    will use Qt3D. This part of the framework is divided into various Qt modules that
    enable the application to have a near-real time simulation of a 3D environment.
    Built on OpenGL, Qt3D offers a high-level API to describe complex scenes without
    having to resort to writing low-level OpenGL instructions. Qt3D supports the following
    basic features:'
  prefs: []
  type: TYPE_NORMAL
- en: 2D and 3D rendering for C++ and Qt Quick
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Meshes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Materials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GLSL shaders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shadow mapping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deferred rendering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instance rendering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uniform Buffer Object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All these features are implemented in the **ECS** (**entity component system**)
    architecture. Each mesh, material, or shader that you define is a component. The
    aggregation of these components makes an entity. If you wanted to draw a 3D red
    apple, you would need the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: A mesh component, holding the vertices of your apple
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A material component, applying a texture on the mesh or coloring it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These two components will then be regrouped to define the entity Apple. You
    see here the two parts of the ECS: entities and components. The overall architecture
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Discovering Qt3D](img/image00389.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Each of these components can be regrouped in aspects. An aspect is a "slice"
    of multiple components working on the same part (rendering, audio, logic, and
    physics). When the graph of all your entities is processed by the Qt3D engine,
    each layer of aspects is processed sequentially.
  prefs: []
  type: TYPE_NORMAL
- en: 'The underlying approach is to favor composition over inheritance. In a game,
    an entity (an apple, a player, an enemy) can have various states during its life
    cycle: spawning, animating for a given state, dying animation, and so on. Using
    inheritance to describe these states will lead to a nerve-wracking tree: `AppleSpawn`, `AppleAnimationShiny`, `AppleDeath`,
    and so on. It would become quickly unmaintainable. Any modification to a class
    could have huge impact on many other classes and the number of possible combinations
    of states would get out of hand. Saying that a state is simply a component for
    a given entity, gives the flexibility to easily swap components and still keep
    the entity abstraction; an apple `Entity` element is still an apple, even though
    it is using the `AnimationShiny``Component` instead of the `AnimationSpawn``Component`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how to define a basic `Entity` element in QML. Imagine that this
    is the apple we have been talking about. The `Apple.qml` file would look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In a very few lines, you describe every aspect of the `Entity` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Entity`: This is the root object of the file; it follows the same QML pattern
    we studied in [Chapter 5](part0048.xhtml#aid-1DOR02 "Chapter 5.  Dominating the
    Mobile UI"), *Dominating the Mobile UI*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PhongMaterial`: This defines how the surface will be rendered. Here, it uses
    the Phong shading technique to achieve smooth surfaces. It inherits `QMaterial`,
    which is the base class for all the material classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CuboidMesh`: This defines what type of mesh will be used. It inherits `QGeometryRenderer`,
    which also gives the ability to load custom models (exported from 3D modeling
    software).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Transform`: This defines the transformation matrix of the component. It can
    customize the translation, scale, and position of the `Entity` element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Position`: This is a property to expose `transform.translation` for a given
    caller/parent. This might quickly become handy if we want to move the apple around.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Components`: This is the array containing all the IDs of all the components
    for the `Entity` element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we want to make this `Apple` a child of another `Entity`, it is simply a
    matter of defining the Apple inside this new `Entity` element. Let''s call it `World.qml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `World Entity` has no visual representation; we want it to be the
    root of our 3D scene. It only contains the `Apple` we defined earlier. The *x*, *y*, *z*
    coordinates of the apple are relative to the parent. When the parent makes a translation,
    the same translation will be applied to the apple.
  prefs: []
  type: TYPE_NORMAL
- en: This is how the hierarchy of entities/components is defined. If you write your
    Qt3D code in C++, the same logic applies to the equivalent C++ classes (`QEntity`, `QComponent`,
    and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Because we decided to use the `World.qml` file as the root of our scene, it
    has to define how the scene will be rendered. The Qt3D rendering algorithm is
    data-driven. In other words, there is a clear separation between *what* should
    be rendered (the tree of entities and components) and *how* it should be rendered.
  prefs: []
  type: TYPE_NORMAL
- en: The *how* relies on a similar tree structure using `framegraph`. In Qt Quick,
    a single method of rendering is used and it covers the 2D drawing. On the other
    hand, in 3D, the need for flexible rendering makes it necessary to decouple the
    rendering techniques.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example: you play a game where you control your avatar and you
    encounter a mirror. The same 3D scene must be rendered from multiple viewports.
    If the rendering technique is fixed, this poses multiple problems: which viewport
    should be drawn first? Is it possible to parallelize the rendering of the viewports
    in the GPU? What if we need to make multiple passes for the rendering?'
  prefs: []
  type: TYPE_NORMAL
- en: In this code snippet, we use the traditional OpenGL rendering technique with
    the `ForwardRenderer` tree, where each object is rendered directly on the back
    buffer, one at a time. Qt3D offers the possibility to choose the renderer (`ForwardRenderer`, `DeferredRenderer`,
    and so on) and configure how the scene should be rendered.
  prefs: []
  type: TYPE_NORMAL
- en: OpenGL typically uses the double-buffering technique to render its content.
    The front-buffer is what is displayed on the screen and the back-buffer is where
    the scene is being rendered. When the back-buffer is ready, the two buffers are
    swapped.
  prefs: []
  type: TYPE_NORMAL
- en: 'One last thing to notice at the top of each `Entity` element is that we specified
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'There are only Qt3D modules in the import section. Qt3D classes do not inherit
    `Item` so cannot be directly mixed with QML components. This inheritance tree
    of the basic Qt3D building blocks is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Discovering Qt3D](img/image00390.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The `QNode` class is the base class of all Qt3D node classes. It relies on the `QObject`
    class to define the parenting relationship. Each `QNode` class instance also adds
    a unique `id` variable, which allows it to be recognized from other instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though `QNode` cannot be mixed with Qt Quick types, they can be added
    to a `Q3DScene` element (or `Scene3D` in QML), which serves as the canvas for
    Qt3D content and can be added to a Qt Quick `Item`. Adding `World.qml` to a scene
    is as simple as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `Scene3D` element includes a `World` instance and defines common Qt Quick
    properties (`anchors`, `focus`).
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Qt for your Raspberry Pi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This project targets a new embedded platform: the Raspberry Pi. Qt officially
    supports the Raspberry Pi 2, but we got the project running without any trouble
    on a Raspberry Pi 3\. If you do not have one of these devices, it might be nonetheless
    interesting to read this section to know how the cross-compilation works and how
    to configure your own kit in Qt Creator. The rest of the chapter will work on
    a Desktop platform anyway.'
  prefs: []
  type: TYPE_NORMAL
- en: Before diving into the Raspberry Pi configuration, let's take a step back to
    understand our aim. Your computer is probably running on an x86 CPU architecture.
    This means that every program you run will be executed with the x86 instructions
    set of your CPU. In Qt Creator, this translates to your available kits. A kit
    must match your target platform. On startup, Qt Creator searches for available
    kits in your computer and loads them for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 5](part0048.xhtml#aid-1DOR02 "Chapter 5.  Dominating the Mobile
    UI"), *Dominating the Mobile UI*, we targeted different platforms: Android and
    iOS. These platforms are running on a different CPU instruction set: ARM. Luckily,
    the people behind Qt automatically configured for us the necessary nuts and bolts
    to make it work.'
  prefs: []
  type: TYPE_NORMAL
- en: The Raspberry Pi also runs on ARM but it is not ready for Qt by default. We
    have to prepare it before playing with it in Qt Creator. Note that the following
    commands are run from a Linux box, but you should be able to run them from Mac
    or Windows with Cygwin.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please follow the complete guide to prepare your Raspberry Pi for Qt at [https://wiki.qt.io/RaspberryPi2EGLFS](https://wiki.qt.io/RaspberryPi2EGLFS),
    or simply download a precompiled bundle from [http://www.qtrpi.com](http://www.qtrpi.com).
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete Raspberry Pi installation guide is outside the scope of the book.
    It is interesting nonetheless to sum up the main steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add development packages to the Raspberry Pi.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Retrieve the complete toolchain, including the cross-compiler that will be executed
    from your machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `sysroot` folder on your machine that will mirror the necessary directories
    from the Raspberry Pi.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile Qt with the cross-compiler in the `sysroot` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Synchronize this `sysroot` with the Raspberry Pi.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `sysroot` is simply a directory containing a minimal filesystem for a given
    platform. It typically contains the `/usr/lib` and `/usr/include` directories.
    Having this directory on your machine enables the cross-compiler to properly compile
    and link the output binary without being executed from the Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: All these steps are done to avoid compiling anything directly on the Raspberry
    Pi. Being a low-powered device, the execution of any compilation would take a
    very, very long time. Compiling Qt on a Raspberry Pi would easily take more than
    40 hours. Knowing this, the time spent on configuring the cross-compiler seems
    much easier to bear.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `qopenglwidget` example mentioned in the wiki should be properly running
    before proceeding. Once this has been done, we have to cross-compile a few more
    Qt modules to have our project running:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Qtdeclarative`: This model is used to access Qt Quick'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`qt3d`: This model is used to construct a 3D world'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`qtquickcontrols`: This model is used to include interesting controls (Label)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`qtquickcontrols2`: This model is used to make some new layouts available'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For each of these modules, execute the following commands (from your `~/raspi`
    directory):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can speed up the compilation by adding the parameter `-j` (or `--jobs`)
    to `make`. The `make` command will try to parallelize the compilations jobs over
    your CPU cores, if you have four cores, use `make -j 4`, eight cores, `make -j
    8`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'When everything has been compiled, synchronize your `sysroot` directory again
    with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the previous command, you must replace the `IP` with the real Raspberry Pi
    address.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Raspberry Pi is ready to execute our Qt code. However, we have to create
    our own kit in Qt Creator to be able to compile and deploy our program on it.
    A kit is composed of the following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: A **compiler** that will compile your code using the CPU instruction set of
    the target platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **debugger** that will know the instruction set of the target platform to
    properly break and read the memory content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **Qt version** compiled for the targeted platform to compile and link your
    binary to the target platform's shared objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **device** to which Qt Creator can connect to deploy and execute your program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will start with the compiler. In Qt Creator:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to **Tools** | **Options** | **Build & Run** | **Compilers**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Add** |**GCC**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Browse to `~/raspi/tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian/bin/arm-linux-gnueabihf-g++`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the compiler to `Rpi GCC`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This strange binary name makes it easier for Qt to parse the **ABI** (**application
    binary interface**) to find out the platform architecture, file format, and so
    on. It should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring Qt for your Raspberry Pi](img/image00391.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now for the debugger. As we said earlier, we are building this project from
    a Linux box (Ubuntu). Cross-compilation and embedded development tend to be easier
    on Linux but you should be able to do the same on a Windows or Mac with a few
    additional steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Ubuntu Linux, just install a multi-architecture `gdb` with the command `sudo
    apt-get install gdb-multiarch`. In Qt Creator, add this new debugger in the **Debuggers**
    tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring Qt for your Raspberry Pi](img/image00392.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, add the cross-compiled Qt explained on the wiki page in the **Qt Versions**
    tab. Click on **Add** and browse to `~/raspi/qt5/bin/qmake`. This is the resulting
    Qt Version:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring Qt for your Raspberry Pi](img/image00393.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We are almost there! Before building the kit, we simply have to configure Raspberry
    Pi device access. In **Options** | **Devices**, follow this procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on **Add..** | **Generic Linux Device** | **Start Wizard**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The name will be `Rpi 2` (or 3 if you have one).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the IP address of your device (indeed, you have to be connected to your
    local network!).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The default username is **pi**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The default password is "raspberry".
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Next** to test the connection to the device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If everything went well, this is your new device:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring Qt for your Raspberry Pi](img/image00394.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, the kit will compose all these parts into a valid Qt Creator platform.
    Go back to **Build & Run** | **Kits**. From here you simply have to point to each
    of the parts we built previously. Here is the resulting kit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring Qt for your Raspberry Pi](img/image00395.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note that the **Sysroot** filed should point to the `sysroot` folder we previously
    created at `~/raspi/sysroot`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you click on the button to the right of **Name**, you can choose a custom
    picture for a kit, such as the Raspberry Pi logo.
  prefs: []
  type: TYPE_NORMAL
- en: Everything is now ready to make an awesome snake game.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an entry point for your Qt3D code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For those who did not play the snake game in their youth, here is a quick reminder
    of the gameplay:'
  prefs: []
  type: TYPE_NORMAL
- en: You control a snake moving in an empty area
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This area is surrounded by walls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An apple spawns randomly in the game area
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the snake eats the apple, it grows and you gain a point. Right after, another
    apple spawns in the game area
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the snake touches a wall or a part of its own body, you lose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The goal is to eat as many apples as possible to have the highest score. The
    longer the snake, the harder it will become to avoid the wall and its own tail.
    Oh, and the snake goes faster and faster each time it eats an apple. The architecture
    of the game will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: All the game items will be defined using Qt3D in QML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the game logic will be done in JavaScript, which will communicate with the
    QML elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will keep the 2D feel of the original snake game by placing the camera above
    the game area but we will spice things up with 3D models and some shaders.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alright, we spent an awful lot of pages preparing for this moment. It is now
    time to begin the snake project. Create a new **Qt Quick Controls Application**
    named `ch06-snake`. In the project details:'
  prefs: []
  type: TYPE_NORMAL
- en: Select **Qt 5.6** for the **minimal required Qt version** field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uncheck **With ui.qml file**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uncheck **Enable native styling**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on **Next** and select the following kits:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: RaspberryPi 2
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Desktop**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Click on **Next** | **Finish**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We have to add the Qt3D modules. Modify `ch06-snake.pro` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to prepare the entry point of the application to have a proper OpenGL
    context with which Qt3D can work. Open and update `main.cpp` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The idea is to configure a `QSurfaceFormat` to properly handle OpenGL and to
    give it to a custom `QQuickView view`. This `view` will use this format to paint
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: The `qputenv("QT3D_GLSL100_WORKAROUND", "")` instruction is a workaround related
    to Qt3D shaders on some embedded Linux devices, such as the Raspberry Pi. It will
    enable a separate GLSL 1.00 snippet for the lights required by some embedded devices.
    If you do not use this workaround, you will get a black screen and will not be
    able to properly run the project on Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The details of the Qt3d lights workaround are here:[https://codereview.qt-project.org/#/c/143136/](https://codereview.qt-project.org/#/c/143136/).
  prefs: []
  type: TYPE_NORMAL
- en: We chose to handle the view using Qt Quick. Another approach would be to create
    a C++ class that inherits `QMainWindow` and make it the parent of the QML content.
    This approach can be found in many Qt3D example projects. Both are valid and work.
    You tend to write more code with the `QMainWindow` approach, but it allows you
    to create 3D scenes with C++ only.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that `view` from the `main.cpp` file tries to load a `main.qml` file.
    You can see it coming; here is the `main.qml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here we define the **HUD** (**heads up display**) at the top of the screen,
    where the score (the number of apples eaten) will be displayed. Note that we bound
    the Escape key to the `Qt.quit()` signal. This signal is connected in `main.cpp`
    to the `QGuiApplication::quit()` signal to quit the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The QML context is now ready to welcome Qt3D content. Modify `main.qml` like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `Scene3D` element takes all the available space below the `hud` object.
    It takes the focus of the window to be able to intercept keyboard events. It also
    enables the input aspect to let the Qt3D engine process keyboard events in its
    graph traversal.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can now start writing Qt3D code. The first step is to define the root of
    the scene. Create a new file named `GameArea.qml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing we do is create a camera and position it. Remember that, in
    OpenGL, the coordinates follow the thumb on your right hand points left!:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the scene](img/image00396.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'By placing the camera at `Qt.vector3d(x, y, 33)`, we make it come "out of the
    screen" to be able to express our yet-to-be-created entitiy''s coordinates with
    the simple `x`, `y` axis. The `upVector: Qt.vector3d(0.0, 1.0, 0.0)` specifies
    the up vector of the camera,  in our case it is the `Y` axis. Finally, we point
    at `Qt.vector(x, y, 0)`, meaning the center of the screen.'
  prefs: []
  type: TYPE_NORMAL
- en: The overall goal is to simplify coordinate expression. By positioning the camera
    this way, placing an object at the coordinate 0, 0 will put it in the bottom-left
    part of the window, whereas the coordinates 50, 28 mean the top-right part of
    the window.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also configure `RenderSettings` with a `ForwardRendered` that defines two
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`clearColor`: This property `Qt.rgba(0, 0, 0, 1)` means that the background
    will be pitch-black'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`camera`: This property is used to determine the viewport to be rendered'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The scene is ready to be rendered, but we need to handle user input, namely
    the keyboard. To capture keyboard events, modify `GameArea.qml` to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `KeyboardDevice` element is in charge of dispatching key events to the active `KeyboardHandler`,
    namely `input`. The `KeyboardHandler` component is attached to the controller
    and the `onPressed()` function will be called each time a key is pressed. The `KeyboardHandler`
    is a component; therefore it needs to be added to the list of components for `GameArea`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last missing part of `GameArea` is preapring the engine execution (initialization
    and update):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here we mix Qt Quick elements with Qt3D. Due to possible name collisions, we
    have to import the module using the alias `QQ2`. We already met `Component.onCompleted`
    in [Chapter 5](part0048.xhtml#aid-1DOR02 "Chapter 5.  Dominating the Mobile UI"), *Dominating
    the Mobile UI*. Its job will be to start the game engine and start the `timer`
    defined right after.
  prefs: []
  type: TYPE_NORMAL
- en: This `timer` variable will repeat every 80 milliseconds (as defined in the `initialTimeInterval`
    property) and call the engine's `update()` function. This function will be covered
    when we build the engine code, later in this chapter. The goal is to emulate the
    original snake game as closely as possible. The whole game logic will be updated
    at this interval and not at the normal frame refresh interval. After each call
    to `update()`, the snake will advance. As a result, the snake's movement will
    not be smooth but rather jerky. This is clearly a design choice we made to have
    a retro-gaming feeling.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each time the snake eats an apple, two things happen:'
  prefs: []
  type: TYPE_NORMAL
- en: The `interval` of the timer will be reduced by the engine (accessed by the `timerInterval`
    property).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The snake will grow. Its initial size is defined in the `intialSnakeSize` property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducing the timer interval will make the snake advance faster until it becomes
    very hard to manage its direction.
  prefs: []
  type: TYPE_NORMAL
- en: Assembling your Qt3D entities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now proceed to create the building blocks of the game, each in the
    form of an `Entity` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Wall`: This represents the limit of where the snake cannot go'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SnakePart`: This represents a part of the snake''s body'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Apple`: This represents the apple (no way!) spawned at a random location'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Background`: This represents a good-looking background behind the snake and
    the apple'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each entity will be placed on a grid handled by the engine and will have a
    type identifier to make it easier to find. To factorize these properties, let''s
    create a parent QML file named `GameEntity.qml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This `Entity` element only defines a `type` property and a `gridPosition` property
    , which will be used by the engine to lay out the content on the grid.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first item we will build is the `Wall.qml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `Wall` type does not have any visual representation. Because
    we target a Raspberry Pi device, we have to be very careful with the CPU/GPU consumption.
    The game area will be a grid where each cell contains an instance of one of our
    entities. The snake will be surrounded by `Wall` instances. The Raspberry Pi is
    much slower than your average computer, to the extent that the game would become
    unbearably slow if we displayed all the walls.
  prefs: []
  type: TYPE_NORMAL
- en: To address this issue, the walls are invisible. They will be placed outside
    the visible viewport and the borders of the window will act as the visual limit
    of the snake. Of course, if you do not target the Raspberry Pi, but rather your
    computer, it is fine to display the walls and make them look fancier than just
    nothing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next `Entity` element we will implement is `SnakePart.qml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If added to the `GameArea` scene, the `SnakePart` block will display a single
    green cube. The `SnakePart` block is not the complete snake, rather a part of
    its body. Remember that the snake grows each time it eats an apple. Growing means
    adding a new instance of `SnakePart` to a list of `SnakePart`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s proceed with the `Apple.qml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This snippet starts with introducing more complex yet easy-to-use features of
    Qt3D, namely a custom mesh and a texture applied to it. Qt3D supports the Wavefront
    `obj` format to load custom meshes. Here we added a home-cooked apple to the `.qrc`
    file of the application and we just have to provide the path to this resource
    to load it.
  prefs: []
  type: TYPE_NORMAL
- en: The same principle is applied for the `DiffuseMapMaterial` element. We added
    a custom texture and added it as a source of the component.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the `Entity` definition and its components look very much the
    same. Yet we effortlessly traded a Qt3D `CuboidMesh` with a custom model.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will push things even further with `Background.qml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Background` block will be displayed behind the snake and the apple. At
    first sight, this entity looks very much like `SnakePart`. However, `Material`
    is not a Qt3D class. It is a custom defined `Material` that relies on shaders.
    Let''s see `MaterialBackground.qml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are not familiar with shaders, we can summarize them in the following
    statement: shaders are computer programs written in a C-style syntax that are
    executed by the GPU. Data from your logic will be fed by the CPU and made available
    to the GPU memory where your shaders will run. Here we manipulate two types of
    shader:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vertex shader**, which is executed on each vertex of the source of your mesh'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fragment**, which is executed on each pixel to produce the final rendering'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By being executed on the GPU, these shaders utilize the huge parallelization
    power of the GPU (which is orders-of-magnitude higher than your CPU). It enables
    modern games to have such stunning visual rendering. Covering shaders and the
    OpenGL pipeline is beyond the scope of this book (you can fill several bookshelves
    on this subject alone). We will limit ourselves to showing you how you can use
    shaders in Qt3D.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to delve into OpenGL or sharpen your skills with shaders, we recommend
    the *OpenGL SuperBible*, by Graham Sellers, Richard S Wright Jr., and Nicholas
    Haemel.
  prefs: []
  type: TYPE_NORMAL
- en: Qt3D supports shaders in a very convenient way. Simply add your shader file
    to the `.qrc` resource file and load it in the `effect` property of a given `Material`.
  prefs: []
  type: TYPE_NORMAL
- en: In this snippet, we specify that this shader `Technique` should be run only
    on OpenGL 3.2\. This is indicated in the `graphicsApiFilter` block. This version
    of OpenGL targets your desktop machine. Because the performance gap between your
    desktop and your Raspberry Pi is very marked, we have the ability to execute different
    shaders depending on the platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, here is the Raspberry Pi-compatible technique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You just have to add it to the `techniques` property of the `Material`. Note
    that the targeted OpenGL version is OpenGLES 2.0, which will run fine on your
    Raspberry Pi and even your iOS/Android phone.
  prefs: []
  type: TYPE_NORMAL
- en: 'A last thing to cover is how parameters can be passed to shaders. Here is an
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `score` variable will be accessible in the shader with this simple section.
    Please take a look at the source code for the chapter to see the complete content
    of this `Material` element. We had the fun of writing a shader displaying a moving
    and glowing wave over a grass texture.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only fixed element of the game is the background. We can directly add it
    to `GameArea.qml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `Background` element is positioned to cover the whole visible area behind
    the snake and the apple. Being defined inside `GameArea`, it will be automatically
    added to the entity/component tree and will be drawn right away.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the board game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Even if our game has a 3D representation, we will implement 2D gameplay like
    the original snake game. Our game items are born, will live, and die in a 2D area.
    Like chess, this board will be composed of rows and columns. But in our snake
    game, each square can be:'
  prefs: []
  type: TYPE_NORMAL
- en: An apple
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A snake
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A wall
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Empty
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of a board representation from the point of view of the
    engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Preparing the board game](img/image00397.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This is a small 10x8 board; even if the size does not matter, you will be able
    to define a bigger one. Your game, your rules! We have walls (**W**) surrounding
    the game area. An apple (**A**) is spawned at 7x2\. Finally, we have a snake (**S**)
    beginning at 3x4 and ending at 5x5.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is time to create our board class. Please create a JS file called `board.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This object constructor function required three parameters. The `columnCount`
    and `rowCount` parameters will help you to choose the board dimension. The last
    parameter, `blockSize`, is the size of a board square in the OpenGL world. For
    example, we can set `blockSize` to 10\. In this case, the apple in 7x2 on the
    board we be displayed with `x = 70` and `y = 20` in the OpenGL world. In this
    chapter, we will use a `blockSize` of 1, so the board coordinates match OpenGL
    coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add some utility functions to `board.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Defining a class in JavaScript can be disturbing for a C++ developer. Every
    JavaScript object has a prototype object to which you can add functions. We are
    using it to add class methods to `Board`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a summary of the purpose of each function of the `Board` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`init()`: This function initializes all array values to the `null` value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index()`: This function returns the array index from column/row coordinates'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setData()`: This function assigns the `data` value on the board from column/row
    coordinates'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`at()`: This function retrieves the `data` value in an array from column/row
    coordinates'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please note that, in our case, a `null` square means an empty square.
  prefs: []
  type: TYPE_NORMAL
- en: Crafting entities from the factory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have a board to receive items, we will create the game items factory.
    The factory is a design pattern that allows us to create an object without exposing
    the creation logic to the caller. This factory can be seen as a helper class that
    will handle all the dirty tasks required when you want to create a new game item
    from JavaScript. Do you remember `GameEntity.qml`? It is the parent class of `Apple.qml`, `Snake.qml`,
    and `Wall.qml`. The factory will be able to create a specific entity for a given
    a type and coordinates. We will use the property type to identify an entity kind.
    Here is the factory pattern schema used in our snake game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Crafting entities from the factory](img/image00398.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can now create the `factory.js` file, which begins like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: First of all, we define all the game entity types. In our case we have apple,
    snake, and wall types. Then, we create game item components from QML files. These
    components will be use by the factory to dynamically create new game entities.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now add the constructor and a `removeAllEntities()` utility function
    to remove all instantiated entities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This factory has three member variables:'
  prefs: []
  type: TYPE_NORMAL
- en: A reference to the game `board` described in the previous section
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A reference to the `parentEntity` variable, that is, the game area
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `entities` array that keeps a reference to created items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `removeAllEntities()` function will remove the items from their parent (that
    is, the game area) and create a new empty entities array. This ensures that old
    entities are deleted by the garbage collector.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the core function `createGameEnity()` in the factory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the caller provides an entity `type` and board coordinates (`column`
    and `row`). The first part is a switch to select the correct QML component. Once
    we have the component, we can call `component.createObject()` to create an instance
    of this component. The parent of this new component will be `this.parentEntity`,
    in our case, `GameArea`. Then, we can update the board, update the entity position,
    and add this new entity in the `entities` array.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing to do is to update our QML game entities with the proper factory
    type. Please open `Apple.qml` and update the file like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: You can now update `Snake.qml` with the `Factory.SNAKE_TYPE` type and `Wall.qml`
    with the `Factory.WALL_TYPE` type.
  prefs: []
  type: TYPE_NORMAL
- en: Building a snake engine in JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is time to get your hands dirty. Let's see how to create an engine in JavaScript
    to manage a snake game using our board, our factory, and the power of QML.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please create a new `engine.js` file with the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The first lines are the Qt way to import a JavaScript file from another JavaScript
    file. Then, we can easily instantiate a `factory` variable and a 50x29 `board`
    variable. The `snake` array contains all the snake game items instantiated. This
    array will be useful to move our snake. Finally, the `direction` variable is a
    2d vector handling the current snake direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the first function of our engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives you a summary of what is done when we start the engine:'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize the engine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the initial snake.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create walls surrounding the game area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Spawn the first apple.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch the `GameArea` state to `PLAY`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s begin with the `initEngine()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This function initializes and resets all the variables. The first task is to
    set the `GameArea` timer interval to its initial value. Each time the snake eats
    an apple, this interval is reduced, increasing the game speed and thus the snake's
    movement speed. Logically, we reset the score of the player to `0`. Then we initialize
    the factory, giving the board and `gameRoot` references. The `gameRoot` refers
    to the `GameArea`; this entity will be the parent of all items instantiated by
    the factory. Then, we remove all the existing entities from the factory and call
    the board's `init()` function to clear the board. Finally, we set a default direction
    for the snake. The vector `-1,0` means that the snake will begin moving to the
    left. If you want the snake to start moving up, you can set the vector to `0,
    1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next function is creating the snake:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: No big deal here, we reset and initialize the `snake` array. The first snake
    item will be created at 25x12\. We then proceed to create as many snake items
    as we need to spawn a snake with the correct initial size. Please note that other
    snake items will be created to the right of the first item (26x12, 27x12, and
    so on). You can see how easy it is to call our factory and request a new snake
    item instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the `createWalls()` function to `engine.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The first loop creates the top and bottom walls. The second loop creates the
    left and right walls. The indexes of the second loop are different from the first
    one to avoid creating the corners twice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see now how to implement the `spawnApple()` function in `engine.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The first step is to find an empty square. The while loop will generate a random
    board position and check whether a square is empty. As soon as an empty square
    is found, we request the factory to create an apple entity at this position. Finally,
    we reduce the `timerInverval` value of `GameArea` to speed up the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now add some utility functions related to the snake position in `engine.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `setPosition()` function handles all the necessary tasks when we want to
    move a game item. We first assign the game item to the correct board square, then
    we update the `gridPosition` property (from `GameEntity`) but also the OpenGL `position.x`
    and `position.y`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second function, `moveSnake()`, moves the snake to an adjacent square.
    Let''s dissect all the steps performed by this function:'
  prefs: []
  type: TYPE_NORMAL
- en: The `snake` is our global array containing all the snake items. The `pop()`
    method removes and returns the last element that we store in the `last` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `last` variable contains the snake's tail's grid position. We set this board
    square to `null`; that means an empty square for us.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `last` variable is now put on the adjacent square requested by the caller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `last` variable is finally inserted at the beginning of the `snake` array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next schema illustrates the `moveSnake()` process when a snake is moving
    on the left. We also name snake items with a letter to visualize how the tail
    becomes the head, simulating a moving snake:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a snake engine in JavaScript](img/image00399.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we can move our snake, we must handle key events to move the snake
    in the correct direction. Please add this new function to `engine.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In this game, we use the `I-J-K-L` keys to update the snake direction vector.
    Like the original snake game, you can't reverse your direction. A check is performed
    to avoid this behavior. Please notice that pressing the `R` key will call `start()`
    and so restart the game. We will see soon how to bind this function with the QML
    keyboard controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we are, the last (but not least) function, the `update()` function of `engine.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This function will be called at regular intervals by QML. As you can see, if
    the `gameRoot` (that is `GameArea`) `state` variable equals `GAMEOVER`, this function
    does nothing and returns immediately. Then, three important steps are performed:'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieve the grid position of the snake's head in `headPosition`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Process where the snake goes using the `direction` vector in `newPosition`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Put the item where the snake is going in `itemOnNewPosition`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The second part of the `update()` function is the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: If the snake is going to an empty square (`itemOnNewPosition` is `null`), it
    is alright and we only move the snake to `newPosition`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the square is not empty, we must apply the correct rule depending on the
    item type. If the next square is a snake part or a wall, we update the state to
    `GAMEOVER`. On the other hand, if the next square is an apple, several steps are
    performed:'
  prefs: []
  type: TYPE_NORMAL
- en: Detach the apple item from `GameArea`, setting its parent to `null`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the apple from the board, setting the board square to `null`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Grow the snake, creating a snake part at the beginning of the `snake` array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Spawn a new apple in a random empty square.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Increment the score.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our snake engine is now complete. The last step is to call some engine functions
    from QML. Please update `GameArea.qml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'You can already play the game. If you eat an apple, the snake grows and you
    get one point. When you hit yourself or a wall, the game state switches to `GAMEOVER`
    and the game stops. Finally, if you press the `R` key, the game restarts. The
    game looks like the next screenshot on to null Raspberry Pi:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a snake engine in JavaScript](img/image00400.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Varying the HUD with QML states
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now create a "Game Over" HUD, displayed when you lose the game. Create
    a new file `GameOverItem.qml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s examine the items of this Game Over screen:'
  prefs: []
  type: TYPE_NORMAL
- en: A black rectangle filling the entire screen with an `opacity` value of 75%.
    As a consequence, the game area will still be visible at 25% behind the game over
    screen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `gameOverLabel` label displaying the text "Game Over". This is a traditional
    video game message but you can edit this label with text such as "Loser!" or "Too
    bad!".
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A dynamic `scoreLabel` label that will display the final score.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A label explaining to the player how he can restart the game.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please notice that, when the visibility of the root item changes, the `scoreLabel`
    text is updated with the current `score` variable from `main.qml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Qt Quick provides an interesting feature related to UI states. You can define
    several states for an item and describe the behaviors for each state. We will
    now use this feature and our `GameOverItem` in a new file called `OverlayItem.qml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the `states` element is an `Item` property. By default, the `states`
    element contains an empty string state. Here we are defining two `State` items
    named `PLAY` and `GAMEOVER`. We are using the same naming convention as in `engine.js`.
    Afterwards we can bind property values to a state. In our case, when the state
    is `GAMEOVER`, we set the visibility to `true` for this `OverlayItem` and its `GameOverItem`.
    Otherwise, for the state `PLAY`, we hide it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The overlay HUD and its "Game Over" screen are ready to be used. Please update
    your `mail.qml` with the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `OverlayItem` element fits the screen and is not visible by default. Like
    a C++ Qt Widgets signal/slot connection, you can perform a QML connection. The
    target property contains the item that will send the signal. Then you can use
    the QML slot syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In our case, the target is `gameArea`. This item contains the `state` variable,
    so we can be notified when the state variable is updated using `onStateChanged`.
    Then, we switch the state of `OverlayItem`. This assignation will trigger all `ProperyChanged`
    defined in `OverlayItem` element and display or hide our `GameOverItem`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now lose the game and enjoy your Game Over overlay:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Varying the HUD with QML states](img/image00401.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Profiling your QML application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Qt Creator provides a QML profiler to collect useful data on your application
    during the runtime. You can use it on a desktop and also on a remote target such
    as our Raspberry Pi. Let''s check that your debug build configuration allows QML
    debugging and profiling. Click on **Projects** | **Rpi 2** | **Build**. Then you
    can click on **Details** of **qmake** from **Build Steps**. You should also check
    it for your desktop kit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Profiling your QML application](img/image00402.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'By default, data is only sent from target to host when you stop profiling.
    You can flush data periodically: **Tools** | **Options** | **Analyser** | **QML
    Profiler**.'
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that flushing data while profiling frees memory on the target device
    but takes time. Thus, it can affect your profiling result and analysis.
  prefs: []
  type: TYPE_NORMAL
- en: 'While we are using Qt Creator kits, we can start the QML profiler in the same
    way for desktops or remote devices. Switch to a kit and click on **Analyze** | **QML
    Profiler** to start the QML profiling. If you are profiling an application running
    on your desktop, Qt Creator starts your software with an argument such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'If you''re profiling an application on a remote device (such as a Raspberry
    Pi), Qt Creator uses a TCP socket to retrieve data, adding an argument such as
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'For both targets, the QML profiler will afterwards try to connect to your application.
    Another way to start the QML profiler on a remote device is to start the application
    yourself with the `-qmljsdebugger` argument, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Then, you can click on **Analyze** | **QML Profiler (External)**. Select your
    remote kit (such as Rpi 2), set the **port** to `3768`, and click on **OK**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Great, the QML profiler is started, a new toolbar appears. You can play the
    game for a few seconds and click on the **Stop** button from the QML Profiler
    toolbar. Then the QML profiler processes data and displays something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Profiling your QML application](img/image00403.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s begin analyzing the top buttons from left to right:'
  prefs: []
  type: TYPE_NORMAL
- en: Start QML profiler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stop the application and the QML profiler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable/disable profiling. You can also select an event to capture.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Discard data to clean your profiling session.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search timeline event notes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hide or show event categories.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Elapsed** indicates the session duration.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Views** hides or shows the **Timeline**, **Statistics**, and **Flamegraph**
    tabs.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To learn to use the QML profiler, we will take a real case. Restarting the game
    is a little slow on the Raspberry Pi. Let's find with the QML profiler what requires
    several seconds to restart the game!
  prefs: []
  type: TYPE_NORMAL
- en: 'Please follow this operational mode to gather data from the QML profiler:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the Raspberry Pi kit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the QML profiler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait for the snake to hit a wall.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press the  ***R*** key to restart the game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait for the game to restart and the snake to move again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stop the QML profiler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s begin our investigation using the **timeline** tab. This view displays
    a chronological view of events, grouped by event type. The JavaScript row dissects
    your code and displays useful information. You can click on an item to get some
    details. Identify in the timeline when you restart the game. The JavaScript row
    can be read as a call stack, from top to bottom:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Profiling your QML application](img/image00404.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In our case, we restarted the game around 3.5 seconds after the application
    started. Here is the stack with durations provided by the QML profiler. Here is
    the stack with durations provided by the QML profiler. Let''s track all functions
    called when we restart the game pressing the R key:'
  prefs: []
  type: TYPE_NORMAL
- en: The `onPressed()` function from `GameArea.qml`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `handleKetEvent()` function from `engine.js`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `start()` function from `engine.js` at 4.2 seconds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`initEngine()` at 80 ms'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`createSnake()` at 120 ms'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`createWalls()` at 4.025 seconds!'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Here we are, `createWalls()` takes ~4 seconds on the Raspberry Pi when we restart
    the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s switch to the **Statistics** view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Profiling your QML application](img/image00405.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The **Statistics** view displays numbers concerning the call count of an event.
    An event can be a QML binding, creation, signal triggered, or a JavaScript function.
    The bottom part shows QML callers and callees.
  prefs: []
  type: TYPE_NORMAL
- en: A caller is the source of a change in a binding. For example, the JS function
    `createWalls()` is a caller.
  prefs: []
  type: TYPE_NORMAL
- en: A callee is the affected item that a binding triggers. For example, the QML
    item `Wall.qml` is a callee.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, `createWalls()` requesting many factory item creation seems responsible
    for the slow restart of the game on Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the last view of the QML profiler, the **Flamegraph**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Profiling your QML application](img/image00406.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The **Flamegraph** view is a compact summary of your QML and JavaScript code
    while running the game. You can see the call count and the amount of time relative
    to the total duration. Like the **Timeline** view, you can see the call stack
    but from bottom to top!
  prefs: []
  type: TYPE_NORMAL
- en: Again, the profiler indicates `createWalls()`  is a heavy function. On a profiling
    session of 10 seconds with one game restart, 77% of the time is spent in `engine.createWalls()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will now be able to profile a QML application. You can try to edit the
    code to speed up the restart. Here are some hints:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the walls only once at application startup; do not delete and recreate
    them on each restart.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Implement a common design pattern in video games: an object pool of preloaded
    items. Request a wall when needed, and return the wall to the pool when you do
    not use it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discovered how to use the Qt3D module. You also learned
    how to configure Qt Creator to create a new kit for an embedded Linux device.
    Your Raspberry Pi can now run your Qt applications. We created a snake game using
    QML views and an engine in JavaScript. We also covered the Factory design pattern
    to easily create new game items from the engine. Finally, you are now able to
    investigate the bad behavior of QML software using the powerful QML profiler.
  prefs: []
  type: TYPE_NORMAL
- en: Even if Qt is a powerful framework, sometimes you need to use a third-party
    library. In the next chapter, we will see how to integrate the OpenCV library
    into your Qt application.
  prefs: []
  type: TYPE_NORMAL
