- en: '*Chapter 7*: Dynamic Collision Detection and Physics – Finishing the Pong Game'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第7章*：动态碰撞检测和物理——完成Pong游戏'
- en: In this chapter, we will code our second class. We will see that although the
    ball is obviously quite different from the bat, we will use the exact same techniques
    to encapsulate the appearance and functionality of a ball inside a `Ball` class,
    just like we did with the bat and the `Bat` class. We will then add the finishing
    touches to the Pong game by coding some dynamic collision detection and scorekeeping.
    This might sound complicated but as we are coming to expect, SFML will make things
    much easier than they otherwise would be.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将编写我们的第二个类。我们将看到，尽管球显然与棒子有很大的不同，但我们将使用完全相同的技巧在`Ball`类中封装球的形状和功能，就像我们对棒子和`Bat`类所做的那样。然后，我们将通过编写一些动态碰撞检测和计分功能来完善Pong游戏。这听起来可能很复杂，但正如我们所期待的，SFML将使事情比其他方式更容易。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Coding the Ball class
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写`Ball`类
- en: Using the Ball class
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Ball`类
- en: Collision detection and scoring
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碰撞检测和计分
- en: Running the game
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行游戏
- en: We will start by coding the class that represents the ball.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先编写代表球的类。
- en: Coding the Ball class
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写`Ball`类
- en: To get started, we will code the header file. Right-click on `Ball.h`. Click
    the **Add** button. Now, we are ready to code the file.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们将编写头文件。在`Ball.h`上右键单击。点击**添加**按钮。现在，我们准备好编写文件。
- en: 'Add the following code to `Ball.h`:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`Ball.h`中：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first thing you will notice is the similarity in the member variables compared
    to the `Bat` class. There is a member variable for the position, appearance, and
    speed, just like there was for the player's bat, and they are the same types (`Vector2f`,
    `RectangleShape`, and `float`, respectively). They even have the same names (`m_Position`,
    `m_Shape`, and `m_Speed`, respectively). The difference between the member variables
    of this class is that the direction is handled with two `float` variables that
    will track horizontal and vertical movement. These are `m_DirectionX` and `m_DirectionY`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先会注意到与`Bat`类相比成员变量的相似性。有一个用于位置的成员变量，外观和速度，就像玩家的棒子一样，它们的类型相同（`Vector2f`、`RectangleShape`和`float`分别）。它们甚至有相同的名称（`m_Position`、`m_Shape`和`m_Speed`分别）。这个类成员变量之间的区别在于，方向由两个`float`变量处理，这些变量将跟踪水平和垂直移动。这些是`m_DirectionX`和`m_DirectionY`。
- en: Note that we will need to code eight functions to bring the ball to life. There
    is a constructor that has the same name as the class, which we will use to initialize
    a `Ball` instance. There are three functions with the same name and usage as the
    `Bat` class. They are `getPosition`, `getShape`, and `update`. The `getPosition`
    and `getShape` functions will share the location and the appearance of the ball
    with the `main` function, and the `update` function will be called from the `main`
    function to allow the `Ball` class to update its position once per frame.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们需要编写八个函数来使球变得生动。有一个与类名相同的构造函数，我们将使用它来初始化一个`Ball`实例。有三个与`Bat`类相同名称和用途的函数。它们是`getPosition`、`getShape`和`update`。`getPosition`和`getShape`函数将与`main`函数共享球的位置和外观，而`update`函数将从`main`函数中调用，以允许`Ball`类在每一帧更新其位置。
- en: The remaining functions control the direction the ball will travel in. The `reboundSides`
    function will be called from `main` when a collision is detected with either side
    of the screen, the `reboundBatOrTop` function will be called in response to the
    ball hitting the player's bat or the top of the screen, and the `reboundBottom`
    function will be called when the ball hits the bottom of the screen.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的函数控制球将移动的方向。当检测到与屏幕任一侧的碰撞时，`reboundSides`函数将从`main`中调用，当球击中玩家的棒子或屏幕顶部时，将调用`reboundBatOrTop`函数，当球击中屏幕底部时，将调用`reboundBottom`函数。
- en: Of course, these are just the declarations, so let's write the C++ that actually
    does the work in the `Ball.cpp` file.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这些只是声明，所以让我们在`Ball.cpp`文件中编写实际工作的C++代码。
- en: Let's create the file, and then we can start discussing the code. Right-click
    the `Ball.cpp` in the **Name:** field. Click the **Add** button and our new file
    will be created for us.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建文件，然后我们可以开始讨论代码。在**名称**字段中右键单击`Ball.cpp`。点击**添加**按钮，我们的新文件将为我们创建。
- en: 'Add the following code to `Ball.cpp`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`Ball.cpp`中：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code, we have added the required `include` directive for the
    `Ball` class header file. The constructor function with the same name as the class
    receives two `float` parameters, which are used to initialize the `m_Position`
    member's `Vector2f` instance. The `RectangleShape` instance is then sized with
    the `setSize` function and positioned with `setPosition`. The size that's being
    used is 10 pixels wide and 10 high; this is arbitrary but works well. The position
    that's being used is, of course, taken from the `m_Position Vector2f` instance.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们已添加了`Ball`类头文件的必需`include`指令。与类名相同的构造函数接收两个`float`参数，用于初始化`m_Position`成员的`Vector2f`实例。然后使用`setSize`函数设置`RectangleShape`实例的大小，并使用`setPosition`函数定位。使用的大小是10像素宽和10像素高；这是任意的，但效果很好。使用的位置当然是从`m_Position
    Vector2f`实例中获取的。
- en: 'Add the following code underneath the constructor in the `Ball.cpp` function:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Ball.cpp`函数的构造函数下方添加以下代码：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code, we are coding the three getter functions of the `Ball`
    class. They each return something to the `main` function. The first, `getPosition`,
    uses the `getGlobalBounds` function on `m_Shape` to return a `FloatRect` instance.
    This will be used for collision detection.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们正在编写`Ball`类的三个getter函数。它们各自向`main`函数返回一些内容。第一个是`getPosition`，它使用`m_Shape`上的`getGlobalBounds`函数返回一个`FloatRect`实例。这将用于碰撞检测。
- en: The `getShape` function returns `m_Shape` so that it can be drawn each frame
    of the game loop. The `getXVelocity` function tells the `main` function which
    direction the ball is traveling in, and we will see very soon exactly how this
    is useful to us. Since we don't ever need to get the vertical velocity, there
    is no corresponding `getYVelocity` function, but it would be simple to add one
    if we did.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`getShape`函数返回`m_Shape`，以便在游戏循环的每一帧中绘制。`getXVelocity`函数告诉`main`函数球体正在移动的方向，我们很快就会看到这如何对我们有用。由于我们永远不需要获取垂直速度，因此没有相应的`getYVelocity`函数，但如果我们需要，添加一个也很简单。'
- en: 'Add the following functions underneath the previous code we just added:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刚刚添加的代码下方添加以下函数：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code, the three functions whose names begin with `rebound…`
    handle what happens when the ball collides with various places. In the `reboundSides`
    function, `m_DirectionX` has its value inverted, which will have the effect of
    making a positive value negative and a negative value positive, thereby reversing
    (horizontally) the direction the ball is traveling in. `reboundBatOrTop` does
    exactly the same but with `m_DirectionY`, which has the effect of reversing the
    direction the ball is traveling in vertically. The `reboundBottom` function repositions
    the ball at the top center of the screen and sends it downward. This is just what
    we want after the player has missed a ball and it has hit the bottom of the screen.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，以`rebound...`开头的三个函数处理球体与各种位置的碰撞情况。在`reboundSides`函数中，`m_DirectionX`的值被反转，这将使正值变为负值，负值变为正值，从而反转（水平）球体移动的方向。`reboundBatOrTop`函数与`reboundSides`函数完全相同，但作用于`m_DirectionY`，这将反转球体垂直移动的方向。`reboundBottom`函数将球体重新定位到屏幕顶部中央，并将其向下发送。这就是玩家错过球体并击中屏幕底部后我们想要的。
- en: 'Finally, for the `Ball` class, add the update function, as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为`Ball`类添加更新函数，如下所示：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding code, `m_Position.y` and `m_Position.x` are updated using the
    appropriate direction velocity, the speed, and the amount of time the current
    frame took to complete. The newly updated `m_Position` values are then used to
    change the position the `m_Shape RectangleShape` instance is positioned at.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`m_Position.y`和`m_Position.x`使用适当的方向速度、速度和当前帧完成所需的时间进行更新。然后使用新更新的`m_Position`值来更改`m_Shape
    RectangleShape`实例的位置。
- en: The `Ball` class is done, so let's put it into action.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ball`类已完成，现在让我们将其投入使用。'
- en: Using the Ball class
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`Ball`类
- en: 'To put the ball into action, add the following code to make the `Ball` class
    available in the `main` function:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要使`Ball`类在`main`函数中可用，请将以下代码添加到使球体生效的部分：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add the following highlighted line of code to declare and initialize an instance
    of the `Ball` class using the constructor function that we have just coded:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下高亮显示的代码行，使用我们刚刚编写的构造函数声明并初始化`Ball`类的一个实例：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add the following code positioned exactly as highlighted:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到高亮显示的位置：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code, we simply call `update` on the `ball` instance. The ball
    will be repositioned accordingly.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们只是对`ball`实例调用`update`。球将相应地重新定位。
- en: 'Add the following highlighted code to draw the ball on each frame of the game
    loop:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下高亮代码添加到游戏循环的每一帧上绘制球：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: At this stage, you could run the game and the ball would spawn at the top of
    the screen and begin its descent toward the bottom of the screen. It would, however,
    disappear off the bottom of the screen because we are not detecting any collisions
    yet. Let's fix that now.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你可以运行游戏，球会在屏幕顶部生成并开始向屏幕底部下降。然而，球会从屏幕底部消失，因为我们还没有检测到任何碰撞。现在让我们解决这个问题。
- en: Collision detection and scoring
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞检测和得分
- en: Unlike in the Timber!!! game when we simply checked whether a branch in the
    lowest position was on the same side as the player's character, in this game,
    we will need to mathematically check for the intersection of the ball with the
    bat or the ball with any of the four sides of the screen.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 与Timber!!!游戏不同，我们当时只是检查最低位置的树枝是否与玩家的角色在同一个侧面，在这个游戏中，我们需要通过数学方法检查球与球拍或球与屏幕四边的交点。
- en: Let's look at some hypothetical code that would achieve this so that we understand
    what we are doing. Then, we will turn to SFML to solve the problem for us.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些假设的代码，以便我们理解我们在做什么。然后，我们将转向SFML来为我们解决这个问题。
- en: 'The code for testing the intersection of two rectangles would look something
    like this. Don''t use the following code. It is for demonstration purposes only:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 测试两个矩形相交的代码可能看起来像这样。不要使用以下代码。它仅用于演示目的：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We don't need to write this code; however, we will be using the SFML `intersects`
    function, which works on `FloatRect` objects. Think or look back to the `Bat`
    and `Ball` classes; they both had a `getPosition` function, which returned a `FloatRect`
    of the object's current location. We will see how we can use `getPosition`, along
    with `intersects`, to do all our collision detection.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要编写此代码；然而，我们将使用SFML的`intersects`函数，该函数作用于`FloatRect`对象。回想或查看`Bat`和`Ball`类；它们都有`getPosition`函数，该函数返回对象的当前位置的`FloatRect`。我们将看到如何使用`getPosition`和`intersects`来完成所有的碰撞检测。
- en: 'Add the following highlighted code at the end of the update section of the
    main function:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在主函数的更新部分末尾添加以下高亮代码：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the preceding code, the first `if` condition checks whether the ball has
    hit the bottom of the screen:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，第一个`if`条件检查球是否触碰到屏幕底部：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If the top of the ball is at a greater position than the height of the window,
    then the ball has disappeared off the bottom of the player's view. In response,
    the `ball.reboundBottom` function is called. Remember that, in this function,
    the ball is repositioned at the top of the screen. At this point, the player has
    lost a life, so the `lives` variable is decremented.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果球的上部位置高于窗口的高度，那么球已经从玩家的视图中消失。作为回应，调用`ball.reboundBottom`函数。记住，在这个函数中，球被重新定位到屏幕顶部。此时，玩家失去了一条生命，因此`lives`变量被递减。
- en: The second `if` condition checks whether the player has run out of lives (`lives
    < 1`). If this is the case, the score is reset to 0, the number of lives is reset
    to 3, and the game is restarted. In the next project, we will learn how to keep
    and display the player's highest score.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个`if`条件检查玩家是否用完了生命（`lives < 1`）。如果是这种情况，分数重置为0，生命值重置为3，游戏重新开始。在下一个项目中，我们将学习如何保存和显示玩家的最高分。
- en: 'Add the following code underneath the previous code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码下方添加以下代码：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding code, we are detecting that the top of the ball hits the top
    of the screen. When this occurs, the player is awarded a point and `ball.reboundBatOrTop`
    is called, which reverses the vertical direction of travel and sends the ball
    back toward the bottom of the screen.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们检测到球的上部触碰到屏幕的上部。当这种情况发生时，玩家获得一分，并调用`ball.reboundBatOrTop`，这将反转球的垂直运动方向，并将球送回屏幕底部。
- en: 'Add the following code underneath the previous code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码下方添加以下代码：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding code, the `if` condition detects a collision with the left-hand
    side of the ball with the left-hand side of the screen or the right-hand side
    of the ball (left + 10) with the right-hand side of the screen. In either event,
    the `ball.reboundSides` function is called and the horizontal direction of travel
    is reversed.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`if`条件检测到球与屏幕左侧的碰撞或球右侧（左+10）与屏幕右侧的碰撞。在任何一种情况下，都会调用`ball.reboundSides`函数，并反转水平移动的方向。
- en: 'Add the following code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code, the `intersects` function is used to determine whether
    the ball has hit the bat. When this occurs, we use the same function that we used
    for a collision with the top of the screen to reverse the vertical direction of
    travel of the ball.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`intersects`函数用于确定球是否击中了球拍。当发生这种情况时，我们使用与屏幕顶部碰撞相同的函数来反转球垂直移动的方向。
- en: Running the game
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行游戏
- en: 'You can now run the game and bounce the ball around the screen. The score will
    increase when you hit the ball with the bat and the lives will decrease when you
    miss it. When `lives` gets to 0, the score will reset, and the `lives` will go
    back up to 3, as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以运行游戏，让球在屏幕上弹跳。当你用球拍击中球时，分数会增加，当你错过它时，生命值会减少。当`lives`达到0时，分数将重置，`lives`将回到3，如下所示：
- en: '![](img/Image86489.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Image86489.jpg)'
- en: Summary
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Congratulations; that's the second game completed! We could have added more
    features to that game such as coop play, high scores, sound effects, and more,
    but I just wanted to use the simplest possible example to introduce classes and
    dynamic collision detection. Now that we have these topics in our game developer's
    arsenal, we can move on to a much more exciting project and yet more game development
    topics.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你；这是第二个完成的游戏！我们本可以给那个游戏添加更多功能，比如合作游戏、高分、音效等等，但我只是想用最简单的例子来介绍类和动态碰撞检测。现在我们有了这些主题在我们的游戏开发者工具箱中，我们可以继续到一个更加激动人心的项目，以及更多游戏开发主题。
- en: In the next chapter, we will plan the Zombie Arena game, learn about the SFML
    `View` class, which acts as a virtual camera into our game world, and code some
    more classes.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将规划僵尸竞技场游戏，了解SFML的`View`类，它作为进入我们游戏世界的虚拟摄像头，并编写一些更多的类。
- en: FAQ
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见问题解答
- en: Q) Isn't this game a little quiet?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Q) 这款游戏是不是有点安静？
- en: A) I didn't add sound effects to this game because I wanted to keep the code
    as short as possible while using our first classes and learning to use the time
    to smoothly animate all the game objects. If you want to add sound effects, then
    all you need to do is add the .wav files to the project, use SFML to load the
    sounds, and play a sound effect in each of the collision events. We will do this
    in the next project.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: A) 我没有给这个游戏添加音效，因为我想要保持代码尽可能短，同时使用我们的第一个类，并学习如何使用时间来平滑地动画化所有游戏对象。如果你想添加音效，你只需要将.wav文件添加到项目中，使用SFML加载声音，并在每个碰撞事件中播放一个音效。我们将在下一个项目中这样做。
- en: Q) The game is too easy! How can I make the ball speed up a little?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Q) 游戏太简单了！我怎样才能让球的速度稍微快一点？
- en: 'A) There are lots of ways you can make the game more challenging. One simple
    way would be to add a line of code in the `Ball` class'' `reboundBatOrTop` function
    that increases the speed. As an example, the following code would increase the
    speed of the ball by 10% each time the function is called:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: A) 有很多方法可以使游戏更具挑战性。一种简单的方法是在`Ball`类的`reboundBatOrTop`函数中添加一行代码来增加速度。例如，以下代码会在每次函数被调用时将球的速度增加10%：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The ball would get quite fast quite quickly. You would then need to devise a
    way to reset the speed back to `300.0f` when the player has lost all their lives.
    You could create a new function in the `Ball` class, perhaps called `resetSpeed`,
    and call it from `main` when the code detects that the player has lost their last
    life.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 球会很快变得非常快。当玩家失去所有生命时，你需要想出一个方法将速度重置回`300.0f`。你可以在`Ball`类中创建一个新的函数，可能叫做`resetSpeed`，并在代码检测到玩家失去最后一条生命时从`main`中调用它。
