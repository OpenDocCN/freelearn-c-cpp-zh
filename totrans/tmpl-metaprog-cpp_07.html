<html><head></head><body><div><div><h1 id="_idParaDest-75"><em class="italic"><a id="_idTextAnchor080"/>Chapter 5</em>: Type Traits and Conditional Compilation</h1>
			<p><strong class="bold">Type traits</strong> are an important metaprogramming technique that enables us to inspect properties of types or to perform transformations of types at compile-time. Type traits are themselves templates and you can see them as meta-types. Knowing information such as the nature of a type, its supported operations, and its various properties is key for performing conditional compilation of templated code. It is also very useful when writing a library of templates.</p>
			<p>In this chapter, you will learn the following:</p>
			<ul>
				<li>Understanding and defining type traits </li>
				<li>Understanding SFINAE and its purpose</li>
				<li>Enabling SFINAE with the <code>enable_if</code> type trait</li>
				<li>Using <code>constexpr if</code></li>
				<li>Exploring the standard type traits</li>
				<li>Seeing real-world examples of using type traits</li>
			</ul>
			<p>By the end of the chapter, you will have a good understanding of what type traits are, how they are useful, and what type traits are available in the <strong class="bold">C++</strong> standard library.</p>
			<p>We will start the chapter by looking at what type traits are and how they help us.</p>
			<h1 id="_idParaDest-76"><a id="_idTextAnchor081"/>Understanding and defining type traits </h1>
			<p>In a nutshell, <strong class="bold">type traits</strong> are small <a id="_idIndexMarker400"/>class templates that contain a constant value whose value represents the answer to a question we ask about a type. An example of such a question is: is this type a floating-point type? The technique for building type traits that provide such information about types relies on template specialization: we define a primary template as well as one or more specializations. </p>
			<p>Let’s see how we <a id="_idIndexMarker401"/>can build a type trait that tells us, at compile-time, whether a type is a floating-point type:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct is_floating_point</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   static const bool value = false;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;&gt;</pre>
			<pre class="source-code">struct is_floating_point&lt;float&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   static const bool value = true;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;&gt;</pre>
			<pre class="source-code">struct is_floating_point&lt;double&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   static const bool value = true;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;&gt;</pre>
			<pre class="source-code">struct is_floating_point&lt;long double&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   static const bool value = true;</pre>
			<pre class="source-code">};</pre>
			<p>There are two things to notice here:</p>
			<ul>
				<li>We have defined a primary template as well as several full specializations, one for each type that is a floating-point type.</li>
				<li>The primary template has a <code>static const</code> Boolean member initialized with the <code>false</code> value; the full specializations set the value of this member to <code>true</code>.</li>
			</ul>
			<p>There is nothing more to <a id="_idIndexMarker402"/>building a type trait than this. <code>is_floating_point&lt;T&gt;</code> is a type trait that tells us whether a type is a floating-point type or not. We can use it as follows:</p>
			<pre class="source-code">int main()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   static_assert(is_floating_point&lt;float&gt;::value);</pre>
			<pre class="source-code">   static_assert(is_floating_point&lt;double&gt;::value);</pre>
			<pre class="source-code">   static_assert(is_floating_point&lt;long double&gt;::value);</pre>
			<pre class="source-code">   static_assert(!is_floating_point&lt;int&gt;::value);</pre>
			<pre class="source-code">   static_assert(!is_floating_point&lt;bool&gt;::value);</pre>
			<pre class="source-code">}</pre>
			<p>This proves that we have built the type trait correctly. But it does not show a real use-case scenario. For this type trait to be really useful, we need to use it at compile-time to do something with the information it provides. </p>
			<p>Let’s suppose we want to build a function that does something with a floating-point value. There are multiple floating-point types, such as <code>float</code>, <code>double</code>, and <code>long double</code>. For us to avoid writing multiple implementations, we would build this as a template function. However, that means we could actually pass other types as template arguments, so we need a way to prevent that. A simple solution is to use the <code>static_assert()</code> statement we saw earlier and produce an error should the user supply a value that is not a floating-point value. This can look as follows:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">void process_real_number(T const value)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   static_assert(is_floating_point&lt;T&gt;::value);</pre>
			<pre class="source-code">   std::cout &lt;&lt; "processing a real number: " &lt;&lt; value </pre>
			<pre class="source-code">             &lt;&lt; '\n';</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">int main()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   process_real_number(42.0);</pre>
			<pre class="source-code">   process_real_number(42); // error: </pre>
			<pre class="source-code">                            // static assertion failed</pre>
			<pre class="source-code">}</pre>
			<p>This is a really simple example but it demonstrates the use of type traits to do conditional compilation. There are other approaches than using <code>static_assert()</code> and we will explore them throughout this chapter. For the time being, let’s look at a second example.</p>
			<p>Suppose we have classes that define operations for writing to an output stream. This is basically a form of <a id="_idIndexMarker403"/>serialization. However, some support this with an overloaded <code>operator&lt;&lt;</code>, others with the help of a member function called <code>write</code>. The following listing shows two such classes:</p>
			<pre class="source-code">struct widget</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   int         id;</pre>
			<pre class="source-code">   std::string name;</pre>
			<pre class="source-code">   std::ostream&amp; write(std::ostream&amp; os) const</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      os &lt;&lt; id &lt;&lt; ',' &lt;&lt; name &lt;&lt; '\n';</pre>
			<pre class="source-code">      return os;</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">struct gadget</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   int         id;</pre>
			<pre class="source-code">   std::string name;</pre>
			<pre class="source-code">   friend std::ostream&amp; operator &lt;&lt;(std::ostream&amp; os, </pre>
			<pre class="source-code">                                    gadget const&amp; o);</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">std::ostream&amp; operator &lt;&lt;(std::ostream&amp; os, </pre>
			<pre class="source-code">                          gadget const&amp; o)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   os &lt;&lt; o.id &lt;&lt; ',' &lt;&lt; o.name &lt;&lt; '\n';</pre>
			<pre class="source-code">   return os;</pre>
			<pre class="source-code">}</pre>
			<p>In this example, the <code>widget</code> class contains a member function, <code>write</code>. However, for the <code>gadget</code> class, the stream <a id="_idIndexMarker404"/>operator, <code>&lt;&lt;</code>, is overloaded for the same purpose. We can write the following code using these classes:</p>
			<pre class="source-code">widget w{ 1, "one" };</pre>
			<pre class="source-code">w.write(std::cout);</pre>
			<pre class="source-code">gadget g{ 2, "two" };</pre>
			<pre class="source-code">std::cout &lt;&lt; g;</pre>
			<p>However, our goal would be to define a function template that enables us to treat them the same way. In other words, instead of using either <code>write</code> or the <code>&lt;&lt;</code> operator, we should be able to write the following:</p>
			<pre class="source-code">serialize(std::cout, w);</pre>
			<pre class="source-code">serialize(std::cout, g);</pre>
			<p>This brings up some questions. First, how would such a function template look, and second, how can we know whether a type provides a <code>write</code> method or has the <code>&lt;&lt;</code> operator overloaded? The answer <a id="_idIndexMarker405"/>to the second question is type traits. We can build a type trait to help us answer this latter question at compile-time. This is how such a type trait may look:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct uses_write</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   static constexpr bool value = false;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;&gt;</pre>
			<pre class="source-code">struct uses_write&lt;widget&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   static constexpr bool value = true;</pre>
			<pre class="source-code">};</pre>
			<p>This is very similar to the type trait we defined previously. <code>uses_write</code> tells us whether a type defines the <code>write</code> member function. The primary template sets the data member called <code>value</code> to <code>false</code>, but the full specialization for the <code>widget</code> class sets it to <code>true</code>. In order to avoid the verbose syntax <code>uses_write&lt;T&gt;::value</code>, we can also define a variable template, reducing the syntax to the form <code>uses_write_v&lt;T&gt;</code>. This variable template will look as follows:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">inline constexpr bool uses_write_v = uses_write&lt;T&gt;::value;</pre>
			<p>To make the exercise simple, we’ll assume that the types that don’t provide a <code>write</code> member function overload the output stream operator. In practice, this is would not be the case, but for the sake of simplicity, we will build on this assumption.</p>
			<p>The next step in defining the function template <code>serialize</code> that provides a uniform API for serializing all classes is to <a id="_idIndexMarker406"/>define more class templates. However, these would follow the same path – a primary template that provides one form of serialization and a full specialization that provides a different form. Here is the code for it:</p>
			<pre class="source-code">template &lt;bool&gt;</pre>
			<pre class="source-code">struct serializer</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   template &lt;typename T&gt;</pre>
			<pre class="source-code">   static void serialize(std::ostream&amp; os, T const&amp; value)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      os &lt;&lt; value;</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template&lt;&gt;</pre>
			<pre class="source-code">struct serializer&lt;true&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   template &lt;typename T&gt;</pre>
			<pre class="source-code">   static void serialize(std::ostream&amp; os, T const&amp; value)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      value.write(os);</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<p>The <code>serializer</code> class template has a single template parameter, which is a non-type template parameter. It is also <a id="_idIndexMarker407"/>an anonymous template parameter because we don’t use it anywhere in the implementation. This class template contains a single member function. It is actually a member function template with a single type template parameter. This parameter defines the type of value we would serialize. The primary template uses the <code>&lt;&lt;</code> operator to output the value to the provided stream. On the other hand, the full specialization of the <code>serializer</code> class template uses the member function <code>write</code> to do the same. Notice that we fully specialize the <code>serializer</code> class template and not the <code>serialize</code> member function template.</p>
			<p>The only thing left now is to implement the desired free function <code>serialize</code>. Its implementation will be based <a id="_idIndexMarker408"/>on the <code>serializer&lt;T&gt;::serialize</code> function. Let’s see how:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">void serialize(std::ostream&amp; os, T const&amp; value)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   serializer&lt;uses_write_v&lt;T&gt;&gt;::serialize(os, value);</pre>
			<pre class="source-code">}</pre>
			<p>The signature of this function template is the same as the one of the <code>serialize</code> member function from the <code>serializer</code> class template. The selection between the primary template and the full specialization is done with the help of the variable template <code>uses_write_v</code>, which provides a convenient way to access the value data member of the <code>uses_write</code> type trait.</p>
			<p>In these examples, we have seen how to implement type traits and use the information they provide at compile-time to either impose restrictions on types or select between one implementation <a id="_idIndexMarker409"/>or the other. A similar purpose has another metaprogramming technique called <strong class="bold">SFINAE</strong>, which we will cover next.</p>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor082"/>Exploring SFINAE and its purpose</h1>
			<p>When we write templates, we sometimes need to restrict the template arguments. For instance, we have a function template that should work for any numeric type, therefore integral and floating-point, but <a id="_idIndexMarker410"/>should not work with anything else. Or we may have a class template that should only accept trivial types for an argument.</p>
			<p>There are also cases when we may have overloaded function templates that should each work with some types only. For instance, one overload should work for integral types and the other for floating-point types only. There are different ways to achieve this goal and we will explore them in this chapter and the next. </p>
			<p>Type traits, however, are involved in one way or another in all of them. The first one that will be discussed in this chapter is a feature called SFINAE. Another approach, superior to SFINAE, is represented by concepts, which will be discussed in the next chapter.</p>
			<p><strong class="bold">SFINAE</strong> stands for <strong class="bold">Substitution Failure Is Not An Error</strong>. When the compiler encounters the use of a function template, it substitutes the arguments in order to instantiate the template. If an error occurs at this point, it is not regarded as ill-informed code, only as a deduction failure. The function is removed from the overload set instead of causing an error. Only if there is no match in the overload set does an error occur.</p>
			<p>It’s difficult to really understand SFINAE without concrete examples. Therefore, we will go through several examples to explain the concept.</p>
			<p>Every standard container, such as <code>std::vector</code>, <code>std::array</code>, and <code>std::map</code>, not only has iterators that <a id="_idIndexMarker411"/>enable us to access its elements but also modify the container (such as inserting after the element pointed by an iterator). Therefore, these containers have member functions to return iterators to the first and the one-past-last elements of the container. These methods are called <code>begin</code> and <code>end</code>.</p>
			<p>There are other methods such as <code>cbegin</code> and <code>cend</code>, <code>rbegin</code> and <code>rend</code>, and <code>crbegin</code> and <code>crend</code> but these are beyond the purpose of this topic. In C++11, there are also free functions, <code>std:begin</code> and <code>std::end</code>, that do the same. However, these work not just with standard containers but also with arrays. One benefit of these is enabling range-based <code>for</code> loops for arrays. The question is how this non-member function could be implemented to work with both containers and arrays? Certainly, we need two overloads of a function template. A possible implementation is the following:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">auto begin(T&amp; c) { return c.begin(); }   // [1]</pre>
			<pre class="source-code">template &lt;typename T, size_t N&gt;</pre>
			<pre class="source-code">T* begin(T(&amp;arr)[N]) {return arr; }      // [2]</pre>
			<p>The first overload calls the member function <code>begin</code> and returns the value. Therefore, this <a id="_idIndexMarker412"/>overload is restricted to types that have <a id="_idIndexMarker413"/>a member function <code>begin</code>; otherwise, a compiler error would occur. The second overload simply returns a pointer to the first element of the array. This is restricted to array types; anything else would produce a compiler error. We can use these overloads as follows:</p>
			<pre class="source-code">std::array&lt;int, 5&gt; arr1{ 1,2,3,4,5 };</pre>
			<pre class="source-code">std::cout &lt;&lt; *begin(arr1) &lt;&lt; '\n';       // [3] prints 1</pre>
			<pre class="source-code">int arr2[]{ 5,4,3,2,1 };</pre>
			<pre class="source-code">std::cout &lt;&lt; *begin(arr2) &lt;&lt; '\n';       // [4] prints 5</pre>
			<p>If you compile this piece of code, no error, not even a warning, occurs. The reason for that is SFINAE. When resolving the call to <code>begin(arr1)</code>, substituting <code>std::array&lt;int, 5&gt;</code> to the first overload (at <code>[1]</code>) succeeds, but the substitution for the second (at <code>[2]</code>) fails. Instead of issuing an error at this point, the compiler just ignores it, so it builds an overload set with a single instantiation and, therefore, it can successfully find a match for the invocation. Similarly, when resolving the call to <code>begin(arr2)</code>, the substitution of <code>int[5]</code> for the first overload fails and is ignored, but it succeeds for the second and is added to the overload set, eventually finding a good match for the invocation. Therefore, both calls can be successfully made. Should one of the two overloads not be present, either <code>begin(arr1)</code> or <code>begin(arr2)</code> would fail to match the function template and a compiler error would occur.</p>
			<p>SFINAE only applies in the so-called <strong class="bold">immediate context</strong> of a function. The immediate context is basically the <a id="_idIndexMarker414"/>template declaration (including the template parameter list, the function return type, and the function parameter list). Therefore, it does not apply to the body of a function. Let’s consider the following example:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">void increment(T&amp; val) { val++; }</pre>
			<pre class="source-code">int a = 42;</pre>
			<pre class="source-code">increment(a);  // OK</pre>
			<pre class="source-code">std::string s{ "42" };</pre>
			<pre class="source-code">increment(s);  // error</pre>
			<p>There are no restrictions on the type <code>T</code> in the immediate context of the <code>increment</code> function <a id="_idIndexMarker415"/>template. However, in the body <a id="_idIndexMarker416"/>of the function, the parameter <code>val</code> is incremented with the post-fix <code>operator++</code>. That means, substituting for <code>T</code> any type for which the post-fix <code>operator++</code> is not implemented is a failure. However, this failure is an error and will not be ignored by the compiler.</p>
			<p>The C++ standard (license usage link: <a href="http://creativecommons.org/licenses/by-sa/3.0/">http://creativecommons.org/licenses/by-sa/3.0/</a>) defines the list of errors that are considered SFINAE errors (in paragraph <em class="italic">§13.10.2</em>, <em class="italic">Template argument deduction</em>, the <strong class="bold">C++20</strong> standard version). These SFINAE errors are the following attempts:</p>
			<ul>
				<li>Creating an array of <code>void</code>, an array of reference, an array of function, an array of negative size, an array of size zero, and an array of non-integral size</li>
				<li>Using a type that is not a class or enum on the left side of the scope resolution operator <code>::</code> (such as in <code>T::value_type</code> with <code>T</code> being a numeric type for instance)</li>
				<li>Creating a pointer to reference</li>
				<li>Creating a reference to <code>void</code></li>
				<li>Creating a pointer to member of <code>T</code>, where <code>T</code> is not a class type</li>
				<li>Using a member of a type when the type does not contain that member</li>
				<li>Using a member of a type where a type is required but the member is not a type</li>
				<li>Using a member of a type where a template is required but the member is not a template</li>
				<li>Using a member of a type where a non-type is required but the member is not a non-type</li>
				<li>Creating a function type with a parameter of type <code>void</code></li>
				<li>Creating a function type that returns an array type or another function type</li>
				<li>Performing an invalid conversion in a template argument expression or an expression used in a function declaration</li>
				<li>Supplying an invalid type to a non-type template parameter</li>
				<li>Instantiating a pack expansion containing multiple packs of different lengths</li>
			</ul>
			<p>The last error in this list was introduced in C++11 together with variadic templates. The others were defined before C++11. We will not go on to exemplify all of these errors, but we can <a id="_idIndexMarker417"/>take a look at a couple more <a id="_idIndexMarker418"/>examples. The first concerns attempting to create an array of size zero. Let’s say we want to have two function template overloads, one that handles arrays of even sizes and one that handles arrays of odd sizes. A solution to this is the following:</p>
			<pre class="source-code">template &lt;typename T, size_t N&gt;</pre>
			<pre class="source-code">void handle(T(&amp;arr)[N], char(*)[N % 2 == 0] = 0)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   std::cout &lt;&lt; "handle even array\n";</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template &lt;typename T, size_t N&gt;</pre>
			<pre class="source-code">void handle(T(&amp;arr)[N], char(*)[N % 2 == 1] = 0)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   std::cout &lt;&lt; "handle odd array\n";</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">int arr1[]{ 1,2,3,4,5 };</pre>
			<pre class="source-code">handle(arr1);</pre>
			<pre class="source-code">int arr2[]{ 1,2,3,4 };</pre>
			<pre class="source-code">handle(arr2);</pre>
			<p>The template arguments and the first function parameter are similar to what we saw with the <code>begin</code> overload for arrays. However, these overloads for <code>handle</code> have a second anonymous parameter with the default value <code>0</code>. The type of this parameter is a pointer to an array of type <code>char</code> and a size specified with the expressions <code>N%2==0</code> and <code>N%2==1</code>. For every possible array, one of these two is <code>true</code> and the other is <code>false</code>. Therefore, the second parameter is either <code>char(*)[1]</code> or <code>char(*)[0]</code>, the latter being an SFINAE error (an attempt to create an array of size zero). Therefore, we are able to call either one of the other overloads without generating compiler errors, thanks to SFINAE.</p>
			<p>The last example <a id="_idIndexMarker419"/>that we will look <a id="_idIndexMarker420"/>at in this section will show SFINAE with an attempt to use a member of a class that does not exist. Let’s start with the following snippet:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct foo</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   using foo_type = T;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct bar</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   using bar_type = T;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">struct int_foo : foo&lt;int&gt; {};</pre>
			<pre class="source-code">struct int_bar : bar&lt;int&gt; {};</pre>
			<p>Here we have two classes, <code>foo</code>, which has a member type called <code>foo_type</code>, and <code>bar</code>, which has a member type called <code>bar_type</code>. There are also classes that derive from these <a id="_idIndexMarker421"/>two. The goal is to write two <a id="_idIndexMarker422"/>function templates, one that handles the <code>foo</code> hierarchy of classes, and one that handles the <code>bar</code> hierarchy of classes. A possible implementation is the following:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">decltype(typename T::foo_type(), void()) handle(T const&amp; v)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   std::cout &lt;&lt; "handle a foo\n";</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">decltype(typename T::bar_type(), void()) handle(T const&amp; v)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   std::cout &lt;&lt; "handle a bar\n";</pre>
			<pre class="source-code">}</pre>
			<p>Both overloads have a single template parameter and a single function parameter of type <code>T const&amp;</code>. They also return the same type, and that type is <code>void</code>. The expression <code>decltype(typename T::foo_type(), void())</code> may need a little consideration to understand better. We discussed <code>decltype</code> in <a href="B18367_04_ePub.xhtml#_idTextAnchor064"><em class="italic">Chapter 4</em></a>, <em class="italic">Advanced Template Concepts</em>. Remember that this is a type specifier that deduces the type of an expression. We <a id="_idIndexMarker423"/>use the comma <a id="_idIndexMarker424"/>operator, so the first argument is evaluated but then discarded, so <code>decltype</code> will only deduce the type from <code>void()</code>, and the deduced type is <code>void</code>. However, the arguments <code>typename T::foo_type()</code> and <code>typename T::bar_type()</code> do use an inner type, and this only exists either for <code>foo</code> or <code>bar</code>. This is where SFINAE manifests itself, as shown in the following snippet:</p>
			<pre class="source-code">int_foo fi;</pre>
			<pre class="source-code">int_bar bi;</pre>
			<pre class="source-code">int x = 0;</pre>
			<pre class="source-code">handle(fi); // OK</pre>
			<pre class="source-code">handle(bi); // OK</pre>
			<pre class="source-code">handle(x);  // error</pre>
			<p>Calling <code>handle</code> with an <code>int_foo</code> value will match the first overload, while the second is discarded because of a substitution failure. Similarly, calling <code>handle</code> with an <code>int_bar</code> value will match the second overload, while the first is discarded because of a substitution failure. However, calling <code>handle</code> with an <code>int</code> will cause substitution failure for both overloads so the final overload set for substituting <code>int</code> will be empty, which means there is no match for the call. Therefore, a compiler error occurs.</p>
			<p>SFINAE is not the best way to achieve conditional compilation. However, in modern C++ it’s probably best used together with a type trait called <code>enable_if</code>. This is what we will discuss next.</p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor083"/>Enabling SFINAE with the enable_if type trait</h1>
			<p>The C++ <a id="_idIndexMarker425"/>standard <a id="_idIndexMarker426"/>library is a family of sub-libraries. One of these is the type support library. This library defines types such as <code>std::size_t</code>, <code>std::nullptr_t</code>, and <code>std::byte</code>, run-time type identification support with classes such as <code>std::type_info</code>, as well as a collection of type traits. There are <a id="_idIndexMarker427"/>two categories of type traits:</p>
			<ul>
				<li>Type traits that enable us to query properties of types at compile-time.</li>
				<li>Type traits that enable us to perform type transformations at compile-time (such as adding or removing the <code>const</code> qualifier, or adding or removing pointer or reference from a type). These type <a id="_idIndexMarker428"/>traits are also called <strong class="bold">metafunctions</strong>.</li>
			</ul>
			<p>One type trait <a id="_idIndexMarker429"/>from the second category is <code>std::enable_if</code>. This is used to enable <a id="_idIndexMarker430"/>SFINAE and remove candidates from a function’s overload set. A possible implementation is the following:</p>
			<pre class="source-code">template&lt;bool B, typename T = void&gt;</pre>
			<pre class="source-code">struct enable_if {};</pre>
			<pre class="source-code">template&lt;typename T&gt;</pre>
			<pre class="source-code">struct enable_if&lt;true, T&gt; { using type = T; };</pre>
			<p>There is a primary template, with two template parameters, a Boolean non-type template, and a type parameter with <code>void</code> as the default argument. This primary template is an empty class. There is also a partial specialization for the <code>true</code> value of the non-type template parameter. This, however, defines a member type simply called <code>type</code>, which is an alias template for the template parameter <code>T</code>.</p>
			<p>The <code>enable_if</code> metafunction is intended to be used with a Boolean expression. When this Boolean expression <a id="_idIndexMarker431"/>is evaluated as <code>true</code>, it defines a member type called <code>type</code>. If the Boolean expression is <code>false</code>, this member type is not defined. Let’s see how it works.</p>
			<p>Remember the example from the <em class="italic">Understanding and defining type traits</em> section at the beginning of the chapter, where we had classes that provided a <code>write</code> method to write their content to an output stream, and classes for which the <code>operator&lt;&lt;</code> was overloaded for the same purpose? In that section, we defined a type trait called <code>uses_write</code> and wrote a <code>serialize</code> function template that allowed us to serialize, in a <a id="_idIndexMarker432"/>uniform manner, both types of objects (<code>widget</code> and <code>gadget</code>). However, the implementation <a id="_idIndexMarker433"/>was rather complex. With <code>enable_if</code>, we can implement that function in a simple manner. A possible implementation is shown in the next snippet:</p>
			<pre class="source-code">template &lt;typename T, </pre>
			<pre class="source-code">          typename std::enable_if&lt;</pre>
			<pre class="source-code">             uses_write_v&lt;T&gt;&gt;::type* = nullptr&gt;</pre>
			<pre class="source-code">void serialize(std::ostream&amp; os, T const&amp; value)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   value.write(os);</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template &lt;typename T,</pre>
			<pre class="source-code">          typename std::enable_if&lt;</pre>
			<pre class="source-code">             !uses_write_v&lt;T&gt;&gt;::type*=nullptr&gt;</pre>
			<pre class="source-code">void serialize(std::ostream&amp; os, T const&amp; value)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   os &lt;&lt; value;</pre>
			<pre class="source-code">}</pre>
			<p>There are two overloaded function templates in this implementation. They both have two template parameters. The first parameter is a type template parameter, called <code>T</code>. The second is an anonymous non-type template parameter of a pointer type that also has the default value <code>nullptr</code>. We use <code>enable_if</code> to define the member called <code>type</code> only if the <code>uses_write_v</code> variable evaluates to <code>true</code>. Therefore, for classes that have the member function <code>write</code>, the substitution succeeds for the first overload but fails for the second overload, because <code>typename * = nullptr</code> is not a valid parameter. For classes for which the <code>operator&lt;&lt;</code> is overloaded, we have the opposite situation.</p>
			<p>The <code>enable_if</code> metafunction <a id="_idIndexMarker434"/>can be used in several scenarios:</p>
			<ul>
				<li>To define a template parameter that has a default argument, which we saw earlier</li>
				<li>To define a function parameter that has a default argument</li>
				<li>To specify the return type of a function</li>
			</ul>
			<p>For this reason, I <a id="_idIndexMarker435"/>mentioned earlier that the <a id="_idIndexMarker436"/>provided implementation of the <code>serialize</code> overloads is just one of the possibilities. A similar one that uses <code>enable_if</code> to define a function parameter with a default argument is shown next:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">void serialize(</pre>
			<pre class="source-code">   std::ostream&amp; os, T const&amp; value, </pre>
			<pre class="source-code">   typename std::enable_if&lt;</pre>
			<pre class="source-code">               uses_write_v&lt;T&gt;&gt;::type* = nullptr)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   value.write(os);</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">void serialize(</pre>
			<pre class="source-code">   std::ostream&amp; os, T const&amp; value,</pre>
			<pre class="source-code">   typename std::enable_if&lt;</pre>
			<pre class="source-code">               !uses_write_v&lt;T&gt;&gt;::type* = nullptr)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   os &lt;&lt; value;</pre>
			<pre class="source-code">}</pre>
			<p>You <a id="_idIndexMarker437"/>will notice here that we basically <a id="_idIndexMarker438"/>moved the parameter from the template parameter list to the function parameter list. There is no other change, and the usage is the same, such as follows:</p>
			<pre class="source-code">widget w{ 1, "one" };</pre>
			<pre class="source-code">gadget g{ 2, "two" };</pre>
			<pre class="source-code">serialize(std::cout, w);</pre>
			<pre class="source-code">serialize(std::cout, g);</pre>
			<p>The third alternative is to use <code>enable_if</code> to wrap the return type of the function. This implementation is only slightly different (the default argument does not make sense for a return type). Here is how it looks:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">typename std::enable_if&lt;uses_write_v&lt;T&gt;&gt;::type serialize(</pre>
			<pre class="source-code">   std::ostream&amp; os, T const&amp; value)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   value.write(os);</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">typename std::enable_if&lt;!uses_write_v&lt;T&gt;&gt;::type serialize(</pre>
			<pre class="source-code">   std::ostream&amp; os, T const&amp; value)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   os &lt;&lt; value;</pre>
			<pre class="source-code">}</pre>
			<p>The return type, in this implementation, is defined if <code>uses_write_v&lt;T&gt;</code> is <code>true</code>. Otherwise, a substitution failure occurs and SFINAE takes place.</p>
			<p>Although in all these examples, the <code>enable_if</code> type trait was used to enable SFINAE during <a id="_idIndexMarker439"/>the overload resolution for function <a id="_idIndexMarker440"/>templates, this type trait can also be used to restrict instantiations of class templates. In the following example, we have a class called <code>integral_wrapper</code> that is supposed to be instantiated only with integral types, and a class called <code>floating_wrapper</code> that is supposed to be instantiated only with floating-point types:</p>
			<pre class="source-code">template &lt;</pre>
			<pre class="source-code">   typename T,</pre>
			<pre class="source-code">   typename=typenamestd::enable_if_t&lt;</pre>
			<pre class="source-code">                        std::is_integral_v&lt;T&gt;&gt;&gt;</pre>
			<pre class="source-code">struct integral_wrapper</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   T value;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;</pre>
			<pre class="source-code">   typename T,</pre>
			<pre class="source-code">   typename=typename std::enable_if_t&lt;</pre>
			<pre class="source-code">                        std::is_floating_point_v&lt;T&gt;&gt;&gt;</pre>
			<pre class="source-code">struct floating_wrapper</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   T value;</pre>
			<pre class="source-code">};</pre>
			<p>Both these class templates have two type template parameters. The first one is called <code>T</code>, but the <a id="_idIndexMarker441"/>second one is anonymous and has a <a id="_idIndexMarker442"/>default argument. The value of this argument is defined or not with the help of the <code>enable_if</code> type trait, based on the value of a Boolean expression. </p>
			<p>In this implementation, we can see:</p>
			<ul>
				<li>An alias template called <code>std::enable_if_t</code>, which is a convenient way to access the <code>std::enable_if&lt;B, T&gt;::type</code> member type. This is defined as follows:<pre>template &lt;bool B, typename T = void&gt;
using enable_if_t = typename enable_if&lt;B,T&gt;::type;</pre></li>
				<li>Two variable templates, <code>std::is_integral_v</code> and <code>std::is_floating_point_v</code>, which are convenient ways to access the data members, <code>std::is_integral&lt;T&gt;::value</code> and <code>std::is_floating_point&lt;T&gt;::value</code>. The <code>std::is_integral</code> and <code>std::is_floating_point</code> classes are standard type traits that check whether a type is an integral type or a floating-point type respectively.</li>
			</ul>
			<p>The two wrapper class templates shown previously can be used as follows:</p>
			<pre class="source-code">integral_wrapper w1{ 42 };   // OK</pre>
			<pre class="source-code">integral_wrapper w2{ 42.0 }; // error</pre>
			<pre class="source-code">integral_wrapper w3{ "42" }; // error</pre>
			<pre class="source-code">floating_wrapper w4{ 42 };   // error</pre>
			<pre class="source-code">floating_wrapper w5{ 42.0 }; // OK</pre>
			<pre class="source-code">floating_wrapper w6{ "42" }; // error</pre>
			<p>Only two of these instantiations work, <code>w1</code>, because <code>integral_wrapper</code> is instantiated with the <code>int</code> type, and <code>w5</code>, because <code>floating_wrapper</code> is instantiated with the <code>double</code> type. All the others generate compiler errors.</p>
			<p>It should be pointed out that this code samples only work with the provided definitions of <code>integral_wrapper</code> and <code>floating_wrapper</code> in C++20. For previous versions of the standard, even the definitions of <code>w1</code> and <code>w5</code> would generate compiler errors because <a id="_idIndexMarker443"/>the compiler wasn’t able to deduce <a id="_idIndexMarker444"/>the template arguments. In order to make them work, we’d have to change the class templates to include a constructor, as follows:</p>
			<pre class="source-code">template &lt;</pre>
			<pre class="source-code">   typename T,</pre>
			<pre class="source-code">   typename=typenamestd::enable_if_t&lt;</pre>
			<pre class="source-code">                        std::is_integral_v&lt;T&gt;&gt;&gt;</pre>
			<pre class="source-code">struct integral_wrapper</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   T value;</pre>
			<pre class="source-code">   integral_wrapper(T v) : value(v) {}</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;</pre>
			<pre class="source-code">   typename T,</pre>
			<pre class="source-code">   typename=typename std::enable_if_t&lt;</pre>
			<pre class="source-code">                        std::is_floating_point_v&lt;T&gt;&gt;&gt;</pre>
			<pre class="source-code">struct floating_wrapper</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   T value;</pre>
			<pre class="source-code">   floating_wrapper(T v) : value(v) {}</pre>
			<pre class="source-code">};</pre>
			<p>Although <code>enable_if</code> helps <a id="_idIndexMarker445"/>achieve <a id="_idIndexMarker446"/>SFINAE with simpler and more readable code, it’s still rather complicated. Fortunately, in <code>constexpr if</code> statements. Let’s explore this alternative next.</p>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor084"/>Using constexpr if</h1>
			<p>A C++17 feature <a id="_idIndexMarker447"/>makes SFINAE much easier. It’s called <code>constexpr if</code> and it’s a compile-time version of the <code>if</code> statement. It helps replace complex template code with simpler versions. Let’s start by looking at a C++17 implementation of the <code>serialize</code> function that can uniformly serialize both widgets and gadgets:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">void serialize(std::ostream&amp; os, T const&amp; value)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   if constexpr (uses_write_v&lt;T&gt;)</pre>
			<pre class="source-code">      value.write(os);</pre>
			<pre class="source-code">   else</pre>
			<pre class="source-code">      os &lt;&lt; value;</pre>
			<pre class="source-code">}</pre>
			<p>The syntax for <code>constexpr if</code> is <code>if constexpr(condition)</code>. The condition must be a compile-time expression. There is no short-circuit logic performed when evaluating the expression. This means that if the expression has the form <code>a &amp;&amp; b</code> or <code>a || b</code>, then both <code>a</code> and <code>b</code> must be well-formed.</p>
			<p><code>constexpr if</code> enables us to discard a branch, at compile-time, based on the value of the expression. In our example, when the <code>uses_write_v</code> variable is <code>true</code>, the <code>else</code> branch is discarded, and the body of the first branch is retained. Otherwise, the opposite occurs. Therefore, we end up with the following specializations for the <code>widget</code> and <code>gadget</code> classes:</p>
			<pre class="source-code">template&lt;&gt;</pre>
			<pre class="source-code">void serialize&lt;widget&gt;(std::ostream &amp; os,</pre>
			<pre class="source-code">                      widget const &amp; value)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   if constexpr(true)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      value.write(os);</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template&lt;&gt;</pre>
			<pre class="source-code">void serialize&lt;gadget&gt;(std::ostream &amp; os,</pre>
			<pre class="source-code">                       gadget const &amp; value)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   if constexpr(false) </pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">   } </pre>
			<pre class="source-code">   else</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      os &lt;&lt; value;</pre>
			<pre class="source-code">   } </pre>
			<pre class="source-code">}</pre>
			<p>Of course, this <a id="_idIndexMarker448"/>code is likely to be further simplified by the compiler. Therefore, eventually, these specializations would simply look like the following:</p>
			<pre class="source-code">template&lt;&gt;</pre>
			<pre class="source-code">void serialize&lt;widget&gt;(std::ostream &amp; os,</pre>
			<pre class="source-code">                       widget const &amp; value)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   value.write(os);</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template&lt;&gt;</pre>
			<pre class="source-code">void serialize&lt;gadget&gt;(std::ostream &amp; os,</pre>
			<pre class="source-code">                       gadget const &amp; value)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   os &lt;&lt; value;</pre>
			<pre class="source-code">}</pre>
			<p>The end <a id="_idIndexMarker449"/>result is the same as the one we achieved with SFINAE and <code>enable_if</code>, but the actual code we wrote here was simpler and easier to understand.</p>
			<p><code>constexpr if</code> is a great tool for simplifying code and we actually saw it earlier in <a href="B18367_03_ePub.xhtml#_idTextAnchor051"><em class="italic">Chapter 3</em></a>, <em class="italic">Variadic Templates</em>, in the <em class="italic">Parameter packs</em> paragraph, when we implemented a function called <code>sum</code>. This is shown again here:</p>
			<pre class="source-code">template &lt;typename T, typename... Args&gt;</pre>
			<pre class="source-code">T sum(T a, Args... args)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   if constexpr (sizeof...(args) == 0)</pre>
			<pre class="source-code">      return a;</pre>
			<pre class="source-code">   else</pre>
			<pre class="source-code">      return a + sum(args...);</pre>
			<pre class="source-code">}</pre>
			<p>In this example, <code>constexpr if</code> helps us to avoid having two overloads, one for the general case and one for ending the recursion. Another example presented already in this book where <code>constexpr if</code> can simplify the implementation is the <code>factorial</code> function <a id="_idIndexMarker450"/>template from <a href="B18367_04_ePub.xhtml#_idTextAnchor064"><em class="italic">Chapter 4</em></a>, <em class="italic">Advanced Template Concepts</em>, in the <em class="italic">Exploring template recursion</em> section. That function looked as follows:</p>
			<pre class="source-code">template &lt;unsigned int n&gt;</pre>
			<pre class="source-code">constexpr unsigned int factorial()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return n * factorial&lt;n - 1&gt;();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template&lt;&gt; </pre>
			<pre class="source-code">constexpr unsigned int factorial&lt;1&gt;() { return 1; }</pre>
			<pre class="source-code">template&lt;&gt; </pre>
			<pre class="source-code">constexpr unsigned int factorial&lt;0&gt;() { return 1; }</pre>
			<p>With <code>constexpr if</code>, we can replace all this with a single template and let the compiler take care of providing the right specializations. The C++17 version of this function may look as follows:</p>
			<pre class="source-code">template &lt;unsigned int n&gt;</pre>
			<pre class="source-code">constexpr unsigned int factorial()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   if constexpr (n &gt; 1)</pre>
			<pre class="source-code">      return n * factorial&lt;n - 1&gt;();</pre>
			<pre class="source-code">   else</pre>
			<pre class="source-code">      return 1;</pre>
			<pre class="source-code">}</pre>
			<p>The <code>constexpr if</code> statements can be useful in many situations. The last example presented in this section is a function template called <code>are_equal</code>, which determines whether the two supplied arguments are equal or not. Typically, you’d think that using <code>operator==</code> should be enough to determine whether two values are equal or not. That is true in <a id="_idIndexMarker451"/>most cases, except for floating-point values. Because only some of the floating-point numbers can be stored without a precision loss (numbers like 1, 1.25, 1.5, and anything else where the fractional part is an exact sum of inverse powers of 2) we need to take special care when comparing floating-point numbers. Usually, this is solved by ensuring that the difference between two floating-point values is less than some threshold. Therefore, a possible implementation for such a function could be as follows:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">bool are_equal(T const&amp; a, T const&amp; b)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   if constexpr (std::is_floating_point_v&lt;T&gt;)</pre>
			<pre class="source-code">      return std::abs(a - b) &lt; 0.001;</pre>
			<pre class="source-code">   else</pre>
			<pre class="source-code">      return a == b;</pre>
			<pre class="source-code">}</pre>
			<p>When the <code>T</code> type is a floating-point type, we compare the absolute value of the difference of the two numbers with the selected threshold. Otherwise, we fall back to using <code>operator==</code>. This enables us to use this function not just with arithmetic types, but also any other type for which the equality operator is overloaded.</p>
			<pre class="source-code">are_equal(1, 1);                                   // OK</pre>
			<pre class="source-code">are_equal(1.999998, 1.999997);                     // OK</pre>
			<pre class="source-code">are_equal(std::string{ "1" }, std::string{ "1" }); // OK</pre>
			<pre class="source-code">are_equal(widget{ 1, "one" }, widget{ 1, "two" }); // error</pre>
			<p>We are able to call the <code>are_equal</code> function template with arguments of type <code>int</code>, <code>double</code>, and <code>std::string</code>. However, attempting to do the same with values of the <code>widget</code> type will trigger a compiler error, because the <code>==</code> operator is not overloaded for this type.</p>
			<p>So far in this <a id="_idIndexMarker452"/>chapter, we have seen what type traits are as well as different ways to perform conditional compilation. We have also seen some of the type traits available in the standard library. In the second part of this chapter, we will explore what the standard has to offer with regard to type traits.</p>
			<h1 id="_idParaDest-80"><a id="_idTextAnchor085"/>Exploring the standard type traits</h1>
			<p>The standard library <a id="_idIndexMarker453"/>features a series of type traits for querying properties of types as well as performing transformations on types. These type traits are available in the <code>&lt;type_traits&gt;</code> header as part of the type support library. There are several categories of type traits including the following:</p>
			<ul>
				<li>Querying the type category (primary or composite)</li>
				<li>Querying type properties</li>
				<li>Querying supported operations</li>
				<li>Querying type relationships</li>
				<li>Modifying cv-specifiers, references, pointers, or a sign</li>
				<li>Miscellaneous transformations</li>
			</ul>
			<p>Although looking at every single type trait is beyond the scope of this book, we will explore all these categories to see what they contain. In the following subsections, we will list the type traits (or most of them) that make up each of these categories. These lists as well as detailed information about each type trait can be found in the C++ standard (see the <em class="italic">Further reading</em> section at the end of the chapter for a link to a freely available draft version) or on the <a href="http://cppreference.com">cppreference.com</a> website at <a href="https://en.cppreference.com/w/cpp/header/type_traits">https://en.cppreference.com/w/cpp/header/type_traits</a> (license usage link: <a href="http://creativecommons.org/licenses/by-sa/3.0/">http://creativecommons.org/licenses/by-sa/3.0/</a>).</p>
			<p>We will start with the type traits for querying the type category.</p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor086"/>Querying the type category</h2>
			<p>Throughout <a id="_idIndexMarker454"/>this book so far, we have used <a id="_idIndexMarker455"/>several type traits, such as <code>std::is_integral</code>, <code>std::is_floating_point</code>, and <code>std::is_arithmetic</code>. These are just some of the standard type traits used for querying primary and composite type categories. The following table lists the entire set of such type traits:</p>
			<div><div><img src="img/B18367_05_Table1.1.jpg" alt="Table 5.1" width="1568" height="1184"/>
				</div>
			</div>
			<div><div><img src="img/B18367_05_Table1.2.jpg" alt="Table 5.1" width="1568" height="1932"/>
				</div>
			</div>
			<div><div><img src="img/B18367_05_Table1.3.jpg" alt="Table 5.1&#13;&#10;" width="1568" height="897"/>
				</div>
			</div>
			<p class="figure-caption">Table 5.1</p>
			<p>All these type <a id="_idIndexMarker456"/>traits are available in C++11. For each <a id="_idIndexMarker457"/>of them, starting with C++17, a variable template is available to simplify the access to the Boolean member called <code>value</code>. For a type trait with the name <code>is_abc</code>, a variable template with the name <code>is_abc_v</code> exists. This is true for all the type traits that have a Boolean member called <code>value</code>. The definition of these variables is very simple. The next snippet shows the definition for the <code>is_arithmentic_v</code> variable template:</p>
			<pre class="source-code">template&lt; class T &gt;</pre>
			<pre class="source-code">inline constexpr bool is_arithmetic_v =</pre>
			<pre class="source-code">   is_arithmetic&lt;T&gt;::value;</pre>
			<p>Here is an example of using some of these type traits:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">std::string as_string(T value)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   if constexpr (std::is_null_pointer_v&lt;T&gt;)</pre>
			<pre class="source-code">      return "null";</pre>
			<pre class="source-code">   else if constexpr (std::is_arithmetic_v&lt;T&gt;)</pre>
			<pre class="source-code">      return std::to_string(value);</pre>
			<pre class="source-code">   else</pre>
			<pre class="source-code">      static_assert(always_false&lt;T&gt;);</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">std::cout &lt;&lt; as_string(nullptr) &lt;&lt; '\n'; // prints null</pre>
			<pre class="source-code">std::cout &lt;&lt; as_string(true) &lt;&lt; '\n';    // prints 1</pre>
			<pre class="source-code">std::cout &lt;&lt; as_string('a') &lt;&lt; '\n';     // prints a</pre>
			<pre class="source-code">std::cout &lt;&lt; as_string(42) &lt;&lt; '\n';      // prints 42</pre>
			<pre class="source-code">std::cout &lt;&lt; as_string(42.0) &lt;&lt; '\n';   // prints 42.000000</pre>
			<pre class="source-code">std::cout &lt;&lt; as_string("42") &lt;&lt; '\n';    // error</pre>
			<p>The function template <code>as_string</code> returns a string containing the value pass as an argument. It <a id="_idIndexMarker458"/>works with arithmetic types only <a id="_idIndexMarker459"/>and with the <code>nullptr_t</code> for which it returns the value <code>"null"</code>.</p>
			<p>You must have noticed the statement, <code>static_assert(always_false&lt;T&gt;)</code>, and wondering what this <code>always_false&lt;T&gt;</code> expression actually is. It is a variable template of the <code>bool</code> type that evaluates to <code>false</code>. Its definition is as simple as the following:</p>
			<pre class="source-code">template&lt;class T&gt; </pre>
			<pre class="source-code">constexpr bool always_false = std::false_type::value;</pre>
			<p>This is needed because the statement, <code>static_assert(false)</code>, would make the program ill-formed. The reason for this is that its condition would not depend on a template argument but evaluate to <code>false</code>. When no valid specialization can be generated for a sub-statement of a <code>constexpr if</code> statement within a template, the program is ill-formed (and no diagnostic is required). To avoid this, the condition of the <code>static_assert</code> statement must depend on a template argument. With <code>static_assert(always_false&lt;T&gt;)</code>, the compiler does not know whether this would evaluate to <code>true</code> or <code>false</code> until the template is instantiated.</p>
			<p>The next category of type traits we explore allows us to query properties of types.</p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor087"/>Querying type properties</h2>
			<p>The type <a id="_idIndexMarker460"/>traits that enable us to query properties of types <a id="_idIndexMarker461"/>are the following:</p>
			<div><div><img src="img/B18367_05_Table2.1.jpg" alt="Table 5.2&#10;" width="1650" height="368"/>
				</div>
			</div>
			<div><div><img src="img/B18367_05_Table2.2.jpg" alt="Table 5.2&#10;" width="1577" height="2241"/>
				</div>
			</div>
			<div><div><img src="img/B18367_05_Table2.3.jpg" alt="Table 5.2&#10;" width="1568" height="749"/>
				</div>
			</div>
			<p class="figure-caption">Table 5.2</p>
			<p>Although most of these are probably straightforward to understand, there are two that seem the <a id="_idIndexMarker462"/>same at a first glance. These are <code>is_trivial</code> and <code>is_trivially_copyable</code>. These both are true for scalar types or arrays of <a id="_idIndexMarker463"/>scalar types. They also are true for classes that are trivially copyable or arrays of such classes but <code>is_trivial</code> is true only for copyable classes that have a trivial default constructor. </p>
			<p>According to the paragraph <em class="italic">§11.4.4.1</em> in the C++ 20 standard, a default constructor is trivial if it is not user-provided, and the class has no virtual member functions, no virtual base classes, no non-static members with default initializers, every direct base of it has a trivial default constructor, and every non-static member of a class type also has a trivial default constructor. To understand this better, let’s look at the following example:</p>
			<pre class="source-code">struct foo</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   int a;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">struct bar</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   int a = 0;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">struct tar</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   int a = 0;</pre>
			<pre class="source-code">   tar() : a(0) {}</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">std::cout &lt;&lt; std::is_trivial_v&lt;foo&gt; &lt;&lt; '\n'; // true</pre>
			<pre class="source-code">std::cout &lt;&lt; std::is_trivial_v&lt;bar&gt; &lt;&lt; '\n'; // false</pre>
			<pre class="source-code">std::cout &lt;&lt; std::is_trivial_v&lt;tar&gt; &lt;&lt; '\n'; // false</pre>
			<pre class="source-code">std::cout &lt;&lt; std::is_trivially_copyable_v&lt;foo&gt; </pre>
			<pre class="source-code">          &lt;&lt; '\n';                                 // true</pre>
			<pre class="source-code">std::cout &lt;&lt; std::is_trivially_copyable_v&lt;bar&gt; </pre>
			<pre class="source-code">          &lt;&lt; '\n';                                 // true</pre>
			<pre class="source-code">std::cout &lt;&lt; std::is_trivially_copyable_v&lt;tar&gt; </pre>
			<pre class="source-code">          &lt;&lt; '\n';                                 // true</pre>
			<p>In this <a id="_idIndexMarker464"/>example, there are three similar classes. All three of <a id="_idIndexMarker465"/>them, <code>foo</code>, <code>bar</code>, and <code>tar</code>, are trivially copyable. However, only the <code>foo</code> class is a trivial class, because it has a trivial default constructor. The <code>bar</code> class has a non-static member with a default initializer, and the <code>tar</code> class has a user-defined constructor, and this makes them non-trivial.</p>
			<p>Apart from trivial copy-ability, there are other operations that we can query for with the help of other type traits. We will see these in the following section.</p>
			<h2 id="_idParaDest-83"><a id="_idTextAnchor088"/>Querying supported operations</h2>
			<p>The following <a id="_idIndexMarker466"/>set of type traits helps us to query supported operations:</p>
			<div><div><img src="img/B18367_05_Table3.1.jpg" alt="Table 5.3&#10;" width="1568" height="716"/>
				</div>
			</div>
			<div><div><img src="img/B18367_05_Table3.2.jpg" alt="Table 5.3&#10;" width="1568" height="1552"/>
				</div>
			</div>
			<p class="figure-caption">Table 5.3</p>
			<p>Except for the last sub-set, which was introduced in C++17, the others are available in C++11. Each <a id="_idIndexMarker467"/>kind of these type traits has multiple variants, including ones for checking operations that are trivial or declared as non-throwing with the <code>noexcept</code> specifier.</p>
			<p>Now let’s look at type traits that allow us to query for relationships between types.</p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor089"/>Querying type relationships</h2>
			<p>In this category, we <a id="_idIndexMarker468"/>can find several type traits that help to <a id="_idIndexMarker469"/>query relationships between types. These type traits are as follows:</p>
			<div><div><img src="img/B18367_05_Table4.jpg" alt="Table 5.4&#10;" width="1568" height="1250"/>
				</div>
			</div>
			<p class="figure-caption">Table 5.4</p>
			<p>Of these type traits, perhaps the most used one is <code>std::is_same</code>. This type trait is very useful in determining whether two types are the same. Keep in mind that this type trait takes into account the <code>const</code> and <code>volatile</code> qualifiers; therefore, <code>int</code> and <code>int const</code>, for instance, are not the same type. </p>
			<p>We can <a id="_idIndexMarker470"/>use this type trait to extend the implementation <a id="_idIndexMarker471"/>of the <code>as_string</code> function shown earlier. Remember that if you called it with the arguments <code>true</code> or <code>false</code> it prints <code>1</code> or <code>0</code>, and not <code>true</code>/<code>false</code>. We can add an explicit check for the <code>bool</code> type and return a string containing one of these two values, shown as follows:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">std::string as_string(T value)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   if constexpr (std::is_null_pointer_v&lt;T&gt;)</pre>
			<pre class="source-code">      return "null";</pre>
			<pre class="source-code">   else if constexpr (std::is_same_v&lt;T, bool&gt;)</pre>
			<pre class="source-code">      return value ? "true" : "false";</pre>
			<pre class="source-code">   else if constexpr (std::is_arithmetic_v&lt;T&gt;)</pre>
			<pre class="source-code">      return std::to_string(value);</pre>
			<pre class="source-code">   else</pre>
			<pre class="source-code">      static_assert(always_false&lt;T&gt;);</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">std::cout &lt;&lt; as_string(true) &lt;&lt; '\n';    // prints true</pre>
			<pre class="source-code">std::cout &lt;&lt; as_string(false) &lt;&lt; '\n';   // prints false</pre>
			<p>All the type <a id="_idIndexMarker472"/>traits seen so far are used to query some kind of <a id="_idIndexMarker473"/>information about types. In the next sections, we will see type traits that perform modifications on types.</p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor090"/>Modifying cv-specifiers, references, pointers, or a sign</h2>
			<p>The type <a id="_idIndexMarker474"/>traits that are performing transformations <a id="_idIndexMarker475"/>on types are also called <a id="_idIndexMarker476"/>metafunctions. These type traits provided a <a id="_idIndexMarker477"/>member type (<code>typedef</code>) called <code>type</code> that represents <a id="_idIndexMarker478"/>the transformed type. This category of type traits includes the following:</p>
			<div><div><img src="img/B18367_05_Table5.1.jpg" alt="Table 5.5&#10;" width="1568" height="677"/>
				</div>
			</div>
			<div><div><img src="img/B18367_05_Table5.2.jpg" alt="Table 5.5&#10;" width="1577" height="864"/>
				</div>
			</div>
			<p class="figure-caption">Table 5.5</p>
			<p>With the <a id="_idIndexMarker479"/>exception of <code>remove_cvref</code>, which <a id="_idIndexMarker480"/>was added in C++20, all the <a id="_idIndexMarker481"/>other type traits listed in this table <a id="_idIndexMarker482"/>are available in C++11. These are not all the metafunctions from the standard library. More are listed in the next section.</p>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor091"/>Miscellaneous transformations</h2>
			<p>Apart from <a id="_idIndexMarker483"/>the metafunctions previously listed, there are other type traits performing type transformations. The most important of these are listed in the following table:</p>
			<div><div><img src="img/B18367_05_Table6.1.jpg" alt="Table 5.6&#13;&#10;" width="1566" height="843"/>
				</div>
			</div>
			<div><div><img src="img/B18367_05_Table6.2.jpg" alt="Table 5.6&#13;&#10;" width="1566" height="581"/>
				</div>
			</div>
			<p class="figure-caption">Table 5.6</p>
			<p>From this list, we have already discussed <code>enable_if</code>. There are some other type traits here that are <a id="_idIndexMarker484"/>worth exemplifying. Let’s first look at <code>std::decay</code> and for this purpose, let’s consider the following slightly changed implementation of the <code>as_string</code> function:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">std::string as_string(T&amp;&amp; value)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   if constexpr (std::is_null_pointer_v&lt;T&gt;)</pre>
			<pre class="source-code">      return "null";</pre>
			<pre class="source-code">   else if constexpr (std::is_same_v&lt;T, bool&gt;)</pre>
			<pre class="source-code">      return value ? "true" : "false";</pre>
			<pre class="source-code">   else if constexpr (std::is_arithmetic_v&lt;T&gt;)</pre>
			<pre class="source-code">      return std::to_string(value);</pre>
			<pre class="source-code">   else</pre>
			<pre class="source-code">      static_assert(always_false&lt;T&gt;);</pre>
			<pre class="source-code">}</pre>
			<p>The only change is the way we pass arguments to the function. Instead of passing by value, we <a id="_idIndexMarker485"/>pass by rvalue reference. If you remember from <a href="B18367_04_ePub.xhtml#_idTextAnchor064"><em class="italic">Chapter 4</em></a>, <em class="italic">Advanced Template Concepts</em>, this is a forwarding reference. We can still make calls passing rvalues (such as literals) but passing lvalues will trigger compiler errors:</p>
			<pre class="source-code">std::cout &lt;&lt; as_string(true) &lt;&lt; '\n';  // OK</pre>
			<pre class="source-code">std::cout &lt;&lt; as_string(42) &lt;&lt; '\n';    // OK</pre>
			<pre class="source-code">bool f = true;</pre>
			<pre class="source-code">std::cout &lt;&lt; as_string(f) &lt;&lt; '\n';     // error</pre>
			<pre class="source-code">int n = 42;</pre>
			<pre class="source-code">std::cout &lt;&lt; as_string(n) &lt;&lt; '\n';     // error</pre>
			<p>The last two calls are triggering the <code>static_assert</code> statement to fail. The actual type template arguments are <code>bool&amp;</code> and <code>int&amp;</code>. Therefore <code>std::is_same&lt;bool, bool&amp;&gt;</code> will initialize the <code>value</code> member with <code>false</code>. Similarly, <code>std::is_arithmetic&lt;int&amp;&gt;</code> will do the same. In order to evaluate these types, we need to ignore references and the <code>const</code> and <code>volatile</code> qualifiers. The type trait that helps us do so is <code>std::decay</code>, which performs several transformations, as described in the previous table. Its conceptual implementation is the following:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct decay</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">private:</pre>
			<pre class="source-code">    using U = typename std::remove_reference_t&lt;T&gt;;</pre>
			<pre class="source-code">public:</pre>
			<pre class="source-code">    using type = typename std::conditional_t&lt; </pre>
			<pre class="source-code">        std::is_array_v&lt;U&gt;,</pre>
			<pre class="source-code">        typename std::remove_extent_t&lt;U&gt;*,</pre>
			<pre class="source-code">        typename std::conditional_t&lt; </pre>
			<pre class="source-code">            std::is_function&lt;U&gt;::value,</pre>
			<pre class="source-code">            typename std::add_pointer_t&lt;U&gt;,</pre>
			<pre class="source-code">            typename std::remove_cv_t&lt;U&gt;</pre>
			<pre class="source-code">        &gt;</pre>
			<pre class="source-code">    &gt;;</pre>
			<pre class="source-code">};</pre>
			<p>From this snippet, we can see that <code>std::decay</code> is implemented with the help of other metafunctions, including <code>std::conditional</code>, which is key for selecting between one type or another based on a compile-time expression. Actually, this type trait is used multiple times, which is something you can do if you need to make a selection based on multiple conditions.</p>
			<p>With the <a id="_idIndexMarker486"/>help of <code>std::decay</code>, we can modify the implementation of the <code>as_string</code> function, stripping reference, and cv-qualifiers:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">std::string as_string(T&amp;&amp; value)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   using value_type = std::decay_t&lt;T&gt;;</pre>
			<pre class="source-code">   if constexpr (std::is_null_pointer_v&lt;value_type&gt;)</pre>
			<pre class="source-code">      return "null";</pre>
			<pre class="source-code">   else if constexpr (std::is_same_v&lt;value_type, bool&gt;)</pre>
			<pre class="source-code">      return value ? "true" : "false";</pre>
			<pre class="source-code">   else if constexpr (std::is_arithmetic_v&lt;value_type&gt;)</pre>
			<pre class="source-code">      return std::to_string(value);</pre>
			<pre class="source-code">   else</pre>
			<pre class="source-code">      static_assert(always_false&lt;T&gt;);</pre>
			<pre class="source-code">}</pre>
			<p>By changing the implementation as shown here, we made the previous calls to <code>as_string</code> that failed to compile without any more errors.</p>
			<p>In the implementation of <code>std::decay</code> we saw the repetitive use of <code>std::conditional</code>. This is a metafunction that is fairly easy to use and can help to simplify many implementations. In <a href="B18367_02_ePub.xhtml#_idTextAnchor024"><em class="italic">Chapter 2</em></a>, <em class="italic">Template Fundamentals</em>, in the section <em class="italic">Defining alias templates</em>, we saw an example where we built a list type called <code>list_t</code>. This had a member alias template called <code>type</code> that was aliasing either the template <a id="_idIndexMarker487"/>type <code>T</code>, if the size of the list was <code>1</code>, or <code>std::vector&lt;T&gt;</code>, if it was higher. Let’s look at the snippet again:</p>
			<pre class="source-code">template &lt;typename T, size_t S&gt;</pre>
			<pre class="source-code">struct list</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   using type = std::vector&lt;T&gt;;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct list&lt;T, 1&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   using type = T;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;typename T, size_t S&gt;</pre>
			<pre class="source-code">using list_t = typename list&lt;T, S&gt;::type;</pre>
			<p>This implementation can be greatly simplified with the help of <code>std::conditional</code> as follows:</p>
			<pre class="source-code">template &lt;typename T, size_t S&gt;</pre>
			<pre class="source-code">using list_t = </pre>
			<pre class="source-code">   typename std::conditional&lt;S == </pre>
			<pre class="source-code">                 1, T, std::vector&lt;T&gt;&gt;::type;</pre>
			<p>There is no need to rely on class template specialization to define such a list type. The entire solution can be reduced to defining an alias template. We can verify this works as expected with some <code>static_assert</code> statements, as follows:</p>
			<pre class="source-code">static_assert(std::is_same_v&lt;list_t&lt;int, 1&gt;, int&gt;);</pre>
			<pre class="source-code">static_assert(std::is_same_v&lt;list_t&lt;int, 2&gt;,</pre>
			<pre class="source-code">                             std::vector&lt;int&gt;&gt;);</pre>
			<p>Exemplifying the <a id="_idIndexMarker488"/>use of each of the standard type traits is beyond the scope of this book. However, the next section of this chapter provides more complex examples that require the use of several standard type traits.</p>
			<h1 id="_idParaDest-87"><a id="_idTextAnchor092"/>Seeing real-world examples of using type traits</h1>
			<p>In the previous section of the chapter, we have explored the various type traits that the standard library <a id="_idIndexMarker489"/>provides. It is difficult and unnecessary to find examples for each and every type trait. However, it is worth showcasing some examples where multiple type traits can be used for solving a problem. We will do this next.</p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor093"/>Implementing a copy algorithm</h2>
			<p>The first example problem we will take a look at is a possible implementation for the <code>std::copy</code> standard <a id="_idIndexMarker490"/>algorithm (from the <code>&lt;algorithm&gt;</code> header). Keep in mind that what we will see next is not the actual implementation <a id="_idIndexMarker491"/>but a possible one that helps us learn more about the use of type traits. The signature of this algorithm is as follows:</p>
			<pre class="source-code">template &lt;typename InputIt, typename OutputIt&gt;</pre>
			<pre class="source-code">constexpr OutputIt copy(InputIt first, InputIt last,</pre>
			<pre class="source-code">                        OutputIt d_first);</pre>
			<p>As a note, this function is <code>constexpr</code> only in C++20, but we can discuss it in this context. What it does is copy all the elements in the range [<code>first</code>, <code>last</code>) to another range that begins with <code>d_first</code>. There is also an overload that takes an execution policy, and a version, <code>std::copy_if</code>, that copies all the elements that match a predicate, but <a id="_idIndexMarker492"/>these are not important for our example. A <a id="_idIndexMarker493"/>straightforward implementation of this function is the following:</p>
			<pre class="source-code">template &lt;typename InputIt, typename OutputIt&gt;</pre>
			<pre class="source-code">constexpr OutputIt copy(InputIt first, InputIt last,</pre>
			<pre class="source-code">                        OutputIt d_first)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   while (first != last)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      *d_first++ = *first++;</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   return d_first;</pre>
			<pre class="source-code">}</pre>
			<p>However, there are cases when this implementation can be optimized by simply copying memory. However, there are some conditions that must be met for this purpose:</p>
			<ul>
				<li>Both iterator types, <code>InputIt</code> and <code>OutputIt</code>, must be pointers.</li>
				<li>Both template parameters, <code>InputIt</code> and <code>OutputIt</code>, must point to the same type (ignoring cv-qualifiers).</li>
				<li>The type pointed by <code>InputIt</code> must have a trivial copy assignment operator.</li>
			</ul>
			<p>We can check these conditions with the following standard type traits:</p>
			<ul>
				<li><code>std::is_same</code> (and the <code>std::is_same_v</code> variable) to check that two types are the same.</li>
				<li><code>std::is_pointer</code> (and the <code>std::is_pointer_v</code> variable) to check that a type is a pointer type.</li>
				<li><code>std::is_trivially_copy_assignable</code> (and the <code>std::is_trivially_copy_assignable_v</code> variable) to check whether a type has a trivial copy assignment operator.</li>
				<li><code>std::remove_cv</code> (and the <code>std::remove_cv_t</code> alias template) to remove cv-qualifiers from a type.</li>
			</ul>
			<p>Let’s see how we can implement this. First, we need to have a primary template with the generic <a id="_idIndexMarker494"/>implementation, and then a specialization <a id="_idIndexMarker495"/>for pointer types with the optimized implementation. We can do this using class templates with member function templates as shown next:</p>
			<pre class="source-code">namespace detail</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   template &lt;bool b&gt;</pre>
			<pre class="source-code">   struct copy_fn</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      template&lt;typename InputIt, typename OutputIt&gt;</pre>
			<pre class="source-code">      constexpr static OutputIt copy(InputIt first, </pre>
			<pre class="source-code">                                     InputIt last, </pre>
			<pre class="source-code">                                     OutputIt d_first)</pre>
			<pre class="source-code">      {</pre>
			<pre class="source-code">         while (first != last)</pre>
			<pre class="source-code">         {</pre>
			<pre class="source-code">            *d_first++ = *first++;</pre>
			<pre class="source-code">         }</pre>
			<pre class="source-code">         return d_first;</pre>
			<pre class="source-code">      }</pre>
			<pre class="source-code">   };</pre>
			<pre class="source-code">   template &lt;&gt;</pre>
			<pre class="source-code">   struct copy_fn&lt;true&gt;</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      template&lt;typename InputIt, typename OutputIt&gt;</pre>
			<pre class="source-code">      constexpr static OutputIt* copy(</pre>
			<pre class="source-code">         InputIt* first, InputIt* last,</pre>
			<pre class="source-code">         OutputIt* d_first)</pre>
			<pre class="source-code">      {</pre>
			<pre class="source-code">         std::memmove(d_first, first, </pre>
			<pre class="source-code">                      (last - first) * sizeof(InputIt));</pre>
			<pre class="source-code">         return d_first + (last - first);</pre>
			<pre class="source-code">      }</pre>
			<pre class="source-code">   };</pre>
			<pre class="source-code">}</pre>
			<p>To copy memory between a source and a destination we use <code>std::memmove</code> here, which <a id="_idIndexMarker496"/>copies data even if objects overlap. These implementations <a id="_idIndexMarker497"/>are provided in a namespace called <code>detail</code>, because they are implementation details that are used in turn by the <code>copy</code> function and not directly by the user. The implementation of this generic <code>copy</code> algorithm could be as follows:</p>
			<pre class="source-code">template&lt;typename InputIt, typename OutputIt&gt;</pre>
			<pre class="source-code">constexpr OutputIt copy(InputIt first, InputIt last, </pre>
			<pre class="source-code">                        OutputIt d_first)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   using input_type = std::remove_cv_t&lt;</pre>
			<pre class="source-code">      typename std::iterator_traits&lt;InputIt&gt;::value_type&gt;;</pre>
			<pre class="source-code">   using output_type = std::remove_cv_t&lt;</pre>
			<pre class="source-code">      typename std::iterator_traits&lt;OutputIt&gt;::value_type&gt;;</pre>
			<pre class="source-code">   constexpr bool opt =</pre>
			<pre class="source-code">      std::is_same_v&lt;input_type, output_type&gt; &amp;&amp;</pre>
			<pre class="source-code">      std::is_pointer_v&lt;InputIt&gt; &amp;&amp;</pre>
			<pre class="source-code">      std::is_pointer_v&lt;OutputIt&gt; &amp;&amp;</pre>
			<pre class="source-code">      std::is_trivially_copy_assignable_v&lt;input_type&gt;;</pre>
			<pre class="source-code">   return detail::copy_fn&lt;opt&gt;::copy(first, last, d_first);</pre>
			<pre class="source-code">}</pre>
			<p>You can see here <a id="_idIndexMarker498"/>that the decision to select one specialization <a id="_idIndexMarker499"/>or the other is based on a <code>constexpr</code> Boolean value that is determined using the aforementioned type traits. Examples of using this <code>copy</code> function are shown in the next snippet:</p>
			<pre class="source-code">std::vector&lt;int&gt; v1{ 1, 2, 3, 4, 5 };</pre>
			<pre class="source-code">std::vector&lt;int&gt; v2(5);</pre>
			<pre class="source-code">// calls the generic implementation</pre>
			<pre class="source-code">copy(std::begin(v1), std::end(v1), std::begin(v2));</pre>
			<pre class="source-code">int a1[5] = { 1,2,3,4,5 };</pre>
			<pre class="source-code">int a2[5];</pre>
			<pre class="source-code">// calls the optimized implementation</pre>
			<pre class="source-code">copy(a1, a1 + 5, a2);</pre>
			<p>Keep in mind that this is not the real definition of the generic algorithm <code>copy</code> you will find in standard library implementations, which are further optimized. However, this was a good example to demonstrate how to use type traits for a real-world problem. </p>
			<p>For simplicity, I have defined the <code>copy</code> function in what appears to be the global namespace. This is a <a id="_idIndexMarker500"/>bad practice. In general, code, especially <a id="_idIndexMarker501"/>in libraries, is grouped in namespaces. In the source code on GitHub that accompanies the book, you will find this function defined in a namespace called <code>n520</code> (this is just a unique name, nothing relevant to the topic). When calling the <code>copy</code> function that we have defined, we would actually need to use the fully qualified name (that includes the namespace name) such as the following:</p>
			<pre class="source-code">n520::copy(std::begin(v1), std::end(v1), std::begin(v2));</pre>
			<p>Without this qualification, a process called <code>copy</code> to the <code>std::copy</code> function because the arguments we pass are found <a id="_idIndexMarker503"/>in the <code>std</code> namespace. You can read more about ADL at <a href="https://en.cppreference.com/w/cpp/language/adl">https://en.cppreference.com/w/cpp/language/adl</a>.</p>
			<p>Now, let’s look at another example.</p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor094"/>Building a homogenous variadic function template</h2>
			<p>For the <a id="_idIndexMarker504"/>second example, we want to <a id="_idIndexMarker505"/>build a variadic function template that can only take arguments of the same type or types that can be implicitly converted to a common one. Let’s start with the following skeleton definition:</p>
			<pre class="source-code">template&lt;typename... Ts&gt;</pre>
			<pre class="source-code">void process(Ts&amp;&amp;... ts) {}</pre>
			<p>The problem with this is that all of the following function calls work (keep in mind that the body of this function is empty so there will be no errors due to performing operations unavailable on some types):</p>
			<pre class="source-code">process(1, 2, 3);</pre>
			<pre class="source-code">process(1, 2.0, '3');</pre>
			<pre class="source-code">process(1, 2.0, "3");</pre>
			<p>In the first example, we pass three <code>int</code> values. In the second example, we pass an <code>int</code>, a <code>double</code>, and a <code>char</code>; both <code>int</code> and <code>char</code> are implicitly convertible to <code>double</code>, so this should be all right. However, in the third example, we pass an <code>int</code>, a <code>double</code>, and a <code>char const*</code>, and this last type is not implicitly convertible to either <code>int</code> or <code>double</code>. Therefore, this last call is supposed to trigger a compiler error but does not.</p>
			<p>In order to do so, we need to ensure that when a common type for the function arguments is not available, the compiler will generate an error. To do so, we can use a <code>static_assert</code> statement or <code>std::enable_if</code> and SFINAE. However, we do need to figure out whether a common type exists or not. This is possible with the help of the <code>std::common_type</code> type trait.</p>
			<p>The <code>std::common_type</code> is a metafunction that defines the common type among all of its type arguments that all the types can be implicitly converted to. Therefore <code>std::common_type&lt;int, double, char&gt;::type</code> will alias the <code>double</code> type. Using this <a id="_idIndexMarker506"/>type trait, we can build <a id="_idIndexMarker507"/>another type trait that tells us whether a common type exists. A possible implementation is as follows:</p>
			<pre class="source-code">template &lt;typename, typename... Ts&gt;</pre>
			<pre class="source-code">struct has_common_type : std::false_type {};</pre>
			<pre class="source-code">template &lt;typename... Ts&gt;</pre>
			<pre class="source-code">struct has_common_type&lt;</pre>
			<pre class="source-code">          std::void_t&lt;std::common_type_t&lt;Ts...&gt;&gt;, </pre>
			<pre class="source-code">          Ts...&gt;</pre>
			<pre class="source-code">   : std::true_type {};</pre>
			<pre class="source-code">template &lt;typename... Ts&gt;</pre>
			<pre class="source-code">constexpr bool has_common_type_v =</pre>
			<pre class="source-code">   sizeof...(Ts) &lt; 2 ||</pre>
			<pre class="source-code">   has_common_type&lt;void, Ts...&gt;::value;</pre>
			<p>You can see in this snippet that we base the implementation on several other type traits. First, there is the <code>std::false_type</code> and <code>std::true_type</code> pair. These are type aliases for <code>std::bool_constant&lt;false&gt;</code> and <code>std::bool_constant&lt;true&gt;</code> respectively. The <code>std::bool_constant</code> class is available in C++17 and is, in turn, an alias template for a specialization of the <code>std::integral_constant</code> class for the <code>bool</code> type. This last class template wraps a static <a id="_idIndexMarker508"/>constant of the specified <a id="_idIndexMarker509"/>type. Its conceptual implementation looks as follows (although some operations are also provided):</p>
			<pre class="source-code">template&lt;class T, T v&gt;</pre>
			<pre class="source-code">struct integral_constant</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   static constexpr T value = v;</pre>
			<pre class="source-code">   using value_type = T;</pre>
			<pre class="source-code">};</pre>
			<p>This helps us simplify the definition of type traits that need to define a Boolean compile-time value, as we saw in several cases in this chapter. </p>
			<p>A third type trait used in the implementation of the <code>has_common_type</code> class is <code>std::void_t</code>. This type trait defines a mapping between a variable number of types and the <code>void</code> type. We use this to build a mapping between the common type, if one exists, and the <code>void</code> type. This enables us to leverage SFINAE for the specialization of the <code>has_common_type</code> class template.</p>
			<p>Finally, a variable template called <code>has_common_type_v</code> is defined to ease the use of the <code>has_common_type</code> trait. </p>
			<p>All these can be used to modify the definition of the <code>process</code> function template to ensure it only allows arguments of a common type. A possible implementation is shown next:</p>
			<pre class="source-code">template&lt;typename... Ts,</pre>
			<pre class="source-code">         typename = std::enable_if_t&lt;</pre>
			<pre class="source-code">                       has_common_type_v&lt;Ts...&gt;&gt;&gt;</pre>
			<pre class="source-code">void process(Ts&amp;&amp;... ts) </pre>
			<pre class="source-code">{ }</pre>
			<p>As a result of this, calls such as <code>process(1, 2.0, "3")</code> will produce a compiler error because there is no overloaded <code>process</code> function for this set of arguments.</p>
			<p>As previously <a id="_idIndexMarker510"/>mentioned, there are different <a id="_idIndexMarker511"/>ways to use the <code>has_common_type</code> trait to achieve the defined goal. One of these, using <code>std::enable_if</code>, was shown here, but we can also use <code>static_assert</code>. However, a much better approach can be taken with the use of concepts, which we will see in the next chapter.</p>
			<h1 id="_idParaDest-90"><a id="_idTextAnchor095"/>Summary</h1>
			<p>This chapter explored the concept of type traits, which are small classes that define meta-information about types or transformation operations for types. We started by looking at how type traits can be implemented and how they help us. Next, we learned about <strong class="bold">SFINAE</strong>, which stands for <strong class="bold">Substitution Failure Is Not An Error</strong>. This is a technique that enables us to provide constraints for template parameters.</p>
			<p>We then saw how this purpose can be achieved better with <code>enable_if</code> and <code>constexpr if</code>, in C++17. In the second part of the chapter, we looked at the type traits available in the standard library and demonstrated how to use some of them. We ended the chapter with a couple of real-world examples where we used multiple type traits to solve a particular problem.</p>
			<p>In the next chapter, we continue the topic of constraining the template parameters by learning about the C++20 concepts and constraints.</p>
			<h1 id="_idParaDest-91"><a id="_idTextAnchor096"/>Questions</h1>
			<ol>
				<li>What are type traits?</li>
				<li>What is SFINAE?</li>
				<li>What is <code>constexpr if</code>?</li>
				<li>What does <code>std::is_same</code> do?</li>
				<li>What does <code>std::conditional</code> do?</li>
			</ol>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor097"/>Further reading</h1>
			<ul>
				<li><em class="italic">C++ Type traits</em>, John Maddock and Steve Cleary, <a href="https://cs.brown.edu/~jwicks/boost/libs/type_traits/cxx_type_traits.htm">https://cs.brown.edu/~jwicks/boost/libs/type_traits/cxx_type_traits.htm</a></li>
				<li><em class="italic">N4861 Post-Prague 2020 C++ working draft</em>, <a href="https://github.com/cplusplus/draft/releases/tag/n4861">https://github.com/cplusplus/draft/releases/tag/n4861</a></li>
				<li><em class="italic">What is ADL?</em>, Arthur O’Dwyer, <a href="https://quuxplusone.github.io/blog/2019/04/26/what-is-adl/">https://quuxplusone.github.io/blog/2019/04/26/what-is-adl/</a></li>
			</ul>
		</div>
	</div></body></html>