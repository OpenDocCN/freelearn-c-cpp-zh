<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer030">
			<h1 id="_idParaDest-75"><em class="italic"><a id="_idTextAnchor080"/>Chapter 5</em>: Type Traits and Conditional Compilation</h1>
			<p><strong class="bold">Type traits</strong> are an important metaprogramming technique that enables us to inspect properties of types or to perform transformations of types at compile-time. Type traits are themselves templates and you can see them as meta-types. Knowing information such as the nature of a type, its supported operations, and its various properties is key for performing conditional compilation of templated code. It is also very useful when writing a library of templates.</p>
			<p>In this chapter, you will learn the following:</p>
			<ul>
				<li>Understanding and defining type traits </li>
				<li>Understanding SFINAE and its purpose</li>
				<li>Enabling SFINAE with the <strong class="source-inline">enable_if</strong> type trait</li>
				<li>Using <strong class="source-inline">constexpr if</strong></li>
				<li>Exploring the standard type traits</li>
				<li>Seeing real-world examples of using type traits</li>
			</ul>
			<p>By the end of the chapter, you will have a good understanding of what type traits are, how they are useful, and what type traits are available in the <strong class="bold">C++</strong> standard library.</p>
			<p>We will start the chapter by looking at what type traits are and how they help us.</p>
			<h1 id="_idParaDest-76"><a id="_idTextAnchor081"/>Understanding and defining type traits </h1>
			<p>In a nutshell, <strong class="bold">type traits</strong> are small <a id="_idIndexMarker400"/>class templates that contain a constant value whose value represents the answer to a question we ask about a type. An example of such a question is: is this type a floating-point type? The technique for building type traits that provide such information about types relies on template specialization: we define a primary template as well as one or more specializations. </p>
			<p>Let’s see how we <a id="_idIndexMarker401"/>can build a type trait that tells us, at compile-time, whether a type is a floating-point type:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct is_floating_point</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   static const bool value = false;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;&gt;</pre>
			<pre class="source-code">struct is_floating_point&lt;float&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   static const bool value = true;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;&gt;</pre>
			<pre class="source-code">struct is_floating_point&lt;double&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   static const bool value = true;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;&gt;</pre>
			<pre class="source-code">struct is_floating_point&lt;long double&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   static const bool value = true;</pre>
			<pre class="source-code">};</pre>
			<p>There are two things to notice here:</p>
			<ul>
				<li>We have defined a primary template as well as several full specializations, one for each type that is a floating-point type.</li>
				<li>The primary template has a <strong class="source-inline">static const</strong> Boolean member initialized with the <strong class="source-inline">false</strong> value; the full specializations set the value of this member to <strong class="source-inline">true</strong>.</li>
			</ul>
			<p>There is nothing more to <a id="_idIndexMarker402"/>building a type trait than this. <strong class="source-inline">is_floating_point&lt;T&gt;</strong> is a type trait that tells us whether a type is a floating-point type or not. We can use it as follows:</p>
			<pre class="source-code">int main()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   static_assert(is_floating_point&lt;float&gt;::value);</pre>
			<pre class="source-code">   static_assert(is_floating_point&lt;double&gt;::value);</pre>
			<pre class="source-code">   static_assert(is_floating_point&lt;long double&gt;::value);</pre>
			<pre class="source-code">   static_assert(!is_floating_point&lt;int&gt;::value);</pre>
			<pre class="source-code">   static_assert(!is_floating_point&lt;bool&gt;::value);</pre>
			<pre class="source-code">}</pre>
			<p>This proves that we have built the type trait correctly. But it does not show a real use-case scenario. For this type trait to be really useful, we need to use it at compile-time to do something with the information it provides. </p>
			<p>Let’s suppose we want to build a function that does something with a floating-point value. There are multiple floating-point types, such as <strong class="source-inline">float</strong>, <strong class="source-inline">double</strong>, and <strong class="source-inline">long double</strong>. For us to avoid writing multiple implementations, we would build this as a template function. However, that means we could actually pass other types as template arguments, so we need a way to prevent that. A simple solution is to use the <strong class="source-inline">static_assert()</strong> statement we saw earlier and produce an error should the user supply a value that is not a floating-point value. This can look as follows:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">void process_real_number(T const value)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   static_assert(is_floating_point&lt;T&gt;::value);</pre>
			<pre class="source-code">   std::cout &lt;&lt; "processing a real number: " &lt;&lt; value </pre>
			<pre class="source-code">             &lt;&lt; '\n';</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">int main()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   process_real_number(42.0);</pre>
			<pre class="source-code">   process_real_number(42); // error: </pre>
			<pre class="source-code">                            // static assertion failed</pre>
			<pre class="source-code">}</pre>
			<p>This is a really simple example but it demonstrates the use of type traits to do conditional compilation. There are other approaches than using <strong class="source-inline">static_assert()</strong> and we will explore them throughout this chapter. For the time being, let’s look at a second example.</p>
			<p>Suppose we have classes that define operations for writing to an output stream. This is basically a form of <a id="_idIndexMarker403"/>serialization. However, some support this with an overloaded <strong class="source-inline">operator&lt;&lt;</strong>, others with the help of a member function called <strong class="source-inline">write</strong>. The following listing shows two such classes:</p>
			<pre class="source-code">struct widget</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   int         id;</pre>
			<pre class="source-code">   std::string name;</pre>
			<pre class="source-code">   std::ostream&amp; write(std::ostream&amp; os) const</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      os &lt;&lt; id &lt;&lt; ',' &lt;&lt; name &lt;&lt; '\n';</pre>
			<pre class="source-code">      return os;</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">struct gadget</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   int         id;</pre>
			<pre class="source-code">   std::string name;</pre>
			<pre class="source-code">   friend std::ostream&amp; operator &lt;&lt;(std::ostream&amp; os, </pre>
			<pre class="source-code">                                    gadget const&amp; o);</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">std::ostream&amp; operator &lt;&lt;(std::ostream&amp; os, </pre>
			<pre class="source-code">                          gadget const&amp; o)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   os &lt;&lt; o.id &lt;&lt; ',' &lt;&lt; o.name &lt;&lt; '\n';</pre>
			<pre class="source-code">   return os;</pre>
			<pre class="source-code">}</pre>
			<p>In this example, the <strong class="source-inline">widget</strong> class contains a member function, <strong class="source-inline">write</strong>. However, for the <strong class="source-inline">gadget</strong> class, the stream <a id="_idIndexMarker404"/>operator, <strong class="source-inline">&lt;&lt;</strong>, is overloaded for the same purpose. We can write the following code using these classes:</p>
			<pre class="source-code">widget w{ 1, "one" };</pre>
			<pre class="source-code">w.write(std::cout);</pre>
			<pre class="source-code">gadget g{ 2, "two" };</pre>
			<pre class="source-code">std::cout &lt;&lt; g;</pre>
			<p>However, our goal would be to define a function template that enables us to treat them the same way. In other words, instead of using either <strong class="source-inline">write</strong> or the <strong class="source-inline">&lt;&lt;</strong> operator, we should be able to write the following:</p>
			<pre class="source-code">serialize(std::cout, w);</pre>
			<pre class="source-code">serialize(std::cout, g);</pre>
			<p>This brings up some questions. First, how would such a function template look, and second, how can we know whether a type provides a <strong class="source-inline">write</strong> method or has the <strong class="source-inline">&lt;&lt;</strong> operator overloaded? The answer <a id="_idIndexMarker405"/>to the second question is type traits. We can build a type trait to help us answer this latter question at compile-time. This is how such a type trait may look:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct uses_write</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   static constexpr bool value = false;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;&gt;</pre>
			<pre class="source-code">struct uses_write&lt;widget&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   static constexpr bool value = true;</pre>
			<pre class="source-code">};</pre>
			<p>This is very similar to the type trait we defined previously. <strong class="source-inline">uses_write</strong> tells us whether a type defines the <strong class="source-inline">write</strong> member function. The primary template sets the data member called <strong class="source-inline">value</strong> to <strong class="source-inline">false</strong>, but the full specialization for the <strong class="source-inline">widget</strong> class sets it to <strong class="source-inline">true</strong>. In order to avoid the verbose syntax <strong class="source-inline">uses_write&lt;T&gt;::value</strong>, we can also define a variable template, reducing the syntax to the form <strong class="source-inline">uses_write_v&lt;T&gt;</strong>. This variable template will look as follows:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">inline constexpr bool uses_write_v = uses_write&lt;T&gt;::value;</pre>
			<p>To make the exercise simple, we’ll assume that the types that don’t provide a <strong class="source-inline">write</strong> member function overload the output stream operator. In practice, this is would not be the case, but for the sake of simplicity, we will build on this assumption.</p>
			<p>The next step in defining the function template <strong class="source-inline">serialize</strong> that provides a uniform API for serializing all classes is to <a id="_idIndexMarker406"/>define more class templates. However, these would follow the same path – a primary template that provides one form of serialization and a full specialization that provides a different form. Here is the code for it:</p>
			<pre class="source-code">template &lt;bool&gt;</pre>
			<pre class="source-code">struct serializer</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   template &lt;typename T&gt;</pre>
			<pre class="source-code">   static void serialize(std::ostream&amp; os, T const&amp; value)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      os &lt;&lt; value;</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template&lt;&gt;</pre>
			<pre class="source-code">struct serializer&lt;true&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   template &lt;typename T&gt;</pre>
			<pre class="source-code">   static void serialize(std::ostream&amp; os, T const&amp; value)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      value.write(os);</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<p>The <strong class="source-inline">serializer</strong> class template has a single template parameter, which is a non-type template parameter. It is also <a id="_idIndexMarker407"/>an anonymous template parameter because we don’t use it anywhere in the implementation. This class template contains a single member function. It is actually a member function template with a single type template parameter. This parameter defines the type of value we would serialize. The primary template uses the <strong class="source-inline">&lt;&lt;</strong> operator to output the value to the provided stream. On the other hand, the full specialization of the <strong class="source-inline">serializer</strong> class template uses the member function <strong class="source-inline">write</strong> to do the same. Notice that we fully specialize the <strong class="source-inline">serializer</strong> class template and not the <strong class="source-inline">serialize</strong> member function template.</p>
			<p>The only thing left now is to implement the desired free function <strong class="source-inline">serialize</strong>. Its implementation will be based <a id="_idIndexMarker408"/>on the <strong class="source-inline">serializer&lt;T&gt;::serialize</strong> function. Let’s see how:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">void serialize(std::ostream&amp; os, T const&amp; value)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   serializer&lt;uses_write_v&lt;T&gt;&gt;::serialize(os, value);</pre>
			<pre class="source-code">}</pre>
			<p>The signature of this function template is the same as the one of the <strong class="source-inline">serialize</strong> member function from the <strong class="source-inline">serializer</strong> class template. The selection between the primary template and the full specialization is done with the help of the variable template <strong class="source-inline">uses_write_v</strong>, which provides a convenient way to access the value data member of the <strong class="source-inline">uses_write</strong> type trait.</p>
			<p>In these examples, we have seen how to implement type traits and use the information they provide at compile-time to either impose restrictions on types or select between one implementation <a id="_idIndexMarker409"/>or the other. A similar purpose has another metaprogramming technique called <strong class="bold">SFINAE</strong>, which we will cover next.</p>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor082"/>Exploring SFINAE and its purpose</h1>
			<p>When we write templates, we sometimes need to restrict the template arguments. For instance, we have a function template that should work for any numeric type, therefore integral and floating-point, but <a id="_idIndexMarker410"/>should not work with anything else. Or we may have a class template that should only accept trivial types for an argument.</p>
			<p>There are also cases when we may have overloaded function templates that should each work with some types only. For instance, one overload should work for integral types and the other for floating-point types only. There are different ways to achieve this goal and we will explore them in this chapter and the next. </p>
			<p>Type traits, however, are involved in one way or another in all of them. The first one that will be discussed in this chapter is a feature called SFINAE. Another approach, superior to SFINAE, is represented by concepts, which will be discussed in the next chapter.</p>
			<p><strong class="bold">SFINAE</strong> stands for <strong class="bold">Substitution Failure Is Not An Error</strong>. When the compiler encounters the use of a function template, it substitutes the arguments in order to instantiate the template. If an error occurs at this point, it is not regarded as ill-informed code, only as a deduction failure. The function is removed from the overload set instead of causing an error. Only if there is no match in the overload set does an error occur.</p>
			<p>It’s difficult to really understand SFINAE without concrete examples. Therefore, we will go through several examples to explain the concept.</p>
			<p>Every standard container, such as <strong class="source-inline">std::vector</strong>, <strong class="source-inline">std::array</strong>, and <strong class="source-inline">std::map</strong>, not only has iterators that <a id="_idIndexMarker411"/>enable us to access its elements but also modify the container (such as inserting after the element pointed by an iterator). Therefore, these containers have member functions to return iterators to the first and the one-past-last elements of the container. These methods are called <strong class="source-inline">begin</strong> and <strong class="source-inline">end</strong>.</p>
			<p>There are other methods such as <strong class="source-inline">cbegin</strong> and <strong class="source-inline">cend</strong>, <strong class="source-inline">rbegin</strong> and <strong class="source-inline">rend</strong>, and <strong class="source-inline">crbegin</strong> and <strong class="source-inline">crend</strong> but these are beyond the purpose of this topic. In C++11, there are also free functions, <strong class="source-inline">std:begin</strong> and <strong class="source-inline">std::end</strong>, that do the same. However, these work not just with standard containers but also with arrays. One benefit of these is enabling range-based <strong class="source-inline">for</strong> loops for arrays. The question is how this non-member function could be implemented to work with both containers and arrays? Certainly, we need two overloads of a function template. A possible implementation is the following:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">auto begin(T&amp; c) { return c.begin(); }   // [1]</pre>
			<pre class="source-code">template &lt;typename T, size_t N&gt;</pre>
			<pre class="source-code">T* begin(T(&amp;arr)[N]) {return arr; }      // [2]</pre>
			<p>The first overload calls the member function <strong class="source-inline">begin</strong> and returns the value. Therefore, this <a id="_idIndexMarker412"/>overload is restricted to types that have <a id="_idIndexMarker413"/>a member function <strong class="source-inline">begin</strong>; otherwise, a compiler error would occur. The second overload simply returns a pointer to the first element of the array. This is restricted to array types; anything else would produce a compiler error. We can use these overloads as follows:</p>
			<pre class="source-code">std::array&lt;int, 5&gt; arr1{ 1,2,3,4,5 };</pre>
			<pre class="source-code">std::cout &lt;&lt; *begin(arr1) &lt;&lt; '\n';       // [3] prints 1</pre>
			<pre class="source-code">int arr2[]{ 5,4,3,2,1 };</pre>
			<pre class="source-code">std::cout &lt;&lt; *begin(arr2) &lt;&lt; '\n';       // [4] prints 5</pre>
			<p>If you compile this piece of code, no error, not even a warning, occurs. The reason for that is SFINAE. When resolving the call to <strong class="source-inline">begin(arr1)</strong>, substituting <strong class="source-inline">std::array&lt;int, 5&gt;</strong> to the first overload (at <strong class="source-inline">[1]</strong>) succeeds, but the substitution for the second (at <strong class="source-inline">[2]</strong>) fails. Instead of issuing an error at this point, the compiler just ignores it, so it builds an overload set with a single instantiation and, therefore, it can successfully find a match for the invocation. Similarly, when resolving the call to <strong class="source-inline">begin(arr2)</strong>, the substitution of <strong class="source-inline">int[5]</strong> for the first overload fails and is ignored, but it succeeds for the second and is added to the overload set, eventually finding a good match for the invocation. Therefore, both calls can be successfully made. Should one of the two overloads not be present, either <strong class="source-inline">begin(arr1)</strong> or <strong class="source-inline">begin(arr2)</strong> would fail to match the function template and a compiler error would occur.</p>
			<p>SFINAE only applies in the so-called <strong class="bold">immediate context</strong> of a function. The immediate context is basically the <a id="_idIndexMarker414"/>template declaration (including the template parameter list, the function return type, and the function parameter list). Therefore, it does not apply to the body of a function. Let’s consider the following example:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">void increment(T&amp; val) { val++; }</pre>
			<pre class="source-code">int a = 42;</pre>
			<pre class="source-code">increment(a);  // OK</pre>
			<pre class="source-code">std::string s{ "42" };</pre>
			<pre class="source-code">increment(s);  // error</pre>
			<p>There are no restrictions on the type <strong class="source-inline">T</strong> in the immediate context of the <strong class="source-inline">increment</strong> function <a id="_idIndexMarker415"/>template. However, in the body <a id="_idIndexMarker416"/>of the function, the parameter <strong class="source-inline">val</strong> is incremented with the post-fix <strong class="source-inline">operator++</strong>. That means, substituting for <strong class="source-inline">T</strong> any type for which the post-fix <strong class="source-inline">operator++</strong> is not implemented is a failure. However, this failure is an error and will not be ignored by the compiler.</p>
			<p>The C++ standard (license usage link: <a href="http://creativecommons.org/licenses/by-sa/3.0/">http://creativecommons.org/licenses/by-sa/3.0/</a>) defines the list of errors that are considered SFINAE errors (in paragraph <em class="italic">§13.10.2</em>, <em class="italic">Template argument deduction</em>, the <strong class="bold">C++20</strong> standard version). These SFINAE errors are the following attempts:</p>
			<ul>
				<li>Creating an array of <strong class="source-inline">void</strong>, an array of reference, an array of function, an array of negative size, an array of size zero, and an array of non-integral size</li>
				<li>Using a type that is not a class or enum on the left side of the scope resolution operator <strong class="source-inline">::</strong> (such as in <strong class="source-inline">T::value_type</strong> with <strong class="source-inline">T</strong> being a numeric type for instance)</li>
				<li>Creating a pointer to reference</li>
				<li>Creating a reference to <strong class="source-inline">void</strong></li>
				<li>Creating a pointer to member of <strong class="source-inline">T</strong>, where <strong class="source-inline">T</strong> is not a class type</li>
				<li>Using a member of a type when the type does not contain that member</li>
				<li>Using a member of a type where a type is required but the member is not a type</li>
				<li>Using a member of a type where a template is required but the member is not a template</li>
				<li>Using a member of a type where a non-type is required but the member is not a non-type</li>
				<li>Creating a function type with a parameter of type <strong class="source-inline">void</strong></li>
				<li>Creating a function type that returns an array type or another function type</li>
				<li>Performing an invalid conversion in a template argument expression or an expression used in a function declaration</li>
				<li>Supplying an invalid type to a non-type template parameter</li>
				<li>Instantiating a pack expansion containing multiple packs of different lengths</li>
			</ul>
			<p>The last error in this list was introduced in C++11 together with variadic templates. The others were defined before C++11. We will not go on to exemplify all of these errors, but we can <a id="_idIndexMarker417"/>take a look at a couple more <a id="_idIndexMarker418"/>examples. The first concerns attempting to create an array of size zero. Let’s say we want to have two function template overloads, one that handles arrays of even sizes and one that handles arrays of odd sizes. A solution to this is the following:</p>
			<pre class="source-code">template &lt;typename T, size_t N&gt;</pre>
			<pre class="source-code">void handle(T(&amp;arr)[N], char(*)[N % 2 == 0] = 0)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   std::cout &lt;&lt; "handle even array\n";</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template &lt;typename T, size_t N&gt;</pre>
			<pre class="source-code">void handle(T(&amp;arr)[N], char(*)[N % 2 == 1] = 0)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   std::cout &lt;&lt; "handle odd array\n";</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">int arr1[]{ 1,2,3,4,5 };</pre>
			<pre class="source-code">handle(arr1);</pre>
			<pre class="source-code">int arr2[]{ 1,2,3,4 };</pre>
			<pre class="source-code">handle(arr2);</pre>
			<p>The template arguments and the first function parameter are similar to what we saw with the <strong class="source-inline">begin</strong> overload for arrays. However, these overloads for <strong class="source-inline">handle</strong> have a second anonymous parameter with the default value <strong class="source-inline">0</strong>. The type of this parameter is a pointer to an array of type <strong class="source-inline">char</strong> and a size specified with the expressions <strong class="source-inline">N%2==0</strong> and <strong class="source-inline">N%2==1</strong>. For every possible array, one of these two is <strong class="source-inline">true</strong> and the other is <strong class="source-inline">false</strong>. Therefore, the second parameter is either <strong class="source-inline">char(*)[1]</strong> or <strong class="source-inline">char(*)[0]</strong>, the latter being an SFINAE error (an attempt to create an array of size zero). Therefore, we are able to call either one of the other overloads without generating compiler errors, thanks to SFINAE.</p>
			<p>The last example <a id="_idIndexMarker419"/>that we will look <a id="_idIndexMarker420"/>at in this section will show SFINAE with an attempt to use a member of a class that does not exist. Let’s start with the following snippet:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct foo</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   using foo_type = T;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct bar</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   using bar_type = T;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">struct int_foo : foo&lt;int&gt; {};</pre>
			<pre class="source-code">struct int_bar : bar&lt;int&gt; {};</pre>
			<p>Here we have two classes, <strong class="source-inline">foo</strong>, which has a member type called <strong class="source-inline">foo_type</strong>, and <strong class="source-inline">bar</strong>, which has a member type called <strong class="source-inline">bar_type</strong>. There are also classes that derive from these <a id="_idIndexMarker421"/>two. The goal is to write two <a id="_idIndexMarker422"/>function templates, one that handles the <strong class="source-inline">foo</strong> hierarchy of classes, and one that handles the <strong class="source-inline">bar</strong> hierarchy of classes. A possible implementation is the following:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">decltype(typename T::foo_type(), void()) handle(T const&amp; v)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   std::cout &lt;&lt; "handle a foo\n";</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">decltype(typename T::bar_type(), void()) handle(T const&amp; v)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   std::cout &lt;&lt; "handle a bar\n";</pre>
			<pre class="source-code">}</pre>
			<p>Both overloads have a single template parameter and a single function parameter of type <strong class="source-inline">T const&amp;</strong>. They also return the same type, and that type is <strong class="source-inline">void</strong>. The expression <strong class="source-inline">decltype(typename T::foo_type(), void())</strong> may need a little consideration to understand better. We discussed <strong class="source-inline">decltype</strong> in <a href="B18367_04_ePub.xhtml#_idTextAnchor064"><em class="italic">Chapter 4</em></a>, <em class="italic">Advanced Template Concepts</em>. Remember that this is a type specifier that deduces the type of an expression. We <a id="_idIndexMarker423"/>use the comma <a id="_idIndexMarker424"/>operator, so the first argument is evaluated but then discarded, so <strong class="source-inline">decltype</strong> will only deduce the type from <strong class="source-inline">void()</strong>, and the deduced type is <strong class="source-inline">void</strong>. However, the arguments <strong class="source-inline">typename T::foo_type()</strong> and <strong class="source-inline">typename T::bar_type()</strong> do use an inner type, and this only exists either for <strong class="source-inline">foo</strong> or <strong class="source-inline">bar</strong>. This is where SFINAE manifests itself, as shown in the following snippet:</p>
			<pre class="source-code">int_foo fi;</pre>
			<pre class="source-code">int_bar bi;</pre>
			<pre class="source-code">int x = 0;</pre>
			<pre class="source-code">handle(fi); // OK</pre>
			<pre class="source-code">handle(bi); // OK</pre>
			<pre class="source-code">handle(x);  // error</pre>
			<p>Calling <strong class="source-inline">handle</strong> with an <strong class="source-inline">int_foo</strong> value will match the first overload, while the second is discarded because of a substitution failure. Similarly, calling <strong class="source-inline">handle</strong> with an <strong class="source-inline">int_bar</strong> value will match the second overload, while the first is discarded because of a substitution failure. However, calling <strong class="source-inline">handle</strong> with an <strong class="source-inline">int</strong> will cause substitution failure for both overloads so the final overload set for substituting <strong class="source-inline">int</strong> will be empty, which means there is no match for the call. Therefore, a compiler error occurs.</p>
			<p>SFINAE is not the best way to achieve conditional compilation. However, in modern C++ it’s probably best used together with a type trait called <strong class="source-inline">enable_if</strong>. This is what we will discuss next.</p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor083"/>Enabling SFINAE with the enable_if type trait</h1>
			<p>The C++ <a id="_idIndexMarker425"/>standard <a id="_idIndexMarker426"/>library is a family of sub-libraries. One of these is the type support library. This library defines types such as <strong class="source-inline">std::size_t</strong>, <strong class="source-inline">std::nullptr_t</strong>, and <strong class="source-inline">std::byte</strong>, run-time type identification support with classes such as <strong class="source-inline">std::type_info</strong>, as well as a collection of type traits. There are <a id="_idIndexMarker427"/>two categories of type traits:</p>
			<ul>
				<li>Type traits that enable us to query properties of types at compile-time.</li>
				<li>Type traits that enable us to perform type transformations at compile-time (such as adding or removing the <strong class="source-inline">const</strong> qualifier, or adding or removing pointer or reference from a type). These type <a id="_idIndexMarker428"/>traits are also called <strong class="bold">metafunctions</strong>.</li>
			</ul>
			<p>One type trait <a id="_idIndexMarker429"/>from the second category is <strong class="source-inline">std::enable_if</strong>. This is used to enable <a id="_idIndexMarker430"/>SFINAE and remove candidates from a function’s overload set. A possible implementation is the following:</p>
			<pre class="source-code">template&lt;bool B, typename T = void&gt;</pre>
			<pre class="source-code">struct enable_if {};</pre>
			<pre class="source-code">template&lt;typename T&gt;</pre>
			<pre class="source-code">struct enable_if&lt;true, T&gt; { using type = T; };</pre>
			<p>There is a primary template, with two template parameters, a Boolean non-type template, and a type parameter with <strong class="source-inline">void</strong> as the default argument. This primary template is an empty class. There is also a partial specialization for the <strong class="source-inline">true</strong> value of the non-type template parameter. This, however, defines a member type simply called <strong class="source-inline">type</strong>, which is an alias template for the template parameter <strong class="source-inline">T</strong>.</p>
			<p>The <strong class="source-inline">enable_if</strong> metafunction is intended to be used with a Boolean expression. When this Boolean expression <a id="_idIndexMarker431"/>is evaluated as <strong class="source-inline">true</strong>, it defines a member type called <strong class="source-inline">type</strong>. If the Boolean expression is <strong class="source-inline">false</strong>, this member type is not defined. Let’s see how it works.</p>
			<p>Remember the example from the <em class="italic">Understanding and defining type traits</em> section at the beginning of the chapter, where we had classes that provided a <strong class="source-inline">write</strong> method to write their content to an output stream, and classes for which the <strong class="source-inline">operator&lt;&lt;</strong> was overloaded for the same purpose? In that section, we defined a type trait called <strong class="source-inline">uses_write</strong> and wrote a <strong class="source-inline">serialize</strong> function template that allowed us to serialize, in a <a id="_idIndexMarker432"/>uniform manner, both types of objects (<strong class="source-inline">widget</strong> and <strong class="source-inline">gadget</strong>). However, the implementation <a id="_idIndexMarker433"/>was rather complex. With <strong class="source-inline">enable_if</strong>, we can implement that function in a simple manner. A possible implementation is shown in the next snippet:</p>
			<pre class="source-code">template &lt;typename T, </pre>
			<pre class="source-code">          typename std::enable_if&lt;</pre>
			<pre class="source-code">             uses_write_v&lt;T&gt;&gt;::type* = nullptr&gt;</pre>
			<pre class="source-code">void serialize(std::ostream&amp; os, T const&amp; value)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   value.write(os);</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template &lt;typename T,</pre>
			<pre class="source-code">          typename std::enable_if&lt;</pre>
			<pre class="source-code">             !uses_write_v&lt;T&gt;&gt;::type*=nullptr&gt;</pre>
			<pre class="source-code">void serialize(std::ostream&amp; os, T const&amp; value)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   os &lt;&lt; value;</pre>
			<pre class="source-code">}</pre>
			<p>There are two overloaded function templates in this implementation. They both have two template parameters. The first parameter is a type template parameter, called <strong class="source-inline">T</strong>. The second is an anonymous non-type template parameter of a pointer type that also has the default value <strong class="source-inline">nullptr</strong>. We use <strong class="source-inline">enable_if</strong> to define the member called <strong class="source-inline">type</strong> only if the <strong class="source-inline">uses_write_v</strong> variable evaluates to <strong class="source-inline">true</strong>. Therefore, for classes that have the member function <strong class="source-inline">write</strong>, the substitution succeeds for the first overload but fails for the second overload, because <strong class="source-inline">typename * = nullptr</strong> is not a valid parameter. For classes for which the <strong class="source-inline">operator&lt;&lt;</strong> is overloaded, we have the opposite situation.</p>
			<p>The <strong class="source-inline">enable_if</strong> metafunction <a id="_idIndexMarker434"/>can be used in several scenarios:</p>
			<ul>
				<li>To define a template parameter that has a default argument, which we saw earlier</li>
				<li>To define a function parameter that has a default argument</li>
				<li>To specify the return type of a function</li>
			</ul>
			<p>For this reason, I <a id="_idIndexMarker435"/>mentioned earlier that the <a id="_idIndexMarker436"/>provided implementation of the <strong class="source-inline">serialize</strong> overloads is just one of the possibilities. A similar one that uses <strong class="source-inline">enable_if</strong> to define a function parameter with a default argument is shown next:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">void serialize(</pre>
			<pre class="source-code">   std::ostream&amp; os, T const&amp; value, </pre>
			<pre class="source-code">   typename std::enable_if&lt;</pre>
			<pre class="source-code">               uses_write_v&lt;T&gt;&gt;::type* = nullptr)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   value.write(os);</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">void serialize(</pre>
			<pre class="source-code">   std::ostream&amp; os, T const&amp; value,</pre>
			<pre class="source-code">   typename std::enable_if&lt;</pre>
			<pre class="source-code">               !uses_write_v&lt;T&gt;&gt;::type* = nullptr)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   os &lt;&lt; value;</pre>
			<pre class="source-code">}</pre>
			<p>You <a id="_idIndexMarker437"/>will notice here that we basically <a id="_idIndexMarker438"/>moved the parameter from the template parameter list to the function parameter list. There is no other change, and the usage is the same, such as follows:</p>
			<pre class="source-code">widget w{ 1, "one" };</pre>
			<pre class="source-code">gadget g{ 2, "two" };</pre>
			<pre class="source-code">serialize(std::cout, w);</pre>
			<pre class="source-code">serialize(std::cout, g);</pre>
			<p>The third alternative is to use <strong class="source-inline">enable_if</strong> to wrap the return type of the function. This implementation is only slightly different (the default argument does not make sense for a return type). Here is how it looks:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">typename std::enable_if&lt;uses_write_v&lt;T&gt;&gt;::type serialize(</pre>
			<pre class="source-code">   std::ostream&amp; os, T const&amp; value)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   value.write(os);</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">typename std::enable_if&lt;!uses_write_v&lt;T&gt;&gt;::type serialize(</pre>
			<pre class="source-code">   std::ostream&amp; os, T const&amp; value)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   os &lt;&lt; value;</pre>
			<pre class="source-code">}</pre>
			<p>The return type, in this implementation, is defined if <strong class="source-inline">uses_write_v&lt;T&gt;</strong> is <strong class="source-inline">true</strong>. Otherwise, a substitution failure occurs and SFINAE takes place.</p>
			<p>Although in all these examples, the <strong class="source-inline">enable_if</strong> type trait was used to enable SFINAE during <a id="_idIndexMarker439"/>the overload resolution for function <a id="_idIndexMarker440"/>templates, this type trait can also be used to restrict instantiations of class templates. In the following example, we have a class called <strong class="source-inline">integral_wrapper</strong> that is supposed to be instantiated only with integral types, and a class called <strong class="source-inline">floating_wrapper</strong> that is supposed to be instantiated only with floating-point types:</p>
			<pre class="source-code">template &lt;</pre>
			<pre class="source-code">   typename T,</pre>
			<pre class="source-code">   typename=typenamestd::enable_if_t&lt;</pre>
			<pre class="source-code">                        std::is_integral_v&lt;T&gt;&gt;&gt;</pre>
			<pre class="source-code">struct integral_wrapper</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   T value;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;</pre>
			<pre class="source-code">   typename T,</pre>
			<pre class="source-code">   typename=typename std::enable_if_t&lt;</pre>
			<pre class="source-code">                        std::is_floating_point_v&lt;T&gt;&gt;&gt;</pre>
			<pre class="source-code">struct floating_wrapper</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   T value;</pre>
			<pre class="source-code">};</pre>
			<p>Both these class templates have two type template parameters. The first one is called <strong class="source-inline">T</strong>, but the <a id="_idIndexMarker441"/>second one is anonymous and has a <a id="_idIndexMarker442"/>default argument. The value of this argument is defined or not with the help of the <strong class="source-inline">enable_if</strong> type trait, based on the value of a Boolean expression. </p>
			<p>In this implementation, we can see:</p>
			<ul>
				<li>An alias template called <strong class="source-inline">std::enable_if_t</strong>, which is a convenient way to access the <strong class="source-inline">std::enable_if&lt;B, T&gt;::type</strong> member type. This is defined as follows:<p class="source-code">template &lt;bool B, typename T = void&gt;</p><p class="source-code">using enable_if_t = typename enable_if&lt;B,T&gt;::type;</p></li>
				<li>Two variable templates, <strong class="source-inline">std::is_integral_v</strong> and <strong class="source-inline">std::is_floating_point_v</strong>, which are convenient ways to access the data members, <strong class="source-inline">std::is_integral&lt;T&gt;::value</strong> and <strong class="source-inline">std::is_floating_point&lt;T&gt;::value</strong>. The <strong class="source-inline">std::is_integral</strong> and <strong class="source-inline">std::is_floating_point</strong> classes are standard type traits that check whether a type is an integral type or a floating-point type respectively.</li>
			</ul>
			<p>The two wrapper class templates shown previously can be used as follows:</p>
			<pre class="source-code">integral_wrapper w1{ 42 };   // OK</pre>
			<pre class="source-code">integral_wrapper w2{ 42.0 }; // error</pre>
			<pre class="source-code">integral_wrapper w3{ "42" }; // error</pre>
			<pre class="source-code">floating_wrapper w4{ 42 };   // error</pre>
			<pre class="source-code">floating_wrapper w5{ 42.0 }; // OK</pre>
			<pre class="source-code">floating_wrapper w6{ "42" }; // error</pre>
			<p>Only two of these instantiations work, <strong class="source-inline">w1</strong>, because <strong class="source-inline">integral_wrapper</strong> is instantiated with the <strong class="source-inline">int</strong> type, and <strong class="source-inline">w5</strong>, because <strong class="source-inline">floating_wrapper</strong> is instantiated with the <strong class="source-inline">double</strong> type. All the others generate compiler errors.</p>
			<p>It should be pointed out that this code samples only work with the provided definitions of <strong class="source-inline">integral_wrapper</strong> and <strong class="source-inline">floating_wrapper</strong> in C++20. For previous versions of the standard, even the definitions of <strong class="source-inline">w1</strong> and <strong class="source-inline">w5</strong> would generate compiler errors because <a id="_idIndexMarker443"/>the compiler wasn’t able to deduce <a id="_idIndexMarker444"/>the template arguments. In order to make them work, we’d have to change the class templates to include a constructor, as follows:</p>
			<pre class="source-code">template &lt;</pre>
			<pre class="source-code">   typename T,</pre>
			<pre class="source-code">   typename=typenamestd::enable_if_t&lt;</pre>
			<pre class="source-code">                        std::is_integral_v&lt;T&gt;&gt;&gt;</pre>
			<pre class="source-code">struct integral_wrapper</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   T value;</pre>
			<pre class="source-code">   integral_wrapper(T v) : value(v) {}</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;</pre>
			<pre class="source-code">   typename T,</pre>
			<pre class="source-code">   typename=typename std::enable_if_t&lt;</pre>
			<pre class="source-code">                        std::is_floating_point_v&lt;T&gt;&gt;&gt;</pre>
			<pre class="source-code">struct floating_wrapper</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   T value;</pre>
			<pre class="source-code">   floating_wrapper(T v) : value(v) {}</pre>
			<pre class="source-code">};</pre>
			<p>Although <strong class="source-inline">enable_if</strong> helps <a id="_idIndexMarker445"/>achieve <a id="_idIndexMarker446"/>SFINAE with simpler and more readable code, it’s still rather complicated. Fortunately, in <strong class="bold">C++17</strong> there is a better alternative with <strong class="source-inline">constexpr if</strong> statements. Let’s explore this alternative next.</p>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor084"/>Using constexpr if</h1>
			<p>A C++17 feature <a id="_idIndexMarker447"/>makes SFINAE much easier. It’s called <strong class="source-inline">constexpr if</strong> and it’s a compile-time version of the <strong class="source-inline">if</strong> statement. It helps replace complex template code with simpler versions. Let’s start by looking at a C++17 implementation of the <strong class="source-inline">serialize</strong> function that can uniformly serialize both widgets and gadgets:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">void serialize(std::ostream&amp; os, T const&amp; value)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   if constexpr (uses_write_v&lt;T&gt;)</pre>
			<pre class="source-code">      value.write(os);</pre>
			<pre class="source-code">   else</pre>
			<pre class="source-code">      os &lt;&lt; value;</pre>
			<pre class="source-code">}</pre>
			<p>The syntax for <strong class="source-inline">constexpr if</strong> is <strong class="source-inline">if constexpr(condition)</strong>. The condition must be a compile-time expression. There is no short-circuit logic performed when evaluating the expression. This means that if the expression has the form <strong class="source-inline">a &amp;&amp; b</strong> or <strong class="source-inline">a || b</strong>, then both <strong class="source-inline">a</strong> and <strong class="source-inline">b</strong> must be well-formed.</p>
			<p><strong class="source-inline">constexpr if</strong> enables us to discard a branch, at compile-time, based on the value of the expression. In our example, when the <strong class="source-inline">uses_write_v</strong> variable is <strong class="source-inline">true</strong>, the <strong class="source-inline">else</strong> branch is discarded, and the body of the first branch is retained. Otherwise, the opposite occurs. Therefore, we end up with the following specializations for the <strong class="source-inline">widget</strong> and <strong class="source-inline">gadget</strong> classes:</p>
			<pre class="source-code">template&lt;&gt;</pre>
			<pre class="source-code">void serialize&lt;widget&gt;(std::ostream &amp; os,</pre>
			<pre class="source-code">                      widget const &amp; value)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   if constexpr(true)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      value.write(os);</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template&lt;&gt;</pre>
			<pre class="source-code">void serialize&lt;gadget&gt;(std::ostream &amp; os,</pre>
			<pre class="source-code">                       gadget const &amp; value)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   if constexpr(false) </pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">   } </pre>
			<pre class="source-code">   else</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      os &lt;&lt; value;</pre>
			<pre class="source-code">   } </pre>
			<pre class="source-code">}</pre>
			<p>Of course, this <a id="_idIndexMarker448"/>code is likely to be further simplified by the compiler. Therefore, eventually, these specializations would simply look like the following:</p>
			<pre class="source-code">template&lt;&gt;</pre>
			<pre class="source-code">void serialize&lt;widget&gt;(std::ostream &amp; os,</pre>
			<pre class="source-code">                       widget const &amp; value)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   value.write(os);</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template&lt;&gt;</pre>
			<pre class="source-code">void serialize&lt;gadget&gt;(std::ostream &amp; os,</pre>
			<pre class="source-code">                       gadget const &amp; value)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   os &lt;&lt; value;</pre>
			<pre class="source-code">}</pre>
			<p>The end <a id="_idIndexMarker449"/>result is the same as the one we achieved with SFINAE and <strong class="source-inline">enable_if</strong>, but the actual code we wrote here was simpler and easier to understand.</p>
			<p><strong class="source-inline">constexpr if</strong> is a great tool for simplifying code and we actually saw it earlier in <a href="B18367_03_ePub.xhtml#_idTextAnchor051"><em class="italic">Chapter 3</em></a>, <em class="italic">Variadic Templates</em>, in the <em class="italic">Parameter packs</em> paragraph, when we implemented a function called <strong class="source-inline">sum</strong>. This is shown again here:</p>
			<pre class="source-code">template &lt;typename T, typename... Args&gt;</pre>
			<pre class="source-code">T sum(T a, Args... args)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   if constexpr (sizeof...(args) == 0)</pre>
			<pre class="source-code">      return a;</pre>
			<pre class="source-code">   else</pre>
			<pre class="source-code">      return a + sum(args...);</pre>
			<pre class="source-code">}</pre>
			<p>In this example, <strong class="source-inline">constexpr if</strong> helps us to avoid having two overloads, one for the general case and one for ending the recursion. Another example presented already in this book where <strong class="source-inline">constexpr if</strong> can simplify the implementation is the <strong class="source-inline">factorial</strong> function <a id="_idIndexMarker450"/>template from <a href="B18367_04_ePub.xhtml#_idTextAnchor064"><em class="italic">Chapter 4</em></a>, <em class="italic">Advanced Template Concepts</em>, in the <em class="italic">Exploring template recursion</em> section. That function looked as follows:</p>
			<pre class="source-code">template &lt;unsigned int n&gt;</pre>
			<pre class="source-code">constexpr unsigned int factorial()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return n * factorial&lt;n - 1&gt;();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template&lt;&gt; </pre>
			<pre class="source-code">constexpr unsigned int factorial&lt;1&gt;() { return 1; }</pre>
			<pre class="source-code">template&lt;&gt; </pre>
			<pre class="source-code">constexpr unsigned int factorial&lt;0&gt;() { return 1; }</pre>
			<p>With <strong class="source-inline">constexpr if</strong>, we can replace all this with a single template and let the compiler take care of providing the right specializations. The C++17 version of this function may look as follows:</p>
			<pre class="source-code">template &lt;unsigned int n&gt;</pre>
			<pre class="source-code">constexpr unsigned int factorial()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   if constexpr (n &gt; 1)</pre>
			<pre class="source-code">      return n * factorial&lt;n - 1&gt;();</pre>
			<pre class="source-code">   else</pre>
			<pre class="source-code">      return 1;</pre>
			<pre class="source-code">}</pre>
			<p>The <strong class="source-inline">constexpr if</strong> statements can be useful in many situations. The last example presented in this section is a function template called <strong class="source-inline">are_equal</strong>, which determines whether the two supplied arguments are equal or not. Typically, you’d think that using <strong class="source-inline">operator==</strong> should be enough to determine whether two values are equal or not. That is true in <a id="_idIndexMarker451"/>most cases, except for floating-point values. Because only some of the floating-point numbers can be stored without a precision loss (numbers like 1, 1.25, 1.5, and anything else where the fractional part is an exact sum of inverse powers of 2) we need to take special care when comparing floating-point numbers. Usually, this is solved by ensuring that the difference between two floating-point values is less than some threshold. Therefore, a possible implementation for such a function could be as follows:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">bool are_equal(T const&amp; a, T const&amp; b)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   if constexpr (std::is_floating_point_v&lt;T&gt;)</pre>
			<pre class="source-code">      return std::abs(a - b) &lt; 0.001;</pre>
			<pre class="source-code">   else</pre>
			<pre class="source-code">      return a == b;</pre>
			<pre class="source-code">}</pre>
			<p>When the <strong class="source-inline">T</strong> type is a floating-point type, we compare the absolute value of the difference of the two numbers with the selected threshold. Otherwise, we fall back to using <strong class="source-inline">operator==</strong>. This enables us to use this function not just with arithmetic types, but also any other type for which the equality operator is overloaded.</p>
			<pre class="source-code">are_equal(1, 1);                                   // OK</pre>
			<pre class="source-code">are_equal(1.999998, 1.999997);                     // OK</pre>
			<pre class="source-code">are_equal(std::string{ "1" }, std::string{ "1" }); // OK</pre>
			<pre class="source-code">are_equal(widget{ 1, "one" }, widget{ 1, "two" }); // error</pre>
			<p>We are able to call the <strong class="source-inline">are_equal</strong> function template with arguments of type <strong class="source-inline">int</strong>, <strong class="source-inline">double</strong>, and <strong class="source-inline">std::string</strong>. However, attempting to do the same with values of the <strong class="source-inline">widget</strong> type will trigger a compiler error, because the <strong class="source-inline">==</strong> operator is not overloaded for this type.</p>
			<p>So far in this <a id="_idIndexMarker452"/>chapter, we have seen what type traits are as well as different ways to perform conditional compilation. We have also seen some of the type traits available in the standard library. In the second part of this chapter, we will explore what the standard has to offer with regard to type traits.</p>
			<h1 id="_idParaDest-80"><a id="_idTextAnchor085"/>Exploring the standard type traits</h1>
			<p>The standard library <a id="_idIndexMarker453"/>features a series of type traits for querying properties of types as well as performing transformations on types. These type traits are available in the <strong class="source-inline">&lt;type_traits&gt;</strong> header as part of the type support library. There are several categories of type traits including the following:</p>
			<ul>
				<li>Querying the type category (primary or composite)</li>
				<li>Querying type properties</li>
				<li>Querying supported operations</li>
				<li>Querying type relationships</li>
				<li>Modifying cv-specifiers, references, pointers, or a sign</li>
				<li>Miscellaneous transformations</li>
			</ul>
			<p>Although looking at every single type trait is beyond the scope of this book, we will explore all these categories to see what they contain. In the following subsections, we will list the type traits (or most of them) that make up each of these categories. These lists as well as detailed information about each type trait can be found in the C++ standard (see the <em class="italic">Further reading</em> section at the end of the chapter for a link to a freely available draft version) or on the <a href="http://cppreference.com">cppreference.com</a> website at <a href="https://en.cppreference.com/w/cpp/header/type_traits">https://en.cppreference.com/w/cpp/header/type_traits</a> (license usage link: <a href="http://creativecommons.org/licenses/by-sa/3.0/">http://creativecommons.org/licenses/by-sa/3.0/</a>).</p>
			<p>We will start with the type traits for querying the type category.</p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor086"/>Querying the type category</h2>
			<p>Throughout <a id="_idIndexMarker454"/>this book so far, we have used <a id="_idIndexMarker455"/>several type traits, such as <strong class="source-inline">std::is_integral</strong>, <strong class="source-inline">std::is_floating_point</strong>, and <strong class="source-inline">std::is_arithmetic</strong>. These are just some of the standard type traits used for querying primary and composite type categories. The following table lists the entire set of such type traits:</p>
			<div>
				<div id="_idContainer017" class="IMG---Figure">
					<img src="Images/B18367_05_Table1.1.jpg" alt="Table 5.1" width="1568" height="1184"/>
				</div>
			</div>
			<div>
				<div id="_idContainer018" class="IMG---Figure">
					<img src="Images/B18367_05_Table1.2.jpg" alt="Table 5.1" width="1568" height="1932"/>
				</div>
			</div>
			<div>
				<div id="_idContainer019" class="IMG---Figure">
					<img src="Images/B18367_05_Table1.3.jpg" alt="Table 5.1&#13;&#10;" width="1568" height="897"/>
				</div>
			</div>
			<p class="figure-caption">Table 5.1</p>
			<p>All these type <a id="_idIndexMarker456"/>traits are available in C++11. For each <a id="_idIndexMarker457"/>of them, starting with C++17, a variable template is available to simplify the access to the Boolean member called <strong class="source-inline">value</strong>. For a type trait with the name <strong class="source-inline">is_abc</strong>, a variable template with the name <strong class="source-inline">is_abc_v</strong> exists. This is true for all the type traits that have a Boolean member called <strong class="source-inline">value</strong>. The definition of these variables is very simple. The next snippet shows the definition for the <strong class="source-inline">is_arithmentic_v</strong> variable template:</p>
			<pre class="source-code">template&lt; class T &gt;</pre>
			<pre class="source-code">inline constexpr bool is_arithmetic_v =</pre>
			<pre class="source-code">   is_arithmetic&lt;T&gt;::value;</pre>
			<p>Here is an example of using some of these type traits:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">std::string as_string(T value)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   if constexpr (std::is_null_pointer_v&lt;T&gt;)</pre>
			<pre class="source-code">      return "null";</pre>
			<pre class="source-code">   else if constexpr (std::is_arithmetic_v&lt;T&gt;)</pre>
			<pre class="source-code">      return std::to_string(value);</pre>
			<pre class="source-code">   else</pre>
			<pre class="source-code">      static_assert(always_false&lt;T&gt;);</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">std::cout &lt;&lt; as_string(nullptr) &lt;&lt; '\n'; // prints null</pre>
			<pre class="source-code">std::cout &lt;&lt; as_string(true) &lt;&lt; '\n';    // prints 1</pre>
			<pre class="source-code">std::cout &lt;&lt; as_string('a') &lt;&lt; '\n';     // prints a</pre>
			<pre class="source-code">std::cout &lt;&lt; as_string(42) &lt;&lt; '\n';      // prints 42</pre>
			<pre class="source-code">std::cout &lt;&lt; as_string(42.0) &lt;&lt; '\n';   // prints 42.000000</pre>
			<pre class="source-code">std::cout &lt;&lt; as_string("42") &lt;&lt; '\n';    // error</pre>
			<p>The function template <strong class="source-inline">as_string</strong> returns a string containing the value pass as an argument. It <a id="_idIndexMarker458"/>works with arithmetic types only <a id="_idIndexMarker459"/>and with the <strong class="source-inline">nullptr_t</strong> for which it returns the value <strong class="source-inline">"null"</strong>.</p>
			<p>You must have noticed the statement, <strong class="source-inline">static_assert(always_false&lt;T&gt;)</strong>, and wondering what this <strong class="source-inline">always_false&lt;T&gt;</strong> expression actually is. It is a variable template of the <strong class="source-inline">bool</strong> type that evaluates to <strong class="source-inline">false</strong>. Its definition is as simple as the following:</p>
			<pre class="source-code">template&lt;class T&gt; </pre>
			<pre class="source-code">constexpr bool always_false = std::false_type::value;</pre>
			<p>This is needed because the statement, <strong class="source-inline">static_assert(false)</strong>, would make the program ill-formed. The reason for this is that its condition would not depend on a template argument but evaluate to <strong class="source-inline">false</strong>. When no valid specialization can be generated for a sub-statement of a <strong class="source-inline">constexpr if</strong> statement within a template, the program is ill-formed (and no diagnostic is required). To avoid this, the condition of the <strong class="source-inline">static_assert</strong> statement must depend on a template argument. With <strong class="source-inline">static_assert(always_false&lt;T&gt;)</strong>, the compiler does not know whether this would evaluate to <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong> until the template is instantiated.</p>
			<p>The next category of type traits we explore allows us to query properties of types.</p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor087"/>Querying type properties</h2>
			<p>The type <a id="_idIndexMarker460"/>traits that enable us to query properties of types <a id="_idIndexMarker461"/>are the following:</p>
			<div>
				<div id="_idContainer020" class="IMG---Figure">
					<img src="Images/B18367_05_Table2.1.jpg" alt="Table 5.2&#10;" width="1650" height="368"/>
				</div>
			</div>
			<div>
				<div id="_idContainer021" class="IMG---Figure">
					<img src="Images/B18367_05_Table2.2.jpg" alt="Table 5.2&#10;" width="1577" height="2241"/>
				</div>
			</div>
			<div>
				<div id="_idContainer022" class="IMG---Figure">
					<img src="Images/B18367_05_Table2.3.jpg" alt="Table 5.2&#10;" width="1568" height="749"/>
				</div>
			</div>
			<p class="figure-caption">Table 5.2</p>
			<p>Although most of these are probably straightforward to understand, there are two that seem the <a id="_idIndexMarker462"/>same at a first glance. These are <strong class="source-inline">is_trivial</strong> and <strong class="source-inline">is_trivially_copyable</strong>. These both are true for scalar types or arrays of <a id="_idIndexMarker463"/>scalar types. They also are true for classes that are trivially copyable or arrays of such classes but <strong class="source-inline">is_trivial</strong> is true only for copyable classes that have a trivial default constructor. </p>
			<p>According to the paragraph <em class="italic">§11.4.4.1</em> in the C++ 20 standard, a default constructor is trivial if it is not user-provided, and the class has no virtual member functions, no virtual base classes, no non-static members with default initializers, every direct base of it has a trivial default constructor, and every non-static member of a class type also has a trivial default constructor. To understand this better, let’s look at the following example:</p>
			<pre class="source-code">struct foo</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   int a;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">struct bar</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   int a = 0;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">struct tar</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   int a = 0;</pre>
			<pre class="source-code">   tar() : a(0) {}</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">std::cout &lt;&lt; std::is_trivial_v&lt;foo&gt; &lt;&lt; '\n'; // true</pre>
			<pre class="source-code">std::cout &lt;&lt; std::is_trivial_v&lt;bar&gt; &lt;&lt; '\n'; // false</pre>
			<pre class="source-code">std::cout &lt;&lt; std::is_trivial_v&lt;tar&gt; &lt;&lt; '\n'; // false</pre>
			<pre class="source-code">std::cout &lt;&lt; std::is_trivially_copyable_v&lt;foo&gt; </pre>
			<pre class="source-code">          &lt;&lt; '\n';                                 // true</pre>
			<pre class="source-code">std::cout &lt;&lt; std::is_trivially_copyable_v&lt;bar&gt; </pre>
			<pre class="source-code">          &lt;&lt; '\n';                                 // true</pre>
			<pre class="source-code">std::cout &lt;&lt; std::is_trivially_copyable_v&lt;tar&gt; </pre>
			<pre class="source-code">          &lt;&lt; '\n';                                 // true</pre>
			<p>In this <a id="_idIndexMarker464"/>example, there are three similar classes. All three of <a id="_idIndexMarker465"/>them, <strong class="source-inline">foo</strong>, <strong class="source-inline">bar</strong>, and <strong class="source-inline">tar</strong>, are trivially copyable. However, only the <strong class="source-inline">foo</strong> class is a trivial class, because it has a trivial default constructor. The <strong class="source-inline">bar</strong> class has a non-static member with a default initializer, and the <strong class="source-inline">tar</strong> class has a user-defined constructor, and this makes them non-trivial.</p>
			<p>Apart from trivial copy-ability, there are other operations that we can query for with the help of other type traits. We will see these in the following section.</p>
			<h2 id="_idParaDest-83"><a id="_idTextAnchor088"/>Querying supported operations</h2>
			<p>The following <a id="_idIndexMarker466"/>set of type traits helps us to query supported operations:</p>
			<div>
				<div id="_idContainer023" class="IMG---Figure">
					<img src="Images/B18367_05_Table3.1.jpg" alt="Table 5.3&#10;" width="1568" height="716"/>
				</div>
			</div>
			<div>
				<div id="_idContainer024" class="IMG---Figure">
					<img src="Images/B18367_05_Table3.2.jpg" alt="Table 5.3&#10;" width="1568" height="1552"/>
				</div>
			</div>
			<p class="figure-caption">Table 5.3</p>
			<p>Except for the last sub-set, which was introduced in C++17, the others are available in C++11. Each <a id="_idIndexMarker467"/>kind of these type traits has multiple variants, including ones for checking operations that are trivial or declared as non-throwing with the <strong class="source-inline">noexcept</strong> specifier.</p>
			<p>Now let’s look at type traits that allow us to query for relationships between types.</p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor089"/>Querying type relationships</h2>
			<p>In this category, we <a id="_idIndexMarker468"/>can find several type traits that help to <a id="_idIndexMarker469"/>query relationships between types. These type traits are as follows:</p>
			<div>
				<div id="_idContainer025" class="IMG---Figure">
					<img src="Images/B18367_05_Table4.jpg" alt="Table 5.4&#10;" width="1568" height="1250"/>
				</div>
			</div>
			<p class="figure-caption">Table 5.4</p>
			<p>Of these type traits, perhaps the most used one is <strong class="source-inline">std::is_same</strong>. This type trait is very useful in determining whether two types are the same. Keep in mind that this type trait takes into account the <strong class="source-inline">const</strong> and <strong class="source-inline">volatile</strong> qualifiers; therefore, <strong class="source-inline">int</strong> and <strong class="source-inline">int const</strong>, for instance, are not the same type. </p>
			<p>We can <a id="_idIndexMarker470"/>use this type trait to extend the implementation <a id="_idIndexMarker471"/>of the <strong class="source-inline">as_string</strong> function shown earlier. Remember that if you called it with the arguments <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong> it prints <strong class="source-inline">1</strong> or <strong class="source-inline">0</strong>, and not <strong class="source-inline">true</strong>/<strong class="source-inline">false</strong>. We can add an explicit check for the <strong class="source-inline">bool</strong> type and return a string containing one of these two values, shown as follows:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">std::string as_string(T value)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   if constexpr (std::is_null_pointer_v&lt;T&gt;)</pre>
			<pre class="source-code">      return "null";</pre>
			<pre class="source-code">   else if constexpr (std::is_same_v&lt;T, bool&gt;)</pre>
			<pre class="source-code">      return value ? "true" : "false";</pre>
			<pre class="source-code">   else if constexpr (std::is_arithmetic_v&lt;T&gt;)</pre>
			<pre class="source-code">      return std::to_string(value);</pre>
			<pre class="source-code">   else</pre>
			<pre class="source-code">      static_assert(always_false&lt;T&gt;);</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">std::cout &lt;&lt; as_string(true) &lt;&lt; '\n';    // prints true</pre>
			<pre class="source-code">std::cout &lt;&lt; as_string(false) &lt;&lt; '\n';   // prints false</pre>
			<p>All the type <a id="_idIndexMarker472"/>traits seen so far are used to query some kind of <a id="_idIndexMarker473"/>information about types. In the next sections, we will see type traits that perform modifications on types.</p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor090"/>Modifying cv-specifiers, references, pointers, or a sign</h2>
			<p>The type <a id="_idIndexMarker474"/>traits that are performing transformations <a id="_idIndexMarker475"/>on types are also called <a id="_idIndexMarker476"/>metafunctions. These type traits provided a <a id="_idIndexMarker477"/>member type (<strong class="source-inline">typedef</strong>) called <strong class="source-inline">type</strong> that represents <a id="_idIndexMarker478"/>the transformed type. This category of type traits includes the following:</p>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<img src="Images/B18367_05_Table5.1.jpg" alt="Table 5.5&#10;" width="1568" height="677"/>
				</div>
			</div>
			<div>
				<div id="_idContainer027" class="IMG---Figure">
					<img src="Images/B18367_05_Table5.2.jpg" alt="Table 5.5&#10;" width="1577" height="864"/>
				</div>
			</div>
			<p class="figure-caption">Table 5.5</p>
			<p>With the <a id="_idIndexMarker479"/>exception of <strong class="source-inline">remove_cvref</strong>, which <a id="_idIndexMarker480"/>was added in C++20, all the <a id="_idIndexMarker481"/>other type traits listed in this table <a id="_idIndexMarker482"/>are available in C++11. These are not all the metafunctions from the standard library. More are listed in the next section.</p>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor091"/>Miscellaneous transformations</h2>
			<p>Apart from <a id="_idIndexMarker483"/>the metafunctions previously listed, there are other type traits performing type transformations. The most important of these are listed in the following table:</p>
			<div>
				<div id="_idContainer028" class="IMG---Figure">
					<img src="Images/B18367_05_Table6.1.jpg" alt="Table 5.6&#13;&#10;" width="1566" height="843"/>
				</div>
			</div>
			<div>
				<div id="_idContainer029" class="IMG---Figure">
					<img src="Images/B18367_05_Table6.2.jpg" alt="Table 5.6&#13;&#10;" width="1566" height="581"/>
				</div>
			</div>
			<p class="figure-caption">Table 5.6</p>
			<p>From this list, we have already discussed <strong class="source-inline">enable_if</strong>. There are some other type traits here that are <a id="_idIndexMarker484"/>worth exemplifying. Let’s first look at <strong class="source-inline">std::decay</strong> and for this purpose, let’s consider the following slightly changed implementation of the <strong class="source-inline">as_string</strong> function:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">std::string as_string(T&amp;&amp; value)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   if constexpr (std::is_null_pointer_v&lt;T&gt;)</pre>
			<pre class="source-code">      return "null";</pre>
			<pre class="source-code">   else if constexpr (std::is_same_v&lt;T, bool&gt;)</pre>
			<pre class="source-code">      return value ? "true" : "false";</pre>
			<pre class="source-code">   else if constexpr (std::is_arithmetic_v&lt;T&gt;)</pre>
			<pre class="source-code">      return std::to_string(value);</pre>
			<pre class="source-code">   else</pre>
			<pre class="source-code">      static_assert(always_false&lt;T&gt;);</pre>
			<pre class="source-code">}</pre>
			<p>The only change is the way we pass arguments to the function. Instead of passing by value, we <a id="_idIndexMarker485"/>pass by rvalue reference. If you remember from <a href="B18367_04_ePub.xhtml#_idTextAnchor064"><em class="italic">Chapter 4</em></a>, <em class="italic">Advanced Template Concepts</em>, this is a forwarding reference. We can still make calls passing rvalues (such as literals) but passing lvalues will trigger compiler errors:</p>
			<pre class="source-code">std::cout &lt;&lt; as_string(true) &lt;&lt; '\n';  // OK</pre>
			<pre class="source-code">std::cout &lt;&lt; as_string(42) &lt;&lt; '\n';    // OK</pre>
			<pre class="source-code">bool f = true;</pre>
			<pre class="source-code">std::cout &lt;&lt; as_string(f) &lt;&lt; '\n';     // error</pre>
			<pre class="source-code">int n = 42;</pre>
			<pre class="source-code">std::cout &lt;&lt; as_string(n) &lt;&lt; '\n';     // error</pre>
			<p>The last two calls are triggering the <strong class="source-inline">static_assert</strong> statement to fail. The actual type template arguments are <strong class="source-inline">bool&amp;</strong> and <strong class="source-inline">int&amp;</strong>. Therefore <strong class="source-inline">std::is_same&lt;bool, bool&amp;&gt;</strong> will initialize the <strong class="source-inline">value</strong> member with <strong class="source-inline">false</strong>. Similarly, <strong class="source-inline">std::is_arithmetic&lt;int&amp;&gt;</strong> will do the same. In order to evaluate these types, we need to ignore references and the <strong class="source-inline">const</strong> and <strong class="source-inline">volatile</strong> qualifiers. The type trait that helps us do so is <strong class="source-inline">std::decay</strong>, which performs several transformations, as described in the previous table. Its conceptual implementation is the following:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct decay</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">private:</pre>
			<pre class="source-code">    using U = typename std::remove_reference_t&lt;T&gt;;</pre>
			<pre class="source-code">public:</pre>
			<pre class="source-code">    using type = typename std::conditional_t&lt; </pre>
			<pre class="source-code">        std::is_array_v&lt;U&gt;,</pre>
			<pre class="source-code">        typename std::remove_extent_t&lt;U&gt;*,</pre>
			<pre class="source-code">        typename std::conditional_t&lt; </pre>
			<pre class="source-code">            std::is_function&lt;U&gt;::value,</pre>
			<pre class="source-code">            typename std::add_pointer_t&lt;U&gt;,</pre>
			<pre class="source-code">            typename std::remove_cv_t&lt;U&gt;</pre>
			<pre class="source-code">        &gt;</pre>
			<pre class="source-code">    &gt;;</pre>
			<pre class="source-code">};</pre>
			<p>From this snippet, we can see that <strong class="source-inline">std::decay</strong> is implemented with the help of other metafunctions, including <strong class="source-inline">std::conditional</strong>, which is key for selecting between one type or another based on a compile-time expression. Actually, this type trait is used multiple times, which is something you can do if you need to make a selection based on multiple conditions.</p>
			<p>With the <a id="_idIndexMarker486"/>help of <strong class="source-inline">std::decay</strong>, we can modify the implementation of the <strong class="source-inline">as_string</strong> function, stripping reference, and cv-qualifiers:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">std::string as_string(T&amp;&amp; value)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   using value_type = std::decay_t&lt;T&gt;;</pre>
			<pre class="source-code">   if constexpr (std::is_null_pointer_v&lt;value_type&gt;)</pre>
			<pre class="source-code">      return "null";</pre>
			<pre class="source-code">   else if constexpr (std::is_same_v&lt;value_type, bool&gt;)</pre>
			<pre class="source-code">      return value ? "true" : "false";</pre>
			<pre class="source-code">   else if constexpr (std::is_arithmetic_v&lt;value_type&gt;)</pre>
			<pre class="source-code">      return std::to_string(value);</pre>
			<pre class="source-code">   else</pre>
			<pre class="source-code">      static_assert(always_false&lt;T&gt;);</pre>
			<pre class="source-code">}</pre>
			<p>By changing the implementation as shown here, we made the previous calls to <strong class="source-inline">as_string</strong> that failed to compile without any more errors.</p>
			<p>In the implementation of <strong class="source-inline">std::decay</strong> we saw the repetitive use of <strong class="source-inline">std::conditional</strong>. This is a metafunction that is fairly easy to use and can help to simplify many implementations. In <a href="B18367_02_ePub.xhtml#_idTextAnchor024"><em class="italic">Chapter 2</em></a>, <em class="italic">Template Fundamentals</em>, in the section <em class="italic">Defining alias templates</em>, we saw an example where we built a list type called <strong class="source-inline">list_t</strong>. This had a member alias template called <strong class="source-inline">type</strong> that was aliasing either the template <a id="_idIndexMarker487"/>type <strong class="source-inline">T</strong>, if the size of the list was <strong class="source-inline">1</strong>, or <strong class="source-inline">std::vector&lt;T&gt;</strong>, if it was higher. Let’s look at the snippet again:</p>
			<pre class="source-code">template &lt;typename T, size_t S&gt;</pre>
			<pre class="source-code">struct list</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   using type = std::vector&lt;T&gt;;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct list&lt;T, 1&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   using type = T;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;typename T, size_t S&gt;</pre>
			<pre class="source-code">using list_t = typename list&lt;T, S&gt;::type;</pre>
			<p>This implementation can be greatly simplified with the help of <strong class="source-inline">std::conditional</strong> as follows:</p>
			<pre class="source-code">template &lt;typename T, size_t S&gt;</pre>
			<pre class="source-code">using list_t = </pre>
			<pre class="source-code">   typename std::conditional&lt;S == </pre>
			<pre class="source-code">                 1, T, std::vector&lt;T&gt;&gt;::type;</pre>
			<p>There is no need to rely on class template specialization to define such a list type. The entire solution can be reduced to defining an alias template. We can verify this works as expected with some <strong class="source-inline">static_assert</strong> statements, as follows:</p>
			<pre class="source-code">static_assert(std::is_same_v&lt;list_t&lt;int, 1&gt;, int&gt;);</pre>
			<pre class="source-code">static_assert(std::is_same_v&lt;list_t&lt;int, 2&gt;,</pre>
			<pre class="source-code">                             std::vector&lt;int&gt;&gt;);</pre>
			<p>Exemplifying the <a id="_idIndexMarker488"/>use of each of the standard type traits is beyond the scope of this book. However, the next section of this chapter provides more complex examples that require the use of several standard type traits.</p>
			<h1 id="_idParaDest-87"><a id="_idTextAnchor092"/>Seeing real-world examples of using type traits</h1>
			<p>In the previous section of the chapter, we have explored the various type traits that the standard library <a id="_idIndexMarker489"/>provides. It is difficult and unnecessary to find examples for each and every type trait. However, it is worth showcasing some examples where multiple type traits can be used for solving a problem. We will do this next.</p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor093"/>Implementing a copy algorithm</h2>
			<p>The first example problem we will take a look at is a possible implementation for the <strong class="source-inline">std::copy</strong> standard <a id="_idIndexMarker490"/>algorithm (from the <strong class="source-inline">&lt;algorithm&gt;</strong> header). Keep in mind that what we will see next is not the actual implementation <a id="_idIndexMarker491"/>but a possible one that helps us learn more about the use of type traits. The signature of this algorithm is as follows:</p>
			<pre class="source-code">template &lt;typename InputIt, typename OutputIt&gt;</pre>
			<pre class="source-code">constexpr OutputIt copy(InputIt first, InputIt last,</pre>
			<pre class="source-code">                        OutputIt d_first);</pre>
			<p>As a note, this function is <strong class="source-inline">constexpr</strong> only in C++20, but we can discuss it in this context. What it does is copy all the elements in the range [<strong class="source-inline">first</strong>, <strong class="source-inline">last</strong>) to another range that begins with <strong class="source-inline">d_first</strong>. There is also an overload that takes an execution policy, and a version, <strong class="source-inline">std::copy_if</strong>, that copies all the elements that match a predicate, but <a id="_idIndexMarker492"/>these are not important for our example. A <a id="_idIndexMarker493"/>straightforward implementation of this function is the following:</p>
			<pre class="source-code">template &lt;typename InputIt, typename OutputIt&gt;</pre>
			<pre class="source-code">constexpr OutputIt copy(InputIt first, InputIt last,</pre>
			<pre class="source-code">                        OutputIt d_first)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   while (first != last)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      *d_first++ = *first++;</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   return d_first;</pre>
			<pre class="source-code">}</pre>
			<p>However, there are cases when this implementation can be optimized by simply copying memory. However, there are some conditions that must be met for this purpose:</p>
			<ul>
				<li>Both iterator types, <strong class="source-inline">InputIt</strong> and <strong class="source-inline">OutputIt</strong>, must be pointers.</li>
				<li>Both template parameters, <strong class="source-inline">InputIt</strong> and <strong class="source-inline">OutputIt</strong>, must point to the same type (ignoring cv-qualifiers).</li>
				<li>The type pointed by <strong class="source-inline">InputIt</strong> must have a trivial copy assignment operator.</li>
			</ul>
			<p>We can check these conditions with the following standard type traits:</p>
			<ul>
				<li><strong class="source-inline">std::is_same</strong> (and the <strong class="source-inline">std::is_same_v</strong> variable) to check that two types are the same.</li>
				<li><strong class="source-inline">std::is_pointer</strong> (and the <strong class="source-inline">std::is_pointer_v</strong> variable) to check that a type is a pointer type.</li>
				<li><strong class="source-inline">std::is_trivially_copy_assignable</strong> (and the <strong class="source-inline">std::is_trivially_copy_assignable_v</strong> variable) to check whether a type has a trivial copy assignment operator.</li>
				<li><strong class="source-inline">std::remove_cv</strong> (and the <strong class="source-inline">std::remove_cv_t</strong> alias template) to remove cv-qualifiers from a type.</li>
			</ul>
			<p>Let’s see how we can implement this. First, we need to have a primary template with the generic <a id="_idIndexMarker494"/>implementation, and then a specialization <a id="_idIndexMarker495"/>for pointer types with the optimized implementation. We can do this using class templates with member function templates as shown next:</p>
			<pre class="source-code">namespace detail</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   template &lt;bool b&gt;</pre>
			<pre class="source-code">   struct copy_fn</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      template&lt;typename InputIt, typename OutputIt&gt;</pre>
			<pre class="source-code">      constexpr static OutputIt copy(InputIt first, </pre>
			<pre class="source-code">                                     InputIt last, </pre>
			<pre class="source-code">                                     OutputIt d_first)</pre>
			<pre class="source-code">      {</pre>
			<pre class="source-code">         while (first != last)</pre>
			<pre class="source-code">         {</pre>
			<pre class="source-code">            *d_first++ = *first++;</pre>
			<pre class="source-code">         }</pre>
			<pre class="source-code">         return d_first;</pre>
			<pre class="source-code">      }</pre>
			<pre class="source-code">   };</pre>
			<pre class="source-code">   template &lt;&gt;</pre>
			<pre class="source-code">   struct copy_fn&lt;true&gt;</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      template&lt;typename InputIt, typename OutputIt&gt;</pre>
			<pre class="source-code">      constexpr static OutputIt* copy(</pre>
			<pre class="source-code">         InputIt* first, InputIt* last,</pre>
			<pre class="source-code">         OutputIt* d_first)</pre>
			<pre class="source-code">      {</pre>
			<pre class="source-code">         std::memmove(d_first, first, </pre>
			<pre class="source-code">                      (last - first) * sizeof(InputIt));</pre>
			<pre class="source-code">         return d_first + (last - first);</pre>
			<pre class="source-code">      }</pre>
			<pre class="source-code">   };</pre>
			<pre class="source-code">}</pre>
			<p>To copy memory between a source and a destination we use <strong class="source-inline">std::memmove</strong> here, which <a id="_idIndexMarker496"/>copies data even if objects overlap. These implementations <a id="_idIndexMarker497"/>are provided in a namespace called <strong class="source-inline">detail</strong>, because they are implementation details that are used in turn by the <strong class="source-inline">copy</strong> function and not directly by the user. The implementation of this generic <strong class="source-inline">copy</strong> algorithm could be as follows:</p>
			<pre class="source-code">template&lt;typename InputIt, typename OutputIt&gt;</pre>
			<pre class="source-code">constexpr OutputIt copy(InputIt first, InputIt last, </pre>
			<pre class="source-code">                        OutputIt d_first)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   using input_type = std::remove_cv_t&lt;</pre>
			<pre class="source-code">      typename std::iterator_traits&lt;InputIt&gt;::value_type&gt;;</pre>
			<pre class="source-code">   using output_type = std::remove_cv_t&lt;</pre>
			<pre class="source-code">      typename std::iterator_traits&lt;OutputIt&gt;::value_type&gt;;</pre>
			<pre class="source-code">   constexpr bool opt =</pre>
			<pre class="source-code">      std::is_same_v&lt;input_type, output_type&gt; &amp;&amp;</pre>
			<pre class="source-code">      std::is_pointer_v&lt;InputIt&gt; &amp;&amp;</pre>
			<pre class="source-code">      std::is_pointer_v&lt;OutputIt&gt; &amp;&amp;</pre>
			<pre class="source-code">      std::is_trivially_copy_assignable_v&lt;input_type&gt;;</pre>
			<pre class="source-code">   return detail::copy_fn&lt;opt&gt;::copy(first, last, d_first);</pre>
			<pre class="source-code">}</pre>
			<p>You can see here <a id="_idIndexMarker498"/>that the decision to select one specialization <a id="_idIndexMarker499"/>or the other is based on a <strong class="source-inline">constexpr</strong> Boolean value that is determined using the aforementioned type traits. Examples of using this <strong class="source-inline">copy</strong> function are shown in the next snippet:</p>
			<pre class="source-code">std::vector&lt;int&gt; v1{ 1, 2, 3, 4, 5 };</pre>
			<pre class="source-code">std::vector&lt;int&gt; v2(5);</pre>
			<pre class="source-code">// calls the generic implementation</pre>
			<pre class="source-code">copy(std::begin(v1), std::end(v1), std::begin(v2));</pre>
			<pre class="source-code">int a1[5] = { 1,2,3,4,5 };</pre>
			<pre class="source-code">int a2[5];</pre>
			<pre class="source-code">// calls the optimized implementation</pre>
			<pre class="source-code">copy(a1, a1 + 5, a2);</pre>
			<p>Keep in mind that this is not the real definition of the generic algorithm <strong class="source-inline">copy</strong> you will find in standard library implementations, which are further optimized. However, this was a good example to demonstrate how to use type traits for a real-world problem. </p>
			<p>For simplicity, I have defined the <strong class="source-inline">copy</strong> function in what appears to be the global namespace. This is a <a id="_idIndexMarker500"/>bad practice. In general, code, especially <a id="_idIndexMarker501"/>in libraries, is grouped in namespaces. In the source code on GitHub that accompanies the book, you will find this function defined in a namespace called <strong class="source-inline">n520</strong> (this is just a unique name, nothing relevant to the topic). When calling the <strong class="source-inline">copy</strong> function that we have defined, we would actually need to use the fully qualified name (that includes the namespace name) such as the following:</p>
			<pre class="source-code">n520::copy(std::begin(v1), std::end(v1), std::begin(v2));</pre>
			<p>Without this qualification, a process called <strong class="bold">Argument-Dependent Lookup</strong> (<strong class="bold">ADL</strong>) would kick in. This <a id="_idIndexMarker502"/>would result in resolving the call to <strong class="source-inline">copy</strong> to the <strong class="source-inline">std::copy</strong> function because the arguments we pass are found <a id="_idIndexMarker503"/>in the <strong class="source-inline">std</strong> namespace. You can read more about ADL at <a href="https://en.cppreference.com/w/cpp/language/adl">https://en.cppreference.com/w/cpp/language/adl</a>.</p>
			<p>Now, let’s look at another example.</p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor094"/>Building a homogenous variadic function template</h2>
			<p>For the <a id="_idIndexMarker504"/>second example, we want to <a id="_idIndexMarker505"/>build a variadic function template that can only take arguments of the same type or types that can be implicitly converted to a common one. Let’s start with the following skeleton definition:</p>
			<pre class="source-code">template&lt;typename... Ts&gt;</pre>
			<pre class="source-code">void process(Ts&amp;&amp;... ts) {}</pre>
			<p>The problem with this is that all of the following function calls work (keep in mind that the body of this function is empty so there will be no errors due to performing operations unavailable on some types):</p>
			<pre class="source-code">process(1, 2, 3);</pre>
			<pre class="source-code">process(1, 2.0, '3');</pre>
			<pre class="source-code">process(1, 2.0, "3");</pre>
			<p>In the first example, we pass three <strong class="source-inline">int</strong> values. In the second example, we pass an <strong class="source-inline">int</strong>, a <strong class="source-inline">double</strong>, and a <strong class="source-inline">char</strong>; both <strong class="source-inline">int</strong> and <strong class="source-inline">char</strong> are implicitly convertible to <strong class="source-inline">double</strong>, so this should be all right. However, in the third example, we pass an <strong class="source-inline">int</strong>, a <strong class="source-inline">double</strong>, and a <strong class="source-inline">char const*</strong>, and this last type is not implicitly convertible to either <strong class="source-inline">int</strong> or <strong class="source-inline">double</strong>. Therefore, this last call is supposed to trigger a compiler error but does not.</p>
			<p>In order to do so, we need to ensure that when a common type for the function arguments is not available, the compiler will generate an error. To do so, we can use a <strong class="source-inline">static_assert</strong> statement or <strong class="source-inline">std::enable_if</strong> and SFINAE. However, we do need to figure out whether a common type exists or not. This is possible with the help of the <strong class="source-inline">std::common_type</strong> type trait.</p>
			<p>The <strong class="source-inline">std::common_type</strong> is a metafunction that defines the common type among all of its type arguments that all the types can be implicitly converted to. Therefore <strong class="source-inline">std::common_type&lt;int, double, char&gt;::type</strong> will alias the <strong class="source-inline">double</strong> type. Using this <a id="_idIndexMarker506"/>type trait, we can build <a id="_idIndexMarker507"/>another type trait that tells us whether a common type exists. A possible implementation is as follows:</p>
			<pre class="source-code">template &lt;typename, typename... Ts&gt;</pre>
			<pre class="source-code">struct has_common_type : std::false_type {};</pre>
			<pre class="source-code">template &lt;typename... Ts&gt;</pre>
			<pre class="source-code">struct has_common_type&lt;</pre>
			<pre class="source-code">          std::void_t&lt;std::common_type_t&lt;Ts...&gt;&gt;, </pre>
			<pre class="source-code">          Ts...&gt;</pre>
			<pre class="source-code">   : std::true_type {};</pre>
			<pre class="source-code">template &lt;typename... Ts&gt;</pre>
			<pre class="source-code">constexpr bool has_common_type_v =</pre>
			<pre class="source-code">   sizeof...(Ts) &lt; 2 ||</pre>
			<pre class="source-code">   has_common_type&lt;void, Ts...&gt;::value;</pre>
			<p>You can see in this snippet that we base the implementation on several other type traits. First, there is the <strong class="source-inline">std::false_type</strong> and <strong class="source-inline">std::true_type</strong> pair. These are type aliases for <strong class="source-inline">std::bool_constant&lt;false&gt;</strong> and <strong class="source-inline">std::bool_constant&lt;true&gt;</strong> respectively. The <strong class="source-inline">std::bool_constant</strong> class is available in C++17 and is, in turn, an alias template for a specialization of the <strong class="source-inline">std::integral_constant</strong> class for the <strong class="source-inline">bool</strong> type. This last class template wraps a static <a id="_idIndexMarker508"/>constant of the specified <a id="_idIndexMarker509"/>type. Its conceptual implementation looks as follows (although some operations are also provided):</p>
			<pre class="source-code">template&lt;class T, T v&gt;</pre>
			<pre class="source-code">struct integral_constant</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   static constexpr T value = v;</pre>
			<pre class="source-code">   using value_type = T;</pre>
			<pre class="source-code">};</pre>
			<p>This helps us simplify the definition of type traits that need to define a Boolean compile-time value, as we saw in several cases in this chapter. </p>
			<p>A third type trait used in the implementation of the <strong class="source-inline">has_common_type</strong> class is <strong class="source-inline">std::void_t</strong>. This type trait defines a mapping between a variable number of types and the <strong class="source-inline">void</strong> type. We use this to build a mapping between the common type, if one exists, and the <strong class="source-inline">void</strong> type. This enables us to leverage SFINAE for the specialization of the <strong class="source-inline">has_common_type</strong> class template.</p>
			<p>Finally, a variable template called <strong class="source-inline">has_common_type_v</strong> is defined to ease the use of the <strong class="source-inline">has_common_type</strong> trait. </p>
			<p>All these can be used to modify the definition of the <strong class="source-inline">process</strong> function template to ensure it only allows arguments of a common type. A possible implementation is shown next:</p>
			<pre class="source-code">template&lt;typename... Ts,</pre>
			<pre class="source-code">         typename = std::enable_if_t&lt;</pre>
			<pre class="source-code">                       has_common_type_v&lt;Ts...&gt;&gt;&gt;</pre>
			<pre class="source-code">void process(Ts&amp;&amp;... ts) </pre>
			<pre class="source-code">{ }</pre>
			<p>As a result of this, calls such as <strong class="source-inline">process(1, 2.0, "3")</strong> will produce a compiler error because there is no overloaded <strong class="source-inline">process</strong> function for this set of arguments.</p>
			<p>As previously <a id="_idIndexMarker510"/>mentioned, there are different <a id="_idIndexMarker511"/>ways to use the <strong class="source-inline">has_common_type</strong> trait to achieve the defined goal. One of these, using <strong class="source-inline">std::enable_if</strong>, was shown here, but we can also use <strong class="source-inline">static_assert</strong>. However, a much better approach can be taken with the use of concepts, which we will see in the next chapter.</p>
			<h1 id="_idParaDest-90"><a id="_idTextAnchor095"/>Summary</h1>
			<p>This chapter explored the concept of type traits, which are small classes that define meta-information about types or transformation operations for types. We started by looking at how type traits can be implemented and how they help us. Next, we learned about <strong class="bold">SFINAE</strong>, which stands for <strong class="bold">Substitution Failure Is Not An Error</strong>. This is a technique that enables us to provide constraints for template parameters.</p>
			<p>We then saw how this purpose can be achieved better with <strong class="source-inline">enable_if</strong> and <strong class="source-inline">constexpr if</strong>, in C++17. In the second part of the chapter, we looked at the type traits available in the standard library and demonstrated how to use some of them. We ended the chapter with a couple of real-world examples where we used multiple type traits to solve a particular problem.</p>
			<p>In the next chapter, we continue the topic of constraining the template parameters by learning about the C++20 concepts and constraints.</p>
			<h1 id="_idParaDest-91"><a id="_idTextAnchor096"/>Questions</h1>
			<ol>
				<li>What are type traits?</li>
				<li>What is SFINAE?</li>
				<li>What is <strong class="source-inline">constexpr if</strong>?</li>
				<li>What does <strong class="source-inline">std::is_same</strong> do?</li>
				<li>What does <strong class="source-inline">std::conditional</strong> do?</li>
			</ol>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor097"/>Further reading</h1>
			<ul>
				<li><em class="italic">C++ Type traits</em>, John Maddock and Steve Cleary, <a href="https://cs.brown.edu/~jwicks/boost/libs/type_traits/cxx_type_traits.htm">https://cs.brown.edu/~jwicks/boost/libs/type_traits/cxx_type_traits.htm</a></li>
				<li><em class="italic">N4861 Post-Prague 2020 C++ working draft</em>, <a href="https://github.com/cplusplus/draft/releases/tag/n4861">https://github.com/cplusplus/draft/releases/tag/n4861</a></li>
				<li><em class="italic">What is ADL?</em>, Arthur O’Dwyer,<span class="hidden"> </span><a href="https://quuxplusone.github.io/blog/2019/04/26/what-is-adl/">https://quuxplusone.github.io/blog/2019<span id="_idTextAnchor098"/>/04/26/what-is-adl/</a></li>
			</ul>
		</div>
	</div></body></html>