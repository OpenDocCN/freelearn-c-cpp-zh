<html><head></head><body>
		<div id="_idContainer102">
			<h1 class="chapterNumber">Chapter <a id="_idTextAnchor316"/>12</h1>
			<h1 id="_idParaDest-168" class="chapterTitle" lang="en-GB" xml:lang="en-GB">The Most Recent <a id="_idTextAnchor317"/>C<a id="_idTextAnchor318"/></h1>
			<p class="normal">Change cannot be prevented, and C is no exception. The C <a id="_idIndexMarker837"/>programming language is standardized by an ISO standard, and it is constantly under revision by a group of people who are trying to make it better and bring new features to it. This doesn't mean that the language will necessarily get easier, however; we might see novel and complex features emerge in the language as new content is added.</p>
			<p class="normal">In this chapter, we are going to have a brief look at C11's features. You might know that C11 has replaced the old C99 standard, and it has been superseded by the C18 standard. In other words, C18 is the latest version of the C standard, and just before that we had C11.</p>
			<p class="normal">It's interesting to know that C18 doesn't offer any new features; it just contains fixes for the issues found in C11. Therefore, talking about C11 is basically the same as talking about C18, and it will lead us to the most recent C standard. As you can see, we are observing constant improvement in the C language… contrary to the belief that it is a long-dead language!</p>
			<p class="normal">This chapter will give a brief overview of the following topics:</p>
			<ul>
				<li class="list">How to detect the C version and how to write a piece of C code which is compatible with various C versions</li>
				<li class="list">New features for writing optimized and secure code, such as <em class="italics">no-return</em> functions and <em class="italics">bounds-checking</em> functions</li>
				<li class="list">New data types and memory alignment techniques</li>
				<li class="list">Type-generic functions</li>
				<li class="list">Unicode support in C11, which was missing from the language in the older standards</li>
				<li class="list">Anonymous structures and unions</li>
				<li class="list">Standard support for multithreading and synchronization techniques in C11</li>
			</ul>
			<p class="normal">Let's begin the chapter by talking about C11 and its new features.<a id="_idTextAnchor319"/></p>
			<h1 id="_idParaDest-169" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor320"/>C11</h1>
			<p class="normal">Gathering a new standard for <a id="_idIndexMarker838"/>a technology that has been in use for more than 30 years is not an easy task. Millions (if not billions!) of lines of C code exist, and if you are about to introduce new features, this must be done while keeping previous code or features intact. New features shouldn't create new problems for the existing programs, and they should be bug-free. While this view seems to be idealistic, it is something that we should be committed to.</p>
			<p class="normal">The following PDF document resides on the <em class="italics">Open Standards</em> website and contains the worries and thoughts that people in the <a id="_idIndexMarker839"/>C community had in mind before starting to shape C11: <span class="url">http://www.open-std.org/JTC1/SC22/wg14/www/docs/n1250.pdf</span>. It would be useful to give it a read because it will introduce you to the experience of authoring a new standard for a programming language that several thousand pieces of software have been built upo<a id="_idTextAnchor321"/>n.</p>
			<p class="normal">Finally, with these<a id="_idIndexMarker840"/> things in mind, we consider the release of C11. When C11 came out, it was not in its ideal form and was in fact suffering from some serious defects. You can see the list of these defects he<a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2244.htm">re: <span class="url">http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2244</span></a><span class="url">.htm</span>.</p>
			<p class="normal">Seven years after the launch of C11, C18 was introduced, which<a id="_idIndexMarker841"/> came about to fix the defects found in C11. Note that C18 is also <em class="italics">informally</em> referred to as C17, and both C17 and C18 refer to the same C<a id="_idIndexMarker842"/> standard. If you open the previous link you will see the defects and their current statuses. If the status of a defect is "C17," it means that the defect is solved as part of C18. This shows how hard and delicate process it is to assemble a standard that has as many users as C does.</p>
			<p class="normal">In the following sections, we'll talk about the new features of C11. Before going through them however, we need a way to be sure that we are really writing C11 code, and that we are using a compatible compiler. The following section will address this require<a id="_idTextAnchor322"/>ment.</p>
			<h1 id="_idParaDest-170" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor323"/>Finding a supported version of C standard</h1>
			<p class="normal">At the time of writing, it has been <a id="_idIndexMarker843"/>almost 8 years since C11 came out. Therefore, it would be expected that many compilers should support the standard, and this is indeed the case. Open source compilers such as <code class="Code-In-Text--PACKT-">gcc</code> and <code class="Code-In-Text--PACKT-">clang</code> both support C11 perfectly, and they can switch back to C99 or even older versions of C if needed. In this section, we show how to use specific macros to detect the C version and, depending on the version, how to use the supported features.</p>
			<p class="normal">The first thing that is <a id="_idIndexMarker844"/>necessary when using a compiler that supports different versions of the C standard is being able to identify which version of the C standard is currently in use. Every C standard defines a special macro that can be used to find out what version is being used. So far, we have used <code class="Code-In-Text--PACKT-">gcc</code> in Linux and <code class="Code-In-Text--PACKT-">clang</code> in macOS systems. As of version 4.7, <code class="Code-In-Text--PACKT-">gcc</code> offers C11 as one of its supported standards.</p>
			<p class="normal">Let's look at the following example and see how already-defined macros can be used to detect the current version of the C standard at runtime:</p>
			<p class="snippet code">#include &lt;stdio.h&gt;</p>
			<p class="snippet code">int main(int argc, char** argv) {</p>
			<p class="snippet code">#if __STDC_VERSION__ &gt;=  201710L</p>
			<p class="snippet code">  printf("Hello World from C18!\n");</p>
			<p class="snippet code">#elif __STDC_VERSION__ &gt;= 201112L</p>
			<p class="snippet code">  printf("Hello World from C11!\n");</p>
			<p class="snippet code">#elif __STDC_VERSION__ &gt;= 199901L</p>
			<p class="snippet code">  printf("Hello World from C99!\n");</p>
			<p class="snippet code">#else</p>
			<p class="snippet code">  printf("Hello World from C89/C90!\n");</p>
			<p class="snippet code">#endif</p>
			<p class="snippet code">  return 0;</p>
			<p class="snippet code">}</p>
			<p class="packt_figref">Code Box 12-1 [ExtremeC_examples_chapter12_1.c]: Detecting the version of the C standard</p>
			<p class="normal">As you can see, the preceding code can distinguish between various versions of the C standard. In order to see how various C versions can lead to various printings, we have to compile the preceding source code multiple times with various versions of C standard that are supported by the compiler.</p>
			<p class="normal">To ask the compiler to use a specific version of the C standard, we have to pass the -<code class="Code-In-Text--PACKT-">std=CXX</code> option to the C compiler. Look at the following commands and the produced output:</p>
			<p class="snippet shell"><strong class="highlight">$ gcc ExtremeC_examples_chapter12_1.c -o ex12_1.out</strong></p>
			<p class="snippet shell"><strong class="highlight">$ ./ex12_1.out</strong></p>
			<p class="snippet shell">Hello World from C11!</p>
			<p class="snippet shell"><strong class="highlight">$ gcc ExtremeC_examples_chapter12_1.c -o ex12_1.out -std=c11</strong></p>
			<p class="snippet shell"><strong class="highlight">$ ./ex12_1.out</strong></p>
			<p class="snippet shell">Hello World from C11!</p>
			<p class="snippet shell"><strong class="highlight">$ gcc ExtremeC_examples_chapter12_1.c -o ex12_1.out -std=c99</strong></p>
			<p class="snippet shell"><strong class="highlight">$ ./ex12_1.out</strong></p>
			<p class="snippet shell">Hello World from C99!</p>
			<p class="snippet shell"><strong class="highlight">$ gcc ExtremeC_examples_chapter12_1.c -o ex12_1.out -std=c90</strong></p>
			<p class="snippet shell"><strong class="highlight">$ ./ex12_1.out</strong></p>
			<p class="snippet shell">Hello World from C89/C90!</p>
			<p class="snippet shell"><strong class="highlight">$ gcc ExtremeC_examples_chapter12_1.c -o ex12_1.out -std=c89</strong></p>
			<p class="snippet shell"><strong class="highlight">$ ./ex12_1.out</strong></p>
			<p class="snippet shell">Hello World from C89/C90!</p>
			<p class="snippet shell"><strong class="highlight">$</strong></p>
			<p class="packt_figref">Shell Box 12-1: Compiling example 12.1 with various versions of C standard</p>
			<p class="normal">As you can see, the default C <a id="_idIndexMarker845"/>standard version in newer compilers is C11. With older versions, you have to specify the version using the <code class="Code-In-Text--PACKT-">-std</code> option, if you want to enable C11. Note the comments made at the beginning of the file. I have used <code class="Code-In-Text--PACKT-">/* ... */</code> comments (multiline comments) instead of <code class="Code-In-Text--PACKT-">//</code> comments (one-line comments). That's because one-line comments were not supported in standards before C99. Therefore, we had to use multiline comments in order to have the preceding code compiled with all C v<a id="_idTextAnchor324"/>ersions.</p>
			<h1 id="_idParaDest-171" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor325"/>Removal of the gets function</h1>
			<p class="normal">In C11, the famous <code class="Code-In-Text--PACKT-">gets</code> function<a id="_idIndexMarker846"/> is removed. The <code class="Code-In-Text--PACKT-">gets</code> function was subject to <em class="italics">buffer overflow</em> attacks, and in older versions it was decided to make the function <em class="italics">deprecated</em>. Later, as part of the C11 standard, it was removed. Therefore, older source code that uses the <code class="Code-In-Text--PACKT-">gets</code> function won't be compiled using a C11 compiler.</p>
			<p class="normal">The <code class="Code-In-Text--PACKT-">fgets</code> function can be used<a id="_idIndexMarker847"/> instead of <code class="Code-In-Text--PACKT-">gets</code>. The following is an excerpt from the <code class="Code-In-Text--PACKT-">gets</code> manual page (man page) in macOS:</p>
			<blockquote class="packt_quote">SECURITY CONSIDERATIONS </blockquote>
			<blockquote class="packt_quote">The gets() function cannot be used securely. Because of its lack of bounds checking, and the inability for the calling program to reliably determine the length of the next incoming line, the use of this function enables malicious users to arbitrarily change a running program's functionality through a buffer overflow attack. It is strongly suggested that the fgets() function be used in all cases. (See the FSA.)</blockquote>
			<h1 id="_idParaDest-172" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor326"/>Changes to fopen function</h1>
			<p class="normal">The <code class="Code-In-Text--PACKT-">fopen</code> function is usually<a id="_idIndexMarker848"/> used for opening a file and returning a file descriptor to that file. The concept of a file is very general in Unix, and by using the term <em class="italics">file</em>, we don't necessarily mean a file located on the filesystem. The <code class="Code-In-Text--PACKT-">fopen</code> function has the following signatures:</p>
			<p class="snippet code">FILE* fopen(const char *pathname, const char *mode);</p>
			<p class="snippet code">FILE* fdopen(int fd, const char *mode);</p>
			<p class="snippet code">FILE* freopen(const char *pathname, const char *mode, FILE *stream);</p>
			<p class="packt_figref">Code Box 12-2: Various signatures of the family of fopen functions</p>
			<p class="normal">As you can see, all of the preceding signatures accept a <code class="Code-In-Text--PACKT-">mode</code> input. This input parameter is a string that determines how the file should be opened. The following description in <em class="italics">Shell Box 12-2</em> is obtained from the FreeBSD manual for the <code class="Code-In-Text--PACKT-">fopen</code> function and explains how <code class="Code-In-Text--PACKT-">mode</code> should be used:</p>
			<p class="snippet shell"><strong class="highlight">$ man 3 fopen</strong></p>
			<p class="snippet shell">...</p>
			<p class="snippet shell">The argument mode points to a string beginning with one of the following letters:</p>
			<p class="snippet shell">     "r"     Open for reading.  The stream is positioned at the beginning</p>
			<p class="snippet shell">             of the file.  Fail if the file does not exist.</p>
			<p class="snippet shell">     "w"     Open for writing.  The stream is positioned at the beginning</p>
			<p class="snippet shell">             of the file.  Create the file if it does not exist.</p>
			<p class="snippet shell">     "a"     Open for writing.  The stream is positioned at the end of</p>
			<p class="snippet shell">             the file. Subsequent writes to the file will always end up</p>
			<p class="snippet shell">             at the then current end of file, irrespective of </p>
			<p class="snippet shell">             any intervening fseek(3) or similar. Create the file </p>
			<p class="snippet shell">             if it does not exist.</p>
			<p class="snippet shell">     An optional "+" following "r", "w", or "a" opens the file</p>
			<p class="snippet shell">     for both reading and writing.  <strong class="highlight">An optional "x" following "w" or</strong></p>
			<p class="snippet shell">     <strong class="highlight">"w+" causes the fopen() call to fail if the file already exists.</strong></p>
			<p class="snippet shell">     An optional "e" following the above causes the fopen() call to set</p>
			<p class="snippet shell">     the FD_CLOEXEC flag on the underlying file descriptor.</p>
			<p class="snippet shell">     The mode string can also include the letter "b" after either </p>
			<p class="snippet shell">     the "+" or the first letter.</p>
			<p class="snippet shell">...</p>
			<p class="snippet shell"><strong class="highlight">$</strong></p>
			<p class="packt_figref">Shell Box 12-2: An excerpt from the fopen's manual page in FreeBSD</p>
			<p class="normal">The mode <code class="Code-In-Text--PACKT-">x</code>, explained in the preceding extract from the <code class="Code-In-Text--PACKT-">fopen</code> manual page, has been introduced as part of C11. To <a id="_idIndexMarker849"/>open a file in order to write to it, the mode <code class="Code-In-Text--PACKT-">w</code> or <code class="Code-In-Text--PACKT-">w+</code> should be supplied to <code class="Code-In-Text--PACKT-">fopen</code>. The problem is that, if the file already exists, the <code class="Code-In-Text--PACKT-">w</code> or <code class="Code-In-Text--PACKT-">w+</code> mode will truncate (empty) the file.</p>
			<p class="normal">Therefore, if the programmer wants to append to a file and keep its current content, they have to use a different mode, <code class="Code-In-Text--PACKT-">a</code>. Hence, they have to check for the file's existence, using a filesystem API such as <code class="Code-In-Text--PACKT-">stat</code>, before calling <code class="Code-In-Text--PACKT-">fopen</code>, and then choose the proper mode based on the result. Now however, with the new mode <code class="Code-In-Text--PACKT-">x</code>, the programmer first tries with the mode <code class="Code-In-Text--PACKT-">wx</code> or <code class="Code-In-Text--PACKT-">w+x</code>, and if the file already exists the <code class="Code-In-Text--PACKT-">fopen</code> will fail. Then the programmer can continue with the <code class="Code-In-Text--PACKT-">a</code> mode.</p>
			<p class="normal">Thus, less boilerplate code needs to be written to open a file without using the filesystem API to check for the file's existence. From now on, <code class="Code-In-Text--PACKT-">fopen</code> is enough to open a file in every desired mode.</p>
			<p class="normal">Another change in C11 was the introduction of the <code class="Code-In-Text--PACKT-">fopen_s</code> API. This function serves as a secure <code class="Code-In-Text--PACKT-">fopen</code>. According to the <a id="_idIndexMarker850"/>documentation for <code class="Code-In-Text--PACKT-">fopen_s</code> found at <span class="url">https://en.cppreference.com/w/c/io/fopen</span>, performs extra checking on the provided buffers and their boundaries in order to detect any flaw in them.</p>
			<h1 id="_idParaDest-173" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor327"/>Bounds-checking functions</h1>
			<p class="normal">One of the serious problems with C programs operating on strings and byte arrays is the ability to go easily beyond the boundary defined for a buffer or a byte array.</p>
			<p class="normal">As a reminder, a buffer is a region of<a id="_idIndexMarker851"/> memory that is used as the place holder for a byte array or a string variable. Going beyond the boundary of a buffer causes a <em class="italics">buffer overflow</em> and based on that a malicious entity can organize an attack (usually called a <em class="italics">buffer overflow attack</em>). This type of attack either results in a <strong class="bold">denial of service</strong> (<strong class="bold">DOS</strong>) or in <em class="italics">exploitation</em> of the<a id="_idIndexMarker852"/> victim C program.</p>
			<p class="normal">Most such attacks usually start in a function operating on character or byte arrays. String manipulation functions found in <code class="Code-In-Text--PACKT-">string.h</code>, such as <code class="Code-In-Text--PACKT-">strcpy</code> and <code class="Code-In-Text--PACKT-">strcat</code>, are among the <em class="italics">vulnerable</em> functions that lack a boundary checking mechanism to prevent buffer overflow attacks.</p>
			<p class="normal">However, as part of C11, a new set of functions has been introduced. <em class="italics">Bounds-checking</em> functions borrow the same name from the string manipulation functions but with an <code class="Code-In-Text--PACKT-">_s</code> at the end. The suffix <code class="Code-In-Text--PACKT-">_s</code> distinguishes them as a <em class="italics">secure</em> or <em class="italics">safe</em> flavor of those functions that conduct more runtime checks in order to shut down the vulnerabilities. Functions such as <code class="Code-In-Text--PACKT-">strcpy_s</code> and <code class="Code-In-Text--PACKT-">strcat_s</code> have been introduced as part of bounds-checking functions in C11.</p>
			<p class="normal">These functions accept some extra arguments for the input buffers that restrict them from performing dangerous operations. As an example, the <code class="Code-In-Text--PACKT-">strcpy_s</code> function has the following signature:</p>
			<p class="snippet code">errno_t strcpy_s(char *restrict dest, rsize_t destsz, const char *restrict src);</p>
			<p class="packt_figref">Code Box 12-3: Signature of the strcpy_s function</p>
			<p class="normal">As you can see, the second argument is the length of the <code class="Code-In-Text--PACKT-">dest</code> buffer. Using that, the function performs some runtime checks, such as ensuring that the <code class="Code-In-Text--PACKT-">src</code> string is shorter than or at the same size of the <code class="Code-In-Text--PACKT-">dest</code> buffer in order to prevent writing to unal<a id="_idTextAnchor328"/>located memory.</p>
			<h1 id="_idParaDest-174" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor329"/>No-return functions</h1>
			<p class="normal">A function call can end either by <a id="_idIndexMarker853"/>using the <code class="Code-In-Text--PACKT-">return</code> keyword or by reaching the end of the function's block. There are also situations in which a function call never ends, and this is usually done intentionally. Look at the following code example contained in <em class="italics">Code Box 12-4</em>:</p>
			<p class="snippet code">void <strong class="highlight">main_loop()</strong> {</p>
			<p class="snippet code">  while (1) {</p>
			<p class="snippet code">    ...</p>
			<p class="snippet code">  }</p>
			<p class="snippet code">}</p>
			<p class="snippet code">  </p>
			<p class="snippet code">int <strong class="highlight">main</strong>(int argc, char** argv) {</p>
			<p class="snippet code">  ...</p>
			<p class="snippet code">  main_loop();</p>
			<p class="snippet code">  return 0;</p>
			<p class="snippet code">}</p>
			<p class="packt_figref">Code Box 12-4: Example of a function that never returns</p>
			<p class="normal">As you can see, the function <code class="Code-In-Text--PACKT-">main_loop</code> performs the main task of the program, and if we return from the<a id="_idIndexMarker854"/> function, the program could be considered as finished. In these exceptional cases, the compiler can perform some more optimizations, but somehow, it needs to know that the function <code class="Code-In-Text--PACKT-">main_loop</code> never returns.</p>
			<p class="normal">In C11, you have the ability to mark a function as a <em class="italics">no-return</em> function. The <code class="Code-In-Text--PACKT-">_Noreturn</code> keyword from the <code class="Code-In-Text--PACKT-">stdnoreturn.h</code> header file can be used to specify that a function never exits. So, the code in <em class="italics">Code Box 12-4</em> can be changed for C11 to look like this:</p>
			<p class="snippet code"><strong class="highlight">_Noreturn</strong> void main_loop() {</p>
			<p class="snippet code">  while (true) {</p>
			<p class="snippet code">    ...</p>
			<p class="snippet code">  }</p>
			<p class="snippet code">}</p>
			<p class="packt_figref">Code Box 12-5: Using the _Noreturn keyword to mark main_loop as a never-ending function</p>
			<p class="normal">There are other functions, such as <code class="Code-In-Text--PACKT-">exit</code>, <code class="Code-In-Text--PACKT-">quick_exit</code> (added recently as part of C11 for quick termination of the program), and <code class="Code-In-Text--PACKT-">abort</code>, that are considered to be no-return functions. In addition, knowing about no-return functions allows the compiler to recognize function calls that un<a id="_idTextAnchor330"/>intentionally won't return and produce proper warnings because they could be a sign <a id="_idTextAnchor331"/>of a logical bug. Note that if a function marked as <code class="Code-In-Text--PACKT-">_Noreturn</code> returns, then this would be an <em class="italics">undefined behavior</em> and it is highly discouraged.</p>
			<h1 id="_idParaDest-175" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor332"/>Type generic macros</h1>
			<p class="normal">In C11, a new keyword has been introduced: <code class="Code-In-Text--PACKT-">_Generic</code>. It can be used to write macros that are type-aware at compile<a id="_idIndexMarker855"/> time. In other words, you can write macros that can change their value based on the type of their arguments. This is usually called <em class="italics">generic selection</em>. Look at the following code example in <em class="italics">Code Box 12-6</em>:</p>
			<p class="snippet code">#include &lt;stdio.h&gt;</p>
			<p class="snippet code">#define abs(x) _Generic((x), \</p>
			<p class="snippet code">                        int: absi, \</p>
			<p class="snippet code">                        double: absd)(x)</p>
			<p class="snippet code">int absi(int a) {</p>
			<p class="snippet code">  return a &gt; 0 ? a : -a;</p>
			<p class="snippet code">}</p>
			<p class="snippet code">double absd(double a) {</p>
			<p class="snippet code">  return a &gt; 0 ? a : -a;</p>
			<p class="snippet code">}</p>
			<p class="snippet code">int main(int argc, char** argv) {</p>
			<p class="snippet code">  printf("abs(-2): %d\n", abs(-2));</p>
			<p class="snippet code">  printf("abs(2.5): %f\n", abs(2.5));;</p>
			<p class="snippet code">  return 0;</p>
			<p class="snippet code">}</p>
			<p class="packt_figref">Code Box 12-6: Example of a generic macro</p>
			<p class="normal">As you can see in the macro definition, we have used different expressions based on the type of the argument <code class="Code-In-Text--PACKT-">x</code>. We use <code class="Code-In-Text--PACKT-">absi</code> if it is an integer value, and <code class="Code-In-Text--PACKT-">absd</code> if it is a double value. This feature is not new to C11, and you can find it in older C compilers, but it wasn't part of the C standard. As of C11, it is now standard, and you can use this syntax to write <a id="_idTextAnchor333"/>type-aware macros.</p>
			<h1 id="_idParaDest-176" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor334"/>Unicode</h1>
			<p class="normal">One of the greatest<a id="_idIndexMarker856"/> features that has been added to the C11 standard is support for<a id="_idIndexMarker857"/> Unicode through UTF-8, UTF-16, and UTF-32 encodings. C was missing this feature for a long time, and C programmers had to use third-party libraries such as <strong class="bold">IBM International Components for Unicode</strong> (<strong class="bold">ICU</strong>) to fulfill their needs.</p>
			<p class="normal">Before C11, we only had <code class="Code-In-Text--PACKT-">char</code> and <code class="Code-In-Text--PACKT-">unsigned char</code> types, which were 8-bit variables used to store ASCII and Extended ASCII characters. By creating arrays of these ASCII characters, we could create<a id="_idIndexMarker858"/> ASCII strings.</p>
			<div>
				<div id="_idContainer100" class="note">
					<p class="Information-Box--PACKT-"><strong class="screen-text">Note</strong>:</p>
					<p class="Information-Box--PACKT-">ASCII standard has 128 characters <a id="_idIndexMarker859"/>which can be stored in 7 bits. Extended ASCII is an extension to ASCII which adds another 128 characters to make them together 256 characters. Then, an 8-bit or one-byte variable is enough to store all of them. In the upcoming text, we will only use the term ASCII, and by that we refer to both ASCII standard and Extended ASCII.</p>
				</div>
			</div>
			<p class="normal">Note that support for ASCII characters and strings is fundamental, and it will never be removed from C. Thus, we can be confident that we will always have ASCII support in C. From C11, they have added support for new characters, and therefore new strings that use a different number of bytes, not just one byte, for each character.</p>
			<p class="normal">To explain this further, in ASCII, we have one byte for each character. Therefore, the bytes and characters can be used interchangeably, but this is <em class="italics">not</em> true in general. Different encodings define new ways to store a wider range of characters in multiple bytes.</p>
			<p class="normal">In ASCII, altogether we have 256 characters. Therefore, a single one-byte (8-bit) character is enough to store all of them. If we are going to have more than 256 characters, however, we must use more than one byte to store their numerical values after 255. Characters that need <a id="_idIndexMarker860"/>more than one byte to store their values are usually called <em class="italics">wide characters</em>. By this definition, ASCII characters are not considered as wide characters.</p>
			<p class="normal">The Unicode standard introduced various<a id="_idIndexMarker861"/> methods of using more than one byte to encode all characters in ASCII, Extended ASCII, and wide characters. These methods are called <em class="italics">encodings</em>. Through Unicode, there are three well-known encodings: UTF-8, UTF-16, and UTF-32. UTF-8 uses the first byte for storing the first half of the ASCII characters, and the next bytes, usually up to 4 bytes, for the other half of ASCII characters together with all other wide characters. Hence, UTF-8 is considered as a variable-sized encoding. It uses certain bits in the first byte of the character to denote the number of actual bytes that should be read to retrieve the character fully. UTF-8 is considered a superset of ASCII because for ASCII characters (not Extended ASCII characters) the representation is the same.</p>
			<p class="normal">Like UTF-8, UTF-16 uses one or two <em class="italics">words</em> (each word has 16 bits within) for storing all characters; hence it is also a variable-sized encoding. UTF-32 uses exactly 4 bytes for storing the values of all characters; therefore, it is a fixed-sized encoding. UTF-8, and after that, UTF-16, are suitable for the applications in which a smaller number of bytes should be used for more frequent characters.</p>
			<p class="normal">UTF-32 uses a fixed number of <a id="_idIndexMarker862"/>bytes even for ASCII characters. So, it consumes more memory space to store strings using this encoding compared to others; but it requires less computation power when using UTF-32 characters. UTF-8 and UTF-16 can be considered as compressed<a id="_idIndexMarker863"/> encodings, but they need more computation to return the <a id="_idIndexMarker864"/>actual value of a character.</p>
			<div>
				<div id="_idContainer101" class="note">
					<p class="Information-Box--PACKT-"><strong class="screen-text">Note</strong>:</p>
					<p class="Information-Box--PACKT-">More information about UTF-8, UTF-16, and UTF-32 strings and<a id="_idIndexMarker865"/> how to decode them can be found on <a id="_idIndexMarker866"/>Wik<a href="https://unicodebook.readthedocs.io/unicode_encodings.html">ipedia or other<span id="_idIndexMarker867"/> sources like:</a></p>
					<p class="Information-Box--PACKT-"><a href="https://unicodebook.readthedocs.io/unicode_encodings.html"><span class="url">https://unicodebook.readth</span></a><span class="url">e</span><a href="https://javarevisited.blogspot.com/2015/02/difference-between-utf-8-utf-16-and-utf.html"><span class="url">docs.io/unicode_encodings.html</span></a></p>
					<p class="Information-Box--PACKT-"><a href="https://javarevisited.blogspot.com/2015/02/difference-between-utf-8-utf-16-and-utf.html"><span class="url">https://javarevisited.blogspot.com/2015/02/difference-be</span></a><span class="url">t</span><a href="https://unicodebook.readthedocs.io/unicode_encodings.html"><span class="url">ween-utf-8-utf-16-and-utf.html</span></a>.</p>
				</div>
			</div>
			<p class="normal">In C11 we have support for all the above Unicode encodings. Look at the following example, <em class="italics">example 12.3</em>. It defines various ASCII, UTF-8, UTF-16, and UTF-32 strings, and counts the number of actual bytes <a id="_idIndexMarker868"/>used to store them and the number of characters observed within them. We present the code in multiple steps in order to give additional comments on the code. The following code box demonstrates the inclusions and declarations required:</p>
			<p class="snippet code">#include &lt;stdlib.h&gt;</p>
			<p class="snippet code">#include &lt;stdio.h&gt;</p>
			<p class="snippet code">#include &lt;string.h&gt;</p>
			<p class="snippet code">#ifdef __APPLE__</p>
			<p class="snippet code">#include &lt;stdint.h&gt;</p>
			<p class="snippet code">typedef uint16_t char16_t;</p>
			<p class="snippet code">typedef uint32_t char32_t;</p>
			<p class="snippet code">#else</p>
			<p class="snippet code">#include &lt;uchar.h&gt; // Needed for char16_t and char32_t</p>
			<p class="snippet code">#endif</p>
			<p class="packt_figref">Code Box 12-7 [ExtremeC_examples_chapter12_3.c]: Inclusions and declarations required for example 12.3 to get built</p>
			<p class="normal">The preceding lines are the <code class="Code-In-Text--PACKT-">include</code> statements for <em class="italics">example 12.3</em>. As you can see, in macOS we do not have the <code class="Code-In-Text--PACKT-">uchar.h</code> header and we have to define new types for the <code class="Code-In-Text--PACKT-">char16_t</code> and <code class="Code-In-Text--PACKT-">char32_t</code> types. The whole functionality of Unicode strings is supported, however. On Linux, we don't have any issu<a id="_idTextAnchor335"/>es with Unicode support in C11.</p>
			<p class="normal">The next part of the code <a id="_idIndexMarker869"/>demonstrates the functions used for counting the number of bytes and characters in various kinds of Unicode strings. Note that no utility function is offered by C11 to operate on Unicode strings, therefore we have to write a new <code class="Code-In-Text--PACKT-">strlen</code> for them. In fact, our versions of <code class="Code-In-Text--PACKT-">strlen</code> functions do more just than returning the number of characters; they return the number of consumed bytes as well. The implementation details won't be described, but it is strongly recommended to give them a read:</p>
			<p class="snippet code">typedef struct {</p>
			<p class="snippet code">  long num_chars;</p>
			<p class="snippet code">  long num_bytes;</p>
			<p class="snippet code">} <strong class="highlight">unicode_len_t;</strong></p>
			<p class="snippet code">unicode_len_t <strong class="highlight">strlen_ascii</strong>(char* str) {</p>
			<p class="snippet code">  unicode_len_t res;</p>
			<p class="snippet code">  res.num_chars = 0;</p>
			<p class="snippet code">  res.num_bytes = 0;</p>
			<p class="snippet code">  if (!str) {</p>
			<p class="snippet code">    return res;</p>
			<p class="snippet code">  }</p>
			<p class="snippet code">  res.num_chars = strlen(str) + 1;</p>
			<p class="snippet code">  res.num_bytes = strlen(str) + 1;</p>
			<p class="snippet code">  return res;</p>
			<p class="snippet code">}</p>
			<p class="snippet code">unicode_len_t <strong class="highlight">strlen_u8</strong>(char* str) {</p>
			<p class="snippet code">  unicode_len_t res;</p>
			<p class="snippet code">  res.num_chars = 0;</p>
			<p class="snippet code">  res.num_bytes = 0;</p>
			<p class="snippet code">  if (!str) {</p>
			<p class="snippet code">    return res;</p>
			<p class="snippet code">  }</p>
			<p class="snippet code">  // Last null character</p>
			<p class="snippet code">  res.num_chars = 1;</p>
			<p class="snippet code">  res.num_bytes = 1;</p>
			<p class="snippet code">  while (*str) {</p>
			<p class="snippet code">    if ((*str | 0x7f) == 0x7f) { // 0x7f = 0b01111111</p>
			<p class="snippet code">      res.num_chars++;</p>
			<p class="snippet code">      res.num_bytes++;</p>
			<p class="snippet code">      str++;</p>
			<p class="snippet code">    } else if ((*str &amp; 0xc0) == 0xc0) { // 0xc0 = 0b11000000</p>
			<p class="snippet code">      res.num_chars++;</p>
			<p class="snippet code">      res.num_bytes += 2;</p>
			<p class="snippet code">      str += 2;</p>
			<p class="snippet code">    } else if ((*str &amp; 0xe0) == 0xe0) { // 0xe0 = 0b11100000</p>
			<p class="snippet code">      res.num_chars++;</p>
			<p class="snippet code">      res.num_bytes += 3;</p>
			<p class="snippet code">      str += 3;</p>
			<p class="snippet code">    } else if ((*str &amp; 0xf0) == 0xf0) { // 0xf0 = 0b11110000</p>
			<p class="snippet code">      res.num_chars++;</p>
			<p class="snippet code">      res.num_bytes += 4;</p>
			<p class="snippet code">      str += 4;</p>
			<p class="snippet code">    } else {</p>
			<p class="snippet code">      fprintf(stderr, "UTF-8 string is not valid!\n");</p>
			<p class="snippet code">      exit(1);</p>
			<p class="snippet code">    }</p>
			<p class="snippet code">  }</p>
			<p class="snippet code">  return res;</p>
			<p class="snippet code">}</p>
			<p class="snippet code">unicode_len_t <strong class="highlight">strlen_u16</strong>(char16_t* str) {</p>
			<p class="snippet code">  unicode_len_t res;</p>
			<p class="snippet code">  res.num_chars = 0;</p>
			<p class="snippet code">  res.num_bytes = 0;</p>
			<p class="snippet code">  if (!str) {</p>
			<p class="snippet code">    return res;</p>
			<p class="snippet code">  }</p>
			<p class="snippet code">  // Last null character</p>
			<p class="snippet code">  res.num_chars = 1;</p>
			<p class="snippet code">  res.num_bytes = 2;</p>
			<p class="snippet code">  while (*str) {</p>
			<p class="snippet code">    if (*str &lt; 0xdc00 || *str &gt; 0xdfff) {</p>
			<p class="snippet code">      res.num_chars++;</p>
			<p class="snippet code">      res.num_bytes += 2;</p>
			<p class="snippet code">      str++;</p>
			<p class="snippet code">    } else {</p>
			<p class="snippet code">      res.num_chars++;</p>
			<p class="snippet code">      res.num_bytes += 4;</p>
			<p class="snippet code">      str += 2;</p>
			<p class="snippet code">    }</p>
			<p class="snippet code">  }</p>
			<p class="snippet code">  return res;</p>
			<p class="snippet code">}</p>
			<p class="snippet code">unicode_len_t <strong class="highlight">strlen_u32</strong>(char32_t* str) {</p>
			<p class="snippet code">  unicode_len_t res;</p>
			<p class="snippet code">  res.num_chars = 0;</p>
			<p class="snippet code">  res.num_bytes = 0;</p>
			<p class="snippet code">  if (!str) {</p>
			<p class="snippet code">    return res;</p>
			<p class="snippet code">  }</p>
			<p class="snippet code">  // Last null character</p>
			<p class="snippet code">  res.num_chars = 1;</p>
			<p class="snippet code">  res.num_bytes = 4;</p>
			<p class="snippet code">  while (*str) {</p>
			<p class="snippet code">      res.num_chars++;</p>
			<p class="snippet code">      res.num_bytes += 4;</p>
			<p class="snippet code">      str++;</p>
			<p class="snippet code">  }</p>
			<p class="snippet code">  return res;</p>
			<p class="snippet code">}</p>
			<p class="packt_figref">Code Box 12-8 [ExtremeC_examples_chapter12_3.c]: The definitions of the functions used in example 12.3</p>
			<p class="normal">The last part is the <code class="Code-In-Text--PACKT-">main</code> function. It declares some different strings in English, Persian, and some alien language to <a id="_idIndexMarker870"/>evaluate the preceding functions:</p>
			<p class="snippet code">int <strong class="bold">main</strong>(int argc, char** argv) {</p>
			<p class="snippet code">  char ascii_string[32] = "Hello World!";</p>
			<p class="snippet code">  char utf8_string[32] = u8"Hello World!";</p>
			<p class="snippet code">  char utf8_string_2[32] = u8"درود دنیا!";</p>
			<p class="snippet code">  char16_t utf16_string[32] = u"Hello World!";</p>
			<p class="snippet code">  char16_t utf16_string_2[32] = u"درود دنیا!";</p>
			<p class="snippet code">  char16_t utf16_string_3[32] = u"হহহ!";</p>
			<p class="snippet code">  char32_t utf32_string[32] = U"Hello World!";</p>
			<p class="snippet code">  char32_t utf32_string_2[32] = U"درود دنیا!";</p>
			<p class="snippet code">  char32_t utf32_string_3[32] = U"হহহ!";</p>
			<p class="snippet code">  unicode_len_t len = strlen_ascii(ascii_string);</p>
			<p class="snippet code">  printf("Length of ASCII string:\t\t\t %ld chars, %ld bytes\n\n",</p>
			<p class="snippet code">      len.num_chars, len.num_bytes);</p>
			<p class="snippet code">  len = strlen_u8(utf8_string);</p>
			<p class="snippet code">  printf("Length of UTF-8 English string:\t\t %ld chars, %ld bytes\n",</p>
			<p class="snippet code">      len.num_chars, len.num_bytes);</p>
			<p class="snippet code">  len = strlen_u16(utf16_string);</p>
			<p class="snippet code">  printf("Length of UTF-16 english string:\t %ld chars, %ld bytes\n",</p>
			<p class="snippet code">      len.num_chars, len.num_bytes);</p>
			<p class="snippet code">  len = strlen_u32(utf32_string);</p>
			<p class="snippet code">  printf("Length of UTF-32 english string:\t %ld chars, %ld bytes\n\n",</p>
			<p class="snippet code">      len.num_chars, len.num_bytes);</p>
			<p class="snippet code">  len = strlen_u8(utf8_string_2);</p>
			<p class="snippet code">  printf("Length of UTF-8 Persian string:\t\t %ld chars, %ld bytes\n",</p>
			<p class="snippet code">      len.num_chars, len.num_bytes);</p>
			<p class="snippet code">  len = strlen_u16(utf16_string_2);</p>
			<p class="snippet code">  printf("Length of UTF-16 persian string:\t %ld chars, %ld bytes\n",</p>
			<p class="snippet code">      len.num_chars, len.num_bytes);</p>
			<p class="snippet code">  len = strlen_u32(utf32_string_2);</p>
			<p class="snippet code">  printf("Length of UTF-32 persian string:\t %ld chars, %ld bytes\n\n",</p>
			<p class="snippet code">      len.num_chars, len.num_bytes);</p>
			<p class="snippet code">  len = strlen_u16(utf16_string_3);</p>
			<p class="snippet code">  printf("Length of UTF-16 alien string:\t\t %ld chars, %ld bytes\n",</p>
			<p class="snippet code">      len.num_chars, len.num_bytes);</p>
			<p class="snippet code">  len = strlen_u32(utf32_string_3);</p>
			<p class="snippet code">  printf("Length of UTF-32 alien string:\t\t %ld chars, %ld bytes\n",</p>
			<p class="snippet code">      len.num_chars, len.num_bytes);</p>
			<p class="snippet code">  return 0;</p>
			<p class="snippet code">}</p>
			<p class="packt_figref">Code Box 12-9 [ExtremeC_examples_chapter12_3.c]: The main function of example 12.3</p>
			<p class="normal">Now, we must compile the preceding example. Note that the example can only be compiled using a C11 compiler. You<a id="_idIndexMarker871"/> can try using older compilers and take a look at the resulting errors. The following commands compile and run the preceding program:</p>
			<p class="snippet shell"><strong class="highlight">$ gcc ExtremeC_examples_chapter12_3.c -std=c11 -o ex12_3.out</strong></p>
			<p class="snippet shell"><strong class="highlight">$ ./ex12_3.out</strong></p>
			<p class="snippet shell">Length of ASCII string:            13 chars, 13 bytes</p>
			<p class="snippet shell">Length of UTF-8 english string:      13 chars, 13 bytes</p>
			<p class="snippet shell">Length of UTF-16 english string:     13 chars, 26 bytes</p>
			<p class="snippet shell">Length of UTF-32 english string:     13 chars, 52 bytes</p>
			<p class="snippet shell">Length of UTF-8 persian string:      11 chars, 19 bytes</p>
			<p class="snippet shell">Length of UTF-16 persian string:     11 chars, 22 bytes</p>
			<p class="snippet shell">Length of UTF-32 persian string:     11 chars, 44 bytes</p>
			<p class="snippet shell">Length of UTF-16 alien string:       5 chars, 14 bytes</p>
			<p class="snippet shell">Length of UTF-32 alien string:       5 chars, 20 bytes</p>
			<p class="snippet shell"><strong class="highlight">$</strong></p>
			<p class="packt_figref">Shell Box 12-3: Compiling and running example 12.3</p>
			<p class="normal">As you can see, the same string with the same number of characters uses a different number of bytes to encode and store the same value. UTF-8 uses the least number of bytes, especially when a large number of characters in a text are ASCII characters, simply because most of the characters will use only one byte.</p>
			<p class="normal">As we go through the characters that are more distinct<a id="_idIndexMarker872"/> from the Latin characters, such as characters in Asian languages, UTF-16 has a better balance between the number of characters and the number of used bytes, because most of the characters will use up to two bytes.</p>
			<p class="normal">UTF-32 is rarely used, but it <a id="_idIndexMarker873"/>can be used in systems where having a fixed-length <em class="italics">code print</em> for characters is useful; for example, if the system suffers from low computational power or is benefiting<a id="_idIndexMarker874"/> from some parallel processing pipelines. Therefore, UTF-32 characters can be used as keys in mappings from the characters to any kind of data. In other words, they can be used to build up some inde<a id="_idTextAnchor336"/>xes to look up data very quickly.</p>
			<h1 id="_idParaDest-177" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor337"/>Anonymous structures and anonymous unions</h1>
			<p class="normal">Anonymous structures and <a id="_idIndexMarker875"/>anonymous unions are type definitions without names, and they<a id="_idIndexMarker876"/> are usually used in other types as a nested type. It is easier to explain them with an example. Here, you can see a type that has both an anonymous structure and an anonymous union in one place, displayed in <em class="italics">Code Box 12-10</em>:</p>
			<p class="snippet code">typedef struct {</p>
			<p class="snippet code">  union {</p>
			<p class="snippet code">    struct {</p>
			<p class="snippet code">      int x;</p>
			<p class="snippet code">      int y;</p>
			<p class="snippet code">    };</p>
			<p class="snippet code">    int data[2];</p>
			<p class="snippet code">  };</p>
			<p class="snippet code">} <strong class="highlight">point_t;</strong></p>
			<p class="packt_figref">Code Box 12-10: Example of an anonymous structure together with an anonymous union</p>
			<p class="normal">The preceding type uses the same memory for the anonymous structure and the byte array field <code class="Code-In-Text--PACKT-">data</code>. The following code box shows how it can be used in a real example:</p>
			<p class="snippet code">#include &lt;stdio.h&gt;</p>
			<p class="snippet code">typedef struct {</p>
			<p class="snippet code">  union {</p>
			<p class="snippet code">    struct {</p>
			<p class="snippet code">      int x;</p>
			<p class="snippet code">      int y;</p>
			<p class="snippet code">    };</p>
			<p class="snippet code">    int data[2];</p>
			<p class="snippet code">  };</p>
			<p class="snippet code">} <strong class="highlight">point_t;</strong></p>
			<p class="snippet code">int <strong class="highlight">main</strong>(int argc, char** argv) {</p>
			<p class="snippet code">  point_t p;</p>
			<p class="snippet code">  p.x = 10;</p>
			<p class="snippet code">  p.data[1] = -5;</p>
			<p class="snippet code">  printf("Point (%d, %d) using an anonymous structure inside an anonymous union.\n", p.x, p.y);</p>
			<p class="snippet code">  printf("Point (%d, %d) using byte array inside an anonymous union.\n",</p>
			<p class="snippet code">      p.data[0], p.data[1]);</p>
			<p class="snippet code">  return 0;</p>
			<p class="snippet code">}</p>
			<p class="packt_figref">Code box 12-11 [ExtremeC_examples_chapter12_4.c]: The main function using an anonymous structure together with an anonymous union</p>
			<p class="normal">In this example we<a id="_idIndexMarker877"/> are creating an anonymous union that has an anonymous structure within. Therefore, the same memory region is used to store an instance of the<a id="_idIndexMarker878"/> anonymous structure and the two-element integer array. Next, you can see the output of the preceding program:</p>
			<p class="snippet shell"><strong class="highlight">$ gcc ExtremeC_examples_chapter12_4.c -std=c11 -o ex12_4.out</strong></p>
			<p class="snippet shell"><strong class="highlight">$ ./ex12_4.out</strong></p>
			<p class="snippet shell">Point (10, -5) using anonymous structure.</p>
			<p class="snippet shell">Point (10, -5) using anonymous byte array.</p>
			<p class="snippet shell"><strong class="highlight">$</strong></p>
			<p class="packt_figref">Shell Box 12-4: Compiling and running example 12.4</p>
			<p class="normal">As you can see, any changes to the two-element integer array can be seen in th<a id="_idTextAnchor338"/>e structure variable, and vice versa.</p>
			<h1 id="_idParaDest-178" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor339"/>Multithreading</h1>
			<p class="normal">Multithreading support has been <a id="_idIndexMarker879"/>available in C for a long time via POSIX threading functions, or the <code class="Code-In-Text--PACKT-">pthreads</code> library. We have covered multithreading thoroughly in <em class="italics">Chapter 15</em>, <em class="italics">Thread Execution</em>, and <em class="italics">Chapter 16</em>, <em class="italics">Thread Synchronization</em>.</p>
			<p class="normal">The POSIX threading library, as the name implies, is only available in POSIX-compliant systems such as Linux and other Unix-like systems. Therefore, if you are on a non-POSIX compliant operating system such as Microsoft Windows, you have to use the library provided by the operating system. As part of C11, a standard threading library is provided that can be used on<a id="_idIndexMarker880"/> all systems that are using standard C, regardless of whether it's POSIX-compliant or not. This is the biggest change we see in the C11 standard.</p>
			<p class="normal">Unfortunately, C11 threading is not imp<a id="_idTextAnchor340"/>lemented for Linux and macOS. Therefore, we cannot provide w<a id="_idTextAnchor341"/>orking examples at the time of writing.</p>
			<h1 id="_idParaDest-179" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor342"/>A bit about C18</h1>
			<p class="normal">As we've mentioned in the earlier<a id="_idIndexMarker881"/> sections, the C18 standard contains all the fixes that were made in C11, and no new feature has been introduced as part of it. As said before, the following link takes you to a page on which you can see the issues created and being tracked for C11 and the <a id="_idIndexMarker882"/>discussions around them: <span class="url">http://www.open-s<a id="_idTextAnchor343"/>td.org/jtc1/sc22/wg14/www/docs/n2244.htm</span>.</p>
			<h1 id="_idParaDest-180" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor344"/>Summary</h1>
			<p class="normal">In this chapter, we went through C11, C18, and the most recent C standards, and we explored C11's various new features. Unicode support, anonymous structures and unions, and the new standard threading library (despite the fact that it is not available in recent compilers and platforms to date) are among the most important features that have been introduced in modern C. We will look forward to seeing new versions of the C standard in the future.</p>
			<p class="normal">In the next chapter, we begin to talk about concurrency and the theory behind concurrent systems. This will begin a long journey through six chapters in which we'll cover multithreading and multi-processing in order to fulfil our purpose to be able to write concurrent systems.</p>
		</div>
</body></html>