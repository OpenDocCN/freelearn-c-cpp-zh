- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Writing Expressive Code with Lambdas
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Lambda 表达式编写表达性代码
- en: Lambda expressions in C++ allow us to write short blocks of code that encapsulate
    functionality and capture the surrounding state into a callable object. We can
    use `operator()` on a callable object to execute the functionality implemented
    in it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 中的 Lambda 表达式允许我们编写封装功能并将周围状态捕获到可调用对象中的短代码块。我们可以在可调用对象上使用 `operator()` 来执行其中实现的功能。
- en: Common uses of lambdas include passing a function object (also called a functor
    – an object of a class that overrides `operator()`) to standard library algorithms,
    or any code expecting a function object, encapsulating small blocks of code that
    are often used only in a single function, and variable initialization. Their ability
    to localize functionality without separate functions or class methods modernized
    C++, making it possible to write cleaner, more expressive code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 表达式的常见用途包括将函数对象（也称为函数对象 – 一个覆盖 `operator()` 的类的对象）传递给标准库算法，或任何期望函数对象的代码，封装通常仅在单个函数中使用的代码块，以及变量初始化。它们能够局部化功能而不需要单独的函数或类方法，使
    C++ 能够编写更干净、更具有表达性的代码。
- en: 'In embedded development, lambdas are especially useful for defining actions
    in response to timer or external interrupts, scheduling tasks, and similar event-driven
    mechanisms. The goal of this chapter is to learn how to use lambda expressions
    to write expressive C++ code. In this chapter, we’re going to cover the following
    main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌入式开发中，Lambda 表达式特别适用于定义对定时器或外部中断的反应动作、调度任务以及类似的事件驱动机制。本章的目标是学习如何使用 Lambda
    表达式编写具有表达性的 C++ 代码。在本章中，我们将涵盖以下主要主题：
- en: Lambda expression basics
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda 表达式基础
- en: Store lambdas using `std::function`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::function` 存储 Lambda 表达式
- en: '`std::function` and dynamic memory allocation'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::function` 和动态内存分配'
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To get the most out of this chapter, I strongly recommend using Compiler Explorer
    ([https://godbolt.org/](https://godbolt.org/)) as you read through the examples.
    Select GCC as your compiler and target x86 architecture. This will allow you to
    see standard output (stdio) results and better observe the code’s behavior. As
    we are using a lot of modern C++ features, make sure to select the C++23 standard
    by adding `-std=c++23` in the compiler options box.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用本章内容，我强烈建议在阅读示例时使用 Compiler Explorer ([https://godbolt.org/](https://godbolt.org/))。选择
    GCC 作为您的编译器，并选择 x86 架构。这将允许您看到标准输出（stdio）结果，并更好地观察代码的行为。由于我们使用了大量的现代 C++ 功能，请确保通过在编译器选项框中添加
    `-std=c++23` 来选择 C++23 标准。
- en: Compiler Explorer makes it easy to try out the code, tweak it, and immediately
    see how it affects the output and generated assembly. Most of the examples can
    also be run in the Renode simulator on the ARM Cortex-M0 target and are available
    on GitHub ([https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter10](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter10)).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Compiler Explorer 使得尝试代码、调整代码并立即看到它如何影响输出和生成的汇编变得容易。大多数示例也可以在 ARM Cortex-M0
    目标的 Renode 模拟器上运行，并在 GitHub 上提供（[https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter10](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter10)）。
- en: Lambda expression basics
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda 表达式基础
- en: '**Lambda expressions**, or lambdas, were introduced in C++11\. They are used
    to create an instance of an unnamed closure type in C++. A closure stores an unnamed
    function and can capture variables from its scope by value or reference. We can
    call `operator ()` on a lambda instance, with arguments specified in the lambda
    definition, effectively calling the underlying unnamed function. To draw a parallel
    with C, lambdas are callable in the same way as function pointers.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lambda 表达式**，或称为 Lambda，是在 C++11 中引入的。它们用于在 C++ 中创建未命名的闭包类型的实例。闭包存储一个未命名的函数，并且可以通过值或引用捕获其作用域中的变量。我们可以在
    Lambda 实例上调用 `operator ()`，并指定 Lambda 定义中的参数，从而有效地调用底层未命名的函数。为了与 C 语言进行比较，Lambda
    可以像函数指针一样调用。'
- en: 'We will now dive into an example to demonstrate how we can use lambdas in C++
    and explain details regarding lambda capturing. Let us process the example below:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将深入一个示例来展示如何在 C++ 中使用 Lambda 表达式，并解释有关 Lambda 捕获的细节。让我们处理以下示例：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Running the above example, we will get the following output:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述示例，我们将得到以下输出：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'What we see are outputs of the lambda `print_arr` used to print an array `arr`
    defined in the main function. Let’s go through the `print_arr` lambda in detail:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到的是 Lambda `print_arr` 的输出，该 Lambda 用于打印在主函数中定义的数组 `arr`。让我们详细分析 `print_arr`
    Lambda：
- en: The `[&arr]` syntax captures the variable arr by reference from the surrounding
    scope. This means the lambda can access and use arr directly within its body.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[&arr]` 语法通过引用从周围作用域捕获变量 arr。这意味着 lambda 可以在其主体中直接访问和使用 arr。'
- en: We can capture variables by value, or by reference if we prefix the name of
    a variable with `&` as we did for the `print_arr` lambda.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过值捕获变量，或者通过引用捕获，如果我们像 `print_arr` lambda 那样在变量名前加上 `&`。
- en: Capturing by reference `[&arr]` allows the lambda to see any changes made to
    `arr` outside the lambda after its definition. If we captured by value, the lambda
    would have its own copy of `arr`.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过引用捕获 `[&arr]` 允许 lambda 在其定义之后看到对 `arr` 在 lambda 外部所做的任何更改。如果我们通过值捕获，lambda
    将有自己的 `arr` 副本。
- en: By defining `print_arr` as a lambda within `main`, we encapsulate the functionality
    of printing the array without needing to create a separate function. This keeps
    related code together and enhances readability.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `main` 中定义 `print_arr` 为 lambda，我们封装了打印数组的函数功能，而不需要创建一个单独的函数。这使相关代码放在一起，并提高了可读性。
- en: 'In the same example, we used lambdas as predicate functions to the `std::sort`
    algorithm, to sort array `arr` first in ascending, then in descending order. We
    will go through this use case of lambdas in more detail:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在相同的示例中，我们使用了 lambda 作为 `std::sort` 算法的谓词函数，首先按升序排序数组 `arr`，然后按降序排序。我们将更详细地介绍
    lambda 的这个用例：
- en: The `std::sort` algorithm rearranges the elements of `arr` based on the comparator
    provided.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::sort` 算法根据提供的比较器重新排列 `arr` 的元素。'
- en: The lambda `[](int a, int b) { return a < b; }` acts as a comparator function
    for `std::sort`. It takes two integers and returns `true` if the first is less
    than the second, which results in an ascending sort.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: lambda `[](int a, int b) { return a < b; }` 作为 `std::sort` 的比较函数。它接受两个整数，如果第一个小于第二个则返回
    `true`，从而实现升序排序。
- en: The lambda `[](int a, int b) { return a > b; }` returns `true` if the first
    integer is greater than the second, resulting in a descending sort.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: lambda `[](int a, int b) { return a > b; }` 如果第一个整数大于第二个则返回 `true`，从而实现降序排序。
- en: Defining the comparator directly at the call site of `std::sort` makes the code
    more concise. It becomes immediately clear how the array is being sorted without
    needing to look elsewhere in the code.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `std::sort` 的调用位置直接定义比较器使代码更加简洁。无需查看代码的其他部分，就可以立即清楚地了解数组是如何排序的。
- en: 'In the cases of using lambdas with the `std::sort` algorithm, both lambdas
    are small and simple, making it easy to deduce what they return. Keeping lambdas
    short and straightforward is considered a good practice as it improves readability
    and makes the intent of the code immediately clear to others. We can also specify
    the lambda return type explicitly as in the following example:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 lambda 与 `std::sort` 算法的情况下，lambda 都很小且简单，这使得推断它们返回的内容变得容易。保持 lambda 短小直接被视为一种良好的实践，因为它提高了可读性，并使代码意图对他人来说一目了然。我们还可以在以下示例中显式指定
    lambda 的返回类型：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we explicitly defined the return type. This is optional and can be used
    when we want to be explicit about the type that a lambda returns. Also, note that
    the capture clause of this lambda is empty square brackets `[]`. This indicates
    that the lambda is not capturing any variables from the surrounding scope.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们显式地定义了返回类型。这是可选的，可以在我们想要明确 lambda 返回的类型时使用。此外，请注意，这个 lambda 的捕获子句是空方括号
    `[]`。这表示 lambda 没有从周围作用域捕获任何变量。
- en: When the lambda is capturing a variable by reference, it is important to note
    that this introduces lifetime dependency – meaning that the object that reference
    is bound to must exist when we call the lambda – else, we will use a so-called
    dangling reference, which is undefined behavior. This is especially a concern
    with asynchronous operations – that is, when a lambda is passed to a function
    and called later. Next, we will learn how to store lambdas using `std::function`
    to use them asynchronously.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当 lambda 通过引用捕获变量时，需要注意的是，这引入了生命周期依赖性——这意味着引用所绑定到的对象必须在调用 lambda 时存在——否则，我们将使用所谓的悬垂引用，这是未定义的行为。这在异步操作中尤其是一个问题——也就是说，当
    lambda 被传递给函数并在稍后调用时。接下来，我们将学习如何使用 `std::function` 存储lambda以异步使用它们。
- en: Storing lambdas using std::function
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 std::function 存储lambda
- en: '`std::function` is a class template that allows us to store, copy, and invoke
    callable objects such as function pointers and lambdas. We will go through a simple
    code example to demonstrate this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::function` 是一个类模板，允许我们存储、复制和调用可调用对象，如函数指针和 lambda。我们将通过一个简单的代码示例来演示这一点：'
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let us go through the example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来了解：
- en: In the `main` function, we first create an object fun of type `std::function<void()>`.
    This specifies that `fun` can store any callable object that returns `void` and
    takes no arguments. This includes function pointers, lambdas, or any object with
    an `operator()` that matches the signature.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `main` 函数中，我们首先创建一个类型为 `std::function<void()>` 的对象 fun。这指定了 `fun` 可以存储任何返回
    `void` 且不带参数的可调用对象。这包括函数指针、lambda 表达式或任何具有匹配签名的 `operator()` 的对象。
- en: We then assign a lambda to `fun` and invoke it, which prints the message “This
    is a lambda!” to the console.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们将一个 lambda 表达式赋值给 `fun` 并调用它，它将消息“这是一个 lambda！”打印到控制台。
- en: Next, we assigned another lambda to the `fun` object. This time the lambda captures
    the `uint32_t reg` by value from the surrounding scope and prints it. Capturing
    by value means the lambda makes its own copy of `reg` at the moment the lambda
    is defined.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们将另一个 lambda 表达式赋值给 `fun` 对象。这次 lambda 表达式通过值捕获周围作用域中的 `uint32_t reg` 并打印它。通过值捕获意味着
    lambda 表达式在定义时创建了 `reg` 的副本。
- en: We change the value of `reg` to `0` before invoking the callable object stored
    in `fun` to show it is being captured by value. Calling `fun` prints `Reg content
    0x12345678`.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调用存储在 `fun` 中的可调用对象之前，我们将 `reg` 的值更改为 `0`，以显示它是通过值捕获的。调用 `fun` 打印 `Reg content
    0x12345678`。
- en: 'Let’s use `std::function` in a more interesting example, where we will use
    it to store a callback to a GPIO interrupt. The code is below:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个更有趣的例子来使用 `std::function`，我们将使用它来存储一个 GPIO 中断的回调。以下是代码：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the code above, we created a `hal::gpio` class that represents a GPIO:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们创建了一个 `hal::gpio` 类来表示 GPIO：
- en: The class stores `std::function<void()> on_press_`, which can hold any callable
    object like a lambda function. It is initialized to nullptr to indicate it holds
    no callable object.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 该类存储 `std::function<void()> on_press_`，它可以持有任何可调用对象，如 lambda 函数。它被初始化为 nullptr，以表示它不持有任何可调用对象。
- en: It provides the method `execute_interrupt_handler`, which checks if `on_press_`
    evaluates to true, that is, if it stores a callable object, and executes it if
    it does.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了 `execute_interrupt_handler` 方法，该方法检查 `on_press_` 是否评估为 true，即它存储了一个可调用对象，并在必要时执行它。
- en: 'In the `main` function, we create `button1`, an object of class `hal::button`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 函数中，我们创建 `button1`，一个 `hal::button` 类的对象：
- en: We provide the constructor with a simple lambda that prints Button1 pressed!.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们向构造函数提供一个简单的 lambda 表达式，它会打印 Button1 pressed!。
- en: Next, we call the method `execute_interrupt_handler`, which invokes the stored
    lambda and the program prints `Button1 pressed!`.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们调用 `execute_interrupt_handler` 方法，它调用存储的 lambda 表达式，程序打印 `Button1 pressed!`。
- en: In a real firmware, we would call the method `execute_interrupt_handler` from
    an interrupt service.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际的固件中，我们会在中断服务中调用方法 `execute_interrupt_handler`。
- en: The above code is an example of the application of the **command pattern**,
    which is implemented in a simple and expressive way in C++ thanks to `std::function`
    and lambda expressions.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是命令模式应用的示例，它在 C++ 中通过 `std::function` 和 lambda 表达式以简单和表达的方式实现。
- en: The command pattern
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令模式
- en: The **command pattern** is a behavioral design pattern used to capture a function
    call together with required arguments – allowing us to execute those functions
    with a delay.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**命令模式**是一种行为设计模式，用于捕获一个函数调用及其所需参数 – 允许我们延迟执行这些函数。'
- en: 'We will go through a canonical definition of the command pattern. Let us start
    with a UML diagram of the pattern and explain it afterward:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论命令模式的经典定义。让我们从模式的 UML 图开始，然后进行解释：
- en: '![Figure 10.1 – Command pattern – UML diagram](img/B22402_10_01.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1 – 命令模式 – UML 图](img/B22402_10_01.png)'
- en: Figure 10.1 – Command pattern – UML diagram
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – 命令模式 – UML 图
- en: '*Figure 10**.1* depicts a UML diagram of the command pattern. We notice the
    following entities in the above diagram.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10**.1* 描述了命令模式的 UML 图。我们在上述图中注意到以下实体。'
- en: The `command` interface with a virtual `execute` method, and a `concrete_command`
    implementation of the interface.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 具有虚拟 `execute` 方法的 `command` 接口和 `concrete_command` 接口的具体实现。
- en: '`receiver`, stored by a reference in the `concrete_command` implementation.
    It performs an `action` that takes `params` as arguments.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`receiver`，在 `concrete_command` 实现中通过引用存储。它执行一个带 `params` 参数的 `action`。'
- en: '`invoker`, which stores a reference to the `command` interface and executes
    a `command`.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`invoker`，它存储对 `command` 接口的引用并执行一个 `command`。'
- en: '`client`, which creates a `receiver` and passes it to the constructor of `concrete_command`.
    It passes a reference of a created `concrete_command` to an `invoker`.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`client` 创建一个 `receiver` 并将其传递给 `concrete_command` 的构造函数。它将创建的 `concrete_command`
    的引用传递给 `invoker`。'
- en: By using the command interface, we are able to make different concrete commands
    and provide them to invokers. Instead of the command interface and concrete commands,
    we can use class template `std::function` and lambda expressions for the same
    purpose.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用命令接口，我们能够创建不同的具体命令并将它们提供给调用者。而不是使用命令接口和具体命令，我们可以使用类模板 `std::function` 和
    lambda 表达式来实现相同的目的。
- en: In our previous example, we created the `hal::gpio` class as an invoker from
    the command pattern. It has a `std::function<void()>` as a member – an equivalent
    to a command interface. A concrete command is a lambda expression that we stored
    in `std::function<void()>`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子中，我们创建了 `hal::gpio` 类作为命令模式的调用者。它有一个 `std::function<void()>` 成员 – 等同于命令接口。具体命令是我们存储在
    `std::function<void()>` 中的 lambda 表达式。
- en: '`receiver` is the lambda body – the `printf` function in our example – and
    `client` is the `main` function. The client creates a receiver (`hal::gpio button1`)
    and provides it with a concrete command (lambda expression). We call `execute_interrupt_handler`
    on the invoker directly from the `main` function.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`receiver` 是 lambda 体 – 在我们的例子中是 `printf` 函数 – 而 `client` 是 `main` 函数。客户端创建一个接收器（`hal::gpio
    button1`）并向它提供一个具体的命令（lambda 表达式）。我们直接从 `main` 函数中调用 `execute_interrupt_handler`。'
- en: Next, we will expand this example to call `execute_interrupt_handler` from the
    interrupt handler on the STM32 platform. The design will support interrupts from
    multiple pins. We will introduce the `gpio_interrupt_manager` entity, which will
    be responsible for registering invokers and calling the `execute_interrupt_handler`
    method on them.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将扩展这个例子，从 STM32 平台的中断处理程序中调用 `execute_interrupt_handler`。该设计将支持来自多个引脚的中断。我们将引入
    `gpio_interrupt_manager` 实体，它将负责注册调用者并在它们上调用 `execute_interrupt_handler` 方法。
- en: GPIO interrupt manager
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GPIO 中断管理器
- en: 'We want to utilize the `std::function` class template and lambda expressions
    to enable an expressive way of creating GPIO interrupt handlers in firmware as
    in the following code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望利用 `std::function` 类模板和 lambda 表达式来在固件中实现创建 GPIO 中断处理程序的表达式方式，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the code above, we are creating an object `button1` from the class template
    `hal::gpio_stm32` parametrized with `hal::port_a`. We are providing a constructor
    with `hal::pin::p4` and a lambda expression that will be executed on interrupt.
    This is a goal, an expressive interface for writing interrupt handlers that also
    allows us to capture surrounding variables if needed, thanks to lambda expressions.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们从一个由 `hal::port_a` 参数化的类模板 `hal::gpio_stm32` 中创建了一个 `button1` 对象。我们提供了一个带有
    `hal::pin::p4` 和 lambda 表达式的构造函数，该 lambda 表达式将在中断上执行。这是一个目标，一个用于编写中断处理程序的表达式接口，同时也允许我们通过
    lambda 表达式捕获所需的周围变量。
- en: From the code above, we can see both the pin and the port we are configuring
    and the callback that will be executed on the interrupt. The mechanism that we
    will create will handle interrupt handler registration to a central entity we
    will name `gpio_interrupt_manager`. Before we proceed with the design, please
    run the full example in Renode using the instructions below.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的代码中，我们可以看到我们正在配置的引脚和端口以及将在中断上执行的回调。我们将创建的机制将处理将中断处理程序注册到我们将命名为 `gpio_interrupt_manager`
    的中央实体。在我们继续设计之前，请按照以下说明在 Renode 中运行完整示例。
- en: 'Start Visual Studio Code, attach it to the running container, open the `Chapter10/lambdas`
    project as described in [*Chapter 4*](Chapter_04.xhtml), and run the following
    commands in the Visual Studio Code terminal, or run them directly in the container
    terminal:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Visual Studio Code，将其附加到正在运行的容器，按照 [*第 4 章*](Chapter_04.xhtml) 中所述打开 `Chapter10/lambdas`
    项目，并在 Visual Studio Code 终端中运行以下命令，或者在容器终端中直接运行它们：
- en: '[PRE6]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In Renode, we can simulate button press and release using the following command
    for `button1` and `button2`:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Renode 中，我们可以使用以下命令来模拟 `button1` 和 `button2` 的按键和释放：
- en: '[PRE7]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Entering the above command should result in the following output in the Renode
    console:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入上述命令应在 Renode 控制台中产生以下输出：
- en: '[PRE8]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As you can see, actions provided in lambdas are invoked by interrupts generated
    by buttons. Let us go through the UML diagram of this example to understand how
    it works:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在 lambda 中提供的操作是由按钮生成的中断调用的。让我们通过这个例子的 UML 图来了解它是如何工作的：
- en: '![Figure 10.2 – GPIO Interrupt manager UML diagram](img/B22402_10_02.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.2 – GPIO 中断管理器 UML 图](img/B22402_10_02.png)'
- en: Figure 10.2 – GPIO Interrupt manager UML diagram
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 – GPIO 中断管理器 UML 图
- en: 'In *Figure 10**.2*, we see the UML diagram of the GPIO interrupt manager. It
    is based on the command pattern. We are using `std::function<void()>` in place
    of the command interface and lambda expression for concrete commands. The invoker
    is the `hal::gpio` abstract class, which stores the lambda in the member `on_press`.
    It registers itself with `gpio_interrupt_manager` in the constructor as we can
    see from the following code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 10**.2 中，我们看到 GPIO 中断管理器的 UML 图。它基于命令模式。我们使用 `std::function<void()>` 代替命令接口和
    lambda 表达式作为具体命令。调用者是 `hal::gpio` 抽象类，它在成员 `on_press` 中存储 lambda。它如以下代码所示在构造函数中将自己注册到
    `gpio_interrupt_manager`：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`gpio_interrupt_manager` is a simple struct. It serves as a central entity
    for the interrupt handling mechanism with the following features:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`gpio_interrupt_manager` 是一个简单的结构体。它作为中断处理机制的中央实体，具有以下特性：'
- en: It contains an array of hal::gpio pointers – `std::array<gpio*, c_gpio_handlers_num>
    gpio_handlers`.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它包含一个 `hal::gpio` 指针数组 – `std::array<gpio*, c_gpio_handlers_num> gpio_handlers`。
- en: It provides a static method to register a `hal::gpio` pointer – `void register_interrupt_handler(gpio
    * pin)`.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了一个静态方法来注册一个 `hal::gpio` 指针 – `void register_interrupt_handler(gpio * pin)`。
- en: It provides a static method that executes interrupt handlers stored in the array
    – `void execute_interrupt_handlers()`.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了一个静态方法，用于执行存储在数组中的中断处理程序 – `void execute_interrupt_handlers()`。
- en: 'The method `execute_interrupt_handlers` is called from the interrupt service
    routine as shown below:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 `execute_interrupt_handlers` 如下所示从中断服务例程中调用：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`EXTI4_15_IRQHandler` is an interrupt service routine defined in the vector
    table (defined in platform/startup_stm32f072xb.s). That’s why we used `"C"` language
    linkage and implemented it as a global function. The `execute_interrupt_handlers`
    method loops through the array of `hal::gpio` pointers and calls the `execute_interrupt_handler`
    method on them as shown below:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`EXTI4_15_IRQHandler` 是在向量表中定义的中断服务例程（在 `platform/startup_stm32f072xb.s` 中定义）。这就是为什么我们使用了
    `"C"` 语言链接并将其实现为一个全局函数。`execute_interrupt_handlers` 方法遍历 `hal::gpio` 指针数组，并在它们上调用
    `execute_interrupt_handler` 方法，如下所示：'
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`hal::gpio` is an abstract class with the following features:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`hal::gpio` 是一个具有以下特性的抽象类：'
- en: It implements the `execute_interrupt_handler` method used by `gpio_interrupt_manager`
    as we saw earlier.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它实现了之前看到的 `gpio_interrupt_manager` 所使用的 `execute_interrupt_handler` 方法。
- en: It defines the pure virtual method `[[nodiscard]] virtual bool is_interrupt_generated()
    const = 0`. This method needs to be overridden by the derived class that implements
    platform-specific functionality.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它定义了一个纯虚方法 `[[nodiscard]] virtual bool is_interrupt_generated() const = 0`。此方法需要由实现特定平台功能的派生类重写。
- en: It defines the virtual method `virtual void clear_interrupt_flag() const = 0`.
    This method needs to be overridden by the derived class that implements platform-specific
    functionality.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它定义了一个虚拟方法 `virtual void clear_interrupt_flag() const = 0`。此方法需要由实现特定平台功能的派生类重写。
- en: 'The code for `execute_interrupt_handler` is shown below:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 下面展示了 `execute_interrupt_handler` 的代码：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `execute_interrupt_handler` method implements the following functionality:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`execute_interrupt_handler` 方法实现了以下功能：'
- en: It checks if the interrupt should be handled by the current object using the
    virtual method `is_interrupt_generated`. This method must be overridden by a derived
    class. The derived class has the data needed to determine if the generated interrupt
    needs to be addressed by the current object.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用虚拟方法 `is_interrupt_generated` 检查中断是否应由当前对象处理。此方法必须由派生类重写。派生类具有确定生成中断是否需要由当前对象处理所需的数据。
- en: If the interrupt should be addressed by the current object, the interrupt flag
    is cleared using the virtual method `clear_interrupt_flag` and `on_press_` is
    called if it stores a callable object.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果中断应由当前对象处理，则使用虚拟方法 `clear_interrupt_flag` 清除中断标志，如果它存储了一个可调用对象，则调用 `on_press_`。
- en: '`hal::gpio_stm32` is a class template derived from `hal::gpio`. We instantiate
    it with port as a parameter, and it implements platform-specific operations such
    as GPIO initialization using the vendor-provided C HAL library.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`hal::gpio_stm32` 是从 `hal::gpio` 派生出的类模板。我们用端口作为参数实例化它，并实现了平台特定的操作，例如使用供应商提供的
    C HAL 库进行 GPIO 初始化。'
- en: In the example, we instantiated `hal::gpio_stm32` with struct `port_a`, which
    contains the `void init_clock()` static function. This allows us to call a static
    method on the template parameter, instead of defining port as an `enum`, checking
    it in runtime, and calling a port-specific function for clock initialization.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们使用 `port_a` 结构体实例化了 `hal::gpio_stm32`，其中包含 `void init_clock()` 静态函数。这允许我们在模板参数上调用静态方法，而不是将端口定义为
    `enum`，在运行时进行检查，并调用特定端口的时钟初始化函数。
- en: 'The `hal::gpio_stm32` class template uses `hal::gpio` as a base class:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`hal::gpio_stm32` 类模板使用 `hal::gpio` 作为基类：'
- en: The constructor takes an enum pin and const reference to a `std::function<void()>`
    object that we use to initialize the base class in the initialization list.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数接受一个枚举引脚和一个对 `std::function<void()>` 对象的 const 引用，我们使用它来在初始化列表中初始化基类。
- en: '`[[nodiscard]] bool is_interrupt_generated() const` – the overridden method
    uses vendor-provided C HAL to determine if the interrupt was generated by the
    pin provided to the object through the constructor.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[[nodiscard]] bool is_interrupt_generated() const` – 重写的方法使用供应商提供的 C HAL 来确定是否由构造函数通过的对象提供的引脚生成了中断。'
- en: '`void clear_interrupt_flag() const` – the overridden method implements platform-specific
    code used to clear the interrupt flag.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void clear_interrupt_flag() const` – 重写的方法实现了用于清除中断标志的平台特定代码。'
- en: This sums up the implementation of the GPIO interrupt manager and explains the
    design. You can refer to other details of the implementation in the source code
    provided in the `Chapter10/lambdas` folder of the book’s GitHub repo.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这总结了 GPIO 中断管理器的实现，并解释了其设计。您可以在书籍 GitHub 仓库的 `Chapter10/lambdas` 文件夹中找到提供的源代码中的其他实现细节。
- en: Next, we will discuss the implications of using `std::function` on dynamic memory
    allocation.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论使用 `std::function` 对动态内存分配的影响。
- en: std::function and dynamic memory allocation
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`std::function` 和动态内存分配'
- en: '`std::function` needs to store all variables and references that a lambda captures.
    This behavior is implementation-defined, and implementations usually use heap,
    which is dynamic memory allocation to store large amounts of variables. If the
    captured data is small (on some platforms, 16 bytes), it will be stored on the
    stack. This is called small object optimization. To demonstrate the behavior of
    the `std::function` class template when capturing data, we will go through the
    following example:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::function` 需要存储 lambda 所捕获的所有变量和引用。这种行为是实现定义的，并且实现通常使用堆，即动态内存分配来存储大量变量。如果捕获的数据量小（在某些平台上，16字节），它将被存储在栈上。这被称为小对象优化。为了演示
    `std::function` 类模板在捕获数据时的行为，我们将通过以下示例进行说明：'
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the above example, we have overridden the operators `new` and `delete` to
    show that storing a lambda that captures an array of 6 integers will invoke dynamic
    memory allocation. If you run the above example in Compiler Explorer using `x86-64
    GCC 14.2`, you will see the following output:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，我们已经重写了 `new` 和 `delete` 操作符，以显示存储捕获了 6 个整数的 lambda 将会调用动态内存分配。如果您使用
    `x86-64 GCC 14.2` 在 Compiler Explorer 中运行上述示例，您将看到以下输出：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This example also demonstrates the initialization of variable `arr` by using
    a lambda to generate members of the array. If you change `constexpr std::size_t
    c_array_size` to 4, you will notice that the operators `new` and `delete` are
    no longer invoked, meaning that, in this case, the captured data is stored on
    the stack.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例还演示了通过 lambda 生成数组成员来初始化变量 `arr`。如果您将 `constexpr std::size_t c_array_size`
    改为 4，您将注意到 `new` 和 `delete` 操作符不再被调用，这意味着在这种情况下，捕获的数据存储在栈上。
- en: 'To get around this problem, we can assign `std::reference_wrapper` of a lambda
    object to `std::function<void()> fun` instead of the object itself as in the following
    line of code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以将 lambda 对象的 `std::reference_wrapper` 赋值给 `std::function<void()>
    fun`，而不是像以下代码行中那样赋值给对象本身：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This will make the `std::function` object use a reference wrapper to the lambda
    object, instead of copying it and storing all the variables that lambda is capturing.
    Using this approach, we must take care of the lambda object lifetime, meaning
    that if it goes out of scope and we try to invoke it through the `std::function`
    object, we will end up with undefined behavior of the program.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使 `std::function` 对象使用对 lambda 对象的引用包装器，而不是复制它并存储 lambda 所捕获的所有变量。使用这种方法，我们必须注意
    lambda 对象的生存期，这意味着如果它超出作用域，并且我们尝试通过 `std::function` 对象调用它，程序将出现未定义的行为。
- en: 'We can also use plain function pointers to store lambdas, but only if they
    don’t capture anything from the surrounding scope, as in the following example:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用普通的函数指针来存储lambda表达式，但前提是它们不捕获周围作用域中的任何内容，如下面的示例所示：
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the above example, we assign the lambda to a function pointer, making it
    a possible alternative to storing lambdas to the `std::function` class template
    in certain applications. This also makes it possible to pass non-capturing lambdas
    to C functions that expect function pointers.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，我们将lambda表达式赋值给函数指针，使其在某些应用中成为将lambda表达式存储到`std::function`类模板的可行替代方案。这也使得将非捕获lambda表达式传递给期望函数指针的C函数成为可能。
- en: Summary
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Lambda expressions and `std::function` are powerful modern C++ tools that allow
    us to write expressive code and implement design patterns such as command patterns
    in an elegant way. We learned about different ways to capture data from the surrounding
    scope – by value or a reference. We also went through the command pattern design
    pattern and learned how to apply it to a GPIO interrupt manager.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式和`std::function`是强大的现代C++工具，允许我们编写表达性代码并以优雅的方式实现设计模式，例如命令模式。我们学习了从周围作用域捕获数据的不同方法——通过值或引用。我们还探讨了命令模式设计模式，并学习了如何将其应用于GPIO中断管理器。
- en: In the next chapter, we will go through compile-time computation in C++.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍C++中的编译时计算。
