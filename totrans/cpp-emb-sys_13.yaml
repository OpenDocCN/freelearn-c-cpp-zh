- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing Expressive Code with Lambdas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lambda expressions in C++ allow us to write short blocks of code that encapsulate
    functionality and capture the surrounding state into a callable object. We can
    use `operator()` on a callable object to execute the functionality implemented
    in it.
  prefs: []
  type: TYPE_NORMAL
- en: Common uses of lambdas include passing a function object (also called a functor
    – an object of a class that overrides `operator()`) to standard library algorithms,
    or any code expecting a function object, encapsulating small blocks of code that
    are often used only in a single function, and variable initialization. Their ability
    to localize functionality without separate functions or class methods modernized
    C++, making it possible to write cleaner, more expressive code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In embedded development, lambdas are especially useful for defining actions
    in response to timer or external interrupts, scheduling tasks, and similar event-driven
    mechanisms. The goal of this chapter is to learn how to use lambda expressions
    to write expressive C++ code. In this chapter, we’re going to cover the following
    main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Lambda expression basics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store lambdas using `std::function`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::function` and dynamic memory allocation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get the most out of this chapter, I strongly recommend using Compiler Explorer
    ([https://godbolt.org/](https://godbolt.org/)) as you read through the examples.
    Select GCC as your compiler and target x86 architecture. This will allow you to
    see standard output (stdio) results and better observe the code’s behavior. As
    we are using a lot of modern C++ features, make sure to select the C++23 standard
    by adding `-std=c++23` in the compiler options box.
  prefs: []
  type: TYPE_NORMAL
- en: Compiler Explorer makes it easy to try out the code, tweak it, and immediately
    see how it affects the output and generated assembly. Most of the examples can
    also be run in the Renode simulator on the ARM Cortex-M0 target and are available
    on GitHub ([https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter10](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter10)).
  prefs: []
  type: TYPE_NORMAL
- en: Lambda expression basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Lambda expressions**, or lambdas, were introduced in C++11\. They are used
    to create an instance of an unnamed closure type in C++. A closure stores an unnamed
    function and can capture variables from its scope by value or reference. We can
    call `operator ()` on a lambda instance, with arguments specified in the lambda
    definition, effectively calling the underlying unnamed function. To draw a parallel
    with C, lambdas are callable in the same way as function pointers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now dive into an example to demonstrate how we can use lambdas in C++
    and explain details regarding lambda capturing. Let us process the example below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the above example, we will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'What we see are outputs of the lambda `print_arr` used to print an array `arr`
    defined in the main function. Let’s go through the `print_arr` lambda in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: The `[&arr]` syntax captures the variable arr by reference from the surrounding
    scope. This means the lambda can access and use arr directly within its body.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can capture variables by value, or by reference if we prefix the name of
    a variable with `&` as we did for the `print_arr` lambda.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capturing by reference `[&arr]` allows the lambda to see any changes made to
    `arr` outside the lambda after its definition. If we captured by value, the lambda
    would have its own copy of `arr`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By defining `print_arr` as a lambda within `main`, we encapsulate the functionality
    of printing the array without needing to create a separate function. This keeps
    related code together and enhances readability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the same example, we used lambdas as predicate functions to the `std::sort`
    algorithm, to sort array `arr` first in ascending, then in descending order. We
    will go through this use case of lambdas in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: The `std::sort` algorithm rearranges the elements of `arr` based on the comparator
    provided.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The lambda `[](int a, int b) { return a < b; }` acts as a comparator function
    for `std::sort`. It takes two integers and returns `true` if the first is less
    than the second, which results in an ascending sort.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The lambda `[](int a, int b) { return a > b; }` returns `true` if the first
    integer is greater than the second, resulting in a descending sort.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the comparator directly at the call site of `std::sort` makes the code
    more concise. It becomes immediately clear how the array is being sorted without
    needing to look elsewhere in the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the cases of using lambdas with the `std::sort` algorithm, both lambdas
    are small and simple, making it easy to deduce what they return. Keeping lambdas
    short and straightforward is considered a good practice as it improves readability
    and makes the intent of the code immediately clear to others. We can also specify
    the lambda return type explicitly as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, we explicitly defined the return type. This is optional and can be used
    when we want to be explicit about the type that a lambda returns. Also, note that
    the capture clause of this lambda is empty square brackets `[]`. This indicates
    that the lambda is not capturing any variables from the surrounding scope.
  prefs: []
  type: TYPE_NORMAL
- en: When the lambda is capturing a variable by reference, it is important to note
    that this introduces lifetime dependency – meaning that the object that reference
    is bound to must exist when we call the lambda – else, we will use a so-called
    dangling reference, which is undefined behavior. This is especially a concern
    with asynchronous operations – that is, when a lambda is passed to a function
    and called later. Next, we will learn how to store lambdas using `std::function`
    to use them asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: Storing lambdas using std::function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`std::function` is a class template that allows us to store, copy, and invoke
    callable objects such as function pointers and lambdas. We will go through a simple
    code example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us go through the example:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `main` function, we first create an object fun of type `std::function<void()>`.
    This specifies that `fun` can store any callable object that returns `void` and
    takes no arguments. This includes function pointers, lambdas, or any object with
    an `operator()` that matches the signature.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then assign a lambda to `fun` and invoke it, which prints the message “This
    is a lambda!” to the console.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we assigned another lambda to the `fun` object. This time the lambda captures
    the `uint32_t reg` by value from the surrounding scope and prints it. Capturing
    by value means the lambda makes its own copy of `reg` at the moment the lambda
    is defined.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We change the value of `reg` to `0` before invoking the callable object stored
    in `fun` to show it is being captured by value. Calling `fun` prints `Reg content
    0x12345678`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s use `std::function` in a more interesting example, where we will use
    it to store a callback to a GPIO interrupt. The code is below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the code above, we created a `hal::gpio` class that represents a GPIO:'
  prefs: []
  type: TYPE_NORMAL
- en: The class stores `std::function<void()> on_press_`, which can hold any callable
    object like a lambda function. It is initialized to nullptr to indicate it holds
    no callable object.
  prefs: []
  type: TYPE_NORMAL
- en: It provides the method `execute_interrupt_handler`, which checks if `on_press_`
    evaluates to true, that is, if it stores a callable object, and executes it if
    it does.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the `main` function, we create `button1`, an object of class `hal::button`:'
  prefs: []
  type: TYPE_NORMAL
- en: We provide the constructor with a simple lambda that prints Button1 pressed!.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we call the method `execute_interrupt_handler`, which invokes the stored
    lambda and the program prints `Button1 pressed!`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a real firmware, we would call the method `execute_interrupt_handler` from
    an interrupt service.
  prefs: []
  type: TYPE_NORMAL
- en: The above code is an example of the application of the **command pattern**,
    which is implemented in a simple and expressive way in C++ thanks to `std::function`
    and lambda expressions.
  prefs: []
  type: TYPE_NORMAL
- en: The command pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **command pattern** is a behavioral design pattern used to capture a function
    call together with required arguments – allowing us to execute those functions
    with a delay.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will go through a canonical definition of the command pattern. Let us start
    with a UML diagram of the pattern and explain it afterward:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Command pattern – UML diagram](img/B22402_10_01.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – Command pattern – UML diagram
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10**.1* depicts a UML diagram of the command pattern. We notice the
    following entities in the above diagram.'
  prefs: []
  type: TYPE_NORMAL
- en: The `command` interface with a virtual `execute` method, and a `concrete_command`
    implementation of the interface.
  prefs: []
  type: TYPE_NORMAL
- en: '`receiver`, stored by a reference in the `concrete_command` implementation.
    It performs an `action` that takes `params` as arguments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`invoker`, which stores a reference to the `command` interface and executes
    a `command`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`client`, which creates a `receiver` and passes it to the constructor of `concrete_command`.
    It passes a reference of a created `concrete_command` to an `invoker`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By using the command interface, we are able to make different concrete commands
    and provide them to invokers. Instead of the command interface and concrete commands,
    we can use class template `std::function` and lambda expressions for the same
    purpose.
  prefs: []
  type: TYPE_NORMAL
- en: In our previous example, we created the `hal::gpio` class as an invoker from
    the command pattern. It has a `std::function<void()>` as a member – an equivalent
    to a command interface. A concrete command is a lambda expression that we stored
    in `std::function<void()>`.
  prefs: []
  type: TYPE_NORMAL
- en: '`receiver` is the lambda body – the `printf` function in our example – and
    `client` is the `main` function. The client creates a receiver (`hal::gpio button1`)
    and provides it with a concrete command (lambda expression). We call `execute_interrupt_handler`
    on the invoker directly from the `main` function.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will expand this example to call `execute_interrupt_handler` from the
    interrupt handler on the STM32 platform. The design will support interrupts from
    multiple pins. We will introduce the `gpio_interrupt_manager` entity, which will
    be responsible for registering invokers and calling the `execute_interrupt_handler`
    method on them.
  prefs: []
  type: TYPE_NORMAL
- en: GPIO interrupt manager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We want to utilize the `std::function` class template and lambda expressions
    to enable an expressive way of creating GPIO interrupt handlers in firmware as
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the code above, we are creating an object `button1` from the class template
    `hal::gpio_stm32` parametrized with `hal::port_a`. We are providing a constructor
    with `hal::pin::p4` and a lambda expression that will be executed on interrupt.
    This is a goal, an expressive interface for writing interrupt handlers that also
    allows us to capture surrounding variables if needed, thanks to lambda expressions.
  prefs: []
  type: TYPE_NORMAL
- en: From the code above, we can see both the pin and the port we are configuring
    and the callback that will be executed on the interrupt. The mechanism that we
    will create will handle interrupt handler registration to a central entity we
    will name `gpio_interrupt_manager`. Before we proceed with the design, please
    run the full example in Renode using the instructions below.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start Visual Studio Code, attach it to the running container, open the `Chapter10/lambdas`
    project as described in [*Chapter 4*](Chapter_04.xhtml), and run the following
    commands in the Visual Studio Code terminal, or run them directly in the container
    terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In Renode, we can simulate button press and release using the following command
    for `button1` and `button2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Entering the above command should result in the following output in the Renode
    console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you can see, actions provided in lambdas are invoked by interrupts generated
    by buttons. Let us go through the UML diagram of this example to understand how
    it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – GPIO Interrupt manager UML diagram](img/B22402_10_02.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – GPIO Interrupt manager UML diagram
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 10**.2*, we see the UML diagram of the GPIO interrupt manager. It
    is based on the command pattern. We are using `std::function<void()>` in place
    of the command interface and lambda expression for concrete commands. The invoker
    is the `hal::gpio` abstract class, which stores the lambda in the member `on_press`.
    It registers itself with `gpio_interrupt_manager` in the constructor as we can
    see from the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`gpio_interrupt_manager` is a simple struct. It serves as a central entity
    for the interrupt handling mechanism with the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: It contains an array of hal::gpio pointers – `std::array<gpio*, c_gpio_handlers_num>
    gpio_handlers`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides a static method to register a `hal::gpio` pointer – `void register_interrupt_handler(gpio
    * pin)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides a static method that executes interrupt handlers stored in the array
    – `void execute_interrupt_handlers()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The method `execute_interrupt_handlers` is called from the interrupt service
    routine as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`EXTI4_15_IRQHandler` is an interrupt service routine defined in the vector
    table (defined in platform/startup_stm32f072xb.s). That’s why we used `"C"` language
    linkage and implemented it as a global function. The `execute_interrupt_handlers`
    method loops through the array of `hal::gpio` pointers and calls the `execute_interrupt_handler`
    method on them as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`hal::gpio` is an abstract class with the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: It implements the `execute_interrupt_handler` method used by `gpio_interrupt_manager`
    as we saw earlier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It defines the pure virtual method `[[nodiscard]] virtual bool is_interrupt_generated()
    const = 0`. This method needs to be overridden by the derived class that implements
    platform-specific functionality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It defines the virtual method `virtual void clear_interrupt_flag() const = 0`.
    This method needs to be overridden by the derived class that implements platform-specific
    functionality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code for `execute_interrupt_handler` is shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `execute_interrupt_handler` method implements the following functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: It checks if the interrupt should be handled by the current object using the
    virtual method `is_interrupt_generated`. This method must be overridden by a derived
    class. The derived class has the data needed to determine if the generated interrupt
    needs to be addressed by the current object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the interrupt should be addressed by the current object, the interrupt flag
    is cleared using the virtual method `clear_interrupt_flag` and `on_press_` is
    called if it stores a callable object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hal::gpio_stm32` is a class template derived from `hal::gpio`. We instantiate
    it with port as a parameter, and it implements platform-specific operations such
    as GPIO initialization using the vendor-provided C HAL library.'
  prefs: []
  type: TYPE_NORMAL
- en: In the example, we instantiated `hal::gpio_stm32` with struct `port_a`, which
    contains the `void init_clock()` static function. This allows us to call a static
    method on the template parameter, instead of defining port as an `enum`, checking
    it in runtime, and calling a port-specific function for clock initialization.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `hal::gpio_stm32` class template uses `hal::gpio` as a base class:'
  prefs: []
  type: TYPE_NORMAL
- en: The constructor takes an enum pin and const reference to a `std::function<void()>`
    object that we use to initialize the base class in the initialization list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[[nodiscard]] bool is_interrupt_generated() const` – the overridden method
    uses vendor-provided C HAL to determine if the interrupt was generated by the
    pin provided to the object through the constructor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void clear_interrupt_flag() const` – the overridden method implements platform-specific
    code used to clear the interrupt flag.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This sums up the implementation of the GPIO interrupt manager and explains the
    design. You can refer to other details of the implementation in the source code
    provided in the `Chapter10/lambdas` folder of the book’s GitHub repo.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss the implications of using `std::function` on dynamic memory
    allocation.
  prefs: []
  type: TYPE_NORMAL
- en: std::function and dynamic memory allocation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`std::function` needs to store all variables and references that a lambda captures.
    This behavior is implementation-defined, and implementations usually use heap,
    which is dynamic memory allocation to store large amounts of variables. If the
    captured data is small (on some platforms, 16 bytes), it will be stored on the
    stack. This is called small object optimization. To demonstrate the behavior of
    the `std::function` class template when capturing data, we will go through the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the above example, we have overridden the operators `new` and `delete` to
    show that storing a lambda that captures an array of 6 integers will invoke dynamic
    memory allocation. If you run the above example in Compiler Explorer using `x86-64
    GCC 14.2`, you will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This example also demonstrates the initialization of variable `arr` by using
    a lambda to generate members of the array. If you change `constexpr std::size_t
    c_array_size` to 4, you will notice that the operators `new` and `delete` are
    no longer invoked, meaning that, in this case, the captured data is stored on
    the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get around this problem, we can assign `std::reference_wrapper` of a lambda
    object to `std::function<void()> fun` instead of the object itself as in the following
    line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This will make the `std::function` object use a reference wrapper to the lambda
    object, instead of copying it and storing all the variables that lambda is capturing.
    Using this approach, we must take care of the lambda object lifetime, meaning
    that if it goes out of scope and we try to invoke it through the `std::function`
    object, we will end up with undefined behavior of the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use plain function pointers to store lambdas, but only if they
    don’t capture anything from the surrounding scope, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the above example, we assign the lambda to a function pointer, making it
    a possible alternative to storing lambdas to the `std::function` class template
    in certain applications. This also makes it possible to pass non-capturing lambdas
    to C functions that expect function pointers.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lambda expressions and `std::function` are powerful modern C++ tools that allow
    us to write expressive code and implement design patterns such as command patterns
    in an elegant way. We learned about different ways to capture data from the surrounding
    scope – by value or a reference. We also went through the command pattern design
    pattern and learned how to apply it to a GPIO interrupt manager.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will go through compile-time computation in C++.
  prefs: []
  type: TYPE_NORMAL
