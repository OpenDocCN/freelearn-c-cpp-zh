<html><head></head><body><div><div><div><h1 class="chapterNumber">8</h1>
    <h1 id="_idParaDest-218" class="chapterTitle">An Introduction to Collision Detection</h1>
    <p class="normal">Welcome to <a href=""><em class="italic">Chapter 8</em></a>! In the previous chapter, we extended the instance animation system. We started by adding lookup tables for the animation transforms and moved the computations to the GPU. Next, we added movement states and UI controls to the application to create mappings between states and animation clips. As the last step, we updated the YAML parser to save and restore the animation clip mappings.</p>
    <p class="normal">In this chapter, we will implement a two-tier collision detection for the instances. We will start with an exploration of the complexity of collision detection, and how to lower the complexity by removing instances based on their distance and by simplifying the representation of the instances. Then, we will discuss methods to simplify the instances to minimize the number of intersection checks even more. Next, we will implement a quadtree to limit the number of instances to check, and finally, we will add bounding spheres to the instances to create the two tiers of collision detection.</p>
    <p class="normal">In this chapter, we will cover the following topics:</p>
    <ul>
      <li class="bulletList">The complexities of collision detection</li>
      <li class="bulletList">Using spatial partitioning to reduce complexity</li>
      <li class="bulletList">Simplifying the instances for faster collision checks</li>
      <li class="bulletList">Adding a quadtree to store nearby model instances</li>
      <li class="bulletList">Implementing bounding spheres</li>
    </ul>
    <h1 id="_idParaDest-219" class="heading-1">Technical requirements</h1>
    <p class="normal">The example code is in the <code class="inlineCode">chapter08</code> folder, in the subfolders <code class="inlineCode">01_opengl_collisions</code> for OpenGL and <code class="inlineCode">02_vulkan_collisions</code> for Vulkan.</p>
    <h1 id="_idParaDest-220" class="heading-1">The complexities of collision detection</h1>
    <p class="normal">We already talked about the complexity of finding a collision in <a href="Chapter_3.xhtml"><em class="italic">Chapter 3</em></a> when deciding how to implement a visual selection, either using ray shooting or buffer drawing. We’ve chosen to draw the instances into a separate buffer, avoiding collision detection entirely.</p>
    <p class="normal">Now is the right time to do a short reprise of the complex topic and to present solutions to accelerate finding collisions between instances.</p>
    <h2 id="_idParaDest-221" class="heading-2">Avoiding the naive way</h2>
    <p class="normal">If we would check every triangle of every instance against all triangles of all other instances for collisions in the virtual <a id="_idIndexMarker351"/>world, this would come with immense processing costs. These simple, brute-force collision checks would grow exponentially, making it impossible to keep up a reasonable frame time when adding more and more instances.</p>
    <p class="normal">Instead of using the naive solution, we should take a step back and think about possible types of simplification before implementing any kind of collision detection.</p>
    <p class="normal">One idea is to reduce the number of instances we have to check against. Why bother with instances in distant parts of the virtual world? Even if our object is some kind of bullet, rocket, or other flying entity, all we can possibly hit needs to be “less than an arm’s length” away from us. All other objects can be safely ignored.</p>
    <p class="normal">To achieve this reduction, we can split the world into different areas. And suddenly, we only have to check the area we are in. Maybe we have to check adjacent areas too, depending on the algorithm we use, but the total number of instances we have to check against can be reduced by a large amount.</p>
    <p class="normal">On the other hand, we can lower the computational work for collision detection by reducing the amount of surface elements to test if we are even close to any of the triangles of the instance. Any kind of simplification will become handy; the fewer intersections to test, the better.</p>
    <p class="normal">Representing an instance as a box or sphere may produce a lot of false results, but if the collision check against the box or sphere around the instance already fails, we can immediately sort out this instance from our list of possible collision targets.</p>
    <p class="normal">Both ideas combined – reducing the number of instances to check and lowering the complexity of the instance checks – help to do collision checks in real time, even with larger numbers of detailed models.</p>
    <p class="normal">Let’s start with the spatial partitioning of the virtual world.</p>
    <h1 id="_idParaDest-222" class="heading-1">Using spatial partitioning to reduce complexity</h1>
    <p class="normal">In this section, we will take a look at some <a id="_idIndexMarker352"/>methods to split our world space into different parts, lowering the number of instances in each of the parts. We start with the simplest variant of spatial partitioning in two or three dimensions, the grid.</p>
    <h2 id="_idParaDest-223" class="heading-2">Grid</h2>
    <p class="normal">In a <strong class="keyWord">grid</strong>, the virtual lines<a id="_idIndexMarker353"/> divide the virtual world into equally sized squares or rectangles, or equally<a id="_idIndexMarker354"/> sized cubes and cuboids.</p>
    <figure class="mediaobject"><img src="img/B22428_08_01.png" alt="" width="751" height="344"/></figure>
    <p class="packt_figref">Figure 8.1: 2D and 3D grids</p>
    <p class="normal">While grids are easy to create, <em class="italic">Figure 8.1</em> already shows some of the problems. Objects larger than the grid spacing must be placed into all overlapping grid fields, requiring checking all affected fields for other instances.</p>
    <p class="normal">And while the vast majority of the grid will remain empty, “crowded places” inside the virtual world can lead to many instances inside a single field of the grid. Many instances mean many checks, and an uneven distribution of instances may cause slowdowns due to the number of calculations.</p>
    <p class="normal">A sort of successor to the grid is the quadtree. A quadtree addresses the uneven distribution problem of the grid.</p>
    <h2 id="_idParaDest-224" class="heading-2">Quadtree</h2>
    <p class="normal">The basic element of a <strong class="keyWord">quadtree</strong> is a single cell, being either a square or a rectangle. We will only use square cells for the description, but <a id="_idIndexMarker355"/>all holds true for rectangle-shaped cells, too. Objects<a id="_idIndexMarker356"/> are inserted with their position and sizes into the root cell, usually by using a two-dimensional bounding box covering the extents of the object.</p>
    <p class="normal">The magic part of a quadtree starts when a configurable threshold of objects per cell has been hit. The affected cell is subdivided into four equally sized child cells. Any object overlapping one or more children could be either kept in the parent cell or added to all affected child cells, depending on the implementation. All other objects are moved into the respective child cell. See <em class="italic">Figure 8.2</em> for an example of a quadtree:</p>
    <figure class="mediaobject"><img src="img/Image3907.png" alt="" width="379" height="343"/></figure>
    <p class="packt_figref">Figure 8.2: A quadtree with different subdivisions</p>
    <p class="normal">Dividing the squares into four child cells and moving the objects from the parent cell into the child cells reduces the <a id="_idIndexMarker357"/>number of objects per cell to be less than the configured threshold, minimizing the number of objects to test for collisions.</p>
    <p class="normal">If the sum of all objects inside the<a id="_idIndexMarker358"/> four child cells falls below the threshold, all objects are moved to the parent cell again, and the now empty child cells are deleted. This dynamic behavior helps to keep the number of objects in each cell between zero and the threshold, independent of the size, number of parents, or location of a cell.</p>
    <p class="normal">A quadtree can hold only two-dimensional information about the object’s position and size. To extend the same logic into three dimensions, an octree can be used.</p>
    <h2 id="_idParaDest-225" class="heading-2">Octree</h2>
    <p class="normal">The basic functionality of a <a id="_idIndexMarker359"/>quadtree and an <strong class="keyWord">octree</strong> is identical. The only difference is the number of dimensions used for the <a id="_idIndexMarker360"/>element of the tree itself. While a quadtree uses squares or rectangles as cells, an octree is made of cubes or cuboids. In <em class="italic">Figure 8.3</em>, a simple octree is shown:</p>
    <figure class="mediaobject"><img src="img/Image3914.png" alt="" width="468" height="416"/></figure>
    <p class="packt_figref">Figure 8.3: An octree with subdivisions</p>
    <p class="normal">The inserted objects are internally maintained as three-dimensional axis-aligned bounding boxes, representing the extents of the object. A split operation when reaching the threshold results in creating eight sub-cubes as child cells (or eight sub-cuboids).</p>
    <p class="normal">An octree is an effective <a id="_idIndexMarker361"/>way to remove large parts of the three-dimensional space when checking for<a id="_idIndexMarker362"/> possible collisions. Another data structure to handle two- and three-dimensional space partitioning is <strong class="keyWord">binary space partitioning</strong> (<strong class="keyWord">BSP</strong>).</p>
    <h2 id="_idParaDest-226" class="heading-2">Binary space partitioning</h2>
    <p class="normal">You may have heard of the<a id="_idIndexMarker363"/> three letters BSP from older games. One of the first games using BSP trees to maintain level data was the 1993 game <strong class="keyWord">Doom</strong> from <strong class="keyWord">Id Software</strong>.</p>
    <p class="normal">Although the level data in Doom <a id="_idIndexMarker364"/>was only two-dimensional, the game engine created the illusion of a fully three-dimensional game.</p>
    <p class="normal">A BSP tree is created by recursively dividing the world space by using lines (2D) or planes (3D) as hyperplanes, creating a front side and a back side. The division into front and back sides continues until the remaining partition fulfills some exit condition; for games, this condition is usually when the partition is either completely filled or empty.</p>
    <p class="normal">If any other lines or planes are hit by the subdivision, these lines or planes are split into two parts, one residing on the front side and the other on the back side.</p>
    <p class="normal"><em class="italic">Figure 8.4</em> shows the subdivision of a space and the resulting BSP tree:</p>
    <figure class="mediaobject"><img src="img/Image3922.png" alt="" width="1003" height="312"/></figure>
    <p class="packt_figref">Figure 8.4: An example object and the resulting BSP tree</p>
    <p class="normal">In <em class="italic">Figure 8.4</em>, line A is used as the starting point, with the front side pointing downward. Splitting the space into two halves also splits lines B and C, resulting in lines B1, B2, C1, and C2. Line B1 lies on the back side of A and will be added as the left child to A, and B2, on the back of A, as the right child of A. Both lines C1 and C3 are on the back sides of B1 and B2, so they are added as the left children to B1 respective to B2.</p>
    <p class="normal">While parsing a BSP tree to find a partition is really fast, generating the same BSP tree is a time-consuming task. The tree generation is done offline in most cases, and the precalculated tree is shipped with the game or application. Checking all lines or planes against all other lines or planes is the same type of problem we have with collision detection.</p>
    <p class="normal">The inability to quickly change or update the elements of a BSP tree makes such a tree only suitable for static data (i.e., for level data of a game). Dynamic game elements, like doors or players, require using a different <a id="_idIndexMarker365"/>data structure, for instance, an octree.</p>
    <p class="normal">Similar to BSP trees, a k-d tree is<a id="_idIndexMarker366"/> fast for searching elements but slow for creation or updates.</p>
    <h2 id="_idParaDest-227" class="heading-2">K-d tree</h2>
    <p class="normal">A <strong class="keyWord">k-d tree</strong> stores information about<a id="_idIndexMarker367"/> objects in a k-dimensional space. The <a id="_idIndexMarker368"/>algorithm is a bit more complex compared to the previous trees. At every data point insertion, the remaining space gets split into two parts, and after the split, the affected dimension is changed.</p>
    <p class="normal">For a two-dimensional k-d tree, the split dimensions alternate between the X and Y axes; for a three-dimensional k-d tree, it alternates in the order X, Y, and Z; and so on. <em class="italic">Figure 8.5</em> shows what a k-d tree in two and three dimensions looks like:</p>
    <figure class="mediaobject"><img src="img/Image3930.png" alt="" width="1552" height="577"/></figure>
    <p class="packt_figref">Figure 8.5: A two- and a three-dimensional k-d tree</p>
    <p class="normal">The red lines and the respective blue lines are for the split dimension in 2D: red stands for an X split and blue for a Y split. In three dimensions, the same pattern applies, and we use the “next” dimension upon consecutive splits. Due to the removal of parts of the remaining space, searching in a k-d tree for an element is fast. The main uses for k-d trees are point clouds and searching for the nearest neighbors of a given point.</p>
    <p class="normal">A slightly different method for space partitioning is by using a bounding volume hierarchy.</p>
    <h2 id="_idParaDest-228" class="heading-2">Bounding volume hierarchy</h2>
    <p class="normal">In contrast to the <a id="_idIndexMarker369"/>previous tree variants, a <strong class="keyWord">bounding volume hierarchy</strong> can be achieved<a id="_idIndexMarker370"/> by different types of geometrical representations. As an example, we are using two-dimensional bounding circles, as shown in <em class="italic">Figure 8.6</em>:</p>
    <figure class="mediaobject"><img src="img/Image3937.png" alt="" width="435" height="413"/></figure>
    <p class="packt_figref">Figure 8.6: A bounding volume hierarchy made of circles</p>
    <p class="normal">By enclosing two or more bounding circles into a larger bounding circle, the number of collision tests can be lowered. If the possible colliding object does not hit the outer circle, there is no need to check any of the inner circles for possible collisions. The inner circles are impossible to reach for the <a id="_idIndexMarker371"/>colliding object.</p>
    <p class="normal">Only if we hit the outer circle is a deeper check required. Similar to the other trees, a bounding volume hierarchy can remove<a id="_idIndexMarker372"/> larger parts of the world space from further collision checks.</p>
    <p class="normal">Before we start the implementation of a spatial partitioning algorithm, we need to explore the second way of accelerating collision detection: using simplified representations of the instances for faster checks.</p>
    <h1 id="_idParaDest-229" class="heading-1">Simplifying the instances for faster collision checks</h1>
    <p class="normal">Instead of checking every triangle of the instances after reducing the overall number, we can greatly improve the performance of collision <a id="_idIndexMarker373"/>checks if we use <strong class="keyWord">model abstractions</strong>. These abstractions are made of only a few geometrical elements, like boxes, cuboids, or circles, enclosing the instance. If these abstractions don’t intersect, the instances cannot have a collision, and we can remove the instance already from our list of candidates.</p>
    <p class="normal">One of the fastest abstractions for an object is the axis-aligned bounding box.</p>
    <h2 id="_idParaDest-230" class="heading-2">Axis-aligned bounding box</h2>
    <p class="normal">An <strong class="keyWord">axis-aligned bounding box</strong> (<strong class="keyWord">AABB</strong>) is a rectangle or cuboid, just large enough to contain the object, and all lines of the rectangle or <a id="_idIndexMarker374"/>planes of the cuboid are aligned with the axes of the Cartesian coordinate system. We will use the two-dimensional variant of an AABB during the implementation of the quadtree, the bounding box. <em class="italic">Figure 8.7</em> shows a two-dimensional bounding box:</p>
    <figure class="mediaobject"><img src="img/Image3945.png" alt="" width="193" height="371"/></figure>
    <p class="packt_figref">Figure 8.7: A two-dimensional bounding box</p>
    <p class="normal">AABBs are best suited for objects shaped close to squares, rectangles, cubes, or cuboids. For round objects, AABBs will produce a lot of space between the object and the box extents, leading to more “false positives” when checking for a possible collision.</p>
    <p class="normal">Checking intersections between AABBs is a quick and easy task. Since all four lines or six sides are aligned to axes, only one dimension per line or plane needs to be checked against the opposite line or plane of the second instance.</p>
    <p class="normal">For instance, the bottom plane of instance one and the top plane of instance two can be checked by just comparing the<a id="_idIndexMarker375"/> Y values (if the Y axis points upward). If this check signals that the instances are not colliding (namely, the top plane of the second instance is not above the bottom plane of instance one), the collision check can be ended immediately – these two instances cannot intersect at all. So, we can do a fast preflight check by using AABBs.</p>
    <p class="normal">When we rotate an AABB with the object, an <strong class="keyWord">oriented bounding box</strong> (<strong class="keyWord">OBB</strong>) will be created.</p>
    <h2 id="_idParaDest-231" class="heading-2">Oriented bounding box</h2>
    <p class="normal">Just rotating the AABB with the <a id="_idIndexMarker376"/>object may be tempting, since we still have a good ratio between the object data and the extra space of the box. See <em class="italic">Figure 8.8</em> for an example:</p>
    <figure class="mediaobject"><img src="img/Image3952.png" alt="" width="327" height="333"/></figure>
    <p class="packt_figref">Figure 8.8: An oriented bounding box</p>
    <p class="normal">But be aware that OBBs are not just AABBs in disguise! Rotating the planes will no longer allow us to do simple coordinate checks, and we now need to solve a lot of plane equations or use advanced methods like the <a id="_idIndexMarker377"/>so-called <strong class="keyWord">Separating Axis Theorem</strong> to check if the side planes of the two OBBs intersect. Plus, the creation <a id="_idIndexMarker378"/>and rotation of OOBs can be complex and ambiguous. So, the tip here is to stay away from OBBs; in most cases, they are not worth the additional complexity.</p>
    <p class="normal">For round(ish) objects, bounding circles and spheres are a good simplification type.</p>
    <h2 id="_idParaDest-232" class="heading-2">Bounding circles and spheres</h2>
    <p class="normal">A bounding circle in two dimensions, or a<a id="_idIndexMarker379"/> bounding sphere in three dimensions, is rather simple. We just need a center point and a radius, and we are done. <em class="italic">Figure 8.9</em> shows a bounding circle around an object:</p>
    <figure class="mediaobject"><img src="img/Image3959.png" alt="" width="362" height="368"/></figure>
    <p class="packt_figref">Figure 8.9: A bounding circle around an object</p>
    <p class="normal">Checking against a bounding circle or sphere is also fast and simple. The Pythagorean theorem helps us to calculate the distance to the center of the sphere from any point in the world. Only if the calculated distance is smaller than the radius will a collision hit occur.</p>
    <p class="normal">Please keep in mind that the Pythagorean theorem includes calculating a square root, a quite expensive operation if you don’t <a id="_idIndexMarker380"/>use modern <strong class="keyWord">Single Instruction, Multiple Data</strong> (<strong class="keyWord">SIMD</strong>) CPU extensions<a id="_idIndexMarker381"/> like <strong class="keyWord">Streaming SIMD Extensions</strong> (<strong class="keyWord">SSE</strong>) or <strong class="keyWord">Advanced Vector Extensions</strong> (<strong class="keyWord">AVX</strong>). One possible optimization here is <a id="_idIndexMarker382"/>using the square of the radius and skipping the square root when calculating the distance. Since both results are squared now, the outcome of the comparison is identical to the square root version.</p>
    <p class="normal">An interesting adaptation of the bounding circle or bounding sphere is a capsule.</p>
    <h2 id="_idParaDest-233" class="heading-2">Capsule</h2>
    <p class="normal"><strong class="keyWord">Capsules</strong> look like a stretched <a id="_idIndexMarker383"/>version of a circle or a sphere, where the middle part is shaped like a rectangle or cylinder. Capsules are used for human bodies since the overall form of a capsule comes closer to the body shape compared to spheres or rectangular bounding boxes. <em class="italic">Figure 8.10</em> shows an example of a capsule:</p>
    <figure class="mediaobject"><img src="img/Image3972.png" alt="" width="171" height="437"/></figure>
    <p class="packt_figref">Figure 8.10: A capsule around a simple character</p>
    <p class="normal">When using the same values for the radius of the ending circles or spheres, and the central rectangle or cylinder, we need to store only the central line of the capsule and the radius. Calculating the distances of a <a id="_idIndexMarker384"/>possible collision point is not much more expensive than the calculations for bounding circles or spheres.</p>
    <p class="normal">On the high end of the costs for collision checks comes the convex hull.</p>
    <h2 id="_idParaDest-234" class="heading-2">Convex hull</h2>
    <p class="normal">A <strong class="keyWord">convex hull</strong> is defined as the smallest <strong class="keyWord">convex</strong> volume <a id="_idIndexMarker385"/>containing the object. Emphasizing the convex <a id="_idIndexMarker386"/>property of the hull is done on purpose since this property allows algorithmic optimizations to some extent. However, the number of planes for the complex hull can become high, and the construction may be not trivial. See <em class="italic">Figure 8.11</em> for a convex hull:</p>
    <figure class="mediaobject"><img src="img/Image3981.png" alt="" width="145" height="385"/></figure>
    <p class="packt_figref">Figure 8.11: A convex hull around an object</p>
    <p class="normal">Checking a convex hull for collisions needs a lot of tests, possibly lowering the effect we wanted to achieve with our model simplification. As long as you don’t have models with lots of triangles, a convex hull may<a id="_idIndexMarker387"/> be out of scope.</p>
    <p class="normal">On the other hand, if small collision errors can be tolerated, the convex hull can be used as a replacement for a high-poly model, and all collision checks can be done only against the convex hull.</p>
    <p class="normal">As the last method, the bounding volume hierarchy can be used. The hierarchy model is not just suitable for space partitioning but also for model simplification.</p>
    <h2 id="_idParaDest-235" class="heading-2">Bounding volume hierarchy</h2>
    <p class="normal">The general idea of the <strong class="keyWord">bounding volume hierarchy</strong> for space partitioning also holds true to simplify the instances. But here, the <a id="_idIndexMarker388"/>model parts are enclosed in larger and larger volumes. <em class="italic">Figure 8.12</em> shows a simplified example of the bounding volume hierarchy around a character model:</p>
    <figure class="mediaobject"><img src="img/Image3988.png" alt="" width="376" height="368"/></figure>
    <p class="packt_figref">Figure 8.12: Bounding spheres in a hierarchy around an object</p>
    <p class="normal">A failing check on one of the larger volumes allows us to discard the body part(s) inside the volume completely. By using a carefully crafted configuration, only a small number of tests are needed to decide if the instance should stay on the list for deeper checks, or if it can be ignored.</p>
    <p class="normal">For details about collision checking between convex <a id="_idIndexMarker389"/>objects, you can look at the <strong class="keyWord">Gilbert–Johnson–Keerthi</strong> (<strong class="keyWord">GJK</strong>) distance algorithm. The GJK algorithm<a id="_idIndexMarker390"/> reduces the collision detection complexity by using the so-called Minkowski difference. A link to a web page explaining the principle of the GJK algorithm is available in the <em class="italic">Additional resources</em> section.</p>
    <p class="normal">For the sake of simplicity, because of the fast updates, and also based on setting a limit to the number of instances to check, we will implement a quadtree into the application and bounding spheres for the instances. The quadtree will allow us to do the first step of collision detection much faster than the “brute-force” pairwise comparisons of all models in the naive approach. The bounding spheres are great for a balance between the number of collision checks and the number of false positives due to the free space between the sphere and the instance triangles.</p>
    <p class="normal">Next, let’s jump into the implementation of the quadtree.</p>
    <h1 id="_idParaDest-236" class="heading-1">Adding a quadtree to store nearby model instances</h1>
    <p class="normal">Getting complex code<a id="_idIndexMarker391"/> right is hard, so using an open-source implementation of a quadtree is a viable option. The best fitting version of a quadtree I’ve found is from <strong class="keyWord">Pierre Vigier</strong> and <a id="_idIndexMarker392"/>can be found on GitHub here: <a href="https://github.com/pvigier/Quadtree">https://github.com/pvigier/Quadtree</a>.</p>
    <p class="normal">The code from Pierre is based on C++ templating to have great flexibility on the data one stores in the quadtree. Also, he uses a custom-templated two-dimensional vector type for storing positions and sizes.</p>
    <p class="normal">We don’t need this kind of flexibility as we will store only an <code class="inlineCode">int</code> containing the instance index position in the quadtree. And since we are using GLM for all other cases where we need a two-dimensional vector type, we will change the bounding box implementation to use <code class="inlineCode">glm::vec2</code> to store box position and size.</p>
    <h2 id="_idParaDest-237" class="heading-2">Adjusting the bounding box code</h2>
    <p class="normal">As the first step for the new and shiny quadtree, we need to adjust the code for the bounding box. Instead of storing the top and left<a id="_idIndexMarker393"/> positions and width plus height as single values, we use a <code class="inlineCode">vec2</code> for position and size. Transforming the templated C++ code from the <code class="inlineCode">Box.h</code> file in the <code class="inlineCode">include</code> folder of the GitHub repository is done fairly easily, and we end up with constructors, a couple of getters, and the two methods <code class="inlineCode">contains()</code> and <code class="inlineCode">intersects()</code> in the <code class="inlineCode">BoundingBox2D.h</code> and <code class="inlineCode">BoundingBox2D.cpp</code> files in the newly created <code class="inlineCode">quadtree</code> folder.</p>
    <p class="normal">The most complex method is <code class="inlineCode">intersects()</code> to check if two bounding boxes intersect each other:</p>
    <pre class="programlisting code"><code class="hljs-code">bool BoundingBox2D::intersects(BoundingBox2D otherBox) {
  return !(
    mPosition.x &gt;= otherBox.getRight() ||
    otherBox.getTopLeft().x &gt;= getRight() ||
    mPosition.y &gt;= otherBox.getBottom() ||
    otherBox.getTopLeft().y &gt;= getBottom()
  );
}
</code></pre>
    <p class="normal">In the <code class="inlineCode">AssimpInstance</code> class, a new <code class="inlineCode">private</code> member named <code class="inlineCode">mBoundingBox</code> will be added, storing the bounding box of the instance:</p>
    <pre class="programlisting code"><code class="hljs-code">    BoundingBox2D mBoundingBox{};
</code></pre>
    <p class="normal">We don’t need to load or save the bounding box, so it can be stored directly in the <code class="inlineCode">AssimpClass</code>, outside of the <code class="inlineCode">InstanceSettings</code> struct.</p>
    <p class="normal">We need two trivial <code class="inlineCode">public</code> methods to store and retrieve the bounding box:</p>
    <pre class="programlisting code"><code class="hljs-code">    BoundingBox2D getBoundingBox();
    void setBoundingBox(BoundingBox2D box);
</code></pre>
    <p class="normal">As the last step for the bounding box implementation, we must add the new <code class="inlineCode">quadtree</code> folder to the <code class="inlineCode">CMakeLists.txt</code> file in the <code class="inlineCode">project root</code> folder in two places, to be able to use the bounding box and the quadtree in <a id="_idIndexMarker394"/>other classes. First, add the folder with a wildcard for all <code class="inlineCode">.cpp</code> files to the <code class="inlineCode">SOURCES</code> file search:</p>
    <pre class="programlisting code"><code class="hljs-code">file(GLOB SOURCES
  ...
  <strong class="hljs-slc">quadtree/*.cpp</strong>
  ...
)
</code></pre>
    <p class="normal">Then, append the <code class="inlineCode">quadtree</code> folder to the include directory list:</p>
    <pre class="programlisting code"><code class="hljs-code">target_include_directories(${PROJECT_NAME} ... <strong class="hljs-slc">quadtree</strong>)
</code></pre>
    <p class="normal">After recreating the CMake files, which should be done automatically by Visual Studio and other IDEs after saving the changes in <code class="inlineCode">CMakeLists.txt</code>, we can continue with the implementation of the quadtree.</p>
    <h2 id="_idParaDest-238" class="heading-2">Rewriting the quadtree code to fit our needs</h2>
    <p class="normal">We will store the new <code class="inlineCode">Quadtree</code> class in the <code class="inlineCode">Quadtree.h</code> and <code class="inlineCode">Quadtree.cpp</code> files in the <code class="inlineCode">quadtree</code> folder. The<a id="_idIndexMarker395"/> transformation from the quadtree C++ template to a C++ class needs some extra steps compared to the bounding box code.</p>
    <p class="normal">We will need to make the following adjustments while translating the C++ template code:</p>
    <ul>
      <li class="bulletList">Replace the custom <code class="inlineCode">Vector2</code> type with <code class="inlineCode">glm::vec2</code>.</li>
      <li class="bulletList">Replace the custom <code class="inlineCode">Box</code> type with the <code class="inlineCode">BoundingBox2D</code> type and change the parameters to <code class="inlineCode">glm::vec2</code>.</li>
      <li class="bulletList">Replace the <code class="inlineCode">assert()</code> checks with log outputs.</li>
      <li class="bulletList">Add a <code class="inlineCode">clear()</code> method that removes all contents of the quadtree.</li>
      <li class="bulletList">Add code to clean up the pairs of colliding instances with swapped IDs.</li>
      <li class="bulletList">Use return values for results instead of output parameters.</li>
      <li class="bulletList">Use a callback function instead of the <code class="inlineCode">GetBox</code> function parameter.</li>
    </ul>
    <p class="normal">For the callback function, we add another callback to the <code class="inlineCode">Callbacks.h</code> file, taking an <code class="inlineCode">int</code> as the only parameter and returning a <code class="inlineCode">BoundingBox2D</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">using instanceGetBoundingBox2D =
   std::function&lt;BoundingBox2D(int)&gt;;
</code></pre>
    <p class="normal">The quadtree will be added to the renderer as a <code class="inlineCode">private</code> member variable named <code class="inlineCode">mQuadtree</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">    std::shared_ptr&lt;QuadTree&gt; mQuadtree = nullptr;
</code></pre>
    <p class="normal">During the initialization in the <code class="inlineCode">initQuadTree()</code> method, we will bind the callback function to the <code class="inlineCode">getBoundingBox()</code> method, using the instance index as the parameter:</p>
    <pre class="programlisting code"><code class="hljs-code">  mQuadtree-&gt;instanceGetBoundingBox2DCallback =
    [this](int instanceId) {
     return mModelInstCamData.micAssimpInstances.at(
       instanceId)-&gt;getBoundingBox();
    };
</code></pre>
    <p class="normal">Filling the quadtree will happen in the <code class="inlineCode">draw()</code> call of the renderer while iterating over the instances of the models. For<a id="_idIndexMarker396"/> each instance, we create the bounding box and add the instance to the quadtree:</p>
    <pre class="programlisting code"><code class="hljs-code">    BoundingBox2D box{position, size};
    instances.at(i)-&gt;setBoundingBox(box);
    mQuadtree-&gt;add(instSettings.isInstanceIndexPosition);
</code></pre>
    <p class="normal">Creating the bounding box for every instance will be handled in the section <em class="italic">Calculating the instance bounding boxes</em>.</p>
    <p class="normal">One important question for the quadtree usage remains: Should we update the instance positions in the tree in every frame, or should we clear the entire quadtree and add all instances again?</p>
    <p class="normal">Updating an object inside a quadtree needs to be done by deleting and re-adding. So, if we have mostly static objects in the quadtree, updates would be fine. But since our plan is to have many instances moving around and/or playing animations, the position and/or bounding box will change in almost every frame. In such an environment, instance removal and addition will be more expensive than clearing the quadtree and adding all instances with fresh data.</p>
    <p class="normal">Starting over with a fresh quadtree in the <code class="inlineCode">draw()</code> call of the renderer is easy. Right before going into the instance loop, clear the contents of the quadtree:</p>
    <pre class="programlisting code"><code class="hljs-code">  mQuadtree-&gt;clear();
</code></pre>
    <p class="normal">After the quadtree is ready, we have to solve the question of how to generate the bounding boxes for the instances. The answer may be surprising: We need to split the work between the GPU and the CPU.</p>
    <h2 id="_idParaDest-239" class="heading-2">Calculating the instance bounding boxes</h2>
    <p class="normal">The first idea when it <a id="_idIndexMarker397"/>comes to a large number of calculations for all instances will most probably be “I will use a compute shader!”, especially after we have solved some compute-intense problems by offloading the work to the GPU. But in this case, the CPU must do a part of the job.</p>
    <p class="normal">While compute shaders are great for calculating independent results in a massively parallel way, they aren’t well suited for simple tasks like creating a bounding box. To calculate the bounding box of an instance, we need to store the minimum and maximum coordinates of all nodes for every instance in the virtual world, combining the intermediate results to create the final bounding box. On the CPU, we can easily grab the vertex positions from the data structures one by one, do the required calculations, and store the final AABB back in memory.</p>
    <p class="normal">But if we would like to compute the AABB coordinates inside a shader, we may end up overwriting the results of other shader invocations if the AABB results use the same buffer positions. Or we will have a huge list of coordinates that must be sorted afterward. Sorting the coordinates could be done in another computer shader too, but parallel sorting algorithms tend to be complex because<a id="_idIndexMarker398"/> they face the same constraints of not being able to write data to the same buffer positions.</p>
    <p class="normal">So, instead of worrying about data synchronization issues in compute shaders, we use them for what they can do very fast: creating lookup tables.</p>
    <h3 id="_idParaDest-240" class="heading-3">Adding a three-dimensional bounding cube class</h3>
    <p class="normal">To store the generated lookup data, we will add a C++ class for a three-dimensional AABB. Using AABBs here has the advantage of having data to draw debug lines in the renderer, but the third set of coordinates adds only a little overhead to storage and generation time. Also, a possible upgrade to an octree<a id="_idIndexMarker399"/> for a fast collision check in all three dimensions will be simple.</p>
    <p class="normal">The new class is called <code class="inlineCode">AABB</code> and will reside in the <code class="inlineCode">tools</code> folder. Next to the constructor, some <code class="inlineCode">public</code> getters and setters, and the two <code class="inlineCode">private</code> floats <code class="inlineCode">mMinPos</code> and <code class="inlineCode">mMaxPos</code>, the <code class="inlineCode">AABB</code> class has two <code class="inlineCode">public</code> methods called <code class="inlineCode">create()</code> and <code class="inlineCode">addPoint()</code>.</p>
    <p class="normal">By using the <code class="inlineCode">create()</code> method, we add a point at the position given as the <code class="inlineCode">glm::vec3</code> parameter as the minimum and maximum extents for the bounding box. And with <code class="inlineCode">addPoint()</code>, we extend the bounding box to include the new point:</p>
    <pre class="programlisting code"><code class="hljs-code">void AABB::addPoint(glm::vec3 point) {
  mMinPos.x = std::min(mMinPos.x, point.x);
  mMinPos.y = std::min(mMinPos.y, point.y);
  mMinPos.z = std::min(mMinPos.z, point.z);
  mMaxPos.x = std::max(mMaxPos.x, point.x);
  mMaxPos.y = std::max(mMaxPos.y, point.y);
  mMaxPos.z = std::max(mMaxPos.z, point.z);
}
</code></pre>
    <p class="normal">If the new point is inside the bounding box, nothing happens. But if the point is outside of the bounding box, the box will be expanded in one, two, or three dimensions to include the new point. In the end, we will have a box around all the points we added, defined by the minimum and maximum values of the three dimensions.</p>
    <p class="normal">For generating debug lines to draw in the renderer, the <code class="inlineCode">public</code> method <code class="inlineCode">getAABBlines()</code> is used. In <code class="inlineCode">getAABBLines()</code>, we create the 12 lines between the 8 possible combinations of the minimum and maximum positions of the <code class="inlineCode">x</code>, <code class="inlineCode">y</code>, and <code class="inlineCode">z</code> elements of <code class="inlineCode">mMinPos</code> and <code class="inlineCode">mMaxPos</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">  mAabbMesh-&gt;vertices.at(0) =
    {{mMinPos.x, mMinPos.y, mMinPos.z}, color};
  mAabbMesh-&gt;vertices.at(1) =
    {{mMaxPos.x, mMinPos.y, mMinPos.z}, color};
  ...
  mAabbMesh-&gt;vertices.at(22) =
    {{mMaxPos.x, mMaxPos.y, mMinPos.z}, color};
  mAabbMesh-&gt;vertices.at(23) =
    {{mMaxPos.x, mMaxPos.y, mMaxPos.z}, color};
</code></pre>
    <h3 id="_idParaDest-241" class="heading-3">Creating the AABB lookup tables</h3>
    <p class="normal">The general idea of the AABB lookup tables is to precalculate the AABB for a fixed number of frames of every animation clip for every model. Having the bounding boxes in a lookup table allows us to retrieve a <a id="_idIndexMarker400"/>good approximation of the model’s AABB in a frame of an animation clip.</p>
    <p class="normal">By blending between AABB coordinates <a id="_idIndexMarker401"/>of the same frame number in two different clips plus transforming the final AABB according to the model’s transformations, we can calculate a well-fitting AABB for the instance at low computing costs, even if the instance is in the middle of an animation blending.</p>
    <p class="normal">Creating the lookup table is a mix of a compute shader and CPU work, done in the <code class="inlineCode">createAABBLookup()</code> method of the renderer. The lookup table is generated in the renderer class for two reasons:</p>
    <ul>
      <li class="bulletList">The main method to load the models is placed in the renderer, and we also expose the model loading method to the user interface via callback.</li>
      <li class="bulletList">The renderer already has the compute shaders loaded. We can use the shaders directly, instead of using another set of the same shaders in the <code class="inlineCode">AssimpModel</code> class.</li>
    </ul>
    <p class="normal">For the compute shader part, we can reuse the code from the instance loop of the <code class="inlineCode">draw()</code> call of the renderer we made back in <a href="Chapter_2.xhtml"><em class="italic">Chapter 2</em></a>.</p>
    <p class="normal">To find the maximum extents of the model, we will use the nodes. To calculate the nodes per instance, the two compute shaders <code class="inlineCode">assimp_instance_transform.comp</code> and <code class="inlineCode">assimp_instance_matrix_mult.comp</code> can be used. In the translation part of the calculated matrices containing translation, rotation, and scale of the node, the location of each node is stored. The only difference here is the node offset matrices.</p>
    <p class="normal">While these offset matrices are required for vertex skinning, they would give the wrong results for node positions. We can remove the offset matrices in the calculations by binding an SSBO full of identity matrices, giving us only the node’s TRS matrices.</p>
    <p class="normal">By extracting the node positions per instance and creating a per-node AABB from the positions, we have an easy way to calculate the data we need for the quadtree and the debug display. For the 2D bounding box, we simply extract the <code class="inlineCode">x</code> and <code class="inlineCode">z</code> elements of the AABB, generating a “top-down” view of the AABB.</p>
    <p class="normal">The AABB calculations are done per animation clip and per node of the model. The resulting <code class="inlineCode">std::vector</code> will be stored in the <code class="inlineCode">AssimpModel</code> data of the model we just loaded. To retrieve the correct AABB data for a time position in an animation clip, we use the same logic we already have for generating the vertex skinning matrices and take the scaled time position as an index into the lookup data. If we blend between two animations, we can even blend between the AABBs of the two animations.</p>
    <h3 id="_idParaDest-242" class="heading-3">Using the AABB in the model and renderer</h3>
    <p class="normal">When iterating over the instances in the <code class="inlineCode">draw()</code> call of the renderer, we can now retrieve the AABB data for the animation clip and time position by calling <code class="inlineCode">getAABB()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">  AABB instanceAABB = model-&gt;getAABB(instSettings);
</code></pre>
    <p class="normal">Inside <code class="inlineCode">getAABB()</code>, the data from animation and instance translation, rotation, and scale are used to create an AABB fitting the<a id="_idIndexMarker402"/> instance. In detail, <code class="inlineCode">getAABB()</code> will:</p>
    <ul>
      <li class="bulletList">Look up the AABBs of the first and second animation clip</li>
      <li class="bulletList">Blend between the two AABBs according to the animation blend factor</li>
      <li class="bulletList">Scale the resulting AABB by the instance scale factor</li>
      <li class="bulletList">Rotate the AABB in case the axis swap of the model is activated</li>
      <li class="bulletList">Rotate the AABB according to the instance rotation (which is an OBB now)</li>
      <li class="bulletList">Generate a new AABB from the rotated ABB</li>
      <li class="bulletList">Translate the AABB to the instance position</li>
    </ul>
    <p class="normal">At this point, the AABB encloses the instance.</p>
    <p class="normal">Since blending and rotations are still expensive operations that may harm performance in scenes with many instances, a speed-up can be achieved by parallelizing the computations with SIMD operations of modern processors, like SSE or AVX. But even keeping the AABB lookup data on the GPU may be beneficial. Calculating the bounding boxes of all instances with a compute shader and downloading the results could be still faster than pure CPU calculation, despite the additional download of the results.</p>
    <p class="normal">To achieve the best possible performance, you might want to implement different versions of the <code class="inlineCode">getAABB()</code> method and profile the application with various scene sizes and complexities.</p>
    <p class="normal">After the AABB is adjusted for the instance, we calculate the position and size of the two-dimensional bounding box for the quadtree:</p>
    <pre class="programlisting code"><code class="hljs-code">  glm::vec2 position =
    glm::vec2(instanceAABB.getMinPos().x,
    instanceAABB.getMinPos().z);
  glm::vec2 size =
    glm::vec2(std::fabs(instanceAABB.getMaxPos().x -
    instanceAABB.getMinPos().x),
    std::fabs(instanceAABB.getMaxPos().z -
    instanceAABB.getMinPos().z));
</code></pre>
    <p class="normal">Now, we have all the data to insert the instance into the quadtree:</p>
    <pre class="programlisting code"><code class="hljs-code">  BoundingBox2D box{position, size};
  instances.at(i)-&gt;setBoundingBox(box);
  mQuadtree-&gt;add(instSettings.isInstanceIndexPosition);
</code></pre>
    <p class="normal">To make sure we create a working quadtree, we will add a new ImGui window containing the quadtree, including all subdivisions and instances. Seeing the quadtree in action helps a lot to find any implementation bugs.</p>
    <h3 id="_idParaDest-243" class="heading-3">Creating a window to show the quadtree plus contents</h3>
    <p class="normal">For the ImGui window, we create a new method called <code class="inlineCode">createPositionsWindow()</code> in the <code class="inlineCode">UserInterface</code> class. Inside this method, we create a new window by using <code class="inlineCode">ImGui::Begin()</code>. Next, we retrieve the world boundaries to<a id="_idIndexMarker403"/> have the origin, size, and center point to draw.</p>
    <p class="normal">Then, we iterate over all instances, using the position and size of the bounding box to draw ImGui rectangles at the 2D world positions of the instances. We also use the pairs of the <code class="inlineCode">micInstanceCollisions</code> variable to draw non-colliding and colliding instances in different colors.</p>
    <p class="normal">Finally, we retrieve the bounding boxes of the quadtree and all the subdivisions. To get the bounding boxes of all levels of the quadtree, we add a pair of <code class="inlineCode">public</code> and <code class="inlineCode">private</code> methods to the <code class="inlineCode">Quadtree</code> class called <code class="inlineCode">getTreeBoxes()</code>. The <code class="inlineCode">getTreeBoxes()</code> method recursively iterates over the quadtree nodes and child nodes, storing the bounding boxes in a <code class="inlineCode">std::vector</code> of <code class="inlineCode">BoundingBox2D</code> elements. We draw all quadtree boxes by using white lines.</p>
    <p class="normal"><em class="italic">Figure 8.13</em> shows an example of the quadtree window:</p>
    <figure class="mediaobject"><img src="img/Image4098.png" alt="" width="317" height="334"/></figure>
    <p class="packt_figref">Figure 8.13: A quadtree with subdivisions, instances, and detected collisions</p>
    <p class="normal">In <em class="italic">Figure 8.13</em>, the quadtree and all its subdivisions are drawn in white. The bounding boxes of a normal instance are drawn as yellow lines and colliding instances are drawn as red lines.</p>
    <p class="normal">Filling the quadtree and drawing the result on the screen is only the first half of the collision detection; we also need to do something with the information of instances colliding in the virtual world.</p>
    <h3 id="_idParaDest-244" class="heading-3">Retrieving the colliding instances and reacting to collisions</h3>
    <p class="normal">Getting the list of all colliding instances <a id="_idIndexMarker404"/>out of the quadtree is done by calling <code class="inlineCode">findAllIntersections()</code> of the <code class="inlineCode">mQuadtree</code> object:</p>
    <pre class="programlisting code"><code class="hljs-code">  mModelInstCamData.micInstanceCollisions =
    mQuadtree-&gt;findAllIntersections();
</code></pre>
    <p class="normal">We store the result in the new variable <code class="inlineCode">micInstanceCollisions</code> in the <code class="inlineCode">ModelInstanceCamData</code> struct to<a id="_idIndexMarker405"/> make the instance collisions available for other parts of the code (i.e., for debug drawing lines). The colliding instances are given to us as pairs of instances.</p>
    <p class="normal">To see the results of a collision in the screen, we can iterate over the pairs of instances and rotate one or both instances:</p>
    <pre class="programlisting code"><code class="hljs-code">for (const auto&amp; instPairs :
    mModelInstCamData.micInstanceCollisions) {
  instances.at(instPairs.first)-&gt;rotateInstance(6.5f);
  instances.at(instPairs.second)-&gt;rotateInstance(-5.3f);
}
</code></pre>
    <p class="normal">Walking or running into another instance should now rotate your instance, or your instance and the colliding instance. Even though the angle is small, it will be incremented for every frame where a collision between those instances is detected. At a normal frame rate of 60 or 75 FPS, you will see yourself instantly rotated away from the other instance, suddenly running in a different direction.</p>
    <p class="normal">If you don’t like having the instances just rotating on collisions, you can try to implement more complex reactions to collisions. Check out the <em class="italic">Practical sessions</em> section for a task about adding collision resolution and the <em class="italic">Additional resources</em> section for links to resources about collision avoidance.</p>
    <h3 id="_idParaDest-245" class="heading-3">Drawing the AABB debug lines</h3>
    <p class="normal">In the case that your instance or the other instance does not rotate and you can still walk right through other instances, drawing <a id="_idIndexMarker406"/>the AABB lines to the screen will become helpful.</p>
    <p class="normal">To draw the debug lines in the renderer, we can use the pairs in <code class="inlineCode">micInstanceCollisions</code>, retrieve the AABB lines from both affected instances, and add the vertices of the lines to a <code class="inlineCode">private</code> variable called <code class="inlineCode">mAABBMesh</code>. Then, we upload the vertex data to the line vertex buffer, and by using the line shader, we draw the AABBs to the screen:</p>
    <pre class="programlisting code"><code class="hljs-code">  mLineVertexBuffer.uploadData(*mAABBMesh);
  mLineShader.use();
  mLineVertexBuffer.bindAndDraw(GL_LINES, 0,
    mAABBMesh-&gt;vertices.size());
</code></pre>
    <p class="normal">As an alternative solution, we can iterate over all instances and use the instance indices in the pairs in <code class="inlineCode">micInstanceCollisions</code> to switch the color of the AABB to draw.</p>
    <p class="normal">For more control over the AABB lines, a separate section in the ImGui <strong class="screenText">Control</strong> window will be created. Combined with a new <code class="inlineCode">enum</code> class called <code class="inlineCode">collisionDebugDraws</code> and a bit more code in the <code class="inlineCode">drawAABBs()</code> method in the renderer, you can switch between three different drawing modes:</p>
    <ul>
      <li class="bulletList">No AABBs</li>
      <li class="bulletList">Only the colliding AABBs in red</li>
      <li class="bulletList">All colliding AABBs in red and all other AABBs in yellow</li>
    </ul>
    <p class="normal"><em class="italic">Figure 8.14</em> shows an example<a id="_idIndexMarker407"/> of a detected collision, using yellow lines around non-colliding instances and red lines around the two colliding instances:</p>
    <figure class="mediaobject"><img src="img/Image4158.png" alt="" width="613" height="338"/></figure>
    <p class="packt_figref">Figure 8.14: Two colliding instances among other non-colliding instances</p>
    <p class="normal">Don’t be alarmed if some of the instances behave strangely, like constantly rotating around themselves. The reaction to collisions with other instances and the world boundaries is still very basic (just a rotation). We will enhance the collision handling in <a href="Chapter_9.xhtml"><em class="italic">Chapter 9</em></a>.</p>
    <p class="normal">After the quadtree is working and reduces the number of instances to check to a configurable minimum, we will start the implementation of one of the listed simplifications: By utilizing the nodes of the game character models as anchor points, bounding spheres have a good trade-off between creation and checking complexity.</p>
    <p class="normal">So, let’s go and add some spheres to the models.</p>
    <h1 id="_idParaDest-246" class="heading-1">Implementing bounding spheres</h1>
    <p class="normal">Bounding spheres as abstractions of higher detailed models can be used in different ways. One possible way is shown in <em class="italic">Figure 8.9</em>, where the sphere encloses the entire model. But as you can see in <em class="italic">Figure 8.9</em>, we would <a id="_idIndexMarker408"/>have a lot of empty space around the model, resulting in more false positives. Plus, we already have a method to do a broader check for possible collisions: the bounding boxes.</p>
    <p class="normal">Instead, we will use the spheres to simplify the instances at a more detailed level by adding configurable bounding spheres to the model’s nodes. Even though we would have to now check several dozens of spheres against the spheres of another instance, we are still way below the computational power we would need to check every single triangle of both models against each other.</p>
    <p class="normal">The number of false positives will also remain at an acceptable level. As stated broadly in the <em class="italic">Simplifying the instances for faster collision checks</em> section, choosing between a higher detailed simplification and more computations or simpler abstractions and more false positive collision detections is a tradeoff we have to live with, but we can make the decision strategically.</p>
    <h2 id="_idParaDest-247" class="heading-2">Creating the data for the bounding spheres</h2>
    <p class="normal">To create the sphere data, we use the same first step as in the bounding box calculations. We use the compute shaders <code class="inlineCode">assimp_instance_transform.comp</code> and <code class="inlineCode">assimp_instance_matrix_mult.comp</code>, combined with replacing the bone offset matrices with identity matrices. The<a id="_idIndexMarker409"/> result of this shader run is an SSBO containing the node positions of all instances we want to equip with bounding spheres.</p>
    <p class="normal">But, in contrast to the bounding boxes, we can use another compute shader to calculate the bounding spheres for the nodes. The third compute shader, called <code class="inlineCode">assimp_instance_bounding_spheres.comp</code>, uses the TRS matrices of the nodes created by the previous compute shaders, the world position matrices from the instances, and the parent node indices to create a bounding sphere for every node of every instance.</p>
    <p class="normal">Another SSBO called <code class="inlineCode">SphereAdjustment</code> is used, containing a <code class="inlineCode">vec4</code> for every node. These sphere adjustments can be set by a UI extension that maps the node names of the model to one <code class="inlineCode">SliderFloat</code> and one <code class="inlineCode">SliderFloat3</code>, allowing us to resize and move around the bounding spheres created by the shader. By carefully placing the bounding spheres, we can make sure to have as little empty space around the model that would be detected as collision.</p>
    <p class="normal"><em class="italic">Figure 8.15</em> shows the new UI section:</p>
    <figure class="mediaobject"><img src="img/Image4167.png" alt="" width="1078" height="660"/></figure>
    <p class="packt_figref">Figure 8.15: Fine-tuning the bounding spheres of a model</p>
    <p class="normal">The <code class="inlineCode">SphereAdjustments</code> SSBO is backed by a <code class="inlineCode">std::vector</code> of <code class="inlineCode">glm::vec4</code> elements called <code class="inlineCode">msBoundingSphereAdjustments</code>, placed in the <code class="inlineCode">ModelSettings</code> struct. In the adjustments vector, each <code class="inlineCode">vec4</code> is split, using the first three elements for the position and the last element for the radius of each sphere.</p>
    <p class="normal">And since it’s a good idea to not have to tune the bounding spheres on every application restart, the contents of the <code class="inlineCode">msBoundingSphereAdjustments</code> buffer are added to the <code class="inlineCode">YamlParser</code> class to be able to save and restore the adjustments.</p>
    <p class="normal">Both the addition to the user interface and to the YAML parser are more or less trivial, copied from already existing ImGui and YAML parsing code parts. You can explore the <code class="inlineCode">UserInterface</code> and <code class="inlineCode">YamlParser</code> classes <a id="_idIndexMarker410"/>to check out the code changes.</p>
    <p class="normal">Our third compute shader, <code class="inlineCode">assimp_instance_bounding_spheres.comp</code>, also reuses parts of other shaders. The top of the <code class="inlineCode">main()</code> method is identical to the matrix multiplication compute shader:</p>
    <pre class="programlisting code"><code class="hljs-code">void main() {
  uint node = gl_GlobalInvocationID.x;
  uint instance = gl_GlobalInvocationID.y;
  uint numberOfBones = gl_NumWorkGroups.x;
  uint index = node + numberOfBones * instance;
</code></pre>
    <p class="normal">We select the node and instance to work on based on the invocation IDs of the shader, while the number of nodes in the model comes from the X dimension of the number of work groups we use when dispatching the compute shader.</p>
    <p class="normal">Next, we get the node position by extracting the translational part from the TRS matrix of the specific node of the instance and adding the position from the sphere adjustment buffer:</p>
    <pre class="programlisting code"><code class="hljs-code">  vec3 nodePos =
   (worldPosMat[instance] * trsMat[index])[3].xyz;
  nodePos += sphereAdjustment[node].xyz;
  float radius = 1.0;
</code></pre>
    <p class="normal">We also declare the sphere radius and initialize it with a default value.</p>
    <p class="normal">Then, we extract the parent node ID of the current node from the parent index buffer:</p>
    <pre class="programlisting code"><code class="hljs-code">  int parentNode = parentIndex[node];
</code></pre>
    <p class="normal">The parent node is used to switch between nodes that have a parent and the parent or unconnected, standalone nodes. If we find a valid parent, we calculate the world position of the parent node, including the position adjustment:</p>
    <pre class="programlisting code"><code class="hljs-code">  if (parentNode &gt;= 0) {
    uint parentIndex = parentNode +
      numberOfBones * instance;
    vec3 parentPos =
     (worldPosMat[instance] * trsMat[parentIndex])[3].xyz;
    parentPos += sphereAdjustment[parentNode].xyz;
</code></pre>
    <p class="normal">By using the node and parent position, we calculate the middle point between the node and its parent. We calculate the radius of the sphere – again, adjustable by the sphere adjustment value:</p>
    <pre class="programlisting code"><code class="hljs-code">    vec3 center = mix(nodePos, parentPos, 0.5);
    radius = length(center - nodePos) *
      sphereAdjustment[node].w;
</code></pre>
    <p class="normal">For the root node, we set the radius of the sphere to the adjustable value:</p>
    <pre class="programlisting code"><code class="hljs-code">  } else {
    radius = sphereAdjustment[node].w;
  }
</code></pre>
    <p class="normal">At the end of the <code class="inlineCode">main()</code> method, we add a small check to disable small spheres already in the shader:</p>
    <pre class="programlisting code"><code class="hljs-code">  if (radius &lt; 0.05) {
    sphereData[index] = vec4(0.0);
  } else {
    sphereData[index] = vec4(nodePos, radius);
  }
}
</code></pre>
    <p class="normal">As we need to run the three compute shaders from several different places in the renderer code, we make our lives <a id="_idIndexMarker411"/>easier by adding the code to fill and run the shaders to a new method called <code class="inlineCode">runBoundingSphereComputeShaders</code>.</p>
    <h2 id="_idParaDest-248" class="heading-2">Drawing bounding spheres</h2>
    <p class="normal">The second usage of the<a id="_idIndexMarker412"/> compute shaders for the bounding spheres is a debug display, similar to the AABBs. After running the compute shaders, we can use another new vertex and fragment shader pair to draw the spheres to the screen.</p>
    <p class="normal">In the <code class="inlineCode">main()</code> method of the new sphere-drawing vertex shader called <code class="inlineCode">sphere_instanced.vert</code>, we extract the center and radius of the sphere:</p>
    <pre class="programlisting code"><code class="hljs-code">void main() {
  vec3 boneCenter = sphereData[gl_InstanceID].xyz;
  float radius = sphereData[gl_InstanceID].w;
</code></pre>
    <p class="normal">To speed up the drawing, we will use an instanced drawing call for the rendering API, so we can use the special variable <code class="inlineCode">gl_InstanceID</code> here (the variable <code class="inlineCode">gl_InstanceID</code> was renamed to <code class="inlineCode">gl_InstanceIndex</code> in Vulkan). Both OpenGL and Vulkan are internally incrementing the values of the variable <code class="inlineCode">gl_InstanceID</code> respective <code class="inlineCode">gl_InstanceIndex</code> for every instance, allowing us to draw thousands of bounding spheres from a single set of vertices.</p>
    <p class="normal">Resizing the spheres to the correct radius is done by a small GLSL function called <code class="inlineCode">createScaleMatrix()</code> in the shader, essentially creating a scaling matrix with the <code class="inlineCode">radius</code> value in the main diagonal elements:</p>
    <pre class="programlisting code"><code class="hljs-code">  mat3 scaleMat = createScaleMatrix(radius);
</code></pre>
    <p class="normal">Then, we scale the original position of the sphere vertex by the scaling matrix, add the sphere adjustment, create the final shader matrix by multiplication with <code class="inlineCode">view</code> and <code class="inlineCode">projection</code> matrices, and set the line color:</p>
    <pre class="programlisting code"><code class="hljs-code">  gl_Position = projection * view *
    vec4(scaleMat * aPos + boneCenter, 1.0);
  lineColor = vec4(aColor, 1.0);
}
</code></pre>
    <p class="normal">Running the sphere shader is done<a id="_idIndexMarker413"/> by calling an instanced version of the <code class="inlineCode">Shader</code> class drawing command:</p>
    <pre class="programlisting code"><code class="hljs-code">  mLineVertexBuffer.uploadData(mSphereMesh);
  mSphereShader.use();
  mBoundingSphereBuffer.bind(1);
  mLineVertexBuffer.bindAndDrawInstanced(GL_LINES, 0,
    mSphereMesh.vertices.size(), numberOfSpheres);
</code></pre>
    <p class="normal">For the Vulkan renderer, the equivalent drawing calls are used (<code class="inlineCode">vkCmdBindPipeline()</code>, <code class="inlineCode">vkCmdBindVertexBuffers()</code>, <code class="inlineCode">vkCmdBindDescriptorSets()</code>, and <code class="inlineCode">VkCmdDraw()</code>).</p>
    <p class="normal">Since the bounding spheres for collision detection may not be identical to the bounding spheres we want to draw on the screen, we use separate methods for drawing debug spheres. The main difference between our debug draw methods is the creation of the list of instances to feed the compute shaders with.</p>
    <p class="normal">We could draw bounding spheres only on the selected instance by calling <code class="inlineCode">drawSelectedBoundingSpheres()</code>, show the bounding boxes for instances with collisions by calling <code class="inlineCode">drawCollidingBoundingSpheres()</code>, or create “fluffy white snowballs” around all instances in the screen, as in <em class="italic">Figure 8.16</em>, by calling <code class="inlineCode">drawAllBoundingSpheres()</code>.</p>
    <figure class="mediaobject"><img src="img/Image4175.png" alt="" width="379" height="515"/></figure>
    <p class="packt_figref">Figure 8.16: Adjusted bounding spheres on the nodes of the woman’s model</p>
    <p class="normal">Now that we are able to calculate and draw bounding spheres for the models, let’s add the spheres as a second tier to the<a id="_idIndexMarker414"/> collision detection code.</p>
    <h2 id="_idParaDest-249" class="heading-2">Using the bounding spheres for collision detection</h2>
    <p class="normal">The colliding instances from the <a id="_idIndexMarker415"/>quadtree are collected in the renderer by calling <code class="inlineCode">findAllIntersections()</code> and saved to <code class="inlineCode">micInstanceCollisions</code>, as already stated in the <em class="italic">Retrieving the colliding instances and reacting to the collision</em> section:</p>
    <pre class="programlisting code"><code class="hljs-code">  mModelInstCamData.micInstanceCollisions =
    mQuadtree-&gt;findAllIntersections();
</code></pre>
    <p class="normal">To make the collision detection code easier to maintain, we move the intersection extraction call to a new method called <code class="inlineCode">checkForInstanceCollisions()</code>. This new method will be the starting point for all code related to collision detection and handling.</p>
    <p class="normal">Our first step to extend collision detection is done by calling the above <code class="inlineCode">findAllIntersections()</code> method to get all colliding instances from the quadtree. Then, we split up the instances by model into separate sets of <code class="inlineCode">int</code>. Using separate lists of colliding instances per model is needed because different models may have a different number of nodes.</p>
    <p class="normal">Then, for every set of instances, we create the SSBO with the bounding spheres and extract the sphere data to a map of <code class="inlineCode">glm::ve4</code> vectors. We will use the instance index position as the key for the map, splitting up the SSBO into a map containing all spheres per instance as values.</p>
    <p class="normal">The real collision check for the bounding spheres is done by comparing all spheres from one colliding instance with all spheres of the second colliding instance. We already reduced the number of these checks by a lot, since we only have the instance pairs left that were delivered by the quadtree.</p>
    <p class="normal">But even if checking the spheres for collisions is an easy task and we just have to compare the distance between the centers with the sum of the radii of both spheres, the number of comparisons will make this check slow.</p>
    <p class="normal">Even with a shortcut to remove all spheres with a radius of zero and stopping to compare when a collision has been detected, a check between two just-not-colliding instances with 30 active spheres per model will need 900 such comparisons.</p>
    <p class="normal">Speeding up the sphere compare operations <a id="_idIndexMarker416"/>with a compute shader is possible, but problems like different node counts for each instance in a pair to check will raise the complexity and lower the efficiency of a compute shader.</p>
    <p class="normal">While the parallel computation on the GPU may be fast, uploading and downloading the data and running the shader for a single pair of instances may add a significant delay, nullifying the acceleration of the compute shader.</p>
    <p class="normal">So, we stick with the CPU-based solution to calculate the second tier of the collisions between bounding boxes. Unless we have thousands of instances in a very small virtual world or many instances in a small part of the world, the overall number of collision checks will remain low.</p>
    <p class="normal"><em class="italic">Figure 8.17</em> shows an example of a collision detected by the bounding boxes (drawn with red lines), and an additional collision of any of the bounding spheres (also in red):</p>
    <figure class="mediaobject"><img src="img/Image4186.png" alt="" width="964" height="516"/></figure>
    <p class="packt_figref">Figure 8.17: A collision was detected by the bounding spheres of the instances</p>
    <p class="normal">Handling collision remains identical to the reaction of collisions with bounding boxes in the <em class="italic">Retrieving the colliding instances and reacting to collisions</em> section – we simply rotate the colliding instances about a fixed angle in every frame. We will enhance the reaction to collisions in <a href="Chapter_9.xhtml"><em class="italic">Chapter 9</em></a> and <a href="Chapter_12.xhtml"><em class="italic">Chapter 12</em></a>.</p>
    <p class="normal">Collision detection is a complex topic with many algorithms and choices based on your application’s specific needs. We<a id="_idIndexMarker417"/> need to know what kind of objects we need to check to select a good shape of an abstraction, and depending on the complexity of the abstraction, we may need to adjust the algorithm (or algorithms) to use when trying to find collisions. We did not even touch the collision resolution part that resolves the collision by moving the instances apart after an intersection was detected. If you want to dive deeper into the world of game physics, collision detection, and collision resolution, check out the books in the <em class="italic">Additional resources</em> section.</p>
    <h1 id="_idParaDest-250" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we explored collision detection and created a two-tier collision detection for the application. We started by discussing the shortcomings of a naive solution, then we explored spatial partitioning methods and model simplifications to lower the number of checks we have to do until we are quite sure which instances really have some collisions. Finally, we implemented a quadtree with bounding boxes and bounding spheres to find out which instances collide.</p>
    <p class="normal">In the next chapter, we will create “real” <strong class="keyWord">non-player characters</strong> (<strong class="keyWord">NPCs</strong>) and let the instances come to life by adding configurable behavior. We will start by exploring the nature of behavior trees and their relation to the decision-making of NPCs, and we will implement code to support behavior trees for our instances. As the last step, we will look at the interaction between models as a specialized set of the general behavior.</p>
    <h1 id="_idParaDest-251" class="heading-1">Practical sessions</h1>
    <p class="normal">Here are some additions you could make to the code:</p>
    <ul>
      <li class="bulletList">Add UI controls for the quadtree configuration.</li>
    </ul>
    <p class="normal-one">Currently, the quadtree is statically initialized during the renderer <code class="inlineCode">init()</code> call. Add UI controls and a setter callback function to adjust the maximum number of instances before splitting up the box and the maximum depth of the tree.</p>
    <ul>
      <li class="bulletList">Add UI controls to configure the world borders.</li>
    </ul>
    <p class="normal-one">The instances are running around in the virtual world, and if one instance reaches the virtual border set in <code class="inlineCode">mWorldBoundaries</code>, it will be rotated to stay inside the boundaries. Add some sliders and callbacks to control the origin and size of the virtual world, and make sure the <strong class="screenText">Instance Positions</strong> window will be updated, too.</p>
    <ul>
      <li class="bulletList">Implement an octree plus three-dimensional AABB checks.</li>
    </ul>
    <p class="normal-one">Right now, we are using only two-dimensional bounding boxes for the instances, just as if the instances were seen top-down. Extend the quadtree to become an octree and add three-dimensional intersection checks between the AABBs of the instances.</p>
    <ul>
      <li class="bulletList">Speed up the bounding sphere collision check.</li>
    </ul>
    <p class="normal-one">Due to the general complexity of the checks – we have to check every sphere of the first instance against every sphere of the second instance – the collision check is quite slow. Maybe a compute shader can help here. In contrast to the bounding box generation, we need only a single yes/no answer per instance to signal if a collision occurred. Using an atomic counter per sphere or instance could help avoid lengthy post-processing work after the computer shader has done its job.</p>
    <ul>
      <li class="bulletList">Add a simple bounding volume hierarchy.</li>
    </ul>
    <p class="normal-one">Instead of checking all spheres of both instances, you could add some unused nodes to the models and add bigger bounding spheres to these nodes, enclosing some of the smaller spheres. Check the spheres by starting with the largest spheres for both instances. If these large spheres don’t collide, all spheres inside the larger sphere can never have a collision, and the entire part of the body could be skipped for the next collision checks.</p>
    <ul>
      <li class="bulletList">Enhanced difficulty: Do a real triangle-to-triangle check between the instances.</li>
    </ul>
    <p class="normal-one">This is the ultimate goal in collision detection. By checking the instances for real intersections, not just some AABBs or bounding spheres, natural-looking collision behavior could be achieved. Also, make note of the benefits of this method and see whether the extra precision benefits the runtime behavior.</p>
    <ul>
      <li class="bulletList">Enhanced difficulty: Add collision resolution.</li>
    </ul>
    <p class="normal-one">When the collision check signals a collision between two instances, it’s already too late – the instances are partially intersected. Good collision detection comes with collision resolution where the instances are moved apart when a collision is found. Several books have been written about collision detection and collision resolution; see the <em class="italic">Additional resources</em> section for some well-known titles. There are still many caveats on the path to “making it right.”</p>
    <h1 id="_idParaDest-252" class="heading-1">Additional resources</h1>
    <ul>
      <li class="bulletList">Separating Axis Theorem: <a href="https://dyn4j.org/2010/01/sat/">https://dyn4j.org/2010/01/sat/</a></li>
      <li class="bulletList">Gilbert–Johnson–Keerthi distance algorithm: <a href="https://cse442-17f.github.io/Gilbert-Johnson-Keerthi-Distance-Algorithm/">https://cse442-17f.github.io/Gilbert-Johnson-Keerthi-Distance-Algorithm/</a></li>
      <li class="bulletList">Template-based quadtree implementation: <a href="https://github.com/pvigier/Quadtree">https://github.com/pvigier/Quadtree</a></li>
      <li class="bulletList">Collision Detection in Interactive 3D Environments: ISBN 978-1558608016</li>
      <li class="bulletList">Real-Time Collision Detection: ISBN 978-1558607323</li>
      <li class="bulletList">Game Physics Engine Development: ISBN 978-0123819765</li>
      <li class="bulletList">Game Physics: ISBN 978-0123749031</li>
      <li class="bulletList">Collision Avoidance: <a href="https://code.tutsplus.com/understanding-steering-behaviors-collision-avoidance--gamedev-7777t">https://code.tutsplus.com/understanding-steering-behaviors-collision-avoidance--gamedev-7777t</a></li>
      <li class="bulletList">More about Collision Avoidance: <a href="https://www.gameaipro.com/GameAIPro2/GameAIPro2_Chapter19_Guide_to_Anticipatory_Collision_Avoidance.pdf">https://www.gameaipro.com/GameAIPro2/GameAIPro2_Chapter19_Guide_to_Anticipatory_Collision_Avoidance.pdf</a></li>
    </ul>
  </div>
</div></div></body></html>