# 前言

本书旨在以有趣的方式为你介绍游戏编程、C++以及 OpenGL 驱动的 SFML 的世界，通过五个难度递增、功能不断升级的有趣、可玩的游戏来实现。这些游戏包括一个上瘾的、急速的双按钮敲击游戏、一个 Pong 游戏、一个多级僵尸生存射击游戏、一个分屏多人解谜平台游戏和一个射击游戏。

在这个改进和扩展的第二版中，我们将从编程的基础开始，例如变量、循环和条件，随着你通过关键 C++主题，如**面向对象编程**（**OOP**）、C++指针以及**标准模板库**（**STL**）的介绍，你将变得越来越熟练。在构建这些游戏的过程中，你还将学习到令人兴奋的游戏编程概念，例如粒子效果、方向性声音（空间化）、OpenGL 可编程着色器、如何生成成千上万的对象等等。

# 这本书面向的对象

如果你符合以下任何一种情况，这本书非常适合你：你完全没有任何 C++编程知识，或者需要入门级别的复习课程；你想学习如何构建游戏，或者只是想将游戏作为一种有趣的学习 C++的方式；如果你有有一天发布游戏的抱负，也许是在 Steam 上，或者你只是想尽情享受乐趣，并用你的创作给朋友们留下深刻印象。

# 本书涵盖的内容

*第一章*，*C++、SFML、Visual Studio 和开始第一个游戏*，是一个相当庞大的第一章，但我们将学习所有我们需要的东西，以便让我们的第一个游戏的第一部分能够运行起来。以下是我们要做的事情：了解我们将要构建的游戏，了解 C++，了解微软 Visual C++，了解 SFML 及其与 C++的关系，设置开发环境，计划和准备第一个游戏项目 Timber!!!，在书中编写第一段 C++代码，并制作一个可以运行的游戏，该游戏可以绘制背景。

*第二章*，*变量、运算符和决策 – 动画精灵*，涉及更多的屏幕绘制，为了实现这一点，我们需要学习一些 C++的基础知识。我们将学习如何使用变量来记住和操作值，我们还将开始为游戏添加更多图形。随着章节的推进，我们将看到如何操作这些值来动画化图形。这些值被称为变量。

*第三章*，*C++ 字符串和 SFML 时间 – 玩家输入和 HUD*，继续介绍 Timber!!! 游戏。我们将用一半的章节学习如何操作文本并在屏幕上显示它，另一半将探讨时间管理以及如何通过视觉时间条来告知玩家并营造游戏的紧迫感。我们将涵盖以下内容：暂停和重新启动游戏，C++ 字符串，SFML 文本和 SFML 字体类，为 Timber!!! 添加 HUD，以及为 Timber!!! 添加时间条。

*第四章**，循环、数组、开关、枚举和函数 – 实现游戏机制*，可能比书中任何其他章节都包含更多的 C++ 信息。它充满了将极大地提高我们理解的基本概念。它还将开始揭示我们之前略过的一些模糊区域，例如函数和游戏循环。一旦我们探索了整个 C++ 语言必需品列表，我们就会利用我们所知道的一切来制作主要游戏机制——树枝——移动。到本章结束时，我们将为最终阶段和 Timber!!! 的完成做好准备。这是我们将在本章中探讨的内容：循环、数组、使用开关做出决策、枚举、开始使用函数，以及创建和移动树枝。

*第五章*，*碰撞、声音和结束条件 – 使游戏可玩*，构成了第一个项目的最后阶段。到本章结束时，你将拥有你的第一个完成的游戏。一旦 Timber!!! 运行起来，请务必阅读本章的最后部分，因为它将建议如何使游戏变得更好。在本章中，我们将涵盖以下主题：添加剩余的精灵，处理玩家输入，动画飞行木块，处理死亡，添加音效，添加功能，并改进 Timber!!!。

*第六章*，*面向对象编程 – 开始 Pong 游戏*，包含相当大量的理论，但理论将为我们提供使用 OOP 强力效果的知识。此外，我们不会浪费时间将理论应用于编码下一个项目，一个 Pong 游戏。我们将了解如何通过编写一个类来创建新类型，这些类型作为对象使用。我们将首先查看一个简化的 Pong 场景来学习一些类的基本知识，然后我们将重新开始并使用我们学到的原则来编写一个真正的 Pong 游戏。

*第七章*，*动态碰撞检测和物理 – 完成乒乓球游戏*，解释了如何编写我们的第二个类。我们将看到，尽管球显然与球拍有很大不同，但我们仍然会使用完全相同的技术，将球的外观和功能封装在 `Ball` 类中，就像我们处理球拍和 `Bat` 类一样。然后，我们将通过编写一些动态碰撞检测和计分来完善乒乓球游戏。这听起来可能很复杂，但正如我们所期待的，SFML 将使事情比其他方式更容易。

*第八章**，SFML 视图 – 开始僵尸射击游戏*，解释了该项目如何更充分地利用面向对象编程（OOP），并取得了显著的效果。我们还将探讨 SFML 的 `View` 类。这个多功能的类将使我们能够轻松地将游戏分层，以适应游戏的不同方面。在僵尸射击项目中，我们将有一个用于 HUD 的层和一个用于主游戏的层。这是必要的，因为随着游戏世界的每次扩展，玩家清除一波僵尸后，游戏世界最终将比屏幕大，需要滚动。使用视图类可以防止 HUD 中的文本与背景一起滚动。在下一个项目中，我们将更进一步，使用 SFML 视图类创建一个合作分屏游戏，视图类将完成大部分繁重的工作。这就是本章我们将要完成的内容：规划僵尸竞技场游戏，编写 `Player` 类，学习 SFML 视图类，并构建僵尸竞技场游戏引擎，使玩家类发挥作用。

*第九章*，*C++ 引用、精灵图集和顶点数组*，探讨了 C++引用，它允许我们处理那些通常不在作用域内的变量和对象。此外，引用将帮助我们避免在函数之间传递大型对象，这是一个缓慢的过程。这是因为每次我们这样做时，都必须创建变量或对象的副本。掌握了关于引用的新知识后，我们将研究 SFML 的 `VertexArray` 类，它允许我们构建一个大型图像，可以通过单个图像文件中的多个部分快速高效地绘制到屏幕上。到本章结束时，我们将使用引用和 `VertexArray` 对象构建一个可伸缩的、随机的、滚动的背景。

*第十章*，*指针、标准模板库和纹理管理*，首先介绍了 C++的基本主题——指针。指针是存储内存地址的变量。通常，指针将存储另一个变量的内存地址。这听起来有点像引用，但我们将看到它们要强大得多，我们将使用指针来处理不断增长的僵尸群。我们还将了解 STL，它是一组类，允许我们快速轻松地实现常见的数据管理技术。一旦我们理解了 STL 的基础，我们就能使用新获得的知识来管理游戏中的所有纹理，因为如果我们有 1,000 个僵尸，我们真的不希望为每个僵尸加载一个图形副本到 GPU 中。我们还将更深入地探讨面向对象编程，并使用静态函数，这是一个可以在没有类实例的情况下调用的类函数。同时，我们将看到如何设计一个类，以确保只能存在一个实例。当我们需要确保代码的不同部分使用相同的数据时，这是理想的。

*第十一章*，*碰撞检测、拾取和子弹*，解释了到目前为止我们是如何实现游戏的主要视觉方面的。我们有一个可控的角色在一个满是僵尸的竞技场中奔跑，这些僵尸会追逐他。问题是它们之间没有互动。一个僵尸可以毫无阻碍地穿过玩家而不会留下任何痕迹。我们需要检测僵尸和玩家之间的碰撞。如果僵尸能够伤害并最终杀死玩家，那么给玩家一些子弹是公平的。然后我们需要确保子弹能够击中和杀死僵尸。同时，如果我们正在编写子弹、僵尸和玩家的碰撞检测代码，那么添加一个用于健康和弹药拾取的类也是一个好时机。

*第十二章*，*分层视图和实现 HUD*，是我们将看到 SFML 视图真正价值的章节。我们将添加大量 SFML `Text` 对象，并像在 Timber 项目和 Pong 项目中那样操作它们。新的地方在于，我们将使用第二个视图实例来绘制 HUD。这样，无论背景、玩家、僵尸和其他游戏对象在做什么，HUD 都会整齐地定位在主要游戏动作的上方。

*第十三章*, *音效、文件输入/输出和完成游戏*，展示了我们如何使用 C++标准库轻松地操作硬盘上存储的文件，并且我们还将添加音效。当然，我们知道如何添加音效，但我们将讨论代码中调用播放函数的确切位置。我们还将解决一些悬而未决的问题，使游戏完整。在本章中，我们将做以下事情：使用文件输入和文件输出保存和加载高分，添加音效以允许玩家升级，并创建无限循环的多波次。

*第十四章*, *抽象和代码管理 – 更好地利用面向对象编程*，专注于启动托马斯独自一个项目，特别是探索代码将如何结构化以更好地利用面向对象编程。以下是本章将涵盖的主题的详细信息：介绍了最终项目，托马斯迟到，包括游戏玩法功能和项目资产，并详细讨论了与之前项目相比，我们将如何改进代码结构，编写托马斯迟到游戏引擎，并实现分屏功能。

*第十五章*, *高级面向对象编程 – 继承和多态*，通过探讨稍微高级一些的继承和多态概念，进一步扩展了我们对于面向对象编程的知识。然后，我们将能够运用这些新知识来实现游戏中的主角，托马斯和鲍勃。以下是本章将涵盖的内容：学习如何通过继承扩展和修改一个类，通过使用多态将一个类的对象视为多种类型的类，了解抽象类以及设计永远不会实例化的类实际上可能是有用的，构建一个抽象的 `PlayableCharacter` 类，将继承应用于 `Thomas` 和 `Bob` 类，并将托马斯和鲍勃添加到游戏项目中。

*第十六章*，*构建可玩关卡和碰撞检测*，可能会证明是本项目中最令人满意的一章。原因在于，到那时，我们将拥有一个可玩的游戏。尽管仍有一些功能需要实现（声音、粒子效果、HUD 和着色器效果），Bob 和 Thomas 将能够跑步、跳跃和探索世界。此外，你只需在文本文件中创建平台和障碍物，就可以简单地创建任何大小或复杂性的自己的关卡设计。我们将通过以下主题实现所有这些：探索如何在文本文件中设计关卡，构建一个`LevelManager`类，从文本文件中加载关卡，将它们转换为我们的游戏可以使用的数据，并跟踪关卡细节，如出生位置、当前关卡和允许的时间限制，更新游戏引擎以使用`LevelManager`，并编写一个多态函数来处理 Bob 和 Thomas 的碰撞检测。

*第十七章*，*声音空间化和 HUD*，添加了所有声音效果和 HUD。我们已经在之前的两个项目中这样做过，但这次我们会有些不同。我们将探讨声音空间化的概念以及 SFML 如何使这个原本复杂的概念变得简单易行。此外，我们将构建一个 HUD 类来封装我们绘制到屏幕上的代码。我们将按以下顺序完成任务：空间化的定义，SFML 如何处理空间化，构建一个`SoundManager`类，部署发射器，使用`SoundManager`类，以及构建和使用一个 HUD 类。

*第十八章*，*粒子系统和着色器*，探讨了粒子系统是什么，然后继续将其编码到我们的游戏中。我们将浅析 OpenGL 着色器这一主题，并看看使用另一种语言**OpenGL 着色语言**（**GLSL**），它可以直接在图形卡上运行，如何产生可能在其他情况下无法实现的平滑图形效果。像往常一样，我们也将利用我们新的技能和知识来增强当前项目。

*第十九章*，*游戏编程设计模式 – 开始 Space Invaders ++游戏*，介绍了最终项目。正如你现在所期望的，这个项目将学习新的 C++技术迈出重要一步。接下来的四章将探讨包括智能指针、C++断言、使用游戏手柄控制器、使用 Visual Studio 进行调试、将基类指针转换为特定派生类指针、调试以及初步了解设计模式等主题。作者推测，如果你打算用 C++制作深度、大规模的游戏，那么设计模式将是你在未来几个月和几年学习计划中的一个重要部分。为了介绍这个至关重要的主题，我选择了一个相对简单但有趣的游戏作为例子。让我们更深入地了解一下 Space Invaders ++游戏，然后我们可以继续讨论设计模式及其必要性。在本章中，我们将涵盖以下主题：了解 Space Invaders ++及其为何被选为最终项目，学习设计模式是什么以及为什么它们对游戏开发者很重要，研究在接下来的四章中将在 Space Invaders ++项目中使用的各种设计模式，开始 Space Invaders ++项目，并编写许多类以开始完善游戏。

*第二十章*，*游戏对象和组件*，涵盖了我们在上一章开头讨论的实体-组件模式的所有编码。这意味着我们将编写所有其他组件都将从中派生的基本组件类。我们还将充分利用我们关于智能指针的新知识，这样我们就不必担心跟踪为这些组件分配的内存。我们还将在本章中编写`GameObject`类。以下是本章的章节列表：准备编写组件，编写组件基类，编写碰撞组件，编写图形组件，编写更新组件，以及编写`GameObject`类。

*第二十一章*，*文件 I/O 和游戏对象工厂*，解释了`GameObject`如何进入游戏中使用的`m_GameObjects`向量。我们将看到如何在一个文本文件中描述单个对象和整个关卡。我们将编写代码来解释文本，然后将值加载到一个将成为游戏对象蓝图 的类中。我们将编写一个名为`LevelManager`的类，它将监督整个过程，从`InputHandler`通过`ScreenManager`发送的初始请求加载关卡开始，一直到使用工厂模式从组件组装游戏对象并将其整齐地打包到`m_GameObjects`向量中的`LevelManager`类。

*第二十二章*，*使用游戏对象和构建游戏*，构成了 Space Invaders ++项目的最后阶段。我们将学习如何使用 SFML 从游戏手柄接收输入来完成所有困难的工作，我们还将编写一个类来处理入侵者和`GameScreen`类之间的通信，以及玩家和`GameScreen`类之间的通信。这个类将允许玩家和入侵者发射子弹，但同样的技术也可以用于您游戏中不同部分之间所需的任何类型的通信，因此了解它是很有用的。游戏的最后部分（就像往常一样）将是碰撞检测和游戏本身的逻辑。一旦 Space Invaders ++运行起来，我们将学习如何使用 Visual Studio 调试器，这在您设计自己的逻辑时将非常有价值，因为它允许您逐行执行代码并查看变量的值。它也是研究我们在整个项目过程中构建的模式执行流程的有用工具。

*第二十三章*，*在离开之前...*，结束了我们的旅程。当您第一次打开这本书时，可能觉得最后一页似乎还很遥远。但希望这并不太难？重点是您现在在这里，并且希望您对如何使用 C++构建游戏有了深刻的理解。听到即使在这数百页之后，我们才刚刚涉足 C++，可能会让您感到惊讶。甚至我们涵盖的主题也可以更深入地探讨，而且还有许多，其中一些相当重要，我们甚至没有提及。考虑到这一点，让我们看看接下来可能是什么。

# 为了充分利用这本书

需要满足以下要求：

+   Windows 7 Service Pack 1、Windows 8 或 Windows 10

+   1.6 GHz 或更快的处理器

+   1 GB 的 RAM（x86 架构）或 2 GB 的 RAM（x64 架构）

+   15 GB 的可用硬盘空间

+   5400 RPM 的硬盘驱动器

+   具有 DirectX 9 功能的显卡，支持 1024 x 768 或更高显示分辨率

本书使用的所有软件都是免费的。获取和安装软件的步骤在书中都有详细说明。本书在 Windows 上使用 Visual Studio，但经验丰富的 Linux 和 Mac 用户在使用他们喜欢的编程环境运行代码和遵循说明时可能不会有任何困难。

## 下载示例代码文件

您可以从[www.packt.com](http://www.packt.com)的账户下载本书的示例代码文件。如果您在其他地方购买了这本书，您可以访问[www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给您。

您可以通过以下步骤下载代码文件：

1.  在[`www.packt.com`](http://www.packt.com)登录或注册。

1.  选择**支持**选项卡。

1.  点击**代码下载**。

1.  在**搜索**框中输入书名，并遵循屏幕上的说明。

文件下载后，请确保使用最新版本解压缩或提取文件夹：

+   WinRAR / 7-Zip for Windows

+   Zipeg / iZip / UnRarX for Mac

+   7-Zip / PeaZip for Linux

本书代码包也托管在 GitHub 上，网址为[`github.com/PacktPublishing/Beginning-Cpp-Game-Programming-Second-Edition`](https://github.com/PacktPublishing/Beginning-Cpp-Game-Programming-Second-Edition)。如果代码有更新，它将在现有的 GitHub 仓库中更新。

我们还有其他来自我们丰富图书和视频目录的代码包可供在[`github.com/PacktPublishing/`](https://github.com/PacktPublishing/)获取。查看它们吧！

## 下载彩色图片

我们还提供了一份包含本书中使用的截图/图表的彩色图片的 PDF 文件。您可以从这里下载：[`static.packt-cdn.com/downloads/9781838648572_ColorImages.pdf`](https://static.packt-cdn.com/downloads/9781838648572_ColorImages.pdf)。

## 使用的约定

本书使用了多种文本约定。

`CodeInText`: 表示文本中的代码单词、数据库表名、文件夹名、文件名、文件扩展名、路径名、虚拟 URL、用户输入和 Twitter 昵称。例如：“我的主要项目目录是 `D:\VS Projects\Timber`。”

代码块设置如下：

```cpp
int main()
{
    return 0;
}
```

当我们希望引起你对代码块中特定部分的注意时，相关的行或项目将以粗体显示：

```cpp
int main()
{
    return 0;
}
```

**粗体**: 表示新术语、重要单词或你在屏幕上看到的单词。例如，菜单或对话框中的单词在文本中显示如下。以下是一个例子：“点击**创建新项目**按钮。”

重要提示

警告或重要提示如下所示。

小贴士

小技巧和技巧如下所示。

# 联系我们

我们欢迎读者的反馈。

**一般反馈**: 如果你对本书的任何方面有疑问，请在邮件主题中提及书名，并通过 customercare@packtpub.com 给我们发送邮件。

**勘误**: 尽管我们已经尽一切努力确保内容的准确性，但错误仍然可能发生。如果你在这本书中发现了错误，我们将不胜感激，如果你能向我们报告这个错误。请访问[www.packtpub.com/support/errata](http://www.packtpub.com/support/errata)，选择你的书，点击勘误提交表单链接，并输入详细信息。

**盗版**: 如果你在互联网上以任何形式遇到我们作品的非法副本，如果你能提供位置地址或网站名称，我们将不胜感激。请通过版权@packt.com 与我们联系，并提供材料的链接。

**如果您有兴趣成为作者**：如果您在某个领域有专业知识，并且您有兴趣撰写或为书籍做出贡献，请访问 [authors.packtpub.com](http://authors.packtpub.com)。

## 评论

请留下评论。一旦您阅读并使用了这本书，为何不在您购买它的网站上留下评论呢？潜在读者可以查看并使用您的客观意见来做出购买决定，我们 Packt 可以了解您对我们产品的看法，而我们的作者也可以看到他们对书籍的反馈。谢谢！

关于 Packt 的更多信息，请访问 [packt.com](http://packt.com)。
