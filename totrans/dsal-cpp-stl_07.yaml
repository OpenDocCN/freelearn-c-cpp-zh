- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Advanced Ordered Associative Container Usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Associative containers in C++ allow developers to manage data in ways that align
    more naturally with real-world scenarios, such as using keys to retrieve values.
    This chapter gets into both ordered and unordered associative containers, their
    unique attributes, and ideal application environments. For the intermediate C++
    developer, understanding when to use a map over an unordered map or the nuances
    between a set and a multiset can be pivotal in optimizing performance, memory
    usage, and data retrieval speed. Furthermore, mastering best practices will empower
    developers to write efficient, maintainable, and bug-free code, ensuring containers
    serve their purpose effectively in diverse application contexts.
  prefs: []
  type: TYPE_NORMAL
- en: In essence, ordered associative containers, with their strict order and unique
    (or, sometimes, not so unique) elements, provide powerful tools in the C++ developer’s
    arsenal. They are tailor-made for scenarios that involve relationships, ordering,
    and uniqueness. Understanding their characteristics and use cases is the first
    step in leveraging their full potential.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter provides a reference for the following containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::set`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::map`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::multiset`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::multimap`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code in this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
  prefs: []
  type: TYPE_NORMAL
- en: std::set
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At its heart, a `std::set` container is a collection of unique elements where
    each element follows a strict order. You can think of it as a club where each
    member is distinct and all have a particular rank. The container ensures that
    no two elements are the same, making it exceptionally useful in situations where
    duplicates are not desired.
  prefs: []
  type: TYPE_NORMAL
- en: Purpose and suitability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::set` is an associative container designed to store a sorted set of unique
    objects of type `Key`. Its strengths are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring all elements are unique
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatically sorting elements as they are inserted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is particularly suitable in the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: When duplicate elements are not desired
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the ordering of elements matters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When frequent lookups and insertions are anticipated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ideal use cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are some ideal use cases of `std::set`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::set` naturally enforces this. For instance, it will be useful when collecting
    a list of unique student IDs or product codes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::set` keeps its elements in a sorted order as per the comparison criteria.
    It’s beneficial when you require data to be inherently sorted, such as when maintaining
    a leaderboard where scores are continuously inserted but should always be in order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::set` offers logarithmic time complexity for lookups. This makes it apt
    for scenarios where frequent membership checks are necessary – for instance, checking
    if a particular user is part of a VIP list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::set` can be invaluable. It’s particularly useful in situations where
    you might want to find common elements between two collections or determine which
    elements are exclusive to one set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::set` container can be used to keep track of these times. Given its ordered
    nature, you can swiftly determine the next event or if a particular time slot
    is already booked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s worth noting that while `std::set` is adept at these tasks, it is crucial
    to evaluate the specific requirements of the problem at hand. If ordering is not
    essential and you primarily need quick insertions, deletions, and lookups without
    regard for order, `std::unordered_set` might be a more suitable choice.
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The algorithmic performance of `std::set` is characterized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Insertion**: Typically *O(log n)* due to the balanced binary search tree
    structure'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deletion**: *O(log n)* for individual elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access (finding elements)**: *O(log n)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::vector` due to the tree structure'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Internally, `std::set` uses a tree structure, typically a balanced binary search
    tree. Memory allocation can be influenced using custom allocators.
  prefs: []
  type: TYPE_NORMAL
- en: Thread safety
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to `std::vector`, concurrent reads are safe, but modifications or a
    combination of reads and modifications necessitate external synchronization.
  prefs: []
  type: TYPE_NORMAL
- en: Extensions and variants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The C++ `std::multiset` (which allows repeated elements) and `std::unordered_set`
    (a hash table, providing average *O(1)* insert/find at the cost of no ordering).
  prefs: []
  type: TYPE_NORMAL
- en: Sorting and searching complexity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The sorting and search complexity is characterized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sorting**: Elements are automatically sorted upon insertion'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`find` member function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special interface and member functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some handy member functions to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`emplace`: Insert elements in place'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`count`: Return the number of elements (always 0 or 1 in a set)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lower_bound` and `upper_bound`: Provide bounds for a specific key'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparisons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In contrast to `std::vector`, `std::set` excels in ensuring uniqueness and maintaining
    order but may not be optimal for frequent random access or if order isn’t a concern.
  prefs: []
  type: TYPE_NORMAL
- en: Interactions with algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Given its bidirectional iterators, many STL algorithms are compatible with `std::set`.
    However, algorithms requiring random access might not be ideal.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: No exceptions are thrown due to capacity issues since `std::set` does not have
    a fixed capacity. Exceptions can arise from allocators during memory allocation.
  prefs: []
  type: TYPE_NORMAL
- en: Customization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::set` allows custom allocators for memory management. You can also provide
    a custom comparator to define how a set’s elements are ordered.'
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::set` is a sorted associative container that contains unique elements.
    It is typically used to represent a collection where the existence of an element
    is more important than the number of times it appears. The following code is an
    example illustrating best practices when using `std::set`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the example output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we did the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We demonstrated basic `std::set` operations such as insertion, finding an element,
    and erasing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We showcased how a set inherently sorts its elements and how to iterate over
    them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of the `merge` function was illustrated to merge another set into our
    primary set.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `count` method was used to check for the existence of an element in a set,
    which can only be 0 or 1 due to the uniqueness constraint.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, we used a custom comparator to create a case-insensitive set of strings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us explore the best practices of using `std::set`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::set`, access time is not constant as in `std::vector` or `std::array`.
    Due to its tree-based structure, element retrieval typically takes logarithmic
    time. When designing algorithms, factor this in.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::set` container, it is immutable. Altering it directly via an iterator
    could breach the set’s internal ordering. If modification is imperative, erase
    the old element and insert its updated version.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_set`. Thanks to its hash-based design, it frequently trumps
    `std::set` in performance metrics, barring worst-case scenarios.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`emplace` to create elements right within a set. This technique forestalls
    unnecessary object copying or movement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Navigate element alterations**: Direct tinkering of set elements is a no-go.
    The best approach when you need a modification is a two-step process: remove the
    original and introduce its altered counterpart.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`find` method is your go-to for determining if an element resides in a set.
    It’s more succinct and expressive than `count` in the context of `std::set`, given
    a set’s unique element nature.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::is_sorted`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::set` is not intrinsically thread-safe. If concurrent access by multiple
    threads is anticipated, guard the set with synchronization primitives such as
    `std::mutex` or consider using concurrent containers provided by certain C++ libraries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::set` container, remember that the elements are sorted. This can often
    obviate the need for additional sorting operations that you might apply on other
    containers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::vector`, `std::set` doesn’t support `reserve` or `capacity` operations.
    The tree grows as elements are added. For efficiency, when removing elements,
    consider occasional `shrink_to_fit` operations available in some implementations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: std::map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A sibling to the `std::set` container, `std::map` is about relationships. It
    connects unique keys to specific values, forming a pair. In layman’s terms, imagine
    a dictionary where each word (key) has a unique definition (value).
  prefs: []
  type: TYPE_NORMAL
- en: Purpose and suitability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::map` is an ordered associative container that stores key-value pairs,
    ensuring unique keys. Its underlying data structure is typically a balanced binary
    tree (such as a **red-black tree** (**RBT**)). The main advantages include the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Logarithmic access, insertion, and deletion times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintaining key-value pairs in sorted order by keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use `std::map` in the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: When you need to associate values with unique keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When maintaining the order of keys is important
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When frequent access, insertion, or deletion operations are required, and they
    need to be efficient
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ideal use cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are some ideal use cases of `std::map`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::map` shines when associating unique keys with specific values. For example,
    it is useful when mapping a person’s name (unique key) to their contact details
    or a word to its definition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::map` container can associate different configuration keys with their
    respective values, ensuring easy retrieval and modification of settings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Student record system**: Educational institutions might maintain a record
    system where student IDs (ensured to be unique) act as keys, mapping to comprehensive
    student profiles comprising names, courses, grades, and other details.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::map` can associate distinct items with their occurrence counts, ensuring
    efficient updates and retrievals.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::map` container for this purpose ensures that terms are sorted and can
    be efficiently accessed or updated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::map` can serve as a cache, mapping input values to their computed results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::map` inherently maintains its elements in sorted order based on its keys,
    it is apt for scenarios where operations dependent on this order are frequent
    – for example, fetching the *top 10* or *lowest 5* based on some criteria.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always consider the specific needs of your problem. While `std::map` offers
    ordering and unique key-value association, if ordering isn’t required, `std::unordered_map`
    might be a more performance-efficient alternative due to its average constant-time
    complexity for most operations.
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The algorithmic performance of `std::map` is characterized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Insertion**: *O(log n)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deletion**: *O(log n)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access**: *O(log n)* to locate a key'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory overhead**: Generally higher than hash-based counterparts due to tree-based
    structure'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The primary trade-off is balancing memory overhead with the efficiency of ordered
    operations and the flexibility of key-value pair manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: Memory management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::map` efficiently manages its memory internally, ensuring balanced trees.
    However, specific behavior can be influenced by custom allocators, allowing for
    more control.'
  prefs: []
  type: TYPE_NORMAL
- en: Thread safety
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Concurrent reads are safe. However, concurrent writes or mixed read-writes require
    external synchronization, such as utilizing mutexes.
  prefs: []
  type: TYPE_NORMAL
- en: Extensions and variants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::multimap` allows multiple values per key, whereas `std::unordered_map`
    offers a hash-table-based alternative without ordering but with potential *O(1)*
    average access times.'
  prefs: []
  type: TYPE_NORMAL
- en: Sorting and searching complexity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The sorting and search complexity is characterized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::map` inherently maintains sorting'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Searching**: *O(log n)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special interface and member functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some handy member functions to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`emplace`: Directly constructs a key-value pair in place'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`at`: Throws an exception if the key doesn’t exist'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`operator[]`: Accesses or creates a value for a given key'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lower_bound` and `upper_bound`: Provide iterators pointing to positions relative
    to a key'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparisons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Compared to `std::unordered_map`, `std::map` excels in scenarios where key order
    matters or when the dataset might grow and shrink frequently. For situations demanding
    raw performance and where the order is insignificant, `std::unordered_map` might
    be preferable.
  prefs: []
  type: TYPE_NORMAL
- en: Interactions with algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While many STL algorithms can work with `std::map`, its bidirectional iterators
    limit its compatibility with algorithms requiring random access.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Operations such as `at()` can throw out-of-range exceptions. Most operations
    on `std::map` provide strong exception safety, ensuring the map remains unchanged
    if an exception is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: Customization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can provide custom comparators to dictate the order of keys or use custom
    allocators to influence memory management.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In `std::map`, keys are sorted and unique, making it easy to find specific
    entries. The following code is an example illustrating best practices when using
    `std::map`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the example output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we did the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We demonstrated the basic operations of `std::map`, such as insertion, modification,
    checking for the existence of a key, and iterating over its elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We used structured bindings (C++17) to restructure the key-value pairs when
    iterating.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We illustrated the use of `count` to check if a key exists in the map.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We created a custom-ordered map by providing a custom comparator that sorts
    the keys in reverse lexicographical order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us explore the best practices of using `std::map`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::map`, the key remains constant for the lifetime of that element. Modifying
    it directly is not allowed. Should you need to update the key, the correct approach
    is to remove the old key-value pair and insert a new one with the desired key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_map`. Its hash table-based implementation may offer faster
    average-time complexities for many operations compared to the RBT of `std::map`,
    reducing potential overhead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`emplace` method, which constructs the element in place within the map, avoiding
    temporary object creation and unnecessary copies. When paired with tools such
    as `std::make_pair` or `std::piecewise_construct`, it optimizes performance for
    insertions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`operator[]` method, though convenient, can be a double-edged sword. If the
    specified key does not exist, it inserts the key with a default-initialized value
    into the map. When you wish to only query, without potential insertions, use the
    `find` method instead. The `find` method returns an iterator to the element if
    found and to the `end()` method if not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::map` might not always fit the use case. You can customize the order by
    providing a comparator when defining the map. Ensure this comparator enforces
    a strict weak ordering to maintain the integrity of the map’s internal structures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::map` container, synchronization becomes imperative. Consider using `std::mutex`
    or other STL synchronization primitives to lock access during write operations,
    preserving data consistency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`count` method for a direct count result. For a map, this will always return
    `0` or `1`, making it a fast way to check membership.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`erase` operation invalidates the iterator. Use the returned iterator from
    `erase` to continue operations safely.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::map` offers range methods such as `equal_range`, which can return the
    bounds of a subrange of elements with keys equivalent to a given key. Utilize
    them for efficient subrange manipulations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::map` supports custom allocators. This allows for better control over
    allocation and deallocation processes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: std::multiset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While a `std::set` container prides itself on its exclusivity, `std::multiset`
    is a bit more accommodating. It still maintains order, but it allows multiple
    elements to have the same value. This container is like a club where members have
    ranks, but there’s room for more than one member at each rank.
  prefs: []
  type: TYPE_NORMAL
- en: Purpose and suitability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::multiset` is an associative container that stores sorted elements and
    allows multiple occurrences of an element. Its key strengths are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Maintaining a sorted order of elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowing duplicates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Offering logarithmic time complexity for insertion, deletion, and search
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It’s particularly suitable in the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: When duplicate values need to be retained
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you require elements to always remain sorted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When random access is not a necessity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ideal use cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are some ideal use cases for `std::multiset`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::multiset` container is beneficial. It allows for the storage of duplicate
    values while maintaining them in a sorted order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::multiset` container is invaluable due to its inherent sorted nature and
    its ability to accommodate repeated numbers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::multiset` container can help in efficiently managing and tracking these
    selections, especially when a popular session is chosen multiple times.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::multiset` container can represent such items, allowing easy tracking
    and replenishment based on demand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::map`) maps terms to documents, a `std::multiset` container can be used
    to keep track of how frequently terms appear across multiple documents, even if
    some terms are common and appear repeatedly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::multiset` to manage events or points efficiently, especially when multiple
    events share the same position.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::multiset` shines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember, while `std::multiset` is designed to handle multiple instances of
    the same value in a sorted manner, if the sorted property isn’t essential and
    you want to keep track of multiple items, structures such as `std::unordered_multiset`
    can be more performance-efficient in some cases due to hash-based implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The algorithmic performance of `std::multiset` is characterized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Insertion**: *O(log n)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deletion**: *O(log n)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access**: Elements are accessed in *O(log* *n)* time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory overhead**: Overhead is present due to internal balancing (typically
    implemented as a balanced binary search tree)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::multiset` does not dynamically resize like `std::vector`. Instead, it
    uses dynamic memory allocation for nodes as elements are inserted. Allocators
    can influence node memory management.'
  prefs: []
  type: TYPE_NORMAL
- en: Thread safety
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Concurrent reads are safe. However, modifications (insertions or deletions)
    require external synchronization. Utilizing mutexes or other synchronization primitives
    is recommended for concurrent writes.
  prefs: []
  type: TYPE_NORMAL
- en: Extensions and variants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::set` is a direct variant that disallows duplicates. There’s also `std::unordered_multiset`,
    which offers average constant-time complexity for operations but does not maintain
    order.'
  prefs: []
  type: TYPE_NORMAL
- en: Sorting and searching complexity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The sorting and search complexity is characterized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sorting**: Elements are always sorted; thus, no sort operation is required'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Searching**: *O(log n)* due to its tree-based nature'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special interface and member functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While it provides regular functions (`insert`, `erase`, `find`), some handy
    ones include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`count`: Returns the total number of elements matching a specified key'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`equal_range`: Provides range (iterators) of all instances of an element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparisons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Against `std::set`, `std::multiset` allows duplicates but at the cost of slightly
    increased memory. Against sequence containers such as `std::vector`, it maintains
    sorted order but doesn’t offer constant-time access.
  prefs: []
  type: TYPE_NORMAL
- en: Interactions with algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Algorithms that benefit from sorted data (such as binary searches or set operations)
    work well with `std::multiset`. Those requiring random access or frequent reordering
    might not be suitable.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Memory allocation failures can throw exceptions. Most `std::multiset` operations
    provide strong exception-safety guarantees.
  prefs: []
  type: TYPE_NORMAL
- en: Customization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In `std::multiset`, customization entails the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Custom allocators can be used to control memory allocation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom comparators can be provided to dictate the order of element storage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::multiset` is a container that can store multiple keys, including duplicate
    keys. The keys are always sorted from the lowest key to the highest. `std::multiset`
    is typically used in situations where you need to maintain a sorted set of elements,
    and duplicates are allowed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is an example of using `std::multiset`, demonstrating some
    of its unique features and best practices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the example output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Key takeaways from the preceding example are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::multiset` automatically sorts keys.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can store duplicate keys, and this property can be utilized for certain algorithms
    or storage patterns where duplicates are meaningful.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `equal_range` is a best practice to find all instances of a key. This
    method returns both the beginning and the end iterators, covering all instances
    of the key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom comparators, such as `std::greater<>`, can be used to reverse the default
    ordering.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lower_bound` and `upper_bound` can be used for efficient range queries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember, if you don’t need to store duplicates, then `std::set` is a more appropriate
    choice.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us explore the best practices of using `std::multiset`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::multiset` to prevent undue overhead. Instead, favor `std::set`, which
    inherently manages unique elements and can be more efficient.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::multiset` doesn’t offer the same constant-time access that `std::vector`
    provides. Accessing elements is logarithmic in complexity due to the underlying
    tree-based data structure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::multiset` to hold duplicate elements can lead to elevated memory usage,
    especially when those duplicates are numerous. It’s crucial to analyze memory
    requirements and ensure the container’s suitability for the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::multiset`, ensure that it imposes a strict weak ordering. Any inconsistency
    in ordering can lead to undefined behavior. Test the comparator rigorously to
    confirm its reliability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`find` and `count` member functions. They offer a more efficient and direct
    way to perform such checks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::multiset`, clearly outline the reasons for needing duplicate entries.
    If the rationale isn’t strong, or duplicates don’t benefit your application logic
    significantly, consider using `std::set`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: std::multimap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Extending the principles of `std::map`, the `std::multimap` container allows
    for one key to be associated with multiple values. It’s like a dictionary where
    a word might have several related definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Purpose and suitability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::multimap` is an associative container within the STL. Its distinguishing
    features are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Storing key-value pairs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowing multiple values with the same key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing elements in a sorted manner, as determined by the key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It’s particularly suitable in the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: When you need to maintain a collection with non-unique keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you want sorted access based on keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When key-value mapping is paramount
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose `std::multimap` when you expect multiple values under the same key. If
    unique keys are necessary, you might want to look into `std::map`.
  prefs: []
  type: TYPE_NORMAL
- en: Ideal use cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are some ideal use cases of `std::multimap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::multimap`, you can associate one key with several values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::multimap` container can effectively map these multiple meanings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::multimap` container can associate a destination (key) with various flight
    details or times (values).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::multimap`, one can easily keep track of all events for a specific date.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::multimap` can be handy, especially when weights or other data associated
    with the edges are required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::multimap` container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::multimap` container is apt for such use cases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::multimap` helps in organizing and retrieving media based on tags efficiently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember that `std::multimap` is a go-to when one-to-many relationships are
    prevalent. However, if order and sorting aren’t crucial and efficient retrieval
    is more important, considering structures such as `std::unordered_multimap` can
    be beneficial due to their hash-based nature.
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The algorithmic performance of std::multimap is characterized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Insertion**: Logarithmic *O(log n)* in most cases'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deletion**: Logarithmic *O(log* *n)* generally'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access**: *O(log n)* for specific keys'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory overhead**: It is a bit higher due to maintaining the tree-based structure
    and potential balancing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::multimap` internally employs a tree structure, typically an RBT. Thus,
    memory allocation and balancing operations can occur. Allocators can influence
    its memory handling.'
  prefs: []
  type: TYPE_NORMAL
- en: Thread safety
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Multiple reads are safe. However, writes or combinations of reads and writes
    require external synchronization. Using tools such as mutexes is advisable.
  prefs: []
  type: TYPE_NORMAL
- en: Extensions and variants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For hash-table-based key-value mapping, consider `std::unordered_multimap`.
    For unique key-value mapping, `std::map` is more appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting and searching complexity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The sorting and search complexity is characterized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sorting**: Sorting is inherent, as elements are maintained in key order'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Searching**: *O(log n)* to locate a specific key'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special interface and member functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Standard functions such as `insert`, `erase`, and `find` are available. The
    following are also available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`count`: Returns the number of elements with a particular key'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`equal_range`: Retrieves the range of elements with a specific key'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparisons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Against `std::unordered_multimap`, `std::multimap` offers ordered access but
    might have a slightly higher overhead due to its tree-based nature.
  prefs: []
  type: TYPE_NORMAL
- en: Interactions with algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since `std::multimap` maintains ordered access, algorithms that benefit from
    sorted data (such as `std::set_intersection`) can be useful. However, remember
    that data is key-ordered.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Trying to access non-existent keys or out-of-bound scenarios can throw exceptions.
    Most operations are strongly exception-safe, ensuring the container remains valid
    even if an exception is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: Customization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Custom allocators can refine memory management. `std::multimap` also allows
    custom comparators to dictate the ordering of keys.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::multimap` is a container that maintains a collection of key-value pairs,
    where multiple pairs can have the same key. The keys in `std::multimap` are always
    sorted.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is an example of using `std::multimap`, demonstrating some
    of its unique features and best practices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the example output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Key takeaways from the preceding code are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::multimap` automatically sorts keys.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can store multiple key-value pairs with the same key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `equal_range` is a best practice to find all instances of a key. This
    method returns both the beginning and the end iterators, covering all instances
    of the key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`grades.count("John")` efficiently counts the number of key-value pairs with
    the specified key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom comparators, such as `std::greater<>`, can change the ordering from the
    default ascending order to descending.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `std::multimap` container is useful when you need a dictionary-like data structure
    that supports duplicate keys. If duplicates aren’t needed, `std::map` would be
    a more appropriate choice.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us explore the best practices of using `std::multimap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::multimap`. The access complexity is logarithmic, attributed to its tree-based
    underpinning.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::multimap` are unique, as in `std::map`. A `std::multimap` container permits
    multiple entries for a single key. If your application demands unique keys, then
    `std::map` is the appropriate choice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::multimap` is the inherent sorted nature of its elements based on the
    keys. Exploit this characteristic to your advantage, especially when performing
    operations that benefit from ordered data, such as range searches or ordered merges.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_multimap` might be a more fitting alternative due to its hashing
    mechanism. However, it is worth noting that worst-case performance and memory
    overheads can differ.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`find` or `count`. It helps prevent potential pitfalls and ensure robust code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use custom comparators for tailored sorting**: Should you have a specific
    ordering requirement that deviates from the default, use custom comparators. Ensure
    that your comparator enforces a strict weak ordering to guarantee consistent and
    defined behavior of the multimap.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`equal_range` member function. It provides a range (beginning and end iterators)
    of all elements with a particular key, enabling efficient iteration over those
    specific elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::multimap` can become inefficient with large datasets, especially if frequent
    insertions and deletions are commonplace. In such scenarios, evaluate the structure’s
    performance and consider alternatives or optimization strategies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
