- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Advanced Ordered Associative Container Usage
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级有序关联容器使用
- en: Associative containers in C++ allow developers to manage data in ways that align
    more naturally with real-world scenarios, such as using keys to retrieve values.
    This chapter gets into both ordered and unordered associative containers, their
    unique attributes, and ideal application environments. For the intermediate C++
    developer, understanding when to use a map over an unordered map or the nuances
    between a set and a multiset can be pivotal in optimizing performance, memory
    usage, and data retrieval speed. Furthermore, mastering best practices will empower
    developers to write efficient, maintainable, and bug-free code, ensuring containers
    serve their purpose effectively in diverse application contexts.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: C++中的关联容器允许开发者以更符合现实场景的方式管理数据，例如使用键来检索值。本章将探讨有序和无序关联容器，它们的独特属性以及理想的应用环境。对于中级C++开发者来说，理解何时使用map而不是unordered_map，或者理解set和multiset之间的细微差别，对于优化性能、内存使用和数据检索速度至关重要。此外，掌握最佳实践将使开发者能够编写高效、可维护且无错误的代码，确保容器在多种应用场景中有效地发挥作用。
- en: In essence, ordered associative containers, with their strict order and unique
    (or, sometimes, not so unique) elements, provide powerful tools in the C++ developer’s
    arsenal. They are tailor-made for scenarios that involve relationships, ordering,
    and uniqueness. Understanding their characteristics and use cases is the first
    step in leveraging their full potential.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，有序关联容器，由于其严格的顺序和唯一（有时不是那么唯一）的元素，为C++开发者提供了强大的工具。它们专为涉及关系、排序和唯一性的场景量身定制。理解它们的特性和用例是充分发挥其潜力的第一步。
- en: 'This chapter provides a reference for the following containers:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了以下容器的参考：
- en: '`std::set`'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::set`'
- en: '`std::map`'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::map`'
- en: '`std::multiset`'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::multiset`'
- en: '`std::multimap`'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::multimap`'
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code in this chapter can be found on GitHub:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
- en: std::set
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: std::set
- en: At its heart, a `std::set` container is a collection of unique elements where
    each element follows a strict order. You can think of it as a club where each
    member is distinct and all have a particular rank. The container ensures that
    no two elements are the same, making it exceptionally useful in situations where
    duplicates are not desired.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，`std::set`容器是一个包含唯一元素的集合，其中每个元素都遵循严格的顺序。你可以将其想象为一个俱乐部，每个成员都是独特的，并且都有特定的等级。该容器确保没有两个元素是相同的，这使得它在不需要重复元素的情况下非常有用。
- en: Purpose and suitability
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目的和适用性
- en: '`std::set` is an associative container designed to store a sorted set of unique
    objects of type `Key`. Its strengths are as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::set`是一个关联容器，旨在存储类型为`Key`的有序唯一对象集合。其优势如下：'
- en: Ensuring all elements are unique
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保所有元素都是唯一的
- en: Automatically sorting elements as they are inserted
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在插入元素时自动排序
- en: 'It is particularly suitable in the following scenarios:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 它特别适合以下场景：
- en: When duplicate elements are not desired
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当不希望有重复元素时
- en: When the ordering of elements matters
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当元素的排序很重要时
- en: When frequent lookups and insertions are anticipated
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当预期会有频繁的查找和插入操作时
- en: Ideal use cases
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理想用例
- en: 'The following are some ideal use cases of `std::set`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些`std::set`的理想用例：
- en: '`std::set` naturally enforces this. For instance, it will be useful when collecting
    a list of unique student IDs or product codes.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::set`自然地强制执行这一点。例如，当收集唯一的学生ID列表或产品代码时，它将非常有用。'
- en: '`std::set` keeps its elements in a sorted order as per the comparison criteria.
    It’s beneficial when you require data to be inherently sorted, such as when maintaining
    a leaderboard where scores are continuously inserted but should always be in order.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::set`根据比较标准保持其元素排序。当需要数据天生排序时，这很有益，例如在维护一个排行榜，其中分数会持续插入，但始终应该是有序的。'
- en: '`std::set` offers logarithmic time complexity for lookups. This makes it apt
    for scenarios where frequent membership checks are necessary – for instance, checking
    if a particular user is part of a VIP list.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::set`提供了对查找操作的对数时间复杂度。这使得它在需要频繁成员检查的场景中非常适用——例如，检查特定用户是否是VIP名单的一部分。'
- en: '`std::set` can be invaluable. It’s particularly useful in situations where
    you might want to find common elements between two collections or determine which
    elements are exclusive to one set.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::set` 在某些情况下非常有价值。它特别适用于你可能想要在两个集合之间找到共同元素或确定哪些元素仅属于一个集合的情况。'
- en: '`std::set` container can be used to keep track of these times. Given its ordered
    nature, you can swiftly determine the next event or if a particular time slot
    is already booked.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::set` 容器可以用来跟踪这些时间。由于其有序性，你可以迅速确定下一个事件或特定时间段是否已被预订。'
- en: It’s worth noting that while `std::set` is adept at these tasks, it is crucial
    to evaluate the specific requirements of the problem at hand. If ordering is not
    essential and you primarily need quick insertions, deletions, and lookups without
    regard for order, `std::unordered_set` might be a more suitable choice.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，虽然 `std::set` 在这些任务上很擅长，但评估手头问题的具体要求至关重要。如果排序不是必需的，并且你主要需要快速插入、删除和查找而不考虑顺序，`std::unordered_set`
    可能是一个更好的选择。
- en: Performance
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能
- en: 'The algorithmic performance of `std::set` is characterized as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::set` 的算法性能如下：'
- en: '**Insertion**: Typically *O(log n)* due to the balanced binary search tree
    structure'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插入**：通常为 *O(log n)*，因为平衡二叉搜索树结构'
- en: '**Deletion**: *O(log n)* for individual elements'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除**：单个元素为 *O(log n)*'
- en: '**Access (finding elements)**: *O(log n)*'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问（查找元素）**：*O(log n)*'
- en: '`std::vector` due to the tree structure'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::vector` 由于树结构'
- en: Memory management
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存管理
- en: Internally, `std::set` uses a tree structure, typically a balanced binary search
    tree. Memory allocation can be influenced using custom allocators.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，`std::set` 使用树结构，通常是平衡二叉搜索树。可以通过自定义分配器来影响内存分配。
- en: Thread safety
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程安全
- en: Similar to `std::vector`, concurrent reads are safe, but modifications or a
    combination of reads and modifications necessitate external synchronization.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `std::vector` 类似，并发读取是安全的，但修改或读取和修改的组合需要外部同步。
- en: Extensions and variants
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展和变体
- en: The C++ `std::multiset` (which allows repeated elements) and `std::unordered_set`
    (a hash table, providing average *O(1)* insert/find at the cost of no ordering).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 的 `std::multiset`（允许重复元素）和 `std::unordered_set`（一个哈希表，以牺牲无序为代价，提供平均 *O(1)*
    插入/查找）。
- en: Sorting and searching complexity
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序和搜索复杂度
- en: 'The sorting and search complexity is characterized as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 排序和搜索的复杂度如下：
- en: '**Sorting**: Elements are automatically sorted upon insertion'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**排序**：元素在插入时自动排序'
- en: '`find` member function'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find` 成员函数'
- en: Special interface and member functions
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊接口和成员函数
- en: 'Some handy member functions to note are as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一些值得注意的成员函数如下：
- en: '`emplace`: Insert elements in place'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`emplace`：就地插入元素'
- en: '`count`: Return the number of elements (always 0 or 1 in a set)'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count`：返回元素数量（在集合中始终为 0 或 1）'
- en: '`lower_bound` and `upper_bound`: Provide bounds for a specific key'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lower_bound` 和 `upper_bound`：为特定键提供边界'
- en: Comparisons
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较操作
- en: In contrast to `std::vector`, `std::set` excels in ensuring uniqueness and maintaining
    order but may not be optimal for frequent random access or if order isn’t a concern.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `std::vector` 相比，`std::set` 在确保唯一性和保持顺序方面表现出色，但可能不是频繁随机访问或顺序不是关注点时的最佳选择。
- en: Interactions with algorithms
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与算法的交互
- en: Given its bidirectional iterators, many STL algorithms are compatible with `std::set`.
    However, algorithms requiring random access might not be ideal.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其双向迭代器，许多 STL 算法与 `std::set` 兼容。然而，需要随机访问的算法可能不太理想。
- en: Exceptions
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常
- en: No exceptions are thrown due to capacity issues since `std::set` does not have
    a fixed capacity. Exceptions can arise from allocators during memory allocation.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `std::set` 没有固定容量，因此不会因为容量问题而抛出异常。异常可能来自分配器在内存分配期间。
- en: Customization
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义
- en: '`std::set` allows custom allocators for memory management. You can also provide
    a custom comparator to define how a set’s elements are ordered.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::set` 允许自定义分配器进行内存管理。你还可以提供一个自定义比较器来定义集合元素的排序方式。'
- en: Example
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例
- en: '`std::set` is a sorted associative container that contains unique elements.
    It is typically used to represent a collection where the existence of an element
    is more important than the number of times it appears. The following code is an
    example illustrating best practices when using `std::set`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::set` 是一个有序关联容器，包含唯一元素。它通常用于表示一个集合，其中元素的存在比其出现的次数更重要。以下代码是一个示例，说明了使用 `std::set`
    时的最佳实践：'
- en: '[PRE0]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here is the example output:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是示例输出：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this example, we did the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们做了以下操作：
- en: We demonstrated basic `std::set` operations such as insertion, finding an element,
    and erasing.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们展示了基本的`std::set`操作，如插入、查找元素和删除。
- en: We showcased how a set inherently sorts its elements and how to iterate over
    them.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们展示了集合如何固有地排序其元素以及如何遍历它们。
- en: The use of the `merge` function was illustrated to merge another set into our
    primary set.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`merge`函数的示例是为了将另一个集合合并到我们的主集合中。
- en: The `count` method was used to check for the existence of an element in a set,
    which can only be 0 or 1 due to the uniqueness constraint.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`count`方法检查集合中是否存在元素，由于唯一性约束，这只能为0或1。
- en: Lastly, we used a custom comparator to create a case-insensitive set of strings.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们使用自定义比较器创建了一个不区分大小写的字符串集合。
- en: Best practices
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最佳实践
- en: 'Let us explore the best practices of using `std::set`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨使用`std::set`的最佳实践：
- en: '`std::set`, access time is not constant as in `std::vector` or `std::array`.
    Due to its tree-based structure, element retrieval typically takes logarithmic
    time. When designing algorithms, factor this in.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::set`，访问时间不是恒定的，如`std::vector`或`std::array`。由于其基于树的结构，元素检索通常需要对数时间。在设计算法时，要考虑这一点。'
- en: '`std::set` container, it is immutable. Altering it directly via an iterator
    could breach the set’s internal ordering. If modification is imperative, erase
    the old element and insert its updated version.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::set`容器是不可变的。直接通过迭代器修改它可能会破坏集合的内部顺序。如果必须修改，请删除旧元素并插入其更新版本。'
- en: '`std::unordered_set`. Thanks to its hash-based design, it frequently trumps
    `std::set` in performance metrics, barring worst-case scenarios.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_set`。由于其基于哈希的设计，它通常在性能指标上优于`std::set`，除非是极端情况。'
- en: '`emplace` to create elements right within a set. This technique forestalls
    unnecessary object copying or movement.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`emplace`在集合中直接创建元素。这项技术防止了不必要的对象复制或移动。
- en: '**Navigate element alterations**: Direct tinkering of set elements is a no-go.
    The best approach when you need a modification is a two-step process: remove the
    original and introduce its altered counterpart.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导航元素修改**：直接修改集合元素是不可行的。当你需要修改时，最佳方法是两步过程：移除原始元素并引入其修改后的副本。'
- en: '`find` method is your go-to for determining if an element resides in a set.
    It’s more succinct and expressive than `count` in the context of `std::set`, given
    a set’s unique element nature.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find`方法是确定元素是否存在于集合中的首选方法。在`std::set`的上下文中，它比`count`方法更简洁、更易于表达，因为集合具有唯一元素的性质。'
- en: '`std::is_sorted`.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::is_sorted`。'
- en: '`std::set` is not intrinsically thread-safe. If concurrent access by multiple
    threads is anticipated, guard the set with synchronization primitives such as
    `std::mutex` or consider using concurrent containers provided by certain C++ libraries.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::set`本身不是线程安全的。如果预计会有多个线程并发访问，请使用同步原语（如`std::mutex`）保护集合，或者考虑使用某些C++库提供的并发容器。'
- en: '`std::set` container, remember that the elements are sorted. This can often
    obviate the need for additional sorting operations that you might apply on other
    containers.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用`std::set`容器时，请记住元素是排序的。这通常可以免除在其他容器上可能应用的其他排序操作。
- en: '`std::vector`, `std::set` doesn’t support `reserve` or `capacity` operations.
    The tree grows as elements are added. For efficiency, when removing elements,
    consider occasional `shrink_to_fit` operations available in some implementations.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::vector`，`std::set`不支持`reserve`或`capacity`操作。树随着元素的添加而增长。为了效率，在删除元素时，考虑偶尔使用某些实现中可用的`shrink_to_fit`操作。'
- en: std::map
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: std::map
- en: A sibling to the `std::set` container, `std::map` is about relationships. It
    connects unique keys to specific values, forming a pair. In layman’s terms, imagine
    a dictionary where each word (key) has a unique definition (value).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::map`容器是`std::set`的兄弟，它关乎关系。它将唯一的键连接到特定的值，形成一个对。用通俗易懂的话来说，想象一个字典，每个词（键）都有一个唯一的定义（值）。'
- en: Purpose and suitability
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目的和适用性
- en: '`std::map` is an ordered associative container that stores key-value pairs,
    ensuring unique keys. Its underlying data structure is typically a balanced binary
    tree (such as a **red-black tree** (**RBT**)). The main advantages include the
    following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::map`是一个有序关联容器，存储键值对，确保键的唯一性。其底层数据结构通常是平衡二叉树（如**红黑树**（**RBT**））。主要优点包括以下内容：'
- en: Logarithmic access, insertion, and deletion times
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对数访问、插入和删除时间
- en: Maintaining key-value pairs in sorted order by keys
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过键对键值对进行排序维护
- en: 'Use `std::map` in the following scenarios:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下场景中使用`std::map`：
- en: When you need to associate values with unique keys
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你需要将值与唯一键关联时
- en: When maintaining the order of keys is important
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当维护键的顺序很重要时
- en: When frequent access, insertion, or deletion operations are required, and they
    need to be efficient
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当需要频繁地进行访问、插入或删除操作，并且它们需要高效时
- en: Ideal use cases
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理想用例
- en: 'The following are some ideal use cases of `std::map`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些`std::map`的理想用例：
- en: '`std::map` shines when associating unique keys with specific values. For example,
    it is useful when mapping a person’s name (unique key) to their contact details
    or a word to its definition.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::map`在将唯一键与特定值关联时表现出色。例如，当将一个人的姓名（唯一键）映射到其联系详情或一个单词映射到其定义时，它非常有用。'
- en: '`std::map` container can associate different configuration keys with their
    respective values, ensuring easy retrieval and modification of settings.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::map`容器可以将不同的配置键与其相应的值关联起来，确保轻松检索和修改设置。'
- en: '**Student record system**: Educational institutions might maintain a record
    system where student IDs (ensured to be unique) act as keys, mapping to comprehensive
    student profiles comprising names, courses, grades, and other details.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**学生记录系统**：教育机构可能维护一个记录系统，其中学生ID（保证唯一）作为键，映射到包含姓名、课程、成绩和其他详细信息的全面学生档案。'
- en: '`std::map` can associate distinct items with their occurrence counts, ensuring
    efficient updates and retrievals.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::map`可以将不同的项目与其出现次数关联起来，确保高效的更新和检索。'
- en: '`std::map` container for this purpose ensures that terms are sorted and can
    be efficiently accessed or updated.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于此目的的`std::map`容器确保术语按顺序排列，并且可以高效地访问或更新。
- en: '`std::map` can serve as a cache, mapping input values to their computed results.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::map`可以作为缓存，将输入值映射到其计算结果。'
- en: '`std::map` inherently maintains its elements in sorted order based on its keys,
    it is apt for scenarios where operations dependent on this order are frequent
    – for example, fetching the *top 10* or *lowest 5* based on some criteria.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::map`根据其键的顺序维护其元素，适用于频繁依赖此顺序的操作的场景——例如，根据某些标准获取 *top 10* 或 *lowest 5*。'
- en: Always consider the specific needs of your problem. While `std::map` offers
    ordering and unique key-value association, if ordering isn’t required, `std::unordered_map`
    might be a more performance-efficient alternative due to its average constant-time
    complexity for most operations.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 总是考虑你问题的具体需求。虽然`std::map`提供了排序和唯一键值关联，但如果不需要排序，`std::unordered_map`可能是一个更高效的替代方案，因为它的大多数操作的平均时间复杂度为常数时间。
- en: Performance
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能
- en: 'The algorithmic performance of `std::map` is characterized as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::map`的算法性能如下：'
- en: '**Insertion**: *O(log n)*'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插入**：*O(log n)*'
- en: '**Deletion**: *O(log n)*'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除**：*O(log n)*'
- en: '**Access**: *O(log n)* to locate a key'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问**：*O(log n)* 定位键'
- en: '**Memory overhead**: Generally higher than hash-based counterparts due to tree-based
    structure'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存开销**：通常高于基于哈希的对应物，因为基于树的结构'
- en: The primary trade-off is balancing memory overhead with the efficiency of ordered
    operations and the flexibility of key-value pair manipulation.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的权衡是在内存开销与有序操作的效率和键值对操作的灵活性之间取得平衡。
- en: Memory management
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存管理
- en: '`std::map` efficiently manages its memory internally, ensuring balanced trees.
    However, specific behavior can be influenced by custom allocators, allowing for
    more control.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::map`有效地管理其内部内存，确保平衡树。然而，具体行为可能受到自定义分配器的影响，从而允许更多的控制。'
- en: Thread safety
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程安全
- en: Concurrent reads are safe. However, concurrent writes or mixed read-writes require
    external synchronization, such as utilizing mutexes.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 并发读取是安全的。然而，并发写入或混合读写需要外部同步，例如使用互斥锁。
- en: Extensions and variants
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展和变体
- en: '`std::multimap` allows multiple values per key, whereas `std::unordered_map`
    offers a hash-table-based alternative without ordering but with potential *O(1)*
    average access times.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::multimap`允许每个键有多个值，而`std::unordered_map`提供了一个基于哈希表的替代方案，没有排序，但具有潜在的 *O(1)*
    平均访问时间。'
- en: Sorting and searching complexity
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序和搜索复杂度
- en: 'The sorting and search complexity is characterized as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 排序和搜索复杂度如下：
- en: '`std::map` inherently maintains sorting'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::map`本身维护排序'
- en: '**Searching**: *O(log n)*'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**搜索**：*O(log n)*'
- en: Special interface and member functions
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊接口和成员函数
- en: 'Some handy member functions to note are as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些值得注意的成员函数：
- en: '`emplace`: Directly constructs a key-value pair in place'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`emplace`：直接在原地构建键值对'
- en: '`at`: Throws an exception if the key doesn’t exist'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`at`：如果键不存在，则抛出异常'
- en: '`operator[]`: Accesses or creates a value for a given key'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`operator[]`：访问或为给定键创建一个值'
- en: '`lower_bound` and `upper_bound`: Provide iterators pointing to positions relative
    to a key'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lower_bound` 和 `upper_bound`：提供指向相对于键位置的迭代器'
- en: Comparisons
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较操作
- en: Compared to `std::unordered_map`, `std::map` excels in scenarios where key order
    matters or when the dataset might grow and shrink frequently. For situations demanding
    raw performance and where the order is insignificant, `std::unordered_map` might
    be preferable.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `std::unordered_map` 相比，`std::map` 在键顺序重要或数据集可能频繁增减的场景中表现更佳。对于需要原始性能且顺序不重要的场景，`std::unordered_map`
    可能更可取。
- en: Interactions with algorithms
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与算法的交互
- en: While many STL algorithms can work with `std::map`, its bidirectional iterators
    limit its compatibility with algorithms requiring random access.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管许多 STL 算法可以与 `std::map` 一起工作，但其双向迭代器限制了它与需要随机访问的算法的兼容性。
- en: Exceptions
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常
- en: Operations such as `at()` can throw out-of-range exceptions. Most operations
    on `std::map` provide strong exception safety, ensuring the map remains unchanged
    if an exception is thrown.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 操作如 `at()` 可能会抛出越界异常。大多数对 `std::map` 的操作都提供了强异常安全性，确保在抛出异常时映射保持不变。
- en: Customization
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义
- en: You can provide custom comparators to dictate the order of keys or use custom
    allocators to influence memory management.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以提供自定义比较器来指定键的顺序，或使用自定义分配器来影响内存管理。
- en: Example
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例
- en: 'In `std::map`, keys are sorted and unique, making it easy to find specific
    entries. The following code is an example illustrating best practices when using
    `std::map`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `std::map` 中，键是有序且唯一的，这使得查找特定条目变得容易。以下代码是使用 `std::map` 的最佳实践的示例：
- en: '[PRE2]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here is the example output:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例输出：
- en: '[PRE3]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this example, we did the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们做了以下操作：
- en: We demonstrated the basic operations of `std::map`, such as insertion, modification,
    checking for the existence of a key, and iterating over its elements.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们展示了 `std::map` 的基本操作，例如插入、修改、检查键的存在以及遍历其元素。
- en: We used structured bindings (C++17) to restructure the key-value pairs when
    iterating.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用了结构化绑定（C++17）在迭代时重新结构化键值对。
- en: We illustrated the use of `count` to check if a key exists in the map.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们展示了如何使用 `count` 来检查键是否存在于映射中。
- en: We created a custom-ordered map by providing a custom comparator that sorts
    the keys in reverse lexicographical order.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过提供一个自定义比较器，该比较器按逆字典序对键进行排序，创建了一个自定义排序的映射。
- en: Best practices
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最佳实践
- en: 'Let us explore the best practices of using `std::map`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨使用 `std::map` 的最佳实践：
- en: '`std::map`, the key remains constant for the lifetime of that element. Modifying
    it directly is not allowed. Should you need to update the key, the correct approach
    is to remove the old key-value pair and insert a new one with the desired key.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::map` 中，键在其元素的生命周期内保持不变。直接修改是不允许的。如果您需要更新键，正确的方法是删除旧的键值对，并插入一个新的具有所需键的键值对。'
- en: '`std::unordered_map`. Its hash table-based implementation may offer faster
    average-time complexities for many operations compared to the RBT of `std::map`,
    reducing potential overhead.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unordered_map`。其基于哈希表的实现可能比 `std::map` 的红黑树提供许多操作的更快平均时间复杂度，从而减少了潜在的开销。'
- en: '`emplace` method, which constructs the element in place within the map, avoiding
    temporary object creation and unnecessary copies. When paired with tools such
    as `std::make_pair` or `std::piecewise_construct`, it optimizes performance for
    insertions.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`emplace` 方法，在映射中就地构造元素，避免创建临时对象和不必要的复制。当与 `std::make_pair` 或 `std::piecewise_construct`
    等工具配合使用时，它优化了插入的性能。'
- en: '`operator[]` method, though convenient, can be a double-edged sword. If the
    specified key does not exist, it inserts the key with a default-initialized value
    into the map. When you wish to only query, without potential insertions, use the
    `find` method instead. The `find` method returns an iterator to the element if
    found and to the `end()` method if not.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`operator[]` 方法，虽然方便，但可能是一把双刃剑。如果指定的键不存在，它将在映射中插入一个具有默认初始化值的键。当您只想查询，而不希望有潜在的插入时，请使用
    `find` 方法。如果找到，`find` 方法返回指向元素的迭代器；如果没有找到，则返回 `end()` 方法。'
- en: '`std::map` might not always fit the use case. You can customize the order by
    providing a comparator when defining the map. Ensure this comparator enforces
    a strict weak ordering to maintain the integrity of the map’s internal structures.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::map` 可能并不总是适合使用场景。您可以在定义映射时提供一个比较器来自定义顺序。确保此比较器执行严格的弱排序，以保持映射内部结构的完整性。'
- en: '`std::map` container, synchronization becomes imperative. Consider using `std::mutex`
    or other STL synchronization primitives to lock access during write operations,
    preserving data consistency.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::map` 容器，同步变得至关重要。考虑使用 `std::mutex` 或其他 STL 同步原语在写入操作期间锁定访问，以保持数据一致性。'
- en: '`count` method for a direct count result. For a map, this will always return
    `0` or `1`, making it a fast way to check membership.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count` 方法可以直接得到计数结果。对于映射，这总是返回 `0` 或 `1`，这使得检查成员资格成为一种快速方式。'
- en: '`erase` operation invalidates the iterator. Use the returned iterator from
    `erase` to continue operations safely.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`erase` 操作使迭代器无效。使用 `erase` 返回的迭代器继续安全操作。'
- en: '`std::map` offers range methods such as `equal_range`, which can return the
    bounds of a subrange of elements with keys equivalent to a given key. Utilize
    them for efficient subrange manipulations.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::map` 提供了范围方法，如 `equal_range`，它可以返回与给定键等效的元素子范围的上界和下界。利用它们进行高效的子范围操作。'
- en: '`std::map` supports custom allocators. This allows for better control over
    allocation and deallocation processes.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::map` 支持自定义分配器。这允许更好地控制分配和释放过程。'
- en: std::multiset
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: std::multiset
- en: While a `std::set` container prides itself on its exclusivity, `std::multiset`
    is a bit more accommodating. It still maintains order, but it allows multiple
    elements to have the same value. This container is like a club where members have
    ranks, but there’s room for more than one member at each rank.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `std::set` 容器以其独特性而自豪，但 `std::multiset` 则更为宽容。它仍然保持顺序，但允许多个元素具有相同的值。这个容器就像一个俱乐部，成员有等级，但每个等级都有空间容纳多个成员。
- en: Purpose and suitability
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目的和适用性
- en: '`std::multiset` is an associative container that stores sorted elements and
    allows multiple occurrences of an element. Its key strengths are as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::multiset` 是一个关联容器，存储排序元素并允许元素有多个出现。其关键优势如下：'
- en: Maintaining a sorted order of elements
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护元素的排序顺序
- en: Allowing duplicates
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许重复
- en: Offering logarithmic time complexity for insertion, deletion, and search
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供插入、删除和搜索的对数时间复杂度
- en: 'It’s particularly suitable in the following scenarios:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 它特别适合以下场景：
- en: When duplicate values need to be retained
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当需要保留重复值时
- en: When you require elements to always remain sorted
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你需要元素始终保持排序
- en: When random access is not a necessity
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当不需要随机访问时
- en: Ideal use cases
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理想用例
- en: 'The following are some ideal use cases for `std::multiset`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些 `std::multiset` 的理想用例：
- en: '`std::multiset` container is beneficial. It allows for the storage of duplicate
    values while maintaining them in a sorted order.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::multiset` 容器有益。它允许存储重复值，同时保持它们的排序顺序。'
- en: '`std::multiset` container is invaluable due to its inherent sorted nature and
    its ability to accommodate repeated numbers.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于其固有的排序特性和容纳重复数字的能力，`std::multiset` 容器非常宝贵。
- en: '`std::multiset` container can help in efficiently managing and tracking these
    selections, especially when a popular session is chosen multiple times.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::multiset` 容器可以帮助高效地管理和跟踪这些选择，尤其是在一个热门会话被多次选择时。'
- en: '`std::multiset` container can represent such items, allowing easy tracking
    and replenishment based on demand.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::multiset` 容器可以表示此类项目，允许根据需求轻松跟踪和补充。'
- en: '`std::map`) maps terms to documents, a `std::multiset` container can be used
    to keep track of how frequently terms appear across multiple documents, even if
    some terms are common and appear repeatedly.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::map`) 将术语映射到文档，一个 `std::multiset` 容器可以用来跟踪术语在多个文档中出现的频率，即使某些术语很常见且重复出现。'
- en: '`std::multiset` to manage events or points efficiently, especially when multiple
    events share the same position.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::multiset` 来高效管理事件或点，尤其是在多个事件共享相同位置时。
- en: '`std::multiset` shines.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::multiset` 闪耀着光芒。'
- en: Remember, while `std::multiset` is designed to handle multiple instances of
    the same value in a sorted manner, if the sorted property isn’t essential and
    you want to keep track of multiple items, structures such as `std::unordered_multiset`
    can be more performance-efficient in some cases due to hash-based implementations.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，虽然 `std::multiset` 设计用于以排序方式处理相同值的多个实例，但如果排序属性不是必需的，并且你想跟踪多个项目，由于基于哈希的实现，结构如
    `std::unordered_multiset` 在某些情况下可能更高效。
- en: Performance
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能
- en: 'The algorithmic performance of `std::multiset` is characterized as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::multiset` 的算法性能如下：'
- en: '**Insertion**: *O(log n)*'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插入**：*O(log n)*'
- en: '**Deletion**: *O(log n)*'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除**：*O(log n)*'
- en: '**Access**: Elements are accessed in *O(log* *n)* time'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问**：元素以*O(log* *n)*的时间复杂度访问'
- en: '**Memory overhead**: Overhead is present due to internal balancing (typically
    implemented as a balanced binary search tree)'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存开销**：由于内部平衡（通常实现为平衡二叉搜索树），存在开销'
- en: Memory management
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存管理
- en: '`std::multiset` does not dynamically resize like `std::vector`. Instead, it
    uses dynamic memory allocation for nodes as elements are inserted. Allocators
    can influence node memory management.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::multiset`不像`std::vector`那样动态调整大小。相反，它在插入元素时使用动态内存分配来管理节点。分配器可以影响节点内存管理。'
- en: Thread safety
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程安全
- en: Concurrent reads are safe. However, modifications (insertions or deletions)
    require external synchronization. Utilizing mutexes or other synchronization primitives
    is recommended for concurrent writes.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 并发读取是安全的。然而，修改（插入或删除）需要外部同步。建议使用互斥锁或其他同步原语进行并发写入。
- en: Extensions and variants
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展和变体
- en: '`std::set` is a direct variant that disallows duplicates. There’s also `std::unordered_multiset`,
    which offers average constant-time complexity for operations but does not maintain
    order.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::set`是一个不允许重复的直接变体。还有`std::unordered_multiset`，它为操作提供平均常数时间复杂度，但不保持顺序。'
- en: Sorting and searching complexity
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序和搜索复杂度
- en: 'The sorting and search complexity is characterized as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 排序和搜索复杂度如下描述：
- en: '**Sorting**: Elements are always sorted; thus, no sort operation is required'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**排序**：元素始终排序；因此，不需要排序操作'
- en: '**Searching**: *O(log n)* due to its tree-based nature'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**搜索**：由于其基于树的本质，*O(log n)*'
- en: Special interface and member functions
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊接口和成员函数
- en: 'While it provides regular functions (`insert`, `erase`, `find`), some handy
    ones include the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它提供了常规函数（`insert`、`erase`、`find`），但以下是一些实用的函数：
- en: '`count`: Returns the total number of elements matching a specified key'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count`：返回与指定键匹配的总元素数'
- en: '`equal_range`: Provides range (iterators) of all instances of an element'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`equal_range`：提供元素所有实例的范围（迭代器）'
- en: Comparisons
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较操作
- en: Against `std::set`, `std::multiset` allows duplicates but at the cost of slightly
    increased memory. Against sequence containers such as `std::vector`, it maintains
    sorted order but doesn’t offer constant-time access.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 与`std::set`相比，`std::multiset`允许重复，但代价是略微增加的内存。与如`std::vector`之类的序列容器相比，它保持排序顺序，但不提供常数时间访问。
- en: Interactions with algorithms
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与算法的交互
- en: Algorithms that benefit from sorted data (such as binary searches or set operations)
    work well with `std::multiset`. Those requiring random access or frequent reordering
    might not be suitable.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 从排序数据中受益的算法（如二分搜索或集合操作）与`std::multiset`配合良好。那些需要随机访问或频繁重新排序的算法可能不合适。
- en: Exceptions
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常
- en: Memory allocation failures can throw exceptions. Most `std::multiset` operations
    provide strong exception-safety guarantees.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 内存分配失败可能会抛出异常。大多数`std::multiset`操作提供强大的异常安全性保证。
- en: Customization
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定制化
- en: 'In `std::multiset`, customization entails the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在`std::multiset`中，定制包括以下内容：
- en: Custom allocators can be used to control memory allocation.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用自定义分配器来控制内存分配。
- en: Custom comparators can be provided to dictate the order of element storage.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以提供自定义比较器来指定元素存储的顺序。
- en: Example
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例
- en: '`std::multiset` is a container that can store multiple keys, including duplicate
    keys. The keys are always sorted from the lowest key to the highest. `std::multiset`
    is typically used in situations where you need to maintain a sorted set of elements,
    and duplicates are allowed.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::multiset`是一个可以存储多个键的容器，包括重复键。键始终按从低到高的顺序排序。`std::multiset`通常用于需要维护排序元素集且允许重复项的情况。'
- en: 'The following code is an example of using `std::multiset`, demonstrating some
    of its unique features and best practices:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是使用`std::multiset`的示例，展示了其一些独特特性和最佳实践：
- en: '[PRE4]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here is the example output:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是示例输出：
- en: '[PRE5]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Key takeaways from the preceding example are as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的示例中可以得出以下关键要点：
- en: '`std::multiset` automatically sorts keys.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::multiset`自动排序键。'
- en: It can store duplicate keys, and this property can be utilized for certain algorithms
    or storage patterns where duplicates are meaningful.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以存储重复键，并且可以利用此属性进行某些算法或存储模式，其中重复项是有意义的。
- en: Using `equal_range` is a best practice to find all instances of a key. This
    method returns both the beginning and the end iterators, covering all instances
    of the key.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`equal_range`是查找键所有实例的最佳实践。此方法返回开始和结束迭代器，覆盖所有键的实例。
- en: Custom comparators, such as `std::greater<>`, can be used to reverse the default
    ordering.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用自定义比较器，如`std::greater<>`，来反转默认排序。
- en: '`lower_bound` and `upper_bound` can be used for efficient range queries.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用`lower_bound`和`upper_bound`进行高效的范围查询。
- en: Remember, if you don’t need to store duplicates, then `std::set` is a more appropriate
    choice.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，如果你不需要存储重复项，那么`std::set`是一个更合适的选择。
- en: Best practices
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最佳实践
- en: 'Let us explore the best practices of using `std::multiset`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨使用`std::multiset`的最佳实践：
- en: '`std::multiset` to prevent undue overhead. Instead, favor `std::set`, which
    inherently manages unique elements and can be more efficient.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::multiset`来防止不必要的开销。相反，优先考虑`std::set`，它本质上管理唯一元素，可能更高效。
- en: '`std::multiset` doesn’t offer the same constant-time access that `std::vector`
    provides. Accessing elements is logarithmic in complexity due to the underlying
    tree-based data structure.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::multiset`不提供`std::vector`提供的相同时间复杂度的常数时间访问。由于底层基于树的数据结构，访问元素是对数复杂度。'
- en: '`std::multiset` to hold duplicate elements can lead to elevated memory usage,
    especially when those duplicates are numerous. It’s crucial to analyze memory
    requirements and ensure the container’s suitability for the application.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::multiset`来存储重复元素可能导致内存使用增加，尤其是当这些重复项很多时。分析内存需求并确保容器适用于应用程序至关重要。
- en: '`std::multiset`, ensure that it imposes a strict weak ordering. Any inconsistency
    in ordering can lead to undefined behavior. Test the comparator rigorously to
    confirm its reliability.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::multiset`，确保它施加严格的弱排序。任何排序不一致都可能引起未定义的行为。严格测试比较器以确认其可靠性。'
- en: '`find` and `count` member functions. They offer a more efficient and direct
    way to perform such checks.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find`和`count`成员函数。它们提供了更高效和直接的方式来执行此类检查。'
- en: '`std::multiset`, clearly outline the reasons for needing duplicate entries.
    If the rationale isn’t strong, or duplicates don’t benefit your application logic
    significantly, consider using `std::set`.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::multiset`，明确说明需要重复条目的原因。如果理由不强，或者重复项对应用程序逻辑的益处不大，考虑使用`std::set`。'
- en: std::multimap
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`std::multimap`'
- en: Extending the principles of `std::map`, the `std::multimap` container allows
    for one key to be associated with multiple values. It’s like a dictionary where
    a word might have several related definitions.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展`std::map`的原则，`std::multimap`容器允许一个键与多个值关联。它就像一个字典，一个词可能有几个相关定义。
- en: Purpose and suitability
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目的和适用性
- en: '`std::multimap` is an associative container within the STL. Its distinguishing
    features are as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::multimap`是STL中的一个关联容器。其显著特点如下：'
- en: Storing key-value pairs
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储键值对
- en: Allowing multiple values with the same key
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许具有相同键的多个值
- en: Storing elements in a sorted manner, as determined by the key
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按键排序存储元素
- en: 'It’s particularly suitable in the following scenarios:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 它特别适合以下场景：
- en: When you need to maintain a collection with non-unique keys
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你需要维护一个具有非唯一键的集合时
- en: When you want sorted access based on keys
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你需要基于键的排序访问时
- en: When key-value mapping is paramount
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当键值映射至关重要时
- en: Choose `std::multimap` when you expect multiple values under the same key. If
    unique keys are necessary, you might want to look into `std::map`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当你预期在同一个键下有多个值时，选择`std::multimap`。如果需要唯一键，你可能需要考虑`std::map`。
- en: Ideal use cases
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理想使用场景
- en: 'The following are some ideal use cases of `std::multimap`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些`std::multimap`的理想使用场景：
- en: '`std::multimap`, you can associate one key with several values.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`std::multimap`中，你可以将一个键与多个值关联起来。
- en: '`std::multimap` container can effectively map these multiple meanings.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::multimap`容器可以有效地映射这些多个含义。'
- en: '`std::multimap` container can associate a destination (key) with various flight
    details or times (values).'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::multimap`容器可以将目的地（键）与各种航班详情或时间（值）关联起来。'
- en: '`std::multimap`, one can easily keep track of all events for a specific date.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::multimap`，你可以轻松跟踪特定日期的所有事件。
- en: '`std::multimap` can be handy, especially when weights or other data associated
    with the edges are required.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::multimap`在需要权重或其他与边关联的数据时尤其有用。'
- en: '`std::multimap` container.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::multimap`容器。'
- en: '`std::multimap` container is apt for such use cases.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::multimap`容器适用于此类用例。'
- en: '`std::multimap` helps in organizing and retrieving media based on tags efficiently.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::multimap`有助于根据标签有效地组织和检索媒体。'
- en: Remember that `std::multimap` is a go-to when one-to-many relationships are
    prevalent. However, if order and sorting aren’t crucial and efficient retrieval
    is more important, considering structures such as `std::unordered_multimap` can
    be beneficial due to their hash-based nature.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当一对多关系普遍存在时，`std::multimap` 是一个不错的选择。然而，如果顺序和排序不是关键，且高效检索更重要，考虑到基于哈希的结构，如
    `std::unordered_multimap`，可能会有所帮助。
- en: Performance
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能
- en: 'The algorithmic performance of std::multimap is characterized as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::multimap` 的算法性能如下：'
- en: '**Insertion**: Logarithmic *O(log n)* in most cases'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插入**：在大多数情况下是**对数** *O(log n)*'
- en: '**Deletion**: Logarithmic *O(log* *n)* generally'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除**：通常情况下是**对数** *O(log n)*'
- en: '**Access**: *O(log n)* for specific keys'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问**：对于特定键是 *O(log n)*'
- en: '**Memory overhead**: It is a bit higher due to maintaining the tree-based structure
    and potential balancing'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存开销**：由于维护基于树的结构和潜在的平衡，它稍微高一点'
- en: Memory management
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存管理
- en: '`std::multimap` internally employs a tree structure, typically an RBT. Thus,
    memory allocation and balancing operations can occur. Allocators can influence
    its memory handling.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::multimap` 内部使用树结构，通常是红黑树（RBT）。因此，内存分配和平衡操作可能会发生。分配器可以影响其内存处理。'
- en: Thread safety
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程安全
- en: Multiple reads are safe. However, writes or combinations of reads and writes
    require external synchronization. Using tools such as mutexes is advisable.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 多次读取是安全的。然而，写入或读取和写入的组合需要外部同步。使用互斥锁等工具是可取的。
- en: Extensions and variants
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展和变体
- en: For hash-table-based key-value mapping, consider `std::unordered_multimap`.
    For unique key-value mapping, `std::map` is more appropriate.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于哈希表的键值映射，考虑 `std::unordered_multimap`。对于唯一键值映射，`std::map` 更为合适。
- en: Sorting and searching complexity
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序和搜索复杂度
- en: 'The sorting and search complexity is characterized as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 排序和搜索的复杂度如下：
- en: '**Sorting**: Sorting is inherent, as elements are maintained in key order'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**排序**：排序是固有的，因为元素是按键顺序维护的'
- en: '**Searching**: *O(log n)* to locate a specific key'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**搜索**：定位特定键是 *O(log n)*'
- en: Special interface and member functions
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊接口和成员函数
- en: 'Standard functions such as `insert`, `erase`, and `find` are available. The
    following are also available:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 标准函数，如 `insert`、`erase` 和 `find` 都是可用的。以下也是可用的：
- en: '`count`: Returns the number of elements with a particular key'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count`：返回具有特定键的元素数量'
- en: '`equal_range`: Retrieves the range of elements with a specific key'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`equal_range`：检索具有特定键的元素范围'
- en: Comparisons
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较操作
- en: Against `std::unordered_multimap`, `std::multimap` offers ordered access but
    might have a slightly higher overhead due to its tree-based nature.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `std::unordered_multimap` 相比，`std::multimap` 提供了有序访问，但由于其基于树的本质，可能会有稍微高的开销。
- en: Interactions with algorithms
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与算法的交互
- en: Since `std::multimap` maintains ordered access, algorithms that benefit from
    sorted data (such as `std::set_intersection`) can be useful. However, remember
    that data is key-ordered.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `std::multimap` 维护有序访问，从排序数据中受益的算法（如 `std::set_intersection`）可能很有用。然而，请记住数据是按键排序的。
- en: Exceptions
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常
- en: Trying to access non-existent keys or out-of-bound scenarios can throw exceptions.
    Most operations are strongly exception-safe, ensuring the container remains valid
    even if an exception is thrown.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试访问不存在的键或越界场景可能会抛出异常。大多数操作都是强异常安全的，确保即使在抛出异常的情况下容器仍然有效。
- en: Customization
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义
- en: Custom allocators can refine memory management. `std::multimap` also allows
    custom comparators to dictate the ordering of keys.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义分配器可以优化内存管理。`std::multimap` 还允许自定义比较器来指定键的排序。
- en: Example
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例
- en: '`std::multimap` is a container that maintains a collection of key-value pairs,
    where multiple pairs can have the same key. The keys in `std::multimap` are always
    sorted.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::multimap` 是一种容器，它维护一组键值对集合，其中多个键值对可以具有相同的键。`std::multimap` 中的键总是排序的。'
- en: 'The following code is an example of using `std::multimap`, demonstrating some
    of its unique features and best practices:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是使用 `std::multimap` 的示例，展示了它的一些独特特性和最佳实践：
- en: '[PRE6]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here is the example output:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是示例输出：
- en: '[PRE7]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Key takeaways from the preceding code are as follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中可以总结出以下要点：
- en: '`std::multimap` automatically sorts keys.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::multimap` 自动排序键。'
- en: It can store multiple key-value pairs with the same key.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以存储具有相同键的多个键值对。
- en: Using `equal_range` is a best practice to find all instances of a key. This
    method returns both the beginning and the end iterators, covering all instances
    of the key.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`equal_range`是查找键的所有实例的最佳实践。此方法返回开始和结束迭代器，覆盖所有键的实例。
- en: '`grades.count("John")` efficiently counts the number of key-value pairs with
    the specified key.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`grades.count("John")` 高效地统计了具有指定键的键值对数量。'
- en: Custom comparators, such as `std::greater<>`, can change the ordering from the
    default ascending order to descending.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义比较器，如`std::greater<>`，可以将排序从默认的升序更改为降序。
- en: A `std::multimap` container is useful when you need a dictionary-like data structure
    that supports duplicate keys. If duplicates aren’t needed, `std::map` would be
    a more appropriate choice.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要一个支持重复键的字典样式的数据结构时，`std::multimap` 容器非常有用。如果不需要重复键，那么`std::map` 将是一个更合适的选择。
- en: Best practices
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最佳实践
- en: 'Let us explore the best practices of using `std::multimap`:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索使用`std::multimap`的最佳实践：
- en: '`std::multimap`. The access complexity is logarithmic, attributed to its tree-based
    underpinning.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::multimap` 的访问复杂度是对数级的，这归因于其基于树的底层结构。'
- en: '`std::multimap` are unique, as in `std::map`. A `std::multimap` container permits
    multiple entries for a single key. If your application demands unique keys, then
    `std::map` is the appropriate choice.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::multimap` 与`std::map`一样是唯一的。`std::multimap` 容器允许单个键有多个条目。如果你的应用程序需要唯一的键，那么`std::map`是适当的选择。'
- en: '`std::multimap` is the inherent sorted nature of its elements based on the
    keys. Exploit this characteristic to your advantage, especially when performing
    operations that benefit from ordered data, such as range searches or ordered merges.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::multimap` 的元素基于键具有固有的排序特性。利用这一特性，尤其是在执行受益于有序数据的操作（如范围搜索或有序合并）时，可以发挥优势。'
- en: '`std::unordered_multimap` might be a more fitting alternative due to its hashing
    mechanism. However, it is worth noting that worst-case performance and memory
    overheads can differ.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于其哈希机制，`std::unordered_multimap` 可能是一个更合适的替代方案。然而，值得注意的是，最坏情况下的性能和内存开销可能会有所不同。
- en: '`find` or `count`. It helps prevent potential pitfalls and ensure robust code.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`find`或`count`。这有助于防止潜在的问题并确保代码的健壮性。
- en: '**Use custom comparators for tailored sorting**: Should you have a specific
    ordering requirement that deviates from the default, use custom comparators. Ensure
    that your comparator enforces a strict weak ordering to guarantee consistent and
    defined behavior of the multimap.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用自定义比较器进行定制排序**：如果您有与默认排序不同的特定排序要求，请使用自定义比较器。确保您的比较器强制执行严格的弱排序，以保证多映射的一致性和定义良好的行为。'
- en: '`equal_range` member function. It provides a range (beginning and end iterators)
    of all elements with a particular key, enabling efficient iteration over those
    specific elements.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`equal_range` 成员函数。它提供了一个特定键的所有元素的范围（开始和结束迭代器），使得对这些特定元素进行高效迭代成为可能。'
- en: '`std::multimap` can become inefficient with large datasets, especially if frequent
    insertions and deletions are commonplace. In such scenarios, evaluate the structure’s
    performance and consider alternatives or optimization strategies.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::multimap` 在处理大量数据集时可能会变得低效，尤其是当频繁的插入和删除是常见操作时。在这种情况下，评估结构的性能并考虑替代方案或优化策略是值得的。'
