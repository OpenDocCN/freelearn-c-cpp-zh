["```cpp\nauto main()->int{return<:]<class _>(_)->_<%return 7;}(1);%>\n```", "```cpp\n#define __(...)sizeof(int[]){0,\\\n                               ##__VA_ARGS__}/sizeof(int)-1\nauto main()->int{return<:]<class _>(_)->_<%return\n__(_(), _(), _(), _(), _(), _(), _()) ;}(__());%>\n```", "```cpp\n#define $$ sizeof\n#define $ return\n#define $_ int\n#define __(...)$$($_[]){0,##__VA_ARGS__}/$$($_)-1\nauto main()->$_<%$<::><class _>(_)->_<%$\n__(_(), _(), _(), _(), _(), _(), _()) ;%>(__());%>\n```", "```cpp\n#define return(...) main\n#define main(...) int\nmain(7)(return(7))(){\n    return 7;\n}\n```", "```cpp\n#ifndef MINK\n#define MINK\n#include __FILE__\nDD $$ sizeof\nDD $ return\nDD $_ int\nDD _$ _()\nDD __(_...)$$($_[]){0,##_}/$$($_)-1\nauto main()->$_<%$<::><class _>(_)->\n$_<%$ __(_$,_(),_$,_(),_$,_(),_$) ;%>(__());%>\n#endif\n#ifdef MINK\n#define CAT(x, y) CAT_I(x, y)\n#define CAT_I(x, y) x ## y\n#define HH CAT(%, :)\n#define DD HH define\n#endif\n```", "```cpp\nerror: stray '%:' in program\n   15 | #define HH CAT(%, :)\n```", "```cpp\nerror: \"#\" not expected here\n  DD $$ sizeof\n```", "```cpp\nerror C2121: '#': invalid character: possibly the result of a macro expansion\n```", "```cpp\nerror: expected unqualified-id\n    4 | DD $$ sizeof\n      | ^\n```", "```cpp\n%: define $$ sizeof\n%: define $ return\n%: define $_ int\n%: define _$ _()\n%: define __(_...)$$($_[]){0,##_}/$$($_)-1\nauto main()->$_<%$<::><class _>(_)->\n$_<%$ __(_$,_(),_$,_(),_$,_(),_$) ;%>(__());%>\n```", "```cpp\n#define CAT(x, y) CAT_I(x, y)\n#define CAT_I(x, y) x ## y\n```", "```cpp\ncl /P test.cpp & cl /Tp test.i\n```", "```cpp\nclang++ -E test.cpp | g++ -w -x c++ -std=c++20 -\n```", "```cpp\nint z;\nint main()\n{\n    int z1 = 0;\n    int z2(0);\n    int z3{0};\n    int z4 = {0};\n    int z5{};\n    int z6();\n}\n```", "```cpp\nstatic int y;\ndecltype(auto) number(int x) {\n    return y;\n}\ndecltype(auto) reference(int x) {\n    return (y);\n}\n```", "```cpp\nusing namespace std;\nif (is_reference<decltype(number(42))>::value) {\n    cout << \"Reference to \";\n    cout << typeid(typename \nremove_reference<decltype(number(42))>::type).name() << endl;\n} else {\n    cout << \"Not a reference: \" << typeid(decltype(number(42))).name() << endl;\n}\n```", "```cpp\nNot a reference: int\n```", "```cpp\nif (is_reference<decltype(reference(42))>::value) {\n    cout << \"Reference to: \";\n    cout << typeid(typename \nremove_reference<decltype(reference(42))>::type).name() << endl;\n} else {\n    cout << \"Not a reference: \" << typeid(decltype(number(42))).name() << endl;\n}\n```", "```cpp\nReference to: int\n```", "```cpp\nauto reference(int x) {\n    return (y);\n}\n```", "```cpp\ntemplate <typename T>\nvoid printType(T&& var) {\n    if (std::is_reference<T>::value) {\n        if (std::is_lvalue_reference<T>::value) {\n            printf(\"lvalue ref \");\n        } else {\n            printf(\"rvalue ref \");\n        }\n        printf(\"%s\\n\", (typeid(typename\n                  std::remove_reference<T>::type).name()));\n    } else {\n        printf(\"%s\\n\", typeid(var).name());\n    }\n}\n```", "```cpp\nprintType(number(42));\nprintType(reference(42));\n```", "```cpp\nint\nlvalue ref int\n```", "```cpp\nvoid printType <int>(int&&):\n```", "```cpp\nvoid printType <int&>(int&):\n```", "```cpp\npush rbp\n```", "```cpp\nmov rbp, rsp\n```", "```cpp\nsub rsp, 16\n```", "```cpp\nmov QWORD PTR [rbp-8], rdi\n```", "```cpp\nmov edi, OFFSET\n```", "```cpp\n         FLAT:typeinfo\n```", "```cpp\ncall std::type_info::name()\n```", "```cpp\nmov rdi, rax\n```", "```cpp\ncall puts\n```", "```cpp\nnop\n```", "```cpp\nleave\n```", "```cpp\nret\n```", "```cpp\npush rbp\n```", "```cpp\nmov rbp, rsp\n```", "```cpp\nsub rsp, 16\n```", "```cpp\nmov QWORD PTR [rbp-8], rdi\n```", "```cpp\nmov edi, OFFSET FLAT:.LC0\n```", "```cpp\nmov eax, 0\n```", "```cpp\ncall printf\n```", "```cpp\nmov edi, OFFSET\n```", "```cpp\n         FLAT:typeinfo\n```", "```cpp\ncall std::type_info::name() mov rdi, rax\n```", "```cpp\ncall puts\n```", "```cpp\nnop\n```", "```cpp\nleave\n```", "```cpp\nret\n```", "```cpp\n.LC0:\n```", "```cpp\n .string \"lvalue ref \"\n```"]