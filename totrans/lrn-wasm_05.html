<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Creating and Loading a WebAssembly Module</h1>
                </header>
            
            <article>
                
<p class="mce-root">The flags we passed to the <kbd>emcc</kbd> command in <a href="d03f5dbf-8b6e-49aa-96be-9bb64681be24.xhtml">Chapter 4</a>, <em><span class="cdp-organizer-chapter-title"><span class="cdp-organize-title-label">Installing the Required Dependencies</span></span></em>, produced a single <kbd>.wasm</kbd> file that could be loaded and instantiated in the browser using the native <kbd>WebAssembly</kbd> object. The C code was a very simple example intended to test the compiler without having to accommodate for included libraries or WebAssembly's limitations. We can overcome some of the limitations of WebAssembly in our C / C++ code with minimal performance loss by utilizing some of Emscripten's capabilities.</p>
<p class="mce-root">In this chapter, we'll cover the compilation and loading steps that correspond with the use of Emscripten's glue code. We'll also describe the process for compiling/outputting strictly <kbd>.wasm</kbd> files and loading them using the browser's <kbd>WebAssembly</kbd> object.</p>
<p class="mce-root">Our goal for this chapter is to understand the following:</p>
<ul>
<li class="mce-root">The compilation process for C code that utilizes Emscripten's JavaScript "glue" code</li>
<li class="mce-root">How to load an Emscripten module in the browser</li>
<li class="mce-root">The compilation process for C code that outputs only <kbd>.wasm</kbd> files (no "glue" code)</li>
<li class="mce-root">How to configure build tasks in VS Code</li>
<li class="mce-root">How to compile and load a Wasm module in the browser using the global <kbd>WebAssembly</kbd> object</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Compiling C with Emscripten glue code</h1>
                </header>
            
            <article>
                
<p class="mce-root">In <a href="d03f5dbf-8b6e-49aa-96be-9bb64681be24.xhtml">Chapter 4</a>, <em>Installing the Required Dependencies</em>, you wrote and compiled a simple three-line program to ensure your Emscripten installation was valid. We passed several flags to the <kbd>emcc</kbd> command that were required to only output a single <kbd>.wasm</kbd> file. By passing other flags to the <kbd>emcc</kbd> command, we can output JavaScript glue code alongside the <kbd>.wasm</kbd> file as well as an HTML file to handle the loading process. In this section, we're going to write a more complex C program and compile it with the output options that Emscripten offers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing the example C code</h1>
                </header>
            
            <article>
                
<p>We didn't include any header files or pass in any functions in the example we covered in <a href="d03f5dbf-8b6e-49aa-96be-9bb64681be24.xhtml">Chapter 4</a>, <em>Installing the Required Dependencies</em>. Since the intention of the code was solely to test if the compiler installation was valid, there wasn't much need. Emscripten offers a lot of extra functionality that enables us to interact with our C and C++ code with JavaScript and vice versa. Some of these capabilities are Emscripten-specific and don't correspond to the <em>Core Specification</em> or its APIs. In our first example, we'll take advantage of one of Emscripten's ported libraries and a function provided by Emscripten's API.</p>
<p class="mce-root">The following program uses a <strong><span>Simple DirectMedia Layer</span> </strong>(<strong><span>SDL2</span></strong>) to move a rectangle diagonally across a canvas in an infinite loop. It was taken from <a href="https://github.com/timhutton/sdl-canvas-wasm">https://github.com/timhutton/sdl-canvas-wasm</a>, but I converted it from C++ to C and modified the code slightly. The code for this section is located in the <kbd>/chapter-05-create-load-module</kbd> folder of the <kbd>learn-webassembly</kbd> repository. Follow the following instructions to compile C with Emscripten.</p>
<p class="mce-root">Create a folder in your <kbd>/book-examples</kbd> folder named <kbd>/chapter-05-create-load-module</kbd>. Create a new file in this folder named <kbd>with-glue.c</kbd> and populate it with the following contents:</p>
<pre>/*<br/> * Converted to C code taken from:<br/> * https://github.com/timhutton/sdl-canvas-wasm<br/> * Some of the variable names and comments were also<br/> * slightly updated.<br/> */<br/>#include &lt;SDL2/SDL.h&gt;<br/>#include &lt;emscripten.h&gt;<br/>#include &lt;stdlib.h&gt;<br/><br/>// This enables us to have a single point of reference<br/>// for the current iteration and renderer, rather than<br/>// have to refer to them separately.<br/>typedef struct Context {<br/>  SDL_Renderer *renderer;<br/>  int iteration;<br/>} Context;<br/><br/>/*<br/> * Looping function that draws a blue square on a red<br/> * background and moves it across the &lt;canvas&gt;.<br/> */<br/>void mainloop(void *arg) {<br/>    Context *ctx = (Context *)arg;<br/>    SDL_Renderer *renderer = ctx-&gt;renderer;<br/>    int iteration = ctx-&gt;iteration;<br/><br/>    // This sets the background color to red:<br/>    SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);<br/>    SDL_RenderClear(renderer);<br/><br/>    // This creates the moving blue square, the rect.x<br/>    // and rect.y values update with each iteration to move<br/>    // 1px at a time, so the square will move down and<br/>    // to the right infinitely:<br/>    SDL_Rect rect;<br/>    rect.x = iteration;<br/>    rect.y = iteration;<br/>    rect.w = 50;<br/>    rect.h = 50;<br/>    SDL_SetRenderDrawColor(renderer, 0, 0, 255, 255);<br/>    SDL_RenderFillRect(renderer, &amp;rect);<br/><br/>    SDL_RenderPresent(renderer);<br/><br/>    // This resets the counter to 0 as soon as the iteration<br/>    // hits the maximum canvas dimension (otherwise you'd<br/>    // never see the blue square after it travelled across<br/>    // the canvas once).<br/>    if (iteration == 255) {<br/>        ctx-&gt;iteration = 0;<br/>    } else {<br/>        ctx-&gt;iteration++;<br/>    }<br/>}<br/><br/>int main() {<br/>    SDL_Init(SDL_INIT_VIDEO);<br/>    SDL_Window *window;<br/>    SDL_Renderer *renderer;<br/><br/>    // The first two 255 values represent the size of the &lt;canvas&gt;<br/>    // element in pixels.<br/>    SDL_CreateWindowAndRenderer(255, 255, 0, &amp;window, &amp;renderer);<br/><br/>    Context ctx;<br/>    ctx.renderer = renderer;<br/>    ctx.iteration = 0;<br/><br/>    // Call the function repeatedly:<br/>    int infinite_loop = 1;<br/><br/>    // Call the function as fast as the browser wants to render<br/>    // (typically 60fps):<br/>    int fps = -1;<br/><br/>    // This is a function from emscripten.h, it sets a C function<br/>    // as the main event loop for the calling thread:<br/>    emscripten_set_main_loop_arg(mainloop, &amp;ctx, fps, infinite_loop);<br/><br/>    SDL_DestroyRenderer(renderer);<br/>    SDL_DestroyWindow(window);<br/>    SDL_Quit();<br/><br/>    return EXIT_SUCCESS;<br/>}</pre>
<p>The <kbd>emscripten_set_main_loop_arg()</kbd> toward the end of the <kbd>main()</kbd> function is available because we included <kbd>emscripten.h</kbd> at the top of the file. The variables and functions prefixed with <kbd>SDL_</kbd> are available because of the <kbd>#include &lt;SDL2/SDL.h&gt;</kbd> at the top of the file. If you're seeing a squiggly red error line under the <kbd>&lt;SDL2/SDL.h&gt;</kbd> statement, you can disregard it. It's due to SDL's <kbd>include</kbd> path not being present in your <kbd>c_cpp_properties.json</kbd> file.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Compiling the example C code</h1>
                </header>
            
            <article>
                
<p>Now that we have our C code written, we'll need to compile it. One of the required flags you must pass to the <kbd>emcc</kbd> command is <kbd>-o &lt;target&gt;</kbd>, where <kbd>&lt;target&gt;</kbd> is the path to the desired output file. The extension of that file will do more than just output that file; it impacts some of the decisions the compiler makes. The following table, taken from Emscripten's <kbd>emcc</kbd> documentation at <a href="http://kripken.github.io/emscripten-site/docs/tools_reference/emcc.html#emcc-o-target">http://kripken.github.io/emscripten-site/docs/tools_reference/emcc.html#emcc-o-target</a>, defines the generated output types based on the file extension specified:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td class="CDPAlignCenter CDPAlign"><strong>Extension</strong></td>
<td class="CDPAlignCenter CDPAlign"><strong>Output</strong></td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"><kbd>&lt;name&gt;.js</kbd></td>
<td>
<p class="CDPAlignLeft CDPAlign">JavaScript glue code (and <kbd>.wasm</kbd> if the <kbd>s WASM=1</kbd> flag is specified).</p>
</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"><kbd><span>&lt;name&gt;.html</span></kbd></td>
<td>
<p>HTML and separate JavaScript file (<kbd>&lt;name&gt;.js</kbd>). Having the separate JavaScript file improves page load time.</p>
</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"><kbd><span>&lt;name&gt;.bc</span></kbd></td>
<td>
<p>LLVM bitcode (default).</p>
</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"><kbd><span>&lt;name&gt;.o</span></kbd></td>
<td>
<p>LLVM bitcode (same as <kbd>.bc</kbd>).</p>
</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"><kbd><span>&lt;name&gt;.wasm</span></kbd></td>
<td>
<p>Wasm file only (with flags specified from <a href="d03f5dbf-8b6e-49aa-96be-9bb64681be24.xhtml">Chapter 4</a>, <em>Installing the Required Dependencies</em>).</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>You can disregard the <kbd>.bc</kbd> and <kbd>.o</kbd> file extensions—we won't need to output LLVM bitcode. The <kbd>.wasm</kbd> extension isn't on the <kbd>emcc</kbd> <em>Tools Reference</em> page, but it is a valid option if you pass the correct compiler flags. These output options factor into the C/C++ code we write.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Outputting HTML with glue code</h1>
                </header>
            
            <article>
                
<p>If you specify an HTML file extension (for example, <kbd>-o with-glue.html</kbd>) for the output, you'll end up with a <kbd>with-glue.html</kbd>, <kbd>with-glue.js</kbd>, and <kbd>with-glue.wasm</kbd> file (assuming you also specified <kbd>-s WASM=1</kbd>). If you have a <kbd>main()</kbd> function in the source C/C++ file, it'll execute that function as soon as the HTML loads. Let's compile our example C code to see this in action. To compile it with the HTML file and JavaScript glue code, <kbd>cd</kbd> into the <kbd>/chapter-05-create-load-module</kbd> folder and run the following command:</p>
<pre class="mce-root"><strong>emcc with-glue.c -O3 -s WASM=1 -s USE_SDL=2 -o with-glue.html</strong></pre>
<p class="mce-root"/>
<p class="mce-root">The first time you run this command, Emscripten is going to download and build the <kbd>SDL2</kbd> library. It could take several minutes to complete this, but you'll only need to wait once. Emscripten caches the library so subsequent builds will be much faster. Once the build is complete, you'll see three new files in the folder: <kbd>HTML</kbd>, <kbd>JavaScript</kbd>, and <kbd>Wasm</kbd> files. Run the following command to <kbd>serve</kbd> the file locally:</p>
<pre class="mce-root"><strong>serve -l 8080</strong></pre>
<p class="mce-root">If you open your browser up to <kbd>http://127.0.0.1:8080/with-glue.html</kbd>, you should see the following:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/bb584a1f-c5eb-415f-b86a-5904f11404a5.png" style="width:47.42em;height:39.50em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Emscripten loading code running in the browser</div>
<p>The blue rectangle should be moving diagonally from the upper-left corner of the red rectangle to the lower-right. Since you specified a <kbd>main()</kbd> function in the C file, Emscripten knows it should execute it right away. If you open up the <kbd>with-glue.html</kbd> file in VS code and scroll to the bottom of the file, you will see the loading code. You won't see any references to the <kbd>WebAssembly</kbd> object; that's being handled in the JavaScript glue code file.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Outputting glue code with no HTML</h1>
                </header>
            
            <article>
                
<p class="mce-root">The loading code that Emscripten generates in the HTML file contains error handling and other helpful functions to ensure the module is loading before executing the <kbd>main()</kbd> function. If you specify <kbd>.js</kbd> for the extension of the output file, you'll have to create an HTML file and write the loading code yourself. In the next section, we're going to dig into the loading code in more detail.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Loading the Emscripten module</h1>
                </header>
            
            <article>
                
<p class="mce-root">Loading and interacting with a module that utilizes Emscripten's glue code is considerably different from WebAssembly's JavaScript API. This is because Emscripten provides additional functionality for interacting with the JavaScript code. In this section, we're going to discuss the loading code that Emscripten provides when outputting an HTML file and review the process for loading an Emscripten module in the browser.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pre-generated loading code</h1>
                </header>
            
            <article>
                
<p class="mce-root">If you specify <kbd>-o &lt;target&gt;.html</kbd> when running the <kbd>emcc</kbd> command, Emscripten generates an HTML file and automatically adds code to load the module to the end of the file. Here's what the loading code in the HTML file looks like with the contents of each <kbd>Module</kbd> function excluded:</p>
<pre>var statusElement = document.getElementById('status');<br/>var progressElement = document.getElementById('progress');<br/>var spinnerElement = document.getElementById('spinner');<br/><br/>var Module = {<br/>  preRun: [],<br/>  postRun: [],<br/>  print: (function() {...})(),<br/>  printErr: function(text) {...},<br/>  canvas: (function() {...})(),<br/>  setStatus: function(text) {...},<br/>  totalDependencies: 0,<br/>  monitorRunDependencies: function(left) {...}<br/>};<br/><br/>Module.setStatus('Downloading...');<br/><br/>window.onerror = function(event) {<br/>  Module.setStatus('Exception thrown, see JavaScript console');<br/>  spinnerElement.style.display = 'none';<br/>  Module.setStatus = function(text) {<br/>    if (text) Module.printErr('[post-exception status] ' + text);<br/>  };<br/>};</pre>
<p>The functions within the <kbd>Module</kbd> object are present to detect and address errors, monitor the loading status of the <kbd>Module</kbd>, and optionally execute some functions before or after the <kbd>run()</kbd> method from the corresponding glue code file executes. The <kbd>canvas</kbd> function, shown in the following snippet, returns the <kbd>&lt;canvas&gt;</kbd> element from the DOM that was specified in the HTML file before the loading code:</p>
<pre>canvas: (function() {<br/>  var canvas = document.getElementById('canvas');<br/>  canvas.addEventListener(<br/>    'webglcontextlost',<br/>    function(e) {<br/>      alert('WebGL context lost. You will need to reload the page.');<br/>      e.preventDefault();<br/>    },<br/>    false<br/>  );<br/><br/>  return canvas;<br/>})(),</pre>
<p>This code is convenient for detecting errors and ensuring the <kbd>Module</kbd> is loaded, but for our purposes, we won't need to be as verbose.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing custom loading code</h1>
                </header>
            
            <article>
                
<p>Emscripten's generated loading code provides helpful error handling. If you're using Emscripten's output in production, I would recommend that you include it to ensure you're handling errors correctly. However, we don't actually need all the code to utilize our <kbd>Module</kbd>. Let's write some much simpler code and test it out. First, let's compile our C file down to glue code with no HTML output. To do that, run the following command:</p>
<pre class="mce-root"><strong>emcc with-glue.c -O3 -s WASM=1 -s USE_SDL=2 -s MODULARIZE=1 -o custom-loading.js</strong></pre>
<p class="mce-root">The <kbd>-s MODULARIZE=1</kbd> compiler flag allows us to use a Promise-like API to load our <kbd>Module</kbd>. Once the compilation is complete, create a file in the <kbd>/chapter-05-create-load-module</kbd> folder named <kbd>custom-loading.html</kbd> and populate it with the following contents:</p>
<pre>&lt;!doctype html&gt;<br/>&lt;html lang="en-us"&gt;<br/>&lt;head&gt;<br/>  &lt;title&gt;Custom Loading Code&lt;/title&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>  &lt;h1&gt;Using Custom Loading Code&lt;/h1&gt;<br/>  &lt;canvas id="canvas"&gt;&lt;/canvas&gt;<br/>  &lt;script type="application/javascript" src="custom-loading.js"&gt;&lt;/script&gt;<br/>  &lt;script type="application/javascript"&gt;<br/>    Module({<br/>      canvas: (() =&gt; document.getElementById('canvas'))(),<br/>    })<br/>      .then(() =&gt; {<br/>        console.log('Loaded!');<br/>      });<br/>  &lt;/script&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</pre>
<p class="mce-root">The loading code is now using ES6's arrow function syntax for the canvas loading function, which reduces the lines of code required. Start your local server by running the <kbd>serve</kbd> command within the <kbd>/chapter-05-create-load-module</kbd><span> folder</span>:</p>
<pre class="mce-root"><strong>serve -l 8080</strong></pre>
<p class="mce-root">When you navigate to <kbd>http://127.0.0.1:8080/custom-loading.html</kbd> in your browser, you should see this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5089d0d0-ffc7-4874-8cdf-9e307b5c3a1a.png" style="width:32.75em;height:25.58em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Custom loading code running in the browser</div>
<p>Of course, the function we're running isn't very complex, but it demonstrates the bare-bones requirements for loading Emscripten's <kbd>Module</kbd>. We will examine the <kbd>Module</kbd> object in much greater detail in <a href="cdf64596-59dd-4805-8509-7315b7760b1e.xhtml">Chapter 6</a>, <em>Interacting with JavaScript and Debugging</em>, but for now just be aware that the loading process is different from WebAssembly, which we'll cover in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Compiling C without the glue code</h1>
                </header>
            
            <article>
                
<p class="mce-root">If we want to use WebAssembly according to the official specification, without the extra features that Emscripten provides, we need to pass some flags to the <kbd>emcc</kbd> command and ensure we're writing code that can be used by WebAssembly with relative ease. In the <em>Writing the example C code</em> section, we wrote a program that rendered a blue rectangle that moved diagonally across a red canvas. It utilized one of Emscripten's ported libraries, SDL2. In this section, we're going to write and compile some C code that doesn't rely on Emscripten's helper methods and ported libraries.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">C code for WebAssembly</h1>
                </header>
            
            <article>
                
<p class="mce-root">Before we get to the C code we'll use for our WebAssembly module, let's try an experiment. Open the CLI in the <kbd>/chapter-05-create-load-module</kbd> folder, and try running this command:</p>
<pre class="mce-root"><strong>emcc with-glue.c -Os -s WASM=1 -s USE_SDL=2 -s SIDE_MODULE=1 -s BINARYEN_ASYNC_COMPILATION=0 -o try-with-glue.wasm</strong></pre>
<p class="mce-root">You should see a <kbd>try-with-glue.wasm</kbd> file appear in VS Code's file explorer panel after the compilation is complete. Right-click on the file and select <span class="packt_screen">Show WebAssembly</span>. The beginning of the corresponding Wat representation should resemble the following code:</p>
<pre>(module<br/>  (type $t0 (func (param i32)))<br/>  (type $t1 (func (param i32 i32 i32 i32 i32) (result i32)))<br/>  (type $t2 (func (param i32) (result i32)))<br/>  (type $t3 (func))<br/>  (type $t4 (func (param i32 i32) (result i32)))<br/>  (type $t5 (func (param i32 i32 i32 i32)))<br/>  (type $t6 (func (result i32)))<br/>  (type $t7 (func (result f64)))<br/>  (import "env" "memory" (memory $env.memory 256))<br/>  (import "env" "table" (table $env.table 4 anyfunc))<br/>  (import "env" "memoryBase" (global $env.memoryBase i32))<br/>  (import "env" "tableBase" (global $env.tableBase i32))<br/>  (import "env" "abort" (func $env.abort (type $t0)))<br/>  (import "env" "_SDL_CreateWindowAndRenderer" (func $env._SDL_CreateWindowAndRenderer (type $t1)))<br/>  (import "env" "_SDL_DestroyRenderer" (func $env._SDL_DestroyRenderer (type $t0)))<br/>  (import "env" "_SDL_DestroyWindow" (func $env._SDL_DestroyWindow (type $t0)))<br/>  (import "env" "_SDL_Init" (func $env._SDL_Init (type $t2)))<br/>  (import "env" "_SDL_Quit" (func $env._SDL_Quit (type $t3)))<br/>  (import "env" "_SDL_RenderClear" (func $env._SDL_RenderClear (type $t2)))<br/>  (import "env" "_SDL_RenderFillRect" (func $env._SDL_RenderFillRect (type $t4)))<br/>  (import "env" "_SDL_RenderPresent" (func $env._SDL_RenderPresent (type $t0)))<br/>  (import "env" "_SDL_SetRenderDrawColor" (func $env._SDL_SetRenderDrawColor (type $t1)))<br/>  (import "env" "_emscripten_set_main_loop_arg" (func $env._emscripten_set_main_loop_arg (type $t5)))<br/>  ...</pre>
<p class="mce-root"/>
<p>If you wanted to load this in a browser and execute it, you'd have to pass in an <kbd>importObj</kbd> object to WebAssembly's <kbd>instantiate()</kbd> or <kbd>compile()</kbd> function with an <kbd>env</kbd> object containing each of those <kbd>import "env"</kbd> functions. Emscripten handles all of this for us behind the scenes with the glue code, which makes it an incredibly valuable tool. However, we can replace the SDL2 functionality by using the DOM while still tracking the rectangle's location in C.</p>
<p class="mce-root">We will write the C code differently to ensure we only have to pass a few functions into the <kbd>importObj.env</kbd> object to execute the code. Create a file named <kbd>without-glue.c</kbd> in the <kbd>/chapter-05-create-load-module</kbd> folder and populate it with the following contents:</p>
<pre>/*<br/> * This file interacts with the canvas through imported functions.<br/> * It moves a blue rectangle diagonally across the canvas<br/> * (mimics the SDL example).<br/> */<br/>#include &lt;stdbool.h&gt;<br/><br/>#define BOUNDS 255<br/>#define RECT_SIDE 50<br/>#define BOUNCE_POINT (BOUNDS - RECT_SIDE)<br/><br/>// These functions are passed in through the importObj.env object<br/>// and update the rectangle on the &lt;canvas&gt;:<br/>extern int jsClearRect();<br/>extern int jsFillRect(int x, int y, int width, int height);<br/><br/>bool isRunning = true;<br/><br/>typedef struct Rect {<br/>  int x;<br/>  int y;<br/>  char direction;<br/>} Rect;<br/><br/>struct Rect rect;<br/><br/>/*<br/> * Updates the rectangle location by 1px in the x and y in a<br/> * direction based on its current position.<br/> */<br/>void updateRectLocation() {<br/>    // Since we want the rectangle to "bump" into the edge of the<br/>    // canvas, we need to determine when the right edge of the<br/>    // rectangle encounters the bounds of the canvas, which is why<br/>    // we're using the canvas width - rectangle width:<br/>    if (rect.x == BOUNCE_POINT) rect.direction = 'L';<br/><br/>    // As soon as the rectangle "bumps" into the left side of the<br/>    // canvas, it should change direction again.<br/>    if (rect.x == 0) rect.direction = 'R';<br/><br/>    // If the direction has changed based on the x and y<br/>    // coordinates, ensure the x and y points update<br/>    // accordingly:<br/>    int incrementer = 1;<br/>    if (rect.direction == 'L') incrementer = -1;<br/>    rect.x = rect.x + incrementer;<br/>    rect.y = rect.y + incrementer;<br/>}<br/><br/>/*<br/> * Clear the existing rectangle element from the canvas and draw a<br/> * new one in the updated location.<br/> */<br/>void moveRect() {<br/>    jsClearRect();<br/>    updateRectLocation();<br/>    jsFillRect(rect.x, rect.y, RECT_SIDE, RECT_SIDE);<br/>}<br/><br/>bool getIsRunning() {<br/>    return isRunning;<br/>}<br/><br/>void setIsRunning(bool newIsRunning) {<br/>    isRunning = newIsRunning;<br/>}<br/><br/>void init() {<br/>    rect.x = 0;<br/>    rect.y = 0;<br/>    rect.direction = 'R';<br/>    setIsRunning(true);<br/>}</pre>
<p class="mce-root">We will call the functions from the C code to determine the <em>x</em> and <em>y</em> coordinates. The <kbd>setIsRunning()</kbd> function can be used to pause the rectangle's movement. Now that our C code is ready, let's compile it. In the VS Code terminal, <kbd>cd</kbd> into the <kbd>/chapter-05-create-load-module</kbd> folder, and run the following command:</p>
<pre class="mce-root"><strong>emcc without-glue.c -Os -s WASM=1 -s SIDE_MODULE=1 -s BINARYEN_ASYNC_COMPILATION=0 -o without-glue.wasm</strong></pre>
<p class="mce-root"/>
<p class="mce-root">Once the compilation is complete, you can right-click on the resultant <kbd>without-glue.wasm</kbd> file and select <span class="packt_screen">Show WebAssembly</span> to see the Wat representation. You should see the following at the top of the file for the <kbd>import "env"</kbd> items:</p>
<pre>(module<br/>  (type $t0 (func (param i32)))<br/>  (type $t1 (func (result i32)))<br/>  (type $t2 (func (param i32 i32 i32 i32) (result i32)))<br/>  (type $t3 (func))<br/>  (type $t4 (func (result f64)))<br/>  (import "env" "memory" (memory $env.memory 256))<br/>  (import "env" "table" (table $env.table 8 anyfunc))<br/>  (import "env" "memoryBase" (global $env.memoryBase i32))<br/>  (import "env" "tableBase" (global $env.tableBase i32))<br/>  (import "env" "abort" (func $env.abort (type $t0)))<br/>  (import "env" "_jsClearRect" (func $env._jsClearRect (type $t1)))<br/>  (import "env" "_jsFillRect" (func $env._jsFillRect (type $t2)))<br/>  ...</pre>
<p>We need to pass in the <kbd>_jsClearRect</kbd> and <kbd>_jsFillRect</kbd> functions within the <kbd>importObj</kbd> object. We'll cover how to do that in the section on the HTML file with JavaScript interaction code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Compiling with a Build Task in VS Code</h1>
                </header>
            
            <article>
                
<p>The <kbd>emcc</kbd> command is a little verbose, and having to manually run this on the command line for different files can get cumbersome. To expedite the compilation process, we can use VS Code's <span class="packt_screen">Tasks</span> feature to create a build task for the files we'll use. To create a build task, select <span class="packt_screen">Tasks</span> | <span class="packt_screen">Configure Default Build Task…</span>, select the <span class="packt_screen">Create tasks.json from template</span> option, and select <span class="packt_screen">Others</span> to generate a simple <kbd>tasks.json</kbd> file in the <kbd>.vscode</kbd> folder. Update the contents of the file to contain the following:</p>
<pre class="mce-root">{<br/>  // See https://go.microsoft.com/fwlink/?LinkId=733558<br/>  // for the documentation about the tasks.json format<br/>  "version": "2.0.0",<br/>  "tasks": [<br/>    {<br/>      "label": "Build",<br/>      "type": "shell",<br/>      "command": "emcc",<br/>      "args": [<br/>        "${file}",<br/>        "-Os",<br/>        "-s", "WASM=1",<br/>        "-s", "SIDE_MODULE=1",<br/>        "-s", "BINARYEN_ASYNC_COMPILATION=0",<br/>        "-o", "${fileDirname}/${fileBasenameNoExtension}.wasm"<br/>       ],<br/>      "group": {<br/>        "kind": "build",<br/>        "isDefault": true<br/>       },<br/>       "presentation": {<br/>         "panel": "new"<br/>       }<br/>     }<br/>  ]<br/>}</pre>
<p class="mce-root">The <kbd>label</kbd> value is simply a name to refer to when running a task. The <kbd>type</kbd> and <kbd>command</kbd> values indicate that it should run the <kbd>emcc</kbd> command in a shell (terminal). The <kbd>args</kbd> value is an array of arguments to be passed to the <kbd>emcc</kbd> command (based on space separation). The <kbd>"${file}"</kbd> argument tells VS Code to compile the currently open file. The <kbd>"${fileDirname}/${fileBasenameNoExtension}.wasm"</kbd>  <span>argument</span> indicates that the <kbd>.wasm</kbd> output will have the same name as the currently open file (with a <kbd>.wasm</kbd> extension<span>)</span>, and it should be placed in the active folder of the currently open file. If you don't specify <kbd>${fileDirname}</kbd>, the output file will be placed in the root <span>folder</span> (rather than <kbd>/chapter-05-create-load-module</kbd> in this case).</p>
<p class="mce-root">The <kbd>group</kbd> object indicates that this task is the default build step, so if you use the keyboard shortcut <em>Cmd</em>/<em>Ctrl</em> + <em>Shift</em> + <em>B</em>, this is the task that will be run. The <kbd>presentation.panel</kbd> value of <kbd>"new"</kbd> tells VS Code to open up a new CLI instance when the build step runs. This is a personal preference and can be omitted.</p>
<p class="mce-root">You can save and close the <kbd>tasks.json</kbd> file once it's fully populated. To test it out, first delete the <kbd>without-glue.wasm</kbd> file that you generated with the <kbd>emcc</kbd> command in the previous section. Next, ensure you have <kbd>without-glue.c</kbd> open with the cursor in the file and run the build task by either selecting <strong><span class="packt_screen">Tasks</span></strong> | <span class="packt_screen">Run Build Task…</span> or using the keyboard shortcut <em>Cmd</em>/<em>Ctrl</em> + <em>Shift</em> + <em>B</em>. A new panel in the integrated terminal will perform the compilation and a <kbd>without-glue.wasm</kbd> file should appear after a second or two.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Fetching and instantiating a Wasm file</h1>
                </header>
            
            <article>
                
<p>Now that we have a Wasm file, we'll need some JavaScript code to compile and execute it. There's a few steps we'll have to follow to ensure the code can be successfully utilized in the browser. In this section, we will write some common JavaScript loading code that we can reuse for other examples, create an HTML file that demonstrates the use of the Wasm module, and test the results in the browser.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Common JavaScript loading code</h1>
                </header>
            
            <article>
                
<p>We will fetch and instantiate a <kbd>.wasm</kbd> file in several of the examples, so it makes sense to move the JavaScript loading code to a common file. The actual fetch and instantiation code is only a few lines, but having to repeatedly redefine the <kbd>importObj</kbd> object that Emscripten expects is a waste of time. We'll make this code available in a commonly accessible file to expedite the code-writing process. Create a new folder named <kbd>/common</kbd> in the <kbd>/book-examples</kbd> folder and add a file named <kbd>load-wasm.js</kbd> with the following contents:</p>
<pre class="mce-root">/**<br/> * Returns a valid importObj.env object with default values to pass<br/> * into the WebAssembly.Instance constructor for Emscripten's<br/> * Wasm module.<br/> */<br/>const getDefaultEnv = () =&gt; ({<br/>  memoryBase: 0,<br/>  tableBase: 0,<br/>  memory: new WebAssembly.Memory({ initial: 256 }),<br/>  table: new WebAssembly.Table({ initial: 2, element: 'anyfunc' }),<br/>  abort: console.log<br/>});<br/><br/>/**<br/> * Returns a WebAssembly.Instance instance compiled from the specified<br/> * .wasm file.<br/> */<br/>function loadWasm(fileName, importObj = { env: {} }) {<br/>  // Override any default env values with the passed in importObj.env<br/>  // values:<br/>  const allEnv = Object.assign({}, getDefaultEnv(), importObj.env);<br/><br/>  // Ensure the importObj object includes the valid env value:<br/>  const allImports = Object.assign({}, importObj, { env: allEnv });<br/><br/>  // Return the result of instantiating the module (instance and module):<br/>  return fetch(fileName)<br/>    .then(response =&gt; {<br/>      if (response.ok) return response.arrayBuffer();<br/>      throw new Error(`Unable to fetch WebAssembly file ${fileName}`);<br/>    })<br/>    .then(bytes =&gt; WebAssembly.instantiate(bytes, allImports));<br/>}</pre>
<p class="mce-root">The <kbd>getDefaultEnv()</kbd> function provides the required <kbd>importObj.env</kbd> contents for Emscripten's Wasm module. We want the ability to pass in any additional imports, which is why the <kbd>Object.assign()</kbd> statement is used. With the addition of any other imports the Wasm module expects, Emscripten's Wasm output will always require these five import statements for the <kbd>"env"</kbd> object:</p>
<pre>(import "env" "memory" (memory $env.memory 256))<br/>(import "env" "table" (table $env.table 8 anyfunc))<br/>(import "env" "memoryBase" (global $env.memoryBase i32))<br/>(import "env" "tableBase" (global $env.tableBase i32))<br/>(import "env" "abort" (func $env.abort (type $t0)))</pre>
<p>We need to pass those into the <kbd>instantiate()</kbd> function to ensure the Wasm module loads successfully, otherwise the browser will throw an error. Now that we have our loading code ready, let's move on to the HTML and rectangle-rendering code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The HTML page</h1>
                </header>
            
            <article>
                
<p>We're going to need an HTML page with a <kbd>&lt;canvas&gt;</kbd> element and JavaScript code to interact with the Wasm module. Create a file named <kbd>without-glue.html</kbd> in the <kbd>/chapter-05-create-load-module</kbd> folder and populate it with the following contents:</p>
<pre>&lt;!doctype html&gt;<br/>&lt;html lang="en-us"&gt;<br/>&lt;head&gt;<br/>  &lt;title&gt;No Glue Code&lt;/title&gt;<br/>  &lt;script type="application/javascript" src="../common/load-wasm.js"&gt;&lt;/script&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>  &lt;h1&gt;No Glue Code&lt;/h1&gt;<br/>  &lt;canvas id="myCanvas" width="255" height="255"&gt;&lt;/canvas&gt;<br/>  &lt;div style="margin-top: 16px;"&gt;<br/>    &lt;button id="actionButton" style="width: 100px; height: 24px;"&gt;<br/>      Pause<br/>    &lt;/button&gt;<br/>  &lt;/div&gt;<br/>  &lt;script type="application/javascript"&gt;<br/>    const canvas = document.querySelector('#myCanvas');<br/>    const ctx = canvas.getContext('2d');<br/><br/>    const env = {<br/>      table: new WebAssembly.Table({ initial: 8, element: 'anyfunc' }),<br/>      _jsFillRect: function (x, y, w, h) {<br/>        ctx.fillStyle = '#0000ff';<br/>        ctx.fillRect(x, y, w, h);<br/>      },<br/>      _jsClearRect: function() {<br/>        ctx.fillStyle = '#ff0000';<br/>        ctx.fillRect(0, 0, 255, 255);<br/>      },<br/>    };<br/><br/>    loadWasm('without-glue.wasm', { env }).then(({ instance }) =&gt; {<br/>      const m = instance.exports;<br/>      m._init();<br/><br/>      // Move the rectangle by 1px in the x and y every 20 milliseconds:<br/>      const loopRectMotion = () =&gt; {<br/>        setTimeout(() =&gt; {<br/>          m._moveRect();<br/>          if (m._getIsRunning()) loopRectMotion();<br/>        }, 20)<br/>      };<br/><br/>      // Enable you to pause and resume the rectangle movement:<br/>      document.querySelector('#actionButton')<br/>        .addEventListener('click', event =&gt; {<br/>          const newIsRunning = !m._getIsRunning();<br/>          m._setIsRunning(newIsRunning);<br/>          event.target.innerHTML = newIsRunning ? 'Pause' : 'Start';<br/>          if (newIsRunning) loopRectMotion();<br/>        });<br/><br/>      loopRectMotion();<br/>    });<br/>  &lt;/script&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</pre>
<p class="mce-root">This code will replicate the SDL example we created in the previous sections with some added functionality. When the rectangle bumps into the lower-right hand corner, it changes direction. You're also able to pause and resume the rectangle's movement using a button under the <kbd>&lt;canvas&gt;</kbd> element. You can see how we passed the <kbd>_jsFillRect</kbd> and <kbd>_jsClearRect</kbd> functions into the <kbd>importObj.env</kbd> object so they can be referenced by the Wasm module.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Serving it all up</h1>
                </header>
            
            <article>
                
<p class="mce-root">Let's test our code out in the browser. From the VS Code terminal, make sure you're in the <kbd>/book-examples</kbd> folder and run the command to start up a local server:</p>
<pre class="mce-root"><strong>serve -l 8080</strong></pre>
<p>It's important that you're in the <kbd>/book-examples</kbd> folder. If you try serving up the code in the <kbd>/chapter-05-create-load-module</kbd> folder only, you won't be able to use the <kbd>loadWasm()</kbd> function. If you open up your browser to <kbd>http://127.0.0.1:8080/chapter-05-create-load-module/without-glue.html</kbd>, you should see this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/76e4c6ba-e85a-448f-8418-7e71adddb265.png" style="width:34.83em;height:26.75em;"/><br/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Without glue code example running in the browser</div>
<p>Try pressing the <span class="packt_screen">Pause</span> button; the caption should change to <span class="packt_screen">Start</span> and the rectangle should stop moving. Clicking it again should cause the rectangle to start moving again.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, we covered the compilation and loading processes for modules that utilize the Emscripten glue code alongside the Wasm modules. By utilizing some of Emscripten's built-in features, such as ported libraries and helper methods, we were able to demonstrate the advantages Emscripten offers. We discussed some of the compiler flags that you can pass to the <kbd>emcc</kbd> command and how that will affect your output. By utilizing VS Code's <span class="packt_screen">Tasks</span> feature, we were able to set up a build command to expedite the build process going forward. We also reviewed the process for compiling and loading a Wasm module without the glue code. We wrote some reusable JavaScript code to load the module as well as code to interact with our compiled Wasm module.</p>
<p class="mce-root">In <a href="cdf64596-59dd-4805-8509-7315b7760b1e.xhtml">Chapter 6</a>,<em> Interacting with JavaScript and Debugging</em>, we're going to cover interacting with JavaScript and debugging techniques in the browser. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li class="mce-root">What does SDL stand for?</li>
<li class="mce-root">In addition to JavaScript, HTML, and Wasm, what other output type can you generate with the <kbd>-o</kbd> flag for the <kbd>emcc</kbd> command?</li>
<li class="mce-root">What advantages does using Emscripten's pre-generated loading code offer?</li>
<li class="mce-root">What must you name your function in the C/C++ file to ensure it automatically executes the compiled output in the browser?</li>
<li class="mce-root">Why can't we use just the Wasm file output without the "glue" code when using ported libraries?</li>
<li class="mce-root">What is the keyboard shortcut in VS Code for running your default build task?</li>
<li class="mce-root">Why do we need the <kbd>getDefaultEnv()</kbd> method in the Wasm loading code?</li>
<li class="mce-root">Which five items are required for the <kbd>importObj.env</kbd> object passed into the Wasm instantiation code for a Wasm module created with Emscripten?</li>
</ol>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li>About SDL: <a href="https://www.libsdl.org/index.php">https://www.libsdl.org/index.php</a></li>
<li><strong>Emscripten Compiler Frontend</strong> (<strong>emcc</strong>): <a href="http://kripken.github.io/emscripten-site/docs/tools_reference/emcc.html">http://kripken.github.io/emscripten-site/docs/tools_reference/emcc.html</a></li>
<li>Integrate with External Tools via Tasks: <a href="https://code.visualstudio.com/docs/editor/tasks">https://code.visualstudio.com/docs/editor/tasks</a></li>
<li>Loading and running WebAssembly code: <a href="https://developer.mozilla.org/en-US/docs/WebAssembly/Loading_and_running">https://developer.mozilla.org/en-US/docs/WebAssembly/Loading_and_running</a></li>
</ul>


            </article>

            
        </section>
    </body></html>