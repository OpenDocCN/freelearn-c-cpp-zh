["```cpp\ntemplate<typename T>\nconcept Arithmetic = std::is_arithmetic_v<T>;\n```", "```cpp\ntemplate<Arithmetic T>\nT add(T a, T b) { return (a + b); }\n```", "```cpp\n#include <iostream>\n#include <type_traits>\n// Create a class that is not inherently printable.\nstruct NotPrintable\n{\n  int foo{0};\n  int bar{0};\n};\n// Concept definition using the 'requires' clause\ntemplate <typename T>\nconcept Printable = requires(T t) {\n  // Requires that t can be printed to std::cout\n  std::cout << t;\n};\n// Before C++20:\n// A Function template that uses SFINAE to implement a\n// \"Printable concept\"\ntemplate <typename T,\n          typename = typename std::enable_if<std::is_same<\n              decltype(std::cout << std::declval<T>()),\n              std::ostream &>::value>::type>\nvoid printValueSFINAE(const T &value) {\n  std::cout << \"Value: \" << value << \"\\n\";\n}\n// After C++20:\n// A Function template that uses the Printable concept\ntemplate <Printable T> void printValue(const T &value) {\n  std::cout << \"Value: \" << value << \"\\n\";\n}\nint main() {\n  const int num = 42;\n  const NotPrintable np;\n  const std::string str = \"Hello, Concepts!\";\n  // Using the function template with SFINAE\n  printValueSFINAE(num);\n  // This line would fail to compile:\n  // printValueSFINAE(np);\n  printValueSFINAE(str);\n  // Using the function template with concepts\n  printValue(num);\n  // This line would fail to compile\n  // printValue(np);\n  printValue(str);\n  return 0;\n}\n```", "```cpp\nValue: 42\nValue: Hello, Concepts!\nValue: 42\nValue: Hello, Concepts!\n```", "```cpp\n#include <concepts>\n#include <iostream>\n#include <vector>\ntemplate <typename T>\nconcept Drawable = requires(T obj) {\n  { obj.draw() } -> std::convertible_to<void>;\n};\nclass Circle {\npublic:\n  void draw() const { std::cout << \"Drawing a circle.\\n\"; }\n};\nclass Square {\npublic:\n  // No draw() member function\n};\ntemplate <Drawable T> void drawShape(const T &shape) {\n  shape.draw();\n}\nint main() {\n  Circle circle;\n  Square square;\n  drawShape(circle);\n  // Uncommenting the line below would result in\n  // 'drawShape': no matching overloaded function found:\n  // drawShape(square);\n  return 0;\n}\n```", "```cpp\nDrawing a circle.\n```", "```cpp\ntemplate <typename T> class generator {\npublic:\n  struct promise_type {\n    T value;\n    auto get_return_object() {\n      return generator{handle_type::from_promise(*this)};\n    }\n    auto initial_suspend() {\n      return std::suspend_always{};\n    }\n    auto final_suspend() noexcept {\n      return std::suspend_always{};\n    }\n    void unhandled_exception() { std::terminate(); }\n    void return_void() {}\n    auto yield_value(T x) {\n      value = x;\n      return std::suspend_always{};\n    }\n  };\n  using handle_type = std::coroutine_handle<promise_type>;\n  generator(handle_type h) : m_handle(h) {}\n  generator(const generator &) = delete;\n  generator(generator &&o) noexcept\n      : m_handle(std::exchange(o.m_handle, {})) {}\n  ~generator() {\n    if (m_handle) m_handle.destroy();\n  }\n  bool next() {\n    m_handle.resume();\n    return !m_handle.done();\n  }\n  T value() const { return m_handle.promise().value; }\nprivate:\n  handle_type m_handle;\n};\n```", "```cpp\ngenerator<int> generate_numbers(int start, int end) {\n  for (int i = start; i <= end; ++i) { co_yield i; }\n}\nint main() {\n  std::vector<int> numbers;\n  auto gen = generate_numbers(1, 10);\n  while (gen.next()) { numbers.push_back(gen.value()); }\n  std::vector<int> evenNumbers;\n  std::ranges::copy_if(numbers,\n                       std::back_inserter(evenNumbers),\n                       [](int n) { return n % 2 == 0; });\n  const auto transformed =\n      evenNumbers |\n      std::views::transform([](int n) { return n * 2; });\n  for (int n : transformed) { std::cout << n << \" \"; }\n  return 0;\n}\n```", "```cpp\n4 8 12 16 20\n```"]