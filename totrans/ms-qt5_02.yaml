- en: Chapter 2.  Discovering QMake Secrets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter addresses the issue of creating a cross-platform application that
    relies on platform-specific code. We will see the impact of qmake on the compilation
    of your project.
  prefs: []
  type: TYPE_NORMAL
- en: You will learn how to create a system monitoring application that retrieves
    the average CPU load and the memory used from Windows, Linux, and Mac. For this
    kind of OS dependent application, architecture is the key to keeping your application
    reliable and maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this chapter, you will be able to create and organize a cross-platform
    application that uses platform-specific code and displays Qt Charts widgets. Moreover,
    qmake will not be a mystery anymore.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Platform-specific code organization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design patterns, strategy, and singleton
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstract class and pure virtual function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Qt Charts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The qmake tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing a cross-platform project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want to display some visual gauges and chart widgets, so create a new **Qt
    widgets Application** called `ch02-sysinfo`. As already discussed in [Chapter
    1](part0014.xhtml#aid-DB7S1 "Chapter 1.  Get Your Qt Feet Wet"), *Get Your Qt
    Feet Wet*, Qt Creator will generate some files for us: `main.cpp`, `MainWindow.h`, `MainWindow.cpp`,
    and `MainWindow.ui`.
  prefs: []
  type: TYPE_NORMAL
- en: Before diving into the C++ code, we must think about the software's architecture.
    This project will handle multiple desktop platforms. Thanks to the combination
    of C++ and Qt, most of the source code will be common to all targets. However,
    to retrieve both the CPU and memory usage from the OS (operating system), we will
    use some platform-specific code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To successfully achieve this task, we will use two design patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Strategy pattern**: This is an interface that describes functionalities (for
    example, retrieve CPU usage), and specific behaviors (retrieve CPU usage on Windows/Mac
    OS/Linux) will be performed into subclasses that implement this interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Singleton pattern**: This pattern guarantees a single instance for a given
    class. This instance will be easily accessible with a unique access point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you can see in the following diagram, the class `SysInfo` is our interface
    with the strategy pattern, and is also a singleton. The specific behavior from
    the strategy pattern is performed in the classes `SysInfoWindowsImpl`, `SysInfoMacImpl`,
    and `SysInfoLinuxImpl`, subclassing `SysInfo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing a cross-platform project](img/image00360.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The UI part will only know and use the `SysInfo` class. The platform-specific
    implementation class is instantiated by the `SysInfo` class, and the caller doesn't
    need to know anything about the `SysInfo` child classes. As the `SysInfo` class
    is a singleton, access will be easier for all widgets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by creating the `SysInfo` class. On Qt Creator, you can create
    a new C++ class from the contextual menu, accessible with a right click on the
    project name in the hierarchy view. Then click on the **Add new** option, or from
    the menu, go to **File** | **New file or project** | **Files and classes**. Then
    perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to **C++ Class** | **Choose**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Class** name field to `SysInfo`. As this class does not inherit from
    another class, we do not need to use the `Base` class field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Next**, then **Finish** to generate an empty C++ class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will now specify our interface by adding three pure virtual functions: `init()`, `cpuLoadAverage()`,
    and `memoryUsed()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of these functions has specific roles:'
  prefs: []
  type: TYPE_NORMAL
- en: '`init()`: This function allows the derived class to perform any initialization
    process depending on the OS platform'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cpuLoadAverage()`: This function calls some OS-specific code to retrieve the
    average CPU load and returns it as a percentage value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`memoryUsed()`: This function calls some OS-specific code to retrieve the memory
    used and returns it as a percentage value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `virtual` keyword indicates that the function can be overridden in a derived
    class. The `= 0` syntax means that this function is pure virtual, and must be
    overridden in any concrete derived class. Moreover, this makes `SysInfo` an abstract
    class that cannot be instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: We also added an empty virtual destructor. This destructor must be virtual to
    ensure that any deletion of an instance of a derived class--from a base class
    pointer--will call the derived class destructor and not only the base class destructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our `SysInfo` class is an abstract class and ready to be derived,
    we will describe three implementations: Windows, Mac OS, and Linux. You can also
    perform only one implementation if you would rather not use the other two. We
    will not make any judgment on this. The `SysInfo` class will be transformed into
    a singleton after adding the implementations.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Windows implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remember the UML diagram at the beginning of this chapter? The `SysInfoWindowsImpl`
    class is one of the classes derived from the `SysInfo` class. The main purpose
    of this class is to encapsulate the Windows-specific code to retrieve CPU and
    memory usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s time to create the `SysInfoWindowsImpl` class. To do that, you need to
    perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Right click on the `ch02-sysinfo` project name in the hierarchy view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Add New** | **C++ Class** | **Choose**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Class name** field to `SysInfoWindowsImpl`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Base class** field to **<Custom>** and write under the `SysInfo` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Next** then **Finish** to generate an empty C++ class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'These generated files are a good starting point, but we must tune them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The first thing to do is to add the `include` directive to our parent class, `SysInfo`.
    You can now override virtual functions defined in the base class.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Qt Tip**'
  prefs: []
  type: TYPE_NORMAL
- en: Put your cursor on a derived class name (after the keyword `class`) and press *Alt*
    + *Enter* (Windows / Linux) or *Command* + *Enter* (Mac) to automatically insert
    virtual functions of the base class.
  prefs: []
  type: TYPE_NORMAL
- en: The `override` keyword comes from C++11\. It ensures that the function is declared
    as virtual in the base class. If the function signature marked as `override` does
    not match any parent class' `virtual` function, a compile-time error will be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Retrieving the current memory used on Windows is easy. We will begin with this
    feature in the `SysInfoWindowsImpl.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget to include the `windows.h` file so that we can use the Windows
    API! Actually, this function retrieves the total and the available physical memory.
    A simple subtraction gives us the amount of memory used. As required by the base
    class `SysInfo`, this implementation will return the value as a `double` type;
    for example, the value `23.0` for 23% memory used on a Windows OS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Retrieving the total memory used is a good start, but we cannot stop now. Our
    class must also retrieve the CPU load. The Windows API can be messy sometimes.
    To make our code more readable, we will create two private helper functions. Update
    your `SysInfoWindowsImpl.h` file to match the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s analyze these changes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cpuRawData()` is the function that will perform the Windows API call to
    retrieve system timing information and return values in a generic format. We will
    retrieve and return three values: the amount of time that the system has spent
    in idle, in Kernel, and in User mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `convertFileTime()` function is our second helper. It will convert a Windows `FILETIME
    struct` syntax to a `qulonglong` type. The `qulonglong` type is a Qt `unsigned
    long long int`. This type is guaranteed by Qt to be 64-bit on all platforms. You
    can also use the typedef `quint64`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `mCpuLoadLastValues` is a variable that will store system timing (idle,
    Kernel, and User) at a given moment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't forget to include the `<QtGlobal>` tag to use the `qulonglong` type, and
    the `<QVector>` tag to use the `QVector` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The syntax `typedef struct _FILETIME FILETIME` is a kind of forward declaration
    for `FILENAME` syntax. As we only use a reference, we can avoid including the `<windows.h>`
    tag in our file `SysInfoWindowsImpl.h` and keep it in the CPP file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can now switch to the file `SysInfoWindowsImpl.cpp` and implement these
    functions to finish the CPU load average feature on Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: When the `init()` function is called, we store the return value from the `cpuRawData()`
    function in our class variable `mCpuLoadLastValues`. It will be helpful for the `cpuLoadAverage()`function
    process.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may be wondering why we do not perform this task in the initialization
    list of the constructor. That is because when you call a function from the initialization
    list, the object is not yet fully constructed! In some circumstances, it may be
    unsafe because the function can try to access a member variable that has not been
    constructed yet. However, in this `ch02-sysinfo` project, the `cpuRawData` function
    does not use any member variables, so you are safe, if you really want to do it. Add
    the `cpuRawData()` function to the `SysInfoWindowsImpl.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we are: the Windows API call to the `GetSystemTimes` function! This function
    will give us the amount of time that the system has spent idle, and in the Kernel
    and User modes. Before filling the `QVector` class, we convert each value with
    our helper `convertFileTime` described in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The Windows structure `FILEFTIME` stores 64-bit information on two 32-bit parts
    (low and high). Our function `convertFileTime` uses the Windows structure `ULARGE_INTEGER`
    to correctly build a 64-bit value in a single part before returning it as a `qulonglong`
    type. Last but not least, the `cpuLoadAverage()` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'There are three important points to note here:'
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that a sample is an absolute amount of time, so subtracting two
    different samples will give us instantaneous values that can be processed to get
    the current CPU load.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first sample comes from our member variable `mCpuLoadLastValues`, probed
    the first time by the `init()` function. The second one is retrieved when the `cpuLoadAverage()`
    function is called. After initializing the samples, the `mCpuLoadLastValues` variable
    can store the new sample that will be used for the next call.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `percent` equation can be a little tricky because the Kernel value retrieved
    from the Windows API also contains the idle value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to learn more about the Windows API, take a look at the MSDN documentation
    at [https://msdn.microsoft.com/library](https://msdn.microsoft.com/library).
  prefs: []
  type: TYPE_NORMAL
- en: 'The final step to finish the Windows implementation is to edit the file `ch02-sysinfo.pro`
    so that it resembles the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As we did in the `ch01-todo` project, we also use C++14 with the `ch02-sysinfo`
    project. The really new point here is that we removed the files `SysInfoWindowsImpl.cpp`
    and `SysInfoWindowsImpl.h` from the common `SOURCES` and `HEADERS` variables.
    Indeed, we added them into a `windows` platform scope. When building for other
    platforms, those files will not be processed by qmake. That is why we can safely
    include a specific header such as `windows.h` in the source file `SysInfoWindowsImpl.cpp`
    without harming the compilation on other platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Linux implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's make the Linux implementation of our `ch02-sysinfo` project. If you have
    already done the Windows implementation, it will be a piece of cake! If you have
    not, you should take a look at it. Some information and tips will not be repeated
    in this part, such as how to create a `SysInfo` implementation class, keyboard
    shortcuts, and details about the `SysInfo` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new C++ class called `SysInfoLinuxImpl` that inherits from the `SysInfo`
    class, and insert virtual functions from the base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We will start by implementing the `memoryUsed()` function in the file `SysInfoLinuxImpl.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This function uses Linux-specific API. After adding the required includes, you
    can use the Linux `sysinfo()` function that returns information on the overall
    system statistics. With the total memory and the total memory used, we can easily
    return the `percent` value. Note that swap memory has been taken into account.
  prefs: []
  type: TYPE_NORMAL
- en: 'The CPU load feature is a little more complex than the memory feature. Indeed,
    we will retrieve from Linux the total amount of time the CPU spent performing
    different kinds of work. That is not exactly what we want. We must return the
    instantaneous CPU load. A common way to get it is to retrieve two sample values
    in a short period of time and use the difference to get the instantaneous CPU
    load:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In this implementation, we will only add one helper function and one member
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cpuRawData()` is a function that will perform the Linux API call to retrieve
    system timing information and return values in a `QVector` class of `qulonglong`
    type. We retrieve and return four values containing the time the CPU has spent
    on the following: normal processes in User mode, nice processes in User mode,
    processes in Kernel mode, and idle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `mCpuLoadLastValues` is a variable that will store a sample of system timing
    at a given moment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s go to the `SysInfoLinuxImpl.cpp` file to update it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As discussed before, the `cpuLoadAverage` function will need two samples to
    be able to compute an instantaneous CPU load average. Calling the `init()` function
    allows us to set `mCpuLoadLastValues` for the first time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To retrieve the CPU raw information on a Linux system, we chose to parse information
    available in the `/proc/stat` file. All we need is available on the first line,
    so a single `readLine()` is enough. Even though Qt provides some useful features,
    sometimes the C standard library functions are simpler. This is the case here;
    we are using `std::sscanf` to extract variables from a string. Now let''s look
    at the `cpuLoadAvearge()` body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This is where the magic happens. In this last function, we put all the puzzle
    pieces together. This function uses two samples of the CPU raw data. The first
    sample comes from our member variable `mCpuLoadLastValues`, set the first time
    by the `init()` function. The second sample is requested by the `cpuLoadAverage()`
    function. Then the `mCpuLoadLastValues` variable will store the new sample that
    will be used as the first sample on the next `cpuLoadAverage()` function call.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `percent` equation should be easy to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '`overall` is equal to user + nice + kernel'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`total` is equal to overall + idle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find more information about `/proc/stat` in the Linux Kernel documentation
    at [https://www.kernel.org/doc/Documentation/filesystems/proc.txt](https://www.kernel.org/doc/Documentation/filesystems/proc.txt).
  prefs: []
  type: TYPE_NORMAL
- en: 'Like the other implementations, the last thing to do is to edit the `ch02-sysinfo.pro`
    file like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: With this Linux scope condition in the `ch02-sysinfo.pro` file, our Linux-specific
    files will not be processed by the `qmake` command on other platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Mac OS implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take a look at the Mac implementation of the `SysInfo` class. Start
    by creating a new C++ class named `SysInfoMacImpl` that inherits from the `SysInfo`
    class. Override `SysInfo` virtual functions and you should have a `SysInfoMacImpl.h`
    file like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The first implementation we will do will be the `memoryUsed()` function, in
    the `SysInfoMacImpl.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We start by including the different headers for the Mac OS kernel. Then we initialize
    `machPort` with the call to the `mach_host_self()` function. A `machPort` is a
    kind of special connection to the kernel that enables us to request information
    about the system. We then proceed to prepare other variables so that we can retrieve
    virtual memory statistics with `host_statistics64()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the `vmStats` class is filled with the information needed, we extract
    the relevant data: the `freeMemory` and the `totalMemoryUsed`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that Mac OS has a peculiar way of managing its memory: it keeps a lot
    of memory in cache, ready to be flushed when needed. This implies that our statistics
    can be misled; we see the memory as used, whereas it was simply kept "just in
    case".'
  prefs: []
  type: TYPE_NORMAL
- en: The percentage calculation is straightforward; we still return a min/max clamped
    value to avoid any crazy values in our future graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next comes the `cpuLoadAverage()` implementation. The pattern is always the
    same; take samples at regular intervals and compute the growth on this interval.
    Therefore, we have to store intermediate values to be able to calculate the difference
    with the next sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the pattern used is strictly equivalent to the Linux implementation.
    You can even copy-paste the body of the `cpuLoadAverage()` function from the `SysInfoLinuxImpl.cpp`
    file. They do exactly the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the implementation is different for the `cpuRawData()` function. We load `cpuInfo`
    and `cpuCount` with `host_statistics()` and then we loop through each CPU to have
    the `totalUser`, `totalUserNice`, `totalSystem`, and `totalIdle` functions filled.
    Finally, we append all this data to the `rawData` object before returning it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The very last part is to compile the `SysInfoMacImpl` class only on Mac OS.
    Modify the `.pro` file to have the following body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Transforming SysInfo into a singleton
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Promises are made to be kept: we will now transform the `SysInfo` class into
    a singleton. C++ offers many ways to implement the singleton design pattern. We
    will explain one of them here. Open the `SysInfo.h` file and make the following
    changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The singleton must guarantee that there will be only one instance of the class
    and that this instance will be easily accessible from a single access point.
  prefs: []
  type: TYPE_NORMAL
- en: So the first thing to do is to change the visibility of the constructor to `protected`.
    This way, only this class and the child classes will be allowed to call the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Since only one instance of the object must exist, allowing the copy constructor
    and the assignment operator is nonsense. One way to solve the problem is to make
    them `private`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**C++ tip**'
  prefs: []
  type: TYPE_NORMAL
- en: Since C++11, you can define a function as deleted with the syntax void `myFunction()
    = delete`. Any use of a deleted function will display a compile-time error. It's
    another way to prevent the use of the copy constructor and the assignment operator
    with a singleton.
  prefs: []
  type: TYPE_NORMAL
- en: The last change is the "unique access point" with a `static` function instance
    that will return a reference of the `SysInfo` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is now time to commit singleton changes to the `SysInfo.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here you can see another Qt cross-OS trick. Qt provides some macro `Q_OS_WIN`, `Q_OS_LINUX`,
    or `Q_OS_MAC`. A Qt OS macro will be defined only on the corresponding OS. By
    combining these macros with a conditional preprocessor directive`#ifdef`, we can
    always include and instantiate the correct `SysInfo` implementation on all OSes.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring the `singleton` variable as a static variable in the `instance()`
    function is a way to make a singleton in C++. We tend to prefer this version because
    you do not need to worry about the singleton memory management. The compiler will
    handle the instantiation the first time as well as the destruction. Moreover,
    since C++11 this method is thread safe.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Qt Charts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The core part is ready. It's now time to create a UI for this project, and Qt
    Charts can help us with this task. Qt Charts is a module that provides a set of
    easy-to-use chart components, such as line chart, area chart, spline chart, pie
    chart, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Qt Charts was previously a commercial-only Qt module. Since Qt 5.7, the module
    is now included in Qt on GPLv3 license for open source users. If you are stuck
    on Qt 5.6, you can build the module by yourself from sources. More information
    can be found at [https://github.com/qtproject/qtcharts](https://github.com/qtproject/qtcharts).
  prefs: []
  type: TYPE_NORMAL
- en: 'The aim now is to create two Qt widgets, `CpuWidget` and `MemoryWidget`, to
    display nice Qt charts of the CPU and the memory used. These two widgets will
    share a lot of common tasks, so we will first create an abstract class, `SysInfoWidget`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring Qt Charts](img/image00361.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Then the two actual widgets will inherit from the `SysInfoWidget` class and
    perform their specific tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new C++ class called `SysInfoWidget` with `QWidget` as a base class.
    Some enhancements must be processed in the `SysInfoWidget.h` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `QChartView` is the generic widget that can display many types of chart.
    This class will handle the layout and display the `QChartView`. A `QTimer` will
    call the slot function `updateSeries()` regularly. As you can see, this is a pure
    virtual slot. That is the reason why the `SysInfoWidget` class is abstract. The
    slot `updateSeries()` will be overridden by child classes to retrieve a system
    value and define how the chart should be drawn. Note that the parameters `startDelayMs`
    and `updateSeriesDelayMs` have default values that can be customized by the caller
    if required.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now proceed to the `SysInfoWidget.cpp` file to correctly prepare this `SysInfoWidget`
    class before creating the child widgets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: All tasks in the `SysInfoWidget` constructor are common tasks required by the
    child widgets, `CpuWidget`, and `MemoryWidget`. The first step is the `mRefreshTimer`
    initialization to define the timer interval and the slot to call whenever a timeout
    signal is triggered. Then the static function `QTimer::singleShot()` will start
    the real timer after a delay defined by `startDelayMs`. Here again, Qt combined
    with lambda functions will give us a powerful code in just a few lines. The next
    part enables the antialiasing to smooth the chart drawing. We hide the chart's
    legend to get a minimalist display. The last part handles the layout to display
    the `QChartView` widget in our `SysInfoWidget` class.
  prefs: []
  type: TYPE_NORMAL
- en: CpuWidget using QCharts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that the base class `SysInfoWidget` is ready, let''s implement its first
    child class: `CpuWidget`. We will now use the Qt Charts API to display a good-looking
    widget. The average CPU load will be displayed in a pie graph with a hole in the
    center, like a partly eaten donut where the eaten part is the percentage of the
    CPU used. The first step is to add a new C++ class named `CpuWidget` and make
    it inherit `SysInfoWidget`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the constructor, the only parameter needed is a `QWidget* parent`. Since
    we provided default values for the `startDelayMs` and `updateSeriesDelayMs` variables
    in `SysInfoWidget` class, we get the best possible behavior; there is no need
    to remember it when subclassing `SysInfoWidget`, but it is still easy to override
    it if need be.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to override the `updateSeries()` function from the `SysInfoWidget`
    class and start using the Qt Charts API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Since we overrode the `SysInfoWidget::updateSeries()` slot, we have to include
    the `Q_OBJECT` macro to allow `CPUWidget` to respond to the `SysInfoWidgetmRefreshTimer::timeout()`
    signal.
  prefs: []
  type: TYPE_NORMAL
- en: We include `QPieSeries` from the Qt Charts module so that we can create a member `QPieSeries*`
    named `mSeries`. The `QPieSeries` is a subclass of `QAbstractSeries`, which is
    the base class of all Qt Charts series (`QLineSeries`, `QAreaSeries`, `QPieSeries`,
    and so on). In Qt Charts, a `QAbstractSeries` subclass holds the data you want
    to display and defines how it should be drawn, but it does not define where the
    data should be displayed inside your layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now proceed to `CpuWidget.cpp` to investigate how we can tell Qt where
    the drawing takes place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: All Qt Charts classes are defined in the `QtCharts` namespace. This is why we
    start with `using namespace QtCharts`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we initialize `mSeries` in the constructor initializer list. We then
    proceed to configure it. We carve the donut with `mSeries->setHoleSize(0.35)`
    and we append two data sets to `mSeries`: a fake `CPU Load` and `Cpu Free`, which
    are expressed in percentages. The `mSeries` function is now ready to be linked
    to the class managing its drawing: `QChart`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `QChart` class is retrieved from the `SysInfoWidget::chartView()` function.
    When calling `chart->addSeries(mSeries)`, `chart` takes the ownership of `mSeries`
    and will draw it according to the series type--in our case, a `QPieSeries`. `QChart`
    is not a `QWidget`: it is a subclass of `QGraphicsWidget`. `QGraphicsWidget` can
    be described as a lighter `QWidget` with some differences (its coordinates and
    geometry are defined with `doubles` or `floats` instead of `integers`, a subset
    of `QWidget` attributes are supported: custom drag, drop framework, and so on).
    The `QGraphicsWidget` class is designed to be added in a `QGraphicsScene` class,
    a high-performance Qt component used to draw hundreds of items on screen at the
    same time.'
  prefs: []
  type: TYPE_NORMAL
- en: In our `SysInfo` application, the `QChart` has to be displayed in a `QVBoxLayout`
    in `SysInfoWidget`. Here, the `QChartView` class comes in very handy. It lets
    us add `chart` in a `QWidget` layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'Up to now, `QPieSeries` has seemed rather abstract. Let''s add it to the `MainWindow`
    file to see how it looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We simply declare `mCpuWidget` in the `MainWindow.h` file, initialize it, and
    add it to `MainWindow->centralWidget->layout`. If you now run the application,
    you should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![CpuWidget using QCharts](img/image00362.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Even though it looks cool, this donut is a bit static and does not reflect the
    CPU usage. Thanks to the architecture we built with the `SysInfo` and `SysInfoWidget`
    classes, the remaining part will be implemented swiftly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch back to the `CpuWidget.cpp` file and implement the `updateSeries()`
    function with the following body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: First, we get a reference to our `SysInfo` singleton. We then retrieve the current
    average CPU load in the `cpuLoadAverage` variable. We have to feed this data to
    our `mSeries`. The `mSeries` object is a `QPieCharts`, which implies that we just
    want a snapshot of the current CPU average load. Past history is not meaningful
    with this kind of graph; that's why we clear the `mSeries` data with the `mSeries->clear()`
    syntax, and append the `cpuLoadAverage` variable and then the free part (`100.0
    - cpuLoadAverage`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The nice thing to note is that, in the `CpuWidget` class, we don''t have to
    worry about refreshing. All the work is done in the `SysInfoWidget` subclass with
    all the whistles and bells of the `QTimer` class. In a `SysInfoWidget` subclass,
    we only have to concentrate on the valuable specific code: what data should be
    displayed and what kind of graph is used to display it. If you look at the whole `CpuWidget`
    class, it is very short. The next `SysInfoWidget` subclass, `MemoryWidget`, will
    also be very concise, as well as quick to implement.'
  prefs: []
  type: TYPE_NORMAL
- en: Memory using Qcharts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our second `SysInfoWidget` is a `MemoryWidget` class. This widget will display
    a history of the data so that we can see how the memory consumption evolves over
    time. To display this data, we will use a `QLineSeries` class from the Qt Chart
    module. Create the `MemoryWidget` class and follow the same pattern we used for `CpuWidget`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of a being a `QPieSeries*`, `mSeries` is a type of `QLineSeries*` which
    will be linked to the `chart` object in a very similar fashion to `MemoryWidget.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `mSeries` data is, as usual, initialized in the initializer list. The `mPointPositionX`
    is an `unsigned long long` (using the Qt notation `qint64`) variable that will
    track the last X position of our data set. This huge value is used to make sure
    that `mPointPositionX` never overflows.
  prefs: []
  type: TYPE_NORMAL
- en: We then use an intermediate `areaSeries` that takes ownership of `mSeries` upon
    its initialization in `QAreaSeries* areaSeries = new QareaSeries(mSeries)`. `areaSeries`
    is then added to the `chart` object at `chart->addSeries(areaSeries)`. We do not
    want to display a single line in our `QChart`; instead we want to display an area
    that represents the used memory percentage. That is why we use an `areaSeries`
    type. Nonetheless, we will still update the `mSeries` data when adding new points
    to the dataset in the `updateSeries()` function. The `areaSeries` type will automatically
    handle them and deliver them to the `chart` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'After `chart->addSeries(areaSeries)`, we configure the chart display:'
  prefs: []
  type: TYPE_NORMAL
- en: The `chart->createDefaultAxes()` function creates an *X* and *Y* axis based
    on the `areaSeries` type. If we used a 3D series, the `createDefaultAxes()` function
    would have added a *Z* axis.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hide the *X* axis tick values with `chart->axisX()->setVisible(false)` (intermediate
    values displayed at the bottom of the axis). In our `MemoryWidget` class, this
    information is not relevant.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To define the number of points we want to display--the size of the display history--we
    call `chart->axisX()->setRange(0, CHART_X_RANGE_MAX)`. Here we use a constant
    to make it easier to modify this value afterwards. Seeing the value at the top
    of the file, we avoid having to skim through `MemoryWidget.cpp`, searching where
    this value is used to update it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chart->axisY()->setRange(0, 100)` defines the maximum range of the *Y* axis,
    which is a percentage, based on the value returned by the `SysInfo::memoryUsed()`
    function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The chart is now properly configured. We now have to feed it by filling the
    `updateSeries()` body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We first retrieve the latest memory percentage used and append it to `mSeries`
    at the *X* coordinate `mPointPositionX` (we post-increment it for the next `updateSeries()`
    call) and *Y* coordinate `memoryUsed`. As we want to keep a history of `mSeries`, `mSeries->clear()`
    is never called. However, what will happen when we add more than `CHART_X_RANGE_COUNT`
    points? The visible "window" on the chart is static and the points will be added
    outside. This means that we will see the memory usage only for the first `CHART_X_RANGE_MAX`
    points and then, nothing.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, `QChart` provides a function to scroll inside the view to move
    the visible window. We start to handle this case only when the dataset is bigger
    than the visible window, meaning `if (mSeries->count() > CHART_X_RANGE_COUNT)`.
    We then remove the point at the index 0 with `mSeries->remove(0)` to ensure that
    the widget will not store an infinite dataset. A SysInfo application that monitors
    the memory usage and has itself a memory leak is a bit sad.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax `chart->scroll(chart->plotArea().width() / CHART_X_RANGE_MAX, 0)`
    will then scroll to the latest point on the *X* axis and nothing on *Y*. The `chart->scroll(dx,
    dy)` expects coordinates expressed in our series coordinates. That is the reason
    why we have to retrieve the `char->plotArea()` divided by `CHART_X_RANGE_MAX`
    , the *X* axis unit.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now add the `MemoryWidget` class in `MainWindow`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: "Just as we did for `CPUWidget`, add a new member named `mMemoryWidget` to `MainWindow`\
    \ and add it to the `centralWidget` layout with the `uiâ\x86\x92centralWidget->layout()->addWidget(&mMemoryWidget)`\
    \ syntax."
  prefs: []
  type: TYPE_NORMAL
- en: 'Compile, run the application, and wait a few seconds. You should see something
    close to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Memory using Qcharts](img/image00363.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `MemoryWidget` class works fine, but it looks a bit dull. We can customize
    it very easily with Qt. The goal is to have a bold line at the top of the memory
    area and a nice gradient from top to bottom. We just have to modify the `areaSeries`
    class in the `MemoryWidget.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `QPen pen` function is a part of the `QPainter` API. It is the foundation
    on which Qt relies to do most of the GUI drawing. This includes the whole `QWidget`
    API (`QLabel`, `QPushButton`, `QLayout`, and so on). For the `pen`, we just have
    to specify its color and width, and then apply it to the `areaSeries` class with `areaSeries->setPen(pen)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The principle is the same for the gradient. We define the starting point (`QPointF(0,
    0)`) and the final point (`QPointF(0, 1)`) before specifying the color at each
    end of the vertical gradient. The `QGradient::ObjectBoundingMode` parameter defines
    how the start/final coordinates are mapped to the object. With the `QAreaSeries`
    class, we want the gradient coordinates to match the whole `QareaSeries` class.
    These coordinates are normalized coordinates, meaning that `0` is the start and `1`
    is the end of the shape:'
  prefs: []
  type: TYPE_NORMAL
- en: The `[0.0]` coordinates will point to the top left corner of the `QAreaSeries`
    class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `[1.0]` coordinates will point to the bottom left corner of the `QAreaSeries`
    class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A last build and run, and the `SysInfo` application will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Memory using Qcharts](img/image00364.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A memory leak or starting a virtual machine is a great way to make your memory
    go crazy
  prefs: []
  type: TYPE_NORMAL
- en: The `SysInfo` application is now finished, and we even added some visual polish.
    You can explore the `QGradient` classes and the `QPainter` API if you want to
    further customize the widget to your taste.
  prefs: []
  type: TYPE_NORMAL
- en: The .pro file in depth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you click on the **Build** button, what exactly is Qt Creator doing? How
    does Qt handle the compilation of the different platforms with a single `.pro`
    file? What does the `Q_OBJECT` macro imply exactly? We will dig into each of these
    questions in the following sections. Our example case will be the `SysInfo` application
    we just completed, and we will study what Qt is doing under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start this study by digging into the `.pro` file. It is the main entry
    point in compiling any Qt project. Basically, a `.pro` file is a `qmake` project
    file describing the sources and headers used by the project. It is a platform-agnostic
    definition of a `Makefile`. First, we can cover the different `qmake` keywords
    used in the `ch02-sysinfo` application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of these functions has specific roles:'
  prefs: []
  type: TYPE_NORMAL
- en: '`#`: This is the prefix needed to comment on a line. Yes, we generated the
    project on 2016-03-24-crazy, huh?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QT`: This is a list of the Qt modules used in the project. In the platform-specific
    Makefile, each of the values will include the module headers and the corresponding
    library link.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CONFIG`: This is a list of configuration options for the project. Here, we
    configure the support of C++14 in the Makefile.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TARGET`: This is the name of the target output file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TEMPLATE`: This is the project template used when generating the `Makefile.app`
    tells `qmake` to generate a Makefile targeted for a binary. If you are building
    a library, use the `lib` value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the `ch02-sysinfo` application, we started to use platform-specific compilation
    rules using the intuitive scope mechanism:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If you had to do this with a `Makefile`, you would probably lose some hair
    before doing it right (being bald is not an excuse). This syntax is simple yet
    powerful, and is also used for conditional statements. Let''s say you wanted to
    build some files on debug only. You would have written the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Nesting the `debug` scope inside `windows` is the equivalent of `if (windows
    && debug)`. The scoping mechanism is even more flexible; you can have the OR Boolean
    operator condition with this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'You can even have else if/else statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code snippet, we also see the use of the `+=` operator. The qmake tool
    provides a wide range of operators to modify the behavior of variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`=`: This operator sets the variable to the value. The syntax `SOURCES = SysInfoWindowsImpl.cpp`
    would have assigned the single`SysInfoWindowsImpl.cpp` value to the `SOURCES`
    variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`+=`: This operator adds the value to a list of values. This is what we commonly
    use in `HEADERS`, `SOURCES`, `CONFIG`, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-=`: This operator removes the value from the list. You can, for example,
    add a `DEFINE = DEBUG_FLAG` syntax in the common section and in a platform-specific
    scope (say a Windows release) remove it with the `DEFINE -= DEBUG_FLAG` syntax.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*=`: This operator adds the value to the list only if it is not already present.
    The `DEFINE *= DEBUG_FLAG` syntax adds the `DEBUG_FLAG` value only once.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`~=`: This operator replaces any values that match a regular expression with
    the specified value, `DEFINE ~= s/DEBUG_FLAG/debug`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can also define variables in the `.pro` file and reuse them in different
    places. We can simplify this with the use of the qmake `message()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: If you build the project, you will see your platform-specific message each time
    you build the project in the **General Messages** tab (you can access this tab
    from **Window** | **Output Panes** | **General Messages**). Here, we defined a `COMPILE_MSG`
    variable and referenced it when calling `message($$COMPILE_MSG windows)`. This
    offers interesting possibilities when you need to compile external libraries from
    your `.pro` file. You can then aggregate all the sources in a variable, combine
    it with the call to a specific compiler, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If your scope-specific statement is a single line, you can use the following
    syntax to describe it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides `message()`, there are a few other helpful functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`error(string)`: This function displays the string and exits the compilation
    immediately.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exists(filename)`: This function tests the existence of the `filename`. qmake
    also provides the `!` operator, which means you can write `!exist(myfile) { ...
    }`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`include(filename)`: This function includes the content of another `.pro` file.
    It gives you the ability to slice your `.pro` files into more modular components.
    This will prove very useful when you have multiple `.pro` files for a single big
    project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All the built-in functions are described at [http://doc.qt.io/qt-5/qmake-test-function-reference.html](http://doc.qt.io/qt-5/qmake-test-function-reference.html).
  prefs: []
  type: TYPE_NORMAL
- en: Under the hood of qmake
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we said earlier, qmake is the foundation of the Qt framework compilation
    system. In Qt Creator, when you click on the **Build** button, qmake is invoked.
    Let's study what qmake is exactly doing by calling it ourselves on the **CLI**
    (**Command Line Interface**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a temporary directory where you will store the generated files. We are
    working on a Linux box, but this is transposable on any OS. We chose `/tmp/sysinfo`.
    Using the CLI, navigate to this new directory and execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This command will execute qmake in the `-makefile` mode to generate a Makefile
    based on your `sysinfo.pro` file. If you skim through the Makefile content, you
    will see many things we covered earlier in the `.pro` section. The link to Qt
    modules, headers of different modules, inclusion of the headers and sources files
    of your project, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's build this Makefile by simply typing the `make` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'This command will generate the binary `ch02-sysinfo` (based on the `TARGET`
    value of the `.pro` file). If you look at the list of files now present in `/tmp/sysinfo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now this is very interesting, we find all our sources compiled in the usual
    `.o` extension (`SysInfo.o`, `SysInfoWidget.o`, and so on) but there are also
    a lot of other files prefixed with `moc_`. Here lies another keystone of the Qt
    framework: the Meta Object Compiler.'
  prefs: []
  type: TYPE_NORMAL
- en: Every time you use the signal/slot system, you have to include the macro `Q_OBJECT`
    in your header. Each time you emit a signal or receive one in a slot and you did
    not write any specific code to handle it, Qt took care of it. This is done by
    generating an intermediate implementation of your class (the `moc_*.cpp` file)
    containing everything Qt needs to properly handle your signals and slots.
  prefs: []
  type: TYPE_NORMAL
- en: 'A picture is worth a thousand words. Here is the complete compilation pipeline
    for a standard qmake project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Under the hood of qmake](img/image00365.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The blue boxes refer to commands and the wavy boxes are documents (sources
    or final binary). Let''s walk through the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The `qmake` command is executed with the project `.pro` file. It generates a
    Makefile based on the project file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `make` command is executed, which will call other commands to generate intermediate
    files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `uic` command stands for User Interface Compiler. It takes all the `.ui`
    files (which are basically an XML description of your interface) and generates
    the corresponding `ui_*.h` header that you include in your own `.cpp` (in our `ch02-sysinfo`
    project, it is in `MainWindow.cpp`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `moc` command takes every class containing the `Q_OBJECT` macro (paired
    with the superclass `QObject`) and generates the intermediate `moc_*.cpp` files,
    which include everything needed to make the signal/slot framework work.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `g++` command is executed, compiling all your sources' files and intermediate `moc`
    files into `.o` files before finally linking everything in the binary `ch02-sysinfo`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that if you add a `Q_OBJECT` macro after the creation of a class, sometimes
    the compiler will complain about your signals and slots. To fix this, simply run
    the `qmake` command from **Build** | **Run qmake**. You can now see that this
    stems from the fact that the Makefile has to be regenerated to include the generation
    of the new intermediate `moc` file.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, source code generation is regarded as bad practice in the developer
    community. Qt has been criticized on this topic for a long time. We always fear
    that the machines does some kind of voodoo behind our back. Unfortunately, C++
    does not offer any practical way of doing code introspection (namely reflection),
    and the signal and slots mechanism needs some kind of metadata about your class
    to resolve your signals and slots. This could have been done partly with the C++
    template system, but this solution seemed to Qt to be much less readable, portable,
    usable, and robust. You also need an excellent compiler support for templates.
    This cannot be assumed in the wild world of C++ compilers.
  prefs: []
  type: TYPE_NORMAL
- en: The `moc` system is now fully mature. There are some very specific edge cases
    where it could bring trouble (some have reported problems in very specific situations
    with Visual Studio), but even so, we think that the gain of this feature largely
    outweighs the possibly encountered issues. The signal/slot system is a marvel
    to work with, and if you look at the beginnings of Qt, the system has been present
    from the very first releases. Adding the functor notation in Qt 5 (which gives
    a compile time check of the validity of your `connect()`) combined with C++11 `lambas`
    makes it a real delight.
  prefs: []
  type: TYPE_NORMAL
- en: Beneath Q_OBJECT and signals/slots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Qt building system should be clearer now. Still, the `Q_OBJECT` macro and
    the signal/slot/emit keywords are still black boxes. Let's dive into `Q_OBJECT`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The truth lies in the source code; `Q_OBJECT` is defined in the file `qobjectdefs.h`
    (in Qt 5.7):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This macro defines some static functions and a `static QMetaObject`. The body
    of these static functions is implemented in the generated `moc` file. We will
    not drown you in the gory details of the `QMetaObject` class. The role of this
    class is to store all the metainformation for the `QObject` subclass. It also
    maintains a correspondence table between the signals and slots of your class,
    and to the signals and slots of any connected class. Each signal and each slot
    is assigned with a unique index:'
  prefs: []
  type: TYPE_NORMAL
- en: The `metaObject()` function returns the `&staticMetaObject` for a normal Qt
    class and a `dynamicMetaObject` when working with QML objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `qt_metacast()` function performs a dynamic cast using the name of the class.
    This function is required because Qt does not rely on standard C++ **RTTI** (**Runtime
    Type Information**) to retrieve meta data about an object or a class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `qt_metacall()`directly calls an internal signal or slot by its index. Because
    an index is used rather than a pointer, there is no pointer dereferencing, and
    the generated switch case can be heavily optimized by the compiler (the compiler
    can directly include the `jump` instruction to the specific case very early on,
    avoiding a lot of branch evaluation). Thus, the execution of the signal/slot mechanism
    is quite fast.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Qt also adds non-standard C++ keywords to manage the signal/slot mechanism,
    namely  `signals`, `slots`, and `emit`. Let's see what is behind each one and
    see how everything fits inside a `connect()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `slots` and `signals` keywords are also defined in `qobjectdefs.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'That is right: `slots` points to nothing and the `signals` keyword is just
    a placeholder for the `public` keyword. All your `signals`/`slots` are just...
    functions. The `signals` keyword is forced to be `public` to make sure that your
    signal functions are visible outside of your class (what is the point of a `private
    signal` anyway?). The Qt magic is simply the ability to emit a `signal` keyword
    to any connected `slot` keyword without knowing the detail of the class implementing
    this `slot`. Everything is done through the `QMetaObject` class implementation
    in the `moc` file. When a `signal` keyword is emitted, the function `QMetaObject::activate()`
    is called with the changed value and the signals index.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last definition to study is `emit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: So many definitions of nothing, it is almost absurd! The `emit` keyword is completely
    useless from a code perspective; `moc` plainly ignores it and nothing particular
    happens with it afterwards. It is merely a hint for the developer to notice he
    is working with signal/slots rather than plain functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To trigger a `slot`, you must connect your `signal` keyword to it using the `QObject::connect()`
    function. This function creates a new `Connection` instance that is defined in `qobject_p.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The `Connection` instance stores a pointer to the signal emitter class (`sender`),
    the slot receiver class (`receiver`), and the indexes of the connected `signal`
    and `slot` keywords. When a signal is emitted, every connected slot must be called.
    To be able to do this, every `QObject` has a linked list of `Connection` instances
    for each of its `signal`, and the same linked list of `Connection` for each of
    its `slot` keywords.
  prefs: []
  type: TYPE_NORMAL
- en: 'This pair of linked lists allows Qt to properly walk through each dependent
    `slot`/`signal` couple to trigger the right functions using the indexes. The same
    reasoning is used to handle the `receiver` destruction: Qt walks through the double
    linked list and removes the object from where it was connected.'
  prefs: []
  type: TYPE_NORMAL
- en: This walk happens in the famous UI thread, where the whole message loop is processed
    and every connected signal/slot is triggered according to the possible events
    (mouse, keyboard, network, and so on). Because the `QThread` class inherits the `QObject`,
    any `QThread` can use the signal/slot mechanism. Additionally, the `signals` keyword
    can be posted to other threads where they will be processed in the receiving threads'
    event loop.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we created a cross-platform `SysInfo` application. We covered
    the singleton and the strategy pattern to have a neat code organization with platform-specific
    code. You learned to use the Qt Charts module to display system information in
    real time. Finally, we took a deep dive into the `qmake` command to see how Qt
    implements the signal/slot mechanism, and to see what is hidden behind Qt-specific
    keywords (`emit`, `signals`, and `slots`).
  prefs: []
  type: TYPE_NORMAL
- en: By now, you should have a clear picture of how Qt works and how you can tackle
    a cross-platform application. In the next chapter, we will look at how you can
    split a bigger project in order to keep your sanity as a maintainer. We will study
    a fundamental pattern in Qt--the Model/View--and discover how to use a database
    with Qt.
  prefs: []
  type: TYPE_NORMAL
