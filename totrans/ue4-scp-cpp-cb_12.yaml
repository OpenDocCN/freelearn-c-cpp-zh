- en: Multiplayer Networking in UE4
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UE4中的多人网络
- en: 'In this chapter, we are going to cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Testing your game as a client and a server simultaneously
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同时作为客户端和服务器测试你的游戏
- en: Replicating properties over the network
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在网络上复制属性
- en: Replicating functions over the network
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在网络上复制函数
- en: Handling UI network events
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理UI网络事件
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Networking is one of the more complex things you can do as a programmer. Thankfully,
    Unreal Engine has been designed with networking in mind since the original Unreal
    Engine released in 1998\. Unreal uses a client-server model for communication
    between multiple computers. In this case, the **server** is the person who started
    the game and the **clients** are those who are playing the game with the first
    person. For things that are happening in everyone's game to work correctly, we
    need to call certain code at certain times for certain people.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 网络是作为程序员你可以做的更复杂的事情之一。幸运的是，Unreal Engine自1998年最初发布以来就考虑了网络。Unreal使用客户端-服务器模型在多台计算机之间进行通信。在这种情况下，**服务器**是开始游戏的人，而**客户端**是与第一人称一起玩游戏的人。为了使每个人游戏中发生的事情都能正确工作，我们需要在特定时间调用某些代码为某些人。
- en: For example, when a client wants to shoot his/her gun, they send a message to
    the server, which will then determine whether they hit anything and then tells
    all the clients what happened using replication. This can be important because
    some things, such as the game mode, only exist on the server.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当客户端想要射击他的/她的枪时，他们会向服务器发送一条消息，然后服务器将决定他们是否击中任何东西，然后通过复制告诉所有客户端发生了什么。这很重要，因为有些事情，如游戏模式，只存在于服务器上。
- en: For more information on the client-server model, check out [https://en.wikipedia.org/wiki/Client%E2%80%93server_model](https://en.wikipedia.org/wiki/Client%E2%80%93server_model).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 有关客户端-服务器模型的更多信息，请查看[https://en.wikipedia.org/wiki/Client%E2%80%93server_model](https://en.wikipedia.org/wiki/Client%E2%80%93server_model)。
- en: 'Since we are going to want to see multiple characters on the screen, in this
    chapter, we will be using a base project based on the Third Person C++ template:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望在屏幕上看到多个角色，在本章中，我们将使用基于第三人称C++模板的基础项目：
- en: '![](img/641e12f8-c70e-4e03-a8df-9670db5bc80a.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/641e12f8-c70e-4e03-a8df-9670db5bc80a.png)'
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires the use of Unreal Engine 4 and uses Visual Studio 2017
    as the IDE. Instructions on how to install both pieces of software and the requirements
    for them can be found in [Chapter 1](4adb307e-d86f-4d70-b6de-a0893102d1cf.xhtml),
    *UE4 Development Tools*, of this book.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要使用Unreal Engine 4，并使用Visual Studio 2017作为IDE。有关如何安装这两款软件及其要求的信息，请参阅本书的[第1章](4adb307e-d86f-4d70-b6de-a0893102d1cf.xhtml)，*UE4开发工具*。
- en: Testing your game as a client and a server simultaneously
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同时作为客户端和服务器测试你的游戏
- en: When working on networked games, it's always a good idea to test your project
    often. Instead of having to use two separate computers, Unreal comes with an easy
    way to play a game with multiple players at the same time built in.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在网络上工作游戏时，经常测试你的项目总是一个好主意。无需使用两台不同的计算机，Unreal内置了一种简单的方法，可以在同一时间玩多个玩家的游戏。
- en: How to do it...
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Generally, when we play the game, we only have one player on the screen. We
    can modify this with the Play settings:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们玩游戏时，屏幕上只有一个玩家。我们可以通过播放设置来修改这一点：
- en: 'From the Unreal Editor, with the `ThirdPersonExampleMap` open, click on the
    arrow drop-down next to the Play button. Under there, set the Number of Players
    property to `2`:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unreal编辑器中，打开`ThirdPersonExampleMap`，点击播放按钮旁边的箭头下拉菜单。在那里，将玩家数量属性设置为`2`：
- en: '![](img/8ed662ce-096e-4c08-b745-d45fa8545243.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8ed662ce-096e-4c08-b745-d45fa8545243.png)'
- en: 'Afterwards, click on the Play button:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，点击播放按钮：
- en: '![](img/b9faaf92-6b73-479c-8729-74858e85eecc.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b9faaf92-6b73-479c-8729-74858e85eecc.png)'
- en: As you can see, you now have two windows added to the screen!
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，现在屏幕上已经增加了两个窗口！
- en: Remember that you can return mouse control from a window by pressing *Shift*
    + *F1*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，你可以通过按*Shift* + *F1*将鼠标控制从窗口中返回。
- en: How it works...
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In addition to the character that is also placed in the scene, there is another
    object within the world called `NetworkPlayerStart`, which is where networked
    players will be spawned:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 除了场景中放置的角色外，世界上还有一个名为`NetworkPlayerStart`的另一个对象，这是网络玩家将被生成的地方：
- en: '![](img/9cc559e3-4292-4166-9655-c3d333129b7b.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9cc559e3-4292-4166-9655-c3d333129b7b.png)'
- en: If you add more Player Start objects into the scene, by default, objects will
    pick a Player Start randomly from the ones available. You can quickly create new
    ones by holding the *Alt* key down and dragging an object in the new direction.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将更多的玩家起始对象添加到场景中，默认情况下，对象将随机从可用的玩家起始对象中选择。你可以通过按住*Alt*键并拖动一个对象到新方向来快速创建新的对象。
- en: Replicating properties over the network
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在网络上复制属性
- en: To ensure that the values are the same on both clients and servers, we use the
    process of replication. In this recipe, we will see just how easy it is to do
    so.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保客户端和服务器上的值相同，我们使用复制的过程。在这个菜谱中，我们将看到这样做是多么简单。
- en: How to do it...
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'For this simple example, let''s create a variable to store how many times each
    player jumps within the game:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个简单的例子，让我们创建一个变量来存储每个玩家在游戏中跳跃的次数：
- en: 'Open up Visual Studio and open the definition for your character for your project
    (in my case, it is `Chapter_12Character.h`). Add the following property and function
    declaration to the file:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Visual Studio 并打开你项目中角色的定义（在我的例子中，它是`Chapter_12Character.h`）。将以下属性和函数声明添加到文件中：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, go to the implementation file and add the following `#include`:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，转到实现文件并添加以下`#include`：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Afterwards, we need to tell the `SetupPlayerInputComponent` method to use our
    version of `Jump` instead of the parent class''s:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们需要告诉`SetupPlayerInputComponent`方法使用我们的`Jump`版本而不是父类的：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, we need to add the following functions:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要添加以下函数：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Save your script and return to the Unreal Editor. Compile your script and play
    your game:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的脚本并返回到虚幻编辑器。编译你的脚本并玩你的游戏：
- en: '![](img/8e4c2455-67e8-4044-8670-e291b73e5eb6.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8e4c2455-67e8-4044-8670-e291b73e5eb6.png)'
- en: Now, whenever either player presses the *spacebar*, you'll see a message displaying
    their name and the value that it will have.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当任意一个玩家按下*空格键*时，你将看到一个显示他们的名字和它将具有的值的消息。
- en: How it works...
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Property replication is simple in theory. Whenever a variable changes its value,
    the network should notify all clients of the change and then update the variable.
    This is often used for things like health, where the value is extremely important
    to know.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 属性复制在理论上很简单。每当变量值发生变化时，网络应该通知所有客户端变化，然后更新变量。这通常用于像健康这样值非常重要的东西。
- en: When you register a variable like this, this variable should only be modified
    by the server and then replicated to the other clients. To mark something to be
    replicated, we use the `Replicated` specifier inside of the `UPROPERTY`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当你注册这样的变量时，这个变量应该只由服务器修改，然后复制到其他客户端。为了标记要复制的项目，我们在`UPROPERTY`中使用`Replicated`指定符。
- en: After marking something as replicated, we have to define a new function called
    `GetLifetimeReplicatedProps`, which does not need to be declared in the header
    file. Inside of this function, we use the `DOREPLIFETIME` macro to state that
    whenever the `JumpCount` variable changes on the server, all clients need to modify
    the value as well.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在标记某个项目为复制后，我们必须定义一个新的函数，称为`GetLifetimeReplicatedProps`，它不需要在头文件中声明。在这个函数内部，我们使用`DOREPLIFETIME`宏来声明，每当服务器上的`JumpCount`变量发生变化时，所有客户端都需要修改该值。
- en: Inside of the `Jump` function, we added in some new functionality, but we first
    check the `Role` variable to determine if something should happen or not. `ROLE_Authority`
    is the highest level, which means that you're the server. This ensures that our
    functionality will only happen once rather than multiple times.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Jump`函数内部，我们添加了一些新的功能，但我们首先检查`Role`变量以确定是否应该发生某些操作。`ROLE_Authority`是最高级别，这意味着你是服务器。这确保了我们的功能只会发生一次，而不是多次。
- en: For replication to work, make sure that the `bReplicates` variable is set to
    `true`. This should be done in the constructor of the class.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使复制工作，请确保将`bReplicates`变量设置为`true`。这应该在类的构造函数中完成。
- en: There's more...
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: 'For those that want to add a bit of optimization to their code, instead of
    our current `DOREPLIFETIME` macro, you could use the following instead:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些想要在代码中添加一些优化的人来说，你可以使用以下替代我们的当前`DOREPLIFETIME`宏：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This makes it so that the value is only replicated on other clients and not
    the original value.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做使得值只在其他客户端复制，而不是原始值。
- en: For more information on `DOREPLIFETIME_CONDITION` and some other tips and tricks
    for networking, check out [https://www.unrealengine.com/en-US/blog/network-tips-and-tricks](https://www.unrealengine.com/en-US/blog/network-tips-and-tricks).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于`DOREPLIFETIME_CONDITION`以及一些关于网络的其他技巧和窍门的信息，请查看[https://www.unrealengine.com/en-US/blog/network-tips-and-tricks](https://www.unrealengine.com/en-US/blog/network-tips-and-tricks)。
- en: Replicating functions over the network
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在网络上复制函数
- en: In this recipe, we will see a nontrivial example of replication in use with
    a simple pickup object that we may want a player to keep track of.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将看到一个非平凡的复制示例，它使用了一个简单的拾取对象，我们可能希望玩家跟踪它。
- en: How to do it...
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'The first step in creating our collectible would be to actually create the
    class we are going to use:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 创建我们的可收集物品的第一步是实际创建我们将要使用的类：
- en: 'Navigate to File | New C++ Class and from there, in the Choose Parent Class
    window, select Actor and then click on Next:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到文件 | 新建C++类，然后在选择父类窗口中，选择Actor，然后点击下一步：
- en: '![](img/8ee5323f-7efd-4090-8af0-c5b49fb19958.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8ee5323f-7efd-4090-8af0-c5b49fb19958.png)'
- en: 'From the next window, set the Name property to `CollectibleObject` and click
    on the Create Class button to add it to the project and compile the base code:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个窗口中，将名称属性设置为`CollectibleObject`，然后点击创建类按钮将其添加到项目中并编译基本代码：
- en: '![](img/80bd2ac8-2cc5-4433-ad39-c66b466c7fe1.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/80bd2ac8-2cc5-4433-ad39-c66b466c7fe1.png)'
- en: 'Once Visual Studio opens up, update `CollectibleObject.h` to the following:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦Visual Studio打开，更新`CollectibleObject.h`到以下内容：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, inside of `CollectibleObject.cpp`, update the constructor of the class
    to the following:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`CollectibleObject.cpp`中，更新类的构造函数到以下内容：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Afterwards, implement the `OnBeginOverlap` function:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，实现`OnBeginOverlap`函数：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, implement the `UpdateScore_Implementation` and `UpdateScore_Validate`
    methods:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，实现`UpdateScore_Implementation`和`UpdateScore_Validate`方法：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Save the scripts and then return to the Unity Editor. Compile your scripts and
    then drag an instance of the `Collectible Object` class into a scene. Save your
    level and play the game using two players, as shown in the previous recipe.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本，然后返回Unity编辑器。编译你的脚本，然后将`Collectible Object`类的一个实例拖拽到场景中。保存你的关卡，并使用两个玩家玩游戏，如前一个食谱所示。
- en: 'Upon collecting the object, you should see a message displayed on the screen:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收集对象后，你应该在屏幕上看到一条消息显示：
- en: '![](img/f52e7aba-4dcd-4cb2-b270-ccdc626fffa7.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f52e7aba-4dcd-4cb2-b270-ccdc626fffa7.png)'
- en: With this, you can see how we can have a message replicated from a server to
    the client!
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，你可以看到消息是如何从服务器复制到客户端的！
- en: How it works...
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the `CollectibleObject` class's constructor, we make sure that our object
    is going to be replicated. After that, we create a sphere collider that we tell
    (via a listener) to call the `OnBeginOverlap` function when it collides with another
    object. To do that, we use the `OnComponentBeginOverlap` function.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CollectibleObject`类的构造函数中，我们确保我们的对象将被复制。之后，我们创建一个球体碰撞器，并通过监听器告诉它当它与另一个对象碰撞时调用`OnBeginOverlap`函数。为此，我们使用`OnComponentBeginOverlap`函数。
- en: For more information on the `OnComponentBeginOverlap` function and the function
    that needs to be given to it, refer to [https://docs.unrealengine.com/latest/INT/API/
    Runtime/Engine/Components/UPrimitiveComponent/ OnComponentBeginOverlap/index.html](https://docs.unrealengine.com/latest/INT/API/%20Runtime/Engine/Components/UPrimitiveComponent/%20OnComponentBeginOverlap/index.html).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于`OnComponentBeginOverlap`函数以及需要提供给它的函数的信息，请参阅[https://docs.unrealengine.com/latest/INT/API/%20Runtime/Engine/Components/UPrimitiveComponent/%20OnComponentBeginOverlap/index.html](https://docs.unrealengine.com/latest/INT/API/%20Runtime/Engine/Components/UPrimitiveComponent/%20OnComponentBeginOverlap/index.html)。
- en: After this, inside our `OnBeginOverlap` function, we first check if we are currently
    on the server. We don't want things to get called multiple times, and we want
    the server to be the one that tells the other clients that we've increased our
    score.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，在我们的`OnBeginOverlap`函数内部，我们首先检查我们是否目前在服务器上。我们不希望事情被多次调用，并且我们希望服务器是告诉其他客户端我们已经增加了我们的分数的那个。
- en: 'We also call the `UpdateScore` function. This function has had the following
    function specifiers added to it:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还调用了`UpdateScore`函数。此函数已添加以下函数指定符：
- en: '`Reliable`: The function will be replicated over the network and make it so
    that it is guaranteed to arrive, regardless of network errors or bandwidth issues.
    It requires us to select either `Client` or `Server` as an additional specifier.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Reliable`：该函数将通过网络复制，并确保它能够到达，无论网络错误或带宽问题。它要求我们选择`Client`或`Server`作为额外的指定符。'
- en: '`Server`: Specifies that the function should only be called on the server.
    Adds an additional function that has `_Implementation` at the end of it, which
    is where the implementation should happen. The automatically generated code will
    use this function as needed.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Server`: 指定该函数只能在服务器上调用。它会在函数末尾添加一个名为 `_Implementation` 的附加函数，这是实现应该发生的地方。自动生成的代码将根据需要使用此函数。'
- en: '`WithValidation`: Adds an additional function that needs to be implemented
    with `_Validate` at the end. This function will take in the same parameters as
    the function given, but will return a bool that indicates whether the call to
    the main function should happen or not.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WithValidation`: 添加一个需要以 `_Validate` 结尾实现的附加函数。此函数将接受与给定函数相同的参数，但将返回一个布尔值，指示是否应该调用主函数。'
- en: For more information on the other function specifiers, such as `Unreliable`,
    check out [https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Functions#functionspecifiers](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Functions#functionspecifiers).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 关于其他函数指定符（如 `Unreliable`）的更多信息，请参阅 [https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Functions#functionspecifiers](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Functions#functionspecifiers)。
- en: Calling `UpdateScore` will, in turn, call the `UpdateScore_Implementation` function
    that we created and it will display a message, saying that we've collected the
    object by printing out some text like we used earlier.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `UpdateScore` 将会依次调用我们创建的 `UpdateScore_Implementation` 函数，并显示一条消息，说明我们已经通过打印一些类似我们之前使用的文本收集了对象。
- en: Finally, the `UpdateScore_Validate` function is required and just tells the
    game that we should always run the implementation for the `UpdateScore` function.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，需要 `UpdateScore_Validate` 函数，它只是告诉游戏我们应始终运行 `UpdateScore` 函数的实现。
- en: For some recommendations on performance and bandwidth settings that may be useful
    for working with levels with a lot of replication, check out the following link: [https://docs.unrealengine.com/en-US/Gameplay/Networking/Actors/ReplicationPerformance](https://docs.unrealengine.com/en-US/Gameplay/Networking/Actors/ReplicationPerformance).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些关于性能和带宽设置的推荐，这些设置可能对处理大量复制的关卡很有用，请查看以下链接：[https://docs.unrealengine.com/en-US/Gameplay/Networking/Actors/ReplicationPerformance](https://docs.unrealengine.com/en-US/Gameplay/Networking/Actors/ReplicationPerformance)。
- en: See also...
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见...
- en: If you're interested in seeing another example of using networking and replication,
    refer to [https://wiki.unrealengine.com/ Networking/Replication](https://wiki.unrealengine.com/%20Networking/Replication).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要查看使用网络和复制的另一个示例，请参阅 [https://wiki.unrealengine.com/ Networking/Replication](https://wiki.unrealengine.com/%20Networking/Replication)。
- en: In addition, you can also check out the Shooter Game example project included
    with Unreal Engine 4 and read the files to get a feeling for how it's used in
    a complete example. To read more about that, check out [https://docs.unrealengine.com/en-us/Resources/SampleGames/ShooterGame](https://docs.unrealengine.com/en-us/Resources/SampleGames/ShooterGame).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还可以查看 Unreal Engine 4 中包含的 Shooter Game 示例项目，并阅读文件以了解它在完整示例中的使用方式。要了解更多信息，请参阅
    [https://docs.unrealengine.com/en-us/Resources/SampleGames/ShooterGame](https://docs.unrealengine.com/en-us/Resources/SampleGames/ShooterGame)。
- en: Handling UI network events
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理 UI 网络事件
- en: Since each player has their own screen, it makes sense that their UI will only
    display information that is relevant to them. In this recipe, we will see how
    to handle UI network events.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个玩家都有自己的屏幕，因此他们的 UI 只会显示与他们相关的信息是有意义的。在这个配方中，我们将了解如何处理 UI 网络事件。
- en: Getting ready...
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作...
- en: You should complete the *Replication properties over the network* recipe in
    this chapter, as well as be familiar with creating HUDs, which you can learn more
    about in [Chapter 14](a9e9a3c4-2fde-4024-a960-7eb8cc05518b.xhtml), *User Interfaces
    – UI and UMG*.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该完成本章中关于 *网络上的复制属性* 的配方，以及熟悉创建 HUD，你可以在第 14 章 *用户界面 – UI 和 UMG* 中了解更多信息。
- en: How to do it...
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'From your Visual Studio project (File | Open Visual Studio), open the `Source\<Module>` folder
    and from there, open the `<Module>.build.cs` file (in my case, it would be `Source\Chapter_12\Chapter_12.build.cs`)
    and uncomment/add the following line of code:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从你的 Visual Studio 项目（文件 | 打开 Visual Studio），打开 `Source\<Module>` 文件夹，然后从那里打开
    `<Module>.build.cs` 文件（在我的情况下，将是 `Source\Chapter_12\Chapter_12.build.cs`），并取消注释/添加以下代码行：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create a new `HUD` subclass using the Add C++ Class wizard:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Add C++ Class 向导创建一个新的 `HUD` 子类：
- en: '![](img/7af1e6e1-6019-4ef6-9aa4-93e727b3893c.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7af1e6e1-6019-4ef6-9aa4-93e727b3893c.png)'
- en: 'When asked for the name, put in `NetworkHUD`, and click on the Create Class button:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当被要求输入名称时，输入`NetworkHUD`，然后点击创建类按钮：
- en: '![](img/7409fcc2-be62-42bd-8a51-b50a2d9970f6.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7409fcc2-be62-42bd-8a51-b50a2d9970f6.png)'
- en: 'Once created, open up a `GameMode` that you are planning on using (I''m using
    the `Chapter_12GameMode.cpp` file) and add the following to the constructor implementation:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建完成后，打开您计划使用的`GameMode`（我使用的是`Chapter_12GameMode.cpp`文件），并将以下内容添加到构造函数实现中：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Inside `NetworkHUD.h`, add the following function with the `override` keyword
    to the class:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`NetworkHUD.h`中，使用`override`关键字向类中添加以下函数：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, implement the function:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，实现该函数：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, we can comment out the original debug message since our HUD will handle
    it for us:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以取消注释原始调试消息，因为我们的HUD将为我们处理它：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Compile your code and launch the editor.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译您的代码并启动编辑器。
- en: 'Within the editor, open the World Settings panel from the Settings drop-down
    menu:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中，从“设置”下拉菜单中打开“世界设置”面板：
- en: '![](img/a304cb34-ba25-4de7-b4d2-b76012b1d7d8.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a304cb34-ba25-4de7-b4d2-b76012b1d7d8.jpg)'
- en: 'In the World Settings dialog, select `Chapter_12GameMode` from the list under GameMode
    Override:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“世界设置”对话框中，从“游戏模式覆盖”下的列表中选择`Chapter_12GameMode`：
- en: '![](img/10cffe4c-4ab4-4532-90f9-46b7331710a0.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/10cffe4c-4ab4-4532-90f9-46b7331710a0.png)'
- en: 'Play and verify that your custom HUD is drawing to the screen and that each
    character has their own jump value:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放并验证您的自定义HUD是否已绘制到屏幕上，并且每个角色都有自己的跳跃值：
- en: '![](img/edabde91-00da-49d0-b5a1-a16ce3d0c00f.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/edabde91-00da-49d0-b5a1-a16ce3d0c00f.png)'
- en: And with that, we can take these concepts to display any property that is being
    replicated!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些概念，我们可以显示任何正在复制的属性！
- en: How it works...
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `GetOwningPawn` method will return a pointer to the `Pawn` class the HUD
    is attached to. We cast that to our custom character-derived class and then can
    access the properties that the class has. In our case, we are using the variable
    that we previously added a `Replicated` tag to, which allows the HUD to update
    properly, depending on which screen we are using.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetOwningPawn`方法将返回一个指向HUD附加的`Pawn`类的指针。我们将它转换为我们的自定义角色派生类，然后可以访问该类具有的属性。在我们的例子中，我们使用的是之前添加了`Replicated`标签的变量，这使得HUD能够根据我们使用的屏幕正确更新。'
- en: For more information and additional examples of replication in use, check out [https://wiki.unrealengine.com/Replication](https://wiki.unrealengine.com/Replication).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息和复制的使用示例，请查看[https://wiki.unrealengine.com/Replication](https://wiki.unrealengine.com/Replication)。
- en: See also...
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见...
- en: For those that would like to learn more about networking with Unreal Engine
    4, Cedric 'eXi' Neukirchen has created a great guide that I recommend reading.
    You can find that at [http://cedric-neukirchen.net/Downloads/Compendium/UE4_Network_Compendium_by_Cedric_eXi_Neukirchen.pdf](http://cedric-neukirchen.net/Downloads/Compendium/UE4_Network_Compendium_by_Cedric_eXi_Neukirchen.pdf).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 对于想要了解更多关于使用Unreal Engine 4进行网络编程的人来说，Cedric 'eXi' Neukirchen创建了一个非常好的指南，我推荐阅读。您可以在[http://cedric-neukirchen.net/Downloads/Compendium/UE4_Network_Compendium_by_Cedric_eXi_Neukirchen.pdf](http://cedric-neukirchen.net/Downloads/Compendium/UE4_Network_Compendium_by_Cedric_eXi_Neukirchen.pdf)找到它。
