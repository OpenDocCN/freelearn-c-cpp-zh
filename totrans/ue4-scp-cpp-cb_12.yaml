- en: Multiplayer Networking in UE4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Testing your game as a client and a server simultaneously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replicating properties over the network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replicating functions over the network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling UI network events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Networking is one of the more complex things you can do as a programmer. Thankfully,
    Unreal Engine has been designed with networking in mind since the original Unreal
    Engine released in 1998\. Unreal uses a client-server model for communication
    between multiple computers. In this case, the **server** is the person who started
    the game and the **clients** are those who are playing the game with the first
    person. For things that are happening in everyone's game to work correctly, we
    need to call certain code at certain times for certain people.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when a client wants to shoot his/her gun, they send a message to
    the server, which will then determine whether they hit anything and then tells
    all the clients what happened using replication. This can be important because
    some things, such as the game mode, only exist on the server.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on the client-server model, check out [https://en.wikipedia.org/wiki/Client%E2%80%93server_model](https://en.wikipedia.org/wiki/Client%E2%80%93server_model).
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are going to want to see multiple characters on the screen, in this
    chapter, we will be using a base project based on the Third Person C++ template:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/641e12f8-c70e-4e03-a8df-9670db5bc80a.png)'
  prefs: []
  type: TYPE_IMG
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires the use of Unreal Engine 4 and uses Visual Studio 2017
    as the IDE. Instructions on how to install both pieces of software and the requirements
    for them can be found in [Chapter 1](4adb307e-d86f-4d70-b6de-a0893102d1cf.xhtml),
    *UE4 Development Tools*, of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Testing your game as a client and a server simultaneously
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working on networked games, it's always a good idea to test your project
    often. Instead of having to use two separate computers, Unreal comes with an easy
    way to play a game with multiple players at the same time built in.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Generally, when we play the game, we only have one player on the screen. We
    can modify this with the Play settings:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the Unreal Editor, with the `ThirdPersonExampleMap` open, click on the
    arrow drop-down next to the Play button. Under there, set the Number of Players
    property to `2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8ed662ce-096e-4c08-b745-d45fa8545243.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Afterwards, click on the Play button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b9faaf92-6b73-479c-8729-74858e85eecc.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you now have two windows added to the screen!
  prefs: []
  type: TYPE_NORMAL
- en: Remember that you can return mouse control from a window by pressing *Shift*
    + *F1*.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to the character that is also placed in the scene, there is another
    object within the world called `NetworkPlayerStart`, which is where networked
    players will be spawned:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9cc559e3-4292-4166-9655-c3d333129b7b.png)'
  prefs: []
  type: TYPE_IMG
- en: If you add more Player Start objects into the scene, by default, objects will
    pick a Player Start randomly from the ones available. You can quickly create new
    ones by holding the *Alt* key down and dragging an object in the new direction.
  prefs: []
  type: TYPE_NORMAL
- en: Replicating properties over the network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To ensure that the values are the same on both clients and servers, we use the
    process of replication. In this recipe, we will see just how easy it is to do
    so.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this simple example, let''s create a variable to store how many times each
    player jumps within the game:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up Visual Studio and open the definition for your character for your project
    (in my case, it is `Chapter_12Character.h`). Add the following property and function
    declaration to the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, go to the implementation file and add the following `#include`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Afterwards, we need to tell the `SetupPlayerInputComponent` method to use our
    version of `Jump` instead of the parent class''s:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to add the following functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Save your script and return to the Unreal Editor. Compile your script and play
    your game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8e4c2455-67e8-4044-8670-e291b73e5eb6.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, whenever either player presses the *spacebar*, you'll see a message displaying
    their name and the value that it will have.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Property replication is simple in theory. Whenever a variable changes its value,
    the network should notify all clients of the change and then update the variable.
    This is often used for things like health, where the value is extremely important
    to know.
  prefs: []
  type: TYPE_NORMAL
- en: When you register a variable like this, this variable should only be modified
    by the server and then replicated to the other clients. To mark something to be
    replicated, we use the `Replicated` specifier inside of the `UPROPERTY`.
  prefs: []
  type: TYPE_NORMAL
- en: After marking something as replicated, we have to define a new function called
    `GetLifetimeReplicatedProps`, which does not need to be declared in the header
    file. Inside of this function, we use the `DOREPLIFETIME` macro to state that
    whenever the `JumpCount` variable changes on the server, all clients need to modify
    the value as well.
  prefs: []
  type: TYPE_NORMAL
- en: Inside of the `Jump` function, we added in some new functionality, but we first
    check the `Role` variable to determine if something should happen or not. `ROLE_Authority`
    is the highest level, which means that you're the server. This ensures that our
    functionality will only happen once rather than multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: For replication to work, make sure that the `bReplicates` variable is set to
    `true`. This should be done in the constructor of the class.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For those that want to add a bit of optimization to their code, instead of
    our current `DOREPLIFETIME` macro, you could use the following instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This makes it so that the value is only replicated on other clients and not
    the original value.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on `DOREPLIFETIME_CONDITION` and some other tips and tricks
    for networking, check out [https://www.unrealengine.com/en-US/blog/network-tips-and-tricks](https://www.unrealengine.com/en-US/blog/network-tips-and-tricks).
  prefs: []
  type: TYPE_NORMAL
- en: Replicating functions over the network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will see a nontrivial example of replication in use with
    a simple pickup object that we may want a player to keep track of.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first step in creating our collectible would be to actually create the
    class we are going to use:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to File | New C++ Class and from there, in the Choose Parent Class
    window, select Actor and then click on Next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8ee5323f-7efd-4090-8af0-c5b49fb19958.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From the next window, set the Name property to `CollectibleObject` and click
    on the Create Class button to add it to the project and compile the base code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/80bd2ac8-2cc5-4433-ad39-c66b466c7fe1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once Visual Studio opens up, update `CollectibleObject.h` to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, inside of `CollectibleObject.cpp`, update the constructor of the class
    to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Afterwards, implement the `OnBeginOverlap` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, implement the `UpdateScore_Implementation` and `UpdateScore_Validate`
    methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Save the scripts and then return to the Unity Editor. Compile your scripts and
    then drag an instance of the `Collectible Object` class into a scene. Save your
    level and play the game using two players, as shown in the previous recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Upon collecting the object, you should see a message displayed on the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f52e7aba-4dcd-4cb2-b270-ccdc626fffa7.png)'
  prefs: []
  type: TYPE_IMG
- en: With this, you can see how we can have a message replicated from a server to
    the client!
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the `CollectibleObject` class's constructor, we make sure that our object
    is going to be replicated. After that, we create a sphere collider that we tell
    (via a listener) to call the `OnBeginOverlap` function when it collides with another
    object. To do that, we use the `OnComponentBeginOverlap` function.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on the `OnComponentBeginOverlap` function and the function
    that needs to be given to it, refer to [https://docs.unrealengine.com/latest/INT/API/
    Runtime/Engine/Components/UPrimitiveComponent/ OnComponentBeginOverlap/index.html](https://docs.unrealengine.com/latest/INT/API/%20Runtime/Engine/Components/UPrimitiveComponent/%20OnComponentBeginOverlap/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: After this, inside our `OnBeginOverlap` function, we first check if we are currently
    on the server. We don't want things to get called multiple times, and we want
    the server to be the one that tells the other clients that we've increased our
    score.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also call the `UpdateScore` function. This function has had the following
    function specifiers added to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Reliable`: The function will be replicated over the network and make it so
    that it is guaranteed to arrive, regardless of network errors or bandwidth issues.
    It requires us to select either `Client` or `Server` as an additional specifier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Server`: Specifies that the function should only be called on the server.
    Adds an additional function that has `_Implementation` at the end of it, which
    is where the implementation should happen. The automatically generated code will
    use this function as needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WithValidation`: Adds an additional function that needs to be implemented
    with `_Validate` at the end. This function will take in the same parameters as
    the function given, but will return a bool that indicates whether the call to
    the main function should happen or not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on the other function specifiers, such as `Unreliable`,
    check out [https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Functions#functionspecifiers](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Functions#functionspecifiers).
  prefs: []
  type: TYPE_NORMAL
- en: Calling `UpdateScore` will, in turn, call the `UpdateScore_Implementation` function
    that we created and it will display a message, saying that we've collected the
    object by printing out some text like we used earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `UpdateScore_Validate` function is required and just tells the
    game that we should always run the implementation for the `UpdateScore` function.
  prefs: []
  type: TYPE_NORMAL
- en: For some recommendations on performance and bandwidth settings that may be useful
    for working with levels with a lot of replication, check out the following link: [https://docs.unrealengine.com/en-US/Gameplay/Networking/Actors/ReplicationPerformance](https://docs.unrealengine.com/en-US/Gameplay/Networking/Actors/ReplicationPerformance).
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you're interested in seeing another example of using networking and replication,
    refer to [https://wiki.unrealengine.com/ Networking/Replication](https://wiki.unrealengine.com/%20Networking/Replication).
  prefs: []
  type: TYPE_NORMAL
- en: In addition, you can also check out the Shooter Game example project included
    with Unreal Engine 4 and read the files to get a feeling for how it's used in
    a complete example. To read more about that, check out [https://docs.unrealengine.com/en-us/Resources/SampleGames/ShooterGame](https://docs.unrealengine.com/en-us/Resources/SampleGames/ShooterGame).
  prefs: []
  type: TYPE_NORMAL
- en: Handling UI network events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since each player has their own screen, it makes sense that their UI will only
    display information that is relevant to them. In this recipe, we will see how
    to handle UI network events.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should complete the *Replication properties over the network* recipe in
    this chapter, as well as be familiar with creating HUDs, which you can learn more
    about in [Chapter 14](a9e9a3c4-2fde-4024-a960-7eb8cc05518b.xhtml), *User Interfaces
    – UI and UMG*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From your Visual Studio project (File | Open Visual Studio), open the `Source\<Module>` folder
    and from there, open the `<Module>.build.cs` file (in my case, it would be `Source\Chapter_12\Chapter_12.build.cs`)
    and uncomment/add the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `HUD` subclass using the Add C++ Class wizard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7af1e6e1-6019-4ef6-9aa4-93e727b3893c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When asked for the name, put in `NetworkHUD`, and click on the Create Class button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7409fcc2-be62-42bd-8a51-b50a2d9970f6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once created, open up a `GameMode` that you are planning on using (I''m using
    the `Chapter_12GameMode.cpp` file) and add the following to the constructor implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside `NetworkHUD.h`, add the following function with the `override` keyword
    to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, implement the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can comment out the original debug message since our HUD will handle
    it for us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Compile your code and launch the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Within the editor, open the World Settings panel from the Settings drop-down
    menu:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a304cb34-ba25-4de7-b4d2-b76012b1d7d8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the World Settings dialog, select `Chapter_12GameMode` from the list under GameMode
    Override:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/10cffe4c-4ab4-4532-90f9-46b7331710a0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Play and verify that your custom HUD is drawing to the screen and that each
    character has their own jump value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/edabde91-00da-49d0-b5a1-a16ce3d0c00f.png)'
  prefs: []
  type: TYPE_IMG
- en: And with that, we can take these concepts to display any property that is being
    replicated!
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `GetOwningPawn` method will return a pointer to the `Pawn` class the HUD
    is attached to. We cast that to our custom character-derived class and then can
    access the properties that the class has. In our case, we are using the variable
    that we previously added a `Replicated` tag to, which allows the HUD to update
    properly, depending on which screen we are using.
  prefs: []
  type: TYPE_NORMAL
- en: For more information and additional examples of replication in use, check out [https://wiki.unrealengine.com/Replication](https://wiki.unrealengine.com/Replication).
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For those that would like to learn more about networking with Unreal Engine
    4, Cedric 'eXi' Neukirchen has created a great guide that I recommend reading.
    You can find that at [http://cedric-neukirchen.net/Downloads/Compendium/UE4_Network_Compendium_by_Cedric_eXi_Neukirchen.pdf](http://cedric-neukirchen.net/Downloads/Compendium/UE4_Network_Compendium_by_Cedric_eXi_Neukirchen.pdf).
  prefs: []
  type: TYPE_NORMAL
