["```cpp\ngit clone https://github.com/codeplea/Hands-On-Network-Programming-with-C\ncd Hands-On-Network-Programming-with-C/chap04\n```", "```cpp\n#if defined(_WIN32)\n#ifndef _WIN32_WINNT\n#define _WIN32_WINNT 0x0600\n#endif\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#pragma comment(lib, \"ws2_32.lib\")\n\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <unistd.h>\n#include <errno.h>\n\n#endif\n\n#if defined(_WIN32)\n#define ISVALIDSOCKET(s) ((s) != INVALID_SOCKET)\n#define CLOSESOCKET(s) closesocket(s)\n#define GETSOCKETERRNO() (WSAGetLastError())\n\n#else\n#define ISVALIDSOCKET(s) ((s) >= 0)\n#define CLOSESOCKET(s) close(s)\n#define SOCKET int\n#define GETSOCKETERRNO() (errno)\n#endif\n\n#include <stdio.h>\n#include <string.h>\n```", "```cpp\nhints.ai_socktype = SOCK_STREAM;\n```", "```cpp\nhints.ai_socktype = SOCK_DGRAM;\n```", "```cpp\nconnect(tcp_socket, peer_address, peer_address_length);\nsend(tcp_socket, data, data_length, 0);\n```", "```cpp\nsendto(udp_socket, data, data_length, 0,\n        peer_address, peer_address_length);\n```", "```cpp\n/*udp_recvfrom.c*/\n\n#include \"chap04.h\"\n\nint main() {\n\n#if defined(_WIN32)\n    WSADATA d;\n    if (WSAStartup(MAKEWORD(2, 2), &d)) {\n        fprintf(stderr, \"Failed to initialize.\\n\");\n        return 1;\n    }\n#endif\n```", "```cpp\n/*udp_recvfrom.c continued*/\n\n    printf(\"Configuring local address...\\n\");\n    struct addrinfo hints;\n    memset(&hints, 0, sizeof(hints));\n    hints.ai_family = AF_INET;\n    hints.ai_socktype = SOCK_DGRAM;\n    hints.ai_flags = AI_PASSIVE;\n\n    struct addrinfo *bind_address;\n    getaddrinfo(0, \"8080\", &hints, &bind_address);\n```", "```cpp\n/*udp_recvfrom.c continued*/\n\n    printf(\"Creating socket...\\n\");\n    SOCKET socket_listen;\n    socket_listen = socket(bind_address->ai_family,\n            bind_address->ai_socktype, bind_address->ai_protocol);\n    if (!ISVALIDSOCKET(socket_listen)) {\n        fprintf(stderr, \"socket() failed. (%d)\\n\", GETSOCKETERRNO());\n        return 1;\n    }\n```", "```cpp\n/*udp_recvfrom.c continued*/\n\n    printf(\"Binding socket to local address...\\n\");\n    if (bind(socket_listen,\n                bind_address->ai_addr, bind_address->ai_addrlen)) {\n        fprintf(stderr, \"bind() failed. (%d)\\n\", GETSOCKETERRNO());\n        return 1;\n    }\n    freeaddrinfo(bind_address);\n```", "```cpp\n/*udp_recvfrom.c continued*/\n\n    struct sockaddr_storage client_address;\n    socklen_t client_len = sizeof(client_address);\n    char read[1024];\n    int bytes_received = recvfrom(socket_listen,\n            read, 1024,\n            0,\n            (struct sockaddr*) &client_address, &client_len);\n```", "```cpp\n/*udp_recvfrom.c continued*/\n\n    printf(\"Received (%d bytes): %.*s\\n\",\n            bytes_received, bytes_received, read);\n```", "```cpp\n/*udp_recvfrom.c continued*/\n\n    printf(\"Remote address is: \");\n    char address_buffer[100];\n    char service_buffer[100];\n    getnameinfo(((struct sockaddr*)&client_address),\n            client_len,\n            address_buffer, sizeof(address_buffer),\n            service_buffer, sizeof(service_buffer),\n            NI_NUMERICHOST | NI_NUMERICSERV);\n    printf(\"%s %s\\n\", address_buffer, service_buffer);\n```", "```cpp\n/*udp_recvfrom.c continued*/\n\n    CLOSESOCKET(socket_listen);\n\n#if defined(_WIN32)\n    WSACleanup();\n#endif\n\n    printf(\"Finished.\\n\");\n    return 0;\n}\n```", "```cpp\ngcc udp_recvfrom.c -o udp_recvfrom\n./udp_recvfrom\n```", "```cpp\ngcc udp_recvfrom.c -o udp_recvfrom.exe -lws2_32\nudp_recvfrom.exe\n```", "```cpp\n/*udp_sendto.c*/\n\n#include \"chap04.h\"\n\nint main() {\n\n#if defined(_WIN32)\n    WSADATA d;\n    if (WSAStartup(MAKEWORD(2, 2), &d)) {\n        fprintf(stderr, \"Failed to initialize.\\n\");\n        return 1;\n    }\n#endif\n```", "```cpp\n/*udp_sendto.c continued*/\n\n    printf(\"Configuring remote address...\\n\");\n    struct addrinfo hints;\n    memset(&hints, 0, sizeof(hints));\n    hints.ai_socktype = SOCK_DGRAM;\n    struct addrinfo *peer_address;\n    if (getaddrinfo(\"127.0.0.1\", \"8080\", &hints, &peer_address)) {\n        fprintf(stderr, \"getaddrinfo() failed. (%d)\\n\", GETSOCKETERRNO());\n        return 1;\n    }\n```", "```cpp\n/*udp_sendto.c continued*/\n\n    printf(\"Remote address is: \");\n    char address_buffer[100];\n    char service_buffer[100];\n    getnameinfo(peer_address->ai_addr, peer_address->ai_addrlen,\n            address_buffer, sizeof(address_buffer),\n            service_buffer, sizeof(service_buffer),\n            NI_NUMERICHOST  | NI_NUMERICSERV);\n    printf(\"%s %s\\n\", address_buffer, service_buffer);\n```", "```cpp\n/*udp_sendto.c continued*/\n\n    printf(\"Creating socket...\\n\");\n    SOCKET socket_peer;\n    socket_peer = socket(peer_address->ai_family,\n            peer_address->ai_socktype, peer_address->ai_protocol);\n    if (!ISVALIDSOCKET(socket_peer)) {\n        fprintf(stderr, \"socket() failed. (%d)\\n\", GETSOCKETERRNO());\n        return 1;\n    }\n```", "```cpp\n/*udp_sendto.c continued*/\n\n    const char *message = \"Hello World\";\n    printf(\"Sending: %s\\n\", message);\n    int bytes_sent = sendto(socket_peer,\n            message, strlen(message),\n            0,\n            peer_address->ai_addr, peer_address->ai_addrlen);\n    printf(\"Sent %d bytes.\\n\", bytes_sent);\n```", "```cpp\n/*udp_sendto.c continued*/\n\n    freeaddrinfo(peer_address);\n    CLOSESOCKET(socket_peer);\n\n#if defined(_WIN32)\n    WSACleanup();\n#endif\n\n    printf(\"Finished.\\n\");\n    return 0;\n}\n```", "```cpp\ngcc udp_sendto.c -o udp_sendto\n```", "```cpp\ngcc udp_sendto.c -o udp_sendto.exe -lws2_32\n```", "```cpp\n/*udp_serve_toupper.c*/\n\n#include \"chap04.h\"\n#include <ctype.h>\n\nint main() {\n\n#if defined(_WIN32)\n    WSADATA d;\n    if (WSAStartup(MAKEWORD(2, 2), &d)) {\n        fprintf(stderr, \"Failed to initialize.\\n\");\n        return 1;\n    }\n#endif\n```", "```cpp\n/*udp_serve_toupper.c continued*/\n\n    printf(\"Configuring local address...\\n\");\n    struct addrinfo hints;\n    memset(&hints, 0, sizeof(hints));\n    hints.ai_family = AF_INET;\n    hints.ai_socktype = SOCK_DGRAM;\n    hints.ai_flags = AI_PASSIVE;\n\n    struct addrinfo *bind_address;\n    getaddrinfo(0, \"8080\", &hints, &bind_address);\n\n    printf(\"Creating socket...\\n\");\n    SOCKET socket_listen;\n    socket_listen = socket(bind_address->ai_family,\n            bind_address->ai_socktype, bind_address->ai_protocol);\n    if (!ISVALIDSOCKET(socket_listen)) {\n        fprintf(stderr, \"socket() failed. (%d)\\n\", GETSOCKETERRNO());\n        return 1;\n    }\n\n```", "```cpp\n/*udp_serve_toupper.c continued*/\n\n    printf(\"Binding socket to local address...\\n\");\n    if (bind(socket_listen,\n                bind_address->ai_addr, bind_address->ai_addrlen)) {\n        fprintf(stderr, \"bind() failed. (%d)\\n\", GETSOCKETERRNO());\n        return 1;\n    }\n    freeaddrinfo(bind_address);\n```", "```cpp\n/*udp_serve_toupper.c continued*/\n\n    fd_set master;\n    FD_ZERO(&master);\n    FD_SET(socket_listen, &master);\n    SOCKET max_socket = socket_listen;\n\n    printf(\"Waiting for connections...\\n\");\n```", "```cpp\n/*udp_serve_toupper.c continued*/\n\n    while(1) {\n        fd_set reads;\n        reads = master;\n        if (select(max_socket+1, &reads, 0, 0, 0) < 0) {\n            fprintf(stderr, \"select() failed. (%d)\\n\", GETSOCKETERRNO());\n            return 1;\n        }\n\n        if (FD_ISSET(socket_listen, &reads)) {\n            struct sockaddr_storage client_address;\n            socklen_t client_len = sizeof(client_address);\n\n            char read[1024];\n            int bytes_received = recvfrom(socket_listen, read, 1024, 0,\n                    (struct sockaddr *)&client_address, &client_len);\n            if (bytes_received < 1) {\n                fprintf(stderr, \"connection closed. (%d)\\n\",\n                        GETSOCKETERRNO());\n                return 1;\n            }\n\n            int j;\n            for (j = 0; j < bytes_received; ++j)\n                read[j] = toupper(read[j]);\n            sendto(socket_listen, read, bytes_received, 0,\n                    (struct sockaddr*)&client_address, client_len);\n\n        } //if FD_ISSET\n    } //while(1)\n```", "```cpp\n/*udp_serve_toupper.c continued*/\n\n    printf(\"Closing listening socket...\\n\");\n    CLOSESOCKET(socket_listen);\n\n#if defined(_WIN32)\n    WSACleanup();\n#endif\n\n    printf(\"Finished.\\n\");\n\n    return 0;\n}\n```", "```cpp\ngcc udp_serve_toupper.c -o udp_serve_toupper\n./udp_serve_toupper\n```", "```cpp\ngcc udp_serve_toupper.c -o udp_serve_toupper.exe -lws2_32\nudp_serve_toupper.exe\n```", "```cpp\nudp_client 127.0.0.1 8080\n```"]