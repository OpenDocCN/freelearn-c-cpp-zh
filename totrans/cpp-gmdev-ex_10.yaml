- en: Building on the Game Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: n the last chapter, we looked at how to draw basic shapes using OpenGL. Now
    that we have covered the basics, let's improve our objects by adding some textures
    to them so that the objects don't just look like a plain cube and sphere.
  prefs: []
  type: TYPE_NORMAL
- en: We can write our physics as we did last time, but when dealing with 3D objects,
    writing our own physics can become difficult and time consuming. To simplify the
    process, we will use the help of an external physics library to handle the physics
    and collision detection.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the `MeshRenderer` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the `TextureLoader` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding Bullet Physics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding rigid bodies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the MeshRenderer class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For drawing regular game objects, we will create a separate class from the `LightRenderer`
    class by adding texture, and we will also add motion to the object by adding physical
    properties. We will draw a textured object and then add physics to this object
    in the next section of this chapter. To do this, we will create a new `.h` and
    `.cpp` file called `MeshRenderer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `MeshRenderer.h` file, we will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will add the includes as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will create the class itself as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We will create the `public` section first as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we create the constructor, which takes a `ModelType` and the
    `_camera`. We add the destructor afterward. We have a separate function for drawing
    the object.
  prefs: []
  type: TYPE_NORMAL
- en: We then use some `setter` functions to set the position, scale, the shader program,
    and the `textureID` function , which we will be using to set the texture on the
    object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we will add the `private` section as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the `private` section, we have vectors to store the vertices and the indices.
    Then, we have a `glm::mat4` variable called `modelMatrix` to store the model matrix
    value in.
  prefs: []
  type: TYPE_NORMAL
- en: We create a local variable for the camera and `vec3s` for storing the position
    and scale value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we have `Gluint` to store `vao`, `vbo`, `ebo`, `textureID`, and the
    shader program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will now move on to setting up the `MeshRenderer.cpp` file by going through
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we will include the `MeshRenderer.h` file at the top of `MeshRenderer.cpp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we will create the constructor for `MeshRenderer` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'For this, we first initialize the `camera`, `position`, and `scale` local values
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we create a `switch` statement, as we did in `LightRenderer`, to get the
    mesh data, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we generate and bind `vao`, `vbo`, and `ebo`. In addition to this, we
    set the data for `vbo` and `ebo` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The next step is to set the attributes. In this case, we will be setting the
    `position` attribute, but instead of color, we will set the texture coordinate
    attribute, as it will be required to set the texture on top of the object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The attribute at the 0th index will still be a vertex position, but the attribute
    of the first index will be a texture coordinate this time, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, the attribute for the vertex position remains the same, but for the texture
    coordinate, the first index is enabled as before. The change occurs in the number
    of components. The texture coordinate is defined in the *x*- and *y*-axes, as
    this is a 2D texture, so for the second parameter, we specify `2` instead of `3`.
    The stride still remains the same, but the offset is changed to `texCoords`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To close the constructor, we unbind the buffers and `vertexArray` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We now add the `draw` function as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In this `draw` function, we will first set the model matrix as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We will create two matrices for storing `translationMatrix` and `scaleMatrix`
    and then we set the values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will then initialize the `modelMatrix` variable and the multiply scale and
    translation matrix and assign them to the `modelMatrix` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, instead of creating a separate view and projection matrix, we can create
    a single matrix called `vp` and assign the multiplied view and projection matrices
    to it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, the order in which the view and projection matrices are multiplied
    matters and cannot be reversed.
  prefs: []
  type: TYPE_NORMAL
- en: We can now send the values to the GPU.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before we send the values to the shader, the first thing we have to do is call
    `glUseProgram` and set the shader program so that the data is sent to the correct
    program. Once this is complete, we can set the values for `vp` and `modelMatrix`
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will bind the `texture` object. We use the `glBindTexture` function
    to bind the texture. The function takes two parameters, with the first being the
    texture target. We have a 2D texture, so we pass in `GL_TEXTURE_2D` as the first
    parameter and the second parameter as a texture ID. To do this, we add the following
    line to bind the texture:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You might be wondering why we aren't using `glUniformMatrix4fv` or something
    similar while setting the texture location, as we did for the matrices. Well,
    since we have just the one texture, the program sets the uniform location as the
    0th index by default so we don't have to worry about it. This all that we require
    to bind the texture.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can bind the `vao` and draw the object as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Unbind the `VertexArray` at the end as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will add the definition for the destructor and `setters` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Creating the TextureLoader class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We created the `MeshRenderer` class, but we still need to load the texture and
    set the texture ID, which can be passed to the `MeshRendered` object. For this,
    we will create a `TextureLoader` class that will be responsible for loading the
    textures. Let's see how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: We first need to create the new `.h` and `.cpp` file called `TextureLoader`.
  prefs: []
  type: TYPE_NORMAL
- en: To load the JPEG or PNG image, we will use a header-only library called STB.
    This can be downloaded from [https://github.com/nothings/stb](https://github.com/nothings/stb).
    Clone or download the source from the link and place the `stb-master` folder in
    the `Dependencies` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `TextureLoader` class, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We will then use the `string` and `glew.h` libraries, as we will be passing
    the location of the file where the JPEG is located and `STB` will load the file
    from there. We will add a constructor and a destructor as they are required; otherwise,
    the compiler will give an error. We will then create a function called `getTextureID`,
    which takes a string as an input and returns `GLuint`, which will be the texture
    ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `TextureLoader.cpp` file, we include `TextureLoader.h`. We then add
    the following to include `STB`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We add `#define` as it is required in a `TextureLoader.cpp` file, navigate
    to `stb_image.h`, and include it in the project. We then add the constructor and
    destructor as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create the `getTextureID` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `getTextureID` function, we will first create three `int` variables
    to store the width, height, and number of channels. An image usually only has
    three channels: red, green, and blue. However, it could have a fourth channel,
    the alpha channel, which is used for transparency. JPEG pictures have only three
    channels, but the PNG file could have three or four channels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our game, we will only be using a JPEG file, so the `channels` parameter
    will always be three, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use the `stbi_load` function to load the image data to an unsigned
    char pointer, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The function takes five parameters. The first is the string of the location
    of the file/filename. Then, it returns the width, height, and number of channels
    as the second, third, and fourth parameters, and in the fifth parameter, you set
    the required components. In this case, we want just the `r`, `g`, and `b` channels,
    so we specify `STBI_rgb`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then have to generate and bind the texture as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: First, a texture ID called `mtexture` of the `GLuint` type is created. Then,
    we call the `glGenTextures` function, pass in the number of objects we want to
    create, and pass in the array names, which is `mtexture`. We also have to bind
    the texture type by calling `glBindTexture` and pass in the texture type, which
    is `GL_TEXTURE_2D`, specifying that it is a 2D texture and stating the texture
    ID.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have to set the texture wrapping. Texture wrapping dictates what happens
    when the texture coordinate is greater or less than `1` in *x* and *y*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Textures can be wrapped in one of four ways: `GL_REPEAT`, `GL_MIRRORED_REPEAT`,
    `GL_CLAMP_TO_EDGE`, or `GL_CLAMP_TO_BORDER`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we imagine a texture applied to a quad, then the positive *s**-*axis runs
    horizontally and the *t*-axis runs vertically, starting at the origin (the bottom-left
    corner), as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4d8df6ec-bef3-40c7-95b5-795dd859db2b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s look at the different ways that the textures can be wrapped, as shown
    in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GL_REPEAT` just repeats the texture when applied to a quad.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GL_MIRRORER_REPEAT` repeats the texture, but also mirrors the texture the
    next time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GL_CLAMP_TO_EDGE` takes the `rgb` value at the edge of the texture and repeats
    the value for the entire object. In the following screenshot, the red border pixels
    are repeated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GL_CLAMP_TO_BORDER` takes a user-specific value and applies it to the end
    of the object instead of applying the edge color, as shown in the following screenshot:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/4d87c32b-008b-4a1c-8d45-e3446ca4d721.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For our purposes, we need `GL_REPEAT`, which is set as the default anyway,
    but if you had to set it, you will need to add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You use the `glTexParameteri` function, which takes three parameters. The first
    is the texture type, which is `GL_TEXTURE_2D`. The next parameter is the direction
    in which you want the wrapping to apply, which is `S` or `T`. The `S` direction
    is the same as *x* and `T` is the same as *y*. The last parameter is the wrapping
    parameter itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can set the texture filtering. Sometimes, when you apply a low-quality
    texture to a big quad, if you zoom in closer, the texture will be pixelated, as
    shown in the left-hand picture in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9d41fb43-47e4-4d47-9ae8-495d188392d7.png)'
  prefs: []
  type: TYPE_IMG
- en: The picture on the left is the output of setting the texture filtering to `GL_NEAREST`,
    and the picture on the right is the result of applying texture filtering to `GL_LINEAR`. The `GL_LINEAR`
    wrapping linearly interpolates with the texel value of the surrounding values
    to give a much smoother result when compared to `GL_NEAREST`.
  prefs: []
  type: TYPE_NORMAL
- en: When the texture is magnified, it is better to set the value to `GL_LINEAR`
    to get a smoother picture, and when the picture is minimized, it can then be set
    to `GL_NEAREST`, as the texels (which are texture elements) will be so small that
    we won't be able to see them anyway.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set the texture filtering, we use the same `glTexParameteri` function, but
    instead of passing in the wrapping direction as the second parameter we specify
    `GL_TEXTURE_MIN_FILTER` and `GL_TEXTURE_MAG_FILTER` as the second parameter and
    pass in `GL_NEAREST` or `GL_LINEAR` as the third parameter, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: It doesn't make sense to load a huge image with the object so far away that
    you can't even see it, so for optimization purposes, you can create mipmaps. Mipmaps
    basically take the texture and converts it to a lower resolution. This will automatically
    change the image to a lower resolution image when the texture is too far away
    from the camera. It will also change to a higher resolution image when the camera
    is closer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the mipmap chain for the texture we are using:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e794d3ff-8581-4313-b14c-52eafa2f18ef.png)'
  prefs: []
  type: TYPE_IMG
- en: The mipmap quality can be set using the `glTexParameteri` function again. This
    basically replaces `GL_NEAREST` with either `GL_NEAREST_MIPMAP_NEAREST`, `GL_LINEAR_MIPMAP_NEAREST`,
    `GL_NEAREST_MIPMAP_LINEAR`, or `GL_LINEAR_ MIPMAP_LINEAR`.
  prefs: []
  type: TYPE_NORMAL
- en: The best option is `GL_LINEAR_MIPMAP_LINEAR` because it linearly interpolates
    the value of the texel between two mipmaps, as well as samples, by linearly interpolating
    between the surrounding texels (a texel is the lowest unit of an image in the
    same way that a pixel is the smallest unit of a screen to represent a color at
    a location on the screen. If a 1080p picture is shown on a 1080p screen, then
    1 texel is mapped to 1 pixel).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we will use the following as our new filtering/mipmap values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this has been set, we can finally create the texture using the `glTexImage2D`
    function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `glTexImage2D` function takes nine parameters. These are described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The first is the texture type, which is `GL_TEXTURE_2D`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second is the mipmap level. If we want to use a lower quality picture, we
    can set this value to `1`, `2`, or `3`. For our purposes, we will leave this value
    as `0`, which is the base level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the third parameter, we will specify which all-color channels we want to
    store from the image. Since we want to store all three channels, we specify `GL_RGB`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fourth and fifth parameters that we specify are the width and height of
    the picture.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next parameter has to be set to `0`, as specified in the documentation (which
    can be found at [https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexImage2D.xhtml](https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexImage2D.xhtml)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next parameter that we specify is the data format of the image source.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next parameter is the type of data that is passed in, which is `GL_UNSIGNED_BYTE`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we set the image data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that the texture is created, we call `glGenerateMipmap` and pass in the
    `GL_TEXTURE_2D` texture type, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We then unbind the texture, free the picture, and finally return the `textureID` function
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: With all that done, we call finally add our texture to the game object.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `source.cpp`, include `MeshRenderer.h` and `TextureLoader.h` by going
    through  the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top, create a `MeshRenderer` pointer object called a sphere as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `init` function, create a new shader program called `texturedShaderProgram`
    of the `GLuint` type as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now load the two shaders called `TexturedModel.vs` and `TexturedModel.fs` as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is the `TexturedModel.vs` shader:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The only difference between this and `FlatModel.vs` is that here, the second
    location is a `vec2` called `texCoord`. We create an out `vec2` called `TexCoord`,
    into which we will store this value in the `main` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `TexturedModel.fs` shader:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We create a new `vec2` called `TexCoord` to receive the value from the vertex
    shader.
  prefs: []
  type: TYPE_NORMAL
- en: We then create a new uniform type called `sampler2D` and call it `Texture`.
    The texture is received through a sampler that will be used to sample the texture
    depending upon the wrap and filtering parameters we set while creating the texture.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the color is set depending upon the sampler and texture coordinates using
    the `texture` function. This function takes sampler and texture coordinates as
    parameters. The texel at a texture coordinate is sampled based on the sampler,
    and that color value is returned and assigned to the object at that texture coordinate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue creating the `MeshRenderer` object. Load the `globe.jpg` texture file
    using the `getTextureID` function of the `TextureLoader` class and set it to a
    `GLuint` called `sphereTexture` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the sphere `MeshRederer` object, set the mesh type, and pass the camera.
    Set the program, texture, position, and scale as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `renderScene` function, draw the `sphere` object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now see the textured globe when you run the project, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9ef6e337-5eec-4eec-8aa6-9d83485789fe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The camera is created as follows, and is set at the *z* position of four units:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Adding Bullet Physics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To add physics to our game, we will be using the Bullet Physics engine. This
    is an open source project that is widely used in AAA games and movies. It is used
    for collision detection as well as soft- and rigid-body dynamics. The library
    is free for commercial use.
  prefs: []
  type: TYPE_NORMAL
- en: Download the source from [https://github.com/bulletphysics/bullet3](https://github.com/bulletphysics/bullet3) ,
    and using CMake you will need to build the project for the release version of
    x64\. For your convenience, the header and `lib` files are included in the project
    for the chapter. You can take the folder and paste it into the `dependencies`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the folder, let''s take a look at how to add Bullet Physics
    by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `include` folder in C/C++ | General | Additional Include Directories as
    shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/76e2dde2-5097-4e5e-bf7f-6eed3826eaaa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Add the `lib/win64/Rls` folder in Linker | General | Additional Library Directories:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/51590433-e7ac-4e36-b063-09cac2f2fbb6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Add `BulletCollision.lib`, `BulletDynamics.lib`, and `LinearMath.lib` to Linker
    | Input | Additional Dependencies, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1369c25b-a19e-4dd4-b3f7-b0f325fbf94f.png)'
  prefs: []
  type: TYPE_IMG
- en: These libraries are responsible for the calculation of the movement of the game
    objects based on conditions such as gravity and external force, collision detection,
    and memory allocation.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the prep work out of the way, we can start adding physics to the game.
    In the `source.cpp` file, include `btBulletDynamicsCommon.h` at the top of the
    file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, create a new pointer object to `btDiscreteDynamicsWorld` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This object keeps track of all the physics settings and objects in the current
    scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: However, before we create `dynamicWorld`, the Bullet Physics library requires
    some objects to be initialized first.
  prefs: []
  type: TYPE_NORMAL
- en: 'These required objects are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`btBroadPhaseInerface`: Collision detection is actually done in two phases: `broadphase`
    and `narrowphase`. In the `broadphase`, the physics engine eliminates all the
    objects that are unlikely to collide. This check is done using the objects'' bounding
    boxes. Then, in the `narrowphase`, the actual shape of the object is used to check
    the likelihood of a collision. Pairs of objects are created with a strong likelihood
    of collision. In the following screenshot, the red box around the sphere is used
    for `broadphase` collision and the white wiremesh of the sphere is used for `narrowphase`
    collision:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/f0bc4f36-35eb-4c02-b8bc-eef4a2ce1530.png)'
  prefs: []
  type: TYPE_IMG
- en: '`btDefaultColliusion` **configuration**: This is used for setting up default
    memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`btCollisionDispatcher`**:** A pair of objects that have a strong likelihood
    of colliding are tested for collision using actual shapes. This is used for getting
    details of the collision detection, such as which object collided with which other
    object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`btSequentialImpulseConstraintSolver`: You can create constraints, such as
    a hinge constraint or slider constraint, which can restrict the motion or rotation
    of one object about another object. For example, if there is a hinge joint between
    the wall and the door, then the door can only rotate around the joint and cannot
    be moved about, as it is fixed at the hinge joint. The constraint solver is responsible
    for calculating this correctly. The calculation is repeated a number of times
    to get close to the optimal solution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the `init` function, before we create the `sphere` object, we will initialize
    these objects as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will create a new `dynamicWorld` by passing the `dispatcher`, `broadphase`,
    `solver`, and `collisionConfiguration` as parameters to the `btDiscreteDynamicsWorld`
    function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that our physics world is created, we can set the parameters for our physics.
    The basic parameter is gravity. We set its value to real-world conditions, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Adding rigid bodies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we can create rigid bodies or soft bodies and watch them interact with other
    rigid or soft bodies. A rigid body is an animate or inanimate object that doesn't
    change its shape or physical properties. Soft bodies, on the other hand, can be
    squishy and made to change shape.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we will focus on the creation of a rigid body.
  prefs: []
  type: TYPE_NORMAL
- en: To create a rigid body, we have to specify the shape of the object and the motion
    state, and then set the mass and inertia of the objects. Shapes are defined using
    `btCollisionShape`. An object can have different shapes, or sometimes even a combination
    of shapes, called a compound shape. We use `btBoxShape` to create cubes and cuboids
    and `btSphereShape` to create spheres. We can also create other shapes, such as `btCapsuleShape`,
    `btCylinderShape`, and `btConeShape`, which will be used for `narrowphase` collision
    by the library.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we are going to create a sphere shape and see our Earth sphere
    bounce around. So, let''s begin:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the following code, create a `btSphere` for creating a sphere shape and
    set the radius as `1.0`, which is the radius of our rendered sphere as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, set the `btDefaultMotionState`, where we specify the rotation and position
    of the sphere, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We set the rotation to `0` and set the position of the rigid body to a distance
    of `10.0f` along the *y*-axis. We should also set the mass and inertia and calculate
    the inertia of the `sphereShape` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'To create the rigid body, we first have to create `btRiigidBodyConstructionInfo` and
    pass the variables to it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create the rigid body object by passing `btRiigidBodyConstructionInfo`
    into it using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, set the physical properties of the rigid body, including friction and
    restitution, using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: These values are between `0.0f` and `1.0.0.0`, meaning that the object is really
    smooth and has no friction, and has no restitution or bounciness. The `1.0` figure,
    on the other hand, means that the object is rough on the outside and extremely
    bouncy, like a bouncy ball.
  prefs: []
  type: TYPE_NORMAL
- en: 'After these necessary parameters are set, we need to add the rigid body to
    the `dynamicWorld` we created as follows, using the `addRigidBody` function of
    the `dynamicsWorld`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, for our sphere mesh to actually behave like the sphere body, we have to
    pass the rigid body to the sphere mesh class and make some minor changes. Open
    the `MeshRenderer.h` and `.cpp` files. In the `MeshRenderer.h` file, include the
    `btBulletDynamicsCommon.h` header and add a local `btRigidBody` called `rigidBody`
    to the `private` section. You should also change the constructor to take a rigid
    body, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `MeshRenderer.cpp` file, change the constructor to take a `rigidBody` variable
    and set the local `rigidBody` variable to it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `draw` function, we have to replace the code where we set the
    `modelMatrix` variable with the code where we get the sphere rigid body value,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the `btTransform` variable to get the transformation from the rigid
    body''s `getMotionState` function and then get the `WorldTransform` variable and
    set it to our `brTransform` variable `t`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We create two new variables of the `btQuaternion` type to store rotation and
    `btVector3` to store the translation values using the `getRotation` and `getOrigin`
    functions of the `btTransform` class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create three `glm::mat4` variables, called `RotationMatrix`, `TranslationMatrix`,
    and `ScaleMatrix`, and set the values of rotation and translation using the `glm::rotate`
    and `glm:: translation` functions. We then pass in the rotation and translation
    values we stored earlier, as shown in the following code. We will keep the `ScaleMatrix` variable
    as is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The new `modelMatrix` variable will be the multiplication of the scale, rotation,
    and translation matrices in that order. The rest of the code will remain the same
    in the `draw` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `init` function, change the code to reflect the modified `MeshRenderer`
    constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We don''t have to set the position, as that will be set by the rigid body.
    Set the camera as shown in the following code so that we can see the sphere:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Now, run the project. We can see the sphere being drawn, but it is not moving.
    That's because we have to update the physics bodies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have to use the `dynamicsWorld` and `stepSimulation` functions to update
    the simulation every frame. To do this, we have to calculate the delta time between
    the previous and current frames.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of the `source.cpp`, include `<chrono>` so that we can calculate
    the tick update. Now, we have to make changes to the `main` function and the `while`
    loop as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Just before the `while` loop, we create a variable called `previousTime` and
    initialize it with the current time. In the `while` loop, we get the current time
    and store it in the variable. Then, we calculate the delta time between the previous
    time and the current time by subtracting the two. We have the delta time now,
    so we call the `stepSimulation` and pass in the delta time. Then we render the
    scene and swap the buffer and poll for events as usual. Finally, we set the current
    time as the previous time.
  prefs: []
  type: TYPE_NORMAL
- en: Now, when we run the project, we can see the sphere falling down, which is pretty
    cool. However, the sphere doesn't interact with anything.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a box rigid body at the bottom and watch the sphere bounce off it.
    After the sphere `MeshRenderer` object, add the following code to create a box
    rigid body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Here, we first create a shape of the `btBoxShape` type with the length, height,
    and depth set as `4.0`, `0.5`, and `4.0` respectively. Next, we will set the motion
    state, where we set the rotation to zero and the position at `-2.0` in the *y*-axis
    and `0` along the *x*- and *z*-axis. For the construction information, we set
    the mass and intertia to `0`. We also set the default motion state and pass in
    the shape. Next, we create the rigid body by passing the rigid body information
    into it. Once the rigid body is created, we set the restitution and friction value.
    Next, we use the `setCollisionFlags` function of `rigidBody` to set the rigid
    body type as static. This means that it will be like a brick wall or won't move
    and be affected by forces from other rigid bodies, but other bodies will still
    be affected by it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we add the ground rigid body to the world so that the box rigid body
    will be part of the physics simulation as well. We now have to create a `MeshRenderer` cube
    to render the ground rigid body. Create a new `MeshRenderer` object called `Ground`
    at the top, under which you created the sphere `MeshRenderer` object. In the `init`
    function, under which we added the code for the ground rigid body, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: We will create a new texture by loading `ground.jpg`, so make sure you add it
    to the `Assets/ Textures` directory. Call the constructor and set the `meshtype`
    to `cube`, and then set the camera and pass in the ground rigid body. We then
    set the shader program, texture, and scale of the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `renderScene` function, draw the ground `MeshRenderer` object as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when you run the project, you will see the sphere bouncing on the ground
    box:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5aa9e70f-6bc0-4e07-8212-24d7cebc2dbf.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we created a new class called `MeshRenderer`, which will be
    used to render textured 3D objects to our scene. We created a texture-loaded class,
    which will be used to load the textures from the images provided. Then, we added
    physics to the object by adding the Bullet Physics library. We then initialized
    the physics world and created and added the rigid body to the mesh renderer by
    adding the body itself to the world, causing the rendered object to be affected
    by physics.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will add a gameplay loop, as well as scoring and text
    rendering to display the score on the viewport. We will also add lighting to our
    world.
  prefs: []
  type: TYPE_NORMAL
