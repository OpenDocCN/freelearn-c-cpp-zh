- en: Building on the Game Objects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: n the last chapter, we looked at how to draw basic shapes using OpenGL. Now
    that we have covered the basics, let's improve our objects by adding some textures
    to them so that the objects don't just look like a plain cube and sphere.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: We can write our physics as we did last time, but when dealing with 3D objects,
    writing our own physics can become difficult and time consuming. To simplify the
    process, we will use the help of an external physics library to handle the physics
    and collision detection.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Creating the `MeshRenderer` class
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the `TextureLoader` class
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding Bullet Physics
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding rigid bodies
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the MeshRenderer class
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For drawing regular game objects, we will create a separate class from the `LightRenderer`
    class by adding texture, and we will also add motion to the object by adding physical
    properties. We will draw a textured object and then add physics to this object
    in the next section of this chapter. To do this, we will create a new `.h` and
    `.cpp` file called `MeshRenderer`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `MeshRenderer.h` file, we will do the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will add the includes as follows:'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we will create the class itself as follows:'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We will create the `public` section first as follows:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this section, we create the constructor, which takes a `ModelType` and the
    `_camera`. We add the destructor afterward. We have a separate function for drawing
    the object.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: We then use some `setter` functions to set the position, scale, the shader program,
    and the `textureID` function , which we will be using to set the texture on the
    object.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we will add the `private` section as follows:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the `private` section, we have vectors to store the vertices and the indices.
    Then, we have a `glm::mat4` variable called `modelMatrix` to store the model matrix
    value in.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: We create a local variable for the camera and `vec3s` for storing the position
    and scale value.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we have `Gluint` to store `vao`, `vbo`, `ebo`, `textureID`, and the
    shader program.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will now move on to setting up the `MeshRenderer.cpp` file by going through
    the following steps:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: First, we will include the `MeshRenderer.h` file at the top of `MeshRenderer.cpp`.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we will create the constructor for `MeshRenderer` as follows:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For this, we first initialize the `camera`, `position`, and `scale` local values
    as follows:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then we create a `switch` statement, as we did in `LightRenderer`, to get the
    mesh data, as follows:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, we generate and bind `vao`, `vbo`, and `ebo`. In addition to this, we
    set the data for `vbo` and `ebo` as follows:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The next step is to set the attributes. In this case, we will be setting the
    `position` attribute, but instead of color, we will set the texture coordinate
    attribute, as it will be required to set the texture on top of the object.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The attribute at the 0th index will still be a vertex position, but the attribute
    of the first index will be a texture coordinate this time, as shown in the following
    code:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, the attribute for the vertex position remains the same, but for the texture
    coordinate, the first index is enabled as before. The change occurs in the number
    of components. The texture coordinate is defined in the *x*- and *y*-axes, as
    this is a 2D texture, so for the second parameter, we specify `2` instead of `3`.
    The stride still remains the same, but the offset is changed to `texCoords`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'To close the constructor, we unbind the buffers and `vertexArray` as follows:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We now add the `draw` function as follows:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In this `draw` function, we will first set the model matrix as follows:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We will create two matrices for storing `translationMatrix` and `scaleMatrix`
    and then we set the values.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will then initialize the `modelMatrix` variable and the multiply scale and
    translation matrix and assign them to the `modelMatrix` variable.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, instead of creating a separate view and projection matrix, we can create
    a single matrix called `vp` and assign the multiplied view and projection matrices
    to it as follows:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Obviously, the order in which the view and projection matrices are multiplied
    matters and cannot be reversed.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: We can now send the values to the GPU.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before we send the values to the shader, the first thing we have to do is call
    `glUseProgram` and set the shader program so that the data is sent to the correct
    program. Once this is complete, we can set the values for `vp` and `modelMatrix`
    as follows:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we will bind the `texture` object. We use the `glBindTexture` function
    to bind the texture. The function takes two parameters, with the first being the
    texture target. We have a 2D texture, so we pass in `GL_TEXTURE_2D` as the first
    parameter and the second parameter as a texture ID. To do this, we add the following
    line to bind the texture:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You might be wondering why we aren't using `glUniformMatrix4fv` or something
    similar while setting the texture location, as we did for the matrices. Well,
    since we have just the one texture, the program sets the uniform location as the
    0th index by default so we don't have to worry about it. This all that we require
    to bind the texture.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can bind the `vao` and draw the object as follows:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Unbind the `VertexArray` at the end as follows:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we will add the definition for the destructor and `setters` as follows:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Creating the TextureLoader class
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We created the `MeshRenderer` class, but we still need to load the texture and
    set the texture ID, which can be passed to the `MeshRendered` object. For this,
    we will create a `TextureLoader` class that will be responsible for loading the
    textures. Let's see how to do this.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: We first need to create the new `.h` and `.cpp` file called `TextureLoader`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: To load the JPEG or PNG image, we will use a header-only library called STB.
    This can be downloaded from [https://github.com/nothings/stb](https://github.com/nothings/stb).
    Clone or download the source from the link and place the `stb-master` folder in
    the `Dependencies` folder.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `TextureLoader` class, add the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We will then use the `string` and `glew.h` libraries, as we will be passing
    the location of the file where the JPEG is located and `STB` will load the file
    from there. We will add a constructor and a destructor as they are required; otherwise,
    the compiler will give an error. We will then create a function called `getTextureID`,
    which takes a string as an input and returns `GLuint`, which will be the texture
    ID.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `TextureLoader.cpp` file, we include `TextureLoader.h`. We then add
    the following to include `STB`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We add `#define` as it is required in a `TextureLoader.cpp` file, navigate
    to `stb_image.h`, and include it in the project. We then add the constructor and
    destructor as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, we create the `getTextureID` function as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the `getTextureID` function, we will first create three `int` variables
    to store the width, height, and number of channels. An image usually only has
    three channels: red, green, and blue. However, it could have a fourth channel,
    the alpha channel, which is used for transparency. JPEG pictures have only three
    channels, but the PNG file could have three or four channels.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'In our game, we will only be using a JPEG file, so the `channels` parameter
    will always be three, as shown in the following code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We will use the `stbi_load` function to load the image data to an unsigned
    char pointer, as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The function takes five parameters. The first is the string of the location
    of the file/filename. Then, it returns the width, height, and number of channels
    as the second, third, and fourth parameters, and in the fifth parameter, you set
    the required components. In this case, we want just the `r`, `g`, and `b` channels,
    so we specify `STBI_rgb`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'We then have to generate and bind the texture as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: First, a texture ID called `mtexture` of the `GLuint` type is created. Then,
    we call the `glGenTextures` function, pass in the number of objects we want to
    create, and pass in the array names, which is `mtexture`. We also have to bind
    the texture type by calling `glBindTexture` and pass in the texture type, which
    is `GL_TEXTURE_2D`, specifying that it is a 2D texture and stating the texture
    ID.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have to set the texture wrapping. Texture wrapping dictates what happens
    when the texture coordinate is greater or less than `1` in *x* and *y*.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'Textures can be wrapped in one of four ways: `GL_REPEAT`, `GL_MIRRORED_REPEAT`,
    `GL_CLAMP_TO_EDGE`, or `GL_CLAMP_TO_BORDER`.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'If we imagine a texture applied to a quad, then the positive *s**-*axis runs
    horizontally and the *t*-axis runs vertically, starting at the origin (the bottom-left
    corner), as shown in the following screenshot:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4d8df6ec-bef3-40c7-95b5-795dd859db2b.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
- en: 'Let''s look at the different ways that the textures can be wrapped, as shown
    in the following list:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '`GL_REPEAT` just repeats the texture when applied to a quad.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GL_MIRRORER_REPEAT` repeats the texture, but also mirrors the texture the
    next time.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GL_CLAMP_TO_EDGE` takes the `rgb` value at the edge of the texture and repeats
    the value for the entire object. In the following screenshot, the red border pixels
    are repeated.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GL_CLAMP_TO_BORDER` takes a user-specific value and applies it to the end
    of the object instead of applying the edge color, as shown in the following screenshot:'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/4d87c32b-008b-4a1c-8d45-e3446ca4d721.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
- en: 'For our purposes, we need `GL_REPEAT`, which is set as the default anyway,
    but if you had to set it, you will need to add the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You use the `glTexParameteri` function, which takes three parameters. The first
    is the texture type, which is `GL_TEXTURE_2D`. The next parameter is the direction
    in which you want the wrapping to apply, which is `S` or `T`. The `S` direction
    is the same as *x* and `T` is the same as *y*. The last parameter is the wrapping
    parameter itself.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can set the texture filtering. Sometimes, when you apply a low-quality
    texture to a big quad, if you zoom in closer, the texture will be pixelated, as
    shown in the left-hand picture in the following screenshot:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9d41fb43-47e4-4d47-9ae8-495d188392d7.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
- en: The picture on the left is the output of setting the texture filtering to `GL_NEAREST`,
    and the picture on the right is the result of applying texture filtering to `GL_LINEAR`. The `GL_LINEAR`
    wrapping linearly interpolates with the texel value of the surrounding values
    to give a much smoother result when compared to `GL_NEAREST`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: When the texture is magnified, it is better to set the value to `GL_LINEAR`
    to get a smoother picture, and when the picture is minimized, it can then be set
    to `GL_NEAREST`, as the texels (which are texture elements) will be so small that
    we won't be able to see them anyway.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'To set the texture filtering, we use the same `glTexParameteri` function, but
    instead of passing in the wrapping direction as the second parameter we specify
    `GL_TEXTURE_MIN_FILTER` and `GL_TEXTURE_MAG_FILTER` as the second parameter and
    pass in `GL_NEAREST` or `GL_LINEAR` as the third parameter, as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: It doesn't make sense to load a huge image with the object so far away that
    you can't even see it, so for optimization purposes, you can create mipmaps. Mipmaps
    basically take the texture and converts it to a lower resolution. This will automatically
    change the image to a lower resolution image when the texture is too far away
    from the camera. It will also change to a higher resolution image when the camera
    is closer.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the mipmap chain for the texture we are using:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e794d3ff-8581-4313-b14c-52eafa2f18ef.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
- en: The mipmap quality can be set using the `glTexParameteri` function again. This
    basically replaces `GL_NEAREST` with either `GL_NEAREST_MIPMAP_NEAREST`, `GL_LINEAR_MIPMAP_NEAREST`,
    `GL_NEAREST_MIPMAP_LINEAR`, or `GL_LINEAR_ MIPMAP_LINEAR`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: The best option is `GL_LINEAR_MIPMAP_LINEAR` because it linearly interpolates
    the value of the texel between two mipmaps, as well as samples, by linearly interpolating
    between the surrounding texels (a texel is the lowest unit of an image in the
    same way that a pixel is the smallest unit of a screen to represent a color at
    a location on the screen. If a 1080p picture is shown on a 1080p screen, then
    1 texel is mapped to 1 pixel).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we will use the following as our new filtering/mipmap values:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Once this has been set, we can finally create the texture using the `glTexImage2D`
    function, as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `glTexImage2D` function takes nine parameters. These are described as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: The first is the texture type, which is `GL_TEXTURE_2D`.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second is the mipmap level. If we want to use a lower quality picture, we
    can set this value to `1`, `2`, or `3`. For our purposes, we will leave this value
    as `0`, which is the base level.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the third parameter, we will specify which all-color channels we want to
    store from the image. Since we want to store all three channels, we specify `GL_RGB`.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fourth and fifth parameters that we specify are the width and height of
    the picture.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next parameter has to be set to `0`, as specified in the documentation (which
    can be found at [https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexImage2D.xhtml](https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexImage2D.xhtml)).
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next parameter that we specify is the data format of the image source.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next parameter is the type of data that is passed in, which is `GL_UNSIGNED_BYTE`.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we set the image data.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that the texture is created, we call `glGenerateMipmap` and pass in the
    `GL_TEXTURE_2D` texture type, as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We then unbind the texture, free the picture, and finally return the `textureID` function
    like so:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: With all that done, we call finally add our texture to the game object.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `source.cpp`, include `MeshRenderer.h` and `TextureLoader.h` by going
    through  the following steps:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top, create a `MeshRenderer` pointer object called a sphere as follows:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the `init` function, create a new shader program called `texturedShaderProgram`
    of the `GLuint` type as follows:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We will now load the two shaders called `TexturedModel.vs` and `TexturedModel.fs` as
    follows:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is the `TexturedModel.vs` shader:'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The only difference between this and `FlatModel.vs` is that here, the second
    location is a `vec2` called `texCoord`. We create an out `vec2` called `TexCoord`,
    into which we will store this value in the `main` function.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `TexturedModel.fs` shader:'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We create a new `vec2` called `TexCoord` to receive the value from the vertex
    shader.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: We then create a new uniform type called `sampler2D` and call it `Texture`.
    The texture is received through a sampler that will be used to sample the texture
    depending upon the wrap and filtering parameters we set while creating the texture.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Then, the color is set depending upon the sampler and texture coordinates using
    the `texture` function. This function takes sampler and texture coordinates as
    parameters. The texel at a texture coordinate is sampled based on the sampler,
    and that color value is returned and assigned to the object at that texture coordinate.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue creating the `MeshRenderer` object. Load the `globe.jpg` texture file
    using the `getTextureID` function of the `TextureLoader` class and set it to a
    `GLuint` called `sphereTexture` as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Create the sphere `MeshRederer` object, set the mesh type, and pass the camera.
    Set the program, texture, position, and scale as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the `renderScene` function, draw the `sphere` object as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You should now see the textured globe when you run the project, as shown in
    the following screenshot:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9ef6e337-5eec-4eec-8aa6-9d83485789fe.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
- en: 'The camera is created as follows, and is set at the *z* position of four units:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Adding Bullet Physics
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To add physics to our game, we will be using the Bullet Physics engine. This
    is an open source project that is widely used in AAA games and movies. It is used
    for collision detection as well as soft- and rigid-body dynamics. The library
    is free for commercial use.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Download the source from [https://github.com/bulletphysics/bullet3](https://github.com/bulletphysics/bullet3) ,
    and using CMake you will need to build the project for the release version of
    x64\. For your convenience, the header and `lib` files are included in the project
    for the chapter. You can take the folder and paste it into the `dependencies`
    folder.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the folder, let''s take a look at how to add Bullet Physics
    by following these steps:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `include` folder in C/C++ | General | Additional Include Directories as
    shown in the following screenshot:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/76e2dde2-5097-4e5e-bf7f-6eed3826eaaa.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
- en: 'Add the `lib/win64/Rls` folder in Linker | General | Additional Library Directories:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/51590433-e7ac-4e36-b063-09cac2f2fbb6.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
- en: 'Add `BulletCollision.lib`, `BulletDynamics.lib`, and `LinearMath.lib` to Linker
    | Input | Additional Dependencies, as shown in the following screenshot:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1369c25b-a19e-4dd4-b3f7-b0f325fbf94f.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
- en: These libraries are responsible for the calculation of the movement of the game
    objects based on conditions such as gravity and external force, collision detection,
    and memory allocation.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'With the prep work out of the way, we can start adding physics to the game.
    In the `source.cpp` file, include `btBulletDynamicsCommon.h` at the top of the
    file, as follows:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'After this, create a new pointer object to `btDiscreteDynamicsWorld` as follows:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This object keeps track of all the physics settings and objects in the current
    scene.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: However, before we create `dynamicWorld`, the Bullet Physics library requires
    some objects to be initialized first.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在创建`dynamicWorld`之前，Bullet物理库需要首先初始化一些对象。
- en: 'These required objects are listed as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这些必需的对象如下列出：
- en: '`btBroadPhaseInerface`: Collision detection is actually done in two phases: `broadphase`
    and `narrowphase`. In the `broadphase`, the physics engine eliminates all the
    objects that are unlikely to collide. This check is done using the objects'' bounding
    boxes. Then, in the `narrowphase`, the actual shape of the object is used to check
    the likelihood of a collision. Pairs of objects are created with a strong likelihood
    of collision. In the following screenshot, the red box around the sphere is used
    for `broadphase` collision and the white wiremesh of the sphere is used for `narrowphase`
    collision:'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`btBroadPhaseInerface`：碰撞检测实际上分为两个阶段：`broadphase`和`narrowphase`。在`broadphase`阶段，物理引擎消除所有不太可能发生碰撞的对象。这个检查是通过使用对象的边界框来完成的。然后，在`narrowphase`阶段，使用对象的实际形状来检查碰撞的可能性。具有强烈碰撞可能性的对象对被创建。在以下屏幕截图中，围绕球体的红色框用于`broadphase`碰撞，而球体的白色线网用于`narrowphase`碰撞：'
- en: '![](img/f0bc4f36-35eb-4c02-b8bc-eef4a2ce1530.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f0bc4f36-35eb-4c02-b8bc-eef4a2ce1530.png)'
- en: '`btDefaultColliusion` **configuration**: This is used for setting up default
    memory.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`btDefaultColliusion` **configuration**：这用于设置默认内存。'
- en: '`btCollisionDispatcher`**:** A pair of objects that have a strong likelihood
    of colliding are tested for collision using actual shapes. This is used for getting
    details of the collision detection, such as which object collided with which other
    object.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`btCollisionDispatcher`**:** 使用实际形状测试具有强烈碰撞可能性的对象对以检测碰撞。这用于获取碰撞检测的详细信息，例如哪个对象与哪个其他对象发生了碰撞。'
- en: '`btSequentialImpulseConstraintSolver`: You can create constraints, such as
    a hinge constraint or slider constraint, which can restrict the motion or rotation
    of one object about another object. For example, if there is a hinge joint between
    the wall and the door, then the door can only rotate around the joint and cannot
    be moved about, as it is fixed at the hinge joint. The constraint solver is responsible
    for calculating this correctly. The calculation is repeated a number of times
    to get close to the optimal solution.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`btSequentialImpulseConstraintSolver`：你可以创建约束，例如铰链约束或滑块约束，这些约束可以限制一个物体相对于另一个物体的运动或旋转。例如，如果墙壁和门之间存在铰链关节，那么门只能绕着关节旋转，不能移动，因为它在铰链关节处是固定的。约束求解器负责正确计算这一点。计算会重复多次，以接近最优解。'
- en: 'In the `init` function, before we create the `sphere` object, we will initialize
    these objects as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在`init`函数中，在我们创建`sphere`对象之前，我们将按照以下方式初始化这些对象：
- en: '[PRE41]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Then, we will create a new `dynamicWorld` by passing the `dispatcher`, `broadphase`,
    `solver`, and `collisionConfiguration` as parameters to the `btDiscreteDynamicsWorld`
    function, as follows:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将通过将`dispatcher`、`broadphase`、`solver`和`collisionConfiguration`作为参数传递给`btDiscreteDynamicsWorld`函数来创建一个新的`dynamicWorld`，如下所示：
- en: '[PRE42]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now that our physics world is created, we can set the parameters for our physics.
    The basic parameter is gravity. We set its value to real-world conditions, as
    follows:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经创建了物理世界，我们可以设置物理参数。基本参数是重力。我们将其值设置为现实世界的条件，如下所示：
- en: '[PRE43]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Adding rigid bodies
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加刚体
- en: Now we can create rigid bodies or soft bodies and watch them interact with other
    rigid or soft bodies. A rigid body is an animate or inanimate object that doesn't
    change its shape or physical properties. Soft bodies, on the other hand, can be
    squishy and made to change shape.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建刚体或软体，并观察它们与其他刚体或软体的相互作用。刚体是一个不会改变其形状或物理特性的有生命或无生命物体。另一方面，软体可以是可挤压的，并使其形状发生变化。
- en: In the following example, we will focus on the creation of a rigid body.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将专注于创建刚体。
- en: To create a rigid body, we have to specify the shape of the object and the motion
    state, and then set the mass and inertia of the objects. Shapes are defined using
    `btCollisionShape`. An object can have different shapes, or sometimes even a combination
    of shapes, called a compound shape. We use `btBoxShape` to create cubes and cuboids
    and `btSphereShape` to create spheres. We can also create other shapes, such as `btCapsuleShape`,
    `btCylinderShape`, and `btConeShape`, which will be used for `narrowphase` collision
    by the library.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we are going to create a sphere shape and see our Earth sphere
    bounce around. So, let''s begin:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the following code, create a `btSphere` for creating a sphere shape and
    set the radius as `1.0`, which is the radius of our rendered sphere as well:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Next, set the `btDefaultMotionState`, where we specify the rotation and position
    of the sphere, as follows:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We set the rotation to `0` and set the position of the rigid body to a distance
    of `10.0f` along the *y*-axis. We should also set the mass and inertia and calculate
    the inertia of the `sphereShape` as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To create the rigid body, we first have to create `btRiigidBodyConstructionInfo` and
    pass the variables to it as follows:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, create the rigid body object by passing `btRiigidBodyConstructionInfo`
    into it using the following code:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, set the physical properties of the rigid body, including friction and
    restitution, using the following code:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: These values are between `0.0f` and `1.0.0.0`, meaning that the object is really
    smooth and has no friction, and has no restitution or bounciness. The `1.0` figure,
    on the other hand, means that the object is rough on the outside and extremely
    bouncy, like a bouncy ball.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'After these necessary parameters are set, we need to add the rigid body to
    the `dynamicWorld` we created as follows, using the `addRigidBody` function of
    the `dynamicsWorld`:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, for our sphere mesh to actually behave like the sphere body, we have to
    pass the rigid body to the sphere mesh class and make some minor changes. Open
    the `MeshRenderer.h` and `.cpp` files. In the `MeshRenderer.h` file, include the
    `btBulletDynamicsCommon.h` header and add a local `btRigidBody` called `rigidBody`
    to the `private` section. You should also change the constructor to take a rigid
    body, as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In the `MeshRenderer.cpp` file, change the constructor to take a `rigidBody` variable
    and set the local `rigidBody` variable to it as follows:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Then, in the `draw` function, we have to replace the code where we set the
    `modelMatrix` variable with the code where we get the sphere rigid body value,
    as follows:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We use the `btTransform` variable to get the transformation from the rigid
    body''s `getMotionState` function and then get the `WorldTransform` variable and
    set it to our `brTransform` variable `t`, as follows:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We create two new variables of the `btQuaternion` type to store rotation and
    `btVector3` to store the translation values using the `getRotation` and `getOrigin`
    functions of the `btTransform` class, as follows:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Next, we create three `glm::mat4` variables, called `RotationMatrix`, `TranslationMatrix`,
    and `ScaleMatrix`, and set the values of rotation and translation using the `glm::rotate`
    and `glm:: translation` functions. We then pass in the rotation and translation
    values we stored earlier, as shown in the following code. We will keep the `ScaleMatrix` variable
    as is:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The new `modelMatrix` variable will be the multiplication of the scale, rotation,
    and translation matrices in that order. The rest of the code will remain the same
    in the `draw` function.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `init` function, change the code to reflect the modified `MeshRenderer`
    constructor:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We don''t have to set the position, as that will be set by the rigid body.
    Set the camera as shown in the following code so that we can see the sphere:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Now, run the project. We can see the sphere being drawn, but it is not moving.
    That's because we have to update the physics bodies.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have to use the `dynamicsWorld` and `stepSimulation` functions to update
    the simulation every frame. To do this, we have to calculate the delta time between
    the previous and current frames.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of the `source.cpp`, include `<chrono>` so that we can calculate
    the tick update. Now, we have to make changes to the `main` function and the `while`
    loop as follows:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Just before the `while` loop, we create a variable called `previousTime` and
    initialize it with the current time. In the `while` loop, we get the current time
    and store it in the variable. Then, we calculate the delta time between the previous
    time and the current time by subtracting the two. We have the delta time now,
    so we call the `stepSimulation` and pass in the delta time. Then we render the
    scene and swap the buffer and poll for events as usual. Finally, we set the current
    time as the previous time.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Now, when we run the project, we can see the sphere falling down, which is pretty
    cool. However, the sphere doesn't interact with anything.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a box rigid body at the bottom and watch the sphere bounce off it.
    After the sphere `MeshRenderer` object, add the following code to create a box
    rigid body:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Here, we first create a shape of the `btBoxShape` type with the length, height,
    and depth set as `4.0`, `0.5`, and `4.0` respectively. Next, we will set the motion
    state, where we set the rotation to zero and the position at `-2.0` in the *y*-axis
    and `0` along the *x*- and *z*-axis. For the construction information, we set
    the mass and intertia to `0`. We also set the default motion state and pass in
    the shape. Next, we create the rigid body by passing the rigid body information
    into it. Once the rigid body is created, we set the restitution and friction value.
    Next, we use the `setCollisionFlags` function of `rigidBody` to set the rigid
    body type as static. This means that it will be like a brick wall or won't move
    and be affected by forces from other rigid bodies, but other bodies will still
    be affected by it.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we add the ground rigid body to the world so that the box rigid body
    will be part of the physics simulation as well. We now have to create a `MeshRenderer` cube
    to render the ground rigid body. Create a new `MeshRenderer` object called `Ground`
    at the top, under which you created the sphere `MeshRenderer` object. In the `init`
    function, under which we added the code for the ground rigid body, add the following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We will create a new texture by loading `ground.jpg`, so make sure you add it
    to the `Assets/ Textures` directory. Call the constructor and set the `meshtype`
    to `cube`, and then set the camera and pass in the ground rigid body. We then
    set the shader program, texture, and scale of the object.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `renderScene` function, draw the ground `MeshRenderer` object as follows:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now, when you run the project, you will see the sphere bouncing on the ground
    box:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5aa9e70f-6bc0-4e07-8212-24d7cebc2dbf.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
- en: Summary
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we created a new class called `MeshRenderer`, which will be
    used to render textured 3D objects to our scene. We created a texture-loaded class,
    which will be used to load the textures from the images provided. Then, we added
    physics to the object by adding the Bullet Physics library. We then initialized
    the physics world and created and added the rigid body to the mesh renderer by
    adding the body itself to the world, causing the rendered object to be affected
    by physics.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will add a gameplay loop, as well as scoring and text
    rendering to display the score on the viewport. We will also add lighting to our
    world.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
