<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer037">&#13;
			<h1 id="_idParaDest-207" class="chapter-number"><a id="_idTextAnchor222"/>13</h1>&#13;
			<h1 id="_idParaDest-208"><a id="_idTextAnchor223"/>Beyond Instruction Selection</h1>&#13;
			<p>Now that we’ve learned about instruction selection using the SelectionDAG and GlobalISel LLVM-based frameworks in the previous chapters, we can explore other interesting concepts beyond instruction selection. This chapter encapsulates some more advanced topics outside of the backend that can be interesting for a highly optimizing compiler. For instance, some passes run beyond instruction selection and can perform different optimizations on various instructions, which can mean that developers have the luxury to introduce their own passes to perform meaningful target-specific tasks at this point in <span class="No-Break">the compiler.</span></p>&#13;
			<p>Ultimately, within this chapter, we will dive into the <span class="No-Break">following concepts:</span></p>&#13;
			<ul>&#13;
				<li>Adding a new machine function pass <span class="No-Break">to LLVM</span></li>&#13;
				<li>Integrating a new target into the <span class="No-Break">clang frontend</span></li>&#13;
				<li>How to target a different <span class="No-Break">CPU architecture</span></li>&#13;
			</ul>&#13;
			<h1 id="_idParaDest-209"><a id="_idTextAnchor224"/>Adding a new machine function pass to LLVM</h1>&#13;
			<p>In this section, we will explore how to implement a new machine function pass within LLVM that <a id="_idIndexMarker894"/>runs after instruction selection. Specifically, a <strong class="source-inline">MachineFunctionPass</strong> class will be created, which is a subset of <a id="_idIndexMarker895"/>the original <strong class="source-inline">FunctionPass</strong> class within LLVM that can be run with <strong class="source-inline">opt</strong>. This class adapts the original infrastructure to allow for the implementation of passes that operate on the <strong class="source-inline">MachineFunction</strong> representation in the backend <span class="No-Break">through </span><span class="No-Break"><strong class="source-inline">llc</strong></span><span class="No-Break">.</span></p>&#13;
			<p>It is important to note that the implementation of passes within the backend utilizes the interfaces of the legacy pass manager, rather than the new pass manager. This is because LLVM currently does not have a complete working implementation of the new pass manager within the backend. Due to this, this chapter will follow the method of adding a new pass within the legacy pass <span class="No-Break">manager pipeline.</span></p>&#13;
			<p>In terms of the actual implementation, such as function passes, machine function passes optimize a single (machine) function at a time, but instead of overriding the <strong class="source-inline">runOnFunction()</strong> method, machine function passes override the <strong class="source-inline">runOnMachineFunction()</strong> method. The machine function pass that will be implemented <a id="_idIndexMarker896"/>in this section is a pass that checks for <a id="_idIndexMarker897"/>when a division by zero occurs, specifically, to insert code that traps in the backend. This type of pass is important for the M88k target due to hardware limitations on MC88100 as this CPU does not reliably detect division by <span class="No-Break">zero situations.</span></p>&#13;
			<p>Continuing from the previous chapter’s implementation of the backend, let’s examine how a backend machine function pass <span class="No-Break">is implemented!</span></p>&#13;
			<h2 id="_idParaDest-210"><a id="_idTextAnchor225"/>Implementing the top-level interface for the M88k target</h2>&#13;
			<p>Firstly, within <strong class="source-inline">llvm/lib/Target/M88k/M88k.h</strong>, let’s add two prototypes inside the <strong class="source-inline">llvm</strong> namespace <a id="_idIndexMarker898"/>declaration that will be <span class="No-Break">used later:</span></p>&#13;
			<ol>&#13;
				<li>The machine function pass that will be implemented will be called <strong class="source-inline">M88kDivInstrPass</strong>. We will add a function declaration that initializes this pass <a id="_idIndexMarker899"/>and takes in the pass <a id="_idIndexMarker900"/>registry, which is a class that manages the registration and initialization of <span class="No-Break">all passes:</span><pre class="source-code">&#13;
void initializeM88kDivInstrPass(PassRegistry &amp;);</pre></li>				<li>Next, the actual function that creates the <strong class="source-inline">M88kDivInstr</strong> pass is declared, with the M88k target machine information as <span class="No-Break">its argument:</span><pre class="source-code">&#13;
FunctionPass *createM88kDivInstr(const M88kTargetMachine &amp;);</pre></li>			</ol>&#13;
			<h2 id="_idParaDest-211"><a id="_idTextAnchor226"/>Adding the TargetMachine implementation for machine function passes</h2>&#13;
			<p>Next, we <a id="_idIndexMarker901"/>will analyze some of the changes that are required <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">llvm/lib/Target/M88k/M88kTargetMachine.cpp</strong></span><span class="No-Break">:</span></p>&#13;
			<ol>&#13;
				<li>Within LLVM, it’s common to give the user the option to toggle passes on or off. So, let’s provide the user the same flexibility with our machine function pass. We’ll start by declaring a command-line option called <strong class="source-inline">m88k-no-check-zero-division</strong> and initializing it to <strong class="source-inline">false</strong>, which implies that there will always be a check for zero division unless the user explicitly turns this off. We’ll add this under the <strong class="source-inline">llvm</strong> namespace declaration and is an option <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">llc</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
using namespace llvm;&#13;
static cl::opt&lt;bool&gt;&#13;
    NoZeroDivCheck("m88k-no-check-zero-division", cl::Hidden,&#13;
                   cl::desc("M88k: Don't trap on integer division by zero."),&#13;
                   cl::init(false));</pre></li>				<li>It is also customary to create a formal method that returns the command-line value so that we can query it to determine whether the pass will be run. Our original command-line option will be wrapped in the <strong class="source-inline">noZeroDivCheck()</strong> method so that we can utilize the command-line <span class="No-Break">result later:</span><pre class="source-code">&#13;
M88kTargetMachine::~M88kTargetMachine() {}&#13;
bool M88kTargetMachine::noZeroDivCheck() const { return NoZeroDivCheck; }</pre></li>				<li>Next, inside <strong class="source-inline">LLVMInitializeM88kTarget()</strong>, where the M88k target and passes are registered and initialized, we will insert a call to the <strong class="source-inline">initializeM88kDivInstrPass()</strong> method that was declared earlier <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">llvm/lib/Target/M88k/M88k.h</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
extern "C" LLVM_EXTERNAL_VISIBILITY void LLVMInitializeM88kTarget() {&#13;
   RegisterTargetMachine&lt;M88kTargetMachine&gt; X(getTheM88kTarget());&#13;
   auto &amp;PR = *PassRegistry::getPassRegistry();&#13;
   initializeM88kDAGToDAGISelPass(PR);&#13;
   initializeM88kDivInstrPass(PR);&#13;
 }</pre></li>				<li>The M88k target also needs to override <strong class="source-inline">addMachineSSAOptimization()</strong>, which is <a id="_idIndexMarker902"/>a method that adds passes to optimize machine instructions when they are in SSA form. Essentially, our machine function pass is added as a type of machine SSA optimization. This method is declared as a function that is to be overridden. We will add the full implementation at the end <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">M88kTargetMachine.cpp</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
   bool addInstSelector() override;&#13;
   void addPreEmitPass() override;&#13;
   void addMachineSSAOptimization() override;&#13;
. . .&#13;
void M88kPassConfig::addMachineSSAOptimization() {&#13;
   addPass(createM88kDivInstr(getTM&lt;M88kTargetMachine&gt;()));&#13;
   TargetPassConfig::addMachineSSAOptimization();&#13;
}</pre></li>				<li>Our method that returns the command-line option to toggle the machine function pass on and off (the <strong class="source-inline">noZeroDivCheck()</strong> method) is also declared <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">M88kTargetMachine.h</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
   ~M88kTargetMachine() override;&#13;
   bool noZeroDivCheck() const;</pre></li>			</ol>&#13;
			<h2 id="_idParaDest-212"><a id="_idTextAnchor227"/>Developing the specifics of the machine function pass</h2>&#13;
			<p>Now that the implementation in the M88k target machine is completed, the next step will be <a id="_idIndexMarker903"/>to develop the machine function pass itself. The implementation is contained within the new <span class="No-Break">file, </span><span class="No-Break"><strong class="source-inline">llvm/lib/Target/M88k/M88kDivInstr.cpp</strong></span><span class="No-Break">:</span></p>&#13;
			<ol>&#13;
				<li>The necessary headers for our machine function pass are added first. This includes headers that give us access to the M88k target information and headers that allow us to operate on machine functions and <span class="No-Break">machine instructions:</span><pre class="source-code">&#13;
#include "M88k.h"&#13;
#include "M88kInstrInfo.h"&#13;
#include "M88kTargetMachine.h"&#13;
#include "MCTargetDesc/M88kMCTargetDesc.h"&#13;
#include "llvm/ADT/Statistic.h"&#13;
#include "llvm/CodeGen/MachineFunction.h"&#13;
#include "llvm/CodeGen/MachineFunctionPass.h"&#13;
#include "llvm/CodeGen/MachineInstrBuilder.h"&#13;
#include "llvm/CodeGen/MachineRegisterInfo.h"&#13;
#include "llvm/IR/Instructions.h"&#13;
#include "llvm/Support/Debug.h"</pre></li>				<li>After that, we will add some code to prepare for our machine function pass. The first is a <strong class="source-inline">DEBUG_TYPE</strong> definition that is named <strong class="source-inline">m88k-div-instr</strong>, which is used for fine-grained control when debugging. Specifically, defining this <strong class="source-inline">DEBUG_TYPE</strong> allows users to specify the machine function pass name and view any debugging information that is pertinent to the pass when debug information <span class="No-Break">is enabled:</span><pre class="source-code">&#13;
#define DEBUG_TYPE "m88k-div-instr"</pre></li>				<li>We also specify that the <strong class="source-inline">llvm</strong> namespace is being used, and a <strong class="source-inline">STATISTIC</strong> value for <a id="_idIndexMarker904"/>our machine function is also declared. This statistic, called <strong class="source-inline">InsertedChecks</strong>, keeps track of how many division-by-zero checks are inserted by the compiler. Finally, an anonymous namespace is declared to encapsulate the subsequent machine function <span class="No-Break">pass implementation:</span><pre class="source-code">&#13;
using namespace llvm;&#13;
STATISTIC(InsertedChecks, "Number of inserted checks for division by zero");&#13;
namespace {</pre></li>				<li>As mentioned previously, this machine function pass aims to check for division by zero cases and inserts instructions that will cause the CPU to trap. These instructions require condition codes, so an <strong class="source-inline">enum</strong> value that we call <strong class="source-inline">CC0</strong> is defined with condition codes that are valid for the M88k target, along with <span class="No-Break">their encodings:</span><pre class="source-code">&#13;
enum class CC0 : unsigned {&#13;
  EQ0 = 0x2,&#13;
  NE0 = 0xd,&#13;
  GT0 = 0x1,&#13;
  LT0 = 0xc,&#13;
  GE0 = 0x3,&#13;
  LE0 = 0xe&#13;
};</pre></li>				<li>Let’s create the actual class for our machine function pass next, called <strong class="source-inline">M88kDivInstr</strong>. Firstly, we create it as an instance that inherits and is of the <strong class="source-inline">MachineFunctionPass</strong> type. Next, we declare various necessary instances that our <strong class="source-inline">M88kDivInstr</strong> pass will require. This includes <strong class="source-inline">M88kBuilder</strong>, which we will create and elaborate on later, and <strong class="source-inline">M88kTargetMachine</strong>, which contains target instruction and register information. Furthermore, we also require <a id="_idIndexMarker905"/>the register bank information and the machine register information when emitting instructions. An <strong class="source-inline">AddZeroDivCheck</strong> Boolean is also added to represent the previous command-line option, which turns our pass on <span class="No-Break">or off:</span><pre class="source-code">&#13;
class M88kDivInstr : public MachineFunctionPass {&#13;
  friend class M88kBuilder;&#13;
  const M88kTargetMachine *TM;&#13;
  const TargetInstrInfo *TII;&#13;
  const TargetRegisterInfo *TRI;&#13;
  const RegisterBankInfo *RBI;&#13;
  MachineRegisterInfo *MRI;&#13;
  bool AddZeroDivCheck;</pre></li>				<li>For the public variables and methods of the <strong class="source-inline">M88kDivInstr</strong> class, we declare an identification number that LLVM will use to identify our pass, as well as the <strong class="source-inline">M88kDivInstr</strong> constructor, which takes in <strong class="source-inline">M88kTargetMachine</strong>. Next, we override the <strong class="source-inline">getRequiredProperties()</strong> method, which represents the properties that <strong class="source-inline">MachineFunction</strong> may have at any time during the optimization, and we also override the <strong class="source-inline">runOnMachineFunction()</strong> method, which will be one of the primary methods that our pass will run when checking for any division by zero. The second important function that is publicly declared is the <strong class="source-inline">runOnMachineBasicBlock()</strong> function, which will be executed from <span class="No-Break">inside </span><span class="No-Break"><strong class="source-inline">runOnMachineFunction()</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
public:&#13;
  static char ID;&#13;
  M88kDivInstr(const M88kTargetMachine *TM = nullptr);&#13;
  MachineFunctionProperties getRequiredProperties() const override;&#13;
  bool runOnMachineFunction(MachineFunction &amp;MF) override;&#13;
  bool runOnMachineBasicBlock(MachineBasicBlock &amp;MBB);</pre></li>				<li>Finally, the last part is declaring the private methods and closing off the class. The only private <a id="_idIndexMarker906"/>method we declare within the <strong class="source-inline">M88kDivInstr</strong> class is the <strong class="source-inline">addZeroDivCheck()</strong> method, which inserts the checks for division by zero after any divide instruction. As we will see later, <strong class="source-inline">MachineInstr</strong> will need to point to specific divide instructions on the <span class="No-Break">M88k target:</span><pre class="source-code">&#13;
private:&#13;
  void addZeroDivCheck(MachineBasicBlock &amp;MBB, MachineInstr *DivInst);&#13;
};</pre></li>				<li>An <strong class="source-inline">M88kBuilder</strong> class is created next, which is a specialized builder instance that creates M88k-specific instructions. This class keeps an instance of <strong class="source-inline">MachineBasicBlock</strong> (and a corresponding iterator), and <strong class="source-inline">DebugLoc</strong> to keep track of the debug location of this builder class. Other necessary instances include the target instruction information, the target register information, and the register bank information of the <span class="No-Break">M88k target:</span><pre class="source-code">&#13;
class M88kBuilder {&#13;
  MachineBasicBlock *MBB;&#13;
  MachineBasicBlock::iterator I;&#13;
  const DebugLoc &amp;DL;&#13;
  const TargetInstrInfo &amp;TII;&#13;
  const TargetRegisterInfo &amp;TRI;&#13;
  const RegisterBankInfo &amp;RBI;</pre></li>				<li>For public methods of the <strong class="source-inline">M88kBuilder</strong> class, we must implement the constructor <a id="_idIndexMarker907"/>for this builder. Upon initialization, our specialized builder requires an instance of the <strong class="source-inline">M88kDivInstr</strong> pass to initialize the target instruction, register information, and the register bank information, as well as <strong class="source-inline">MachineBasicBlock</strong> and a <span class="No-Break">debug location:</span><pre class="source-code">&#13;
public:&#13;
  M88kBuilder(M88kDivInstr &amp;Pass, MachineBasicBlock *MBB, const DebugLoc &amp;DL)&#13;
      : MBB(MBB), I(MBB-&gt;end()), DL(DL), TII(*Pass.TII), TRI(*Pass.TRI),&#13;
        RBI(*Pass.RBI) {}</pre></li>				<li>Next, a method to set <strong class="source-inline">MachineBasicBlock</strong> inside the M88k builder is created, and the <strong class="source-inline">MachineBasicBlock</strong> iterator is also <span class="No-Break">set accordingly:</span><pre class="source-code">&#13;
  void setMBB(MachineBasicBlock *NewMBB) {&#13;
    MBB = NewMBB;&#13;
    I = MBB-&gt;end();&#13;
  }</pre></li>				<li>The <strong class="source-inline">constrainInst()</strong> function needs to be implemented next and is needed for when <strong class="source-inline">MachineInstr</strong> instances are processed. For a given <strong class="source-inline">MachineInstr</strong>, we check if the register class of the <strong class="source-inline">MachineInstr</strong> instance’s operands can be constrained through the pre-existing function, <strong class="source-inline">constrainSelectedInstRegOperands()</strong>. As shown here, this machine function pass requires that the register operands of the machine instruction can <span class="No-Break">be constrained:</span><pre class="source-code">&#13;
  void constrainInst(MachineInstr *MI) {&#13;
    if (!constrainSelectedInstRegOperands(*MI, TII, TRI, RBI))&#13;
      llvm_unreachable("Could not constrain register operands");&#13;
  }</pre></li>				<li>One of the <a id="_idIndexMarker908"/>instructions that this pass inserts is a <strong class="source-inline">BCND</strong> instruction, as defined in <strong class="source-inline">M88kInstrInfo.td</strong>, which is a conditional branch on the M88k target. To create this instruction, we require a condition code, which are the <strong class="source-inline">CC0</strong> enums that were implemented at the beginning of <strong class="source-inline">M88kDivInstr.cpp</strong> – that is, a register and <strong class="source-inline">MachineBasicBlock</strong>. The <strong class="source-inline">BCND</strong> instruction is simply returned upon creation and after checking if the newly created instruction can <span class="No-Break">be constrained:</span><pre class="source-code">&#13;
  MachineInstr *bcnd(CC0 Cc, Register Reg, MachineBasicBlock *TargetMBB) {&#13;
    MachineInstr *MI = BuildMI(*MBB, I, DL, TII.get(M88k::BCND))&#13;
                           .addImm(static_cast&lt;int64_t&gt;(Cc))&#13;
                           .addReg(Reg)&#13;
                           .addMBB(TargetMBB);&#13;
    constrainInst(MI);&#13;
    return MI;&#13;
  }</pre></li>				<li>Similarly, we also require a trap instruction for our machine function pass, which is a <strong class="source-inline">TRAP503</strong> instruction. This instruction requires a register and raises a trap with vector 503 if the 0-th bit of the register is not set, which will be raised after a zero division. Upon creating the <strong class="source-inline">TRAP503</strong> instruction, <strong class="source-inline">TRAP503</strong> is checked for constraints <a id="_idIndexMarker909"/>before being returned. Moreover, this concludes the class implementation of the <strong class="source-inline">M88kBuilder</strong> class and completes the previously declared <span class="No-Break">anonymous namespace:</span><pre class="source-code">&#13;
  MachineInstr *trap503(Register Reg) {&#13;
    MachineInstr *MI = BuildMI(*MBB, I, DL, TII.get(M88k::TRAP503)).addReg(Reg);&#13;
    constrainInst(MI);&#13;
    return MI;&#13;
  }&#13;
};&#13;
} // end anonymous namespace</pre></li>				<li>We can now start implementing the functions that perform the actual checks in the machine function pass. First, let’s explore how <strong class="source-inline">addZeroDivCheck()</strong> is implemented. This function simply inserts a check for division by zero between the current machine instruction, which is expected to point to either <strong class="source-inline">DIVSrr</strong> or <strong class="source-inline">DIVUrr</strong>; these are mnemonics for signed and unsigned divisions, respectively. The <strong class="source-inline">BCND</strong> and <strong class="source-inline">TRAP503</strong> instructions are inserted, and the <strong class="source-inline">InsertedChecks</strong> statistic is incremented to indicate the addition of the <span class="No-Break">two instructions:</span><pre class="source-code">&#13;
void M88kDivInstr::addZeroDivCheck(MachineBasicBlock &amp;MBB,&#13;
                                   MachineInstr *DivInst) {&#13;
 assert(DivInst-&gt;getOpcode() == M88k::DIVSrr ||&#13;
         DivInst-&gt;getOpcode() == M88k::DIVUrr &amp;&amp; "Unexpected          opcode");&#13;
  MachineBasicBlock *TailBB = MBB.splitAt(*DivInst);&#13;
  M88kBuilder B(*this, &amp;MBB, DivInst-&gt;getDebugLoc());&#13;
  B.bcnd(CC0::NE0, DivInst-&gt;getOperand(2).getReg(), TailBB);&#13;
  B.trap503(DivInst-&gt;getOperand(2).getReg());&#13;
  ++InsertedChecks;&#13;
}</pre></li>				<li><strong class="source-inline">runOnMachineFunction()</strong> is implemented next and is one of the important functions to override when creating a type of function pass within LLVM. This function returns true or false, depending on if any changes have been made <a id="_idIndexMarker910"/>during the duration of the machine function pass. Furthermore, for a given machine function, we gather all the relevant M88k subtarget information, including the target instruction, target register, register bank, and machine register information. Details regarding whether or not the user turns the <strong class="source-inline">M88kDivInstr</strong> machine function pass on or off are also queried and stored in the <strong class="source-inline">AddZeroDivCheck</strong> variable. Additionally, all machine basic blocks in the machine function are analyzed for the division by zero. The function that performs the machine basic block analysis is <strong class="source-inline">runOnMachineBasicBlock()</strong>; we will implement this next. Finally, if the machine function has changed, this is indicated by the <strong class="source-inline">Changed</strong> variable that <span class="No-Break">is returned:</span><pre class="source-code">&#13;
bool M88kDivInstr::runOnMachineFunction(MachineFunction &amp;MF) {&#13;
  const M88kSubtarget &amp;Subtarget =   MF.getSubtarget&lt;M88kSubtarget&gt;();&#13;
  TII = Subtarget.getInstrInfo();&#13;
  TRI = Subtarget.getRegisterInfo();&#13;
  RBI = Subtarget.getRegBankInfo();&#13;
  MRI = &amp;MF.getRegInfo();&#13;
  AddZeroDivCheck = !TM-&gt;noZeroDivCheck();&#13;
  bool Changed = false;&#13;
  for (MachineBasicBlock &amp;MBB : reverse(MF))&#13;
    Changed |= runOnMachineBasicBlock(MBB);&#13;
  return Changed;&#13;
}</pre></li>				<li>For the <strong class="source-inline">runOnMachineBasicBlock()</strong> function, a <strong class="source-inline">Changed</strong> Boolean flag is also returned to indicate if the machine basic block has been changed; however, it is initially set to <strong class="source-inline">false</strong>. Furthermore, within a machine basic block, we need to analyze all <a id="_idIndexMarker911"/>the machine instructions and check if the instructions are the <strong class="source-inline">DIVUrr</strong> or <strong class="source-inline">DIVSrr</strong> opcodes, respectively. In addition to checking if the opcodes are divide instructions, we need to check if the user has turned our machine function pass on or off. If all of these conditions are satisfied, the division by zero checks with the conditional branch and the trap instructions are added accordingly through the <strong class="source-inline">addZeroDivCheck()</strong> function, which was <span class="No-Break">implemented previously.</span><pre class="source-code">&#13;
bool M88kDivInstr::runOnMachineBasicBlock(MachineBasicBlock &amp;MBB) {&#13;
  bool Changed = false;&#13;
  for (MachineBasicBlock::reverse_instr_iterator I =   MBB.instr_rbegin();&#13;
       I != MBB.instr_rend(); ++I) {&#13;
    unsigned Opc = I-&gt;getOpcode();&#13;
    if ((Opc == M88k::DIVUrr || Opc == M88k::DIVSrr) &amp;&amp;     AddZeroDivCheck) {&#13;
      addZeroDivCheck(MBB, &amp;*I);&#13;
      Changed = true;&#13;
    }&#13;
  }&#13;
  return Changed;&#13;
}</pre></li>				<li>After, we need <a id="_idIndexMarker912"/>to implement the constructor to initialize our function pass and set the appropriate machine function properties. This can be achieved by calling the <strong class="source-inline">initializeM88kDivInstrPass()</strong> function with the <strong class="source-inline">PassRegistry</strong> instance inside the constructor of the <strong class="source-inline">M88kDivInstr</strong> class, and also by setting the machine function properties to indicate that our pass requires machine functions to be in <span class="No-Break">SSA form:</span><pre class="source-code">&#13;
M88kDivInstr::M88kDivInstr(const M88kTargetMachine *TM)&#13;
    : MachineFunctionPass(ID), TM(TM) {&#13;
  initializeM88kDivInstrPass(*PassRegistry::getPassRegistry());&#13;
}&#13;
MachineFunctionProperties M88kDivInstr::getRequiredProperties() const {&#13;
  return MachineFunctionProperties().set(&#13;
      MachineFunctionProperties::Property::IsSSA);&#13;
}</pre></li>				<li>The next step is to initialize the ID for our machine function pass and to instantiate the <strong class="source-inline">INITIALIZE_PASS</strong> macro with the details of our machine function pass. This requires the pass instance, naming information, and two Boolean arguments that indicate if the pass only examines the CFG and if the pass is an analysis pass. Since <strong class="source-inline">M88kDivInstr</strong> performs neither of those, two <strong class="source-inline">false</strong> arguments are specified to the pass <span class="No-Break">initialization macro:</span><pre class="source-code">&#13;
char M88kDivInstr::ID = 0;&#13;
INITIALIZE_PASS(M88kDivInstr, DEBUG_TYPE, "Handle div instructions", false, false)</pre></li>				<li>Finally, the <strong class="source-inline">createM88kDivInstr()</strong> function creates a new instance of the <strong class="source-inline">M88kDivInstr</strong> pass, with a <strong class="source-inline">M88kTargetMachine</strong> instance. This is encapsulated <a id="_idIndexMarker913"/>into an <strong class="source-inline">llvm</strong> namespace, and the namespace is ended after finishing <span class="No-Break">this function:</span><pre class="source-code">&#13;
namespace llvm {&#13;
FunctionPass *createM88kDivInstr(const M88kTargetMachine &amp;TM) {&#13;
  return new M88kDivInstr(&amp;TM);&#13;
}&#13;
} // end namespace llvm</pre></li>			</ol>&#13;
			<h2 id="_idParaDest-213"><a id="_idTextAnchor228"/>Building newly implemented machine function passes</h2>&#13;
			<p>We’re <a id="_idIndexMarker914"/>almost done with implementing our new machine function pass! Now, we need to ensure CMake is aware of the new machine function pass within <strong class="source-inline">M88kDivinstr.cpp</strong>. This file is then added <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">llvm/lib/Target/M88k/CMakeLists.txt</strong></span><span class="No-Break">:</span></p>&#13;
			<pre class="source-code">&#13;
add_llvm_target(M88kCodeGen&#13;
   M88kAsmPrinter.cpp&#13;
   M88kDivInstr.cpp&#13;
   M88kFrameLowering.cpp&#13;
   M88kInstrInfo.cpp&#13;
   M88kISelDAGToDAG.cpp</pre>			<p>The last step is to build LLVM with our new machine function pass implementation with the following commands. We require the <strong class="source-inline">-DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD=M88k</strong> CMake option to build the <span class="No-Break">M88k target:</span></p>&#13;
			<pre class="console">&#13;
$ cmake -G Ninja ../llvm-project/llvm -DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD=M88k -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_PROJECTS="llvm"&#13;
$ ninja</pre>			<p>With that, we’ve <a id="_idIndexMarker915"/>implemented the machine function pass, but wouldn’t it be interesting to see how it works? We can demonstrate the result of this pass by passing LLVM IR <span class="No-Break">through </span><span class="No-Break"><strong class="source-inline">llc</strong></span><span class="No-Break">.</span></p>&#13;
			<h2 id="_idParaDest-214"><a id="_idTextAnchor229"/>A glimpse of running a machine function pass with llc</h2>&#13;
			<p>We have <a id="_idIndexMarker916"/>the following IR, which contains a division <span class="No-Break">by zero:</span></p>&#13;
			<pre class="console">&#13;
$ cat m88k-divzero.ll&#13;
target datalayout = "E-m:e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-a:8:16-n32"&#13;
target triple = "m88k-unknown-openbsd"&#13;
@dividend = dso_local global i32 5, align 4&#13;
define dso_local i32 @testDivZero() #0 {&#13;
  %1 = load i32, ptr @dividend, align 4&#13;
  %2 = sdiv i32 %1, 0&#13;
  ret i32 %2&#13;
}</pre>			<p>Let’s feed it <span class="No-Break">into llc:</span></p>&#13;
			<pre class="console">&#13;
$ llc m88k-divzero.ll</pre>			<p>By doing this, we’ll see that, in the resulting assembly, by default, the division by zero checks, which are represented by <strong class="source-inline">bcnd.n</strong> (<strong class="source-inline">BCND</strong>) and <strong class="source-inline">tb0</strong> (<strong class="source-inline">TRAP503</strong>), are inserted by our new machine <span class="No-Break">function pass:</span></p>&#13;
			<pre class="console">&#13;
| %bb.1:&#13;
     subu %r2, %r0, %r2&#13;
     bcnd.n ne0, %r0, .LBB0_2&#13;
     divu %r2, %r2, 0&#13;
     tb0 0, %r3, 503&#13;
. . .&#13;
.LBB0_3:&#13;
     bcnd.n ne0, %r0, .LBB0_4&#13;
     divu %r2, %r2, 0&#13;
     tb0 0, %r3, 503</pre>			<p>However, let’s see what happens when we specify <strong class="source-inline">--m88k-no-check-zero-division</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">llc</strong></span><span class="No-Break">:</span></p>&#13;
			<pre class="console">&#13;
$ llc m88k-divzero.ll –m88k-no-check-zero-division</pre>			<p>This option <a id="_idIndexMarker917"/>to the backend instructs <strong class="source-inline">llc</strong> not to run the pass that checks for the division by zero. The resulting assembly will not contain any <strong class="source-inline">BCND</strong> or <strong class="source-inline">TRAP503</strong> instructions. Here’s <span class="No-Break">an example:</span></p>&#13;
			<pre class="console">&#13;
| %bb.1:&#13;
     subu %r2, %r0, %r2&#13;
     divu %r2, %r2, 0&#13;
     jmp.n %r1&#13;
     subu %r2, %r0, %r2</pre>			<p>As we can see, implementing a machine function pass requires several steps, but these procedures can be used as a guideline for you to implement any type of machine function pass that fits your needs. Since we have extensively explored the backend within this section, let’s switch gears and see how we can teach the frontend about the <span class="No-Break">M88k target.</span></p>&#13;
			<h1 id="_idParaDest-215"><a id="_idTextAnchor230"/>Integrating a new target into the clang frontend</h1>&#13;
			<p>In the previous chapters, we developed the M88k target’s backend implementation within LLVM. To complete the compiler implementation for the M88k target, we will investigate <a id="_idIndexMarker918"/>connecting our new target to <a id="_idIndexMarker919"/>the frontend by adding a clang implementation for our <span class="No-Break">M88k target.</span></p>&#13;
			<h2 id="_idParaDest-216"><a id="_idTextAnchor231"/>Implementing the driver integration within clang</h2>&#13;
			<p>Let’s <a id="_idIndexMarker920"/>start by adding driver integration into clang <span class="No-Break">for M88k:</span></p>&#13;
			<ol>&#13;
				<li>The first change we will be making is inside the <strong class="source-inline">clang/include/clang/Basic/TargetInfo.h</strong> file. The <strong class="source-inline">BuiltinVaListKind</strong> enum lists the different kinds of <strong class="source-inline">__builtin_va_list</strong> types for each target, which is used for variadic functions support, so a corresponding type for M88k <span class="No-Break">is added:</span><pre class="source-code">&#13;
enum BuiltinVaListKind {&#13;
. . .&#13;
    // typedef struct __va_list_tag {&#13;
    //    int __va_arg;&#13;
    //    int *__va_stk;&#13;
    //    int *__va_reg;&#13;
    //} va_list;&#13;
    M88kBuiltinVaList&#13;
  };</pre></li>				<li>Next, we must add a new header file, <strong class="source-inline">clang/lib/Basic/Targets/M88k.h</strong>. This file is a header for the M88k target feature support within the frontend. The first step is to define a new macro, to prevent multiple inclusive of the same header files, types, variables, and more. We must also include various headers that we require for the implementation <span class="No-Break">to follow:</span><pre class="source-code">&#13;
#ifndef LLVM_CLANG_LIB_BASIC_TARGETS_M88K_H&#13;
#define LLVM_CLANG_LIB_BASIC_TARGETS_M88K_H&#13;
#include "OSTargets.h"&#13;
#include "clang/Basic/TargetInfo.h"&#13;
#include "clang/Basic/TargetOptions.h"&#13;
#include "llvm/Support/Compiler.h"&#13;
#include "llvm/TargetParser/Triple.h"</pre></li>				<li>The methods <a id="_idIndexMarker921"/>we will declare will be added to the <strong class="source-inline">clang</strong> and <strong class="source-inline">targets</strong> namespaces accordingly, much like the other targets <span class="No-Break">within </span><span class="No-Break"><strong class="source-inline">llvm-project</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
namespace clang {&#13;
namespace targets {</pre></li>				<li>Let’s declare the actual <strong class="source-inline">M88kTargetInfo</strong> class now, and have it extend the original <strong class="source-inline">TargetInfo</strong> class. This class is marked with <strong class="source-inline">LLVM_LIBRARY_VISIBILITY</strong> because if this class is linked to a shared library, this attribute allows the <strong class="source-inline">M88kTargetInfo</strong> class to only be visible from within the library, and <span class="No-Break">inaccessible externally:</span><pre class="source-code">&#13;
class LLVM_LIBRARY_VISIBILITY M88kTargetInfo: public TargetInfo {</pre></li>				<li>Additionally, we must declare two variables – an array of characters to represent the register names and an <strong class="source-inline">enum</strong> value containing the type of CPUs available in the M88k target that can be selected. The default CPU that we set is the <strong class="source-inline">CK_Unknown</strong> CPU. Later, we will see that this can be overwritten by <span class="No-Break">user options:</span><pre class="source-code">&#13;
  static const char *const GCCRegNames[];&#13;
  enum CPUKind { CK_Unknown, CK_88000, CK_88100, CK_88110 } CPU = CK_Unknown;</pre></li>				<li>After, we begin by declaring the public methods that will be needed in our class implementation. Aside from the constructor of our class, we define various getter methods. This includes methods that get target-specific <strong class="source-inline">#define</strong> values, ones that get a list of built-ins supported by the target, methods that return the <a id="_idIndexMarker922"/>GCC register names along with their aliases, and finally, a method that returns our M88k <strong class="source-inline">BuiltinVaListKind</strong> that we previously added <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">clang/include/clang/Basic/TargetInfo.h</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
public:&#13;
  M88kTargetInfo(const llvm::Triple &amp;Triple, const TargetOptions &amp;);&#13;
  void getTargetDefines(const LangOptions &amp;Opts,&#13;
                        MacroBuilder &amp;Builder) const override;&#13;
  ArrayRef&lt;Builtin::Info&gt; getTargetBuiltins() const override;&#13;
  ArrayRef&lt;const char *&gt; getGCCRegNames() const override;&#13;
  ArrayRef&lt;TargetInfo::GCCRegAlias&gt; getGCCRegAliases() const override;&#13;
  BuiltinVaListKind getBuiltinVaListKind() const override {&#13;
    return TargetInfo::M88kBuiltinVaList;&#13;
  }</pre></li>				<li>Following the getter methods, we must also define methods that perform various checks on the M88k target. The first one checks if the M88k target has a particular target feature, supplied in the form of a string. Secondly, we add a function to <a id="_idIndexMarker923"/>validate the constraints when inline assembly is used. Finally, we have a function that checks if a specific CPU is valid for the M88k target, also supplied in the form of <span class="No-Break">a string:</span><pre class="source-code">&#13;
  bool hasFeature(StringRef Feature) const override;&#13;
  bool validateAsmConstraint(const char *&amp;Name,&#13;
                             TargetInfo::ConstraintInfo &amp;info)                              const override;&#13;
  bool isValidCPUName(StringRef Name) const override;</pre></li>				<li>Next, let’s declare setter methods for our <strong class="source-inline">M88kTargetInfo</strong> class. The first one simply sets the specific M88k CPU that we want to target, while the second method sets a vector to contain all of the valid supported CPUs <span class="No-Break">for M88k:</span><pre class="source-code">&#13;
  bool setCPU(const std::string &amp;Name) override;&#13;
  void fillValidCPUList(SmallVectorImpl&lt;StringRef&gt; &amp;Values)   const override;&#13;
};</pre></li>				<li>To complete our header for the driver implementation, let’s conclude our namespaces and macro definition that we added in <span class="No-Break">the beginning:</span><pre class="source-code">&#13;
} // namespace targets&#13;
} // namespace clang&#13;
#endif // LLVM_CLANG_LIB_BASIC_TARGETS_M88K_H</pre></li>				<li>Now that we’ve completed the M88k header file within <strong class="source-inline">clang/lib/Basic/Targets</strong>, we must add the corresponding <strong class="source-inline">TargetInfo</strong> C++ implementation within <strong class="source-inline">clang/lib/Basic/Targets/M88k.cpp</strong>. We’ll start by including the required header files, especially the new <strong class="source-inline">M88k.h</strong> header we have <span class="No-Break">just created:</span><pre class="source-code">&#13;
#include "M88k.h"&#13;
#include "clang/Basic/Builtins.h"&#13;
#include "clang/Basic/Diagnostic.h"&#13;
#include "clang/Basic/TargetBuiltins.h"&#13;
#include "llvm/ADT/StringExtras.h"&#13;
#include "llvm/ADT/StringRef.h"&#13;
#include "llvm/ADT/StringSwitch.h"&#13;
#include "llvm/TargetParser/TargetParser.h"&#13;
#include &lt;cstring&gt;</pre></li>				<li>As we did <a id="_idIndexMarker924"/>previously in the header, we start with the <strong class="source-inline">clang</strong> and <strong class="source-inline">targets</strong> namespaces, and then also begin implementing the constructor for the <span class="No-Break"><strong class="source-inline">M88kTargetInfo</strong></span><span class="No-Break"> class:</span><pre class="source-code">&#13;
namespace clang {&#13;
namespace targets {&#13;
M88kTargetInfo::M88kTargetInfo(const llvm::Triple &amp;Triple,&#13;
                               const TargetOptions &amp;)&#13;
    : TargetInfo(Triple) {</pre></li>				<li>Within the constructor, we set the data layout string for the M88k target. As you may have seen before, this data layout string is seen at the top of the emitted LLVM IR files. An explanation of each section of the data layout string is <span class="No-Break">described here:</span><pre class="source-code">&#13;
  std::string Layout = "";&#13;
  Layout += "E"; // M68k is Big Endian&#13;
  Layout += "-m:e";&#13;
  Layout += "-p:32:32:32"; // Pointers are 32 bit.&#13;
  // All scalar types are naturally aligned.&#13;
  Layout += "-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64";&#13;
  // Floats and doubles are also naturally aligned.&#13;
  Layout += "-f32:32:32-f64:64:64";&#13;
  // We prefer 16 bits of aligned for all globals; see above.&#13;
  Layout += "-a:8:16";&#13;
  Layout += "-n32"; // Integer registers are 32bits.&#13;
  resetDataLayout(Layout);</pre></li>				<li>The constructor for the <strong class="source-inline">M88kTargetInfo</strong> class concludes by setting the various <a id="_idIndexMarker925"/>variable types as <strong class="source-inline">signed long long</strong>, <strong class="source-inline">unsigned long</strong>, or <span class="No-Break"><strong class="source-inline">signed int</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
  IntMaxType = SignedLongLong;&#13;
  Int64Type = SignedLongLong;&#13;
  SizeType = UnsignedLong;&#13;
  PtrDiffType = SignedInt;&#13;
  IntPtrType = SignedInt;&#13;
}</pre></li>				<li>After that, the function to set the CPU for the target is implemented. This function takes a string and sets the CPU to be the particular CPU string that is supplied by the user within <strong class="source-inline">llvm::StringSwitch</strong>, which is essentially just a regular switch but specifically for strings with LLVM. We can see that there are three supported CPU types on the M88k target, and there is a <strong class="source-inline">CK_Unknown</strong> type for if the supplied string does not match any of the <span class="No-Break">expected types:</span><pre class="source-code">&#13;
bool M88kTargetInfo::setCPU(const std::string &amp;Name) {&#13;
  StringRef N = Name;&#13;
  CPU = llvm::StringSwitch&lt;CPUKind&gt;(N)&#13;
            .Case("generic", CK_88000)&#13;
            .Case("mc88000", CK_88000)&#13;
            .Case("mc88100", CK_88100)&#13;
            .Case("mc88110", CK_88110)&#13;
            .Default(CK_Unknown);&#13;
  return CPU != CK_Unknown;&#13;
}</pre></li>				<li>It was <a id="_idIndexMarker926"/>previously stated that there are three supported and valid CPU types on the M88k target: <strong class="source-inline">mc88000</strong>, <strong class="source-inline">mc88100</strong>, and <strong class="source-inline">mc88110</strong>, with the <strong class="source-inline">generic</strong> type simply being the <strong class="source-inline">mc88000</strong> CPU. We must implement the following functions to enforce these valid CPUs within clang. First, we must declare an array of strings, <strong class="source-inline">ValidCPUNames[]</strong>, to denote the valid CPU names on M88k. Secondly, the <strong class="source-inline">fillValidCPUList()</strong> method populates the array of valid CPU names into a vector. This vector is then used in the <strong class="source-inline">isValidCPUName()</strong> method, to check whether a particular CPU name supplied is indeed valid for our <span class="No-Break">M88k target:</span><pre class="source-code">&#13;
static constexpr llvm::StringLiteral ValidCPUNames[] = {&#13;
    {"generic"}, {"mc88000"}, {"mc88100"}, {"mc88110"}};&#13;
void M88kTargetInfo::fillValidCPUList(&#13;
    SmallVectorImpl&lt;StringRef&gt; &amp;Values) const {&#13;
  Values.append(std::begin(ValidCPUNames),   std::end(ValidCPUNames));&#13;
}&#13;
bool M88kTargetInfo::isValidCPUName(StringRef Name) const {&#13;
  return llvm::is_contained(ValidCPUNames, Name);&#13;
}</pre></li>				<li>Next, the <strong class="source-inline">getTargetDefines()</strong> method is implemented. This function defines the <a id="_idIndexMarker927"/>macros that are necessary for the frontend, such as the valid CPU types. Aside from the <strong class="source-inline">__m88k__</strong> and <strong class="source-inline">__m88k</strong> macros, we must also define corresponding CPU macros for the <span class="No-Break">valid CPUs:</span><pre class="source-code">&#13;
void M88kTargetInfo::getTargetDefines(const LangOptions &amp;Opts,&#13;
                                      MacroBuilder &amp;Builder) const {&#13;
  using llvm::Twine;&#13;
  Builder.defineMacro("__m88k__");&#13;
  Builder.defineMacro("__m88k");&#13;
  switch (CPU) { // For sub-architecture&#13;
  case CK_88000:&#13;
    Builder.defineMacro("__mc88000__");&#13;
    break;&#13;
  case CK_88100:&#13;
    Builder.defineMacro("__mc88100__");&#13;
    break;&#13;
  case CK_88110:&#13;
    Builder.defineMacro("__mc88110__");&#13;
    break;&#13;
  default:&#13;
    break;&#13;
  }&#13;
}</pre></li>				<li>The next few functions are stub functions but are required for the frontend for basic support. This includes the functions to get builtins from a target and a function to <a id="_idIndexMarker928"/>query the target if a specific feature of the target is supported. For now, we’ll leave them unimplemented and set default return values for these functions so that they can be <span class="No-Break">implemented later:</span><pre class="source-code">&#13;
ArrayRef&lt;Builtin::Info&gt; M88kTargetInfo::getTargetBuiltins() const {&#13;
  return std::nullopt;&#13;
}&#13;
bool M88kTargetInfo::hasFeature(StringRef Feature) const {&#13;
  return Feature == "M88000";&#13;
}</pre></li>				<li>Following these functions, we will add an implementation for the register names on M88k. Usually, the list of supported register names and their purposes can be found on the ABI of the specific platform of interest. Within this implementation, we’ll implement the main general-purpose registers from 0-31 and also create an array to store this information in. In terms of register aliases, note that there are no aliases for the registers that we <span class="No-Break">implement currently:</span><pre class="source-code">&#13;
const char *const M88kTargetInfo::GCCRegNames[] = {&#13;
    "r0",  "r1",  "r2",  "r3",  "r4",  "r5",  "r6",  "r7",  &#13;
    "r8",  "r9",  "r10",  "r11", "r12", "r13", "r14", "r15", &#13;
    "r16", "r17", "r18",  "r19", "r20", "r21",  "r22", "r23", &#13;
    "r24", "r25", "r26", "r27", "r28", "r29",  "r39", "r31"};&#13;
ArrayRef&lt;const char *&gt; M88kTargetInfo::getGCCRegNames() const {&#13;
  return llvm::makeArrayRef(GCCRegNames);&#13;
}&#13;
ArrayRef&lt;TargetInfo::GCCRegAlias&gt; M88kTargetInfo::getGCCRegAliases() const {&#13;
  return std::nullopt; // No aliases.&#13;
}</pre></li>				<li>The last function we’ll implement is a function that validates the inline assembly constraints on our target. This function simply takes a character, which represents <a id="_idIndexMarker929"/>the inline assembly constraint, and handles the constraint accordingly. A few inline assembly register constraints are implemented, such as for the address, data, and floating-point registers, and a select few constraints for constants are also <span class="No-Break">accounted for:</span><pre class="source-code">&#13;
bool M88kTargetInfo::validateAsmConstraint(&#13;
    const char *&amp;Name, TargetInfo::ConstraintInfo &amp;info) const {&#13;
  switch (*Name) {&#13;
  case 'a': // address register&#13;
  case 'd': // data register&#13;
  case 'f': // floating point register&#13;
    info.setAllowsRegister();&#13;
    return true;&#13;
  case 'K': // the constant 1&#13;
  case 'L': // constant -1^20 .. 1^19&#13;
  case 'M': // constant 1-4:&#13;
    return true;&#13;
  }&#13;
  return false;&#13;
}</pre></li>				<li>We conclude <a id="_idIndexMarker930"/>the file by closing off the <strong class="source-inline">clang</strong> and <strong class="source-inline">targets</strong> namespaces that we initiated at the beginning of <span class="No-Break">the file:</span><pre class="source-code">&#13;
} // namespace targets&#13;
} // namespace clang</pre></li>			</ol>&#13;
			<p>After completing the implementation for <strong class="source-inline">clang/lib/Basic/Targets/M88k.cpp</strong>, the following implementation  of adding the M88k features group and valid CPU types within <strong class="source-inline">clang/include/clang/Driver/Options.td</strong>. <span class="No-Break">is required.</span></p>&#13;
			<p>Recall from earlier that we previously defined three valid CPU types for our M88k target: <strong class="source-inline">mc88000</strong>, <strong class="source-inline">mc88100</strong>, and <strong class="source-inline">mc88110</strong>. These CPU types also need to be defined in <strong class="source-inline">Options.td</strong> since this file is the central place that defines all options and flags that will be accepted <span class="No-Break">by clang:</span></p>&#13;
			<ol>&#13;
				<li>First, we must add <strong class="source-inline">m_m88k_Features_Group</strong>, which represents a group of features that will be available to the <span class="No-Break">M88k target:</span><pre class="source-code">&#13;
def m_m88k_Features_Group: OptionGroup&lt;"&lt;m88k features group&gt;"&gt;,&#13;
                           Group&lt;m_Group&gt;, DocName&lt;"M88k"&gt;;</pre></li>				<li>Next, we must define the three valid M88k CPU types as a feature in the M88k <span class="No-Break">features group:</span><pre class="source-code">&#13;
def m88000 : Flag&lt;["-"], "m88000"&gt;, Group&lt;m_m88k_Features_Group&gt;;&#13;
def m88100 : Flag&lt;["-"], "m88100"&gt;, Group&lt;m_m88k_Features_Group&gt;;&#13;
def m88110 : Flag&lt;["-"], "m88110"&gt;, Group&lt;m_m88k_Features_Group&gt;;</pre></li>			</ol>&#13;
			<p>With <a id="_idIndexMarker931"/>that, we have implemented the driver integration portion for connecting the M88k target <span class="No-Break">with clang.</span></p>&#13;
			<h2 id="_idParaDest-217"><a id="_idTextAnchor232"/>Implementing ABI support for M88k within clang</h2>&#13;
			<p>Now, we need <a id="_idIndexMarker932"/>to add ABI support within the frontend for clang, which allows us to produce code specific to the M88k target from <span class="No-Break">the frontend:</span></p>&#13;
			<ol>&#13;
				<li>Let’s start by adding the following <strong class="source-inline">clang/lib/CodeGen/TargetInfo.h</strong>. This is a prototype that creates the code generation information for the <span class="No-Break">M88k target:</span><pre class="source-code">&#13;
std::unique_ptr&lt;TargetCodeGenInfo&gt; createM88kTargetCodeGenInfo(CodeGenModule &amp;CGM);</pre></li>				<li>We also need to add the following code to <strong class="source-inline">clang/lib/Basic/Targets.cpp</strong>, which will help teach clang the acceptable target triples for M88k. As we can see, for the M88k target, the acceptable operating system is OpenBSD. This means that clang accepts <strong class="source-inline">m88k-openbsd</strong> as a <span class="No-Break">target triple:</span><pre class="source-code">&#13;
 #include "Targets/M88k.h"&#13;
 #include "Targets/MSP430.h"&#13;
. . .&#13;
   case llvm::Triple::m88k:&#13;
     switch (os) {&#13;
     case llvm::Triple::OpenBSD:&#13;
       return std::make_unique&lt;OpenBSDTargetInfo&lt;M88kTargetInfo&gt;&gt;(Triple, Opts);&#13;
     default:&#13;
       return std::make_unique&lt;M88kTargetInfo&gt;(Triple, Opts);&#13;
     }&#13;
   case llvm::Triple::le32:&#13;
. . .</pre><p class="list-inset">Now, we need to create a file called <strong class="source-inline">clang/lib/CodeGen/Targets/M88k.cpp</strong> so that we can continue the code generation information and ABI implementation <span class="No-Break">for M88k.</span></p></li>				<li>Within <strong class="source-inline">clang/lib/CodeGen/Targets/M88k.cpp</strong>, we must add the following <a id="_idIndexMarker933"/>necessary headers, one of which is the <strong class="source-inline">TargetInfo.h</strong> header that we have just modified. Then, we must specify that we’re using the <strong class="source-inline">clang</strong> and <span class="No-Break"><strong class="source-inline">clang::codegen</strong></span><span class="No-Break"> namespaces:</span><pre class="source-code">&#13;
#include "ABIInfoImpl.h"&#13;
#include "TargetInfo.h"&#13;
using namespace clang;&#13;
using namespace clang::CodeGen;</pre></li>				<li>Next, we must declare a new anonymous namespace and place our <strong class="source-inline">M88kABIInfo</strong> inside of it. <strong class="source-inline">M88kABIInfo</strong> inherits from the existing <strong class="source-inline">ABIInfo</strong> from clang and contains <strong class="source-inline">DefaultABIInfo</strong> inside it. For our target, we rely heavily on the existing <strong class="source-inline">ABIInfo</strong> and <strong class="source-inline">DefaultABIInfo</strong>, which simplifies the <strong class="source-inline">M88kABIInfo</strong> <span class="No-Break">class significantly:</span><pre class="source-code">&#13;
namespace {&#13;
class M88kABIInfo final : public ABIInfo {&#13;
  DefaultABIInfo defaultInfo;</pre></li>				<li>Furthermore, aside from adding the constructor for the <strong class="source-inline">M88kABIInfo</strong> class, a couple <a id="_idIndexMarker934"/>of methods are also added. <strong class="source-inline">computeInfo()</strong> implements the default <strong class="source-inline">clang::CodeGen::ABIInfo</strong> class. There’s also the <strong class="source-inline">EmitVAArg()</strong> function, which generates code that retrieves an argument from a pointer that is passed in; this is updated after. This is primarily used for variadic <span class="No-Break">function support:</span><pre class="source-code">&#13;
public:&#13;
  explicit M88kABIInfo(CodeGen::CodeGenTypes &amp;CGT)&#13;
      : ABIInfo(CGT), defaultInfo(CGT) {}&#13;
  void computeInfo(CodeGen::CGFunctionInfo &amp;FI) const override {}&#13;
  CodeGen::Address EmitVAArg(CodeGen::CodeGenFunction &amp;CGF,&#13;
                             CodeGen::Address VAListAddr,&#13;
                             QualType Ty) const override {&#13;
    return VAListAddr;&#13;
  }&#13;
};</pre></li>				<li>The class constructor for the <strong class="source-inline">M88kTargetCodeGenInfo</strong> class is added next, which extends from the original <strong class="source-inline">TargetCodeGenInfo</strong>. After, we must close off the anonymous namespace that was <span class="No-Break">created initially:</span><pre class="source-code">&#13;
class M88kTargetCodeGenInfo final : public TargetCodeGenInfo {&#13;
public:&#13;
  explicit M88kTargetCodeGenInfo(CodeGen::CodeGenTypes &amp;CGT)&#13;
      : TargetCodeGenInfo(std::make_unique&lt;DefaultABIInfo&gt;(CGT)) {} };&#13;
}</pre></li>				<li>Finally, we <a id="_idIndexMarker935"/>must add the implementation to create the actual <strong class="source-inline">M88kTargetCodeGenInfo</strong> class as <strong class="source-inline">std::unique_ptr</strong>, which takes in a single <strong class="source-inline">CodeGenModule</strong> that generates LLVM IR code. This directly corresponds to what was originally added <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">TargetInfo.h</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
std::unique_ptr&lt;TargetCodeGenInfo&gt;&#13;
CodeGen::createM88kTargetCodeGenInfo(CodeGenModule &amp;CGM) {&#13;
  return std::make_unique&lt;M88kTargetCodeGenInfo&gt;(CGM.getTypes());&#13;
}</pre></li>			</ol>&#13;
			<p>That concludes the ABI support for the M88k in <span class="No-Break">the frontend.</span></p>&#13;
			<h2 id="_idParaDest-218"><a id="_idTextAnchor233"/>Implementing the toolchain support for M88k within clang</h2>&#13;
			<p>The <a id="_idIndexMarker936"/>final portion of the M88k target integration within clang will be to implement toolchain support for our target.  Like before, we’ll need to create a header file for toolchain support. We call this <span class="No-Break">header </span><span class="No-Break"><strong class="source-inline">clang/lib/Driver/ToolChains/Arch/M88k.h</strong></span><span class="No-Break">:</span></p>&#13;
			<ol>&#13;
				<li>First, we must define <strong class="source-inline">LLVM_CLANG_LIB_DRIVER_TOOLCHAINS_ARCH_M88K_H</strong> to prevent multiple inclusion later, and also add any necessary headers for later use. Following this, we must declare the <strong class="source-inline">clang</strong>, <strong class="source-inline">driver</strong>, <strong class="source-inline">tools</strong>, and <strong class="source-inline">m88k</strong> namespaces, with each nesting inside <span class="No-Break">the other:</span><pre class="source-code">&#13;
#ifndef LLVM_CLANG_LIB_DRIVER_TOOLCHAINS_ARCH_M88K_H&#13;
#define LLVM_CLANG_LIB_DRIVER_TOOLCHAINS_ARCH_M88K_H&#13;
#include "clang/Driver/Driver.h"&#13;
#include "llvm/ADT/StringRef.h"&#13;
#include "llvm/Option/Option.h"&#13;
#include &lt;string&gt;&#13;
#include &lt;vector&gt;&#13;
namespace clang {&#13;
namespace driver {&#13;
namespace tools {&#13;
namespace m88k {</pre></li>				<li>Next, we must declare an <strong class="source-inline">enum</strong> value that depicts the floating-point ABI, which is for <a id="_idIndexMarker937"/>soft and hard floating points. This means that floating-point computations can either be done by the floating-point hardware itself, which is fast, or through software emulation, which would <span class="No-Break">be slower:</span><pre class="source-code">&#13;
enum class FloatABI { Invalid, Soft, Hard, };</pre></li>				<li>Following this, we must add definitions to get the float ABI through the driver, and the CPU through clang’s <strong class="source-inline">-mcpu=</strong> and <strong class="source-inline">-mtune=</strong> options. We must also declare a function that retrieves the target features from <span class="No-Break">the driver:</span><pre class="source-code">&#13;
FloatABI getM88kFloatABI(const Driver &amp;D, const llvm::opt::ArgList &amp;Args);&#13;
StringRef getM88kTargetCPU(const llvm::opt::ArgList &amp;Args);&#13;
StringRef getM88kTuneCPU(const llvm::opt::ArgList &amp;Args);&#13;
void getM88kTargetFeatures(const Driver &amp;D, const llvm::Triple &amp;Triple, const llvm::opt::ArgList &amp;Args, std::vector&lt;llvm::StringRef&gt; &amp;Features);</pre></li>				<li>Finally, we conclude the header file by ending the namespaces and the macro that we <span class="No-Break">originally defined:</span><pre class="source-code">&#13;
} // end namespace m88k&#13;
} // end namespace tools&#13;
} // end namespace driver&#13;
} // end namespace clang&#13;
#endif // LLVM_CLANG_LIB_DRIVER_TOOLCHAINS_ARCH_M88K_H</pre></li>			</ol>&#13;
			<p>The <a id="_idIndexMarker938"/>last file we will implement is the C++ implementation for the toolchain support, <span class="No-Break">within </span><span class="No-Break"><strong class="source-inline">clang/lib/Driver/ToolChains/Arch/M88k.cpp</strong></span><span class="No-Break">:</span></p>&#13;
			<ol>&#13;
				<li>Once again, we’ll begin the implementation by including the necessary headers and namespaces that we will use later. We must also include the <strong class="source-inline">M88k.h</strong> header that we <span class="No-Break">created earlier:</span><pre class="source-code">&#13;
#include "M88k.h"&#13;
#include "ToolChains/CommonArgs.h"&#13;
#include "clang/Driver/Driver.h"&#13;
#include "clang/Driver/DriverDiagnostic.h"&#13;
#include "clang/Driver/Options.h"&#13;
#include "llvm/ADT/SmallVector.h"&#13;
#include "llvm/ADT/StringSwitch.h"&#13;
#include "llvm/Option/ArgList.h"&#13;
#include "llvm/Support/Host.h"&#13;
#include "llvm/Support/Regex.h"&#13;
#include &lt;sstream&gt;&#13;
using namespace clang::driver;&#13;
using namespace clang::driver::tools;&#13;
using namespace clang;&#13;
using namespace llvm::opt;</pre></li>				<li>The <strong class="source-inline">normalizeCPU()</strong> function is implemented next, which processes the CPU <a id="_idIndexMarker939"/>name into the <strong class="source-inline">-mcpu=</strong> option in clang. As we can see, each CPU name has several accepted variations. Furthermore, when a user specifies <strong class="source-inline">-mcpu=native</strong>, it allows them to compile for the current host’s <span class="No-Break">CPU type:</span><pre class="source-code">&#13;
static StringRef normalizeCPU(StringRef CPUName) {&#13;
  if (CPUName == "native") {&#13;
    StringRef CPU = std::string(llvm::sys::getHostCPUName());&#13;
    if (!CPU.empty() &amp;&amp; CPU != "generic")&#13;
      return CPU;&#13;
  }&#13;
  return llvm::StringSwitch&lt;StringRef&gt;(CPUName)&#13;
      .Cases("mc88000", "m88000", "88000", "generic", "mc88000")&#13;
      .Cases("mc88100", "m88100", "88100", "mc88100")&#13;
      .Cases("mc88110", "m88110", "88110", "mc88110")&#13;
      .Default(CPUName);&#13;
}</pre></li>				<li>Next up, we must implement the <strong class="source-inline">getM88kTargetCPU()</strong> function, in which, given the clang CPU name that we implemented earlier in <strong class="source-inline">clang/include/clang/Driver/Options.td</strong>, we get the corresponding LLVM name for the M88k CPU we <span class="No-Break">are targeting:</span><pre class="source-code">&#13;
StringRef m88k::getM88kTargetCPU(const ArgList &amp;Args) {&#13;
  Arg *A = Args.getLastArg(options::OPT_m88000, options::OPT_m88100, options::OPT_m88110, options::OPT_mcpu_EQ);&#13;
  if (!A)&#13;
    return StringRef();&#13;
  switch (A-&gt;getOption().getID()) {&#13;
  case options::OPT_m88000:&#13;
    return "mc88000";&#13;
  case options::OPT_m88100:&#13;
    return "mc88100";&#13;
  case options::OPT_m88110:&#13;
    return "mc88110";&#13;
  case options::OPT_mcpu_EQ:&#13;
    return normalizeCPU(A-&gt;getValue());&#13;
  default:&#13;
    llvm_unreachable("Impossible option ID");&#13;
  }&#13;
}</pre></li>				<li>The <strong class="source-inline">getM88kTuneCPU()</strong> function is implemented after. This is the behavior of the <a id="_idIndexMarker940"/>clang <strong class="source-inline">-mtune=</strong> option, which changes the instruction scheduling model to use data from a given CPU for M88k. We simply tune for whatever CPU that we are <span class="No-Break">currently targeting:</span><pre class="source-code">&#13;
StringRef m88k::getM88kTuneCPU(const ArgList &amp;Args) {&#13;
  if (const Arg *A = Args.getLastArg(options::OPT_mtune_EQ))&#13;
    return normalizeCPU(A-&gt;getValue());&#13;
  return StringRef();&#13;
}</pre></li>				<li>We’ll <a id="_idIndexMarker941"/>also implement the <strong class="source-inline">getM88kFloatABI()</strong> method, which gets the floating-point ABI. Initially, we’ll set the ABI to be <strong class="source-inline">m88k::FloatABI::Invalid</strong> as a default value. Next, we must check if any of the <strong class="source-inline">-msoft-float</strong> or <strong class="source-inline">-mhard-float</strong> options are passed to the command line. If <strong class="source-inline">-msoft-float</strong> is specified, then we set the ABI to <strong class="source-inline">m88k::FloatABI::Soft</strong> accordingly. Likewise, we set <strong class="source-inline">m88k::FloatABI::Hard</strong> when <strong class="source-inline">-mhard-float</strong> is specified to clang. Finally, if none of these options are specified, we choose the default on the current platform, which would be a hard floating-point value <span class="No-Break">for M88k:</span><pre class="source-code">&#13;
m88k::FloatABI m88k::getM88kFloatABI(const Driver &amp;D, const ArgList &amp;Args) {&#13;
  m88k::FloatABI ABI = m88k::FloatABI::Invalid;&#13;
  if (Arg *A =&#13;
          Args.getLastArg(options::OPT_msoft_float, options::OPT_mhard_float)) {&#13;
    if (A-&gt;getOption().matches(options::OPT_msoft_float))&#13;
      ABI = m88k::FloatABI::Soft;&#13;
    else if (A-&gt;getOption().matches(options::OPT_mhard_float))&#13;
      ABI = m88k::FloatABI::Hard;&#13;
  }&#13;
  if (ABI == m88k::FloatABI::Invalid)&#13;
    ABI = m88k::FloatABI::Hard;&#13;
  return ABI;&#13;
}</pre></li>				<li>We’ll add the implementation for <strong class="source-inline">getM88kTargetFeatures()</strong> next. The important <a id="_idIndexMarker942"/>part of this function is the vector of <strong class="source-inline">Features</strong> that are passed as a parameter. As we can see, the only target features that are handled are the floating-point ABI. From the driver and arguments passed to it, we’ll get the appropriate floating-point ABI from what we implemented in the previous step. Note that we add the <strong class="source-inline">-hard-float</strong> target features to the <strong class="source-inline">Features</strong> vector for soft float ABI as well, which means that currently, M88k only supports <span class="No-Break">hard float:</span><pre class="source-code">&#13;
void m88k::getM88kTargetFeatures(const Driver &amp;D, const llvm::Triple &amp;Triple,&#13;
                                 const ArgList &amp;Args,&#13;
                                 std::vector&lt;StringRef&gt; &amp;Features) {&#13;
  m88k::FloatABI FloatABI = m88k::getM88kFloatABI(D, Args);&#13;
  if (FloatABI == m88k::FloatABI::Soft)&#13;
    Features.push_back("-hard-float");&#13;
}</pre></li>			</ol>&#13;
			<h2 id="_idParaDest-219"><a id="_idTextAnchor234"/>Building the M88k target with clang integration</h2>&#13;
			<p>We’re <a id="_idIndexMarker943"/>almost done with the implementation for integrating M88k into clang. The last step is to add the new clang files that we have added into their corresponding <strong class="source-inline">CMakeLists.txt</strong> file, which allows us to build the clang project with our M88k <span class="No-Break">target implementation:</span></p>&#13;
			<ol>&#13;
				<li>First, add the <strong class="source-inline">Targets/M88k.cpp</strong> line <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">clang/lib/Basic/CMakeLists.txt</strong></span><span class="No-Break">.</span></li>&#13;
				<li>Next, add <strong class="source-inline">Targets/M88k.cpp</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">clang/lib/CodeGen/CMakeLists.txt</strong></span><span class="No-Break">.</span></li>&#13;
				<li>Finally, add <strong class="source-inline">ToolChains/Arch/M88k.cpp</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">clang/lib/Driver/CMakeLists.txt</strong></span><span class="No-Break">.</span></li>&#13;
			</ol>&#13;
			<p>There we have it! That concludes our toolchain implementation for the toolchain support for <a id="_idIndexMarker944"/>the M88k target, which subsequently means we’ve completed the integration into clang <span class="No-Break">for M88k!</span></p>&#13;
			<p>The last step we need to do is build clang with the M88k target. The following commands will build the clang and LLVM project. For clang, be aware of the M88k target. Here, the <strong class="source-inline">-DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD=M88k</strong> CMake option must be added, as in the <span class="No-Break">previous section:</span></p>&#13;
			<pre class="console">&#13;
$ cmake -G Ninja ../llvm-project/llvm -DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD=M88k -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_PROJECTS="clang;llvm"&#13;
$ ninja</pre>			<p>We should now have a version of clang that recognizes the M88k target! We can confirm this by checking the list of targets that clang supports, through the <strong class="source-inline">–</strong><span class="No-Break"><strong class="source-inline">print-targets</strong></span><span class="No-Break"> option:</span></p>&#13;
			<pre class="console">&#13;
$ clang --print-targets | grep M88k&#13;
    m88k        - M88k</pre>			<p>In this section, we delved into the technical details of integrating a new backend target into clang and having it recognized. In the next section, we’ll explore the concept of cross-compiling, where we detail the procedure of targeting a different CPU architecture from the <span class="No-Break">current host.</span></p>&#13;
			<h1 id="_idParaDest-220"><a id="_idTextAnchor235"/>Targeting a different CPU architecture</h1>&#13;
			<p>Today, many small computers, such as the Raspberry Pi, are in use despite having only limited resources. Running a compiler on such a computer is often not possible or it takes too much time. Thus, a common requirement for a compiler is to generate code for a different <a id="_idIndexMarker945"/>CPU architecture. The whole process of having a host compile an executable for a different target is <span class="No-Break">called cross-compiling.</span></p>&#13;
			<p>In cross-compiling, two systems are involved: the host system and the target system. The compiler runs on the host system and produces code for the target system. To denote the systems, the so-called triple is used. This is a configuration string that usually consists of the CPU architecture, the vendor, and the operating system. Furthermore, additional information about the environment is often added to the configuration string. For example, the <strong class="source-inline">x86_64-pc-win32</strong> triple is used for a Windows system running on a 64-bit X86 CPU. The CPU architecture is <strong class="source-inline">x86_64</strong>, <strong class="source-inline">pc</strong> is a generic vendor, and <strong class="source-inline">win32</strong> is the operating system, and all of these pieces are connected by a hyphen. A Linux system running on an ARMv8 CPU uses <strong class="source-inline">aarch64-unknown-linux-gnu</strong> as the triple, with <strong class="source-inline">aarch64</strong> as the CPU architecture. Moreover, the operating system is <strong class="source-inline">linux</strong>, running a <strong class="source-inline">gnu</strong> environment. There is no real vendor for a Linux-based system, so this part is <strong class="source-inline">unknown</strong>. Additionally, parts that are not known or unimportant for a specific purpose are often omitted: the <strong class="source-inline">aarch64-linux-gnu</strong> triple describes the same <span class="No-Break">Linux system.</span></p>&#13;
			<p>Let’s assume your development machine runs Linux on an X86 64-bit CPU and you want to cross-compile to an ARMv8 CPU system running Linux. The host triple is <strong class="source-inline">x86_64-linux-gnu</strong> and the target triple is <strong class="source-inline">aarch64-linux-gnu</strong>. Different systems have different characteristics. Thus, your application must be written in a portable fashion; otherwise, complications may arise. Some common pitfalls are <span class="No-Break">as follows:</span></p>&#13;
			<ul>&#13;
				<li><strong class="bold">Endianness</strong>: The order in which multi-byte values are stored in memory can <span class="No-Break">be different.</span></li>&#13;
				<li><strong class="bold">Pointer size</strong>: The size of a pointer varies with the CPU architecture (usually 16, 32, or 64-bit). The C <strong class="source-inline">int</strong> type may not be large enough to hold <span class="No-Break">a pointer.</span></li>&#13;
				<li><strong class="bold">Type differences</strong>: Data types are often closely related to the hardware. The <strong class="source-inline">long double</strong> type can use 64-bit (ARM), 80-bit (X86), or 128-bit (ARMv8). PowerPC systems may use double-double arithmetic for <strong class="source-inline">long double</strong>, which gives more precision by using a combination of two 64-bit <span class="No-Break"><strong class="source-inline">double</strong></span><span class="No-Break"> values.</span></li>&#13;
			</ul>&#13;
			<p>If you do not pay attention to these points, then your application can act surprisingly or crash on the target platform, even if it runs perfectly on your host system. The LLVM libraries are tested on different platforms and also contain portable solutions to the <span class="No-Break">aforementioned issues.</span></p>&#13;
			<p>For cross-compiling, the following tools <span class="No-Break">are required:</span></p>&#13;
			<ul>&#13;
				<li>A compiler that generates code for <span class="No-Break">the target</span></li>&#13;
				<li>A linker capable of generating binaries for <span class="No-Break">the target</span></li>&#13;
				<li>Header files and libraries for <span class="No-Break">the target</span></li>&#13;
			</ul>&#13;
			<p>Fortunately, the Ubuntu and Debian distributions have packages that support cross-compiling. We’re <a id="_idIndexMarker946"/>taking advantage of this in the following setup. The <strong class="source-inline">gcc</strong> and <strong class="source-inline">g++</strong> compilers, the linker, <strong class="source-inline">ld</strong>, and the libraries are available as precompiled binaries that produce ARMv8 code and executables. The following command installs all of <span class="No-Break">these packages:</span></p>&#13;
			<pre class="console">&#13;
$ sudo apt –y install gcc-12-aarch64-linux-gnu \&#13;
  g++-12-aarch64-linux-gnu binutils-aarch64-linux-gnu \&#13;
  libstdc++-12-dev-arm64-cross</pre>			<p>The new files are installed under the <strong class="source-inline">/usr/aarch64-linux-gnu</strong> directory. This directory is the (logical) root directory of the target system. It contains the usual <strong class="source-inline">bin</strong>, <strong class="source-inline">lib</strong>, and <strong class="source-inline">include</strong> directories. The cross-compilers (<strong class="source-inline">aarch64-linux-gnu-gcc-8</strong> and <strong class="source-inline">aarch64-linux-gnu-g++-8</strong>) are aware of <span class="No-Break">this directory.</span></p>&#13;
			<p class="callout-heading">Cross-compiling on other systems</p>&#13;
			<p class="callout">Some distributions, such as Fedora, only provide cross-compiling support for bare-metal targets such <a id="_idIndexMarker947"/>as the Linux kernel, but the header and library files needed for user land applications are not provided. In such a case, you can simply copy the missing files from your <span class="No-Break">target system.</span></p>&#13;
			<p class="callout">If your distribution does not come with the required toolchain, then you can build it from source. For the compiler, you can use clang or gcc/g++. The gcc and g++ compilers must be configured to produce code for the target system and the binutils tools need to handle files for the target system. Moreover, the C and C++ libraries need to be compiled with this toolchain. The steps vary by operating system and host and target architecture. On the web, you can find instructions if you search for <strong class="source-inline">gcc </strong><span class="No-Break"><strong class="source-inline">cross-compile &lt;architecture&gt;</strong></span><span class="No-Break">.</span></p>&#13;
			<p>With this preparation, you are almost ready to cross-compile the sample application (including the LLVM libraries) except <a id="_idIndexMarker948"/>for one little detail. LLVM uses the <strong class="bold">TableGen</strong> tool during the build. During cross-compilation, everything is compiled for the target architecture, including this tool. You can use <strong class="source-inline">llvm-tblgen</strong> from the build in <a href="B19561_01.xhtml#_idTextAnchor017"><span class="No-Break"><em class="italic">Chapter 1</em></span></a> or you can <a id="_idIndexMarker949"/>compile only this tool. Assuming you are in the directory that contains the clone of this book’s GitHub repository, type <span class="No-Break">the following:</span></p>&#13;
			<pre class="console">&#13;
$ mkdir build-host&#13;
$ cd build-host&#13;
$ cmake -G Ninja \&#13;
  -DLLVM_TARGETS_TO_BUILD="X86" \&#13;
  -DLLVM_ENABLE_ASSERTIONS=ON \&#13;
  -DCMAKE_BUILD_TYPE=Release \&#13;
  ../llvm-project/llvm&#13;
$ ninja llvm-tblgen&#13;
$ cd ..</pre>			<p>These steps should be familiar by now. A build directory is created and entered. The <strong class="source-inline">cmake</strong> command creates the build files for LLVM only for the X86 target. To save space and time, a release build is done but assertions are enabled to catch possible errors. Only the <strong class="source-inline">llvm-tblgen</strong> tool is compiled <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">ninja</strong></span><span class="No-Break">.</span></p>&#13;
			<p>With the <strong class="source-inline">llvm-tblgen</strong> tool at hand, you can now start the cross-compilation process. The CMake command line is very long, so you may want to store the command in a script file. The difference from previous builds is that more information must <span class="No-Break">be provided:</span></p>&#13;
			<pre class="console">&#13;
$ mkdir build-target&#13;
$ cd build-target&#13;
$ cmake -G Ninja \&#13;
  -DCMAKE_CROSSCOMPILING=True \&#13;
  -DLLVM_TABLEGEN=../build-host/bin/llvm-tblgen \&#13;
  -DLLVM_DEFAULT_TARGET_TRIPLE=aarch64-linux-gnu \&#13;
  -DLLVM_TARGET_ARCH=AArch64 \&#13;
  -DLLVM_TARGETS_TO_BUILD=AArch64 \&#13;
  -DLLVM_ENABLE_ASSERTIONS=ON \&#13;
  -DLLVM_EXTERNAL_PROJECTS=tinylang \&#13;
  -DLLVM_EXTERNAL_TINYLANG_SOURCE_DIR=../tinylang \&#13;
  -DCMAKE_INSTALL_PREFIX=../target-tinylang \&#13;
  -DCMAKE_BUILD_TYPE=Release \&#13;
  -DCMAKE_C_COMPILER=aarch64-linux-gnu-gcc-12 \&#13;
  -DCMAKE_CXX_COMPILER=aarch64-linux-gnu-g++-12 \&#13;
  ../llvm-project/llvm&#13;
$ ninja</pre>			<p>Again, you create a build directory and enter it before running the CMake command. Some of <a id="_idIndexMarker950"/>these CMake parameters have not been used before and require <span class="No-Break">some explanation:</span></p>&#13;
			<ul>&#13;
				<li><strong class="source-inline">CMAKE_CROSSCOMPILING</strong> set to <strong class="source-inline">ON</strong> tells CMake that we <span class="No-Break">are cross-compiling.</span></li>&#13;
				<li><strong class="source-inline">LLVM_TABLEGEN</strong> specifies the path to the <strong class="source-inline">llvm-tblgen</strong> tool to use. This is the one from the <span class="No-Break">previous build.</span></li>&#13;
				<li><strong class="source-inline">LLVM_DEFAULT_TARGET_TRIPLE</strong> is the triple of the <span class="No-Break">target architecture.</span></li>&#13;
				<li><strong class="source-inline">LLVM_TARGET_ARCH</strong> is used for <strong class="bold">JIT</strong> code generation. It defaults to the architecture of the host. For cross-compiling, this must be set to the <span class="No-Break">target architecture.</span></li>&#13;
				<li><strong class="source-inline">LLVM_TARGETS_TO_BUILD</strong> is the list of targets for which LLVM should include code generators. The list should at least include the <span class="No-Break">target architecture.</span></li>&#13;
				<li><strong class="source-inline">CMAKE_C_COMPILER</strong> and <strong class="source-inline">CMAKE_CXX_COMPILER</strong> specify the C and C++ compilers used for the build, respectively. The binaries of the cross-compilers are prefixed with the target triple and are not found automatically <span class="No-Break">by CMake.</span></li>&#13;
			</ul>&#13;
			<p>With the <a id="_idIndexMarker951"/>other parameters, a release build with assertions enabled is requested and our tinylang application is built as part of LLVM. Once the compilation process has finished, the <strong class="source-inline">file</strong> command can demonstrate that we have created a binary for ARMv8. Specifically, we can run <strong class="source-inline">$ file bin/tinylang</strong> and check that the output says <strong class="source-inline">ELF 64-bit object for the ARM </strong><span class="No-Break"><strong class="source-inline">aarch64 architecture</strong></span><span class="No-Break">.</span></p>&#13;
			<p class="callout-heading">Cross-compiling with clang</p>&#13;
			<p class="callout">As LLVM generates code for different architectures, it seems obvious to use clang to cross-compile. The obstacle here is that LLVM does not provide all the required parts – for example, the C library is missing. Because of this, you must use a mix of LLVM and GNU tools and as a result, you need to tell CMake even more about the environment you are using. As a minimum, you need to specify the following options for clang and clang++: <strong class="source-inline">--target=&lt;target-triple&gt;</strong> (enables code generation for a different target), <strong class="source-inline">--sysroot=&lt;path&gt;</strong> (path to the root directory for the target), <strong class="source-inline">I</strong> (search path for header files), and <strong class="source-inline">–L</strong> (search path for libraries). During the CMake run, a small application is compiled and CMake complains if something is wrong with your setup. This step is sufficient to check if you have a working environment. Common problems are picking the wrong header files or link failures due to different library names or wrong <span class="No-Break">search paths.</span></p>&#13;
			<p>Cross-compiling is surprisingly complex. With the instructions from this section, you will be able to cross-compile your application for a target architecture of <span class="No-Break">your choice.</span></p>&#13;
			<h1 id="_idParaDest-221"><a id="_idTextAnchor236"/>Summary</h1>&#13;
			<p>In this chapter, you learned about creating passes that run beyond instruction selection, specifically exploring the creation behind machine function passes in the backend! You also discovered how to add a new experimental target into clang, and some of the driver, ABI, and toolchain changes that are required. Finally, while considering the supreme discipline of compiler construction, you learned how to cross-compile your application for another <span class="No-Break">target architecture.</span></p>&#13;
			<p>Now that we’re at the end of <em class="italic">Learn LLVM 17</em>, you are equipped with the knowledge to use LLVM in creative ways in your projects and have explored many interesting topics. The LLVM ecosystem is very active, and new features are added all the time, so be sure to follow <span class="No-Break">its development!</span></p>&#13;
			<p>As compiler developers ourselves, it was a pleasure for us to write about LLVM and discover some new features along the way. Have fun <span class="No-Break">with LLVM!</span></p>&#13;
		</div>&#13;
	</div></body></html>