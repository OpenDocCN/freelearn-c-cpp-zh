<html><head></head><body><div><p>&#13;
			<h1 id="_idParaDest-207" class="chapter-number"><a id="_idTextAnchor222"/>13</h1>&#13;
			<h1 id="_idParaDest-208"><a id="_idTextAnchor223"/>Beyond Instruction Selection</h1>&#13;
			<p>Now that we’ve learned about instruction selection using the SelectionDAG and GlobalISel LLVM-based frameworks in the previous chapters, we can explore other interesting concepts beyond instruction selection. This chapter encapsulates some more advanced topics outside of the backend that can be interesting for a highly optimizing compiler. For instance, some passes run beyond instruction selection and can perform different optimizations on various instructions, which can mean that developers have the luxury to introduce their own passes to perform meaningful target-specific tasks at this point in the compiler.</p>&#13;
			<p>Ultimately, within this chapter, we will dive into the following concepts:</p>&#13;
			<ul>&#13;
				<li>Adding a new machine function pass to LLVM</li>&#13;
				<li>Integrating a new target into the clang frontend</li>&#13;
				<li>How to target a different CPU architecture</li>&#13;
			</ul>&#13;
			<h1 id="_idParaDest-209"><a id="_idTextAnchor224"/>Adding a new machine function pass to LLVM</h1>&#13;
			<p>In this section, we will explore how to implement a new machine function pass within LLVM that <a id="_idIndexMarker894"/>runs after instruction selection. Specifically, a <code>MachineFunctionPass</code> class will be created, which is a subset of <a id="_idIndexMarker895"/>the original <code>FunctionPass</code> class within LLVM that can be run with <code>opt</code>. This class adapts the original infrastructure to allow for the implementation of passes that operate on the <code>MachineFunction</code> representation in the backend through <code>llc</code>.</p>&#13;
			<p>It is important to note that the implementation of passes within the backend utilizes the interfaces of the legacy pass manager, rather than the new pass manager. This is because LLVM currently does not have a complete working implementation of the new pass manager within the backend. Due to this, this chapter will follow the method of adding a new pass within the legacy pass manager pipeline.</p>&#13;
			<p>In terms of the actual implementation, such as function passes, machine function passes optimize a single (machine) function at a time, but instead of overriding the <code>runOnFunction()</code> method, machine function passes override the <code>runOnMachineFunction()</code> method. The machine function pass that will be implemented <a id="_idIndexMarker896"/>in this section is a pass that checks for <a id="_idIndexMarker897"/>when a division by zero occurs, specifically, to insert code that traps in the backend. This type of pass is important for the M88k target due to hardware limitations on MC88100 as this CPU does not reliably detect division by zero situations.</p>&#13;
			<p>Continuing from the previous chapter’s implementation of the backend, let’s examine how a backend machine function pass is implemented!</p>&#13;
			<h2 id="_idParaDest-210"><a id="_idTextAnchor225"/>Implementing the top-level interface for the M88k target</h2>&#13;
			<p>Firstly, within <code>llvm/lib/Target/M88k/M88k.h</code>, let’s add two prototypes inside the <code>llvm</code> namespace <a id="_idIndexMarker898"/>declaration that will be used later:</p>&#13;
			<ol>&#13;
				<li>The machine function pass that will be implemented will be called <code>M88kDivInstrPass</code>. We will add a function declaration that initializes this pass <a id="_idIndexMarker899"/>and takes in the pass <a id="_idIndexMarker900"/>registry, which is a class that manages the registration and initialization of all passes:<pre class="source-code">&#13;
void initializeM88kDivInstrPass(PassRegistry &amp;);</pre></li>				<li>Next, the actual function that creates the <code>M88kDivInstr</code> pass is declared, with the M88k target machine information as its argument:<pre class="source-code">&#13;
FunctionPass *createM88kDivInstr(const M88kTargetMachine &amp;);</pre></li>			</ol>&#13;
			<h2 id="_idParaDest-211"><a id="_idTextAnchor226"/>Adding the TargetMachine implementation for machine function passes</h2>&#13;
			<p>Next, we <a id="_idIndexMarker901"/>will analyze some of the changes that are required in <code>llvm/lib/Target/M88k/M88kTargetMachine.cpp</code>:</p>&#13;
			<ol>&#13;
				<li>Within LLVM, it’s common to give the user the option to toggle passes on or off. So, let’s provide the user the same flexibility with our machine function pass. We’ll start by declaring a command-line option called <code>m88k-no-check-zero-division</code> and initializing it to <code>false</code>, which implies that there will always be a check for zero division unless the user explicitly turns this off. We’ll add this under the <code>llvm</code> namespace declaration and is an option for <code>llc</code>:<pre class="source-code">&#13;
using namespace llvm;&#13;
static cl::opt&lt;bool&gt;&#13;
    NoZeroDivCheck("m88k-no-check-zero-division", cl::Hidden,&#13;
                   cl::desc("M88k: Don't trap on integer division by zero."),&#13;
                   cl::init(false));</pre></li>				<li>It is also customary to create a formal method that returns the command-line value so that we can query it to determine whether the pass will be run. Our original command-line option will be wrapped in the <code>noZeroDivCheck()</code> method so that we can utilize the command-line result later:<pre class="source-code">&#13;
M88kTargetMachine::~M88kTargetMachine() {}&#13;
bool M88kTargetMachine::noZeroDivCheck() const { return NoZeroDivCheck; }</pre></li>				<li>Next, inside <code>LLVMInitializeM88kTarget()</code>, where the M88k target and passes are registered and initialized, we will insert a call to the <code>initializeM88kDivInstrPass()</code> method that was declared earlier in <code>llvm/lib/Target/M88k/M88k.h</code>:<pre class="source-code">&#13;
extern "C" LLVM_EXTERNAL_VISIBILITY void LLVMInitializeM88kTarget() {&#13;
   RegisterTargetMachine&lt;M88kTargetMachine&gt; X(getTheM88kTarget());&#13;
   auto &amp;PR = *PassRegistry::getPassRegistry();&#13;
   initializeM88kDAGToDAGISelPass(PR);&#13;
   initializeM88kDivInstrPass(PR);&#13;
 }</pre></li>				<li>The M88k target also needs to override <code>addMachineSSAOptimization()</code>, which is <a id="_idIndexMarker902"/>a method that adds passes to optimize machine instructions when they are in SSA form. Essentially, our machine function pass is added as a type of machine SSA optimization. This method is declared as a function that is to be overridden. We will add the full implementation at the end of <code>M88kTargetMachine.cpp</code>:<pre class="source-code">&#13;
   bool addInstSelector() override;&#13;
   void addPreEmitPass() override;&#13;
   void addMachineSSAOptimization() override;&#13;
. . .&#13;
void M88kPassConfig::addMachineSSAOptimization() {&#13;
   addPass(createM88kDivInstr(getTM&lt;M88kTargetMachine&gt;()));&#13;
   TargetPassConfig::addMachineSSAOptimization();&#13;
}</pre></li>				<li>Our method that returns the command-line option to toggle the machine function pass on and off (the <code>noZeroDivCheck()</code> method) is also declared in <code>M88kTargetMachine.h</code>:<pre class="source-code">&#13;
   ~M88kTargetMachine() override;&#13;
   bool noZeroDivCheck() const;</pre></li>			</ol>&#13;
			<h2 id="_idParaDest-212"><a id="_idTextAnchor227"/>Developing the specifics of the machine function pass</h2>&#13;
			<p>Now that the implementation in the M88k target machine is completed, the next step will be <a id="_idIndexMarker903"/>to develop the machine function pass itself. The implementation is contained within the new file, <code>llvm/lib/Target/M88k/M88kDivInstr.cpp</code>:</p>&#13;
			<ol>&#13;
				<li>The necessary headers for our machine function pass are added first. This includes headers that give us access to the M88k target information and headers that allow us to operate on machine functions and machine instructions:<pre class="source-code">&#13;
#include "M88k.h"&#13;
#include "M88kInstrInfo.h"&#13;
#include "M88kTargetMachine.h"&#13;
#include "MCTargetDesc/M88kMCTargetDesc.h"&#13;
#include "llvm/ADT/Statistic.h"&#13;
#include "llvm/CodeGen/MachineFunction.h"&#13;
#include "llvm/CodeGen/MachineFunctionPass.h"&#13;
#include "llvm/CodeGen/MachineInstrBuilder.h"&#13;
#include "llvm/CodeGen/MachineRegisterInfo.h"&#13;
#include "llvm/IR/Instructions.h"&#13;
#include "llvm/Support/Debug.h"</pre></li>				<li>After that, we will add some code to prepare for our machine function pass. The first is a <code>DEBUG_TYPE</code> definition that is named <code>m88k-div-instr</code>, which is used for fine-grained control when debugging. Specifically, defining this <code>DEBUG_TYPE</code> allows users to specify the machine function pass name and view any debugging information that is pertinent to the pass when debug information is enabled:<pre class="source-code">&#13;
#define DEBUG_TYPE "m88k-div-instr"</pre></li>				<li>We also specify that the <code>llvm</code> namespace is being used, and a <code>STATISTIC</code> value for <a id="_idIndexMarker904"/>our machine function is also declared. This statistic, called <code>InsertedChecks</code>, keeps track of how many division-by-zero checks are inserted by the compiler. Finally, an anonymous namespace is declared to encapsulate the subsequent machine function pass implementation:<pre class="source-code">&#13;
using namespace llvm;&#13;
STATISTIC(InsertedChecks, "Number of inserted checks for division by zero");&#13;
namespace {</pre></li>				<li>As mentioned previously, this machine function pass aims to check for division by zero cases and inserts instructions that will cause the CPU to trap. These instructions require condition codes, so an <code>enum</code> value that we call <code>CC0</code> is defined with condition codes that are valid for the M88k target, along with their encodings:<pre class="source-code">&#13;
enum class CC0 : unsigned {&#13;
  EQ0 = 0x2,&#13;
  NE0 = 0xd,&#13;
  GT0 = 0x1,&#13;
  LT0 = 0xc,&#13;
  GE0 = 0x3,&#13;
  LE0 = 0xe&#13;
};</pre></li>				<li>Let’s create the actual class for our machine function pass next, called <code>M88kDivInstr</code>. Firstly, we create it as an instance that inherits and is of the <code>MachineFunctionPass</code> type. Next, we declare various necessary instances that our <code>M88kDivInstr</code> pass will require. This includes <code>M88kBuilder</code>, which we will create and elaborate on later, and <code>M88kTargetMachine</code>, which contains target instruction and register information. Furthermore, we also require <a id="_idIndexMarker905"/>the register bank information and the machine register information when emitting instructions. An <code>AddZeroDivCheck</code> Boolean is also added to represent the previous command-line option, which turns our pass on or off:<pre class="source-code">&#13;
class M88kDivInstr : public MachineFunctionPass {&#13;
  friend class M88kBuilder;&#13;
  const M88kTargetMachine *TM;&#13;
  const TargetInstrInfo *TII;&#13;
  const TargetRegisterInfo *TRI;&#13;
  const RegisterBankInfo *RBI;&#13;
  MachineRegisterInfo *MRI;&#13;
  bool AddZeroDivCheck;</pre></li>				<li>For the public variables and methods of the <code>M88kDivInstr</code> class, we declare an identification number that LLVM will use to identify our pass, as well as the <code>M88kDivInstr</code> constructor, which takes in <code>M88kTargetMachine</code>. Next, we override the <code>getRequiredProperties()</code> method, which represents the properties that <code>MachineFunction</code> may have at any time during the optimization, and we also override the <code>runOnMachineFunction()</code> method, which will be one of the primary methods that our pass will run when checking for any division by zero. The second important function that is publicly declared is the <code>runOnMachineBasicBlock()</code> function, which will be executed from inside <code>runOnMachineFunction()</code>:<pre class="source-code">&#13;
public:&#13;
  static char ID;&#13;
  M88kDivInstr(const M88kTargetMachine *TM = nullptr);&#13;
  MachineFunctionProperties getRequiredProperties() const override;&#13;
  bool runOnMachineFunction(MachineFunction &amp;MF) override;&#13;
  bool runOnMachineBasicBlock(MachineBasicBlock &amp;MBB);</pre></li>				<li>Finally, the last part is declaring the private methods and closing off the class. The only private <a id="_idIndexMarker906"/>method we declare within the <code>M88kDivInstr</code> class is the <code>addZeroDivCheck()</code> method, which inserts the checks for division by zero after any divide instruction. As we will see later, <code>MachineInstr</code> will need to point to specific divide instructions on the M88k target:<pre class="source-code">&#13;
private:&#13;
  void addZeroDivCheck(MachineBasicBlock &amp;MBB, MachineInstr *DivInst);&#13;
};</pre></li>				<li>An <code>M88kBuilder</code> class is created next, which is a specialized builder instance that creates M88k-specific instructions. This class keeps an instance of <code>MachineBasicBlock</code> (and a corresponding iterator), and <code>DebugLoc</code> to keep track of the debug location of this builder class. Other necessary instances include the target instruction information, the target register information, and the register bank information of the M88k target:<pre class="source-code">&#13;
class M88kBuilder {&#13;
  MachineBasicBlock *MBB;&#13;
  MachineBasicBlock::iterator I;&#13;
  const DebugLoc &amp;DL;&#13;
  const TargetInstrInfo &amp;TII;&#13;
  const TargetRegisterInfo &amp;TRI;&#13;
  const RegisterBankInfo &amp;RBI;</pre></li>				<li>For public methods of the <code>M88kBuilder</code> class, we must implement the constructor <a id="_idIndexMarker907"/>for this builder. Upon initialization, our specialized builder requires an instance of the <code>M88kDivInstr</code> pass to initialize the target instruction, register information, and the register bank information, as well as <code>MachineBasicBlock</code> and a debug location:<pre class="source-code">&#13;
public:&#13;
  M88kBuilder(M88kDivInstr &amp;Pass, MachineBasicBlock *MBB, const DebugLoc &amp;DL)&#13;
      : MBB(MBB), I(MBB-&gt;end()), DL(DL), TII(*Pass.TII), TRI(*Pass.TRI),&#13;
        RBI(*Pass.RBI) {}</pre></li>				<li>Next, a method to set <code>MachineBasicBlock</code> inside the M88k builder is created, and the <code>MachineBasicBlock</code> iterator is also set accordingly:<pre class="source-code">&#13;
  void setMBB(MachineBasicBlock *NewMBB) {&#13;
    MBB = NewMBB;&#13;
    I = MBB-&gt;end();&#13;
  }</pre></li>				<li>The <code>constrainInst()</code> function needs to be implemented next and is needed for when <code>MachineInstr</code> instances are processed. For a given <code>MachineInstr</code>, we check if the register class of the <code>MachineInstr</code> instance’s operands can be constrained through the pre-existing function, <code>constrainSelectedInstRegOperands()</code>. As shown here, this machine function pass requires that the register operands of the machine instruction can be constrained:<pre class="source-code">&#13;
  void constrainInst(MachineInstr *MI) {&#13;
    if (!constrainSelectedInstRegOperands(*MI, TII, TRI, RBI))&#13;
      llvm_unreachable("Could not constrain register operands");&#13;
  }</pre></li>				<li>One of the <a id="_idIndexMarker908"/>instructions that this pass inserts is a <code>BCND</code> instruction, as defined in <code>M88kInstrInfo.td</code>, which is a conditional branch on the M88k target. To create this instruction, we require a condition code, which are the <code>CC0</code> enums that were implemented at the beginning of <code>M88kDivInstr.cpp</code> – that is, a register and <code>MachineBasicBlock</code>. The <code>BCND</code> instruction is simply returned upon creation and after checking if the newly created instruction can be constrained:<pre class="source-code">&#13;
  MachineInstr *bcnd(CC0 Cc, Register Reg, MachineBasicBlock *TargetMBB) {&#13;
    MachineInstr *MI = BuildMI(*MBB, I, DL, TII.get(M88k::BCND))&#13;
                           .addImm(static_cast&lt;int64_t&gt;(Cc))&#13;
                           .addReg(Reg)&#13;
                           .addMBB(TargetMBB);&#13;
    constrainInst(MI);&#13;
    return MI;&#13;
  }</pre></li>				<li>Similarly, we also require a trap instruction for our machine function pass, which is a <code>TRAP503</code> instruction. This instruction requires a register and raises a trap with vector 503 if the 0-th bit of the register is not set, which will be raised after a zero division. Upon creating the <code>TRAP503</code> instruction, <code>TRAP503</code> is checked for constraints <a id="_idIndexMarker909"/>before being returned. Moreover, this concludes the class implementation of the <code>M88kBuilder</code> class and completes the previously declared anonymous namespace:<pre class="source-code">&#13;
  MachineInstr *trap503(Register Reg) {&#13;
    MachineInstr *MI = BuildMI(*MBB, I, DL, TII.get(M88k::TRAP503)).addReg(Reg);&#13;
    constrainInst(MI);&#13;
    return MI;&#13;
  }&#13;
};&#13;
} // end anonymous namespace</pre></li>				<li>We can now start implementing the functions that perform the actual checks in the machine function pass. First, let’s explore how <code>addZeroDivCheck()</code> is implemented. This function simply inserts a check for division by zero between the current machine instruction, which is expected to point to either <code>DIVSrr</code> or <code>DIVUrr</code>; these are mnemonics for signed and unsigned divisions, respectively. The <code>BCND</code> and <code>TRAP503</code> instructions are inserted, and the <code>InsertedChecks</code> statistic is incremented to indicate the addition of the two instructions:<pre class="source-code">&#13;
void M88kDivInstr::addZeroDivCheck(MachineBasicBlock &amp;MBB,&#13;
                                   MachineInstr *DivInst) {&#13;
 assert(DivInst-&gt;getOpcode() == M88k::DIVSrr ||&#13;
         DivInst-&gt;getOpcode() == M88k::DIVUrr &amp;&amp; "Unexpected          opcode");&#13;
  MachineBasicBlock *TailBB = MBB.splitAt(*DivInst);&#13;
  M88kBuilder B(*this, &amp;MBB, DivInst-&gt;getDebugLoc());&#13;
  B.bcnd(CC0::NE0, DivInst-&gt;getOperand(2).getReg(), TailBB);&#13;
  B.trap503(DivInst-&gt;getOperand(2).getReg());&#13;
  ++InsertedChecks;&#13;
}</pre></li>				<li><code>runOnMachineFunction()</code> is implemented next and is one of the important functions to override when creating a type of function pass within LLVM. This function returns true or false, depending on if any changes have been made <a id="_idIndexMarker910"/>during the duration of the machine function pass. Furthermore, for a given machine function, we gather all the relevant M88k subtarget information, including the target instruction, target register, register bank, and machine register information. Details regarding whether or not the user turns the <code>M88kDivInstr</code> machine function pass on or off are also queried and stored in the <code>AddZeroDivCheck</code> variable. Additionally, all machine basic blocks in the machine function are analyzed for the division by zero. The function that performs the machine basic block analysis is <code>runOnMachineBasicBlock()</code>; we will implement this next. Finally, if the machine function has changed, this is indicated by the <code>Changed</code> variable that is returned:<pre class="source-code">&#13;
bool M88kDivInstr::runOnMachineFunction(MachineFunction &amp;MF) {&#13;
  const M88kSubtarget &amp;Subtarget =   MF.getSubtarget&lt;M88kSubtarget&gt;();&#13;
  TII = Subtarget.getInstrInfo();&#13;
  TRI = Subtarget.getRegisterInfo();&#13;
  RBI = Subtarget.getRegBankInfo();&#13;
  MRI = &amp;MF.getRegInfo();&#13;
  AddZeroDivCheck = !TM-&gt;noZeroDivCheck();&#13;
  bool Changed = false;&#13;
  for (MachineBasicBlock &amp;MBB : reverse(MF))&#13;
    Changed |= runOnMachineBasicBlock(MBB);&#13;
  return Changed;&#13;
}</pre></li>				<li>For the <code>runOnMachineBasicBlock()</code> function, a <code>Changed</code> Boolean flag is also returned to indicate if the machine basic block has been changed; however, it is initially set to <code>false</code>. Furthermore, within a machine basic block, we need to analyze all <a id="_idIndexMarker911"/>the machine instructions and check if the instructions are the <code>DIVUrr</code> or <code>DIVSrr</code> opcodes, respectively. In addition to checking if the opcodes are divide instructions, we need to check if the user has turned our machine function pass on or off. If all of these conditions are satisfied, the division by zero checks with the conditional branch and the trap instructions are added accordingly through the <code>addZeroDivCheck()</code> function, which was implemented previously.<pre class="source-code">&#13;
bool M88kDivInstr::runOnMachineBasicBlock(MachineBasicBlock &amp;MBB) {&#13;
  bool Changed = false;&#13;
  for (MachineBasicBlock::reverse_instr_iterator I =   MBB.instr_rbegin();&#13;
       I != MBB.instr_rend(); ++I) {&#13;
    unsigned Opc = I-&gt;getOpcode();&#13;
    if ((Opc == M88k::DIVUrr || Opc == M88k::DIVSrr) &amp;&amp;     AddZeroDivCheck) {&#13;
      addZeroDivCheck(MBB, &amp;*I);&#13;
      Changed = true;&#13;
    }&#13;
  }&#13;
  return Changed;&#13;
}</pre></li>				<li>After, we need <a id="_idIndexMarker912"/>to implement the constructor to initialize our function pass and set the appropriate machine function properties. This can be achieved by calling the <code>initializeM88kDivInstrPass()</code> function with the <code>PassRegistry</code> instance inside the constructor of the <code>M88kDivInstr</code> class, and also by setting the machine function properties to indicate that our pass requires machine functions to be in SSA form:<pre class="source-code">&#13;
M88kDivInstr::M88kDivInstr(const M88kTargetMachine *TM)&#13;
    : MachineFunctionPass(ID), TM(TM) {&#13;
  initializeM88kDivInstrPass(*PassRegistry::getPassRegistry());&#13;
}&#13;
MachineFunctionProperties M88kDivInstr::getRequiredProperties() const {&#13;
  return MachineFunctionProperties().set(&#13;
      MachineFunctionProperties::Property::IsSSA);&#13;
}</pre></li>				<li>The next step is to initialize the ID for our machine function pass and to instantiate the <code>INITIALIZE_PASS</code> macro with the details of our machine function pass. This requires the pass instance, naming information, and two Boolean arguments that indicate if the pass only examines the CFG and if the pass is an analysis pass. Since <code>M88kDivInstr</code> performs neither of those, two <code>false</code> arguments are specified to the pass initialization macro:<pre class="source-code">&#13;
char M88kDivInstr::ID = 0;&#13;
INITIALIZE_PASS(M88kDivInstr, DEBUG_TYPE, "Handle div instructions", false, false)</pre></li>				<li>Finally, the <code>createM88kDivInstr()</code> function creates a new instance of the <code>M88kDivInstr</code> pass, with a <code>M88kTargetMachine</code> instance. This is encapsulated <a id="_idIndexMarker913"/>into an <code>llvm</code> namespace, and the namespace is ended after finishing this function:<pre class="source-code">&#13;
namespace llvm {&#13;
FunctionPass *createM88kDivInstr(const M88kTargetMachine &amp;TM) {&#13;
  return new M88kDivInstr(&amp;TM);&#13;
}&#13;
} // end namespace llvm</pre></li>			</ol>&#13;
			<h2 id="_idParaDest-213"><a id="_idTextAnchor228"/>Building newly implemented machine function passes</h2>&#13;
			<p>We’re <a id="_idIndexMarker914"/>almost done with implementing our new machine function pass! Now, we need to ensure CMake is aware of the new machine function pass within <code>M88kDivinstr.cpp</code>. This file is then added to <code>llvm/lib/Target/M88k/CMakeLists.txt</code>:</p>&#13;
			<pre class="source-code">&#13;
add_llvm_target(M88kCodeGen&#13;
   M88kAsmPrinter.cpp&#13;
   M88kDivInstr.cpp&#13;
   M88kFrameLowering.cpp&#13;
   M88kInstrInfo.cpp&#13;
   M88kISelDAGToDAG.cpp</pre>			<p>The last step is to build LLVM with our new machine function pass implementation with the following commands. We require the <code>-DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD=M88k</code> CMake option to build the M88k target:</p>&#13;
			<pre class="console">&#13;
$ cmake -G Ninja ../llvm-project/llvm -DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD=M88k -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_PROJECTS="llvm"&#13;
$ ninja</pre>			<p>With that, we’ve <a id="_idIndexMarker915"/>implemented the machine function pass, but wouldn’t it be interesting to see how it works? We can demonstrate the result of this pass by passing LLVM IR through <code>llc</code>.</p>&#13;
			<h2 id="_idParaDest-214"><a id="_idTextAnchor229"/>A glimpse of running a machine function pass with llc</h2>&#13;
			<p>We have <a id="_idIndexMarker916"/>the following IR, which contains a division by zero:</p>&#13;
			<pre class="console">&#13;
$ cat m88k-divzero.ll&#13;
target datalayout = "E-m:e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-a:8:16-n32"&#13;
target triple = "m88k-unknown-openbsd"&#13;
@dividend = dso_local global i32 5, align 4&#13;
define dso_local i32 @testDivZero() #0 {&#13;
  %1 = load i32, ptr @dividend, align 4&#13;
  %2 = sdiv i32 %1, 0&#13;
  ret i32 %2&#13;
}</pre>			<p>Let’s feed it into llc:</p>&#13;
			<pre class="console">&#13;
$ llc m88k-divzero.ll</pre>			<p>By doing this, we’ll see that, in the resulting assembly, by default, the division by zero checks, which are represented by <code>bcnd.n</code> (<code>BCND</code>) and <code>tb0</code> (<code>TRAP503</code>), are inserted by our new machine function pass:</p>&#13;
			<pre class="console">&#13;
| %bb.1:&#13;
     subu %r2, %r0, %r2&#13;
     bcnd.n ne0, %r0, .LBB0_2&#13;
     divu %r2, %r2, 0&#13;
     tb0 0, %r3, 503&#13;
. . .&#13;
.LBB0_3:&#13;
     bcnd.n ne0, %r0, .LBB0_4&#13;
     divu %r2, %r2, 0&#13;
     tb0 0, %r3, 503</pre>			<p>However, let’s see what happens when we specify <code>--m88k-no-check-zero-division</code> to <code>llc</code>:</p>&#13;
			<pre class="console">&#13;
$ llc m88k-divzero.ll –m88k-no-check-zero-division</pre>			<p>This option <a id="_idIndexMarker917"/>to the backend instructs <code>llc</code> not to run the pass that checks for the division by zero. The resulting assembly will not contain any <code>BCND</code> or <code>TRAP503</code> instructions. Here’s an example:</p>&#13;
			<pre class="console">&#13;
| %bb.1:&#13;
     subu %r2, %r0, %r2&#13;
     divu %r2, %r2, 0&#13;
     jmp.n %r1&#13;
     subu %r2, %r0, %r2</pre>			<p>As we can see, implementing a machine function pass requires several steps, but these procedures can be used as a guideline for you to implement any type of machine function pass that fits your needs. Since we have extensively explored the backend within this section, let’s switch gears and see how we can teach the frontend about the M88k target.</p>&#13;
			<h1 id="_idParaDest-215"><a id="_idTextAnchor230"/>Integrating a new target into the clang frontend</h1>&#13;
			<p>In the previous chapters, we developed the M88k target’s backend implementation within LLVM. To complete the compiler implementation for the M88k target, we will investigate <a id="_idIndexMarker918"/>connecting our new target to <a id="_idIndexMarker919"/>the frontend by adding a clang implementation for our M88k target.</p>&#13;
			<h2 id="_idParaDest-216"><a id="_idTextAnchor231"/>Implementing the driver integration within clang</h2>&#13;
			<p>Let’s <a id="_idIndexMarker920"/>start by adding driver integration into clang for M88k:</p>&#13;
			<ol>&#13;
				<li>The first change we will be making is inside the <code>clang/include/clang/Basic/TargetInfo.h</code> file. The <code>BuiltinVaListKind</code> enum lists the different kinds of <code>__builtin_va_list</code> types for each target, which is used for variadic functions support, so a corresponding type for M88k is added:<pre class="source-code">&#13;
enum BuiltinVaListKind {&#13;
. . .&#13;
    // typedef struct __va_list_tag {&#13;
    //    int __va_arg;&#13;
    //    int *__va_stk;&#13;
    //    int *__va_reg;&#13;
    //} va_list;&#13;
    M88kBuiltinVaList&#13;
  };</pre></li>				<li>Next, we must add a new header file, <code>clang/lib/Basic/Targets/M88k.h</code>. This file is a header for the M88k target feature support within the frontend. The first step is to define a new macro, to prevent multiple inclusive of the same header files, types, variables, and more. We must also include various headers that we require for the implementation to follow:<pre class="source-code">&#13;
#ifndef LLVM_CLANG_LIB_BASIC_TARGETS_M88K_H&#13;
#define LLVM_CLANG_LIB_BASIC_TARGETS_M88K_H&#13;
#include "OSTargets.h"&#13;
#include "clang/Basic/TargetInfo.h"&#13;
#include "clang/Basic/TargetOptions.h"&#13;
#include "llvm/Support/Compiler.h"&#13;
#include "llvm/TargetParser/Triple.h"</pre></li>				<li>The methods <a id="_idIndexMarker921"/>we will declare will be added to the <code>clang</code> and <code>targets</code> namespaces accordingly, much like the other targets within <code>llvm-project</code>:<pre class="source-code">&#13;
namespace clang {&#13;
namespace targets {</pre></li>				<li>Let’s declare the actual <code>M88kTargetInfo</code> class now, and have it extend the original <code>TargetInfo</code> class. This class is marked with <code>LLVM_LIBRARY_VISIBILITY</code> because if this class is linked to a shared library, this attribute allows the <code>M88kTargetInfo</code> class to only be visible from within the library, and inaccessible externally:<pre class="source-code">&#13;
class LLVM_LIBRARY_VISIBILITY M88kTargetInfo: public TargetInfo {</pre></li>				<li>Additionally, we must declare two variables – an array of characters to represent the register names and an <code>enum</code> value containing the type of CPUs available in the M88k target that can be selected. The default CPU that we set is the <code>CK_Unknown</code> CPU. Later, we will see that this can be overwritten by user options:<pre class="source-code">&#13;
  static const char *const GCCRegNames[];&#13;
  enum CPUKind { CK_Unknown, CK_88000, CK_88100, CK_88110 } CPU = CK_Unknown;</pre></li>				<li>After, we begin by declaring the public methods that will be needed in our class implementation. Aside from the constructor of our class, we define various getter methods. This includes methods that get target-specific <code>#define</code> values, ones that get a list of built-ins supported by the target, methods that return the <a id="_idIndexMarker922"/>GCC register names along with their aliases, and finally, a method that returns our M88k <code>BuiltinVaListKind</code> that we previously added to <code>clang/include/clang/Basic/TargetInfo.h</code>:<pre class="source-code">&#13;
public:&#13;
  M88kTargetInfo(const llvm::Triple &amp;Triple, const TargetOptions &amp;);&#13;
  void getTargetDefines(const LangOptions &amp;Opts,&#13;
                        MacroBuilder &amp;Builder) const override;&#13;
  ArrayRef&lt;Builtin::Info&gt; getTargetBuiltins() const override;&#13;
  ArrayRef&lt;const char *&gt; getGCCRegNames() const override;&#13;
  ArrayRef&lt;TargetInfo::GCCRegAlias&gt; getGCCRegAliases() const override;&#13;
  BuiltinVaListKind getBuiltinVaListKind() const override {&#13;
    return TargetInfo::M88kBuiltinVaList;&#13;
  }</pre></li>				<li>Following the getter methods, we must also define methods that perform various checks on the M88k target. The first one checks if the M88k target has a particular target feature, supplied in the form of a string. Secondly, we add a function to <a id="_idIndexMarker923"/>validate the constraints when inline assembly is used. Finally, we have a function that checks if a specific CPU is valid for the M88k target, also supplied in the form of a string:<pre class="source-code">&#13;
  bool hasFeature(StringRef Feature) const override;&#13;
  bool validateAsmConstraint(const char *&amp;Name,&#13;
                             TargetInfo::ConstraintInfo &amp;info)                              const override;&#13;
  bool isValidCPUName(StringRef Name) const override;</pre></li>				<li>Next, let’s declare setter methods for our <code>M88kTargetInfo</code> class. The first one simply sets the specific M88k CPU that we want to target, while the second method sets a vector to contain all of the valid supported CPUs for M88k:<pre class="source-code">&#13;
  bool setCPU(const std::string &amp;Name) override;&#13;
  void fillValidCPUList(SmallVectorImpl&lt;StringRef&gt; &amp;Values)   const override;&#13;
};</pre></li>				<li>To complete our header for the driver implementation, let’s conclude our namespaces and macro definition that we added in the beginning:<pre class="source-code">&#13;
} // namespace targets&#13;
} // namespace clang&#13;
#endif // LLVM_CLANG_LIB_BASIC_TARGETS_M88K_H</pre></li>				<li>Now that we’ve completed the M88k header file within <code>clang/lib/Basic/Targets</code>, we must add the corresponding <code>TargetInfo</code> C++ implementation within <code>clang/lib/Basic/Targets/M88k.cpp</code>. We’ll start by including the required header files, especially the new <code>M88k.h</code> header we have just created:<pre class="source-code">&#13;
#include "M88k.h"&#13;
#include "clang/Basic/Builtins.h"&#13;
#include "clang/Basic/Diagnostic.h"&#13;
#include "clang/Basic/TargetBuiltins.h"&#13;
#include "llvm/ADT/StringExtras.h"&#13;
#include "llvm/ADT/StringRef.h"&#13;
#include "llvm/ADT/StringSwitch.h"&#13;
#include "llvm/TargetParser/TargetParser.h"&#13;
#include &lt;cstring&gt;</pre></li>				<li>As we did <a id="_idIndexMarker924"/>previously in the header, we start with the <code>clang</code> and <code>targets</code> namespaces, and then also begin implementing the constructor for the <code>M88kTargetInfo</code> class:<pre class="source-code">&#13;
namespace clang {&#13;
namespace targets {&#13;
M88kTargetInfo::M88kTargetInfo(const llvm::Triple &amp;Triple,&#13;
                               const TargetOptions &amp;)&#13;
    : TargetInfo(Triple) {</pre></li>				<li>Within the constructor, we set the data layout string for the M88k target. As you may have seen before, this data layout string is seen at the top of the emitted LLVM IR files. An explanation of each section of the data layout string is described here:<pre class="source-code">&#13;
  std::string Layout = "";&#13;
  Layout += "E"; // M68k is Big Endian&#13;
  Layout += "-m:e";&#13;
  Layout += "-p:32:32:32"; // Pointers are 32 bit.&#13;
  // All scalar types are naturally aligned.&#13;
  Layout += "-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64";&#13;
  // Floats and doubles are also naturally aligned.&#13;
  Layout += "-f32:32:32-f64:64:64";&#13;
  // We prefer 16 bits of aligned for all globals; see above.&#13;
  Layout += "-a:8:16";&#13;
  Layout += "-n32"; // Integer registers are 32bits.&#13;
  resetDataLayout(Layout);</pre></li>				<li>The constructor for the <code>M88kTargetInfo</code> class concludes by setting the various <a id="_idIndexMarker925"/>variable types as <code>signed long long</code>, <code>unsigned long</code>, or <code>signed int</code>:<pre class="source-code">&#13;
  IntMaxType = SignedLongLong;&#13;
  Int64Type = SignedLongLong;&#13;
  SizeType = UnsignedLong;&#13;
  PtrDiffType = SignedInt;&#13;
  IntPtrType = SignedInt;&#13;
}</pre></li>				<li>After that, the function to set the CPU for the target is implemented. This function takes a string and sets the CPU to be the particular CPU string that is supplied by the user within <code>llvm::StringSwitch</code>, which is essentially just a regular switch but specifically for strings with LLVM. We can see that there are three supported CPU types on the M88k target, and there is a <code>CK_Unknown</code> type for if the supplied string does not match any of the expected types:<pre class="source-code">&#13;
bool M88kTargetInfo::setCPU(const std::string &amp;Name) {&#13;
  StringRef N = Name;&#13;
  CPU = llvm::StringSwitch&lt;CPUKind&gt;(N)&#13;
            .Case("generic", CK_88000)&#13;
            .Case("mc88000", CK_88000)&#13;
            .Case("mc88100", CK_88100)&#13;
            .Case("mc88110", CK_88110)&#13;
            .Default(CK_Unknown);&#13;
  return CPU != CK_Unknown;&#13;
}</pre></li>				<li>It was <a id="_idIndexMarker926"/>previously stated that there are three supported and valid CPU types on the M88k target: <code>mc88000</code>, <code>mc88100</code>, and <code>mc88110</code>, with the <code>generic</code> type simply being the <code>mc88000</code> CPU. We must implement the following functions to enforce these valid CPUs within clang. First, we must declare an array of strings, <code>ValidCPUNames[]</code>, to denote the valid CPU names on M88k. Secondly, the <code>fillValidCPUList()</code> method populates the array of valid CPU names into a vector. This vector is then used in the <code>isValidCPUName()</code> method, to check whether a particular CPU name supplied is indeed valid for our M88k target:<pre class="source-code">&#13;
static constexpr llvm::StringLiteral ValidCPUNames[] = {&#13;
    {"generic"}, {"mc88000"}, {"mc88100"}, {"mc88110"}};&#13;
void M88kTargetInfo::fillValidCPUList(&#13;
    SmallVectorImpl&lt;StringRef&gt; &amp;Values) const {&#13;
  Values.append(std::begin(ValidCPUNames),   std::end(ValidCPUNames));&#13;
}&#13;
bool M88kTargetInfo::isValidCPUName(StringRef Name) const {&#13;
  return llvm::is_contained(ValidCPUNames, Name);&#13;
}</pre></li>				<li>Next, the <code>getTargetDefines()</code> method is implemented. This function defines the <a id="_idIndexMarker927"/>macros that are necessary for the frontend, such as the valid CPU types. Aside from the <code>__m88k__</code> and <code>__m88k</code> macros, we must also define corresponding CPU macros for the valid CPUs:<pre class="source-code">&#13;
void M88kTargetInfo::getTargetDefines(const LangOptions &amp;Opts,&#13;
                                      MacroBuilder &amp;Builder) const {&#13;
  using llvm::Twine;&#13;
  Builder.defineMacro("__m88k__");&#13;
  Builder.defineMacro("__m88k");&#13;
  switch (CPU) { // For sub-architecture&#13;
  case CK_88000:&#13;
    Builder.defineMacro("__mc88000__");&#13;
    break;&#13;
  case CK_88100:&#13;
    Builder.defineMacro("__mc88100__");&#13;
    break;&#13;
  case CK_88110:&#13;
    Builder.defineMacro("__mc88110__");&#13;
    break;&#13;
  default:&#13;
    break;&#13;
  }&#13;
}</pre></li>				<li>The next few functions are stub functions but are required for the frontend for basic support. This includes the functions to get builtins from a target and a function to <a id="_idIndexMarker928"/>query the target if a specific feature of the target is supported. For now, we’ll leave them unimplemented and set default return values for these functions so that they can be implemented later:<pre class="source-code">&#13;
ArrayRef&lt;Builtin::Info&gt; M88kTargetInfo::getTargetBuiltins() const {&#13;
  return std::nullopt;&#13;
}&#13;
bool M88kTargetInfo::hasFeature(StringRef Feature) const {&#13;
  return Feature == "M88000";&#13;
}</pre></li>				<li>Following these functions, we will add an implementation for the register names on M88k. Usually, the list of supported register names and their purposes can be found on the ABI of the specific platform of interest. Within this implementation, we’ll implement the main general-purpose registers from 0-31 and also create an array to store this information in. In terms of register aliases, note that there are no aliases for the registers that we implement currently:<pre class="source-code">&#13;
const char *const M88kTargetInfo::GCCRegNames[] = {&#13;
    "r0",  "r1",  "r2",  "r3",  "r4",  "r5",  "r6",  "r7",  &#13;
    "r8",  "r9",  "r10",  "r11", "r12", "r13", "r14", "r15", &#13;
    "r16", "r17", "r18",  "r19", "r20", "r21",  "r22", "r23", &#13;
    "r24", "r25", "r26", "r27", "r28", "r29",  "r39", "r31"};&#13;
ArrayRef&lt;const char *&gt; M88kTargetInfo::getGCCRegNames() const {&#13;
  return llvm::makeArrayRef(GCCRegNames);&#13;
}&#13;
ArrayRef&lt;TargetInfo::GCCRegAlias&gt; M88kTargetInfo::getGCCRegAliases() const {&#13;
  return std::nullopt; // No aliases.&#13;
}</pre></li>				<li>The last function we’ll implement is a function that validates the inline assembly constraints on our target. This function simply takes a character, which represents <a id="_idIndexMarker929"/>the inline assembly constraint, and handles the constraint accordingly. A few inline assembly register constraints are implemented, such as for the address, data, and floating-point registers, and a select few constraints for constants are also accounted for:<pre class="source-code">&#13;
bool M88kTargetInfo::validateAsmConstraint(&#13;
    const char *&amp;Name, TargetInfo::ConstraintInfo &amp;info) const {&#13;
  switch (*Name) {&#13;
  case 'a': // address register&#13;
  case 'd': // data register&#13;
  case 'f': // floating point register&#13;
    info.setAllowsRegister();&#13;
    return true;&#13;
  case 'K': // the constant 1&#13;
  case 'L': // constant -1^20 .. 1^19&#13;
  case 'M': // constant 1-4:&#13;
    return true;&#13;
  }&#13;
  return false;&#13;
}</pre></li>				<li>We conclude <a id="_idIndexMarker930"/>the file by closing off the <code>clang</code> and <code>targets</code> namespaces that we initiated at the beginning of the file:<pre class="source-code">&#13;
} // namespace targets&#13;
} // namespace clang</pre></li>			</ol>&#13;
			<p>After completing the implementation for <code>clang/lib/Basic/Targets/M88k.cpp</code>, the following implementation  of adding the M88k features group and valid CPU types within <code>clang/include/clang/Driver/Options.td</code>. is required.</p>&#13;
			<p>Recall from earlier that we previously defined three valid CPU types for our M88k target: <code>mc88000</code>, <code>mc88100</code>, and <code>mc88110</code>. These CPU types also need to be defined in <code>Options.td</code> since this file is the central place that defines all options and flags that will be accepted by clang:</p>&#13;
			<ol>&#13;
				<li>First, we must add <code>m_m88k_Features_Group</code>, which represents a group of features that will be available to the M88k target:<pre class="source-code">&#13;
def m_m88k_Features_Group: OptionGroup&lt;"&lt;m88k features group&gt;"&gt;,&#13;
                           Group&lt;m_Group&gt;, DocName&lt;"M88k"&gt;;</pre></li>				<li>Next, we must define the three valid M88k CPU types as a feature in the M88k features group:<pre class="source-code">&#13;
def m88000 : Flag&lt;["-"], "m88000"&gt;, Group&lt;m_m88k_Features_Group&gt;;&#13;
def m88100 : Flag&lt;["-"], "m88100"&gt;, Group&lt;m_m88k_Features_Group&gt;;&#13;
def m88110 : Flag&lt;["-"], "m88110"&gt;, Group&lt;m_m88k_Features_Group&gt;;</pre></li>			</ol>&#13;
			<p>With <a id="_idIndexMarker931"/>that, we have implemented the driver integration portion for connecting the M88k target with clang.</p>&#13;
			<h2 id="_idParaDest-217"><a id="_idTextAnchor232"/>Implementing ABI support for M88k within clang</h2>&#13;
			<p>Now, we need <a id="_idIndexMarker932"/>to add ABI support within the frontend for clang, which allows us to produce code specific to the M88k target from the frontend:</p>&#13;
			<ol>&#13;
				<li>Let’s start by adding the following <code>clang/lib/CodeGen/TargetInfo.h</code>. This is a prototype that creates the code generation information for the M88k target:<pre class="source-code">&#13;
std::unique_ptr&lt;TargetCodeGenInfo&gt; createM88kTargetCodeGenInfo(CodeGenModule &amp;CGM);</pre></li>				<li>We also need to add the following code to <code>clang/lib/Basic/Targets.cpp</code>, which will help teach clang the acceptable target triples for M88k. As we can see, for the M88k target, the acceptable operating system is OpenBSD. This means that clang accepts <code>m88k-openbsd</code> as a target triple:<pre class="source-code">&#13;
 #include "Targets/M88k.h"&#13;
 #include "Targets/MSP430.h"&#13;
. . .&#13;
   case llvm::Triple::m88k:&#13;
     switch (os) {&#13;
     case llvm::Triple::OpenBSD:&#13;
       return std::make_unique&lt;OpenBSDTargetInfo&lt;M88kTargetInfo&gt;&gt;(Triple, Opts);&#13;
     default:&#13;
       return std::make_unique&lt;M88kTargetInfo&gt;(Triple, Opts);&#13;
     }&#13;
   case llvm::Triple::le32:&#13;
. . .</pre><p class="list-inset">Now, we need to create a file called <code>clang/lib/CodeGen/Targets/M88k.cpp</code> so that we can continue the code generation information and ABI implementation for M88k.</p></li>				<li>Within <code>clang/lib/CodeGen/Targets/M88k.cpp</code>, we must add the following <a id="_idIndexMarker933"/>necessary headers, one of which is the <code>TargetInfo.h</code> header that we have just modified. Then, we must specify that we’re using the <code>clang</code> and <code>clang::codegen</code> namespaces:<pre class="source-code">&#13;
#include "ABIInfoImpl.h"&#13;
#include "TargetInfo.h"&#13;
using namespace clang;&#13;
using namespace clang::CodeGen;</pre></li>				<li>Next, we must declare a new anonymous namespace and place our <code>M88kABIInfo</code> inside of it. <code>M88kABIInfo</code> inherits from the existing <code>ABIInfo</code> from clang and contains <code>DefaultABIInfo</code> inside it. For our target, we rely heavily on the existing <code>ABIInfo</code> and <code>DefaultABIInfo</code>, which simplifies the <code>M88kABIInfo</code> class significantly:<pre class="source-code">&#13;
namespace {&#13;
class M88kABIInfo final : public ABIInfo {&#13;
  DefaultABIInfo defaultInfo;</pre></li>				<li>Furthermore, aside from adding the constructor for the <code>M88kABIInfo</code> class, a couple <a id="_idIndexMarker934"/>of methods are also added. <code>computeInfo()</code> implements the default <code>clang::CodeGen::ABIInfo</code> class. There’s also the <code>EmitVAArg()</code> function, which generates code that retrieves an argument from a pointer that is passed in; this is updated after. This is primarily used for variadic function support:<pre class="source-code">&#13;
public:&#13;
  explicit M88kABIInfo(CodeGen::CodeGenTypes &amp;CGT)&#13;
      : ABIInfo(CGT), defaultInfo(CGT) {}&#13;
  void computeInfo(CodeGen::CGFunctionInfo &amp;FI) const override {}&#13;
  CodeGen::Address EmitVAArg(CodeGen::CodeGenFunction &amp;CGF,&#13;
                             CodeGen::Address VAListAddr,&#13;
                             QualType Ty) const override {&#13;
    return VAListAddr;&#13;
  }&#13;
};</pre></li>				<li>The class constructor for the <code>M88kTargetCodeGenInfo</code> class is added next, which extends from the original <code>TargetCodeGenInfo</code>. After, we must close off the anonymous namespace that was created initially:<pre class="source-code">&#13;
class M88kTargetCodeGenInfo final : public TargetCodeGenInfo {&#13;
public:&#13;
  explicit M88kTargetCodeGenInfo(CodeGen::CodeGenTypes &amp;CGT)&#13;
      : TargetCodeGenInfo(std::make_unique&lt;DefaultABIInfo&gt;(CGT)) {} };&#13;
}</pre></li>				<li>Finally, we <a id="_idIndexMarker935"/>must add the implementation to create the actual <code>M88kTargetCodeGenInfo</code> class as <code>std::unique_ptr</code>, which takes in a single <code>CodeGenModule</code> that generates LLVM IR code. This directly corresponds to what was originally added to <code>TargetInfo.h</code>:<pre class="source-code">&#13;
std::unique_ptr&lt;TargetCodeGenInfo&gt;&#13;
CodeGen::createM88kTargetCodeGenInfo(CodeGenModule &amp;CGM) {&#13;
  return std::make_unique&lt;M88kTargetCodeGenInfo&gt;(CGM.getTypes());&#13;
}</pre></li>			</ol>&#13;
			<p>That concludes the ABI support for the M88k in the frontend.</p>&#13;
			<h2 id="_idParaDest-218"><a id="_idTextAnchor233"/>Implementing the toolchain support for M88k within clang</h2>&#13;
			<p>The <a id="_idIndexMarker936"/>final portion of the M88k target integration within clang will be to implement toolchain support for our target.  Like before, we’ll need to create a header file for toolchain support. We call this header <code>clang/lib/Driver/ToolChains/Arch/M88k.h</code>:</p>&#13;
			<ol>&#13;
				<li>First, we must define <code>LLVM_CLANG_LIB_DRIVER_TOOLCHAINS_ARCH_M88K_H</code> to prevent multiple inclusion later, and also add any necessary headers for later use. Following this, we must declare the <code>clang</code>, <code>driver</code>, <code>tools</code>, and <code>m88k</code> namespaces, with each nesting inside the other:<pre class="source-code">&#13;
#ifndef LLVM_CLANG_LIB_DRIVER_TOOLCHAINS_ARCH_M88K_H&#13;
#define LLVM_CLANG_LIB_DRIVER_TOOLCHAINS_ARCH_M88K_H&#13;
#include "clang/Driver/Driver.h"&#13;
#include "llvm/ADT/StringRef.h"&#13;
#include "llvm/Option/Option.h"&#13;
#include &lt;string&gt;&#13;
#include &lt;vector&gt;&#13;
namespace clang {&#13;
namespace driver {&#13;
namespace tools {&#13;
namespace m88k {</pre></li>				<li>Next, we must declare an <code>enum</code> value that depicts the floating-point ABI, which is for <a id="_idIndexMarker937"/>soft and hard floating points. This means that floating-point computations can either be done by the floating-point hardware itself, which is fast, or through software emulation, which would be slower:<pre class="source-code">&#13;
enum class FloatABI { Invalid, Soft, Hard, };</pre></li>				<li>Following this, we must add definitions to get the float ABI through the driver, and the CPU through clang’s <code>-mcpu=</code> and <code>-mtune=</code> options. We must also declare a function that retrieves the target features from the driver:<pre class="source-code">&#13;
FloatABI getM88kFloatABI(const Driver &amp;D, const llvm::opt::ArgList &amp;Args);&#13;
StringRef getM88kTargetCPU(const llvm::opt::ArgList &amp;Args);&#13;
StringRef getM88kTuneCPU(const llvm::opt::ArgList &amp;Args);&#13;
void getM88kTargetFeatures(const Driver &amp;D, const llvm::Triple &amp;Triple, const llvm::opt::ArgList &amp;Args, std::vector&lt;llvm::StringRef&gt; &amp;Features);</pre></li>				<li>Finally, we conclude the header file by ending the namespaces and the macro that we originally defined:<pre class="source-code">&#13;
} // end namespace m88k&#13;
} // end namespace tools&#13;
} // end namespace driver&#13;
} // end namespace clang&#13;
#endif // LLVM_CLANG_LIB_DRIVER_TOOLCHAINS_ARCH_M88K_H</pre></li>			</ol>&#13;
			<p>The <a id="_idIndexMarker938"/>last file we will implement is the C++ implementation for the toolchain support, within <code>clang/lib/Driver/ToolChains/Arch/M88k.cpp</code>:</p>&#13;
			<ol>&#13;
				<li>Once again, we’ll begin the implementation by including the necessary headers and namespaces that we will use later. We must also include the <code>M88k.h</code> header that we created earlier:<pre class="source-code">&#13;
#include "M88k.h"&#13;
#include "ToolChains/CommonArgs.h"&#13;
#include "clang/Driver/Driver.h"&#13;
#include "clang/Driver/DriverDiagnostic.h"&#13;
#include "clang/Driver/Options.h"&#13;
#include "llvm/ADT/SmallVector.h"&#13;
#include "llvm/ADT/StringSwitch.h"&#13;
#include "llvm/Option/ArgList.h"&#13;
#include "llvm/Support/Host.h"&#13;
#include "llvm/Support/Regex.h"&#13;
#include &lt;sstream&gt;&#13;
using namespace clang::driver;&#13;
using namespace clang::driver::tools;&#13;
using namespace clang;&#13;
using namespace llvm::opt;</pre></li>				<li>The <code>normalizeCPU()</code> function is implemented next, which processes the CPU <a id="_idIndexMarker939"/>name into the <code>-mcpu=</code> option in clang. As we can see, each CPU name has several accepted variations. Furthermore, when a user specifies <code>-mcpu=native</code>, it allows them to compile for the current host’s CPU type:<pre class="source-code">&#13;
static StringRef normalizeCPU(StringRef CPUName) {&#13;
  if (CPUName == "native") {&#13;
    StringRef CPU = std::string(llvm::sys::getHostCPUName());&#13;
    if (!CPU.empty() &amp;&amp; CPU != "generic")&#13;
      return CPU;&#13;
  }&#13;
  return llvm::StringSwitch&lt;StringRef&gt;(CPUName)&#13;
      .Cases("mc88000", "m88000", "88000", "generic", "mc88000")&#13;
      .Cases("mc88100", "m88100", "88100", "mc88100")&#13;
      .Cases("mc88110", "m88110", "88110", "mc88110")&#13;
      .Default(CPUName);&#13;
}</pre></li>				<li>Next up, we must implement the <code>getM88kTargetCPU()</code> function, in which, given the clang CPU name that we implemented earlier in <code>clang/include/clang/Driver/Options.td</code>, we get the corresponding LLVM name for the M88k CPU we are targeting:<pre class="source-code">&#13;
StringRef m88k::getM88kTargetCPU(const ArgList &amp;Args) {&#13;
  Arg *A = Args.getLastArg(options::OPT_m88000, options::OPT_m88100, options::OPT_m88110, options::OPT_mcpu_EQ);&#13;
  if (!A)&#13;
    return StringRef();&#13;
  switch (A-&gt;getOption().getID()) {&#13;
  case options::OPT_m88000:&#13;
    return "mc88000";&#13;
  case options::OPT_m88100:&#13;
    return "mc88100";&#13;
  case options::OPT_m88110:&#13;
    return "mc88110";&#13;
  case options::OPT_mcpu_EQ:&#13;
    return normalizeCPU(A-&gt;getValue());&#13;
  default:&#13;
    llvm_unreachable("Impossible option ID");&#13;
  }&#13;
}</pre></li>				<li>The <code>getM88kTuneCPU()</code> function is implemented after. This is the behavior of the <a id="_idIndexMarker940"/>clang <code>-mtune=</code> option, which changes the instruction scheduling model to use data from a given CPU for M88k. We simply tune for whatever CPU that we are currently targeting:<pre class="source-code">&#13;
StringRef m88k::getM88kTuneCPU(const ArgList &amp;Args) {&#13;
  if (const Arg *A = Args.getLastArg(options::OPT_mtune_EQ))&#13;
    return normalizeCPU(A-&gt;getValue());&#13;
  return StringRef();&#13;
}</pre></li>				<li>We’ll <a id="_idIndexMarker941"/>also implement the <code>getM88kFloatABI()</code> method, which gets the floating-point ABI. Initially, we’ll set the ABI to be <code>m88k::FloatABI::Invalid</code> as a default value. Next, we must check if any of the <code>-msoft-float</code> or <code>-mhard-float</code> options are passed to the command line. If <code>-msoft-float</code> is specified, then we set the ABI to <code>m88k::FloatABI::Soft</code> accordingly. Likewise, we set <code>m88k::FloatABI::Hard</code> when <code>-mhard-float</code> is specified to clang. Finally, if none of these options are specified, we choose the default on the current platform, which would be a hard floating-point value for M88k:<pre class="source-code">&#13;
m88k::FloatABI m88k::getM88kFloatABI(const Driver &amp;D, const ArgList &amp;Args) {&#13;
  m88k::FloatABI ABI = m88k::FloatABI::Invalid;&#13;
  if (Arg *A =&#13;
          Args.getLastArg(options::OPT_msoft_float, options::OPT_mhard_float)) {&#13;
    if (A-&gt;getOption().matches(options::OPT_msoft_float))&#13;
      ABI = m88k::FloatABI::Soft;&#13;
    else if (A-&gt;getOption().matches(options::OPT_mhard_float))&#13;
      ABI = m88k::FloatABI::Hard;&#13;
  }&#13;
  if (ABI == m88k::FloatABI::Invalid)&#13;
    ABI = m88k::FloatABI::Hard;&#13;
  return ABI;&#13;
}</pre></li>				<li>We’ll add the implementation for <code>getM88kTargetFeatures()</code> next. The important <a id="_idIndexMarker942"/>part of this function is the vector of <code>Features</code> that are passed as a parameter. As we can see, the only target features that are handled are the floating-point ABI. From the driver and arguments passed to it, we’ll get the appropriate floating-point ABI from what we implemented in the previous step. Note that we add the <code>-hard-float</code> target features to the <code>Features</code> vector for soft float ABI as well, which means that currently, M88k only supports hard float:<pre class="source-code">&#13;
void m88k::getM88kTargetFeatures(const Driver &amp;D, const llvm::Triple &amp;Triple,&#13;
                                 const ArgList &amp;Args,&#13;
                                 std::vector&lt;StringRef&gt; &amp;Features) {&#13;
  m88k::FloatABI FloatABI = m88k::getM88kFloatABI(D, Args);&#13;
  if (FloatABI == m88k::FloatABI::Soft)&#13;
    Features.push_back("-hard-float");&#13;
}</pre></li>			</ol>&#13;
			<h2 id="_idParaDest-219"><a id="_idTextAnchor234"/>Building the M88k target with clang integration</h2>&#13;
			<p>We’re <a id="_idIndexMarker943"/>almost done with the implementation for integrating M88k into clang. The last step is to add the new clang files that we have added into their corresponding <code>CMakeLists.txt</code> file, which allows us to build the clang project with our M88k target implementation:</p>&#13;
			<ol>&#13;
				<li>First, add the <code>Targets/M88k.cpp</code> line to <code>clang/lib/Basic/CMakeLists.txt</code>.</li>&#13;
				<li>Next, add <code>Targets/M88k.cpp</code> to <code>clang/lib/CodeGen/CMakeLists.txt</code>.</li>&#13;
				<li>Finally, add <code>ToolChains/Arch/M88k.cpp</code> to <code>clang/lib/Driver/CMakeLists.txt</code>.</li>&#13;
			</ol>&#13;
			<p>There we have it! That concludes our toolchain implementation for the toolchain support for <a id="_idIndexMarker944"/>the M88k target, which subsequently means we’ve completed the integration into clang for M88k!</p>&#13;
			<p>The last step we need to do is build clang with the M88k target. The following commands will build the clang and LLVM project. For clang, be aware of the M88k target. Here, the <code>-DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD=M88k</code> CMake option must be added, as in the previous section:</p>&#13;
			<pre class="console">&#13;
$ cmake -G Ninja ../llvm-project/llvm -DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD=M88k -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_PROJECTS="clang;llvm"&#13;
$ ninja</pre>			<p>We should now have a version of clang that recognizes the M88k target! We can confirm this by checking the list of targets that clang supports, through the <code>–</code><code>print-targets</code> option:</p>&#13;
			<pre class="console">&#13;
$ clang --print-targets | grep M88k&#13;
    m88k        - M88k</pre>			<p>In this section, we delved into the technical details of integrating a new backend target into clang and having it recognized. In the next section, we’ll explore the concept of cross-compiling, where we detail the procedure of targeting a different CPU architecture from the current host.</p>&#13;
			<h1 id="_idParaDest-220"><a id="_idTextAnchor235"/>Targeting a different CPU architecture</h1>&#13;
			<p>Today, many small computers, such as the Raspberry Pi, are in use despite having only limited resources. Running a compiler on such a computer is often not possible or it takes too much time. Thus, a common requirement for a compiler is to generate code for a different <a id="_idIndexMarker945"/>CPU architecture. The whole process of having a host compile an executable for a different target is called cross-compiling.</p>&#13;
			<p>In cross-compiling, two systems are involved: the host system and the target system. The compiler runs on the host system and produces code for the target system. To denote the systems, the so-called triple is used. This is a configuration string that usually consists of the CPU architecture, the vendor, and the operating system. Furthermore, additional information about the environment is often added to the configuration string. For example, the <code>x86_64-pc-win32</code> triple is used for a Windows system running on a 64-bit X86 CPU. The CPU architecture is <code>x86_64</code>, <code>pc</code> is a generic vendor, and <code>win32</code> is the operating system, and all of these pieces are connected by a hyphen. A Linux system running on an ARMv8 CPU uses <code>aarch64-unknown-linux-gnu</code> as the triple, with <code>aarch64</code> as the CPU architecture. Moreover, the operating system is <code>linux</code>, running a <code>gnu</code> environment. There is no real vendor for a Linux-based system, so this part is <code>unknown</code>. Additionally, parts that are not known or unimportant for a specific purpose are often omitted: the <code>aarch64-linux-gnu</code> triple describes the same Linux system.</p>&#13;
			<p>Let’s assume your development machine runs Linux on an X86 64-bit CPU and you want to cross-compile to an ARMv8 CPU system running Linux. The host triple is <code>x86_64-linux-gnu</code> and the target triple is <code>aarch64-linux-gnu</code>. Different systems have different characteristics. Thus, your application must be written in a portable fashion; otherwise, complications may arise. Some common pitfalls are as follows:</p>&#13;
			<ul>&#13;
				<li><strong class="bold">Endianness</strong>: The order in which multi-byte values are stored in memory can be different.</li>&#13;
				<li><code>int</code> type may not be large enough to hold a pointer.</li>&#13;
				<li><code>long double</code> type can use 64-bit (ARM), 80-bit (X86), or 128-bit (ARMv8). PowerPC systems may use double-double arithmetic for <code>long double</code>, which gives more precision by using a combination of two 64-bit <code>double</code> values.</li>&#13;
			</ul>&#13;
			<p>If you do not pay attention to these points, then your application can act surprisingly or crash on the target platform, even if it runs perfectly on your host system. The LLVM libraries are tested on different platforms and also contain portable solutions to the aforementioned issues.</p>&#13;
			<p>For cross-compiling, the following tools are required:</p>&#13;
			<ul>&#13;
				<li>A compiler that generates code for the target</li>&#13;
				<li>A linker capable of generating binaries for the target</li>&#13;
				<li>Header files and libraries for the target</li>&#13;
			</ul>&#13;
			<p>Fortunately, the Ubuntu and Debian distributions have packages that support cross-compiling. We’re <a id="_idIndexMarker946"/>taking advantage of this in the following setup. The <code>gcc</code> and <code>g++</code> compilers, the linker, <code>ld</code>, and the libraries are available as precompiled binaries that produce ARMv8 code and executables. The following command installs all of these packages:</p>&#13;
			<pre class="console">&#13;
$ sudo apt –y install gcc-12-aarch64-linux-gnu \&#13;
  g++-12-aarch64-linux-gnu binutils-aarch64-linux-gnu \&#13;
  libstdc++-12-dev-arm64-cross</pre>			<p>The new files are installed under the <code>/usr/aarch64-linux-gnu</code> directory. This directory is the (logical) root directory of the target system. It contains the usual <code>bin</code>, <code>lib</code>, and <code>include</code> directories. The cross-compilers (<code>aarch64-linux-gnu-gcc-8</code> and <code>aarch64-linux-gnu-g++-8</code>) are aware of this directory.</p>&#13;
			<p class="callout-heading">Cross-compiling on other systems</p>&#13;
			<p class="callout">Some distributions, such as Fedora, only provide cross-compiling support for bare-metal targets such <a id="_idIndexMarker947"/>as the Linux kernel, but the header and library files needed for user land applications are not provided. In such a case, you can simply copy the missing files from your target system.</p>&#13;
			<p class="callout">If your distribution does not come with the required toolchain, then you can build it from source. For the compiler, you can use clang or gcc/g++. The gcc and g++ compilers must be configured to produce code for the target system and the binutils tools need to handle files for the target system. Moreover, the C and C++ libraries need to be compiled with this toolchain. The steps vary by operating system and host and target architecture. On the web, you can find instructions if you search for <code>gcc </code><code>cross-compile &lt;architecture&gt;</code>.</p>&#13;
			<p>With this preparation, you are almost ready to cross-compile the sample application (including the LLVM libraries) except <a id="_idIndexMarker948"/>for one little detail. LLVM uses the <code>llvm-tblgen</code> from the build in <a href="B19561_01.xhtml#_idTextAnchor017"><em class="italic">Chapter 1</em></a> or you can <a id="_idIndexMarker949"/>compile only this tool. Assuming you are in the directory that contains the clone of this book’s GitHub repository, type the following:</p>&#13;
			<pre class="console">&#13;
$ mkdir build-host&#13;
$ cd build-host&#13;
$ cmake -G Ninja \&#13;
  -DLLVM_TARGETS_TO_BUILD="X86" \&#13;
  -DLLVM_ENABLE_ASSERTIONS=ON \&#13;
  -DCMAKE_BUILD_TYPE=Release \&#13;
  ../llvm-project/llvm&#13;
$ ninja llvm-tblgen&#13;
$ cd ..</pre>			<p>These steps should be familiar by now. A build directory is created and entered. The <code>cmake</code> command creates the build files for LLVM only for the X86 target. To save space and time, a release build is done but assertions are enabled to catch possible errors. Only the <code>llvm-tblgen</code> tool is compiled with <code>ninja</code>.</p>&#13;
			<p>With the <code>llvm-tblgen</code> tool at hand, you can now start the cross-compilation process. The CMake command line is very long, so you may want to store the command in a script file. The difference from previous builds is that more information must be provided:</p>&#13;
			<pre class="console">&#13;
$ mkdir build-target&#13;
$ cd build-target&#13;
$ cmake -G Ninja \&#13;
  -DCMAKE_CROSSCOMPILING=True \&#13;
  -DLLVM_TABLEGEN=../build-host/bin/llvm-tblgen \&#13;
  -DLLVM_DEFAULT_TARGET_TRIPLE=aarch64-linux-gnu \&#13;
  -DLLVM_TARGET_ARCH=AArch64 \&#13;
  -DLLVM_TARGETS_TO_BUILD=AArch64 \&#13;
  -DLLVM_ENABLE_ASSERTIONS=ON \&#13;
  -DLLVM_EXTERNAL_PROJECTS=tinylang \&#13;
  -DLLVM_EXTERNAL_TINYLANG_SOURCE_DIR=../tinylang \&#13;
  -DCMAKE_INSTALL_PREFIX=../target-tinylang \&#13;
  -DCMAKE_BUILD_TYPE=Release \&#13;
  -DCMAKE_C_COMPILER=aarch64-linux-gnu-gcc-12 \&#13;
  -DCMAKE_CXX_COMPILER=aarch64-linux-gnu-g++-12 \&#13;
  ../llvm-project/llvm&#13;
$ ninja</pre>			<p>Again, you create a build directory and enter it before running the CMake command. Some of <a id="_idIndexMarker950"/>these CMake parameters have not been used before and require some explanation:</p>&#13;
			<ul>&#13;
				<li><code>CMAKE_CROSSCOMPILING</code> set to <code>ON</code> tells CMake that we are cross-compiling.</li>&#13;
				<li><code>LLVM_TABLEGEN</code> specifies the path to the <code>llvm-tblgen</code> tool to use. This is the one from the previous build.</li>&#13;
				<li><code>LLVM_DEFAULT_TARGET_TRIPLE</code> is the triple of the target architecture.</li>&#13;
				<li><code>LLVM_TARGET_ARCH</code> is used for <strong class="bold">JIT</strong> code generation. It defaults to the architecture of the host. For cross-compiling, this must be set to the target architecture.</li>&#13;
				<li><code>LLVM_TARGETS_TO_BUILD</code> is the list of targets for which LLVM should include code generators. The list should at least include the target architecture.</li>&#13;
				<li><code>CMAKE_C_COMPILER</code> and <code>CMAKE_CXX_COMPILER</code> specify the C and C++ compilers used for the build, respectively. The binaries of the cross-compilers are prefixed with the target triple and are not found automatically by CMake.</li>&#13;
			</ul>&#13;
			<p>With the <a id="_idIndexMarker951"/>other parameters, a release build with assertions enabled is requested and our tinylang application is built as part of LLVM. Once the compilation process has finished, the <code>file</code> command can demonstrate that we have created a binary for ARMv8. Specifically, we can run <code>$ file bin/tinylang</code> and check that the output says <code>ELF 64-bit object for the ARM </code><code>aarch64 architecture</code>.</p>&#13;
			<p class="callout-heading">Cross-compiling with clang</p>&#13;
			<p class="callout">As LLVM generates code for different architectures, it seems obvious to use clang to cross-compile. The obstacle here is that LLVM does not provide all the required parts – for example, the C library is missing. Because of this, you must use a mix of LLVM and GNU tools and as a result, you need to tell CMake even more about the environment you are using. As a minimum, you need to specify the following options for clang and clang++: <code>--target=&lt;target-triple&gt;</code> (enables code generation for a different target), <code>--sysroot=&lt;path&gt;</code> (path to the root directory for the target), <code>I</code> (search path for header files), and <code>–L</code> (search path for libraries). During the CMake run, a small application is compiled and CMake complains if something is wrong with your setup. This step is sufficient to check if you have a working environment. Common problems are picking the wrong header files or link failures due to different library names or wrong search paths.</p>&#13;
			<p>Cross-compiling is surprisingly complex. With the instructions from this section, you will be able to cross-compile your application for a target architecture of your choice.</p>&#13;
			<h1 id="_idParaDest-221"><a id="_idTextAnchor236"/>Summary</h1>&#13;
			<p>In this chapter, you learned about creating passes that run beyond instruction selection, specifically exploring the creation behind machine function passes in the backend! You also discovered how to add a new experimental target into clang, and some of the driver, ABI, and toolchain changes that are required. Finally, while considering the supreme discipline of compiler construction, you learned how to cross-compile your application for another target architecture.</p>&#13;
			<p>Now that we’re at the end of <em class="italic">Learn LLVM 17</em>, you are equipped with the knowledge to use LLVM in creative ways in your projects and have explored many interesting topics. The LLVM ecosystem is very active, and new features are added all the time, so be sure to follow its development!</p>&#13;
			<p>As compiler developers ourselves, it was a pleasure for us to write about LLVM and discover some new features along the way. Have fun with LLVM!</p>&#13;
		</p>&#13;
	</div></body></html>