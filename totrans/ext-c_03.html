<html><head></head><body>
		<div id="_idContainer048">
			<h1 class="chapterNumber">Chapter 0<a id="_idTextAnchor093"/>3</h1>
			<h1 id="_idParaDest-61" class="chapterTitle" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor094"/>Object Files</h1>
			<p class="normal">This chapter details the various products that a C/C++ project can have. Possible products include relocatable object files, executable object files, static libraries, and shared object files. However, relocatable object files are considered to be temporary products and they act as ingredients for making other types of products that are final.</p>
			<p class="normal">It seems that today in C, it's crucial to have further discussion about the various types of object files and their internal structures. The majority of C books only talk about the C syntax and the language itself; but, in real-world you need more in-depth knowledge to be a successful C programmer.</p>
			<p class="normal">When you are creating software, it is not just about the development and the programming language. In fact, it is about the whole process: writing the code, compilation, optimization, producing correct products, and further subsequent steps, in order to run and maintain those products on the target platforms.</p>
			<p class="normal">You should be knowledgeable about these intermediate steps, to the extent that you are able to solve any issues you might encounter. This is even more serious regarding embedded development, as the hardware architectures and the instruction sets can be challenging and atypical.</p>
			<p class="normal">This chapter is divided into the following sections:</p>
			<ol>
				<li class="list"><strong class="bold">Application binary interface</strong>: Here, we are first going to talk about the <strong class="bold">Application Binary Interface</strong> (<strong class="bold">ABI</strong>) and its importance.</li>
				<li class="list"><strong class="bold">Object file formats</strong>: In this section, we talk about various object file formats that exist today or they have become obsolete over the years. We also introduce ELF as the most used object file format in Unix-like systems.</li>
				<li class="list"><strong class="bold">Relocatable object files</strong>: Here we discuss relocatable object files and the very first products of a C project. We take a look inside ELF relocatable object files to see what we can find there.</li>
				<li class="list"><strong class="bold">Executable object files</strong>: As part of this section, we talk about the executable object files. We also explain how they are created from a number of relocatable object files. We discuss the differences between ELF relocatable and executable object files in terms of their internal structure.</li>
				<li class="list"><strong class="bold">Static library</strong>: In this section, we talk about static libraries and how we can create them. We also demonstrate how to write a program and use already built static libraries.</li>
			</ol>
			<ol>
				<li class="list" value="6"><strong class="bold">Dynamic library</strong>: Here we talk about shared object files. We demonstrate how to create them out of a number of relocatable object files and how to use them in a program. We also briefly talk about the internal structure of an ELF shared object file.</li>
			</ol>
			<p class="normal">Our discussions in this chapter will be mostly themed around Unix-like systems, but we will discuss some differences in other operating systems like Microsoft Windows.</p>
			<div>
				<div id="_idContainer041" class="note">
					<p class="Information-Box--PACKT-"><strong class="screen-text">Note</strong>:</p>
					<p class="Information-Box--PACKT-">Before moving on to read this chapter, you need to be familiar with the basic ideas and steps required for building a C project. You need to know what a translation unit is and how linking is different from compilation. Please read the previous chapter before moving on with this one.</p>
				</div>
			</div>
			<p class="normal">Let's begin the chapter by talking about ABI.</p>
			<h1 id="_idParaDest-62" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor095"/>Application binary interface (ABI)</h1>
			<p class="normal">As you may already <a id="_idIndexMarker243"/>know, every library or framework, regardless of the technologies or the programming language used, exposes a set of certain functionalities, which is known as its <strong class="bold">Application Programming Interface</strong> (<strong class="bold">API</strong>). If a library is supposed to be used by another code, then the consumer code should use the provided API. To be clear, nothing other than the API should be used in order to use a library because it is the public interface of the library and everything else is seen as a black box, hence cannot be used.</p>
			<p class="normal">Now suppose after some time, the library's API undergoes some modifications. In order for the consumer code to continue using the newer versions of the library, the code must adapt itself to the new API; otherwise, it won't be able to use it anymore. The consumer code could stick to a certain version of the library (maybe an old one) and ignore the newer versions, but let's assume that there is a desire to upgrade to the latest version of the library.</p>
			<p class="normal">To put it simply, an API is like a convention (or standard) accepted between two software components to serve or use each other. An ABI is pretty similar to API, but at a different level. While the API guarantees the compatibility of two software components to continue their functional cooperation, the ABI guarantees that two programs are compatible at the level of their machine-level instructions, together with their corresponding object files.</p>
			<p class="normal">For instance, a program cannot use a dynamic or static library that has a different ABI. Perhaps worse than that, an executable file (which is, in fact, an object file) cannot be run on a system<a id="_idIndexMarker244"/> supporting a different ABI than the one that the executable file was built for. A number of vital and obvious system functionalities, such as <em class="italics">dynamic linking</em>, <em class="italics">loading an executable</em>, and <em class="italics">function calling convention</em>, should be done precisely according to an agreed upon ABI.</p>
			<p class="normal">An ABI will typically cover the following things:</p>
			<ul>
				<li class="list">The instruction set of the target architecture, which includes the processor instructions, memory layout, endianness, registers, and so on.</li>
				<li class="list">Existing data types, their sizes, and the alignment policy.</li>
				<li class="list">The function calling convention describes how functions should be called. For example, subjects like the structure of the <em class="italics">stack frame</em> and the pushing order of the arguments are part of it.</li>
				<li class="list">Defining how <em class="italics">system calls</em> should be called in a Unix-like system.</li>
				<li class="list">Used <em class="italics">object file format</em>, which we will explain in the following section, for having <em class="italics">relocatable, executable</em>, and <em class="italics">shared object files</em>.</li>
				<li class="list">Regarding object files produced by a C++ compiler, the <em class="italics">name mangling</em>, <em class="italics">virtual table</em> layout, is part of the ABI.</li>
			</ul>
			<p class="normal">The <em class="italics">System V ABI</em> is the most widely used ABI standard among Unix-like operating systems like Linux and the BSD<a id="_idIndexMarker245"/> systems. <strong class="bold">Executable and Linking Format</strong> (<strong class="bold">ELF</strong>) is the standard object file format used in the System V ABI.</p>
			<div>
				<div id="_idContainer042" class="note">
					<p class="Information-Box--PACKT-"><strong class="screen-text">Note</strong>:</p>
					<p class="Information-Box--PACKT-">The following link is the System V ABI for AMD 64-bit architectur<a href="https://www.uclibc.org/docs/psABI-x86_64.pdf">e: <span class="url">https://www.uclibc.org/docs/psABI-x86_64.</span></a><span class="url">pdf</span>. You can go through the list of contents and see the areas it covers.</p>
				</div>
			</div>
			<p class="normal">In the following section, we will discuss the object file formats, particularly E<a id="_idTextAnchor096"/>LF.</p>
			<h1 id="_idParaDest-63" class="title" lang="en-GB" xml:lang="en-GB">Object file forma<a id="_idTextAnchor097"/>ts</h1>
			<p class="normal">As we explained in the previous chapter, <em class="italics">Chapter 2</em>, <em class="italics">Compilation and Linking</em>, on a platform, object files <a id="_idIndexMarker246"/>have their own specific format for storing machine-level instructions. Note that this is about the structure of object files and this is different from the fact that each architecture has its own instruction set. As we know from the previous discussion, these two variations are different parts of the ABI in a platform; the object file format and the architecture's instruction set.</p>
			<p class="normal">In this section, we are going to have a brief look into some widely known object file formats. To start with, let's look at<a id="_idIndexMarker247"/> some object file formats used in various operating systems:</p>
			<ul>
				<li class="list"><strong class="bold">ELF</strong> used by Linux and many other Unix-like operating systems</li>
				<li class="list"><strong class="bold">Mach-O</strong> used in OS X (macOS and iOS) systems</li>
				<li class="list"><strong class="bold">PE</strong> used in Microsoft Windows</li>
			</ul>
			<p class="normal">To give some history and context about the current and past object file formats, we can say that all object file formats that exist today are successors to the old <code class="Code-In-Text--PACKT-">a.out</code> object file format. It was designed for early versions of Unix.</p>
			<p class="normal">The term <strong class="bold">a.out</strong> stands for <strong class="bold">assembler output</strong>. Despite the fact that the file format is obsolete today, the <a id="_idIndexMarker248"/>name is still used as the default filename for the executable files produced by most linkers. You should remember seeing <code class="Code-In-Text--PACKT-">a.out</code> in a number of examples in the first chapter of the book.</p>
			<p class="normal">However, the <code class="Code-In-Text--PACKT-">a.out</code> format was<a id="_idIndexMarker249"/> soon replaced by <strong class="bold">COFF</strong> or the <strong class="bold">Common Object File Format</strong>. COFF is the basis for ELF – the object format that we use in most Unix-like systems. Apple also replaced <code class="Code-In-Text--PACKT-">a.out</code> with Mach-O as part of OS/X. Windows<a id="_idIndexMarker250"/> uses the <strong class="bold">PE</strong> or <strong class="bold">Portable Execution</strong> file format for its object files, which is based on COFF.</p>
			<div>
				<div id="_idContainer043" class="note">
					<p class="Information-Box--PACKT-"><strong class="screen-text">Note</strong>:</p>
					<p class="Information-Box--PACKT-">A deeper history of<a id="_idIndexMarker251"/> object file formats can be found here: <a href="https://en.wikipedia.org/wiki/COFF#History"><span class="url">https://en.wikipedia.org/wiki/COFF#History</span></a>. Knowing about the history of a specific topic will help you to get a better understanding of its evolution path and current and past characteristics.</p>
				</div>
			</div>
			<p class="normal">As you can see, all of today's major object file formats are based on the historic object file format <code class="Code-In-Text--PACKT-">a.out</code>, and then COFF, and in many ways share the same <a id="_idTextAnchor098"/>ancestry.</p>
			<p class="normal">ELF is the standard object file format used in Linux and most Unix-like operating systems. In fact, ELF is the object file format used as part of the System V ABI, heavily employed in most Unix systems. Today, it is the most widely accepted object file format used by operating systems.</p>
			<p class="normal">ELF is the standard binary file format for operating systems including, but not limited to:</p>
			<ul>
				<li class="list">Linux</li>
				<li class="list">FreeBSD</li>
				<li class="list">NetBSD</li>
				<li class="list">Solaris</li>
			</ul>
			<p class="normal">This means that as long as the architecture beneath them remains the same, an ELF object file created for one of <a id="_idIndexMarker252"/>these operating systems can be run and used in others. ELF, like all other <em class="italics">file formats</em>, has a structure that we will describe briefly in the upcoming sections.</p>
			<div>
				<div id="_idContainer044" class="note">
					<p class="Information-Box--PACKT-"><strong class="screen-text">Note</strong>:</p>
					<p class="Information-Box--PACKT-">More information about<a id="_idIndexMarker253"/> ELF and its details can be f<a href="https://www.uclibc.org/docs/psABI-x86_64.pdf">ound here: <span class="url">https://www.uclibc.org/docs/psABI</span></a><span class="url">-x86_64.pdf</span>. Note that this link refers to the System V ABI for AMD 64-bits (<code class="Code-In-Text--PACKT-">amd64</code>) architecture.</p>
					<p class="Information-Box--PACKT-">You can also read the<a id="_idIndexMarker254"/> HTML version of the System V ABI here: <a href="http://www.sco.com/developers/gabi/2003-12-17/ch4.intro.html"><span class="url">http://www.sco.com/developers/gabi/2003-12-17/ch4.intro.html</span></a>.</p>
				</div>
			</div>
			<p class="normal">In the upcoming sections, we are going to talk about the temporary and final products of a C project. We start with relocatable object files.</p>
			<h1 id="_idParaDest-64" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor099"/>Relocatable object files</h1>
			<p class="normal">In this section, we are going to talk about<a id="_idIndexMarker255"/> relocatable object files. As we explained in the previous chapter, these object files are the output of the assembly step in the C compilation pipeline. These files are considered to be temporary products of a C project, and they are the main ingredients to produce further and final products. For this reason, it would be useful to have a deeper look at them and see what we can find in a relocatable object file.</p>
			<p class="normal">In a relocatable object file, we can find the following items regarding the compiled translation unit:</p>
			<ul>
				<li class="list">The machine-level instructions produced for the functions found in the translation unit (code).</li>
				<li class="list">The values of the initialized global variables declared in the translation unit (data).</li>
				<li class="list">The <em class="italics">symbol table</em> containing all the defined and reference symbols found in the translation unit.</li>
			</ul>
			<p class="normal">These are the key items that can be found in any relocatable object file. Of course, the way that they are put together depends on the object file format, but using proper tools, you should be able to extract these items from a relocatable object file. We are going to do this for an ELF relocatable object file shortly.</p>
			<p class="normal">But before delving <a id="_idIndexMarker256"/>into the example, let's talk about the reason why relocatable object files are named like this. In other words, what does the <em class="italics">relocatable</em> mean after all? The reason comes from the process that a linker performs in order to put some relocatable object files together and form a bigger object file – an executable object file or a shared object file.</p>
			<p class="normal">We discuss what can be found in an executable file in the next section, but for now, we should know that the items we find in an executable object file are the sum of all the items found in all the constituent relocatable object files. Let's just talk about machine-level instructions.</p>
			<p class="normal">The machine-level instructions found in one relocatable object file should be put next to the machine-level instructions coming from another relocatable object file. This means that the instructions should be easily <em class="italics">movable</em> or <em class="italics">relocatable</em>. For this to happen, the instructions have no addresses in a relocatable object file, and they obtain their addresses only after the linking step. This is the main reason why we call these object files relocatable. To elaborate more on this, we need to show it in a real example.</p>
			<p class="normal"><em class="italics">Example 3.1</em> is about two source files, one containing the definitions of two functions, <code class="Code-In-Text--PACKT-">max</code> and <code class="Code-In-Text--PACKT-">max_3</code>, and the other source file containing the <code class="Code-In-Text--PACKT-">main</code> function using the declared functions <code class="Code-In-Text--PACKT-">max</code> and <code class="Code-In-Text--PACKT-">max_3</code>. Next, you can see the content of the first source file:</p>
			<p class="snippet code">int max(int a, int b) {</p>
			<p class="snippet code">  return a &gt; b ? a : b;</p>
			<p class="snippet code">}</p>
			<p class="snippet code">int max_3(int a, int b, int c) {</p>
			<p class="snippet code">  int temp = max(a, b);</p>
			<p class="snippet code">  return c &gt; temp ? c : temp;</p>
			<p class="snippet code">}</p>
			<p class="packt_figref">Code Box 3-1 [ExtremeC_examples_chapter3_1_funcs.c]: A source file containing two function definitions</p>
			<p class="normal">And the second source file looks like the following code box:</p>
			<p class="snippet code">int max(int, int);</p>
			<p class="snippet code">int max_3(int, int, int);</p>
			<p class="snippet code">int a = 5;</p>
			<p class="snippet code">int b = 10;</p>
			<p class="snippet code">int main(int argc, char** argv) {</p>
			<p class="snippet code">  int m1 = max(a, b);</p>
			<p class="snippet code">  int m2 = max_3(5, 8, -1);</p>
			<p class="snippet code">  return 0;</p>
			<p class="snippet code">}</p>
			<p class="packt_figref">Code Box 3-2 [ExtremeC_examples_chapter3_1.c]: The main function using the already declared functions. Definitions are put in a separate source file.</p>
			<p class="normal">Let's produce the relocatable object files for the preceding source files. This way, we can investigate the content and that which we explained before. Note that, since we are compiling these<a id="_idIndexMarker257"/> sources on a Linux machine, we expect to see ELF object files as the result:</p>
			<p class="snippet shell"><strong class="screen-text">$ gcc -c ExtremeC_examples_chapter3_1_funcs.c  -o funcs.o</strong></p>
			<p class="snippet shell"><strong class="screen-text">$ gcc -c ExtremeC_examples_chapter3_1.c -o main.o</strong></p>
			<p class="snippet shell"><strong class="screen-text">$</strong></p>
			<p class="packt_figref">Shell Box 3-1: Compiling source files to their corresponding relocatable object files</p>
			<p class="normal">Both <code class="Code-In-Text--PACKT-">funcs.o</code> and <code class="Code-In-Text--PACKT-">main.o</code> are relocatable ELF object files. In an ELF object file, the items described to be in a relocatable object file are put into a number of sections. In order to see the present sections in the preceding relocatable object files, we can use the <code class="Code-In-Text--PACKT-">readelf</code> utility as follows:</p>
			<p class="snippet shell"><strong class="screen-text">$ readelf -hSl funcs.o</strong></p>
			<p class="snippet shell">[7/7]</p>
			<p class="snippet shell">ELF Header:</p>
			<p class="snippet shell">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00</p>
			<p class="snippet shell">  Class:                             ELF64</p>
			<p class="snippet shell">  Data:                              2's complement, little endian</p>
			<p class="snippet shell">  Version:                           1 (current)</p>
			<p class="snippet shell">  OS/ABI:                            UNIX - System V</p>
			<p class="snippet shell">  ABI Version:                       0</p>
			<p class="snippet shell">  Type:                              REL (Relocatable file)</p>
			<p class="snippet shell">  Machine:                           Advanced Micro Devices X86-64</p>
			<p class="snippet shell">...</p>
			<p class="snippet shell">  Number of section headers:         12</p>
			<p class="snippet shell">  Section header string table index: 11</p>
			<p class="snippet shell">Section Headers:</p>
			<p class="snippet shell">  [Nr] Name              Type             Address           Offset</p>
			<p class="snippet shell">       Size              EntSize          Flags  Link  Info  Align</p>
			<p class="snippet shell">  [ 0]                   NULL             0000000000000000  00000000</p>
			<p class="snippet shell">       0000000000000000  0000000000000000           0     0     0</p>
			<p class="snippet shell">  [ 1] .text             PROGBITS         0000000000000000  00000040</p>
			<p class="snippet shell">       0000000000000045  0000000000000000  AX       0     0     1</p>
			<p class="snippet shell">...</p>
			<p class="snippet shell">  [ 3] .data             PROGBITS         0000000000000000  00000085</p>
			<p class="snippet shell">       0000000000000000  0000000000000000  WA       0     0     1</p>
			<p class="snippet shell">  [ 4] .bss              NOBITS           0000000000000000  00000085</p>
			<p class="snippet shell">       0000000000000000  0000000000000000  WA       0     0     1</p>
			<p class="snippet shell">...</p>
			<p class="snippet shell">  [ 9] .symtab           SYMTAB           0000000000000000  00000110</p>
			<p class="snippet shell">       00000000000000f0  0000000000000018          10     8     8</p>
			<p class="snippet shell">  [10] .strtab           STRTAB           0000000000000000  00000200</p>
			<p class="snippet shell">       0000000000000030  0000000000000000           0     0     1</p>
			<p class="snippet shell">  [11] .shstrtab         STRTAB           0000000000000000  00000278</p>
			<p class="snippet shell">       0000000000000059  0000000000000000           0     0     1</p>
			<p class="snippet shell">...</p>
			<p class="snippet shell"><strong class="screen-text">$</strong></p>
			<p class="packt_figref">Shell Box 3-2: The ELF content of the funcs.o object file</p>
			<p class="normal">As you can see in the preceding shell box, the relocatable object file has 11 sections. The sections in bold font are the sections that we have introduced as items existing in an object file. The <code class="Code-In-Text--PACKT-">.text</code> section contains all the machine-level instructions for the translation unit. The <code class="Code-In-Text--PACKT-">.data</code> and <code class="Code-In-Text--PACKT-">.bss</code> sections contain the values for initialized global variables, and the number of bytes required for uninitialized global variables respectively. The <code class="Code-In-Text--PACKT-">.symtab</code> section contains the symbol table.</p>
			<p class="normal">Note that, the sections <a id="_idIndexMarker258"/>existing in both preceding object files are the same, but their content is different. Therefore, we don't show the sections for the other relocatable object file.</p>
			<p class="normal">As we mentioned before, one of the sections in an ELF object file contains the symbol table. In the previous chapter, we had a thorough discussion about the symbol table and its entries. We described how it is being used by the linker to produce executable and shared object files. Here, we want to draw your attention to something about the symbol table that we didn't discuss in the previous chapter. This would be in accordance with our explanation on why relocatable object files are named in this manner.</p>
			<p class="normal">Let's dump the symbol table for <code class="Code-In-Text--PACKT-">funcs.o</code>. In the previous chapter, we used <code class="Code-In-Text--PACKT-">objdump</code> but now, we are going to use <code class="Code-In-Text--PACKT-">readelf</code> to do so:</p>
			<p class="snippet shell"><strong class="screen-text">$ readelf -s funcs.o</strong></p>
			<p class="snippet shell">Symbol table '.symtab' contains 10 entries:</p>
			<p class="snippet shell">   Num:    Value          Size Type    Bind   Vis      Ndx Name</p>
			<p class="snippet shell">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND</p>
			<p class="snippet shell">...</p>
			<p class="snippet shell">     6: 0000000000000000     0 SECTION LOCAL  DEFAULT    7</p>
			<p class="snippet shell">     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    5</p>
			<p class="snippet shell">     8: 0000000000000000    22 FUNC    GLOBAL DEFAULT    1 max</p>
			<p class="snippet shell">     9: 0000000000000016    47 FUNC    GLOBAL DEFAULT    1 max_3</p>
			<p class="snippet shell"><strong class="screen-text">$</strong></p>
			<p class="packt_figref">Shell Box 3-3: The symbol table of the funcs.o object file</p>
			<p class="normal">As you can see in the <code class="Code-In-Text--PACKT-">Value</code> column, the address assigned to <code class="Code-In-Text--PACKT-">max</code> is <code class="Code-In-Text--PACKT-">0</code> and the address assigned to <code class="Code-In-Text--PACKT-">max_3</code> is <code class="Code-In-Text--PACKT-">22</code> (hexadecimal <code class="Code-In-Text--PACKT-">16</code>). This means that the instructions related to these symbols are adjacent and their addresses start from 0. These symbols, and their corresponding <a id="_idIndexMarker259"/>machine-level instructions, are ready to be relocated to other places in the final executable. Let's look at the symbol table of <code class="Code-In-Text--PACKT-">main.o</code>:</p>
			<p class="snippet shell"><strong class="screen-text">$ readelf -s main.o</strong></p>
			<p class="snippet shell">Symbol table '.symtab' contains 14 entries:</p>
			<p class="snippet shell">   Num:    Value          Size Type    Bind   Vis      Ndx Name</p>
			<p class="snippet shell">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND</p>
			<p class="snippet shell">...</p>
			<p class="snippet shell">     8: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    3 a</p>
			<p class="snippet shell">     9: 0000000000000004     4 OBJECT  GLOBAL DEFAULT    3 b</p>
			<p class="snippet shell">    10: 0000000000000000    69 FUNC    GLOBAL DEFAULT    1 main</p>
			<p class="snippet shell">    11: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _GLOBAL_OFFSET_TABLE_</p>
			<p class="snippet shell">    12: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND max</p>
			<p class="snippet shell">    13: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND max_3</p>
			<p class="snippet shell"><strong class="screen-text">$</strong></p>
			<p class="packt_figref">Shell Box 3-4: The symbol table of the main.o object file</p>
			<p class="normal">As you can see, the symbols associated with global variables <code class="Code-In-Text--PACKT-">a</code> and <code class="Code-In-Text--PACKT-">b</code>, as well as the symbol for the <code class="Code-In-Text--PACKT-">main</code> function are put at addresses that don't seem be the final addresses that they should be placed at. This is a sign of being a relocatable object file. As we have said before, the symbols in a relocatable object files don't have any final and absolute addresses and their addresses will be determined as part of the linking step.</p>
			<p class="normal">In the following section, we continue to produce an executable file from the preceding relocatable object files. You will see that the symbol tab<a id="_idTextAnchor100"/><a id="_idTextAnchor101"/><a id="_idTextAnchor102"/><a id="_idTextAnchor103"/>le is different.</p>
			<h1 id="_idParaDest-65" class="title" lang="en-GB" xml:lang="en-GB"><span class="normaltextrun"><a id="_idTextAnchor104"/>Executable Object Files</span></h1>
			<p class="normal"><span class="normaltextrun">Now, it's time to talk about executable object files. You should know by now that executable object file is one of the final products of a C project. Like</span><span class="normaltextrun"><a id="_idIndexMarker260"/></span><span class="normaltextrun"> relocatable object files, they have the same items</span><span class="normaltextrun"><a id="_idIndexMarker261"/></span><span class="normaltextrun"> in the:; the machine-level instructions, the values for initialized global variables, and the symbol tabl;t however, the arrangement can be different. We can show this regarding the ELF executable object files since it would be easy to generate them and study their internal structure.</span></p>
			<p class="normal"><span class="normaltextrun">In order to produce an executable ELF object file, we continue with </span><em class="italics">example 3.1</em><span class="normaltextrun">. In the previous section, we generated relocatable object files for the two sources existing in the example, and in this section, we are going to link them to form an executable file.</span></p>
			<p class="normal">The following commands do that for you, as explained in the previous chapter:</p>
			<p class="snippet shell"><strong class="highlight">$ gcc funcs.o main.o -o ex3_1.out</strong></p>
			<p class="snippet shell"><strong class="highlight">$ </strong></p>
			<p class="packt_figref">Shell Box 3-5: Linking previously built relocatable object files in example 3.1</p>
			<p class="normal"><span class="normaltextrun">In the previous section, we spoke about sections being present in an ELF object file. We should say that more sections exist in an ELF executable object file, but together with some segments. Every ELF executable object file, and as you will see later in this chapter, every ELF shared object file, has </span><span class="advancedproofingissue">a number of</span><span class="normaltextrun"> </span><em class="italics">segments</em> <span class="normaltextrun">in addition to sections. Each segment consists of </span><span class="advancedproofingissue">a number of</span><span class="normaltextrun"> sections (zero or more), and the sections are put into segments based on their content.</span></p>
			<p class="normal"><span class="normaltextrun">For example, all sections containing machine-level instructions go into the same segment. You will see in </span><em class="italics">Chapter 4</em>, <em class="italics">Process Memory Structure</em><span class="normaltextrun">, that these segments nicely map to static </span><em class="italics">memory segments</em><span class="normaltextrun"> found in the memory layout of a running process.</span></p>
			<p class="normal"><span class="normaltextrun">Let's look at the contents of an executable file and meet these segments. Similarly, to relocatable object files, we can use the same command to show the sectios, and the segments found in an executable ELF object fil</span>e.</p>
			<p class="snippet shell"><strong class="highlight">$ readelf -hSl ex3_1.out</strong></p>
			<p class="snippet shell">ELF Header:</p>
			<p class="snippet shell">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00</p>
			<p class="snippet shell">  Class:                             ELF64</p>
			<p class="snippet shell">  Data:                              2's complement, little endian</p>
			<p class="snippet shell">  Version:                           1 (current)</p>
			<p class="snippet shell">  OS/ABI:                            UNIX - System V</p>
			<p class="snippet shell">  ABI Version:                       0</p>
			<p class="snippet shell">  <strong class="highlight">Type:                              DYN (Shared object file) </strong></p>
			<p class="snippet shell">  Machine:                           Advanced Micro Devices X86-64 </p>
			<p class="snippet shell">  Version:                           0x1</p>
			<p class="snippet shell">  Entry point address:               0x4f0</p>
			<p class="snippet shell">  Start of program headers:          64 (bytes into file)</p>
			<p class="snippet shell">  Start of section headers:          6576 (bytes into file)</p>
			<p class="snippet shell">  Flags:                             0x0</p>
			<p class="snippet shell">  Size of this header:               64 (bytes)</p>
			<p class="snippet shell">  Size of program headers:           56 (bytes)</p>
			<p class="snippet shell">  Number of program headers:         9</p>
			<p class="snippet shell">  Size of section headers:           64 (bytes)</p>
			<p class="snippet shell">  Number of section headers:         28</p>
			<p class="snippet shell">  Section header string table index: 27</p>
			<p class="snippet shell">Section Headers: </p>
			<p class="snippet shell">  [Nr] Name              Type             Address           Offset </p>
			<p class="snippet shell">       Size              EntSize          Flags  Link  Info  Align </p>
			<p class="snippet shell">  [ 0]                   NULL             0000000000000000  00000000 </p>
			<p class="snippet shell">      0000000000000000  0000000000000000           0     0     0 </p>
			<p class="snippet shell">  [ 1] .interp           PROGBITS         0000000000000238  00000238 </p>
			<p class="snippet shell">       000000000000001c  0000000000000000   A       0     0     1 </p>
			<p class="snippet shell">  [ 2] .note.ABI-tag     NOTE             0000000000000254  00000254 </p>
			<p class="snippet shell">       0000000000000020  0000000000000000   A       0     0     4 </p>
			<p class="snippet shell">  [ 3] .note.gnu.build-i NOTE             0000000000000274  00000274 </p>
			<p class="snippet shell">       0000000000000024  0000000000000000   A       0     0     4 </p>
			<p class="snippet shell">... </p>
			<p class="snippet shell">  [26] .strtab           STRTAB           0000000000000000  00001678 </p>
			<p class="snippet shell">       0000000000000239  0000000000000000           0     0     1 </p>
			<p class="snippet shell">  [27] .shstrtab         STRTAB           0000000000000000  000018b1 </p>
			<p class="snippet shell">       00000000000000f9  0000000000000000           0     0     1 </p>
			<p class="snippet shell">Key to Flags: </p>
			<p class="snippet shell">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info), </p>
			<p class="snippet shell">  L (link order), O (extra OS processing required), G (group), T (TLS), </p>
			<p class="snippet shell">  C (compressed), x (unknown), o (OS specific), E (exclude), </p>
			<p class="snippet shell">  l (large), p (processor specific) </p>
			<p class="snippet shell">Program Headers: </p>
			<p class="snippet shell">  Type           Offset             VirtAddr           PhysAddr </p>
			<p class="snippet shell">                 FileSiz            MemSiz              Flags  Align </p>
			<p class="snippet shell">  PHDR           0x0000000000000040 0x0000000000000040 0x0000000000000040 </p>
			<p class="snippet shell">                 0x00000000000001f8 0x00000000000001f8  R      0x8 </p>
			<p class="snippet shell">  INTERP         0x0000000000000238 0x0000000000000238 0x0000000000000238 </p>
			<p class="snippet shell">                 0x000000000000001c 0x000000000000001c  R      0x1 </p>
			<p class="snippet shell">      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2] </p>
			<p class="snippet shell">... </p>
			<p class="snippet shell">  GNU_EH_FRAME   0x0000000000000714 0x0000000000000714 0x0000000000000714 </p>
			<p class="snippet shell">                 0x000000000000004c 0x000000000000004c  R      0x4 </p>
			<p class="snippet shell">  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000 </p>
			<p class="snippet shell">                 0x0000000000000000 0x0000000000000000  RW     0x10 </p>
			<p class="snippet shell">  GNU_RELRO      0x0000000000000df0 0x0000000000200df0 0x0000000000200df0 </p>
			<p class="snippet shell">                 0x0000000000000210 0x0000000000000210  R      0x1 </p>
			<p class="snippet shell">Section to Segment mapping: </p>
			<p class="snippet shell">  Segment Sections... </p>
			<p class="snippet shell">   00 </p>
			<p class="snippet shell">   <strong class="highlight">01     .interp </strong></p>
			<p class="snippet shell">   <strong class="highlight">02     .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .init .plt .plt.got .text .fini .rodata .eh_frame_hdr .eh_frame </strong></p>
			<p class="snippet shell">   <strong class="highlight">03     .init_array .fini_array .dynamic .got .data .bss </strong></p>
			<p class="snippet shell">   <strong class="highlight">04     .dynamic </strong></p>
			<p class="snippet shell">   05     .note.ABI-tag .note.gnu.build-id </p>
			<p class="snippet shell">   06     .eh_frame_hdr </p>
			<p class="snippet shell">   07 </p>
			<p class="snippet shell">   08     .init_array .fini_array .dynamic .got </p>
			<p class="snippet shell"><strong class="highlight">$</strong></p>
			<p class="packt_figref">Shell Box 3-6: The ELF content of ex3_1.out executable object file</p>
			<p class="normal">There are multiple notes about the <a id="_idIndexMarker262"/>above output:</p>
			<ul>
				<li class="list">We can see that the type of object file from the ELF point of vew, is a shared object file. In other words, in ELF, an executable object file is a shared object file that has some specific segments like <code class="Code-In-Text--PACKT-">INTERP</code>. This segment (actually the <code class="Code-In-Text--PACKT-">.interp</code> section which is referred to by this segment) is used by the loader program to load and execute the executable object file.</li>
				<li class="list">We have made four segments bold. The first one refers to the <code class="Code-In-Text--PACKT-">INTERP</code> segment which is explained in the previous bullet point. The second one is the <code class="Code-In-Text--PACKT-">TEXT</code> segment. It contains all the section having machine-level instructions. The third one is the <code class="Code-In-Text--PACKT-">DATA</code> segment that contains all the values that should be used to initialize the global variables and other early structures. The fourth segment refers to the section<a id="_idIndexMarker263"/> that <em class="italics">dynamic linking</em> related information can be found. For instance, the shared object files that need to be loaded as part of the execution.</li>
				<li class="list">As you see, we've got more sections in comparison to a relocatable shared object, probably filled with data required to load and execute the object file.</li>
			</ul>
			<p class="normal">As we explained in the previous section, the symbols found in the symbol table of a relocatable object file do not have any absolute and determined addresses. That's because the sections containing machine-level instructions are not linked yet.</p>
			<p class="normal">In a deeper sense, linking a number of relocatable object files is actually to collect all similar sections from the given relocatable object files and put them together to form a bigger section, and finally put<a id="_idIndexMarker264"/> the resulting section into the output executable or the shared object file. Therefore, only after this step, the symbols can be finalized and obtain the addresses that are not going to change. In executable object files, the addresses are absolute, while in shared object files, the relative addresses are absolute. We will discuss this more in the section dedicated to dynamic libraries.</p>
			<p class="normal">Let's look at the symbol table found in the executable file <code class="Code-In-Text--PACKT-">ex3_1.out</code>. Note that the symbol table has many entries and that's why the output is not fully shown in the following shell box:</p>
			<p class="snippet shell"><strong class="highlight">$ readelf -s ex3_1.out</strong></p>
			<p class="snippet shell">Symbol table <strong class="highlight">'.dynsym'</strong> contains 6 entries: </p>
			<p class="snippet shell">   Num:    Value          Size Type    Bind   Vis      Ndx Name </p>
			<p class="snippet shell">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND </p>
			<p class="snippet shell">... </p>
			<p class="snippet shell">     5: 0000000000000000     0 FUNC    WEAK   DEFAULT  UND __cxa_finalize@GLIBC_2.2.5 (2) </p>
			<p class="snippet shell">Symbol table <strong class="highlight">'.symtab'</strong> contains 66 entries: </p>
			<p class="snippet shell">   Num:    Value          Size Type    Bind   Vis      Ndx Name </p>
			<p class="snippet shell">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND </p>
			<p class="snippet shell">... </p>
			<p class="snippet shell">    45: 0000000000201000     0 NOTYPE  WEAK   DEFAULT   22 data_start </p>
			<p class="snippet shell">    46: <strong class="highlight">0000000000000610</strong>    47 FUNC    GLOBAL DEFAULT   13 max_3 </p>
			<p class="snippet shell">    47: 0000000000201014     4 OBJECT  GLOBAL DEFAULT   22 b </p>
			<p class="snippet shell">    48: 0000000000201018     0 NOTYPE  GLOBAL DEFAULT   22 _edata </p>
			<p class="snippet shell">    49: 0000000000000704     0 FUNC    GLOBAL DEFAULT   14 _fini </p>
			<p class="snippet shell">    50: <strong class="highlight">00000000000005fa</strong>    22 FUNC    GLOBAL DEFAULT   13 max </p>
			<p class="snippet shell">    51: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_main@@GLIBC_ </p>
			<p class="snippet shell">... </p>
			<p class="snippet shell">    64: 0000000000000000     0 FUNC    WEAK   DEFAULT  UND __cxa_finalize@@GLIBC_2.2 </p>
			<p class="snippet shell">    65: 00000000000004b8     0 FUNC    GLOBAL DEFAULT   10 _init </p>
			<p class="snippet shell"><strong class="highlight">$</strong></p>
			<p class="packt_figref">Shell Box 3-7: The symbol tables found in the ex3_1.out executable object file</p>
			<p class="normal">As you see in the preceding shell box, we have two different symbol tables in an executable object file. The first one, <code class="Code-In-Text--PACKT-">.dynsym</code>, contains the symbols that should be resolved when loading the <a id="_idIndexMarker265"/>executable, but the second symbol table, <code class="Code-In-Text--PACKT-">.symtab</code>, contains all the resolved symbols together with unresolved symbols brought from the dynamic symbol table. In other words, the symbol table contains the unresolved symbols from the dynamic table as well.</p>
			<p class="normal">As you see, the resolved symbols in the symbol table have absolute corresponding addresses that they have obtained after the linking step. The addresses for <code class="Code-In-Text--PACKT-">max</code> and <code class="Code-In-Text--PACKT-">max_3</code> symbols are shown in bold font.</p>
			<p class="normal">In this section, we took a brief look into the executable object file. In the next section, we are going to talk about static libraries.</p>
			<h1 id="_idParaDest-66" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor105"/>Static libraries</h1>
			<p class="normal">As we have explained before, a static library is one of the possible products of a C project. In this section, we are<a id="_idIndexMarker266"/> going to talk about static libraries and the way they are created and used. We will then continue this discussion by introducing dynamic libraries in the next section.</p>
			<p class="normal">A static library is simply a Unix archive made from the relocatable object files. Such a library is usually linked together with other object files to form an executable object file.</p>
			<p class="normal">Note that a static library itself is not considered as an object file, rather it is a container for them. In other words, static libraries are not ELF files in Linux systems, nor are they Mach-O files in macOS systems. They are simply archived files that have been created by the Unix <code class="Code-In-Text--PACKT-">ar</code> utility.</p>
			<p class="normal">When a linker is about to use a static library in the linking step, it first tries to extract the relocatable object files from it, then it starts to look up and resolve the undefined symbols that may be found in some of them.</p>
			<p class="normal">Now, it's time to create a static library for a project with multiple source files. The first step is to create some relocatable object files. Once you have compiled all of the source files in a C/C++ project, you can use the Unix archiving tool, <code class="Code-In-Text--PACKT-">ar</code>, to create the static library's archive file.</p>
			<p class="normal">In Unix systems, static libraries are usually named according to an accepted and widely used convention. The name starts with <code class="Code-In-Text--PACKT-">lib</code>, and it ends with the <code class="Code-In-Text--PACKT-">.a</code> extension. This can be different for other operating systems; for instance, in Microsoft Windows, static libraries carry the <code class="Code-In-Text--PACKT-">.lib</code> extension.</p>
			<p class="normal">Suppose that, in an<a id="_idIndexMarker267"/> imaginary C project, you have the source files <code class="Code-In-Text--PACKT-">aa.c</code>, <code class="Code-In-Text--PACKT-">bb.c</code>, all the way up to <code class="Code-In-Text--PACKT-">zz.c</code>. In order to produce the relocatable object files, you will need to compile the source files in a similar manner to how we use the commands next. Note that the compilation process has been thoroughly explained in the previous chapter:</p>
			<p class="snippet shell"><strong class="screen-text">$ gcc -c aa.c -o aa.o</strong></p>
			<p class="snippet shell"><strong class="screen-text">$ gcc -c bb.c -o bb.o</strong></p>
			<p class="snippet shell"><strong class="screen-text">.</strong></p>
			<p class="snippet shell"><strong class="screen-text">.</strong></p>
			<p class="snippet shell"><strong class="screen-text">.</strong></p>
			<p class="snippet shell"><strong class="screen-text">$ gcc -c zz.c -o zz.o</strong></p>
			<p class="snippet shell"><strong class="screen-text">$</strong></p>
			<p class="packt_figref">Shell Box 3-8: Compiling a number of sources to their corresponding relocatable object files</p>
			<p class="normal">By running the preceding commands, we will get all the required relocatable object files. Note that this can take a considerable amount of time if the project is big and contains thousands of source files. Of course, having a powerful build machine, together with running the compilation jobs in parallel, can reduce the build time significantly.</p>
			<p class="normal">When it comes to creating a static library file, we simply need to run the following command:</p>
			<p class="snippet shell"><strong class="screen-text">$ ar crs libexample.a aa.o bb.o ... zz.o</strong></p>
			<p class="snippet shell"><strong class="screen-text">$</strong></p>
			<p class="packt_figref">Shell Box 3-9: The general recipe for making a static library out of a number of relocatable object files</p>
			<p class="normal">As a result, <code class="Code-In-Text--PACKT-">libexample.a</code> is created, which contains all of the preceding relocatable object files as a single archive. Explaining the <code class="Code-In-Text--PACKT-">crs</code> option passed to <code class="Code-In-Text--PACKT-">ar</code> would be out of the scope of this chapter, but in the following link, you can read <a href="https://stackoverflow.com/questions/29714300/what-does-the-rcs-option-in-ar-do">about its meaning: <span class="url">https://stackoverflow.com/questions/29714300/what-does-th</span></a><span class="url">e-rcs-option-in-ar-do</span>.</p>
			<div>
				<div id="_idContainer045" class="note">
					<p class="Information-Box--PACKT-"><strong class="screen-text">Note</strong>:</p>
					<p class="Information-Box--PACKT-">The <code class="Code-In-Text--PACKT-">ar</code> command does not necessarily create a <em class="italics">compressed</em> archive file. It is only used to put files together to form a single file that is an archive of all those files. The tool <code class="Code-In-Text--PACKT-">ar</code> is general purpose, and you can use it to put any kind of files together and create your own archive out of them.</p>
				</div>
			</div>
			<p class="normal">Now that we know how to create a static library, we are going to create a real one as part of <em class="italics">example 3.2</em>.</p>
			<p class="normal">First, we are going to presume that <em class="italics">example 3.2</em> is a C project about geometry. The example consists of three source files and one header file. The purpose of the library is to define a selection of<a id="_idIndexMarker268"/> geometry related functions that can be used in other applications.</p>
			<p class="normal">To do this, we need to create a static library file named <code class="Code-In-Text--PACKT-">libgeometry.a</code> out of the three source files. By having the static library, we can use the header file and the static library file together in order to write another program that will use the geometry functions defined in the library.</p>
			<p class="normal">The following code boxes are the contents of the source and header files. The first file, <code class="Code-In-Text--PACKT-">ExtremeC_examples_chapter3_2_geometry.h</code>, contains all of the declarations that need to be exported from our geometry library. These declarations will be used by future applications that are going to use the library.</p>
			<div>
				<div id="_idContainer046" class="note">
					<p class="Information-Box--PACKT-"><strong class="screen-text">Note</strong>:</p>
					<p class="Information-Box--PACKT-">All the commands provided for creating object files are run and tested on Linux. Some modifications might be necessary if you're going to execute them on a different operating system.</p>
				</div>
			</div>
			<p class="normal">We need to take note that future applications <em class="italics">must</em> be only dependent on the declarations and not the definitions at all. Therefore, firstly, let's look at the declarations of the geometry library:</p>
			<p class="snippet code">#ifndef EXTREME_C_EXAMPLES_CHAPTER_3_2_H</p>
			<p class="snippet code">#define EXTREME_C_EXAMPLES_CHAPTER_3_2_H</p>
			<p class="snippet code">#define PI 3.14159265359</p>
			<p class="snippet code">typedef struct {</p>
			<p class="snippet code">  double x;</p>
			<p class="snippet code">  double y;</p>
			<p class="snippet code">} cartesian_pos_2d_t;</p>
			<p class="snippet code">typedef struct {</p>
			<p class="snippet code">  double length;</p>
			<p class="snippet code">  // in degrees</p>
			<p class="snippet code">  double theta;</p>
			<p class="snippet code">} polar_pos_2d_t;</p>
			<p class="snippet code">typedef struct {</p>
			<p class="snippet code">  double x;</p>
			<p class="snippet code">  double y;</p>
			<p class="snippet code">  double z;</p>
			<p class="snippet code">} cartesian_pos_3d_t;</p>
			<p class="snippet code">typedef struct {</p>
			<p class="snippet code">  double length;</p>
			<p class="snippet code">  // in degrees</p>
			<p class="snippet code">  double theta;</p>
			<p class="snippet code">  // in degrees</p>
			<p class="snippet code">  double phi;</p>
			<p class="snippet code">} polar_pos_3d_t;</p>
			<p class="snippet code">double to_radian(double deg);</p>
			<p class="snippet code">double to_degree(double rad);</p>
			<p class="snippet code">double cos_deg(double deg);</p>
			<p class="snippet code">double acos_deg(double deg);</p>
			<p class="snippet code">double sin_deg(double deg);</p>
			<p class="snippet code">double asin_deg(double deg);</p>
			<p class="snippet code">cartesian_pos_2d_t convert_to_2d_cartesian_pos(</p>
			<p class="snippet code">        const polar_pos_2d_t* polar_pos);</p>
			<p class="snippet code">polar_pos_2d_t convert_to_2d_polar_pos(</p>
			<p class="snippet code">        const cartesian_pos_2d_t* cartesian_pos);</p>
			<p class="snippet code">cartesian_pos_3d_t convert_to_3d_cartesian_pos(</p>
			<p class="snippet code">        const polar_pos_3d_t* polar_pos);</p>
			<p class="snippet code">polar_pos_3d_t convert_to_3d_polar_pos(</p>
			<p class="snippet code">        const cartesian_pos_3d_t* cartesian_pos);</p>
			<p class="snippet code">#endif</p>
			<p class="packt_figref">Code Box 3-3 [ExtremeC_examples_chapter3_2_geometry.h]: The header file of example 3.2</p>
			<p class="normal">The second file, which is a source file, contains the definitions of the trigonometry functions, the first six<a id="_idIndexMarker269"/> functions declared in the preceding header file:</p>
			<p class="snippet code">#include &lt;math.h&gt;</p>
			<p class="snippet code">// We need to include the header file since</p>
			<p class="snippet code">// we want to use the macro PI</p>
			<p class="snippet code">#include "ExtremeC_examples_chapter3_2_geometry.h"</p>
			<p class="snippet code">double to_radian(double deg) {</p>
			<p class="snippet code">  return (PI * deg) / 180;</p>
			<p class="snippet code">}</p>
			<p class="snippet code">double to_degree(double rad) {</p>
			<p class="snippet code">  return (180 * rad) / PI;</p>
			<p class="snippet code">}</p>
			<p class="snippet code">double cos_deg(double deg) {</p>
			<p class="snippet code">  return cos(to_radian(deg));</p>
			<p class="snippet code">}</p>
			<p class="snippet code">double acos_deg(double deg) {</p>
			<p class="snippet code">  return acos(to_radian(deg));</p>
			<p class="snippet code">}</p>
			<p class="snippet code">double sin_deg(double deg) {</p>
			<p class="snippet code">  return sin(to_radian(deg));</p>
			<p class="snippet code">}</p>
			<p class="snippet code">double asin_deg(double deg) {</p>
			<p class="snippet code">  return asin(to_radian(deg));</p>
			<p class="snippet code">}</p>
			<p class="packt_figref">Code Box 3-4 [ExtremeC_examples_chapter3_2_trigon.c]: The source file containing the definitions of the trigonometry functions</p>
			<p class="normal">Note that it is not necessary for sources to include the header file unless they are going to use a declaration like <code class="Code-In-Text--PACKT-">PI</code> or <code class="Code-In-Text--PACKT-">to_degree</code>, which is declared in the header file.</p>
			<p class="normal">The third file, which is <a id="_idIndexMarker270"/>a source file again, contains the definitions of all 2D Geometry functions:</p>
			<p class="snippet code">#include &lt;math.h&gt;</p>
			<p class="snippet code">// We need to include the header file since we want</p>
			<p class="snippet code">// to use the types polar_pos_2d_t, cartesian_pos_2d_t,</p>
			<p class="snippet code">// etc and the trigonometry functions implemented in</p>
			<p class="snippet code">// another source file.</p>
			<p class="snippet code">#include "ExtremeC_examples_chapter3_2_geometry.h"</p>
			<p class="snippet code">cartesian_pos_2d_t convert_to_2d_cartesian_pos(</p>
			<p class="snippet code">        const polar_pos_2d_t* polar_pos) {</p>
			<p class="snippet code">  cartesian_pos_2d_t result;</p>
			<p class="snippet code">  result.x = polar_pos-&gt;length * cos_deg(polar_pos-&gt;theta);</p>
			<p class="snippet code">  result.y = polar_pos-&gt;length * sin_deg(polar_pos-&gt;theta);</p>
			<p class="snippet code">  return result;</p>
			<p class="snippet code">}</p>
			<p class="snippet code">polar_pos_2d_t convert_to_2d_polar_pos(</p>
			<p class="snippet code">        const cartesian_pos_2d_t* cartesian_pos) {</p>
			<p class="snippet code">  polar_pos_2d_t result;</p>
			<p class="snippet code">  result.length = sqrt(cartesian_pos-&gt;x * cartesian_pos-&gt;x +</p>
			<p class="snippet code">    cartesian_pos-&gt;y * cartesian_pos-&gt;y);</p>
			<p class="snippet code">  result.theta =</p>
			<p class="snippet code">      to_degree(atan(cartesian_pos-&gt;y / cartesian_pos-&gt;x));</p>
			<p class="snippet code">  return result;</p>
			<p class="snippet code">}</p>
			<p class="packt_figref">Code Box 3-5 [ExtremeC_examples_chapter3_2_2d.c]: The source file containing the definitions of the 2D functions</p>
			<p class="normal">And finally, the fourth file that contains the definitions of 3D Geometry functions:</p>
			<p class="snippet code">#include &lt;math.h&gt;</p>
			<p class="snippet code">// We need to include the header file since we want to</p>
			<p class="snippet code">// use the types polar_pos_3d_t, cartesian_pos_3d_t,</p>
			<p class="snippet code">// etc and the trigonometry functions implemented in</p>
			<p class="snippet code">// another source file.</p>
			<p class="snippet code">#include "ExtremeC_examples_chapter3_2_geometry.h"</p>
			<p class="snippet code">cartesian_pos_3d_t convert_to_3d_cartesian_pos(</p>
			<p class="snippet code">        const polar_pos_3d_t* polar_pos) {</p>
			<p class="snippet code">  cartesian_pos_3d_t result;</p>
			<p class="snippet code">  result.x = polar_pos-&gt;length *</p>
			<p class="snippet code">      sin_deg(polar_pos-&gt;theta) * cos_deg(polar_pos-&gt;phi);</p>
			<p class="snippet code">  result.y = polar_pos-&gt;length *</p>
			<p class="snippet code">      sin_deg(polar_pos-&gt;theta) * sin_deg(polar_pos-&gt;phi);</p>
			<p class="snippet code">  result.z = polar_pos-&gt;length * cos_deg(polar_pos-&gt;theta);</p>
			<p class="snippet code">  return result;</p>
			<p class="snippet code">}</p>
			<p class="snippet code">polar_pos_3d_t convert_to_3d_polar_pos(</p>
			<p class="snippet code">        const cartesian_pos_3d_t* cartesian_pos) {</p>
			<p class="snippet code">  polar_pos_3d_t result;</p>
			<p class="snippet code">  result.length = sqrt(cartesian_pos-&gt;x * cartesian_pos-&gt;x +</p>
			<p class="snippet code">    cartesian_pos-&gt;y * cartesian_pos-&gt;y +</p>
			<p class="snippet code">    cartesian_pos-&gt;z * cartesian_pos-&gt;z);</p>
			<p class="snippet code">  result.theta =</p>
			<p class="snippet code">      to_degree(acos(cartesian_pos-&gt;z / result.length));</p>
			<p class="snippet code">  result.phi =</p>
			<p class="snippet code">      to_degree(atan(cartesian_pos-&gt;y / cartesian_pos-&gt;x));</p>
			<p class="snippet code">  return result;</p>
			<p class="snippet code">}</p>
			<p class="packt_figref">Code Box 3-6 [ExtremeC_examples_chapter3_2_3d.c]: The source file containing the definitions of the 3D functions</p>
			<p class="normal">Now we'll create the static library file. To do this, firstly we need to compile the preceding sources to their corresponding relocatable object files. You need to note that we cannot link these object files to create an executable file as there is no <code class="Code-In-Text--PACKT-">main</code> function in any of the preceding <a id="_idIndexMarker271"/>source files. Therefore, we can either keep them as relocatable object files or archive them to form a static library. We have another option to create a shared object file out of them, but we'll wait until the next section to look at this.</p>
			<p class="normal">In this section, we have chosen to archive them in order to create a static library file. The following commands will do the compilation on a Linux system:</p>
			<p class="snippet shell"><strong class="screen-text">$ gcc -c ExtremeC_examples_chapter3_2_trigon.c -o trigon.o</strong></p>
			<p class="snippet shell"><strong class="screen-text">$ gcc -c ExtremeC_examples_chapter3_2_2d.c -o 2d.o</strong></p>
			<p class="snippet shell"><strong class="screen-text">$ gcc -c ExtremeC_examples_chapter3_2_3d.c -o 3d.o</strong></p>
			<p class="snippet shell"><strong class="screen-text">$</strong></p>
			<p class="packt_figref">Shell Box 3-10: Compiling source files to their corresponding relocatable object files</p>
			<p class="normal">When it comes to archiving these object files into a static library file, we need to run the following command:</p>
			<p class="snippet shell"><strong class="screen-text">$ ar crs libgeometry.a trigon.o 2d.o 3d.o</strong></p>
			<p class="snippet shell"><strong class="screen-text">$ mkdir -p /opt/geometry</strong></p>
			<p class="snippet shell"><strong class="screen-text">$ mv libgeometry.a /opt/geometry</strong></p>
			<p class="snippet shell"><strong class="screen-text">$</strong></p>
			<p class="packt_figref">Shell Box 3-11: Creating the static library file out of the relocatable object files</p>
			<p class="normal">As we can see, the file <code class="Code-In-Text--PACKT-">libgeometry.a</code> has been created. As you see, we have moved the library file to the <code class="Code-In-Text--PACKT-">/opt/geometry</code> directory to be easily locatable by any other program. Again, using the <code class="Code-In-Text--PACKT-">ar</code> command, and via<a id="_idIndexMarker272"/> passing the <code class="Code-In-Text--PACKT-">t</code> option, we can see the content of the archive file:</p>
			<p class="snippet shell"><strong class="screen-text">$ ar t /opt/geometry/libgeometry.a</strong></p>
			<p class="snippet shell">trigon.o</p>
			<p class="snippet shell">2d.o</p>
			<p class="snippet shell">3d.o</p>
			<p class="snippet shell"><strong class="screen-text">$</strong></p>
			<p class="packt_figref">Shell Box 3-12: Listing the content of the static library file</p>
			<p class="normal">As is clear from the preceding shell box, the static library file contains three relocatable object files as we intended. The next step is to use<a id="_idTextAnchor106"/> the static library file.</p>
			<p class="normal">Now that we have created a static library for our geometry example, <em class="italics">example 3.2</em>, we are going to use it in a new application. When using a C library, we need to have access to the declarations that are exposed by the library together with its static library file. The declarations are considered as the <em class="italics">public interface</em> of the library, or more commonly, the API of the library.</p>
			<p class="normal">We need declarations in the compile stage, when the compiler needs to know about the existence of types, function signatures, and so on. Header files serve this purpose. Other details such as type sizes and function addresses are needed at later stages; linking and loading.</p>
			<p class="normal">As we said before, we usually find a C API (an API exposed by a C library) as a group of header files. Therefore, the header file from <em class="italics">example 3.2</em>, and the created static library file <code class="Code-In-Text--PACKT-">libgeometry.a</code>, are enough for us to write a new program that uses our geometry library.</p>
			<p class="normal">When it comes to using the static library, we need to write a new source file that includes the library's API and make use of its functions. We write the new code as a new example, <em class="italics">example 3.3</em>. The following code is the source that we have written for <em class="italics">example 3.3</em>:</p>
			<p class="snippet code">#include &lt;stdio.h&gt;</p>
			<p class="snippet code">#include "ExtremeC_examples_chapter3_2_geometry.h"</p>
			<p class="snippet code">int main(int argc, char** argv) {</p>
			<p class="snippet code">  cartesian_pos_2d_t cartesian_pos;</p>
			<p class="snippet code">  cartesian_pos.x = 100;</p>
			<p class="snippet code">  cartesian_pos.y = 200;</p>
			<p class="snippet code">  polar_pos_2d_t polar_pos =</p>
			<p class="snippet code">      convert_to_2d_polar_pos(&amp;cartesian_pos);</p>
			<p class="snippet code">  printf("Polar Position: Length: %f, Theta: %f (deg)\n",</p>
			<p class="snippet code">    polar_pos.length, polar_pos.theta);</p>
			<p class="snippet code">  return 0;</p>
			<p class="snippet code">}</p>
			<p class="packt_figref">Code Box 3-7 [ExtremeC_examples_chapter3_3.c]: The main function testing some of the geometry functions</p>
			<p class="normal">As you can see, <em class="italics">example 3.3</em> has included the header file from <em class="italics">example 3.2</em>. It has done this because it needs the<a id="_idIndexMarker273"/> declarations of the functions that it is going to use.</p>
			<p class="normal">We now need to compile the preceding source file to create its corresponding relocatable object file in a Linux system:</p>
			<p class="snippet shell"><strong class="screen-text">$ gcc -c ExtremeC_examples_chapter3_3.c -o main.o</strong></p>
			<p class="snippet shell"><strong class="screen-text">$</strong></p>
			<p class="packt_figref">Shell Box 3-13: Compiling example 3.3</p>
			<p class="normal">After we have done that, we need to link it with the static library that we created for <em class="italics">example 3.2</em>. In this case, we assume that the file <code class="Code-In-Text--PACKT-">libgeometry.a</code> is located in the <code class="Code-In-Text--PACKT-">/opt/geometry</code> directory, as we had in <em class="italics">Shell Box 3-11</em>. The following command will complete the build by performing the linking step and creating the executable object file, <em class="italics">ex3_3.out</em>:</p>
			<p class="snippet shell"><strong class="screen-text">$ gcc main.o -L/opt/geometry -lgeometry -lm -o ex3_3.out</strong></p>
			<p class="snippet shell"><strong class="screen-text">$</strong></p>
			<p class="packt_figref">Shell Box 3-14: Linking with the static library created as part of example 3.2</p>
			<p class="normal">To explain the preceding command, we are going to explain each passing option separately:</p>
			<ul>
				<li class="list"><code class="Code-In-Text--PACKT-">-L/opt/geometry</code> tells <code class="Code-In-Text--PACKT-">gcc</code> to consider the directory <code class="Code-In-Text--PACKT-">/opt/geometry</code> as one of the various locations in which static and shared libraries could be found. There are well-known paths like <code class="Code-In-Text--PACKT-">/usr/lib</code> or <code class="Code-In-Text--PACKT-">/usr/local/lib</code> in which the linker searches for library files by default. If you do not specify the <code class="Code-In-Text--PACKT-">-L</code> option, the linker only searches its default paths.</li>
				<li class="list"><code class="Code-In-Text--PACKT-">-lgeometry</code> tells <code class="Code-In-Text--PACKT-">gcc</code> to look for the file <code class="Code-In-Text--PACKT-">libgeometry.a</code> or <code class="Code-In-Text--PACKT-">libgeometry.so</code>. A file ending with <code class="Code-In-Text--PACKT-">.so</code> is a shared object file, which we explain in the next section. Note the convention used. If you pass the option <code class="Code-In-Text--PACKT-">-lxyz</code> for instance, the linker will search for the file <code class="Code-In-Text--PACKT-">libxyz.a</code> or <code class="Code-In-Text--PACKT-">libxyz.so</code> in the default <a id="_idIndexMarker274"/>and specified directories. If the file is not found, the linker stops and generates an error.</li>
				<li class="list"><code class="Code-In-Text--PACKT-">-lm</code> tells <code class="Code-In-Text--PACKT-">gcc</code> to look for another library named <code class="Code-In-Text--PACKT-">libm.a</code> or <code class="Code-In-Text--PACKT-">libm.so</code>. This library keeps the definitions of mathematical functions in <em class="italics">glibc</em>. We need it for the <code class="Code-In-Text--PACKT-">cos</code>, <code class="Code-In-Text--PACKT-">sin</code>, and <code class="Code-In-Text--PACKT-">acos</code> functions. Note that we are building <em class="italics">example 3.3</em> on a Linux machine, which uses <em class="italics">glibc</em> as its default C library's implementation. In macOS and possibly some other Unix-like systems, you don't need to specify this option.</li>
				<li class="list"><code class="Code-In-Text--PACKT-">-o ex3_3.out</code> tells <code class="Code-In-Text--PACKT-">gcc</code> that the output executable file should be named <code class="Code-In-Text--PACKT-">ex3_3.out</code>.</li>
			</ul>
			<p class="normal">After running the preceding command, if everything goes smoothly, you will have an executable binary file that contains all the relocatable object files found in the static library <code class="Code-In-Text--PACKT-">libgeometry.a</code> plus <code class="Code-In-Text--PACKT-">main.o</code>.</p>
			<p class="normal">Note that there will not be any dependency on the existence of the static library file after linking, as everything is <em class="italics">embedded</em> inside the executable file itself. In other words, the final executable file can be run on its own without needing the static library to be present.</p>
			<p class="normal">However, executable files produced from the linkage of many static libraries usually have huge sizes. The more static libraries and the more relocatable object files inside them, the bigger the size of the final executable. Sometimes it can go up to several hundred megabytes or even a few gigabytes.</p>
			<p class="normal">It is a trade-off between the size of the binary and the dependencies it might have. You can have a smaller binary, but by using shared libraries. It means that the final binary is not complete and cannot be run if the external shared libraries do not exist or cannot be found. We talk more<a id="_idIndexMarker275"/> about this in the upcoming sections.</p>
			<p class="normal">In this section, we described what static libraries are and how they should be created and used. We also demonstrated how another program can use the exposed API and get linked to an existing static library. In the following section, we are going to talk about dynamic libraries and how to produce a shared object file (dynamic library) from sources in <em class="italics">example 3.2</em>, instead of using a static library.</p>
			<h1 id="_idParaDest-67" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor107"/>Dynamic libraries</h1>
			<p class="normal">Dynamic libraries, or shared libraries, are another way to produce libraries for reuse. As their name implies, unlike the<a id="_idIndexMarker276"/> static libraries, dynamic libraries are not part of the final executable itself. Instead, they should be loaded and brought in while loading a process for execution.</p>
			<p class="normal">Since static libraries are part of the executable, the linker puts everything found in the given relocatable files into the final executable file. In other words, the linker detects the undefined symbols, and required definitions, and tries to find them in the given relocatable object files, then puts them all in the output executable file.</p>
			<p class="normal">The final product is only produced when every undefined symbol is found. From a unique perspective, we detect all dependencies and resolve them at linking time. Regarding dynamic libraries, it is possible to have undefined symbols that are not resolved at linking time. These symbols are searched for when the executable product is about to be loaded and begin the execution.</p>
			<p class="normal">In other words, a different kind of linking step is needed when you have undefined dynamic symbols. A <em class="italics">dynamic linker</em>, or simply the <em class="italics">loader</em>, usually does the linking while loading an executable file and preparing it to be run as a process.</p>
			<p class="normal">Since the undefined dynamic symbols are not found in the executable file, they should be found somewhere else. These symbols should be loaded from shared object files. These files are sister files to static library files. While the static library files have a <code class="Code-In-Text--PACKT-">.a</code> extension in their names, the shared object files carry the <code class="Code-In-Text--PACKT-">.so</code> extension in most Unix-like systems. In macOS, they have the <code class="Code-In-Text--PACKT-">.dylib</code> extension.</p>
			<p class="normal">When loading a process and about to be launched, a shared object file will be loaded and mapped to a memory region accessible by the process. This procedure is done by a dynamic linker (or loader), which loads and executes an executable file.</p>
			<p class="normal">Like we said in the section dedicated to executable object files, both ELF executable and shared object files have segments in their ELF structure. Each segment has zero or more sections in them. There are two main differences between an ELF executable object file and an ELF shared object file. Firstly, the symbols have relative absolute addresses that allow them to be loaded as part of many processes at the same time.</p>
			<p class="normal">This means that while the address of each instruction is different in any process, the distance between two instructions remains fixed. In other words, the addresses are fixed relative to an offset. This is because the relocatable object files are <em class="italics">position independent</em>. We talk more about this in the last section of this chapter.</p>
			<p class="normal">For instance, if two<a id="_idIndexMarker277"/> instructions are located at addresses 100 and 200 in a process, in another process they may be at 140 and 240, and in another one they could be at 323 and 423. The related addresses are absolute, but the actual addresses can change. These two instructions will always be 100 addresses apart from each other.</p>
			<p class="normal">The second difference is that some segments related to loading an ELF executable object file are not present in shared object files. This effectively means that shared object files cannot be executed.</p>
			<p class="normal">Before giving more details on how a shared object is accessed from different processes, we need to show an example of how they are created and used. Therefore, we are going to create dynamic libraries for the same geometry library, <em class="italics">example 3.2</em>, that we worked on in the previous section.</p>
			<p class="normal">In the previous section we created a static library for the geometry library. In this section, we want to compile the sources again in order to create a shared object file out of them. The following commands show you how to compile the three sources into their corresponding relocatable object files, with just one difference in comparison to what we did for <em class="italics">example 3.2</em>. In the following commands, note the <code class="Code-In-Text--PACKT-">-fPIC</code> option that is passed to <code class="Code-In-Text--PACKT-">gcc</code>:</p>
			<p class="snippet shell"><strong class="screen-text">$ gcc -c ExtremeC_examples_chapter3_2_2d.c -fPIC -o 2d.o</strong></p>
			<p class="snippet shell"><strong class="screen-text">$ gcc -c ExtremeC_examples_chapter3_2_3d.c -fPIC -o 3d.o</strong></p>
			<p class="snippet shell"><strong class="screen-text">$ gcc -c ExtremeC_examples_chapter3_2_trigon.c -fPIC -o trigon.o</strong></p>
			<p class="snippet shell"><strong class="screen-text">$</strong></p>
			<p class="packt_figref">Shell Box 3-15: Compiling the sources of example 3.2 to corresponding position-independent relocatable object files</p>
			<p class="normal">Looking at the commands, you can see that we have passed an extra option,<code class="Code-In-Text--PACKT-">-fPIC</code>, to <code class="Code-In-Text--PACKT-">gcc</code> while compiling the sources. This option is <em class="italics">mandatory</em> if you are going to create a shared object file out of some <a id="_idIndexMarker278"/>relocatable object files. <strong class="bold">PIC</strong> stands for <strong class="bold">position independent code</strong>. As we explained before, if a relocatable object file is position independent, it simply means that the instructions within it don't have fixed addresses. Instead, they have relative addresses; hence they can obtain different addresses in different processes. This is a requirement because of the way we use shared object files.</p>
			<p class="normal">There is no guarantee that <a id="_idIndexMarker279"/>the loader program will load a shared object file at the same address in different processes. In fact, the loader creates memory mappings to the shared object files, and the address ranges for those mappings can be different. If the instruction addresses were absolute, we couldn't load the same shared object file in various processes, and in various memory regions, at the same time.</p>
			<div>
				<div id="_idContainer047" class="note">
					<p class="Information-Box--PACKT-"><strong class="screen-text">Note</strong>:</p>
					<p class="Information-Box--PACKT-">For more detailed information on how<a id="_idIndexMarker280"/> the dynamic loading of programs and shared object<a id="_idIndexMarker281"/> files works, you can see the following resources: </p>
					<ul>
						<li class="list"><a href="https://software.intel.com/sites/default/files/m/a/1/e/dsohowto.pdf"><span class="url">https://software.intel.com/sites/default/files/m/a/1/e/dsohowto.pdf</span></a></li>
						<li class="list"><a href="https://www.technovelty.org/linux/plt-and-got-the-key-to-code-sharing-and-dynamic-libraries.html"><span class="url">https://www.technovelty.org/linux/plt-and-got-the-key-to-code-sharing-and-dynamic-libraries.html</span></a></li>
					</ul>
				</div>
			</div>
			<p class="normal">To create shared object files, you need to use the compiler, in this case, <code class="Code-In-Text--PACKT-">gcc</code>, again. Unlike a static library file, which is a simple archive, a shared object file is an object file itself. Therefore, they should be created by the same linker program, for instance <code class="Code-In-Text--PACKT-">ld</code>, that we used to produce the relocatable object files.</p>
			<p class="normal">We know that, on most Unix-like systems, <code class="Code-In-Text--PACKT-">ld</code> does that. However, it is strongly recommended not to use <code class="Code-In-Text--PACKT-">ld</code> directly for linking object files for the reasons we explained in the previous chapter.</p>
			<p class="normal">The following command shows how you should create a shared object file out of a number of relocatable object files that have been compiled using the <code class="Code-In-Text--PACKT-">-fPIC</code> option:</p>
			<p class="snippet shell"><strong class="screen-text">$ gcc -shared 2d.o 3d.o trigon.o -o libgeometry.so</strong></p>
			<p class="snippet shell"><strong class="screen-text">$ mkdir -p /opt/geometry</strong></p>
			<p class="snippet shell"><strong class="screen-text">$ mv libgeometry.so /opt/geometry</strong></p>
			<p class="snippet shell"><strong class="screen-text">$</strong></p>
			<p class="packt_figref">Shell Box 3-16: Creating a shared object file out of the relocatable object files</p>
			<p class="normal">As you can see in the first command, we passed the <code class="Code-In-Text--PACKT-">-shared</code> option, to ask <code class="Code-In-Text--PACKT-">gcc</code> to create a shared object file out of the relocatable object files. The result is a shared object file named <code class="Code-In-Text--PACKT-">libgeometry.so</code>. We have moved the shared object file to <code class="Code-In-Text--PACKT-">/opt/geometry</code> to make it easily available to other programs willing to use it. The next step is to compile and link <em class="italics">example 3.3</em> again.</p>
			<p class="normal">Previously, we compiled and linked <em class="italics">example 3.3</em> with the created static library file, <code class="Code-In-Text--PACKT-">libgeometry.a</code>. Here, we are going to do the same, but instead, link it with <code class="Code-In-Text--PACKT-">libgeometry.so</code>, a dynamic library.</p>
			<p class="normal">While everything<a id="_idIndexMarker282"/> seems to be the same, especially the commands, they are in fact different. This time, we are going to link <em class="italics">example 3.3</em> with <code class="Code-In-Text--PACKT-">libgeometry.so</code> instead of <code class="Code-In-Text--PACKT-">libgeometry.a</code>, and more than that, the dynamic library won't get embedded into the final executable, instead it will load the library upon execution. While practicing this, make sure that you have removed the static library file, <code class="Code-In-Text--PACKT-">libgeometry.a</code>, from <code class="Code-In-Text--PACKT-">/opt/geometry</code> before linking <em class="italics">example 3.3</em> again:</p>
			<p class="snippet shell"><strong class="screen-text">$ rm -fv /opt/geometry/libgeometry.a</strong></p>
			<p class="snippet shell"><strong class="screen-text">$ gcc -c ExtremeC_examples_chapter3_3.c -o main.o</strong></p>
			<p class="snippet shell"><strong class="screen-text">$ gcc main.o -L/opt/geometry-lgeometry -lm -o ex3_3.out</strong></p>
			<p class="snippet shell"><strong class="screen-text">$</strong></p>
			<p class="packt_figref">Shell Box 3-17: Linking example 3.3 against the built shared object file</p>
			<p class="normal">As we explained before, the option <code class="Code-In-Text--PACKT-">-lgeometry</code> tells the compiler to find and use a library, either static or shared, to link it with the rest of the object files. Since we have removed the static library file, the shared object file is picked up. If both the static library and shared object files exist for a defined library, then <code class="Code-In-Text--PACKT-">gcc</code> prefers to pick the shared object file and link it with the program.</p>
			<p class="normal">If you now try to run the executable file <code class="Code-In-Text--PACKT-">ex3_3.out</code>, you will most probably face the following error:</p>
			<p class="snippet shell"><strong class="screen-text">$ ./ex3_3.out</strong></p>
			<p class="snippet shell">./ex3_3.out: error while loading shared libraries: libgeometry.so: cannot open shared object file: No such file or directory</p>
			<p class="snippet shell"><strong class="screen-text">$</strong></p>
			<p class="packt_figref">Shell Box 3-18: Trying to run example 3.3</p>
			<p class="normal">We haven't seen this error so far, because we were using static linkage and a static library. But now, by introducing dynamic libraries, if we are going to run a program that has <em class="italics">dynamic dependencies</em>, we should provide the required dynamic libraries to have it run. But what has happened and why we've received the error message?</p>
			<p class="normal">The <code class="Code-In-Text--PACKT-">ex3_3.out</code> executable file depends on <code class="Code-In-Text--PACKT-">libgeometry.so</code>. That's because some of the definitions it needs can only be found inside that shared object file. We should note that this is not true for the static library <code class="Code-In-Text--PACKT-">libgeometry.a</code>. An executable file linked with a static library can be run on its own as a standalone executable, since it has copied everything from the static library file, and therefore, doesn't rely on its existence anymore.</p>
			<p class="normal">This is not true for the shared object files. We received the error because the program loader (dynamic linker) could not find <code class="Code-In-Text--PACKT-">libgeometry.so</code> in its default search paths. Therefore, we need to add <code class="Code-In-Text--PACKT-">/opt/geometry</code> to its search paths, so that it finds the <code class="Code-In-Text--PACKT-">libgeometry.so</code> file there. To do this, we will update the environment variable <code class="Code-In-Text--PACKT-">LD_LIBRARY_PATH</code> to point to the current directory.</p>
			<p class="normal">The loader will check the<a id="_idIndexMarker283"/> value of this environment variable, and it will search the specified paths for the required shared libraries. Note that more than one path can be specified in this environment variable (using the separator colon <code class="Code-In-Text--PACKT-">:</code>).</p>
			<p class="snippet shell"><strong class="screen-text">$ export LD_LIBRARY_PATH=/opt/geometry </strong></p>
			<p class="snippet shell"><strong class="screen-text">$ ./ex3_3.out</strong></p>
			<p class="snippet shell">Polar Position: Length: 223.606798, Theta: 63.434949 (deg)</p>
			<p class="snippet shell"><strong class="screen-text">$</strong></p>
			<p class="packt_figref">Shell Box 3-19: Running example 3.3 by specifying LD_LIBRARY_PATH</p>
			<p class="normal">This time, the program has successfully been run! This means that the program loader has found the shared object file and the dynamic linker has loaded the required symbols from it successfully.</p>
			<p class="normal">Note that, in the preceding shell box, we used the <code class="Code-In-Text--PACKT-">export</code> command to change the <code class="Code-In-Text--PACKT-">LD_LIBRARY_PATH</code>. However, it is common to set the environment variable together with the execution command. You can see this in the following shell box. The result would be the same for both usages:</p>
			<p class="snippet shell"><strong class="screen-text">$ LD_LIBRARY_PATH=/opt/geometry ./ex3_3.out</strong></p>
			<p class="snippet shell">Polar Position: Length: 223.606798, Theta: 63.434949 (deg)</p>
			<p class="snippet shell"><strong class="screen-text">$</strong></p>
			<p class="packt_figref">Shell Box 3-20: Running example 3.3 by specifying LD_LIBRARY_PATH as part of the same command</p>
			<p class="normal">By linking an executable with several shared object files, as we did before, we tell the system that this executable file needs a number of shared libraries to be found and loaded at runtime. Therefore, before running the executable, the loader searches for those shared object files <a id="_idIndexMarker284"/>automatically, and the required symbols are mapped to the proper addresses that are accessible by the process. Only then can the processor begin the execution.</p>
			<h2 id="_idParaDest-68" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor108"/>Manual loading of shared libraries</h2>
			<p class="normal">Shared object files can also be loaded and used in a different way, in which they are not loaded <em class="italics">automatically</em> by the<a id="_idIndexMarker285"/> loader program (dynamic linker). Instead, the programmer will use a set of functions to load a shared object file <em class="italics">manually</em> before using some symbols (functions) that can be found inside that shared library. There are applications for this manual loading mechanism, and we'll talk about them once we've discussed the example we'll look at in this section.</p>
			<p class="normal"><em class="italics">Example 3.4</em> demonstrates how to load a shared object file lazily, or manually, without having it in the linking step. This example borrows the same logic from <em class="italics">example 3.3</em>, but instead, it loads the shared object file <code class="Code-In-Text--PACKT-">libgeometry.so</code> manually inside the program.</p>
			<p class="normal">Before going through <em class="italics">example 3.4</em>, we need to produce <code class="Code-In-Text--PACKT-">libgeometry.so</code> a bit differently in order to make <em class="italics">example 3.4</em> work. To do this, we have to use the following command in Linux:</p>
			<p class="snippet shell"><strong class="screen-text">$ gcc -shared 2d.o 3d.o trigon.o -lm -o libgeometry.so</strong></p>
			<p class="snippet shell"><strong class="screen-text">$</strong></p>
			<p class="packt_figref">Shell Box 3-21: Linking the geometry shared object file against the standard math library</p>
			<p class="normal">Looking at the preceding command, you can see a new option, <code class="Code-In-Text--PACKT-">-lm</code>, which tells the linker to link the shared object file against the standard math library, <code class="Code-In-Text--PACKT-">libm.so</code>. That is done because when we load <code class="Code-In-Text--PACKT-">libgeometry.so</code> manually, its dependencies should, somehow, be loaded automatically. If they're not, then we will get errors about the symbols that are required by <code class="Code-In-Text--PACKT-">libgeometry.so</code> itself, such as <code class="Code-In-Text--PACKT-">cos</code> or <code class="Code-In-Text--PACKT-">sqrt</code>. Note that we won't link the final executable file with the math standard library, and it will be resolved automatically by the loader when loading <code class="Code-In-Text--PACKT-">libgeometry.so</code>.</p>
			<p class="normal">Now that we have a linked shared object file, we can proceed to <em class="italics">example 3.4</em>:</p>
			<p class="snippet code">#include &lt;stdio.h&gt;</p>
			<p class="snippet code">#include &lt;stdlib.h&gt;</p>
			<p class="snippet code">#include &lt;dlfcn.h&gt;</p>
			<p class="snippet code">#include "ExtremeC_examples_chapter3_2_geometry.h"</p>
			<p class="snippet code">polar_pos_2d_t (*func_ptr)(cartesian_pos_2d_t*);</p>
			<p class="snippet code">int main(int argc, char** argv) {</p>
			<p class="snippet code">  void* handle = dlopen ("/opt/geometry/libgeometry.so", RTLD_LAZY);</p>
			<p class="snippet code">  if (!handle) {</p>
			<p class="snippet code">    fprintf(stderr, "%s\n", dlerror());</p>
			<p class="snippet code">    exit(1);</p>
			<p class="snippet code">  }</p>
			<p class="snippet code">  func_ptr = dlsym(handle, "convert_to_2d_polar_pos");</p>
			<p class="snippet code">  if (!func_ptr)  {</p>
			<p class="snippet code">    fprintf(stderr, "%s\n", dlerror());</p>
			<p class="snippet code">    exit(1);</p>
			<p class="snippet code">  }</p>
			<p class="snippet code">  cartesian_pos_2d_t cartesian_pos;</p>
			<p class="snippet code">  cartesian_pos.x = 100;</p>
			<p class="snippet code">  cartesian_pos.y = 200;</p>
			<p class="snippet code">  polar_pos_2d_t polar_pos = func_ptr(&amp;cartesian_pos);</p>
			<p class="snippet code">  printf("Polar Position: Length: %f, Theta: %f (deg)\n",</p>
			<p class="snippet code">    polar_pos.length, polar_pos.theta);</p>
			<p class="snippet code">  return 0;</p>
			<p class="snippet code">}</p>
			<p class="packt_figref">Code Box 3-8 [ExtremeC_examples_chapter3_4.c]: Example 3.4 loading the geometry shared object file manually</p>
			<p class="normal">Looking at the preceding code, you can see how we have used the functions <code class="Code-In-Text--PACKT-">dlopen</code> and <code class="Code-In-Text--PACKT-">dlsym</code> to load the<a id="_idIndexMarker286"/> shared object file and then find the symbol <code class="Code-In-Text--PACKT-">convert_to_2d_polar_pos</code> in it. The function <code class="Code-In-Text--PACKT-">dlsym</code> returns a function pointer, which can be used to invoke the target function.</p>
			<p class="normal">It is worth noting that the preceding code searches for the shared object file in <code class="Code-In-Text--PACKT-">/opt/geometry</code>, and if there is no such object file, then an error message is shown. Note that in macOS, the shared object files end in the <code class="Code-In-Text--PACKT-">.dylib</code> extension. Therefore, the preceding code should be modified in order to load the file with the correct extension.</p>
			<p class="normal">The following command compiles the preceding code and runs the executable file:</p>
			<p class="snippet shell"><strong class="screen-text">$ gcc ExtremeC_examples_chapter3_4.c -ldl -o ex3_4.out</strong></p>
			<p class="snippet shell"><strong class="screen-text">$ ./ex3_4.out</strong></p>
			<p class="snippet shell">Polar Position: Length: 223.606798, Theta: 63.434949 (deg)</p>
			<p class="snippet shell"><strong class="screen-text">$</strong></p>
			<p class="packt_figref">Shell Box 3-22: Running example 3.4</p>
			<p class="normal">As you can see, we did not link the program with the file <code class="Code-In-Text--PACKT-">libgeometry.so</code>. We didn't do this because we want to instead load it manually when it is needed. This method is often referred to as the <em class="italics">lazy loading</em> of shared object files. Yet, despite the name, in certain scenarios, lazy loading the shared object files can be really useful.</p>
			<p class="normal">One such case is when you have different shared object files for different implementations or <a id="_idIndexMarker287"/>versions of the same library. Lazy loading gives you increased freedom to load the desired shared objects according to your own logic and when it is needed, instead of having them automatically loaded at load time, where you have less control over them.</p>
			<h1 id="_idParaDest-69" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor109"/>Summary</h1>
			<p class="normal">This chapter mainly talked about various types of object files, as products of a C/C++ project after building. As part of this chapter, we covered the following points:</p>
			<ul>
				<li class="list">We discussed the API and ABI, along with their differences.</li>
				<li class="list">We went through various object file formats and looked at a brief history of them. They all share the same ancestor, but they have changed in their specific paths to become what they are today.</li>
				<li class="list">We talked about relocatable object files and their internal structure regarding ELF relocatable object files.</li>
				<li class="list">We discussed executable object files and the differences between them and relocatable object files. We also took a look at an ELF executable object file.</li>
				<li class="list">We showed static and dynamic symbol tables and how their content can be read using some command-line tools.</li>
				<li class="list">We discussed static linking and dynamic linking and how various symbol tables are looked up in order to produce the final binary or execute a program.</li>
				<li class="list">We discussed static library files and the fact that they are just archive files that contain a number of relocatable object files.</li>
				<li class="list">Shared object files (dynamic libraries) were discussed and we demonstrated how they can be made out of a number of relocatable object files.</li>
				<li class="list">We explained what position-independent code is and why the relocatable object files participating in the creation of a shared library must be position-independent.</li>
			</ul>
			<p class="normal">In the following chapter, we will go through the memory structure of a process; another key topic in C/C++ programming. The various memory segments will be described as part of the next chapter and we'll see how we can write code that has no memory issues in it.</p>
		</div>
</body></html>