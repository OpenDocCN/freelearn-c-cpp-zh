["```cpp\nVkAccelerationStructureGeometryKHR geometry{\n    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR };\ngeometry.geometryType = VK_GEOMETRY_TYPE_TRIANGLES_KHR;\ngeometry.flags =  mesh.is_transparent() ? 0 :\n    VK_GEOMETRY_OPAQUE_BIT_KHR;\n```", "```cpp\ngeometry.geometry.triangles.sType =\n    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY\n        _TRIANGLES_DATA_KHR;\ngeometry.geometry.triangles.vertexFormat =\n    VK_FORMAT_R32G32B32_SFLOAT;\ngeometry.geometry.triangles.vertexData.deviceAddress =\n    renderer->gpu->get_buffer_device_address(\n        mesh.position_buffer ) + mesh.position_offset;\ngeometry.geometry.triangles.vertexStride = sizeof( float )\n    * 3;\ngeometry.geometry.triangles.maxVertex = vertex_count;\ngeometry.geometry.triangles.indexType = mesh.index_type;\ngeometry.geometry.triangles.indexData.deviceAddress =\n    renderer->gpu->get_buffer_device_address(\n        mesh.index_buffer );\n```", "```cpp\nVkAccelerationStructureBuildRangeInfoKHR build_range_info{ };\nbuild_range_info.primitiveCount = vertex_count;\nbuild_range_info.primitiveOffset = mesh.index_offset;\n```", "```cpp\nVkAccelerationStructureBuildGeometryInfoKHR as_info{\n    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD\n        _GEOMETRY_INFO_KHR };\nas_info.type =\n    VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR;\nas_info.mode =\n    VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR;\nas_info.geometryCount = scene->geometries.size;\nas_info.pGeometries = scene->geometries.data;\n```", "```cpp\nas_info.flags =\n    VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR |\n        VK_BUILD_ACCELERATION_STRUCTURE_ALLOW\n            _COMPACTION_BIT_KHR;\n```", "```cpp\nfor ( u32 range_index = 0; range_index < scene->\n    geometries.size; range_index++ ) {\n        max_primitives_count[ range_index ] = scene->\n           build_range_infos[ range_index ].primitiveCount;\n}\n```", "```cpp\nVkAccelerationStructureBuildSizesInfoKHR as_size_info{\n    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD\n        _SIZES_INFO_KHR };\nvkGetAccelerationStructureBuildSizesKHR( gpu.vulkan_device,\n    VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR,\n      &as_info, max_primitives_count.data, &as_size_info );\n```", "```cpp\nas_buffer_creation.set(\n    VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR,\n        ResourceUsageType::Immutable,\n            as_size_info.accelerationStructureSize )\n                .set_device_only( true )\n                    .set_name( \"blas_buffer\" );\nscene->blas_buffer = gpu.create_buffer(\n    as_buffer_creation );\nas_buffer_creation.set(\nVK_BUFFER_USAGE_STORAGE_BUFFER_BIT |\n    VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR,\n        ResourceUsageType::Immutable,\n            as_size_info.buildScratchSize )\n                .set_device_only( true )\n                    .set_name( \"blas_scratch_buffer\" );\nBufferHandle blas_scratch_buffer_handle =\n    gpu.create_buffer( as_buffer_creation );\n```", "```cpp\nVkAccelerationStructureCreateInfoKHR as_create_info{\n    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE\n        _CREATE_INFO_KHR };\nas_create_info.buffer = blas_buffer->vk_buffer;\nas_create_info.offset = 0;\nas_create_info.size =\n    as_size_info.accelerationStructureSize;\nas_create_info.type =\n    VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR;\nvkCreateAccelerationStructureKHR( gpu.vulkan_device,\n    &as_create_info, gpu.vulkan_allocation_callbacks,\n        &scene->blas );\n```", "```cpp\nas_info.dstAccelerationStructure = scene->blas;\nas_info.scratchData.deviceAddress =\n    gpu.get_buffer_device_address(\n        blas_scratch_buffer_handle );\nVkAccelerationStructureBuildRangeInfoKHR* blas_ranges[] = {\n    scene->build_range_infos.data\n};\n```", "```cpp\nvkCmdBuildAccelerationStructuresKHR( gpu_commands->\n    vk_command_buffer, 1, &as_info, blas_ranges );\ngpu.submit_immediate( gpu_commands );\n```", "```cpp\nVkAccelerationStructureInstanceKHR tlas_structure{ };\ntlas_structure.transform.matrix[ 0 ][ 0 ] = 1.0f;\ntlas_structure.transform.matrix[ 1 ][ 1 ] = 1.0f;\ntlas_structure.transform.matrix[ 2 ][ 2 ] = 1.0f;\ntlas_structure.mask = 0xff;\ntlas_structure.flags = VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR;\ntlas_structure.accelerationStructureReference =\n    blas_address;\n```", "```cpp\nas_buffer_creation.reset().set(\n    VK_BUFFER_USAGE_ACCELERATION_STRUCTURE\n    _BUILD_INPUT_READ_ONLY_BIT_KHR | VK_BUFFER_USAGE_\n    SHADER_DEVICE_ADDRESS_BIT,\n    ResourceUsageType::Immutable, sizeof(\n    VkAccelerationStructureInstanceKHR ) )\n    .set_data( &tlas_structure )\n    .set_name( \"tlas_instance_buffer\" );\nBufferHandle tlas_instance_buffer_handle =\n    gpu.create_buffer( as_buffer_creation );\n```", "```cpp\nVkAccelerationStructureGeometryKHR tlas_geometry{\n    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR };\ntlas_geometry.geometryType =\n    VK_GEOMETRY_TYPE_INSTANCES_KHR;\ntlas_geometry.geometry.instances.sType =\n    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE\n        _GEOMETRY_INSTANCES_DATA_KHR;\ntlas_geometry.geometry.instances.arrayOfPointers = false;\ntlas_geometry.geometry.instances.data.deviceAddress =\n    gpu.get_buffer_device_address(\n        tlas_instance_buffer_handle );\n```", "```cpp\nas_info.type =\n    VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR;\nas_info.geometryCount = 1;\nas_info.pGeometries = &tlas_geometry;\n```", "```cpp\nas_create_info.buffer = tlas_buffer->vk_buffer;\nas_create_info.offset = 0;\nas_create_info.size =\n    as_size_info.accelerationStructureSize;\nas_create_info.type =\n    VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR;\nvkCreateAccelerationStructureKHR( gpu.vulkan_device,\n                                  &as_create_info, \n                                  gpu.vulkan_allocation_\n                                     callbacks,\n                                  &scene->tlas );\n```", "```cpp\nas_info.dstAccelerationStructure = scene->tlas;\nas_info.scratchData.deviceAddress =\n    gpu.get_buffer_device_address(\n        tlas_scratch_buffer_handle );\nVkAccelerationStructureBuildRangeInfoKHR tlas_range_info{ };\n    tlas_range_info.primitiveCount = 1;\nVkAccelerationStructureBuildRangeInfoKHR* tlas_ranges[] = {\n    &tlas_range_info\n};\nvkCmdBuildAccelerationStructuresKHR( gpu_commands->\n    vk_command_buffer, 1, &as_info, tlas_ranges );\n```", "```cpp\n#extension GL_EXT_ray_tracing : enable\n```", "```cpp\nlayout( location = 0 ) rayPayloadEXT vec4 payload;\n```", "```cpp\nlayout( binding = 1, set = MATERIAL_SET ) uniform\n    accelerationStructureEXT as;\n```", "```cpp\nlayout( binding = 2, set = MATERIAL_SET ) uniform rayParams\n{\n    uint sbt_offset;\n    uint sbt_stride;\n    uint miss_index;\n    uint out_image_index;\n};\n```", "```cpp\ntraceRayEXT( as, // top level acceleration structure\n                gl_RayFlagsOpaqueEXT, // rayFlags\n                0xff, // cullMask\n                sbt_offset,\n                sbt_stride,\n                miss_index,\n                camera_position.xyz, // origin\n                0.0, // Tmin\n                compute_ray_dir( gl_LaunchIDEXT,\n                gl_LaunchSizeEXT ),\n                100.0, // Tmax\n                0 // payload\n            );\n```", "```cpp\nvec3 compute_ray_dir( uvec3 launchID, uvec3 launchSize) {\n```", "```cpp\n    float x = ( 2 * ( float( launchID.x ) + 0.5 ) / float(\n        launchSize.x ) - 1.0 );\n    float y = ( 1.0 - 2 * ( float( launchID.y ) + 0.5 ) /\n        float( launchSize.y ) );\n```", "```cpp\n   vec4 dir = inverse_view_projection * vec4( x, y, 1, 1 );\n   dir = normalize( dir );\n   return dir.xyz;\n}\n```", "```cpp\nimageStore( global_images_2d[ out_image_index ], ivec2(\n    gl_LaunchIDEXT.xy ), payload );\n```", "```cpp\nlayout( location = 0 ) rayPayloadInEXT vec4 payload;\nvoid main() {\n    payload = vec4( 1.0, 0.0, 0.0, 1.0 );\n}\n```", "```cpp\nshader_group_info.sType =\n    VK_STRUCTURE_TYPE_RAY_TRACING_SHADER\n        _GROUP_CREATE_INFO_KHR;\nshader_group_info.type =\n    VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR;\nshader_group_info.generalShader = stage index;\nshader_group_info.closestHitShader = VK_SHADER_UNUSED_KHR;\nshader_group_info.anyHitShader = VK_SHADER_UNUSED_KHR;\nshader_group_info.intersectionShader =\n    VK_SHADER_UNUSED_KHR;\n```", "```cpp\nshader_group_info.type =\n    VK_RAY_TRACING_SHADER_GROUP_TYPE\n        _TRIANGLES_HIT_GROUP_KHR;\nshader_group_info.closestHitShader = stage_index;\n```", "```cpp\nVkRayTracingPipelineCreateInfoKHR pipeline_info{\n    VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR };\npipeline_info.stageCount = shader_state_data->\n    active_shaders;\npipeline_info.pStages = shader_state_data->\n    shader_stage_info;\npipeline_info.groupCount = shader_state_data->\n    active_shaders;\npipeline_info.pGroups = shader_state_data->\n    shader_group_info;\npipeline_info.maxPipelineRayRecursionDepth = 1;\npipeline_info.layout = pipeline_layout;\nvkCreateRayTracingPipelinesKHR( vulkan_device,\n    VK_NULL_HANDLE, pipeline_cache, 1, &pipeline_info,\n        vulkan_allocation_callbacks, &pipeline->vk_pipeline );\npipeline->vk_bind_point =\n    VkPipelineBindPoint::VK_PIPELINE\n        _BIND_POINT_RAY_TRACING_KHR;\n```", "```cpp\nu32 group_handle_size =\n    ray_tracing_pipeline_properties.shaderGroupHandleSize;\nsizet shader_binding_table_size = group_handle_size *\n    shader_state_data->active_shaders;\n```", "```cpp\nArray<u8> shader_binding_table_data{ };\nshader_binding_table_data.init( allocator,\n    shader_binding_table_size, shader_binding_table_size );\nvkGetRayTracingShaderGroupHandlesKHR( vulkan_device,\n    pipeline->vk_pipeline, 0, shader_state_data->\n        active_shaders, shader_binding_table_size,\n            shader_binding_table_data.data );\n```", "```cpp\nBufferCreation shader_binding_table_creation{ };\nshader_binding_table_creation.set(\n    VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR |\n    VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR,\n    ResourceUsageType::Immutable, group_handle_size\n    ).set_data( shader_binding_table_data.data\n    ).set_name(  \"shader_binding_table_raygen\" );\npipeline->shader_binding_table_raygen = create_buffer(\n    shader_binding_table_creation );\nshader_binding_table_creation.set_data(\n    shader_binding_table_data.data + group_handle_size )\n        .set_name( \"shader_binding_table_hit\" );\npipeline->shader_binding_table_hit = create_buffer(\n    shader_binding_table_creation );\nshader_binding_table_creation.set_data(\n    shader_binding_table_data.data + ( group_handle_size *\n        2 ) ).set_name( \"shader_binding_table_miss\" );\npipeline->shader_binding_table_miss = create_buffer(\n    shader_binding_table_creation );\n```", "```cpp\nu32 shader_group_handle_size = gpu_device->\n    ray_tracing_pipeline_properties.shaderGroupHandleSize;\nVkStridedDeviceAddressRegionKHR raygen_table{ };\nraygen_table.deviceAddress = gpu_device->\n    get_buffer_device_address( pipeline->\n        shader_binding_table_raygen );\nraygen_table.stride = shader_group_handle_size;\nraygen_table.size = shader_group_handle_size;\nVkStridedDeviceAddressRegionKHR hit_table{ };\nhit_table.deviceAddress = gpu_device->\n    get_buffer_device_address( pipeline->\n        shader_binding_table_hit );\nVkStridedDeviceAddressRegionKHR miss_table{ };\nmiss_table.deviceAddress = gpu_device->\n    get_buffer_device_address( pipeline->\n        shader_binding_table_miss );\nVkStridedDeviceAddressRegionKHR callable_table{ };\nvkCmdTraceRaysKHR( vk_command_buffer, &raygen_table,\n    &miss_table, &hit_table, &callable_table, width,\n        height, depth );\n```"]