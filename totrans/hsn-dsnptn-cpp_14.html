<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-245"><a id="_idTextAnchor640"/>14</h1>
<h1 id="_idParaDest-246"><a id="_idTextAnchor641"/>The Template Method Pattern and the Non-Virtual Idiom<a id="_idTextAnchor642"/></h1>
<p>The Template Method is one of the classic <em class="italic">Gang of Four</em> design patterns, or, more formally, one of the 24 patterns described in the book <em class="italic">Design Patterns – Elements of Reusable Object-Oriented Software</em> by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. It is a behavioral design pattern, meaning that it describes a way for communicating between different objects. As an object-oriented language, C++, of course, fully supports the Template Method pattern, although there are some implementation details that are specific or unique to C++ that this chapter will elucidate.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>What is the Template Method pattern, and what problems does it solve?</li>
<li>What is the non-virtual interface?</li>
<li>Should you make virtual functions public, private, or protected by default?</li>
<li>Should you always make destructors virtual and public in polymorphic classes?<a id="_idTextAnchor643"/></li>
</ul>
<h1 id="_idParaDest-247"><a id="_idTextAnchor644"/>Technical requirements</h1>
<p><a id="_idTextAnchor645"/>The example code for this chapter can be found at the following GitHub link: <a href="https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter14">https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter14</a>.<a id="_idTextAnchor646"/></p>
<h1 id="_idParaDest-248"><a id="_idTextAnchor647"/>The Template Method pattern</h1>
<p>The Template Method <a id="_idIndexMarker766"/>pattern is a common way to implement an algorithm whose overall structure is pre-determined, but some of the details of the implementation need to be customized. If you are thinking about a solution that goes something like this—first, we do <em class="italic">X</em>, then <em class="italic">Y</em>, and then <em class="italic">Z</em>, but how exactly we do <em class="italic">Y</em> depends on the data we process—you are thinking about the Template Method. As a pattern that allows the behavior of a program to change dynamically, the Template Method is somewhat similar to the strategy pattern. The key difference is that the strategy pattern changes the entire algorithm at runtime, while the Template Method lets <a id="_idIndexMarker767"/>us customize specific parts of the algorithm. This section deals with the latter, while we have a separate <a href="B19262_16.xhtml#_idTextAnchor739"><em class="italic">Chapter 16</em></a>, <em class="italic">Policy-Based Design</em>, dedicated to the forme<a id="_idTextAnchor648"/>r<a id="_idTextAnchor649"/>.</p>
<h2 id="_idParaDest-249"><a id="_idTextAnchor650"/>The Template Method in C++</h2>
<p>The Template Method pattern is easily implemented in any object-oriented language. The C++ implementation uses inheritance and virtual functions. Note that this has nothing to do with C++ templates, as in generic programming. The <em class="italic">template</em> here is the skeleton implementation of the algorithm:</p>
<pre class="source-code">
// Example 01
class Base {
  public:
  bool TheAlgorithm() {
    if (!Step1()) return false; // Step 1 failed
    Step2();
    return true;
  }
};</pre>
<p>The <em class="italic">template</em> here is the structure of the algorithm—all implementations must first do <em class="italic">step 1</em>, which may fail. If this happens, the entire algorithm is considered to have failed, and nothing more is done. If <em class="italic">step 1</em> succeeded, we must do <em class="italic">step 2</em>. By design, <em class="italic">step 2</em> cannot fail, and the overall algorithm computation is considered a success once <em class="italic">step 2</em> is completed.</p>
<p>Note that the <code>TheAlgorithm()</code> method is public but not virtual—any class derived from <code>Base</code> has it as a part of its interface but cannot override what it does. What the derived classes can override are the implementations of <em class="italic">step 1</em> and <em class="italic">step 2</em>, within the restrictions of the algorithm template – <em class="italic">step 1</em> may fail and must signal the failure by returning <code>false</code>, while <em class="italic">step 2</em> may not fail:</p>
<pre class="source-code">
// Example 01
class Base {
  public:
  ...
  virtual bool Step1() { return true };
  virtual void Step2() = 0;
};
class Derived1 : public Base {
  public:
  void Step2() override { ... do the work ... }
};
class Derived2 : public Base {
  public:
  bool Step1() override { ... check preconditions ... }
  void Step2() override { ... do the work ... }
};</pre>
<p>In the preceding<a id="_idIndexMarker768"/> example, overriding<a id="_idIndexMarker769"/> the potentially failing <em class="italic">step 1</em> is optional, and the default implementation is trivial; it does nothing and never fails. <em class="italic">Step 2</em> must be implemented by every derived class—there is no default, and it is declared as a pure virtual function.</p>
<p>You can see that the overall flow of control—the framework—remains invariant, but it has <em class="italic">placeholders</em> for customizable options, possibly with a default offered by the framework itself. Such a flow is known as the inversion of control. In a traditional control flow, its specific implementation determines the flow of computation and sequence of operations and makes calls to library functions or other lower-level functions to implement the necessary general algorithms. In the Template Method, it is the framework that calls specific implementations in the custom c<a id="_idTextAnchor651"/>o<a id="_idTextAnchor652"/>de.</p>
<h2 id="_idParaDest-250"><a id="_idTextAnchor653"/>Applications of the Template Method</h2>
<p>There are many<a id="_idIndexMarker770"/> reasons to use the Template Method. In general, it is used to control what can and cannot be sub-classed—as opposed to a general polymorphic override, where the entire virtual function can be replaced, the base class here determines what can and cannot be overridden. Another common use of the Template Method is to avoid code duplication, and in this context, you can arrive at the use of the Template Method as follows. Suppose that you start with the regular polymorphism—a virtual function—and it overrides. For example, let’s consider this toy design for a turn-based combat system for a game:</p>
<pre class="source-code">
// Example 02
class Character {
  public:
  virtual void CombatTurn() = 0;
  protected:
  int health_;
};
class Swordsman : public Character {
  bool wielded_sword_;
  public:
  void CombatTurn() override {
    if (health_ &lt; 5) { // Critically injured
      Flee();
      return;
    }
    if (!wielded_sword_) {
      Wield();
      return; // Wielding takes a full turn
    }
    Attack();
  }
};
class Wizard : public Character {
  int mana_;
  bool scroll_ready_;
  public:
  void CombatTurn() override {
    if (health_ &lt; 2 ||
        mana_ == 0) { // Critically injured or out of mana
      Flee();
      return;
    }
    if (!scroll_ready_) {
      ReadScroll();
      return; // Reading takes a full turn
    }
    CastSpell();
  }
};</pre>
<p>Note how this code is <a id="_idIndexMarker771"/>highly repetitive—all characters may be forced to disengage from combat on their turn, then they must take a turn to get ready for combat, and only then, if they are ready and strong enough, can they use their offensive capabilities. If you see this pattern repeating over and over, it is a strong hint that the Template Method may be called for. With the Template Method, the overall sequence of the combat turn is fixed, but how each character advances to the next step and what he/she does once he/she gets there remains character-specific:</p>
<pre class="source-code">
// Example 03
class Character {
  public:
  void CombatTurn() {
    if (MustFlee()) {
      Flee();
      return;
    }
    if (!Ready()) {
      GetReady();
      return; // Getting ready takes a full turn
    }
    CombatAction();
  }
  virtual bool MustFlee() const = 0;
  virtual bool Ready() const = 0;
  virtual void GetReady() = 0;
  virtual void CombatAction() = 0;
  protected:
  int health_;
};</pre>
<p>Now each derived <a id="_idIndexMarker772"/>class must implement only the part of the code that is unique to this class:</p>
<pre class="source-code">
// Example 03
class Swordsman : public Character {
  bool wielded_sword_;
  public:
  bool MustFlee() const override { return health_ &lt; 5; }
  bool Ready() const override { return wielded_sword_; }
  void GetReady()override { Wield(); }
  void CombatAction()override { Attack(); }
};
class Wizard : public Character {
  int mana_;
  bool scroll_ready_;
  public:
  bool MustFlee() const override { return health_ &lt; 2 ||
                                          mana_ == 0; }
  bool Ready() const override { return scroll_ready_; }
  void GetReady() override { ReadScroll(); }
  void CombatAction() override { CastSpell(); }
};</pre>
<p>Note how this code is<a id="_idIndexMarker773"/> much less repetitive. The advantage of the Template Method goes beyond good looks, though. Let’s say that in the next revision of the game, we have added healing potions, and at the beginning of the turn, each character may drink a potion. Now, imagine going through every derived class and adding code like <code>if (health_ &lt; ... some class-specific value ... &amp;&amp; potion_count_ &gt; 0) ...</code>. If the design already used the Template Method, the logic of potion-quaffing needs to be coded only once, and different classes implement their specific conditions for using a potion, as well as the consequences of drinking one. However, don’t rush to implement this solution until you get to the end of this chapter, as this is not the best C++ code you<a id="_idTextAnchor654"/> <a id="_idTextAnchor655"/>can do.</p>
<h2 id="_idParaDest-251"><a id="_idTextAnchor656"/>Pre-and post-conditions and actions</h2>
<p>Another <a id="_idIndexMarker774"/>common use of the Template Method <a id="_idIndexMarker775"/>is dealing with pre-and post-conditions or actions. In a class hierarchy, pre- and post-conditions generally verify that the design invariants of an abstraction provided by an interface are not violated by any specific implementation at any point during execution. Such verification naturally submits to the Template Method’s design:</p>
<pre class="source-code">
// Example 04
class Base {
  public:
  void VerifiedAction() {
    assert(StateIsValid());
    ActionImpl();
    assert(StateIsValid());
  }
  virtual void ActionImpl() = 0;
};
class Derived : public Base {
  public:
  void ActionImpl() override { ... real implementation ...}
};</pre>
<p>The invariants are the requirements that the object must satisfy when it’s accessible to the client, i.e., before any member function is called on it or after it returns. The member functions themselves often have to temporarily break the invariants, but they must restore the correct state of the class before returning control to the caller. Let us say that our classes from the preceding example keep track of how many actions have been executed. Each action is registered when it starts and again when it’s done, and the two counts must be the same: once an action is initiated, it has to complete before control is returned to the caller. Of course, inside the <code>ActionImpl()</code> member function this invariant is violated since an action is in progress:</p>
<pre class="source-code">
// Example 04
class Base {
  bool StateIsValid() const {
    return actions_started_ == actions_completed_;
  }
  protected:
  size_t actions_started_ = 0;
  size_t actions_completed_ = 0;
  public:
  void VerifiedAction() {
    assert(StateIsValid());
    ActionImpl();
    assert(StateIsValid());
  }
  virtual void ActionImpl() = 0;
};
class Derived : public Base {
  public:
  void ActionImpl() override {
    ++actions_started_;
    ... perform the action ...
    ++actions_completed_;
  }
};</pre>
<p>Of course, any <a id="_idIndexMarker776"/>practical<a id="_idIndexMarker777"/> implementation of pre- and post-conditions must take into account several additional factors. First, some member functions may have additional invariants, i.e., they can be called only when the object is in a restricted state. Such functions would have specific pre-conditions to test. Second, we have not considered the possibility that an action is aborted due to an error (this may or may not involve throwing an exception). A well-designed implementation of error handling must guarantee that the class invariants are not violated after such an error. In our case, a failed action may be ignored altogether (in which case, we need to decrement the count of started actions) or our invariant may have to be more complex: all started actions must<a id="_idIndexMarker778"/> end <a id="_idIndexMarker779"/>up as completed or failed, and we need to count both:</p>
<pre class="source-code">
// Example 05
class Base {
  bool StateIsValid() const {
    return actions_started_ ==
      actions_completed_ + actions_failed_;
  }
  protected:
  size_t actions_started_ = 0;
  size_t actions_completed_ = 0;
  size_t actions_failed_ = 0;
  ...
};
class Derived : public Base {
  public:
  void ActionImpl() override {
    ++actions_started_;
    try {
      ... perform the action – may throw ...
      ++actions_completed_;
    } catch (...) {
      ++actions_failed_;
    }
  }
};</pre>
<p>In a real program, you must ensure that a failed transaction isn’t just counted correctly but is handled correctly too (often, it must be undone). We have discussed it in great detail in <a href="B19262_05.xhtml#_idTextAnchor199"><em class="italic">Chapter 5</em></a>, <em class="italic">A Comprehensive Look at RAII</em>, and again in <a href="B19262_11.xhtml#_idTextAnchor509"><em class="italic">Chapter 11</em></a>, <em class="italic">ScopeGuard</em>. Finally, in a concurrent program, it is no longer true that an object cannot be observed while a member function is being executed, and the entire subject of class invariants becomes much more complex and intertwined with thread-safety guarantees.</p>
<p>Of course, in software design, one man’s invariants are another’s customization points. Sometimes, it is the main code that remains the same, but what happens right before and right after depends on the specific application. In this case, we probably wouldn’t be <a id="_idIndexMarker780"/>verifying<a id="_idIndexMarker781"/> any invariants, but instead executing initial and final actions:</p>
<pre class="source-code">
// Example 06
class FileWriter {
  public:
  void Write(const char* data) {
    Preamble(data);
    ... write data to a file ...
    Postscript(data);
  }
  virtual void Preamble(const char* data) {}
  virtual void Postscript(const char* data) {}
};
class LoggingFileWriter : public FileWriter {
  public:
  using FileWriter::FileWriter;
  void Preamble(const char* data) override {
    std::cout &lt;&lt; "Writing " &lt;&lt; data &lt;&lt; " to the file" &lt;&lt;
      std::endl;
  }
  void Postscript (const char*) override {
    std::cout &lt;&lt; "Writing done" &lt;&lt; s<a id="_idTextAnchor657"/>t<a id="_idTextAnchor658"/>d::endl;
  }
};</pre>
<p>There is, of course, no reason why pre- and post-conditions cannot be combined with opening and closing actions – the base class can have several “standard” member function calls before <a id="_idIndexMarker782"/>and<a id="_idIndexMarker783"/> after the primary implementation.</p>
<p>While this code gets the job done, it still has some deficiencies that we are about to expose.</p>
<h1 id="_idParaDest-252"><a id="_idTextAnchor659"/>The Non-Virtual Interface</h1>
<p>The implementation of the dynamically customizable parts of the templated algorithm is usually done with virtual functions. For a general Template Method pattern, this is not a requirement, but in C++, we rarely need another way. Now, we are going to focus specifically on using the virtual functions and improving on wha<a id="_idTextAnchor660"/>t<a id="_idTextAnchor661"/> we have learned.</p>
<h2 id="_idParaDest-253"><a id="_idTextAnchor662"/>Virtual functions and access</h2>
<p>Let’s start with <a id="_idIndexMarker784"/>a <a id="_idIndexMarker785"/>general question—should virtual functions be public or private? The textbook object-oriented design style uses public virtual functions, so we often make them public without a second thought. Within the Template Method, this practice needs to be reevaluated—a public function is part of the class interface. In our case, the class interface includes the entire algorithm, and the framework we put in place in the base class. This function should be public, but it is also non-virtual. The customized implementations of some parts of the algorithm were never meant to be called directly by the clients of the class hierarchy. They are used in one place only—in the non-virtual public function, where they replace the placeholders we put in the template of the algorithm.</p>
<p>This idea may seem trivial, but it comes as a surprise to many programmers. I’ve had this question asked more than once—<em class="italic">does C++ even allow virtual functions to be anything other than public?</em> In fact, the language itself makes no restrictions on access to virtual functions; they can be private, protected, or public, just like any other class member functions. This can take some time to wrap <a id="_idIndexMarker786"/>your mind around; perhaps an example would help:</p>
<pre class="source-code">
// Example 07
class Base {
  public:
  void method1() { method2(); method3(); }
  virtual void method2() { ... }
  private:
  virtual void method3() { ... }
};
class Derived : public Base {
  private:
  void method2() override { ... }
  void method3() override { ... }
};</pre>
<p>Here, <code>Derived::method2()</code> and <code>Derived::method3()</code>are both private. Can the base class even call private methods of its derived classes? The answer is, it doesn’t have to—<code>Base::method1()</code> only calls <code>Base::method2()</code> and <code>Base::method3()</code> which are its own member functions (public and private, respectively); there is no problem with calling private member functions of the same class. But if the actual class type is <code>Derived</code>, the virtual override of <code>method2()</code> is called at runtime instead. These two decisions, <em class="italic">can I call</em> <code>method2()</code><em class="italic">?</em> and <em class="italic">which</em> <code>method2()</code><em class="italic">?</em>, happen at totally different times—the former happens when the module containing the <code>Base</code> class is compiled (and the <code>Derived</code> class may not have even been written yet), while the latter happens when the program is executed (and the words <em class="italic">private</em> or <em class="italic">public</em> don’t mean anything at that point). Also note that, as shown by <code>method3()</code> in the preceding example, a virtual function and its override can have different access. Again, the function invoked at compile time (<code>Base::method3()</code> in our case) must be accessible at the point of the call; the override that ends up executed at runtime doesn’t have to be (however, if we were to call <code>Derived::method3()</code> directly outside of the class itself, we would be trying to call a private method of that class).</p>
<pre class="source-code">
// Example 07
Derived* d = new Derived;
Base* b = d;
b-&gt;method2();    // OK, calls Derived::method2()
d-&gt;method2();    // Does not compile – private function</pre>
<p>There is another, more fundamental reason, to avoid public virtual functions. A public method is a part of the class interface. A virtual function override is a customization of the implementation. A public virtual function inherently does both of these tasks, at once. The same entity performs two very different functions that should not be coupled—declaring the public interface and providing an alternative implementation. Each of these functions has different constraints—the implementation can be altered in any way, as long as the hierarchy invariants hold. But the interface cannot be actually changed by the virtual function (except for returning covariant types, but even that does not really change the interface). All the public virtual function does is restate that yes, indeed, the public interface still looks like what the base class has declared. Such a mixing of two very distinct<a id="_idIndexMarker787"/> roles <a id="_idIndexMarker788"/>calls for a better separation of concerns. The Template Method pattern is an answer to that design problem, and in C++, it takes the form of the <strong class="bold">Non-V<a id="_idTextAnchor663"/>i<a id="_idTextAnchor664"/>rtual </strong><strong class="bold">Interface</strong> (<strong class="bold">NVI</strong>).</p>
<h2 id="_idParaDest-254"><a id="_idTextAnchor665"/>The NVI idiom in C++</h2>
<p>The tension<a id="_idIndexMarker789"/> between <a id="_idIndexMarker790"/>the two roles of a public virtual function, and the unnecessary exposure of the customization points created by such functions, lead us to the idea of making the implementation-specific virtual functions private. Herb Sutter in his article, <em class="italic">Virtuality</em> (<a href="http://www.gotw.ca/publications/mill18.htm">http://www.gotw.ca/publications/mill18.htm</a>), suggests that most, if not all, virtual functions should be private.</p>
<p>For the Template Method, moving virtual functions from public to private comes with no consequences (other than the initial shock of seeing a private virtual function, if you have never realized<a id="_idIndexMarker791"/> that<a id="_idIndexMarker792"/> C++ allows them):</p>
<pre class="source-code">
// Example 08 (NVI version of example 01)
class Base {
  public:
  bool TheAlgorithm() {
    if (!Step1()) return false; // Step 1 failed
    Step2();
    return true;
  }
  private:
  virtual bool Step1() { return true };
  virtual void Step2() = 0;
};
class Derived1 : public Base {
  void Step2() override { ... do the work ... }
};
class Derived2 : public Base {
  bool Step1() override { ... check preconditions ... }
  void Step2() override { ... do the work ... }
};</pre>
<p>This design nicely separates the interface and the implementation—the client interface is, and always was, the one call to run the entire algorithm. The possibility to change parts of the algorithm’s implementation is not reflected in the interface. Therefore, the user of this class hierarchy who only accesses it through the public interface and does not need to extend the hierarchy (write more derived classes), remains unaware of such implementation details. To see how this works in practice, you can convert every example in this chapter from public virtual functions to NVI; we are going to do just <a id="_idIndexMarker793"/>one, example 06, and <a id="_idIndexMarker794"/>leave the rest as an exercise to the reader.</p>
<pre class="source-code">
// Example 09 (NVI version of example 06)
class FileWriter {
  virtual void Preamble(const char* data) {}
  virtual void Postscript(const char* data) {}
  public:
  void Write(const char* data) {
    Preamble(data);
    ... write data to a file ...
    Postscript(data);
  }
};
class LoggingFileWriter : public FileWriter {
  using FileWriter::FileWriter;
  void Preamble(const char* data) override {
    std::cout &lt;&lt; "Writing " &lt;&lt; data &lt;&lt; " to the file" &lt;&lt;
      std::endl;
  }
  void Postscript (const char*) override {
    std::cout &lt;&lt; "Writing done" &lt;&lt; std::endl;
  }
};</pre>
<p>The NVI gives complete control of the interface to the base class. The derived classes can only customize the implementation of this interface. The base class can determine and verify the invariants, impose the overall structure of the implementation, and specify which parts can, must, and cannot be customized. The NVI also separates the interface from the implementation explicitly. The implementers of the derived classes do not need to be concerned with exposing part of their implementation to the callers unintentionally—the implementation-only private methods cannot be called by anyone except the base class.</p>
<p>Note that it is still possible for a derived class such as <code>LoggingFileWriter</code> to declare its own non-virtual function named <code>Write</code>. This is known as “shadowing” in C++: a name introduced in a derived class shadows (or makes inaccessible) all functions with the same name that would have been otherwise inherited from the base class. This causes the interfaces of the base and derived classes to diverge and is a very bad practice. Unfortunately, there is no good way for the base class implementer to protect from intentional shadowing. Accidental shadowing sometimes occurs when a function that is intended as a virtual override is declared with slightly different arguments; this can be avoided if the <code>override</code> keyword is used for all overrides.</p>
<p>So far, we have made all virtual functions that customize the implementation private. That, however, is not exactly the main point of the NVI—this idiom, and the more general Template Method, focus on making the public interface non-virtual. It follows, by extension, that <a id="_idIndexMarker795"/>the<a id="_idIndexMarker796"/> implementation-specific overrides should not be public since they are not part of the interface. It does not necessarily follow that they should be private. That leaves <em class="italic">protected</em>. So, should the virtual functions that provide customizations for the algorithm be private or protected? The Template Method allows both—the client of the hierarchy cannot directly call either one, so the framework of the algorithm remains unaffected. The answer depends on whether the derived classes may need to sub-invoke the implementations provided by the base class. For an example of the latter, consider a class hierarchy that can be serialized and sent to a remote machine through a socket:</p>
<pre class="source-code">
// Example 10
class Base {
  public:
  void Send() { // Template Method used here
    ... open connection ...
    SendData(); // Customization point
    ... close connection ...
  }
  protected:
  virtual void SendData() { ... send base class data ... }
  private:
  ... data ...
};
class Derived : public Base {
  protected:
  void SendData() {
    Base::SendData();
    ... send derived class data ...
  }
};</pre>
<p>Here, the framework is<a id="_idIndexMarker797"/> provided<a id="_idIndexMarker798"/> by the public non-virtual method <code>Base::Send()</code>, which handles the connection protocol and, at the right time, sends the data across the network. Of course, it can only send the data that the base class knows about. That is why <code>SendData</code> is a customization point and is made virtual. The derived class must send its own data, of course, but someone must still send the base class data, and so the derived class makes a call to the protected vi<a id="_idTextAnchor666"/>rtual function in the base class.</p>
<p>If this example looks like it’s missing something, there is a good reason for it. While we provided the general template for how to send data and a customization point for each class to handle its own data, there is another behavior aspect that should be user-configurable: <em class="italic">how</em> to send data. This is a great place to show the (sometimes obscure) difference between the template method pattern and the strategy pattern.</p>
<h2 id="_idParaDest-255"><a id="_idTextAnchor667"/>Template Method vs Strategy</h2>
<p>While this <a id="_idIndexMarker799"/>chapter<a id="_idIndexMarker800"/> is not about the Strategy pattern, it is<a id="_idIndexMarker801"/> sometimes confused with the Template Method, so we will now clarify the difference. We can use the example from the previous section to do this.</p>
<p>We have already used the Template Method to provide an overall template for the execution of the “send” operation in <code>Base::Send()</code>. There are three steps to the operation: open the connection, send the data, and close the connection. Sending data is the step that depends on the actual type of the object (which derived class it really is), and so it is explicitly designated as a customization point. The rest of the template is set in stone.</p>
<p>However we need another kind of customization: the <code>Base</code> class, in general, is not the right place to define how to open and close the connection. Neither is the derived class: the same objects could be sent across different types of connections (sockets, files, shared memory, etc). This is where we can use the Strategy pattern to define communication strategy. The strategy is provided by a separate class:</p>
<pre class="source-code">
// Example 11
class CommunicationStrategy {
  public:
  virtual void Open() = 0;
  virtual void Close() = 0;
  virtual void Send(int v) = 0;
  virtual void Send(long v) = 0;
  virtual void Send(double v) = 0;
  ... Send other types ...
};</pre>
<p>Isn’t it frustrating that template functions cannot be virtual? For a better solution to this problem, you have to wait until <a href="B19262_15.xhtml#_idTextAnchor689"><em class="italic">Chapter 15</em></a>, <em class="italic">Policy-Based Design</em>. Anyway, now that we have the communication strategy, we can use it to parametrize the <code>Send()</code> operation template:</p>
<pre class="source-code">
// Example 11
class Base {
  public:
  void Send(CommunicationStrategy* comm) {
    comm-&gt;Open();
    SendData(comm);
    comm-&gt;Close();
  }
  protected:
  virtual void SendData(CommunicationStrategy* comm) {
    comm-&gt;Send(i_);
    ... send all data ...
  }
  private:
  int i_;
  ... other data members ...
};</pre>
<p>Note that the template for sending the data is basically unchanged, but we delegated the implementation of the specific steps to another class – the strategy. This is the key difference: the Strategy pattern allows us to choose (generally, at runtime) which implementation should be used for a particular operation. The public interface is fixed but the entire implementation is up to the specific strategy. The Template Method pattern enforces the overall implementation flow as well as the public interface. Only the specific steps of the algorithm can be customized.</p>
<p>The second difference is where the customization happens: <code>Base::Send()</code> is customized in two ways. The customizations to the template are done in the derived classes; the implementations of the strategy are provided by the classes outside of the <code>Base</code> hierarchy.</p>
<p>As we pointed out at the beginning of this section, there are good reasons to make all virtual member functions, by default, private (or protected), and they go beyond the applications of the Template Method pattern. However, there is one particular member function – the destructor - that deserves separate consideration because the rules for <a id="_idTextAnchor668"/>destructors are somewhat different.</p>
<h2 id="_idParaDest-256"><a id="_idTextAnchor669"/>A note about destructors</h2>
<p>The entire<a id="_idIndexMarker802"/> discussion of the NVI is an elaboration on<a id="_idIndexMarker803"/> a simple guideline—make virtual functions private (or protected), and present the public interface through non-virtual base class functions. This sounds fine until it runs head-on into another well-known guideline—if the class has at least one virtual function, its destructor must also be made virtual. Since the two are in conflict, some clarification is needed.</p>
<p>The reason to make destructors virtual is that if the object is deleted polymorphically - for example, a derived class object is deleted through a pointer to the base class - the destructor must be virtual; otherwise, only the base part of the class will be destructed (the usual result is the <em class="italic">slicing</em> of the class, partial deletion, although the standard simply states that the results are undefined). So, if the objects are deleted through the base class pointers, the destructors must be virtual; there is no way around it. But that is the only reason. If the objects are always deleted with the correct derived type, then this reason does not apply. This situation is not uncommon: for example, if derived class objects are stored in a container, they will be deleted as their true type.</p>
<p>The container has to know how much memory to allocate for the object, so it can’t store a mix of base and derived objects, or delete them as base objects (note that a container of pointers to the base class object is a different construct altogether, and is usually created specifically so that we can store and delete objects polymorphically).</p>
<p>Now, if the derived class has to be deleted as itself, its destructor does not need to be virtual. However, bad things will still happen if someone calls the destructor of the base class when the actual object is of the derived class type. To safely prevent that from happening, we can declare the non-virtual base class destructor as protected instead of public. Of course, if the base class is not abstract, and there are objects of both base and derived types around, then both destructors must be made public, and the safer option is to make them virtual (a runtime check can be implemented to verify that the base class destructor is not called to destroy a derived class object).</p>
<p>By the way, if polymorphic deletion (deletion through the base class pointer) is the only reason you need to write a destructor in the base class, writing <code>virtual ~Base() = default;</code> is perfectly acceptable – a destructor can be both <code>virtual</code> and <code>default</code> at the same time.</p>
<p>We must also caution the reader against trying to employ the Template Method, or the non-virtual interface idiom, for class destructors. It may be tempting to do <a id="_idIndexMarker804"/>something like this:</p>
<pre class="source-code">
// Example 12
class Base {
  public:
  ~Base() { // Non-virtual interface!
    std::cout &lt;&lt; "Deleting now" &lt;&lt; std::endl;
    clear(); // Employing Template Method here
    std::cout &lt;&lt; "Deleting done" &lt;&lt; std::endl;
  }
  protected:
  virtual void clear() { ... } // Customizable part
};
class Derived : public Base {
  private:
  void clear() override {
    ...
    Base::clear();
  }
};</pre>
<p>However, this is not going to work (if the base class has a pure virtual <code>Base::clear()</code> instead of a default implementation, it is not going to work in a rather spectacular fashion). The reason for this is that, inside the destructor of the base class, <code>Base::~Base()</code>, the actual, real, and true type of the object is not <code>Derived</code> anymore. It’s <code>Base</code>. That’s right—when the <code>Derived::~Derived()</code> destructor is done with its work and the control is transferred to the base class destructor, the dynamic type of the object changes to <code>Base</code>.</p>
<p>The only other class member that works this way is the constructor—the type of the object is <code>Base</code> as long as the base constructor is running, and then changes to <code>Derived</code> when the derived constructor has started. For all other member functions, the type of the object is always the type it was created with. If the object was created as <code>Derived</code>, then that is the type, even if a method of the base class is called. So, what happens if, in the preceding example, <code>Base::clear()</code> is pure virtual? It’s called anyway! The result depends on the compiler; most compilers will generate code that aborts the<a id="_idIndexMarker805"/> program, with <a id="_idIndexMarker806"/>some diagnostic<a id="_idTextAnchor670"/> <a id="_idTextAnchor671"/>that <em class="italic">a pure virtual function </em><em class="italic">was called</em>.</p>
<h1 id="_idParaDest-257"><a id="_idTextAnchor672"/>Drawbacks of the Non-Virtual Interface</h1>
<p>There aren’t many drawbacks regarding the use of the NVI. That is why the guideline to always make virtual functions private, and use the NVI to call them, is widely accepted. However, there are some considerations that you must be aware of when deciding whether the Template Method is the right design pattern to follow. The use of the template pattern may lead to fragile hierarchies. Also, there is some overlap between design problems that can be solved using the template pattern and the ones better served by the strategy pattern, or, in C++, policies. We will rev<a id="_idTextAnchor673"/><a id="_idTextAnchor674"/>iew both considerations in this section.</p>
<h2 id="_idParaDest-258"><a id="_idTextAnchor675"/>Composability</h2>
<p>Consider the<a id="_idIndexMarker807"/> earlier design for <code>LoggingFileWriter</code>. Now, suppose that we want to also have <code>CountingFileWriter</code> that counts how many characters were written into the file:</p>
<pre class="source-code">
class CountingFileWriter : public FileWriter {
  size_t count_ = 0;
  void Preamble(const char* data) {
    count_ += strlen(data);
  }
};</pre>
<p>That was easy. But there is no reason a counting file writer cannot also log. How would we implement a <code>CountingLoggingFileWriter</code>? No problem, we have the technology—change the private virtual functions to protected and call the base class version from the derived class:</p>
<pre class="source-code">
class CountingLoggingFileWriter : public LoggingFileWriter {
  size_t count_ = 0;
  void Preamble(const char* data) {
    count_ += strlen(data);
    LoggingFileWriter::Preamble(data);
  }
};</pre>
<p>Or should it be <code>LoggingCountingFileWriter</code> that inherits from <code>CountingFileWriter</code>? Note that, either way, some code is duplicated—in our case, the counting code is present in both <code>CountingLoggingFileWriter</code> and <code>CountingFileWriter</code>. This duplication is only going to get worse as we add more variations. The <a id="_idIndexMarker808"/>Template Method just isn’t the right pattern if you need composable customizations. For that, you s<a id="_idTextAnchor676"/>h<a id="_idTextAnchor677"/>ould read <a href="B19262_15.xhtml#_idTextAnchor689"><em class="italic">Chapter 15</em></a>, <em class="italic">Policy-Based Design</em>.</p>
<h2 id="_idParaDest-259"><a id="_idTextAnchor678"/>The Fragile Base Class problem</h2>
<p>The Fragile Base Class problem is not limited to the Template Method, but is, to some degree, inherent in all object-oriented languages. The problem arises when changes to the base class break the derived class. To see how this can happen, specifically when using the non-virtual interface, let’s go back to the file writer and add the ability to write many strings at once:</p>
<pre class="source-code">
class FileWriter {
  public:
  void Write(const char* data) {
    Preamble(data);
    ... write data to a file ...
    Postscript(data);
  }
  void Write(std::vector&lt;const char*&gt; huge_data) {
    Preamble(huge_data);
    for (auto data: huge_data) {
      ... write data to file ...
    }
    Postscript(huge_data);
  }
  private:
  virtual void Preamble(std::vector&lt;const char*&gt; data) {}
  virtual void Postscript(std::vector&lt;const char*&gt; data) {}
  virtual void Preamble(const char* data) {}
  virtual void Postscript(const char* data) {}
};</pre>
<p>The counting writer <a id="_idIndexMarker809"/>is kept <a id="_idIndexMarker810"/>up to date with the changes:</p>
<pre class="source-code">
class CountingFileWriter : public FileWriter {
  size_t count_ = 0;
  void Preamble(std::vector&lt;const char*&gt; huge_data) {
    for (auto data: huge_data) count_ += strlen(data);
  }
  void Preamble(const char* data) {
    count_ += strlen(data);
  }
};</pre>
<p>So far, so good. Later, a well-intentioned programmer notices that the base class suffers from some code duplication and decides to refactor it:</p>
<pre class="source-code">
class FileWriter {
  public:
  void Write(const char* data) { ... no changes here ... }
  void Write(std::vector&lt;const char*&gt; huge_data) {
    Preamble(huge_data);
    for (auto data: huge_data) Write(data); // Code reuse!
    Postscript(huge_data);
  }
  private:
  ... no changes here ...
};</pre>
<p>Now, the derived<a id="_idIndexMarker811"/> class is <a id="_idIndexMarker812"/>broken—the counting customizations of both versions of <code>Write</code> are called when a vector of strings is written, and the data size is counted twice. Note that we are not talking about the more basic kind of fragility where an override method in a derived class can stop being an override if the signature of the base class method is changed: this kind of fragility is largely avoided by the proper use of the <code>override</code> keyword as recommended in <a href="B19262_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">An Introduction to Inheritance </em><em class="italic">and Polymorphism</em>.</p>
<p>While there is no general solution to the Fragile Base Class problem as long as inheritance is used at all, the guideline that helps to avoid it when using the Template Method is straightforward—when changing the base class and the structure of the algorithms, or the framework, avoid changing which customization points are invoked. Specifically, do not skip any customization options that were already invoked, and do not add new calls to already existing ones (it’s OK to add new customization points, as long as the default implementation is sensible). If such a change cannot be avoided, you will need to review every derived class to see whether it relied on the implementation override that is now removed or replaced, <a id="_idTextAnchor679"/>and what the consequences of such a change are.</p>
<h2 id="_idParaDest-260"><a id="_idTextAnchor680"/>A cautionary note about template customization points</h2>
<p>This brief <a id="_idIndexMarker813"/>section is not a <a id="_idIndexMarker814"/>drawback of the Template Method, but rather a warning about a somewhat arcane corner of C++. Many of the design patterns that were originally developed as run-time behaviors (object-oriented patterns) found their compile-time analogs in C++ generic programming.  So, is there a compile-time template method?</p>
<p>Of course, there is an obvious one: we can have a function or a class template that accepts function parameters, or, more generally, callable parameters, for a certain step of the otherwise fixed algorithm. The standard library has a plethora of examples, such as <code>std::find_if</code>:</p>
<pre class="source-code">
std::vector&lt;int&gt; v = ... some data ...
auto it = std::find_if(v.begin(), v.end(),
                       [](int i) { return i &amp; 1; });
if (it != v.end()) { ... } // even value found</pre>
<p>The algorithm of <code>std::find_if</code> is known and cannot be altered, except for the step where it checks whether a particular value satisfies the caller’s predicate.</p>
<p>If we want to do the same for class hierarchies, we can use member function pointers (although it is easier to invoke member functions through lambdas), but there is no way to say “<em class="italic">call a member function with the same name but on a different class</em>” except by using virtual functions and their overrides. There is no equivalent to that in generic programming.</p>
<p>Unfortunately, there is a case where a template can be customized by accident, usually with unintended results. Consider this example:</p>
<pre class="source-code">
// Example 15
void f() { ... }
template &lt;typename T&gt; struct A {
  void f() const { ... }
};
template &lt;typename T&gt; struct B : public A&lt;T&gt; {
  void h() { f(); }
};
B&lt;int&gt; b;
b.h();</pre>
<p>Which function <code>f()</code> is called from inside <code>B&lt;T&gt;::h()</code>? On a standard-compliant compiler, it should be the free-standing function, i.e. <code>::f()</code>, and not the member function of the base class! This may come as a surprise: if <code>A</code> and <code>B</code> were non-template classes, the base class method <code>A::f()</code> would have been called. This behavior arises from the complexities of parsing templates in C++ (if you want to learn more about this, <code>two-phase template parse</code> or <code>two-stage name lookup</code> are the terms to search for, but the matter is far outside the subject of this book).</p>
<p>What would have <a id="_idIndexMarker815"/>happened <a id="_idIndexMarker816"/>if the global function <code>f()</code> was not available in the first place? Then we have to call the one in the base class, don’t we?</p>
<pre class="source-code">
// Example 15
// No f() here!
template &lt;typename T&gt; struct A {
  void f() const { ... }
};
template &lt;typename T&gt; struct B : public A&lt;T&gt; {
  void h() { f(); } // Should not compile!
};
B&lt;int&gt; b;
b.h();</pre>
<p>If you tried this code and it has called <code>A&lt;T&gt;::f()</code>, then you have a buggy compiler: the standard says that this should not compile at all! But what should you do if you want to call a member function of your own base class? The answer is very simple but looks strange if you haven’t written a lot of template code:</p>
<pre class="source-code">
// Example 15
template &lt;typename T&gt; struct A {
  void f() const { ... }
};
template &lt;typename T&gt; struct B : public A&lt;T&gt; {
  void h() { this-&gt;f(); } // Definitely A::f()
};
B&lt;int&gt; b;
b.h();</pre>
<p>That’s right, you have to explicitly call <code>this-&gt;f()</code> to ensure that you’re calling a member function. If you do this, <code>A&lt;T&gt;::f()</code> gets called whether or not there is a global <code>f()</code> declared. By the way, if you intended to call the global function, the way to do this unambiguously is <code>::f()</code>, or, if the function is in a namespace <code>NS</code>, <code>NS::f()</code>.</p>
<p>The compilation error where the compiler cannot find a member function that is clearly present in the base class is one of the more confusing C++ errors; it is even worse if the compiler does not issue this error and compiles the code “as intended” instead: if someone adds a global function with the same name later (or it is declared in another header you include), the compiler will switch to that function with no warning. The general guideline is to always qualify member function calls in a class template with <code>this-&gt;</code>.</p>
<p>Overall, the Template Method is one of the few patterns that remain purely object-oriented in C++: the template form we saw employed by <code>std::find_if</code> (and many more templates) usually<a id="_idIndexMarker817"/> falls <a id="_idIndexMarker818"/>under the general umbrella of Policy-Based de<a id="_idTextAnchor681"/>signs that we’re going to study in the next chapter.</p>
<h1 id="_idParaDest-261"><a id="_idTextAnchor682"/>Summary</h1>
<p>In this chapter, we have reviewed a classic object-oriented design pattern, the Template Method, as it applies to C++ programs. This pattern works in C++ as well as in any other object-oriented language, but C++ also has its own flavor of the Template Method—the non-virtual interface idiom. The advantages of this design pattern lead to a rather broad guideline—make all virtual functions private or protected. Be mindful, however, of the specifics of the destructors with regard to polymorphism. Here are the general guidelines for access (public vs private) to virtual functions:</p>
<ol>
<li>Prefer to make interfaces nonvirtual, using the Template Method design pattern</li>
<li>Prefer to make virtual functions private</li>
<li>Only if derived classes need to invoke the base implementation of a virtual function, make the virtual function protected.</li>
<li>A base class destructor should be either public and virtual (if objects are deleted through the base class pointer) or protected and n<a id="_idTextAnchor683"/>onvirtual (if derived objects are deleted directly).</li>
</ol>
<p>We already mentioned the Strategy pattern in this chapter by way of clarifying how it differs from the Template Method pattern. Strategy is also a popular pattern in C++, in particular, its generic programming equivalent. <a id="_idTextAnchor684"/>This is going to be the subject of the next chapter.</p>
<h1 id="_idParaDest-262"><a id="_idTextAnchor685"/>Questions</h1>
<ol>
<li>What is a behavioral design pattern?</li>
<li>What is the Template Method pattern?</li>
<li>Why is the Template Method considered a behavioral pattern?</li>
<li>What is the inversion of control, and how does it apply to the Template Method?</li>
<li>What is the non-virtual interface?</li>
<li>Why is it recommended to make all virtual functions in C++ private?</li>
<li>When should virtual functions be protected?</li>
<li>Why can’t the Template Method be used for destructors?</li>
<li>What is the Fragile Base class problem, and how<a id="_idTextAnchor686"/><a id="_idTextAnchor687"/> can we avoid it when employing the Template Method?</li>
</ol>
</div>


<div><h1 id="_idParaDest-263"><a id="_idTextAnchor688"/>Part 4: Advanced C++ Design Patterns</h1>
<p>This part continues with the description and detailed explanation of C++ design patterns, moving on to the more advanced patterns. Some of these patterns use advanced features of the C++ language. Others represent complex concepts and address more difficult design problems. Yet other patterns implement very open-ended designs, where part of the solution can be factored out into a commonly accepted pattern, but the entire system must be customizable within very wide limits.</p>
<p>This part has the following chapters:</p>
<ul>
<li><a href="B19262_15.xhtml#_idTextAnchor689"><em class="italic">Chapter 15</em></a>, <em class="italic">Policy-Based Design</em></li>
<li><a href="B19262_16.xhtml#_idTextAnchor739"><em class="italic">Chapter 16</em></a>, <em class="italic">Adapters and Decorators</em></li>
<li><a href="B19262_17.xhtml#_idTextAnchor783"><em class="italic">Chapter 17</em></a>, <em class="italic">The Visitor Pattern and Multiple Dispatch</em></li>
<li><a href="B19262_18.xhtml#_idTextAnchor832"><em class="italic">Chapter 18</em></a>, <em class="italic">Patterns for Concurrency</em></li>
</ul>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
</body></html>