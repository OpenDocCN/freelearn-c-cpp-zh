<html><head></head><body>
<div id="_idContainer030">
<h1 class="chapter-number" id="_idParaDest-245"><a id="_idTextAnchor640"/><span class="koboSpan" id="kobo.1.1">14</span></h1>
<h1 id="_idParaDest-246"><a id="_idTextAnchor641"/><span class="koboSpan" id="kobo.2.1">The Template Method Pattern and the Non-Virtual Idiom</span><a id="_idTextAnchor642"/></h1>
<p><span class="koboSpan" id="kobo.3.1">The Template Method is one of the classic </span><em class="italic"><span class="koboSpan" id="kobo.4.1">Gang of Four</span></em><span class="koboSpan" id="kobo.5.1"> design patterns, or, more formally, one of the 24 patterns described in the book </span><em class="italic"><span class="koboSpan" id="kobo.6.1">Design Patterns – Elements of Reusable Object-Oriented Software</span></em><span class="koboSpan" id="kobo.7.1"> by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. </span><span class="koboSpan" id="kobo.7.2">It is a behavioral design pattern, meaning that it describes a way for communicating between different objects. </span><span class="koboSpan" id="kobo.7.3">As an object-oriented language, C++, of course, fully supports the Template Method pattern, although there are some implementation details that are specific or unique to C++ that this chapter </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">will elucidate.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">The following topics will be covered in </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.11.1">What is the Template Method pattern, and what problems does </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">it solve?</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">What is the </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">non-virtual interface?</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Should you make virtual functions public, private, or protected </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">by default?</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Should you always make destructors virtual and public in </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">polymorphic classes?</span></span><a id="_idTextAnchor643"/></li>
</ul>
<h1 id="_idParaDest-247"><a id="_idTextAnchor644"/><span class="koboSpan" id="kobo.19.1">Technical requirements</span></h1>
<p><a id="_idTextAnchor645"/><span class="koboSpan" id="kobo.20.1">The example code for this chapter can be found at the following GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">link: </span></span><a href="https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter14"><span class="No-Break"><span class="koboSpan" id="kobo.22.1">https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter14</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.23.1">.</span></span><a id="_idTextAnchor646"/></p>
<h1 id="_idParaDest-248"><a id="_idTextAnchor647"/><span class="koboSpan" id="kobo.24.1">The Template Method pattern</span></h1>
<p><span class="koboSpan" id="kobo.25.1">The Template Method </span><a id="_idIndexMarker766"/><span class="koboSpan" id="kobo.26.1">pattern is a common way to implement an algorithm whose overall structure is pre-determined, but some of the details of the implementation need to be customized. </span><span class="koboSpan" id="kobo.26.2">If you are thinking about a solution that goes something like this—first, we do </span><em class="italic"><span class="koboSpan" id="kobo.27.1">X</span></em><span class="koboSpan" id="kobo.28.1">, then </span><em class="italic"><span class="koboSpan" id="kobo.29.1">Y</span></em><span class="koboSpan" id="kobo.30.1">, and then </span><em class="italic"><span class="koboSpan" id="kobo.31.1">Z</span></em><span class="koboSpan" id="kobo.32.1">, but how exactly we do </span><em class="italic"><span class="koboSpan" id="kobo.33.1">Y</span></em><span class="koboSpan" id="kobo.34.1"> depends on the data we process—you are thinking about the Template Method. </span><span class="koboSpan" id="kobo.34.2">As a pattern that allows the behavior of a program to change dynamically, the Template Method is somewhat similar to the strategy pattern. </span><span class="koboSpan" id="kobo.34.3">The key difference is that the strategy pattern changes the entire algorithm at runtime, while the Template Method lets </span><a id="_idIndexMarker767"/><span class="koboSpan" id="kobo.35.1">us customize specific parts of the algorithm. </span><span class="koboSpan" id="kobo.35.2">This section deals with the latter, while we have a separate </span><a href="B19262_16.xhtml#_idTextAnchor739"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.36.1">Chapter 16</span></em></span></a><span class="koboSpan" id="kobo.37.1">, </span><em class="italic"><span class="koboSpan" id="kobo.38.1">Policy-Based Design</span></em><span class="koboSpan" id="kobo.39.1">, dedicated to </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">the forme</span><a id="_idTextAnchor648"/><span class="koboSpan" id="kobo.41.1">r</span><a id="_idTextAnchor649"/><span class="koboSpan" id="kobo.42.1">.</span></span></p>
<h2 id="_idParaDest-249"><a id="_idTextAnchor650"/><span class="koboSpan" id="kobo.43.1">The Template Method in C++</span></h2>
<p><span class="koboSpan" id="kobo.44.1">The Template Method pattern is easily implemented in any object-oriented language. </span><span class="koboSpan" id="kobo.44.2">The C++ implementation uses inheritance and virtual functions. </span><span class="koboSpan" id="kobo.44.3">Note that this has nothing to do with C++ templates, as in generic programming. </span><span class="koboSpan" id="kobo.44.4">The </span><em class="italic"><span class="koboSpan" id="kobo.45.1">template</span></em><span class="koboSpan" id="kobo.46.1"> here is the skeleton implementation of </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">the algorithm:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.48.1">
// Example 01
class Base {
  public:
  bool TheAlgorithm() {
    if (!Step1()) return false; // Step 1 failed
    Step2();
    return true;
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.49.1">The </span><em class="italic"><span class="koboSpan" id="kobo.50.1">template</span></em><span class="koboSpan" id="kobo.51.1"> here is the structure of the algorithm—all implementations must first do </span><em class="italic"><span class="koboSpan" id="kobo.52.1">step 1</span></em><span class="koboSpan" id="kobo.53.1">, which may fail. </span><span class="koboSpan" id="kobo.53.2">If this happens, the entire algorithm is considered to have failed, and nothing more is done. </span><span class="koboSpan" id="kobo.53.3">If </span><em class="italic"><span class="koboSpan" id="kobo.54.1">step 1</span></em><span class="koboSpan" id="kobo.55.1"> succeeded, we must do </span><em class="italic"><span class="koboSpan" id="kobo.56.1">step 2</span></em><span class="koboSpan" id="kobo.57.1">. </span><span class="koboSpan" id="kobo.57.2">By design, </span><em class="italic"><span class="koboSpan" id="kobo.58.1">step 2</span></em><span class="koboSpan" id="kobo.59.1"> cannot fail, and the overall algorithm computation is considered a success once </span><em class="italic"><span class="koboSpan" id="kobo.60.1">step 2</span></em> <span class="No-Break"><span class="koboSpan" id="kobo.61.1">is completed.</span></span></p>
<p><span class="koboSpan" id="kobo.62.1">Note that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.63.1">TheAlgorithm()</span></strong><span class="koboSpan" id="kobo.64.1"> method is public but not virtual—any class derived from </span><strong class="source-inline"><span class="koboSpan" id="kobo.65.1">Base</span></strong><span class="koboSpan" id="kobo.66.1"> has it as a part of its interface but cannot override what it does. </span><span class="koboSpan" id="kobo.66.2">What the derived classes can override are the implementations of </span><em class="italic"><span class="koboSpan" id="kobo.67.1">step 1</span></em><span class="koboSpan" id="kobo.68.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.69.1">step 2</span></em><span class="koboSpan" id="kobo.70.1">, within the restrictions of the algorithm template – </span><em class="italic"><span class="koboSpan" id="kobo.71.1">step 1</span></em><span class="koboSpan" id="kobo.72.1"> may fail and must signal the failure by returning </span><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">false</span></strong><span class="koboSpan" id="kobo.74.1">, while </span><em class="italic"><span class="koboSpan" id="kobo.75.1">step 2</span></em><span class="koboSpan" id="kobo.76.1"> may </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">not fail:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.78.1">
// Example 01
class Base {
  public:
  ...
</span><span class="koboSpan" id="kobo.78.2">  virtual bool Step1() { return true };
  virtual void Step2() = 0;
};
class Derived1 : public Base {
  public:
  void Step2() override { ... </span><span class="koboSpan" id="kobo.78.3">do the work ... </span><span class="koboSpan" id="kobo.78.4">}
};
class Derived2 : public Base {
  public:
  bool Step1() override { ... </span><span class="koboSpan" id="kobo.78.5">check preconditions ... </span><span class="koboSpan" id="kobo.78.6">}
  void Step2() override { ... </span><span class="koboSpan" id="kobo.78.7">do the work ... </span><span class="koboSpan" id="kobo.78.8">}
};</span></pre>
<p><span class="koboSpan" id="kobo.79.1">In the preceding</span><a id="_idIndexMarker768"/><span class="koboSpan" id="kobo.80.1"> example, overriding</span><a id="_idIndexMarker769"/><span class="koboSpan" id="kobo.81.1"> the potentially failing </span><em class="italic"><span class="koboSpan" id="kobo.82.1">step 1</span></em><span class="koboSpan" id="kobo.83.1"> is optional, and the default implementation is trivial; it does nothing and never fails. </span><em class="italic"><span class="koboSpan" id="kobo.84.1">Step 2</span></em><span class="koboSpan" id="kobo.85.1"> must be implemented by every derived class—there is no default, and it is declared as a pure </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">virtual function.</span></span></p>
<p><span class="koboSpan" id="kobo.87.1">You can see that the overall flow of control—the framework—remains invariant, but it has </span><em class="italic"><span class="koboSpan" id="kobo.88.1">placeholders</span></em><span class="koboSpan" id="kobo.89.1"> for customizable options, possibly with a default offered by the framework itself. </span><span class="koboSpan" id="kobo.89.2">Such a flow is known as the inversion of control. </span><span class="koboSpan" id="kobo.89.3">In a traditional control flow, its specific implementation determines the flow of computation and sequence of operations and makes calls to library functions or other lower-level functions to implement the necessary general algorithms. </span><span class="koboSpan" id="kobo.89.4">In the Template Method, it is the framework that calls specific implementations in the </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">custom c</span><a id="_idTextAnchor651"/><span class="koboSpan" id="kobo.91.1">o</span><a id="_idTextAnchor652"/><span class="koboSpan" id="kobo.92.1">de.</span></span></p>
<h2 id="_idParaDest-250"><a id="_idTextAnchor653"/><span class="koboSpan" id="kobo.93.1">Applications of the Template Method</span></h2>
<p><span class="koboSpan" id="kobo.94.1">There are many</span><a id="_idIndexMarker770"/><span class="koboSpan" id="kobo.95.1"> reasons to use the Template Method. </span><span class="koboSpan" id="kobo.95.2">In general, it is used to control what can and cannot be sub-classed—as opposed to a general polymorphic override, where the entire virtual function can be replaced, the base class here determines what can and cannot be overridden. </span><span class="koboSpan" id="kobo.95.3">Another common use of the Template Method is to avoid code duplication, and in this context, you can arrive at the use of the Template Method as follows. </span><span class="koboSpan" id="kobo.95.4">Suppose that you start with the regular polymorphism—a virtual function—and it overrides. </span><span class="koboSpan" id="kobo.95.5">For example, let’s consider this toy design for a turn-based combat system for </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">a game:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.97.1">
// Example 02
class Character {
  public:
  virtual void CombatTurn() = 0;
  protected:
  int health_;
};
class Swordsman : public Character {
  bool wielded_sword_;
  public:
  void CombatTurn() override {
    if (health_ &lt; 5) { // Critically injured
      Flee();
      return;
    }
    if (!wielded_sword_) {
      Wield();
      return; // Wielding takes a full turn
    }
    Attack();
  }
};
class Wizard : public Character {
  int mana_;
  bool scroll_ready_;
  public:
  void CombatTurn() override {
    if (health_ &lt; 2 ||
        mana_ == 0) { // Critically injured or out of mana
      Flee();
      return;
    }
    if (!scroll_ready_) {
      ReadScroll();
      return; // Reading takes a full turn
    }
    CastSpell();
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.98.1">Note how this code is </span><a id="_idIndexMarker771"/><span class="koboSpan" id="kobo.99.1">highly repetitive—all characters may be forced to disengage from combat on their turn, then they must take a turn to get ready for combat, and only then, if they are ready and strong enough, can they use their offensive capabilities. </span><span class="koboSpan" id="kobo.99.2">If you see this pattern repeating over and over, it is a strong hint that the Template Method may be called for. </span><span class="koboSpan" id="kobo.99.3">With the Template Method, the overall sequence of the combat turn is fixed, but how each character advances to the next step and what he/she does once he/she gets there </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">remains character-specific:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.101.1">
// Example 03
class Character {
  public:
  void CombatTurn() {
    if (MustFlee()) {
      Flee();
      return;
    }
    if (!Ready()) {
      GetReady();
      return; // Getting ready takes a full turn
    }
    CombatAction();
  }
  virtual bool MustFlee() const = 0;
  virtual bool Ready() const = 0;
  virtual void GetReady() = 0;
  virtual void CombatAction() = 0;
  protected:
  int health_;
};</span></pre>
<p><span class="koboSpan" id="kobo.102.1">Now each derived </span><a id="_idIndexMarker772"/><span class="koboSpan" id="kobo.103.1">class must implement only the part of the code that is unique to </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">this class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.105.1">
// Example 03
class Swordsman : public Character {
  bool wielded_sword_;
  public:
  bool MustFlee() const override { return health_ &lt; 5; }
  bool Ready() const override { return wielded_sword_; }
  void GetReady()override { Wield(); }
  void CombatAction()override { Attack(); }
};
class Wizard : public Character {
  int mana_;
  bool scroll_ready_;
  public:
  bool MustFlee() const override { return health_ &lt; 2 ||
                                          mana_ == 0; }
  bool Ready() const override { return scroll_ready_; }
  void GetReady() override { ReadScroll(); }
  void CombatAction() override { CastSpell(); }
};</span></pre>
<p><span class="koboSpan" id="kobo.106.1">Note how this code is</span><a id="_idIndexMarker773"/><span class="koboSpan" id="kobo.107.1"> much less repetitive. </span><span class="koboSpan" id="kobo.107.2">The advantage of the Template Method goes beyond good looks, though. </span><span class="koboSpan" id="kobo.107.3">Let’s say that in the next revision of the game, we have added healing potions, and at the beginning of the turn, each character may drink a potion. </span><span class="koboSpan" id="kobo.107.4">Now, imagine going through every derived class and adding code like </span><strong class="source-inline"><span class="koboSpan" id="kobo.108.1">if (health_ &lt; ... </span><span class="koboSpan" id="kobo.108.2">some class-specific value ... </span><span class="koboSpan" id="kobo.108.3">&amp;&amp; potion_count_ &gt; 0) ...</span></strong><span class="koboSpan" id="kobo.109.1">. </span><span class="koboSpan" id="kobo.109.2">If the design already used the Template Method, the logic of potion-quaffing needs to be coded only once, and different classes implement their specific conditions for using a potion, as well as the consequences of drinking one. </span><span class="koboSpan" id="kobo.109.3">However, don’t rush to implement this solution until you get to the end of this chapter, as this is not the best C++ code you</span><a id="_idTextAnchor654"/> <a id="_idTextAnchor655"/><span class="No-Break"><span class="koboSpan" id="kobo.110.1">can do.</span></span></p>
<h2 id="_idParaDest-251"><a id="_idTextAnchor656"/><span class="koboSpan" id="kobo.111.1">Pre-and post-conditions and actions</span></h2>
<p><span class="koboSpan" id="kobo.112.1">Another </span><a id="_idIndexMarker774"/><span class="koboSpan" id="kobo.113.1">common use of the Template Method </span><a id="_idIndexMarker775"/><span class="koboSpan" id="kobo.114.1">is dealing with pre-and post-conditions or actions. </span><span class="koboSpan" id="kobo.114.2">In a class hierarchy, pre- and post-conditions generally verify that the design invariants of an abstraction provided by an interface are not violated by any specific implementation at any point during execution. </span><span class="koboSpan" id="kobo.114.3">Such verification naturally submits to the Template </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">Method’s design:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.116.1">
// Example 04
class Base {
  public:
  void VerifiedAction() {
    assert(StateIsValid());
    ActionImpl();
    assert(StateIsValid());
  }
  virtual void ActionImpl() = 0;
};
class Derived : public Base {
  public:
  void ActionImpl() override { ... </span><span class="koboSpan" id="kobo.116.2">real implementation ...}
};</span></pre>
<p><span class="koboSpan" id="kobo.117.1">The invariants are the requirements that the object must satisfy when it’s accessible to the client, i.e., before any member function is called on it or after it returns. </span><span class="koboSpan" id="kobo.117.2">The member functions themselves often have to temporarily break the invariants, but they must restore the correct state of the class before returning control to the caller. </span><span class="koboSpan" id="kobo.117.3">Let us say that our classes from the preceding example keep track of how many actions have been executed. </span><span class="koboSpan" id="kobo.117.4">Each action is registered when it starts and again when it’s done, and the two counts must be the same: once an action is initiated, it has to complete before control is returned to the caller. </span><span class="koboSpan" id="kobo.117.5">Of course, inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">ActionImpl()</span></strong><span class="koboSpan" id="kobo.119.1"> member function this invariant is violated since an action is </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">in progress:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.121.1">
// Example 04
class Base {
  bool StateIsValid() const {
    return actions_started_ == actions_completed_;
  }
  protected:
  size_t actions_started_ = 0;
  size_t actions_completed_ = 0;
  public:
  void VerifiedAction() {
    assert(StateIsValid());
    ActionImpl();
    assert(StateIsValid());
  }
  virtual void ActionImpl() = 0;
};
class Derived : public Base {
  public:
  void ActionImpl() override {
    ++actions_started_;
    ... </span><span class="koboSpan" id="kobo.121.2">perform the action ...
</span><span class="koboSpan" id="kobo.121.3">    ++actions_completed_;
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.122.1">Of course, any </span><a id="_idIndexMarker776"/><span class="koboSpan" id="kobo.123.1">practical</span><a id="_idIndexMarker777"/><span class="koboSpan" id="kobo.124.1"> implementation of pre- and post-conditions must take into account several additional factors. </span><span class="koboSpan" id="kobo.124.2">First, some member functions may have additional invariants, i.e., they can be called only when the object is in a restricted state. </span><span class="koboSpan" id="kobo.124.3">Such functions would have specific pre-conditions to test. </span><span class="koboSpan" id="kobo.124.4">Second, we have not considered the possibility that an action is aborted due to an error (this may or may not involve throwing an exception). </span><span class="koboSpan" id="kobo.124.5">A well-designed implementation of error handling must guarantee that the class invariants are not violated after such an error. </span><span class="koboSpan" id="kobo.124.6">In our case, a failed action may be ignored altogether (in which case, we need to decrement the count of started actions) or our invariant may have to be more complex: all started actions must</span><a id="_idIndexMarker778"/><span class="koboSpan" id="kobo.125.1"> end </span><a id="_idIndexMarker779"/><span class="koboSpan" id="kobo.126.1">up as completed or failed, and we need to </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">count both:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.128.1">
// Example 05
class Base {
  bool StateIsValid() const {
    return actions_started_ ==
      actions_completed_ + actions_failed_;
  }
  protected:
  size_t actions_started_ = 0;
  size_t actions_completed_ = 0;
  size_t actions_failed_ = 0;
  ...
</span><span class="koboSpan" id="kobo.128.2">};
class Derived : public Base {
  public:
  void ActionImpl() override {
    ++actions_started_;
    try {
      ... </span><span class="koboSpan" id="kobo.128.3">perform the action – may throw ...
</span><span class="koboSpan" id="kobo.128.4">      ++actions_completed_;
    } catch (...) {
      ++actions_failed_;
    }
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.129.1">In a real program, you must ensure that a failed transaction isn’t just counted correctly but is handled correctly too (often, it must be undone). </span><span class="koboSpan" id="kobo.129.2">We have discussed it in great detail in </span><a href="B19262_05.xhtml#_idTextAnchor199"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.130.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.131.1">, </span><em class="italic"><span class="koboSpan" id="kobo.132.1">A Comprehensive Look at RAII</span></em><span class="koboSpan" id="kobo.133.1">, and again in </span><a href="B19262_11.xhtml#_idTextAnchor509"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.134.1">Chapter 11</span></em></span></a><span class="koboSpan" id="kobo.135.1">, </span><em class="italic"><span class="koboSpan" id="kobo.136.1">ScopeGuard</span></em><span class="koboSpan" id="kobo.137.1">. </span><span class="koboSpan" id="kobo.137.2">Finally, in a concurrent program, it is no longer true that an object cannot be observed while a member function is being executed, and the entire subject of class invariants becomes much more complex and intertwined with </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">thread-safety guarantees.</span></span></p>
<p><span class="koboSpan" id="kobo.139.1">Of course, in software design, one man’s invariants are another’s customization points. </span><span class="koboSpan" id="kobo.139.2">Sometimes, it is the main code that remains the same, but what happens right before and right after depends on the specific application. </span><span class="koboSpan" id="kobo.139.3">In this case, we probably wouldn’t be </span><a id="_idIndexMarker780"/><span class="koboSpan" id="kobo.140.1">verifying</span><a id="_idIndexMarker781"/><span class="koboSpan" id="kobo.141.1"> any invariants, but instead executing initial and </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">final actions:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.143.1">
// Example 06
class FileWriter {
  public:
  void Write(const char* data) {
    Preamble(data);
    ... </span><span class="koboSpan" id="kobo.143.2">write data to a file ...
</span><span class="koboSpan" id="kobo.143.3">    Postscript(data);
  }
  virtual void Preamble(const char* data) {}
  virtual void Postscript(const char* data) {}
};
class LoggingFileWriter : public FileWriter {
  public:
  using FileWriter::FileWriter;
  void Preamble(const char* data) override {
    std::cout &lt;&lt; "Writing " &lt;&lt; data &lt;&lt; " to the file" &lt;&lt;
      std::endl;
  }
  void Postscript (const char*) override {
    std::cout &lt;&lt; "Writing done" &lt;&lt; s</span><a id="_idTextAnchor657"/><span class="koboSpan" id="kobo.144.1">t</span><a id="_idTextAnchor658"/><span class="koboSpan" id="kobo.145.1">d::endl;
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.146.1">There is, of course, no reason why pre- and post-conditions cannot be combined with opening and closing actions – the base class can have several “standard” member function calls before </span><a id="_idIndexMarker782"/><span class="koboSpan" id="kobo.147.1">and</span><a id="_idIndexMarker783"/><span class="koboSpan" id="kobo.148.1"> after the </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">primary implementation.</span></span></p>
<p><span class="koboSpan" id="kobo.150.1">While this code gets the job done, it still has some deficiencies that we are about </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">to expose.</span></span></p>
<h1 id="_idParaDest-252"><a id="_idTextAnchor659"/><span class="koboSpan" id="kobo.152.1">The Non-Virtual Interface</span></h1>
<p><span class="koboSpan" id="kobo.153.1">The implementation of the dynamically customizable parts of the templated algorithm is usually done with virtual functions. </span><span class="koboSpan" id="kobo.153.2">For a general Template Method pattern, this is not a requirement, but in C++, we rarely need another way. </span><span class="koboSpan" id="kobo.153.3">Now, we are going to focus specifically on using the virtual functions and improving on wha</span><a id="_idTextAnchor660"/><span class="koboSpan" id="kobo.154.1">t</span><a id="_idTextAnchor661"/><span class="koboSpan" id="kobo.155.1"> we </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">have learned.</span></span></p>
<h2 id="_idParaDest-253"><a id="_idTextAnchor662"/><span class="koboSpan" id="kobo.157.1">Virtual functions and access</span></h2>
<p><span class="koboSpan" id="kobo.158.1">Let’s start with </span><a id="_idIndexMarker784"/><span class="koboSpan" id="kobo.159.1">a </span><a id="_idIndexMarker785"/><span class="koboSpan" id="kobo.160.1">general question—should virtual functions be public or private? </span><span class="koboSpan" id="kobo.160.2">The textbook object-oriented design style uses public virtual functions, so we often make them public without a second thought. </span><span class="koboSpan" id="kobo.160.3">Within the Template Method, this practice needs to be reevaluated—a public function is part of the class interface. </span><span class="koboSpan" id="kobo.160.4">In our case, the class interface includes the entire algorithm, and the framework we put in place in the base class. </span><span class="koboSpan" id="kobo.160.5">This function should be public, but it is also non-virtual. </span><span class="koboSpan" id="kobo.160.6">The customized implementations of some parts of the algorithm were never meant to be called directly by the clients of the class hierarchy. </span><span class="koboSpan" id="kobo.160.7">They are used in one place only—in the non-virtual public function, where they replace the placeholders we put in the template of </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">the algorithm.</span></span></p>
<p><span class="koboSpan" id="kobo.162.1">This idea may seem trivial, but it comes as a surprise to many programmers. </span><span class="koboSpan" id="kobo.162.2">I’ve had this question asked more than once—</span><em class="italic"><span class="koboSpan" id="kobo.163.1">does C++ even allow virtual functions to be anything other than public?</span></em><span class="koboSpan" id="kobo.164.1"> In fact, the language itself makes no restrictions on access to virtual functions; they can be private, protected, or public, just like any other class member functions. </span><span class="koboSpan" id="kobo.164.2">This can take some time to wrap </span><a id="_idIndexMarker786"/><span class="koboSpan" id="kobo.165.1">your mind around; perhaps an example </span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">would help:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.167.1">
// Example 07
class Base {
  public:
  void method1() { method2(); method3(); }
  virtual void method2() { ... </span><span class="koboSpan" id="kobo.167.2">}
  private:
  virtual void method3() { ... </span><span class="koboSpan" id="kobo.167.3">}
};
class Derived : public Base {
  private:
  void method2() override { ... </span><span class="koboSpan" id="kobo.167.4">}
  void method3() override { ... </span><span class="koboSpan" id="kobo.167.5">}
};</span></pre>
<p><span class="koboSpan" id="kobo.168.1">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">Derived::method2()</span></strong><span class="koboSpan" id="kobo.170.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">Derived::method3()</span></strong><span class="koboSpan" id="kobo.172.1">are both private. </span><span class="koboSpan" id="kobo.172.2">Can the base class even call private methods of its derived classes? </span><span class="koboSpan" id="kobo.172.3">The answer is, it doesn’t have to—</span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">Base::method1()</span></strong><span class="koboSpan" id="kobo.174.1"> only calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">Base::method2()</span></strong><span class="koboSpan" id="kobo.176.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">Base::method3()</span></strong><span class="koboSpan" id="kobo.178.1"> which are its own member functions (public and private, respectively); there is no problem with calling private member functions of the same class. </span><span class="koboSpan" id="kobo.178.2">But if the actual class type is </span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">Derived</span></strong><span class="koboSpan" id="kobo.180.1">, the virtual override of </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">method2()</span></strong><span class="koboSpan" id="kobo.182.1"> is called at runtime instead. </span><span class="koboSpan" id="kobo.182.2">These two decisions, </span><em class="italic"><span class="koboSpan" id="kobo.183.1">can I call</span></em> <strong class="source-inline"><span class="koboSpan" id="kobo.184.1">method2()</span></strong><em class="italic"><span class="koboSpan" id="kobo.185.1">?</span></em><span class="koboSpan" id="kobo.186.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.187.1">which</span></em> <strong class="source-inline"><span class="koboSpan" id="kobo.188.1">method2()</span></strong><em class="italic"><span class="koboSpan" id="kobo.189.1">?</span></em><span class="koboSpan" id="kobo.190.1">, happen at totally different times—the former happens when the module containing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">Base</span></strong><span class="koboSpan" id="kobo.192.1"> class is compiled (and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">Derived</span></strong><span class="koboSpan" id="kobo.194.1"> class may not have even been written yet), while the latter happens when the program is executed (and the words </span><em class="italic"><span class="koboSpan" id="kobo.195.1">private</span></em><span class="koboSpan" id="kobo.196.1"> or </span><em class="italic"><span class="koboSpan" id="kobo.197.1">public</span></em><span class="koboSpan" id="kobo.198.1"> don’t mean anything at that point). </span><span class="koboSpan" id="kobo.198.2">Also note that, as shown by </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">method3()</span></strong><span class="koboSpan" id="kobo.200.1"> in the preceding example, a virtual function and its override can have different access. </span><span class="koboSpan" id="kobo.200.2">Again, the function invoked at compile time (</span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">Base::method3()</span></strong><span class="koboSpan" id="kobo.202.1"> in our case) must be accessible at the point of the call; the override that ends up executed at runtime doesn’t have to be (however, if we were to call </span><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">Derived::method3()</span></strong><span class="koboSpan" id="kobo.204.1"> directly outside of the class itself, we would be trying to call a private method of </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">that class).</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.206.1">
// Example 07
Derived* d = new Derived;
Base* b = d;
b-&gt;method2();    // OK, calls Derived::method2()
d-&gt;method2();    // Does not compile – private function</span></pre>
<p><span class="koboSpan" id="kobo.207.1">There is another, more fundamental reason, to avoid public virtual functions. </span><span class="koboSpan" id="kobo.207.2">A public method is a part of the class interface. </span><span class="koboSpan" id="kobo.207.3">A virtual function override is a customization of the implementation. </span><span class="koboSpan" id="kobo.207.4">A public virtual function inherently does both of these tasks, at once. </span><span class="koboSpan" id="kobo.207.5">The same entity performs two very different functions that should not be coupled—declaring the public interface and providing an alternative implementation. </span><span class="koboSpan" id="kobo.207.6">Each of these functions has different constraints—the implementation can be altered in any way, as long as the hierarchy invariants hold. </span><span class="koboSpan" id="kobo.207.7">But the interface cannot be actually changed by the virtual function (except for returning covariant types, but even that does not really change the interface). </span><span class="koboSpan" id="kobo.207.8">All the public virtual function does is restate that yes, indeed, the public interface still looks like what the base class has declared. </span><span class="koboSpan" id="kobo.207.9">Such a mixing of two very distinct</span><a id="_idIndexMarker787"/><span class="koboSpan" id="kobo.208.1"> roles </span><a id="_idIndexMarker788"/><span class="koboSpan" id="kobo.209.1">calls for a better separation of concerns. </span><span class="koboSpan" id="kobo.209.2">The Template Method pattern is an answer to that design problem, and in C++, it takes the form of the </span><strong class="bold"><span class="koboSpan" id="kobo.210.1">Non-V</span><a id="_idTextAnchor663"/><span class="koboSpan" id="kobo.211.1">i</span><a id="_idTextAnchor664"/><span class="koboSpan" id="kobo.212.1">rtual </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.213.1">Interface</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.214.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.215.1">NVI</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">).</span></span></p>
<h2 id="_idParaDest-254"><a id="_idTextAnchor665"/><span class="koboSpan" id="kobo.217.1">The NVI idiom in C++</span></h2>
<p><span class="koboSpan" id="kobo.218.1">The tension</span><a id="_idIndexMarker789"/><span class="koboSpan" id="kobo.219.1"> between </span><a id="_idIndexMarker790"/><span class="koboSpan" id="kobo.220.1">the two roles of a public virtual function, and the unnecessary exposure of the customization points created by such functions, lead us to the idea of making the implementation-specific virtual functions private. </span><span class="koboSpan" id="kobo.220.2">Herb Sutter in his article, </span><em class="italic"><span class="koboSpan" id="kobo.221.1">Virtuality</span></em><span class="koboSpan" id="kobo.222.1"> (</span><a href="http://www.gotw.ca/publications/mill18.htm"><span class="koboSpan" id="kobo.223.1">http://www.gotw.ca/publications/mill18.htm</span></a><span class="koboSpan" id="kobo.224.1">), suggests that most, if not all, virtual functions should </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">be private.</span></span></p>
<p><span class="koboSpan" id="kobo.226.1">For the Template Method, moving virtual functions from public to private comes with no consequences (other than the initial shock of seeing a private virtual function, if you have never realized</span><a id="_idIndexMarker791"/><span class="koboSpan" id="kobo.227.1"> that</span><a id="_idIndexMarker792"/><span class="koboSpan" id="kobo.228.1"> C++ </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">allows them):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.230.1">
// Example 08 (NVI version of example 01)
class Base {
  public:
  bool TheAlgorithm() {
    if (!Step1()) return false; // Step 1 failed
    Step2();
    return true;
  }
  private:
  virtual bool Step1() { return true };
  virtual void Step2() = 0;
};
class Derived1 : public Base {
  void Step2() override { ... </span><span class="koboSpan" id="kobo.230.2">do the work ... </span><span class="koboSpan" id="kobo.230.3">}
};
class Derived2 : public Base {
  bool Step1() override { ... </span><span class="koboSpan" id="kobo.230.4">check preconditions ... </span><span class="koboSpan" id="kobo.230.5">}
  void Step2() override { ... </span><span class="koboSpan" id="kobo.230.6">do the work ... </span><span class="koboSpan" id="kobo.230.7">}
};</span></pre>
<p><span class="koboSpan" id="kobo.231.1">This design nicely separates the interface and the implementation—the client interface is, and always was, the one call to run the entire algorithm. </span><span class="koboSpan" id="kobo.231.2">The possibility to change parts of the algorithm’s implementation is not reflected in the interface. </span><span class="koboSpan" id="kobo.231.3">Therefore, the user of this class hierarchy who only accesses it through the public interface and does not need to extend the hierarchy (write more derived classes), remains unaware of such implementation details. </span><span class="koboSpan" id="kobo.231.4">To see how this works in practice, you can convert every example in this chapter from public virtual functions to NVI; we are going to do just </span><a id="_idIndexMarker793"/><span class="koboSpan" id="kobo.232.1">one, example 06, and </span><a id="_idIndexMarker794"/><span class="koboSpan" id="kobo.233.1">leave the rest as an exercise to </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">the reader.</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.235.1">
// Example 09 (NVI version of example 06)
class FileWriter {
  virtual void Preamble(const char* data) {}
  virtual void Postscript(const char* data) {}
  public:
  void Write(const char* data) {
    Preamble(data);
    ... </span><span class="koboSpan" id="kobo.235.2">write data to a file ...
</span><span class="koboSpan" id="kobo.235.3">    Postscript(data);
  }
};
class LoggingFileWriter : public FileWriter {
  using FileWriter::FileWriter;
  void Preamble(const char* data) override {
    std::cout &lt;&lt; "Writing " &lt;&lt; data &lt;&lt; " to the file" &lt;&lt;
      std::endl;
  }
  void Postscript (const char*) override {
    std::cout &lt;&lt; "Writing done" &lt;&lt; std::endl;
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.236.1">The NVI gives complete control of the interface to the base class. </span><span class="koboSpan" id="kobo.236.2">The derived classes can only customize the implementation of this interface. </span><span class="koboSpan" id="kobo.236.3">The base class can determine and verify the invariants, impose the overall structure of the implementation, and specify which parts can, must, and cannot be customized. </span><span class="koboSpan" id="kobo.236.4">The NVI also separates the interface from the implementation explicitly. </span><span class="koboSpan" id="kobo.236.5">The implementers of the derived classes do not need to be concerned with exposing part of their implementation to the callers unintentionally—the implementation-only private methods cannot be called by anyone except the </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">base class.</span></span></p>
<p><span class="koboSpan" id="kobo.238.1">Note that it is still possible for a derived class such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">LoggingFileWriter</span></strong><span class="koboSpan" id="kobo.240.1"> to declare its own non-virtual function named </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">Write</span></strong><span class="koboSpan" id="kobo.242.1">. </span><span class="koboSpan" id="kobo.242.2">This is known as “shadowing” in C++: a name introduced in a derived class shadows (or makes inaccessible) all functions with the same name that would have been otherwise inherited from the base class. </span><span class="koboSpan" id="kobo.242.3">This causes the interfaces of the base and derived classes to diverge and is a very bad practice. </span><span class="koboSpan" id="kobo.242.4">Unfortunately, there is no good way for the base class implementer to protect from intentional shadowing. </span><span class="koboSpan" id="kobo.242.5">Accidental shadowing sometimes occurs when a function that is intended as a virtual override is declared with slightly different arguments; this can be avoided if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">override</span></strong><span class="koboSpan" id="kobo.244.1"> keyword is used for </span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">all overrides.</span></span></p>
<p><span class="koboSpan" id="kobo.246.1">So far, we have made all virtual functions that customize the implementation private. </span><span class="koboSpan" id="kobo.246.2">That, however, is not exactly the main point of the NVI—this idiom, and the more general Template Method, focus on making the public interface non-virtual. </span><span class="koboSpan" id="kobo.246.3">It follows, by extension, that </span><a id="_idIndexMarker795"/><span class="koboSpan" id="kobo.247.1">the</span><a id="_idIndexMarker796"/><span class="koboSpan" id="kobo.248.1"> implementation-specific overrides should not be public since they are not part of the interface. </span><span class="koboSpan" id="kobo.248.2">It does not necessarily follow that they should be private. </span><span class="koboSpan" id="kobo.248.3">That leaves </span><em class="italic"><span class="koboSpan" id="kobo.249.1">protected</span></em><span class="koboSpan" id="kobo.250.1">. </span><span class="koboSpan" id="kobo.250.2">So, should the virtual functions that provide customizations for the algorithm be private or protected? </span><span class="koboSpan" id="kobo.250.3">The Template Method allows both—the client of the hierarchy cannot directly call either one, so the framework of the algorithm remains unaffected. </span><span class="koboSpan" id="kobo.250.4">The answer depends on whether the derived classes may need to sub-invoke the implementations provided by the base class. </span><span class="koboSpan" id="kobo.250.5">For an example of the latter, consider a class hierarchy that can be serialized and sent to a remote machine through </span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">a socket:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.252.1">
// Example 10
class Base {
  public:
  void Send() { // Template Method used here
    ... </span><span class="koboSpan" id="kobo.252.2">open connection ...
</span><span class="koboSpan" id="kobo.252.3">    SendData(); // Customization point
    ... </span><span class="koboSpan" id="kobo.252.4">close connection ...
</span><span class="koboSpan" id="kobo.252.5">  }
  protected:
  virtual void SendData() { ... </span><span class="koboSpan" id="kobo.252.6">send base class data ... </span><span class="koboSpan" id="kobo.252.7">}
  private:
  ... </span><span class="koboSpan" id="kobo.252.8">data ...
</span><span class="koboSpan" id="kobo.252.9">};
class Derived : public Base {
  protected:
  void SendData() {
    Base::SendData();
    ... </span><span class="koboSpan" id="kobo.252.10">send derived class data ...
</span><span class="koboSpan" id="kobo.252.11">  }
};</span></pre>
<p><span class="koboSpan" id="kobo.253.1">Here, the framework is</span><a id="_idIndexMarker797"/><span class="koboSpan" id="kobo.254.1"> provided</span><a id="_idIndexMarker798"/><span class="koboSpan" id="kobo.255.1"> by the public non-virtual method </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">Base::Send()</span></strong><span class="koboSpan" id="kobo.257.1">, which handles the connection protocol and, at the right time, sends the data across the network. </span><span class="koboSpan" id="kobo.257.2">Of course, it can only send the data that the base class knows about. </span><span class="koboSpan" id="kobo.257.3">That is why </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">SendData</span></strong><span class="koboSpan" id="kobo.259.1"> is a customization point and is made virtual. </span><span class="koboSpan" id="kobo.259.2">The derived class must send its own data, of course, but someone must still send the base class data, and so the derived class makes a call to the protected vi</span><a id="_idTextAnchor666"/><span class="koboSpan" id="kobo.260.1">rtual function in the </span><span class="No-Break"><span class="koboSpan" id="kobo.261.1">base class.</span></span></p>
<p><span class="koboSpan" id="kobo.262.1">If this example looks like it’s missing something, there is a good reason for it. </span><span class="koboSpan" id="kobo.262.2">While we provided the general template for how to send data and a customization point for each class to handle its own data, there is another behavior aspect that should be user-configurable: </span><em class="italic"><span class="koboSpan" id="kobo.263.1">how</span></em><span class="koboSpan" id="kobo.264.1"> to send data. </span><span class="koboSpan" id="kobo.264.2">This is a great place to show the (sometimes obscure) difference between the template method pattern and the </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">strategy pattern.</span></span></p>
<h2 id="_idParaDest-255"><a id="_idTextAnchor667"/><span class="koboSpan" id="kobo.266.1">Template Method vs Strategy</span></h2>
<p><span class="koboSpan" id="kobo.267.1">While this </span><a id="_idIndexMarker799"/><span class="koboSpan" id="kobo.268.1">chapter</span><a id="_idIndexMarker800"/><span class="koboSpan" id="kobo.269.1"> is not about the Strategy pattern, it is</span><a id="_idIndexMarker801"/><span class="koboSpan" id="kobo.270.1"> sometimes confused with the Template Method, so we will now clarify the difference. </span><span class="koboSpan" id="kobo.270.2">We can use the example from the previous section to </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">do this.</span></span></p>
<p><span class="koboSpan" id="kobo.272.1">We have already used the Template Method to provide an overall template for the execution of the “send” operation in </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">Base::Send()</span></strong><span class="koboSpan" id="kobo.274.1">. </span><span class="koboSpan" id="kobo.274.2">There are three steps to the operation: open the connection, send the data, and close the connection. </span><span class="koboSpan" id="kobo.274.3">Sending data is the step that depends on the actual type of the object (which derived class it really is), and so it is explicitly designated as a customization point. </span><span class="koboSpan" id="kobo.274.4">The rest of the template is set </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">in stone.</span></span></p>
<p><span class="koboSpan" id="kobo.276.1">However we need another kind of customization: the </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">Base</span></strong><span class="koboSpan" id="kobo.278.1"> class, in general, is not the right place to define how to open and close the connection. </span><span class="koboSpan" id="kobo.278.2">Neither is the derived class: the same objects could be sent across different types of connections (sockets, files, shared memory, etc). </span><span class="koboSpan" id="kobo.278.3">This is where we can use the Strategy pattern to define communication strategy. </span><span class="koboSpan" id="kobo.278.4">The strategy is provided by a </span><span class="No-Break"><span class="koboSpan" id="kobo.279.1">separate class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.280.1">
// Example 11
class CommunicationStrategy {
  public:
  virtual void Open() = 0;
  virtual void Close() = 0;
  virtual void Send(int v) = 0;
  virtual void Send(long v) = 0;
  virtual void Send(double v) = 0;
  ... </span><span class="koboSpan" id="kobo.280.2">Send other types ...
</span><span class="koboSpan" id="kobo.280.3">};</span></pre>
<p><span class="koboSpan" id="kobo.281.1">Isn’t it frustrating that template functions cannot be virtual? </span><span class="koboSpan" id="kobo.281.2">For a better solution to this problem, you have to wait until </span><a href="B19262_15.xhtml#_idTextAnchor689"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.282.1">Chapter 15</span></em></span></a><span class="koboSpan" id="kobo.283.1">, </span><em class="italic"><span class="koboSpan" id="kobo.284.1">Policy-Based Design</span></em><span class="koboSpan" id="kobo.285.1">. </span><span class="koboSpan" id="kobo.285.2">Anyway, now that we have the communication strategy, we can use it to parametrize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">Send()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.287.1">operation template:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.288.1">
// Example 11
class Base {
  public:
  void Send(CommunicationStrategy* comm) {
    comm-&gt;Open();
    SendData(comm);
    comm-&gt;Close();
  }
  protected:
  virtual void SendData(CommunicationStrategy* comm) {
    comm-&gt;Send(i_);
    ... </span><span class="koboSpan" id="kobo.288.2">send all data ...
</span><span class="koboSpan" id="kobo.288.3">  }
  private:
  int i_;
  ... </span><span class="koboSpan" id="kobo.288.4">other data members ...
</span><span class="koboSpan" id="kobo.288.5">};</span></pre>
<p><span class="koboSpan" id="kobo.289.1">Note that the template for sending the data is basically unchanged, but we delegated the implementation of the specific steps to another class – the strategy. </span><span class="koboSpan" id="kobo.289.2">This is the key difference: the Strategy pattern allows us to choose (generally, at runtime) which implementation should be used for a particular operation. </span><span class="koboSpan" id="kobo.289.3">The public interface is fixed but the entire implementation is up to the specific strategy. </span><span class="koboSpan" id="kobo.289.4">The Template Method pattern enforces the overall implementation flow as well as the public interface. </span><span class="koboSpan" id="kobo.289.5">Only the specific steps of the algorithm can </span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">be customized.</span></span></p>
<p><span class="koboSpan" id="kobo.291.1">The second difference is where the customization happens: </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">Base::Send()</span></strong><span class="koboSpan" id="kobo.293.1"> is customized in two ways. </span><span class="koboSpan" id="kobo.293.2">The customizations to the template are done in the derived classes; the implementations of the strategy are provided by the classes outside of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">Base</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.295.1"> hierarchy.</span></span></p>
<p><span class="koboSpan" id="kobo.296.1">As we pointed out at the beginning of this section, there are good reasons to make all virtual member functions, by default, private (or protected), and they go beyond the applications of the Template Method pattern. </span><span class="koboSpan" id="kobo.296.2">However, there is one particular member function – the destructor - that deserves separate consideration because the rules for </span><a id="_idTextAnchor668"/><span class="koboSpan" id="kobo.297.1">destructors are </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">somewhat different.</span></span></p>
<h2 id="_idParaDest-256"><a id="_idTextAnchor669"/><span class="koboSpan" id="kobo.299.1">A note about destructors</span></h2>
<p><span class="koboSpan" id="kobo.300.1">The entire</span><a id="_idIndexMarker802"/><span class="koboSpan" id="kobo.301.1"> discussion of the NVI is an elaboration on</span><a id="_idIndexMarker803"/><span class="koboSpan" id="kobo.302.1"> a simple guideline—make virtual functions private (or protected), and present the public interface through non-virtual base class functions. </span><span class="koboSpan" id="kobo.302.2">This sounds fine until it runs head-on into another well-known guideline—if the class has at least one virtual function, its destructor must also be made virtual. </span><span class="koboSpan" id="kobo.302.3">Since the two are in conflict, some clarification </span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">is needed.</span></span></p>
<p><span class="koboSpan" id="kobo.304.1">The reason to make destructors virtual is that if the object is deleted polymorphically - for example, a derived class object is deleted through a pointer to the base class - the destructor must be virtual; otherwise, only the base part of the class will be destructed (the usual result is the </span><em class="italic"><span class="koboSpan" id="kobo.305.1">slicing</span></em><span class="koboSpan" id="kobo.306.1"> of the class, partial deletion, although the standard simply states that the results are undefined). </span><span class="koboSpan" id="kobo.306.2">So, if the objects are deleted through the base class pointers, the destructors must be virtual; there is no way around it. </span><span class="koboSpan" id="kobo.306.3">But that is the only reason. </span><span class="koboSpan" id="kobo.306.4">If the objects are always deleted with the correct derived type, then this reason does not apply. </span><span class="koboSpan" id="kobo.306.5">This situation is not uncommon: for example, if derived class objects are stored in a container, they will be deleted as their </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">true type.</span></span></p>
<p><span class="koboSpan" id="kobo.308.1">The container has to know how much memory to allocate for the object, so it can’t store a mix of base and derived objects, or delete them as base objects (note that a container of pointers to the base class object is a different construct altogether, and is usually created specifically so that we can store and delete </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">objects polymorphically).</span></span></p>
<p><span class="koboSpan" id="kobo.310.1">Now, if the derived class has to be deleted as itself, its destructor does not need to be virtual. </span><span class="koboSpan" id="kobo.310.2">However, bad things will still happen if someone calls the destructor of the base class when the actual object is of the derived class type. </span><span class="koboSpan" id="kobo.310.3">To safely prevent that from happening, we can declare the non-virtual base class destructor as protected instead of public. </span><span class="koboSpan" id="kobo.310.4">Of course, if the base class is not abstract, and there are objects of both base and derived types around, then both destructors must be made public, and the safer option is to make them virtual (a runtime check can be implemented to verify that the base class destructor is not called to destroy a derived </span><span class="No-Break"><span class="koboSpan" id="kobo.311.1">class object).</span></span></p>
<p><span class="koboSpan" id="kobo.312.1">By the way, if polymorphic deletion (deletion through the base class pointer) is the only reason you need to write a destructor in the base class, writing </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">virtual ~Base() = default;</span></strong><span class="koboSpan" id="kobo.314.1"> is perfectly acceptable – a destructor can be both </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">virtual</span></strong><span class="koboSpan" id="kobo.316.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">default</span></strong><span class="koboSpan" id="kobo.318.1"> at the </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">same time.</span></span></p>
<p><span class="koboSpan" id="kobo.320.1">We must also caution the reader against trying to employ the Template Method, or the non-virtual interface idiom, for class destructors. </span><span class="koboSpan" id="kobo.320.2">It may be tempting to do </span><a id="_idIndexMarker804"/><span class="koboSpan" id="kobo.321.1">something </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.323.1">
// Example 12
class Base {
  public:
  ~Base() { // Non-virtual interface!
</span><span class="koboSpan" id="kobo.323.2">    std::cout &lt;&lt; "Deleting now" &lt;&lt; std::endl;
    clear(); // Employing Template Method here
    std::cout &lt;&lt; "Deleting done" &lt;&lt; std::endl;
  }
  protected:
  virtual void clear() { ... </span><span class="koboSpan" id="kobo.323.3">} // Customizable part
};
class Derived : public Base {
  private:
  void clear() override {
    ...
</span><span class="koboSpan" id="kobo.323.4">    Base::clear();
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.324.1">However, this is not going to work (if the base class has a pure virtual </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">Base::clear()</span></strong><span class="koboSpan" id="kobo.326.1"> instead of a default implementation, it is not going to work in a rather spectacular fashion). </span><span class="koboSpan" id="kobo.326.2">The reason for this is that, inside the destructor of the base class, </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">Base::~Base()</span></strong><span class="koboSpan" id="kobo.328.1">, the actual, real, and true type of the object is not </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">Derived</span></strong><span class="koboSpan" id="kobo.330.1"> anymore. </span><span class="koboSpan" id="kobo.330.2">It’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">Base</span></strong><span class="koboSpan" id="kobo.332.1">. </span><span class="koboSpan" id="kobo.332.2">That’s right—when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">Derived::~Derived()</span></strong><span class="koboSpan" id="kobo.334.1"> destructor is done with its work and the control is transferred to the base class destructor, the dynamic type of the object changes </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">Base</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.338.1">The only other class member that works this way is the constructor—the type of the object is </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">Base</span></strong><span class="koboSpan" id="kobo.340.1"> as long as the base constructor is running, and then changes to </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">Derived</span></strong><span class="koboSpan" id="kobo.342.1"> when the derived constructor has started. </span><span class="koboSpan" id="kobo.342.2">For all other member functions, the type of the object is always the type it was created with. </span><span class="koboSpan" id="kobo.342.3">If the object was created as </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">Derived</span></strong><span class="koboSpan" id="kobo.344.1">, then that is the type, even if a method of the base class is called. </span><span class="koboSpan" id="kobo.344.2">So, what happens if, in the preceding example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">Base::clear()</span></strong><span class="koboSpan" id="kobo.346.1"> is pure virtual? </span><span class="koboSpan" id="kobo.346.2">It’s called anyway! </span><span class="koboSpan" id="kobo.346.3">The result depends on the compiler; most compilers will generate code that aborts the</span><a id="_idIndexMarker805"/><span class="koboSpan" id="kobo.347.1"> program, with </span><a id="_idIndexMarker806"/><span class="koboSpan" id="kobo.348.1">some diagnostic</span><a id="_idTextAnchor670"/> <a id="_idTextAnchor671"/><span class="koboSpan" id="kobo.349.1">that </span><em class="italic"><span class="koboSpan" id="kobo.350.1">a pure virtual function </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.351.1">was called</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">.</span></span></p>
<h1 id="_idParaDest-257"><a id="_idTextAnchor672"/><span class="koboSpan" id="kobo.353.1">Drawbacks of the Non-Virtual Interface</span></h1>
<p><span class="koboSpan" id="kobo.354.1">There aren’t many drawbacks regarding the use of the NVI. </span><span class="koboSpan" id="kobo.354.2">That is why the guideline to always make virtual functions private, and use the NVI to call them, is widely accepted. </span><span class="koboSpan" id="kobo.354.3">However, there are some considerations that you must be aware of when deciding whether the Template Method is the right design pattern to follow. </span><span class="koboSpan" id="kobo.354.4">The use of the template pattern may lead to fragile hierarchies. </span><span class="koboSpan" id="kobo.354.5">Also, there is some overlap between design problems that can be solved using the template pattern and the ones better served by the strategy pattern, or, in C++, policies. </span><span class="koboSpan" id="kobo.354.6">We will rev</span><a id="_idTextAnchor673"/><a id="_idTextAnchor674"/><span class="koboSpan" id="kobo.355.1">iew both considerations in </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">this section.</span></span></p>
<h2 id="_idParaDest-258"><a id="_idTextAnchor675"/><span class="koboSpan" id="kobo.357.1">Composability</span></h2>
<p><span class="koboSpan" id="kobo.358.1">Consider the</span><a id="_idIndexMarker807"/><span class="koboSpan" id="kobo.359.1"> earlier design for </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">LoggingFileWriter</span></strong><span class="koboSpan" id="kobo.361.1">. </span><span class="koboSpan" id="kobo.361.2">Now, suppose that we want to also have </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">CountingFileWriter</span></strong><span class="koboSpan" id="kobo.363.1"> that counts how many characters were written into </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">the file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.365.1">
class CountingFileWriter : public FileWriter {
  size_t count_ = 0;
  void Preamble(const char* data) {
    count_ += strlen(data);
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.366.1">That was easy. </span><span class="koboSpan" id="kobo.366.2">But there is no reason a counting file writer cannot also log. </span><span class="koboSpan" id="kobo.366.3">How would we implement a </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">CountingLoggingFileWriter</span></strong><span class="koboSpan" id="kobo.368.1">? </span><span class="koboSpan" id="kobo.368.2">No problem, we have the technology—change the private virtual functions to protected and call the base class version from the </span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">derived class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.370.1">
class CountingLoggingFileWriter : public LoggingFileWriter {
  size_t count_ = 0;
  void Preamble(const char* data) {
    count_ += strlen(data);
    LoggingFileWriter::Preamble(data);
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.371.1">Or should it be </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">LoggingCountingFileWriter</span></strong><span class="koboSpan" id="kobo.373.1"> that inherits from </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">CountingFileWriter</span></strong><span class="koboSpan" id="kobo.375.1">? </span><span class="koboSpan" id="kobo.375.2">Note that, either way, some code is duplicated—in our case, the counting code is present in both </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">CountingLoggingFileWriter</span></strong><span class="koboSpan" id="kobo.377.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">CountingFileWriter</span></strong><span class="koboSpan" id="kobo.379.1">. </span><span class="koboSpan" id="kobo.379.2">This duplication is only going to get worse as we add more variations. </span><span class="koboSpan" id="kobo.379.3">The </span><a id="_idIndexMarker808"/><span class="koboSpan" id="kobo.380.1">Template Method just isn’t the right pattern if you need composable customizations. </span><span class="koboSpan" id="kobo.380.2">For that, you s</span><a id="_idTextAnchor676"/><span class="koboSpan" id="kobo.381.1">h</span><a id="_idTextAnchor677"/><span class="koboSpan" id="kobo.382.1">ould read </span><a href="B19262_15.xhtml#_idTextAnchor689"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.383.1">Chapter 15</span></em></span></a><span class="koboSpan" id="kobo.384.1">, </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.385.1">Policy-Based Design</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.386.1">.</span></span></p>
<h2 id="_idParaDest-259"><a id="_idTextAnchor678"/><span class="koboSpan" id="kobo.387.1">The Fragile Base Class problem</span></h2>
<p><span class="koboSpan" id="kobo.388.1">The Fragile Base Class problem is not limited to the Template Method, but is, to some degree, inherent in all object-oriented languages. </span><span class="koboSpan" id="kobo.388.2">The problem arises when changes to the base class break the derived class. </span><span class="koboSpan" id="kobo.388.3">To see how this can happen, specifically when using the non-virtual interface, let’s go back to the file writer and add the ability to write many strings </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">at once:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.390.1">
class FileWriter {
  public:
  void Write(const char* data) {
    Preamble(data);
    ... </span><span class="koboSpan" id="kobo.390.2">write data to a file ...
</span><span class="koboSpan" id="kobo.390.3">    Postscript(data);
  }
  void Write(std::vector&lt;const char*&gt; huge_data) {
    Preamble(huge_data);
    for (auto data: huge_data) {
      ... </span><span class="koboSpan" id="kobo.390.4">write data to file ...
</span><span class="koboSpan" id="kobo.390.5">    }
    Postscript(huge_data);
  }
  private:
  virtual void Preamble(std::vector&lt;const char*&gt; data) {}
  virtual void Postscript(std::vector&lt;const char*&gt; data) {}
  virtual void Preamble(const char* data) {}
  virtual void Postscript(const char* data) {}
};</span></pre>
<p><span class="koboSpan" id="kobo.391.1">The counting writer </span><a id="_idIndexMarker809"/><span class="koboSpan" id="kobo.392.1">is kept </span><a id="_idIndexMarker810"/><span class="koboSpan" id="kobo.393.1">up to date with </span><span class="No-Break"><span class="koboSpan" id="kobo.394.1">the changes:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.395.1">
class CountingFileWriter : public FileWriter {
  size_t count_ = 0;
  void Preamble(std::vector&lt;const char*&gt; huge_data) {
    for (auto data: huge_data) count_ += strlen(data);
  }
  void Preamble(const char* data) {
    count_ += strlen(data);
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.396.1">So far, so good. </span><span class="koboSpan" id="kobo.396.2">Later, a well-intentioned programmer notices that the base class suffers from some code duplication and decides to </span><span class="No-Break"><span class="koboSpan" id="kobo.397.1">refactor it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.398.1">
class FileWriter {
  public:
  void Write(const char* data) { ... </span><span class="koboSpan" id="kobo.398.2">no changes here ... </span><span class="koboSpan" id="kobo.398.3">}
  void Write(std::vector&lt;const char*&gt; huge_data) {
    Preamble(huge_data);
    for (auto data: huge_data) Write(data); // Code reuse!
</span><span class="koboSpan" id="kobo.398.4">    Postscript(huge_data);
  }
  private:
  ... </span><span class="koboSpan" id="kobo.398.5">no changes here ...
</span><span class="koboSpan" id="kobo.398.6">};</span></pre>
<p><span class="koboSpan" id="kobo.399.1">Now, the derived</span><a id="_idIndexMarker811"/><span class="koboSpan" id="kobo.400.1"> class is </span><a id="_idIndexMarker812"/><span class="koboSpan" id="kobo.401.1">broken—the counting customizations of both versions of </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">Write</span></strong><span class="koboSpan" id="kobo.403.1"> are called when a vector of strings is written, and the data size is counted twice. </span><span class="koboSpan" id="kobo.403.2">Note that we are not talking about the more basic kind of fragility where an override method in a derived class can stop being an override if the signature of the base class method is changed: this kind of fragility is largely avoided by the proper use of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">override</span></strong><span class="koboSpan" id="kobo.405.1"> keyword as recommended in </span><a href="B19262_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.406.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.407.1">, </span><em class="italic"><span class="koboSpan" id="kobo.408.1">An Introduction to Inheritance </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.409.1">and Polymorphism</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.411.1">While there is no general solution to the Fragile Base Class problem as long as inheritance is used at all, the guideline that helps to avoid it when using the Template Method is straightforward—when changing the base class and the structure of the algorithms, or the framework, avoid changing which customization points are invoked. </span><span class="koboSpan" id="kobo.411.2">Specifically, do not skip any customization options that were already invoked, and do not add new calls to already existing ones (it’s OK to add new customization points, as long as the default implementation is sensible). </span><span class="koboSpan" id="kobo.411.3">If such a change cannot be avoided, you will need to review every derived class to see whether it relied on the implementation override that is now removed or replaced, </span><a id="_idTextAnchor679"/><span class="koboSpan" id="kobo.412.1">and what the consequences of such a </span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">change are.</span></span></p>
<h2 id="_idParaDest-260"><a id="_idTextAnchor680"/><span class="koboSpan" id="kobo.414.1">A cautionary note about template customization points</span></h2>
<p><span class="koboSpan" id="kobo.415.1">This brief </span><a id="_idIndexMarker813"/><span class="koboSpan" id="kobo.416.1">section is not a </span><a id="_idIndexMarker814"/><span class="koboSpan" id="kobo.417.1">drawback of the Template Method, but rather a warning about a somewhat arcane corner of C++. </span><span class="koboSpan" id="kobo.417.2">Many of the design patterns that were originally developed as run-time behaviors (object-oriented patterns) found their compile-time analogs in C++ generic programming.  </span><span class="koboSpan" id="kobo.417.3">So, is there a compile-time </span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">template method?</span></span></p>
<p><span class="koboSpan" id="kobo.419.1">Of course, there is an obvious one: we can have a function or a class template that accepts function parameters, or, more generally, callable parameters, for a certain step of the otherwise fixed algorithm. </span><span class="koboSpan" id="kobo.419.2">The standard library has a plethora of examples, such </span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">std::find_if</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.422.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.423.1">
std::vector&lt;int&gt; v = ... </span><span class="koboSpan" id="kobo.423.2">some data ...
</span><span class="koboSpan" id="kobo.423.3">auto it = std::find_if(v.begin(), v.end(),
                       [](int i) { return i &amp; 1; });
if (it != v.end()) { ... </span><span class="koboSpan" id="kobo.423.4">} // even value found</span></pre>
<p><span class="koboSpan" id="kobo.424.1">The algorithm of </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">std::find_if</span></strong><span class="koboSpan" id="kobo.426.1"> is known and cannot be altered, except for the step where it checks whether a particular value satisfies the </span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">caller’s predicate.</span></span></p>
<p><span class="koboSpan" id="kobo.428.1">If we want to do the same for class hierarchies, we can use member function pointers (although it is easier to invoke member functions through lambdas), but there is no way to say “</span><em class="italic"><span class="koboSpan" id="kobo.429.1">call a member function with the same name but on a different class</span></em><span class="koboSpan" id="kobo.430.1">” except by using virtual functions and their overrides. </span><span class="koboSpan" id="kobo.430.2">There is no equivalent to that in </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">generic programming.</span></span></p>
<p><span class="koboSpan" id="kobo.432.1">Unfortunately, there is a case where a template can be customized by accident, usually with unintended results. </span><span class="koboSpan" id="kobo.432.2">Consider </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">this example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.434.1">
// Example 15
void f() { ... </span><span class="koboSpan" id="kobo.434.2">}
template &lt;typename T&gt; struct A {
  void f() const { ... </span><span class="koboSpan" id="kobo.434.3">}
};
template &lt;typename T&gt; struct B : public A&lt;T&gt; {
  void h() { f(); }
};
B&lt;int&gt; b;
b.h();</span></pre>
<p><span class="koboSpan" id="kobo.435.1">Which function </span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">f()</span></strong><span class="koboSpan" id="kobo.437.1"> is called from inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">B&lt;T&gt;::h()</span></strong><span class="koboSpan" id="kobo.439.1">? </span><span class="koboSpan" id="kobo.439.2">On a standard-compliant compiler, it should be the free-standing function, i.e. </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">::f()</span></strong><span class="koboSpan" id="kobo.441.1">, and not the member function of the base class! </span><span class="koboSpan" id="kobo.441.2">This may come as a surprise: if </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">A</span></strong><span class="koboSpan" id="kobo.443.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">B</span></strong><span class="koboSpan" id="kobo.445.1"> were non-template classes, the base class method </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">A::f()</span></strong><span class="koboSpan" id="kobo.447.1"> would have been called. </span><span class="koboSpan" id="kobo.447.2">This behavior arises from the complexities of parsing templates in C++ (if you want to learn more about this, </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">two-phase template parse</span></strong><span class="koboSpan" id="kobo.449.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">two-stage name lookup</span></strong><span class="koboSpan" id="kobo.451.1"> are the terms to search for, but the matter is far outside the subject of </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">this book).</span></span></p>
<p><span class="koboSpan" id="kobo.453.1">What would have </span><a id="_idIndexMarker815"/><span class="koboSpan" id="kobo.454.1">happened </span><a id="_idIndexMarker816"/><span class="koboSpan" id="kobo.455.1">if the global function </span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">f()</span></strong><span class="koboSpan" id="kobo.457.1"> was not available in the first place? </span><span class="koboSpan" id="kobo.457.2">Then we have to call the one in the base class, </span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">don’t we?</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.459.1">
// Example 15
// No f() here!
</span><span class="koboSpan" id="kobo.459.2">template &lt;typename T&gt; struct A {
  void f() const { ... </span><span class="koboSpan" id="kobo.459.3">}
};
template &lt;typename T&gt; struct B : public A&lt;T&gt; {
  void h() { f(); } // Should not compile!
</span><span class="koboSpan" id="kobo.459.4">};
B&lt;int&gt; b;
b.h();</span></pre>
<p><span class="koboSpan" id="kobo.460.1">If you tried this code and it has called </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">A&lt;T&gt;::f()</span></strong><span class="koboSpan" id="kobo.462.1">, then you have a buggy compiler: the standard says that this should not compile at all! </span><span class="koboSpan" id="kobo.462.2">But what should you do if you want to call a member function of your own base class? </span><span class="koboSpan" id="kobo.462.3">The answer is very simple but looks strange if you haven’t written a lot of </span><span class="No-Break"><span class="koboSpan" id="kobo.463.1">template code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.464.1">
// Example 15
template &lt;typename T&gt; struct A {
  void f() const { ... </span><span class="koboSpan" id="kobo.464.2">}
};
template &lt;typename T&gt; struct B : public A&lt;T&gt; {
  void h() { this-&gt;f(); } // Definitely A::f()
};
B&lt;int&gt; b;
b.h();</span></pre>
<p><span class="koboSpan" id="kobo.465.1">That’s right, you have to explicitly call </span><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">this-&gt;f()</span></strong><span class="koboSpan" id="kobo.467.1"> to ensure that you’re calling a member function. </span><span class="koboSpan" id="kobo.467.2">If you do this, </span><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">A&lt;T&gt;::f()</span></strong><span class="koboSpan" id="kobo.469.1"> gets called whether or not there is a global </span><strong class="source-inline"><span class="koboSpan" id="kobo.470.1">f()</span></strong><span class="koboSpan" id="kobo.471.1"> declared. </span><span class="koboSpan" id="kobo.471.2">By the way, if you intended to call the global function, the way to do this unambiguously is </span><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">::f()</span></strong><span class="koboSpan" id="kobo.473.1">, or, if the function is in a namespace </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">NS</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">NS::f()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.477.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.478.1">The compilation error where the compiler cannot find a member function that is clearly present in the base class is one of the more confusing C++ errors; it is even worse if the compiler does not issue this error and compiles the code “as intended” instead: if someone adds a global function with the same name later (or it is declared in another header you include), the compiler will switch to that function with no warning. </span><span class="koboSpan" id="kobo.478.2">The general guideline is to always qualify member function calls in a class template </span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">this-&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.481.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.482.1">Overall, the Template Method is one of the few patterns that remain purely object-oriented in C++: the template form we saw employed by </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">std::find_if</span></strong><span class="koboSpan" id="kobo.484.1"> (and many more templates) usually</span><a id="_idIndexMarker817"/><span class="koboSpan" id="kobo.485.1"> falls </span><a id="_idIndexMarker818"/><span class="koboSpan" id="kobo.486.1">under the general umbrella of Policy-Based de</span><a id="_idTextAnchor681"/><span class="koboSpan" id="kobo.487.1">signs that we’re going to study in the </span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">next chapter.</span></span></p>
<h1 id="_idParaDest-261"><a id="_idTextAnchor682"/><span class="koboSpan" id="kobo.489.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.490.1">In this chapter, we have reviewed a classic object-oriented design pattern, the Template Method, as it applies to C++ programs. </span><span class="koboSpan" id="kobo.490.2">This pattern works in C++ as well as in any other object-oriented language, but C++ also has its own flavor of the Template Method—the non-virtual interface idiom. </span><span class="koboSpan" id="kobo.490.3">The advantages of this design pattern lead to a rather broad guideline—make all virtual functions private or protected. </span><span class="koboSpan" id="kobo.490.4">Be mindful, however, of the specifics of the destructors with regard to polymorphism. </span><span class="koboSpan" id="kobo.490.5">Here are the general guidelines for access (public vs private) to </span><span class="No-Break"><span class="koboSpan" id="kobo.491.1">virtual functions:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.492.1">Prefer to make interfaces nonvirtual, using the Template Method </span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">design pattern</span></span></li>
<li><span class="koboSpan" id="kobo.494.1">Prefer to make virtual </span><span class="No-Break"><span class="koboSpan" id="kobo.495.1">functions private</span></span></li>
<li><span class="koboSpan" id="kobo.496.1">Only if derived classes need to invoke the base implementation of a virtual function, make the virtual </span><span class="No-Break"><span class="koboSpan" id="kobo.497.1">function protected.</span></span></li>
<li><span class="koboSpan" id="kobo.498.1">A base class destructor should be either public and virtual (if objects are deleted through the base class pointer) or protected and n</span><a id="_idTextAnchor683"/><span class="koboSpan" id="kobo.499.1">onvirtual (if derived objects are </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">deleted directly).</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.501.1">We already mentioned the Strategy pattern in this chapter by way of clarifying how it differs from the Template Method pattern. </span><span class="koboSpan" id="kobo.501.2">Strategy is also a popular pattern in C++, in particular, its generic programming equivalent. </span><a id="_idTextAnchor684"/><span class="koboSpan" id="kobo.502.1">This is going to be the subject of the </span><span class="No-Break"><span class="koboSpan" id="kobo.503.1">next chapter.</span></span></p>
<h1 id="_idParaDest-262"><a id="_idTextAnchor685"/><span class="koboSpan" id="kobo.504.1">Questions</span></h1>
<ol>
<li><span class="koboSpan" id="kobo.505.1">What is a behavioral </span><span class="No-Break"><span class="koboSpan" id="kobo.506.1">design pattern?</span></span></li>
<li><span class="koboSpan" id="kobo.507.1">What is the Template </span><span class="No-Break"><span class="koboSpan" id="kobo.508.1">Method pattern?</span></span></li>
<li><span class="koboSpan" id="kobo.509.1">Why is the Template Method considered a </span><span class="No-Break"><span class="koboSpan" id="kobo.510.1">behavioral pattern?</span></span></li>
<li><span class="koboSpan" id="kobo.511.1">What is the inversion of control, and how does it apply to the </span><span class="No-Break"><span class="koboSpan" id="kobo.512.1">Template Method?</span></span></li>
<li><span class="koboSpan" id="kobo.513.1">What is the </span><span class="No-Break"><span class="koboSpan" id="kobo.514.1">non-virtual interface?</span></span></li>
<li><span class="koboSpan" id="kobo.515.1">Why is it recommended to make all virtual functions in </span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">C++ private?</span></span></li>
<li><span class="koboSpan" id="kobo.517.1">When should virtual functions </span><span class="No-Break"><span class="koboSpan" id="kobo.518.1">be protected?</span></span></li>
<li><span class="koboSpan" id="kobo.519.1">Why can’t the Template Method be used </span><span class="No-Break"><span class="koboSpan" id="kobo.520.1">for destructors?</span></span></li>
<li><span class="koboSpan" id="kobo.521.1">What is the Fragile Base class problem, and how</span><a id="_idTextAnchor686"/><a id="_idTextAnchor687"/><span class="koboSpan" id="kobo.522.1"> can we avoid it when employing the </span><span class="No-Break"><span class="koboSpan" id="kobo.523.1">Template Method?</span></span></li>
</ol>
</div>


<div class="Content" id="_idContainer031">
<h1 id="_idParaDest-263"><a id="_idTextAnchor688"/><span class="koboSpan" id="kobo.1.1">Part 4: Advanced C++ Design Patterns</span></h1>
<p><span class="koboSpan" id="kobo.2.1">This part continues with the description and detailed explanation of C++ design patterns, moving on to the more advanced patterns. </span><span class="koboSpan" id="kobo.2.2">Some of these patterns use advanced features of the C++ language. </span><span class="koboSpan" id="kobo.2.3">Others represent complex concepts and address more difficult design problems. </span><span class="koboSpan" id="kobo.2.4">Yet other patterns implement very open-ended designs, where part of the solution can be factored out into a commonly accepted pattern, but the entire system must be customizable within very </span><span class="No-Break"><span class="koboSpan" id="kobo.3.1">wide limits.</span></span></p>
<p><span class="koboSpan" id="kobo.4.1">This part has the </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">following chapters:</span></span></p>
<ul>
<li><a href="B19262_15.xhtml#_idTextAnchor689"><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapter 15</span></em></a><span class="koboSpan" id="kobo.7.1">, </span><em class="italic"><span class="koboSpan" id="kobo.8.1">Policy-Based Design</span></em></li>
<li><a href="B19262_16.xhtml#_idTextAnchor739"><em class="italic"><span class="koboSpan" id="kobo.9.1">Chapter 16</span></em></a><span class="koboSpan" id="kobo.10.1">, </span><em class="italic"><span class="koboSpan" id="kobo.11.1">Adapters and Decorators</span></em></li>
<li><a href="B19262_17.xhtml#_idTextAnchor783"><em class="italic"><span class="koboSpan" id="kobo.12.1">Chapter 17</span></em></a><span class="koboSpan" id="kobo.13.1">, </span><em class="italic"><span class="koboSpan" id="kobo.14.1">The Visitor Pattern and Multiple Dispatch</span></em></li>
<li><a href="B19262_18.xhtml#_idTextAnchor832"><em class="italic"><span class="koboSpan" id="kobo.15.1">Chapter 18</span></em></a><span class="koboSpan" id="kobo.16.1">, </span><em class="italic"><span class="koboSpan" id="kobo.17.1">Patterns for Concurrency</span></em></li>
</ul>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer032">
</div>
</div>
<div>
<div id="_idContainer033">
</div>
</div>
</body></html>