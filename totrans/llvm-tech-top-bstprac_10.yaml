- en: '*Chapter 8*: Working with Compiler Flags and Toolchains'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 8 章*：使用编译器标志和工具链'
- en: In the previous chapter, we learned how to process Clang's AST – one of the
    most common formats for analyzing programs. In addition, we learned how to develop
    an AST plugin, which is an easy way to insert custom logic into the Clang compilation
    pipeline. This knowledge will help you augment your skillset for tasks such as
    source code linting or finding potential security vulnerabilities.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何处理 Clang 的 AST – 分析程序中最常见的格式之一。此外，我们还学习了如何开发 AST 插件，这是一种将自定义逻辑插入
    Clang 编译管道的简单方法。这些知识将帮助你在源代码检查或寻找潜在的安全漏洞等任务中增强你的技能集。
- en: In this chapter, we are ascending from specific subsystems and looking at the
    bigger picture – the compiler **driver** and **toolchain** that orchestrate, configure,
    and run individual LLVM and Clang components according to users' needs. More specifically,
    we will focus on how to add new compiler flags and how to create a custom toolchain.
    As we mentioned in [*Chapter 5*](B14590_05_Final_JC_ePub.xhtml#_idTextAnchor067),
    *Exploring Clang's Architecture*, compiler drivers and toolchains are often under-appreciated
    and have long been ignored. However, without these two important pieces of software,
    compilers will become extremely difficult to use. For example, users need to pass
    over *10* different compiler flags merely to build a simple *hello world* program,
    owing to the lack of flag translation. Users also need to run at least three different
    kinds of tools in order to create an executable to run, since there are no drivers
    or toolchains to help us invoke *assemblers* and *linkers*. In this chapter, you
    will learn how compiler drivers and toolchains work in Clang and how to customize
    them, which is extremely useful if you want to support Clang on a new operating
    system or architecture.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们正在从特定的子系统向上攀升，着眼于更大的图景 – 编译器**驱动程序**和**工具链**，根据用户的需求协调、配置和运行单个 LLVM 和
    Clang 组件。更具体地说，我们将关注如何添加新的编译器标志以及如何创建自定义工具链。正如我们在[*第 5 章*](B14590_05_Final_JC_ePub.xhtml#_idTextAnchor067)中提到的，即[*探索
    Clang 的架构*]，编译器驱动程序和工具链通常被低估，并且长期以来一直被忽视。然而，没有这两个重要的软件组件，编译器将变得极其难以使用。例如，由于缺乏标志转换，用户需要传递超过
    *10* 个不同的编译器标志才能构建一个简单的 *hello world* 程序。用户还需要运行至少三种不同类型的工具，以便创建一个可执行的程序来运行，因为没有驱动程序或工具链帮助我们调用
    *汇编器* 和 *链接器*。在本章中，你将学习编译器驱动程序和工具链在 Clang 中的工作方式以及如何自定义它们，这对于你想要在新的操作系统或架构上支持
    Clang 来说非常有用。
- en: 'In this section, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将涵盖以下主题：
- en: Understanding drivers and toolchains in Clang
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Clang 中的驱动程序和工具链
- en: Adding custom driver flags
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加自定义驱动程序标志
- en: Adding a custom toolchain
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加自定义工具链
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we are still relying on the `clang` executable, so make sure
    you build it, like this:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们仍然依赖于 `clang` 可执行文件，所以请确保你已构建它，如下所示：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Since we are working with a driver, as we mentioned in [*Chapter 5*](B14590_05_Final_JC_ePub.xhtml#_idTextAnchor067),
    *Exploring Clang''s Architecture*, you can use the `-###` command-line option
    to print out the frontend flags that have been translated from the driver, like
    so:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第 5 章*](B14590_05_Final_JC_ePub.xhtml#_idTextAnchor067)中提到的，即[*探索 Clang
    的架构*]，我们正在使用驱动程序，你可以使用 `-###` 命令行选项来打印出已从驱动程序转换的前端标志，如下所示：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Using this flag will *not* run the rest of the compilation but merely execute
    the driver and toolchain. This makes it a good way to verify and debug specific
    flags and check they are correctly propagated from the driver to the frontend.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此标志将**不会**运行编译的其余部分，而只是执行驱动程序和工具链。这使得它成为验证和调试特定标志以及检查它们是否正确从驱动程序传播到前端的好方法。
- en: 'Last but not least, in the last section of this chapter, *Adding a custom toolchain*,
    we will work on a project that can only run on Linux systems. Also, please install
    OpenSSL beforehand. It is usually available as a package in most Linux systems.
    For example, on Ubuntu, you can use the following command to install it:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，在本章的最后部分，*添加自定义工具链*，我们将处理一个只能在 Linux 系统上运行的项目。此外，请事先安装 OpenSSL。在大多数
    Linux 系统中，它通常作为软件包提供。例如，在 Ubuntu 上，你可以使用以下命令来安装它：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We are only using the command-line utility, so there's no need to install any
    OpenSSL libraries that are normally used for development.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只使用命令行工具，因此不需要安装通常用于开发的任何 OpenSSL 库。
- en: 'The code that will be used in this chapter can be found here: [https://github.com/PacktPublishing/LLVM-Techniques-Tips-and-Best-Practices-Clang-and-Middle-End-Libraries/tree/main/Chapter08](https://github.com/PacktPublishing/LLVM-Techniques-Tips-and-Best-Practices-Clang-and-Middle-End-Libraries/tree/main/Chapter08).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将使用的代码可以在以下位置找到：[https://github.com/PacktPublishing/LLVM-Techniques-Tips-and-Best-Practices-Clang-and-Middle-End-Libraries/tree/main/Chapter08](https://github.com/PacktPublishing/LLVM-Techniques-Tips-and-Best-Practices-Clang-and-Middle-End-Libraries/tree/main/Chapter08).
- en: In the first section of this chapter, we will provide a brief introduction to
    Clang's driver and toolchain infrastructure.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一部分，我们将简要介绍 Clang 的驱动程序和工具链基础设施。
- en: Understanding drivers and toolchains in Clang
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Clang 中的驱动程序和工具链
- en: Before we talk about the compiler driver in Clang, it is necessary to highlight
    the fact that *compiling a piece of code* is never a *single* task (and not a
    simple one, either). In school, we were taught that a compiler consists of a **lexer**,
    a **parser**, sometimes came with an **optimizer**, and ended with an **assembly
    code printer**. While you still can see these stages in real-world compilers,
    they give you nothing but textual assembly code rather than an executable or library,
    as we would normally expect. Furthermore, this naïve compiler only provides limited
    flexibility – it can't be ported to any other operating systems or platforms.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论 Clang 的编译器驱动程序之前，有必要强调一点：**编译一段代码**永远不是一个**单一**的任务（也不是一个简单的任务）。在学校，我们被教导说编译器由一个**词法分析器**、一个**解析器**组成，有时还包含一个**优化器**，并以**汇编代码生成器**结束。虽然你仍然可以在现实世界的编译器中看到这些阶段，但它们只能给你文本形式的汇编代码，而不是我们通常期望的可执行文件或库。此外，这个简单的编译器只提供了有限的灵活性——它不能移植到任何其他操作系统或平台。
- en: 'To make this toy compiler more realistic and usable, many other *plumber* tools
    need to be put together, along with the core compiler: an **assembler** to transform
    assembly code into (binary format) object file, a **linker** to put multiple object
    files into an executable or library, and many other routines to resolve platform-specific
    configurations, such as data width, default header file paths, or **Application
    Binary Interfaces** (**ABIs**). Only with help from these *plumbers* can we use
    a compiler by just typing a few words:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个玩具编译器更加真实和可用，还需要将许多其他**管道**工具组合起来，包括核心编译器：一个**汇编器**，将汇编代码转换为（二进制格式）目标文件，一个**链接器**，将多个目标文件放入可执行文件或库中，以及许多其他例程来解决特定平台的配置，例如数据宽度、默认头文件路径或**应用程序二进制接口**（**ABIs**）。只有借助这些**管道**，我们才能通过输入几个单词来使用编译器：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A **compiler driver** is software that organizes these *plumber* jobs. Despite
    having multiple different tasks to do during the compilation, we will only focus
    on two of the most important ones in this chapter – handling compiler flags and
    invoking the right tools on different platforms – which is what toolchains are
    designed for.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**编译器驱动程序**是一种组织这些**管道**工作的软件。尽管在编译过程中有多个不同的任务需要完成，但本章我们将只关注两个最重要的任务——处理编译器标志和在不同平台上调用正确的工具——这正是工具链设计的目的。'
- en: 'The following diagram shows the interactions between the driver, the toolchains,
    and the rest of the compiler:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了驱动程序、工具链和编译器其他部分的交互：
- en: '![Figure 8.1 – Typical workflow of Clang''s driver, toolchains, and the rest
    of the compiler'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.1 – Clang 驱动程序、工具链和编译器其他部分的典型工作流程'
- en: '](img/Figure_8.1_B14590.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.1_B14590.jpg)'
- en: Figure 8.1 – Typical workflow of Clang's driver, toolchains, and the rest of
    the compiler
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – Clang 驱动程序、工具链和编译器其他部分的典型工作流程
- en: As shown in the preceding diagram, Clang's driver acts as a *dispatcher* and
    distributes flags and workloads to each of the compilation phases, namely the
    frontend/backend, the assembler, and the linker. To give you a more concrete idea
    of what the flags for each of these phases look like, recall the `-###` compiler
    option we introduced at the beginning of this chapter. The (massive amount of)
    content that's printed by that option is the flags for the frontend (`-internal-isystem`
    carries the information about the system header path, including the path where
    the C/C++ standard library header files are stored. It is obvious that Clang's
    frontend needs to know where the standard library headers are stored, but as per
    your past experiences of using `clang` (or `gcc`), you rarely need to tell them
    where those headers are *explicitly* – the driver will do that for you. The same
    logic applies to the linking phase as well. Linkers usually need more than just
    an object file to properly generate an executable or a library. For example, they
    need to know where the C/C++ standard library's library files (`*.a` or `*.so`
    on Unix/Linux systems) are. In that case, Clang's driver will provide that information
    to the linkers via linker flags.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，Clang 的驱动程序充当 *调度器* 并将标志和工作负载分配给编译的每个阶段，即前端/后端、汇编器和链接器。为了给您一个更具体的概念，了解每个这些阶段的标志看起来像什么，回想一下我们在本章开头介绍的
    `-###` 编译器选项。该选项打印的（大量）内容是前端（`-internal-isystem` 包含有关系统头文件路径的信息，包括 C/C++ 标准库头文件存储的路径。显然，Clang
    的前端需要知道标准库头文件存储在哪里，但根据您过去使用 `clang`（或 `gcc`）的经验，您很少需要明确地告诉它们这些头文件的路径 – 驱动程序会为您完成这项工作。同样的逻辑也适用于链接阶段。链接器通常需要不仅仅是对象文件才能正确生成可执行文件或库。例如，它们需要知道
    C/C++ 标准库的库文件（在 Unix/Linux 系统上是 `*.a` 或 `*.so`）在哪里。在这种情况下，Clang 的驱动程序将通过链接器标志向链接器提供这些信息。
- en: 'Flags and workloads – or *configurations*, in short – that are provided to
    individual compiler phases are *translated* from two sources: driver flags (`-c`,
    `-Wall`, and `-std=c++11`. In the next section, *Adding custom driver flags*,
    we will show you some examples of how Clang translates driver flags into frontend
    flags or even assembler/linker flags.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 提供给各个编译阶段的标志和工作负载（简称为 *配置*）是从两个来源 *转换* 的：驱动标志（`-c`、`-Wall` 和 `-std=c++11`。在下一节，*添加自定义驱动标志*
    中，我们将展示一些 Clang 如何将驱动标志转换为前端标志或甚至汇编器/链接器标志的示例。
- en: On the other hand, a `/usr/include` and `/usr/lib`. Also, macOS X uses an executable
    format called **Mach-O**, which is different from Linux's ELF format. This greatly
    affects how compilers (Clang) build the code.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，还有 `/usr/include` 和 `/usr/lib`。此外，macOS X 使用一种名为 **Mach-O** 的可执行格式，这与 Linux
    的 ELF 格式不同。这极大地影响了编译器（Clang）构建代码的方式。
- en: For Clang to compile code for various platforms, it uses toolchains (which are
    effectively represented by the `ToolChain` C++ class internally) to encapsulate
    platform-specific information and configurations. In the early stage of compilation,
    Clang's driver selects a correct toolchain based on the system currently running
    (called the `-target=` driver flag to ask Clang to build a program for a specific
    platform that is different from the host system, which is effectively doing `ld64`
    and `lld` linkers for now, whereas Linux can use `ld` (BFD linker), `ld.gold`,
    and `lld` as linkers. Therefore, a toolchain should also specify what assembler
    and linker to use. In the last section of this chapter, *Adding a custom toolchain*,
    we will go through an example project to learn how Clang's toolchains work. Let's
    start our journey by learning how driver flags work in Clang.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 Clang 为各种平台编译代码，它使用工具链（在内部通过 `ToolChain` C++ 类有效地表示）来封装平台特定的信息和配置。在编译的早期阶段，Clang
    的驱动程序根据当前运行的系统（称为 `-target=` 驱动标志，用于请求 Clang 为与主机系统不同的特定平台构建程序，目前实际上是在做 `ld64`
    和 `lld` 链接器，而 Linux 可以使用 `ld`（BFD 链接器）、`ld.gold` 和 `lld` 作为链接器。因此，工具链还应指定要使用哪个汇编器和链接器。在本章的最后部分，*添加自定义工具链*，我们将通过一个示例项目来了解
    Clang 的工具链是如何工作的。让我们从学习 Clang 中驱动标志的工作原理开始我们的旅程。
- en: Adding custom driver flags
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加自定义驱动标志
- en: In the previous section, we explained the role of the driver and toolchains
    in Clang. In this section, we are going to learn how Clang's driver does this
    translation by adding a custom driver flag to Clang. Again, we will go through
    the overview for this example project first before demonstrating the detailed
    steps in a separate section.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们解释了驱动和工具链在 Clang 中的作用。在本节中，我们将学习如何通过向 Clang 添加自定义驱动标志来实现 Clang 的这种转换。同样，我们将在单独的部分中演示详细步骤之前，首先概述这个示例项目。
- en: Project overview
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目概述
- en: The example project we will be using for this section is going to add a new
    driver flag so that when that flag is given by users, a header file will be *implicitly*
    included in the input code.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本节中使用的示例项目将添加一个新的驱动标志，以便当用户提供该标志时，头文件将 *隐式地* 包含在输入代码中。
- en: 'To be more specific, here, we have a header file – `simple_log.h` – shown in
    the following code that defines some simple APIs to print log messages:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，这里我们有一个头文件 – `simple_log.h` – 如下代码所示，它定义了一些简单的API来打印日志消息：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The goal here is to use these APIs in our code *without* writing the `#include
    "simple_log.h"` line to import the header file. And this feature will only be
    enabled when we give a custom driver flag, `-fuse-simple-log`, to `clang`. For
    example, let''s write the following code, `test.cc`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的目标是使用这些API在我们的代码中 *不* 写入 `#include "simple_log.h"` 行来导入头文件。并且这个特性只有在提供自定义驱动标志
    `-fuse-simple-log` 给 `clang` 时才会启用。例如，让我们写下以下代码，`test.cc`：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Despite its lack of any `#include` directives, it can still be compiled (with
    the `-fuse-simple-log` flag) and run without any problems:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它没有任何 `#include` 指令，但它仍然可以编译（使用 `-fuse-simple-log` 标志）并运行而不会出现任何问题：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Moreover, we can use `-fuse-<log level>-simple-log` /`-fno-use-<log level>-simple-log`
    to include or exclude a function for a specific log level. For example, let''s
    use the same preceding code snippets but add `-fno-use-info-simple-log` when we
    compile the code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以使用 `-fuse-<log level>-simple-log` /`-fno-use-<log level>-simple-log`
    来包含或排除特定日志级别的函数。例如，让我们使用相同的先前代码片段，但在编译代码时添加 `-fno-use-info-simple-log`：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The switch for each log printing function is simply controlled by its surrounding
    `#ifdef` statements in `simple_log.h`. For example, `print_info` will only be
    included if `SLG_ENABLE_INFO` is defined. Later, in the *Translating custom driver
    flags* section, we will show you how these macro definitions are toggled by driver
    flags.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 每个日志打印功能的开关简单地由其周围的 `simple_log.h` 中的 `#ifdef` 语句控制。例如，`print_info` 只有在 `SLG_ENABLE_INFO`
    被定义时才会被包含。在 *翻译自定义驱动标志* 部分，我们将向您展示这些宏定义是如何通过驱动标志切换的。
- en: 'Last but not least, you can specify a custom path to the `simple_log.h` file.
    By default, our feature will include `simple_log.h` in the current folder of the
    source code. You can change this by supplying `-fsimple-log-path=<file path>`
    or `-fuse-simple-log=<file path>`. For example, we want to use an alternative
    version of `simple_log.h` – `advanced_log.h`, which is stored in `/home/user`
    – which provides functions with the same interfaces but different implementations.
    Now, we can use the following commands:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，您可以指定 `simple_log.h` 文件的自定义路径。默认情况下，我们的特性将在源代码的当前文件夹中包含 `simple_log.h`。您可以通过提供
    `-fsimple-log-path=<file path>` 或 `-fuse-simple-log=<file path>` 来更改此设置。例如，我们想要使用
    `simple_log.h` 的一个替代版本 – `advanced_log.h`，它存储在 `/home/user`，提供了相同接口但不同实现的函数。现在，我们可以使用以下命令：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The following section will show you how to change the code in Clang's driver
    so that you can implement these features.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分将向您展示如何更改 Clang 驱动中的代码，以便您可以实现这些功能。
- en: Declaring custom driver flags
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明自定义驱动标志
- en: First, we will lead you through the steps to *declare* custom driver flags such
    as `-fuse-simple-log` and `-fno-use-info-simple-log`. Then, we are going to *wire*
    those flags to the real frontend functionalities.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将引导您通过步骤来 *声明* 自定义驱动标志，例如 `-fuse-simple-log` 和 `-fno-use-info-simple-log`。然后，我们将
    *连接* 这些标志到真正的前端功能。
- en: Clang uses **TableGen** syntax to declare all kinds of compiler flags – both
    driver flags and frontend flags.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Clang 使用 **TableGen** 语法来声明所有类型的编译器标志 – 包括驱动标志和前端标志。
- en: TableGen
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: TableGen
- en: '**TableGen** is a **Domain-Specific Language** (**DSL**) that''s used for declaring
    structural and relational data. To learn more, please check out [*Chapter 4*](B14590_04_Final_JC_ePub.xhtml#_idTextAnchor052),
    *TableGen Development*.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**TableGen** 是一种 **领域特定语言** (**DSL**)，用于声明结构和关系数据。要了解更多信息，请参阅 [*第4章*](B14590_04_Final_JC_ePub.xhtml#_idTextAnchor052)，*TableGen
    开发*。'
- en: 'All these flag declarations are put in `clang/include/clang/Driver/Options.td`.
    Take the common `-g` flag, for example, which tells you that you want to generate
    source-level debug information. For example, it has a declaration like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些标志声明都放在`clang/include/clang/Driver/Options.td`中。以常见的`-g`标志为例，它告诉你你想要生成源级调试信息。例如，它有一个这样的声明：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The TableGen record, `g_Flag`, is created from several TableGen classes: `Flag`,
    `Group`, and `HelpText`. Among them, we are most interested in `Flag`, whose template
    values (`["-"]` and `"g"`) describe the actual command-line flag format. Note
    that when we are declaring a *boolean* flag – the value of this flag is determined
    by its presence and no other values follow – as in this case, we inherit from
    the `Flag` class.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: TableGen记录`g_Flag`是由几个TableGen类创建的：`Flag`、`Group`和`HelpText`。其中，我们最感兴趣的是`Flag`，其模板值（`["-"]`和`"g"`）描述了实际的命令行标志格式。注意，当我们声明一个*布尔*标志时——这个标志的值由其存在决定，没有其他值跟随——就像在这个例子中，我们继承自`Flag`类。
- en: 'In cases where we want to declare a flag that has values that follow an equal
    sign ("="), we inherit from the `Joined` class. For example, the TableGen declaration
    for `-std=<C++ standard name>` looks like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们想要声明一个具有等于号（"="）后跟值的标志的情况下，我们继承自`Joined`类。例如，`-std=<C++ standard name>`的TableGen声明看起来像这样：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Usually, the record names (`std_EQ`, in this case) for these kinds of flags
    have `_EQ` as their suffices.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这类标志的记录名称（如本例中的`std_EQ`）以`_EQ`作为后缀。
- en: Last but not least, the `Flags` (plural) class can be used to specify some properties.
    For example, `CC1Options` in the preceding snippet tells us that this flag can
    also be a frontend flag.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，`Flags`（复数）类可以用来指定一些属性。例如，前面的代码片段中的`CC1Options`告诉我们这个标志也可以是一个前端标志。
- en: 'Now that we''ve learned how driver flags are generally declared, it is time
    to create our own:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何通常声明驱动器标志，是时候创建我们自己的了：
- en: 'First, we are going to deal with the `-fuse-simple-log` flag. Here is how we
    declare it:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将处理`-fuse-simple-log`标志。以下是我们的声明方式：
- en: '[PRE11]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This snippet basically has no differences from the examples we used previously,
    except for the `Group` class and `NoXarchOption`. The former specifies the *logical*
    group this flag belongs to – for example, `f_Group` is for flags starting with
    `-f`. The latter tells us that this flag can *only* be used in the driver. You
    cannot, for example, pass it to the frontend (but how do we pass flags directly
    to the frontend? We will answer this question shortly, at the end of this section).
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个代码片段基本上与我们之前使用的示例没有区别，只是多了`Group`类和`NoXarchOption`。前者指定了这个标志所属的*逻辑*组——例如，`f_Group`是为以`-f`开头的标志。后者告诉我们这个标志*只能*在驱动器中使用。例如，你不能将它传递给前端（但我们如何直接将标志传递给前端？我们将在本节的最后回答这个问题）。
- en: Note that we only declare `-fuse-simple-log` here but not `-fuse-simple-log=<file
    path>` – that will be done in *another* flag that we will introduce shortly.
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们在这里只声明了`-fuse-simple-log`，而没有声明`-fuse-simple-log=<file path>`——这将在稍后介绍的另一个标志中完成。
- en: 'Next, we are dealing with `-fuse-<log level>-simple-log` and `-fno-use-<log
    level>-simple-log`. In both GCC and Clang, it is pretty common to see pairwise
    flags such as `-f<flag name>`/`-fno-<flag name>` to enable or disable a certain
    feature. Therefore, Clang provides a handy TableGen utility – `BooleanFFlag` –
    to make creating pairwise flags easier. Please see the declarations for `-fuse-error-simple-log`/`-fno-use-error-simple-log`
    in the following code:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们处理`-fuse-<log level>-simple-log`和`-fno-use-<log level>-simple-log`。在GCC和Clang中，看到成对标志（如`-f<flag
    name>`/`-fno-<flag name>`）以启用或禁用某个功能是很常见的。因此，Clang提供了一个方便的TableGen实用工具——`BooleanFFlag`——以简化成对标志的创建。请参见以下代码中`-fuse-error-simple-log`/`-fno-use-error-simple-log`的声明：
- en: '[PRE12]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`BooleanFFlag` is a *multiclass* (so make sure you use `defm` rather than `def`
    to create the TableGen record). Under the hood, it creates TableGen records for
    both `-f<flag name>` and `-fno-<flag name>` *at the same time*.'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`BooleanFFlag`是一个*多类*（所以请确保你使用`defm`而不是`def`来创建TableGen记录）。在底层，它同时为`-f<flag
    name>`和`-fno-<flag name>`创建TableGen记录。'
- en: 'Now that we''ve learned how `use_error_simple_log` was created, we can use
    the same trick to create TableGen records for other log levels:'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何创建`use_error_simple_log`，我们可以使用同样的技巧来为其他日志级别创建TableGen记录：
- en: '[PRE13]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, we are declaring the `-fuse-simple-log=<file path>` and `-fsimple-log-path=<file
    path>` flags. In the previous steps, we were only dealing with boolean flags,
    but here, we are creating flags that have values that follow the equal sign, so
    we are using the `Joined` class we introduced earlier:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们声明了`-fuse-simple-log=<文件路径>`和`-fsimple-log-path=<文件路径>`标志。在前面的步骤中，我们只处理布尔标志，但在这里，我们正在创建具有等于号后跟值的标志，因此我们使用了我们之前引入的`Joined`类：
- en: '[PRE14]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Again, flags with values will usually use `_EQ` in their TableGen record name
    suffix.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次，具有值的标志通常在其TableGen记录名称后缀中使用`_EQ`。
- en: That wraps up all the necessary steps for declaring our custom driver flags.
    During Clang's building process, these TableGen directives will be translated
    into C++ enums and other utilities that are used by the driver. For example, `-fuse-simple-log=<file
    path>` will be represented by an enum; that is, `options::OPT_fuse_simple_log_EQ`.
    The next section will show you how to query these flags from all the command-line
    flags given by users and, most importantly, how to translate our custom flags
    into their frontend counterparts.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了声明我们自定义驱动程序标志所需的所有必要步骤。在Clang的构建过程中，这些TableGen指令将被翻译成C++枚举和其他由驱动程序使用的实用程序。例如，`-fuse-simple-log=<文件路径>`将被表示为一个枚举；即`options::OPT_fuse_simple_log_EQ`。下一节将向您展示如何查询用户给出的所有命令行标志，以及最重要的是，如何将我们的自定义标志翻译成其前端对应物。
- en: Translating custom driver flags
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 翻译自定义驱动程序标志
- en: 'Recall that compiler drivers do a lot of things for users under the hood. For
    instance, they figure out the correct toolchain based on the compilation target
    and translate driver flags that have been designated by users, which is what we
    are going to do next. In our case here, we want to include the `simple_log.h`
    header file for users when our newly created `-fuse-simple-log` is given and define
    macro variables such as `SLG_ENABLE_ERROR` to include or exclude certain log printing
    functions, depending on the `-fuse-<log level>-simple-log`/`-fno-use-<log level>-simple-log`
    flags. More specifically, these tasks can be broken down into two parts:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，编译器驱动程序在幕后为用户做了很多事情。例如，它们根据编译目标确定正确的工具链，并将用户指定的驱动程序标志翻译成驱动程序标志，这正是我们接下来要做的。在我们的例子中，当我们的新创建的`-fuse-simple-log`被给出时，我们希望为用户包含`simple_log.h`头文件，并定义宏变量，如`SLG_ENABLE_ERROR`，以根据`-fuse-<日志级别>-simple-log`/`-fno-use-<日志级别>-simple-log`标志包含或排除某些日志打印函数。更具体地说，这些任务可以分为两部分：
- en: 'If `-fuse-simple-log` is given, we are translating it into a frontend flag:'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果给出`-fuse-simple-log`，我们将将其翻译成前端标志：
- en: '[PRE15]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: -include "/other/file.h"
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`-include "/other/file.h"'
- en: '[PRE16]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If either `-fuse-<log level>-simple-log` or `-fno-use-<log level>-simple-log`
    is given – for instance, `-fuse-error-simple-log` – it will be translated into
    the following:'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果给出`-fuse-<日志级别>-simple-log`或`-fno-use-<日志级别>-simple-log`中的任何一个——例如，`-fuse-error-simple-log`——它将被翻译成以下：
- en: '[PRE17]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '-D -fuse-simple-log and -fno-use-<log level>-simple-log are used together,
    for example:'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`-D -fuse-simple-log`和`-fno-use-<日志级别>-simple-log`一起使用，例如：'
- en: '[PRE18]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'They will be translated into the following code:'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它们将被翻译成以下代码：
- en: '[PRE19]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Last but not least, we also allow the following combinations:'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们还允许以下组合：
- en: '[PRE20]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'That is, we only enable a single log printing function without using `-fuse-simple-log`
    (instead of using the latter flag and subtracting two other log printing functions)
    and use a custom simple log header file. These driver flags will be translated
    into the following code:'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 也就是说，我们只启用单个日志打印函数，而不使用`-fuse-simple-log`（而不是使用该标志并减去两个其他日志打印函数），并使用自定义简单日志头文件。这些驱动程序标志将被翻译成以下代码：
- en: '[PRE21]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The aforementioned rules and combinations of flags can actually be handled in
    a pretty elegant way, albeit being complex at first glance. We will show you how
    to do this shortly.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述规则和标志的组合实际上可以以一种相当优雅的方式处理，尽管乍一看可能很复杂。我们很快就会向您展示如何做到这一点。
- en: '[PRE22]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now that we have learned *what* frontend flags we are going to translate to,
    it is time to learn *how* to do these translations.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了将要翻译的前端标志是什么，是时候学习如何进行这些翻译了。
- en: The place where many driver flags translations happen is inside the `driver::tools::Clang`
    C++ class. More specifically, this happens in its `Clang::ConstructJob` method,
    which is located in the `clang/lib/Driver/ToolChains/Clang.cpp` file.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 许多驱动程序标志翻译发生的地方是在`driver::tools::Clang` C++类内部。更具体地说，这发生在其`Clang::ConstructJob`方法中，该方法位于`clang/lib/Driver/ToolChains/Clang.cpp`文件中。
- en: About driver::tools::Clang
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 关于driver::tools::Clang
- en: Some of the most prominent questions for this C++ class are probably, what *concept*
    does it represent? Why is it put under the folder named *ToolChains*? Does that
    mean it is also a toolchain? While we will answer these questions in detail in
    the next section, *Adding a custom toolchain*, for now, you can just think of
    it as the representative of Clang's frontend. This (kind of) explains why it is
    responsible for translating driver flags into frontend ones.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个 C++ 类，最突出的问题可能包括：它代表什么 *概念*？为什么它被放在名为 *ToolChains* 的文件夹下？这意味着它也是一个工具链吗？虽然我们将在下一节详细回答这些问题，*添加自定义工具链*，但到目前为止，你只需将其视为
    Clang 前端的代表。这（某种程度上）解释了为什么它负责将驱动标志转换为前端标志。
- en: 'Here are the steps to translate our custom driver flags. The following code
    can be inserted anywhere within the `Clang::ConstructJob` method, before the `addDashXForInput`
    function is called, which starts to wrap up the translation process:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是将我们的自定义驱动标志翻译的步骤。以下代码可以插入到 `Clang::ConstructJob` 方法中的任何位置，在调用 `addDashXForInput`
    函数之前，该函数开始封装翻译过程：
- en: 'First, we are defining a help class – `SimpleLogOpts` – to carry our custom
    flag''s information:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义了一个帮助类 – `SimpleLogOpts` – 来携带我们的自定义标志信息：
- en: '[PRE23]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `bool` fields in `SimpleLogOpts` – `Error`, `Info`, and `Debug` – represent
    log levels that are enabled by our custom flags. We also define a helper function
    `SimpleLogOpts::All()` to create a `SimpleLogOpts` in which all log levels are
    enabled, and a `bool` type conversion operator such that we can use a cleaner
    syntax, shown here, to tell us if any of the levels are enabled:'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`SimpleLogOpts` 中的 `bool` 字段 – `Error`、`Info` 和 `Debug` – 代表由我们的自定义标志启用的日志级别。我们还定义了一个辅助函数
    `SimpleLogOpts::All()`，用于创建一个所有日志级别都启用的 `SimpleLogOpts`，以及一个 `bool` 类型转换运算符，这样我们就可以使用更简洁的语法，如下所示，来告诉我们是否启用了任何级别：'
- en: '[PRE24]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Let's handle the simplest case first – the `-fuse-simple-log` flag. In this
    step, we are only going to turn on all the log levels in `SLG` when we see a `-fuse-simple-log`
    flag.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先处理最简单的情况 – `-fuse-simple-log` 标志。在这个步骤中，当我们看到 `-fuse-simple-log` 标志时，我们只会在
    `SLG` 中打开所有日志级别。
- en: 'Inside the `Clang::ConstructJob` method, the driver flags given by users are
    stored in the `Args` variable (one of the arguments for `ConstructJob`), which
    is of the `ArgList` type. There are many ways to query `Args`, but here, since
    we only care about the *presence* of `-fuse-simple-log`, `hasArg` is the most
    suitable option:'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `Clang::ConstructJob` 方法内部，用户提供的驱动标志存储在 `Args` 变量中（`ConstructJob` 的一个参数），该变量是
    `ArgList` 类型。查询 `Args` 有许多方法，但在这里，因为我们只关心 `-fuse-simple-log` 的 *存在性*，所以 `hasArg`
    是最合适的选择：
- en: '[PRE25]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Each flag we declared in the previous code via TableGen syntax will be represented
    by a unique *enum* under the `options` namespace. In this case, the enum value
    is `OPT_fuse_simple_log`. The name of the enum value is usually `OPT_`, followed
    by the `def` or `defm`) when we were declaring the flag. The `ArgList::hasArg`
    function will return true if the given flag identifier is present in the input
    driver flags.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们通过 TableGen 语法声明的每个标志都将由 `options` 命名空间下的一个唯一的 *enum* 来表示。在这种情况下，枚举值是
    `OPT_fuse_simple_log`。枚举值的名称通常是 `OPT_`，后面跟着我们在声明标志时使用的 `def` 或 `defm`)。如果 `ArgList::hasArg`
    函数返回 true，则表示给定的标志标识符存在于输入驱动标志中。
- en: 'In addition to `-fuse-simple-log`, we also need to turn on all the log levels
    when `-fuse-simple-log=<file path>` is given, even though we are only going to
    handle the file path that follows later. Thus, we will change the preceding snippet
    into the following:'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 除了 `-fuse-simple-log` 之外，当提供 `-fuse-simple-log=<文件路径>` 时，我们还需要打开所有日志级别，尽管我们稍后只处理跟随的文件路径。因此，我们将前面的代码片段更改为以下内容：
- en: '[PRE26]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`ArgList::hasArg` can actually take multiple flag identifiers and return true
    if *any* of them are present in the input driver flags. And again, the `-fuse-simple-log=<…>`
    flag is represented by `OPT_fuse_simple_log_EQ` since its TableGen record name
    is `fuse_simple_log_EQ`.'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ArgList::hasArg` 实际上可以接受多个标志标识符，如果 *任何* 一个存在于输入驱动标志中，则返回 true。再次强调，`-fuse-simple-log=<…>`
    标志由 `OPT_fuse_simple_log_EQ` 表示，因为它的 TableGen 记录名称是 `fuse_simple_log_EQ`。'
- en: 'Next, we are going to handle `-fuse-<log level>-simple-log`/`-fno-use-<log
    level>-simple-log`. Taking the error level, as an example (flags for other levels
    are used in the exact same way, so we are not showing them here), here, we are
    leveraging the `ArgList::hasFlag` function:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将处理 `-fuse-<日志级别>-simple-log`/`-fno-use-<日志级别>-simple-log`。以错误级别为例（其他级别的标志使用完全相同的方式，所以这里不展示），在这里，我们利用了
    `ArgList::hasFlag` 函数：
- en: '[PRE27]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `hasFlag` function will return true or false if the flag that's represented
    by the first (`OPT_fuse_error_simple_log` here) or second (`OPT_fno_use_error_simple_log`
    here) argument is present in the input driver flags, respectively.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`hasFlag` 函数将根据第一个（此处为 `OPT_fuse_error_simple_log`）或第二个（此处为 `OPT_fno_use_error_simple_log`）参数是否存在于输入驱动标志中返回
    true 或 false。'
- en: If *neither* of the flags are present, `hasFlag` will return a default value
    that's designated by its third argument (`SLG.Error`, in this case).
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果两个标志都不存在，`hasFlag` 将返回由其第三个参数指定的默认值（在这种情况下为 `SLG.Error`）。
- en: 'Using this mechanism, we have already implemented some of the (complex) rule
    and flag combinations we mentioned earlier in this section:'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用这种机制，我们已经在本节中提到的（复杂的）规则和标志组合中实现了一些：
- en: a) The `-fno-use-<log level>-simple-log` flags can disable certain log printing
    function(s) when `-fuse-simple-log` – which effectively includes all the log printing
    functions in the first place – is present.
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a) `-fno-use-<log level>-simple-log` 标志可以禁用某些日志打印功能，当 `-fuse-simple-log`（最初实际上包括所有日志打印功能）存在时。
- en: b) Even *without* the presence of `-fuse-simple-log`, we can still enable individual
    log printing functions by using the `-fuse-<log level>-simple-log` flag(s).
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b) 即使没有 `-fuse-simple-log` 的存在，我们也可以通过使用 `-fuse-<log level>-simple-log` 标志来启用单个日志打印功能。
- en: 'Currently, we are only playing around with the `SimpleLogOpts` data structure.
    Starting from the next step, we will start to generate frontend flags according
    to the `SimpleLogOpts` instance we have built so far. The first frontend flag
    we are generating here is `-include <file path>`. First, it only makes sense to
    proceed if at least one log level has been enabled. Therefore, we will wrap the
    generation of `-include` with an `if` statement by checking on `SLG`, as we explained
    earlier:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，我们只是在玩弄 `SimpleLogOpts` 数据结构。从下一步开始，我们将根据我们迄今为止构建的 `SimpleLogOpts` 实例开始生成前端标志。我们在这里生成的前端第一个标志是
    `-include <file path>`。首先，如果至少已经启用了一个日志级别，那么继续才有意义。因此，我们将通过检查 `SLG`（正如我们之前解释的那样）用
    `if` 语句包装 `-include` 的生成：
- en: '[PRE28]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `CmdArgs` (a local variable – with a vector-like type – inside `Clang::ConstructJob`)
    is the place where we will put our `CmdArgs`) will be treated as `argv`, which
    we can see in the `main` function of C/C++, and any white space within a single
    argument will create failures when those arguments are realized.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`CmdArgs`（`Clang::ConstructJob` 内的一个局部变量，具有类似向量的类型）是我们将放置 `CmdArgs` 的地方，它将被视为
    `argv`，我们可以在 C/C++ 的 `main` 函数中看到，任何单个参数内的空白都会在参数实现时造成失败。'
- en: 'Instead, we are pushing the path to a simple log header file *separately*,
    as follows:'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 相反，我们正在单独推送简单日志头文件的路径，如下所示：
- en: '[PRE29]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `ArgList::getLastArg` function will retrieve the value (the last value,
    if there are multiple occurrences of the same flag), follow a given flag, and
    return null if none of those flags are present. For instance, in this case, the
    flag is `-fuse-simple-log=` (`-fsimple-log-path=` in the second argument is just
    the *alias* flag of the first one).
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ArgList::getLastArg` 函数将检索值（如果有多个相同的标志，则为最后一个值），跟随给定的标志，如果这些标志都不存在，则返回 null。例如，在这种情况下，标志是
    `-fuse-simple-log=`（第二个参数中的 `-fsimple-log-path=` 只是第一个标志的*别名*标志）。'
- en: 'Finally, we are generating frontend flags that control which log printing functions
    should be enabled. Again, we are only showing the code for one of the log levels
    here since other levels are using the same approach:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们正在生成前端标志，以控制哪些日志打印功能应该被启用。同样，我们在这里只展示了其中一个日志级别的代码，因为其他级别使用的是相同的方法：
- en: '[PRE30]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: These are basically all the modifications that are required for our project.
    The final thing we must do before we move on is verify our work. Recall the `-###`
    command-line flag, which is used to print all the flags that are passed to the
    frontend. We are using it here to see if our custom driver flags are translated
    properly.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这些基本上是我们项目所需的全部修改。在我们继续之前，我们必须验证我们的工作。回想一下 `-###` 命令行标志，它用于打印传递给前端的所有标志。我们在这里使用它来查看我们的自定义驱动标志是否被正确转换。
- en: 'First, let''s try this command:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们尝试这个命令：
- en: '[PRE31]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output should contain these strings:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应包含这些字符串：
- en: '[PRE32]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, let''s try the following command:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试以下命令：
- en: '[PRE33]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Tthe output should contain these strings:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应包含这些字符串：
- en: '[PRE34]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Finally, let''s use the following command:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们使用以下命令：
- en: '[PRE35]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The output should contain the following strings :'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应包含以下字符串：
- en: '[PRE36]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the last subsection of this section, we are going to talk about some miscellaneous
    ways to pass flags to the frontend.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的最后一个小节中，我们将讨论一些向前端传递标志的杂项方法。
- en: Passing flags to the frontend
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向前端传递标志
- en: In the previous sections, we showed you the differences between driver flags
    and frontend flags, how they are related, and how Clang's driver translates the
    former into the latter. At this point, you might be wondering, can we skip through
    the driver and pass the flags directly to the frontend? What flags are we allowed
    to pass?
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几节中，我们展示了驱动程序标志和前端标志之间的区别，它们是如何相关的，以及 Clang 的驱动程序如何将前者转换为后者。在这个时候，你可能想知道，我们能否跳过驱动程序，直接将标志传递给前端？我们允许传递哪些标志？
- en: 'The short answer for the first question is *yes, and you have actually already
    done that several times in previous chapters*. Recall that in [*Chapter 7*](B14590_07_Final_JC_ePub.xhtml#_idTextAnchor093),
    *Handling AST*, we developed a plugin – more specifically, an AST plugin. We were
    using command-line arguments like the one shown here to load and run our plugin
    inside Clang:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个问题的简短答案是**是的，实际上你已经在之前的章节中这样做了好几次**。回想一下，在[*第7章*](B14590_07_Final_JC_ePub.xhtml#_idTextAnchor093)，*处理抽象语法树*中，我们开发了一个插件——更具体地说，是一个抽象语法树插件。我们使用像这里显示的命令行参数来在
    Clang 中加载和运行我们的插件：
- en: '[PRE37]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You might already find that, somehow, we need to precede a `-Xclang` flag before
    the `-plugin` and `ternary-converter` arguments. And the answer is simple: this
    is because `-plugin` (and its value, `ternary-converter`) is a *frontend-only*
    flag.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经发现，我们需要在 `-plugin` 和 `ternary-converter` 参数之前先使用 `-Xclang` 标志。答案是简单的：这是因为
    `-plugin`（及其值 `ternary-converter`）是一个**仅前端**标志。
- en: 'To pass a flag directly to the frontend, we can put `-Xclang` in front of it.
    But there is a caveat of using `-Xclang`: a single `-Xclang` will only relay *one*
    succeeding command-line argument (a string without any whitespace) to the frontend.
    In other words, you cannot rewrite the preceding plugin loading example like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要直接将标志传递给前端，我们可以在其前面加上 `-Xclang`。但是使用 `-Xclang` 有一个注意事项：单个 `-Xclang` 只会转达**一个**随后的命令行参数（一个没有空白的字符串）到前端。换句话说，你不能像这样重写前面的插件加载示例：
- en: '[PRE38]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This is because `-Xclang` will only transfer `-plugin` to the frontend and leave
    `ternary-converter` behind, in which case Clang will fail to know which plugin
    to run.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 `-Xclang` 只会将 `-plugin` 传递到前端，而将 `ternary-converter` 留在后面，在这种情况下，Clang
    将无法知道要运行哪个插件。
- en: Another way to pass flags directly to the frontend would be using `-cc1`. Recall
    that when we were using `-###` to print out the frontend flags that had been translated
    by the driver in the previous sections, among those frontend flags, the first
    one that followed the path to the `clang` executable was always `-cc1`. This flag
    effectively collects all the command-line arguments and sends them to the frontend.
    Though this looks handy – there's no need to prefix every flag we want to pass
    to the frontend with `-Xclang` anymore – be careful that you are not allowed to
    mix any *driver-only* flags inside that list of flags. For example, earlier in
    this section, when we were declaring our `-fuse-simple-log` flag in TableGen syntax,
    we annotated the flag with `NoXarchOption`, which stated that it can only be used
    by the driver. In that case, `-fuse-simple-log` cannot appear after `-cc1`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 向前端直接传递标志的另一种方法是将 `-cc1` 使用。回想一下，当我们使用 `-###` 在前几节打印由驱动程序翻译的前端标志时，在这些前端标志中，第一个跟随
    `clang` 可执行文件路径的总是 `-cc1`。这个标志有效地收集所有命令行参数并将它们发送到前端。虽然这看起来很方便——我们不再需要将每个想要传递给前端标志的前缀为
    `-Xclang`——但请注意，你不允许在该标志列表中混合任何**仅驱动程序**标志。例如，在本节早期，当我们使用 TableGen 语法声明我们的 `-fuse-simple-log`
    标志时，我们用 `NoXarchOption` 注释了该标志，这表示它只能由驱动程序使用。在这种情况下，`-fuse-simple-log` 不能出现在 `-cc1`
    之后。
- en: 'This leads us to our final question: what flags can be used by either the driver
    or the frontend, and what flags are accepted by both? The answer can actually
    be seen via `NoXarchOption`, which was just mentioned. When declaring flags –
    either for the driver or the frontend – in TableGen syntax, you can use the `Flags<…>`
    TableGen class and its template parameters to enforce some constraints. For instance,
    using the following directives, you can *prevent* the `-foo` flag from being used
    by the driver:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了我们的最终问题：驱动程序或前端可以使用哪些标志，以及哪些标志被两者都接受？答案实际上可以通过刚刚提到的 `NoXarchOption` 来看到。在
    TableGen 语法中声明标志时——无论是为驱动程序还是前端——你可以使用 `Flags<…>` TableGen 类及其模板参数来强制执行一些约束。例如，使用以下指令，你可以*阻止*驱动程序使用
    `-foo` 标志：
- en: '[PRE39]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In addition to `NoXarchOption` and `NoDriverOption`, here are some other common
    annotations you can use in `Flags<…>`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `NoXarchOption` 和 `NoDriverOption` 之外，这里还有一些你可以在 `Flags<…>` 中使用的其他常见注释：
- en: '`CoreOption`: States that this flag can be shared by both `clang` and `clang-cl`.
    `clang-cl` is an interesting driver that is compatible with the command-line interface
    (including command-line arguments) used by **MSVC** (the compiler framework used
    by Microsoft Visual Studio).'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CoreOption`：表示此标志可以被 `clang` 和 `clang-cl` 共享。`clang-cl` 是一个有趣的驱动程序，它与 Microsoft
    Visual Studio 使用的命令行界面（包括命令行参数）兼容。'
- en: '`CC1Option`: States that this flag can be accepted by the frontend. It doesn''t
    say it''s a frontend-only flag, though.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CC1Option`：表示此标志可以被前端接受。但这并不意味着它是一个仅限前端使用的标志。'
- en: '`Ignored`: States that this flag is going to be ignored by Clang''s driver
    (but continue the compilation process). GCC has many flags that are not supported
    in Clang (either obsolete or just not applicable). However, Clang actually tries
    to *recognize* those flags but does nothing except show a warning message about
    a lack of implementation. The rationale behind this is we hope that Clang can
    be a *drop-in* replacement for GCC without the need to modify the existing building
    scripts in many projects (without this compatibility layer, Clang will terminate
    the compilation when it sees unknown flags).'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ignored`：表示此标志将被 Clang 驱动程序忽略（但继续编译过程）。GCC 有许多标志在 Clang 中不受支持（要么已过时，要么根本不适用）。然而，Clang
    实际上试图*识别*这些标志，但除了显示关于缺少实现的警告消息外，不做任何操作。背后的理由是我们希望 Clang 可以在不修改许多项目中现有的构建脚本的情况下（没有这个兼容层，当
    Clang 看到未知标志时将终止编译）。 '
- en: In this section, we learned how to add custom flags for Clang's driver and implemented
    the logic to translate them into frontend flags. This skill is pretty useful when
    you want to toggle custom features in a more straightforward and clean way.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何为 Clang 的驱动程序添加自定义标志，并实现了将它们转换为前端标志的逻辑。当你想要以更直接和简洁的方式切换自定义功能时，这项技能非常有用。
- en: In the next section, we are going to learn the role of a toolchain and how it
    works in Clang by creating our own custom one.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将通过创建自己的自定义工具链来学习工具链的作用以及它在 Clang 中的工作原理。
- en: Adding a custom toolchain
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加自定义工具链
- en: In the previous section, we learned how to add custom flags for the driver in
    Clang and learned how the driver translated them into flags that are accepted
    by the frontend. In this section, we are going to talk about the toolchain – an
    important module inside the driver that helps it adapt to different platforms.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们学习了如何在 Clang 中为驱动程序添加自定义标志，并了解了驱动程序如何将它们转换为前端接受的标志。在本节中，我们将讨论工具链——驱动程序内部的一个重要模块，它帮助驱动程序适应不同的平台。
- en: 'Recall that in the first section of this chapter, *Understanding drivers and
    toolchains in Clang*, we showed the relationships between driver and toolchains
    in *Figure 8.1*: the driver chooses a proper toolchain based on the target platform
    before leveraging its knowledge to do the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，在本章的第一节“理解 Clang 中的驱动程序和工具链”中，我们展示了驱动程序和工具链之间的关系——*图 8.1*：驱动程序根据目标平台选择合适的工具链，然后利用其知识执行以下操作：
- en: Execute the correct *assembler*, *linker*, or any tool that is required for
    the target code's generation.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行正确的*汇编器*、*链接器*或任何用于生成目标代码所需的工具。
- en: Pass *platform-specific* flags to the compiler, assembler, or linker.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将*平台特定的*标志传递给编译器、汇编器或链接器。
- en: This information is crucial for building the source code since each platform
    might have its own unique characteristics, such as system library paths and supported
    assembler/linker variants. Without them, a correct executable or library cannot
    even be generated.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这些信息对于构建源代码至关重要，因为每个平台可能都有其独特的特性，例如系统库路径和支持的汇编器/链接器变体。没有它们，甚至无法生成正确的可执行文件或库。
- en: This section hopes to teach you how to create Clang toolchains for custom platforms
    in the future. The toolchain framework in Clang is powerful enough to be adapted
    to a wide variety of use cases. For example, you can create a toolchain that resembles
    conventional compilers on Linux – including using GNU AS to assemble and GNU LD
    for linking – without you needing to make many customizations to a default library
    path or compiler flags. On the other hand, you can have an exotic toolchain that
    does not even use Clang to compile source code and uses a propriety assembler
    and linker with uncommon command-line flags. This section will try to use an example
    that catches the most common use cases without missing this framework's flexible
    aspect.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 本节旨在教会你如何在将来为定制平台创建 Clang 工具链。Clang 的工具链框架足够强大，可以适应各种用例。例如，你可以创建一个类似于 Linux
    上传统编译器的工具链——包括使用 GNU AS 进行汇编和 GNU LD 进行链接——而无需对默认库路径或编译器标志进行许多自定义。另一方面，你可以有一个异国风情的工具链，甚至不使用
    Clang 编译源代码，并使用专有汇编器和链接器以及不常见的命令行标志。本节将尝试使用一个示例，以涵盖最常见的用例，同时不遗漏这个框架的灵活方面。
- en: 'This section is organized as follows: as usual, we will start with an overview
    of the project we are going to work on. After that, we will break down our project
    workload into three parts – adding custom compiler options, setting up a custom
    assembler, and setting up a custom linker – before we put them together to wrap
    up this section.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 本节组织如下：通常，我们将从将要工作的项目概述开始。之后，我们将把项目工作量分解为三个部分——添加自定义编译器选项、设置自定义汇编器和设置自定义链接器——在我们把它们组合起来完成本节之前。
- en: System requirements
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 系统要求
- en: As another friendly reminder, the following project can only work on Linux systems.
    Please make sure OpenSSL is installed.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个友好的提醒，以下项目只能在 Linux 系统上运行。请确保已安装 OpenSSL。
- en: Project overview
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目概述
- en: We are going to create a toolchain called `.tarbell` file) during the linking
    phase.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在链接阶段创建一个名为 `.tarbell` 文件的工具链。
- en: Base64
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Base64
- en: '**Base64** is an encoding scheme that is commonly used to convert binary into
    plain text. It can be easily transmitted in a context that does not support binary
    format (for example, HTTP headers). You can also apply Base64 to normal textual
    files, just like in our case.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**Base64** 是一种常用的编码方案，用于将二进制转换为纯文本。它可以在不支持二进制格式的环境中轻松传输（例如，HTTP 头部）。你还可以将 Base64
    应用于普通文本文件，就像在我们的案例中一样。'
- en: This toolchain is basically useless in production environments. It's merely
    a demo that emulates common situations a developer might encounter when they're
    creating a new toolchain for custom platforms.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工具链在生产环境中基本上是没用的。它仅仅是一个演示，模拟了开发者在为定制平台创建新工具链时可能遇到的一些常见情况。
- en: 'This toolchain is enabled by a custom driver flag, `-zipline`/`--zipline`.
    When the flag is provided, first, the compiler will implicitly add the `my_include`
    folder to your home directory as one of the header files searching the path. For
    example, recall that in the previous section, *Adding custom driver flags*, our
    custom `-fuse-simple-log` flag would implicitly include a header file, `simple_log.h`,
    in the input source code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 此工具链通过自定义驱动器标志 `-zipline`/`--zipline` 启用。当提供此标志时，首先，编译器会隐式地将 `my_include` 文件夹添加到你的主目录中，作为搜索头文件的路径之一。例如，回想一下在上一节中，*添加自定义驱动器标志*，我们的自定义
    `-fuse-simple-log` 标志会隐式地包含一个头文件，`simple_log.h`，在输入源代码中：
- en: '[PRE40]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'However, if `simple_log.h` is not in the current directory, as in the preceding
    snippet, we need to specify its full path via another flag:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果 `simple_log.h` 不在当前目录中，就像前面的片段中那样，我们需要通过另一个标志指定其完整路径：
- en: '[PRE41]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'With the help of Zipline, you can put `simple_log.h` inside `/home/<user name>/my_include`,
    and the compiler will find it:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Zipline 的帮助下，你可以将 `simple_log.h` 放在 `/home/<用户名>/my_include` 中，编译器将找到它：
- en: '[PRE42]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The second feature of Zipline is that the `clang` executable will compile the
    source code into assembly code that''s encoded by Base64 under the `-c` flag,
    which *was* supposed to assemble the assembly file – coming out from the compiler
    – into an object file. Here is an example command:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Zipline的第二个特性是，在`-c`标志下，`clang`可执行文件会将源代码编译成由Base64编码的汇编代码，这个标志原本是用来将汇编文件（来自编译器）组装成目标文件的。以下是一个示例命令：
- en: '[PRE43]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The preceding `file` command showed that the generated file, `test.o`, from
    the previous invocation of `clang`, is no longer a binary format object file.
    The content of this file is now a Base64-encoded version of the assembly code
    that was generated from the compiler's backend.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`file`命令显示，来自之前`clang`调用的生成文件`test.o`不再是二进制格式对象文件。现在这个文件的内容是编译器后端生成的汇编代码的Base64编码版本。
- en: 'Finally, Zipline replaces the original linking stage with a custom one that
    packages and compresses the aforementioned Base64-encoded assembly files into
    a `.zip` file. Here is an example:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Zipline用自定义的链接阶段替换了原始的链接阶段，将上述Base64编码的汇编文件打包并压缩成`.zip`文件。以下是一个示例：
- en: '[PRE44]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: If you unzip `test.zip`, you will find that those extracted files are Base64-encoded
    assembly files, as we mentioned earlier.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你解压`test.zip`，你会发现那些提取的文件是Base64编码的汇编文件，正如我们之前提到的。
- en: 'Alternatively, we can use Linux''s `tar` and `gzip` utilities to package and
    compress them in Zipline. Let''s look at an example:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以在Zipline中使用Linux的`tar`和`gzip`实用工具来打包和压缩它们。让我们看看一个示例：
- en: '[PRE45]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: By using the existing `-fuse-ld=<linker name>` flag, we can choose between using
    `zip` or `tar` and `gzip` for our custom linking phase.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用现有的`-fuse-ld=<linker name>`标志，我们可以在自定义链接阶段之间选择使用`zip`或`tar`和`gzip`。
- en: In the next section, we are going to create the skeleton code for this toolchain
    and show you how to add an additional folder to the header file searching path.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将为这个工具链创建骨架代码，并展示如何将额外的文件夹添加到头文件搜索路径中。
- en: Creating the toolchain and adding a custom include path
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建工具链并添加自定义包含路径
- en: 'In this section, we are going to create the skeleton for our Zipline toolchain
    and show you how to add an extra include folder path – more specifically, an extra
    **system include path** – to the compilation stage within Zipline. Here are the
    detailed steps:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将为我们的Zipline工具链创建骨架，并展示如何将额外的包含文件夹路径——更具体地说，一个额外的**系统包含路径**——添加到Zipline的编译阶段。以下是详细步骤：
- en: 'Before we add a real toolchain implementation, don''t forget that we are going
    to use a custom driver flag, `-zipline`/`--zipline`, to enable our toolchain.
    Let''s use the same skill we learned in the previous section, *Adding custom driver
    flags*, to do that. Inside `clang/include/clang/Driver/Options.td`, we will add
    the following lines:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们添加实际的工具链实现之前，别忘了我们将使用自定义驱动程序标志`-zipline`/`--zipline`来启用我们的工具链。让我们使用在上一节中学到的相同技能，*添加自定义驱动程序标志*，来完成这个任务。在`clang/include/clang/Driver/Options.td`内部，我们将添加以下行：
- en: '[PRE46]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Again, `Flag` tells us this is a boolean flag and `NoXarchOption` tells us that
    this flag is driver-only. We will use this driver flag shortly.
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次强调，`Flag`告诉我们这是一个布尔标志，而`NoXarchOption`告诉我们这个标志仅适用于驱动程序。我们将在不久的将来使用这个驱动程序标志。
- en: 'Toolchains in Clang are represented by the `clang::driver::ToolChain` class.
    Each toolchain supported by Clang is derived from it, and their source files are
    put under the `clang/lib/Driver/ToolChains` folder. We are going to create two
    new files there: `Zipline.h` and `Zipline.cpp`.'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Clang中，工具链由`clang::driver::ToolChain`类表示。Clang支持的每个工具链都从它派生出来，它们的源文件都放在`clang/lib/Driver/ToolChains`文件夹下。我们将在那里创建两个新文件：`Zipline.h`和`Zipline.cpp`。
- en: 'For `Zipline.h`, let''s add the following skeleton code first:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`Zipline.h`，我们首先添加以下骨架代码：
- en: '[PRE47]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The class we created here, `ZiplineToolChain`, is derived from `Generic_ELF`,
    which is a subclass of `ToolChain` that''s specialized for systems that use ELF
    as its execution format – including Linux. In addition to the parent class, there
    are three important methods that we are going to implement in this or later sections:
    `AddClangSystemIncludeArgs`, `buildAssembler`, and `buildLinker`.'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在这里创建的类`ZiplineToolChain`是从`Generic_ELF`派生出来的，`Generic_ELF`是`ToolChain`的一个子类，专门用于使用ELF作为其执行格式的系统——包括Linux。除了父类之外，我们将在本节或后续章节中实现三个重要方法：`AddClangSystemIncludeArgs`、`buildAssembler`和`buildLinker`。
- en: 'The `buildAssembler` and `buildLinker` methods generate `Tool` instances that
    represent the `AddClangSystemIncludeArgs` method. Inside `Zipline.cpp`, we will
    add its method body:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`buildAssembler` 和 `buildLinker` 方法生成代表 `AddClangSystemIncludeArgs` 方法的 `Tool`
    实例。在 `Zipline.cpp` 中，我们将添加其方法体：'
- en: '[PRE48]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The only thing we are doing here is calling the `addSystemInclude` function
    with the full path to the `my_include` folder located in the home directory. Since
    each user's home directory is different, we are using the `sys::fs::expand_tilde`
    helper function to expand `~/my_include` – where `~` represents the home directory
    in Linux and Unix systems – in the absolute path. The `addSystemInclude` function,
    on the other hand, helps you add `"-internal-isystem" "/path/to/my_include"` flags
    to the list of all the frontend flags. The `-internal-isystem` flag is used for
    designating folders of system header files, including standard library headers
    and some platform-specific header files.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在这里所做的唯一事情是调用 `addSystemInclude` 函数，并传入位于主目录中的 `my_include` 文件夹的完整路径。由于每个用户的家目录都不同，我们使用
    `sys::fs::expand_tilde` 辅助函数来展开 `~/my_include` – 其中 `~` 代表 Linux 和 Unix 系统中的主目录
    – 到绝对路径。另一方面，`addSystemInclude` 函数可以帮助你将 `"-internal-isystem" "/path/to/my_include"`
    标志添加到所有前端标志的列表中。`-internal-isystem` 标志用于指定系统头文件文件夹，包括标准库头文件和一些特定平台的头文件。
- en: 'Last but not least, we need to teach the driver to use the Zipline toolchain
    when it sees our newly created `-zipline`/`--zipline` driver flag. We are going
    to modify the `Driver::getToolChain` method inside `clang/lib/Driver/Driver.cpp`
    to do so. The `Driver::getToolChain` method contains a huge switch case for selecting
    different toolchains based on the target operating system and hardware architecture.
    Please navigate to the code handling the Linux system; we are going to add an
    extra branch condition there:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们需要教会驱动程序在看到我们新创建的 `-zipline`/`--zipline` 驱动标志时使用 Zipline 工具链。我们将修改
    `clang/lib/Driver/Driver.cpp` 中的 `Driver::getToolChain` 方法来实现这一点。`Driver::getToolChain`
    方法包含一个巨大的 switch case，用于根据目标操作系统和硬件架构选择不同的工具链。请导航到处理 Linux 系统的代码；我们将在那里添加一个额外的分支条件：
- en: '[PRE49]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The extra `else-if` statement basically says that if the target OS is Linux,
    then we will use Zipline when the `-zipline`/`--zipline` flag is given.
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个额外的 `else-if` 语句基本上表示，如果目标操作系统是 Linux，那么当给出 `-zipline`/`--zipline` 标志时，我们将使用
    Zipline。
- en: With that, you have added the skeleton of Zipline and successfully told the
    driver to use Zipline when a custom driver flag is given. On top of that, you've
    also learned how to add extra system library folders to the header file search
    path.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，你已经添加了 Zipline 的骨架，并成功告诉驱动程序在给出自定义驱动标志时使用 Zipline。除此之外，你还学习了如何将额外的系统库文件夹添加到头文件搜索路径中。
- en: In the next section, we are going to create a custom assembling stage and connect
    it to the toolchain we created here.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将创建一个自定义汇编阶段并将其连接到我们在这里创建的工具链。
- en: Creating a custom assembling stage
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义汇编阶段
- en: As we mentioned in the *Project overview* section, instead of doing regular
    assembling to convert assembly code into an object file in the assembling stage
    of Zipline, we are invoking a program to convert the assembly file we generated
    from Clang into its Base64-encoded counterpart. Before we go deeper into its implementation,
    let's learn how each of these *stages* in a toolchain is represented.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 *项目概述* 部分中提到的，在 Zipline 的汇编阶段，我们不是进行常规的汇编来将汇编代码转换为对象文件，而是调用一个程序将我们从 Clang
    生成的汇编文件转换为它的 Base64 编码的对应文件。在我们深入其实现之前，让我们先了解工具链中每个 *阶段* 的表示方法。
- en: 'In the previous section, we learned that a toolchain in Clang is represented
    by the `ToolChain` class. Each of these `ToolChain` instances is responsible for
    telling the driver what *tool* to run in each compilation stage – namely compiling,
    assembling, and linking. And this information is encapsulated inside a `clang::driver::Tool`
    type object. Recall the `buildAssembler` and `buildLinker` methods in the previous
    section; they return the very `Tool` type objects that depict the actions to perform
    and the tool to run in the assembling and linking stages, respectively. In this
    section, we will show you how to implement the `Tool` object that''s returned
    by `buildAssembler`. Let''s get started:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们了解到在 Clang 中，工具链由 `ToolChain` 类表示。每个这些 `ToolChain` 实例都负责告诉驱动程序在每个编译阶段运行哪个
    *工具* —— 也就是编译、汇编和链接。这些信息封装在一个 `clang::driver::Tool` 类型的对象中。回想一下上一节中的 `buildAssembler`
    和 `buildLinker` 方法；它们返回的正是描述汇编和链接阶段要执行的操作以及要运行的工具的 `Tool` 类型对象。在本节中，我们将向您展示如何实现由
    `buildAssembler` 返回的 `Tool` 对象。让我们开始吧：
- en: 'Let''s go back to `Zipline.h` first. Here, we are adding an extra class, `Assembler`,
    inside the `clang::driver::tools::zipline` namespace:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先回到 `Zipline.h`。在这里，我们在 `clang::driver::tools::zipline` 命名空间内添加了一个额外的类，`Assembler`：
- en: '[PRE50]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Be careful because the newly created `Assembler` resides in the `clang::driver::tools::zipline`
    namespace, while `ZiplineToolChain`, which we created in the previous section,
    is in `clang::driver::toolchains`.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，新创建的 `Assembler` 位于 `clang::driver::tools::zipline` 命名空间中，而我们在上一节中创建的 `ZiplineToolChain`
    位于 `clang::driver::toolchains` 中。
- en: The `Assembler::ConstructJob` method is where we will put our logic for invoking
    Base64 encoding tools.
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Assembler::ConstructJob` 方法是我们将放置调用 Base64 编码工具逻辑的地方。'
- en: 'Inside `Zipline.cpp`, we will implement the method body of `Assembler::ConstructJob`:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Zipline.cpp` 内部，我们将实现 `Assembler::ConstructJob` 方法的主体：
- en: '[PRE51]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We are using OpenSSL to do the Base64 encoding, and the command we hope to
    run is as follows:'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用 OpenSSL 进行 Base64 编码，我们希望运行的命令如下：
- en: '[PRE52]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The job of the `ConstructJob` method is building a *program invocation* to run
    the previous command. It is realized by the `C.addCommand(…)` function call at
    the very end of `ConstructJob`. The `Command` instance that's passed to the `addCommand`
    call represents the concrete command to be run during the assembling stage. It
    contains necessary information such as the path to the program executable (the
    `Exec` variable) and its arguments (the `CmdArgs` variable).
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ConstructJob` 方法的任务是构建一个 *程序调用* 来运行之前的命令。这是通过在 `ConstructJob` 的最后调用 `C.addCommand(…)`
    函数实现的。传递给 `addCommand` 调用的 `Command` 实例代表在汇编阶段要运行的具体命令。它包含必要的信息，例如程序可执行文件的路径（`Exec`
    变量）及其参数（`CmdArgs` 变量）。'
- en: For the `Exec` variable, the toolchain has provided a handy utility, the `GetProgramPath`
    function, to resolve the absolute path of an executable for you.
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于 `Exec` 变量，工具链提供了一个方便的实用工具，即 `GetProgramPath` 函数，以为您解析可执行文件的绝对路径。
- en: 'The way we build arguments for `openssl` (the `CmdArgs` variable), on the other
    hand, is very similar to the thing we did in the *Adding custom driver flags*
    section: translating driver flags (the `Args` argument) and the input/output file
    information (the `Output` and `Inputs` argument) into a new set of command-line
    arguments and storing them in `CmdArgs`.'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与我们在 *添加自定义驱动程序标志* 部分所做的事情类似，我们构建 `openssl`（`CmdArgs` 变量）的参数方式非常相似：将驱动程序标志（`Args`
    参数）和输入/输出文件信息（`Output` 和 `Inputs` 参数）转换成一组新的命令行参数，并将它们存储在 `CmdArgs` 中。
- en: 'Finally, we connect this `Assembler` class with `ZiplineToolChain` by implementing
    the `ZiplineToolChain::buildAssembler` method:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们通过实现 `ZiplineToolChain::buildAssembler` 方法将这个 `Assembler` 类与 `ZiplineToolChain`
    连接起来：
- en: '[PRE53]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: These are all the steps we need to follow to create a `Tool` instance that represents
    the command to run during the linking stage of our Zipline toolchain.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这些就是我们创建代表 Zipline 工具链链接阶段运行命令的 `Tool` 实例所需遵循的所有步骤。
- en: Creating a custom linking stage
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义链接阶段
- en: 'Now that we''ve finished the assembler stage, it''s time to move on to the
    next stage – the linking stage. We are going to use the same approach we used
    in the previous section; that is, we will create a custom `Tool` class representing
    the linker. Here are the steps:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了汇编阶段，是时候进入下一个阶段——链接阶段了。我们将使用与上一节相同的方法；也就是说，我们将创建一个自定义的 `Tool` 类来表示链接器。以下是步骤：
- en: 'Inside `Zipline.h`, create a `Linker` class that is derived from `Tool`:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Zipline.h` 内部，创建一个从 `Tool` 派生的 `Linker` 类：
- en: '[PRE54]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In this `Linker` class, we also need to implement the `ConstructJob` method
    to tell the driver what to execute during the linking stage. Differently from
    `Assembler`, since we need to support both the `zip` and `tar` + `gzip` packaging/compression
    schemes, we will add two extra methods, `buildZipArgs` and `buildTarArgs`, to
    handle argument building for each.
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个 `Linker` 类中，我们还需要实现 `ConstructJob` 方法，以告诉驱动器在链接阶段要执行什么。与 `Assembler` 不同，由于我们需要支持
    `zip` 和 `tar` + `gzip` 打包/压缩方案，我们将添加两个额外的方法，`buildZipArgs` 和 `buildTarArgs`，以处理每个的参数构建。
- en: 'Inside `Zipline.cpp`, we''ll focus on the implementation of `Linker::ConstructJob`
    first:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Zipline.cpp` 中，我们将首先关注 `Linker::ConstructJob` 的实现：
- en: '[PRE55]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In this custom linking stage, we hope to use either the `zip` command or the
    `tar` command – depending on the `-fuse-ld` flag specified by users – to package
    all the (Base64-encoded) files generated by our custom `Assembler`.
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个自定义链接阶段，我们希望使用 `zip` 命令或 `tar` 命令——根据用户指定的 `-fuse-ld` 标志——来打包所有由我们的自定义 `Assembler`
    生成的（Base64 编码的）文件。
- en: The detailed command format for both `zip` and `tar` will be explained shortly.
    From the preceding snippet, we can see that the thing we are doing here is similar
    to `Assembler::ConstructJob`. The `Exec` variable carries the absolute path to
    either the `zip` or `tar` program; the `CmdArgs` variable, which is populated
    by either `buildZipArgs` or `buildTarArgs`, which will be explained later, carries
    the command-line arguments for the tool (`zip` or `tar`).
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`zip` 和 `tar` 的详细命令格式将很快解释。从前面的代码片段中，我们可以看到我们在这里所做的是与 `Assembler::ConstructJob`
    类似的。`Exec` 变量携带到 `zip` 或 `tar` 程序的绝对路径；`CmdArgs` 变量，由 `buildZipArgs` 或 `buildTarArgs`（稍后解释）填充，携带工具的命令行参数（`zip`
    或 `tar`）。'
- en: The biggest difference compared to `Assembler::ConstructJob` is that the command
    to execute can be designated by the `-fuse-ld` flag that's supplied by users.
    Thus, we are using the skill we learned about in the *Adding custom driver flags*
    section to read that driver flag and set up the command.
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与 `Assembler::ConstructJob` 相比，最大的不同之处在于可以通过用户提供的 `-fuse-ld` 标志指定要执行的命令。因此，我们正在使用我们在
    *添加自定义驱动器标志* 部分学到的技能来读取该驱动器标志并设置命令。
- en: 'If your users decide to package files in a ZIP file (which is the default scheme,
    or you can specify it explicitly via `-fuse-ld=zip`), we are going to run the
    following command:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您的用户决定将文件打包成 ZIP 文件（这是默认方案，或者您可以通过 `-fuse-ld=zip` 明确指定它），我们将运行以下命令：
- en: '[PRE56]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Therefore, we will build our `Linker::buildZipArgs` method, which constructs
    an argument list for the preceding command, as follows:'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，我们将构建我们的 `Linker::buildZipArgs` 方法，该方法构建前面命令的参数列表，如下所示：
- en: '[PRE57]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The `CmdArgs` argument of `Linker::buildZipArgs` will be where we'll export
    our results. While we are still using the same way to fetch the output filename
    (via `Output.getFilename()`), since a linker might accept multiple inputs at a
    time, we are leveraging another helper function, `AddLinkerInputs`, to add all
    the input filenames to `CmdArgs` for us.
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Linker::buildZipArgs` 的 `CmdArgs` 参数将是我们将导出结果的地方。虽然我们仍然使用相同的方式获取输出文件名（通过 `Output.getFilename()`），但由于链接器可能一次接受多个输入，我们正在利用另一个辅助函数
    `AddLinkerInputs` 来为我们添加所有输入文件名到 `CmdArgs`。'
- en: 'If your users decide to use the `tar` + `gzip` packaging scheme (via the `-fuse-ld=tar`
    or `-fuse-ld=gzip` flags), we are going to run the following command:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您的用户决定使用 `tar` + `gzip` 打包方案（通过 `-fuse-ld=tar` 或 `-fuse-ld=gzip` 标志），我们将运行以下命令：
- en: '[PRE58]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Therefore, we will build our `Linker::buildTarArgs` method, which constructs
    an argument list for the previous command, as follows:'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，我们将构建我们的 `Linker::buildTarArgs` 方法，该方法构建前面命令的参数列表，如下所示：
- en: '[PRE59]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Just like `buildZipArgs`, we grab the output filename via `Output.getFilename()`
    and add all the input filenames, using `AddLinkerInput`, into `CmdArgs`.
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 就像 `buildZipArgs` 一样，我们通过 `Output.getFilename()` 获取输出文件名，并使用 `AddLinkerInput`
    将所有输入文件名添加到 `CmdArgs` 中。
- en: 'Last but not least, let''s connect our `Linker` to `ZiplineToolChain`:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，让我们将我们的 `Linker` 连接到 `ZiplineToolChain`：
- en: '[PRE60]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: That's all of the steps for implementing a custom linking phase for our Zipline
    toolchain.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 实现我们 Zipline 工具链的自定义链接阶段的步骤就到这里了。
- en: Now that we have created the necessary components for the Zipline toolchain,
    we can execute our custom features – encode the source files and package them
    into an archive – when users select this toolchain. In the next section, we are
    going to learn how to verify these functionalities.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为 Zipline 工具链创建了必要的组件，当用户选择此工具链时，我们可以执行我们的自定义功能——编码源文件并将它们打包成归档文件。在下一节中，我们将学习如何验证这些功能。
- en: Verifying the custom toolchain
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证自定义工具链
- en: To test the functionalities we implemented in this chapter, we can run the example
    commands depicted in the project overview or we can leverage the `-###` driver
    flag again to dump all the expected compiler, assembler, and linker command details.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试本章中实现的功能，我们可以运行项目概述中描述的示例命令，或者我们可以再次利用`-###`驱动程序标志来转储所有预期的编译器、汇编器和链接器命令详情。
- en: 'So far, we''ve learned that the `-###` flag will show all the frontend flags
    that have been translated by the driver. But actually, it will also show the assembler
    and linker commands that have been scheduled to run. For instance, let''s invoke
    the following command:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解到`-###`标志将显示由驱动程序翻译的所有前端标志。但实际上，它还会显示已安排运行的汇编器和链接器命令。例如，让我们调用以下命令：
- en: '[PRE61]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Since the `-c` flag always tries to run the assembler over the assembly file
    generated by Clang, our custom assembler (that is, the Base64 encoder) within
    Zipline will be triggered. Therefore, you will see an output similar to the following:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`-c`标志总是尝试在Clang生成的汇编文件上运行汇编器，因此我们的自定义汇编器（即Base64编码器）将在Zipline中被触发。因此，您将看到以下类似的输出：
- en: '[PRE62]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The line starting with `/path/to/clang -cc1` contains the frontend flags we
    learned about earlier. The line that follows is the assembler invocation command.
    This, in our case, runs `openssl` to perform Base64 encoding.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 以`/path/to/clang -cc1`开头的行包含我们之前了解的前端标志。接下来的行是汇编器调用命令。在这种情况下，运行`openssl`以执行Base64编码。
- en: Note that the weird `/tmp/test_ae4f5b.s` filename is the temporary file that's
    created by the driver to accommodate the assembly code that's generated by the
    compiler.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，奇特的`/tmp/test_ae4f5b.s`文件名是由驱动程序创建的临时文件，用于容纳编译器生成的汇编代码。
- en: 'Using the same trick, we can verify our custom linker stage, as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的技巧，我们可以验证我们的自定义链接阶段，如下所示：
- en: '[PRE63]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Since the `-o` flag was used in the previous command, Clang will build a complete
    executable from `test.c` involving the assembler and the linker. Therefore, our
    custom linking stage is up here due to the `zip` command taking the result (the
    `/tmp/test_ae4f5b.o` file) from the previous assembling stage. Feel free to add
    the `-fuse-ld=tar` flag to see the `zip` command replace the `tar` command with
    a completely different argument list.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 由于前一个命令使用了`-o`标志，Clang将构建一个完整的可执行文件，从`test.c`开始，涉及汇编器和链接器。因此，由于`zip`命令从上一个汇编阶段获取结果（`/tmp/test_ae4f5b.o`文件），我们的自定义链接阶段在这里。您可以随意添加`-fuse-ld=tar`标志来查看`zip`命令用完全不同的参数列表替换`tar`命令。
- en: In this section, we showed you how to create a toolchain for Clang's driver.
    This is a crucial skill for supporting Clang on custom or new platforms. We also
    learned that the toolchain framework in Clang is flexible and can handle a variety
    of tasks that are required by the target platform.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们向您展示了如何创建Clang驱动程序的工具链。这是在自定义或新平台上支持Clang的关键技能。我们还了解到，Clang的工具链框架是灵活的，可以处理目标平台所需的各种任务。
- en: Summary
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started by introducing Clang's driver and the role of the
    toolchain – the module that provides platform-specific information such as the
    supported assemblers and linkers – that assisted it. Then, we showed you one of
    the most common ways to customize the driver – adding a new driver flag. After
    that, we talked about the toolchain and, most importantly, how to create a custom
    one. These skills are really useful when you want to create a new feature in Clang
    (or even LLVM) and need a custom compiler flag to enable it. Also, the ability
    to develop a custom toolchain is crucial for supporting Clang on new operating
    systems, or even new hardware architecture.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先介绍了Clang的驱动程序和工具链的作用——提供特定平台信息的模块，例如支持的汇编器和链接器——它协助了它。然后，我们向您展示了定制驱动程序最常见的方法之一——添加新的驱动程序标志。之后，我们讨论了工具链，最重要的是，如何创建一个自定义工具链。当您想在Clang（甚至LLVM）中创建新功能并需要自定义编译器标志来启用它时，这些技能非常有用。此外，开发自定义工具链的能力对于在新的操作系统或新的硬件架构上支持Clang至关重要。
- en: This is the final chapter of the second part of this book. Starting from the
    next chapter, we will talk about LLVM's middle end – the *platform-independent*
    program analysis and optimization framework.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本书第二部分的最后一章。从下一章开始，我们将讨论LLVM的中端——*平台无关*的程序分析和优化框架。
- en: Exercises
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: It is common to override the assembling and linking stage since different platforms
    tend to support different assemblers and linkers. However, is it possible to override
    the *compiling* stage (which is Clang)? If it is possible, how can we do this?
    Why may people wish to do this?
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖汇编和链接阶段是很常见的，因为不同的平台往往支持不同的汇编器和链接器。然而，是否有可能覆盖 *编译* 阶段（即 Clang）？如果可能，我们该如何做？为什么人们可能希望这样做？
- en: When we were working on `tools::zipline::Linker::ConstructJob`, we simply use
    `llvm_unreachable` to bail out the compilation process if a user provides an unsupported
    compressor name through the `-fuse-ld` flag. Can we replace it with Clang's **diagnostic**
    framework, which we learned about in [*Chapter 7*](B14590_07_Final_JC_ePub.xhtml#_idTextAnchor093),
    *Handling AST*, to print out better messages?
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们正在处理 `tools::zipline::Linker::ConstructJob` 时，我们简单地使用 `llvm_unreachable`
    来退出编译过程，如果用户通过 `-fuse-ld` 标志提供了一个不支持的压缩器名称。我们能否用我们在 [*第7章*](B14590_07_Final_JC_ePub.xhtml#_idTextAnchor093)
    中学到的 Clang 的 **诊断** 框架来替换它，以打印出更好的消息？
- en: Just like we can use `-Xclang` to pass flags directly to the frontend, we can
    also pass assembler-specific or linker-specific flags directly to the assembler
    or linker using driver flags such as `-Wa` (for the assembler) or `-Wl` (for the
    linker). How can we consume those flags in our custom assembler and linker stages
    within Zipline?
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像我们可以使用 `-Xclang` 直接将标志传递给前端一样，我们也可以通过驱动器标志，如 `-Wa`（用于汇编器）或 `-Wl`（用于链接器），直接将汇编器特定的或链接器特定的标志传递给汇编器或链接器。我们如何在
    Zipline 的自定义汇编器和链接器阶段消耗这些标志？
