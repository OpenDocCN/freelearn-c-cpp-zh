<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Memory Management, Smart Pointers, and Debugging</h1>
                </header>
            
            <article>
                
<p>In this chapter, we are going to cover the following topics:</p>
<ul>
<li>Unmanaged memory – using malloc()/free()</li>
<li>Unmanaged memory – using new/delete</li>
<li>Managed memory – using NewObject&lt; &gt; and ConstructObject&lt; &gt;</li>
<li>Managed memory – de-allocating memory</li>
<li>Managed memory – using smart pointers (TSharedPtr, TWeakPtr, TAutoPtr) to track an object</li>
<li>Using TScopedPointer to track an object</li>
<li>Unreal's garbage collection system and UPROPERTY()</li>
<li>Forcing garbage collection</li>
<li>Breakpoints and stepping through code</li>
<li>Finding bugs and using call stacks</li>
<li>Using the profiler to identify hot spots</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>Memory management is always one of the most important things to get right in your computer program to ensure stability and good, bug-free operation of your code. A dangling pointer (<em>pointer</em> referring to something that has been removed from memory) is an example of a bug that is hard to track if it occurs.</p>
<p>In any computer program, memory management is extremely important. UE4's <kbd>UObject</kbd> reference-counting system is the default way that memory is managed for actors and classes derived from the <kbd>UObject</kbd> class. This is the default way that your memory will be managed within your UE4 program.</p>
<p>If you write custom C++ classes of your own, which do not derive from <kbd>UObject</kbd>, you may find the <kbd>TSharedPtr</kbd> / <kbd>TWeakPtr</kbd> reference-counted classes useful to use. These classes provide reference counting and automatic deletion for objects when they have no more references.</p>
<p>This chapter provides recipes for memory management within UE4. It also provides information on debugging your code through some of the useful features that Visual Studio includes for us, including breakpoints and the profiler.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>This chapter requires the use of Unreal Engine 4 and uses Visual Studio 2017 as the IDE. Instructions on how to install both pieces of software and the requirements for them can be found in <a href="4adb307e-d86f-4d70-b6de-a0893102d1cf.xhtml">Chapter 1</a>, <em>UE4 Development Tools</em>, of this book.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unmanaged memory – using malloc( ) / free( )</h1>
                </header>
            
            <article>
                
<p>The basic way to allocate memory to your computer program in C (which is still possible to use in C++) is by using the <kbd>malloc()</kbd> function. This function designates a block of the computer system's memory for your program's use. Once your program is using a segment of memory, no other program can use or access that segment of memory. An attempt to access a segment of memory not allocated to your program will generate a <strong>segmentation fault</strong>, and represents an illegal operation on most systems.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Let's look at some example code that allocates a pointer variable, <kbd>i</kbd>, then assigns memory to it using <kbd>malloc()</kbd>. We allocate a single integer behind an <kbd>int*</kbd> pointer. After allocation, we store a value inside <kbd>int</kbd>, using the dereferencing operator <kbd>*</kbd>:</p>
<pre>// CREATING AND ALLOCATING MEMORY FOR AN INT VARIABLE i <br/><br/>// Declare a pointer variable i <br/>int * i; <br/><br/>// Allocates system memory<br/>i = ( int* )malloc( sizeof( int ) );<br/><br/>// Assign the value 0 into variable i <br/>*i = 0; <br/><br/>// Use the variable i, ensuring to <br/>// use dereferencing operator * during use <br/>printf( "i contains %d", *i ); <br/><br/>// RELEASING MEMORY OCCUPIED BY i TO THE SYSTEM <br/><br/>// When we're done using i, we free the memory <br/>// allocated for it back to the system. <br/>free( i ); <br/><br/>// Set the pointer's reference to address 0 <br/>i = 0;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The preceding code does what is shown in the diagram that follows:</p>
<ol>
<li>The first line creates an <kbd>int *</kbd> pointer variable, <kbd>i</kbd>, which starts as a dangling pointer referring to a segment of memory that probably won't be valid for your program to reference.</li>
<li>In the second step of the diagram, we use a <kbd>malloc()</kbd> call to initialize the variable <kbd>i</kbd> to point to a segment of memory precisely the size of an <kbd>int</kbd> variable, which will be valid for your program to refer to.</li>
<li>We then initialize the contents of that memory segment to the value <kbd>0</kbd> using the command <kbd>*i = 0;</kbd>. Refer to the following diagram:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/00340e70-51a4-4f85-916c-9e0a483211bf.png" style="width:44.08em;height:12.42em;"/></p>
<div class="mce-root packt_tip"><span>Note the difference between the assignment to a pointer variable (</span><kbd>i =</kbd><span>), which tells the pointer which memory address to refer to, and the assignment to what it is inside the memory address that the pointer variable refers to (</span><kbd>*i =</kbd><span>).</span></div>
<p>When the memory in the variable <kbd>i</kbd> needs to be released back to the system, we do so using a <kbd>free()</kbd> de-allocation call, as shown in the following diagram. <kbd>i</kbd> is then assigned to point to the memory address, <kbd>0</kbd>, shown in this diagram by the <strong>electrical grounding</strong> symbol reference, <img src="assets/97df6b03-e489-4edc-b53e-53668ce93f7f.png" style="width:2.08em;height:2.58em;"/>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/aeff3a49-d8d6-43af-965c-fda71b7d0499.png" style="width:26.92em;height:12.17em;"/></p>
<p>The reason we set the variable <kbd>i</kbd> to point to the <kbd>NULL</kbd> reference is to make it clear that the variable <kbd>i</kbd> does not refer to a valid segment of memory.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unmanaged memory – using new/delete</h1>
                </header>
            
            <article>
                
<p>The <kbd>new</kbd> operator is almost the same as a <kbd>malloc</kbd> call, except that it invokes a constructor call on the object created immediately after the memory is allocated. Objects allocated with the <kbd>new</kbd> operator should be de-allocated with the <kbd>delete</kbd> operator (and not <kbd>free()</kbd>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>In C++, use of <kbd>malloc()</kbd> was replaced as a best practice by use of the <kbd>new</kbd> operator. The main difference between the functionality of <kbd>malloc()</kbd> and the <kbd>new</kbd> operator is that <kbd>new</kbd> will call the constructor on object types after memory allocation. Refer to the following table:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td style="width: 149px">
<p><kbd>malloc</kbd></p>
</td>
<td style="width: 507px">
<p><span>Allocates a zone of contiguous space for use</span></p>
</td>
</tr>
<tr>
<td style="width: 149px">
<p><kbd>new</kbd></p>
</td>
<td style="width: 507px">
<p>Allocates a zone of contiguous space for use</p>
<p>Calls constructor as an object type used as an argument to the <kbd>new</kbd> operator.</p>
</td>
</tr>
</tbody>
</table>
<div class="packt_figure"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>In the following code, we declare a simple <kbd>Object</kbd> class, then construct an instance of it using the <kbd>new</kbd> operator:</p>
<pre>class Object <br/>{ <br/>  Object() <br/>  { <br/>    puts( "Object constructed" ); <br/>  } <br/>  ~Object() <br/>  { <br/>    puts( "Object destructed" ); <br/>  } <br/>}; <br/><br/>// Invokes constructor <br/>Object * object = new Object(); <br/><br/>// Invokes deconstrctor <br/>delete object; <br/><br/>// resets object to a null pointer<br/>object = 0;  </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The <kbd>new</kbd> operator works by allocating space just as <kbd>malloc()</kbd> does. If the type used with the <kbd>new</kbd> operator is an object type, the constructor is invoked automatically with the use of the <kbd>new</kbd> keyword, whereas the constructor is never invoked with the use of <kbd>malloc()</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>You should avoid using naked heap allocations with the <kbd>new</kbd> keyword (or <kbd>malloc</kbd> for that matter). Managed memory is preferred within the engine so that all memory use is tracked and clean. If you allocate a <kbd>UObject</kbd> derivative, you definitely need to use <kbd>NewObject&lt; &gt;</kbd> or <kbd>ConstructObject&lt; &gt;</kbd> (outlined in subsequent recipes).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Managed memory – using NewObject&lt; &gt; and ConstructObject&lt; &gt;</h1>
                </header>
            
            <article>
                
<p><strong>Managed memory</strong> refers to memory that is &lt;indexentry content="managed memory:allocating, NewObject used"&gt;allocated and de-allocated by some programmed subsystem above the <kbd>new</kbd>, <kbd>delete</kbd>, <kbd>malloc,</kbd>, and <kbd>free</kbd> calls in C++. These subsystems are commonly created so that the programmer does not forget to release memory after allocating it. Unreleased, occupied, but unused memory chunks are called <strong>memory leaks</strong>, as follows:</p>
<pre>// generates memory leaks galore! <br/>for( int i = 0; i &lt; 100; i++ ) <br/>{<br/>  int** leak = new int[500];<br/>}</pre>
<p>In the preceding example, the memory allocated is not referenceable by any variable! So, you can neither use the allocated memory after the <kbd>for</kbd> loop, nor free it. If your program allocates all available system memory, then what will happen is that your system will run out of memory entirely, and your OS will flag your program and close it for using up too much memory.</p>
<p>Memory management prevents forgetting to release memory. In memory-managed programs, it is commonly remembered by objects that are dynamically &lt;indexentry content="managed memory:allocating, ConstructObject used"&gt;allocated the number of pointers referencing the object. When there are zero pointers referencing the object, it is either automatically deleted immediately, or flagged for deletion on the next run of the garbage collector.</p>
<p>Use of managed memory is automatic within UE4. Any allocation of an object to be<br/>
used within the engine must be done using the <kbd>NewObject&lt; &gt;()</kbd> or <kbd>SpawnActor&lt; &gt;()</kbd> function.</p>
<p>The release of objects is done by removing the reference to the object and then occasionally calling the garbage cleanup routine (listed further in this chapter).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>When you need to construct any <kbd>UObject</kbd> derivative that is not a derivative of the <kbd>Actor</kbd> class, you should always use the <kbd>NewObject&lt; &gt;</kbd> function. <kbd>SpawnActor&lt; &gt;</kbd> should be used only when the object is an <kbd>Actor</kbd> or its derivative.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Let's say we are trying to construct an object of a <kbd>UAction</kbd> type that itself derives from <kbd>UObject</kbd>—for example, the following class:</p>
<pre>UCLASS(BlueprintType, Blueprintable, <br/>       meta=(ShortTooltip="Base class for any Action type") )<br/>class CHAPTER_03_API UAction : public UObject<br/>{<br/>  GENERATED_BODY()<br/><br/>public:<br/>  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Properties)<br/>  FString Text;<br/>  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Properties)<br/>  FKey ShortcutKey;<br/><br/>};</pre>
<p>To construct an instance of the <kbd>UAction</kbd> class, we'd do the following:</p>
<pre>// Create an object<br/>UAction * action = NewObject&lt;UAction&gt;(GetTransientPackage(), <br/>                                      UAction::StaticClass() <br/>                                      /* RF_* flags */ ); </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Here, <kbd>UAction::StaticClass()</kbd> gets you a base <kbd>UClass *</kbd> for the <kbd>UAction</kbd> object. The first argument to <kbd>NewObject&lt; &gt;</kbd> is <kbd>GetTransientPackage()</kbd>, which simply retrieves the transient package for the game. A package (<kbd>UPackage</kbd>) in UE4 is just a data conglomerate. Here we use the <strong>Transient Package</strong> to store our heap-allocated data. You could also use <kbd>UPROPERTY() TSubclassOf&lt;AActor&gt;</kbd> from Blueprints to select a <kbd>UClass</kbd> instance.</p>
<p>The third argument (optional) is a combination of parameters that indicate how <kbd>UObject</kbd> is treated by the memory management system.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>There is another function very similar to <kbd>NewObject&lt; &gt;</kbd> called <kbd>ConstructObject&lt; &gt;</kbd>. <kbd>ConstructObject&lt; &gt;</kbd> provides more parameters in construction, and you may find it useful if you need to initialize certain properties. Otherwise, <kbd>NewObject</kbd> works just fine.</p>
<div class="packt_infobox">You can find out more about the ConstructObject function here: <a href="https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/Objects/Creation#constructobject">https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/Objects/Creation#constructobject</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p>You may also want to see the documentation for the <kbd>RF_*</kbd> flags at <a href="https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Objects/Creation/index.html#objectflags%20">https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Objects/Creation/index.html#objectflags</a>.<a href="https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Objects/Creation/index.html#objectflags%20"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Managed memory – de-allocating memory</h1>
                </header>
            
            <article>
                
<p>The <kbd>UObject</kbd> instances are reference-counted and garbage-collected when there are no more references to the <kbd>UObject</kbd> instance. Memory allocated on a <kbd>UObject</kbd> class derivative using <kbd>ConstructObject&lt;&gt;</kbd> or <kbd>NewObject&lt; &gt;</kbd> can also be de-allocated manually (before the reference count drops to 0) by calling the <kbd>UObject::ConditionalBeginDestroy()</kbd> member function.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>You'd only do this if you were sure you no longer wanted <kbd>UObject</kbd> or the <kbd>UObject</kbd> class derivative instance in memory. Use the <kbd>ConditionalBeginDestroy()</kbd> function to release memory.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>The following code demonstrates the de-allocation of an instance of the <kbd>UObject</kbd> class:</p>
<pre>UObject *o = NewObject&lt; UObject &gt;( ... ); 
o-&gt;ConditionalBeginDestroy(); </pre>
<p>This concept also works with any class derived from the <kbd>UObject</kbd> class. So, for instance, if we wanted to do this with the <kbd>UAction</kbd> object we created in the previous recipe, we would add the bold text in the following snippet:</p>
<pre>// Create an object<br/>UAction * action = NewObject&lt;UAction&gt;(GetTransientPackage(), <br/>                    UAction::StaticClass() <br/>                    /* RF_* flags */ ); <br/><br/><strong>// Destroy an object</strong><br/><strong>action-&gt;ConditionalBeginDestroy();</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The <kbd>ConditionalBeginDestroy()</kbd> command begins the de-allocation process, calling the <kbd>BeginDestroy()</kbd> and <kbd>FinishDestroy()</kbd> overrideable functions.</p>
<div class="packt_infobox">Be careful not to call <kbd>UObject::ConditionalBeginDestroy()</kbd> on any object still being referenced in memory by other objects' pointers. </div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Managed memory – smart pointers (TSharedPtr, TWeakPtr, TAutoPtr) to track an object</h1>
                </header>
            
            <article>
                
<p>When people are afraid that they'll forget the <kbd>delete</kbd> call for standard C++ objects they create, they often use smart pointers to prevent memory leaks. <kbd>TSharedPtr</kbd> is a very useful C++ class that will make any custom C++ object reference-counted—with the exception of <kbd>UObject</kbd> derivatives, which are already reference-counted. An alternate class, <kbd>TWeakPtr</kbd>, is also provided for pointing to a reference-counted object with the strange property of being unable to prevent deletion (hence, <em>weak</em>):</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/66139d96-b541-46d5-a16e-093e46d853fd.png" style="width:22.08em;height:13.50em;"/></p>
<div class="packt_tip"><kbd>UObject</kbd><span> and its derivative classes (anything created with </span><kbd>NewObject</kbd><span> or </span><kbd>ConstructObject</kbd><span>) cannot use </span><kbd>TSharedPtr</kbd><span>!</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>If you don't want to use raw pointers and manually track deletes into your C++ code that do not use <kbd>UObject</kbd> derivatives, then that code is a good candidate for using smart pointers such as <kbd>TSharedPtr</kbd>, <kbd>TSharedRef</kbd>, and the like. When you use a dynamically allocated object (created using the <kbd>new</kbd> keyword), you can wrap it up in a reference-counted pointer so that de-allocation happens automatically. The different types of smart pointers determine the smart pointer behavior and deletion call time. They are as follows:</p>
<ul>
<li><kbd>TSharedPtr</kbd>: A thread-safe (provided you supplied <kbd>ESPMode::ThreadSafe</kbd> as the second argument to the template) reference-counted pointer type that indicates a shared object. The shared object will be de-allocated when there are no more references to it.</li>
<li><kbd>TAutoPtr</kbd>: A non-thread-safe shared pointer.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>We can demonstrate the use of the four types of smart pointers referred to previously using a short code segment. In all of this code, the starting pointer can either be a raw pointer, or a copy of another smart pointer. All you have to do is take the C++ raw pointer and wrap it in a constructor call to any of the following: <kbd>TSharedPtr</kbd>, <kbd>TSharedRef</kbd>, <kbd>TWeakPtr,</kbd>, or <kbd>TAutoPtr</kbd>.</p>
<p>For example, take a look at the following code snippet:</p>
<pre>// C++ Class NOT deriving from UObject 
class MyClass { }; 
TSharedPtr&lt;MyClass&gt;sharedPtr( new MyClass() ); </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>There are some differences between weak pointers and shared pointers. Weak pointers do not have the capability to keep the object in memory when the reference count drops to 0.</p>
<p>The advantage of using a weak pointer (over a raw pointer) is that, when the object underneath the weak pointer is manually deleted (using <kbd>ConditionalBeginDestroy()</kbd>), the weak pointer's reference becomes a <kbd>NULL</kbd> reference. This enables you to check whether the resource underneath the pointer is still allocated properly by checking a statement of the following form:</p>
<pre>if( ptr.IsValid() ) // Check to see if the pointer is valid 
{ 
} </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Shared pointers are thread-safe. This means that the underlying object can safely be manipulated on separate threads.</p>
<p>Always remember that you cannot use <kbd>TSharedRef</kbd> with <kbd>UObject</kbd>s or <kbd>UObject</kbd> derivatives; you can only use them on your custom C++ classes. Your <kbd>FStructures</kbd> can use the <kbd>TSharedPtr</kbd>, <kbd>TSharedRef</kbd>, and <kbd>TWeakPtr</kbd> classes to wrap up a raw pointer.</p>
<p>If you want to use smart pointers to point to an object, you must use <kbd>TWeakObjectPointer</kbd> or <kbd>UPROPERTY()</kbd>.</p>
<p>You can use <kbd>TAutoPtr</kbd> if you do not need the thread-safety guarantee of <kbd>TSharedPtr</kbd>. <kbd>TAutoPtr</kbd> will automatically delete an object when the number of references to it drops to 0.</p>
<div class="packt_infobox">If you are interested in learning more about Unreal's smart pointers, check out <a href="https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/SmartPointerLibrary">https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/SmartPointerLibrary</a>.<a href="https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/SmartPointerLibrary"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using TScopedPointer to track an object</h1>
                </header>
            
            <article>
                
<p>A <strong>scoped</strong> pointer is a pointer that is auto-deleted at the end of the block in which it was declared. Recall that a scope is just a section of code during which a variable is <em>alive</em>. A scope will last until the first closing brace, <kbd>}</kbd>, that appears.</p>
<p>For example, in the following block, we have two scopes. The outer scope declares an integer variable <kbd>x</kbd> (valid for the entire outer block), while the inner scope declares an integer variable <kbd>y</kbd> (valid for the inner block, after the line on which it is declared):</p>
<pre>{ 
  int x; 
  { 
    int y; 
  } // scope of y ends 
} // scope of x ends </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Scoped pointers are useful when it is important that a reference-counted object (that is in danger of going out of scope) is retained for the duration of the usage.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To declare a scoped pointer, we simply use the following syntax:</p>
<pre>TScopedPointer&lt;AWarrior&gt; warrior(this ); </pre>
<p>This declares a scoped pointer referencing an object of the type declared within the angle brackets: <kbd>&lt; AWarrior &gt;</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The <kbd>TScopedPointer</kbd> variable type automatically adds a reference count to the variable pointed to. This prevents the de-allocation of the underlying object for at least the life of the scoped pointer.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unreal's garbage collection system and UPROPERTY( )</h1>
                </header>
            
            <article>
                
<p>When you have an object (such as <kbd>TArray&lt; &gt;</kbd>) as a <kbd>UPROPERTY()</kbd> member of <kbd>UCLASS()</kbd>, you need to declare that member as <kbd>UPROPERTY()</kbd> (even if you won't edit it in Blueprints); otherwise, <kbd>TArray</kbd> will not stay allocated properly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Say we have a <kbd>UCLASS()</kbd> macro as follows:</p>
<pre>UCLASS() 
class MYPROJECT_API AWarrior : public AActor 
{ 
  //TArray&lt; FSoundEffect &gt; Greets; // Incorrect 
  UPROPERTY() TArray&lt; FSoundEffect &gt; Greets; // Correct 
}; </pre>
<p>You'd have to list the <kbd>TArray</kbd> member as <kbd>UPROPERTY()</kbd> for it to be properly reference-counted. If you don't do so, you'll get an unexpected memory error-type bug sitting about in the code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The <kbd>UPROPERTY()</kbd> declaration tells UE4 that <kbd>TArray</kbd> must be properly memory-managed. Without the <kbd>UPROPERTY()</kbd> declaration, your <kbd>TArray</kbd> won't work properly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Forcing garbage collection</h1>
                </header>
            
            <article>
                
<p>When memory fills up, and you want to free some of it, garbage collection can be forced. You seldom need to do this, but you can do it in the case of having a very large texture (or set of textures) that are reference-counted and that you need to clear.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Simply call <kbd>ConditionalBeginDestroy()</kbd> on all <kbd>UObject</kbd>s that you want de-allocated from memory, or set their reference counts to <kbd>0</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Garbage collection is performed by calling the following:</p>
<pre>GetWorld()-&gt;ForceGarbageCollection( true ); </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Breakpoints and stepping through code</h1>
                </header>
            
            <article>
                
<p><strong>Breakpoints</strong> are how you pause your C++ program to temporarily stop the code from running, and have a chance to analyze and inspect your program's operation. You can peer at variables, step through code, and change variable values.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Breakpoints are easy to set in Visual Studio. All you have to do is press <em><span class="KeyPACKT">F9</span></em> on the line of code where you want the operation to pause, or click in the gray margin to the left of the line of code where you want the operation to pause. The code will pause when the operation reaches the line indicated.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Press <em><span class="KeyPACKT">F9</span></em> on the line where you want the execution to pause. This will add a breakpoint to the code, indicated by a red dot, as shown in the following screenshot. Clicking on the red dot toggles it:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/491cbfc5-5a48-4baf-9391-1023a104c953.png" style="width:37.00em;height:3.58em;"/></p>
<ol start="2">
<li>Set the <span class="packt_screen">Build Configuration</span> to any of the configurations with <span class="packt_screen">Debug</span> in the title (<span class="packt_screen"><span class="packt_screen">DebugGame</span> Editor</span> or simply <span class="packt_screen">DebugGame</span> if you launch it without the editor):</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7fb56b04-3359-4b04-bf33-f48dfb485aaa.png"/></p>
<ol start="3">
<li>Launch your code by pressing <em><span class="KeyPACKT">F5</span></em> <span>(without holding</span> <em>Ctrl</em><span>), or select the</span> <span class="packt_screen">Debug</span> <span>|</span> <span class="packt_screen">Start Debugging</span> <span>menu option.</span></li>
<li>When the code reaches the red dot, the code's execution will pause.</li>
</ol>
<ol start="5">
<li>The paused view will take you to the code editor in <strong>Debug mode</strong>. In this mode, the windows may appear re arranged, with <span class="packt_screen">Solution Explorer</span> possibly moved to the right, and new windows appearing at the bottom, including <span class="packt_screen">Locals</span>, <span class="packt_screen">Watch 1</span>, and <span class="packt_screen">Call Stack</span>. If these windows do not appear, find them under the <span class="packt_screen">Debug</span> | <span class="packt_screen">Windows</span> submenu.</li>
<li>Check out your variables under the <span class="packt_screen">Locals</span> window (<span class="packt_screen">Debug</span> | <span class="packt_screen">Windows</span> | <span class="packt_screen">Locals</span>).</li>
<li>Press <em><span class="KeyPACKT">F10</span></em> to step over a line of code.</li>
<li>Press <em><span class="KeyPACKT">F11</span></em> to step into a line of code.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Debuggers are powerful tools that allow you to see everything about your code as it is running, including variable states.</p>
<p>Stepping over a line of code (<em><span class="KeyPACKT">F10</span></em>) executes the line of code in its entirety, and then pauses the program again, immediately, at the next line. If the line of code is a function call, then the function is executed without pausing at the first line of code of the function call, as follows:</p>
<pre>void f() 
{ 
  // F11 pauses here 
  UE_LOG( LogTemp, Warning, TEXT( "Log message" ) ); 
} 
int main() 
{ 
  f(); // Breakpoint here: F10 runs and skips to next line 
} </pre>
<p>Stepping into a line of code (<em><span class="KeyPACKT">F11</span></em>) will pause execution at the very next line of code run.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Finding bugs and using call stacks</h1>
                </header>
            
            <article>
                
<p>When you have a bug in your code that causes a crash, a thrown exception, and so on, Visual Studio will attempt to halt execution of code and will allow you to inspect the code. The place at which Visual Studio halts won't always be the exact location of the bug, but it can be close. It will at least be at a line of code that doesn't execute properly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>In this recipe, we'll describe the <strong>Call Stack</strong><span class="packt_screen">,</span> and how to trace where you think an error may come from. Try adding a bug to your code, or adding a breakpoint somewhere interesting where you'd like to pause for inspection.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Run the code to a point where a bug occurs by pressing <span class="KeyPACKT"><em>F5</em>,</span> or selecting the <span class="packt_screen">Debug</span> | <span class="packt_screen">Start Debugging</span> menu option. For example, add these lines of code:</li>
</ol>
<pre style="padding-left: 60px">UObject *o = 0; // Initialize to an illegal null pointer 
o-&gt;GetName(); // Try and get the name of the object (has <br/> bug) </pre>
<ol start="2">
<li>The code will pause at the second line (<kbd>o-&gt;GetName()</kbd>).</li>
</ol>
<div class="packt_infobox">Note that this code will only execute (and thus crash) when the game is played in the editor.</div>
<ol start="3">
<li>When the code pauses, navigate to the <span class="packt_screen">Call Stack</span> window (<span class="packt_screen">Debug</span> | <span class="packt_screen">Windows</span> | <span class="packt_screen">Call Stack</span>).</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The <span class="packt_screen">Call Stack</span> is a list of function calls that were executed. When a bug occurs, the line on which it occurred is listed at the top of the <span class="packt_screen">Call Stack</span>. Refer to the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/84f61f30-4a18-4bea-b9fc-5472d2ad68fd.png"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the profiler to identify hot spots</h1>
                </header>
            
            <article>
                
<p>The C++ profiler is extremely useful for finding sections of code that require a high amount of processing time. Using the profiler can help you find sections of code to focus on during optimization. If you suspect that a region of code runs slowly, then you can actually confirm that it isn't slow if it doesn't appear highlighted in the profiler.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Go to <span class="packt_screen">Debug</span> | <span class="packt_screen">Performance Profiler...</span>:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/69e22bc5-0985-4574-ab72-93fee172f5af.png"/></div>
<ol start="2">
<li>In the dialog shown in the preceding screenshot, select the type of analysis you'd like displayed. You can choose to analyze <span class="packt_screen">CPU Usage</span>, <span class="packt_screen">GPU Usage</span>, <span class="packt_screen">Memory Usage</span>, or step through a <span class="packt_screen">Performance Wizard</span> to assist you in selecting what you want to see.</li>
</ol>
<ol start="3">
<li>Make sure to run the game without the editor and then click on the <span class="packt_screen">Start</span> button at the bottom of the dialog.</li>
<li>Stop the code after a brief time (less than a minute or two) to halt sample collection.</li>
</ol>
<div class="packt_tip"><span>Do not collect too many samples or the profiler, as then it will take a really long time to start up.</span></div>
<ol start="5">
<li>Inspect the results that appear in the <kbd>.diagsession</kbd> file. Be sure to browse<br/>
all the available tabs that open up. Available tabs will vary depending on the type of analysis performed.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The C++ profiler samples and analyzes the running code, and presents you with a series of diagrams and images about how the code is performed.</p>
<div class="packt_infobox">You can find more information about the performance profiler by going to <a href="https://docs.microsoft.com/en-us/visualstudio/profiling/?view=vs-2017">https://docs.microsoft.com/en-us/visualstudio/profiling/?view=vs-2017</a>.<a href="https://docs.microsoft.com/en-us/visualstudio/profiling/?view=vs-2017"/></div>


            </article>

            
        </section>
    </body></html>