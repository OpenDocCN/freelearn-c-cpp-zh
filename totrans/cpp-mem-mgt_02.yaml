- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Things to Be Careful With
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, you decided to read a book about memory management in C++ and are as ready
    to look at the high-level approaches and techniques as you are willing to “get
    your hands dirty”, so to speak, in order to get fine-grained control over the
    memory management process. What an excellent plan!
  prefs: []
  type: TYPE_NORMAL
- en: Since you know that you are going to be writing very high-level code, but also
    very low-level code, there are a few things we need to make sure you are aware
    of such that you do not get in trouble or write code that seems to work but does
    not, at least not portably.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will point out some aspects of C++ programming that will
    come into play throughout this book, but that you should be careful with. This
    might look like a (very) small compendium of bad practices or an encouragement
    to get in trouble, but please consider what follows as ways to use somewhat dangerous
    or tricky features well. You’re using C++, you have significant freedom of expression,
    and you get access to features that are useful if you know and understand them
    well.
  prefs: []
  type: TYPE_NORMAL
- en: We want code that’s clean and efficient, and we want responsible programmers.
    Let’s try to get there together.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We will cover some of the ways in which one can get into trouble with C++ code.
    Indeed, there are things a compiler cannot reliably diagnose, just as there are
    things for which the C++ standard does not say what will happen, and writing code
    that does such things is a recipe for disaster – or at the very least surprising
    or non-portable behavior.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In particular, we will explore how one can get in trouble with pointers. Since
    this book discusses memory management, we will use pointers and pointer arithmetic
    quite often, and being able to distinguish appropriate uses thereof from inappropriate
    ones will be valuable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we will discuss what kinds of type conversions we can do without resorting
    to type casts (the main subject of [*Chapter 3*](B21071_03.xhtml#_idTextAnchor047)),
    and how rarely that’s a good idea, contrary to popular belief.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our overall goal will be to learn things we should not do (even though we will
    do some maneuvers that resemble them, on occasion), and avoid them thereafter,
    hopefully understanding why we do so. With that out of the way, we’ll have many
    chapters to look at things we *should* do, and how to do them well!
  prefs: []
  type: TYPE_NORMAL
- en: Different kinds of evil
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before delving into some actual practices that require care, it’s interesting
    to look at the main categories of risks we could run into if our code does not
    respect the rules of the language. With each such category comes a form of unpleasantness
    we should strive to avoid.
  prefs: []
  type: TYPE_NORMAL
- en: Ill-formed, no diagnostic required
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some constructs in C++ are said to be **Ill-Formed, No Diagnostic Required**
    (**IFNDR**). Indeed, you will find quite a few occurrences in the standard of
    *“if […], the program is ill-formed, with no diagnostic required.”* When something
    is IFNDR, it means your program is broken. Bad things could happen, but the compiler
    is not required to tell you about them (indeed, sometimes, the compiler does not
    have sufficient information to diagnose the problematic situation).
  prefs: []
  type: TYPE_NORMAL
- en: '`alignas`) in different translation units (different source files, essentially),
    or having a constructor that delegates to itself either directly or indirectly.
    Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note that your compiler might give a diagnostic; it’s just not required to do
    so. It’s not that compilers are lazy – they might even be unable to provide a
    diagnostic in some cases! So, be careful not to write code that leads to IFNDR
    situations.
  prefs: []
  type: TYPE_NORMAL
- en: Undefined behavior
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We mentioned **Undefined Behavior** (**UB**) in [*Chapter 1*](B21071_01.xhtml#_idTextAnchor016).
    UB is often seen as a source of headaches and pain for C++ programmers but it
    refers to any behavior for which the C++ standard imposes no requirement. In practice,
    this means that if you write code that contains UB, you have no idea what’s going
    to happen at runtime (at least if you’re aiming for somewhat portable code). Canonical
    examples of UB include dereferencing a null pointer or an uninitialized pointer:
    do that and you’ll be in serious trouble.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To compilers, UB is not supposed to happen (code that respects the rules of
    the language does not contain UB, after all). For that reason, compilers “optimize
    around” code that contains UB, to sometimes surprising effect: they might begin
    removing tests and branches, optimizing loops away, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: The effects of UB tend to be local. For instance, in the following example,
    there is a test that ensures that `p` is not null before using `*p` in one case,
    but there is at least one access to `*p` that is unchecked. This code is broken
    (the unchecked access to `*p` is UB), so the compiler is allowed to rewrite it
    in such a way that all tests to verify that `p` is not null are effectively removed.
    After all, the damage would be done if `p` were `nullptr`, so the compiler is
    entitled to assume that the programmer passed a non-null pointer to the function!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The whole body of `f()` could legitimately be rewritten by your compiler as
    `return g(*p)` in this case, with the `return *p` statement being turned into
    unreachable code.
  prefs: []
  type: TYPE_NORMAL
- en: The potential for UB hides in various places in the language, including signed
    integer overflow, accessing an array out of bounds, data races, and so on. There
    are ongoing efforts to reduce the number of potential UB cases (there’s even a
    study group, **SG12**, dedicated to this effort), but UB will likely remain part
    of the language for the foreseeable future, and we need to be aware of it.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation-defined behavior
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some parts of the standard fall under the umbrella of **implementation-defined
    behavior**, or behavior that you can count on with a specific platform. This is
    behavior that your platform of choice is supposed to document, but that is not
    guaranteed to be portable to other platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementation-defined behavior occurs in many situations and includes such
    things as implementation-defined limits: the maximum number of nested parentheses;
    the maximum number of case labels in a switch statement; the actual size of an
    object; the maximum number of recursive calls in a `constexpr` function; the number
    of bits in a byte; and so on. Other well-known cases of implementation-defined
    behavior include the number of bytes in an `int` object or whether the `char`
    type is a signed or an unsigned integral type.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementation-defined behavior is not really a source of evil, but it can be
    problematic if one strives for portable code but depends on some non-portable
    assumptions. It is sometimes useful to spell one’s assumptions in code through
    `static_assert` when the assumption can be validated at compile-time or some similar,
    potentially runtime mechanisms in order to realize—before it’s too late—that these
    assumptions are broken for a given target platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Unless you are convinced that your code will never need to be ported to another
    platform, strive to rely as little as possible on implementation-defined behavior,
    and if you do, make sure that you validate (through `static_assert` if possible,
    at runtime if there’s no other choice) and document this situation. It might help
    you avoid some nasty surprises in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Unspecified behavior (not documented)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Where implementation-defined behavior is non-portable but documented for a given
    platform, unspecified behavior is a behavior that, even for a well-formed program
    given correct data, behaves in a way that depends on the implementation but does
    not need to be documented.
  prefs: []
  type: TYPE_NORMAL
- en: Some cases of unspecified behavior include the state of a moved-from object
    (said to be `f(g(),h())` will evaluate `g()` or `h()` first, the values in a newly
    allocated chunk of memory, and so on. This latter example is interesting to our
    study; a debug build might fill newly allocated chunks of memory with a recognizable
    bit pattern to help in the debugging process, and an optimized build with the
    same toolset could leave the initial bits of a newly allocated chunk of memory
    “uninitialized”, with the bits it held at the time when the allocation was performed,
    to get speed improvements.
  prefs: []
  type: TYPE_NORMAL
- en: The ODR
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The ODR, simply summarized, states that there shall be only one definition
    of each “thing” (function, object in a scope, enumeration, template, and so on)
    in a translation unit, although there can be multiple declarations of that thing.
    Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In C++, avoiding ODR violations is important, as these “evils” can escape the
    compiler’s scrutiny and fall into the realm of IFNDR situations. For example,
    due to the separate compilation of source files, a header file containing the
    definition of a non-`inline` function will lead to that definition being replicated
    in each source file that includes that same header. Then, each compilation might
    succeed, and the fact that there are multiple definitions of that function in
    the same build might be detected later (at link time) or just left undetected
    and cause havoc.
  prefs: []
  type: TYPE_NORMAL
- en: Erroneous behavior
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ongoing security-related efforts in C++ have led to discussions on a new kind
    of “evil” tentatively named *erroneous behavior*. This new category is meant to
    cover situations that could have been UB in the past, but for which we could issue
    diagnostics and provide well-defined behavior. The behavior would still be incorrect,
    but erroneous behavior would, in a way, provide boundaries to the consequences.
    Note that work on erroneous behavior is ongoing as of this writing, and this new
    wording feature might target C++26.
  prefs: []
  type: TYPE_NORMAL
- en: One use case envisioned for erroneous behavior is reading from an uninitialized
    variable, where the implementation could (for safety reasons) provide a fixed
    value for the bits read, and the conceptual error that stems from reading that
    variable would be something that implementations are encouraged to diagnose. Another
    use case would be forgetting to return a value from a non-void assignment operator.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve looked at the large “families” of unpleasantness that might hit
    our programs if we don’t behave, let’s delve into some of the main facilities
    that could get us in trouble and see what we should avoid doing.
  prefs: []
  type: TYPE_NORMAL
- en: Pointers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[*Chapter 1*](B21071_01.xhtml#_idTextAnchor016) looked at pointers in C++ in
    the sense of what they represent and what they mean. It described what pointer
    arithmetic is, and what it allows us to do. We will now examine practical uses
    of pointer arithmetic, with both proper and improper uses of this low-level (but
    sometimes precious) tool.'
  prefs: []
  type: TYPE_NORMAL
- en: Uses of pointer arithmetic within an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Pointer arithmetic is a nice and useful tool, but it’s a sharp one that tends
    to be misused. With raw arrays, the following two loops, labeled `A` and `B`,
    behave in exactly the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You might wonder about the `vals + N` part in loop `B`, but it’s valid (and
    idiomatic) C++ code. You can observe the pointer just past the end of an array,
    even though you’re not allowed to observe what it points to; the standard guarantees
    that this specific one-past-the-end address is accessible to your program. However,
    no such guarantee is provided for the following address, so be careful!
  prefs: []
  type: TYPE_NORMAL
- en: 'As long as you respect the rules, you can use pointers to jump back and forth
    within an array. If you overreach and use a pointer to go further than one past-the-end,
    you will end up in UB territory; that is, you might be trying to access an address
    that’s not in your process’ address space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Pointer interconvertibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The C++ standard defines what it means for an object to be `reinterpret_cast`
    (we will expand on this in [*Chapter 3*](B21071_03.xhtml#_idTextAnchor047)), as
    they have the same address. Broadly speaking, the following points hold true:'
  prefs: []
  type: TYPE_NORMAL
- en: An object is pointer-interconvertible with itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `union` is pointer-interconvertible with its data members, as well as their
    first data member if they are compound types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With some restrictions, `x` and `y` are pointer-interconvertible with one another
    if one is an object and the other one is of the same type as the first non-static
    data member of that object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some examples are included here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If you try to apply `reinterpret_cast` in a way that does not respect pointer-interconvertibility
    rules, your code is technically incorrect and is not guaranteed to work in practice.
    Don’t do that.
  prefs: []
  type: TYPE_NORMAL
- en: We will occasionally use the pointer-interconvertibility property in our code
    examples, including in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Uses of pointer arithmetic within an object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pointer arithmetic within an object is also allowed in C++, although one should
    be careful about how this is handled (using the appropriate casts, which we will
    explore in [*Chapter 3*](B21071_03.xhtml#_idTextAnchor047), and ensuring that
    one performs pointer arithmetic appropriately).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following code is correct, albeit not something one should
    seek to do (it makes no sense, and it does things in unnecessarily complicated
    ways, but it’s legal and does no harm):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We will not abuse this aspect of the C++ language in this book, but we do need
    to be aware of it in order to write correct, low-level code.
  prefs: []
  type: TYPE_NORMAL
- en: About the difference between pointer and address
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to strengthen hardware and software security, there has been work
    on hardware architectures that can provide a form of “pointer tagging”, which
    allows the hardware tracking of pointer provenance, among other things. Two well-known
    examples are the CHERI architecture ([https://packt.link/cJeLo](https://packt.link/cJeLo))
    and **Memory Tagging Extensions** (**MTEs**) (Linux: [https://packt.link/KXeRn](https://packt.link/KXeRn)
    | Android: [https://packt.link/JDfEo](https://packt.link/JDfEo), and [https://packt.link/fQM2T](https://packt.link/fQM2T)|
    Windows: [https://packt.link/DgSaH](https://packt.link/DgSaH)).'
  prefs: []
  type: TYPE_NORMAL
- en: To benefit from such hardware, the language needs to distinguish between the
    low-level idea of addresses and the high-level idea of pointers, as the latter
    could take into account the fact that a pointer is more than just a memory location.
    If your code absolutely needs to compare unrelated pointers for ordering, one
    thing you can do is cast the pointers to `std::intprt_t` or to `std::uintptr_t`
    and compare the (numeric) results instead of comparing the actual pointers. Note
    that compiler support for those two types is optional, although all major compiler
    vendors offer it.
  prefs: []
  type: TYPE_NORMAL
- en: The null pointer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The idea of a null pointer as a recognizable value for pointers that lead to
    nowhere valid can be traced back to C.A.R. Hoare ([https://packt.link/ByfeX](https://packt.link/ByfeX)).
    In the C language, through the `NULL` macro, it has been represented first as
    a `char*` of value `0`, then as a `void*` of value `0`, then in C++ as value `0`
    simply since such things as `int *p = NULL;` with a typed `NULL` were legal C
    but not legal C++. This is because the type system is stricter in C++. Note that
    a pointer with value `0` does not mean “point to address zero” as this address
    is in itself perfectly valid and is used as such on many platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'In C++, the preferred way of expressing a null pointer is `nullptr`, an object
    of the `std::nullptr_t` type that converts to pointers of any type and behaves
    as expected. This solves some longstanding issues with literal `0` in C++, such
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note that `nullptr` is not a pointer; it’s an object that implicitly converts
    to a pointer. For that reason, the `std::is_pointer_v<nullptr>` trait is false,
    and C++ offers a distinct trait named `std::is_null_pointer<T>` to statically
    test whether `T` is a `std::nullptr_t` or not (taking `const` and `volatile` into
    account).
  prefs: []
  type: TYPE_NORMAL
- en: 'Dereferencing a null pointer is UB, just as dereferencing an uninitialized
    pointer is. The point of using `nullptr` in your code is to make that state recognizable:
    `nullptr` is a distinguishable value, whereas an uninitialized pointer could be
    anything.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In C++ (contrary to C), arithmetic on a null pointer is well-defined… as long
    as you add zero to the null pointer. Or, to put it differently: if you add zero
    to a null pointer, the code remains well-defined, but if you add anything else,
    you’re on your own. There’s an explicit provision to that effect in wg21.link/c++draft/expr.add#4.1\.
    This means that the following is correct as in the case of an empty `Array`, `begin()`
    yields `nullptr` and `size()` yields zero, so `end()` effectively computes `nullptr+0`,
    which respects the rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We will return to this `Array` example in more detail in *Chapters 12*, *13*,
    and *14*; it will help us discuss several important aspects of efficient memory
    management techniques. For now, let’s look at another source of risky programming
    maneuvers.
  prefs: []
  type: TYPE_NORMAL
- en: Type punning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another area where a C++ programmer can get into trouble is **type punning**.
    By type punning, we mean techniques that subvert the language’s type system somewhat.
    The consecrated tool to perform type conversions is casts, as they are explicit
    in source code text and (apart from C-style casts) express the intent for the
    conversion, but that topic deserves its own chapter ([*Chapter 3*](B21071_03.xhtml#_idTextAnchor047),
    if you’re wondering).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will examine other ways to achieve type punning, including
    both recommendable ones and others that you should seek to avoid.
  prefs: []
  type: TYPE_NORMAL
- en: Type punning through members of a union
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A union is a type for which the members are all at the same address. The size
    of a union is the size of its largest member, and the alignment of a union is
    the strictest alignment of its members.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: It’s tempting to think that one can use a union to implicitly convert such things
    as a four-byte floating point number into a four-byte integral number, and in
    the C language (not C++), that is indeed possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though there is a widespread belief that this practice is legal in C++,
    the reality is that it is not (with one special caveat, which we will explore
    shortly). Indeed, in C++, the last member of a union one has written to is called
    the union’s `constexpr` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you might know, a `constexpr` function such as `f()` in the preceding example
    cannot contain code that is UB if it is called in a `constexpr` context. This
    sometimes makes it an interesting tool to make a point.
  prefs: []
  type: TYPE_NORMAL
- en: There is a caveat with respect to conversions between `union` members, and that
    caveat is associated with the common initial sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Common initial sequence
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As explained at wg21.link/class.mem.general#23, the `A` and `B` is made of
    their first two members (`int` is layout-compatible with `const int` and `float`
    is layout-compatible with `volatile float`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'With a union, it is possible to read from a non-active member if the value
    read is part of both the common initial sequence of that member and of the active
    member. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note that such type punning should be kept to a minimum, as it can make it harder
    to reason about source code, but it can be quite useful. For example, it can be
    used to implement some interesting underlying representations for classes that
    can have two distinct representations (classes such as `optional` or `string`),
    making it easier to switch from one to the other. Some useful optimizations can
    be built on this.
  prefs: []
  type: TYPE_NORMAL
- en: The intptr_t and uintptr_t types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned earlier in this chapter, one cannot directly compare pointers
    to arbitrary locations in memory in a well-defined manner in C++. One can, however,
    compare the integral values associated with pointers in a well-defined manner,
    such as here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `std::intptr_t` and `std::uintptr_t` types are aliases for integral types
    that are large enough to hold an address. Use the signed type, `intptr_t`, for
    operations that could lead to negative values (for example, subtraction).
  prefs: []
  type: TYPE_NORMAL
- en: The std::memcpy() function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For historical (and C compatibility) reasons, `std::memcpy()` is *special*
    as it can start the lifetime of an object if used appropriately. An incorrect
    use of `std::memcpy()` for type punning would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The reason why this is illegal is that the call to `std::memcpy()` copies a
    `float` object into the storage pointed to by `p`, effectively starting the lifetime
    of a `float` object in that storage. Since `q` is an `int*`, dereferencing it
    is UB.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, the following is legal and shows how `std::memcpy()` can
    be used for type punning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Indeed, in this second example, using `std::memcpy()` to copy the bits from
    `f` to `value` starts the lifetime of `value`. That object can be used as any
    other `int` from that point on.
  prefs: []
  type: TYPE_NORMAL
- en: The special cases of char*, unsigned char*, and std::byte*
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `char*`, `unsigned char*` (not `signed char*`), and `std::byte*` types have
    special status in C++ as they can literally point anywhere and alias anything
    ([wg21.link/basic.lval#11](http://wg21.link/basic.lval#11)). For that reason,
    if you need to access the underlying bytes of the value representation of an object,
    these types are an important tool in your toolbox.
  prefs: []
  type: TYPE_NORMAL
- en: We will, later in this book, occasionally resort to these types to perform low-level
    byte manipulation. Note that such maneuvers are inherently fragile and non-portable,
    as such details as the order of bytes in an integer can vary from platform to
    platform. Use such low-level facilities with care.
  prefs: []
  type: TYPE_NORMAL
- en: The std::start_lifetime_as<T>() function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One last set of facilities for this chapter is `std::start_lifetime_as<T>()`
    and `std::start_lifetime_as_array<T>()`. These functions have been discussed for
    years but came into their own with C++23\. Their role is to take as arguments
    something such as a buffer of raw memory bytes and return a pointer to some `T`
    (pointing to that buffer) whose lifetime has started, such that the pointee can
    be used as such from that point on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This is, again, a low-level feature to be used with care. The intent here is
    to be able to implement such things as low-level file I/O and networking code
    (for example, receiving a UDP packet and treating its value representation as
    if it were an existing object) in pure C++ without falling into a UB trap. We
    will discuss these functions in more detail in [*Chapter 15*](B21071_15.xhtml#_idTextAnchor213).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explored some low-level and sometimes unpleasant facilities that
    we will sometimes use, in order to put up the proper “warning signs” and remind
    us that we have to be responsible and write sensible and correct code even though
    our language of choice gives significant freedom.
  prefs: []
  type: TYPE_NORMAL
- en: When writing advanced memory management facilities in the later chapters of
    this book, these dangerous facilities will sometimes be useful to us. Inspired
    by the contents of this chapter on things to be careful with, we will resort to
    these facilities sparingly, carefully, and in ways that make them hard to misuse.
  prefs: []
  type: TYPE_NORMAL
- en: In our next chapter, we will examine the key C++ casts put at our disposal;
    the intent is to make us aware of what each cast does, as well as when (and to
    what end) it should be used, such that we can thereafter build the powerful memory
    management abstractions we want to use.
  prefs: []
  type: TYPE_NORMAL
