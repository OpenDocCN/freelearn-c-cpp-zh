- en: 3 Working with Vulkan Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Join our book community on Discord
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](img/file40.png)'
  prefs: []
  type: TYPE_IMG
- en: '[https://packt.link/unitydev](https://packt.link/unitydev)'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to get our first triangle on the screen
    using Vulkan. Let’s move forward and learn how to deal with textures and buffers
    to build a modern Vulkan wrapper. The recipes of this chapter will not be focusing
    solely on the graphics APIs but on various tips and tricks necessary to improve
    graphical application development and various 3D graphics algorithms. On the Vulkan
    side, we will cover the basic stuff to get it up and running. The underlying Vulkan
    implementation is based on the *LightweightVK* library ([https://github.com/corporateshark/lightweightvk](https://github.com/corporateshark/lightweightvk)).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with buffers in Vulkan
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing staging buffers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using texture data in Vulkan
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing Vulkan objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Vulkan descriptor indexing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To run the recipes from this chapter, you have to use a Windows or Linux computer
    with a video card and drivers supporting Vulkan 1.3\. Read the previous chapter,
    *Chapter 2, Getting started with Vulkan*, to learn the basics necessary to get
    you started with Vulkan.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with buffers in Vulkan
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Buffers in Vulkan are essentially memory regions that hold arbitrary data capable
    of being accessed by the GPU. To be more precise, Vulkan buffers refer to metadata
    `VkBuffer` connected with memory regions `VkDeviceMemory`. To render a 3D scene
    using the Vulkan API, we have to transform the scene data into a format suitable
    for the GPU. In this recipe, we will describe how to create GPU buffers and upload
    vertex data into them. We will use an open-source asset-loading library, *Assimp*,
    ([https://github.com/assimp/assimp](https://github.com/assimp/assimp)) to load
    a 3D model from an `.obj` file and render it using *LightweightVK* and Vulkan.
    Besides that, the recipe covers some basic usage of the **Vulkan Memory Allocator**
    (**VMA**) library.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Uploading data into GPU buffers is an operation that is executed, just like
    any other Vulkan operation, using command buffers. This means we need to have
    a command queue capable of transfer operations. The creation and usage of command
    buffers were covered in the previous chapter, in the *Using Vulkan command buffers*
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let us start from the high-level code in our sampler application, `Chapter03/01_Assimp`,
    and explore all the way down to the Vulkan API from there:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to load our model from an .obj file with some help from the Assimp
    library. Here is some basic code to do it. Don’t forget that `reserve()` can be
    called on vectors for better performance. For simplicity here, we load just the
    first mesh and read only vertex positions and indices.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now we have to create buffers for loaded vertex positions and indices. Our vertex
    buffer will have a usage flag `BufferUsageBits_Vertex`. We ask *LightweightVK*
    to upload the initial buffer data from `positions.data()` right from the get-go.
    The C++20 designated initializers syntax is very handy for this type of high-level
    API. The index buffer has a corresponding usage flag `BufferUsageBits_Index`.
    Both buffers are stored in GPU memory for better performance. This is ensured
    by specifying the storage type `StorageType_Device`, which is parsed in *LightweightVK*
    to pick an appropriate Vulkan memory type for these buffers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: To render a complicated concave mesh with Vulkan, we have to use a depth buffer.
    We need to create one ourselves as follows. We specify `Format_Z_F32` here but
    the underlying *LightweightVK* Vulkan backend will replace it with whatever closes
    format is actually available on the current Vulkan implementation. The values
    of `width` and `height` correspond to the dimensions of the framebuffer. We are
    going to use the depth texture only as a depth buffer and are not going to sample
    from it, which means specifying usage flags as `TextureUsageBits_Attachment` is
    sufficient.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Before we go forward and create rendering pipelines as was described in the
    previous chapter in the recipe *Initializing Vulkan pipelines*, we have to specify
    the vertex input state for them using the abovementioned vertex buffer. Here’s
    how we can do it. Here, `.location = 0` corresponds to the input location in a
    GLSL vertex shader, which will render this mesh.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now we can create two rendering pipelines. The first one is required to render
    a solid mesh. The other will render a wireframe mesh on top of it. Note that `.depthFormat`
    is set to the format of the depth texture we created earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The second rendering pipeline does wireframe rendering by setting the `.polygonMode`
    field to `PolygonMode_Line`. Both pipelines use the same set of shaders. A specialization
    constant is used to change the shader behavior.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Before we can enter the main loop, we need to define a depth state. The depth
    state enables depth buffer writes and sets an appropriate depth comparison operator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can take a look at the application’s main loop. We skip GLFW events
    pulling and framebuffer size update code here. You can find them in `Chapter03/01_Assimp/src/main.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: The main loop updates the projection matrix `p` based on the current framebuffer
    aspect ratio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Set the model-view matrix to enable a gradual rotation of the model around the
    vertical axis. The model matrix `m` is responsible for aligning the model’s “up”
    direction with the vertical axis in Vulkan. The view matrix `v` is responsible
    for our 3D camera orientation and viewing direction, which rotates slowly around
    the vertical axis `Y`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: A render pass now requires specifying a load operation and a clear value for
    the depth buffer. The framebuffer has only one color-attachment – the current
    swapchain image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: With all preparations done, we can acquire a command buffer as described in
    the recipe *Using Vulkan command buffers* and begin rendering. Curly braces are
    used to emphasize the scope.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Both vertex and index buffers should be bound. The vertex buffer is bound to
    the binding point `0`. The index buffer uses unsigned 32-bit integer values as
    indices.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Let’s render a solid mesh using the first rendering pipeline and the depth state.
    The model-view-projection matrix is sent to the shader using Vulkan push constants.
    Push constants are a performant mechanism to pass very small amounts of data to
    shaders. Vulkan 1.3 guarantees at least `128` bytes for push constants, which
    is sufficient to store `2` 4x4 matrices or `16` arbitrary 64-bit GPU buffer addresses.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Then, we render a wireframe copy of the mesh on top of the solid one. We set
    the depth bias so that wireframe edges are rendered correctly and without flickering.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now the command buffer can be submitted for execution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The demo application should render a colored rotating ducky with a wireframe
    overlay, as in the following screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1: Rendering a mesh loaded with Assimp](img/file15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: Rendering a mesh loaded with Assimp'
  prefs: []
  type: TYPE_NORMAL
- en: The high-level part was easy. Now let’s dive deep into the underlying implementation
    and learn how to implement this lean buffers-management interface using the Vulkan
    API.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s take a look at the low-level Vulkan code to understand how buffers work.
    Our deep dive starts with the exploration of `IContext::createBuffer()`, which
    takes a buffer description structure `BufferDesc` as input:'
  prefs: []
  type: TYPE_NORMAL
- en: The declaration of `BufferDesc` looks as follows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The storage type can be one of the following three enum values: `StorageType_Device`,
    `StorageType_HostVisible`. They correspond to GPU local memory – which is not
    visible from the CPU side – and host-visible memory. The actual Vulkan memory
    type is selected more precisely by the underlying *LightweightVK* code and the
    **VulkanMemoryAllocator** (**VMA**) library.'
  prefs: []
  type: TYPE_NORMAL
- en: The buffer usage mode is a combination of the following flags. These flags are
    very flexible and we can request any necessary combination of them, except that
    uniform and storage buffers are exclusive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s now look into the implementation of `VulkanContext::createBuffer()`,
    which converts requested LightweightVK buffer properties into corresponding supported
    Vulkan flags:'
  prefs: []
  type: TYPE_NORMAL
- en: Before everything else, we should check if a staging buffer should be used to
    upload data into this new buffer. If the staging buffer is disabled, for example,
    because our GPU has only one shared memory heap that is both host-visible and
    device-local, we override the requested device-local storage mode with `StorageType_HostVisible`.
    This is important to eliminate that extra copy on GPUs with such memory configurations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If the application wants a device-local buffer, we should use a staging buffer
    to transfer data into our device-local buffer. Set corresponding Vulkan flags
    to make sure we can transfer to and from such a buffer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: For each requested usage flag, enable a specific set of necessary Vulkan usage
    flags. To use the buffer device address feature and access buffers by pointers
    from shaders, we should add the flag `VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Get required Vulkan memory properties using a helper function and then call
    another variant of `VulkanContext::createBuffer()` that accepts only Vulkan flags.
    Delegation is helpful because this function is used inside the *LightweightVK*
    Vulkan backend to create internal auxiliary buffers. This function checks buffer
    size limits and creates a `VulkanBuffer` object in a corresponding pool.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: If some initial buffer data was provided, upload it immediately.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Let’s take a look at the interface of `VulkanBuffer`, which wraps Vulkan buffer
    management functionality.
  prefs: []
  type: TYPE_NORMAL
- en: All previously obtained Vulkan flags are passed to the class constructor. The
    default constructor is trivial and enables `VulkanBuffer` to be stored in *LightweightVK*
    object pools. We will talk about these pools later in subsequent chapters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: A bunch of methods to get data from the host into and out of buffers. All host-visible
    buffers are automatically mapped so that we can access their data via normal C++
    pointers. The function `flushMappedMemory()` is necessary in case buffers on our
    system do not support coherent memory. This function is called to make the data,
    written into the mapped memory by the host, become available to the GPU. It is
    a wrapper over `vkFlushMappedMemoryRanges()` and `vmaFlushAllocation()` when the
    **Vulkan Memory Allocator** (**VMA**) library is enabled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Data members encapsulate everything necessary related to the underlying Vulkan
    buffer management code. VMA-related fields are used only when the *VMA* library
    is enabled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are ready to create an actual Vulkan buffer object. Let’s take a look
    at the code. Error handling is omitted for the sake of better understanding:'
  prefs: []
  type: TYPE_NORMAL
- en: Constructor parameters are used directly to populate the *VkBufferCreateInfo*
    structure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now we decide whether to use Vulkan directly or let *Vulkan Memory Allocator*
    do all the memory allocation for us. VMA is the main code path, while direct Vulkan
    calls are helpful to do debugging when necessary. In the case of VMA, we convert
    flags once again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Handle host-visible memory-mapped buffers. Use persistent mapping for the entire
    lifetime of the buffer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The direct Vulkan code path is straightforward but requires manual memory allocation.
    Refer to `lvk/vulkan/VulkanClasses.cpp` for full detailed error checking, which
    is omitted here in the text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Host-visible buffers are handled in a similar way.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Let’s set a user-provided debug name for this buffer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Once the buffer is created, get a buffer device address that can be used in
    shaders to access this buffer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The buffer destruction process is interesting and worth mentioning because
    Vulkan buffers should not be deleted while still in use by the GPU. Besides doing
    VMA and Vulkan calls for memory unmapping and deallocation, the destructor defers
    the actual deallocation until the buffer is no longer in use by the GPU:'
  prefs: []
  type: TYPE_NORMAL
- en: If this `VulkanBuffer` object was created with the default constructor and does
    not have any payload, we can just return immediately. The `deferredTask()` member
    function postpones the execution of its lambda argument to a later time when all
    previously submitted command buffers have completed processing. We will look into
    this mechanism in subsequent chapters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: A similar approach is taken when we do not use VMA and talk to Vulkan directly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'There are three other member functions to mention here before we conclude how
    we work with Vulkan buffers:'
  prefs: []
  type: TYPE_NORMAL
- en: The function `flushMappedMemory()` is used to ensure that host writes to the
    buffer mapped memory become available to the GPU when the coherent memory is not
    supported.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The function `getBufferSubData()` wraps a `memcpy()` operation in a convenient
    way. It only works with memory-mapped host-visible buffers. Device-local buffers
    are handled separately using a staging buffer. We will discuss this mechanism
    in subsequent chapters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The function `bufferSubData()` is a similar wrapper. It is trivial for host-visible
    buffers. Note how `memset()` is used here to set the content of the buffer to
    `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Now we’ve covered all the Vulkan code necessary to run the app `Chapter03/01_Assimp`,
    which renders an `.obj` 3D model loaded via *Assimp*. There are two small functions
    to mention that bind vertex and index buffers, respectively, and are part of the
    `ICommandBuffer` interface.
  prefs: []
  type: TYPE_NORMAL
- en: The first function binds a vertex buffer via `vkCmdBindVertexBuffers()` to be
    used for vertex input. A few checks are necessary to ensure the correct usage
    of buffers. In subsequent chapters, we will learn how to omit vertex buffers altogether
    and learn the *Programmable-Vertex-Pulling* (*PVP*) approach.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The second function binds an index buffer using `vkCmdBindIndexBuffer()`. Besides
    assertions, some enum types conversion from *LightweightVK* to the Vulkan API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The application `Chapter03/01_Assimp` should render the following image.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2: Rendering a mesh loaded with Assimp](img/file16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.2: Rendering a mesh loaded with Assimp'
  prefs: []
  type: TYPE_NORMAL
- en: Now we are done with some very basic Vulkan usage and ready to add some textures
    to our examples.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing staging buffers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GPU device-local buffers are not visible from the host, and we can upload data
    into them using various CPU-GPU-CPU copy operations. In Vulkan, this can be done
    by creating an auxiliary buffer, called a staging buffer, which is CPU-visible
    or host-visible, uploading some data into it from the host and then issuing GPU
    commands to copy from this staging buffer into a device-local buffer. Let’s learn
    how to implement this technique in Vulkan.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before reading any further, check out the previous recipe, *Dealing with buffers
    in Vulkan*, to learn how to create different types of Vulkan buffers.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As usual, let’s start from the high-level interface of LightweightVK and then
    dive deep into the implementation. The interface class `IContext` declared in
    `lvk/LVK.h` exposes the following methods to operate on buffers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: These methods are implemented in a subclass `VulkanContext` and roughly correspond
    to the implementation of `VulkanBuffer` that was discussed in detail in the previous
    recipe. We also saw how `VulkanContext::createBuffer()` calls `VulkanContext::uload()`
    in case there’s some initial data to be uploaded into a buffer. Let’s take a look
    at what is inside that method.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we have to convert a buffer handle into a pointer to a `VulkanBuffer`
    object. This is done by a pool that stores all `VulkanBuffer` objects in the system.
    The pool implementation will be discussed in subsequent recipes. For now, let’s
    just pretend that it is an opaque mechanism to map an integer handle into a `VulkanBuffer`
    object pointer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: After doing some range checking, we delegate the work to the member function
    `VulkanStagingDevice::bufferSubData()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The class `VulkanStagingDevice` encapsulates all the functionality necessary
    to manage Vulkan staging buffers.
  prefs: []
  type: TYPE_NORMAL
- en: The staging device provides functionality to access device-local buffers and
    images. In this recipe, we will focus only on the buffers part and 2D images.
    While 3D image uploading is supported by *LightweightVK*, it is not used in our
    book, and we will skip it. If you are interested in learning those details, you
    are encouraged to check the actual source code of *LightweightVK* at `lvk/vulkan/VulkanClasses.cpp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Each call to `bufferSubData()` or `imageData2D()` occupies some space in the
    staging buffer. The structure `MemoryRegionDesc` describes such a memory region
    with one `SubmitHandle` that was used to upload data through it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The function `getNextFreeOffset()` returns the next available memory region
    suitable to accommodate `size` bytes of data. The function `waitAndReset()` is
    used internally to wait until all memory regions become available.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The uploading process is trivial once we understand how the `getNextFreeOffset()`
    helper function works. Let’s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure the requested buffer size is aligned. Some compressed image formats
    require the size to be padded to `16` bytes. We just use that value greedily here.
    A simple binary arithmetic trick is used to ensure the size value is aligned as
    required.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Track the most suitable memory region. Check if we can reuse any of the previously
    used memory regions. This may cause some memory fragmentation in the staging buffer,
    but it’s not a concern since these sub-allocations have a very short lifespan.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Reclaim and return the memory region. If there is no more space available in
    the staging buffer, reclaim all previous memory regions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: If we cannot reuse any previous memory region, allocate a new one from the free
    staging memory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Now we can implement the `VulkanStagingDevice::bufferSubData()` function. The
    main complexity here comes when the size of the data to upload is greater than
    the size of the staging buffer.
  prefs: []
  type: TYPE_NORMAL
- en: If the destination buffer is host-visible, just mem-copy the data into it as
    we discussed in the previous recipe, *Dealing with buffers in Vulkan:*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Iterate while there’s still some data to upload. On each iteration, we try
    to obtain a memory region to fit the entire remaining size. We select a chunk
    size accordingly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The staging buffer itself is always host-visible, so we can mem-copy our data
    into it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Acquire a command buffer and issue Vulkan commands to copy buffer data between
    the staging buffer and the destination buffer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'As the GPU is doing the copying, we add this memory region – together with
    its `SubmitHandle` – to the container of occupied memory regions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Another crucial role of the staging buffer is to copy pixel data into Vulkan
    images. Let’s take a look at how it can be implemented. This function is significantly
    more complicated, so we omit all the error checking again here in the text for
    the sake of better understanding the code.
  prefs: []
  type: TYPE_NORMAL
- en: The `imageData2D()` function can upload in one go multiple layers of an image,
    starting from `layer`, together with multiple mip-levels starting from `baseMipLevel`.
    *LightweightVK* assumes there’s a maximum possible number of mip-levels. We calculate
    the size in bytes of each mip-level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: As we know the base mip-level number that we want to update, we can calculate
    its dimensions from the Vulkan image extents by bit-shifting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Now let us calculate per-layer storage sizes, which are necessary to accommodate
    all corresponding mip-levels of the image. The function `getTextureBytesPerLayer()`
    returns the size in bytes of a layer with the requested image format. Store the
    results in `mipSizes[]`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Now we know the size necessary to store the entire image data. Try to acquire
    the next memory region from the staging buffer. *LightweightVK* provides no support
    for copying image data in multiple smaller chunks. If we get a memory region smaller
    than `storageSize`, we should until a bigger memory region becomes available.
    One consequence of this is that *LightweightVK* is unable to upload images whose
    memory footprint is larger than the staging buffer size.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Once we have a suitable memory region in the staging buffer, we can iterate
    over image layers and mip-levels to prepare the data for Vulkan.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Transition the image layout into `VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL` so that
    we can use it as a destination in Vulkan transfer operations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Copy the pixel data from the staging buffer into the image. The buffer offset
    for this level is at the start of all mip-levels plus the size of all previous
    mip-levels being uploaded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: We are done with this mip-level and layer. Transition its image layout from
    `VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL`, into `VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL`.
    This is necessary for normal workflow as any subsequent code dealing with images
    expects this image layout.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The Vulkan image layout is a property of each image sub-resource that describes
    how the data in memory is organized in some opaque implementation-specific manner.
    This property is considered by the Vulkan implementation when the image is accessed.
    Not specifying correct layouts for different use cases may result in undefined
    behavior and distorted images.
  prefs: []
  type: TYPE_NORMAL
- en: Advance the buffer offset to the next mip-level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Once the Vulkan commands are recorded in the command buffer, we can submit it
    to copy the image data. Before we exit, we set the last image layout to `VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL`
    so that correct image layout transitions can happen later on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: This is all regarding the staging buffers implementation and the uploading device-local
    buffer data and images via them.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*LightweightVK* has a function `VulkanStagingDevice::imageData3D()` to upload
    3D texture data using a staging buffer. It can be found in `lvk/vulkan/VulkanClasses.cpp`.
    Make sure you explore it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There can be a memory heap described by the flags `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT
    | VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT`. Some GPUs can have a separate relatively
    small memory heap like that, while some GPUs can have the entire device memory
    marked as host-visible. This is called Resizable BAR, or ReBAR, which is a hardware
    feature allowing the CPU to access GPU device memory. If you have such a memory
    heap, you can use it to write data to GPU local memory directly. For example,
    you can allocate a staging buffer in that memory. If you want to learn more comprehensive
    details about Vulkan memory types and how to use them, here’s an amazing article
    by Adam Sawicki: `https://asawicki.info/news_1740_vulkan_memory_types_on_pc_and_how_to_use_them`.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have everything we need to know about how to deal with Vulkan images.
    Let’s go to the next recipe and learn how to use Vulkan images to create textures.
  prefs: []
  type: TYPE_NORMAL
- en: Using texture data in Vulkan
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we can write meaningful 3D rendering applications with Vulkan, we need
    to learn how to deal with textures. This recipe shows how to implement a number
    of functions to create, destroy, and modify texture objects on the GPU using the
    Vulkan API.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Uploading texture data to the GPU requires a staging buffer. Read the recipe
    *Dealing with buffers* before you proceed further.
  prefs: []
  type: TYPE_NORMAL
- en: The source code for this recipe can be found in `Chapter03/02_STB`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first thing we do is create an image. A Vulkan image is another type of
    object backed by memory, designed to store 1D, 2D, and 3D images or arrays of
    those images. Readers familiar with OpenGL will probably be wondering about cube
    maps. Cube maps are represented as an array of six 2D images and can be constructed
    by setting the `VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT` flag in the `VkImageCreateInfo`
    structure. We will come back to that later. Now let us investigate the basic use
    case with just a 2D image. Let’s start with the high-level application code and
    go all the way down to Vulkan image allocation:'
  prefs: []
  type: TYPE_NORMAL
- en: The application `Chapter03/02_STB` loads pixel data from a `.jpg` file using
    the STB library ([https://github.com/nothings/stb](https://github.com/nothings/stb)).
    We enforce conversion to 4-channels to simplify texture handling. Many Vulkan
    implementations do not support 3-channel images.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: A handle to a texture object is created. The texture format is normalized unsigned
    8-bit RGBA, which corresponds to the Vulkan format `VK_FORMAT_R8G8B8A8_UNORM`.
    We intend to use this texture for sampling in shaders, so we specify the texture
    usage flag `TextureUsageBits_Sampled`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Do not forget to free the image memory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Let’s take a look at the main loop. *LightweightVK* is built around the bindless
    renderer design. Bindless rendering is a technique that allows for more efficient
    GPU resource management by removing the need to explicitly bind resources, such
    as textures, buffers, or samplers. Here’s how we can pass texture data into shaders
    using push constants. After that, we render a quad formed of `4` triangle strip
    vertices.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The vertices are generated without any vertex input right in the vertex shader
    `Chapter03/02_STB/src/main.vert`, which looks as follows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The fragment shader is much more interesting. We need to declare arrays of 2D
    textures and samplers provided by *LightweightVK*. They contain all textures and
    all samplers loaded at the current moment. The element `0` in both arrays corresponds
    to a dummy object. This is useful for safely utilizing null values as texture
    identifiers. Our push constant `textureId` is nothing but an index into the `kTextures2D`
    array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Here’s a handy helper function `textureBindless2D()` to sample from a bindless
    2D texture using a bindless sampler. We shall use it instead of standard GLSL
    `texture()` to quickly sample a texture.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here we provided the entire fragment shader GLSL source code ourselves. If we
    skip the `#version` directive at the beginning of the shader, *LightweightVK*
    will inject this and many other helper functions into our GLSL source code, together
    with `kTextures2D[]` and other declarations. We will use this functionality in
    subsequent chapters to simplify our shaders. Here we list this function just for
    purely educational reasons.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: In case of not dynamically uniform texture indices, the `nonuniformEXT` type
    qualifier is required by the Vulkan API to be used when indexing descriptor bindings.
  prefs: []
  type: TYPE_NORMAL
- en: The resulting application `Chapter03/02_STB` should render a textured rotating
    quad as in the following screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3: Rendering a textured quad](img/file17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.3: Rendering a textured quad'
  prefs: []
  type: TYPE_NORMAL
- en: The high-level part was pretty short and straightforward, hiding all the Vulkan
    complexity from us. Now let’s take a look at the underlying implementation to
    learn how it works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Vulkan textures, namely images and image views, are complex. Together with descriptor
    sets, they are necessary to access texture data in shaders. The *LightweightVK*
    implementation of textures comes in many layers. Let’s dissect them one by one
    and learn how.
  prefs: []
  type: TYPE_NORMAL
- en: 'The tip of the iceberg is the function `VulkanContext::createTexture()`, which
    returns a handle to a texture. The function is quite long, so we omit the error-checking
    code here again to make it a bit easier to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: This function converts a *LightweightVK* texture description `TextureDesc` into
    various Vulkan flags for images and image views. The extra argument `debugName`
    provides a convenient way to override the `TextureDesc::debugName` field. It is
    very useful if we want to create multiple textures using the same `TextureDesc`
    object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Convert the *LightweightVK* format into Vulkan format. Vulkan has somewhat stronger
    guarantees regarding the support of color formats. Therefore, depth formats are
    converted based on the actual availability, while color formats are converted
    as is.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: If the image is going to be allocated in the GPU device memory, we should set
    the `VK_IMAGE_USAGE_TRANSFER_DST_BIT` to allow Vulkan to transfer data into it.
    Other Vulkan image usage flags are set accordingly to the *LVK* usage flags.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: For convenience, we always allow an image to be read back from the GPU to the
    CPU. However, it might be worth checking if this usage flag is actually supported.
    The memory flags are chosen in the same way as we did for buffers in the recipe
    *Dealing with buffers in Vulkan*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Generate debug names for Vulkan image and image view objects by prefixing the
    provided `debugName` string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Now we can deduce `VkImageCreateFlags` and types of the Vulkan image and image
    view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 2D images can be multisampled ([https://en.wikipedia.org/wiki/Multisample_anti-aliasing](https://en.wikipedia.org/wiki/Multisample_anti-aliasing)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Cube textures in Vulkan can be represented with an image view of the type `VK_IMAGE_VIEW_TYPE_CUBE`
    and a 2D image with a special flag `VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT`. The
    number of layers if multiplied by `6` to accommodate all cube map faces according
    to the Vulkan specification.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Now we can create a wrapper object `VulkanImage` which encapsulates all necessary
    `VkImage` related properties. We will explore the `createImage()` function a bit
    later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: To access a Vulkan image from shaders, we need to create a `VkImageView` object.
    To do so, we have to choose which image “aspect” should be included in the view.
    Images in Vulkan can have multiple aspects simultaneously, such as combined depth-stencil
    images, hence depth and stencil bits are handled separately.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: An image view can control which mip-levels and layers are included. Here we
    create an image view that contains all levels and layers of the image. Later,
    we will need separate image views for framebuffer attachments that can have only
    one layer and one mip-level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '*LightweightVK* calls a pair of objects – `VkImage`, wrapped in the `VulkanImage`
    class, and `VkImageView` – as a texture. The Boolean flag `awaitingCreation_`
    tells `VulkanContext` that a texture was created and the bindless descriptor set
    has to be updated. We will come back to this in the next chapters.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Before we return a handle to the newly created texture, let’s upload the initial
    texture data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: The abovementioned helper function `createImage()` creates a `VulkanImage` object.
    It does some error checking, which is omitted here, and delegates the actual work
    to the constructor of `VulkanImage`. Here’s its implementation just for convenience.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: We will be more interested in the `VulkanImage` constructor, which creates an
    actual `VkImage` object.
  prefs: []
  type: TYPE_NORMAL
- en: The constructor takes a bunch of parameters describing all necessary Vulkan
    properties of the image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Using these parameters, we can fill in the `VkImageCreateInfo` structure right
    away. LightweightVK does not work with multiple Vulkan queues, so it sets the
    sharing mode to `VK_SHARING_MODE_EXCLUSIVE`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: In the same way that we dealt with buffers in the recipe *Dealing with buffers
    in Vulkan*, we have two code paths for Vulkan images. One uses the *Vulkan Memory
    Allocator* library and the other calls Vulkan directly to allocate memory. This
    is useful for debugging purposes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: We can have memory-mapped images in the same way we have memory-mapped buffers.
    However, this is only useful for non-tiled image layouts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: The direct Vulkan code path is quite similar. We call `vkCreateImage()` and
    then allocate some memory and bind it using `vkBindImageMemory()`. Memory allocation
    is done in the same way as we did earlier in this chapter for buffers in the recipe
    *Dealing with buffers in Vulkan*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Before exiting, set the debug name of the created `VkImage` object and retrieve
    physical device format properties for further use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Once we have a `VulkanImage` wrapper object, we can create an image view. This
    is much simpler and can be done using a short member `createImageView()` function.
  prefs: []
  type: TYPE_NORMAL
- en: This function does not use any wrappers and creates a `VkImageView` object directly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: If a non-zero `numLevels` argument was provided, we would use it to override
    the number of mip-levels we want to have in this new image view. Otherwise, we
    use all mip-levels available in the current image to create the image view. This
    is handy because image views for framebuffer attachments should have only `1`
    mip-level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: The `VkImage` and `VkImageView` objects created above can represent a texture.
    *LightweightVK* groups them together into the `VulkanTexture` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `VulkanTexture` class is just a data container and the only
    interesting part is the `getOrCreateVkImageViewForFramebuffer()` function. As
    we mentioned earlier, image views that are used as framebuffer attachments should
    have only `1` mip-level and `1` layer. This function precaches such image views
    in a simple way inside the array `imageViewForFramebuffer_[][]`. It supports a
    maximum of only `6` layers – this is just enough to render into the faces of a
    cube map.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While technically all of the abovementioned code is sufficient to create `VkImage`
    and `VkImageView` objects, we still cannot access them from shaders. To do that,
    we need to learn how to store these objects and how to create and manage Vulkan
    descriptor sets. Let’s move on to the next recipes to learn that.
  prefs: []
  type: TYPE_NORMAL
- en: Storing Vulkan objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous recipes, we mentioned a plethora of `lvk::…Handle` classes wrapped
    in a unique-pointer-like class `lvk::Holder`. They are central to how *LightweightVK*
    manages Vulkan objects and other resources. Handles are lightweight value types
    that are cheap to pass around as integers and we pay no costs of shared ownership
    with atomic counters compared to `std::shared_ptr` and similar reference-counted
    smart pointers. When having ownership of some object is desirable, we wrap handles
    in the `lvk::Holder` class, which conceptually is similar to `std::unique_ptr`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *LightweightVK* implementation of handles is inspired by Sebastian Aaltonen`s
    SIGGRAPH 2023 presentation *HypeHype Mobile Rendering Architecture*. If you want
    to learn more low-level interesting details about an API design using handles,
    make sure to read: [https://advances.realtimerendering.com/s2023/AaltonenHypeHypeAdvances2023.pdf](https://advances.realtimerendering.com/s2023/AaltonenHypeHypeAdvances2023.pdf).'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An abstract handle is represented by a templated class `Handle<>`:'
  prefs: []
  type: TYPE_NORMAL
- en: Handles are designed to serve as pointers to objects that are stored in arrays.
    An index into an array is sufficient to identify an object. To handle situations
    when objects are deallocated and then replaced by other objects, we introduce
    a value `gen_`, which represents the object’s “generation” and is incremented
    every time a new object is assigned to the same element in the storage array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: These values are private so that handles can be constructed only by a friendly
    `Pool` class. The `Pool` class is templated and is parametrized by two types;
    one corresponds to the handle`s object type and the other is the type stored inside
    the implementation array. It is not visible from the interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: The contract is that handles with a generation equal to 0 are considered empty
    null-handles.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: The `indexAsVoid()` function is helpful when we need to pass a handle through
    some third-party C-style interface that accepts `void*` parameters. One example
    used in this book is *ImGui* integration, which is discussed in the next chapter,
    *Chapter 4*, *Adding User Interaction and Productivity Tools*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: The explicit conversion to `bool` is necessary to allow the usage of handles
    in conditional statements such as `if (handle) …`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: The `Handle<>` template can be parametrized with a forward-declared object,
    which is never defined. This is done to ensure type safety so that heterogenous
    handles cannot be mixed with each other. Here is how *LightweightVK* declares
    all its `Handle<>` types. All structs are declared but not defined.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Handles do not own the objects they point to. Only the `Holder<>` class does.
    Let’s take a look at its implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Holder<>` class is templated with a `Handle` type it can hold. The constructor
    accepts a handle and a pointer to `lvk::IContext` to ensure the handle can be
    destroyed properly. The class has move-only semantics similar to `std::unique_ptr`.
    We skip definitions of the move constructor and move assignment for the sake of
    brevity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: We do not have a declaration of the `IContext` class here. That is why we use
    an overloaded forward-declared function `lvk::destroy()` to deallocate the handle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Assign `nullptr` to a holder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Manually reset the holder and make it deallocate the stored handle or just
    return the handle and release ownership when necessary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: The `Holder` class calls a family of overloaded `destroy()` functions. Here
    is how *LightweightVK* defines them, once function per each handle type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Implementations of these functions are located in `lightweightvk/lvk/LVK.cpp`
    and they all look very similar. Each function calls a corresponding overloaded
    method in `IContext`. While it may seem unnecessary, this actually helps to avoid
    a circular dependency between the `Holder` class and `IContext`, making the interface
    much cleaner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: That is all there is to discuss about the `Holder` class and the portion of
    the Handle-Holder mechanism exposed in the interface. Now, let’s delve into the
    implementation and understand how object `Pool`s can be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The implementation starts with a class `Pool<>`, which is located in `lightweightvk/lvk/Pool.h`.
    It stores a collection of objects of type `ImplObjectType` inside `std::vector`
    and can manage handles to these objects. Let’s look at the implementation details:'
  prefs: []
  type: TYPE_NORMAL
- en: Every array element is a struct `PoolEntry` that stores an `ImplObjectType`
    object by value together with its generation used to check handles that point
    to this element. The field `nextFree_` is used to maintain a linked list of free
    elements inside the array. Once a handle is deallocated, a corresponding array
    element is added to the free list. The field `freeListHead_` stores an index of
    the first free element, or `kListEndSentinel` if there are no free elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Proponents of data-oriented design may argue that this structure minimizes cache
    utilization by interleaving the payload of `ImplObjectType` with utility values
    `gen_` and `nextFree_`. This is indeed true. One approach to mitigate this is
    to maintain two separate arrays. The first array can tightly pack `ImplObjectType`
    values, while the second one can store the necessary metadata for bookkeeping.
    In fact, it can go a step further, as mentioned in the original presentation by
    Sebastian Aaltonen, by separating a high-frequency accessed “hot” object type
    from a low-frequency accessed “cold” type, which can be stored in different arrays.
    However, for the sake of simplicity, we will leave this as an exercise for our
    readers.
  prefs: []
  type: TYPE_NORMAL
- en: A method to create a new handle takes an R-value reference. It checks the head
    of the free list. If there is a free element within the array, we can promptly
    place our object into it and remove the front element from the free list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: If there’s no space inside, append a new element to the `std::vector` container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Destruction is simple but involves some additional error checking. Empty handles
    should not be destroyed. Trying to remove a non-empty handle from an empty pool
    means a logic error and should assert. If the generation of the handle does not
    match the generation of the corresponding array element, it means we are trying
    to do double-deletion.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: If all the checks are successful, replace the stored object with an empty default-constructed
    object and increment its generation. Then, place this array element at the front
    of the free list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Dereferencing a handle is done via the `get()` method, which has `const` and
    non-`const` implementations. They are identical, so we can check only one. A mismatch
    of the generation allows us to identify access to a deleted object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: A pool can be manually cleared so that a destructor is called for every object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: The member field `numObjects_` is used to track memory leaks and prevent deallocations
    inside an empty pool.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: That is how `Pool`s work. The actual implementation in `VulkanContext` uses
    them to store all implementation-specific objects that are accessible by handles
    from the interface side. These are the declarations that can be found in `lightweightvk/lvk/vulkan/VulkanClasses.h`.
    In many situations, Vulkan objects – such as `VkShaderModule` and `VkSampler`
    – can be stored directly. If some additional bookkeeping is required, a wrapper
    object is stored instead.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Now we know how to store various objects and expose access to them via handles.
    Before we can conclude the topic of this chapter and finish our introduction to
    Vulkan, let’s take a look at how to construct bindless descriptor sets to access
    textures from GLSL shaders.
  prefs: []
  type: TYPE_NORMAL
- en: Using Vulkan descriptor indexing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Descriptor indexing became a part of the Vulkan core in version 1.2 as an optional
    feature. Vulkan 1.3 made it mandatory. This feature allows applications to put
    all the resources they have into one huge descriptor set and make it available
    to all shaders. There is no need to manage descriptor pools, and no need to construct
    per-shader descriptor sets. Everything is available to the shaders at once. Shaders
    can access all resources in the system, and the only practical limit is performance.
  prefs: []
  type: TYPE_NORMAL
- en: Let us learn how to work with descriptor sets and descriptor indexing Vulkan
    by exploring the *LightweightVK* framework.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s take a look at some parts of the `lvk::VulkanContext` class that deals
    with descriptors. The `VulkanContext` class declaration in `lightweightvk/lvk/vulkan/VulkanClasses.h`
    contains these member fields. The integer variables store the maximal number of
    resources that can be stored in the currently allocated descriptor set `vkDSet_`,
    which is allocated from a descriptor pool `vkDPool_`. The descriptor pool is allocated
    according to the descriptor set layout `vkDSL_`. The submit handle `lastSubmitHandle_`
    corresponds to the last submit this descriptor set was a part of. Submit handles
    were discussed in the previous chapter in the recipe *Using Vulkan command buffers*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s start our exploration with the function `growDescriptorPool()`, which
    recreates Vulkan objects as needed to accommodate the requested number of textures
    and samplers. Excessive error checking is omitted for the sake of readability:'
  prefs: []
  type: TYPE_NORMAL
- en: First, error checking is done to ensure the number of resources is within the
    hardware-specific limits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Deallocate previous Vulkan resources if they exist.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Create a new descriptor set layout, which is going to be shared by all Vulkan
    pipelines. It should contain all Vulkan resources *LightweightVK* supports – sampled
    images, samplers, and storage images.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: The descriptor indexing feature allows descriptor sets to be updated after they
    were bound.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: A chain of Vulkan `Vk…CreateInfo` structures should be prepared to create a
    desired `VkDesciptorSetLayout` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Using this newly created descriptor set layout, we can create a new descriptor
    pool. Note the flag `VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT`, which is
    required to support the corresponding flag for the descriptor set layout `VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Now we can allocate one descriptor set from the descriptor pool `vkDPool_`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: To create Vulkan pipelines, we need a pipeline layout. The pipeline layout in
    *LightweightVK* is shared between all pipelines. In Vulkan 1.3, it would be sufficient
    to use a single descriptor set layout `vkDSL_` to create the pipeline layout.
    However, *LightweightVK* supports running on Mac using MoltenVK and *Metal Shading
    Language* cannot support aliasing of descriptor sets in shaders. Hence, we do
    the duplication here to prevent aliasing and keep compatibility with MoltenVK.
    We set the size of push constants to `128` bytes, which is the maximal guaranteed
    size by the Vulkan specification.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'The `growDescriptorPool()` function was the first part of our descriptor set
    management mechanism. We have a descriptor set and we have to update it. Updating
    is done in another function, `checkAndUpdateDescriptorSets()`, which is called
    before we can dispatch Vulkan draw calls. Some parts of error checking have been
    left out once again:'
  prefs: []
  type: TYPE_NORMAL
- en: Newly created resources can be used immediately – make sure they are put into
    descriptor sets. We discussed the texture creation process earlier in the recipe
    *Using texture data in Vulkan*. Once a new texture is created, the flag `awaitingCreation_`
    is set to signal that we need to update the descriptor set. If there are no new
    textures or samplers, no descriptor set updates are required.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: As we learned from the previous recipe, *Storing Vulkan objects*, textures and
    samplers are stored in pools within `VulkanContext`. Here we grow the descriptor
    pool as needed to accommodate all those textures and samplers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: Let’s prepare Vulkan structures to update the descriptor set with sampled and
    storage images. *LightweightVK* always stores a dummy texture at the index `0`
    to avoid sparse arrays in GLSL shaders and enable all shaders to safely sample
    non-existing textures.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Iterate over the pool of textures and fill in the `VkDescriptorImageInfo` structures
    according to the image properties. Multisampled images can be accessed from shaders
    only using `texelFetch()`. This is not supported by *LightweightVK*, so we will
    skip this here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: Images are expected to be in specific image layouts. Sampled images should use
    `VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL`, while storage images should use `VK_IMAGE_LAYOUT_GENERAL`.
    *LightweightVK* ensures proper image layout conversions automatically. We will
    talk about it in subsequent chapters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: Samplers are handled in a very similar way.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'The structure `VkWriteDescriptorSet` specifies parameters of a descriptor set
    write operation. We need to fill in one structure per each of our `3` bindings
    that correspond to `3` different descriptor types: `VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE`,
    `VK_DESCRIPTOR_TYPE_SAMPLER`, and `VK_DESCRIPTOR_TYPE_STORAGE_IMAGE`. This code
    snippet is straightforward but somewhat lengthy. We include it here in its entirety
    for your reference.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: If we have filled in any `VkWriteDescriptorSet` structures, invoke the Vulkan
    function `vkUpdateDescriptorSets()` to update the descriptor set. Since we are
    updating the entire descriptor set, it is essential to ensure that Vulkan is not
    using it by calling `wait()` with the last known submit handle. This mechanism
    was discussed in the previous chapter in the recipe *Using Vulkan command buffers*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: The C++ part of the descriptor set updating process is concluded. The only remaining
    part now is how to access these descriptor sets from GLSL shaders. Let’s learn
    how it works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`VulkanContext` injects some helper code into GLSL shaders to simplify the
    workflow with our bindless descriptor sets. Let’s recall the function `VulkanContext::createShaderModule()`,
    which does the injection. Here’s the GLSL code that automatically inserts into
    every fragment shader:'
  prefs: []
  type: TYPE_NORMAL
- en: First, it declares some unbound arrays that are stored in our bindless descriptor
    set. Here, you’ll notice that the descriptor set ID ranges from `0` to `2`. However,
    don’t be misled by this; it is the same descriptor set bound to three different
    locations. As demonstrated earlier in this recipe, this is necessary to ensure
    compatibility with *MoltenVK*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: Then, some helper functions are added. These functions correspond to the standard
    GLSL functions, such as `texture()`, `textureLod()`, and others. These functions
    streamline the process of working with descriptor indexing. We list here only
    some of them so you can get the overall picture.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: With this, our GLSL fragment shader `Chapter03/02_STB/main.frag` can be rewritten
    as follows without any manual declarations of the lengthy data structures.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: With the bindless descriptor set code in place, we can render textured objects
    such as the one in the following image.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4: Rendering a textured quad](img/img_chapter03_image5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.4: Rendering a textured quad'
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The topic of efficient resource management in Vulkan is vast and complicated.
    We will return to descriptor set management later when we discuss 3D scene data
    management and the rendering of complex multitextured materials.
  prefs: []
  type: TYPE_NORMAL
