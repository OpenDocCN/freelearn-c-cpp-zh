- en: 3 Working with Vulkan Objects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 使用 Vulkan 对象
- en: Join our book community on Discord
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 书籍社区
- en: '![](img/file40.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/file40.png)'
- en: '[https://packt.link/unitydev](https://packt.link/unitydev)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/unitydev](https://packt.link/unitydev)'
- en: In the previous chapter, we learned how to get our first triangle on the screen
    using Vulkan. Let’s move forward and learn how to deal with textures and buffers
    to build a modern Vulkan wrapper. The recipes of this chapter will not be focusing
    solely on the graphics APIs but on various tips and tricks necessary to improve
    graphical application development and various 3D graphics algorithms. On the Vulkan
    side, we will cover the basic stuff to get it up and running. The underlying Vulkan
    implementation is based on the *LightweightVK* library ([https://github.com/corporateshark/lightweightvk](https://github.com/corporateshark/lightweightvk)).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用 Vulkan 在屏幕上显示我们的第一个三角形。让我们继续前进，学习如何处理纹理和缓冲区来构建一个现代的 Vulkan 包装器。本章的食谱将不仅关注图形
    API，还将涵盖提高图形应用程序开发和各种 3D 图形算法所必需的各种技巧和窍门。在 Vulkan 方面，我们将涵盖使其运行的基本内容。底层 Vulkan
    实现基于 *LightweightVK* 库 ([https://github.com/corporateshark/lightweightvk](https://github.com/corporateshark/lightweightvk))。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下食谱：
- en: Dealing with buffers in Vulkan
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Vulkan 中处理缓冲区
- en: Implementing staging buffers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现阶段缓冲区
- en: Using texture data in Vulkan
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Vulkan 中使用纹理数据
- en: Storing Vulkan objects
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储 Vulkan 对象
- en: Using Vulkan descriptor indexing
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Vulkan 描述符索引
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术要求
- en: To run the recipes from this chapter, you have to use a Windows or Linux computer
    with a video card and drivers supporting Vulkan 1.3\. Read the previous chapter,
    *Chapter 2, Getting started with Vulkan*, to learn the basics necessary to get
    you started with Vulkan.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行本章的食谱，您必须使用配备支持 Vulkan 1.3 的显卡和驱动程序的 Windows 或 Linux 计算机。阅读上一章，*第二章，Vulkan
    入门*，以了解开始使用 Vulkan 所必需的基本知识。
- en: Dealing with buffers in Vulkan
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Vulkan 中处理缓冲区
- en: Buffers in Vulkan are essentially memory regions that hold arbitrary data capable
    of being accessed by the GPU. To be more precise, Vulkan buffers refer to metadata
    `VkBuffer` connected with memory regions `VkDeviceMemory`. To render a 3D scene
    using the Vulkan API, we have to transform the scene data into a format suitable
    for the GPU. In this recipe, we will describe how to create GPU buffers and upload
    vertex data into them. We will use an open-source asset-loading library, *Assimp*,
    ([https://github.com/assimp/assimp](https://github.com/assimp/assimp)) to load
    a 3D model from an `.obj` file and render it using *LightweightVK* and Vulkan.
    Besides that, the recipe covers some basic usage of the **Vulkan Memory Allocator**
    (**VMA**) library.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Vulkan 中的缓冲区本质上是指持任意数据且能够被 GPU 访问的内存区域。更准确地说，Vulkan 缓冲区指的是与内存区域 `VkDeviceMemory`
    相连的元数据 `VkBuffer`。要使用 Vulkan API 渲染 3D 场景，我们必须将场景数据转换为适合 GPU 的格式。在本食谱中，我们将描述如何创建
    GPU 缓冲区并将顶点数据上传到其中。我们将使用开源的资产加载库 *Assimp* ([https://github.com/assimp/assimp](https://github.com/assimp/assimp))
    从 `.obj` 文件中加载 3D 模型，并使用 *LightweightVK* 和 Vulkan 进行渲染。此外，食谱还涵盖了 *Vulkan 内存分配器*
    (*VMA*) 库的一些基本用法。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: Uploading data into GPU buffers is an operation that is executed, just like
    any other Vulkan operation, using command buffers. This means we need to have
    a command queue capable of transfer operations. The creation and usage of command
    buffers were covered in the previous chapter, in the *Using Vulkan command buffers*
    recipe.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据上传到 GPU 缓冲区是像任何其他 Vulkan 操作一样通过命令缓冲区执行的运算。这意味着我们需要一个能够执行传输操作的命令队列。命令缓冲区的创建和使用在上一章的
    *使用 Vulkan 命令缓冲区* 食谱中已有介绍。
- en: How to do it...
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Let us start from the high-level code in our sampler application, `Chapter03/01_Assimp`,
    and explore all the way down to the Vulkan API from there:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们的采样应用程序中的高级代码开始，`Chapter03/01_Assimp`，并从那里探索到 Vulkan API：
- en: First, we need to load our model from an .obj file with some help from the Assimp
    library. Here is some basic code to do it. Don’t forget that `reserve()` can be
    called on vectors for better performance. For simplicity here, we load just the
    first mesh and read only vertex positions and indices.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要借助 Assimp 库从 .obj 文件中加载我们的模型。以下是一些基本的代码来完成这项工作。不要忘记，为了更好的性能，可以在向量上调用
    `reserve()`。为了简单起见，我们只加载第一个网格，并只读取顶点位置和索引。
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now we have to create buffers for loaded vertex positions and indices. Our vertex
    buffer will have a usage flag `BufferUsageBits_Vertex`. We ask *LightweightVK*
    to upload the initial buffer data from `positions.data()` right from the get-go.
    The C++20 designated initializers syntax is very handy for this type of high-level
    API. The index buffer has a corresponding usage flag `BufferUsageBits_Index`.
    Both buffers are stored in GPU memory for better performance. This is ensured
    by specifying the storage type `StorageType_Device`, which is parsed in *LightweightVK*
    to pick an appropriate Vulkan memory type for these buffers.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们必须为加载的顶点位置和索引创建缓冲区。我们的顶点缓冲区将具有使用标志 `BufferUsageBits_Vertex`。我们要求 *LightweightVK*
    从 `positions.data()` 开始上传初始缓冲区数据。C++20 的指定初始化器语法对于这种高级 API 非常方便。索引缓冲区有一个相应的使用标志
    `BufferUsageBits_Index`。这两个缓冲区都存储在 GPU 内存中以提高性能。这通过指定存储类型 `StorageType_Device`
    来确保，它在 *LightweightVK* 中被解析以选择这些缓冲区的适当 Vulkan 内存类型。
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To render a complicated concave mesh with Vulkan, we have to use a depth buffer.
    We need to create one ourselves as follows. We specify `Format_Z_F32` here but
    the underlying *LightweightVK* Vulkan backend will replace it with whatever closes
    format is actually available on the current Vulkan implementation. The values
    of `width` and `height` correspond to the dimensions of the framebuffer. We are
    going to use the depth texture only as a depth buffer and are not going to sample
    from it, which means specifying usage flags as `TextureUsageBits_Attachment` is
    sufficient.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用 Vulkan 渲染复杂的凹面网格，我们必须使用深度缓冲区。我们需要自己创建一个，如下所示。在这里我们指定 `Format_Z_F32`，但底层的
    *LightweightVK* Vulkan 后端会将其替换为当前 Vulkan 实现上实际可用的最接近的格式。`width` 和 `height` 的值对应于帧缓冲区的尺寸。我们只将深度纹理用作深度缓冲区，不会从中采样，这意味着指定使用标志为
    `TextureUsageBits_Attachment` 就足够了。
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Before we go forward and create rendering pipelines as was described in the
    previous chapter in the recipe *Initializing Vulkan pipelines*, we have to specify
    the vertex input state for them using the abovementioned vertex buffer. Here’s
    how we can do it. Here, `.location = 0` corresponds to the input location in a
    GLSL vertex shader, which will render this mesh.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们继续创建渲染管线之前，正如在上一章的食谱“初始化 Vulkan 管线”中所描述的，我们必须使用上述顶点缓冲区为它们指定顶点输入状态。以下是我们可以这样做的方法。在这里，`.location
    = 0` 对应于 GLSL 顶点着色器中的输入位置，它将渲染此网格。
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now we can create two rendering pipelines. The first one is required to render
    a solid mesh. The other will render a wireframe mesh on top of it. Note that `.depthFormat`
    is set to the format of the depth texture we created earlier.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以创建两个渲染管线。第一个用于渲染实体网格。另一个将在其上方渲染线框网格。注意，`.depthFormat` 设置为我们之前创建的深度纹理的格式。
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The second rendering pipeline does wireframe rendering by setting the `.polygonMode`
    field to `PolygonMode_Line`. Both pipelines use the same set of shaders. A specialization
    constant is used to change the shader behavior.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个渲染管线通过将 `.polygonMode` 字段设置为 `PolygonMode_Line` 来执行线框渲染。两个管线使用相同的着色器集。使用一个专用常量来改变着色器的行为。
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Before we can enter the main loop, we need to define a depth state. The depth
    state enables depth buffer writes and sets an appropriate depth comparison operator.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们可以进入主循环之前，我们需要定义一个深度状态。深度状态启用深度缓冲区写入并设置适当的深度比较运算符。
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now we can take a look at the application’s main loop. We skip GLFW events
    pulling and framebuffer size update code here. You can find them in `Chapter03/01_Assimp/src/main.cpp`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看看应用程序的主循环。这里我们跳过了 GLFW 事件拉取和帧缓冲区大小更新代码。你可以在 `Chapter03/01_Assimp/src/main.cpp`
    中找到它们：
- en: The main loop updates the projection matrix `p` based on the current framebuffer
    aspect ratio.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主循环根据当前帧缓冲区宽高比更新投影矩阵 `p`。
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Set the model-view matrix to enable a gradual rotation of the model around the
    vertical axis. The model matrix `m` is responsible for aligning the model’s “up”
    direction with the vertical axis in Vulkan. The view matrix `v` is responsible
    for our 3D camera orientation and viewing direction, which rotates slowly around
    the vertical axis `Y`.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置模型视图矩阵以启用模型绕垂直轴的逐渐旋转。模型矩阵 `m` 负责将模型的“向上”方向与 Vulkan 中的垂直轴对齐。视图矩阵 `v` 负责我们的
    3D 相机方向和观察方向，它围绕垂直轴 `Y` 缓慢旋转。
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: A render pass now requires specifying a load operation and a clear value for
    the depth buffer. The framebuffer has only one color-attachment – the current
    swapchain image.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在渲染通道需要指定深度缓冲区的加载操作和清除值。帧缓冲区只有一个颜色附件 - 当前的交换链图像。
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With all preparations done, we can acquire a command buffer as described in
    the recipe *Using Vulkan command buffers* and begin rendering. Curly braces are
    used to emphasize the scope.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备工作完成后，我们可以按照*使用Vulkan命令缓冲区*的说明获取命令缓冲区，并开始渲染。大括号用于强调范围。
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Both vertex and index buffers should be bound. The vertex buffer is bound to
    the binding point `0`. The index buffer uses unsigned 32-bit integer values as
    indices.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 顶点缓冲区和索引缓冲区都应该被绑定。顶点缓冲区绑定到绑定点`0`。索引缓冲区使用无符号32位整数作为索引。
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Let’s render a solid mesh using the first rendering pipeline and the depth state.
    The model-view-projection matrix is sent to the shader using Vulkan push constants.
    Push constants are a performant mechanism to pass very small amounts of data to
    shaders. Vulkan 1.3 guarantees at least `128` bytes for push constants, which
    is sufficient to store `2` 4x4 matrices or `16` arbitrary 64-bit GPU buffer addresses.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用第一个渲染管线和深度状态渲染一个实体网格。模型视图投影矩阵通过Vulkan推送常数发送到着色器。推送常数是一种高效机制，用于将非常少量的数据传递给着色器。Vulkan
    1.3保证至少有`128`字节的推送常数，这足以存储`2`个4x4矩阵或`16`个任意的64位GPU缓冲区地址。
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Then, we render a wireframe copy of the mesh on top of the solid one. We set
    the depth bias so that wireframe edges are rendered correctly and without flickering.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们在实体网格的上方渲染网格的线框副本。我们设置深度偏移，以便正确且无闪烁地渲染线框边缘。
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now the command buffer can be submitted for execution.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在可以将命令缓冲区提交以执行。
- en: '[PRE14]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The demo application should render a colored rotating ducky with a wireframe
    overlay, as in the following screenshot.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 演示应用程序应该渲染一个带有线框覆盖的彩色旋转鸭，如下面的截图所示。
- en: '![Figure 3.1: Rendering a mesh loaded with Assimp](img/file15.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1：使用Assimp加载的网格渲染](img/file15.png)'
- en: 'Figure 3.1: Rendering a mesh loaded with Assimp'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1：使用Assimp加载的网格渲染
- en: The high-level part was easy. Now let’s dive deep into the underlying implementation
    and learn how to implement this lean buffers-management interface using the Vulkan
    API.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 高级部分很容易。现在让我们深入到底层实现，学习如何使用Vulkan API实现这个精简的缓冲区管理接口。
- en: How it works…
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let’s take a look at the low-level Vulkan code to understand how buffers work.
    Our deep dive starts with the exploration of `IContext::createBuffer()`, which
    takes a buffer description structure `BufferDesc` as input:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看低级Vulkan代码，以了解缓冲区是如何工作的。我们的深入探索从`IContext::createBuffer()`开始，它接受一个缓冲区描述结构`BufferDesc`作为输入：
- en: The declaration of `BufferDesc` looks as follows.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`BufferDesc`的声明如下。'
- en: '[PRE15]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The storage type can be one of the following three enum values: `StorageType_Device`,
    `StorageType_HostVisible`. They correspond to GPU local memory – which is not
    visible from the CPU side – and host-visible memory. The actual Vulkan memory
    type is selected more precisely by the underlying *LightweightVK* code and the
    **VulkanMemoryAllocator** (**VMA**) library.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 存储类型可以是以下三个枚举值之一：`StorageType_Device`、`StorageType_HostVisible`。它们对应于GPU本地内存——从CPU端不可见——和主机可见内存。实际的Vulkan内存类型由底层的*LightweightVK*代码和**VulkanMemoryAllocator**（**VMA**）库更精确地选择。
- en: The buffer usage mode is a combination of the following flags. These flags are
    very flexible and we can request any necessary combination of them, except that
    uniform and storage buffers are exclusive.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 缓冲区使用模式是以下标志的组合。这些标志非常灵活，我们可以请求任何必要的组合，除了统一和存储缓冲区是互斥的。
- en: '[PRE16]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let’s now look into the implementation of `VulkanContext::createBuffer()`,
    which converts requested LightweightVK buffer properties into corresponding supported
    Vulkan flags:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看`VulkanContext::createBuffer()`的实现，它将请求的LightweightVK缓冲区属性转换为相应的支持Vulkan标志：
- en: Before everything else, we should check if a staging buffer should be used to
    upload data into this new buffer. If the staging buffer is disabled, for example,
    because our GPU has only one shared memory heap that is both host-visible and
    device-local, we override the requested device-local storage mode with `StorageType_HostVisible`.
    This is important to eliminate that extra copy on GPUs with such memory configurations.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在所有其他事情之前，我们应该检查是否应该使用一个阶段缓冲区来将数据上传到这个新的缓冲区。例如，如果阶段缓冲区被禁用，因为我们的GPU只有一个既是主机可见又是设备本地的共享内存堆，我们将使用`StorageType_HostVisible`覆盖请求的设备本地存储模式。这对于消除具有这种内存配置的GPU上的额外复制非常重要。
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If the application wants a device-local buffer, we should use a staging buffer
    to transfer data into our device-local buffer. Set corresponding Vulkan flags
    to make sure we can transfer to and from such a buffer.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果应用程序想要设备本地缓冲区，我们应该使用一个阶段缓冲区将数据传输到我们的设备本地缓冲区。设置相应的 Vulkan 标志以确保我们可以传输到和从这个缓冲区。
- en: '[PRE18]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: For each requested usage flag, enable a specific set of necessary Vulkan usage
    flags. To use the buffer device address feature and access buffers by pointers
    from shaders, we should add the flag `VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT`.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个请求的使用标志，启用一组必要的特定 Vulkan 使用标志。要使用缓冲区设备地址功能并通过指针从着色器访问缓冲区，我们应该添加标志 `VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT`。
- en: '[PRE19]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Get required Vulkan memory properties using a helper function and then call
    another variant of `VulkanContext::createBuffer()` that accepts only Vulkan flags.
    Delegation is helpful because this function is used inside the *LightweightVK*
    Vulkan backend to create internal auxiliary buffers. This function checks buffer
    size limits and creates a `VulkanBuffer` object in a corresponding pool.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用辅助函数获取所需的 Vulkan 内存属性，然后调用 `VulkanContext::createBuffer()` 的另一个变体，该变体只接受 Vulkan
    标志。委托很有用，因为这个函数在 *LightweightVK* Vulkan 后端内部使用来创建内部辅助缓冲区。这个函数检查缓冲区大小限制并在相应的池中创建
    `VulkanBuffer` 对象。
- en: '[PRE20]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If some initial buffer data was provided, upload it immediately.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果提供了初始缓冲区数据，则立即上传。
- en: '[PRE21]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Let’s take a look at the interface of `VulkanBuffer`, which wraps Vulkan buffer
    management functionality.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `VulkanBuffer` 的接口，它封装了 Vulkan 缓冲区管理功能。
- en: All previously obtained Vulkan flags are passed to the class constructor. The
    default constructor is trivial and enables `VulkanBuffer` to be stored in *LightweightVK*
    object pools. We will talk about these pools later in subsequent chapters.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有之前获得的 Vulkan 标志都传递给类构造函数。默认构造函数很简单，使 `VulkanBuffer` 能够存储在 *LightweightVK*
    对象池中。我们将在后续章节中讨论这些池。
- en: '[PRE22]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: A bunch of methods to get data from the host into and out of buffers. All host-visible
    buffers are automatically mapped so that we can access their data via normal C++
    pointers. The function `flushMappedMemory()` is necessary in case buffers on our
    system do not support coherent memory. This function is called to make the data,
    written into the mapped memory by the host, become available to the GPU. It is
    a wrapper over `vkFlushMappedMemoryRanges()` and `vmaFlushAllocation()` when the
    **Vulkan Memory Allocator** (**VMA**) library is enabled.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '一系列方法用于从主机获取数据到缓冲区和从缓冲区获取数据。所有主机可见的缓冲区都自动映射，以便我们可以通过正常的 C++ 指针访问其数据。`flushMappedMemory()`
    函数在系统上的缓冲区不支持一致性内存时是必要的。当启用 **Vulkan Memory Allocator** (**VMA**) 库时，该函数调用 `vkFlushMappedMemoryRanges()`
    和 `vmaFlushAllocation()`。 '
- en: '[PRE23]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Data members encapsulate everything necessary related to the underlying Vulkan
    buffer management code. VMA-related fields are used only when the *VMA* library
    is enabled.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据成员封装了与底层 Vulkan 缓冲区管理代码相关的所有必要内容。只有在启用 *VMA* 库时才使用 VMA 相关字段。
- en: '[PRE24]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now we are ready to create an actual Vulkan buffer object. Let’s take a look
    at the code. Error handling is omitted for the sake of better understanding:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好创建实际的 Vulkan 缓冲区对象。让我们看看代码。为了更好地理解，省略了错误处理：
- en: Constructor parameters are used directly to populate the *VkBufferCreateInfo*
    structure.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数参数直接用于填充 *VkBufferCreateInfo* 结构。
- en: '[PRE25]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now we decide whether to use Vulkan directly or let *Vulkan Memory Allocator*
    do all the memory allocation for us. VMA is the main code path, while direct Vulkan
    calls are helpful to do debugging when necessary. In the case of VMA, we convert
    flags once again.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们决定是直接使用 Vulkan 还是让 *Vulkan Memory Allocator* 为我们做所有的内存分配。VMA 是主要代码路径，而直接
    Vulkan 调用在必要时进行调试很有帮助。在 VMA 的情况下，我们再次转换标志。
- en: '[PRE26]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Handle host-visible memory-mapped buffers. Use persistent mapping for the entire
    lifetime of the buffer.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理主机可见的内存映射缓冲区。在整个缓冲区生命周期中使用持久映射。
- en: '[PRE27]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The direct Vulkan code path is straightforward but requires manual memory allocation.
    Refer to `lvk/vulkan/VulkanClasses.cpp` for full detailed error checking, which
    is omitted here in the text.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 直接的 Vulkan 代码路径很简单，但需要手动内存分配。有关完整的详细错误检查，请参阅 `lvk/vulkan/VulkanClasses.cpp`，这里省略了文本中的内容。
- en: '[PRE28]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Host-visible buffers are handled in a similar way.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主机可见的缓冲区以类似的方式处理。
- en: '[PRE29]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Let’s set a user-provided debug name for this buffer.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为此缓冲区设置一个用户提供的调试名称。
- en: '[PRE30]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Once the buffer is created, get a buffer device address that can be used in
    shaders to access this buffer.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦创建缓冲区，获取一个可以在着色器中使用以访问此缓冲区的缓冲区设备地址。
- en: '[PRE31]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The buffer destruction process is interesting and worth mentioning because
    Vulkan buffers should not be deleted while still in use by the GPU. Besides doing
    VMA and Vulkan calls for memory unmapping and deallocation, the destructor defers
    the actual deallocation until the buffer is no longer in use by the GPU:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区销毁过程很有趣，值得提及，因为 Vulkan 缓冲区在 GPU 使用期间不应被删除。除了进行 VMA 和 Vulkan 调用来进行内存解映射和释放外，析构函数将实际释放延迟到缓冲区不再被
    GPU 使用为止：
- en: If this `VulkanBuffer` object was created with the default constructor and does
    not have any payload, we can just return immediately. The `deferredTask()` member
    function postpones the execution of its lambda argument to a later time when all
    previously submitted command buffers have completed processing. We will look into
    this mechanism in subsequent chapters.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果这个 `VulkanBuffer` 对象是用默认构造函数创建的，并且没有任何有效负载，我们就可以立即返回。`deferredTask()` 成员函数将
    lambda 参数的执行推迟到所有先前提交的命令缓冲区完成处理的时间。我们将在后续章节中探讨此机制。
- en: '[PRE32]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: A similar approach is taken when we do not use VMA and talk to Vulkan directly.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们不使用 VMA 并直接与 Vulkan 通信时，采取类似的方法。
- en: '[PRE33]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'There are three other member functions to mention here before we conclude how
    we work with Vulkan buffers:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们总结如何与 Vulkan 缓冲区一起工作时，这里还有三个其他成员函数需要提及：
- en: The function `flushMappedMemory()` is used to ensure that host writes to the
    buffer mapped memory become available to the GPU when the coherent memory is not
    supported.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数 `flushMappedMemory()` 用于确保当不支持一致性内存时，主机写入到映射内存的缓冲区对 GPU 可用。
- en: '[PRE34]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The function `getBufferSubData()` wraps a `memcpy()` operation in a convenient
    way. It only works with memory-mapped host-visible buffers. Device-local buffers
    are handled separately using a staging buffer. We will discuss this mechanism
    in subsequent chapters.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数 `getBufferSubData()` 以方便的方式包装了一个 `memcpy()` 操作。它仅适用于内存映射的主机可见缓冲区。设备本地缓冲区使用一个阶段缓冲区单独处理。我们将在后续章节中讨论此机制。
- en: '[PRE35]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The function `bufferSubData()` is a similar wrapper. It is trivial for host-visible
    buffers. Note how `memset()` is used here to set the content of the buffer to
    `0`.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数 `bufferSubData()` 是一个类似的包装器。对于主机可见的缓冲区来说，这是微不足道的。注意这里是如何使用 `memset()` 来将缓冲区的内容设置为
    `0`。
- en: '[PRE36]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now we’ve covered all the Vulkan code necessary to run the app `Chapter03/01_Assimp`,
    which renders an `.obj` 3D model loaded via *Assimp*. There are two small functions
    to mention that bind vertex and index buffers, respectively, and are part of the
    `ICommandBuffer` interface.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了运行 `Chapter03/01_Assimp` 应用程序所需的全部 Vulkan 代码，该应用程序通过 *Assimp* 加载并渲染
    `.obj` 3D 模型。有两个小函数需要提及，分别用于绑定顶点和索引缓冲区，它们是 `ICommandBuffer` 接口的一部分。
- en: The first function binds a vertex buffer via `vkCmdBindVertexBuffers()` to be
    used for vertex input. A few checks are necessary to ensure the correct usage
    of buffers. In subsequent chapters, we will learn how to omit vertex buffers altogether
    and learn the *Programmable-Vertex-Pulling* (*PVP*) approach.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个函数通过 `vkCmdBindVertexBuffers()` 绑定顶点缓冲区，用于顶点输入。需要进行一些检查以确保缓冲区的正确使用。在后续章节中，我们将学习如何完全省略顶点缓冲区，并学习
    *可编程顶点提取* (*PVP*) 方法。
- en: '[PRE37]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The second function binds an index buffer using `vkCmdBindIndexBuffer()`. Besides
    assertions, some enum types conversion from *LightweightVK* to the Vulkan API.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个函数使用 `vkCmdBindIndexBuffer()` 绑定索引缓冲区。除了断言之外，还有一些从 *LightweightVK* 到 Vulkan
    API 的枚举类型转换。
- en: '[PRE38]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The application `Chapter03/01_Assimp` should render the following image.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序 `Chapter03/01_Assimp` 应渲染以下图像。
- en: '![Figure 3.2: Rendering a mesh loaded with Assimp](img/file16.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2：使用 Assimp 加载的网格渲染](img/file16.png)'
- en: 'Figure 3.2: Rendering a mesh loaded with Assimp'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2：使用 Assimp 加载的网格渲染
- en: Now we are done with some very basic Vulkan usage and ready to add some textures
    to our examples.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了一些非常基本的 Vulkan 使用，并准备好向我们的示例添加一些纹理。
- en: Implementing staging buffers
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现阶段缓冲区
- en: GPU device-local buffers are not visible from the host, and we can upload data
    into them using various CPU-GPU-CPU copy operations. In Vulkan, this can be done
    by creating an auxiliary buffer, called a staging buffer, which is CPU-visible
    or host-visible, uploading some data into it from the host and then issuing GPU
    commands to copy from this staging buffer into a device-local buffer. Let’s learn
    how to implement this technique in Vulkan.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: GPU 设备本地缓冲区对主机不可见，我们可以使用各种 CPU-GPU-CPU 复制操作将数据上传到它们。在 Vulkan 中，这可以通过创建一个辅助缓冲区，称为阶段缓冲区，它是
    CPU 可见或主机可见的，从主机上传一些数据到其中，然后发出 GPU 命令从该阶段缓冲区复制到设备本地缓冲区来实现。让我们学习如何在 Vulkan 中实现这项技术。
- en: Getting ready
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before reading any further, check out the previous recipe, *Dealing with buffers
    in Vulkan*, to learn how to create different types of Vulkan buffers.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续阅读之前，请查看之前的配方，*处理Vulkan中的缓冲区*，以了解如何创建不同类型的Vulkan缓冲区。
- en: How to do it…
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: As usual, let’s start from the high-level interface of LightweightVK and then
    dive deep into the implementation. The interface class `IContext` declared in
    `lvk/LVK.h` exposes the following methods to operate on buffers.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，让我们从LightweightVK的高级接口开始，然后深入到实现。在`lvk/LVK.h`中声明的接口类`IContext`公开以下方法来操作缓冲区。
- en: '[PRE39]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: These methods are implemented in a subclass `VulkanContext` and roughly correspond
    to the implementation of `VulkanBuffer` that was discussed in detail in the previous
    recipe. We also saw how `VulkanContext::createBuffer()` calls `VulkanContext::uload()`
    in case there’s some initial data to be uploaded into a buffer. Let’s take a look
    at what is inside that method.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法在子类`VulkanContext`中实现，大致对应于前一个配方中详细讨论的`VulkanBuffer`实现。我们还看到了`VulkanContext::createBuffer()`如何在有初始数据要上传到缓冲区的情况下调用`VulkanContext::uload()`。让我们看看这个方法内部是什么。
- en: First of all, we have to convert a buffer handle into a pointer to a `VulkanBuffer`
    object. This is done by a pool that stores all `VulkanBuffer` objects in the system.
    The pool implementation will be discussed in subsequent recipes. For now, let’s
    just pretend that it is an opaque mechanism to map an integer handle into a `VulkanBuffer`
    object pointer.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须将缓冲区句柄转换为指向`VulkanBuffer`对象的指针。这是通过一个存储系统中所有`VulkanBuffer`对象的池来完成的。池的实现将在后续配方中讨论。现在，让我们假装这是一个将整数句柄映射到`VulkanBuffer`对象指针的不可见机制。
- en: '[PRE40]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: After doing some range checking, we delegate the work to the member function
    `VulkanStagingDevice::bufferSubData()`.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在进行一些范围检查后，我们将工作委托给成员函数`VulkanStagingDevice::bufferSubData()`。
- en: '[PRE41]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The class `VulkanStagingDevice` encapsulates all the functionality necessary
    to manage Vulkan staging buffers.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 类`VulkanStagingDevice`封装了管理Vulkan阶段缓冲区所需的所有功能。
- en: The staging device provides functionality to access device-local buffers and
    images. In this recipe, we will focus only on the buffers part and 2D images.
    While 3D image uploading is supported by *LightweightVK*, it is not used in our
    book, and we will skip it. If you are interested in learning those details, you
    are encouraged to check the actual source code of *LightweightVK* at `lvk/vulkan/VulkanClasses.cpp`.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 阶段设备提供了访问设备本地缓冲区和图像的功能。在本配方中，我们将仅关注缓冲区部分和2D图像。虽然3D图像上传由*LightweightVK*支持，但本书中并未使用，我们将跳过它。如果您对学习这些细节感兴趣，鼓励您查看*LightweightVK*的实际源代码，位于`lvk/vulkan/VulkanClasses.cpp`。
- en: '[PRE42]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Each call to `bufferSubData()` or `imageData2D()` occupies some space in the
    staging buffer. The structure `MemoryRegionDesc` describes such a memory region
    with one `SubmitHandle` that was used to upload data through it.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每次调用`bufferSubData()`或`imageData2D()`都会在阶段缓冲区中占用一些空间。结构`MemoryRegionDesc`使用一个`SubmitHandle`描述这样的内存区域，该`SubmitHandle`用于通过它上传数据。
- en: '[PRE43]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The function `getNextFreeOffset()` returns the next available memory region
    suitable to accommodate `size` bytes of data. The function `waitAndReset()` is
    used internally to wait until all memory regions become available.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数`getNextFreeOffset()`返回下一个可用的内存区域，该区域适合容纳`size`字节的数据。函数`waitAndReset()`用于内部等待，直到所有内存区域都可用。
- en: '[PRE44]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The uploading process is trivial once we understand how the `getNextFreeOffset()`
    helper function works. Let’s take a look:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们理解了`getNextFreeOffset()`辅助函数的工作原理，上传过程就变得非常简单。让我们看看：
- en: Make sure the requested buffer size is aligned. Some compressed image formats
    require the size to be padded to `16` bytes. We just use that value greedily here.
    A simple binary arithmetic trick is used to ensure the size value is aligned as
    required.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保请求的缓冲区大小是对齐的。某些压缩图像格式要求大小填充到`16`字节。我们在这里贪婪地使用那个值。使用简单的二进制算术技巧来确保大小值按要求对齐。
- en: '[PRE45]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Track the most suitable memory region. Check if we can reuse any of the previously
    used memory regions. This may cause some memory fragmentation in the staging buffer,
    but it’s not a concern since these sub-allocations have a very short lifespan.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跟踪最合适的内存区域。检查我们是否可以重用之前使用的任何内存区域。这可能会在阶段缓冲区中引起一些内存碎片化，但这不是问题，因为这些子分配的生命周期非常短。
- en: '[PRE46]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Reclaim and return the memory region. If there is no more space available in
    the staging buffer, reclaim all previous memory regions.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新获取并返回内存区域。如果没有更多空间可用在阶段缓冲区中，则重新获取所有之前的内存区域。
- en: '[PRE47]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: If we cannot reuse any previous memory region, allocate a new one from the free
    staging memory.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们不能重用任何之前的内存区域，则从空闲阶段内存中分配一个新的。
- en: '[PRE48]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Now we can implement the `VulkanStagingDevice::bufferSubData()` function. The
    main complexity here comes when the size of the data to upload is greater than
    the size of the staging buffer.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以实现 `VulkanStagingDevice::bufferSubData()` 函数。这里的复杂性主要在于要上传的数据大小大于阶段缓冲区的大小。
- en: If the destination buffer is host-visible, just mem-copy the data into it as
    we discussed in the previous recipe, *Dealing with buffers in Vulkan:*
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果目标缓冲区对主机可见，就像我们在之前的配方中讨论的那样，直接将数据内存复制到其中，*处理 Vulkan 中的缓冲区*：
- en: '[PRE49]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Iterate while there’s still some data to upload. On each iteration, we try
    to obtain a memory region to fit the entire remaining size. We select a chunk
    size accordingly:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在还有数据要上传的情况下迭代。在每次迭代中，我们尝试获取一个适合整个剩余大小的内存区域。我们相应地选择块大小：
- en: '[PRE50]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The staging buffer itself is always host-visible, so we can mem-copy our data
    into it:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 阶段缓冲区本身始终对主机可见，因此我们可以将我们的数据内存复制到其中：
- en: '[PRE51]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Acquire a command buffer and issue Vulkan commands to copy buffer data between
    the staging buffer and the destination buffer:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取命令缓冲区并发出 Vulkan 命令，在阶段缓冲区和目标缓冲区之间复制缓冲区数据：
- en: '[PRE52]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'As the GPU is doing the copying, we add this memory region – together with
    its `SubmitHandle` – to the container of occupied memory regions:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 GPU 正在执行复制时，我们将这个内存区域——连同其 `SubmitHandle` ——添加到已占用内存区域的容器中：
- en: '[PRE53]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Another crucial role of the staging buffer is to copy pixel data into Vulkan
    images. Let’s take a look at how it can be implemented. This function is significantly
    more complicated, so we omit all the error checking again here in the text for
    the sake of better understanding the code.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 阶段缓冲区的另一个关键作用是将像素数据复制到 Vulkan 图像中。让我们看看它是如何实现的。这个函数要复杂得多，所以我们再次省略文本中的所有错误检查，以便更好地理解代码。
- en: The `imageData2D()` function can upload in one go multiple layers of an image,
    starting from `layer`, together with multiple mip-levels starting from `baseMipLevel`.
    *LightweightVK* assumes there’s a maximum possible number of mip-levels. We calculate
    the size in bytes of each mip-level.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`imageData2D()` 函数可以一次性上传图像的多个层，从 `layer` 开始，以及从 `baseMipLevel` 开始的多个米普级别。*LightweightVK*
    假设存在一个最大可能的米普级别数量。我们计算每个米普级别的字节数。'
- en: '[PRE54]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: As we know the base mip-level number that we want to update, we can calculate
    its dimensions from the Vulkan image extents by bit-shifting.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们知道我们想要更新的基本米普级别编号，我们可以通过位移从 Vulkan 图像范围中计算其尺寸。
- en: '[PRE55]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Now let us calculate per-layer storage sizes, which are necessary to accommodate
    all corresponding mip-levels of the image. The function `getTextureBytesPerLayer()`
    returns the size in bytes of a layer with the requested image format. Store the
    results in `mipSizes[]`.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们计算每层存储大小，这是为了容纳图像的所有相应米普级别所必需的。函数 `getTextureBytesPerLayer()` 返回具有请求图像格式的层的字节数。将结果存储在
    `mipSizes[]` 中。
- en: '[PRE56]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Now we know the size necessary to store the entire image data. Try to acquire
    the next memory region from the staging buffer. *LightweightVK* provides no support
    for copying image data in multiple smaller chunks. If we get a memory region smaller
    than `storageSize`, we should until a bigger memory region becomes available.
    One consequence of this is that *LightweightVK* is unable to upload images whose
    memory footprint is larger than the staging buffer size.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们知道存储整个图像数据所需的大小。尝试从阶段缓冲区获取下一个内存区域。*LightweightVK* 不提供在多个较小的块中复制图像数据的功能。如果我们得到一个小于
    `storageSize` 的内存区域，我们应该等待一个更大的内存区域变得可用。这一结果的一个后果是，*LightweightVK* 无法上传内存占用大于阶段缓冲区大小的图像。
- en: '[PRE57]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Once we have a suitable memory region in the staging buffer, we can iterate
    over image layers and mip-levels to prepare the data for Vulkan.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们在阶段缓冲区中有一个合适的内存区域，我们可以遍历图像层和米普级别，为 Vulkan 准备数据。
- en: '[PRE58]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Transition the image layout into `VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL` so that
    we can use it as a destination in Vulkan transfer operations.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图像布局转换为 `VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL`，以便我们可以在 Vulkan 转移操作中使用它作为目标。
- en: '[PRE59]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Copy the pixel data from the staging buffer into the image. The buffer offset
    for this level is at the start of all mip-levels plus the size of all previous
    mip-levels being uploaded.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将像素数据从阶段缓冲区复制到图像中。此级别的缓冲区偏移量位于所有米普级别开始处，加上所有之前上传的米普级别的尺寸。
- en: '[PRE60]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We are done with this mip-level and layer. Transition its image layout from
    `VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL`, into `VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL`.
    This is necessary for normal workflow as any subsequent code dealing with images
    expects this image layout.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经完成了这个mip级别和层的处理。将其图像布局从 `VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL` 转换为 `VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL`。这对于正常工作流程是必要的，因为任何后续处理图像的代码都期望这个图像布局。
- en: '[PRE61]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The Vulkan image layout is a property of each image sub-resource that describes
    how the data in memory is organized in some opaque implementation-specific manner.
    This property is considered by the Vulkan implementation when the image is accessed.
    Not specifying correct layouts for different use cases may result in undefined
    behavior and distorted images.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Vulkan图像布局是每个图像子资源的属性，它以某种不透明的实现特定方式描述了内存中数据的组织方式。当访问图像时，Vulkan实现会考虑这个属性。未指定不同用例的正确布局可能会导致未定义的行为和扭曲的图像。
- en: Advance the buffer offset to the next mip-level.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将缓冲区偏移量推进到下一个mip级别。
- en: '[PRE62]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Once the Vulkan commands are recorded in the command buffer, we can submit it
    to copy the image data. Before we exit, we set the last image layout to `VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL`
    so that correct image layout transitions can happen later on.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦Vulkan命令记录在命令缓冲区中，我们就可以提交它以复制图像数据。在我们退出之前，我们将最后一个图像布局设置为 `VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL`，以便稍后可以正确地发生图像布局转换。
- en: '[PRE63]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This is all regarding the staging buffers implementation and the uploading device-local
    buffer data and images via them.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都是关于阶段缓冲区实现以及通过它们上传设备本地缓冲区数据和图像。
- en: There’s more…
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多...
- en: '*LightweightVK* has a function `VulkanStagingDevice::imageData3D()` to upload
    3D texture data using a staging buffer. It can be found in `lvk/vulkan/VulkanClasses.cpp`.
    Make sure you explore it.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*LightweightVK* 有一个名为 `VulkanStagingDevice::imageData3D()` 的函数，用于通过阶段缓冲区上传3D纹理数据。它可以在
    `lvk/vulkan/VulkanClasses.cpp` 中找到。确保你探索它。'
- en: 'There can be a memory heap described by the flags `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT
    | VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT`. Some GPUs can have a separate relatively
    small memory heap like that, while some GPUs can have the entire device memory
    marked as host-visible. This is called Resizable BAR, or ReBAR, which is a hardware
    feature allowing the CPU to access GPU device memory. If you have such a memory
    heap, you can use it to write data to GPU local memory directly. For example,
    you can allocate a staging buffer in that memory. If you want to learn more comprehensive
    details about Vulkan memory types and how to use them, here’s an amazing article
    by Adam Sawicki: `https://asawicki.info/news_1740_vulkan_memory_types_on_pc_and_how_to_use_them`.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 可以有一个由标志 `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT`
    描述的内存堆。一些GPU可以有一个相对较小的独立内存堆，而一些GPU可以将整个设备内存标记为主机可见。这被称为可调整大小的BAR，或ReBAR，这是一个硬件特性，允许CPU访问GPU设备内存。如果您有这样的内存堆，您可以直接使用它来向GPU本地内存写入数据。例如，您可以在该内存中分配一个阶段缓冲区。如果您想了解更多关于Vulkan内存类型及其使用方法的信息，这里有一篇由Adam
    Sawicki撰写的精彩文章：`https://asawicki.info/news_1740_vulkan_memory_types_on_pc_and_how_to_use_them`。
- en: Now, we have everything we need to know about how to deal with Vulkan images.
    Let’s go to the next recipe and learn how to use Vulkan images to create textures.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们知道了如何处理Vulkan图像所需的一切。让我们进入下一个配方，学习如何使用Vulkan图像创建纹理。
- en: Using texture data in Vulkan
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Vulkan中使用纹理数据
- en: Before we can write meaningful 3D rendering applications with Vulkan, we need
    to learn how to deal with textures. This recipe shows how to implement a number
    of functions to create, destroy, and modify texture objects on the GPU using the
    Vulkan API.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够使用Vulkan编写有意义的3D渲染应用程序之前，我们需要学习如何处理纹理。这个配方展示了如何使用Vulkan API实现一系列函数，以在GPU上创建、销毁和修改纹理对象。
- en: Getting ready
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: Uploading texture data to the GPU requires a staging buffer. Read the recipe
    *Dealing with buffers* before you proceed further.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 将纹理数据上传到GPU需要使用一个阶段缓冲区。在继续之前，请阅读配方*处理缓冲区*。
- en: The source code for this recipe can be found in `Chapter03/02_STB`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 该配方的源代码可以在 `Chapter03/02_STB` 中找到。
- en: How to do it...
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The first thing we do is create an image. A Vulkan image is another type of
    object backed by memory, designed to store 1D, 2D, and 3D images or arrays of
    those images. Readers familiar with OpenGL will probably be wondering about cube
    maps. Cube maps are represented as an array of six 2D images and can be constructed
    by setting the `VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT` flag in the `VkImageCreateInfo`
    structure. We will come back to that later. Now let us investigate the basic use
    case with just a 2D image. Let’s start with the high-level application code and
    go all the way down to Vulkan image allocation:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个图像。Vulkan 图像是另一种由内存支持的类型，用于存储 1D、2D 和 3D 图像或这些图像的数组。熟悉 OpenGL 的读者可能会对立方体贴图感到好奇。立方体贴图表示为六个
    2D 图像的数组，可以通过在 `VkImageCreateInfo` 结构中设置 `VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT`
    标志来构建。我们稍后会回到这一点。现在让我们仅使用 2D 图像来研究基本的使用案例。让我们从高级应用程序代码开始，一直到底层 Vulkan 图像分配：
- en: The application `Chapter03/02_STB` loads pixel data from a `.jpg` file using
    the STB library ([https://github.com/nothings/stb](https://github.com/nothings/stb)).
    We enforce conversion to 4-channels to simplify texture handling. Many Vulkan
    implementations do not support 3-channel images.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序 `Chapter03/02_STB` 使用 STB 库（[https://github.com/nothings/stb](https://github.com/nothings/stb)）从
    `.jpg` 文件中加载像素数据。我们强制转换为 4 通道，以简化纹理处理。许多 Vulkan 实现不支持 3 通道图像。
- en: '[PRE64]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: A handle to a texture object is created. The texture format is normalized unsigned
    8-bit RGBA, which corresponds to the Vulkan format `VK_FORMAT_R8G8B8A8_UNORM`.
    We intend to use this texture for sampling in shaders, so we specify the texture
    usage flag `TextureUsageBits_Sampled`.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建了一个纹理对象的句柄。纹理格式是归一化的无符号 8 位 RGBA，对应于 Vulkan 格式 `VK_FORMAT_R8G8B8A8_UNORM`。我们打算在着色器中使用这个纹理进行采样，因此指定了纹理使用标志
    `TextureUsageBits_Sampled`。
- en: '[PRE65]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Do not forget to free the image memory.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要忘记释放图像内存。
- en: '[PRE66]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Let’s take a look at the main loop. *LightweightVK* is built around the bindless
    renderer design. Bindless rendering is a technique that allows for more efficient
    GPU resource management by removing the need to explicitly bind resources, such
    as textures, buffers, or samplers. Here’s how we can pass texture data into shaders
    using push constants. After that, we render a quad formed of `4` triangle strip
    vertices.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看主循环。*LightweightVK* 是围绕无绑定渲染器设计构建的。无绑定渲染是一种技术，通过移除显式绑定资源（如纹理、缓冲区或采样器）的需要，从而允许更有效地管理
    GPU 资源。以下是我们可以使用推送常量将纹理数据传递到着色器中的方法。之后，我们渲染一个由 `4` 个三角形条顶点组成的四边形。
- en: '[PRE67]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The vertices are generated without any vertex input right in the vertex shader
    `Chapter03/02_STB/src/main.vert`, which looks as follows.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 顶点在 `Chapter03/02_STB/src/main.vert` 顶点着色器中生成，没有任何顶点输入，如下所示。
- en: '[PRE68]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The fragment shader is much more interesting. We need to declare arrays of 2D
    textures and samplers provided by *LightweightVK*. They contain all textures and
    all samplers loaded at the current moment. The element `0` in both arrays corresponds
    to a dummy object. This is useful for safely utilizing null values as texture
    identifiers. Our push constant `textureId` is nothing but an index into the `kTextures2D`
    array.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 片段着色器更有趣。我们需要声明由 *LightweightVK* 提供的 2D 纹理和采样器数组。它们包含当前加载的所有纹理和所有采样器。两个数组中的元素
    `0` 对应于一个虚拟对象。这对于安全地利用空值作为纹理标识符很有用。我们的推送常量 `textureId` 仅仅是 `kTextures2D` 数组中的一个索引。
- en: '[PRE69]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Here’s a handy helper function `textureBindless2D()` to sample from a bindless
    2D texture using a bindless sampler. We shall use it instead of standard GLSL
    `texture()` to quickly sample a texture.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里有一个方便的辅助函数 `textureBindless2D()`，用于使用无绑定采样器从无绑定 2D 纹理中采样。我们将用它来代替标准的 GLSL
    `texture()` 函数，以便快速采样纹理。
- en: Here we provided the entire fragment shader GLSL source code ourselves. If we
    skip the `#version` directive at the beginning of the shader, *LightweightVK*
    will inject this and many other helper functions into our GLSL source code, together
    with `kTextures2D[]` and other declarations. We will use this functionality in
    subsequent chapters to simplify our shaders. Here we list this function just for
    purely educational reasons.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们自行提供了整个片段着色器 GLSL 源代码。如果我们省略着色器开头处的 `#version` 指令，*LightweightVK* 将会将其以及许多其他辅助函数注入到我们的
    GLSL 源代码中，包括 `kTextures2D[]` 和其他声明。我们将在后续章节中使用这一功能来简化我们的着色器。这里列出这个函数仅出于纯粹的教育目的。
- en: '[PRE70]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: In case of not dynamically uniform texture indices, the `nonuniformEXT` type
    qualifier is required by the Vulkan API to be used when indexing descriptor bindings.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有动态均匀纹理索引，Vulkan API 需要使用 `nonuniformEXT` 类型限定符来索引描述符绑定。
- en: The resulting application `Chapter03/02_STB` should render a textured rotating
    quad as in the following screenshot.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的应用程序 `Chapter03/02_STB` 应该渲染一个如以下截图所示的纹理旋转四边形。
- en: '![Figure 3.3: Rendering a textured quad](img/file17.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3：渲染纹理四边形](img/file17.png)'
- en: 'Figure 3.3: Rendering a textured quad'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3：渲染纹理四边形
- en: The high-level part was pretty short and straightforward, hiding all the Vulkan
    complexity from us. Now let’s take a look at the underlying implementation to
    learn how it works.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 高级部分相当简短且直接，隐藏了所有 Vulkan 的复杂性。现在让我们看看底层实现，以了解它是如何工作的。
- en: How it works…
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Vulkan textures, namely images and image views, are complex. Together with descriptor
    sets, they are necessary to access texture data in shaders. The *LightweightVK*
    implementation of textures comes in many layers. Let’s dissect them one by one
    and learn how.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Vulkan 纹理，即图像和图像视图，很复杂。与描述符集一起，它们是访问着色器中纹理数据的必要条件。*LightweightVK* 的纹理实现有很多层。让我们逐一剖析它们，并学习如何使用。
- en: 'The tip of the iceberg is the function `VulkanContext::createTexture()`, which
    returns a handle to a texture. The function is quite long, so we omit the error-checking
    code here again to make it a bit easier to understand:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 冰山一角是 `VulkanContext::createTexture()` 函数，该函数返回一个纹理句柄。该函数相当长，所以我们再次省略错误检查代码，以便更容易理解：
- en: This function converts a *LightweightVK* texture description `TextureDesc` into
    various Vulkan flags for images and image views. The extra argument `debugName`
    provides a convenient way to override the `TextureDesc::debugName` field. It is
    very useful if we want to create multiple textures using the same `TextureDesc`
    object.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此函数将 *LightweightVK* 纹理描述 `TextureDesc` 转换为图像和图像视图的各种 Vulkan 标志。额外的参数 `debugName`
    提供了一种方便的方法来覆盖 `TextureDesc::debugName` 字段。如果我们想使用相同的 `TextureDesc` 对象创建多个纹理，这将非常有用。
- en: '[PRE71]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Convert the *LightweightVK* format into Vulkan format. Vulkan has somewhat stronger
    guarantees regarding the support of color formats. Therefore, depth formats are
    converted based on the actual availability, while color formats are converted
    as is.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 *LightweightVK* 格式转换为 Vulkan 格式。Vulkan 在支持颜色格式方面提供了一些更强的保证。因此，深度格式根据实际可用性进行转换，而颜色格式则直接转换。
- en: '[PRE72]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: If the image is going to be allocated in the GPU device memory, we should set
    the `VK_IMAGE_USAGE_TRANSFER_DST_BIT` to allow Vulkan to transfer data into it.
    Other Vulkan image usage flags are set accordingly to the *LVK* usage flags.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果图像将要分配在 GPU 设备内存中，我们应该设置 `VK_IMAGE_USAGE_TRANSFER_DST_BIT` 以允许 Vulkan 将数据传输到其中。其他
    Vulkan 图像使用标志根据 *LVK* 使用标志相应设置。
- en: '[PRE73]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: For convenience, we always allow an image to be read back from the GPU to the
    CPU. However, it might be worth checking if this usage flag is actually supported.
    The memory flags are chosen in the same way as we did for buffers in the recipe
    *Dealing with buffers in Vulkan*.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了方便起见，我们始终允许从 GPU 读取图像到 CPU。然而，检查此使用标志是否实际上受支持可能是有价值的。内存标志的选择方式与我们在 *处理 Vulkan
    中的缓冲区* 菜谱中所做的方式相同。
- en: '[PRE74]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Generate debug names for Vulkan image and image view objects by prefixing the
    provided `debugName` string.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在提供的 `debugName` 字符串前添加前缀来为 Vulkan 图像和图像视图对象生成调试名称。
- en: '[PRE75]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Now we can deduce `VkImageCreateFlags` and types of the Vulkan image and image
    view.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以推断出 `VkImageCreateFlags` 和 Vulkan 图像及图像视图的类型。
- en: '[PRE76]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 2D images can be multisampled ([https://en.wikipedia.org/wiki/Multisample_anti-aliasing](https://en.wikipedia.org/wiki/Multisample_anti-aliasing)).
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2D 图像可以是多采样（[https://en.wikipedia.org/wiki/Multisample_anti-aliasing](https://en.wikipedia.org/wiki/Multisample_anti-aliasing)）。
- en: '[PRE77]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Cube textures in Vulkan can be represented with an image view of the type `VK_IMAGE_VIEW_TYPE_CUBE`
    and a 2D image with a special flag `VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT`. The
    number of layers if multiplied by `6` to accommodate all cube map faces according
    to the Vulkan specification.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Vulkan 中的立方体贴图可以使用类型为 `VK_IMAGE_VIEW_TYPE_CUBE` 的图像视图和带有特殊标志 `VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT`
    的 2D 图像来表示。层数乘以 `6` 以根据 Vulkan 规范容纳所有立方体贴图面。
- en: '[PRE78]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Now we can create a wrapper object `VulkanImage` which encapsulates all necessary
    `VkImage` related properties. We will explore the `createImage()` function a bit
    later.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以创建一个包装对象 `VulkanImage`，它封装了所有必要的 `VkImage` 相关属性。我们将在稍后探索 `createImage()`
    函数。
- en: '[PRE79]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: To access a Vulkan image from shaders, we need to create a `VkImageView` object.
    To do so, we have to choose which image “aspect” should be included in the view.
    Images in Vulkan can have multiple aspects simultaneously, such as combined depth-stencil
    images, hence depth and stencil bits are handled separately.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要从着色器访问 Vulkan 图像，我们需要创建一个 `VkImageView` 对象。为此，我们必须选择应包含在视图中的图像“方面”。Vulkan 中的图像可以同时具有多个方面，例如组合深度-模板图像，因此深度和模板位是分别处理的。
- en: '[PRE80]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: An image view can control which mip-levels and layers are included. Here we
    create an image view that contains all levels and layers of the image. Later,
    we will need separate image views for framebuffer attachments that can have only
    one layer and one mip-level.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 图像视图可以控制包含哪些米级和层。在这里，我们创建一个包含图像所有级别和层的图像视图。稍后，我们需要为只能有一个层和一个米级的帧缓冲区附加物创建单独的图像视图。
- en: '[PRE81]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '*LightweightVK* calls a pair of objects – `VkImage`, wrapped in the `VulkanImage`
    class, and `VkImageView` – as a texture. The Boolean flag `awaitingCreation_`
    tells `VulkanContext` that a texture was created and the bindless descriptor set
    has to be updated. We will come back to this in the next chapters.'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*LightweightVK* 调用了一对对象——`VkImage`，封装在 `VulkanImage` 类中，以及 `VkImageView`——作为纹理。布尔标志
    `awaitingCreation_` 告诉 `VulkanContext` 已创建纹理，并且无绑定描述符集需要更新。我们将在下一章中回到这一点。'
- en: '[PRE82]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Before we return a handle to the newly created texture, let’s upload the initial
    texture data.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们返回新创建的纹理句柄之前，让我们上传初始纹理数据。
- en: '[PRE83]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The abovementioned helper function `createImage()` creates a `VulkanImage` object.
    It does some error checking, which is omitted here, and delegates the actual work
    to the constructor of `VulkanImage`. Here’s its implementation just for convenience.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 上文提到的辅助函数 `createImage()` 创建一个 `VulkanImage` 对象。它执行一些错误检查，这里省略了，并将实际工作委托给 `VulkanImage`
    的构造函数。以下是其实施的方便版本。
- en: '[PRE84]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: We will be more interested in the `VulkanImage` constructor, which creates an
    actual `VkImage` object.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更感兴趣的是 `VulkanImage` 构造函数，它创建一个实际的 `VkImage` 对象。
- en: The constructor takes a bunch of parameters describing all necessary Vulkan
    properties of the image.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数接受一系列参数，描述图像的所有必要 Vulkan 属性。
- en: '[PRE85]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Using these parameters, we can fill in the `VkImageCreateInfo` structure right
    away. LightweightVK does not work with multiple Vulkan queues, so it sets the
    sharing mode to `VK_SHARING_MODE_EXCLUSIVE`.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这些参数，我们可以立即填写 `VkImageCreateInfo` 结构。LightweightVK 不与多个 Vulkan 队列一起工作，因此它将共享模式设置为
    `VK_SHARING_MODE_EXCLUSIVE`。
- en: '[PRE86]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: In the same way that we dealt with buffers in the recipe *Dealing with buffers
    in Vulkan*, we have two code paths for Vulkan images. One uses the *Vulkan Memory
    Allocator* library and the other calls Vulkan directly to allocate memory. This
    is useful for debugging purposes.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与我们在配方“处理 Vulkan 中的缓冲区”中处理缓冲区的方式相同，我们对 Vulkan 图像有两种代码路径。一个使用 *Vulkan Memory
    Allocator* 库，另一个直接调用 Vulkan 来分配内存。这对于调试目的很有用。
- en: '[PRE87]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: We can have memory-mapped images in the same way we have memory-mapped buffers.
    However, this is only useful for non-tiled image layouts.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以有与内存映射缓冲区相同的方式拥有内存映射图像。然而，这仅适用于非平铺的图像布局。
- en: '[PRE88]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The direct Vulkan code path is quite similar. We call `vkCreateImage()` and
    then allocate some memory and bind it using `vkBindImageMemory()`. Memory allocation
    is done in the same way as we did earlier in this chapter for buffers in the recipe
    *Dealing with buffers in Vulkan*.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 直接的 Vulkan 代码路径相当相似。我们调用 `vkCreateImage()`，然后分配一些内存并使用 `vkBindImageMemory()`
    绑定它。内存分配的方式与我们在本章的配方“处理 Vulkan 中的缓冲区”中为缓冲区所做的相同。
- en: '[PRE89]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Before exiting, set the debug name of the created `VkImage` object and retrieve
    physical device format properties for further use.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在退出之前，设置创建的 `VkImage` 对象的调试名称，并检索物理设备格式属性以供进一步使用。
- en: '[PRE90]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Once we have a `VulkanImage` wrapper object, we can create an image view. This
    is much simpler and can be done using a short member `createImageView()` function.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了 `VulkanImage` 包装对象，我们就可以创建一个图像视图。这要简单得多，可以使用一个简短的成员函数 `createImageView()`
    来完成。
- en: This function does not use any wrappers and creates a `VkImageView` object directly.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此函数不使用任何包装器，并直接创建一个 `VkImageView` 对象。
- en: '[PRE91]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: If a non-zero `numLevels` argument was provided, we would use it to override
    the number of mip-levels we want to have in this new image view. Otherwise, we
    use all mip-levels available in the current image to create the image view. This
    is handy because image views for framebuffer attachments should have only `1`
    mip-level.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果提供了非零的 `numLevels` 参数，我们将使用它来覆盖我们想要在这个新图像视图中拥有的 MIP 级别数量。否则，我们将使用当前图像中可用的所有
    MIP 级别来创建图像视图。这很方便，因为用作帧缓冲区附件的图像视图应该只有 `1` 个 MIP 级别。
- en: '[PRE92]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The `VkImage` and `VkImageView` objects created above can represent a texture.
    *LightweightVK* groups them together into the `VulkanTexture` class.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 上文中创建的 `VkImage` 和 `VkImageView` 对象可以表示纹理。*LightweightVK* 将它们组合到 `VulkanTexture`
    类中。
- en: '[PRE93]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: As you can see, the `VulkanTexture` class is just a data container and the only
    interesting part is the `getOrCreateVkImageViewForFramebuffer()` function. As
    we mentioned earlier, image views that are used as framebuffer attachments should
    have only `1` mip-level and `1` layer. This function precaches such image views
    in a simple way inside the array `imageViewForFramebuffer_[][]`. It supports a
    maximum of only `6` layers – this is just enough to render into the faces of a
    cube map.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`VulkanTexture` 类只是一个数据容器，唯一有趣的部分是 `getOrCreateVkImageViewForFramebuffer()`
    函数。正如我们之前提到的，用作帧缓冲区附件的图像视图应该只有 `1` 个 MIP 级别和 `1` 个层。这个函数以简单的方式在数组 `imageViewForFramebuffer_[][]`
    中预缓存这样的图像视图。它最多支持 `6` 个层——这足以渲染到立方体贴图的各个面。
- en: There’s more…
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多…
- en: While technically all of the abovementioned code is sufficient to create `VkImage`
    and `VkImageView` objects, we still cannot access them from shaders. To do that,
    we need to learn how to store these objects and how to create and manage Vulkan
    descriptor sets. Let’s move on to the next recipes to learn that.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然技术上上述所有代码都足以创建 `VkImage` 和 `VkImageView` 对象，但我们仍然无法从着色器中访问它们。要做到这一点，我们需要了解如何存储这些对象以及如何创建和管理
    Vulkan 描述符集。让我们继续学习下一道菜谱来了解这一点。
- en: Storing Vulkan objects
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储 Vulkan 对象
- en: In the previous recipes, we mentioned a plethora of `lvk::…Handle` classes wrapped
    in a unique-pointer-like class `lvk::Holder`. They are central to how *LightweightVK*
    manages Vulkan objects and other resources. Handles are lightweight value types
    that are cheap to pass around as integers and we pay no costs of shared ownership
    with atomic counters compared to `std::shared_ptr` and similar reference-counted
    smart pointers. When having ownership of some object is desirable, we wrap handles
    in the `lvk::Holder` class, which conceptually is similar to `std::unique_ptr`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的菜谱中，我们提到了许多 `lvk::…Handle` 类，它们被封装在一个类似唯一指针的类 `lvk::Holder` 中。它们是 *LightweightVK*
    管理 Vulkan 对象和其他资源的关键。处理器是轻量级值类型，作为整数传递时成本低廉，与 `std::shared_ptr` 和类似的引用计数智能指针相比，我们没有共享所有权的成本。当拥有某些对象是可取的时候，我们将处理器封装在
    `lvk::Holder` 类中，从概念上讲，它类似于 `std::unique_ptr`。
- en: Getting ready
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The *LightweightVK* implementation of handles is inspired by Sebastian Aaltonen`s
    SIGGRAPH 2023 presentation *HypeHype Mobile Rendering Architecture*. If you want
    to learn more low-level interesting details about an API design using handles,
    make sure to read: [https://advances.realtimerendering.com/s2023/AaltonenHypeHypeAdvances2023.pdf](https://advances.realtimerendering.com/s2023/AaltonenHypeHypeAdvances2023.pdf).'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器的 *LightweightVK* 实现受到了 Sebastian Aaltonen 在 SIGGRAPH 2023 上的演示 *HypeHype
    Mobile Rendering Architecture* 的启发。如果你想了解更多关于使用处理器进行 API 设计的底层有趣细节，请务必阅读：[https://advances.realtimerendering.com/s2023/AaltonenHypeHypeAdvances2023.pdf](https://advances.realtimerendering.com/s2023/AaltonenHypeHypeAdvances2023.pdf)。
- en: How to do it…
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'An abstract handle is represented by a templated class `Handle<>`:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象处理器由一个模板类 `Handle<>` 表示：
- en: Handles are designed to serve as pointers to objects that are stored in arrays.
    An index into an array is sufficient to identify an object. To handle situations
    when objects are deallocated and then replaced by other objects, we introduce
    a value `gen_`, which represents the object’s “generation” and is incremented
    every time a new object is assigned to the same element in the storage array.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理器被设计为指向存储在数组中的对象的指针。数组中的索引足以识别一个对象。为了处理对象被释放然后被其他对象替换的情况，我们引入了一个值 `gen_`，它代表对象的“生成”，每次将新对象分配到存储数组中的相同元素时，该值都会递增。
- en: '[PRE94]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: These values are private so that handles can be constructed only by a friendly
    `Pool` class. The `Pool` class is templated and is parametrized by two types;
    one corresponds to the handle`s object type and the other is the type stored inside
    the implementation array. It is not visible from the interface.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些值是私有的，这样句柄就只能由友好的 `Pool` 类构建。`Pool` 类是模板化的，并且由两种类型参数化；一种对应于句柄的对象类型，另一种是存储在实现数组中的类型。它从接口中不可见。
- en: '[PRE95]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The contract is that handles with a generation equal to 0 are considered empty
    null-handles.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 合同规定，生成等于 0 的句柄被视为空的空句柄。
- en: '[PRE96]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The `indexAsVoid()` function is helpful when we need to pass a handle through
    some third-party C-style interface that accepts `void*` parameters. One example
    used in this book is *ImGui* integration, which is discussed in the next chapter,
    *Chapter 4*, *Adding User Interaction and Productivity Tools*.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们需要通过接受 `void*` 参数的第三方 C 风格接口传递句柄时，`indexAsVoid()` 函数很有帮助。本书中使用的例子是 *ImGui*
    集成，这在下一章 *第四章*，*添加用户交互和生产率工具* 中讨论。
- en: '[PRE97]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The explicit conversion to `bool` is necessary to allow the usage of handles
    in conditional statements such as `if (handle) …`.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显式转换为 `bool` 是必要的，以便在条件语句（如 `if (handle) …`）中使用句柄。
- en: '[PRE98]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: The `Handle<>` template can be parametrized with a forward-declared object,
    which is never defined. This is done to ensure type safety so that heterogenous
    handles cannot be mixed with each other. Here is how *LightweightVK* declares
    all its `Handle<>` types. All structs are declared but not defined.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`Handle<>` 模板可以用一个提前声明的对象参数化，该对象永远不会定义。这样做是为了确保类型安全，以便异构句柄不能相互混合。以下是 *LightweightVK*
    声明所有其 `Handle<>` 类型的示例。所有结构体都已声明但未定义。'
- en: '[PRE99]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Handles do not own the objects they point to. Only the `Holder<>` class does.
    Let’s take a look at its implementation:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 句柄不拥有它们指向的对象。只有 `Holder<>` 类才拥有。让我们看看它的实现：
- en: The `Holder<>` class is templated with a `Handle` type it can hold. The constructor
    accepts a handle and a pointer to `lvk::IContext` to ensure the handle can be
    destroyed properly. The class has move-only semantics similar to `std::unique_ptr`.
    We skip definitions of the move constructor and move assignment for the sake of
    brevity.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Holder<>` 类使用它可以持有的 `Handle` 类型进行模板化。构造函数接受一个句柄和指向 `lvk::IContext` 的指针，以确保句柄可以正确销毁。该类具有类似于
    `std::unique_ptr` 的移动语义。为了简洁起见，我们省略了移动构造函数和移动赋值的定义。'
- en: '[PRE100]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: We do not have a declaration of the `IContext` class here. That is why we use
    an overloaded forward-declared function `lvk::destroy()` to deallocate the handle.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在这里没有 `IContext` 类的声明。这就是为什么我们使用重载的提前声明的函数 `lvk::destroy()` 来释放句柄。
- en: '[PRE101]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Assign `nullptr` to a holder:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `nullptr` 分配给持有者：
- en: '[PRE102]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Manually reset the holder and make it deallocate the stored handle or just
    return the handle and release ownership when necessary:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 手动重置持有者并使其释放存储的句柄或仅在必要时返回句柄并释放所有权：
- en: '[PRE103]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: The `Holder` class calls a family of overloaded `destroy()` functions. Here
    is how *LightweightVK* defines them, once function per each handle type.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Holder` 类调用一系列重载的 `destroy()` 函数。以下是 *LightweightVK* 定义它们的示例，每个句柄类型一个函数。'
- en: '[PRE104]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Implementations of these functions are located in `lightweightvk/lvk/LVK.cpp`
    and they all look very similar. Each function calls a corresponding overloaded
    method in `IContext`. While it may seem unnecessary, this actually helps to avoid
    a circular dependency between the `Holder` class and `IContext`, making the interface
    much cleaner.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些函数的实现位于 `lightweightvk/lvk/LVK.cpp`，并且它们看起来非常相似。每个函数都会调用 `IContext` 中的相应重载方法。虽然这可能看起来是不必要的，但实际上这有助于避免
    `Holder` 类和 `IContext` 之间的循环依赖，从而使接口更加清晰。
- en: '[PRE105]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: That is all there is to discuss about the `Holder` class and the portion of
    the Handle-Holder mechanism exposed in the interface. Now, let’s delve into the
    implementation and understand how object `Pool`s can be implemented.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `Holder` 类以及接口中暴露的 Handle-Holder 机制的部分，这就是所有需要讨论的内容。现在，让我们深入探讨实现，了解对象 `Pool`s
    可以如何实现。
- en: How it works…
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The implementation starts with a class `Pool<>`, which is located in `lightweightvk/lvk/Pool.h`.
    It stores a collection of objects of type `ImplObjectType` inside `std::vector`
    and can manage handles to these objects. Let’s look at the implementation details:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 实现从类 `Pool<>` 开始，该类位于 `lightweightvk/lvk/Pool.h`。它使用 `std::vector` 存储类型为 `ImplObjectType`
    的对象集合，并可以管理这些对象的句柄。让我们看看实现细节：
- en: Every array element is a struct `PoolEntry` that stores an `ImplObjectType`
    object by value together with its generation used to check handles that point
    to this element. The field `nextFree_` is used to maintain a linked list of free
    elements inside the array. Once a handle is deallocated, a corresponding array
    element is added to the free list. The field `freeListHead_` stores an index of
    the first free element, or `kListEndSentinel` if there are no free elements.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个数组元素都是一个`PoolEntry`结构体，它通过值存储一个`ImplObjectType`对象及其生成，用于检查指向此元素的句柄。字段`nextFree_`用于在数组内部维护空闲元素的链表。一旦句柄被释放，相应的数组元素就会被添加到空闲列表中。字段`freeListHead_`存储第一个空闲元素的索引，如果没有空闲元素，则为`kListEndSentinel`。
- en: '[PRE106]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Proponents of data-oriented design may argue that this structure minimizes cache
    utilization by interleaving the payload of `ImplObjectType` with utility values
    `gen_` and `nextFree_`. This is indeed true. One approach to mitigate this is
    to maintain two separate arrays. The first array can tightly pack `ImplObjectType`
    values, while the second one can store the necessary metadata for bookkeeping.
    In fact, it can go a step further, as mentioned in the original presentation by
    Sebastian Aaltonen, by separating a high-frequency accessed “hot” object type
    from a low-frequency accessed “cold” type, which can be stored in different arrays.
    However, for the sake of simplicity, we will leave this as an exercise for our
    readers.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 数据导向设计的支持者可能会争论说，这种结构通过将`ImplObjectType`的有效负载与效用值`gen_`和`nextFree_`交织在一起来最小化缓存利用率。这确实是正确的。一种缓解方法是通过维护两个单独的数组。第一个数组可以紧密打包`ImplObjectType`值，而第二个数组可以存储必要的记录元数据。实际上，可以更进一步，正如Sebastian
    Aaltonen的原版演示中提到的，通过将高频访问的“热”对象类型与低频访问的“冷”类型分开，这些类型可以存储在不同的数组中。然而，为了简单起见，我们将把这个作为读者的练习。
- en: A method to create a new handle takes an R-value reference. It checks the head
    of the free list. If there is a free element within the array, we can promptly
    place our object into it and remove the front element from the free list.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建新句柄的方法接受一个右值引用。它检查空闲列表的头部。如果数组中有空闲元素，我们可以立即将我们的对象放入其中，并从空闲列表中移除前端元素。
- en: '[PRE107]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: If there’s no space inside, append a new element to the `std::vector` container.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果内部没有空间，则将新元素追加到`std::vector`容器中。
- en: '[PRE108]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Destruction is simple but involves some additional error checking. Empty handles
    should not be destroyed. Trying to remove a non-empty handle from an empty pool
    means a logic error and should assert. If the generation of the handle does not
    match the generation of the corresponding array element, it means we are trying
    to do double-deletion.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 销毁过程简单，但涉及一些额外的错误检查。空句柄不应被销毁。尝试从一个空池中移除非空句柄意味着逻辑错误，应该断言。如果句柄的生成与相应数组元素的生成不匹配，这意味着我们正在尝试双重删除。
- en: '[PRE109]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: If all the checks are successful, replace the stored object with an empty default-constructed
    object and increment its generation. Then, place this array element at the front
    of the free list.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果所有检查都成功，则用空默认构造的对象替换存储的对象，并增加其生成。然后，将此数组元素放置在空闲列表的前端。
- en: '[PRE110]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Dereferencing a handle is done via the `get()` method, which has `const` and
    non-`const` implementations. They are identical, so we can check only one. A mismatch
    of the generation allows us to identify access to a deleted object.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`get()`方法进行句柄解引用，该方法有`const`和非`const`实现。它们是相同的，因此我们只需检查一个。生成不匹配使我们能够识别对已删除对象的访问。
- en: '[PRE111]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: A pool can be manually cleared so that a destructor is called for every object.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以手动清空池，以便为每个对象调用析构函数。
- en: '[PRE112]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: The member field `numObjects_` is used to track memory leaks and prevent deallocations
    inside an empty pool.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成员字段`numObjects_`用于跟踪内存泄漏并防止在空池内部进行分配。
- en: '[PRE113]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: That is how `Pool`s work. The actual implementation in `VulkanContext` uses
    them to store all implementation-specific objects that are accessible by handles
    from the interface side. These are the declarations that can be found in `lightweightvk/lvk/vulkan/VulkanClasses.h`.
    In many situations, Vulkan objects – such as `VkShaderModule` and `VkSampler`
    – can be stored directly. If some additional bookkeeping is required, a wrapper
    object is stored instead.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`Pool`的工作原理。在`VulkanContext`中的实际实现使用它们来存储所有从接口侧可访问的实现特定对象。这些声明可以在`lightweightvk/lvk/vulkan/VulkanClasses.h`中找到。在许多情况下，Vulkan对象——例如`VkShaderModule`和`VkSampler`——可以直接存储。如果需要额外的记录，则存储一个包装对象。
- en: '[PRE114]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Now we know how to store various objects and expose access to them via handles.
    Before we can conclude the topic of this chapter and finish our introduction to
    Vulkan, let’s take a look at how to construct bindless descriptor sets to access
    textures from GLSL shaders.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何存储各种对象并通过句柄暴露对这些对象的访问。在我们能够总结本章的主题并完成对 Vulkan 的介绍之前，让我们看看如何构建无绑定描述符集以从
    GLSL 着色器访问纹理。
- en: Using Vulkan descriptor indexing
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Vulkan 描述符索引
- en: Descriptor indexing became a part of the Vulkan core in version 1.2 as an optional
    feature. Vulkan 1.3 made it mandatory. This feature allows applications to put
    all the resources they have into one huge descriptor set and make it available
    to all shaders. There is no need to manage descriptor pools, and no need to construct
    per-shader descriptor sets. Everything is available to the shaders at once. Shaders
    can access all resources in the system, and the only practical limit is performance.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 描述符索引从版本 1.2 开始成为 Vulkan 核心的一部分，作为一个可选特性。Vulkan 1.3 使其成为强制特性。这个特性允许应用程序将它们拥有的所有资源放入一个巨大的描述符集中，并使其对所有着色器可用。无需管理描述符池，也无需为每个着色器构建描述符集。所有内容都一次性对着色器可用。着色器可以访问系统中的所有资源，唯一实际的限制是性能。
- en: Let us learn how to work with descriptor sets and descriptor indexing Vulkan
    by exploring the *LightweightVK* framework.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过探索 *LightweightVK* 框架来学习如何使用描述符集和描述符索引 Vulkan。
- en: How to do it...
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Let’s take a look at some parts of the `lvk::VulkanContext` class that deals
    with descriptors. The `VulkanContext` class declaration in `lightweightvk/lvk/vulkan/VulkanClasses.h`
    contains these member fields. The integer variables store the maximal number of
    resources that can be stored in the currently allocated descriptor set `vkDSet_`,
    which is allocated from a descriptor pool `vkDPool_`. The descriptor pool is allocated
    according to the descriptor set layout `vkDSL_`. The submit handle `lastSubmitHandle_`
    corresponds to the last submit this descriptor set was a part of. Submit handles
    were discussed in the previous chapter in the recipe *Using Vulkan command buffers*.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `lvk::VulkanContext` 类中处理描述符的一些部分。在 `lightweightvk/lvk/vulkan/VulkanClasses.h`
    中的 `VulkanContext` 类声明包含这些成员字段。整数变量存储当前分配的描述符集 `vkDSet_` 中可以存储的最大资源数量，该描述符集是从描述符池
    `vkDPool_` 分配的。描述符池是根据描述符集布局 `vkDSL_` 分配的。提交句柄 `lastSubmitHandle_` 与描述符集是最后提交的一部分相对应。提交句柄在上一章的配方
    *使用 Vulkan 命令缓冲区* 中进行了讨论。
- en: '[PRE115]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Let’s start our exploration with the function `growDescriptorPool()`, which
    recreates Vulkan objects as needed to accommodate the requested number of textures
    and samplers. Excessive error checking is omitted for the sake of readability:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从函数 `growDescriptorPool()` 开始探索，该函数根据所需的纹理和采样器的数量需要时重新创建 Vulkan 对象。为了可读性，省略了过多的错误检查：
- en: First, error checking is done to ensure the number of resources is within the
    hardware-specific limits.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，进行错误检查以确保资源数量在硬件特定的限制内。
- en: '[PRE116]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Deallocate previous Vulkan resources if they exist.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果存在，则释放之前的 Vulkan 资源。
- en: '[PRE117]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Create a new descriptor set layout, which is going to be shared by all Vulkan
    pipelines. It should contain all Vulkan resources *LightweightVK* supports – sampled
    images, samplers, and storage images.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的描述符集布局，该布局将被所有 Vulkan 管道共享。它应包含 *LightweightVK* 支持的所有 Vulkan 资源 – 样本图像、采样器和存储图像。
- en: '[PRE118]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: The descriptor indexing feature allows descriptor sets to be updated after they
    were bound.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述符索引功能允许在绑定后更新描述符集。
- en: '[PRE119]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: A chain of Vulkan `Vk…CreateInfo` structures should be prepared to create a
    desired `VkDesciptorSetLayout` object.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应准备一系列 Vulkan `Vk…CreateInfo` 结构来创建所需的 `VkDescriptorSetLayout` 对象。
- en: '[PRE120]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Using this newly created descriptor set layout, we can create a new descriptor
    pool. Note the flag `VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT`, which is
    required to support the corresponding flag for the descriptor set layout `VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT`.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这个新创建的描述符集布局，我们可以创建一个新的描述符池。注意标志 `VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT`，这是为了支持描述符集布局的相应标志
    `VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT`。
- en: '[PRE121]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Now we can allocate one descriptor set from the descriptor pool `vkDPool_`.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以从描述符池 `vkDPool_` 中分配一个描述符集。
- en: '[PRE122]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: To create Vulkan pipelines, we need a pipeline layout. The pipeline layout in
    *LightweightVK* is shared between all pipelines. In Vulkan 1.3, it would be sufficient
    to use a single descriptor set layout `vkDSL_` to create the pipeline layout.
    However, *LightweightVK* supports running on Mac using MoltenVK and *Metal Shading
    Language* cannot support aliasing of descriptor sets in shaders. Hence, we do
    the duplication here to prevent aliasing and keep compatibility with MoltenVK.
    We set the size of push constants to `128` bytes, which is the maximal guaranteed
    size by the Vulkan specification.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建Vulkan管线，我们需要一个管线布局。在*LightweightVK*中，管线布局在所有管线之间是共享的。在Vulkan 1.3中，使用单个描述符集布局`vkDSL_`来创建管线布局就足够了。然而，*LightweightVK*支持在Mac上使用MoltenVK，而*Metal
    Shading Language*不支持在着色器中别名描述符集。因此，我们在这里进行复制以防止别名并保持与MoltenVK的兼容性。我们将推送常量的大小设置为`128`字节，这是Vulkan规范保证的最大大小。
- en: '[PRE123]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'The `growDescriptorPool()` function was the first part of our descriptor set
    management mechanism. We have a descriptor set and we have to update it. Updating
    is done in another function, `checkAndUpdateDescriptorSets()`, which is called
    before we can dispatch Vulkan draw calls. Some parts of error checking have been
    left out once again:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '`growDescriptorPool()`函数是我们描述符集管理机制的第一个部分。我们有一个描述符集，我们必须更新它。更新是通过另一个函数`checkAndUpdateDescriptorSets()`完成的，在我们可以分发Vulkan绘制调用之前调用。错误检查的一些部分再次被省略了：'
- en: Newly created resources can be used immediately – make sure they are put into
    descriptor sets. We discussed the texture creation process earlier in the recipe
    *Using texture data in Vulkan*. Once a new texture is created, the flag `awaitingCreation_`
    is set to signal that we need to update the descriptor set. If there are no new
    textures or samplers, no descriptor set updates are required.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新创建的资源可以立即使用 - 确保它们被放入描述符集中。我们之前在配方*在Vulkan中使用纹理数据*中讨论了纹理创建过程。一旦创建了一个新的纹理，`awaitingCreation_`标志就会被设置，以表示我们需要更新描述符集。如果没有新的纹理或样本器，则不需要更新描述符集。
- en: '[PRE124]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: As we learned from the previous recipe, *Storing Vulkan objects*, textures and
    samplers are stored in pools within `VulkanContext`. Here we grow the descriptor
    pool as needed to accommodate all those textures and samplers.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如我们从之前的配方中学到的，*存储Vulkan对象*，纹理和样本器都存储在`VulkanContext`内的池中。在这里，我们根据需要扩展描述符池，以容纳所有这些纹理和样本器。
- en: '[PRE125]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Let’s prepare Vulkan structures to update the descriptor set with sampled and
    storage images. *LightweightVK* always stores a dummy texture at the index `0`
    to avoid sparse arrays in GLSL shaders and enable all shaders to safely sample
    non-existing textures.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们准备Vulkan结构来更新描述符集，以包含采样和存储图像。*LightweightVK*总是存储一个索引为`0`的虚拟纹理，以避免GLSL着色器中的稀疏数组，并使所有着色器能够安全地采样不存在的纹理。
- en: '[PRE126]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Iterate over the pool of textures and fill in the `VkDescriptorImageInfo` structures
    according to the image properties. Multisampled images can be accessed from shaders
    only using `texelFetch()`. This is not supported by *LightweightVK*, so we will
    skip this here.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历纹理池，并根据图像属性填充`VkDescriptorImageInfo`结构。多采样图像只能通过`texelFetch()`从着色器中访问。这不被*LightweightVK*支持，所以我们在这里跳过这一步。
- en: '[PRE127]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: Images are expected to be in specific image layouts. Sampled images should use
    `VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL`, while storage images should use `VK_IMAGE_LAYOUT_GENERAL`.
    *LightweightVK* ensures proper image layout conversions automatically. We will
    talk about it in subsequent chapters.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 预期图像将处于特定的图像布局中。采样图像应使用`VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL`，而存储图像应使用`VK_IMAGE_LAYOUT_GENERAL`。*LightweightVK*会自动确保正确的图像布局转换。我们将在后续章节中讨论它。
- en: '[PRE128]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Samplers are handled in a very similar way.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 样本器以非常相似的方式处理。
- en: '[PRE129]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'The structure `VkWriteDescriptorSet` specifies parameters of a descriptor set
    write operation. We need to fill in one structure per each of our `3` bindings
    that correspond to `3` different descriptor types: `VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE`,
    `VK_DESCRIPTOR_TYPE_SAMPLER`, and `VK_DESCRIPTOR_TYPE_STORAGE_IMAGE`. This code
    snippet is straightforward but somewhat lengthy. We include it here in its entirety
    for your reference.'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结构`VkWriteDescriptorSet`指定了描述符集写入操作的参数。我们需要为每个对应于`3`种不同描述符类型的`3`个绑定填充一个结构：`VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE`、`VK_DESCRIPTOR_TYPE_SAMPLER`和`VK_DESCRIPTOR_TYPE_STORAGE_IMAGE`。这个代码片段很简单，但有些长。我们将其完整地包含在这里供您参考。
- en: '[PRE130]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: If we have filled in any `VkWriteDescriptorSet` structures, invoke the Vulkan
    function `vkUpdateDescriptorSets()` to update the descriptor set. Since we are
    updating the entire descriptor set, it is essential to ensure that Vulkan is not
    using it by calling `wait()` with the last known submit handle. This mechanism
    was discussed in the previous chapter in the recipe *Using Vulkan command buffers*.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们已填充任何 `VkWriteDescriptorSet` 结构，则调用 Vulkan 函数 `vkUpdateDescriptorSets()`
    来更新描述符集。由于我们正在更新整个描述符集，因此确保 Vulkan 在调用 `wait()` 时没有使用它，这是至关重要的，这里使用的是最后一个已知的提交句柄。这种机制在前一章的配方
    *使用 Vulkan 命令缓冲区* 中已有讨论。
- en: '[PRE131]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: The C++ part of the descriptor set updating process is concluded. The only remaining
    part now is how to access these descriptor sets from GLSL shaders. Let’s learn
    how it works.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 描述符集更新过程的 C++ 部分已经完成。现在唯一剩下的部分是如何从 GLSL 着色器中访问这些描述符集。让我们来看看它是如何工作的。
- en: How it works…
  id: totrans-357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`VulkanContext` injects some helper code into GLSL shaders to simplify the
    workflow with our bindless descriptor sets. Let’s recall the function `VulkanContext::createShaderModule()`,
    which does the injection. Here’s the GLSL code that automatically inserts into
    every fragment shader:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '`VulkanContext` 将一些辅助代码注入到 GLSL 着色器中，以简化与我们的无绑定描述符集的工作流程。让我们回顾一下 `VulkanContext::createShaderModule()`
    函数，它负责注入。以下是自动插入到每个片段着色器中的 GLSL 代码：'
- en: First, it declares some unbound arrays that are stored in our bindless descriptor
    set. Here, you’ll notice that the descriptor set ID ranges from `0` to `2`. However,
    don’t be misled by this; it is the same descriptor set bound to three different
    locations. As demonstrated earlier in this recipe, this is necessary to ensure
    compatibility with *MoltenVK*.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它声明了一些存储在我们的无绑定描述符集中的未绑定数组。在这里，您会注意到描述符集 ID 范围从 `0` 到 `2`。然而，不要被这个误导；这是绑定到三个不同位置的相同描述符集。正如在本配方中先前演示的那样，这是确保与
    *MoltenVK* 兼容所必需的。
- en: '[PRE132]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: Then, some helper functions are added. These functions correspond to the standard
    GLSL functions, such as `texture()`, `textureLod()`, and others. These functions
    streamline the process of working with descriptor indexing. We list here only
    some of them so you can get the overall picture.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加了一些辅助函数。这些函数对应于标准的 GLSL 函数，例如 `texture()`、`textureLod()` 等。这些函数简化了使用描述符索引的过程。我们在这里只列出其中的一些，以便您能够了解整体情况。
- en: '[PRE133]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: With this, our GLSL fragment shader `Chapter03/02_STB/main.frag` can be rewritten
    as follows without any manual declarations of the lengthy data structures.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了这个，我们的 GLSL 片段着色器 `Chapter03/02_STB/main.frag` 可以重写如下，无需手动声明这些冗长的数据结构。
- en: '[PRE134]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: With the bindless descriptor set code in place, we can render textured objects
    such as the one in the following image.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在绑定的描述符集代码就绪后，我们可以渲染纹理对象，例如以下图像中的对象。
- en: '![Figure 3.4: Rendering a textured quad](img/img_chapter03_image5.png)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4：渲染纹理四边形](img/img_chapter03_image5.png)'
- en: 'Figure 3.4: Rendering a textured quad'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4：渲染纹理四边形
- en: There’s more…
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The topic of efficient resource management in Vulkan is vast and complicated.
    We will return to descriptor set management later when we discuss 3D scene data
    management and the rendering of complex multitextured materials.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: Vulkan 中高效资源管理的主题非常广泛且复杂。当我们讨论 3D 场景数据管理和复杂多纹理材质的渲染时，我们将在稍后返回到描述符集管理。
