- en: Advanced Data Structures and Algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn about advanced data structures and algorithms.
    We will learn how to use structures such as stacks, circular linked lists, doubly
    linked lists, and binary trees and their traversal.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a stack using a singly linked list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a doubly or two-way linked list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a circular linked list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a binary search tree and doing inorder traversal recursively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing postorder traversal of a binary tree non-recursively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we get into the recipes, it will be helpful for us to understand some
    of the structures and related terminologies we will be using in this chapter as
    well as in the other recipes in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A stack is a data structure where all insertions and deletions are performed
    at one end. The end at which insertions and deletions are performed is called
    the **top of the stack** (**tos**). The stack is also known as a **pushdown list**
    or **Last In First Out** (**LIFO**); that is, the last item that is added to the
    stack is added at the top of all earlier items and will be the first item to be
    taken out of the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'The operations that can be performed on the stack are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Push**: This pushes the value onto the stack. Before pushing the value onto
    the stack, the value at the top is incremented to point at the new position where
    the new value can be pushed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pop**: This pops or fetches the value from the stack. The value at the top
    or the value pointed at by the top is taken out of the stack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Peep**: This shows the value that is at the top of the stack, that is, the
    value that is pointed at by the stack, without taking that value out of the stack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Doubly linked lists (two-way linked lists)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In doubly or two-way linked lists, two pointers are used in the structure,
    where one pointer points in the forward direction and the other points in the
    backward direction. These two pointers allow us to traverse a linked list in both
    ways, that is, in **First in First Out** (**FIFO**) order as well as LIFO order.
    In a singly linked list, traversal is only possible in one direction. The node
    of a doubly linked list looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1c8fbda8-34ef-4484-9747-6dac9b13303c.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see in the preceding diagram, there are two pointers, `next` and `prev`
    (you can give any name you like to these pointers). The `next` pointer is pointing
    at the next node, while the `prev` pointer is pointing at its previous node. To
    traverse the doubly linked list in both directions, we will make use of two other
    pointers called `startList` and `endList`. The `startList` pointer is set to point
    at the first node, while the `endList` pointer is set to point at the last node
    to allow for the traversal of the doubly linked list in both directions.
  prefs: []
  type: TYPE_NORMAL
- en: To traverse in FIFO order, we begin traversing from the node being pointed at
    by `startList`, moving further with the help of the `next` pointer. To traverse
    in LIFO order, we begin traversing the linked list from the node that's being
    pointed at by the `endList` pointer, then move backward with help of the `prev`
    pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 'A doubly linked list that consists of certain nodes may look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/30635fc0-c588-4f92-9e20-49a4f63fa3ae.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that the `prev` pointer of the first node and the `next` pointer of the
    last node is set to `NULL`. These `NULL` values help to terminate the traversing
    procedure.
  prefs: []
  type: TYPE_NORMAL
- en: Circular linked lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a linear linked list, the nodes are connected one after the other, and each
    node except the first has a unique predecessor and successor. The last node is
    set to point at `NULL` to indicate the termination of the linked list. But in
    the case of a circular linked list, the next pointer of the last node points back
    to the first node instead of pointing at `NULL`. In other words, a circular linked
    list has no `NULL` pointer, as can be seen in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4658723f-6b9c-44b0-973c-f6c8a8e82480.png)'
  prefs: []
  type: TYPE_IMG
- en: The advantage of a circular linked list over a linear linked list is that a
    circular linked list allows the pointer to move in reverse direction too. In real-world
    applications, the circular linked list is used in several places. For example,
    it can be used in an operating system while scheduling a CPU in a round-robin
    fashion, it can be used in a playlist of songs, and it can be used to track users
    in games.
  prefs: []
  type: TYPE_NORMAL
- en: Binary tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A tree in which all of the nodes can have two children or siblings (at most)
    is called a binary tree. A binary tree has the following characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: A tree contains, at most, 2^l nodes at level *l*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a binary tree contains *m* nodes at level *l*, it contains at most *2m* nodes
    at level *l+1*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A tree contains *2d* leaves and therefore *2d-1* non-leaf nodes, where *d* is
    its depth.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A binary tree with *n* internal nodes has (*n+1*) external nodes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A binary tree with *n* nodes has exactly *n+1* `NULL` links (see the following
    screenshot):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/04bee979-2cad-4fd6-b42c-7fa8c26840de.png)'
  prefs: []
  type: TYPE_IMG
- en: Binary search trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A binary search tree is a tree in which the time to search an element is `O(log2n)`
    (which is faster than searching an element in a binary tree, where `O(n)`). But
    to support `O(log2n)` searching, we need to add a special property to the binary
    tree: we put all the nodes with values smaller than the value in the root into
    its left subtree and all of the nodes with values larger than the value in the
    root into its right subtree.'
  prefs: []
  type: TYPE_NORMAL
- en: Traversing trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Traversing means visiting the nodes of a tree. There are three ways of traversing
    a binary tree: preorder, inorder, and postorder. Since traversing a binary tree
    requires visiting the root and then its left and right child, these three ways
    of traversal only differ in the order in which visiting is performed. The tree
    traversal methods that are defined with the recursion method are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For preorder traversal, these are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Visit the root
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Traverse the left subtree in preorder
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Traverse the right subtree in preorder
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In preorder traversal, the root node of the binary tree is visited first.
  prefs: []
  type: TYPE_NORMAL
- en: 'For inorder traversal, these are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Traverse the left subtree in inorder
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visit the root
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Traverse the right subtree in inorder
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For postorder traversal, these are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Traverse the left subtree in postorder
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Traverse the right subtree in postorder
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we've had a thorough introduction to the structures we will be looking
    at in this chapter, we can begin our journey.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a stack using a singly linked list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to implement a stack that has a LIFO structure.
    LIFO means that whatever element was added to the stack last will be the first
    to be removed. The stack is a very important component of any compiler and operating
    system. The stack is used in branching operations, recursion, and many other system-level
    tasks. The stack can be implemented using arrays as well as through linked lists.
    In this recipe, we will learn how to implement a stack using a single linked list.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement a stack using a linked list:'
  prefs: []
  type: TYPE_NORMAL
- en: A structure is defined called `node`. In this structure, besides a data member
    for storing content for the stack, a pointer is also defined that points to the
    next node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `top` pointer is initialized to `NULL` to indicate that the stack is currently
    empty.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A menu is displayed and the user is asked whether they want to push or pop from
    the stack. The user can enter 1 to indicate that they want to push a value to
    the stack or enter 2 to indicate that they want to pop a value from the stack.
    If the user enters `1`, go to *step 4*. If they enter `2`, go to *step 9*. If
    they enter `3`, it means they want to quit the program, so go to *step 13*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Allocate memory for the new node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ask the user for the value to be pushed and assign that value to the data member
    of the node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Invoke the push function where the next pointer of the new node is set to point
    at `top`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `top` pointer is set to point at the new node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to *step 3* to display the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check whether the `top` pointer is `NULL`. If yes, then display the message
    `Stack is empty` and go to *step 3* to display the menu. If `top` is not `NULL`,
    go to the next step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A temporary pointer, `temp`, is set to point at the node where `top` is pointing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `top` pointer is set to point to where its `next` pointer is pointing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the node that's being pointed at by `temp` as the popped node and display
    the data member of the popped node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exit the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The program for implementing a stack using a linked list is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes so that we can understand the code.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, a structure is defined, called a node, that consists of two members:
    one is the data and the other is a pointer called `next`. Because we want our
    stack to only store integer values, the data member of the structure is defined
    as an integer for storing integers and the next pointer is used to connect other
    nodes. Initially, the `top` pointer is set to `NULL`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A `while` loop is set to execute, within which a menu is displayed. The menu
    is set to display three options: 1, to push into the stack; 2, to pop from the
    stack; and 3, to quit. Until the user enters 3 in the menu, the `while` loop will
    continue executing and keep displaying the menu, prompting the user to enter the
    desired option. If the user enters 1 to push a value to the stack, a new node
    is created by `newNode`. The user is prompted to enter the value to be pushed
    to the stack. Suppose the data that''s being entered by the user is 10\. Here,
    that value will be assigned to the data member of `newNode`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ad051f01-8b3b-437b-9031-ba1b14bcefba.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Thereafter, the `push` function is invoked and `newNode` and the `top` pointer
    are passed to it. In the `push` function, the next pointer of `newNode` is set
    to point at the `top` pointer, which is `NULL`, and then the top pointer is set
    to point at X, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/277d1b4c-441a-448f-aef3-5659f893dfd7.png)'
  prefs: []
  type: TYPE_IMG
- en: The `top` pointer must always point to the last inserted node. Due to this,
    it is set to point at `newNode`. After completing the `push` function, control
    goes back to the `main` function, where the menu will be displayed once more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that the user enters 1 to push another value to the stack. Again,
    a new node is created by `newNode`. The user is asked to enter the value to push.
    Assuming that the user enters 20, the value 20 will be assigned to the data member
    of `newNode`. The `push` function is invoked and `newNode` and the `top` pointer
    are passed to it. Here, the `top` pointer is pointing at the node that was pushed
    earlier, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/64e52460-2831-421b-a0da-33b7d732b1b9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the `push` function, the next pointer of `newNode` is set to point at the
    node where the `top` pointer is pointing to, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bbcdabfb-5091-4fec-9d07-63c99c6289aa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, the `top` pointer is set to point at `newNode`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/178f2a74-ced5-4ebf-86e6-363a748dc792.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After executing the `push` function, the menu will be displayed again. Let''s
    assume that the user wants to *pop* a value from the stack. To do this, they will
    enter 2 in the menu. The `pop` function will be invoked and the top pointer will
    be passed to it. In the `pop` function, it''s ensured that the `top` pointer is
    not `NULL` because if it is, this means the stack is already empty; a value can''t
    be popped out from an empty stack. To get the value from the stack, we will use
    a temporary pointer called `temp`. The `temp` pointer is set to point at the node
    that''s being pointed to by the `top` pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb78cf8e-23a8-4f5a-b201-f19fe992329b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Thereafter, the `top` pointer is set to move to the next node, that is, the
    node where its next pointer is pointing to. The node that''s being pointed at
    by the `temp` pointer is returned to the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/79728034-2bf2-47f8-ac1b-146e0f874ff2.png)'
  prefs: []
  type: TYPE_IMG
- en: In the `main` function, the node that's returned by the `pop` function is assigned
    to `recNode`. First, it's confirmed that `recNode` is not `NULL`. Then, the value
    in its data member is displayed on the screen. So, 20 will be displayed on the
    screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'After executing the `pop` function, the menu will be displayed once more, asking
    the user to enter the desired option. Let''s assume that the user presses 2 to
    pop another value from the stack. Again, the `pop` function will be invoked. In
    the `pop` function, we check that the `top` pointer is not `NULL` and that it''s
    pointing to a node. Because the `top` pointer is pointing at a node and is not
    `NULL`, a temporary pointer, `temp`, is set to point at the node that''s being
    pointed to by the `top` pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1f27a42c-d088-43d1-badc-3b5b10b39470.png)'
  prefs: []
  type: TYPE_IMG
- en: Thereafter, the `top` pointer is set to point to where its next pointer is pointing.
    The next pointer of `top` is pointing at `NULL`, so the `top` pointer will be
    set to `NULL` and the node that is being pointed to by the `temp` pointer is returned
    to the `main` function.
  prefs: []
  type: TYPE_NORMAL
- en: In the `main` function, the returned node from the `pop` function is assigned
    to the `recNode` pointer. After confirming that `recNode` is not pointing at `NULL`,
    the value in the data member of `recNode` is displayed on the screen. So, the
    value 10 will appear on the screen. After executing the `pop` function, the menu
    will be displayed again on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Let's assume that the user wants to pop the stack once more. But at this point,
    we know that the stack is empty. When the user presses `2` on the menu, the `pop`
    function will be invoked. However, since the value of the `top` pointer is `NULL`,
    the pop function will return a `NULL` value to the `main` function. In the `main`
    function, the `NULL` value that was returned by the `pop` function is assigned
    to the `recNode` pointer. Because the `recNode` pointer is assigned `NULL`, a
    message stating `stack is empty` will be displayed on the screen. Again, the menu
    will be displayed, prompting the user to enter a choice. Upon entering 3, the
    program will terminate.
  prefs: []
  type: TYPE_NORMAL
- en: 'The program is compiled using GCC. Because no error appears on compilation,
    this means the `stacklinkedlist.c` program has successfully compiled into the
    `stacklinkedlist.exe` file. On executing the file, we get a menu, prompting us
    to push or pop from the stack, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/11df2b8a-038e-4966-8c43-8642b2ff7ce8.png)'
  prefs: []
  type: TYPE_IMG
- en: While popping from the stack, you must have noticed that the stack is a LIFO
    structure where the value that was pushed last was the first to be popped out.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move on to the next recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a doubly or two-way linked list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will learn how to create a doubly linked list and how to
    traverse its elements in FIFO and LIFO order. As we explained in the introduction
    to this chapter, the node of a doubly linked list consists of two pointers: one
    points forward, while the other points backward. The pointer pointing forward
    is usually called `next` and is used to point at the next node. The other, which
    is pointing backward, is usually called `prev` and is used to point at the previous
    node.'
  prefs: []
  type: TYPE_NORMAL
- en: Traversal in FIFO order means the elements of the doubly linked list are displayed
    in the order in which they were added to the list. Traversal is done by making
    use of the `next` pointer of the node.
  prefs: []
  type: TYPE_NORMAL
- en: Traversal in LIFO order means the elements are displayed in reverse or backward
    direction, and this traversal is done with the help of the `prev` pointer.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this doubly linked list, I will be making use of two pointers, `startList`
    and `endList`, where `startList` will point at the first node and `endList` will
    point at the last node. The `startList` pointer will help to traverse the list
    in FIFO order, while the `endList` pointer will help to traverse it in LIFO order.
    Follow these steps to create a doubly linked list and traverse it in either direction:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a structure called `node`. To store content for the doubly linked list,
    define a data member in the node structure. Define two pointers called `next`
    and `prev`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A menu is displayed that shows four options: `1`, to create a doubly linked
    list; `2`, to display the elements of the list in LIFO order; `3`, for displaying
    the elements in FIFO order; and `4`, to quit. If the user enters 1, go to *step
    3*. If the user enters 2, go to *step 10*. If the user enters 3, go to *step 15*.
    Finally, if the user enters 4, then it means they want to quit the program, so
    go to *step 19*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize the `startList` pointer to `NULL`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Allocate memory for the new node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ask the user for the value to be added to the doubly linked list. The value
    that's entered by the user is assigned to the data member of the node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `next` and `prev` pointers of the node to `NULL`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If this node is the first node of the doubly linked list, set the `startList`
    pointer to point at the new node. If this node is not the first node, don't disturb
    the `startList` pointer and let it point at the node that it is currently pointing
    to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If this is the first node of the doubly linked list, set the `endList` pointer
    to at new node. If this is not the first node, perform the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `next` pointer of the new node to `NULL`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `prev` pointer of the new node so that it points at the node pointed
    at by `endList`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `next` pointer of `endList` so that it points at the new node.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `endList` so that it points at the new node.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Ask the user whether more elements have to be added to the doubly linked list.
    If the user wants to enter more, go to *step 4*; otherwise, display the menu by
    going to *step 2*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To display the linked list in LIFO order, let the `temp` pointer point at the
    node being pointed at by `endList`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let *step 12* and *step 13* run until the `temp` pointer reaches `NULL`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display the data member of the node being pointed at by `temp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `temp` pointer so that it points to where its `prev` pointer is pointing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The doubly linked list's content is displayed in LIFO order. Now, go to *step
    2* to display the menu again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the `temp` pointer point at the node being pointed at by the `startList`
    pointer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the `temp` pointer is not `NULL`, display the data member of the node being
    pointed at by `temp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let the `temp` point at the node that its next pointer is pointing to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `temp` has reached `NULL`, this means all of the nodes of the doubly linked
    list have been traversed. Now, you can display the menu by jumping to *step 2*.
    If `temp` has not reached `NULL`, then go to *step 16* to display the rest of
    the elements of the doubly linked list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exit the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The program for implementing a doubly or two-way linked list is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes so that we can understand the code.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When implementing a doubly linked list, a structure is defined, called a node,
    that consists of an integer called `data` and two pointers, `next` and `prev`.
    Because a doubly linked list can be traversed from either end—that is, forward
    or backward—the two pointers are required. The `next` pointer will point at the
    node after it, whereas the `prev` pointer will point at the node just before it.
  prefs: []
  type: TYPE_NORMAL
- en: 'A menu is displayed on the screen showing four options: `1`, for creating the
    doubly linked list; `2`, for displaying the elements of the doubly linked list
    in LIFO order; `3`, for displaying elements in FIFO order; and `4`, to quit the
    program.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's assume that the user enters 1\. The `createdoubly` function will be invoked.
    In this function, the `startList` pointer is set to `NULL` and a string variable,
    `k`, is assigned the `yes` string. A `while` loop is set to execute while `k`
    has `yes` assigned to it. Here, the user can keep adding more elements to the
    doubly linked list by entering `yes` whenever they are prompted to continue. The
    `startList` pointer will be set to point at the first node of the doubly linked
    list, while the `endList` pointer will be set to point at the last node.
  prefs: []
  type: TYPE_NORMAL
- en: 'The procedure for adding the first node is different from adding the rest of
    the nodes. Due to this, `if else` blocks are made in the code. When `startList`
    is `NULL` while creating the first node, an `if` block will be executed; otherwise,
    an `else` block will be executed. In the `if` block, a new node is created called
    `newNode`. The user is asked to enter a value for the doubly linked list. Suppose
    the user enters the value 10; this will be assigned to the data member of `newNode`,
    and the `next` and `prev` pointers of `newNode` will be set to `NULL`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/08445db2-9147-4fce-83e4-0841e2e820c6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `startList` pointer is set to point at `newNode`, and the `endList` pointer
    is also set to point at `newNode`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/39d11d91-2d0b-4f2b-a76d-b1f28b66996d.png)'
  prefs: []
  type: TYPE_IMG
- en: '`endList` will not stay on this first node; instead, it will keep moving forward
    and will point at the last node of this doubly linked list. After executing the
    `if` block, the user is asked whether more nodes have to be added. If the user
    enters yes, the `while` loop will execute again. Now, `startList` isn''t `NULL`
    and is pointing at `newNode`; so, instead of the `if` block, the `else` block
    will execute. In the `else` block, a new node is created called `newNode`. The
    user is prompted to enter a value to be added to the doubly linked list. Assuming
    the user enters a value of 20, the value will be assigned to the data member of
    `newNode`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/abb133f0-d943-4b09-a8d1-6a2213614f7a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `prev` pointer of `newNode` is set to point at `endList`, while the `next`
    pointer of `newNode` is set to `NULL`. The `next` pointer of `endList` is set
    to point at `newNode`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5a6c0aae-f263-4212-8702-08f1dba14544.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Thereafter, the `endList` pointer is set to point at `newNode`, but the `startList`
    pointer will be kept pointing at the first node, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e5baf9cf-76ab-4f5f-8ae9-691220202160.png)'
  prefs: []
  type: TYPE_IMG
- en: Once again, the user is asked whether they want to add more elements to the
    doubly linked list. Suppose the user doesn't want to add more elements to the
    list, so the text they enter is `no`. The text `no` will be assigned to `k` and,
    consequently, the `while` loop will terminate. The `createdoubly` function ends
    and control will be returned to the `main` function. In the `main` function, the
    menu will be displayed with the aforementioned four options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that the user enters 2 to display the elements of the doubly
    linked list in LIFO order. Here, the `list_lifo` function will be invoked. In
    the `list_lifo` function, a temporary pointer called `temp` is used and is set
    to point at the last node that was pointed at by the `endList` pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/74d46d9f-471f-478a-962f-3be90d46728a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A `while` loop is set to execute until the `temp` pointer reaches `NULL`. The
    value in the data member of the node being pointed at by the `temp` pointer is
    displayed on the screen. Here, a value of 20 will appear on the screen. After
    that, the `temp` pointer is set to point to the node being pointed to by its `prev`
    pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d8d19e78-3cdc-4377-bc86-c47a9fb324d1.png)'
  prefs: []
  type: TYPE_IMG
- en: Again, the value of the `temp` pointer is checked. Because the `temp` pointer
    isn't `NULL`, the `while` loop will execute again. Within the `while` loop, the
    value in the data member of the node being pointed at by the `temp` pointer is
    displayed on the screen. Here, a value of 10 will appear on the screen. Thereafter,
    the `temp` pointer is set to point at the node that its `prev` pointer is pointing
    to. The `prev` pointer of `temp` is pointing at `NULL`, so the `temp` pointer
    is set to point at `NULL`. Now, because `temp` is pointing at `NULL`, the `while`
    loop will terminate, the `list_lifo` function ends, and control goes back to the
    `main` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `main` function, the menu will be displayed again asking the user to
    enter the desired option. Now, let''s assume that the user enters 3 to display
    the elements of the doubly linked list in FIFO order. On entering 3, the `list_fifo`
    function will be invoked. In the `list_fifo` function, the `temp` pointer is set
    to point at the node being pointed at by the `startList` pointer, as shown previously.
    The `while` loop is set to execute until the `temp` pointer points at `NULL`.
    Because `temp` is not `NULL`, the value in the data member of the node being pointed
    at by the `temp` pointer is displayed on the screen. Here, a value of 10 will
    appear on the screen. Thereafter, the `temp` pointer is set to point at the node
    that is being pointed to by its `next` pointer, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cae73af2-783d-4354-8e19-1b62499c1a27.png)'
  prefs: []
  type: TYPE_IMG
- en: Because the `temp` pointer is still not pointing at `NULL`, the `while` loop
    will execute once more. Within the `while` loop, the value in the data member
    of the node being pointed at by the `temp` pointer is displayed on the screen;
    a value of 20 will appear. Again, the `temp` pointer is set to point at the node
    that its next pointer is pointing to. The next pointer of `temp` is pointing at
    the `NULL` pointer, so `temp` will point at `NULL`. Because the `temp` pointer
    is pointing at `NULL`, the `while` loop will terminate; hence, the `list_fifo`
    function ends and control goes back to the `main` function. Here, the menu is
    displayed once more, asking the user to enter the desired option. Let's assume
    the user enters 4 to quit the program. Upon entering 4, the program will terminate.
  prefs: []
  type: TYPE_NORMAL
- en: 'The program is compiled using GCC. Because no error appears upon compilation,
    this means the `doublylinkedlist.c` program has successfully compiled into the
    `doublylinkedlist.exe` file. On executing the file, we get a menu asking for options
    for creating a doubly linked list and for traversing the doubling linked list
    in LIFO as well as in FIFO order. By doing this, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3bb270ba-890b-467a-8426-c07ad0332809.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows the benefit of using a doubly linked list that
    is traversing its elements in FIFO, as well as in LIFO, order.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a circular linked list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to implement a circular linked list. The difference
    between a linear linked list and a circular linked list is that where the last
    node of the linear linked list points at `NULL`, the pointer of the last node
    in a circular linked list points back to the first node, hence allowing the pointer
    to traverse in a backward direction too.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement a circular linked list:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a structure called `node`. To store data in a circular linked list, define
    a data member in the node structure. Besides a data member, define a pointer that
    will point at the next node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A pointer called `startList` is initialized to `NULL`. The `startList` pointer
    will designate the start of the circular linked list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A menu is displayed and the user is asked to press `1` to add elements to the
    circular linked list, `2` to display elements of the circular linked list, and
    `3` to quit the program. If the user enters 1, go to *step 4*. If they enter 2,
    go to *step 16*. If they enter 3, it means they want to quit the program, so go
    to *step 23*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user is prompted to specify how many numbers they want to add to the circular
    linked list. A loop is set to execute for the specified number of times; that
    is, *steps 5* to *14* are repeated for the specified number of times.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Allocate memory for the new node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ask the user for the value to be added to the circular linked list. The value
    that's entered by the user is assigned to the data member of the node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `startList` is `NULL`—that is, if it is the first node of the circular linked
    list—then make the `startList` pointer point at a new node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To make a linked list appear as circular, make the next pointer of `startList`
    point at `startList`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `startList` is not `NULL`—that is, if it is not the first node of the circular
    linked list—follow *steps 10* to *14*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the `temp` pointer point at `startList`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Until the `next` pointer of `temp` is equal to `startList`, make the `temp`
    pointer point to where its next pointer is pointing; that is, set the `temp` pointer
    so that it points at the last node of the circular linked list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the `temp` pointer reaches the last node of the circular linked list, the
    next pointer of `temp` is set to point at the new node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, the `temp` pointer is set to point at the new node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next pointer of `temp` is set to point at `startLIst`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to *step 3* to display the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The previous step ensures `startList` is not `NULL`. If `startList` is `NULL`,
    it means the circular linked list is empty. In that case, a message is displayed,
    informing the user that the circular linked list is empty. Then, control jumps
    to *step 3* to display the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `startList` is not `NULL`, the data member of the node being pointed at by
    the `startList` pointer is displayed on the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A temporary pointer, `temp`, is set to point to where the next pointer of `startList`
    is pointing to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat *steps 20* and *21* until the `temp` pointer reaches the node being pointed
    at by the `startList` pointer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display the contents of the node being pointed at by the data member of `temp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `temp` pointer is set to point to where its next pointer is pointing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Jump to *step 3* to display the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Terminate the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The program for implementing a circular linked list is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes so that we can understand the code.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A structure is defined, called a node, that consists of two members: an integer
    and a pointer called `next`. I am creating a circular linked list comprised of
    integer numbers, which is why I have taken an integer member. However, you can
    use any number of members you want, as well as any data type.'
  prefs: []
  type: TYPE_NORMAL
- en: We define a pointer called `startList` and initialize it to `NULL`. The `startList`
    pointer will be used to point at the first node of the circular linked list.
  prefs: []
  type: TYPE_NORMAL
- en: 'A menu is displayed on the screen that shows three options: `1`, to add elements
    to the circular linked list; `2`, to display elements of the circular linked list;
    and `3`, to quit. Obviously, the first step is to add elements to the circular
    linked list. Let''s assume that the user enters 1\. On entering 1, the user will
    be asked to specify how many values they want to enter in the list. The limit
    that''s entered by the user will be assigned to a variable called `k`. Assuming
    that the user wants to enter five elements in the list, a `for` loop is set to
    run five times. Within the `for` loop, a new node is created called `newNode`.
    The value that''s entered by the user is assigned to the data member of `newNode`.
    Assuming the value that''s entered by the user is 10, it will be assigned to the
    data member of `newNode`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bd7d0b89-849c-4743-a722-80cb251ac5db.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `addlist` function will be invoked and `newNode` will be passed to it as
    an argument. In the `addlist` function, it is confirmed whether it is the first
    node of the circular linked list or not; that is, if `startList` is `NULL`, it
    is set to point at `newNode`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ddbf4966-3251-45db-b97c-bbf95fe499a7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To make it a circular linked list, the next pointer of `startList` is set to
    point at `startList` itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/18d831f7-c2ff-49b8-84d6-3695f73c5055.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `addlist` function ends. Control goes back to the main function and resumes
    the `for` loop''s execution. Within the `for` loop, a `newNode` node is created.
    The value that''s entered by the user is assigned to the data member of `newNode`.
    Assuming that the user has entered a value of 20, it will be assigned to the data
    member of `newNode`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f76a5552-d4af-462a-a06d-15492e2bfefe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Again, the `addlist` function is invoked and `newNode` is passed to it. In
    the `addlist` function, because the `startList` pointer is no longer `NULL`, the
    `else` block will be executed. In the `else` block, a temporary pointer called
    `temp` is set to point at `startList`. A `while` loop is set to execute until
    the next pointer of `temp` points at `startList`; that is, until the `temp` pointer
    reaches the last node of the circular linked list, the `temp` pointer will keep
    moving further so that it points at its next node. Because there is only a single
    node in the circular linked list, the `temp` pointer is already pointing at the
    last node of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6a7ddca6-64af-4ac2-9c1c-8326829b46e4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the `temp` pointer reaches the last node of the circular linked list,
    the next pointer of `temp` is set to point at `newNode`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a0dd88ba-a9ba-47ba-82cb-555a0dd9e642.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Thereafter, the `temp` pointer is set to point at `newNode`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c25e914c-b753-46b5-a583-755ddb88c8dc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, to make the linked list appear circular, the next pointer of `temp`
    is set to point at `startList`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dc084ee7-5ca2-4916-9cf4-4fbe1e804156.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This procedure is repeated for the other three elements of the circular linked
    list. Assuming the other the three elements that are entered are 30, 40, and 50,
    the circular linked list will appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/238ecd8f-3881-40b7-9040-d79acdb41f4a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After creating the circular linked list, the user will see the display menu
    again. Assuming the user wants to display the elements of the circular linked
    list, they will enter a value as per the menu choices. Upon entering the value,
    the `disp` function will be invoked. In the `disp` function, it''s ensured that
    the `startList` pointer is `NULL`. If the `startList` pointer is `NULL`, it means
    the circular linked list is empty. In that case, the `disp` function will terminate
    after displaying the message that the circular linked list is empty. If the `startList`
    pointer is not empty, the value in the data member of the node being pointed at
    by the `startList` pointer is displayed on the screen; that is, a value of 10
    will appear on the screen. A temporary pointer, `temp`, is set to point at the
    node being pointed at by the next pointer of `startList`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c05a6088-bde0-4a6b-b7a3-93c75c315db2.png)'
  prefs: []
  type: TYPE_IMG
- en: A `while` loop is set to execute until the `temp` pointer reaches the node being
    pointed at by the `startList` pointer. Within the `while` loop, the data member
    of the node being pointed at by the `temp` pointer is displayed on the screen;
    that is, a value of 20 will appear on the screen. Thereafter, the `temp` pointer
    is set to point at the node that its next pointer is pointing to. This way, the
    `while` loop will execute and display all of the elements of the circular linked
    list. When the `while` loop ends, the `disp` function also ends. Control goes
    back to the `main` function, where the menu will be displayed once more. To exit
    the program, the user has to enter 3\. On entering 3, the program will terminate.
  prefs: []
  type: TYPE_NORMAL
- en: 'The program is compiled using GCC. Because no error appears on compilation,
    this means the `circularlinkedlist.c` program has successfully compiled into the
    `circularlinkedlist.exe` file. On executing the file, we get a menu that will
    not only add elements to the circular linked list but will display them too. By
    doing this, we get the output shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d1593da0-7c2b-4c29-80f1-d46b8594694f.png)'
  prefs: []
  type: TYPE_IMG
- en: Voilà! We have successfully implemented a circular linked list. Now, let's move
    on to the next recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a binary search tree and performing an inorder traversal on it recursively
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will ask the user to enter a few numbers and build a binary
    tree from those numbers. Once the binary tree has been created, its inorder traversal
    is performed. These steps will be divided into two parts: creating the binary
    tree and traversing the binary tree in inorder.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it... – binary tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to create the binary tree:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a node with the following structure: `data` for storing tree elements,
    a `right` pointer to point at the right child of the tree, and a `left` pointer
    to point at the left child of the tree.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `root` node of the tree. To do this, allocate memory space for a
    new node and set the `root` pointer to point at it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prompt the user to enter the tree elements. The value that's entered by the
    user is assigned to the data member of the `root` node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `left` and `right` pointers of the `root` node are set to `NULL`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The root node is created. Next, prompt the user to specify the number of elements
    in the tree.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat *steps 7* to *22* for the number of elements specified by the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Allocate memory space for a new node and set the `new` pointer so that it points
    at it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prompt the user to enter the tree element. The tree element that's entered by
    the user is assigned to the data member of the new node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `left` and `right` pointers of the new node are set to `NULL`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To connect the root node to the new node, we need to find a location where it
    can be connected. To do so, set the `temp` pointer so that it points at the root
    node. Compare the values in the data members of the new node and `temp` node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `new ->data > temp->data`, go to *step 12*; otherwise, go to *step 16*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the right link of `temp` is `NULL`—that is, if there is no child on the right
    of the `temp` node—then, the new node is added to the right link of the `temp`
    node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The new node is added as the right child of the `temp` node. Jump to *step 7*
    to add more tree elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the right link of the root is not `NULL`, the `temp` pointer is set to point
    where the `right` pointer of `temp` is pointing to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to *step 11* for more comparisons.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `new->data < root->data`, go to *step 17*; otherwise, go to *step 21*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the left link of the node is `NULL`—that is, there is no child on the left
    of the temp node—then the new node is added to the left link.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The new node is added as the left child of the `temp` node. Jump to *step 7*
    to add more tree elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the left link of the root is not `NULL`, the `temp` pointer is set to point
    to where its `left` pointer is pointing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to *step 11* for more comparisons.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `new->data = temp->data`, this means the value in the new node is a duplicate
    and cannot be added to the tree.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to *step 7* to add more tree elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For inorder traversal, we will follow the algorithm that's provided in the next
    section. The `inorder` function is called recursively and the root node of the
    binary tree is passed to this function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it... – inorder traversal of the tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Because it''s a recursive form, the function will be called recursively. The
    function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `inorder` is the function that will be recursively called and `node`
    is the node of the binary tree that''s being passed to it. Initially, the node
    will be the root of the binary tree, whose inorder traversal is required. Follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: If node is `NULL`, go to *step 2*; otherwise, return to the caller function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Call the same function (the `inorder` function) with the node''s left child
    set as an argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Display the content in the node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the same function itself (the `inorder` function) with the node''s right
    child set as an argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The program for creating a binary search tree and traversing it in inorder
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes so that we can understand the code.
  prefs: []
  type: TYPE_NORMAL
- en: How it works... – binary tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We created a structure called `tree` consisting of the following members:'
  prefs: []
  type: TYPE_NORMAL
- en: '`data`: An integer member for storing integer data. Here, we''re assuming that
    our tree only consists of integer elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`right` and `left` pointers: These are used to point at the left and right
    child, respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internally, the tree will be maintained through an array; an integer array is
    defined of the size 20\. For our purposes, let's assume that the user doesn't
    enter more than 20 elements for the tree. However, you can always increase the
    size of the macro to any larger number you desired.
  prefs: []
  type: TYPE_NORMAL
- en: 'The user is prompted to specify the number of elements they want to enter for
    the tree. Let''s say the user wants to enter seven elements for the tree; here,
    the value 7 will be assigned to the `len` variable. The user is prompted to enter
    the seven integers and the values entered by them will be assigned to the `arr`
    array, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6ea4ab83-40b9-4a24-ada1-7ea9807a844b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `build` function is invoked and the array, `arr`, containing the tree elements
    and the length of the array, `len`, are passed to it. In the `build` function,
    we need to create a root node of the tree. To create a root node of the tree,
    the `makeroot` function is invoked and the first element of the array, `arr`,
    is passed to it as an argument. In the `makeroot` function, a node called `rootNode`
    is created and the value of the first array element is assigned to its data member.
    Because the root node of the tree is not pointing at any other node at the moment,
    the right and left child of the root node are set to `NULL`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0edf7982-a38b-4793-91a4-e2cc4f4251d4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `makeroot` function ends and `rootNode` is returned to the `build` function.
    In the `build` function, a `temp` pointer is set to point at `rootNode`. All of
    the array elements from index 1 and above are compared with the data members of
    the `temp` node, that is, the root node. If the array element is smaller than
    the data member of the `temp` node, the array element will be added as the left
    child of the root node. Also, if the array element is larger than the data member
    of the `temp` node, it will be added as the right child of the root node, for
    example, if the second array element is 20 and the root node is 40\. Because 20
    is smaller than 40, it is checked whether the `left` pointer of the `temp` node
    is `NULL`. Because the `left` pointer of `temp` is `NULL`, the `leftchild` function
    is invoked and 20 is passed to it. In the `leftchild` function, a new node is
    created called `newNode`. Here, the second array element (20) is assigned to the
    data member of `newNode`. The `left` and `right` pointers of `newNode` are set
    to `NULL`. The `left` pointer of `temp` is set to point at `newNode`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/175d0f87-4e87-4ee8-aee5-ea4349f47147.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Control goes back to the `build` function, where the `for` loop will pick up
    the next array element for building the tree. Let''s say the next array element
    is 60\. Again, a `temp` pointer is set to point at the root node. The value 60
    is compared with the root node, which is 40\. Because the value of the array element,
    60, is greater than the root node, 40, the right child of the root node is checked.
    Because the right child of the root node is `NULL`, the `rightchild` function
    is invoked and the `temp` pointer and the array element, 60, are passed to it.
    In the `rightchild` function, a new node is created called `newNode` and the value
    60 is passed to it, which is assigned to its data member. The `left` and `right`
    pointers of `newNode` are set to `NULL`. The `right` pointer of `rootNode` is
    set to point at `newNode`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0c051ac3-4b13-48eb-b3b3-d516019dee9d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After completing the `rightchild` function, control goes back to the `build`
    function, where the `for` loop picks up the next array element for building the
    tree. The next array element is 80\. A temporary pointer, `temp`, is set to point
    at the root node. The root node, 40 is compared with the new element to be added,
    80\. Because 80 > 40, the right child of the `temp` node is checked. The `right`
    pointer of the `temp` node is not `NULL`, so the `temp` pointer is set to point
    at its right node, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/62a3ecf0-7352-4881-9a00-31dd843a41f4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, the `right` pointer of `temp` is checked again. This procedure is repeated
    until the `right` pointer of `temp` is found to be `NULL`. The `right` pointer
    of 60 is `NULL`, so the `rightchild` function is invoked and `temp`, 60, and the
    new element, 80, are passed to it. In the `rightchild` function, a new node is
    created called `newNode` and the value 80 is assigned to it. The right and left
    pointers of `newNode` are set to `NULL`. The `right` pointer of `temp` is set
    to point at `newNode`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/db86352f-0d49-4f40-b250-fb8f3694e29d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After completing the `rightchild` function, control jumps back to the `build`
    function, where the `for` loop picks up the next array element for building the
    tree. After all of the array elements have been used, the binary search tree will
    look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e653e801-ba03-49a4-86f8-5442d383bbac.png)'
  prefs: []
  type: TYPE_IMG
- en: Once the binary search tree has been created, the `travino` function is invoked
    for inorder traversal of the binary tree and the root node is passed to it.
  prefs: []
  type: TYPE_NORMAL
- en: How it works... – inorder traversal of the tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `travino` function is a recursive function. First, it ensures the supplied
    node is not `NULL`. If the node is not `NULL`, a recursive call to the `travino`
    function is made with the node's left child. The node is checked to ensure it's
    not `NULL`. If it isn't, again, a recursive call to the `travino` function is
    made with its left child. If the node is `NULL`, the value in the data member
    of the node is displayed on the screen and a recursive call to the `travino` function
    is made with the node's right child. This procedure is repeated until all of the
    nodes that are displayed on the screen have been visited.
  prefs: []
  type: TYPE_NORMAL
- en: 'The inorder traversal is described as *L*,*V*,*R*, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: L means visiting the left child
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: V means visiting the node that is displaying its content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: R means visiting the right child
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On each node of the binary tree, LVR operations are applied, beginning from
    the root node. Our binary tree has already been created and looks as follows.
    At node 40, three operations—L,V, and R—are applied. L means visiting its left
    child, so we move to the left child of node 40, but two of its operations, V and
    R, still need to be completed on the node left. So, node 40 is pushed onto the
    stack with V and R attached to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fe0d2554-9261-4645-9d19-fd47caa653fe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The left child of node 40 is node 20\. Again, at node 20, three operations—L,V,
    and R—are applied. First, L (the left child) is visited. Only two operations,
    V and R, are left. So, again, node 20 is pushed onto the stack with V and R attached
    to it. The left child of node 20 is node 10\. Again, at this node L, V, and R
    are applied. Since its left child is `NULL`, the second operation, V, is applied;
    that is, the node is displayed or we can say it is traversed. After that, we go
    to its right child. The right child of node 10 is `NULL` and since all three operations
    (L,V, and R) have been applied on this node, it is not pushed to the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b621ce57-32ab-44b2-bb83-17f6eb4d0ca5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, node 20 is popped from the stack. Its two operations, V and R, are pending.
    First, it is visited (displayed) and then we go to its right child:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/52060a7d-41df-4c5d-8c1d-ed5974915369.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The right child of node 20 is 30\. Again, at node 30, three operations—L,V,
    and R—are applied. First L (the left child) is visited. Since it has no left child,
    the second operation, V, is applied; that is, node 30 is visited (displayed),
    and then we go to its right child. It has no right child either and since all
    three operations (L,V, and R) have been applied on this node, 30 is not pushed
    to the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1166c2b0-4537-4afc-b92e-8cb0008651b7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, node 40 is popped from the stack. Its two operations, V and R, are pending.
    First, it is visited (displayed) and then we go to its right child. The right
    child of node 40 is node 60\. At node 60, the three operations—L,V, and R—are
    applied. First, L (the left child) is visited. V and R are left. Here, node 60
    is pushed to the stack with V and R attached to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/52dbf9ff-a522-4981-a405-8c1d91826656.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The left child of node 60 is node 50\. Again at this node, L, V, and R are
    applied. Since its left child is `NULL`, the second operation, V, is applied;
    that is, node 50 is displayed or we can say it is traversed. After that, we go
    to its right child. The right child of node 50 is `NULL` and since all three operations
    (L,V, and R) have been applied to this node, it is not pushed to the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7ea51249-d309-46d1-8f81-4847b36790d6.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, node 60 is popped from the stack. Its two operations, V and R, are pending.
    First, it is visited (displayed) and then we go to its right child. So, the visited
    nodes will be 10, 20, 30, 40, 50, and 60.
  prefs: []
  type: TYPE_NORMAL
- en: The right child of node 60 is 80\. Again, at node 80, three operations—L,V,
    and R—are applied. First, L (its left child) is visited. Since it has no left
    child, the second operation, V, is applied; that is, node 80 is visited (displayed),
    and then we go to its right child. It has no right child either and since all
    three operations (L,V, and R) have been applied to this node, 80 is not pushed
    to the stack.
  prefs: []
  type: TYPE_NORMAL
- en: So, the final inorder traversal of the tree is 10, 20, 30, 40, 50, 60, and 80.
  prefs: []
  type: TYPE_NORMAL
- en: 'The program is compiled using the GCC compiler using the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the following screenshot, no error appears when we compile. This
    means the `binarysearchtree.c` program has successfully compiled into a `.exe`
    file called `binarysearchtree.exe`. Let''s run the executable file and enter some
    elements to create a binary tree and see its inorder traversal. By doing this,
    we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2fac6eb0-302a-4251-8697-856e33eae1c1.png)'
  prefs: []
  type: TYPE_IMG
- en: Performing postorder traversal of a binary tree non-recursively
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will perform postorder traversal of a binary tree without
    recursion. This will be done through non-recursive calls to the function.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create a binary tree, refer to the *Creating a binary search tree and performing
    an inorder traversal on it recursively* recipe. We will be performing postorder
    traversal on the same binary tree we created in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For postorder traversal of a binary tree, we need to apply three tasks—L, R,
    and V—on each of the tree nodes. These tasks are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: L means visit the left link
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: R means visit the right link
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: V means visit the node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To find out which tasks between L, R, and V are pending and which have already
    been performed, we will use two stacks: one for storing the node and another for
    storing an integer value of 0 or 1\. Let''s go over what 0 and 1 indicate:'
  prefs: []
  type: TYPE_NORMAL
- en: The value 0 indicates that the L task is done, while the R and V tasks are pending
    on the node.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value 1 means that the L and R tasks have been performed on the node and
    that only V is pending.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Follow these steps to perform postorder tree traversal:'
  prefs: []
  type: TYPE_NORMAL
- en: A temporary node called `temp` is set to point at the root node of the tree.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Push the node that's being pointed at by `temp` to `nodeArray` and the value
    0 to `valueArray`. The integer 0 in `valueArray` indicates that the R and V tasks
    are pending on the node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the `temp` node point at the node where its `left` pointer is pointing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the `temp` is not pointing at `NULL`, go to *step 2*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `temp` reaches `NULL`, go to *step 6*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pop the node from `nodeArray`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pop the integer from `valueArray`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the popped integer value is 1, visit the node that is displaying the data
    member of the node. Then, go to *step 6*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the popped integer value is 0, go to *step 10*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Push the node to `nodeArray`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Push the integer 1 to `valueArray` to indicate that the L and R operations have
    been performed and that only V is pending.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the `temp` pointer point to where its `right` pointer is pointing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the `temp` pointer does not reach `NULL`, go to *step 2*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the `temp` pointer reaches `NULL`, go to *step 6*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The program for creating a binary search tree and traversing it in postorder
    non-recursively is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes so that we can understand the code.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Postorder traversal requires the L, R, and V tasks to be applied to each node
    of the binary tree. Here, L means visiting the left child, R means visiting the
    right child, and V means visiting the node that is displaying its content.
  prefs: []
  type: TYPE_NORMAL
- en: 'The question is, how will we know which tasks have already been performed on
    a node and which tasks are left to be performed? To do so, we will use two arrays,
    `nodeArray` and `valueArray`. `nodeArray` contains the node that the tasks are
    to be performed one, while `valueArray` is used to indicate what task has been
    left on the corresponding node. `valueArray` can have one of the following two
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Value 0**: This indicates that the left link of the node has been traversed
    and that two tasks are pending: traversing the node being pointed to by its `right`
    pointer and visiting the node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Value 1**: This indicates that the node being pointed to by its `right` pointer
    has been traversed. Only the task of visiting the node is pending.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the binary search tree has been created, the `nontravpost` function is
    invoked for postorder traversal of the binary tree and the root node is passed
    to the function as an argument. The `nontravpost` function is a non-recursive
    function.
  prefs: []
  type: TYPE_NORMAL
- en: A temporary pointer, `temp`, is set to point at the root node. A `while` loop
    is set to execute until `temp` is not `NULL`. Within the `while` loop, the `pushNode`
    function is called and the node being pointed to by `temp` is passed to it, along
    with a value of 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `pushNode` function, the value of top that was initialized to -1 is
    incremented to 0 and the node, 40, and the value 0 are pushed into the `nodeArray`
    and `valueArray` arrays at index location being pointed to by `top` (the index
    location, 0):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a2cae85b-f46b-4551-a21f-aeb46c8eb57a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `pushNode` function ends and control jumps back to the `nontravpost` function,
    where the `temp` pointer is set to point at its left node. The `left` pointer
    of temp is pointing at node 20, so `temp` will now point at node 20\. The `while`
    loop will keep executing until the `temp` pointer reaches the `NULL` pointer.
    Again, within the `while` loop, the `pushNode` function is called and node 20
    and value 0 are passed to it. In the `pushNode` function, the value of the `top`
    pointer is incremented to 1 and node 20 and the value 0 are pushed to the `nodeArray[1]`
    and `valueArray[1]` array index locations, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a60b6d60-79e2-49ba-8277-250bc30a0843.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This process is repeated for the next node that''s on the left of the `temp`
    node. On the left of node 20 is node 10\. Upon pushing node 10, the `nodeArray`
    and `valueArray` arrays will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5067f030-aaf3-48d4-bcf4-5502af649446.png)'
  prefs: []
  type: TYPE_IMG
- en: Because temp has reached the `NULL` pointer, the first `while` loop will terminate
    and the next `while` loop will execute while the value of `top` is greater than
    or equal to 0\. The `popNode` function is invoked, which returns the node in the
    `nodeArray` array that's being pointed at by the `top` index. The value of the
    `top` index is currently 2, so the node at the index location of `nodeArray[2]`,
    that is, 10, is accessed and returned to the `nontravpost` function. In the `nontravpost`
    function, node 10 will be assigned to the `temp` pointer. Next, the `popVal` function
    is invoked, which returns the value in the `valueArray` array that's being pointed
    to by the `top` index. This happens at the `valueArray[2]` index location. That
    is, the value 0 at the `valueArray[2]` index location is returned by the `popVal`
    function and is assigned to the `val` variable. The value of `top` is now decremented
    to 1\. Because the value in the `val` variable is 0, an `if` block is executed
    in the `nontravpost` function. The `if` block checks whether the right child of
    the node being pointed at by the `temp` pointer isn't `NULL`; if so, the `pushNode`
    function is called and the node being pointed to by `temp`, that is, 10 and integer
    value 1, is passed to it as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `pushNode` function, the value of `top` is incremented to 2 and node
    10 and the value 1 are pushed to the `nodeArray[2]` and `valueArray[2]` index
    locations, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/165fead0-b3a1-4ab1-a88b-e5dd8fc18503.png)'
  prefs: []
  type: TYPE_IMG
- en: After executing the `pushNode` function, control jumps back to the `nontravpost`
    function, where the `temp` pointer is set to point to where its `right` pointer
    is pointing. But because the `right` pointer of `temp` is `NULL`, the `while`
    loop will break and the data member of the node being pointed to by `temp` (that
    is, 10) is displayed on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, the `while` loop will execute and the `popNode` and `popVal` functions
    will execute to pop node 20 and value 0, respectively. Node 20 will be pointed
    to by the `temp` pointer. Because the value that''s being popped is 0, the right
    pointer of the node being pointed to by `temp` is searched. If the `right` pointer
    of node 20 is pointing at node 30, the `pushNode` function is invoked and node
    20 is pushed, along with the value 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/56ae7b01-996a-44a8-83b4-8b051cf325f0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, the `temp` pointer is set to point to where its `right` pointer is pointing,
    that is, node 30\. The `pushNode` function is invoked and node 30 and an integer
    value of 0 are pushed to the `nodeArray` and `valueArray` arrays, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/83d145b5-6a46-444e-ac61-987a88be7791.png)'
  prefs: []
  type: TYPE_IMG
- en: This procedure is repeated until the stacks are empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'The program is compiled with GCC using the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If no error appears upon compilation, then the `postordernonrec.c` program
    has successfully compiled into the `postordernonrec.exe` file. Let''s run this
    file and enter some new elements that will build a binary tree and get its postorder
    traversal using a non-recursive approach. By doing this, we will get the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b53423cb-9e80-40ed-a30b-a155df9939bf.png)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn how to implement queues and circular queues using arrays and dequeues
    using circular queues, visit *Appendix B* found on this link: [https://github.com/PacktPublishing/Practical-C-Programming/blob/master/Appendix%20B.pdf](https://github.com/PacktPublishing/Practical-C-Programming/blob/master/Appendix%20B.pdf).'
  prefs: []
  type: TYPE_NORMAL
