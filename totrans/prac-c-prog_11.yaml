- en: Advanced Data Structures and Algorithms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级数据结构与算法
- en: In this chapter, we will learn about advanced data structures and algorithms.
    We will learn how to use structures such as stacks, circular linked lists, doubly
    linked lists, and binary trees and their traversal.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习高级数据结构和算法。我们将学习如何使用栈、循环链表、双向链表和二叉树等结构及其遍历。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Implementing a stack using a singly linked list
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用单链表实现栈
- en: Implementing a doubly or two-way linked list
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现双向或双向链表
- en: Implementing a circular linked list
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现循环链表
- en: Making a binary search tree and doing inorder traversal recursively
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归地实现二叉搜索树并进行中序遍历
- en: Performing postorder traversal of a binary tree non-recursively
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非递归地遍历二叉树的后序
- en: Before we get into the recipes, it will be helpful for us to understand some
    of the structures and related terminologies we will be using in this chapter as
    well as in the other recipes in this book.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究食谱之前，了解我们将在本章以及本书其他食谱中使用的一些结构和相关术语对我们来说将是有帮助的。
- en: Stack
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 栈
- en: A stack is a data structure where all insertions and deletions are performed
    at one end. The end at which insertions and deletions are performed is called
    the **top of the stack** (**tos**). The stack is also known as a **pushdown list**
    or **Last In First Out** (**LIFO**); that is, the last item that is added to the
    stack is added at the top of all earlier items and will be the first item to be
    taken out of the stack.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 栈是一种数据结构，其中所有插入和删除操作都在一端进行。进行插入和删除操作的一端称为**栈顶**（**tos**）。栈也称为**下推列表**或**后进先出**（**LIFO**）；也就是说，最后添加到栈中的项目将添加到所有较早项目的顶部，并将是第一个被取出的项目。
- en: 'The operations that can be performed on the stack are as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在栈上执行的操作如下：
- en: '**Push**: This pushes the value onto the stack. Before pushing the value onto
    the stack, the value at the top is incremented to point at the new position where
    the new value can be pushed.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Push**：这是将值推入栈中。在将值推入栈之前，栈顶的值会增加以指向新位置，新值可以推入该位置。'
- en: '**Pop**: This pops or fetches the value from the stack. The value at the top
    or the value pointed at by the top is taken out of the stack.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pop**：这是弹出或获取栈中的值。栈顶的值或被顶指针指向的值从栈中取出。'
- en: '**Peep**: This shows the value that is at the top of the stack, that is, the
    value that is pointed at by the stack, without taking that value out of the stack.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Peep**：这显示了栈顶的值，即栈所指向的值，而不从栈中取出该值。'
- en: Doubly linked lists (two-way linked lists)
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 双向链表（双向链表）
- en: 'In doubly or two-way linked lists, two pointers are used in the structure,
    where one pointer points in the forward direction and the other points in the
    backward direction. These two pointers allow us to traverse a linked list in both
    ways, that is, in **First in First Out** (**FIFO**) order as well as LIFO order.
    In a singly linked list, traversal is only possible in one direction. The node
    of a doubly linked list looks like this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在双向或双向链表中，结构中使用两个指针，其中一个指针指向正向，另一个指针指向反向。这两个指针使我们能够以两种方式遍历链表，即以**先进先出**（**FIFO**）顺序以及后进先出（**LIFO**）顺序。在单链表中，遍历只能在一个方向上进行。双向链表的节点看起来如下：
- en: '![](img/1c8fbda8-34ef-4484-9747-6dac9b13303c.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1c8fbda8-34ef-4484-9747-6dac9b13303c.png)'
- en: As we can see in the preceding diagram, there are two pointers, `next` and `prev`
    (you can give any name you like to these pointers). The `next` pointer is pointing
    at the next node, while the `prev` pointer is pointing at its previous node. To
    traverse the doubly linked list in both directions, we will make use of two other
    pointers called `startList` and `endList`. The `startList` pointer is set to point
    at the first node, while the `endList` pointer is set to point at the last node
    to allow for the traversal of the doubly linked list in both directions.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，有两个指针，`next`和`prev`（你可以给这些指针起任何你喜欢的名字）。`next`指针指向下一个节点，而`prev`指针指向其前一个节点。为了在两个方向上遍历双向链表，我们将使用另外两个称为`startList`和`endList`的指针。`startList`指针被设置为指向第一个节点，而`endList`指针被设置为指向最后一个节点，以便在两个方向上遍历双向链表。
- en: To traverse in FIFO order, we begin traversing from the node being pointed at
    by `startList`, moving further with the help of the `next` pointer. To traverse
    in LIFO order, we begin traversing the linked list from the node that's being
    pointed at by the `endList` pointer, then move backward with help of the `prev`
    pointer.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要按 FIFO 顺序遍历，我们从 `startList` 指针指向的节点开始遍历，借助 `next` 指针进一步移动。要按 LIFO 顺序遍历链表，我们从
    `endList` 指针指向的节点开始遍历链表，然后借助 `prev` 指针向后移动。
- en: 'A doubly linked list that consists of certain nodes may look as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由某些节点组成的双向链表可能看起来如下：
- en: '![](img/30635fc0-c588-4f92-9e20-49a4f63fa3ae.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/30635fc0-c588-4f92-9e20-49a4f63fa3ae.png)'
- en: Note that the `prev` pointer of the first node and the `next` pointer of the
    last node is set to `NULL`. These `NULL` values help to terminate the traversing
    procedure.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，第一个节点的 `prev` 指针和最后一个节点的 `next` 指针被设置为 `NULL`。这些 `NULL` 值有助于终止遍历过程。
- en: Circular linked lists
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环链表
- en: 'In a linear linked list, the nodes are connected one after the other, and each
    node except the first has a unique predecessor and successor. The last node is
    set to point at `NULL` to indicate the termination of the linked list. But in
    the case of a circular linked list, the next pointer of the last node points back
    to the first node instead of pointing at `NULL`. In other words, a circular linked
    list has no `NULL` pointer, as can be seen in the following diagram:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在线性链表中，节点一个接一个地连接，除了第一个节点外，每个节点都有一个唯一的 predecessor 和 successor。最后一个节点被设置为指向
    `NULL` 以指示链表的结束。但在循环链表的情况下，最后一个节点的下一个指针指向第一个节点，而不是指向 `NULL`。换句话说，循环链表没有 `NULL`
    指针，如下面的图所示：
- en: '![](img/4658723f-6b9c-44b0-973c-f6c8a8e82480.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/4658723f-6b9c-44b0-973c-f6c8a8e82480.png)'
- en: The advantage of a circular linked list over a linear linked list is that a
    circular linked list allows the pointer to move in reverse direction too. In real-world
    applications, the circular linked list is used in several places. For example,
    it can be used in an operating system while scheduling a CPU in a round-robin
    fashion, it can be used in a playlist of songs, and it can be used to track users
    in games.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 循环链表相对于线性链表的优势在于，循环链表允许指针向反方向移动。在现实世界的应用中，循环链表被用于多个地方。例如，它可以在操作系统调度 CPU 时以轮询方式使用，它可以在歌曲播放列表中使用，也可以用于跟踪游戏中的用户。
- en: Binary tree
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二叉树
- en: 'A tree in which all of the nodes can have two children or siblings (at most)
    is called a binary tree. A binary tree has the following characteristics:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一棵树中所有节点都可以有两个孩子或兄弟（最多）的树称为二叉树。二叉树有以下特点：
- en: A tree contains, at most, 2^l nodes at level *l*.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一棵树在级别 *l* 上最多有 2^l 个节点。
- en: If a binary tree contains *m* nodes at level *l*, it contains at most *2m* nodes
    at level *l+1*.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个二叉树在级别 *l* 上有 *m* 个节点，它在级别 *l+1* 上最多有 *2m* 个节点。
- en: A tree contains *2d* leaves and therefore *2d-1* non-leaf nodes, where *d* is
    its depth.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一棵树包含 *2d* 个叶子节点，因此有 *2d-1* 个非叶子节点，其中 *d* 是它的深度。
- en: A binary tree with *n* internal nodes has (*n+1*) external nodes.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含 *n* 个内部节点的二叉树有 (*n+1*) 个外部节点。
- en: 'A binary tree with *n* nodes has exactly *n+1* `NULL` links (see the following
    screenshot):'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含 *n* 个节点的二叉树恰好有 *n+1* 个 `NULL` 链接（见下面的截图）：
- en: '![](img/04bee979-2cad-4fd6-b42c-7fa8c26840de.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/04bee979-2cad-4fd6-b42c-7fa8c26840de.png)'
- en: Binary search trees
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二叉搜索树
- en: 'A binary search tree is a tree in which the time to search an element is `O(log2n)`
    (which is faster than searching an element in a binary tree, where `O(n)`). But
    to support `O(log2n)` searching, we need to add a special property to the binary
    tree: we put all the nodes with values smaller than the value in the root into
    its left subtree and all of the nodes with values larger than the value in the
    root into its right subtree.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉搜索树是一种树，其中搜索一个元素的搜索时间是 `O(log2n)`（这比在二叉树中搜索一个元素的 `O(n)` 快）。但为了支持 `O(log2n)`
    的搜索，我们需要向二叉树添加一个特殊属性：我们将所有值小于根节点值的节点放入其左子树，所有值大于根节点值的节点放入其右子树。
- en: Traversing trees
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遍历树
- en: 'Traversing means visiting the nodes of a tree. There are three ways of traversing
    a binary tree: preorder, inorder, and postorder. Since traversing a binary tree
    requires visiting the root and then its left and right child, these three ways
    of traversal only differ in the order in which visiting is performed. The tree
    traversal methods that are defined with the recursion method are as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历意味着访问树中的节点。遍历二叉树有三种方式：前序、中序和后序。由于遍历二叉树需要访问根节点及其左右子节点，这三种遍历方式仅在访问顺序上有所不同。使用递归方法定义的树遍历方法如下：
- en: 'For preorder traversal, these are the steps:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前序遍历，这些是步骤：
- en: Visit the root
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问根节点
- en: Traverse the left subtree in preorder
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以前序遍历遍历左子树
- en: Traverse the right subtree in preorder
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以前序遍历遍历右子树
- en: In preorder traversal, the root node of the binary tree is visited first.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在前序遍历中，首先访问二叉树的根节点。
- en: 'For inorder traversal, these are the steps:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于中序遍历，这些是步骤：
- en: Traverse the left subtree in inorder
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以中序遍历遍历左子树
- en: Visit the root
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问根节点
- en: Traverse the right subtree in inorder
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以中序遍历遍历右子树
- en: 'For postorder traversal, these are the steps:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于后序遍历，这些是步骤：
- en: Traverse the left subtree in postorder
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以后序遍历遍历左子树
- en: Traverse the right subtree in postorder
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以后序遍历遍历右子树
- en: Now that we've had a thorough introduction to the structures we will be looking
    at in this chapter, we can begin our journey.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对这个章节中将要讨论的结构有了全面的介绍，我们可以开始我们的旅程。
- en: Implementing a stack using a singly linked list
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用单链表实现栈
- en: In this recipe, we will learn how to implement a stack that has a LIFO structure.
    LIFO means that whatever element was added to the stack last will be the first
    to be removed. The stack is a very important component of any compiler and operating
    system. The stack is used in branching operations, recursion, and many other system-level
    tasks. The stack can be implemented using arrays as well as through linked lists.
    In this recipe, we will learn how to implement a stack using a single linked list.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何实现一个具有LIFO结构的栈。LIFO意味着最后添加到栈中的元素将是第一个被移除的。栈是任何编译器和操作系统中非常重要的组件。栈用于分支操作、递归以及许多其他系统级任务。栈可以使用数组以及通过链表实现。在这个菜谱中，我们将学习如何使用单链表实现栈。
- en: How to do it...
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to implement a stack using a linked list:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤使用链表实现栈：
- en: A structure is defined called `node`. In this structure, besides a data member
    for storing content for the stack, a pointer is also defined that points to the
    next node.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为`node`的结构。在这个结构中，除了用于存储栈内容的成员变量外，还定义了一个指针，该指针指向下一个节点。
- en: The `top` pointer is initialized to `NULL` to indicate that the stack is currently
    empty.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`top`指针初始化为`NULL`以指示栈当前为空。
- en: A menu is displayed and the user is asked whether they want to push or pop from
    the stack. The user can enter 1 to indicate that they want to push a value to
    the stack or enter 2 to indicate that they want to pop a value from the stack.
    If the user enters `1`, go to *step 4*. If they enter `2`, go to *step 9*. If
    they enter `3`, it means they want to quit the program, so go to *step 13*.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示菜单并询问用户是否要从栈中压入或弹出值。用户可以输入1表示他们想要将值压入栈中，或输入2表示他们想要从栈中弹出值。如果用户输入`1`，转到*步骤4*。如果他们输入`2`，转到*步骤9*。如果他们输入`3`，则表示他们想要退出程序，因此转到*步骤13*。
- en: Allocate memory for the new node.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为新节点分配内存。
- en: Ask the user for the value to be pushed and assign that value to the data member
    of the node.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 询问用户要压入的值并将该值分配给节点的数据成员。
- en: Invoke the push function where the next pointer of the new node is set to point
    at `top`.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`push`函数，将新节点的下一个指针设置为指向`top`。
- en: The `top` pointer is set to point at the new node.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`top`指针设置为指向其`next`指针指向的位置。
- en: Go to *step 3* to display the menu.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到*步骤3*以显示菜单。
- en: Check whether the `top` pointer is `NULL`. If yes, then display the message
    `Stack is empty` and go to *step 3* to display the menu. If `top` is not `NULL`,
    go to the next step.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`top`指针是否为`NULL`。如果是，则显示消息`栈为空`并转到*步骤3*以显示菜单。如果`top`不是`NULL`，转到下一步。
- en: A temporary pointer, `temp`, is set to point at the node where `top` is pointing.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个临时指针`temp`，使其指向`top`指向的节点。
- en: The `top` pointer is set to point to where its `next` pointer is pointing.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`top`指针设置为指向其`next`指针指向的位置。
- en: Return the node that's being pointed at by `temp` as the popped node and display
    the data member of the popped node.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`temp`所指向的节点作为出栈节点返回，并显示该出栈节点的数据成员。
- en: Exit the program.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出程序。
- en: 'The program for implementing a stack using a linked list is as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用链表实现栈的程序如下：
- en: '[PRE0]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, let's go behind the scenes so that we can understand the code.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解幕后，以便我们可以理解代码。
- en: How it works...
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'First, a structure is defined, called a node, that consists of two members:
    one is the data and the other is a pointer called `next`. Because we want our
    stack to only store integer values, the data member of the structure is defined
    as an integer for storing integers and the next pointer is used to connect other
    nodes. Initially, the `top` pointer is set to `NULL`.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，定义一个结构体，称为节点，它由两个成员组成：一个是数据，另一个是名为`next`的指针。因为我们希望我们的栈只存储整数值，所以结构体的数据成员被定义为整数，用于存储整数，而下一个指针用于连接其他节点。最初，`top`指针被设置为`NULL`。
- en: 'A `while` loop is set to execute, within which a menu is displayed. The menu
    is set to display three options: 1, to push into the stack; 2, to pop from the
    stack; and 3, to quit. Until the user enters 3 in the menu, the `while` loop will
    continue executing and keep displaying the menu, prompting the user to enter the
    desired option. If the user enters 1 to push a value to the stack, a new node
    is created by `newNode`. The user is prompted to enter the value to be pushed
    to the stack. Suppose the data that''s being entered by the user is 10\. Here,
    that value will be assigned to the data member of `newNode`, as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 设置一个`while`循环来执行，循环内显示菜单。菜单设置为显示三个选项：1，将值推入栈中；2，从栈中弹出；3，退出。直到用户在菜单中输入3，`while`循环将继续执行并继续显示菜单，提示用户输入所需的选项。如果用户输入1以将值推入栈中，则通过`newNode`创建一个新的节点。提示用户输入要推入栈中的值。假设用户输入的数据是10。在这里，该值将被分配给`newNode`的数据成员，如下所示：
- en: '![](img/ad051f01-8b3b-437b-9031-ba1b14bcefba.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ad051f01-8b3b-437b-9031-ba1b14bcefba.png)'
- en: 'Thereafter, the `push` function is invoked and `newNode` and the `top` pointer
    are passed to it. In the `push` function, the next pointer of `newNode` is set
    to point at the `top` pointer, which is `NULL`, and then the top pointer is set
    to point at X, as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此后，调用`push`函数，并将`newNode`和`top`指针传递给它。在`push`函数中，将`newNode`的下一个指针设置为指向`top`指针，此时`top`指针为`NULL`，然后设置`top`指针指向X，如下所示：
- en: '![](img/277d1b4c-441a-448f-aef3-5659f893dfd7.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/277d1b4c-441a-448f-aef3-5659f893dfd7.png)'
- en: The `top` pointer must always point to the last inserted node. Due to this,
    it is set to point at `newNode`. After completing the `push` function, control
    goes back to the `main` function, where the menu will be displayed once more.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`top`指针必须始终指向最后一个插入的节点。因此，它被设置为指向`newNode`。完成`push`函数后，控制权返回到`main`函数，此时菜单将再次显示。'
- en: 'Let''s assume that the user enters 1 to push another value to the stack. Again,
    a new node is created by `newNode`. The user is asked to enter the value to push.
    Assuming that the user enters 20, the value 20 will be assigned to the data member
    of `newNode`. The `push` function is invoked and `newNode` and the `top` pointer
    are passed to it. Here, the `top` pointer is pointing at the node that was pushed
    earlier, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 假设用户输入1以将另一个值推入栈中。再次，通过`newNode`创建一个新的节点。要求用户输入要推入的值。假设用户输入20，则值20将被分配给`newNode`的数据成员。调用`push`函数，并将`newNode`和`top`指针传递给它。在这里，`top`指针指向之前推入的节点，如下所示：
- en: '![](img/64e52460-2831-421b-a0da-33b7d732b1b9.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/64e52460-2831-421b-a0da-33b7d732b1b9.png)'
- en: 'In the `push` function, the next pointer of `newNode` is set to point at the
    node where the `top` pointer is pointing to, as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在`push`函数中，将`newNode`的下一个指针设置为指向`top`指针所指向的节点，如下所示：
- en: '![](img/bbcdabfb-5091-4fec-9d07-63c99c6289aa.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bbcdabfb-5091-4fec-9d07-63c99c6289aa.png)'
- en: 'Then, the `top` pointer is set to point at `newNode`, as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将`top`指针设置为指向`newNode`，如下所示：
- en: '![](img/178f2a74-ced5-4ebf-86e6-363a748dc792.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/178f2a74-ced5-4ebf-86e6-363a748dc792.png)'
- en: 'After executing the `push` function, the menu will be displayed again. Let''s
    assume that the user wants to *pop* a value from the stack. To do this, they will
    enter 2 in the menu. The `pop` function will be invoked and the top pointer will
    be passed to it. In the `pop` function, it''s ensured that the `top` pointer is
    not `NULL` because if it is, this means the stack is already empty; a value can''t
    be popped out from an empty stack. To get the value from the stack, we will use
    a temporary pointer called `temp`. The `temp` pointer is set to point at the node
    that''s being pointed to by the `top` pointer:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`push`函数后，菜单将再次显示。假设用户想要从栈中*pop*出一个值。为此，他们将在菜单中输入2。将调用`pop`函数，并将栈顶指针传递给它。在`pop`函数中，确保`top`指针不是`NULL`，因为如果是，这意味着栈已经为空；无法从空栈中弹出值。要从栈中获取值，我们将使用一个名为`temp`的临时指针。`temp`指针被设置为指向由`top`指针指向的节点：
- en: '![](img/eb78cf8e-23a8-4f5a-b201-f19fe992329b.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/eb78cf8e-23a8-4f5a-b201-f19fe992329b.png)'
- en: 'Thereafter, the `top` pointer is set to move to the next node, that is, the
    node where its next pointer is pointing to. The node that''s being pointed at
    by the `temp` pointer is returned to the `main` function:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 此后，`top`指针将移动到下一个节点，即其`next`指针所指向的节点。由`temp`指针指向的节点将被返回到`main`函数：
- en: '![](img/79728034-2bf2-47f8-ac1b-146e0f874ff2.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/79728034-2bf2-47f8-ac1b-146e0f874ff2.png)'
- en: In the `main` function, the node that's returned by the `pop` function is assigned
    to `recNode`. First, it's confirmed that `recNode` is not `NULL`. Then, the value
    in its data member is displayed on the screen. So, 20 will be displayed on the
    screen.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，`pop`函数返回的节点被分配给`recNode`。首先，确认`recNode`不是`NULL`。然后，在屏幕上显示其数据成员的值。因此，20将在屏幕上显示。
- en: 'After executing the `pop` function, the menu will be displayed once more, asking
    the user to enter the desired option. Let''s assume that the user presses 2 to
    pop another value from the stack. Again, the `pop` function will be invoked. In
    the `pop` function, we check that the `top` pointer is not `NULL` and that it''s
    pointing to a node. Because the `top` pointer is pointing at a node and is not
    `NULL`, a temporary pointer, `temp`, is set to point at the node that''s being
    pointed to by the `top` pointer:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`pop`函数后，菜单将再次显示，询问用户输入所需的选项。假设用户按下2以从栈中弹出另一个值。再次调用`pop`函数。在`pop`函数中，我们检查`top`指针是否不是`NULL`并且它指向一个节点。因为`top`指针指向一个节点并且不是`NULL`，所以设置一个临时指针`temp`指向由`top`指针指向的节点：
- en: '![](img/1f27a42c-d088-43d1-badc-3b5b10b39470.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1f27a42c-d088-43d1-badc-3b5b10b39470.png)'
- en: Thereafter, the `top` pointer is set to point to where its next pointer is pointing.
    The next pointer of `top` is pointing at `NULL`, so the `top` pointer will be
    set to `NULL` and the node that is being pointed to by the `temp` pointer is returned
    to the `main` function.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此后，将`top`指针设置为指向其`next`指针所指向的位置。`top`的`next`指针指向`NULL`，因此`top`指针将被设置为`NULL`，而由`temp`指针指向的节点将被返回到`main`函数。
- en: In the `main` function, the returned node from the `pop` function is assigned
    to the `recNode` pointer. After confirming that `recNode` is not pointing at `NULL`,
    the value in the data member of `recNode` is displayed on the screen. So, the
    value 10 will appear on the screen. After executing the `pop` function, the menu
    will be displayed again on the screen.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，从`pop`函数返回的节点被分配给`recNode`指针。确认`recNode`不是指向`NULL`后，在屏幕上显示`recNode`的数据成员的值。因此，值10将出现在屏幕上。执行`pop`函数后，屏幕上再次显示菜单。
- en: Let's assume that the user wants to pop the stack once more. But at this point,
    we know that the stack is empty. When the user presses `2` on the menu, the `pop`
    function will be invoked. However, since the value of the `top` pointer is `NULL`,
    the pop function will return a `NULL` value to the `main` function. In the `main`
    function, the `NULL` value that was returned by the `pop` function is assigned
    to the `recNode` pointer. Because the `recNode` pointer is assigned `NULL`, a
    message stating `stack is empty` will be displayed on the screen. Again, the menu
    will be displayed, prompting the user to enter a choice. Upon entering 3, the
    program will terminate.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 假设用户想要再次弹出栈。但在这个时候，我们知道栈是空的。当用户在菜单上按下 `2` 时，将调用 `pop` 函数。然而，由于 `top` 指针的值为 `NULL`，`pop`
    函数将返回一个 `NULL` 值给 `main` 函数。在 `main` 函数中，`pop` 函数返回的 `NULL` 值被分配给 `recNode` 指针。由于
    `recNode` 指针被分配 `NULL`，屏幕上会显示一条消息“栈为空”。再次，菜单将显示，提示用户输入选择。输入 `3` 后，程序将终止。
- en: 'The program is compiled using GCC. Because no error appears on compilation,
    this means the `stacklinkedlist.c` program has successfully compiled into the
    `stacklinkedlist.exe` file. On executing the file, we get a menu, prompting us
    to push or pop from the stack, as shown in the following screenshot:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 程序使用 GCC 编译。因为没有错误出现在编译过程中，这意味着 `stacklinkedlist.c` 程序已成功编译成 `stacklinkedlist.exe`
    文件。执行该文件后，我们得到一个菜单，提示我们从栈中压入或弹出，如下面的截图所示：
- en: '![](img/11df2b8a-038e-4966-8c43-8642b2ff7ce8.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/11df2b8a-038e-4966-8c43-8642b2ff7ce8.png)'
- en: While popping from the stack, you must have noticed that the stack is a LIFO
    structure where the value that was pushed last was the first to be popped out.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当从栈中弹出时，你必须已经注意到栈是一个后进先出（LIFO）结构，最后压入的值是第一个被弹出的。
- en: Now, let's move on to the next recipe!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续下一个菜谱！
- en: Implementing a doubly or two-way linked list
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现双向或双向链表
- en: 'In this recipe, we will learn how to create a doubly linked list and how to
    traverse its elements in FIFO and LIFO order. As we explained in the introduction
    to this chapter, the node of a doubly linked list consists of two pointers: one
    points forward, while the other points backward. The pointer pointing forward
    is usually called `next` and is used to point at the next node. The other, which
    is pointing backward, is usually called `prev` and is used to point at the previous
    node.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何创建双向链表以及如何以先进先出（FIFO）和后进先出（LIFO）的顺序遍历其元素。正如我们在本章引言中解释的那样，双向链表的节点由两个指针组成：一个指向前方，而另一个指向后方。指向前方的指针通常称为
    `next`，用于指向下一个节点。另一个指向后方的指针通常称为 `prev`，用于指向前一个节点。
- en: Traversal in FIFO order means the elements of the doubly linked list are displayed
    in the order in which they were added to the list. Traversal is done by making
    use of the `next` pointer of the node.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 先进先出（FIFO）顺序的遍历意味着双向链表的元素以它们被添加到列表中的顺序显示。遍历是通过使用节点的 `next` 指针完成的。
- en: Traversal in LIFO order means the elements are displayed in reverse or backward
    direction, and this traversal is done with the help of the `prev` pointer.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 后进先出（LIFO）顺序的遍历意味着元素以反向或倒序显示，并且这种遍历是通过 `prev` 指针完成的。
- en: How to do it...
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做这件事...
- en: 'In this doubly linked list, I will be making use of two pointers, `startList`
    and `endList`, where `startList` will point at the first node and `endList` will
    point at the last node. The `startList` pointer will help to traverse the list
    in FIFO order, while the `endList` pointer will help to traverse it in LIFO order.
    Follow these steps to create a doubly linked list and traverse it in either direction:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个双向链表中，我将使用两个指针，`startList` 和 `endList`，其中 `startList` 将指向第一个节点，而 `endList`
    将指向最后一个节点。`startList` 指针将帮助以先进先出（FIFO）的顺序遍历列表，而 `endList` 指针将帮助以后进先出（LIFO）的顺序遍历它。按照以下步骤创建双向链表并双向遍历：
- en: Define a structure called `node`. To store content for the doubly linked list,
    define a data member in the node structure. Define two pointers called `next`
    and `prev`.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为 `node` 的结构体。为了存储双向链表的内容，在节点结构体中定义一个数据成员。定义两个指针，分别称为 `next` 和 `prev`。
- en: 'A menu is displayed that shows four options: `1`, to create a doubly linked
    list; `2`, to display the elements of the list in LIFO order; `3`, for displaying
    the elements in FIFO order; and `4`, to quit. If the user enters 1, go to *step
    3*. If the user enters 2, go to *step 10*. If the user enters 3, go to *step 15*.
    Finally, if the user enters 4, then it means they want to quit the program, so
    go to *step 19*.'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示一个菜单，显示四个选项：`1`，创建双向链表；`2`，以LIFO顺序显示列表元素；`3`，以FIFO顺序显示元素；以及`4`，退出。如果用户输入1，转到*步骤3*。如果用户输入2，转到*步骤10*。如果用户输入3，转到*步骤15*。最后，如果用户输入4，则意味着他们想要退出程序，因此转到*步骤19*。
- en: Initialize the `startList` pointer to `NULL`.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`startList`指针初始化为`NULL`。
- en: Allocate memory for the new node.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为新节点分配内存。
- en: Ask the user for the value to be added to the doubly linked list. The value
    that's entered by the user is assigned to the data member of the node.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 询问用户要添加到双向链表中的值。用户输入的值分配给节点的数据成员。
- en: Set the `next` and `prev` pointers of the node to `NULL`.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将节点的`next`和`prev`指针设置为`NULL`。
- en: If this node is the first node of the doubly linked list, set the `startList`
    pointer to point at the new node. If this node is not the first node, don't disturb
    the `startList` pointer and let it point at the node that it is currently pointing
    to.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果这个节点是双向链表的第一个节点，将`startList`指针设置为指向新节点。如果这个节点不是第一个节点，不要干扰`startList`指针，让它指向它当前指向的节点。
- en: 'If this is the first node of the doubly linked list, set the `endList` pointer
    to at new node. If this is not the first node, perform the following steps:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果这是双向链表的第一个节点，将`endList`指针设置为指向新节点。如果不是第一个节点，执行以下步骤：
- en: Set the `next` pointer of the new node to `NULL`.
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新节点的`next`指针设置为`NULL`。
- en: Set the `prev` pointer of the new node so that it points at the node pointed
    at by `endList`.
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新节点的`prev`指针设置为指向`endList`指向的节点。
- en: Set the `next` pointer of `endList` so that it points at the new node.
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`endList`的`next`指针设置为指向新节点。
- en: Set `endList` so that it points at the new node.
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`endList`设置为指向新节点。
- en: Ask the user whether more elements have to be added to the doubly linked list.
    If the user wants to enter more, go to *step 4*; otherwise, display the menu by
    going to *step 2*.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 询问用户是否需要向双向链表添加更多元素。如果用户想要添加更多，转到*步骤4*；否则，通过转到*步骤2*来显示菜单。
- en: To display the linked list in LIFO order, let the `temp` pointer point at the
    node being pointed at by `endList`.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要以LIFO顺序显示链表，让`temp`指针指向`endList`指向的节点。
- en: Let *step 12* and *step 13* run until the `temp` pointer reaches `NULL`.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让*步骤12*和*步骤13*运行，直到`temp`指针达到`NULL`。
- en: Display the data member of the node being pointed at by `temp`.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示`temp`指针指向的节点的数据成员。
- en: Set the `temp` pointer so that it points to where its `prev` pointer is pointing.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`temp`指针设置为指向其`prev`指针指向的位置。
- en: The doubly linked list's content is displayed in LIFO order. Now, go to *step
    2* to display the menu again.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双向链表的内容以LIFO顺序显示。现在，转到*步骤2*以再次显示菜单。
- en: Make the `temp` pointer point at the node being pointed at by the `startList`
    pointer.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让`temp`指针指向`startList`指针指向的节点。
- en: If the `temp` pointer is not `NULL`, display the data member of the node being
    pointed at by `temp`.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`temp`指针不是`NULL`，显示`temp`指针指向的节点的数据成员。
- en: Let the `temp` point at the node that its next pointer is pointing to.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让`temp`指向其`next`指针指向的节点。
- en: If `temp` has reached `NULL`, this means all of the nodes of the doubly linked
    list have been traversed. Now, you can display the menu by jumping to *step 2*.
    If `temp` has not reached `NULL`, then go to *step 16* to display the rest of
    the elements of the doubly linked list.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`temp`已达到`NULL`，这意味着双向链表的所有节点都已遍历。现在，可以通过跳转到*步骤2*来显示菜单。如果`temp`未达到`NULL`，则转到*步骤16*以显示双向链表的其余元素。
- en: Exit the program.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出程序。
- en: 'The program for implementing a doubly or two-way linked list is as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 实现双向或双向链表的程序如下：
- en: '[PRE1]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, let's go behind the scenes so that we can understand the code.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们幕后看看，以便我们可以理解代码。
- en: How it works...
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何工作...
- en: When implementing a doubly linked list, a structure is defined, called a node,
    that consists of an integer called `data` and two pointers, `next` and `prev`.
    Because a doubly linked list can be traversed from either end—that is, forward
    or backward—the two pointers are required. The `next` pointer will point at the
    node after it, whereas the `prev` pointer will point at the node just before it.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现双链表时，定义了一个结构体，称为节点，它由一个名为 `data` 的整数和两个指针 `next` 和 `prev` 组成。因为双链表可以从两端遍历——即正向或反向——所以需要两个指针。`next`
    指针将指向它后面的节点，而 `prev` 指针将指向它前面的节点。
- en: 'A menu is displayed on the screen showing four options: `1`, for creating the
    doubly linked list; `2`, for displaying the elements of the doubly linked list
    in LIFO order; `3`, for displaying elements in FIFO order; and `4`, to quit the
    program.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕上显示了一个菜单，显示四个选项：`1`，用于创建双链表；`2`，用于以 LIFO 顺序显示双链表中的元素；`3`，用于以 FIFO 顺序显示元素；以及
    `4`，用于退出程序。
- en: Let's assume that the user enters 1\. The `createdoubly` function will be invoked.
    In this function, the `startList` pointer is set to `NULL` and a string variable,
    `k`, is assigned the `yes` string. A `while` loop is set to execute while `k`
    has `yes` assigned to it. Here, the user can keep adding more elements to the
    doubly linked list by entering `yes` whenever they are prompted to continue. The
    `startList` pointer will be set to point at the first node of the doubly linked
    list, while the `endList` pointer will be set to point at the last node.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 假设用户输入了 1。`createdoubly` 函数将被调用。在这个函数中，`startList` 指针被设置为 `NULL`，一个字符串变量 `k`
    被分配了 `yes` 字符串。设置了一个 `while` 循环，在 `k` 被分配了 `yes` 时执行。在这里，用户可以在被提示继续时输入 `yes`，以继续向双链表添加更多元素。`startList`
    指针将被设置为指向双链表的第一个节点，而 `endList` 指针将被设置为指向最后一个节点。
- en: 'The procedure for adding the first node is different from adding the rest of
    the nodes. Due to this, `if else` blocks are made in the code. When `startList`
    is `NULL` while creating the first node, an `if` block will be executed; otherwise,
    an `else` block will be executed. In the `if` block, a new node is created called
    `newNode`. The user is asked to enter a value for the doubly linked list. Suppose
    the user enters the value 10; this will be assigned to the data member of `newNode`,
    and the `next` and `prev` pointers of `newNode` will be set to `NULL`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 添加第一个节点的过程与添加其余节点的过程不同。因此，在代码中创建了 `if else` 块。当创建第一个节点时 `startList` 是 `NULL`，将执行
    `if` 块；否则，将执行 `else` 块。在 `if` 块中，创建了一个名为 `newNode` 的新节点。用户被要求输入双链表的值。假设用户输入了值
    10；这将分配给 `newNode` 的数据成员，并且 `newNode` 的 `next` 和 `prev` 指针将被设置为 `NULL`：
- en: '![](img/08445db2-9147-4fce-83e4-0841e2e820c6.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/08445db2-9147-4fce-83e4-0841e2e820c6.png)'
- en: 'The `startList` pointer is set to point at `newNode`, and the `endList` pointer
    is also set to point at `newNode`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`startList` 指针被设置为指向 `newNode`，而 `endList` 指针也被设置为指向 `newNode`：'
- en: '![](img/39d11d91-2d0b-4f2b-a76d-b1f28b66996d.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/39d11d91-2d0b-4f2b-a76d-b1f28b66996d.png)'
- en: '`endList` will not stay on this first node; instead, it will keep moving forward
    and will point at the last node of this doubly linked list. After executing the
    `if` block, the user is asked whether more nodes have to be added. If the user
    enters yes, the `while` loop will execute again. Now, `startList` isn''t `NULL`
    and is pointing at `newNode`; so, instead of the `if` block, the `else` block
    will execute. In the `else` block, a new node is created called `newNode`. The
    user is prompted to enter a value to be added to the doubly linked list. Assuming
    the user enters a value of 20, the value will be assigned to the data member of
    `newNode`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`endList` 不会停留在第一个节点上；相反，它将继续前进并指向这个双链表的最后一个节点。在执行 `if` 块之后，用户会被询问是否需要添加更多节点。如果用户输入
    `yes`，`while` 循环将再次执行。现在，`startList` 不是 `NULL`，而是指向 `newNode`；因此，将执行 `else` 块，而不是
    `if` 块。在 `else` 块中，创建了一个名为 `newNode` 的新节点。用户被提示输入要添加到双链表中的值。假设用户输入了值 20，这个值将被分配给
    `newNode` 的数据成员：'
- en: '![](img/abb133f0-d943-4b09-a8d1-6a2213614f7a.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/abb133f0-d943-4b09-a8d1-6a2213614f7a.png)'
- en: 'The `prev` pointer of `newNode` is set to point at `endList`, while the `next`
    pointer of `newNode` is set to `NULL`. The `next` pointer of `endList` is set
    to point at `newNode`, as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`newNode` 的 `prev` 指针被设置为指向 `endList`，而 `newNode` 的 `next` 指针被设置为 `NULL`。`endList`
    的 `next` 指针被设置为指向 `newNode`，如下所示：'
- en: '![](img/5a6c0aae-f263-4212-8702-08f1dba14544.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5a6c0aae-f263-4212-8702-08f1dba14544.png)'
- en: 'Thereafter, the `endList` pointer is set to point at `newNode`, but the `startList`
    pointer will be kept pointing at the first node, as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，`endList`指针被设置为指向`newNode`，但`startList`指针将保持指向第一个节点，如下所示：
- en: '![](img/e5baf9cf-76ab-4f5f-8ae9-691220202160.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e5baf9cf-76ab-4f5f-8ae9-691220202160.png)'
- en: Once again, the user is asked whether they want to add more elements to the
    doubly linked list. Suppose the user doesn't want to add more elements to the
    list, so the text they enter is `no`. The text `no` will be assigned to `k` and,
    consequently, the `while` loop will terminate. The `createdoubly` function ends
    and control will be returned to the `main` function. In the `main` function, the
    menu will be displayed with the aforementioned four options.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 再次询问用户是否想要向双链表添加更多元素。假设用户不想向列表添加更多元素，因此他们输入的文本是`no`。文本`no`将被分配给`k`，因此`while`循环将终止。`createdoubly`函数结束，控制将返回到`main`函数。在`main`函数中，将显示上述四个选项的菜单。
- en: 'Let''s assume that the user enters 2 to display the elements of the doubly
    linked list in LIFO order. Here, the `list_lifo` function will be invoked. In
    the `list_lifo` function, a temporary pointer called `temp` is used and is set
    to point at the last node that was pointed at by the `endList` pointer:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 假设用户输入2以按LIFO顺序显示双链表的元素。在这里，将调用`list_lifo`函数。在`list_lifo`函数中，使用了一个名为`temp`的临时指针，并将其设置为指向由`endList`指针所指向的最后节点：
- en: '![](img/74d46d9f-471f-478a-962f-3be90d46728a.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/74d46d9f-471f-478a-962f-3be90d46728a.png)'
- en: 'A `while` loop is set to execute until the `temp` pointer reaches `NULL`. The
    value in the data member of the node being pointed at by the `temp` pointer is
    displayed on the screen. Here, a value of 20 will appear on the screen. After
    that, the `temp` pointer is set to point to the node being pointed to by its `prev`
    pointer:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`while`循环被设置为执行，直到`temp`指针达到`NULL`。`temp`指针所指向的节点数据成员中的值将在屏幕上显示。在这里，屏幕上将显示一个值为20。之后，`temp`指针被设置为指向其`prev`指针所指向的节点：
- en: '![](img/d8d19e78-3cdc-4377-bc86-c47a9fb324d1.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d8d19e78-3cdc-4377-bc86-c47a9fb324d1.png)'
- en: Again, the value of the `temp` pointer is checked. Because the `temp` pointer
    isn't `NULL`, the `while` loop will execute again. Within the `while` loop, the
    value in the data member of the node being pointed at by the `temp` pointer is
    displayed on the screen. Here, a value of 10 will appear on the screen. Thereafter,
    the `temp` pointer is set to point at the node that its `prev` pointer is pointing
    to. The `prev` pointer of `temp` is pointing at `NULL`, so the `temp` pointer
    is set to point at `NULL`. Now, because `temp` is pointing at `NULL`, the `while`
    loop will terminate, the `list_lifo` function ends, and control goes back to the
    `main` function.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 再次检查`temp`指针的值。因为`temp`指针不是`NULL`，所以`while`循环将再次执行。在`while`循环内，`temp`指针所指向的节点数据成员中的值将在屏幕上显示。在这里，屏幕上将显示一个值为10。之后，`temp`指针被设置为指向其`prev`指针所指向的节点。`temp`的`prev`指针指向`NULL`，因此`temp`指针被设置为指向`NULL`。现在，因为`temp`指向`NULL`，`while`循环将终止，`list_lifo`函数结束，控制返回到`main`函数。
- en: 'In the `main` function, the menu will be displayed again asking the user to
    enter the desired option. Now, let''s assume that the user enters 3 to display
    the elements of the doubly linked list in FIFO order. On entering 3, the `list_fifo`
    function will be invoked. In the `list_fifo` function, the `temp` pointer is set
    to point at the node being pointed at by the `startList` pointer, as shown previously.
    The `while` loop is set to execute until the `temp` pointer points at `NULL`.
    Because `temp` is not `NULL`, the value in the data member of the node being pointed
    at by the `temp` pointer is displayed on the screen. Here, a value of 10 will
    appear on the screen. Thereafter, the `temp` pointer is set to point at the node
    that is being pointed to by its `next` pointer, as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，将再次显示菜单，询问用户输入所需的选项。现在，假设用户输入3以按FIFO顺序显示双链表的元素。输入3后，将调用`list_fifo`函数。在`list_fifo`函数中，`temp`指针被设置为指向由`startList`指针所指向的节点，如前所述。`while`循环被设置为执行，直到`temp`指针指向`NULL`。因为`temp`不是`NULL`，所以`temp`指针所指向的节点数据成员中的值将在屏幕上显示。在这里，屏幕上将显示一个值为10。之后，`temp`指针被设置为指向其`next`指针所指向的节点，如下所示：
- en: '![](img/cae73af2-783d-4354-8e19-1b62499c1a27.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cae73af2-783d-4354-8e19-1b62499c1a27.png)'
- en: Because the `temp` pointer is still not pointing at `NULL`, the `while` loop
    will execute once more. Within the `while` loop, the value in the data member
    of the node being pointed at by the `temp` pointer is displayed on the screen;
    a value of 20 will appear. Again, the `temp` pointer is set to point at the node
    that its next pointer is pointing to. The next pointer of `temp` is pointing at
    the `NULL` pointer, so `temp` will point at `NULL`. Because the `temp` pointer
    is pointing at `NULL`, the `while` loop will terminate; hence, the `list_fifo`
    function ends and control goes back to the `main` function. Here, the menu is
    displayed once more, asking the user to enter the desired option. Let's assume
    the user enters 4 to quit the program. Upon entering 4, the program will terminate.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `temp` 指针仍然没有指向 `NULL`，所以 `while` 循环将再次执行。在 `while` 循环内部，显示由 `temp` 指针指向的节点中的数据成员的值；将显示一个值为
    20 的值。再次，将 `temp` 指针设置为指向其下一个指针指向的节点。`temp` 的下一个指针指向一个 `NULL` 指针，因此 `temp` 将指向
    `NULL`。因为 `temp` 指针指向 `NULL`，所以 `while` 循环将终止；因此，`list_fifo` 函数结束，控制返回到 `main`
    函数。在这里，菜单再次显示，询问用户输入所需的选项。假设用户输入 4 以退出程序。输入 4 后，程序将终止。
- en: 'The program is compiled using GCC. Because no error appears upon compilation,
    this means the `doublylinkedlist.c` program has successfully compiled into the
    `doublylinkedlist.exe` file. On executing the file, we get a menu asking for options
    for creating a doubly linked list and for traversing the doubling linked list
    in LIFO as well as in FIFO order. By doing this, we get the following output:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 GCC 编译程序。因为没有在编译时出现错误，这意味着 `doublylinkedlist.c` 程序已成功编译成 `doublylinkedlist.exe`
    文件。执行该文件时，我们得到一个菜单，要求用户输入创建双链表和遍历双链表（按 LIFO 和 FIFO 顺序）的选项。通过这样做，我们得到以下输出：
- en: '![](img/3bb270ba-890b-467a-8426-c07ad0332809.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3bb270ba-890b-467a-8426-c07ad0332809.png)'
- en: The preceding screenshot shows the benefit of using a doubly linked list that
    is traversing its elements in FIFO, as well as in LIFO, order.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图显示了使用遍历其元素按 FIFO 和 LIFO 顺序的双向链表的好处。
- en: Implementing a circular linked list
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现循环链表
- en: In this recipe, we will learn how to implement a circular linked list. The difference
    between a linear linked list and a circular linked list is that where the last
    node of the linear linked list points at `NULL`, the pointer of the last node
    in a circular linked list points back to the first node, hence allowing the pointer
    to traverse in a backward direction too.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何实现循环链表。线性链表和循环链表之间的区别在于，线性链表的最后一个节点指向 `NULL`，而循环链表的最后一个节点的指针指向第一个节点，因此允许指针以反向方向遍历。
- en: How to do it...
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to implement a circular linked list:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现循环链表：
- en: Define a structure called `node`. To store data in a circular linked list, define
    a data member in the node structure. Besides a data member, define a pointer that
    will point at the next node.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为 `node` 的结构体。为了在循环链表中存储数据，定义节点结构体中的一个数据成员。除了数据成员外，还定义一个指针，该指针将指向下一个节点。
- en: A pointer called `startList` is initialized to `NULL`. The `startList` pointer
    will designate the start of the circular linked list.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个名为 `startList` 的指针被初始化为 `NULL`。`startList` 指针将指定循环链表的起始位置。
- en: A menu is displayed and the user is asked to press `1` to add elements to the
    circular linked list, `2` to display elements of the circular linked list, and
    `3` to quit the program. If the user enters 1, go to *step 4*. If they enter 2,
    go to *step 16*. If they enter 3, it means they want to quit the program, so go
    to *step 23*.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示一个菜单，并要求用户按下 `1` 以向循环链表中添加元素，`2` 以显示循环链表中的元素，以及 `3` 以退出程序。如果用户输入 1，则转到 *步骤
    4*。如果他们输入 2，则转到 *步骤 16*。如果他们输入 3，则意味着他们想要退出程序，因此转到 *步骤 23*。
- en: The user is prompted to specify how many numbers they want to add to the circular
    linked list. A loop is set to execute for the specified number of times; that
    is, *steps 5* to *14* are repeated for the specified number of times.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提示用户指定他们想要添加到循环链表中的数字数量。设置一个循环，执行指定次数；也就是说，*步骤 5* 到 *步骤 14* 将重复指定次数。
- en: Allocate memory for the new node.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为新节点分配内存。
- en: Ask the user for the value to be added to the circular linked list. The value
    that's entered by the user is assigned to the data member of the node.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 询问用户要添加到循环链表中的值。用户输入的值被分配给节点的数据成员。
- en: If `startList` is `NULL`—that is, if it is the first node of the circular linked
    list—then make the `startList` pointer point at a new node.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `startList` 是 `NULL`——也就是说，如果是循环链表的第一个节点——则让 `startList` 指针指向一个新节点。
- en: To make a linked list appear as circular, make the next pointer of `startList`
    point at `startList`.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使链表看起来是循环的，让 `startList` 的下一个指针指向 `startList`。
- en: If `startList` is not `NULL`—that is, if it is not the first node of the circular
    linked list—follow *steps 10* to *14*.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `startList` 不是 `NULL`——也就是说，如果不是循环链表的第一个节点——则遵循 *步骤 10* 到 *步骤 14*。
- en: Make the `temp` pointer point at `startList`.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让 `temp` 指针指向 `startList`。
- en: Until the `next` pointer of `temp` is equal to `startList`, make the `temp`
    pointer point to where its next pointer is pointing; that is, set the `temp` pointer
    so that it points at the last node of the circular linked list.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 直到 `temp` 的 `next` 指针等于 `startList`，让 `temp` 指针指向其下一个指针指向的位置；也就是说，设置 `temp`
    指针，使其指向循环链表的最后一个节点。
- en: Once the `temp` pointer reaches the last node of the circular linked list, the
    next pointer of `temp` is set to point at the new node.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦 `temp` 指针达到循环链表的最后一个节点，将 `temp` 的下一个指针设置为指向新节点。
- en: Then, the `temp` pointer is set to point at the new node.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将 `temp` 指针设置为指向新节点。
- en: The next pointer of `temp` is set to point at `startLIst`.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `temp` 的下一个指针设置为指向 `startLIst`。
- en: Go to *step 3* to display the menu.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跳转到 *步骤 3* 来显示菜单。
- en: The previous step ensures `startList` is not `NULL`. If `startList` is `NULL`,
    it means the circular linked list is empty. In that case, a message is displayed,
    informing the user that the circular linked list is empty. Then, control jumps
    to *step 3* to display the menu.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上一步确保 `startList` 不是 `NULL`。如果 `startList` 是 `NULL`，这意味着循环链表为空。在这种情况下，会显示一条消息，通知用户循环链表为空。然后，控制跳转到
    *步骤 3* 来显示菜单。
- en: If `startList` is not `NULL`, the data member of the node being pointed at by
    the `startList` pointer is displayed on the screen.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `startList` 不是 `NULL`，则在屏幕上显示由 `startList` 指针指向的节点的数据成员。
- en: A temporary pointer, `temp`, is set to point to where the next pointer of `startList`
    is pointing to.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个临时指针 `temp`，使其指向 `startList` 的下一个指针指向的位置。
- en: Repeat *steps 20* and *21* until the `temp` pointer reaches the node being pointed
    at by the `startList` pointer.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复 *步骤 20* 和 *步骤 21*，直到 `temp` 指针达到由 `startList` 指针指向的节点。
- en: Display the contents of the node being pointed at by the data member of `temp`.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示由 `temp` 数据成员指向的节点的内容。
- en: The `temp` pointer is set to point to where its next pointer is pointing.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `temp` 指针设置为指向其下一个指针指向的位置。
- en: Jump to *step 3* to display the menu.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跳转到 *步骤 3* 来显示菜单。
- en: Terminate the program.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 终止程序。
- en: 'The program for implementing a circular linked list is as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 实现循环链表的程序如下：
- en: '[PRE2]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, let's go behind the scenes so that we can understand the code.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们幕后看看，以便我们可以理解代码。
- en: How it works...
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'A structure is defined, called a node, that consists of two members: an integer
    and a pointer called `next`. I am creating a circular linked list comprised of
    integer numbers, which is why I have taken an integer member. However, you can
    use any number of members you want, as well as any data type.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了一个结构，称为节点，它由两个成员组成：一个整数和一个名为 `next` 的指针。我正在创建一个由整数组成的循环链表，这就是为什么我选择了整数成员。然而，你可以使用你想要的任何数量的成员，以及任何数据类型。
- en: We define a pointer called `startList` and initialize it to `NULL`. The `startList`
    pointer will be used to point at the first node of the circular linked list.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个名为 `startList` 的指针，并将其初始化为 `NULL`。`startList` 指针将用于指向循环链表的第一个节点。
- en: 'A menu is displayed on the screen that shows three options: `1`, to add elements
    to the circular linked list; `2`, to display elements of the circular linked list;
    and `3`, to quit. Obviously, the first step is to add elements to the circular
    linked list. Let''s assume that the user enters 1\. On entering 1, the user will
    be asked to specify how many values they want to enter in the list. The limit
    that''s entered by the user will be assigned to a variable called `k`. Assuming
    that the user wants to enter five elements in the list, a `for` loop is set to
    run five times. Within the `for` loop, a new node is created called `newNode`.
    The value that''s entered by the user is assigned to the data member of `newNode`.
    Assuming the value that''s entered by the user is 10, it will be assigned to the
    data member of `newNode`, as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕上显示一个菜单，显示三个选项：`1`，向循环链表中添加元素；`2`，显示循环链表中的元素；`3`，退出。显然，第一步是向循环链表中添加元素。假设用户输入1。输入1后，用户将被要求指定他们想在列表中输入多少个值。用户输入的限制将被分配给一个名为`k`的变量。假设用户想在列表中输入五个元素，将设置一个`for`循环运行五次。在`for`循环中，创建一个名为`newNode`的新节点。用户输入的值被分配给`newNode`的数据成员。假设用户输入的值是10，它将被分配给`newNode`的数据成员，如下所示：
- en: '![](img/bd7d0b89-849c-4743-a722-80cb251ac5db.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd7d0b89-849c-4743-a722-80cb251ac5db.png)'
- en: 'The `addlist` function will be invoked and `newNode` will be passed to it as
    an argument. In the `addlist` function, it is confirmed whether it is the first
    node of the circular linked list or not; that is, if `startList` is `NULL`, it
    is set to point at `newNode`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 将调用`addlist`函数并将`newNode`作为参数传递给它。在`addlist`函数中，确认它是否是循环链表的第一个节点；也就是说，如果`startList`是`NULL`，则将其设置为指向`newNode`：
- en: '![](img/ddbf4966-3251-45db-b97c-bbf95fe499a7.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ddbf4966-3251-45db-b97c-bbf95fe499a7.png)'
- en: 'To make it a circular linked list, the next pointer of `startList` is set to
    point at `startList` itself:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其成为一个循环链表，将`startList`的下一个指针设置为指向`startList`本身：
- en: '![](img/18d831f7-c2ff-49b8-84d6-3695f73c5055.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](img/18d831f7-c2ff-49b8-84d6-3695f73c5055.png)'
- en: 'The `addlist` function ends. Control goes back to the main function and resumes
    the `for` loop''s execution. Within the `for` loop, a `newNode` node is created.
    The value that''s entered by the user is assigned to the data member of `newNode`.
    Assuming that the user has entered a value of 20, it will be assigned to the data
    member of `newNode`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`addlist`函数结束。控制权返回到主函数并继续执行`for`循环。在`for`循环中，创建一个`newNode`节点。用户输入的值被分配给`newNode`的数据成员。假设用户输入的值是20，它将被分配给`newNode`的数据成员：'
- en: '![](img/f76a5552-d4af-462a-a06d-15492e2bfefe.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f76a5552-d4af-462a-a06d-15492e2bfefe.png)'
- en: 'Again, the `addlist` function is invoked and `newNode` is passed to it. In
    the `addlist` function, because the `startList` pointer is no longer `NULL`, the
    `else` block will be executed. In the `else` block, a temporary pointer called
    `temp` is set to point at `startList`. A `while` loop is set to execute until
    the next pointer of `temp` points at `startList`; that is, until the `temp` pointer
    reaches the last node of the circular linked list, the `temp` pointer will keep
    moving further so that it points at its next node. Because there is only a single
    node in the circular linked list, the `temp` pointer is already pointing at the
    last node of the list:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 再次调用`addlist`函数并将`newNode`传递给它。在`addlist`函数中，因为`startList`指针不再是`NULL`，所以将执行`else`块。在`else`块中，设置一个临时指针`temp`指向`startList`。设置一个`while`循环，直到`temp`的下一个指针指向`startList`；也就是说，直到`temp`指针到达循环链表的最后一个节点，`temp`指针将不断移动，以便指向它的下一个节点。因为循环链表中只有一个节点，所以`temp`指针已经指向列表的最后一个节点：
- en: '![](img/6a7ddca6-64af-4ac2-9c1c-8326829b46e4.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6a7ddca6-64af-4ac2-9c1c-8326829b46e4.png)'
- en: 'Once the `temp` pointer reaches the last node of the circular linked list,
    the next pointer of `temp` is set to point at `newNode`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`temp`指针到达循环链表的最后一个节点，将`temp`的下一个指针设置为指向`newNode`：
- en: '![](img/a0dd88ba-a9ba-47ba-82cb-555a0dd9e642.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a0dd88ba-a9ba-47ba-82cb-555a0dd9e642.png)'
- en: 'Thereafter, the `temp` pointer is set to point at `newNode`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 此后，将`temp`指针设置为指向`newNode`：
- en: '![](img/c25e914c-b753-46b5-a583-755ddb88c8dc.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c25e914c-b753-46b5-a583-755ddb88c8dc.png)'
- en: 'Finally, to make the linked list appear circular, the next pointer of `temp`
    is set to point at `startList`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了使链表看起来是循环的，将`temp`的下一个指针设置为指向`startList`：
- en: '![](img/dc084ee7-5ca2-4916-9cf4-4fbe1e804156.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dc084ee7-5ca2-4916-9cf4-4fbe1e804156.png)'
- en: 'This procedure is repeated for the other three elements of the circular linked
    list. Assuming the other the three elements that are entered are 30, 40, and 50,
    the circular linked list will appear as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程将重复应用于环形链表的其余三个元素。假设输入的其他三个元素是30、40和50，环形链表将如下所示：
- en: '![](img/238ecd8f-3881-40b7-9040-d79acdb41f4a.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/238ecd8f-3881-40b7-9040-d79acdb41f4a.png)'
- en: 'After creating the circular linked list, the user will see the display menu
    again. Assuming the user wants to display the elements of the circular linked
    list, they will enter a value as per the menu choices. Upon entering the value,
    the `disp` function will be invoked. In the `disp` function, it''s ensured that
    the `startList` pointer is `NULL`. If the `startList` pointer is `NULL`, it means
    the circular linked list is empty. In that case, the `disp` function will terminate
    after displaying the message that the circular linked list is empty. If the `startList`
    pointer is not empty, the value in the data member of the node being pointed at
    by the `startList` pointer is displayed on the screen; that is, a value of 10
    will appear on the screen. A temporary pointer, `temp`, is set to point at the
    node being pointed at by the next pointer of `startList`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建环形链表后，用户将再次看到显示菜单。假设用户想要显示环形链表的元素，他们将根据菜单选项输入一个值。输入值后，将调用`disp`函数。在`disp`函数中，确保`startList`指针是`NULL`。如果`startList`指针是`NULL`，则表示环形链表为空。在这种情况下，`disp`函数将在显示环形链表为空的消息后终止。如果`startList`指针不为空，则显示由`startList`指针指向的节点数据成员中的值；即屏幕上显示10的值。设置一个临时指针`temp`，使其指向由`startList`的下一个指针指向的节点：
- en: '![](img/c05a6088-bde0-4a6b-b7a3-93c75c315db2.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c05a6088-bde0-4a6b-b7a3-93c75c315db2.png)'
- en: A `while` loop is set to execute until the `temp` pointer reaches the node being
    pointed at by the `startList` pointer. Within the `while` loop, the data member
    of the node being pointed at by the `temp` pointer is displayed on the screen;
    that is, a value of 20 will appear on the screen. Thereafter, the `temp` pointer
    is set to point at the node that its next pointer is pointing to. This way, the
    `while` loop will execute and display all of the elements of the circular linked
    list. When the `while` loop ends, the `disp` function also ends. Control goes
    back to the `main` function, where the menu will be displayed once more. To exit
    the program, the user has to enter 3\. On entering 3, the program will terminate.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 设置一个`while`循环，直到`temp`指针达到由`startList`指针指向的节点。在`while`循环中，显示由`temp`指针指向的节点数据成员；即屏幕上显示20的值。之后，将`temp`指针设置为指向其下一个指针指向的节点。这样，`while`循环将继续执行并显示环形链表的所有元素。当`while`循环结束时，`disp`函数也结束。控制返回到`main`函数，菜单将再次显示。要退出程序，用户必须输入3。输入3后，程序将终止。
- en: 'The program is compiled using GCC. Because no error appears on compilation,
    this means the `circularlinkedlist.c` program has successfully compiled into the
    `circularlinkedlist.exe` file. On executing the file, we get a menu that will
    not only add elements to the circular linked list but will display them too. By
    doing this, we get the output shown in the following screenshot:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GCC编译程序。因为没有错误出现在编译过程中，这意味着`circularlinkedlist.c`程序已成功编译成`circularlinkedlist.exe`文件。执行文件后，我们得到一个菜单，它不仅可以向环形链表添加元素，还可以显示它们。通过这样做，我们得到以下截图所示的输出：
- en: '![](img/d1593da0-7c2b-4c29-80f1-d46b8594694f.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d1593da0-7c2b-4c29-80f1-d46b8594694f.png)'
- en: Voilà! We have successfully implemented a circular linked list. Now, let's move
    on to the next recipe!
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功实现了环形链表。现在，让我们继续下一个菜谱！
- en: Creating a binary search tree and performing an inorder traversal on it recursively
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归地创建二叉搜索树并对其进行中序遍历
- en: 'In this recipe, we will ask the user to enter a few numbers and build a binary
    tree from those numbers. Once the binary tree has been created, its inorder traversal
    is performed. These steps will be divided into two parts: creating the binary
    tree and traversing the binary tree in inorder.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将要求用户输入一些数字，并从这些数字构建一个二叉树。一旦创建了二叉树，就执行其中序遍历。这些步骤将分为两个部分：创建二叉树和中序遍历二叉树。
- en: How to do it... – binary tree
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作... – 二叉树
- en: 'Follow these steps to create the binary tree:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建二叉树：
- en: 'Create a node with the following structure: `data` for storing tree elements,
    a `right` pointer to point at the right child of the tree, and a `left` pointer
    to point at the left child of the tree.'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有以下结构的节点：用于存储树元素的`data`，一个指向树右子节点的`right`指针，以及一个指向树左子节点的`left`指针。
- en: Create the `root` node of the tree. To do this, allocate memory space for a
    new node and set the `root` pointer to point at it.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建树的`root`节点。为此，为新节点分配内存空间，并将`root`指针设置为指向它。
- en: Prompt the user to enter the tree elements. The value that's entered by the
    user is assigned to the data member of the `root` node.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提示用户输入树元素。用户输入的值被分配给`root`节点的数据成员。
- en: The `left` and `right` pointers of the `root` node are set to `NULL`.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`root`节点的`left`和`right`指针被设置为`NULL`。'
- en: The root node is created. Next, prompt the user to specify the number of elements
    in the tree.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根节点已创建。接下来，提示用户指定树中的元素数量。
- en: Repeat *steps 7* to *22* for the number of elements specified by the user.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复*步骤7*到*步骤22*，直到用户指定的元素数量。
- en: Allocate memory space for a new node and set the `new` pointer so that it points
    at it.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为新节点分配内存空间，并将`new`指针设置为指向它。
- en: Prompt the user to enter the tree element. The tree element that's entered by
    the user is assigned to the data member of the new node.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提示用户输入树元素。用户输入的树元素被分配给新节点的数据成员。
- en: The `left` and `right` pointers of the new node are set to `NULL`.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新节点的`left`和`right`指针被设置为`NULL`。
- en: To connect the root node to the new node, we need to find a location where it
    can be connected. To do so, set the `temp` pointer so that it points at the root
    node. Compare the values in the data members of the new node and `temp` node.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将根节点连接到新节点，我们需要找到一个可以连接的位置。为此，设置`temp`指针，使其指向根节点。比较新节点和`temp`节点的数据成员中的值。
- en: If `new ->data > temp->data`, go to *step 12*; otherwise, go to *step 16*.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`new ->data > temp->data`，转到*步骤12*；否则，转到*步骤16*。
- en: If the right link of `temp` is `NULL`—that is, if there is no child on the right
    of the `temp` node—then, the new node is added to the right link of the `temp`
    node.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`temp`的右链接是`NULL`——也就是说，如果`temp`节点的右侧没有子节点——则，新节点被添加到`temp`节点的右链接。
- en: The new node is added as the right child of the `temp` node. Jump to *step 7*
    to add more tree elements.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新节点被添加为`temp`节点的右子节点。跳转到*步骤7*以添加更多树元素。
- en: If the right link of the root is not `NULL`, the `temp` pointer is set to point
    where the `right` pointer of `temp` is pointing to.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果根的右链接不是`NULL`，则将`temp`指针设置为指向`temp`的`right`指针指向的位置。
- en: Go to *step 11* for more comparisons.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到*步骤11*进行更多比较。
- en: If `new->data < root->data`, go to *step 17*; otherwise, go to *step 21*.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`new->data < root->data`，转到*步骤17*；否则，转到*步骤21*。
- en: If the left link of the node is `NULL`—that is, there is no child on the left
    of the temp node—then the new node is added to the left link.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果节点的左链接是`NULL`——也就是说，在`temp`节点的左侧没有子节点——则新节点被添加到左链接。
- en: The new node is added as the left child of the `temp` node. Jump to *step 7*
    to add more tree elements.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新节点被添加为`temp`节点的左子节点。跳转到*步骤7*以添加更多树元素。
- en: If the left link of the root is not `NULL`, the `temp` pointer is set to point
    to where its `left` pointer is pointing.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果根的左链接不是`NULL`，则将`temp`指针设置为指向其`left`指针指向的位置。
- en: Go to *step 11* for more comparisons.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到*步骤11*进行更多比较。
- en: If `new->data = temp->data`, this means the value in the new node is a duplicate
    and cannot be added to the tree.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`new->data = temp->data`，这意味着新节点中的值是重复的，不能添加到树中。
- en: Go to *step 7* to add more tree elements.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到*步骤7*以添加更多树元素。
- en: For inorder traversal, we will follow the algorithm that's provided in the next
    section. The `inorder` function is called recursively and the root node of the
    binary tree is passed to this function.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于中序遍历，我们将遵循下一节提供的算法。`inorder`函数被递归调用，并将二叉树的根节点传递给此函数。
- en: How to do it... – inorder traversal of the tree
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现... – 树的中序遍历
- en: 'Because it''s a recursive form, the function will be called recursively. The
    function is as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它是递归形式，所以函数将被递归调用。函数如下：
- en: '[PRE3]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here, `inorder` is the function that will be recursively called and `node`
    is the node of the binary tree that''s being passed to it. Initially, the node
    will be the root of the binary tree, whose inorder traversal is required. Follow
    these steps:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`inorder`是将被递归调用的函数，`node`是传递给它的二叉树节点。最初，节点将是二叉树的根，需要执行中序遍历。遵循以下步骤：
- en: If node is `NULL`, go to *step 2*; otherwise, return to the caller function.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果节点是`NULL`，则转到*步骤 2*；否则，返回调用函数。
- en: 'Call the same function (the `inorder` function) with the node''s left child
    set as an argument:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相同的函数（即`inorder`函数）并传入节点的左子节点作为参数：
- en: '[PRE4]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Display the content in the node:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示节点中的内容：
- en: '[PRE5]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Call the same function itself (the `inorder` function) with the node''s right
    child set as an argument:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相同的函数本身（即`inorder`函数）并传入节点的右子节点作为参数：
- en: '[PRE6]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The program for creating a binary search tree and traversing it in inorder
    is as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 创建二叉搜索树并在其中进行中序遍历的程序如下：
- en: '[PRE7]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, let's go behind the scenes so that we can understand the code.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码背后的工作原理。
- en: How it works... – binary tree
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理... – 二叉树
- en: 'We created a structure called `tree` consisting of the following members:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`tree`的结构，它包含以下成员：
- en: '`data`: An integer member for storing integer data. Here, we''re assuming that
    our tree only consists of integer elements.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data`：用于存储整数数据的整数成员。在这里，我们假设我们的树只包含整数元素。'
- en: '`right` and `left` pointers: These are used to point at the left and right
    child, respectively.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`right`和`left`指针：这些用于分别指向左子节点和右子节点。'
- en: Internally, the tree will be maintained through an array; an integer array is
    defined of the size 20\. For our purposes, let's assume that the user doesn't
    enter more than 20 elements for the tree. However, you can always increase the
    size of the macro to any larger number you desired.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，树将通过一个数组来维护；定义了一个大小为20的整数数组。为了我们的目的，让我们假设用户不会为树输入超过20个元素。然而，你可以始终将宏的大小增加到任何你想要的更大的数字。
- en: 'The user is prompted to specify the number of elements they want to enter for
    the tree. Let''s say the user wants to enter seven elements for the tree; here,
    the value 7 will be assigned to the `len` variable. The user is prompted to enter
    the seven integers and the values entered by them will be assigned to the `arr`
    array, as shown in the following screenshot:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 提示用户指定他们想要为树输入的元素数量。假设用户想要为树输入七个元素；这里，值7将被分配给`len`变量。提示用户输入七个整数，他们输入的值将被分配到`arr`数组中，如下面的截图所示：
- en: '![](img/6ea4ab83-40b9-4a24-ada1-7ea9807a844b.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6ea4ab83-40b9-4a24-ada1-7ea9807a844b.png)'
- en: 'The `build` function is invoked and the array, `arr`, containing the tree elements
    and the length of the array, `len`, are passed to it. In the `build` function,
    we need to create a root node of the tree. To create a root node of the tree,
    the `makeroot` function is invoked and the first element of the array, `arr`,
    is passed to it as an argument. In the `makeroot` function, a node called `rootNode`
    is created and the value of the first array element is assigned to its data member.
    Because the root node of the tree is not pointing at any other node at the moment,
    the right and left child of the root node are set to `NULL`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`build`函数，并将包含树元素的数组`arr`及其长度`len`传递给它。在`build`函数中，我们需要创建一个树的根节点。为了创建树的根节点，调用`makeroot`函数并将数组`arr`的第一个元素作为参数传递给它。在`makeroot`函数中，创建一个名为`rootNode`的节点，并将第一个数组元素的值分配给其数据成员。因为此时树的根节点没有指向任何其他节点，所以根节点的左右子节点被设置为`NULL`：
- en: '![](img/0edf7982-a38b-4793-91a4-e2cc4f4251d4.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0edf7982-a38b-4793-91a4-e2cc4f4251d4.png)'
- en: 'The `makeroot` function ends and `rootNode` is returned to the `build` function.
    In the `build` function, a `temp` pointer is set to point at `rootNode`. All of
    the array elements from index 1 and above are compared with the data members of
    the `temp` node, that is, the root node. If the array element is smaller than
    the data member of the `temp` node, the array element will be added as the left
    child of the root node. Also, if the array element is larger than the data member
    of the `temp` node, it will be added as the right child of the root node, for
    example, if the second array element is 20 and the root node is 40\. Because 20
    is smaller than 40, it is checked whether the `left` pointer of the `temp` node
    is `NULL`. Because the `left` pointer of `temp` is `NULL`, the `leftchild` function
    is invoked and 20 is passed to it. In the `leftchild` function, a new node is
    created called `newNode`. Here, the second array element (20) is assigned to the
    data member of `newNode`. The `left` and `right` pointers of `newNode` are set
    to `NULL`. The `left` pointer of `temp` is set to point at `newNode`, as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`makeroot` 函数结束，并将 `rootNode` 返回给 `build` 函数。在 `build` 函数中，一个 `temp` 指针被设置为指向
    `rootNode`。从索引 1 开始的所有数组元素都与 `temp` 节点的数据成员进行比较，即根节点。如果数组元素小于 `temp` 节点的数据成员，则该数组元素将被添加为根节点的左子节点。同样，如果数组元素大于
    `temp` 节点的数据成员，它将被添加为根节点的右子节点，例如，如果第二个数组元素是 20，而根节点是 40。因为 20 小于 40，所以会检查 `temp`
    节点的 `left` 指针是否为 `NULL`。因为 `temp` 的 `left` 指针是 `NULL`，所以调用 `leftchild` 函数并将 20
    传递给它。在 `leftchild` 函数中，创建了一个名为 `newNode` 的新节点。在这里，第二个数组元素（20）被分配给 `newNode` 的数据成员。`newNode`
    的 `left` 和 `right` 指针被设置为 `NULL`。`temp` 的 `left` 指针被设置为指向 `newNode`，如下所示：'
- en: '![](img/175d0f87-4e87-4ee8-aee5-ea4349f47147.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/175d0f87-4e87-4ee8-aee5-ea4349f47147.png)'
- en: 'Control goes back to the `build` function, where the `for` loop will pick up
    the next array element for building the tree. Let''s say the next array element
    is 60\. Again, a `temp` pointer is set to point at the root node. The value 60
    is compared with the root node, which is 40\. Because the value of the array element,
    60, is greater than the root node, 40, the right child of the root node is checked.
    Because the right child of the root node is `NULL`, the `rightchild` function
    is invoked and the `temp` pointer and the array element, 60, are passed to it.
    In the `rightchild` function, a new node is created called `newNode` and the value
    60 is passed to it, which is assigned to its data member. The `left` and `right`
    pointers of `newNode` are set to `NULL`. The `right` pointer of `rootNode` is
    set to point at `newNode`, as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 控制返回到 `build` 函数，其中 `for` 循环将选择下一个数组元素以构建树。假设下一个数组元素是 60。再次，设置一个 `temp` 指针指向根节点。将值
    60 与根节点 40 进行比较。因为数组元素的值 60 大于根节点 40，所以检查根节点的右子节点。因为根节点的右子节点是 `NULL`，所以调用 `rightchild`
    函数并将 `temp` 指针和数组元素 60 传递给它。在 `rightchild` 函数中，创建了一个名为 `newNode` 的新节点并将值 60 传递给它，该值被分配给其数据成员。`newNode`
    的 `left` 和 `right` 指针被设置为 `NULL`。将 `rootNode` 的 `right` 指针设置为指向 `newNode`，如下所示：
- en: '![](img/0c051ac3-4b13-48eb-b3b3-d516019dee9d.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0c051ac3-4b13-48eb-b3b3-d516019dee9d.png)'
- en: 'After completing the `rightchild` function, control goes back to the `build`
    function, where the `for` loop picks up the next array element for building the
    tree. The next array element is 80\. A temporary pointer, `temp`, is set to point
    at the root node. The root node, 40 is compared with the new element to be added,
    80\. Because 80 > 40, the right child of the `temp` node is checked. The `right`
    pointer of the `temp` node is not `NULL`, so the `temp` pointer is set to point
    at its right node, as follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，`rightchild` 函数的控制返回到 `build` 函数，其中 `for` 循环选择下一个数组元素以构建树。下一个数组元素是 80。设置一个临时指针
    `temp` 指向根节点。将根节点 40 与要添加的新元素 80 进行比较。因为 80 大于 40，所以检查 `temp` 节点的右子节点。`temp` 节点的
    `right` 指针不是 `NULL`，因此将 `temp` 指针设置为指向其右节点，如下所示：
- en: '![](img/62a3ecf0-7352-4881-9a00-31dd843a41f4.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/62a3ecf0-7352-4881-9a00-31dd843a41f4.png)'
- en: 'Now, the `right` pointer of `temp` is checked again. This procedure is repeated
    until the `right` pointer of `temp` is found to be `NULL`. The `right` pointer
    of 60 is `NULL`, so the `rightchild` function is invoked and `temp`, 60, and the
    new element, 80, are passed to it. In the `rightchild` function, a new node is
    created called `newNode` and the value 80 is assigned to it. The right and left
    pointers of `newNode` are set to `NULL`. The `right` pointer of `temp` is set
    to point at `newNode`, as follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次检查 `temp` 的 `right` 指针。此过程会重复进行，直到找到 `temp` 的 `right` 指针为 `NULL`。60 的 `right`
    指针是 `NULL`，因此调用 `rightchild` 函数，并将 `temp`、60 和新元素 80 传递给它。在 `rightchild` 函数中，创建了一个新节点，称为
    `newNode`，并将值 80 分配给它。`newNode` 的左右指针设置为 `NULL`。将 `temp` 的 `right` 指针设置为指向 `newNode`，如下所示：
- en: '![](img/db86352f-0d49-4f40-b250-fb8f3694e29d.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![](img/db86352f-0d49-4f40-b250-fb8f3694e29d.png)'
- en: 'After completing the `rightchild` function, control jumps back to the `build`
    function, where the `for` loop picks up the next array element for building the
    tree. After all of the array elements have been used, the binary search tree will
    look as follows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 完成对 `rightchild` 函数的调用后，控制权跳回到 `build` 函数，其中 `for` 循环选择下一个数组元素以构建树。使用完所有数组元素后，二叉搜索树将如下所示：
- en: '![](img/e653e801-ba03-49a4-86f8-5442d383bbac.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e653e801-ba03-49a4-86f8-5442d383bbac.png)'
- en: Once the binary search tree has been created, the `travino` function is invoked
    for inorder traversal of the binary tree and the root node is passed to it.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了二叉搜索树，就调用 `travino` 函数对二叉树进行中序遍历，并将根节点传递给它。
- en: How it works... – inorder traversal of the tree
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的... – 树的中序遍历
- en: The `travino` function is a recursive function. First, it ensures the supplied
    node is not `NULL`. If the node is not `NULL`, a recursive call to the `travino`
    function is made with the node's left child. The node is checked to ensure it's
    not `NULL`. If it isn't, again, a recursive call to the `travino` function is
    made with its left child. If the node is `NULL`, the value in the data member
    of the node is displayed on the screen and a recursive call to the `travino` function
    is made with the node's right child. This procedure is repeated until all of the
    nodes that are displayed on the screen have been visited.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`travino` 函数是一个递归函数。首先，它确保提供的节点不是 `NULL`。如果节点不是 `NULL`，则对 `travino` 函数进行递归调用，使用节点的左子节点。检查节点以确保它不是
    `NULL`。如果不是，再次对 `travino` 函数进行递归调用，使用其左子节点。如果节点是 `NULL`，则在屏幕上显示节点数据成员中的值，并对 `travino`
    函数进行递归调用，使用节点的右子节点。此过程会重复进行，直到屏幕上显示的所有节点都已访问。'
- en: 'The inorder traversal is described as *L*,*V*,*R*, as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 中序遍历描述为 *L*,*V*,*R*，如下所示：
- en: L means visiting the left child
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: L 表示访问左子节点
- en: V means visiting the node that is displaying its content
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: V 表示访问显示其内容的节点
- en: R means visiting the right child
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: R 表示访问右子节点
- en: 'On each node of the binary tree, LVR operations are applied, beginning from
    the root node. Our binary tree has already been created and looks as follows.
    At node 40, three operations—L,V, and R—are applied. L means visiting its left
    child, so we move to the left child of node 40, but two of its operations, V and
    R, still need to be completed on the node left. So, node 40 is pushed onto the
    stack with V and R attached to it:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在二叉树的每个节点上，应用 LVR 操作，从根节点开始。我们的二叉树已经创建，如下所示。在节点 40 上，应用了三个操作—L、V 和 R。L 表示访问其左子节点，因此我们移动到节点
    40 的左子节点，但节点左边的两个操作，V 和 R，仍然需要在该节点上完成。因此，节点 40 被推入栈中，V 和 R 附着于其上：
- en: '![](img/fe0d2554-9261-4645-9d19-fd47caa653fe.png)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fe0d2554-9261-4645-9d19-fd47caa653fe.png)'
- en: 'The left child of node 40 is node 20\. Again, at node 20, three operations—L,V,
    and R—are applied. First, L (the left child) is visited. Only two operations,
    V and R, are left. So, again, node 20 is pushed onto the stack with V and R attached
    to it. The left child of node 20 is node 10\. Again, at this node L, V, and R
    are applied. Since its left child is `NULL`, the second operation, V, is applied;
    that is, the node is displayed or we can say it is traversed. After that, we go
    to its right child. The right child of node 10 is `NULL` and since all three operations
    (L,V, and R) have been applied on this node, it is not pushed to the stack:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 节点40的左子节点是节点20。再次，在节点20，应用了三个操作——L、V和R。首先，访问L（左子节点）。只剩下两个操作，V和R。因此，再次将节点20推入栈中，V和R附加在其上。节点20的左子节点是节点10。再次在这个节点上应用L、V和R。由于它的左子节点是`NULL`，第二个操作V被应用；也就是说，节点被显示，或者我们可以说是被遍历。之后，我们转到它的右子节点。节点10的右子节点是`NULL`，并且由于在这个节点上已经应用了三个操作（L、V和R），因此它没有被推入栈中：
- en: '![](img/b621ce57-32ab-44b2-bb83-17f6eb4d0ca5.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b621ce57-32ab-44b2-bb83-17f6eb4d0ca5.png)'
- en: 'Now, node 20 is popped from the stack. Its two operations, V and R, are pending.
    First, it is visited (displayed) and then we go to its right child:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，节点20从栈中弹出。它的两个操作，V和R，待执行。首先，它被访问（显示），然后我们转到它的右子节点：
- en: '![](img/52060a7d-41df-4c5d-8c1d-ed5974915369.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/52060a7d-41df-4c5d-8c1d-ed5974915369.png)'
- en: 'The right child of node 20 is 30\. Again, at node 30, three operations—L,V,
    and R—are applied. First L (the left child) is visited. Since it has no left child,
    the second operation, V, is applied; that is, node 30 is visited (displayed),
    and then we go to its right child. It has no right child either and since all
    three operations (L,V, and R) have been applied on this node, 30 is not pushed
    to the stack:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 节点20的右子节点是30。再次，在节点30，应用了三个操作——L、V和R。首先，访问L（左子节点）。由于它没有左子节点，第二个操作V被应用；也就是说，节点30被访问（显示），然后我们转到它的右子节点。它也没有右子节点，并且由于在这个节点上已经应用了三个操作（L、V和R），因此30没有被推入栈中：
- en: '![](img/1166c2b0-4537-4afc-b92e-8cb0008651b7.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1166c2b0-4537-4afc-b92e-8cb0008651b7.png)'
- en: 'Now, node 40 is popped from the stack. Its two operations, V and R, are pending.
    First, it is visited (displayed) and then we go to its right child. The right
    child of node 40 is node 60\. At node 60, the three operations—L,V, and R—are
    applied. First, L (the left child) is visited. V and R are left. Here, node 60
    is pushed to the stack with V and R attached to it:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，节点40从栈中弹出。它的两个操作，V和R，待执行。首先，它被访问（显示），然后我们转到它的右子节点。节点40的右子节点是节点60。在节点60，应用了三个操作——L、V和R。首先，访问L（左子节点）。V和R被保留。在这里，节点60被推入栈中，V和R附加在其上：
- en: '![](img/52dbf9ff-a522-4981-a405-8c1d91826656.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/52dbf9ff-a522-4981-a405-8c1d91826656.png)'
- en: 'The left child of node 60 is node 50\. Again at this node, L, V, and R are
    applied. Since its left child is `NULL`, the second operation, V, is applied;
    that is, node 50 is displayed or we can say it is traversed. After that, we go
    to its right child. The right child of node 50 is `NULL` and since all three operations
    (L,V, and R) have been applied to this node, it is not pushed to the stack:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 节点60的左子节点是节点50。再次在这个节点上应用L、V和R。由于它的左子节点是`NULL`，第二个操作V被应用；也就是说，节点50被显示，或者我们可以说是被遍历。之后，我们转到它的右子节点。节点50的右子节点是`NULL`，并且由于在这个节点上已经应用了三个操作（L、V和R），因此它没有被推入栈中：
- en: '![](img/7ea51249-d309-46d1-8f81-4847b36790d6.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7ea51249-d309-46d1-8f81-4847b36790d6.png)'
- en: Now, node 60 is popped from the stack. Its two operations, V and R, are pending.
    First, it is visited (displayed) and then we go to its right child. So, the visited
    nodes will be 10, 20, 30, 40, 50, and 60.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，节点60从栈中弹出。它的两个操作，V和R，待执行。首先，它被访问（显示），然后我们转到它的右子节点。因此，访问过的节点将是10、20、30、40、50和60。
- en: The right child of node 60 is 80\. Again, at node 80, three operations—L,V,
    and R—are applied. First, L (its left child) is visited. Since it has no left
    child, the second operation, V, is applied; that is, node 80 is visited (displayed),
    and then we go to its right child. It has no right child either and since all
    three operations (L,V, and R) have been applied to this node, 80 is not pushed
    to the stack.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 节点60的右子节点是80。再次，在节点80，应用了三个操作——L、V和R。首先，访问L（它的左子节点）。由于它没有左子节点，第二个操作V被应用；也就是说，节点80被访问（显示），然后我们转到它的右子节点。它也没有右子节点，并且由于在这个节点上已经应用了三个操作（L、V和R），因此80没有被推入栈中。
- en: So, the final inorder traversal of the tree is 10, 20, 30, 40, 50, 60, and 80.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，树的最终中序遍历是10、20、30、40、50、60和80。
- en: 'The program is compiled using the GCC compiler using the following statement:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 程序使用GCC编译器以下语句编译：
- en: '[PRE8]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As shown in the following screenshot, no error appears when we compile. This
    means the `binarysearchtree.c` program has successfully compiled into a `.exe`
    file called `binarysearchtree.exe`. Let''s run the executable file and enter some
    elements to create a binary tree and see its inorder traversal. By doing this,
    we get the following output:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下截图所示，编译时没有出现错误。这意味着 `binarysearchtree.c` 程序已成功编译成名为 `binarysearchtree.exe`
    的 `.exe` 文件。让我们运行可执行文件并输入一些元素以创建二叉树并查看其中序遍历。通过这样做，我们得到以下输出：
- en: '![](img/2fac6eb0-302a-4251-8697-856e33eae1c1.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2fac6eb0-302a-4251-8697-856e33eae1c1.png)'
- en: Performing postorder traversal of a binary tree non-recursively
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以非递归方式对二叉树进行后序遍历
- en: In this recipe, we will perform postorder traversal of a binary tree without
    recursion. This will be done through non-recursive calls to the function.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们将通过非递归函数调用以非递归方式对二叉树进行后序遍历。这将通过非递归调用函数来实现。
- en: Getting started
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用
- en: To create a binary tree, refer to the *Creating a binary search tree and performing
    an inorder traversal on it recursively* recipe. We will be performing postorder
    traversal on the same binary tree we created in this recipe.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建二叉树，请参考 *递归创建二叉搜索树并对其进行中序遍历* 的菜谱。我们将对在本菜谱中创建的同一二叉树执行后序遍历。
- en: How to do it...
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'For postorder traversal of a binary tree, we need to apply three tasks—L, R,
    and V—on each of the tree nodes. These tasks are as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 对于二叉树的后序遍历，我们需要在每个树节点上应用三个任务—L、R 和 V。这些任务如下：
- en: L means visit the left link
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: L 表示访问左链接
- en: R means visit the right link
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: R 表示访问右链接
- en: V means visit the node
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: V 表示访问节点
- en: 'To find out which tasks between L, R, and V are pending and which have already
    been performed, we will use two stacks: one for storing the node and another for
    storing an integer value of 0 or 1\. Let''s go over what 0 and 1 indicate:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出 L、R 和 V 之间哪些任务待处理，哪些已执行，我们将使用两个栈：一个用于存储节点，另一个用于存储整数值 0 或 1。让我们回顾一下 0 和 1
    的含义：
- en: The value 0 indicates that the L task is done, while the R and V tasks are pending
    on the node.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值 0 表示 L 任务已完成，而 R 和 V 任务在该节点上待处理。
- en: The value 1 means that the L and R tasks have been performed on the node and
    that only V is pending.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值 1 表示节点上的 L 和 R 任务已完成，而 V 任务待处理。
- en: 'Follow these steps to perform postorder tree traversal:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤执行后序树遍历：
- en: A temporary node called `temp` is set to point at the root node of the tree.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个临时节点 `temp` 指向树的根节点。
- en: Push the node that's being pointed at by `temp` to `nodeArray` and the value
    0 to `valueArray`. The integer 0 in `valueArray` indicates that the R and V tasks
    are pending on the node.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `temp` 所指向的节点推入 `nodeArray`，并将值 0 推入 `valueArray`。`valueArray` 中的整数 0 表示 R
    和 V 任务在该节点上待处理。
- en: Make the `temp` node point at the node where its `left` pointer is pointing.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使 `temp` 节点指向其 `left` 指针所指向的节点。
- en: If the `temp` is not pointing at `NULL`, go to *step 2*.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `temp` 没有指向 `NULL`，则转到 *步骤 2*。
- en: If `temp` reaches `NULL`, go to *step 6*.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `temp` 达到 `NULL`，则转到 *步骤 6*。
- en: Pop the node from `nodeArray`.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `nodeArray` 中弹出节点。
- en: Pop the integer from `valueArray`.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `valueArray` 中弹出整数。
- en: If the popped integer value is 1, visit the node that is displaying the data
    member of the node. Then, go to *step 6*.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果弹出的整数值是 1，则访问显示节点数据成员的节点。然后，转到 *步骤 6*。
- en: If the popped integer value is 0, go to *step 10*.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果弹出的整数值是 0，则转到 *步骤 10*。
- en: Push the node to `nodeArray`.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将节点推入 `nodeArray`。
- en: Push the integer 1 to `valueArray` to indicate that the L and R operations have
    been performed and that only V is pending.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将整数 1 推入 `valueArray` 以表示 L 和 R 操作已完成，而 V 操作待处理。
- en: Make the `temp` pointer point to where its `right` pointer is pointing.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使 `temp` 指针指向其 `right` 指针所指向的位置。
- en: If the `temp` pointer does not reach `NULL`, go to *step 2*.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `temp` 指针没有达到 `NULL`，则转到 *步骤 2*。
- en: If the `temp` pointer reaches `NULL`, go to *step 6*.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `temp` 指针达到 `NULL`，则转到 *步骤 6*。
- en: 'The program for creating a binary search tree and traversing it in postorder
    non-recursively is as follows:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 创建二叉搜索树并在非递归方式遍历它的程序如下：
- en: '[PRE9]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, let's go behind the scenes so that we can understand the code.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码背后的原理。
- en: How it works...
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Postorder traversal requires the L, R, and V tasks to be applied to each node
    of the binary tree. Here, L means visiting the left child, R means visiting the
    right child, and V means visiting the node that is displaying its content.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 后序遍历需要将L、R和V任务应用于二叉树的每个节点。在这里，L表示访问左子树，R表示访问右子树，V表示访问显示其内容的节点。
- en: 'The question is, how will we know which tasks have already been performed on
    a node and which tasks are left to be performed? To do so, we will use two arrays,
    `nodeArray` and `valueArray`. `nodeArray` contains the node that the tasks are
    to be performed one, while `valueArray` is used to indicate what task has been
    left on the corresponding node. `valueArray` can have one of the following two
    values:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，我们如何知道已经对一个节点执行了哪些任务，以及哪些任务尚未执行？为了做到这一点，我们将使用两个数组，`nodeArray`和`valueArray`。`nodeArray`包含要执行任务的节点，而`valueArray`用于指示相应节点上留下的任务。`valueArray`可以有以下两个值：
- en: '**Value 0**: This indicates that the left link of the node has been traversed
    and that two tasks are pending: traversing the node being pointed to by its `right`
    pointer and visiting the node.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**值0**：这表示已遍历节点的左链接，并且有两个任务待完成：遍历由其`right`指针指向的节点和访问节点。'
- en: '**Value 1**: This indicates that the node being pointed to by its `right` pointer
    has been traversed. Only the task of visiting the node is pending.'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**值1**：这表示由其`right`指针指向的节点已被遍历。只有访问节点的任务尚未完成。'
- en: Once the binary search tree has been created, the `nontravpost` function is
    invoked for postorder traversal of the binary tree and the root node is passed
    to the function as an argument. The `nontravpost` function is a non-recursive
    function.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了二叉搜索树，就会调用`nontravpost`函数进行二叉树的后序遍历，并将根节点作为参数传递给函数。`nontravpost`函数是一个非递归函数。
- en: A temporary pointer, `temp`, is set to point at the root node. A `while` loop
    is set to execute until `temp` is not `NULL`. Within the `while` loop, the `pushNode`
    function is called and the node being pointed to by `temp` is passed to it, along
    with a value of 0.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 设置一个临时指针`temp`指向根节点。设置一个`while`循环，直到`temp`不是`NULL`为止。在`while`循环中，会调用`pushNode`函数，并将`temp`指向的节点及其值0传递给它。
- en: 'In the `pushNode` function, the value of top that was initialized to -1 is
    incremented to 0 and the node, 40, and the value 0 are pushed into the `nodeArray`
    and `valueArray` arrays at index location being pointed to by `top` (the index
    location, 0):'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在`pushNode`函数中，初始化为-1的`top`值递增到0，并将节点40和值0推入由`top`（索引位置，0）指向的`nodeArray`和`valueArray`数组中：
- en: '![](img/a2cae85b-f46b-4551-a21f-aeb46c8eb57a.png)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a2cae85b-f46b-4551-a21f-aeb46c8eb57a.png)'
- en: 'The `pushNode` function ends and control jumps back to the `nontravpost` function,
    where the `temp` pointer is set to point at its left node. The `left` pointer
    of temp is pointing at node 20, so `temp` will now point at node 20\. The `while`
    loop will keep executing until the `temp` pointer reaches the `NULL` pointer.
    Again, within the `while` loop, the `pushNode` function is called and node 20
    and value 0 are passed to it. In the `pushNode` function, the value of the `top`
    pointer is incremented to 1 and node 20 and the value 0 are pushed to the `nodeArray[1]`
    and `valueArray[1]` array index locations, as follows:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '`pushNode`函数结束，控制跳转回`nontravpost`函数，其中`temp`指针被设置为指向其左侧节点。`temp`的`left`指针指向节点20，因此`temp`现在指向节点20。`while`循环将继续执行，直到`temp`指针达到`NULL`指针。再次强调，在`while`循环中，会调用`pushNode`函数，并将节点20和值0传递给它。在`pushNode`函数中，`top`指针的值递增到1，并将节点20和值0推入`nodeArray[1]`和`valueArray[1]`数组索引位置，如下所示：'
- en: '![](img/a60b6d60-79e2-49ba-8277-250bc30a0843.png)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a60b6d60-79e2-49ba-8277-250bc30a0843.png)'
- en: 'This process is repeated for the next node that''s on the left of the `temp`
    node. On the left of node 20 is node 10\. Upon pushing node 10, the `nodeArray`
    and `valueArray` arrays will look as follows:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程会重复进行，直到`temp`节点的左侧节点。在节点20的左侧是节点10。在推入节点10后，`nodeArray`和`valueArray`数组将如下所示：
- en: '![](img/5067f030-aaf3-48d4-bcf4-5502af649446.png)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5067f030-aaf3-48d4-bcf4-5502af649446.png)'
- en: Because temp has reached the `NULL` pointer, the first `while` loop will terminate
    and the next `while` loop will execute while the value of `top` is greater than
    or equal to 0\. The `popNode` function is invoked, which returns the node in the
    `nodeArray` array that's being pointed at by the `top` index. The value of the
    `top` index is currently 2, so the node at the index location of `nodeArray[2]`,
    that is, 10, is accessed and returned to the `nontravpost` function. In the `nontravpost`
    function, node 10 will be assigned to the `temp` pointer. Next, the `popVal` function
    is invoked, which returns the value in the `valueArray` array that's being pointed
    to by the `top` index. This happens at the `valueArray[2]` index location. That
    is, the value 0 at the `valueArray[2]` index location is returned by the `popVal`
    function and is assigned to the `val` variable. The value of `top` is now decremented
    to 1\. Because the value in the `val` variable is 0, an `if` block is executed
    in the `nontravpost` function. The `if` block checks whether the right child of
    the node being pointed at by the `temp` pointer isn't `NULL`; if so, the `pushNode`
    function is called and the node being pointed to by `temp`, that is, 10 and integer
    value 1, is passed to it as an argument.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`temp`已经达到`NULL`指针，第一个`while`循环将终止，并且当`top`的值大于或等于0时，将执行下一个`while`循环。调用`popNode`函数，该函数返回由`top`索引指向的`nodeArray`数组中的节点。当前`top`索引的值为2，因此访问索引位置`nodeArray[2]`处的节点，即10，并将其返回给`nontravpost`函数。在`nontravpost`函数中，节点10将被分配给`temp`指针。接下来，调用`popVal`函数，该函数返回由`top`索引指向的`valueArray`数组中的值。这发生在`valueArray[2]`索引位置。即，`popVal`函数从`valueArray[2]`索引位置返回值0，并将其分配给`val`变量。此时`top`的值减少到1。因为`val`变量中的值是0，`nontravpost`函数中执行了一个`if`块。该`if`块检查由`temp`指针指向的节点的右子节点是否不是`NULL`；如果是，则调用`pushNode`函数，并将由`temp`指向的节点，即10和整数值1，作为参数传递给它。
- en: 'In the `pushNode` function, the value of `top` is incremented to 2 and node
    10 and the value 1 are pushed to the `nodeArray[2]` and `valueArray[2]` index
    locations, respectively:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在`pushNode`函数中，`top`的值增加至2，节点10和值1分别被推入`nodeArray[2]`和`valueArray[2]`索引位置：
- en: '![](img/165fead0-b3a1-4ab1-a88b-e5dd8fc18503.png)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![](img/165fead0-b3a1-4ab1-a88b-e5dd8fc18503.png)'
- en: After executing the `pushNode` function, control jumps back to the `nontravpost`
    function, where the `temp` pointer is set to point to where its `right` pointer
    is pointing. But because the `right` pointer of `temp` is `NULL`, the `while`
    loop will break and the data member of the node being pointed to by `temp` (that
    is, 10) is displayed on the screen.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`pushNode`函数后，控制权跳回`nontravpost`函数，其中`temp`指针被设置为指向其`right`指针指向的位置。但是，因为`temp`的右指针是`NULL`，`while`循环将中断，并将由`temp`指向的节点（即10）的数据成员显示在屏幕上。
- en: 'Again, the `while` loop will execute and the `popNode` and `popVal` functions
    will execute to pop node 20 and value 0, respectively. Node 20 will be pointed
    to by the `temp` pointer. Because the value that''s being popped is 0, the right
    pointer of the node being pointed to by `temp` is searched. If the `right` pointer
    of node 20 is pointing at node 30, the `pushNode` function is invoked and node
    20 is pushed, along with the value 1:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，`while`循环将执行，`popNode`和`popVal`函数将执行以弹出节点20和值0。节点20将由`temp`指针指向。因为被弹出的值是0，所以搜索由`temp`指向的节点的右指针。如果节点20的右指针指向节点30，则调用`pushNode`函数，并将节点20及其值1推入：
- en: '![](img/56ae7b01-996a-44a8-83b4-8b051cf325f0.png)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![](img/56ae7b01-996a-44a8-83b4-8b051cf325f0.png)'
- en: 'Next, the `temp` pointer is set to point to where its `right` pointer is pointing,
    that is, node 30\. The `pushNode` function is invoked and node 30 and an integer
    value of 0 are pushed to the `nodeArray` and `valueArray` arrays, respectively:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将`temp`指针设置为指向其`right`指针指向的位置，即节点30。调用`pushNode`函数，并将节点30和整数值0分别推入`nodeArray`和`valueArray`数组：
- en: '![](img/83d145b5-6a46-444e-ac61-987a88be7791.png)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![](img/83d145b5-6a46-444e-ac61-987a88be7791.png)'
- en: This procedure is repeated until the stacks are empty.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程将重复进行，直到栈为空。
- en: 'The program is compiled with GCC using the following statement:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下语句使用GCC编译程序：
- en: '[PRE10]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If no error appears upon compilation, then the `postordernonrec.c` program
    has successfully compiled into the `postordernonrec.exe` file. Let''s run this
    file and enter some new elements that will build a binary tree and get its postorder
    traversal using a non-recursive approach. By doing this, we will get the following
    output:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 如果编译过程中没有出现错误，那么`postordernonrec.c`程序已成功编译成`postordernonrec.exe`文件。让我们运行这个文件，并输入一些新元素来构建一个二叉树，并使用非递归方法获取其后序遍历。通过这样做，我们将得到以下输出：
- en: '![](img/b53423cb-9e80-40ed-a30b-a155df9939bf.png)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b53423cb-9e80-40ed-a30b-a155df9939bf.png)'
- en: See also
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'To learn how to implement queues and circular queues using arrays and dequeues
    using circular queues, visit *Appendix B* found on this link: [https://github.com/PacktPublishing/Practical-C-Programming/blob/master/Appendix%20B.pdf](https://github.com/PacktPublishing/Practical-C-Programming/blob/master/Appendix%20B.pdf).'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何使用数组实现队列和循环队列，以及如何使用循环队列实现出队操作，请访问此链接中的*附录B*：[https://github.com/PacktPublishing/Practical-C-Programming/blob/master/Appendix%20B.pdf](https://github.com/PacktPublishing/Practical-C-Programming/blob/master/Appendix%20B.pdf)。
