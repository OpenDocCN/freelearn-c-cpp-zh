# C++作为嵌入式语言

当涉及到资源受限系统上的嵌入式开发时，仍然普遍认为只有 C 和 ASM 是可行的选择，伴随着这样的想法：C++的占用空间比 C 大，或者增加了显著复杂性。在本章中，我们将详细探讨所有这些问题，并考虑 C++作为嵌入式编程语言的优点：

+   相对于 C，C++

+   C++作为多范式语言的优点

+   与现有的 C 和 ASM 的兼容性

+   C++11、C++14 和 C++17 的变化

# 相对于 C，C++

C 和 C++的谱系都追溯到 ALGOL 编程语言，该语言在 1958 年（ALGOL 58）首次出现，随后在 1960 年和 1968 年进行了更新。ALGOL 引入了命令式编程的概念——一种编程风格，其中语句明确告诉机器如何更改数据以进行输出和控制流。

从命令式编程中自然出现的范式是过程的使用。我们将从一个例子开始，引入术语。过程与子程序和函数同义。它们标识语句组，使它们自成体系，这有助于将这些语句的范围限制在它们所包含的部分的有限范围内，创建层次结构，并因此将这些过程作为新的、更抽象的语句引入。这种过程式编程风格的过度使用在所谓的结构化编程中找到了其位置，与循环和分支控制结构并列。

随着时间的推移，结构化和模块化编程风格被引入作为提高应用代码开发、质量和可维护性的技术。C 语言由于其使用语句、控制结构和函数，是一种命令式、结构化编程语言。

以 C 中的标准 Hello World 示例为例：

```cpp
#include <stdio.h> 
int main(void) 
{ 
    printf("hello, world"); 
    return 0; 
} 
```

任何 C（和 C++）应用的入口点是`main()`函数（过程）。在这个函数的第一条语句行中，我们调用另一个过程（`printf()`），它包含自己的语句，并可能以其他函数的形式调用其他语句块。

这样，我们已经通过实现一个`main()`逻辑块（即`main()`函数）来利用了过程式编程，该函数按需调用。虽然`main()`函数只会被调用一次，但在`printf()`语句中又发现了过程式风格的再次出现，该语句在应用的其他地方调用语句，而无需显式地复制它们。应用过程式编程使得维护生成的代码变得容易得多，并创建我们可以跨多个应用使用的代码库，同时只需维护单个代码库。

在 1979 年，Bjarne Stroustrup 开始了 *C with Classes* 的工作，他借鉴了 C 的现有编程范式，并从其他语言中添加了元素，特别是 Simula（面向对象编程：既可以是命令式也可以是结构化）和 ML（泛型编程，以模板的形式）。它还将提供 **Basic Combined Programming Language**（**BCPL**）的速度，而不限制开发者对其限制性的低级关注点。

结果产生的多范式语言在 1983 年被更名为 **C++**，同时增加了 C 中没有的额外特性，包括操作符和函数重载、虚函数、引用，并开始为这种 C++ 语言开发独立的编译器。

C++ 的基本目标始终是提供针对现实世界问题的实用解决方案。此外，C++ 总是旨在成为一个更好的 C，因此得名。Stroustrup 本身定义了一系列规则（如 *Evolving C++ 1991-2006* 中所述），这些规则至今仍在推动 C++ 的发展，包括以下内容：

+   C++ 的发展必须由实际问题驱动

+   每个特性都必须有一个合理明显的实现

+   C++ 是一种语言，而不是一个完整的系统

+   不要试图强迫人们使用特定的编程风格

+   不存在对静态类型系统的隐式违反

+   为用户定义的类型提供与内置类型一样好的支持

+   在 C++ 之下不留任何低级语言的余地（除汇编器外）

+   不使用的东西，你不必为此付费（零开销规则）

+   如果有疑问，提供手动控制手段

与 C 相比，差异显然超出了面向对象编程。尽管人们仍然认为 C++ 只是 C 的一系列扩展，但它已经很长时间成为了一种独立的语言，增加了严格的类型系统（与当时 C 的弱类型系统相比）、更强大的编程范式和 C 中没有的特性。因此，它与 C 的兼容性更多是巧合，C 在正确的时间成为了作为基础的正确语言。

当时 Simula 的问题在于它对于通用使用来说太慢，而 BCPL 则太低级。C 在当时是一种相对较新的语言，提供了在特性和性能之间的正确平衡。

# C++ 作为嵌入式语言

大约在 1983 年，当 C++ 刚被构想并命名时，面向大众的个人计算机系统以及企业，其规格如以下表格所示：

| **系统** | **CPU** | **时钟速度 (MHz)** | **RAM (KB)** | **ROM (KB)** | **存储 (KB)** |
| --- | --- | --- | --- | --- | --- |
| BBC Micro | 6502 (B+ 6512A) | 2 | 16-128 | 32-128 | 最大 1,280 (ADFS 软盘) 最大 20 MB (硬盘) |
| MSX | Zilog Z80 | 3.58 | 8-128 | 32 | 720 (软盘) |
| Commodore 64 | 6510 | ~1 | 64 | 20 | 1,000 (磁带) 170 (软盘) |
| Sinclair ZX81 | Zilog Z80 | 3.58 | 1 | 8 | 15 (卡带) |
| IBM PC | Intel 8080 | 4.77 | 16-256 | 8 | 360 (软盘) |

现在将这些计算机系统与近期的一款 8 位**微控制器**（**MCU**）如 AVR ATMega 2560 进行比较，其规格如下：

+   16 MHz 时钟速度

+   8 KB RAM

+   256 KB ROM（程序）

+   4 KB ROM（数据）

ATMega 2560 于 2005 年发布，是当今更强大的 8 位 MCU 之一。其特性与 20 世纪 80 年代的计算机系统相比具有优势，而且 MCU 不依赖于任何外部存储组件。

由于硅 IC 制造工艺的改进，这些改进也提供了更小的芯片尺寸、高吞吐量和更低的成本，现在的 MCU 核心时钟速度显著更快。此外，与 20 世纪 80 年代的架构相比，这些架构通常需要 2 到 5 个时钟周期来检索、解码、执行指令并将结果存储，而 AVR 则具有单周期执行性能。

当前 MCU（静态）RAM 的限制主要由于成本和功耗，但对于大多数 MCU 来说，可以通过使用外部 RAM 芯片以及添加基于闪存的或其他大容量存储设备来轻松克服。

类似于**Commodore 64**（**C64**）的系统通常用 C 语言编程，除了内置的 BASIC 解释器（内置 ROM）。Commodore 64 的一个著名的 C 开发环境是 Spinnaker 出版的 Power C：

![](img/68f27296-883d-413d-9ab1-22a01b44e154.png)

Power C 是针对 C 开发者的一种生产力软件品牌。它包含在一个单面双面的软盘上，允许你在编辑器中编写 C 代码，然后使用包含的编译器、链接器、头文件和库来编译系统可执行文件。

那时候存在许多这样的编译器集合，针对各种系统，展示了当时软件开发所存在的丰富生态系统。在这些集合中，C++当然是一个新来者。斯特劳斯特鲁普的《C++编程语言》第一版仅在 1985 年出版，而且最初并没有与之配套的稳定语言实现。

然而，C++的商业支持开始迅速出现，1987 年发布了 Borland C++ 1.0，并在 1991 年更新到 2.0。这类开发环境特别用于 IBM PC 及其众多克隆机，在这些机器上没有像 BASIC 这样的首选开发语言。

虽然 1985 年 C++开始作为一个非官方标准，但直到 1989 年，随着第二版《C++编程语言》的发布，作为权威著作，C++才大致达到了 ISO/IEC 14882:1998 标准化的水平，通常称为 C++98。尽管如此，可以说在 1990 年摩托罗拉 68040 和 1992 年英特尔 486DX 出现之前，C++经历了显著的发展和采用，这些处理器将处理能力提升到了 20 MIPS 以上。

现在我们已经考虑了早期的硬件规范以及 C++与 C 和其他当时打算用于相对有限系统的语言的演变，这似乎表明 C++完全能够在这样的硬件上运行，进而扩展到现代微控制器。然而，似乎也有必要询问自那时以来添加到 C++中的复杂性在多大程度上影响了内存或计算性能要求。

# C++语言特性

我们之前曾探讨过数据系统和状态变化的显式性质，这定义了命令式编程与声明式编程的不同，在声明式编程中，而不是在循环中操作数据，这种功能可以声明为将运算符映射到某些数据上，从而明确功能，而不是操作的具体顺序。但为什么编程语言必须在命令式和声明式范式之间做出选择呢？

事实上，C++的一个主要区别特征是其多范式性质，它结合了命令式和声明式范式。在将面向对象、泛型和函数式编程纳入 C++，以及 C 的过程式编程之外，似乎很自然地假设这都会带来一定的成本，无论是更高的 CPU 使用率还是更多的 RAM 和/或 ROM 消耗。

然而，正如我们在本章早期所学的，C++语言特性最终是基于 C 语言构建的，因此相对于在纯 C 语言中实现类似结构，应该几乎没有开销。为了解决这个难题并调查低开销假设的有效性，我们现在将详细研究许多 C++语言特性，以及它们最终是如何实现的，以及它们在二进制和内存大小上的相应成本。

一些专注于 C++作为底层嵌入式语言的示例是在 Hackaday 上发布的 Rud Merriam 的《Code Craft》系列中获得的许可，[`hackaday.io/project/8238-embedding-c`](https://hackaday.io/project/8238-embedding-c)。

# 命名空间

命名空间是向应用程序中引入额外作用域层次的一种方式。正如我们在关于类的早期部分所看到的，这些是编译器级别的概念。

主要用途在于模块化代码，在类不是最明显解决方案的情况下，或者当你想明确地将类分类到特定类别时，可以将代码划分为逻辑段。这样，你还可以避免具有相似名称的类、类型和枚举之间的名称和类型冲突。

# 强类型

类型信息对于测试对数据的正确访问和解释是必要的。C++相对于 C 的一个大特性是包含了一个强类型系统。这意味着编译器执行的许多类型检查比 C 语言（一种弱类型语言）所允许的要严格得多。

这在查看以下合法的 C 代码时尤为明显，当作为 C++编译时将产生错误：

```cpp
void* pointer; 
int* number = pointer; 
```

或者，它们也可以按照以下方式编写：

```cpp
int* number = malloc(sizeof(int) * 5); 
```

C++禁止隐式转换，要求这些示例按照以下方式编写：

```cpp
void* pointer; 
int* number = (int*) pointer; 
```

它们也可以按照以下方式编写：

```cpp
int* number = (int*) malloc(sizeof(int) * 5); 
```

由于我们明确指定了要转换到的类型，我们可以确信在编译时任何类型转换都会按照我们的预期执行。

同样，如果尝试将没有`const`修饰符的引用赋值给具有`const`修饰符的变量，编译器也会抱怨并抛出错误：

```cpp
const int constNumber = 42; 
int number = &constNumber; // Error: invalid initialization of reference. 
```

为了解决这个问题，你需要显式地转换以下转换：

```cpp
const int constNumber = 42; 
int number = const_cast<int&>(constNumber); 
```

执行这种显式转换绝对是可能的，并且是有效的。但它也可能在稍后使用此引用修改所谓常量值的内时引起巨大的问题和头疼。然而，当你发现自己正在编写前面那样的代码时，可以合理地假设你已经意识到了其影响。

这种显式类型强制的好处是使静态分析比在弱类型语言中更有用和有效。这反过来又有利于运行时安全性，因为任何转换和赋值都最有可能安全且没有意外的副作用。

由于类型系统主要是编译器的特性，而不是任何类型的运行时代码（除了作为异常的运行时类型信息），在 C++中拥有强类型类型系统的开销仅在编译时才会注意到，因为必须在每个变量赋值、操作和转换上执行更严格的检查。

# 类型转换

当一个值被赋给一个兼容的变量，而这个变量不是与值完全相同的类型时，就会发生类型转换。每当存在转换规则时，这种转换可以隐式地进行，否则可以提供显式的提示（转换）给编译器，以调用存在歧义时的特定规则。

与 C 语言只有隐式和显式类型转换不同，C++通过一系列基于模板的函数扩展了这一点，允许你以各种方式转换常规类型和对象（类）：

+   `dynamic_cast <new_type>` (表达式)

+   `reinterpret_cast <new_type>` (表达式)

+   `static_cast <new_type>` (表达式)

+   `const_cast <new_type>` (表达式)

在这里，`dynamic_cast`保证了结果对象的有效性，依赖于**运行时类型信息**（**RTTI**）（参见后面的章节）来实现这一点。`static_cast`与之类似，但不验证结果对象。

接下来，`reinterpret_cast`可以将任何类型转换为任何类型，甚至是不相关的类。这种转换是否有意义取决于开发者，就像常规的显式转换一样。

最后，`const_cast` 很有趣，因为它可以设置或移除一个值的 `const` 状态，这在你需要为单个函数提供一个非 `const` 版本的值时非常有用。然而，这也绕过了类型安全系统，应该非常谨慎地使用。

# 类

**面向对象编程**（**OOP**）自 Simula 时代以来一直存在，Simula 以其运行速度慢而闻名。这导致 Bjarne Stroustrup 将他的 OOP 实现基于快速高效的 C 编程语言。

C++ 使用 C 风格的语言结构来实现对象。当我们查看 C++ 代码及其对应的 C 代码时，这一点变得很明显。

当查看 C++ 类时，我们看到它的典型结构：

```cpp
namespace had { 
using uint8_t = unsigned char; 
const uint8_t bufferSize = 16;  
    class RingBuffer { 
        uint8_t data[bufferSize]; 
        uint8_t newest_index; 
        uint8_t oldest_index;  
        public: 
        enum BufferStatus { 
            OK, EMPTY, FULL 
        };  
        RingBuffer();  
        BufferStatus bufferWrite(const uint8_t byte); 
        enum BufferStatus bufferRead(uint8_t& byte); 
    }; 
} 
```

这个类也位于一个命名空间内（我们将在后面的章节中更详细地探讨），重新定义了 `unsigned char` 类型，定义了一个命名空间全局变量，最后是类的定义本身，包括私有和公共部分。

这段 C++ 代码定义了多个不同的作用域，从命名空间开始，到类结束。类本身在其公共、受保护和私有访问级别上增加了作用域。

同样的代码可以用常规 C 语言实现如下：

```cpp
typedef unsigned char uint8_t; 
enum BufferStatus {BUFFER_OK, BUFFER_EMPTY, BUFFER_FULL}; 
#define BUFFER_SIZE 16 
struct RingBuffer { 
   uint8_t data[BUFFER_SIZE]; 
   uint8_t newest_index; 
   uint8_t oldest_index; 
};  
void initBuffer(struct RingBuffer* buffer); 
enum BufferStatus bufferWrite(struct RingBuffer* buffer, uint8_t byte); 
enum BufferStatus bufferRead(struct RingBuffer* buffer, uint8_t *byte); 
```

`using` 关键字与 `typedef` 类似，因此在这里有直接的映射。我们使用 `const` 而不是 `#define`。`enum` 在 C 和 C++ 中基本上是相同的，只是 C++ 的编译器在使用 `enum` 作为类型时不需要显式标记。对于简化 C++ 代码来说，这也是相同的。

C++ 类本身是用 C 语言实现的，它是一个包含类变量的 `struct`。当创建类实例时，这实际上意味着初始化了这个 `struct` 的一个实例。然后，这个 `struct` 实例的指针会随着 C++ 类中每个函数的调用而传递。

这些基本示例向我们展示的是，与基于 C 的代码相比，我们使用的任何 C++ 功能都没有运行时开销。命名空间、类访问级别（公共、私有和受保护）以及类似功能仅由编译器用于验证正在编译的代码。

C++ 代码的一个优点是，尽管性能相同，但它需要的代码更少，同时允许你定义严格的接口访问级别，并在类被销毁时调用析构函数，从而自动清理分配的资源。

使用 C++ 类遵循以下模式：

```cpp
had::RingBuffer r_buffer;  
int main() { 
    uint8_t tempCharStorage;     
    // Fill the buffer. 
    for (int i = 0; r_buffer.bufferWrite('A' + i) == 
    had::RingBuffer::OK; i++)    { 
        // 
    } 
    // Read the buffer. 
    while (r_buffer.bufferRead(tempCharStorage) == had::RingBuffer::OK) 
    { 
         // 
    } 
} 
```

这与 C 版本相比如下：

```cpp
struct RingBuffer buffer;  
int main() { 
    initBuffer(&buffer); 
    uint8_t tempCharStorage;  
    // Fill the buffer. 
    uint8_t i = 0; 
    for (; bufferWrite(&buffer, 'A' + i) == BUFFER_OK; i++) {          
        // 
    }  
    // Read the buffer. 
    while (bufferRead(&buffer, &tempCharStorage) == BUFFER_OK) { // 
    } 
} 
```

使用 C++ 类与使用 C 风格的方法没有太大区别。不需要在每次功能调用时手动传递分配的 `struct` 实例，而是调用类方法，这可能是最大的区别。这个实例仍然以 `this` 指针的形式存在，它指向类实例。

尽管 C++示例在`RingBuffer`类中使用了命名空间和内嵌枚举，但这些只是可选特性。一个人仍然可以使用全局枚举，或者在命名空间的作用域内，或者有多个命名空间层。这很大程度上取决于应用程序的需求。

关于使用类别的成本，本节中的示例版本是为之前提到的《代码工艺》系列中的 Arduino UNO（ATMega328 MCU）和 Arduino Due（AT91SAM3X8E MCU）开发板编译的，以下为编译后的代码文件大小：

|  | **Uno** | **Due** |  |  |
| --- | --- | --- | --- | --- |
| **C** | **C++** | **C** | **C++** |  |
| **全局作用域数据** | 614 | 652 | 11,184 | 11,196 |
| **主作用域数据** | 664 | 664 | 11,200 | 11,200 |
| **四个实例** | 638 | 676 | 11,224 | 11,228 |

为这些代码文件大小设置的优化设置是`-O2`。

在这里，我们可以看到，一旦编译，C++代码与 C 代码相同，除非我们在初始化全局类实例时执行初始化，因为为此添加的代码，对于 UNO 来说，总共是 38 字节。

由于这个代码只需要存在一个实例，这是一个我们只需要支付一次的固定成本：在第一行和最后一行，我们有一个和四个类实例或它们的等效物，但在 UNO 固件中只有额外的 38 字节。对于 Due 固件，我们可以看到类似的情况，尽管不是那么明显。这种差异可能受到某些其他设置或优化的影响。

这告诉我们，有时我们不想让编译器为我们初始化一个类，但如果我们需要那些最后的几个 ROM 或 RAM 字节，我们应该自己来做。然而，这种情况通常不会成为问题。

# 继承

除了允许你将代码组织成对象外，类还允许通过使用多态，使类成为其他类的模板。在 C++中，我们可以将任意数量的类的属性组合成一个新的类，给它自定义的属性和方法。

这是一种创建**用户定义类型**（**UDTs**）的有效方法，特别是当与运算符重载结合使用时，可以使用常见的运算符来定义 UDT 的操作，如加法、减法等。

C++中的继承遵循以下模式：

```cpp
class B : public A { // Private members. public: // Additional public members. }; 
```

在这里，我们声明了一个类，`B`，它从类`A`派生。这允许我们使用在类 A 中定义的任何公共方法，在类 B 的实例上，就像它们一开始就在后者中定义一样。

所有这些都相当容易理解，即使当我们开始从多个基类派生时，事情可能会变得有些混乱。然而，通过适当的规划和设计，多态可以是一个非常强大的工具。

不幸的是，这些都未能回答使用多态给我们的代码增加多少开销的问题。我们之前看到，C++类本身在运行时不会增加开销，但是通过从一个或多个基类派生，预期的代码将变得更加复杂。

幸运的是，情况并非如此。与简单的类类似，由此产生的派生类是底层类实现所基于的基结构的简单组合。继承过程本身以及随之而来的验证主要是编译时的问题，为开发者带来了各种好处。

# 虚基类

有时，基类为类方法实现一个实现并没有太多意义，但与此同时，我们希望强制任何派生类实现该方法。这个问题的答案是虚方法。

考虑以下类定义：

```cpp
class A { 
public: 
   virtual bool methodA() = 0; 
   virtual bool methodB() = 0; 
}; 
```

如果我们尝试从这个类派生，我们必须实现这两个类方法，否则会得到编译器错误。由于基类中的两个方法都是虚的，整个基类被称为虚基类。这在当你希望定义一个可以被一系列不同类实现的接口，同时保持只有一个用户定义类型可以引用的便利性时特别有用。

在内部，像这样的虚方法是通过使用`vtables`（虚拟表）来实现的，这是虚拟表的简称。这是一个数据结构，它包含每个虚方法的一个内存地址（指针），该指针指向该方法的实现：

```cpp
VirtualClass* → vtable_ptr → vtable[0] → methodA() 
```

我们可以将这种间接级别与 C 风格代码和具有直接方法调用的类在性能影响上的比较。Code Craft 文章关于虚函数的计时([`hackaday.com/2015/11/13/code-craft-embedding-c-timing-virtual-functions/`](https://hackaday.com/2015/11/13/code-craft-embedding-c-timing-virtual-functions/))描述了这种方法，并有一些有趣的发现：

|  | `Uno` | `Due` |  |  |
| --- | --- | --- | --- | --- |
| `Os` | `O2` | `Os` | `O2` |  |
| **C 函数调用** | 10.4 | 10.2 | 3.7 | 3.6 |
| **C++直接调用** | 10.4 | 10.3 | 3.8 | 3.8 |
| **C++虚函数调用** | 11.1 | 10.9 | 3.9 | 3.8 |
| **多次 C 函数调用** | 110.4 | 106.3 | 39.4 | 35.5 |
| **C 函数指针调用** | 105.7 | 102.9 | 38.6 | 34.9 |
| **C++虚函数调用** | 103.2 | 100.4 | 39.5 | 35.2 |

这里列出的所有时间都是以微秒为单位的。

与比较 C 代码和 C++类编译输出大小的测试一样，这个测试使用了相同的两个 Arduino 开发板。使用了两种不同的优化级别来比较这种编译设置的影响：`-Os`优化结果二进制文件的大小（以字节为单位），而`-O2`设置以比`-O1`优化级别更激进的方式优化速度。

从这些时间测量中，我们可以肯定地说，虚方法引入的间接层是可测量的，尽管不是非常显著，在 Arduino Uno 开发板上的 ATMega328 上增加了整整 0.7 微秒，而在更快的基于 ARM 的板上大约增加了 0.1 微秒。

即使在绝对意义上，使用虚类方法并不足以带来足够的性能损失，以至于真正需要重新考虑其使用，除非性能至关重要，而这主要是在较慢的 MCU 上。MCU 的 CPU 越快，其使用的影响就越小。

# 函数内联

C++中的 inline 关键字是向编译器的一个提示，告知我们希望每个以该关键字开头名称的函数调用都直接执行该函数的实现，而不是将其复制到调用位置，从而跳过函数调用的开销。

这是一个编译时优化，它只将函数实现的大小添加到编译器输出中，对于每个不同的内联函数调用只添加一次。

# 运行时类型信息

RTTI 的主要目的是允许使用安全类型转换，例如使用`dynamic_cast<>`运算符。由于 RTTI 涉及为每个多态类存储额外的信息，因此它有一定的开销。

这是一个运行时特性，正如其名称所暗示的，因此如果你不需要它提供的功能，可以将其禁用。在某些嵌入式平台上，禁用 RTTI 是一种常见的做法，尤其是在低资源平台（如 8 位 MCU）上，因为 RTTI 很少被使用。

# 异常处理

异常在桌面平台上通常被广泛使用，提供了一种生成异常以处理错误条件的方法，这些异常可以在 try/catch 块中被捕获和处理。

虽然异常支持本身并不昂贵，但生成异常相对较贵，需要大量的 CPU 时间和 RAM 来准备和处理异常。你还得确保捕获每一个异常，否则可能会面临应用程序在没有明显原因的情况下终止的风险。

异常处理与调用方法返回码检查之间的区别需要根据具体情况来决定，也可能是个人的偏好问题。这需要一种相当不同的编程风格，可能并不适合所有人。

# 模板

人们常常认为 C++中的模板非常重，使用它们会带来严重的性能损失。这完全忽略了模板的本质，即模板仅仅是为了作为一个简写方法，用于从单个模板自动生成几乎相同的代码——因此得名。

这实际上意味着，对于任何定义的函数或类模板，编译器都会在每次引用模板时生成模板的内置实现。

这是我们经常在 C++ **标准模板库**（**STL**）中看到的一种模式，正如其名所示，它大量使用了模板。以一个像地图这样的数据结构为例：

```cpp
std::map<std::string, int> myMap; 
```

这里发生的情况是，编译器取走了 `std::map` 的单一模板，以及我们在尖括号内提供的模板参数，填充模板，并在其位置写入内联实现。

实际上，我们得到了与手动编写整个数据结构实现相同的实现，专门针对这两种类型。由于替代方案是手动为每个可能的可实现内置类型和额外用户定义类型编写实现，因此使用泛型模板可以节省我们大量时间，而不会牺牲性能。

# 标准模板库

C++ 的标准库（STL）包含了一个全面且不断增长的函数、类等集合，允许执行常见任务而无需依赖外部库。STL 字符串类非常受欢迎，允许你安全地处理字符串，而无需处理空终止符等类似问题。

大多数嵌入式平台支持 STL 的全部或至少大部分，除了对可用 RAM 等的限制，这阻止了完整哈希表和其他复杂数据结构的实现。许多嵌入式 STL 实现针对目标平台进行了优化，最小化了 RAM 和 CPU 的使用。

# 可维护性

在前面的章节中，我们看到了 C++ 提供的许多特性，以及它们在资源受限平台上的可行性。使用 C++ 的一大优势是通过使用模板，可以减少代码大小，同时使用类、命名空间等对代码库进行组织和模块化。

通过在代码中追求更模块化的方法，模块间有清晰的接口，代码在项目间的重用变得更加可行。这也有助于简化代码的维护，因为这样做可以使代码特定部分的函数更清晰，并为单元和集成测试提供明确的目标。

# 摘要

在本章中，我们探讨了为什么你想在嵌入式开发中使用 C++ 的重大问题。我们看到了，由于 C++ 的开发特性，它高度优化了资源受限平台，同时提供了大量对项目管理和组织至关重要的特性。

到目前为止，读者应该能够描述 C++ 的主要特性，并为每个特性提供具体的例子。在编写 C++ 代码时，读者将清楚地了解特定语言特性的成本，能够根据空间和内存限制，推理出为什么某个代码段的实现比另一个实现更可取。

在下一章中，我们将探讨基于**单板计算机**（**SBCs**）及其类似系统的嵌入式 Linux 和类似系统的开发过程。
