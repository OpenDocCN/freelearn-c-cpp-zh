<html><head></head><body>
<div id="_idContainer010">
<h1 class="chapter-number" id="_idParaDest-24"><a id="_idTextAnchor043"/><span class="koboSpan" id="kobo.1.1">2</span></h1>
<h1 id="_idParaDest-25"><a id="_idTextAnchor044"/><span class="koboSpan" id="kobo.2.1">Class and Function Templates</span></h1>
<p><span class="koboSpan" id="kobo.3.1">The template programming features of C++ form a large and complex subject, with many books dedicated exclusively to teaching these features. </span><span class="koboSpan" id="kobo.3.2">In this book, we will use many of the advanced C++ generic programming features. </span><span class="koboSpan" id="kobo.3.3">How, then, should we prepare ourselves to understand these language constructs as they make their appearance throughout this book? </span><span class="koboSpan" id="kobo.3.4">This chapter takes an informal approach—instead of precise definitions, we demonstrate the use of templates through examples and explain what the different language features do. </span><span class="koboSpan" id="kobo.3.5">If you find your knowledge lacking at this point, you’re encouraged to seek a deeper understanding and read one or more of the books dedicated entirely to the C++ language that are focused on explaining its syntax and semantics. </span><span class="koboSpan" id="kobo.3.6">Of course, if you wish for a more precise, formal description, you can refer to the C++ standard or a </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">reference book.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">The following topics will be covered in </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">Templates </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">in C++</span></span></li>
<li><span class="koboSpan" id="kobo.9.1">Class and </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">function templates</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.11.1">Template instantiations</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.12.1">Template specializations</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Overloading of </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">template functions</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.15.1">Variadic templates</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.16.1">Lambda expressions</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.17.1">Concepts</span></span></li>
</ul>
<h1 id="_idParaDest-26"><a id="_idTextAnchor045"/><a id="_idTextAnchor046"/><a id="_idTextAnchor047"/><span class="koboSpan" id="kobo.18.1">Templates in C++</span></h1>
<p><span class="koboSpan" id="kobo.19.1">One of the greatest</span><a id="_idIndexMarker064"/><span class="koboSpan" id="kobo.20.1"> strengths of C++ is its support for generic programming. </span><span class="koboSpan" id="kobo.20.2">In generic programming, the algorithms and data structures are written in terms of generic types that will be specified later. </span><span class="koboSpan" id="kobo.20.3">This allows the programmer to implement a function or a class once, and later, instantiate it for many different types. </span><span class="koboSpan" id="kobo.20.4">Templates are a C++ feature that allows classes and functions to be defined on generic types. </span><span class="koboSpan" id="kobo.20.5">C++ supports three kinds of templates—function, class, and </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">variable templates.</span></span><a id="_idTextAnchor048"/></p>
<h2 id="_idParaDest-27"><a id="_idTextAnchor049"/><span class="koboSpan" id="kobo.22.1">Function templates</span></h2>
<p><span class="koboSpan" id="kobo.23.1">Function templates</span><a id="_idIndexMarker065"/><span class="koboSpan" id="kobo.24.1"> are generic functions—unlike regular </span><a id="_idIndexMarker066"/><span class="koboSpan" id="kobo.25.1">functions, a template function does not declare its argument types. </span><span class="koboSpan" id="kobo.25.2">Instead, the types are </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">template parameters:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.27.1">
// Example 01
template &lt;typename T&gt;
T increment(T x) { return x + 1; }</span></pre>
<p><span class="koboSpan" id="kobo.28.1">This template function can be used to increment a value of any type by one, for which adding one is a </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">valid operation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.30.1">
increment(5);    // T is int, returns 6
increment(4.2);    // T is double, return 5.2 char c[10];
increment(c);    // T is char*, returns &amp;c[1]</span></pre>
<p><span class="koboSpan" id="kobo.31.1">Most template functions have some limitations on the types that are used as their template parameters. </span><span class="koboSpan" id="kobo.31.2">For example, our </span><strong class="source-inline"><span class="koboSpan" id="kobo.32.1">increment()</span></strong><span class="koboSpan" id="kobo.33.1"> function requires that the expression </span><strong class="source-inline"><span class="koboSpan" id="kobo.34.1">x + 1</span></strong><span class="koboSpan" id="kobo.35.1"> is valid for the type of </span><strong class="source-inline"><span class="koboSpan" id="kobo.36.1">x</span></strong><span class="koboSpan" id="kobo.37.1">. </span><span class="koboSpan" id="kobo.37.2">Otherwise, the attempt to instantiate the template will fail, with a somewhat verbose </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">compilation error.</span></span></p>
<p><span class="koboSpan" id="kobo.39.1">Both non-member and class member functions can be function templates; however, virtual functions cannot be templates. </span><span class="koboSpan" id="kobo.39.2">The generic types can be used not only to declare function parameters but to declare any variables inside the body of </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">the function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.41.1">
template &lt;typename T&gt; T sum(T from, T to, T step) {
  T res = from;
  while ((from += step) &lt; to) { res += from; }
  return res;
}</span></pre>
<p><span class="koboSpan" id="kobo.42.1">In C++20, simple template declarations can be abbreviated: instead </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">of writing</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.44.1">
template &lt;typename T&gt; void f(T t);</span></pre>
<p><span class="koboSpan" id="kobo.45.1">we </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">can write</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.47.1">
// Example 01a
void f(auto t);</span></pre>
<p><span class="koboSpan" id="kobo.48.1">Other than more terse declarations, there is no particular advantage to this abbreviation, and the feature is quite limited. </span><span class="koboSpan" id="kobo.48.2">First of all, </span><strong class="source-inline"><span class="koboSpan" id="kobo.49.1">auto</span></strong><span class="koboSpan" id="kobo.50.1"> can be used only as the “top-level” parameter type; for example, this is invalid (but allowed by </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">some compilers):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.52.1">
void f(std::vector&lt;auto&gt;&amp; v);</span></pre>
<p><span class="koboSpan" id="kobo.53.1">and must still be </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">written as</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.55.1">
template &lt;typename T&gt; void f(std::vector&lt;T&gt;&amp; v);</span></pre>
<p><span class="koboSpan" id="kobo.56.1">Also, if you need to use template type parameters elsewhere in the function declaration, you can’t </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">abbreviate them:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.58.1">
template &lt;typename T&gt; T f(T t);</span></pre>
<p><span class="koboSpan" id="kobo.59.1">Of course, you could declare the return type as </span><strong class="source-inline"><span class="koboSpan" id="kobo.60.1">auto</span></strong><span class="koboSpan" id="kobo.61.1"> and use the trailing </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">return type:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.63.1">
auto f(auto t) -&gt; decltype(t);</span></pre>
<p><span class="koboSpan" id="kobo.64.1">but at this </span><a id="_idIndexMarker067"/><span class="koboSpan" id="kobo.65.1">point, the</span><a id="_idIndexMarker068"/><span class="koboSpan" id="kobo.66.1"> template is not </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">really “abbreviated.”</span></span></p>
<p><span class="koboSpan" id="kobo.68.1">We will see more of function templates later, but let’s introduce class </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">templates n</span><a id="_idTextAnchor050"/><a id="_idTextAnchor051"/><span class="koboSpan" id="kobo.70.1">ext.</span></span></p>
<h2 id="_idParaDest-28"><a id="_idTextAnchor052"/><span class="koboSpan" id="kobo.71.1">Class templates</span></h2>
<p><span class="koboSpan" id="kobo.72.1">Class templates</span><a id="_idIndexMarker069"/><span class="koboSpan" id="kobo.73.1"> are classes that use generic types, usually to declare</span><a id="_idIndexMarker070"/><span class="koboSpan" id="kobo.74.1"> their data members, but also to declare methods and local variables </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">inside them:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.76.1">
// Example 02
template &lt;typename T&gt; class ArrayOf2 {
  public:
  T&amp; operator[](size_t i) { return a_[i]; }
  const T&amp; operator[](size_t i) const { return a_[i]; }
  T sum() const { return a_[0] + a_[1]; }
  private:
  T a_[2];
};</span></pre>
<p><span class="koboSpan" id="kobo.77.1">This class is implemented once, and can then be used to define an array of two elements of </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">any type:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.79.1">
ArrayOf2&lt;int&gt; i; i[0] = 1; i[1] = 5;
std::cout &lt;&lt; i.sum();                       // 6
ArrayOf2&lt;double&gt; x; x[0] = -3.5; x[1] = 4;
std::cout &lt;&lt; x.sum();                       // 0.5
ArrayOf2&lt;char*&gt; c; char s[] = "Hello";
c[0] = s; c[1] = s + 2;</span></pre>
<p><span class="koboSpan" id="kobo.80.1">Pay particular</span><a id="_idIndexMarker071"/><span class="koboSpan" id="kobo.81.1"> attention to the last example—you might expect</span><a id="_idIndexMarker072"/><span class="koboSpan" id="kobo.82.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">ArrayOf2</span></strong><span class="koboSpan" id="kobo.84.1"> template not to be valid with a type such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">char*</span></strong><span class="koboSpan" id="kobo.86.1">—after all, it has a method, </span><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">sum()</span></strong><span class="koboSpan" id="kobo.88.1">, that does not compile if the type of </span><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">a_[0]</span></strong><span class="koboSpan" id="kobo.90.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.91.1">a_[1]</span></strong><span class="koboSpan" id="kobo.92.1"> is a pointer. </span><span class="koboSpan" id="kobo.92.2">However, our example compiles as written—a method of a class template does not have to be valid until we try to use it. </span><span class="koboSpan" id="kobo.92.3">If we never call </span><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">c.sum()</span></strong><span class="koboSpan" id="kobo.94.1">, then the fact that it would not compile never comes up,</span><a id="_idTextAnchor053"/><span class="koboSpan" id="kobo.95.1"> and the program remains valid. </span><span class="koboSpan" id="kobo.95.2">If we do call a member function that does not compile for the chosen template arguments, we get a syntax error in the body of the template (in our example, something about not being able to add two pointers). </span><span class="koboSpan" id="kobo.95.3">These error messages are rarely straightforward. </span><span class="koboSpan" id="kobo.95.4">Even if they were, it is unclear if the problem is in the body of the function, or if the function was not supposed to be called in the first place. </span><span class="koboSpan" id="kobo.95.5">Later in this chapter, we will see how to improve </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">this si</span><a id="_idTextAnchor054"/><span class="koboSpan" id="kobo.97.1">tuation.</span></span></p>
<h2 id="_idParaDest-29"><a id="_idTextAnchor055"/><span class="koboSpan" id="kobo.98.1">Variable templates</span></h2>
<p><span class="koboSpan" id="kobo.99.1">The last kind of</span><a id="_idIndexMarker073"/><span class="koboSpan" id="kobo.100.1"> template in C++ is a variable template, which</span><a id="_idIndexMarker074"/><span class="koboSpan" id="kobo.101.1"> was introduced in C++14. </span><span class="koboSpan" id="kobo.101.2">This template allows us to define a variable with a </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">generic type:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.103.1">
// Example 03
template &lt;typename T&gt; constexpr T pi =
T(3.1415926535897932384626433832795028841971693993751058209749445</span><a id="_idTextAnchor056"/><span class="koboSpan" id="kobo.104.1">9230781L);
pi&lt;float&gt;;      // 3.141592
pi&lt;double&gt;;     // 3.14159</span><a id="_idTextAnchor057"/><span class="koboSpan" id="kobo.105.1">2653589793</span></pre>
<p><span class="koboSpan" id="kobo.106.1">Variable templates are, for the most part, very straightforward to use, mostly for defining your own constants, but there are some interesting patterns that take advantage of them; we will see one in the </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">nex</span><a id="_idTextAnchor058"/><span class="koboSpan" id="kobo.108.1">t section.</span></span></p>
<h2 id="_idParaDest-30"><a id="_idTextAnchor059"/><span class="koboSpan" id="kobo.109.1">Non-type template parameters</span></h2>
<p><span class="koboSpan" id="kobo.110.1">Usually, template</span><a id="_idIndexMarker075"/><span class="koboSpan" id="kobo.111.1"> parameters are types, but C++ also</span><a id="_idIndexMarker076"/><span class="koboSpan" id="kobo.112.1"> allows for several kinds of non-type parameters. </span><span class="koboSpan" id="kobo.112.2">First of all, template parameters can be values of integer or </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">enumeration types:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.114.1">
// Example 04
template &lt;typename T, size_t N&gt; class Array {
  public:
  T&amp; operator[](size_t i) {
    if (i &gt;= N) throw std::out_of_range("Bad index");
     return data_[i];
  }
  private:
  T data_[N];
};
Array&lt;int, 5&gt; a;      // OK
cin &gt;&gt; a[0];
Array&lt;int, a[0]&gt; b;   // Error</span></pre>
<p><span class="koboSpan" id="kobo.115.1">This is a template with two parameters—the first is a type, but the second is not. </span><span class="koboSpan" id="kobo.115.2">It is a value of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">size_t</span></strong><span class="koboSpan" id="kobo.117.1"> that determines the size of the array; the advantage of such a template over a built-in C-style array is that it can do range checking. </span><span class="koboSpan" id="kobo.117.2">The C++ standard library has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">std::array</span></strong><span class="koboSpan" id="kobo.119.1"> class template that should be used instead of implementing your own array in any real program, but it does make for an </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">easy-to-follow example.</span></span></p>
<p><span class="koboSpan" id="kobo.121.1">The values of non-type parameters that are used to instantiate a template must be compile-time constants or </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">constexpr</span></strong><span class="koboSpan" id="kobo.123.1"> values—the last line in the preceding example is invalid because the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">a[0]</span></strong><span class="koboSpan" id="kobo.125.1"> is not known until the program reads it in at runtime. </span><span class="koboSpan" id="kobo.125.2">C++20 allows floating-point and user-defined types for non-type template parameters; until then, the parameters were limited to integral types, pointers (including function and member pointers), references, and enumerations. </span><span class="koboSpan" id="kobo.125.3">Of course, the value of a non-type parameter has to be a compile-time constant so, for example, pointers to local variables are </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">not allowed.</span></span></p>
<p><span class="koboSpan" id="kobo.127.1">The numeric template parameters used to be very popular </span><a id="_idIndexMarker077"/><span class="koboSpan" id="kobo.128.1">in C++ because they allow complex compile-time calculations to be implemented, but in the recent versions of the standard, </span><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">constexpr</span></strong><span class="koboSpan" id="kobo.130.1"> functions can be used to the same effect and are much easier to read. </span><span class="koboSpan" id="kobo.130.2">Of course, the standard takes with one hand and gives with the other, and so an interesting new use case emerged for non-template parameters combined with </span><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">constexpr</span></strong><span class="koboSpan" id="kobo.132.1"> functions: these functions, first introduced in C++11, are used to define “immediate functions,” or functions that are evaluated at compile time. </span><span class="koboSpan" id="kobo.132.2">The problem with </span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">constexpr</span></strong><span class="koboSpan" id="kobo.134.1"> functions is that they </span><em class="italic"><span class="koboSpan" id="kobo.135.1">may</span></em><span class="koboSpan" id="kobo.136.1"> evaluate at compile time but it’s not required; they could also be evaluated at </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">run time:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.138.1">
constexpr size_t length(const char* s) {
  size_t res = 0;
  while (*(s++)) ++res;
  return res;
}
std::cout &lt;&lt; length("abc") &lt;&lt; std::endl;
char s[] = "runtime";
std::cout &lt;&lt; length(s) &lt;&lt; std::endl;</span></pre>
<p><span class="koboSpan" id="kobo.139.1">Here we have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.140.1">constexpr</span></strong><span class="koboSpan" id="kobo.141.1"> function </span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">length()</span></strong><span class="koboSpan" id="kobo.143.1">. </span><span class="koboSpan" id="kobo.143.2">Does the length computation actually happen at compile time? </span><span class="koboSpan" id="kobo.143.3">There is no way to know short of examining the generated assembly code (which can differ from one compiler to another). </span><span class="koboSpan" id="kobo.143.4">The only way to be sure is to invoke the function in a compile-time context, </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">for example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.145.1">
static_assert(length("abc") == 3, ""); // OK
char s[] = "runtime";
static_assert(length(s) == 7, ""); // Fails</span></pre>
<p><span class="koboSpan" id="kobo.146.1">The first assert compiles, and the second does not even though the value 7 is correct: the argument is not a compile-time value, so the evaluation must happen at </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">run time.</span></span></p>
<p><span class="koboSpan" id="kobo.148.1">In C++20, the function may be declared </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">consteval</span></strong><span class="koboSpan" id="kobo.150.1"> instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">constexpr</span></strong><span class="koboSpan" id="kobo.152.1">: this guarantees that the evaluation happens at compile time or not at all (thus, the second </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">cout</span></strong><span class="koboSpan" id="kobo.154.1"> statement in </span><a id="_idIndexMarker078"/><span class="koboSpan" id="kobo.155.1">the preceding example </span><a id="_idIndexMarker079"/><span class="koboSpan" id="kobo.156.1">will not compile). </span><span class="koboSpan" id="kobo.156.2">Prior to C++20, we have to get creative. </span><span class="koboSpan" id="kobo.156.3">Here is one way to enforce </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">compile-time execution:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.158.1">
// Example 05c
template &lt;auto V&gt;
static constexpr auto force_consteval = V;</span></pre>
<p><span class="koboSpan" id="kobo.159.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">force_consteval</span></strong><span class="koboSpan" id="kobo.161.1"> variable template can be used to enforce compile-time evaluation </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.163.1">
std::cout &lt;&lt; force_consteval&lt;length("abc")&gt; &lt;&lt; std::endl;
char s[] = "runtime";
std::cout &lt;&lt; force_consteval&lt;length(s)&gt; &lt;&lt; std::endl;</span></pre>
<p><span class="koboSpan" id="kobo.164.1">The second </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">cout</span></strong><span class="koboSpan" id="kobo.166.1"> statement does not compile because the function </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">length()</span></strong><span class="koboSpan" id="kobo.168.1"> cannot be evaluated as an immediate function. </span><span class="koboSpan" id="kobo.168.2">The variable template </span><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">force_consteval</span></strong><span class="koboSpan" id="kobo.170.1"> uses a non-type template parameter whose type is not specified but deduced from the template argument (an </span><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">auto</span></strong><span class="koboSpan" id="kobo.172.1"> template parameter). </span><span class="koboSpan" id="kobo.172.2">This is a C++17 feature; in C++14 we have to use a rather unelegant macro to achieve the </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">same result:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.174.1">
// Example 05d
template &lt;typename T, T V&gt;
static constexpr auto force_consteval_helper = V;
#define force_consteval(V)
force_consteval_helper&lt;decltype(V), (V)&gt;
std::cout &lt;&lt; force_consteval(length("abc")) &lt;&lt; std::endl;</span></pre>
<p><span class="koboSpan" id="kobo.175.1">If a non-type template parameter seems “less than a type,” you will like the next option, a parameter</span><a id="_idIndexMarker080"/><span class="koboSpan" id="kobo.176.1"> that is definitely more than a</span><a id="_idIndexMarker081"/> <span class="No-Break"><span class="koboSpan" id="kobo.177.1">simple type.</span></span></p>
<h2 id="_idParaDest-31"><a id="_idTextAnchor060"/><span class="koboSpan" id="kobo.178.1">Template template parameters</span></h2>
<p><span class="koboSpan" id="kobo.179.1">The second kind of </span><a id="_idIndexMarker082"/><span class="koboSpan" id="kobo.180.1">non-type template parameter</span><a id="_idIndexMarker083"/><span class="koboSpan" id="kobo.181.1"> worth mentioning is a </span><em class="italic"><span class="koboSpan" id="kobo.182.1">template template</span></em><span class="koboSpan" id="kobo.183.1"> parameter—a template parameter that is itself a template. </span><span class="koboSpan" id="kobo.183.2">We will need them in the later chapters of this book. </span><span class="koboSpan" id="kobo.183.3">This template parameter is substituted—not with a name of a class, but a name of an </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">entire template.</span></span></p>
<p><span class="koboSpan" id="kobo.185.1">Here is a class template with a template </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">template parameter:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.187.1">
// Example 06a
template &lt;typename T,
         template &lt;typename&gt; typename Container&gt;
class Builder {
  Container&lt;T&gt; data_;
  public:
  void add(const T&amp; t) { data_.push_back(t); }
  void print() const {
    for (const auto&amp; x : data_) std::cout &lt;&lt; x &lt;&lt; " ";
    std::cout &lt;&lt; std::endl;
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.188.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">Builder</span></strong><span class="koboSpan" id="kobo.190.1"> template declares a class that is used to construct (build) a container of an arbitrary type </span><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">T</span></strong><span class="koboSpan" id="kobo.192.1">. </span><span class="koboSpan" id="kobo.192.2">The container itself does not have a specific type, it’s a </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">template itself.</span></span></p>
<p><span class="koboSpan" id="kobo.194.1">It can be instantiated with any container template that takes one </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">type argument:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.196.1">
template &lt;typename T&gt; class my_vector { … };
Builder&lt;int, my_vector&gt; b;
b.add(1);
b.add(2);
b.print();</span></pre>
<p><span class="koboSpan" id="kobo.197.1">Of course, there are additional requirements on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">Container</span></strong><span class="koboSpan" id="kobo.199.1"> template: it must have a single type parameter </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">T</span></strong><span class="koboSpan" id="kobo.201.1"> (the rest may be defaulted), it should be default-constructible, it must have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.202.1">push_back()</span></strong><span class="koboSpan" id="kobo.203.1"> method, and so on. </span><span class="koboSpan" id="kobo.203.2">C++20 gives us a concise way to state these requirements and make them a part of the template interface; we will learn about it later in this chapter, in the </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.204.1">Concepts</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.205.1"> section.</span></span></p>
<p><span class="koboSpan" id="kobo.206.1">Here is a function </span><a id="_idIndexMarker084"/><span class="koboSpan" id="kobo.207.1">template that has two template </span><a id="_idIndexMarker085"/><span class="No-Break"><span class="koboSpan" id="kobo.208.1">template parameters:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.209.1">
// Example 06b
template &lt;template &lt;typename&gt; class Out_container,
          template &lt;typename&gt; class In_container,</span><a id="_idTextAnchor061"/><span class="koboSpan" id="kobo.210.1">
          typename T&gt; Out_container&lt;T&gt;
resequence(const In_container&lt;T&gt;&amp; in_container) {
  Out_container&lt;T&gt; out_container;
  for (auto x : in_container) {
    out_container.push_back(x);
  }
  return out_container;
}</span></pre>
<p><span class="koboSpan" id="kobo.211.1">This function takes an arbitrary container as an argument and returns another container, a different template, but instantiated on the same type, with the values copied from the </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">input container:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.213.1">
my_vector&lt;int&gt; v { 1, 2, 3, 4, 5 };
template &lt;typename T&gt; class my_deque { … };
auto d = resequence&lt;my_deque&gt;(v);// my_deque with 1 … 5</span></pre>
<p><span class="koboSpan" id="kobo.214.1">Note that the compiler deduces both the type of the template argument (</span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">In_container</span></strong><span class="koboSpan" id="kobo.216.1"> as </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">my_vector</span></strong><span class="koboSpan" id="kobo.218.1">) and the type of its template parameter (</span><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">T</span></strong><span class="koboSpan" id="kobo.220.1"> as </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">int</span></strong><span class="koboSpan" id="kobo.222.1">). </span><span class="koboSpan" id="kobo.222.2">Of course, the remaining template parameter </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">Out_container</span></strong><span class="koboSpan" id="kobo.224.1"> cannot be deduced (it is not used in any parameters of the template function) and must be explicitly specified, which fits our </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">intended use.</span></span></p>
<p><span class="koboSpan" id="kobo.226.1">There is a major limitation on template template parameters that is made more complex by the fact that different compilers enforce it unevenly (i.e., some compilers let through the code that should not compile but you would really like it to). </span><span class="koboSpan" id="kobo.226.2">The limitation is that the number of template parameters specified for the template template must match</span><a id="_idIndexMarker086"/><span class="koboSpan" id="kobo.227.1"> the number of the </span><a id="_idIndexMarker087"/><span class="koboSpan" id="kobo.228.1">template parameters of the argument. </span><span class="koboSpan" id="kobo.228.2">Consider this </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">template function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.230.1">
template &lt;template &lt;typename&gt; class Container, typename T&gt;
void print(const Container&lt;T&gt;&amp; container) {
  for (auto x : container) { std::cout &lt;&lt; x &lt;&lt; " "; }
  std::cout &lt;&lt; std::endl;
}
std::vector&lt;int&gt; v { 1, 2, 3, 4, 5 };
print(v);</span></pre>
<p><span class="koboSpan" id="kobo.231.1">This code may compile, but it depends on the version of the standard and the compiler’s strict adherence to the standard: the </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">std::vector</span></strong><span class="koboSpan" id="kobo.233.1"> template has two template parameters, not one. </span><span class="koboSpan" id="kobo.233.2">The second parameter is the allocator; it has a default value, which is why we do not have to specify the allocator type when declaring a vector object. </span><span class="koboSpan" id="kobo.233.3">GCC, Clang, and MSVC all relax this requirement to some degree (but not to the same degree). </span><span class="koboSpan" id="kobo.233.4">Variadic templates, which we will see later in this chapter, offer another, more robust solution (at least in C++17 </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">and later).</span></span></p>
<p><span class="koboSpan" id="kobo.235.1">Templates are a kind of recipe for generating code. </span><span class="koboSpan" id="kobo.235.2">Next, we will</span><a id="_idTextAnchor062"/><span class="koboSpan" id="kobo.236.1"> see how we can convert these recipes into </span><a id="_idTextAnchor063"/><span class="koboSpan" id="kobo.237.1">actual code we </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">can run.</span></span></p>
<h1 id="_idParaDest-32"><a id="_idTextAnchor064"/><span class="koboSpan" id="kobo.239.1">Template instantiations</span></h1>
<p><span class="koboSpan" id="kobo.240.1">The template</span><a id="_idIndexMarker088"/><span class="koboSpan" id="kobo.241.1"> name is not a type and cannot be used to declare a variable or call a function. </span><span class="koboSpan" id="kobo.241.2">To create a type or a function, the template must be instantiated. </span><span class="koboSpan" id="kobo.241.3">Most of the time, templates are instantiated implicitly when they are used. </span><a id="_idTextAnchor065"/><span class="koboSpan" id="kobo.242.1">We will again start </span><a id="_idTextAnchor066"/><span class="koboSpan" id="kobo.243.1">with </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">function templates.</span></span></p>
<h2 id="_idParaDest-33"><a id="_idTextAnchor067"/><span class="koboSpan" id="kobo.245.1">Function templates</span></h2>
<p><span class="koboSpan" id="kobo.246.1">To use a function </span><a id="_idIndexMarker089"/><span class="koboSpan" id="kobo.247.1">template to generate a function, we have to specify which types should be used for all template type parameters. </span><span class="koboSpan" id="kobo.247.2">We can just specify the </span><span class="No-Break"><span class="koboSpan" id="kobo.248.1">types directly:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.249.1">
template &lt;typename T&gt; T half(T x) { return x/2; }
int i = half&lt;int&gt;(5);</span></pre>
<p><span class="koboSpan" id="kobo.250.1">This instantiates the </span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">half</span></strong><span class="koboSpan" id="kobo.252.1"> function template with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">int</span></strong><span class="koboSpan" id="kobo.254.1"> type. </span><span class="koboSpan" id="kobo.254.2">The type is explicitly specified; we could call the function with an argument of another type, as long as it is convertible to the type </span><span class="No-Break"><span class="koboSpan" id="kobo.255.1">we requested:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.256.1">
double x = half&lt;double&gt;(5);</span></pre>
<p><span class="koboSpan" id="kobo.257.1">Even though the argument is an </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">int</span></strong><span class="koboSpan" id="kobo.259.1">, the instantiation is that of </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">half&lt;double&gt;</span></strong><span class="koboSpan" id="kobo.261.1">, and the return type is </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">double</span></strong><span class="koboSpan" id="kobo.263.1">. </span><span class="koboSpan" id="kobo.263.2">The integer value </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">5</span></strong><span class="koboSpan" id="kobo.265.1"> is implicitly converted </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">double</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.268.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.269.1">Even though every function template can be instantiated by specifying all its type parameters, this is rarely done. </span><span class="koboSpan" id="kobo.269.2">Most of the uses of function templates involve the automatic deduction of types. </span><span class="koboSpan" id="kobo.269.3">Consider </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.271.1">
auto x = half(8);    // int
auto y = half(1.5);    // double</span></pre>
<p><span class="koboSpan" id="kobo.272.1">The template type can be deduced only from the template function arguments—the compiler will attempt to select the type for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">T</span></strong><span class="koboSpan" id="kobo.274.1"> parameter to match the type of the function argument that is declared with the same type. </span><span class="koboSpan" id="kobo.274.2">In our case, the function template has the argument </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">x</span></strong><span class="koboSpan" id="kobo.276.1"> of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">T</span></strong><span class="koboSpan" id="kobo.278.1"> type. </span><span class="koboSpan" id="kobo.278.2">Any call to this function has to provide some value for this argument, and this value must have a type. </span><span class="koboSpan" id="kobo.278.3">The compiler will deduce that </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">T</span></strong><span class="koboSpan" id="kobo.280.1"> must be that type. </span><span class="koboSpan" id="kobo.280.2">In the first call in the preceding code block, the argument is </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">5</span></strong><span class="koboSpan" id="kobo.282.1">, and its type is </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">int</span></strong><span class="koboSpan" id="kobo.284.1">. </span><span class="koboSpan" id="kobo.284.2">There is nothing better to do than to assume that </span><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">T</span></strong><span class="koboSpan" id="kobo.286.1"> should be </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">int</span></strong><span class="koboSpan" id="kobo.288.1"> in this particular template instantiation. </span><span class="koboSpan" id="kobo.288.2">Similarly, in the second call, we can deduce that </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">T</span></strong><span class="koboSpan" id="kobo.290.1"> must </span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">be </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">double</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.294.1">After this deduction, the compiler performs type substitution: all other mentions of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">T</span></strong><span class="koboSpan" id="kobo.296.1"> type are replaced by the type that was deduced; in our case, there is only one other use of </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">T</span></strong><span class="koboSpan" id="kobo.298.1">, which is the </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">return type.</span></span></p>
<p><span class="koboSpan" id="kobo.300.1">Template argument deduction is widely used to capture types that we cannot </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">easily determine:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.302.1">
long x = ...;
unsigned int y = ...;
auto x = half(y + z);</span></pre>
<p><span class="koboSpan" id="kobo.303.1">Here, we deduce the </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">T</span></strong><span class="koboSpan" id="kobo.305.1"> type to be whatever the type of the expression </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">y + z</span></strong><span class="koboSpan" id="kobo.307.1"> is (it’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">long</span></strong><span class="koboSpan" id="kobo.309.1">, but with template deduction, we don’t need to specify that explicitly, and the deduced type will </span><em class="italic"><span class="koboSpan" id="kobo.310.1">follow</span></em><span class="koboSpan" id="kobo.311.1"> the argument type if we ever change the types of </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">y</span></strong><span class="koboSpan" id="kobo.313.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">z</span></strong><span class="koboSpan" id="kobo.315.1">). </span><span class="koboSpan" id="kobo.315.2">Consider the </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.317.1">
template &lt;typename U&gt; auto f(U);
half(f(5));</span></pre>
<p><span class="koboSpan" id="kobo.318.1">We deduce </span><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">T</span></strong><span class="koboSpan" id="kobo.320.1"> to match whatever type the </span><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">f()</span></strong><span class="koboSpan" id="kobo.322.1"> template function returns for an </span><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">int</span></strong><span class="koboSpan" id="kobo.324.1"> argument (of course, the definition of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">f()</span></strong><span class="koboSpan" id="kobo.326.1"> template function has to be provided before it can be called, but we do not need to dig into the header files where </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">f()</span></strong><span class="koboSpan" id="kobo.328.1"> is defined, as the compiler will deduc</span><a id="_idTextAnchor068"/><span class="koboSpan" id="kobo.329.1">e the right type </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">for us).</span></span></p>
<p><span class="koboSpan" id="kobo.331.1">Only the types that are used to declare function arguments can be deduced. </span><span class="koboSpan" id="kobo.331.2">There is no rule that all template type parameters must be somehow present in the argument list, but any parameters that cannot be deduced must be </span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">explicitly specified:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.333.1">
template &lt;typename U, typename V&gt; U half(V x) {
  return x/2;
}
auto y = half&lt;double&gt;(8);</span></pre>
<p><span class="koboSpan" id="kobo.334.1">Here, the first template type parameter is explicitly specified, so </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">U</span></strong><span class="koboSpan" id="kobo.336.1"> is double, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">V</span></strong><span class="koboSpan" id="kobo.338.1"> is deduced to </span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">be </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">int</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.341.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.342.1">Sometimes, the compiler cannot deduce template type parameters, even if they are used to </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">declare arguments:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.344.1">
template &lt;typename T&gt; T Max(T x, T y) {
  return (x &gt; y) ? </span><span class="koboSpan" id="kobo.344.2">x : y;
}
auto x = Max(7L, 11); // Error</span></pre>
<p><span class="koboSpan" id="kobo.345.1">Here, we can deduce from the first argument that </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">T</span></strong><span class="koboSpan" id="kobo.347.1"> must be </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">long</span></strong><span class="koboSpan" id="kobo.349.1">, but from the second argument, we deduce that </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">T</span></strong><span class="koboSpan" id="kobo.351.1"> must be </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">int</span></strong><span class="koboSpan" id="kobo.353.1">. </span><span class="koboSpan" id="kobo.353.2">It is often surprising to programmers who learn their way around templates that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">long</span></strong><span class="koboSpan" id="kobo.355.1"> type is not deduced in this case—after all, if we substitute </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">long</span></strong><span class="koboSpan" id="kobo.357.1"> for </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">T</span></strong><span class="koboSpan" id="kobo.359.1"> everywhere, the second argument will be implicitly converted, and the function will compile fine. </span><span class="koboSpan" id="kobo.359.2">So why isn’t the </span><em class="italic"><span class="koboSpan" id="kobo.360.1">larger</span></em><span class="koboSpan" id="kobo.361.1"> type deduced? </span><span class="koboSpan" id="kobo.361.2">Because the compiler does not attempt to find a type for which all argument conversions are possible: after all, there is usually more than one such type. </span><span class="koboSpan" id="kobo.361.3">In our example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">T</span></strong><span class="koboSpan" id="kobo.363.1"> could be </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">double</span></strong><span class="koboSpan" id="kobo.365.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">unsigned long</span></strong><span class="koboSpan" id="kobo.367.1">, and the function would still be valid. </span><span class="koboSpan" id="kobo.367.2">If a type can</span><a id="_idIndexMarker090"/><span class="koboSpan" id="kobo.368.1"> be deduced from more than one argument, the result of all these deductions must be </span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">the same.</span></span></p>
<p><span class="koboSpan" id="kobo.370.1">Otherwise, the template instantiation is </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">considered ambiguous.</span></span></p>
<p><span class="koboSpan" id="kobo.372.1">The type deduction is not always as straightforward as using the type of the argument for a type parameter. </span><span class="koboSpan" id="kobo.372.2">The argument may be declared with a type that’s more complex than a type </span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">parameter itself:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.374.1">
template &lt;typename T&gt; T decrement(T* p) {
  return --(*p);
}
int i = 7;
decrement(&amp;i);    // i == 6</span></pre>
<p><span class="koboSpan" id="kobo.375.1">Here, the type of the argument is a </span><em class="italic"><span class="koboSpan" id="kobo.376.1">pointer to</span></em> <strong class="source-inline"><span class="koboSpan" id="kobo.377.1">int</span></strong><span class="koboSpan" id="kobo.378.1">, but the type that is deduced for </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">T</span></strong><span class="koboSpan" id="kobo.380.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">int</span></strong><span class="koboSpan" id="kobo.382.1">. </span><span class="koboSpan" id="kobo.382.2">The deduction of types can be arbitrarily complex, as long as </span><span class="No-Break"><span class="koboSpan" id="kobo.383.1">it’s unambiguous:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.384.1">
template &lt;typename T&gt; T first(const std::vector&lt;T&gt;&amp; v) {
  return v[0];
}
std::vector&lt;int&gt; v{11, 25, 67};
first(v);    // T is int, returns 11</span></pre>
<p><span class="koboSpan" id="kobo.385.1">Here, the argument is an instantiation of another template, </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">std::vector</span></strong><span class="koboSpan" id="kobo.387.1">, and we have to deduce the template parameter type from the type that was used to create this </span><span class="No-Break"><span class="koboSpan" id="kobo.388.1">vector instantiation.</span></span></p>
<p><span class="koboSpan" id="kobo.389.1">As we have seen, if a type can be deduced from more than one function argument, the result of these deductions must be the same. </span><span class="koboSpan" id="kobo.389.2">On the other hand, one argument can be used to deduce more than </span><span class="No-Break"><span class="koboSpan" id="kobo.390.1">one type:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.391.1">
template &lt;typename U, typename V&gt;
std::pair&lt;V, U&gt; swap12(const std::pair&lt;U, V&gt;&amp; x) {
  return std::pair&lt;V, U&gt;(x.second, x.first);
}
swap12(std::make_pair(7, 4.2)); // pair of 4.2, 7</span></pre>
<p><span class="koboSpan" id="kobo.392.1">Here, we deduce </span><a id="_idIndexMarker091"/><span class="koboSpan" id="kobo.393.1">two types, </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">U</span></strong><span class="koboSpan" id="kobo.395.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">V</span></strong><span class="koboSpan" id="kobo.397.1">, from one argument, then use these two types to form a new type, </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">std::pair&lt;V, U&gt;</span></strong><span class="koboSpan" id="kobo.399.1">. </span><span class="koboSpan" id="kobo.399.2">This example is unnecessarily verbose, and we can take advantage of a few more C++ features to make it both more compact and easier to maintain. </span><span class="koboSpan" id="kobo.399.3">First of all, the standard already has a function that deduces the argument types and uses them to declare a pair, and we have even used </span><span class="No-Break"><span class="koboSpan" id="kobo.400.1">this function—</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">std::make_pair()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.402.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.403.1">Secondly, the return type of the function can be deduced from the expression in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">return</span></strong><span class="koboSpan" id="kobo.405.1"> statement (a C++14 feature). </span><span class="koboSpan" id="kobo.405.2">The rules of this deduction are similar to the rules of the template argument type deduction. </span><span class="koboSpan" id="kobo.405.3">With these simplifications, our example becomes </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.407.1">
template &lt;typename U, typename V&gt;
auto swap12(const std::pair&lt;U, V&gt;&amp; x) {
  return std::make_pair(x.second, x.first);
}</span></pre>
<p><span class="koboSpan" id="kobo.408.1">Note that we don’t explicitly use the types </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">U</span></strong><span class="koboSpan" id="kobo.410.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">V</span></strong><span class="koboSpan" id="kobo.412.1"> anymore. </span><span class="koboSpan" id="kobo.412.2">We still need this function to be a template, since it operates on a generic type, that is, a pair of two types that we don’t know until we instantiate the function. </span><span class="koboSpan" id="kobo.412.3">We could, however, use only one template parameter that would stand for the type of </span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">the argument:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.414.1">
template &lt;typename T&gt; auto swap12(const T&amp; x) {
  return std::make</span><a id="_idTextAnchor069"/><span class="koboSpan" id="kobo.415.1">_pair(x.second, x.first);
}</span></pre>
<p><span class="koboSpan" id="kobo.416.1">There is a significant difference between these two variants—the last function template will have its type deduced successfully from any call with one argument, no matter the type of that argument. </span><span class="koboSpan" id="kobo.416.2">If that argument is not </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">std::pair</span></strong><span class="koboSpan" id="kobo.418.1">, or, more generally, if the argument is not a class or a struct or it does not have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">first</span></strong><span class="koboSpan" id="kobo.420.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">second</span></strong><span class="koboSpan" id="kobo.422.1"> data members, the deduction will still succeed, but the type substitution will fail. </span><span class="koboSpan" id="kobo.422.2">On the other hand, the previous version will not even be considered for arguments that are not a pair of some types. </span><span class="koboSpan" id="kobo.422.3">For any </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">std::pair</span></strong><span class="koboSpan" id="kobo.424.1"> argument, the pair types are deduced, and the substitution should proceed without a problem. </span><span class="koboSpan" id="kobo.424.2">Can we use the last declaration and still restrict the type </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">T</span></strong><span class="koboSpan" id="kobo.426.1"> to be a pair or another class with a similar interface? </span><span class="koboSpan" id="kobo.426.2">Yes, and we will see several ways to do so later in </span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">this book.</span></span></p>
<p><span class="koboSpan" id="kobo.428.1">Member function</span><a id="_idIndexMarker092"/><span class="koboSpan" id="kobo.429.1"> templates are very similar to non-member function templates, and their arguments are similarly deduced. </span><span class="koboSpan" id="kobo.429.2">Member function temp</span><a id="_idTextAnchor070"/><span class="koboSpan" id="kobo.430.1">lates can be used in classes or class templates</span><a id="_idTextAnchor071"/><span class="koboSpan" id="kobo.431.1">, which we will </span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">review next.</span></span></p>
<h2 id="_idParaDest-34"><a id="_idTextAnchor072"/><span class="koboSpan" id="kobo.433.1">Class templates</span></h2>
<p><span class="koboSpan" id="kobo.434.1">Instantiation of</span><a id="_idIndexMarker093"/><span class="koboSpan" id="kobo.435.1"> class templates is similar to that of function templates—the use of a template to create a type implicitly instantiates the template. </span><span class="koboSpan" id="kobo.435.2">To use a class template, we need to specify the type arguments for the </span><span class="No-Break"><span class="koboSpan" id="kobo.436.1">template parameters:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.437.1">
template &lt;typename N, typename D&gt; class Ratio {
  public:
  Ratio() : num_(), denom_() {}
  Ratio(const N&amp; num, const D&amp; denom) :
    num_(num), denom_(denom) {}
  explicit operator double() const {
    return double(num_)/double(denom_);
  }
  private:
  N num_;
  D denom_;
};
Ratio&lt;int, double&gt; r;</span></pre>
<p><span class="koboSpan" id="kobo.438.1">The definition of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">r</span></strong><span class="koboSpan" id="kobo.440.1"> variable implicitly instantiates the </span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">Ratio</span></strong><span class="koboSpan" id="kobo.442.1"> class template for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">int</span></strong><span class="koboSpan" id="kobo.444.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">double</span></strong><span class="koboSpan" id="kobo.446.1"> types. </span><span class="koboSpan" id="kobo.446.2">It also instantiates the default constructor of this class. </span><span class="koboSpan" id="kobo.446.3">The second constructor is not used in this code and is not instantiated. </span><span class="koboSpan" id="kobo.446.4">It is this feature of class templates—instantiating a template instantiates all data members, but does not instantiate the methods until they are used—that allows us to write class templates where only some of the methods compile for certain types. </span><span class="koboSpan" id="kobo.446.5">If we use the second constructor to initialize the values of </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">Ratio</span></strong><span class="koboSpan" id="kobo.448.1">, then that constructor is instantiated, and must be valid for the </span><span class="No-Break"><span class="koboSpan" id="kobo.449.1">given types:</span></span></p>
<pre class="source-code">
<a id="_idTextAnchor073"/><span class="koboSpan" id="kobo.450.1">Ratio&lt;int, double&gt; r(5, 0.1);</span></pre>
<p><span class="koboSpan" id="kobo.451.1">In C++17, these</span><a id="_idIndexMarker094"/><span class="koboSpan" id="kobo.452.1"> constructors can be used to deduce the types of the class template from the </span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">constructor arguments:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.454.1">
Ratio r(5, 0.1);</span></pre>
<p><span class="koboSpan" id="kobo.455.1">Of course, this works only if there are enough constructor arguments to deduce the types. </span><span class="koboSpan" id="kobo.455.2">For example, the default-constructed </span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">Ratio</span></strong><span class="koboSpan" id="kobo.457.1"> object has to be instantiated with explicitly specified types; there is simply no other way to deduce them. </span><span class="koboSpan" id="kobo.457.2">Prior to C++17, a helper function template was often used to construct an object whose type can be deduced from the arguments. </span><span class="koboSpan" id="kobo.457.3">Similarly to </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">std::make_pair()</span></strong><span class="koboSpan" id="kobo.459.1">, which we looked at previously, we can implement a </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">make_ratio</span></strong><span class="koboSpan" id="kobo.461.1"> function that will do the same thing as the C++17 constructor </span><span class="No-Break"><span class="koboSpan" id="kobo.462.1">argument deduction:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.463.1">
template &lt;typename N, typename D&gt;
Ratio&lt;N, D&gt; make_ratio(const N&amp; num, const D&amp; denom) {
  return { num, denom };
}
auto r(make_ratio(5, 0.1));</span></pre>
<p><span class="koboSpan" id="kobo.464.1">The C++17 way of deducing template arguments should be preferred, if it is available: it does not require writing another function that essentially duplicates the class constructor, and does not make an additional call to the copy or move constructor to initialize the object (although in practice most compilers will perform return value optimization and optimize away the call to the copy or </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">move constructor).</span></span></p>
<p><span class="koboSpan" id="kobo.466.1">When a template is used to generate a type, it is instantiated implicitly. </span><span class="koboSpan" id="kobo.466.2">Both class and function templates can be explicitly instantiated as well. </span><span class="koboSpan" id="kobo.466.3">Doing so instantiates a template without </span><span class="No-Break"><span class="koboSpan" id="kobo.467.1">using it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.468.1">
template class Ratio&lt;long, long&gt;;
template Ratio&lt;long, long&gt; make_ratio(const long&amp;,
                                      const long&amp;);</span></pre>
<p><span class="koboSpan" id="kobo.469.1">Explicit instantiations are rarely needed, and will not be used elsewhere in </span><span class="No-Break"><span class="koboSpan" id="kobo.470.1">this book.</span></span></p>
<p><span class="koboSpan" id="kobo.471.1">While instantiations of class templates with specific template parameters behave (mostly) like regular </span><a id="_idIndexMarker095"/><span class="koboSpan" id="kobo.472.1">classes, static data members of class templates deserve special mention. </span><span class="koboSpan" id="kobo.472.2">First, let us recall the common challenge of static class data members: they must be defined somewhere, and </span><span class="No-Break"><span class="koboSpan" id="kobo.473.1">only once:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.474.1">
// In the header:
class A {
  static int n;
};
// In a C file:
int A::n = 0;
std::cout &lt;&lt; A::n;</span></pre>
<p><span class="koboSpan" id="kobo.475.1">Without such a definition, the program will not link: the name </span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">A::n</span></strong><span class="koboSpan" id="kobo.477.1"> is not defined. </span><span class="koboSpan" id="kobo.477.2">But if the definition is moved into the header and the header is included in several compilation units, the program also will not link, this time the name </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">A::n</span></strong><span class="koboSpan" id="kobo.479.1"> is </span><span class="No-Break"><span class="koboSpan" id="kobo.480.1">multiply defined.</span></span></p>
<p><span class="koboSpan" id="kobo.481.1">The requirement to define static data members exactly once is not feasible for class templates: we need them defined for every set of template parameters the template is instantiated with, and we can’t do that in any one compilation unit (other compilation units may instantiate the same template with different types). </span><span class="koboSpan" id="kobo.481.2">Fortunately, this is not necessary. </span><span class="koboSpan" id="kobo.481.3">Static members of class templates can (and should) be defined together with the </span><span class="No-Break"><span class="koboSpan" id="kobo.482.1">template itself:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.483.1">
// In the header:
template &lt;typename T&gt; class A {
  static T n;
};
template &lt;typename T&gt; T A&lt;T&gt;::n {};</span></pre>
<p><span class="koboSpan" id="kobo.484.1">While this technically results in multiple definitions, it is the job of the linker to consolidate them so we are left with a single definition (there is only one value of a static member </span><a id="_idIndexMarker096"/><span class="koboSpan" id="kobo.485.1">variable for all objects of the </span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">same type).</span></span></p>
<p><span class="koboSpan" id="kobo.487.1">In C++17, inline variables offer a </span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">simpler solution:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.489.1">
// In the header:
template &lt;typename T&gt; class A {
  static inline T n {};
};</span></pre>
<p><span class="koboSpan" id="kobo.490.1">This also works for </span><span class="No-Break"><span class="koboSpan" id="kobo.491.1">non-template classes:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.492.1">
// In the header:
class A {
  static inline int n = 0;
};</span></pre>
<p><span class="koboSpan" id="kobo.493.1">If the static data member of a class template has a non-trivial constructor, this constructor is invoked once for every instantiation of this template (not for every object – there is only one instance of a static member variable for all objects of the </span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">same type).</span></span></p>
<p><span class="koboSpan" id="kobo.495.1">Class templates, as we have used them so far, allow us to declare generic classes, that is, classes that can be instantiated with many different types. </span><span class="koboSpan" id="kobo.495.2">So far, all of these classes look exactly the same, except for the types, and generate the same code. </span><span class="koboSpan" id="kobo.495.3">This is not always desirable—different types may need to be handled </span><span class="No-Break"><span class="koboSpan" id="kobo.496.1">somewhat differently.</span></span></p>
<p><span class="koboSpan" id="kobo.497.1">For example, let’s say that we want to be able to represent not only a ratio of two numbers stored in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">Ratio</span></strong><span class="koboSpan" id="kobo.499.1"> object but also a ratio of two numbers stored elsewhere, with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">Ratio</span></strong><span class="koboSpan" id="kobo.501.1"> object containing pointers to these numbers. </span><span class="koboSpan" id="kobo.501.2">Clearly, some of the methods of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">Ratio</span></strong><span class="koboSpan" id="kobo.503.1"> object, such as the conversion operator to </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">double</span></strong><span class="koboSpan" id="kobo.505.1">, need to be implemented differently </span><a id="_idIndexMarker097"/><span class="koboSpan" id="kobo.506.1">if the object stores pointers to the numerator and denominator. </span><span class="koboSpan" id="kobo.506.2">In C++, this is accomplished by specializing the template, which we will </span><span class="No-Break"><span class="koboSpan" id="kobo.507.1">do next.</span></span></p>
<h1 id="_idParaDest-35"><a id="_idTextAnchor074"/><span class="koboSpan" id="kobo.508.1">Template specializations</span></h1>
<p><span class="koboSpan" id="kobo.509.1">Template specializations allow us to make the generated template code differently for some types—not just the same code with different types substituted, but completely different code. </span><span class="koboSpan" id="kobo.509.2">There are two kinds of template speciali</span><a id="_idTextAnchor075"/><span class="koboSpan" id="kobo.510.1">zations in C++—explicit, or full, specializations and partial specializat</span><a id="_idTextAnchor076"/><span class="koboSpan" id="kobo.511.1">ion. </span><span class="koboSpan" id="kobo.511.2">Let’s start with </span><span class="No-Break"><span class="koboSpan" id="kobo.512.1">the former.</span></span></p>
<h2 id="_idParaDest-36"><a id="_idTextAnchor077"/><span class="koboSpan" id="kobo.513.1">Explicit specialization</span></h2>
<p><span class="koboSpan" id="kobo.514.1">Explicit template </span><a id="_idIndexMarker098"/><span class="koboSpan" id="kobo.515.1">specialization defines a special version of the template for a particular set of types. </span><span class="koboSpan" id="kobo.515.2">In an explicit specialization, all generic types are replaced by specific, concrete types. </span><span class="koboSpan" id="kobo.515.3">Since an explicit specialization is not a generic class or function, it does not need to be instantiated later. </span><span class="koboSpan" id="kobo.515.4">For the same reason, it is sometimes called </span><strong class="bold"><span class="koboSpan" id="kobo.516.1">full specialization</span></strong><span class="koboSpan" id="kobo.517.1">. </span><span class="koboSpan" id="kobo.517.2">If the generic types are fully substituted, there is nothing generic left. </span><span class="koboSpan" id="kobo.517.3">An explicit specialization should not be confused with an explicit template instantiation—while both create an instantiation of a template for a given set of type arguments, an explicit instantiation creates an instantiation of the generic code, with the generic types substituted by the specific types. </span><span class="koboSpan" id="kobo.517.4">An explicit specialization creates an instantiation of the function or class with the same name but it overrides the implementation, so the resulting code can be completely different. </span><span class="koboSpan" id="kobo.517.5">An example should help us understand </span><span class="No-Break"><span class="koboSpan" id="kobo.518.1">this distinction.</span></span></p>
<p><span class="koboSpan" id="kobo.519.1">Let’s start with a class template. </span><span class="koboSpan" id="kobo.519.2">Let’s say that, if both the numerator and the denominator of </span><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">Ratio</span></strong><span class="koboSpan" id="kobo.521.1"> are </span><strong class="source-inline"><span class="koboSpan" id="kobo.522.1">double</span></strong><span class="koboSpan" id="kobo.523.1">, we want to compute the ratio and store it as a single number. </span><span class="koboSpan" id="kobo.523.2">The generic </span><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">Ratio</span></strong><span class="koboSpan" id="kobo.525.1"> code should remain the same, but for one particular set of types, we want the class to look entirely different. </span><span class="koboSpan" id="kobo.525.2">We can do this with an </span><span class="No-Break"><span class="koboSpan" id="kobo.526.1">explicit specialization:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.527.1">
template &lt;&gt; class Ratio&lt;double, double&gt; {
  public:
  Ratio() : value_() {}
  template &lt;typename N, typename D&gt;
    Ratio(const N&amp; num, const D&amp; denom) :
      value_(double(num)/double(denom)) {}
  explicit operator double() const { return value_</span><a id="_idTextAnchor078"/><span class="koboSpan" id="kobo.528.1">; }
  private:
  double value_;
};</span></pre>
<p><span class="koboSpan" id="kobo.529.1">Both template type parameters are specified to be </span><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">double</span></strong><span class="koboSpan" id="kobo.531.1">. </span><span class="koboSpan" id="kobo.531.2">The class implementation is totally unlike the generic version—instead of two data members, we have just one; the conversion operator simply returns the value, and the constructor now computes the ratio of the numerator and the denominator. </span><span class="koboSpan" id="kobo.531.3">But it is not even the same constructor—instead of the non-template constructor </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">Ratio(const double&amp;, const double&amp;)</span></strong><span class="koboSpan" id="kobo.533.1"> that the generic version would have if it was instantiated for two </span><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">double</span></strong><span class="koboSpan" id="kobo.535.1"> template arguments, we provided a template constructor that can take two arguments of any types as long as they are convertible </span><span class="No-Break"><span class="koboSpan" id="kobo.536.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">double</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.538.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.539.1">Sometimes, we don’t need to specialize the whole class template, because most of the generic code is still applicable. </span><span class="koboSpan" id="kobo.539.2">However, we may want to change the implementation of one or a few member functions. </span><span class="koboSpan" id="kobo.539.3">We can explicitly specialize the member function </span><span class="No-Break"><span class="koboSpan" id="kobo.540.1">as well:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.541.1">
template &lt;&gt; Ratio&lt;float, float&gt;::operator double() const {
  return num_/denom_;
}</span></pre>
<p><span class="koboSpan" id="kobo.542.1">Template functions can be explicitly specialized as well. </span><span class="koboSpan" id="kobo.542.2">Again, unlike an explicit instantiation, we get to write the body of the function, and we can implement it any way </span><span class="No-Break"><span class="koboSpan" id="kobo.543.1">we want:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.544.1">
template &lt;typename T&gt; T do_something(T x) {
  return ++x;
}
template &lt;&gt; double do_something&lt;double&gt;(double x) {
  return x/2;
}
do_something(3);        // 4
do_something(3.0);    // 1.5</span></pre>
<p><span class="koboSpan" id="kobo.545.1">We cannot, however, change the number or the types of arguments or the return type—they must match the result of the substitution of the generic types, so the following does </span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">not compile:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.547.1">
template &lt;&gt; long do_something&lt;int&gt;(int x) { return x*x; }</span></pre>
<p><span class="koboSpan" id="kobo.548.1">An explicit specialization must be declared before the first use of the template that would cause an implicit instantiation of the generic template for the same types. </span><span class="koboSpan" id="kobo.548.2">This makes sense—the implicit instantiation would create a class or a function with the same name and the same types as the explicit specialization. </span><span class="koboSpan" id="kobo.548.3">We would now have two versions of the same class or function in the program, and this violates the one definition rule and makes the program ill-formed (the exact rules can be found in th</span><a id="_idTextAnchor079"/><span class="koboSpan" id="kobo.549.1">e standard </span><span class="No-Break"><span class="koboSpan" id="kobo.550.1">under </span></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.551.1">[basic.def.odr]</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.552.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.553.1">Explicit specializations are useful when we have one or a few types for which we need the template to behave very differently. </span><span class="koboSpan" id="kobo.553.2">However, this does not solve our problem with the ratio of </span><a id="_idIndexMarker099"/><span class="koboSpan" id="kobo.554.1">pointers—we want a specialization that is still </span><em class="italic"><span class="koboSpan" id="kobo.555.1">somewhat generic</span></em><span class="koboSpan" id="kobo.556.1">, that is, it can handle pointers to any types, just not any other types</span><a id="_idTextAnchor080"/><span class="koboSpan" id="kobo.557.1">. </span><span class="koboSpan" id="kobo.557.2">This is accomplished by a partial speciali</span><a id="_idTextAnchor081"/><span class="koboSpan" id="kobo.558.1">zation, which we will look </span><span class="No-Break"><span class="koboSpan" id="kobo.559.1">at next.</span></span></p>
<h2 id="_idParaDest-37"><a id="_idTextAnchor082"/><span class="koboSpan" id="kobo.560.1">Partial specialization</span></h2>
<p><span class="koboSpan" id="kobo.561.1">Now, we are</span><a id="_idIndexMarker100"/><span class="koboSpan" id="kobo.562.1"> getting to the really interesting part of C++ template programming—partial template specializations. </span><span class="koboSpan" id="kobo.562.2">When a class template is partially specialized, it remains as generic code, but </span><em class="italic"><span class="koboSpan" id="kobo.563.1">less generic</span></em><span class="koboSpan" id="kobo.564.1"> than the original template. </span><span class="koboSpan" id="kobo.564.2">The simplest form of a partial template is one where some of the generic types are replaced by concrete types, but other types </span><span class="No-Break"><span class="koboSpan" id="kobo.565.1">remain generic:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.566.1">
template &lt;typename N, typename D&gt; class Ratio {
  .....
</span><span class="koboSpan" id="kobo.566.2">};
template &lt;typename D&gt; class Ratio&lt;double, D&gt; {
  public:
  Ratio() : value_() {}
  Ratio(const double&amp; num, const D&amp; denom) :
    value_(num/double(denom)) {}
  explicit operator double() const { return value_; }
  private:
  double value_;
};</span></pre>
<p><span class="koboSpan" id="kobo.567.1">Here, we convert </span><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">Ratio</span></strong><span class="koboSpan" id="kobo.569.1"> to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.570.1">double</span></strong><span class="koboSpan" id="kobo.571.1"> value if the numerator is </span><strong class="source-inline"><span class="koboSpan" id="kobo.572.1">double</span></strong><span class="koboSpan" id="kobo.573.1">, regardless of the denominator type. </span><span class="koboSpan" id="kobo.573.2">More than one partial specialization can be defined for the same template. </span><span class="koboSpan" id="kobo.573.3">For example, we can also specialize for the case when the denominator is </span><strong class="source-inline"><span class="koboSpan" id="kobo.574.1">double</span></strong><span class="koboSpan" id="kobo.575.1"> and the </span><a id="_idIndexMarker101"/><span class="koboSpan" id="kobo.576.1">numerator </span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">is anything:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.578.1">
template &lt;typename N&gt; class Ratio&lt;N, double&gt; {
  public:
  Ratio() : value_() {}
  Ratio(const N&amp; num, const double&amp; denom) :
    value_(double(num)/denom) {}
  explicit operator double() const { return val</span><a id="_idTextAnchor083"/><span class="koboSpan" id="kobo.579.1">ue_; }
  private:
  double value_;
};</span></pre>
<p><span class="koboSpan" id="kobo.580.1">When the template is instantiated, the best specialization for the given set of types is selected. </span><span class="koboSpan" id="kobo.580.2">In our case, if neither the numerator nor the denominator is </span><strong class="source-inline"><span class="koboSpan" id="kobo.581.1">double</span></strong><span class="koboSpan" id="kobo.582.1">, then the general template has to be instantiated—there are no other choices. </span><span class="koboSpan" id="kobo.582.2">If the numerator is </span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">double</span></strong><span class="koboSpan" id="kobo.584.1">, then the first partial specialization is a better (more specific) match than the general template. </span><span class="koboSpan" id="kobo.584.2">If the denominator is </span><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">double</span></strong><span class="koboSpan" id="kobo.586.1">, then the second partial specialization is a better match. </span><span class="koboSpan" id="kobo.586.2">But what happens if both terms are </span><strong class="source-inline"><span class="koboSpan" id="kobo.587.1">double</span></strong><span class="koboSpan" id="kobo.588.1">? </span><span class="koboSpan" id="kobo.588.2">In this case, the two partial specializations are equivalent; neither is more specific than the other. </span><span class="koboSpan" id="kobo.588.3">This situation is considered ambiguous and the instantiation fails. </span><span class="koboSpan" id="kobo.588.4">Note that only this particular instantiation, </span><strong class="source-inline"><span class="koboSpan" id="kobo.589.1">Ratio&lt;double, double&gt;</span></strong><span class="koboSpan" id="kobo.590.1">, fails—it is not an error (at least, not a syntax error) to define both specializations, but it is an error to request an instantiation that cannot be uniquely resolved to the narrowest specialization. </span><span class="koboSpan" id="kobo.590.2">To allow any instantiation of our template, we have to remove this ambiguity, and the only way to do that is to provide an even more narrow specialization that would be preferred over the other two. </span><span class="koboSpan" id="kobo.590.3">In our case, there is only one option—a full specialization for </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.591.1">Ratio&lt;double, double&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.592.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.593.1">
template &lt;&gt; class Ratio&lt;double, double&gt; {
  public:
  Ratio() : value_() {}
  template &lt;typename N, typename D&gt;
    Ratio(const N&amp; num, const D&amp; denom) :
      value_(double(num)/double(denom)) {}
  explicit operator double() const { return value_; }
  private:
  double value_;
};</span></pre>
<p><span class="koboSpan" id="kobo.594.1">Now, the fact that the partial specializations are ambiguous for the instantiation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.595.1">Ratio&lt;double, double&gt;</span></strong><span class="koboSpan" id="kobo.596.1"> is no longer relevant—we have a more specific version of the template than either of them, so that version is preferred </span><span class="No-Break"><span class="koboSpan" id="kobo.597.1">over both.</span></span></p>
<p><span class="koboSpan" id="kobo.598.1">Partial specializations do not have to specify some of the generic types fully. </span><span class="koboSpan" id="kobo.598.2">Therefore, can keep all types generic, but impose some restrictions on them. </span><span class="koboSpan" id="kobo.598.3">For example, we still want a specialization where both the numerator and the denominator are pointers. </span><span class="koboSpan" id="kobo.598.4">They can be pointers to anything, so they are generic types, but </span><em class="italic"><span class="koboSpan" id="kobo.599.1">less generic</span></em><span class="koboSpan" id="kobo.600.1"> than the arbitrary types of the </span><span class="No-Break"><span class="koboSpan" id="kobo.601.1">general template:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.602.1">
template &lt;typename N, typename D&gt; class Ratio&lt;N*, D*&gt; {
  public:
  Ratio(N* num, D* denom) : num_(num), denom_(denom) {}
  explicit operator double() const {
    return double(*num_)/double(*denom_);
  }
  private:
  N* const num_;
  D* const denom_;
};
int i = 5; double x = 10;
auto r(make_ratio(&amp;i, &amp;x));        // Ratio&lt;int*, double*&gt;
double(r);                    // 0.5
x = 2.5;
double(r);                    // 2</span></pre>
<p><span class="koboSpan" id="kobo.603.1">This partial specialization</span><a id="_idIndexMarker102"/><span class="koboSpan" id="kobo.604.1"> still has two generic types, but they are both pointer types, </span><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">N*</span></strong><span class="koboSpan" id="kobo.606.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">D*</span></strong><span class="koboSpan" id="kobo.608.1">, for any </span><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">N</span></strong><span class="koboSpan" id="kobo.610.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">D</span></strong><span class="koboSpan" id="kobo.612.1"> types. </span><span class="koboSpan" id="kobo.612.2">The implementation is totally unlike that of the general template. </span><span class="koboSpan" id="kobo.612.3">When instantiated with two pointer types, the partial specialization is </span><em class="italic"><span class="koboSpan" id="kobo.613.1">more specific</span></em><span class="koboSpan" id="kobo.614.1"> than the general template and is considered a better match. </span><span class="koboSpan" id="kobo.614.2">Note that, in our example, the denominator is </span><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">double</span></strong><span class="koboSpan" id="kobo.616.1">. </span><span class="koboSpan" id="kobo.616.2">So why isn’t a partial specialization for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.617.1">double</span></strong><span class="koboSpan" id="kobo.618.1"> denominator considered? </span><span class="koboSpan" id="kobo.618.2">That is because, while the denominator is </span><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">double</span></strong><span class="koboSpan" id="kobo.620.1"> as far as the program logic is concerned, technically it is </span><strong class="source-inline"><span class="koboSpan" id="kobo.621.1">double*</span></strong><span class="koboSpan" id="kobo.622.1">, a completely different type, and we do not have a specialization </span><span class="No-Break"><span class="koboSpan" id="kobo.623.1">for that.</span></span></p>
<p><span class="koboSpan" id="kobo.624.1">To define a specialization, a general template must first be declared. </span><span class="koboSpan" id="kobo.624.2">It does not, however, need to be defined—it is possible to specialize a template that does not exist in the general case. </span><span class="koboSpan" id="kobo.624.3">To do so, we must forward-declare the general template, then define all the specializations </span><span class="No-Break"><span class="koboSpan" id="kobo.625.1">we need:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.626.1">
template &lt;typename T&gt; class Value; // Declaration 
template &lt;typename T&gt; class Value&lt;T*&gt; {
  public:
  explicit Value(T* p) : v_(*p) {} private:
  T v_;
};
template &lt;typename T&gt; class Value&lt;T&amp;&gt; {
  public:
  explicit Value(T&amp; p) : v_(p) {}
  private:
  T v_;
};
int i = 5; int* p = &amp;i; int&amp; r = i;
Value&lt;int*&gt; v1(p); // T* specialization
V</span><a id="_idTextAnchor084"/><span class="koboSpan" id="kobo.627.1">alue&lt;int&amp;&gt; v2(r); // T&amp; specialization</span></pre>
<p><span class="koboSpan" id="kobo.628.1">Here, we have no general </span><strong class="source-inline"><span class="koboSpan" id="kobo.629.1">Value</span></strong><span class="koboSpan" id="kobo.630.1"> template, but we have partial specializations for any pointer or reference types. </span><span class="koboSpan" id="kobo.630.2">If we try to instantiate the template on some other type, like </span><strong class="source-inline"><span class="koboSpan" id="kobo.631.1">int</span></strong><span class="koboSpan" id="kobo.632.1">, we will get an error stating that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.633.1">Value&lt;int&gt;</span></strong><span class="koboSpan" id="kobo.634.1"> type is incomplete—this is no different than trying to define an object with only a forward declaration of </span><span class="No-Break"><span class="koboSpan" id="kobo.635.1">the class.</span></span></p>
<p><span class="koboSpan" id="kobo.636.1">So far, we have seen only examples of partial specializations for class templates. </span><span class="koboSpan" id="kobo.636.2">Unlike the earlier discussion of full specializations, we have not seen a single function specialization here. </span><span class="koboSpan" id="kobo.636.3">There is a very good reason for that—a partial function template specialization does not exist in C++. </span><span class="koboSpan" id="kobo.636.4">What is sometimes incorrectly called a partial specialization is </span><a id="_idIndexMarker103"/><span class="koboSpan" id="kobo.637.1">nothing more than overloading template functions. </span><span class="koboSpan" id="kobo.637.2">On the other hand, overloading template functions can get quite comp</span><a id="_idTextAnchor085"/><span class="koboSpan" id="kobo.638.1">lex and is worth </span><a id="_idTextAnchor086"/><span class="koboSpan" id="kobo.639.1">learning about—we will cover </span><span class="No-Break"><span class="koboSpan" id="kobo.640.1">this next.</span></span></p>
<h2 id="_idParaDest-38"><a id="_idTextAnchor087"/><span class="koboSpan" id="kobo.641.1">Template function overloading</span></h2>
<p><span class="koboSpan" id="kobo.642.1">We are used to regular</span><a id="_idIndexMarker104"/><span class="koboSpan" id="kobo.643.1"> functions, or class methods, being overloaded—multiple functions with the same name have different parameter types. </span><span class="koboSpan" id="kobo.643.2">Each call invokes the function with the best match of the parameter types to the call arguments, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.644.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.645.1">
// Example 07
void whatami(int x) {
  std::cout &lt;&lt; x &lt;&lt; " is int" &lt;&lt; std::endl;
}
void whatami(long x) {
  std::cout &lt;&lt; x &lt;&lt; " is long" &lt;&lt; std::endl;
}
whatami(5);    // 5 is int
whatami(5.0);    // Compilation error</span></pre>
<p><span class="koboSpan" id="kobo.646.1">If the arguments are a perfect match for one of the overloaded functions with the given name, that function is called. </span><span class="koboSpan" id="kobo.646.2">Otherwise, the compiler considers conversions to the parameter types of the available functions. </span><span class="koboSpan" id="kobo.646.3">If one of the functions offers </span><em class="italic"><span class="koboSpan" id="kobo.647.1">better</span></em><span class="koboSpan" id="kobo.648.1"> conversions, that function is selected. </span><span class="koboSpan" id="kobo.648.2">Otherwise, the call is ambiguous, just as in the last line of the preceding example. </span><span class="koboSpan" id="kobo.648.3">The precise definition of what constitutes the </span><em class="italic"><span class="koboSpan" id="kobo.649.1">best</span></em><span class="koboSpan" id="kobo.650.1"> conversion can be found in the standard (see the section </span><em class="italic"><span class="koboSpan" id="kobo.651.1">Overloading</span></em><span class="koboSpan" id="kobo.652.1">, more specifically, subsection </span><em class="italic"><span class="koboSpan" id="kobo.653.1">[over.match]</span></em><span class="koboSpan" id="kobo.654.1">). </span><span class="koboSpan" id="kobo.654.2">Generally, the </span><em class="italic"><span class="koboSpan" id="kobo.655.1">cheapest</span></em><span class="koboSpan" id="kobo.656.1"> conversions are the ones such as adding </span><strong class="source-inline"><span class="koboSpan" id="kobo.657.1">const</span></strong><span class="koboSpan" id="kobo.658.1"> or removing a reference; then, there are conversions between built-in types, conversions from derived to base class pointers, and so on. </span><span class="koboSpan" id="kobo.658.2">In the case of multiple arguments, each argument for the chosen function must have the best conversion. </span><span class="koboSpan" id="kobo.658.3">There </span><a id="_idIndexMarker105"/><span class="koboSpan" id="kobo.659.1">is no </span><em class="italic"><span class="koboSpan" id="kobo.660.1">voting</span></em><span class="koboSpan" id="kobo.661.1">—if a function has three arguments, and two are an exact match for the first overload, while the third one is an exact match for the second overload, then even if the remaining arguments are implicitly convertible to their corresponding parameter</span><a id="_idTextAnchor088"/><span class="koboSpan" id="kobo.662.1"> types, the overloaded call </span><span class="No-Break"><span class="koboSpan" id="kobo.663.1">is ambiguous.</span></span></p>
<p><span class="koboSpan" id="kobo.664.1">The presence of templates makes the overload resolution much more complex. </span><span class="koboSpan" id="kobo.664.2">Multiple function templates with the same name and, possibly, the same number of arguments, can be defined, in addition to non-template functions. </span><span class="koboSpan" id="kobo.664.3">All of these functions are the candidates for an overloaded function call, but the function templates can generate functions with different parameter types, so how do we decide what the actual overloaded functions are? </span><span class="koboSpan" id="kobo.664.4">The exact rules are even more complex than the ones for non-template functions, but the basic idea is this—if there is a non-template function that is a near-perfect match to the call arguments, that function is selected. </span><span class="koboSpan" id="kobo.664.5">The standard, of course, uses much more precise terms than </span><em class="italic"><span class="koboSpan" id="kobo.665.1">near-perfect</span></em><span class="koboSpan" id="kobo.666.1">, but </span><em class="italic"><span class="koboSpan" id="kobo.667.1">trivial</span></em><span class="koboSpan" id="kobo.668.1"> conversions, such as adding </span><strong class="source-inline"><span class="koboSpan" id="kobo.669.1">const</span></strong><span class="koboSpan" id="kobo.670.1">, fall under that category—you get them </span><em class="italic"><span class="koboSpan" id="kobo.671.1">at no cost</span></em><span class="koboSpan" id="kobo.672.1">. </span><span class="koboSpan" id="kobo.672.2">If there is no such function, the compiler will attempt to instantiate all function templates with the same name to a near-perfect match, using the template argument deduction. </span><span class="koboSpan" id="kobo.672.3">If exactly one of the templates was instantiated, the function created by this instantiation is called. </span><span class="koboSpan" id="kobo.672.4">Otherwise, overload resolution continues the usual way among the </span><span class="No-Break"><span class="koboSpan" id="kobo.673.1">non-template functions.</span></span></p>
<p><span class="koboSpan" id="kobo.674.1">This is a very simplified description of a very complex process, but there are two important points—firstly, if there is an equally good match of a call to a template and a non-template function, the non-template function is preferred, and secondly, the compiler does not attempt to instantiate the function templates into something that might be convertible to the types we need. </span><span class="koboSpan" id="kobo.674.2">The template functions must match the call almost perfectly after the argument type deduction, or they are not called at all. </span><span class="koboSpan" id="kobo.674.3">Let’s add a template to our </span><span class="No-Break"><span class="koboSpan" id="kobo.675.1">previous example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.676.1">
void whatami(int x); // Same as above
void whatami(long x); // Same as above
template &lt;typename T&gt; void whatami(T* x) {
  std::cout &lt;&lt; x &lt;&lt; " is a pointer" &lt;&lt; std::endl;
}
int i = 5;
whatami(i);    // 5 is int
whatami(&amp;i);    // 0x???? </span><span class="koboSpan" id="kobo.676.2">is a pointer</span></pre>
<p><span class="koboSpan" id="kobo.677.1">Here, we have what looks </span><a id="_idIndexMarker106"/><span class="koboSpan" id="kobo.678.1">like a partial specialization of a function template. </span><span class="koboSpan" id="kobo.678.2">But it really isn’t—it is just a function template—there is no general template for which it could be a specialization. </span><span class="koboSpan" id="kobo.678.3">Instead, it is simply a function template whose type parameter is deduced from the same arguments, but using different rules. </span><span class="koboSpan" id="kobo.678.4">The template can have its type deduced if the argument is a pointer of any kind. </span><span class="koboSpan" id="kobo.678.5">This includes a pointer to </span><strong class="source-inline"><span class="koboSpan" id="kobo.679.1">const</span></strong><span class="koboSpan" id="kobo.680.1">—</span><strong class="source-inline"><span class="koboSpan" id="kobo.681.1">T</span></strong><span class="koboSpan" id="kobo.682.1"> could be a </span><strong class="source-inline"><span class="koboSpan" id="kobo.683.1">const</span></strong><span class="koboSpan" id="kobo.684.1"> type, so if we call </span><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">whatami(ptr)</span></strong><span class="koboSpan" id="kobo.686.1">, where </span><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">ptr</span></strong><span class="koboSpan" id="kobo.688.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.689.1">const int*</span></strong><span class="koboSpan" id="kobo.690.1">, that first template overload is a perfect match when </span><strong class="source-inline"><span class="koboSpan" id="kobo.691.1">T</span></strong><span class="koboSpan" id="kobo.692.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">const int</span></strong><span class="koboSpan" id="kobo.694.1">. </span><span class="koboSpan" id="kobo.694.2">If the deduction succeeds, the function generated by the template, that is, the template instantiation, is added to the </span><span class="No-Break"><span class="koboSpan" id="kobo.695.1">overload set.</span></span></p>
<p><span class="koboSpan" id="kobo.696.1">For the </span><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">int*</span></strong><span class="koboSpan" id="kobo.698.1"> argument, it is the only overload that works, so it is called. </span><span class="koboSpan" id="kobo.698.2">But what happens if more than one function template can match the call, and both instantiations are valid overloads? </span><span class="koboSpan" id="kobo.698.3">Let’s add one </span><span class="No-Break"><span class="koboSpan" id="kobo.699.1">more template:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.700.1">
void whatami(int x); // Same as above
void whatami(long x); // Same as above
template &lt;typename T&gt; void whatami(T* x); // Same as above
template &lt;typename T&gt; void whatami(T&amp;&amp; x) {
  std::cout &lt;&lt; "Something weird" &lt;&lt; std::endl;
}
class C {    };
C c;
whatami(c);    // Something weird
whatami(&amp;c);    // 0x???? </span><span class="koboSpan" id="kobo.700.2">is a pointer</span></pre>
<p><span class="koboSpan" id="kobo.701.1">This template function accepts its arguments by the universal reference, so it can be instantiated for any call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.702.1">whatami()</span></strong><span class="koboSpan" id="kobo.703.1"> with one argument. </span><span class="koboSpan" id="kobo.703.2">The first call, </span><strong class="source-inline"><span class="koboSpan" id="kobo.704.1">whatami(c)</span></strong><span class="koboSpan" id="kobo.705.1">, is easy—the last overload, with </span><strong class="source-inline"><span class="koboSpan" id="kobo.706.1">T&amp;&amp;</span></strong><span class="koboSpan" id="kobo.707.1">, is the only one that can be called. </span><span class="koboSpan" id="kobo.707.2">There are no conversions from </span><strong class="source-inline"><span class="koboSpan" id="kobo.708.1">c</span></strong><span class="koboSpan" id="kobo.709.1"> to a pointer or an integer. </span><span class="koboSpan" id="kobo.709.2">But the second call is tricky—we have not one, but two template instantiations that are a perfect match for the call, with no conversions needed. </span><span class="koboSpan" id="kobo.709.3">So why is this not an ambiguous overload? </span><span class="koboSpan" id="kobo.709.4">Because the rules for resolving overloaded function templates are different than the rules for non-template functions and resemble the rules for selecting the partial specialization of a class template (which is another reason why function template overloads are often</span><a id="_idIndexMarker107"/><span class="koboSpan" id="kobo.710.1"> confused with partial specializations). </span><span class="koboSpan" id="kobo.710.2">The template that is more specific is a </span><span class="No-Break"><span class="koboSpan" id="kobo.711.1">better match.</span></span></p>
<p><span class="koboSpan" id="kobo.712.1">In our case, the first template is more specific—it can accept any pointer argument, but only pointers. </span><span class="koboSpan" id="kobo.712.2">The second template can accept any argument at all, so any time the first template is a possible match, the second is too, but not the reverse. </span><span class="koboSpan" id="kobo.712.3">If a more specific template can be used to instantiate a function that is a valid overload, then this template </span><span class="No-Break"><span class="koboSpan" id="kobo.713.1">is used.</span></span></p>
<p><span class="koboSpan" id="kobo.714.1">Otherwise, we have to fall back to the more </span><span class="No-Break"><span class="koboSpan" id="kobo.715.1">general template.</span></span></p>
<p><span class="koboSpan" id="kobo.716.1">The very general template functions in the overload set sometimes lead to unexpected results. </span><span class="koboSpan" id="kobo.716.2">Let’s say we have the following three overloads for </span><strong class="source-inline"><span class="koboSpan" id="kobo.717.1">int</span></strong><span class="koboSpan" id="kobo.718.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.719.1">double</span></strong><span class="koboSpan" id="kobo.720.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.721.1">and anything:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.722.1">
void whatami(int x) {
  std::cout &lt;&lt; x &lt;&lt; " is int" &lt;&lt; std::endl;
}
void whatami(double x) {
  std::cout &lt;&lt; x &lt;&lt; " is double" &lt;&lt; std::endl;
}
template &lt;typename T&gt; void whatami(T&amp;&amp; x) {
  std::cout &lt;&lt; "Something weird" &lt;&lt; std::endl;
}
int i = 5;
float x = 4.2;
whatami(i);    // i is int
whatami(x);    // Someth</span><a id="_idTextAnchor089"/><span class="koboSpan" id="kobo.723.1">ing weird
whatami(1.2);    // 1.2 is double</span></pre>
<p><span class="koboSpan" id="kobo.724.1">The first call has an </span><strong class="source-inline"><span class="koboSpan" id="kobo.725.1">int</span></strong><span class="koboSpan" id="kobo.726.1"> argument, so </span><strong class="source-inline"><span class="koboSpan" id="kobo.727.1">whatami(int)</span></strong><span class="koboSpan" id="kobo.728.1"> is a perfect match. </span><span class="koboSpan" id="kobo.728.2">The second call would have gone to </span><strong class="source-inline"><span class="koboSpan" id="kobo.729.1">whatami(double)</span></strong><span class="koboSpan" id="kobo.730.1"> if we did not have the template overload—the conversion from </span><strong class="source-inline"><span class="koboSpan" id="kobo.731.1">float</span></strong><span class="koboSpan" id="kobo.732.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.733.1">double</span></strong><span class="koboSpan" id="kobo.734.1"> is implicit (so is the conversion from </span><strong class="source-inline"><span class="koboSpan" id="kobo.735.1">float</span></strong><span class="koboSpan" id="kobo.736.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.737.1">int</span></strong><span class="koboSpan" id="kobo.738.1">, but the conversion to </span><strong class="source-inline"><span class="koboSpan" id="kobo.739.1">double</span></strong><span class="koboSpan" id="kobo.740.1"> is preferred). </span><span class="koboSpan" id="kobo.740.2">But it’s still a conversion, so when the function template instantiates to a perfect match of </span><strong class="source-inline"><span class="koboSpan" id="kobo.741.1">whatami(float&amp;&amp;)</span></strong><span class="koboSpan" id="kobo.742.1">, that </span><a id="_idIndexMarker108"/><span class="koboSpan" id="kobo.743.1">is the best match and the chosen overload. </span><span class="koboSpan" id="kobo.743.2">The last call has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.744.1">double</span></strong><span class="koboSpan" id="kobo.745.1"> argument, and again we have a perfect match to a non-template function </span><strong class="source-inline"><span class="koboSpan" id="kobo.746.1">whatami(double)</span></strong><span class="koboSpan" id="kobo.747.1">, so it is preferred over </span><span class="No-Break"><span class="koboSpan" id="kobo.748.1">any alternative.</span></span></p>
<p><span class="koboSpan" id="kobo.749.1">It should be noted that overloading pass-by-value and pass-by-reference functions for the same parameter types often creates ambiguities in overload resolution. </span><span class="koboSpan" id="kobo.749.2">For example, these two functions are almost </span><span class="No-Break"><span class="koboSpan" id="kobo.750.1">always ambiguous:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.751.1">
template &lt;typename T&gt; void whatami(T&amp;&amp; x) {
  std::cout &lt;&lt; "Something weird" &lt;&lt; std::endl;
}
template &lt;typename T&gt; void whatami(T x) {
  std::cout &lt;&lt; "Something copyable" &lt;&lt; std::endl;
}
class C {};
C c;
whatami(c);</span></pre>
<p><span class="koboSpan" id="kobo.752.1">As long as the argument to the function can be copied (and our object </span><strong class="source-inline"><span class="koboSpan" id="kobo.753.1">c</span></strong><span class="koboSpan" id="kobo.754.1"> is copyable), the overload is ambiguous and the call will not compile. </span><span class="koboSpan" id="kobo.754.2">The problem does not happen when a more specific function overloads a more general one (in all our previous examples, </span><strong class="source-inline"><span class="koboSpan" id="kobo.755.1">whatami(int)</span></strong><span class="koboSpan" id="kobo.756.1"> used pass-by-value with no problems), but mixing the two types of parameter passing for similarly general functions </span><span class="No-Break"><span class="koboSpan" id="kobo.757.1">is inadvisable.</span></span></p>
<p><span class="koboSpan" id="kobo.758.1">Finally, there is one more kind of function that has a special place in the overload resolution order—a </span><span class="No-Break"><span class="koboSpan" id="kobo.759.1">variadic function.</span></span></p>
<p><span class="koboSpan" id="kobo.760.1">A variadic function is declared with </span><strong class="source-inline"><span class="koboSpan" id="kobo.761.1">...</span></strong><span class="koboSpan" id="kobo.762.1"> instead of arguments, and it can be called with any number of arguments of any type (</span><strong class="source-inline"><span class="koboSpan" id="kobo.763.1">printf</span></strong><span class="koboSpan" id="kobo.764.1"> is one such function). </span><span class="koboSpan" id="kobo.764.2">This function is the overload of the last resort—it is called only if no other overloads can </span><span class="No-Break"><span class="koboSpan" id="kobo.765.1">be used:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.766.1">
void whatami(...) {
  std::cout &lt;&lt; "It's something or somethings" &lt;&lt; std::endl;
}</span></pre>
<p><span class="koboSpan" id="kobo.767.1">As long as we have the overload </span><strong class="source-inline"><span class="koboSpan" id="kobo.768.1">whatami(T&amp;&amp; x)</span></strong><span class="koboSpan" id="kobo.769.1"> available, a variadic function will never be the preferred overload, at least not for any calls to </span><strong class="source-inline"><span class="koboSpan" id="kobo.770.1">whatami()</span></strong><span class="koboSpan" id="kobo.771.1"> with one argument. </span><span class="koboSpan" id="kobo.771.2">Without </span><a id="_idIndexMarker109"/><span class="koboSpan" id="kobo.772.1">that template, </span><strong class="source-inline"><span class="koboSpan" id="kobo.773.1">whatami(...)</span></strong><span class="koboSpan" id="kobo.774.1"> is called for any argument that is not a number or a pointer. </span><span class="koboSpan" id="kobo.774.2">The variadic functions were around since the days of C, and are not to be confused with variadic templates that were introduce</span><a id="_idTextAnchor090"/><span class="koboSpan" id="kobo.775.1">d in C</span><a id="_idTextAnchor091"/><span class="koboSpan" id="kobo.776.1">++11, and this is what we’ll talk </span><span class="No-Break"><span class="koboSpan" id="kobo.777.1">about next.</span></span></p>
<h1 id="_idParaDest-39"><a id="_idTextAnchor092"/><span class="koboSpan" id="kobo.778.1">Variadic templates</span></h1>
<p><span class="koboSpan" id="kobo.779.1">Probably the greatest</span><a id="_idIndexMarker110"/><span class="koboSpan" id="kobo.780.1"> difference between generic programming in C and C++ is type safety. </span><span class="koboSpan" id="kobo.780.2">It is possible to write generic code in C—the standard function </span><strong class="source-inline"><span class="koboSpan" id="kobo.781.1">qsort()</span></strong><span class="koboSpan" id="kobo.782.1"> is a perfect example—it can sort values of any type and they are passed in using a </span><strong class="source-inline"><span class="koboSpan" id="kobo.783.1">void*</span></strong><span class="koboSpan" id="kobo.784.1"> pointer, which can really be a pointer to any type. </span><span class="koboSpan" id="kobo.784.2">Of course, the programmer has to know what the real type is and cast the pointer to the right type. </span><span class="koboSpan" id="kobo.784.3">In a generic C++ program, the types are either explicitly specified or deduced at the time of the instantiation, and the type system for generic types is as strong as it is for regular types. </span><span class="koboSpan" id="kobo.784.4">Unless we want a function with an unknown number of arguments, that is, prior to C++11, the only way was the old C-style variadic functions where the compiler had no idea what the argument types were; the programmer just had to kno</span><a id="_idTextAnchor093"/><span class="koboSpan" id="kobo.785.1">w and unpack the variable </span><span class="No-Break"><span class="koboSpan" id="kobo.786.1">arguments correctly.</span></span></p>
<p><span class="koboSpan" id="kobo.787.1">C++11 introduced the modern equivalent to a variadic function—a variadic template. </span><span class="koboSpan" id="kobo.787.2">We can now declare a generic function with any number </span><span class="No-Break"><span class="koboSpan" id="kobo.788.1">of arguments:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.789.1">
template &lt;typename ... </span><span class="koboSpan" id="kobo.789.2">T&gt; auto sum(const T&amp; ... </span><span class="koboSpan" id="kobo.789.3">x);</span></pre>
<p><span class="koboSpan" id="kobo.790.1">This function takes one or more arguments, possibly of different types, and computes their sum. </span><span class="koboSpan" id="kobo.790.2">The return type is not easy to determine, but, fortunately, we can let the compiler figure it out—we just declare the return type as </span><strong class="source-inline"><span class="koboSpan" id="kobo.791.1">auto</span></strong><span class="koboSpan" id="kobo.792.1">. </span><span class="koboSpan" id="kobo.792.2">How do we actually implement the function to add up the unknown number of values whose types we can’t name, not even as </span><a id="_idIndexMarker111"/><span class="koboSpan" id="kobo.793.1">generic types? </span><span class="koboSpan" id="kobo.793.2">In C++17, it’s easy, because it has </span><span class="No-Break"><span class="koboSpan" id="kobo.794.1">fold expressions:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.795.1">
// Example 08a
template &lt;typename ... </span><span class="koboSpan" id="kobo.795.2">T&gt; auto sum(const T&amp; ... </span><span class="koboSpan" id="kobo.795.3">x) {
  return (x + ...);
}
sum(5, 7, 3);        // 15, int
sum(5, 7L, 3);        // 15, long
sum(5, 7L, 2.9);        // 14.9, double</span></pre>
<p><span class="koboSpan" id="kobo.796.1">You can verify that the type of the result is what we say </span><span class="No-Break"><span class="koboSpan" id="kobo.797.1">it is:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.798.1">
static_assert(std::is_same_v&lt;
  decltype(sum(5, 7L, 2.9)), double&gt;);</span></pre>
<p><span class="koboSpan" id="kobo.799.1">In C++14, as well as in C++17, when a fold expression is not sufficient (and they are useful only in limited contexts, mostly when the arguments and combines using binary or unary operators), the standard technique is recursion, which is ever-popular in </span><span class="No-Break"><span class="koboSpan" id="kobo.800.1">template programming:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.801.1">
// Example 08b
template &lt;typename T1&gt; auto sum(const T1&amp; x1) {
  return x1;
}
template &lt;typename T1, typename ... </span><span class="koboSpan" id="kobo.801.2">T&gt;
auto sum(const T1&amp; x1, const T&amp; ... </span><span class="koboSpan" id="kobo.801.3">x) {
  return x1 + sum(x ...);
}</span></pre>
<p><span class="koboSpan" id="kobo.802.1">The first overload (not a partial specialization!) is for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.803.1">sum()</span></strong><span class="koboSpan" id="kobo.804.1"> function with one argument of any type. </span><span class="koboSpan" id="kobo.804.2">That value is returned. </span><span class="koboSpan" id="kobo.804.3">The second overload is for more than one argument, and the first argument is explicitly added to the sum of the remaining arguments. </span><span class="koboSpan" id="kobo.804.4">The recursion continues until there is only one argument left, at which point the other overload is called and the recursion stops. </span><span class="koboSpan" id="kobo.804.5">This is the standard technique for unraveling the parameter packs in variadic templates, and we will see this many times in this book. </span><span class="koboSpan" id="kobo.804.6">The compiler will inline all the recursive function calls and generate straightforward code that adds all </span><span class="No-Break"><span class="koboSpan" id="kobo.805.1">arguments together.</span></span></p>
<p><span class="koboSpan" id="kobo.806.1">The class templates can also be variadic—they have an arbitrary number of type arguments and can build</span><a id="_idIndexMarker112"/><span class="koboSpan" id="kobo.807.1"> classes from a varying number of objects of different types. </span><span class="koboSpan" id="kobo.807.2">The declaration is similar to that of a function template. </span><span class="koboSpan" id="kobo.807.3">For example, let’s build a class template, </span><strong class="source-inline"><span class="koboSpan" id="kobo.808.1">Group</span></strong><span class="koboSpan" id="kobo.809.1">, that can hold any number of objects of different types and return the right object when it’s converted to one of the types </span><span class="No-Break"><span class="koboSpan" id="kobo.810.1">it holds:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.811.1">
// Example 09
template &lt;typename ... </span><span class="koboSpan" id="kobo.811.2">T&gt; struct Group;</span></pre>
<p><span class="koboSpan" id="kobo.812.1">The usual implementation of such templates is again recursive, using deeply nested inheritance, although a non-recursive implementation is sometimes possible. </span><span class="koboSpan" id="kobo.812.2">We will see one in the next section. </span><span class="koboSpan" id="kobo.812.3">The recursion has to be terminated when there is only one type parameter left. </span><span class="koboSpan" id="kobo.812.4">This is done using a partial specialization, so we will leave the general template we showed previously as a declaration only, and define a specialization for one </span><span class="No-Break"><span class="koboSpan" id="kobo.813.1">type parameter:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.814.1">
template &lt;typename ... </span><span class="koboSpan" id="kobo.814.2">T&gt; struct Group;
template &lt;typename T1&gt; struct Group&lt;T1&gt; {
  T1 t1_;
  Group() = default;
  explicit Group(const T1&amp; t1) : t1_(t1) {}
  explicit Group(T1&amp;&amp; t1) : t1_(std::move(t1)) {}
  explicit operator const T1&amp;() const { return t1_; }
  explicit operator T1&amp;() { return t1_; }
};</span></pre>
<p><span class="koboSpan" id="kobo.815.1">This class holds the value of one type, </span><strong class="source-inline"><span class="koboSpan" id="kobo.816.1">T1</span></strong><span class="koboSpan" id="kobo.817.1">, initializes it by copy or move and returns a reference to it when converted to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.818.1">T1</span></strong><span class="koboSpan" id="kobo.819.1"> type. </span><span class="koboSpan" id="kobo.819.2">The specialization for an arbitrary number of type parameters contains the first one as a data member, together with the corresponding initialization and conversion methods, and inherits from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.820.1">Group</span></strong><span class="koboSpan" id="kobo.821.1"> class template of the </span><a id="_idIndexMarker113"/><span class="No-Break"><span class="koboSpan" id="kobo.822.1">remaining types:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.823.1">
template &lt;typename T1, typename ... </span><span class="koboSpan" id="kobo.823.2">T&gt;
struct Group&lt;T1, T ...&gt; : Group&lt;T ...&gt; {
  T1 t1_;
  Group() = default;
  explicit Group(const T1&amp; t1, T&amp;&amp; ... </span><span class="koboSpan" id="kobo.823.3">t) :
    Group&lt;T ...&gt;(std::forward&lt;T&gt;(t) ...), t1_(t1) {}
  explicit Group(T1&amp;&amp; t1, T&amp;&amp; ... </span><span class="koboSpan" id="kobo.823.4">t) :
    Group&lt;T...&gt;(std::forward&lt;T&gt;(t)...),
                t1_(std::move(t1)) {}
  explicit operator const T1&amp;() const { return t1</span><a id="_idTextAnchor094"/><span class="koboSpan" id="kobo.824.1">_; }
  explicit operator T1&amp;() { return t1_; }
};</span></pre>
<p><span class="koboSpan" id="kobo.825.1">For every type contained in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.826.1">Group</span></strong><span class="koboSpan" id="kobo.827.1"> class, there are two possible ways it can be initialized—copy or move. </span><span class="koboSpan" id="kobo.827.2">Fortunately, we do not have to spell out the constructors for every combination of copy and move operations. </span><span class="koboSpan" id="kobo.827.3">Instead, we have two versions of the constructor for the two ways to initialize the first argument (the one stored in the specialization); we use perfect forwarding for the </span><span class="No-Break"><span class="koboSpan" id="kobo.828.1">remaining arguments.</span></span></p>
<p><span class="koboSpan" id="kobo.829.1">Now, we can use our </span><strong class="source-inline"><span class="koboSpan" id="kobo.830.1">Group</span></strong><span class="koboSpan" id="kobo.831.1"> class template to hold some values of different types (it cannot handle multiple values of the same type since the attempt to retrieve this type would </span><span class="No-Break"><span class="koboSpan" id="kobo.832.1">be ambiguous):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.833.1">
Group&lt;int, long&gt; g(3, 5);
int(g);    // 3
long(g);    // 5</span></pre>
<p><span class="koboSpan" id="kobo.834.1">It is rather inconvenient to write all the group types explicitly and to make sure they match the argument types. </span><span class="koboSpan" id="kobo.834.2">In C++17, we can use a deduction guide to enable class template parameter deduction from </span><span class="No-Break"><span class="koboSpan" id="kobo.835.1">the constructor:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.836.1">
template &lt;typename ... </span><span class="koboSpan" id="kobo.836.2">T&gt; Group(T&amp;&amp;... </span><span class="koboSpan" id="kobo.836.3">t) -&gt; Group&lt;T...&gt;;
Group g(3, 2.2, std::string("xyz"));
int(g);            // 3
double(g);            // 2.2
std::string(g);        // "xyz"</span></pre>
<p><span class="koboSpan" id="kobo.837.1">Before C++17, the </span><a id="_idIndexMarker114"/><span class="koboSpan" id="kobo.838.1">usual solution to this problem is to use a helper function template (a variadic template, of course) to take advantage of the template </span><span class="No-Break"><span class="koboSpan" id="kobo.839.1">argument deduction:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.840.1">
template &lt;typename ... </span><span class="koboSpan" id="kobo.840.2">T&gt; auto makeGroup(T&amp;&amp; ... </span><span class="koboSpan" id="kobo.840.3">t) {
  return Group&lt;T ...&gt;(std::forward&lt;T&gt;(t) ...);
}
auto g = makeGroup(3, 2.2, std::string("xyz"));</span></pre>
<p><span class="koboSpan" id="kobo.841.1">Note that the C++ standard library contains a class template, </span><strong class="source-inline"><span class="koboSpan" id="kobo.842.1">std::tuple</span></strong><span class="koboSpan" id="kobo.843.1">, which is a much more complete and full-featured version of </span><span class="No-Break"><span class="koboSpan" id="kobo.844.1">our </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.845.1">Group</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.846.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.847.1">Variadic templates can have non-type parameters as well; in this case, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.848.1">makeGroup</span></strong><span class="koboSpan" id="kobo.849.1"> template can be instantiated with an arbitrary number of arguments. </span><span class="koboSpan" id="kobo.849.2">Often, these non-type parameter packs are used in combination with </span><strong class="source-inline"><span class="koboSpan" id="kobo.850.1">auto</span></strong><span class="koboSpan" id="kobo.851.1"> (deduced) types. </span><span class="koboSpan" id="kobo.851.2">For example, here is a template that holds a list of compile-time constant values of </span><span class="No-Break"><span class="koboSpan" id="kobo.852.1">different types:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.853.1">
// Example 10
template &lt;auto... </span><span class="koboSpan" id="kobo.853.2">Values&gt; struct value_list {};</span></pre>
<p><span class="koboSpan" id="kobo.854.1">Without </span><strong class="source-inline"><span class="koboSpan" id="kobo.855.1">auto</span></strong><span class="koboSpan" id="kobo.856.1"> (i.e., prior to C++17) it is almost impossible to declare such a template since the types must be explicitly specified. </span><span class="koboSpan" id="kobo.856.2">Note that this is the entire template: it holds the constant values as a part of its definition. </span><span class="koboSpan" id="kobo.856.3">To extract them, we need another </span><span class="No-Break"><span class="koboSpan" id="kobo.857.1">variadic template:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.858.1">
template &lt;size_t N, auto... </span><span class="koboSpan" id="kobo.858.2">Values&gt;
struct nth_value_helper;
template &lt;size_t n, auto v1, auto... </span><span class="koboSpan" id="kobo.858.3">Values&gt;
struct nth_value_helper&lt;n, v1, Values...&gt; {
  static constexpr auto value =
    nth_value_helper&lt;n - 1, Values...&gt;::value;
};
template &lt;auto v1, auto... </span><span class="koboSpan" id="kobo.858.4">Values&gt;
struct nth_value_helper&lt;0, v1, Values...&gt; {
  static constexpr auto value = v1;
};
template &lt;size_t N, auto... </span><span class="koboSpan" id="kobo.858.5">Values&gt;
constexpr auto nth_value(value_list&lt;Values...&gt;) {
  return nth_value_helper&lt;N, Values...&gt;::value;
}</span></pre>
<p><span class="koboSpan" id="kobo.859.1">The template</span><a id="_idIndexMarker115"/><span class="koboSpan" id="kobo.860.1"> function </span><strong class="source-inline"><span class="koboSpan" id="kobo.861.1">nth_value</span></strong><span class="koboSpan" id="kobo.862.1"> deduces the parameter pack </span><strong class="source-inline"><span class="koboSpan" id="kobo.863.1">Values</span></strong><span class="koboSpan" id="kobo.864.1"> from the type of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.865.1">value_list</span></strong><span class="koboSpan" id="kobo.866.1"> argument (the argument itself contains no data and is of no interest except for its type). </span><span class="koboSpan" id="kobo.866.2">A recursive instantiation of partial class specializations is then used to iterate over the parameter pack until we get to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.867.1">N</span></strong><span class="koboSpan" id="kobo.868.1">-th value. </span><span class="koboSpan" id="kobo.868.2">Note that to store floating-point constants in this manner, we </span><span class="No-Break"><span class="koboSpan" id="kobo.869.1">need C++20.</span></span></p>
<p><span class="koboSpan" id="kobo.870.1">Variadic templates can be used in combination with template template parameters to resolve some of the problems created when, for example, standard library containers are used as arguments substituted for template template parameters. </span><span class="koboSpan" id="kobo.870.2">A simple solution is to declare the parameter as taking any number </span><span class="No-Break"><span class="koboSpan" id="kobo.871.1">of types:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.872.1">
template &lt;template &lt;typename...&gt; class Container,
         typename... </span><span class="koboSpan" id="kobo.872.2">T&gt;
void print(const Container&lt;T...&gt;&amp; container);
std::vector&lt;int&gt; v{ … };
print(v);</span></pre>
<p><span class="koboSpan" id="kobo.873.1">Note that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.874.1">std::vector</span></strong><span class="koboSpan" id="kobo.875.1"> template has two type parameters. </span><span class="koboSpan" id="kobo.875.2">In C++17, a standard change made this a valid match for the parameter pack specified in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.876.1">Container</span></strong><span class="koboSpan" id="kobo.877.1"> template template parameter. </span><span class="koboSpan" id="kobo.877.2">Most compilers allowed such matches </span><span class="No-Break"><span class="koboSpan" id="kobo.878.1">even earlier.</span></span></p>
<p><span class="koboSpan" id="kobo.879.1">The variadic templates, especially combined with perfect forwarding, are extremely useful for writing very general template classes—for example, a vector can contain objects of an arbitrary type, and, to construct these objects in place instead of copying them, we have to call constructors with a different number of arguments. </span><span class="koboSpan" id="kobo.879.2">When the vector template is written, there is no way to know how many arguments are needed to initialize the objects the vector will contain, so a variadic template has to be used (indeed, the in-place constructors of </span><strong class="source-inline"><span class="koboSpan" id="kobo.880.1">std::vector</span></strong><span class="koboSpan" id="kobo.881.1">, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.882.1">emplace_back</span></strong><span class="koboSpan" id="kobo.883.1">, are </span><span class="No-Break"><span class="koboSpan" id="kobo.884.1">variadic templates).</span></span></p>
<p><span class="koboSpan" id="kobo.885.1">There is one more </span><a id="_idIndexMarker116"/><span class="koboSpan" id="kobo.886.1">kind of template-like entity in C++ that we have to mention, one that has the appearance of both a class and a function—a lambd</span><a id="_idTextAnchor095"/><a id="_idTextAnchor096"/><a id="_idTextAnchor097"/><span class="koboSpan" id="kobo.887.1">a expression. </span><span class="koboSpan" id="kobo.887.2">The next section is dedicated </span><span class="No-Break"><span class="koboSpan" id="kobo.888.1">to this.</span></span></p>
<h1 id="_idParaDest-40"><a id="_idTextAnchor098"/><span class="koboSpan" id="kobo.889.1">Lambda expressions</span></h1>
<p><span class="koboSpan" id="kobo.890.1">In C++, the regular</span><a id="_idIndexMarker117"/><span class="koboSpan" id="kobo.891.1"> function syntax is extended with the concept of a </span><em class="italic"><span class="koboSpan" id="kobo.892.1">callable</span></em><span class="koboSpan" id="kobo.893.1">, short for </span><em class="italic"><span class="koboSpan" id="kobo.894.1">callable entity</span></em><span class="koboSpan" id="kobo.895.1">—a callable is something that can be called in the same way as a function. </span><span class="koboSpan" id="kobo.895.2">Some examples of callables are functions (of course), function pointers, or objects with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.896.1">operator()</span></strong><span class="koboSpan" id="kobo.897.1">, also</span><a id="_idIndexMarker118"/><span class="koboSpan" id="kobo.898.1"> known </span><span class="No-Break"><span class="koboSpan" id="kobo.899.1">as </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.900.1">functors</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.901.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.902.1">
void f(int i); struct G {
  void operator()(int i);
};
f(5);            // Function
G g; g(5);        // Functor</span></pre>
<p><span class="koboSpan" id="kobo.903.1">It is often useful to define a callable entity in a local context, right next to the place it is used. </span><span class="koboSpan" id="kobo.903.2">For example, to sort a sequence of objects, we may want to define a custom comparison function. </span><span class="koboSpan" id="kobo.903.3">We can use an ordinary function </span><span class="No-Break"><span class="koboSpan" id="kobo.904.1">for this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.905.1">
bool compare(int i, int j) { return i &lt; j; }
void do_work() {
  std::vector&lt;int&gt; v;
  .....
</span><span class="koboSpan" id="kobo.905.2">  std::sort(v.begin(), v.end(), compare);
}</span></pre>
<p><span class="koboSpan" id="kobo.906.1">However, in C++, functions cannot be defined inside other functions, so our </span><strong class="source-inline"><span class="koboSpan" id="kobo.907.1">compare()</span></strong><span class="koboSpan" id="kobo.908.1"> function may have to be defined quite far from the place it is used. </span><span class="koboSpan" id="kobo.908.2">If it is a single-use comparison function, such separation is inconvenient and reduces the readability and maintainability of </span><span class="No-Break"><span class="koboSpan" id="kobo.909.1">the code.</span></span></p>
<p><span class="koboSpan" id="kobo.910.1">There is a way </span><a id="_idIndexMarker119"/><span class="koboSpan" id="kobo.911.1">around this limitation—while we cannot declare functions inside functions, we can declare classes, and classes can </span><span class="No-Break"><span class="koboSpan" id="kobo.912.1">be callable:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.913.1">
void do_work() {
  std::vector&lt;int&gt; v;
  .....
</span><span class="koboSpan" id="kobo.913.2">  struct compare {
    bool operator()(int i, int j) const { return i &lt; </span><a id="_idTextAnchor099"/><span class="koboSpan" id="kobo.914.1">j; }
  };
  std::sort(v.begin(), v.end(), compare());
}</span></pre>
<p><span class="koboSpan" id="kobo.915.1">This is compact and local, but rather verbose. </span><span class="koboSpan" id="kobo.915.2">We do not actually need to give this class a name, and we only ever want one instance of this class. </span><span class="koboSpan" id="kobo.915.3">In C++11, we have a much better option, the </span><span class="No-Break"><span class="koboSpan" id="kobo.916.1">lambda expression:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.917.1">
void do_work() {
  std::vector&lt;int&gt; v;
  .....
</span><span class="koboSpan" id="kobo.917.2">  auto compare = [](int i, int j) { return i &lt; j; };
  std::sort(v.begin(), v.end(), compare);
}</span></pre>
<p><span class="koboSpan" id="kobo.918.1">If we use this comparison function for just one call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.919.1">std::sort</span></strong><span class="koboSpan" id="kobo.920.1">, we don’t even need to give it a name and can define it inside </span><span class="No-Break"><span class="koboSpan" id="kobo.921.1">the call:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.922.1">
  std::sort(v.begin(), v.end(),
            [](int i, int j) { return i &lt; j; });</span></pre>
<p><span class="koboSpan" id="kobo.923.1">This is as compact as it gets. </span><span class="koboSpan" id="kobo.923.2">The return type can be specified, but can usually be deduced by the compiler. </span><span class="koboSpan" id="kobo.923.3">The lambda expression creates an object, so it has a type, but that type is generated by the compiler, so the object declaration must </span><span class="No-Break"><span class="koboSpan" id="kobo.924.1">use </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.925.1">auto</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.926.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.927.1">The lambda expressions are objects, so they can have data members. </span><span class="koboSpan" id="kobo.927.2">Of course, a local callable class can also have data members. </span><span class="koboSpan" id="kobo.927.3">Usually, they are initialized from the local variables in the</span><a id="_idIndexMarker120"/> <span class="No-Break"><span class="koboSpan" id="kobo.928.1">containing scope:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.929.1">
// Example 11
void do_work() {
  std::vector&lt;double&gt; v;
  .....
</span><span class="koboSpan" id="kobo.929.2">  struct compare_with_tolerance {
    const double tolerance;
    explicit compare_with_tolerance(double tol) :
      tolerance(tol) {}
    bool operator()(double x, double y) const {
      return x &lt; y &amp;&amp; std::abs(x - y) &gt; tolerance;
    }
  };
  double tolerance = 0.01;
  std::sort(v.begin(), v.end(),
            compare_with_tolerance(tolerance));
}</span></pre>
<p><span class="koboSpan" id="kobo.930.1">Again, this is a very verbose way to do something simple. </span><span class="koboSpan" id="kobo.930.2">We have to mention the tolerance variable three times—as a data member, a constructor argument, and in the member initialization list. </span><span class="koboSpan" id="kobo.930.3">A lambda expression makes this code simpler as well because it can capture local variables. </span><span class="koboSpan" id="kobo.930.4">In local classes, we are not allowed to reference variables from the containing scope, except by passing them through the constructor arguments, but for lambda expressions, the compiler automatically generates a constructor to capture all local variables mentioned in the body of </span><span class="No-Break"><span class="koboSpan" id="kobo.931.1">the expression:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.932.1">
void do_work() {
  s</span><a id="_idTextAnchor100"/><span class="koboSpan" id="kobo.933.1">td::vector&lt;double&gt; v;
  .....
</span><span class="koboSpan" id="kobo.933.2">  double tolerance = 0.01;
  auto compare_with_tolerance = [=](auto x, auto y) {
    return x &lt; y &amp;&amp; std::abs(x - y) &gt; tolerance;
  };
  std::sort(v.begin(), v.end(), compare_with_tolerance);
}</span></pre>
<p><span class="koboSpan" id="kobo.934.1">Here, the </span><a id="_idIndexMarker121"/><span class="koboSpan" id="kobo.935.1">name </span><strong class="source-inline"><span class="koboSpan" id="kobo.936.1">tolerance</span></strong><span class="koboSpan" id="kobo.937.1"> inside the lambda expression refers to the local variable with the same name. </span><span class="koboSpan" id="kobo.937.2">The variable is captured by value, which is specified in the lambda expression’s capture clause </span><strong class="source-inline"><span class="koboSpan" id="kobo.938.1">[=]</span></strong><span class="koboSpan" id="kobo.939.1">. </span><span class="koboSpan" id="kobo.939.2">We could have captured by reference using </span><strong class="source-inline"><span class="koboSpan" id="kobo.940.1">[&amp;]</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.941.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.942.1">
auto compare_with_tolerance = [&amp;](auto x, auto y) {
  return x &lt; y &amp;&amp; std::abs(x - y) &gt; tolerance;
};</span></pre>
<p><span class="koboSpan" id="kobo.943.1">The difference is that, when capturing by value, a copy of the captured variable is created inside the lambda object at the point where it is constructed. </span><span class="koboSpan" id="kobo.943.2">This local copy is </span><strong class="source-inline"><span class="koboSpan" id="kobo.944.1">const</span></strong><span class="koboSpan" id="kobo.945.1"> by default, although we can declare the lambda mutable, which would let us change the </span><span class="No-Break"><span class="koboSpan" id="kobo.946.1">captured values:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.947.1">
double tolerance = 0.01;
size_t count = 0; // line 2
auto compare_with_tolerance = [=](auto x, auto y) mutable {
  std::cout &lt;&lt; "called " &lt;&lt; ++count &lt;&lt; " times\n";
  return x &lt; y &amp;&amp; std::abs(x - y) &gt; tolerance;
};
std::vector&lt;double&gt; v;
… store values in v …
// Counts calls but does not change the value on line 2
std::sort(v.begin(), v.end(), compare_with_tolerance);</span></pre>
<p><span class="koboSpan" id="kobo.948.1">On the other hand, capturing the variables from the outer scope by reference makes every mention </span><a id="_idIndexMarker122"/><span class="koboSpan" id="kobo.949.1">of this variable inside the lambda a reference to the original variable. </span><span class="koboSpan" id="kobo.949.2">Values captured by reference can </span><span class="No-Break"><span class="koboSpan" id="kobo.950.1">be changed:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.951.1">
double tolerance = 0.01;
size_t count = 0;
auto compare_with_tolerance = [&amp;](auto x, auto y) mutable {
  ++count; // Changes count above
  return x &lt; y &amp;&amp; std::abs(x - y) &gt; tolerance;
};
std::vector&lt;double&gt; v;
… store values in v …
std::sort(v.begin(), v.end(), compare_with_tolerance);
std::cout &lt;&lt; "lambda called " &lt;&lt; count &lt;&lt; " times\n";</span></pre>
<p><span class="koboSpan" id="kobo.952.1">It is also possible to explicitly capture some variables by value or by reference; for example, the capture </span><strong class="source-inline"><span class="koboSpan" id="kobo.953.1">[=, &amp;count]</span></strong><span class="koboSpan" id="kobo.954.1"> captures everything by value except </span><strong class="source-inline"><span class="koboSpan" id="kobo.955.1">count</span></strong><span class="koboSpan" id="kobo.956.1">, which is captured </span><span class="No-Break"><span class="koboSpan" id="kobo.957.1">by reference.</span></span></p>
<p><span class="koboSpan" id="kobo.958.1">Instead of changing the arguments of the lambda expression from </span><strong class="source-inline"><span class="koboSpan" id="kobo.959.1">int</span></strong><span class="koboSpan" id="kobo.960.1"> in the earlier example to </span><strong class="source-inline"><span class="koboSpan" id="kobo.961.1">double</span></strong><span class="koboSpan" id="kobo.962.1">, we can declare them as </span><strong class="source-inline"><span class="koboSpan" id="kobo.963.1">auto</span></strong><span class="koboSpan" id="kobo.964.1">, which effectively makes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.965.1">operator()</span></strong><span class="koboSpan" id="kobo.966.1"> of the lambda expression a template (this is a </span><span class="No-Break"><span class="koboSpan" id="kobo.967.1">C++14 feature).</span></span></p>
<p><span class="koboSpan" id="kobo.968.1">Lambda expressions are most commonly used as local functions. </span><span class="koboSpan" id="kobo.968.2">However, they are not really functions; they are callable objects, and so they are missing one feature that functions have—the ability to overload them. </span><span class="koboSpan" id="kobo.968.3">The last trick we will learn in this section is how to work around that and create an overload set from </span><span class="No-Break"><span class="koboSpan" id="kobo.969.1">lambda expressions.</span></span></p>
<p><span class="koboSpan" id="kobo.970.1">First, the main idea—it is indeed impossible to overload callable objects. </span><span class="koboSpan" id="kobo.970.2">On the other hand, it is very easy to overload several </span><strong class="source-inline"><span class="koboSpan" id="kobo.971.1">operator()</span></strong><span class="koboSpan" id="kobo.972.1"> methods in the same object—methods are overloaded like any other function. </span><span class="koboSpan" id="kobo.972.2">Of course, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.973.1">operator()</span></strong><span class="koboSpan" id="kobo.974.1"> of a lambda expression object is generated by the compiler, not declared by us, so it is not possible to force the compiler to generate more than one </span><strong class="source-inline"><span class="koboSpan" id="kobo.975.1">operator()</span></strong><span class="koboSpan" id="kobo.976.1"> in the same lambda expression. </span><span class="koboSpan" id="kobo.976.2">But classes have their own advantages, the main one being that we can inherit </span><span class="No-Break"><span class="koboSpan" id="kobo.977.1">from them.</span></span></p>
<p><span class="koboSpan" id="kobo.978.1">Lambda expressions are objects—their types are classes, so we can inherit from them too. </span><span class="koboSpan" id="kobo.978.2">If a class inherits publicly from a base class, all public methods of the base class become public methods of the derived class. </span><span class="koboSpan" id="kobo.978.3">If a class inherits publicly from several base classes (multiple inheritance), its public interface is formed from all the public methods of all the base classes. </span><span class="koboSpan" id="kobo.978.4">If there are multiple methods with the same name in this set, they become</span><a id="_idIndexMarker123"/><span class="koboSpan" id="kobo.979.1"> overloaded and the usual overloading resolution rules apply (in particular, it is possible to create an ambiguous set of overloads, in which case the program will </span><span class="No-Break"><span class="koboSpan" id="kobo.980.1">not compile).</span></span></p>
<p><span class="koboSpan" id="kobo.981.1">So, we need to create a class that automatically inherits from any number of base classes. </span><span class="koboSpan" id="kobo.981.2">We have just seen the right tool for that—variadic templates. </span><span class="koboSpan" id="kobo.981.3">As we have learned in the previous section, the usual way to iterate over an arbitrary number of items in the parameter pack of a variadic template is </span><span class="No-Break"><span class="koboSpan" id="kobo.982.1">through recursion:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.983.1">
// Example 12a
template &lt;typename ... </span><span class="koboSpan" id="kobo.983.2">F&gt; struct overload_set;
template &lt;typename F1&gt;
struct overload_set&lt;F1&gt; : public F1 {
  overload_set(F1&amp;&amp; f1) : F1(std::move(f1)) {}
  ove</span><a id="_idTextAnchor101"/><span class="koboSpan" id="kobo.984.1">rload_set(const F1&amp; f1) : F1(f1) {}
  using F1::operator();
};
template &lt;typename F1, typename ... </span><span class="koboSpan" id="kobo.984.2">F&gt;
struct overload_set&lt;F1, F ...&gt; :
    public F1, public overload_set&lt;F ...&gt; {
  overload_set(F1&amp;&amp; f1, F&amp;&amp; ... </span><span class="koboSpan" id="kobo.984.3">f) :
    F1(std::move(f1)),
    overload_set&lt;F ...&gt;(std::forward&lt;F&gt;(f) ...) {}
  overload_set(const F1&amp; f1, F&amp;&amp; ... </span><span class="koboSpan" id="kobo.984.4">f) :
    F1(f1), overload_set&lt;F ...&gt;(std::forward&lt;F&gt;(f) ...) {}
  using F1::operator();
  using overload_set&lt;F ...&gt;::operator();
};
template &lt;typename ... </span><span class="koboSpan" id="kobo.984.5">F&gt; auto overload(F&amp;&amp; ... </span><span class="koboSpan" id="kobo.984.6">f) {
  return overload_set&lt;F ...&gt;(std::forward&lt;F&gt;(f) ...);
}</span></pre>
<p><span class="koboSpan" id="kobo.985.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.986.1">overload_set</span></strong><span class="koboSpan" id="kobo.987.1"> is a variadic class template; the general template has to be declared before we can</span><a id="_idIndexMarker124"/><span class="koboSpan" id="kobo.988.1"> specialize it, but it has no definition. </span><span class="koboSpan" id="kobo.988.2">The first definition is for the special case of only one lambda expression—the </span><strong class="source-inline"><span class="koboSpan" id="kobo.989.1">overload_set</span></strong><span class="koboSpan" id="kobo.990.1"> class inherits from the lambda expression and adds its </span><strong class="source-inline"><span class="koboSpan" id="kobo.991.1">operator()</span></strong><span class="koboSpan" id="kobo.992.1"> to its public interface. </span><span class="koboSpan" id="kobo.992.2">The specialization for </span><strong class="source-inline"><span class="koboSpan" id="kobo.993.1">N</span></strong><span class="koboSpan" id="kobo.994.1"> lambda expressions (</span><strong class="source-inline"><span class="koboSpan" id="kobo.995.1">N&gt;1</span></strong><span class="koboSpan" id="kobo.996.1">) inherits from the first one and from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.997.1">overload_set</span></strong><span class="koboSpan" id="kobo.998.1"> constructed from the remaining </span><strong class="source-inline"><span class="koboSpan" id="kobo.999.1">N-1</span></strong><span class="koboSpan" id="kobo.1000.1"> lambda expressions. </span><span class="koboSpan" id="kobo.1000.2">Finally, we have a helper function that constructs the overload set from any number of lambda expressions—in our case, this is a necessity and not mere convenience since we cannot explicitly specify the types of the lambda expressions, but have to let the function template deduce them. </span><span class="koboSpan" id="kobo.1000.3">Now, we can construct an overload set from any number of </span><span class="No-Break"><span class="koboSpan" id="kobo.1001.1">lambda expressions:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1002.1">
int i = 5;
double d = 7.3;
auto l = overload(
  [](int* i) { std::cout &lt;&lt; "i=" &lt;&lt; *i &lt;&lt; std::endl; },
  [](double* d) { std::cout &lt;&lt; "d=" &lt;&lt; *d &lt;&lt; std::endl; }
);
l(&amp;i);    // i=5
l(&amp;d);    // d=5.3</span></pre>
<p><span class="koboSpan" id="kobo.1003.1">This solution is not perfect, because it does not handle ambiguous overloads well. </span><span class="koboSpan" id="kobo.1003.2">In C++17, we can do better, and it gives us a chance to demonstrate an alternative way of using a parameter pack that does not need recursion. </span><span class="koboSpan" id="kobo.1003.3">Here is the </span><span class="No-Break"><span class="koboSpan" id="kobo.1004.1">C++17 version:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1005.1">
// Example 12b
template &lt;typename ... </span><span class="koboSpan" id="kobo.1005.2">F&gt;
struct overload_set : public F ... </span><span class="koboSpan" id="kobo.1005.3">{
  overload_set(F&amp;&amp; ... </span><span class="koboSpan" id="kobo.1005.4">f) : F(std::fo</span><a id="_idTextAnchor102"/><span class="koboSpan" id="kobo.1006.1">rward&lt;F&gt;(f)) ... </span><span class="koboSpan" id="kobo.1006.2">{}
  using F::operator() ...;    // C++17
};
template &lt;typename ... </span><span class="koboSpan" id="kobo.1006.3">F&gt; auto overload(F&amp;&amp; ... </span><span class="koboSpan" id="kobo.1006.4">f) {
  return overload_set&lt;F ...&gt;(std::forward&lt;F&gt;(f) ...);
}</span></pre>
<p><span class="koboSpan" id="kobo.1007.1">The variadic template </span><a id="_idIndexMarker125"/><span class="koboSpan" id="kobo.1008.1">does not rely on partial specializations anymore; instead, it inherits directly from the parameter pack (this part of the implementation works in C++14 as well, but the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1009.1">using</span></strong><span class="koboSpan" id="kobo.1010.1"> declaration needs C++17). </span><span class="koboSpan" id="kobo.1010.2">The template helper function is the same—it deduces the types of all lambda expressions and constructs an object from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1011.1">overload_set</span></strong><span class="koboSpan" id="kobo.1012.1"> instantiation with these types. </span><span class="koboSpan" id="kobo.1012.2">The lambda expressions themselves are passed to the base classes using perfect forwarding, where they are used to initialize all the base objects of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1013.1">overload_set</span></strong><span class="koboSpan" id="kobo.1014.1"> objects (lambda expressions are movable). </span><span class="koboSpan" id="kobo.1014.2">Without the need for recursion or partial specialization, this is a much more compact and straightforward template. </span><span class="koboSpan" id="kobo.1014.3">Its use is identical to the previous version of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1015.1">overload_set</span></strong><span class="koboSpan" id="kobo.1016.1">, but it handles near-ambiguous </span><span class="No-Break"><span class="koboSpan" id="kobo.1017.1">overloads better.</span></span></p>
<p><span class="koboSpan" id="kobo.1018.1">We can get rid of the template function as well and use template </span><span class="No-Break"><span class="koboSpan" id="kobo.1019.1">deduction guides:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1020.1">
// Example 12c
template &lt;typename ... </span><span class="koboSpan" id="kobo.1020.2">F&gt;
struct overload : public F ... </span><span class="koboSpan" id="kobo.1020.3">{
  using F::operator() ...;
};
template &lt;typename ... </span><span class="koboSpan" id="kobo.1020.4">F&gt; // Deduction guide
overload(F&amp;&amp; ... </span><span class="koboSpan" id="kobo.1020.5">) -&gt; overload&lt;F ...&gt;;</span></pre>
<p><span class="koboSpan" id="kobo.1021.1">The use of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1022.1">overload</span></strong><span class="koboSpan" id="kobo.1023.1"> template remains largely unchanged; note the curly braces used to construct </span><span class="No-Break"><span class="koboSpan" id="kobo.1024.1">an object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1025.1">
int i = 5;
double d = 7.3;
auto l = overload{
  [](int* i) { std::cout &lt;&lt; "i=" &lt;&lt; *i &lt;&lt; std::endl; },
  [](double* d) { std::cout &lt;&lt; "d=" &lt;&lt; *d &lt;&lt; std::endl; },
};
l(&amp;i);    // i=5
l(&amp;d);    // d=5.3</span></pre>
<p><span class="koboSpan" id="kobo.1026.1">We will see lambdas used extensively in later chapters of this book when we will need to write a fragment of code and attach it to an object so that it can be </span><span class="No-Break"><span class="koboSpan" id="kobo.1027.1">executed later.</span></span></p>
<p><span class="koboSpan" id="kobo.1028.1">Next, we are going to learn about a new C++ feature that, in a way, does the opposite of what we were trying to do so far: it makes templates </span><em class="italic"><span class="koboSpan" id="kobo.1029.1">less</span></em><span class="koboSpan" id="kobo.1030.1"> general. </span><span class="koboSpan" id="kobo.1030.2">As we have seen already, it is easy</span><a id="_idIndexMarker126"/><span class="koboSpan" id="kobo.1031.1"> to over-promise with a template: we can define templates whose definitions then do not compile in some cases. </span><span class="koboSpan" id="kobo.1031.2">It would be better to make any restrictions on the template arguments to</span><a id="_idTextAnchor103"/><span class="koboSpan" id="kobo.1032.1"> be a part of the declaration, so let us see how that </span><span class="No-Break"><span class="koboSpan" id="kobo.1033.1">is done.</span></span></p>
<h1 id="_idParaDest-41"><a id="_idTextAnchor104"/><span class="koboSpan" id="kobo.1034.1">Concepts</span></h1>
<p><span class="koboSpan" id="kobo.1035.1">C++20 introduced</span><a id="_idIndexMarker127"/><span class="koboSpan" id="kobo.1036.1"> a major enhancement to the C++ template </span><span class="No-Break"><span class="koboSpan" id="kobo.1037.1">machinery: concepts.</span></span></p>
<p><span class="koboSpan" id="kobo.1038.1">In C++20, templates (both class and function templates), as well as non-template functions (members of class templates, usually) may use a constraint to specify the requirements on template arguments. </span><span class="koboSpan" id="kobo.1038.2">These constraints are useful to produce better error messages, but they are truly indispensable when there is a need to select a function overload or a template specialization based on some properties of </span><span class="No-Break"><span class="koboSpan" id="kobo.1039.1">template arguments.</span></span></p>
<p><span class="koboSpan" id="kobo.1040.1">The basic syntax for a constraint is quite simple: a constraint is introduced by the keyword </span><strong class="source-inline"><span class="koboSpan" id="kobo.1041.1">requires</span></strong><span class="koboSpan" id="kobo.1042.1"> which</span><a id="_idIndexMarker128"/><span class="koboSpan" id="kobo.1043.1"> can be specified after the function declaration or before the return type (in this book, we use both ways interchangeably so the reader becomes familiar with different styles of writing code). </span><span class="koboSpan" id="kobo.1043.2">The expression itself usually uses the template parameters and must evaluate to a boolean value, </span><span class="No-Break"><span class="koboSpan" id="kobo.1044.1">for example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1045.1">
// Example 13a
template &lt;typename T&gt; T copy(T&amp;&amp; t)
  requires (sizeof(T) &gt; 1)
{
  return std::forward&lt;T&gt;(t);
}</span></pre>
<p><span class="koboSpan" id="kobo.1046.1">Here the function </span><strong class="source-inline"><span class="koboSpan" id="kobo.1047.1">copy()</span></strong><span class="koboSpan" id="kobo.1048.1"> requires that the type of its argument has a size of at least two bytes. </span><span class="koboSpan" id="kobo.1048.2">If we </span><a id="_idIndexMarker129"/><span class="koboSpan" id="kobo.1049.1">attempt to call this function </span><a id="_idIndexMarker130"/><span class="koboSpan" id="kobo.1050.1">with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1051.1">char</span></strong><span class="koboSpan" id="kobo.1052.1"> argument, the call will not compile. </span><span class="koboSpan" id="kobo.1052.2">Note that if a constraint is violated, it is as if the function did not exist for the purposes of a particular call: if there is another overload, it will be considered next even if, without the constraint, the overloads </span><span class="No-Break"><span class="koboSpan" id="kobo.1053.1">were ambiguous.</span></span></p>
<p><span class="koboSpan" id="kobo.1054.1">Here is a more complex (and more </span><span class="No-Break"><span class="koboSpan" id="kobo.1055.1">useful) example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1056.1">
template &lt;typename T1, typename T2&gt;
std::common_type_t&lt;T1, T2&gt; min2(T1&amp;&amp; t1, T2&amp;&amp; t2)
{
  if (t1 &lt; t2) return std::forward&lt;T1&gt;(t1);
  return std::forward&lt;T2&gt;(t2);
}</span></pre>
<p><span class="koboSpan" id="kobo.1057.1">This is a function similar to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1058.1">std::min</span></strong><span class="koboSpan" id="kobo.1059.1">, except it takes two arguments of different types. </span><span class="koboSpan" id="kobo.1059.2">This creates two potential issues: first, what is the return type? </span><span class="koboSpan" id="kobo.1059.3">The return value is one of the two arguments, but there has to be a single return type. </span><span class="koboSpan" id="kobo.1059.4">We can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1060.1">std::common_type</span></strong><span class="koboSpan" id="kobo.1061.1"> trait from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1062.1">&lt;type_traits&gt;</span></strong><span class="koboSpan" id="kobo.1063.1"> header as a reasonable answer: for numeric types, it does the usual type promotion, for classes, it converts from base class to derived class if possible, and it respects implicit user-specified conversions. </span><span class="koboSpan" id="kobo.1063.2">But there is a second problem: if the expression </span><strong class="source-inline"><span class="koboSpan" id="kobo.1064.1">t1 &lt; t2</span></strong><span class="koboSpan" id="kobo.1065.1"> does not compile, we get an error in the body of the function. </span><span class="koboSpan" id="kobo.1065.2">This is unfortunate because the error is hard to analyze and may be misleading: it suggests that the body of the function is implemented incorrectly. </span><span class="koboSpan" id="kobo.1065.3">We can address the second concern by adding a </span><span class="No-Break"><span class="koboSpan" id="kobo.1066.1">static assert:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1067.1">
static_assert(sizeof(t1 &lt; t2) &gt; 0);</span></pre>
<p><span class="koboSpan" id="kobo.1068.1">This at least makes clear that we intended for the code to not compile if there is no matching </span><strong class="source-inline"><span class="koboSpan" id="kobo.1069.1">operator&lt;()</span></strong><span class="koboSpan" id="kobo.1070.1">. </span><span class="koboSpan" id="kobo.1070.2">Note</span><a id="_idIndexMarker131"/><span class="koboSpan" id="kobo.1071.1"> the weird way we had to formulate the assert: the expression </span><strong class="source-inline"><span class="koboSpan" id="kobo.1072.1">t1 &lt; t2</span></strong><span class="koboSpan" id="kobo.1073.1"> itself must, in general, evaluate at run time, and is just as likely to be false. </span><span class="koboSpan" id="kobo.1073.2">We need a compile-time value, and we don’t care which argument is less, just that they can </span><a id="_idIndexMarker132"/><span class="koboSpan" id="kobo.1074.1">be compared. </span><span class="koboSpan" id="kobo.1074.2">So we assert something not about the result of the comparison but about the size of this result: </span><strong class="source-inline"><span class="koboSpan" id="kobo.1075.1">sizeof()</span></strong><span class="koboSpan" id="kobo.1076.1"> is always a compile-time value and the size of anything is at least 1 in C++. </span><span class="koboSpan" id="kobo.1076.2">The only way this assertion can fail is if the expression does not compile </span><span class="No-Break"><span class="koboSpan" id="kobo.1077.1">at all.</span></span></p>
<p><span class="koboSpan" id="kobo.1078.1">This still does not solve the other part of the problem: the requirement on the argument types is not included in the interface of the function. </span><span class="koboSpan" id="kobo.1078.2">The function can be called on any two types and then may or may not compile. </span><span class="koboSpan" id="kobo.1078.3">With C++20 constraints, we can move the requirement from the implicit (compilation failure) or explicit (static assert) error in the function body to the function declaration and make it part of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1079.1">function interface:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1080.1">
// Example 13b
template &lt;typename T1, typename T2&gt;
std::common_type_t&lt;T1, T2&gt; min2(T1&amp;&amp; t1, T2&amp;&amp; t2)
  requires (sizeof(t1 &lt; t2) &gt; 0)
{
  if (t1 &lt; t2) return std::forward&lt;T1&gt;(t1);
  return std::forward&lt;T2&gt;(t2);
}</span></pre>
<p><span class="koboSpan" id="kobo.1081.1">As you learn to build more complex constraints, it is important to remember that the constraint expression must evaluate to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1082.1">bool</span></strong><span class="koboSpan" id="kobo.1083.1"> value; no conversions whatsoever are permitted, which is why a very similar expression does </span><span class="No-Break"><span class="koboSpan" id="kobo.1084.1">not work:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1085.1">
template &lt;typename T1, typename T2&gt;
std::common_type_t&lt;T1, T2&gt; min2(T1&amp;&amp; t1, T2&amp;&amp; t2)
  requires (sizeof(t1 &lt; t2));</span></pre>
<p><span class="koboSpan" id="kobo.1086.1">The integer value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1087.1">sizeof()</span></strong><span class="koboSpan" id="kobo.1088.1"> is always non-zero and would have converted to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1089.1">true</span></strong><span class="koboSpan" id="kobo.1090.1">, but not in this context. </span><span class="koboSpan" id="kobo.1090.2">The good news is that we don’t have to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1091.1">sizeof()</span></strong><span class="koboSpan" id="kobo.1092.1"> hack at all to write constraints. </span><span class="koboSpan" id="kobo.1092.2">There is yet another type of constraint expression, a </span><em class="italic"><span class="koboSpan" id="kobo.1093.1">requires expression</span></em><span class="koboSpan" id="kobo.1094.1">, that is much more powerful and expresses our intent </span><span class="No-Break"><span class="koboSpan" id="kobo.1095.1">much clearer:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1096.1">
// Example 13b
template &lt;typename T1, typename T2&gt;
std::common_type_t&lt;T1, T2&gt; min2(T1&amp;&amp; t1, T2&amp;&amp; t2)
  requires (requires { t1 &lt; t2; });</span></pre>
<p><span class="koboSpan" id="kobo.1097.1">The requires expression </span><a id="_idIndexMarker133"/><span class="koboSpan" id="kobo.1098.1">begins with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1099.1">requires</span></strong><span class="koboSpan" id="kobo.1100.1"> keyword followed by braces </span><strong class="source-inline"><span class="koboSpan" id="kobo.1101.1">{}</span></strong><span class="koboSpan" id="kobo.1102.1">; it can contain any number of expressions that have to compile, or the value of the entire requires expression is false (it does not matter what the results of these expressions are, they just have to be valid C++). </span><span class="koboSpan" id="kobo.1102.2">You can also use types, type traits, and combinations of requirements of different kinds. </span><span class="koboSpan" id="kobo.1102.3">By a quirk of the language, the parentheses around the requires expression are optional, which means you can see code like </span><strong class="source-inline"><span class="koboSpan" id="kobo.1103.1">requires requires { t1 &lt; t2 }</span></strong><span class="koboSpan" id="kobo.1104.1"> where the first and the second </span><strong class="source-inline"><span class="koboSpan" id="kobo.1105.1">requires</span></strong><span class="koboSpan" id="kobo.1106.1"> are completely </span><span class="No-Break"><span class="koboSpan" id="kobo.1107.1">different keywords.</span></span></p>
<p><span class="koboSpan" id="kobo.1108.1">The requirements on template types can be quite complex; often, the same requirements apply in many different templates. </span><span class="koboSpan" id="kobo.1108.2">Sets of such requirements can be given names and defined for later use; these named requirements are called concepts. </span><span class="koboSpan" id="kobo.1108.3">Each concept is a condition that is evaluated at compile time when used in </span><span class="No-Break"><span class="koboSpan" id="kobo.1109.1">a constraint.</span></span></p>
<p><span class="koboSpan" id="kobo.1110.1">The syntax for a constraint is similar to </span><span class="No-Break"><span class="koboSpan" id="kobo.1111.1">a template:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1112.1">
// Example 13c
template &lt;typename T1, typename T2&gt; concept Comparable =
  requires(T1 t1, T2 t2) { t1 &lt; t2; };</span></pre>
<p><span class="koboSpan" id="kobo.1113.1">We are not going to cover the syntax in detail in this book – for that, use a reference source such as </span><a href="http://cppreference.com"><span class="koboSpan" id="kobo.1114.1">cppreference.com</span></a><span class="koboSpan" id="kobo.1115.1">. </span><span class="koboSpan" id="kobo.1115.2">A concept can be used instead of the requirement </span><span class="No-Break"><span class="koboSpan" id="kobo.1116.1">it contains:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1117.1">
template &lt;typename T1, typename T2&gt;
std::common_type_t&lt;T1, T2&gt; min2(T1&amp;&amp; t1, T2&amp;&amp; t2)
  requires Comparable&lt;T1, T2&gt;;</span></pre>
<p><span class="koboSpan" id="kobo.1118.1">Concepts that constrain a single type can also be used as template parameter placeholders. </span><span class="koboSpan" id="kobo.1118.2">Let us consider an </span><a id="_idIndexMarker134"/><span class="koboSpan" id="kobo.1119.1">example of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1120.1">swap()</span></strong><span class="koboSpan" id="kobo.1121.1"> function. </span><span class="koboSpan" id="kobo.1121.2">For integral types, there is a trick that allows us to swap two values without using a temporary variable. </span><span class="koboSpan" id="kobo.1121.3">It relies on the properties of a bitwise XOR operation. </span><span class="koboSpan" id="kobo.1121.4">Let us assume, for the purposes of this demonstration, that, on a particular hardware, this version is faster than the usual way of implementing swap. </span><span class="koboSpan" id="kobo.1121.5">We would like to write a swap template function </span><strong class="source-inline"><span class="koboSpan" id="kobo.1122.1">MySwap(T&amp; a, T&amp; b)</span></strong><span class="koboSpan" id="kobo.1123.1"> that automatically detects whether the type T supports an XOR operation and </span><a id="_idIndexMarker135"/><span class="koboSpan" id="kobo.1124.1">use it, if available; otherwise we fall back on the </span><span class="No-Break"><span class="koboSpan" id="kobo.1125.1">usual swap.</span></span></p>
<p><span class="koboSpan" id="kobo.1126.1">First, we need a concept for a type that </span><span class="No-Break"><span class="koboSpan" id="kobo.1127.1">supports XOR:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1128.1">
// Example 14a,b
template &lt;typename T&gt; concept HasXOR =
  requires(T a, T b) { a ^ b; };</span></pre>
<p><span class="koboSpan" id="kobo.1129.1">The concept has a requires expression; every expression inside the curly braces must compile, otherwise, the requirement of the concept is </span><span class="No-Break"><span class="koboSpan" id="kobo.1130.1">not met.</span></span></p>
<p><span class="koboSpan" id="kobo.1131.1">Now, we can implement an XOR-based swap template. </span><span class="koboSpan" id="kobo.1131.2">We could do it with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1132.1">requires</span></strong><span class="koboSpan" id="kobo.1133.1"> constraint, but there is a more </span><span class="No-Break"><span class="koboSpan" id="kobo.1134.1">compact way:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1135.1">
template &lt;HasXOR T&gt; void MySwap(T&amp; x, T&amp; y) {
     x = x ^ y;
     y = x ^ y;
     x = x ^ y;
}</span></pre>
<p><span class="koboSpan" id="kobo.1136.1">The concept name </span><a id="_idIndexMarker136"/><strong class="source-inline"><span class="koboSpan" id="kobo.1137.1">HasXOR</span></strong><span class="koboSpan" id="kobo.1138.1"> can be used instead of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1139.1">typename</span></strong><span class="koboSpan" id="kobo.1140.1"> keyword to declare the template parameter. </span><span class="koboSpan" id="kobo.1140.2">This restricts our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1141.1">MySwap()</span></strong><span class="koboSpan" id="kobo.1142.1"> function to the </span><a id="_idIndexMarker137"/><span class="koboSpan" id="kobo.1143.1">types that have </span><strong class="source-inline"><span class="koboSpan" id="kobo.1144.1">operator^()</span></strong><span class="koboSpan" id="kobo.1145.1">. </span><span class="koboSpan" id="kobo.1145.2">But we need a general case overload, too. </span><span class="koboSpan" id="kobo.1145.3">We should also note that </span><em class="italic"><span class="koboSpan" id="kobo.1146.1">general</span></em><span class="koboSpan" id="kobo.1147.1"> does not mean </span><em class="italic"><span class="koboSpan" id="kobo.1148.1">any</span></em><span class="koboSpan" id="kobo.1149.1"> in our case: the type has to support move assignment and move construction. </span><span class="koboSpan" id="kobo.1149.2">We need </span><span class="No-Break"><span class="koboSpan" id="kobo.1150.1">another concept:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1151.1">
template &lt;typename T&gt; concept Assignable =
  requires(T a, T b) {
    T(std::move(b));
    b = std::move(a);
  };</span></pre>
<p><span class="koboSpan" id="kobo.1152.1">This is a very similar concept, except we have two expressions; both must be valid for the concept to </span><span class="No-Break"><span class="koboSpan" id="kobo.1153.1">be true.</span></span></p>
<p><span class="koboSpan" id="kobo.1154.1">The second </span><strong class="source-inline"><span class="koboSpan" id="kobo.1155.1">MySwap()</span></strong><span class="koboSpan" id="kobo.1156.1"> overload accepts all </span><strong class="source-inline"><span class="koboSpan" id="kobo.1157.1">Assignable</span></strong><span class="koboSpan" id="kobo.1158.1"> types. </span><span class="koboSpan" id="kobo.1158.2">However, we must explicitly exclude the types with XOR, or we will have ambiguous overloads. </span><span class="koboSpan" id="kobo.1158.3">This is a perfect example </span><a id="_idIndexMarker138"/><span class="koboSpan" id="kobo.1159.1">to show that we can combine concepts as template placeholders with concepts </span><span class="No-Break"><span class="koboSpan" id="kobo.1160.1">in requirements:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1161.1">
template &lt;Assignable T&gt; void MySwap(T&amp; x, T&amp; y)
  requires (!HasXOR&lt;T&gt;)
{
  T tmp(std::move(x));
  x = std::move(y);
  y = std::move(tmp);
}</span></pre>
<p><span class="koboSpan" id="kobo.1162.1">Now a call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1163.1">MySwap()</span></strong><span class="koboSpan" id="kobo.1164.1"> will select the XOR-based overload if possible, otherwise, it will use the general overload (swapping non-assignable types will not compile </span><span class="No-Break"><span class="koboSpan" id="kobo.1165.1">at all).</span></span></p>
<p><span class="koboSpan" id="kobo.1166.1">Finally, let us return to one of the first examples in this chapter: that of a class template </span><strong class="source-inline"><span class="koboSpan" id="kobo.1167.1">ArrayOf2</span></strong><span class="koboSpan" id="kobo.1168.1"> in the section “</span><em class="italic"><span class="koboSpan" id="kobo.1169.1">Class templates</span></em><span class="koboSpan" id="kobo.1170.1">.” </span><span class="koboSpan" id="kobo.1170.2">Recall that it has a member function sum() which has much more strict requirements on the template type than the rest of the class: it adds the values of the array elements. </span><span class="koboSpan" id="kobo.1170.3">If the elements do not have </span><strong class="source-inline"><span class="koboSpan" id="kobo.1171.1">operator+()</span></strong><span class="koboSpan" id="kobo.1172.1">, there is no problem as long as we don’t call </span><strong class="source-inline"><span class="koboSpan" id="kobo.1173.1">sum()</span></strong><span class="koboSpan" id="kobo.1174.1">, but if we do, we get a syntax error. </span><span class="koboSpan" id="kobo.1174.2">It would have been better if this function was not a part of the class interface at all unless the type supports it. </span><span class="koboSpan" id="kobo.1174.3">We can accomplish this with </span><span class="No-Break"><span class="koboSpan" id="kobo.1175.1">a constraint:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1176.1">
// Example 15
template &lt;typename T&gt; class ArrayOf2 {
  public:
  T&amp; operator[](size_t i) { return a_[i]; }
  const T&amp; operator[](size_t i) const { return a_[i]; }
  T sum() const requires (requires (T a, T b) { a + b; }) {
    return a_[0] + a_[1];
  }
  private:
  T a_[2];
};</span></pre>
<p><span class="koboSpan" id="kobo.1177.1">If the expression </span><strong class="source-inline"><span class="koboSpan" id="kobo.1178.1">a + b</span></strong><span class="koboSpan" id="kobo.1179.1"> does not compile, the code behaves as if there was no member function </span><strong class="source-inline"><span class="koboSpan" id="kobo.1180.1">sum()</span></strong><span class="koboSpan" id="kobo.1181.1"> declared in the class interface. </span><span class="koboSpan" id="kobo.1181.2">Of course, we could also use a named concept </span><span class="No-Break"><span class="koboSpan" id="kobo.1182.1">for this.</span></span></p>
<p><span class="koboSpan" id="kobo.1183.1">We will see more</span><a id="_idIndexMarker139"/><span class="koboSpan" id="kobo.1184.1"> ways to manage requirements on template parameters in </span><a href="B19262_07.xhtml#_idTextAnchor314"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1185.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.1186.1">. </span><span class="koboSpan" id="kobo.1186.2">For now, let us review what we have learned and go on to use these tools to solve common </span><span class="No-Break"><span class="koboSpan" id="kobo.1187.1">C++ problems.</span></span></p>
<h1 id="_idParaDest-42"><a id="_idTextAnchor105"/><span class="koboSpan" id="kobo.1188.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1189.1">Templates, variadic templates, and lambda expressions are all powerful features of C++, offering simplicity in use, but are rich in complex details. </span><span class="koboSpan" id="kobo.1189.2">The examples in this chapter should serve to prepare the reader for the later chapters of this book, where we use these techniques to implement design patterns, both classic and novel, with the tools of the modern C++ language. </span><span class="koboSpan" id="kobo.1189.3">The reader wishing to learn the art of using these complex and powerful tools to their fullest potential is referred to other books that are dedicated to teaching these subjects, some of which can be found at the end of </span><span class="No-Break"><span class="koboSpan" id="kobo.1190.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.1191.1">The reader is now ready to learn common C++ idioms,</span><a id="_idTextAnchor106"/><span class="koboSpan" id="kobo.1192.1"> starting with idioms for expressing memory ownership, in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1193.1">next chapter.</span></span></p>
<h1 id="_idParaDest-43"><a id="_idTextAnchor107"/><span class="koboSpan" id="kobo.1194.1">Questions</span></h1>
<ol>
<li><span class="koboSpan" id="kobo.1195.1">What is the difference between a type and </span><span class="No-Break"><span class="koboSpan" id="kobo.1196.1">a template?</span></span></li>
<li><span class="koboSpan" id="kobo.1197.1">What kind of templates does </span><span class="No-Break"><span class="koboSpan" id="kobo.1198.1">C++ have?</span></span></li>
<li><span class="koboSpan" id="kobo.1199.1">What kinds of template parameters do C++ </span><span class="No-Break"><span class="koboSpan" id="kobo.1200.1">templates have?</span></span></li>
<li><span class="koboSpan" id="kobo.1201.1">What is the difference between a template specialization and a </span><span class="No-Break"><span class="koboSpan" id="kobo.1202.1">template instantiation?</span></span></li>
<li><span class="koboSpan" id="kobo.1203.1">How can you access the parameter pack of a </span><span class="No-Break"><span class="koboSpan" id="kobo.1204.1">variadic template?</span></span></li>
<li><span class="koboSpan" id="kobo.1205.1">What a</span><a id="_idTextAnchor108"/><span class="koboSpan" id="kobo.1206.1">re lambda expressions </span><span class="No-Break"><span class="koboSpan" id="kobo.1207.1">used for?</span></span></li>
<li><span class="koboSpan" id="kobo.1208.1">How do concepts refine </span><span class="No-Break"><span class="koboSpan" id="kobo.1209.1">template interfaces?</span></span></li>
</ol>
<h1 id="_idParaDest-44"><a id="_idTextAnchor109"/><span class="koboSpan" id="kobo.1210.1">Further reading</span></h1>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.1211.1">C++ </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1212.1">Fundamentals</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1213.1">: </span></span><a href="https://www.packtpub.com/product/c-fundamentals"><span class="No-Break"><span class="koboSpan" id="kobo.1214.1">https://www.packtpub.com/product/c-fundamentals</span></span></a></li>
<li><em class="italic"><span class="koboSpan" id="kobo.1215.1">C++ Data Structures and </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1216.1">Algorithms</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1217.1">: </span></span><a href="https://www.packtpub.com/product/c-data-structures-and-algorithms"><span class="No-Break"><span class="koboSpan" id="kobo.1218.1">https://www.packtpub.com/product/c-data-structures-and-algorithms</span></span></a></li>
<li><em class="italic"><span class="koboSpan" id="kobo.1219.1">Mastering C++ </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1220.1">Programming</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1221.1">: </span></span><a href="https://www.packtpub.com/product/mastering-c-programming"><span class="No-Break"><span class="koboSpan" id="kobo.1222.1">https://www.packtpub.com/product/mastering-c-programming</span></span></a></li>
</ul>
</div>
</body></html>