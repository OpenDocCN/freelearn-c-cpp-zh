<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-24"><a id="_idTextAnchor043"/>2</h1>
<h1 id="_idParaDest-25"><a id="_idTextAnchor044"/>Class and Function Templates</h1>
<p>The template programming features of C++ form a large and complex subject, with many books dedicated exclusively to teaching these features. In this book, we will use many of the advanced C++ generic programming features. How, then, should we prepare ourselves to understand these language constructs as they make their appearance throughout this book? This chapter takes an informal approach—instead of precise definitions, we demonstrate the use of templates through examples and explain what the different language features do. If you find your knowledge lacking at this point, you’re encouraged to seek a deeper understanding and read one or more of the books dedicated entirely to the C++ language that are focused on explaining its syntax and semantics. Of course, if you wish for a more precise, formal description, you can refer to the C++ standard or a reference book.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Templates in C++</li>
<li>Class and function templates</li>
<li>Template instantiations</li>
<li>Template specializations</li>
<li>Overloading of template functions</li>
<li>Variadic templates</li>
<li>Lambda expressions</li>
<li>Concepts</li>
</ul>
<h1 id="_idParaDest-26"><a id="_idTextAnchor045"/><a id="_idTextAnchor046"/><a id="_idTextAnchor047"/>Templates in C++</h1>
<p>One of the greatest<a id="_idIndexMarker064"/> strengths of C++ is its support for generic programming. In generic programming, the algorithms and data structures are written in terms of generic types that will be specified later. This allows the programmer to implement a function or a class once, and later, instantiate it for many different types. Templates are a C++ feature that allows classes and functions to be defined on generic types. C++ supports three kinds of templates—function, class, and variable templates.<a id="_idTextAnchor048"/></p>
<h2 id="_idParaDest-27"><a id="_idTextAnchor049"/>Function templates</h2>
<p>Function templates<a id="_idIndexMarker065"/> are generic functions—unlike regular <a id="_idIndexMarker066"/>functions, a template function does not declare its argument types. Instead, the types are template parameters:</p>
<pre class="source-code">
// Example 01
template &lt;typename T&gt;
T increment(T x) { return x + 1; }</pre>
<p>This template function can be used to increment a value of any type by one, for which adding one is a valid operation:</p>
<pre class="source-code">
increment(5);    // T is int, returns 6
increment(4.2);    // T is double, return 5.2 char c[10];
increment(c);    // T is char*, returns &amp;c[1]</pre>
<p>Most template functions have some limitations on the types that are used as their template parameters. For example, our <code>increment()</code> function requires that the expression <code>x + 1</code> is valid for the type of <code>x</code>. Otherwise, the attempt to instantiate the template will fail, with a somewhat verbose compilation error.</p>
<p>Both non-member and class member functions can be function templates; however, virtual functions cannot be templates. The generic types can be used not only to declare function parameters but to declare any variables inside the body of the function:</p>
<pre class="source-code">
template &lt;typename T&gt; T sum(T from, T to, T step) {
  T res = from;
  while ((from += step) &lt; to) { res += from; }
  return res;
}</pre>
<p>In C++20, simple template declarations can be abbreviated: instead of writing</p>
<pre class="source-code">
template &lt;typename T&gt; void f(T t);</pre>
<p>we can write</p>
<pre class="source-code">
// Example 01a
void f(auto t);</pre>
<p>Other than more terse declarations, there is no particular advantage to this abbreviation, and the feature is quite limited. First of all, <code>auto</code> can be used only as the “top-level” parameter type; for example, this is invalid (but allowed by some compilers):</p>
<pre class="source-code">
void f(std::vector&lt;auto&gt;&amp; v);</pre>
<p>and must still be written as</p>
<pre class="source-code">
template &lt;typename T&gt; void f(std::vector&lt;T&gt;&amp; v);</pre>
<p>Also, if you need to use template type parameters elsewhere in the function declaration, you can’t abbreviate them:</p>
<pre class="source-code">
template &lt;typename T&gt; T f(T t);</pre>
<p>Of course, you could declare the return type as <code>auto</code> and use the trailing return type:</p>
<pre class="source-code">
auto f(auto t) -&gt; decltype(t);</pre>
<p>but at this <a id="_idIndexMarker067"/>point, the<a id="_idIndexMarker068"/> template is not really “abbreviated.”</p>
<p>We will see more of function templates later, but let’s introduce class templates n<a id="_idTextAnchor050"/><a id="_idTextAnchor051"/>ext.</p>
<h2 id="_idParaDest-28"><a id="_idTextAnchor052"/>Class templates</h2>
<p>Class templates<a id="_idIndexMarker069"/> are classes that use generic types, usually to declare<a id="_idIndexMarker070"/> their data members, but also to declare methods and local variables inside them:</p>
<pre class="source-code">
// Example 02
template &lt;typename T&gt; class ArrayOf2 {
  public:
  T&amp; operator[](size_t i) { return a_[i]; }
  const T&amp; operator[](size_t i) const { return a_[i]; }
  T sum() const { return a_[0] + a_[1]; }
  private:
  T a_[2];
};</pre>
<p>This class is implemented once, and can then be used to define an array of two elements of any type:</p>
<pre class="source-code">
ArrayOf2&lt;int&gt; i; i[0] = 1; i[1] = 5;
std::cout &lt;&lt; i.sum();                       // 6
ArrayOf2&lt;double&gt; x; x[0] = -3.5; x[1] = 4;
std::cout &lt;&lt; x.sum();                       // 0.5
ArrayOf2&lt;char*&gt; c; char s[] = "Hello";
c[0] = s; c[1] = s + 2;</pre>
<p>Pay particular<a id="_idIndexMarker071"/> attention to the last example—you might expect<a id="_idIndexMarker072"/> the <code>ArrayOf2</code> template not to be valid with a type such as <code>char*</code>—after all, it has a method, <code>sum()</code>, that does not compile if the type of <code>a_[0]</code> and <code>a_[1]</code> is a pointer. However, our example compiles as written—a method of a class template does not have to be valid until we try to use it. If we never call <code>c.sum()</code>, then the fact that it would not compile never comes up,<a id="_idTextAnchor053"/> and the program remains valid. If we do call a member function that does not compile for the chosen template arguments, we get a syntax error in the body of the template (in our example, something about not being able to add two pointers). These error messages are rarely straightforward. Even if they were, it is unclear if the problem is in the body of the function, or if the function was not supposed to be called in the first place. Later in this chapter, we will see how to improve this si<a id="_idTextAnchor054"/>tuation.</p>
<h2 id="_idParaDest-29"><a id="_idTextAnchor055"/>Variable templates</h2>
<p>The last kind of<a id="_idIndexMarker073"/> template in C++ is a variable template, which<a id="_idIndexMarker074"/> was introduced in C++14. This template allows us to define a variable with a generic type:</p>
<pre class="source-code">
// Example 03
template &lt;typename T&gt; constexpr T pi =
T(3.1415926535897932384626433832795028841971693993751058209749445<a id="_idTextAnchor056"/>9230781L);
pi&lt;float&gt;;      // 3.141592
pi&lt;double&gt;;     // 3.14159<a id="_idTextAnchor057"/>2653589793</pre>
<p>Variable templates are, for the most part, very straightforward to use, mostly for defining your own constants, but there are some interesting patterns that take advantage of them; we will see one in the nex<a id="_idTextAnchor058"/>t section.</p>
<h2 id="_idParaDest-30"><a id="_idTextAnchor059"/>Non-type template parameters</h2>
<p>Usually, template<a id="_idIndexMarker075"/> parameters are types, but C++ also<a id="_idIndexMarker076"/> allows for several kinds of non-type parameters. First of all, template parameters can be values of integer or enumeration types:</p>
<pre class="source-code">
// Example 04
template &lt;typename T, size_t N&gt; class Array {
  public:
  T&amp; operator[](size_t i) {
    if (i &gt;= N) throw std::out_of_range("Bad index");
     return data_[i];
  }
  private:
  T data_[N];
};
Array&lt;int, 5&gt; a;      // OK
cin &gt;&gt; a[0];
Array&lt;int, a[0]&gt; b;   // Error</pre>
<p>This is a template with two parameters—the first is a type, but the second is not. It is a value of type <code>size_t</code> that determines the size of the array; the advantage of such a template over a built-in C-style array is that it can do range checking. The C++ standard library has a <code>std::array</code> class template that should be used instead of implementing your own array in any real program, but it does make for an easy-to-follow example.</p>
<p>The values of non-type parameters that are used to instantiate a template must be compile-time constants or <code>constexpr</code> values—the last line in the preceding example is invalid because the value of <code>a[0]</code> is not known until the program reads it in at runtime. C++20 allows floating-point and user-defined types for non-type template parameters; until then, the parameters were limited to integral types, pointers (including function and member pointers), references, and enumerations. Of course, the value of a non-type parameter has to be a compile-time constant so, for example, pointers to local variables are not allowed.</p>
<p>The numeric template parameters used to be very popular <a id="_idIndexMarker077"/>in C++ because they allow complex compile-time calculations to be implemented, but in the recent versions of the standard, <code>constexpr</code> functions can be used to the same effect and are much easier to read. Of course, the standard takes with one hand and gives with the other, and so an interesting new use case emerged for non-template parameters combined with <code>constexpr</code> functions: these functions, first introduced in C++11, are used to define “immediate functions,” or functions that are evaluated at compile time. The problem with <code>constexpr</code> functions is that they <em class="italic">may</em> evaluate at compile time but it’s not required; they could also be evaluated at run time:</p>
<pre class="source-code">
constexpr size_t length(const char* s) {
  size_t res = 0;
  while (*(s++)) ++res;
  return res;
}
std::cout &lt;&lt; length("abc") &lt;&lt; std::endl;
char s[] = "runtime";
std::cout &lt;&lt; length(s) &lt;&lt; std::endl;</pre>
<p>Here we have a <code>constexpr</code> function <code>length()</code>. Does the length computation actually happen at compile time? There is no way to know short of examining the generated assembly code (which can differ from one compiler to another). The only way to be sure is to invoke the function in a compile-time context, for example:</p>
<pre class="source-code">
static_assert(length("abc") == 3, ""); // OK
char s[] = "runtime";
static_assert(length(s) == 7, ""); // Fails</pre>
<p>The first assert compiles, and the second does not even though the value 7 is correct: the argument is not a compile-time value, so the evaluation must happen at run time.</p>
<p>In C++20, the function may be declared <code>consteval</code> instead of <code>constexpr</code>: this guarantees that the evaluation happens at compile time or not at all (thus, the second <code>cout</code> statement in <a id="_idIndexMarker078"/>the preceding example <a id="_idIndexMarker079"/>will not compile). Prior to C++20, we have to get creative. Here is one way to enforce compile-time execution:</p>
<pre class="source-code">
// Example 05c
template &lt;auto V&gt;
static constexpr auto force_consteval = V;</pre>
<p>The <code>force_consteval</code> variable template can be used to enforce compile-time evaluation as follows:</p>
<pre class="source-code">
std::cout &lt;&lt; force_consteval&lt;length("abc")&gt; &lt;&lt; std::endl;
char s[] = "runtime";
std::cout &lt;&lt; force_consteval&lt;length(s)&gt; &lt;&lt; std::endl;</pre>
<p>The second <code>cout</code> statement does not compile because the function <code>length()</code> cannot be evaluated as an immediate function. The variable template <code>force_consteval</code> uses a non-type template parameter whose type is not specified but deduced from the template argument (an <code>auto</code> template parameter). This is a C++17 feature; in C++14 we have to use a rather unelegant macro to achieve the same result:</p>
<pre class="source-code">
// Example 05d
template &lt;typename T, T V&gt;
static constexpr auto force_consteval_helper = V;
#define force_consteval(V)
force_consteval_helper&lt;decltype(V), (V)&gt;
std::cout &lt;&lt; force_consteval(length("abc")) &lt;&lt; std::endl;</pre>
<p>If a non-type template parameter seems “less than a type,” you will like the next option, a parameter<a id="_idIndexMarker080"/> that is definitely more than a<a id="_idIndexMarker081"/> simple type.</p>
<h2 id="_idParaDest-31"><a id="_idTextAnchor060"/>Template template parameters</h2>
<p>The second kind of <a id="_idIndexMarker082"/>non-type template parameter<a id="_idIndexMarker083"/> worth mentioning is a <em class="italic">template template</em> parameter—a template parameter that is itself a template. We will need them in the later chapters of this book. This template parameter is substituted—not with a name of a class, but a name of an entire template.</p>
<p>Here is a class template with a template template parameter:</p>
<pre class="source-code">
// Example 06a
template &lt;typename T,
         template &lt;typename&gt; typename Container&gt;
class Builder {
  Container&lt;T&gt; data_;
  public:
  void add(const T&amp; t) { data_.push_back(t); }
  void print() const {
    for (const auto&amp; x : data_) std::cout &lt;&lt; x &lt;&lt; " ";
    std::cout &lt;&lt; std::endl;
  }
};</pre>
<p>The <code>Builder</code> template declares a class that is used to construct (build) a container of an arbitrary type <code>T</code>. The container itself does not have a specific type, it’s a template itself.</p>
<p>It can be instantiated with any container template that takes one type argument:</p>
<pre class="source-code">
template &lt;typename T&gt; class my_vector { … };
Builder&lt;int, my_vector&gt; b;
b.add(1);
b.add(2);
b.print();</pre>
<p>Of course, there are additional requirements on the <code>Container</code> template: it must have a single type parameter <code>T</code> (the rest may be defaulted), it should be default-constructible, it must have a <code>push_back()</code> method, and so on. C++20 gives us a concise way to state these requirements and make them a part of the template interface; we will learn about it later in this chapter, in the <em class="italic">Concepts</em> section.</p>
<p>Here is a function <a id="_idIndexMarker084"/>template that has two template <a id="_idIndexMarker085"/>template parameters:</p>
<pre class="source-code">
// Example 06b
template &lt;template &lt;typename&gt; class Out_container,
          template &lt;typename&gt; class In_container,<a id="_idTextAnchor061"/>
          typename T&gt; Out_container&lt;T&gt;
resequence(const In_container&lt;T&gt;&amp; in_container) {
  Out_container&lt;T&gt; out_container;
  for (auto x : in_container) {
    out_container.push_back(x);
  }
  return out_container;
}</pre>
<p>This function takes an arbitrary container as an argument and returns another container, a different template, but instantiated on the same type, with the values copied from the input container:</p>
<pre class="source-code">
my_vector&lt;int&gt; v { 1, 2, 3, 4, 5 };
template &lt;typename T&gt; class my_deque { … };
auto d = resequence&lt;my_deque&gt;(v);// my_deque with 1 … 5</pre>
<p>Note that the compiler deduces both the type of the template argument (<code>In_container</code> as <code>my_vector</code>) and the type of its template parameter (<code>T</code> as <code>int</code>). Of course, the remaining template parameter <code>Out_container</code> cannot be deduced (it is not used in any parameters of the template function) and must be explicitly specified, which fits our intended use.</p>
<p>There is a major limitation on template template parameters that is made more complex by the fact that different compilers enforce it unevenly (i.e., some compilers let through the code that should not compile but you would really like it to). The limitation is that the number of template parameters specified for the template template must match<a id="_idIndexMarker086"/> the number of the <a id="_idIndexMarker087"/>template parameters of the argument. Consider this template function:</p>
<pre class="source-code">
template &lt;template &lt;typename&gt; class Container, typename T&gt;
void print(const Container&lt;T&gt;&amp; container) {
  for (auto x : container) { std::cout &lt;&lt; x &lt;&lt; " "; }
  std::cout &lt;&lt; std::endl;
}
std::vector&lt;int&gt; v { 1, 2, 3, 4, 5 };
print(v);</pre>
<p>This code may compile, but it depends on the version of the standard and the compiler’s strict adherence to the standard: the <code>std::vector</code> template has two template parameters, not one. The second parameter is the allocator; it has a default value, which is why we do not have to specify the allocator type when declaring a vector object. GCC, Clang, and MSVC all relax this requirement to some degree (but not to the same degree). Variadic templates, which we will see later in this chapter, offer another, more robust solution (at least in C++17 and later).</p>
<p>Templates are a kind of recipe for generating code. Next, we will<a id="_idTextAnchor062"/> see how we can convert these recipes into <a id="_idTextAnchor063"/>actual code we can run.</p>
<h1 id="_idParaDest-32"><a id="_idTextAnchor064"/>Template instantiations</h1>
<p>The template<a id="_idIndexMarker088"/> name is not a type and cannot be used to declare a variable or call a function. To create a type or a function, the template must be instantiated. Most of the time, templates are instantiated implicitly when they are used. <a id="_idTextAnchor065"/>We will again start <a id="_idTextAnchor066"/>with function templates.</p>
<h2 id="_idParaDest-33"><a id="_idTextAnchor067"/>Function templates</h2>
<p>To use a function <a id="_idIndexMarker089"/>template to generate a function, we have to specify which types should be used for all template type parameters. We can just specify the types directly:</p>
<pre class="source-code">
template &lt;typename T&gt; T half(T x) { return x/2; }
int i = half&lt;int&gt;(5);</pre>
<p>This instantiates the <code>half</code> function template with the <code>int</code> type. The type is explicitly specified; we could call the function with an argument of another type, as long as it is convertible to the type we requested:</p>
<pre class="source-code">
double x = half&lt;double&gt;(5);</pre>
<p>Even though the argument is an <code>int</code>, the instantiation is that of <code>half&lt;double&gt;</code>, and the return type is <code>double</code>. The integer value <code>5</code> is implicitly converted to <code>double</code>.</p>
<p>Even though every function template can be instantiated by specifying all its type parameters, this is rarely done. Most of the uses of function templates involve the automatic deduction of types. Consider the following:</p>
<pre class="source-code">
auto x = half(8);    // int
auto y = half(1.5);    // double</pre>
<p>The template type can be deduced only from the template function arguments—the compiler will attempt to select the type for the <code>T</code> parameter to match the type of the function argument that is declared with the same type. In our case, the function template has the argument <code>x</code> of the <code>T</code> type. Any call to this function has to provide some value for this argument, and this value must have a type. The compiler will deduce that <code>T</code> must be that type. In the first call in the preceding code block, the argument is <code>5</code>, and its type is <code>int</code>. There is nothing better to do than to assume that <code>T</code> should be <code>int</code> in this particular template instantiation. Similarly, in the second call, we can deduce that <code>T</code> must be <code>double</code>.</p>
<p>After this deduction, the compiler performs type substitution: all other mentions of the <code>T</code> type are replaced by the type that was deduced; in our case, there is only one other use of <code>T</code>, which is the return type.</p>
<p>Template argument deduction is widely used to capture types that we cannot easily determine:</p>
<pre class="source-code">
long x = ...;
unsigned int y = ...;
auto x = half(y + z);</pre>
<p>Here, we deduce the <code>T</code> type to be whatever the type of the expression <code>y + z</code> is (it’s <code>long</code>, but with template deduction, we don’t need to specify that explicitly, and the deduced type will <em class="italic">follow</em> the argument type if we ever change the types of <code>y</code> and <code>z</code>). Consider the following example:</p>
<pre class="source-code">
template &lt;typename U&gt; auto f(U);
half(f(5));</pre>
<p>We deduce <code>T</code> to match whatever type the <code>f()</code> template function returns for an <code>int</code> argument (of course, the definition of the <code>f()</code> template function has to be provided before it can be called, but we do not need to dig into the header files where <code>f()</code> is defined, as the compiler will deduc<a id="_idTextAnchor068"/>e the right type for us).</p>
<p>Only the types that are used to declare function arguments can be deduced. There is no rule that all template type parameters must be somehow present in the argument list, but any parameters that cannot be deduced must be explicitly specified:</p>
<pre class="source-code">
template &lt;typename U, typename V&gt; U half(V x) {
  return x/2;
}
auto y = half&lt;double&gt;(8);</pre>
<p>Here, the first template type parameter is explicitly specified, so <code>U</code> is double, and <code>V</code> is deduced to be <code>int</code>.</p>
<p>Sometimes, the compiler cannot deduce template type parameters, even if they are used to declare arguments:</p>
<pre class="source-code">
template &lt;typename T&gt; T Max(T x, T y) {
  return (x &gt; y) ? x : y;
}
auto x = Max(7L, 11); // Error</pre>
<p>Here, we can deduce from the first argument that <code>T</code> must be <code>long</code>, but from the second argument, we deduce that <code>T</code> must be <code>int</code>. It is often surprising to programmers who learn their way around templates that the <code>long</code> type is not deduced in this case—after all, if we substitute <code>long</code> for <code>T</code> everywhere, the second argument will be implicitly converted, and the function will compile fine. So why isn’t the <em class="italic">larger</em> type deduced? Because the compiler does not attempt to find a type for which all argument conversions are possible: after all, there is usually more than one such type. In our example, <code>T</code> could be <code>double</code> or <code>unsigned long</code>, and the function would still be valid. If a type can<a id="_idIndexMarker090"/> be deduced from more than one argument, the result of all these deductions must be the same.</p>
<p>Otherwise, the template instantiation is considered ambiguous.</p>
<p>The type deduction is not always as straightforward as using the type of the argument for a type parameter. The argument may be declared with a type that’s more complex than a type parameter itself:</p>
<pre class="source-code">
template &lt;typename T&gt; T decrement(T* p) {
  return --(*p);
}
int i = 7;
decrement(&amp;i);    // i == 6</pre>
<p>Here, the type of the argument is a <em class="italic">pointer to</em> <code>int</code>, but the type that is deduced for <code>T</code> is <code>int</code>. The deduction of types can be arbitrarily complex, as long as it’s unambiguous:</p>
<pre class="source-code">
template &lt;typename T&gt; T first(const std::vector&lt;T&gt;&amp; v) {
  return v[0];
}
std::vector&lt;int&gt; v{11, 25, 67};
first(v);    // T is int, returns 11</pre>
<p>Here, the argument is an instantiation of another template, <code>std::vector</code>, and we have to deduce the template parameter type from the type that was used to create this vector instantiation.</p>
<p>As we have seen, if a type can be deduced from more than one function argument, the result of these deductions must be the same. On the other hand, one argument can be used to deduce more than one type:</p>
<pre class="source-code">
template &lt;typename U, typename V&gt;
std::pair&lt;V, U&gt; swap12(const std::pair&lt;U, V&gt;&amp; x) {
  return std::pair&lt;V, U&gt;(x.second, x.first);
}
swap12(std::make_pair(7, 4.2)); // pair of 4.2, 7</pre>
<p>Here, we deduce <a id="_idIndexMarker091"/>two types, <code>U</code> and <code>V</code>, from one argument, then use these two types to form a new type, <code>std::pair&lt;V, U&gt;</code>. This example is unnecessarily verbose, and we can take advantage of a few more C++ features to make it both more compact and easier to maintain. First of all, the standard already has a function that deduces the argument types and uses them to declare a pair, and we have even used this function—<code>std::make_pair()</code>.</p>
<p>Secondly, the return type of the function can be deduced from the expression in the <code>return</code> statement (a C++14 feature). The rules of this deduction are similar to the rules of the template argument type deduction. With these simplifications, our example becomes the following:</p>
<pre class="source-code">
template &lt;typename U, typename V&gt;
auto swap12(const std::pair&lt;U, V&gt;&amp; x) {
  return std::make_pair(x.second, x.first);
}</pre>
<p>Note that we don’t explicitly use the types <code>U</code> and <code>V</code> anymore. We still need this function to be a template, since it operates on a generic type, that is, a pair of two types that we don’t know until we instantiate the function. We could, however, use only one template parameter that would stand for the type of the argument:</p>
<pre class="source-code">
template &lt;typename T&gt; auto swap12(const T&amp; x) {
  return std::make<a id="_idTextAnchor069"/>_pair(x.second, x.first);
}</pre>
<p>There is a significant difference between these two variants—the last function template will have its type deduced successfully from any call with one argument, no matter the type of that argument. If that argument is not <code>std::pair</code>, or, more generally, if the argument is not a class or a struct or it does not have the <code>first</code> and <code>second</code> data members, the deduction will still succeed, but the type substitution will fail. On the other hand, the previous version will not even be considered for arguments that are not a pair of some types. For any <code>std::pair</code> argument, the pair types are deduced, and the substitution should proceed without a problem. Can we use the last declaration and still restrict the type <code>T</code> to be a pair or another class with a similar interface? Yes, and we will see several ways to do so later in this book.</p>
<p>Member function<a id="_idIndexMarker092"/> templates are very similar to non-member function templates, and their arguments are similarly deduced. Member function temp<a id="_idTextAnchor070"/>lates can be used in classes or class templates<a id="_idTextAnchor071"/>, which we will review next.</p>
<h2 id="_idParaDest-34"><a id="_idTextAnchor072"/>Class templates</h2>
<p>Instantiation of<a id="_idIndexMarker093"/> class templates is similar to that of function templates—the use of a template to create a type implicitly instantiates the template. To use a class template, we need to specify the type arguments for the template parameters:</p>
<pre class="source-code">
template &lt;typename N, typename D&gt; class Ratio {
  public:
  Ratio() : num_(), denom_() {}
  Ratio(const N&amp; num, const D&amp; denom) :
    num_(num), denom_(denom) {}
  explicit operator double() const {
    return double(num_)/double(denom_);
  }
  private:
  N num_;
  D denom_;
};
Ratio&lt;int, double&gt; r;</pre>
<p>The definition of the <code>r</code> variable implicitly instantiates the <code>Ratio</code> class template for the <code>int</code> and <code>double</code> types. It also instantiates the default constructor of this class. The second constructor is not used in this code and is not instantiated. It is this feature of class templates—instantiating a template instantiates all data members, but does not instantiate the methods until they are used—that allows us to write class templates where only some of the methods compile for certain types. If we use the second constructor to initialize the values of <code>Ratio</code>, then that constructor is instantiated, and must be valid for the given types:</p>
<pre class="source-code">
<a id="_idTextAnchor073"/>Ratio&lt;int, double&gt; r(5, 0.1);</pre>
<p>In C++17, these<a id="_idIndexMarker094"/> constructors can be used to deduce the types of the class template from the constructor arguments:</p>
<pre class="source-code">
Ratio r(5, 0.1);</pre>
<p>Of course, this works only if there are enough constructor arguments to deduce the types. For example, the default-constructed <code>Ratio</code> object has to be instantiated with explicitly specified types; there is simply no other way to deduce them. Prior to C++17, a helper function template was often used to construct an object whose type can be deduced from the arguments. Similarly to <code>std::make_pair()</code>, which we looked at previously, we can implement a <code>make_ratio</code> function that will do the same thing as the C++17 constructor argument deduction:</p>
<pre class="source-code">
template &lt;typename N, typename D&gt;
Ratio&lt;N, D&gt; make_ratio(const N&amp; num, const D&amp; denom) {
  return { num, denom };
}
auto r(make_ratio(5, 0.1));</pre>
<p>The C++17 way of deducing template arguments should be preferred, if it is available: it does not require writing another function that essentially duplicates the class constructor, and does not make an additional call to the copy or move constructor to initialize the object (although in practice most compilers will perform return value optimization and optimize away the call to the copy or move constructor).</p>
<p>When a template is used to generate a type, it is instantiated implicitly. Both class and function templates can be explicitly instantiated as well. Doing so instantiates a template without using it:</p>
<pre class="source-code">
template class Ratio&lt;long, long&gt;;
template Ratio&lt;long, long&gt; make_ratio(const long&amp;,
                                      const long&amp;);</pre>
<p>Explicit instantiations are rarely needed, and will not be used elsewhere in this book.</p>
<p>While instantiations of class templates with specific template parameters behave (mostly) like regular <a id="_idIndexMarker095"/>classes, static data members of class templates deserve special mention. First, let us recall the common challenge of static class data members: they must be defined somewhere, and only once:</p>
<pre class="source-code">
// In the header:
class A {
  static int n;
};
// In a C file:
int A::n = 0;
std::cout &lt;&lt; A::n;</pre>
<p>Without such a definition, the program will not link: the name <code>A::n</code> is not defined. But if the definition is moved into the header and the header is included in several compilation units, the program also will not link, this time the name <code>A::n</code> is multiply defined.</p>
<p>The requirement to define static data members exactly once is not feasible for class templates: we need them defined for every set of template parameters the template is instantiated with, and we can’t do that in any one compilation unit (other compilation units may instantiate the same template with different types). Fortunately, this is not necessary. Static members of class templates can (and should) be defined together with the template itself:</p>
<pre class="source-code">
// In the header:
template &lt;typename T&gt; class A {
  static T n;
};
template &lt;typename T&gt; T A&lt;T&gt;::n {};</pre>
<p>While this technically results in multiple definitions, it is the job of the linker to consolidate them so we are left with a single definition (there is only one value of a static member <a id="_idIndexMarker096"/>variable for all objects of the same type).</p>
<p>In C++17, inline variables offer a simpler solution:</p>
<pre class="source-code">
// In the header:
template &lt;typename T&gt; class A {
  static inline T n {};
};</pre>
<p>This also works for non-template classes:</p>
<pre class="source-code">
// In the header:
class A {
  static inline int n = 0;
};</pre>
<p>If the static data member of a class template has a non-trivial constructor, this constructor is invoked once for every instantiation of this template (not for every object – there is only one instance of a static member variable for all objects of the same type).</p>
<p>Class templates, as we have used them so far, allow us to declare generic classes, that is, classes that can be instantiated with many different types. So far, all of these classes look exactly the same, except for the types, and generate the same code. This is not always desirable—different types may need to be handled somewhat differently.</p>
<p>For example, let’s say that we want to be able to represent not only a ratio of two numbers stored in the <code>Ratio</code> object but also a ratio of two numbers stored elsewhere, with the <code>Ratio</code> object containing pointers to these numbers. Clearly, some of the methods of the <code>Ratio</code> object, such as the conversion operator to <code>double</code>, need to be implemented differently <a id="_idIndexMarker097"/>if the object stores pointers to the numerator and denominator. In C++, this is accomplished by specializing the template, which we will do next.</p>
<h1 id="_idParaDest-35"><a id="_idTextAnchor074"/>Template specializations</h1>
<p>Template specializations allow us to make the generated template code differently for some types—not just the same code with different types substituted, but completely different code. There are two kinds of template speciali<a id="_idTextAnchor075"/>zations in C++—explicit, or full, specializations and partial specializat<a id="_idTextAnchor076"/>ion. Let’s start with the former.</p>
<h2 id="_idParaDest-36"><a id="_idTextAnchor077"/>Explicit specialization</h2>
<p>Explicit template <a id="_idIndexMarker098"/>specialization defines a special version of the template for a particular set of types. In an explicit specialization, all generic types are replaced by specific, concrete types. Since an explicit specialization is not a generic class or function, it does not need to be instantiated later. For the same reason, it is sometimes called <strong class="bold">full specialization</strong>. If the generic types are fully substituted, there is nothing generic left. An explicit specialization should not be confused with an explicit template instantiation—while both create an instantiation of a template for a given set of type arguments, an explicit instantiation creates an instantiation of the generic code, with the generic types substituted by the specific types. An explicit specialization creates an instantiation of the function or class with the same name but it overrides the implementation, so the resulting code can be completely different. An example should help us understand this distinction.</p>
<p>Let’s start with a class template. Let’s say that, if both the numerator and the denominator of <code>Ratio</code> are <code>double</code>, we want to compute the ratio and store it as a single number. The generic <code>Ratio</code> code should remain the same, but for one particular set of types, we want the class to look entirely different. We can do this with an explicit specialization:</p>
<pre class="source-code">
template &lt;&gt; class Ratio&lt;double, double&gt; {
  public:
  Ratio() : value_() {}
  template &lt;typename N, typename D&gt;
    Ratio(const N&amp; num, const D&amp; denom) :
      value_(double(num)/double(denom)) {}
  explicit operator double() const { return value_<a id="_idTextAnchor078"/>; }
  private:
  double value_;
};</pre>
<p>Both template type parameters are specified to be <code>double</code>. The class implementation is totally unlike the generic version—instead of two data members, we have just one; the conversion operator simply returns the value, and the constructor now computes the ratio of the numerator and the denominator. But it is not even the same constructor—instead of the non-template constructor <code>Ratio(const double&amp;, const double&amp;)</code> that the generic version would have if it was instantiated for two <code>double</code> template arguments, we provided a template constructor that can take two arguments of any types as long as they are convertible to <code>double</code>.</p>
<p>Sometimes, we don’t need to specialize the whole class template, because most of the generic code is still applicable. However, we may want to change the implementation of one or a few member functions. We can explicitly specialize the member function as well:</p>
<pre class="source-code">
template &lt;&gt; Ratio&lt;float, float&gt;::operator double() const {
  return num_/denom_;
}</pre>
<p>Template functions can be explicitly specialized as well. Again, unlike an explicit instantiation, we get to write the body of the function, and we can implement it any way we want:</p>
<pre class="source-code">
template &lt;typename T&gt; T do_something(T x) {
  return ++x;
}
template &lt;&gt; double do_something&lt;double&gt;(double x) {
  return x/2;
}
do_something(3);        // 4
do_something(3.0);    // 1.5</pre>
<p>We cannot, however, change the number or the types of arguments or the return type—they must match the result of the substitution of the generic types, so the following does not compile:</p>
<pre class="source-code">
template &lt;&gt; long do_something&lt;int&gt;(int x) { return x*x; }</pre>
<p>An explicit specialization must be declared before the first use of the template that would cause an implicit instantiation of the generic template for the same types. This makes sense—the implicit instantiation would create a class or a function with the same name and the same types as the explicit specialization. We would now have two versions of the same class or function in the program, and this violates the one definition rule and makes the program ill-formed (the exact rules can be found in th<a id="_idTextAnchor079"/>e standard under <em class="italic">[basic.def.odr]</em>).</p>
<p>Explicit specializations are useful when we have one or a few types for which we need the template to behave very differently. However, this does not solve our problem with the ratio of <a id="_idIndexMarker099"/>pointers—we want a specialization that is still <em class="italic">somewhat generic</em>, that is, it can handle pointers to any types, just not any other types<a id="_idTextAnchor080"/>. This is accomplished by a partial speciali<a id="_idTextAnchor081"/>zation, which we will look at next.</p>
<h2 id="_idParaDest-37"><a id="_idTextAnchor082"/>Partial specialization</h2>
<p>Now, we are<a id="_idIndexMarker100"/> getting to the really interesting part of C++ template programming—partial template specializations. When a class template is partially specialized, it remains as generic code, but <em class="italic">less generic</em> than the original template. The simplest form of a partial template is one where some of the generic types are replaced by concrete types, but other types remain generic:</p>
<pre class="source-code">
template &lt;typename N, typename D&gt; class Ratio {
  .....
};
template &lt;typename D&gt; class Ratio&lt;double, D&gt; {
  public:
  Ratio() : value_() {}
  Ratio(const double&amp; num, const D&amp; denom) :
    value_(num/double(denom)) {}
  explicit operator double() const { return value_; }
  private:
  double value_;
};</pre>
<p>Here, we convert <code>Ratio</code> to a <code>double</code> value if the numerator is <code>double</code>, regardless of the denominator type. More than one partial specialization can be defined for the same template. For example, we can also specialize for the case when the denominator is <code>double</code> and the <a id="_idIndexMarker101"/>numerator is anything:</p>
<pre class="source-code">
template &lt;typename N&gt; class Ratio&lt;N, double&gt; {
  public:
  Ratio() : value_() {}
  Ratio(const N&amp; num, const double&amp; denom) :
    value_(double(num)/denom) {}
  explicit operator double() const { return val<a id="_idTextAnchor083"/>ue_; }
  private:
  double value_;
};</pre>
<p>When the template is instantiated, the best specialization for the given set of types is selected. In our case, if neither the numerator nor the denominator is <code>double</code>, then the general template has to be instantiated—there are no other choices. If the numerator is <code>double</code>, then the first partial specialization is a better (more specific) match than the general template. If the denominator is <code>double</code>, then the second partial specialization is a better match. But what happens if both terms are <code>double</code>? In this case, the two partial specializations are equivalent; neither is more specific than the other. This situation is considered ambiguous and the instantiation fails. Note that only this particular instantiation, <code>Ratio&lt;double, double&gt;</code>, fails—it is not an error (at least, not a syntax error) to define both specializations, but it is an error to request an instantiation that cannot be uniquely resolved to the narrowest specialization. To allow any instantiation of our template, we have to remove this ambiguity, and the only way to do that is to provide an even more narrow specialization that would be preferred over the other two. In our case, there is only one option—a full specialization for <code>Ratio&lt;double, double&gt;</code>:</p>
<pre class="source-code">
template &lt;&gt; class Ratio&lt;double, double&gt; {
  public:
  Ratio() : value_() {}
  template &lt;typename N, typename D&gt;
    Ratio(const N&amp; num, const D&amp; denom) :
      value_(double(num)/double(denom)) {}
  explicit operator double() const { return value_; }
  private:
  double value_;
};</pre>
<p>Now, the fact that the partial specializations are ambiguous for the instantiation of <code>Ratio&lt;double, double&gt;</code> is no longer relevant—we have a more specific version of the template than either of them, so that version is preferred over both.</p>
<p>Partial specializations do not have to specify some of the generic types fully. Therefore, can keep all types generic, but impose some restrictions on them. For example, we still want a specialization where both the numerator and the denominator are pointers. They can be pointers to anything, so they are generic types, but <em class="italic">less generic</em> than the arbitrary types of the general template:</p>
<pre class="source-code">
template &lt;typename N, typename D&gt; class Ratio&lt;N*, D*&gt; {
  public:
  Ratio(N* num, D* denom) : num_(num), denom_(denom) {}
  explicit operator double() const {
    return double(*num_)/double(*denom_);
  }
  private:
  N* const num_;
  D* const denom_;
};
int i = 5; double x = 10;
auto r(make_ratio(&amp;i, &amp;x));        // Ratio&lt;int*, double*&gt;
double(r);                    // 0.5
x = 2.5;
double(r);                    // 2</pre>
<p>This partial specialization<a id="_idIndexMarker102"/> still has two generic types, but they are both pointer types, <code>N*</code> and <code>D*</code>, for any <code>N</code> and <code>D</code> types. The implementation is totally unlike that of the general template. When instantiated with two pointer types, the partial specialization is <em class="italic">more specific</em> than the general template and is considered a better match. Note that, in our example, the denominator is <code>double</code>. So why isn’t a partial specialization for the <code>double</code> denominator considered? That is because, while the denominator is <code>double</code> as far as the program logic is concerned, technically it is <code>double*</code>, a completely different type, and we do not have a specialization for that.</p>
<p>To define a specialization, a general template must first be declared. It does not, however, need to be defined—it is possible to specialize a template that does not exist in the general case. To do so, we must forward-declare the general template, then define all the specializations we need:</p>
<pre class="source-code">
template &lt;typename T&gt; class Value; // Declaration 
template &lt;typename T&gt; class Value&lt;T*&gt; {
  public:
  explicit Value(T* p) : v_(*p) {} private:
  T v_;
};
template &lt;typename T&gt; class Value&lt;T&amp;&gt; {
  public:
  explicit Value(T&amp; p) : v_(p) {}
  private:
  T v_;
};
int i = 5; int* p = &amp;i; int&amp; r = i;
Value&lt;int*&gt; v1(p); // T* specialization
V<a id="_idTextAnchor084"/>alue&lt;int&amp;&gt; v2(r); // T&amp; specialization</pre>
<p>Here, we have no general <code>Value</code> template, but we have partial specializations for any pointer or reference types. If we try to instantiate the template on some other type, like <code>int</code>, we will get an error stating that the <code>Value&lt;int&gt;</code> type is incomplete—this is no different than trying to define an object with only a forward declaration of the class.</p>
<p>So far, we have seen only examples of partial specializations for class templates. Unlike the earlier discussion of full specializations, we have not seen a single function specialization here. There is a very good reason for that—a partial function template specialization does not exist in C++. What is sometimes incorrectly called a partial specialization is <a id="_idIndexMarker103"/>nothing more than overloading template functions. On the other hand, overloading template functions can get quite comp<a id="_idTextAnchor085"/>lex and is worth <a id="_idTextAnchor086"/>learning about—we will cover this next.</p>
<h2 id="_idParaDest-38"><a id="_idTextAnchor087"/>Template function overloading</h2>
<p>We are used to regular<a id="_idIndexMarker104"/> functions, or class methods, being overloaded—multiple functions with the same name have different parameter types. Each call invokes the function with the best match of the parameter types to the call arguments, as shown in the following example:</p>
<pre class="source-code">
// Example 07
void whatami(int x) {
  std::cout &lt;&lt; x &lt;&lt; " is int" &lt;&lt; std::endl;
}
void whatami(long x) {
  std::cout &lt;&lt; x &lt;&lt; " is long" &lt;&lt; std::endl;
}
whatami(5);    // 5 is int
whatami(5.0);    // Compilation error</pre>
<p>If the arguments are a perfect match for one of the overloaded functions with the given name, that function is called. Otherwise, the compiler considers conversions to the parameter types of the available functions. If one of the functions offers <em class="italic">better</em> conversions, that function is selected. Otherwise, the call is ambiguous, just as in the last line of the preceding example. The precise definition of what constitutes the <em class="italic">best</em> conversion can be found in the standard (see the section <em class="italic">Overloading</em>, more specifically, subsection <em class="italic">[over.match]</em>). Generally, the <em class="italic">cheapest</em> conversions are the ones such as adding <code>const</code> or removing a reference; then, there are conversions between built-in types, conversions from derived to base class pointers, and so on. In the case of multiple arguments, each argument for the chosen function must have the best conversion. There <a id="_idIndexMarker105"/>is no <em class="italic">voting</em>—if a function has three arguments, and two are an exact match for the first overload, while the third one is an exact match for the second overload, then even if the remaining arguments are implicitly convertible to their corresponding parameter<a id="_idTextAnchor088"/> types, the overloaded call is ambiguous.</p>
<p>The presence of templates makes the overload resolution much more complex. Multiple function templates with the same name and, possibly, the same number of arguments, can be defined, in addition to non-template functions. All of these functions are the candidates for an overloaded function call, but the function templates can generate functions with different parameter types, so how do we decide what the actual overloaded functions are? The exact rules are even more complex than the ones for non-template functions, but the basic idea is this—if there is a non-template function that is a near-perfect match to the call arguments, that function is selected. The standard, of course, uses much more precise terms than <em class="italic">near-perfect</em>, but <em class="italic">trivial</em> conversions, such as adding <code>const</code>, fall under that category—you get them <em class="italic">at no cost</em>. If there is no such function, the compiler will attempt to instantiate all function templates with the same name to a near-perfect match, using the template argument deduction. If exactly one of the templates was instantiated, the function created by this instantiation is called. Otherwise, overload resolution continues the usual way among the non-template functions.</p>
<p>This is a very simplified description of a very complex process, but there are two important points—firstly, if there is an equally good match of a call to a template and a non-template function, the non-template function is preferred, and secondly, the compiler does not attempt to instantiate the function templates into something that might be convertible to the types we need. The template functions must match the call almost perfectly after the argument type deduction, or they are not called at all. Let’s add a template to our previous example:</p>
<pre class="source-code">
void whatami(int x); // Same as above
void whatami(long x); // Same as above
template &lt;typename T&gt; void whatami(T* x) {
  std::cout &lt;&lt; x &lt;&lt; " is a pointer" &lt;&lt; std::endl;
}
int i = 5;
whatami(i);    // 5 is int
whatami(&amp;i);    // 0x???? is a pointer</pre>
<p>Here, we have what looks <a id="_idIndexMarker106"/>like a partial specialization of a function template. But it really isn’t—it is just a function template—there is no general template for which it could be a specialization. Instead, it is simply a function template whose type parameter is deduced from the same arguments, but using different rules. The template can have its type deduced if the argument is a pointer of any kind. This includes a pointer to <code>const</code>—<code>T</code> could be a <code>const</code> type, so if we call <code>whatami(ptr)</code>, where <code>ptr</code> is <code>const int*</code>, that first template overload is a perfect match when <code>T</code> is <code>const int</code>. If the deduction succeeds, the function generated by the template, that is, the template instantiation, is added to the overload set.</p>
<p>For the <code>int*</code> argument, it is the only overload that works, so it is called. But what happens if more than one function template can match the call, and both instantiations are valid overloads? Let’s add one more template:</p>
<pre class="source-code">
void whatami(int x); // Same as above
void whatami(long x); // Same as above
template &lt;typename T&gt; void whatami(T* x); // Same as above
template &lt;typename T&gt; void whatami(T&amp;&amp; x) {
  std::cout &lt;&lt; "Something weird" &lt;&lt; std::endl;
}
class C {    };
C c;
whatami(c);    // Something weird
whatami(&amp;c);    // 0x???? is a pointer</pre>
<p>This template function accepts its arguments by the universal reference, so it can be instantiated for any call to <code>whatami()</code> with one argument. The first call, <code>whatami(c)</code>, is easy—the last overload, with <code>T&amp;&amp;</code>, is the only one that can be called. There are no conversions from <code>c</code> to a pointer or an integer. But the second call is tricky—we have not one, but two template instantiations that are a perfect match for the call, with no conversions needed. So why is this not an ambiguous overload? Because the rules for resolving overloaded function templates are different than the rules for non-template functions and resemble the rules for selecting the partial specialization of a class template (which is another reason why function template overloads are often<a id="_idIndexMarker107"/> confused with partial specializations). The template that is more specific is a better match.</p>
<p>In our case, the first template is more specific—it can accept any pointer argument, but only pointers. The second template can accept any argument at all, so any time the first template is a possible match, the second is too, but not the reverse. If a more specific template can be used to instantiate a function that is a valid overload, then this template is used.</p>
<p>Otherwise, we have to fall back to the more general template.</p>
<p>The very general template functions in the overload set sometimes lead to unexpected results. Let’s say we have the following three overloads for <code>int</code>, <code>double</code>, and anything:</p>
<pre class="source-code">
void whatami(int x) {
  std::cout &lt;&lt; x &lt;&lt; " is int" &lt;&lt; std::endl;
}
void whatami(double x) {
  std::cout &lt;&lt; x &lt;&lt; " is double" &lt;&lt; std::endl;
}
template &lt;typename T&gt; void whatami(T&amp;&amp; x) {
  std::cout &lt;&lt; "Something weird" &lt;&lt; std::endl;
}
int i = 5;
float x = 4.2;
whatami(i);    // i is int
whatami(x);    // Someth<a id="_idTextAnchor089"/>ing weird
whatami(1.2);    // 1.2 is double</pre>
<p>The first call has an <code>int</code> argument, so <code>whatami(int)</code> is a perfect match. The second call would have gone to <code>whatami(double)</code> if we did not have the template overload—the conversion from <code>float</code> to <code>double</code> is implicit (so is the conversion from <code>float</code> to <code>int</code>, but the conversion to <code>double</code> is preferred). But it’s still a conversion, so when the function template instantiates to a perfect match of <code>whatami(float&amp;&amp;)</code>, that <a id="_idIndexMarker108"/>is the best match and the chosen overload. The last call has a <code>double</code> argument, and again we have a perfect match to a non-template function <code>whatami(double)</code>, so it is preferred over any alternative.</p>
<p>It should be noted that overloading pass-by-value and pass-by-reference functions for the same parameter types often creates ambiguities in overload resolution. For example, these two functions are almost always ambiguous:</p>
<pre class="source-code">
template &lt;typename T&gt; void whatami(T&amp;&amp; x) {
  std::cout &lt;&lt; "Something weird" &lt;&lt; std::endl;
}
template &lt;typename T&gt; void whatami(T x) {
  std::cout &lt;&lt; "Something copyable" &lt;&lt; std::endl;
}
class C {};
C c;
whatami(c);</pre>
<p>As long as the argument to the function can be copied (and our object <code>c</code> is copyable), the overload is ambiguous and the call will not compile. The problem does not happen when a more specific function overloads a more general one (in all our previous examples, <code>whatami(int)</code> used pass-by-value with no problems), but mixing the two types of parameter passing for similarly general functions is inadvisable.</p>
<p>Finally, there is one more kind of function that has a special place in the overload resolution order—a variadic function.</p>
<p>A variadic function is declared with <code>...</code> instead of arguments, and it can be called with any number of arguments of any type (<code>printf</code> is one such function). This function is the overload of the last resort—it is called only if no other overloads can be used:</p>
<pre class="source-code">
void whatami(...) {
  std::cout &lt;&lt; "It's something or somethings" &lt;&lt; std::endl;
}</pre>
<p>As long as we have the overload <code>whatami(T&amp;&amp; x)</code> available, a variadic function will never be the preferred overload, at least not for any calls to <code>whatami()</code> with one argument. Without <a id="_idIndexMarker109"/>that template, <code>whatami(...)</code> is called for any argument that is not a number or a pointer. The variadic functions were around since the days of C, and are not to be confused with variadic templates that were introduce<a id="_idTextAnchor090"/>d in C<a id="_idTextAnchor091"/>++11, and this is what we’ll talk about next.</p>
<h1 id="_idParaDest-39"><a id="_idTextAnchor092"/>Variadic templates</h1>
<p>Probably the greatest<a id="_idIndexMarker110"/> difference between generic programming in C and C++ is type safety. It is possible to write generic code in C—the standard function <code>qsort()</code> is a perfect example—it can sort values of any type and they are passed in using a <code>void*</code> pointer, which can really be a pointer to any type. Of course, the programmer has to know what the real type is and cast the pointer to the right type. In a generic C++ program, the types are either explicitly specified or deduced at the time of the instantiation, and the type system for generic types is as strong as it is for regular types. Unless we want a function with an unknown number of arguments, that is, prior to C++11, the only way was the old C-style variadic functions where the compiler had no idea what the argument types were; the programmer just had to kno<a id="_idTextAnchor093"/>w and unpack the variable arguments correctly.</p>
<p>C++11 introduced the modern equivalent to a variadic function—a variadic template. We can now declare a generic function with any number of arguments:</p>
<pre class="source-code">
template &lt;typename ... T&gt; auto sum(const T&amp; ... x);</pre>
<p>This function takes one or more arguments, possibly of different types, and computes their sum. The return type is not easy to determine, but, fortunately, we can let the compiler figure it out—we just declare the return type as <code>auto</code>. How do we actually implement the function to add up the unknown number of values whose types we can’t name, not even as <a id="_idIndexMarker111"/>generic types? In C++17, it’s easy, because it has fold expressions:</p>
<pre class="source-code">
// Example 08a
template &lt;typename ... T&gt; auto sum(const T&amp; ... x) {
  return (x + ...);
}
sum(5, 7, 3);        // 15, int
sum(5, 7L, 3);        // 15, long
sum(5, 7L, 2.9);        // 14.9, double</pre>
<p>You can verify that the type of the result is what we say it is:</p>
<pre class="source-code">
static_assert(std::is_same_v&lt;
  decltype(sum(5, 7L, 2.9)), double&gt;);</pre>
<p>In C++14, as well as in C++17, when a fold expression is not sufficient (and they are useful only in limited contexts, mostly when the arguments and combines using binary or unary operators), the standard technique is recursion, which is ever-popular in template programming:</p>
<pre class="source-code">
// Example 08b
template &lt;typename T1&gt; auto sum(const T1&amp; x1) {
  return x1;
}
template &lt;typename T1, typename ... T&gt;
auto sum(const T1&amp; x1, const T&amp; ... x) {
  return x1 + sum(x ...);
}</pre>
<p>The first overload (not a partial specialization!) is for the <code>sum()</code> function with one argument of any type. That value is returned. The second overload is for more than one argument, and the first argument is explicitly added to the sum of the remaining arguments. The recursion continues until there is only one argument left, at which point the other overload is called and the recursion stops. This is the standard technique for unraveling the parameter packs in variadic templates, and we will see this many times in this book. The compiler will inline all the recursive function calls and generate straightforward code that adds all arguments together.</p>
<p>The class templates can also be variadic—they have an arbitrary number of type arguments and can build<a id="_idIndexMarker112"/> classes from a varying number of objects of different types. The declaration is similar to that of a function template. For example, let’s build a class template, <code>Group</code>, that can hold any number of objects of different types and return the right object when it’s converted to one of the types it holds:</p>
<pre class="source-code">
// Example 09
template &lt;typename ... T&gt; struct Group;</pre>
<p>The usual implementation of such templates is again recursive, using deeply nested inheritance, although a non-recursive implementation is sometimes possible. We will see one in the next section. The recursion has to be terminated when there is only one type parameter left. This is done using a partial specialization, so we will leave the general template we showed previously as a declaration only, and define a specialization for one type parameter:</p>
<pre class="source-code">
template &lt;typename ... T&gt; struct Group;
template &lt;typename T1&gt; struct Group&lt;T1&gt; {
  T1 t1_;
  Group() = default;
  explicit Group(const T1&amp; t1) : t1_(t1) {}
  explicit Group(T1&amp;&amp; t1) : t1_(std::move(t1)) {}
  explicit operator const T1&amp;() const { return t1_; }
  explicit operator T1&amp;() { return t1_; }
};</pre>
<p>This class holds the value of one type, <code>T1</code>, initializes it by copy or move and returns a reference to it when converted to the <code>T1</code> type. The specialization for an arbitrary number of type parameters contains the first one as a data member, together with the corresponding initialization and conversion methods, and inherits from the <code>Group</code> class template of the <a id="_idIndexMarker113"/>remaining types:</p>
<pre class="source-code">
template &lt;typename T1, typename ... T&gt;
struct Group&lt;T1, T ...&gt; : Group&lt;T ...&gt; {
  T1 t1_;
  Group() = default;
  explicit Group(const T1&amp; t1, T&amp;&amp; ... t) :
    Group&lt;T ...&gt;(std::forward&lt;T&gt;(t) ...), t1_(t1) {}
  explicit Group(T1&amp;&amp; t1, T&amp;&amp; ... t) :
    Group&lt;T...&gt;(std::forward&lt;T&gt;(t)...),
                t1_(std::move(t1)) {}
  explicit operator const T1&amp;() const { return t1<a id="_idTextAnchor094"/>_; }
  explicit operator T1&amp;() { return t1_; }
};</pre>
<p>For every type contained in a <code>Group</code> class, there are two possible ways it can be initialized—copy or move. Fortunately, we do not have to spell out the constructors for every combination of copy and move operations. Instead, we have two versions of the constructor for the two ways to initialize the first argument (the one stored in the specialization); we use perfect forwarding for the remaining arguments.</p>
<p>Now, we can use our <code>Group</code> class template to hold some values of different types (it cannot handle multiple values of the same type since the attempt to retrieve this type would be ambiguous):</p>
<pre class="source-code">
Group&lt;int, long&gt; g(3, 5);
int(g);    // 3
long(g);    // 5</pre>
<p>It is rather inconvenient to write all the group types explicitly and to make sure they match the argument types. In C++17, we can use a deduction guide to enable class template parameter deduction from the constructor:</p>
<pre class="source-code">
template &lt;typename ... T&gt; Group(T&amp;&amp;... t) -&gt; Group&lt;T...&gt;;
Group g(3, 2.2, std::string("xyz"));
int(g);            // 3
double(g);            // 2.2
std::string(g);        // "xyz"</pre>
<p>Before C++17, the <a id="_idIndexMarker114"/>usual solution to this problem is to use a helper function template (a variadic template, of course) to take advantage of the template argument deduction:</p>
<pre class="source-code">
template &lt;typename ... T&gt; auto makeGroup(T&amp;&amp; ... t) {
  return Group&lt;T ...&gt;(std::forward&lt;T&gt;(t) ...);
}
auto g = makeGroup(3, 2.2, std::string("xyz"));</pre>
<p>Note that the C++ standard library contains a class template, <code>std::tuple</code>, which is a much more complete and full-featured version of our <code>Group</code>.</p>
<p>Variadic templates can have non-type parameters as well; in this case, the <code>makeGroup</code> template can be instantiated with an arbitrary number of arguments. Often, these non-type parameter packs are used in combination with <code>auto</code> (deduced) types. For example, here is a template that holds a list of compile-time constant values of different types:</p>
<pre class="source-code">
// Example 10
template &lt;auto... Values&gt; struct value_list {};</pre>
<p>Without <code>auto</code> (i.e., prior to C++17) it is almost impossible to declare such a template since the types must be explicitly specified. Note that this is the entire template: it holds the constant values as a part of its definition. To extract them, we need another variadic template:</p>
<pre class="source-code">
template &lt;size_t N, auto... Values&gt;
struct nth_value_helper;
template &lt;size_t n, auto v1, auto... Values&gt;
struct nth_value_helper&lt;n, v1, Values...&gt; {
  static constexpr auto value =
    nth_value_helper&lt;n - 1, Values...&gt;::value;
};
template &lt;auto v1, auto... Values&gt;
struct nth_value_helper&lt;0, v1, Values...&gt; {
  static constexpr auto value = v1;
};
template &lt;size_t N, auto... Values&gt;
constexpr auto nth_value(value_list&lt;Values...&gt;) {
  return nth_value_helper&lt;N, Values...&gt;::value;
}</pre>
<p>The template<a id="_idIndexMarker115"/> function <code>nth_value</code> deduces the parameter pack <code>Values</code> from the type of the <code>value_list</code> argument (the argument itself contains no data and is of no interest except for its type). A recursive instantiation of partial class specializations is then used to iterate over the parameter pack until we get to the <code>N</code>-th value. Note that to store floating-point constants in this manner, we need C++20.</p>
<p>Variadic templates can be used in combination with template template parameters to resolve some of the problems created when, for example, standard library containers are used as arguments substituted for template template parameters. A simple solution is to declare the parameter as taking any number of types:</p>
<pre class="source-code">
template &lt;template &lt;typename...&gt; class Container,
         typename... T&gt;
void print(const Container&lt;T...&gt;&amp; container);
std::vector&lt;int&gt; v{ … };
print(v);</pre>
<p>Note that the <code>std::vector</code> template has two type parameters. In C++17, a standard change made this a valid match for the parameter pack specified in the <code>Container</code> template template parameter. Most compilers allowed such matches even earlier.</p>
<p>The variadic templates, especially combined with perfect forwarding, are extremely useful for writing very general template classes—for example, a vector can contain objects of an arbitrary type, and, to construct these objects in place instead of copying them, we have to call constructors with a different number of arguments. When the vector template is written, there is no way to know how many arguments are needed to initialize the objects the vector will contain, so a variadic template has to be used (indeed, the in-place constructors of <code>std::vector</code>, such as <code>emplace_back</code>, are variadic templates).</p>
<p>There is one more <a id="_idIndexMarker116"/>kind of template-like entity in C++ that we have to mention, one that has the appearance of both a class and a function—a lambd<a id="_idTextAnchor095"/><a id="_idTextAnchor096"/><a id="_idTextAnchor097"/>a expression. The next section is dedicated to this.</p>
<h1 id="_idParaDest-40"><a id="_idTextAnchor098"/>Lambda expressions</h1>
<p>In C++, the regular<a id="_idIndexMarker117"/> function syntax is extended with the concept of a <em class="italic">callable</em>, short for <em class="italic">callable entity</em>—a callable is something that can be called in the same way as a function. Some examples of callables are functions (of course), function pointers, or objects with the <code>operator()</code>, also<a id="_idIndexMarker118"/> known as <strong class="bold">functors</strong>:</p>
<pre class="source-code">
void f(int i); struct G {
  void operator()(int i);
};
f(5);            // Function
G g; g(5);        // Functor</pre>
<p>It is often useful to define a callable entity in a local context, right next to the place it is used. For example, to sort a sequence of objects, we may want to define a custom comparison function. We can use an ordinary function for this:</p>
<pre class="source-code">
bool compare(int i, int j) { return i &lt; j; }
void do_work() {
  std::vector&lt;int&gt; v;
  .....
  std::sort(v.begin(), v.end(), compare);
}</pre>
<p>However, in C++, functions cannot be defined inside other functions, so our <code>compare()</code> function may have to be defined quite far from the place it is used. If it is a single-use comparison function, such separation is inconvenient and reduces the readability and maintainability of the code.</p>
<p>There is a way <a id="_idIndexMarker119"/>around this limitation—while we cannot declare functions inside functions, we can declare classes, and classes can be callable:</p>
<pre class="source-code">
void do_work() {
  std::vector&lt;int&gt; v;
  .....
  struct compare {
    bool operator()(int i, int j) const { return i &lt; <a id="_idTextAnchor099"/>j; }
  };
  std::sort(v.begin(), v.end(), compare());
}</pre>
<p>This is compact and local, but rather verbose. We do not actually need to give this class a name, and we only ever want one instance of this class. In C++11, we have a much better option, the lambda expression:</p>
<pre class="source-code">
void do_work() {
  std::vector&lt;int&gt; v;
  .....
  auto compare = [](int i, int j) { return i &lt; j; };
  std::sort(v.begin(), v.end(), compare);
}</pre>
<p>If we use this comparison function for just one call to <code>std::sort</code>, we don’t even need to give it a name and can define it inside the call:</p>
<pre class="source-code">
  std::sort(v.begin(), v.end(),
            [](int i, int j) { return i &lt; j; });</pre>
<p>This is as compact as it gets. The return type can be specified, but can usually be deduced by the compiler. The lambda expression creates an object, so it has a type, but that type is generated by the compiler, so the object declaration must use <code>auto</code>.</p>
<p>The lambda expressions are objects, so they can have data members. Of course, a local callable class can also have data members. Usually, they are initialized from the local variables in the<a id="_idIndexMarker120"/> containing scope:</p>
<pre class="source-code">
// Example 11
void do_work() {
  std::vector&lt;double&gt; v;
  .....
  struct compare_with_tolerance {
    const double tolerance;
    explicit compare_with_tolerance(double tol) :
      tolerance(tol) {}
    bool operator()(double x, double y) const {
      return x &lt; y &amp;&amp; std::abs(x - y) &gt; tolerance;
    }
  };
  double tolerance = 0.01;
  std::sort(v.begin(), v.end(),
            compare_with_tolerance(tolerance));
}</pre>
<p>Again, this is a very verbose way to do something simple. We have to mention the tolerance variable three times—as a data member, a constructor argument, and in the member initialization list. A lambda expression makes this code simpler as well because it can capture local variables. In local classes, we are not allowed to reference variables from the containing scope, except by passing them through the constructor arguments, but for lambda expressions, the compiler automatically generates a constructor to capture all local variables mentioned in the body of the expression:</p>
<pre class="source-code">
void do_work() {
  s<a id="_idTextAnchor100"/>td::vector&lt;double&gt; v;
  .....
  double tolerance = 0.01;
  auto compare_with_tolerance = [=](auto x, auto y) {
    return x &lt; y &amp;&amp; std::abs(x - y) &gt; tolerance;
  };
  std::sort(v.begin(), v.end(), compare_with_tolerance);
}</pre>
<p>Here, the <a id="_idIndexMarker121"/>name <code>tolerance</code> inside the lambda expression refers to the local variable with the same name. The variable is captured by value, which is specified in the lambda expression’s capture clause <code>[=]</code>. We could have captured by reference using <code>[&amp;]</code> like this:</p>
<pre class="source-code">
auto compare_with_tolerance = [&amp;](auto x, auto y) {
  return x &lt; y &amp;&amp; std::abs(x - y) &gt; tolerance;
};</pre>
<p>The difference is that, when capturing by value, a copy of the captured variable is created inside the lambda object at the point where it is constructed. This local copy is <code>const</code> by default, although we can declare the lambda mutable, which would let us change the captured values:</p>
<pre class="source-code">
double tolerance = 0.01;
size_t count = 0; // line 2
auto compare_with_tolerance = [=](auto x, auto y) mutable {
  std::cout &lt;&lt; "called " &lt;&lt; ++count &lt;&lt; " times\n";
  return x &lt; y &amp;&amp; std::abs(x - y) &gt; tolerance;
};
std::vector&lt;double&gt; v;
… store values in v …
// Counts calls but does not change the value on line 2
std::sort(v.begin(), v.end(), compare_with_tolerance);</pre>
<p>On the other hand, capturing the variables from the outer scope by reference makes every mention <a id="_idIndexMarker122"/>of this variable inside the lambda a reference to the original variable. Values captured by reference can be changed:</p>
<pre class="source-code">
double tolerance = 0.01;
size_t count = 0;
auto compare_with_tolerance = [&amp;](auto x, auto y) mutable {
  ++count; // Changes count above
  return x &lt; y &amp;&amp; std::abs(x - y) &gt; tolerance;
};
std::vector&lt;double&gt; v;
… store values in v …
std::sort(v.begin(), v.end(), compare_with_tolerance);
std::cout &lt;&lt; "lambda called " &lt;&lt; count &lt;&lt; " times\n";</pre>
<p>It is also possible to explicitly capture some variables by value or by reference; for example, the capture <code>[=, &amp;count]</code> captures everything by value except <code>count</code>, which is captured by reference.</p>
<p>Instead of changing the arguments of the lambda expression from <code>int</code> in the earlier example to <code>double</code>, we can declare them as <code>auto</code>, which effectively makes the <code>operator()</code> of the lambda expression a template (this is a C++14 feature).</p>
<p>Lambda expressions are most commonly used as local functions. However, they are not really functions; they are callable objects, and so they are missing one feature that functions have—the ability to overload them. The last trick we will learn in this section is how to work around that and create an overload set from lambda expressions.</p>
<p>First, the main idea—it is indeed impossible to overload callable objects. On the other hand, it is very easy to overload several <code>operator()</code> methods in the same object—methods are overloaded like any other function. Of course, the <code>operator()</code> of a lambda expression object is generated by the compiler, not declared by us, so it is not possible to force the compiler to generate more than one <code>operator()</code> in the same lambda expression. But classes have their own advantages, the main one being that we can inherit from them.</p>
<p>Lambda expressions are objects—their types are classes, so we can inherit from them too. If a class inherits publicly from a base class, all public methods of the base class become public methods of the derived class. If a class inherits publicly from several base classes (multiple inheritance), its public interface is formed from all the public methods of all the base classes. If there are multiple methods with the same name in this set, they become<a id="_idIndexMarker123"/> overloaded and the usual overloading resolution rules apply (in particular, it is possible to create an ambiguous set of overloads, in which case the program will not compile).</p>
<p>So, we need to create a class that automatically inherits from any number of base classes. We have just seen the right tool for that—variadic templates. As we have learned in the previous section, the usual way to iterate over an arbitrary number of items in the parameter pack of a variadic template is through recursion:</p>
<pre class="source-code">
// Example 12a
template &lt;typename ... F&gt; struct overload_set;
template &lt;typename F1&gt;
struct overload_set&lt;F1&gt; : public F1 {
  overload_set(F1&amp;&amp; f1) : F1(std::move(f1)) {}
  ove<a id="_idTextAnchor101"/>rload_set(const F1&amp; f1) : F1(f1) {}
  using F1::operator();
};
template &lt;typename F1, typename ... F&gt;
struct overload_set&lt;F1, F ...&gt; :
    public F1, public overload_set&lt;F ...&gt; {
  overload_set(F1&amp;&amp; f1, F&amp;&amp; ... f) :
    F1(std::move(f1)),
    overload_set&lt;F ...&gt;(std::forward&lt;F&gt;(f) ...) {}
  overload_set(const F1&amp; f1, F&amp;&amp; ... f) :
    F1(f1), overload_set&lt;F ...&gt;(std::forward&lt;F&gt;(f) ...) {}
  using F1::operator();
  using overload_set&lt;F ...&gt;::operator();
};
template &lt;typename ... F&gt; auto overload(F&amp;&amp; ... f) {
  return overload_set&lt;F ...&gt;(std::forward&lt;F&gt;(f) ...);
}</pre>
<p>The <code>overload_set</code> is a variadic class template; the general template has to be declared before we can<a id="_idIndexMarker124"/> specialize it, but it has no definition. The first definition is for the special case of only one lambda expression—the <code>overload_set</code> class inherits from the lambda expression and adds its <code>operator()</code> to its public interface. The specialization for <code>N</code> lambda expressions (<code>N&gt;1</code>) inherits from the first one and from the <code>overload_set</code> constructed from the remaining <code>N-1</code> lambda expressions. Finally, we have a helper function that constructs the overload set from any number of lambda expressions—in our case, this is a necessity and not mere convenience since we cannot explicitly specify the types of the lambda expressions, but have to let the function template deduce them. Now, we can construct an overload set from any number of lambda expressions:</p>
<pre class="source-code">
int i = 5;
double d = 7.3;
auto l = overload(
  [](int* i) { std::cout &lt;&lt; "i=" &lt;&lt; *i &lt;&lt; std::endl; },
  [](double* d) { std::cout &lt;&lt; "d=" &lt;&lt; *d &lt;&lt; std::endl; }
);
l(&amp;i);    // i=5
l(&amp;d);    // d=5.3</pre>
<p>This solution is not perfect, because it does not handle ambiguous overloads well. In C++17, we can do better, and it gives us a chance to demonstrate an alternative way of using a parameter pack that does not need recursion. Here is the C++17 version:</p>
<pre class="source-code">
// Example 12b
template &lt;typename ... F&gt;
struct overload_set : public F ... {
  overload_set(F&amp;&amp; ... f) : F(std::fo<a id="_idTextAnchor102"/>rward&lt;F&gt;(f)) ... {}
  using F::operator() ...;    // C++17
};
template &lt;typename ... F&gt; auto overload(F&amp;&amp; ... f) {
  return overload_set&lt;F ...&gt;(std::forward&lt;F&gt;(f) ...);
}</pre>
<p>The variadic template <a id="_idIndexMarker125"/>does not rely on partial specializations anymore; instead, it inherits directly from the parameter pack (this part of the implementation works in C++14 as well, but the <code>using</code> declaration needs C++17). The template helper function is the same—it deduces the types of all lambda expressions and constructs an object from the <code>overload_set</code> instantiation with these types. The lambda expressions themselves are passed to the base classes using perfect forwarding, where they are used to initialize all the base objects of the <code>overload_set</code> objects (lambda expressions are movable). Without the need for recursion or partial specialization, this is a much more compact and straightforward template. Its use is identical to the previous version of <code>overload_set</code>, but it handles near-ambiguous overloads better.</p>
<p>We can get rid of the template function as well and use template deduction guides:</p>
<pre class="source-code">
// Example 12c
template &lt;typename ... F&gt;
struct overload : public F ... {
  using F::operator() ...;
};
template &lt;typename ... F&gt; // Deduction guide
overload(F&amp;&amp; ... ) -&gt; overload&lt;F ...&gt;;</pre>
<p>The use of the <code>overload</code> template remains largely unchanged; note the curly braces used to construct an object:</p>
<pre class="source-code">
int i = 5;
double d = 7.3;
auto l = overload{
  [](int* i) { std::cout &lt;&lt; "i=" &lt;&lt; *i &lt;&lt; std::endl; },
  [](double* d) { std::cout &lt;&lt; "d=" &lt;&lt; *d &lt;&lt; std::endl; },
};
l(&amp;i);    // i=5
l(&amp;d);    // d=5.3</pre>
<p>We will see lambdas used extensively in later chapters of this book when we will need to write a fragment of code and attach it to an object so that it can be executed later.</p>
<p>Next, we are going to learn about a new C++ feature that, in a way, does the opposite of what we were trying to do so far: it makes templates <em class="italic">less</em> general. As we have seen already, it is easy<a id="_idIndexMarker126"/> to over-promise with a template: we can define templates whose definitions then do not compile in some cases. It would be better to make any restrictions on the template arguments to<a id="_idTextAnchor103"/> be a part of the declaration, so let us see how that is done.</p>
<h1 id="_idParaDest-41"><a id="_idTextAnchor104"/>Concepts</h1>
<p>C++20 introduced<a id="_idIndexMarker127"/> a major enhancement to the C++ template machinery: concepts.</p>
<p>In C++20, templates (both class and function templates), as well as non-template functions (members of class templates, usually) may use a constraint to specify the requirements on template arguments. These constraints are useful to produce better error messages, but they are truly indispensable when there is a need to select a function overload or a template specialization based on some properties of template arguments.</p>
<p>The basic syntax for a constraint is quite simple: a constraint is introduced by the keyword <code>requires</code> which<a id="_idIndexMarker128"/> can be specified after the function declaration or before the return type (in this book, we use both ways interchangeably so the reader becomes familiar with different styles of writing code). The expression itself usually uses the template parameters and must evaluate to a boolean value, for example:</p>
<pre class="source-code">
// Example 13a
template &lt;typename T&gt; T copy(T&amp;&amp; t)
  requires (sizeof(T) &gt; 1)
{
  return std::forward&lt;T&gt;(t);
}</pre>
<p>Here the function <code>copy()</code> requires that the type of its argument has a size of at least two bytes. If we <a id="_idIndexMarker129"/>attempt to call this function <a id="_idIndexMarker130"/>with a <code>char</code> argument, the call will not compile. Note that if a constraint is violated, it is as if the function did not exist for the purposes of a particular call: if there is another overload, it will be considered next even if, without the constraint, the overloads were ambiguous.</p>
<p>Here is a more complex (and more useful) example:</p>
<pre class="source-code">
template &lt;typename T1, typename T2&gt;
std::common_type_t&lt;T1, T2&gt; min2(T1&amp;&amp; t1, T2&amp;&amp; t2)
{
  if (t1 &lt; t2) return std::forward&lt;T1&gt;(t1);
  return std::forward&lt;T2&gt;(t2);
}</pre>
<p>This is a function similar to <code>std::min</code>, except it takes two arguments of different types. This creates two potential issues: first, what is the return type? The return value is one of the two arguments, but there has to be a single return type. We can use the <code>std::common_type</code> trait from the <code>&lt;type_traits&gt;</code> header as a reasonable answer: for numeric types, it does the usual type promotion, for classes, it converts from base class to derived class if possible, and it respects implicit user-specified conversions. But there is a second problem: if the expression <code>t1 &lt; t2</code> does not compile, we get an error in the body of the function. This is unfortunate because the error is hard to analyze and may be misleading: it suggests that the body of the function is implemented incorrectly. We can address the second concern by adding a static assert:</p>
<pre class="source-code">
static_assert(sizeof(t1 &lt; t2) &gt; 0);</pre>
<p>This at least makes clear that we intended for the code to not compile if there is no matching <code>operator&lt;()</code>. Note<a id="_idIndexMarker131"/> the weird way we had to formulate the assert: the expression <code>t1 &lt; t2</code> itself must, in general, evaluate at run time, and is just as likely to be false. We need a compile-time value, and we don’t care which argument is less, just that they can <a id="_idIndexMarker132"/>be compared. So we assert something not about the result of the comparison but about the size of this result: <code>sizeof()</code> is always a compile-time value and the size of anything is at least 1 in C++. The only way this assertion can fail is if the expression does not compile at all.</p>
<p>This still does not solve the other part of the problem: the requirement on the argument types is not included in the interface of the function. The function can be called on any two types and then may or may not compile. With C++20 constraints, we can move the requirement from the implicit (compilation failure) or explicit (static assert) error in the function body to the function declaration and make it part of the function interface:</p>
<pre class="source-code">
// Example 13b
template &lt;typename T1, typename T2&gt;
std::common_type_t&lt;T1, T2&gt; min2(T1&amp;&amp; t1, T2&amp;&amp; t2)
  requires (sizeof(t1 &lt; t2) &gt; 0)
{
  if (t1 &lt; t2) return std::forward&lt;T1&gt;(t1);
  return std::forward&lt;T2&gt;(t2);
}</pre>
<p>As you learn to build more complex constraints, it is important to remember that the constraint expression must evaluate to a <code>bool</code> value; no conversions whatsoever are permitted, which is why a very similar expression does not work:</p>
<pre class="source-code">
template &lt;typename T1, typename T2&gt;
std::common_type_t&lt;T1, T2&gt; min2(T1&amp;&amp; t1, T2&amp;&amp; t2)
  requires (sizeof(t1 &lt; t2));</pre>
<p>The integer value of <code>sizeof()</code> is always non-zero and would have converted to <code>true</code>, but not in this context. The good news is that we don’t have to use the <code>sizeof()</code> hack at all to write constraints. There is yet another type of constraint expression, a <em class="italic">requires expression</em>, that is much more powerful and expresses our intent much clearer:</p>
<pre class="source-code">
// Example 13b
template &lt;typename T1, typename T2&gt;
std::common_type_t&lt;T1, T2&gt; min2(T1&amp;&amp; t1, T2&amp;&amp; t2)
  requires (requires { t1 &lt; t2; });</pre>
<p>The requires expression <a id="_idIndexMarker133"/>begins with the <code>requires</code> keyword followed by braces <code>{}</code>; it can contain any number of expressions that have to compile, or the value of the entire requires expression is false (it does not matter what the results of these expressions are, they just have to be valid C++). You can also use types, type traits, and combinations of requirements of different kinds. By a quirk of the language, the parentheses around the requires expression are optional, which means you can see code like <code>requires requires { t1 &lt; t2 }</code> where the first and the second <code>requires</code> are completely different keywords.</p>
<p>The requirements on template types can be quite complex; often, the same requirements apply in many different templates. Sets of such requirements can be given names and defined for later use; these named requirements are called concepts. Each concept is a condition that is evaluated at compile time when used in a constraint.</p>
<p>The syntax for a constraint is similar to a template:</p>
<pre class="source-code">
// Example 13c
template &lt;typename T1, typename T2&gt; concept Comparable =
  requires(T1 t1, T2 t2) { t1 &lt; t2; };</pre>
<p>We are not going to cover the syntax in detail in this book – for that, use a reference source such as <a href="http://cppreference.com">cppreference.com</a>. A concept can be used instead of the requirement it contains:</p>
<pre class="source-code">
template &lt;typename T1, typename T2&gt;
std::common_type_t&lt;T1, T2&gt; min2(T1&amp;&amp; t1, T2&amp;&amp; t2)
  requires Comparable&lt;T1, T2&gt;;</pre>
<p>Concepts that constrain a single type can also be used as template parameter placeholders. Let us consider an <a id="_idIndexMarker134"/>example of a <code>swap()</code> function. For integral types, there is a trick that allows us to swap two values without using a temporary variable. It relies on the properties of a bitwise XOR operation. Let us assume, for the purposes of this demonstration, that, on a particular hardware, this version is faster than the usual way of implementing swap. We would like to write a swap template function <code>MySwap(T&amp; a, T&amp; b)</code> that automatically detects whether the type T supports an XOR operation and <a id="_idIndexMarker135"/>use it, if available; otherwise we fall back on the usual swap.</p>
<p>First, we need a concept for a type that supports XOR:</p>
<pre class="source-code">
// Example 14a,b
template &lt;typename T&gt; concept HasXOR =
  requires(T a, T b) { a ^ b; };</pre>
<p>The concept has a requires expression; every expression inside the curly braces must compile, otherwise, the requirement of the concept is not met.</p>
<p>Now, we can implement an XOR-based swap template. We could do it with a <code>requires</code> constraint, but there is a more compact way:</p>
<pre class="source-code">
template &lt;HasXOR T&gt; void MySwap(T&amp; x, T&amp; y) {
     x = x ^ y;
     y = x ^ y;
     x = x ^ y;
}</pre>
<p>The concept name <a id="_idIndexMarker136"/><code>HasXOR</code> can be used instead of the <code>typename</code> keyword to declare the template parameter. This restricts our <code>MySwap()</code> function to the <a id="_idIndexMarker137"/>types that have <code>operator^()</code>. But we need a general case overload, too. We should also note that <em class="italic">general</em> does not mean <em class="italic">any</em> in our case: the type has to support move assignment and move construction. We need another concept:</p>
<pre class="source-code">
template &lt;typename T&gt; concept Assignable =
  requires(T a, T b) {
    T(std::move(b));
    b = std::move(a);
  };</pre>
<p>This is a very similar concept, except we have two expressions; both must be valid for the concept to be true.</p>
<p>The second <code>MySwap()</code> overload accepts all <code>Assignable</code> types. However, we must explicitly exclude the types with XOR, or we will have ambiguous overloads. This is a perfect example <a id="_idIndexMarker138"/>to show that we can combine concepts as template placeholders with concepts in requirements:</p>
<pre class="source-code">
template &lt;Assignable T&gt; void MySwap(T&amp; x, T&amp; y)
  requires (!HasXOR&lt;T&gt;)
{
  T tmp(std::move(x));
  x = std::move(y);
  y = std::move(tmp);
}</pre>
<p>Now a call to <code>MySwap()</code> will select the XOR-based overload if possible, otherwise, it will use the general overload (swapping non-assignable types will not compile at all).</p>
<p>Finally, let us return to one of the first examples in this chapter: that of a class template <code>ArrayOf2</code> in the section “<em class="italic">Class templates</em>.” Recall that it has a member function sum() which has much more strict requirements on the template type than the rest of the class: it adds the values of the array elements. If the elements do not have <code>operator+()</code>, there is no problem as long as we don’t call <code>sum()</code>, but if we do, we get a syntax error. It would have been better if this function was not a part of the class interface at all unless the type supports it. We can accomplish this with a constraint:</p>
<pre class="source-code">
// Example 15
template &lt;typename T&gt; class ArrayOf2 {
  public:
  T&amp; operator[](size_t i) { return a_[i]; }
  const T&amp; operator[](size_t i) const { return a_[i]; }
  T sum() const requires (requires (T a, T b) { a + b; }) {
    return a_[0] + a_[1];
  }
  private:
  T a_[2];
};</pre>
<p>If the expression <code>a + b</code> does not compile, the code behaves as if there was no member function <code>sum()</code> declared in the class interface. Of course, we could also use a named concept for this.</p>
<p>We will see more<a id="_idIndexMarker139"/> ways to manage requirements on template parameters in <a href="B19262_07.xhtml#_idTextAnchor314"><em class="italic">Chapter 7</em></a>. For now, let us review what we have learned and go on to use these tools to solve common C++ problems.</p>
<h1 id="_idParaDest-42"><a id="_idTextAnchor105"/>Summary</h1>
<p>Templates, variadic templates, and lambda expressions are all powerful features of C++, offering simplicity in use, but are rich in complex details. The examples in this chapter should serve to prepare the reader for the later chapters of this book, where we use these techniques to implement design patterns, both classic and novel, with the tools of the modern C++ language. The reader wishing to learn the art of using these complex and powerful tools to their fullest potential is referred to other books that are dedicated to teaching these subjects, some of which can be found at the end of this chapter.</p>
<p>The reader is now ready to learn common C++ idioms,<a id="_idTextAnchor106"/> starting with idioms for expressing memory ownership, in the next chapter.</p>
<h1 id="_idParaDest-43"><a id="_idTextAnchor107"/>Questions</h1>
<ol>
<li>What is the difference between a type and a template?</li>
<li>What kind of templates does C++ have?</li>
<li>What kinds of template parameters do C++ templates have?</li>
<li>What is the difference between a template specialization and a template instantiation?</li>
<li>How can you access the parameter pack of a variadic template?</li>
<li>What a<a id="_idTextAnchor108"/>re lambda expressions used for?</li>
<li>How do concepts refine template interfaces?</li>
</ol>
<h1 id="_idParaDest-44"><a id="_idTextAnchor109"/>Further reading</h1>
<ul>
<li><em class="italic">C++ </em><em class="italic">Fundamentals</em>: <a href="https://www.packtpub.com/product/c-fundamentals">https://www.packtpub.com/product/c-fundamentals</a></li>
<li><em class="italic">C++ Data Structures and </em><em class="italic">Algorithms</em>: <a href="https://www.packtpub.com/product/c-data-structures-and-algorithms">https://www.packtpub.com/product/c-data-structures-and-algorithms</a></li>
<li><em class="italic">Mastering C++ </em><em class="italic">Programming</em>: <a href="https://www.packtpub.com/product/mastering-c-programming">https://www.packtpub.com/product/mastering-c-programming</a></li>
</ul>
</div>
</body></html>