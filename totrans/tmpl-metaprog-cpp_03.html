<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer007">
			<h1 id="_idParaDest-25"><em class="italic"><a id="_idTextAnchor024"/>Chapter 2</em>: Template Fundamentals</h1>
			<p>In the previous chapter, we saw a short introduction to templates. What they are, how they are helpful, pros and cons for using templates, and, also, a few examples of function and class templates. In this chapter, we will explore this area in detail, and look at aspects such as template parameters, instantiation, specializations, aliases, and more. The main topics that you will learn about from this chapter are as follows:</p>
			<ul>
				<li>How to define function templates, class templates, variable templates, and alias templates</li>
				<li>What kinds of template parameters exist?</li>
				<li>What is template instantiation?</li>
				<li>What is template specialization?</li>
				<li>How to use generic lambdas and lambda templates</li>
			</ul>
			<p>By the end of this chapter, you will be familiar with the core fundamentals of templates in C++ and be able to understand large areas of template code and also write templates by yourself.</p>
			<p>To start this chapter, we will explore the details of defining and using function templates.</p>
			<h1 id="_idParaDest-26"><a id="_idTextAnchor025"/>Defining function templates</h1>
			<p>Function templates are defined in a similar way to regular functions, except that the function declaration is <a id="_idIndexMarker037"/>preceded by the keyword <strong class="source-inline">template</strong> followed by a list of template parameters between angle brackets. The following is a simple example of a function template:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">T add(T const a, T const b)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return a + b;</pre>
			<pre class="source-code">}</pre>
			<p>This function has two parameters, called <strong class="source-inline">a</strong> and <strong class="source-inline">b</strong>, both of the same <strong class="source-inline">T</strong> type. This type is listed in the template parameters list, introduced with the keyword <strong class="source-inline">typename</strong> or <strong class="source-inline">class</strong> (the former is used in this example and throughout the book). This function does nothing more than add the two arguments and returns the result of this operation, which should have the same <strong class="source-inline">T</strong> type.</p>
			<p>Function templates are only blueprints for creating actual functions and only exist in source code. Unless explicitly called in your source code, the function templates will not be present in the compiled executable. However, when the compiler encounters a call to a function template <a id="_idIndexMarker038"/>and is able to match the supplied arguments and their types to a function template's parameters, it generates an actual function from the template and the arguments used to invoke it. To understand this, let's look at some examples:</p>
			<pre class="source-code">auto a = add(42, 21);</pre>
			<p>In this snippet, we call the <strong class="source-inline">add</strong> function with two <strong class="source-inline">int</strong> parameters, <strong class="source-inline">42</strong> and <strong class="source-inline">21</strong>. The compiler is able to deduce the template parameter <strong class="source-inline">T</strong> from the type of the supplied arguments, making it unnecessary to explicitly provide it. However, the following two invocations are also possible, and, in fact, identical to the earlier one:</p>
			<pre class="source-code">auto a = add&lt;int&gt;(42, 21);</pre>
			<pre class="source-code">auto a = add&lt;&gt;(42, 21);</pre>
			<p>From this invocation, the compiler will generate the following function (keep in mind that the actual code may differ for various compilers):</p>
			<pre class="source-code">int add(const int a, const int b)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">  return a + b;</pre>
			<pre class="source-code">}</pre>
			<p>However, if we change the call to the following form, we explicitly provide the argument for the template parameter <strong class="source-inline">T</strong>, as the <strong class="source-inline">short</strong> type:</p>
			<pre class="source-code">auto b = add&lt;short&gt;(42, 21);</pre>
			<p>In this case, the compiler will generate another instantiation of this function, with <strong class="source-inline">short</strong> instead of <strong class="source-inline">int</strong>. This new instantiation would look as follows:</p>
			<pre class="source-code">short add(const short a, const int b)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">  return static_cast&lt;short&gt;(a + b);</pre>
			<pre class="source-code">}</pre>
			<p>If the type of the two parameters is ambiguous, the compiler will not be able to deduce them automatically. This is the case with the following invocation:</p>
			<pre class="source-code">auto d = add(41.0, 21);</pre>
			<p>In this example, <strong class="source-inline">41.0</strong> is a <strong class="source-inline">double</strong> but <strong class="source-inline">21</strong> is an <strong class="source-inline">int</strong>. The <strong class="source-inline">add</strong> function template has two parameters of the same type, so the compiler is not able to match it with the supplied arguments <a id="_idIndexMarker039"/>and will issue an error. To avoid this, and suppose you expected it to be instantiated for <strong class="source-inline">double</strong>, you have to specify the type explicitly, as shown in the following snippet:</p>
			<pre class="source-code">auto d = add&lt;double&gt;(41.0, 21);</pre>
			<p>As long as the two arguments have the same type and the <strong class="source-inline">+</strong> operator is available for the type of the arguments, you can call the function template <strong class="source-inline">add</strong> in the ways shown previously. However, if the <strong class="source-inline">+</strong> operator is not available, then the compiler will not be able to generate an instantiation, even if the template parameters are correctly resolved. This is shown in the following snippet:</p>
			<pre class="source-code">class foo</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   int value;</pre>
			<pre class="source-code">public:</pre>
			<pre class="source-code">   explicit foo(int const i):value(i)</pre>
			<pre class="source-code">   { }</pre>
			<pre class="source-code">   explicit operator int() const { return value; }</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">auto f = add(foo(42), foo(41));</pre>
			<p>In this case, the compiler will issue an error that a binary <strong class="source-inline">+</strong> operator is not found for arguments of type <strong class="source-inline">foo</strong>. Of course, the actual message differs for different compilers, which is the case for all errors. To make it possible to call <strong class="source-inline">add</strong> for arguments of type <strong class="source-inline">foo</strong>, you'd have to overload the <strong class="source-inline">+</strong> operator for this type. A possible implementation is the following:</p>
			<pre class="source-code">foo operator+(foo const a, foo const b)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">  return foo((int)a + (int)b);</pre>
			<pre class="source-code">}</pre>
			<p>All the examples that we have seen so far represented templates with a single template parameter. However, a template <a id="_idIndexMarker040"/>can have any number of parameters and even a variable number of parameters. This latter topic will be addressed in <a href="B18367_03_ePub.xhtml#_idTextAnchor051"><em class="italic">Chapter 3</em></a>, <em class="italic">Variadic Templates</em>. The next function is a function template that has two type template parameters:</p>
			<pre class="source-code">template &lt;typename Input, typename Predicate&gt;</pre>
			<pre class="source-code">int count_if(Input start, Input end, Predicate p)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   int total = 0;</pre>
			<pre class="source-code">   for (Input i = start; i != end; i++)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      if (p(*i))</pre>
			<pre class="source-code">         total++;</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   return total;</pre>
			<pre class="source-code">}</pre>
			<p>This function takes two input iterators to the start and end of a range and a predicate and returns the number of elements in the range that match the predicate. This function, at least conceptually, is very similar to the <strong class="source-inline">std::count_if</strong> general-purpose function from the <strong class="source-inline">&lt;algorithm&gt;</strong> header in the standard library and you should always prefer to use <a id="_idIndexMarker041"/>standard algorithms over hand-crafted implementations. However, for the purpose of this topic, this function is a good example to help you understand how templates work. </p>
			<p>We can use the <strong class="source-inline">count_if</strong> function as follows:</p>
			<pre class="source-code">int main()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   int arr[]{ 1,1,2,3,5,8,11 };</pre>
			<pre class="source-code">   int odds = count_if(</pre>
			<pre class="source-code">                 std::begin(arr), std::end(arr), </pre>
			<pre class="source-code">                 [](int const n) { return n % 2 == 1; });</pre>
			<pre class="source-code">   std::cout &lt;&lt; odds &lt;&lt; '\n';</pre>
			<pre class="source-code">}</pre>
			<p>Again, there is no need to explicitly specify the arguments for the type template parameters (the type of the input iterator and the type of the unary predicate) because the compiler is able to infer them from the call.</p>
			<p>Although there are more things to learn about function templates, this section provided an introduction to working with them. Let's now learn the basics of defining class templates.</p>
			<h1 id="_idParaDest-27"><a id="_idTextAnchor026"/>Defining class templates</h1>
			<p>Class templates are declared in a very similar manner, with the <strong class="source-inline">template</strong> keyword and the template <a id="_idIndexMarker042"/>parameter list preceding the class declaration. We saw the first example in the introductory chapter. The next snippet shows a class template called <strong class="source-inline">wrapper</strong>. It has a single template parameter, a type called <strong class="source-inline">T</strong>, that is used as the type for data members, parameters, and function return types:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">class wrapper</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">public:</pre>
			<pre class="source-code">   wrapper(T const v): value(v)</pre>
			<pre class="source-code">   { }</pre>
			<pre class="source-code">   T const&amp; get() const { return value; }</pre>
			<pre class="source-code">private:</pre>
			<pre class="source-code">   T value;</pre>
			<pre class="source-code">};</pre>
			<p>As long as the class template is not used anywhere in your source code, the compiler will not generate <a id="_idIndexMarker043"/>code from it. For that to happen, the class template must be instantiated and all its parameters properly matched to arguments either explicitly, by the user, or implicitly, by the compiler. Examples for instantiating this class template are shown next:</p>
			<pre class="source-code">wrapper a(42);           // wraps an int</pre>
			<pre class="source-code">wrapper&lt;int&gt; b(42);      // wraps an int</pre>
			<pre class="source-code">wrapper&lt;short&gt; c(42);    // wraps a short</pre>
			<pre class="source-code">wrapper&lt;double&gt; d(42.0); // wraps a double</pre>
			<pre class="source-code">wrapper e("42");         // wraps a char const *</pre>
			<p>The definitions of <strong class="source-inline">a</strong> and <strong class="source-inline">e</strong> in this snippet are only valid in C++17 and onward thanks to a feature called <strong class="bold">class template argument deduction</strong>. This feature enables us to use class templates <a id="_idIndexMarker044"/>without specifying any template argument, as long as the compiler is able to deduce them all. This will be discussed in <a href="B18367_04_ePub.xhtml#_idTextAnchor064"><em class="italic">Chapter 4</em></a>, <em class="italic">Advanced Template Concepts</em>. Until then, all examples that refer to class templates will explicitly list the arguments, as in <strong class="source-inline">wrapper&lt;int&gt;</strong> or <strong class="source-inline">wrapper&lt;char const*&gt;</strong>.</p>
			<p>Class templates can be declared without being defined and used in contexts where incomplete types are allowed, such as the declaration of a function, as shown here:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">class wrapper;</pre>
			<pre class="source-code">void use_foo(wrapper&lt;int&gt;* ptr);</pre>
			<p>However, a class template must be defined at the point where the template instantiation <a id="_idIndexMarker045"/>occurs; otherwise, the compiler will generate an error. This is exemplified with the following snippet:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">class wrapper;                       // OK</pre>
			<pre class="source-code">void use_wrapper(wrapper&lt;int&gt;* ptr); // OK</pre>
			<pre class="source-code">int main()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   wrapper&lt;int&gt; a(42);            // error, incomplete type</pre>
			<pre class="source-code">   use_wrapper(&amp;a);</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">class wrapper</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   // template definition</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">void use_wrapper(wrapper&lt;int&gt;* ptr)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   std::cout &lt;&lt; ptr-&gt;get() &lt;&lt; '\n';</pre>
			<pre class="source-code">}</pre>
			<p>When declaring the <strong class="source-inline">use_wrapper</strong> function, the class template wrapper is only declared, but not defined. However, incomplete types are allowed in this context, which makes it all right to use <strong class="source-inline">wrapper&lt;T&gt;</strong> at this point. However, in the <strong class="source-inline">main</strong> function we are instantiating an object of the <strong class="source-inline">wrapper</strong> class template. This will generate a compiler error because at <a id="_idIndexMarker046"/>this point the definition of the class template must be available. To fix this particular example, we'd have to move the definition of the <strong class="source-inline">main</strong> function to the end, after the definition of <strong class="source-inline">wrapper</strong> and <strong class="source-inline">use_wrapper</strong>.</p>
			<p>In this example, the class template was defined using the <strong class="source-inline">class</strong> keyword. However, in C++ there is little difference between declaring classes with the <strong class="source-inline">class</strong> or <strong class="source-inline">struct</strong> keyword:</p>
			<ul>
				<li>With <strong class="source-inline">struct</strong>, the default member access is public, whereas using <strong class="source-inline">class</strong> is private.</li>
				<li>With <strong class="source-inline">struct</strong>, the default access specifier for base-class inheritance is public, whereas using <strong class="source-inline">class</strong> is private.</li>
			</ul>
			<p>You can define class templates using the <strong class="source-inline">struct</strong> keyword the same way we did here using the <strong class="source-inline">class</strong> keyword. The differences between classes defined with the <strong class="source-inline">struct</strong> or the <strong class="source-inline">class</strong> keyword are also observed for class templates defined with the <strong class="source-inline">struct</strong> or <strong class="source-inline">class</strong> keyword.</p>
			<p>Classes, whether they are templates or not, may contain member function templates too. The way these are defined is discussed in the next section.</p>
			<h1 id="_idParaDest-28"><a id="_idTextAnchor027"/>Defining member function templates</h1>
			<p>So far, we have learned about function templates and class templates. It is possible to define member function templates too, both in non-template classes and class templates. In this <a id="_idIndexMarker047"/>section, we will learn how to do this. To understand the differences, let's start with the following example:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">class composition</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">public:</pre>
			<pre class="source-code">   T add(T const a, T const b)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      return a + b;</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<p>The <strong class="source-inline">composition</strong> class is a class template. It has a single member function called <strong class="source-inline">add</strong> that uses the type parameter <strong class="source-inline">T</strong>. This class can be used as follows:</p>
			<pre class="source-code">composition&lt;int&gt; c;</pre>
			<pre class="source-code">c.add(41, 21);</pre>
			<p>We first need to instantiate an object of the <strong class="source-inline">composition</strong> class. Notice that we must explicitly specify the argument for the type parameter <strong class="source-inline">T</strong> because the compiler is not able to figure it out by itself (there is no context from which to infer it). When we invoke the <strong class="source-inline">add</strong> function, we just provide the arguments. Their type, represented by the <strong class="source-inline">T</strong> type template parameter that was previously resolved to <strong class="source-inline">int</strong>, is already known. A call such as <strong class="source-inline">c.add&lt;int&gt;(42, 21)</strong> would trigger a compiler error. The <strong class="source-inline">add</strong> function is not a function template, but a regular function that is a member of the <strong class="source-inline">composition</strong> class template.</p>
			<p>In the next example, the <strong class="source-inline">composition</strong> class changes slightly, but significantly. Let's see the definition first:</p>
			<pre class="source-code">class composition</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">public:</pre>
			<pre class="source-code">   template &lt;typename T&gt;</pre>
			<pre class="source-code">   T add(T const a, T const b)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      return a + b;</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<p>This time, <strong class="source-inline">composition</strong> is a non-template class. However, the <strong class="source-inline">add</strong> function is a function template. Therefore, to call this function, we must do the following:</p>
			<pre class="source-code">composition c;</pre>
			<pre class="source-code">c.add&lt;int&gt;(41, 21);</pre>
			<p>The explicit specification of the <strong class="source-inline">int</strong> type for the <strong class="source-inline">T</strong> type template parameter is redundant since <a id="_idIndexMarker048"/>the compiler can deduce it by itself from the arguments of the call. However, it was shown here to better comprehend the differences between these two implementations. </p>
			<p>Apart from these two cases, member functions of class templates and member function templates of classes, we can also have member function templates of class templates. In this case, however, the template parameters of the member function template must differ from the template parameters of the class template; otherwise, the compiler will generate an error. Let's return to the <strong class="source-inline">wrapper</strong> class template example and modify it as follows:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">class wrapper</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">public:</pre>
			<pre class="source-code">   wrapper(T const v) :value(v)</pre>
			<pre class="source-code">   {}</pre>
			<pre class="source-code">   T const&amp; get() const { return value; }</pre>
			<pre class="source-code">   template &lt;typename U&gt;</pre>
			<pre class="source-code">   U as() const</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      return static_cast&lt;U&gt;(value);</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">private:</pre>
			<pre class="source-code">   T value;</pre>
			<pre class="source-code">};</pre>
			<p>As you can see here, this implementation features one more member, a function called <strong class="source-inline">as</strong>. This is a function template and has a type template parameter called <strong class="source-inline">U</strong>. This function is <a id="_idIndexMarker049"/>used to cast the wrapped value from a type <strong class="source-inline">T</strong> to a type <strong class="source-inline">U</strong>, and return it to the caller. We can use this implementation as follows:</p>
			<pre class="source-code">wrapper&lt;double&gt; a(42.0);</pre>
			<pre class="source-code">auto d = a.get();       // double</pre>
			<pre class="source-code">auto n = a.as&lt;int&gt;();   // int</pre>
			<p>Arguments for the template parameters were specified when instantiating the <strong class="source-inline">wrapper</strong> class (<strong class="source-inline">double</strong>) – although in C++17 this is redundant, and when invoking the <strong class="source-inline">as</strong> function (<strong class="source-inline">int</strong>) to perform the cast. </p>
			<p>Before we continue with other topics such as instantiation, specialization, and other forms of templates, including variables and aliases, it's important that we take the time to learn more about template parameters. This will make the subject of the next section.</p>
			<h1 id="_idParaDest-29"><a id="_idTextAnchor028"/>Understanding template parameters</h1>
			<p>So far in the book, we have seen multiple examples of templates with one or more parameters. In all these <a id="_idIndexMarker050"/>examples, the parameters represented types supplied at instantiation, either explicitly by the user, or implicitly by the compiler when it could deduce them. These kinds of parameters are called <strong class="bold">type template parameters</strong>. However, templates can also have <strong class="bold">non-type template parameters</strong> and <strong class="bold">template template parameters</strong>. In the following sections, we'll explore all of them.</p>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor029"/>Type template parameters</h2>
			<p>As already mentioned, these are parameters representing types supplied as arguments during the template instantiation. They are introduced either with the <strong class="source-inline">typename</strong> or the <strong class="source-inline">class</strong> keyword. There is <a id="_idIndexMarker051"/>no difference between using these two <a id="_idIndexMarker052"/>keywords. A type template parameter can have a default value, which is a type. This is specified the same way you would specify a default value for a function parameter. Examples for these are shown in the following snippet:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">class wrapper { /* ... */ };</pre>
			<pre class="source-code">template &lt;typename T = int&gt;</pre>
			<pre class="source-code">class wrapper { /* ... */ };</pre>
			<p>The name of the type template parameter can be omitted, which can be useful in forwarding declarations:</p>
			<pre class="source-code">template &lt;typename&gt;</pre>
			<pre class="source-code">class wrapper;</pre>
			<pre class="source-code">template &lt;typename = int&gt;</pre>
			<pre class="source-code">class wrapper;</pre>
			<p>C++11 has introduced variadic templates, which are templates with a variable number of arguments. A template <a id="_idIndexMarker053"/>parameter that accepts zero or more arguments is <a id="_idIndexMarker054"/>called a <strong class="bold">parameter pack</strong>. A <strong class="bold">type template parameter pack</strong> has the following form:</p>
			<pre class="source-code">template &lt;typename... T&gt;</pre>
			<pre class="source-code">class wrapper { /* ... */ };</pre>
			<p>Variadic templates will be addressed in <a href="B18367_03_ePub.xhtml#_idTextAnchor051"><em class="italic">Chapter 3</em></a>, <em class="italic">Variadic Templates</em>. Therefore, we will not get into details about these kinds of parameters at this point. </p>
			<p>C++20 has introduced <strong class="bold">concepts</strong> and <strong class="bold">constraints</strong>. Constraints specify requirements on template arguments. A named set <a id="_idIndexMarker055"/>of constraints is called a concept. Concepts can be specified <a id="_idIndexMarker056"/>as type template parameters. However, the <a id="_idIndexMarker057"/>syntax is a little bit different. The <a id="_idIndexMarker058"/>name of the concept (followed by a list of template arguments in angle brackets if the case) is used instead of the <strong class="source-inline">typename</strong> or the <strong class="source-inline">class</strong> keyword. Examples, including concepts with a default value and constrained type template parameter pack, are shown as follows:</p>
			<pre class="source-code">template &lt;WrappableType T&gt;</pre>
			<pre class="source-code">class wrapper { /* ... */ };</pre>
			<pre class="source-code">template &lt;WrappableType T = int&gt;</pre>
			<pre class="source-code">class wrapper { /* ... */ };</pre>
			<pre class="source-code">template &lt;WrappableType... T&gt;</pre>
			<pre class="source-code">class wrapper { /* ... */ };</pre>
			<p>Concepts and constraints are discussed in <a href="B18367_06_ePub.xhtml#_idTextAnchor099"><em class="italic">Chapter 6</em></a>, <em class="italic">Concepts and Constraints</em>. We will learn more about these kinds of parameters in that chapter. For now, let's look at the second kind of template parameters, non-type template parameters.</p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor030"/>Non-type template parameters</h2>
			<p>Template arguments <a id="_idIndexMarker059"/>don't always have to represent types. They <a id="_idIndexMarker060"/>can also be compile-time expressions, such as constants, addresses of functions or objects with external linkage, or addresses of static class members. Parameters supplied with compile-time expressions are called <strong class="bold">non-type template parameters</strong>. This category of parameters can only have a <strong class="bold">structural type</strong>. The following <a id="_idIndexMarker061"/>are the structural types:</p>
			<ul>
				<li>Integral types</li>
				<li>Floating-point types, as of C++20</li>
				<li>Enumerations</li>
				<li>Pointer types (either to objects or functions)</li>
				<li>Pointer to member types (either to member objects or member functions)</li>
				<li>Lvalue reference types (either to objects or functions)</li>
				<li>A literal class type that meets the following requirements:<ul><li>All base classes are public and non-mutable.</li><li>All non-static data members are public and non-mutable.</li><li>The types of all base classes and non-static data members are also structural types or arrays thereof.</li></ul></li>
			</ul>
			<p>cv-qualified forms of these types can also be used for non-type template parameters. Non-type template parameters can be specified in different ways. The possible forms are shown in the following snippet:</p>
			<pre class="source-code">template &lt;int V&gt;</pre>
			<pre class="source-code">class foo { /*...*/ };</pre>
			<pre class="source-code">template &lt;int V = 42&gt;</pre>
			<pre class="source-code">class foo { /*...*/ };</pre>
			<pre class="source-code">template &lt;int... V&gt;</pre>
			<pre class="source-code">class foo { /*...*/ };</pre>
			<p>In all these examples, the type of the non-type template parameters is <strong class="source-inline">int</strong>. The first and second <a id="_idIndexMarker062"/>examples are similar, except that in the second <a id="_idIndexMarker063"/>example a default value is used. The third example is significantly different because the parameter is actually a parameter pack. This will be discussed in the next chapter.</p>
			<p>To understand non-type template parameters better, let's look at the following example, where we sketch a fixed-size array class, called <strong class="source-inline">buffer</strong>:</p>
			<pre class="source-code">template &lt;typename T, size_t S&gt;</pre>
			<pre class="source-code">class buffer</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   T data_[S];</pre>
			<pre class="source-code">public:</pre>
			<pre class="source-code">   constexpr T const * data() const { return data_; }</pre>
			<pre class="source-code">   constexpr T&amp; operator[](size_t const index)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      return data_[index];</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   constexpr T const &amp; operator[](size_t const index) const</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      return data_[index];</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<p>This <strong class="source-inline">buffer</strong> class holds an internal array of <strong class="source-inline">S</strong> elements of type <strong class="source-inline">T</strong>. Therefore, <strong class="source-inline">S</strong> needs to be a compile-type value. This class can be instantiated as follows:</p>
			<pre class="source-code">buffer&lt;int, 10&gt; b1;</pre>
			<pre class="source-code">buffer&lt;int, 2*5&gt; b2;</pre>
			<p>These two definitions are equivalent, and both <strong class="source-inline">b1</strong> and <strong class="source-inline">b2</strong> are two buffers holding 10 integers. Moreover, they <a id="_idIndexMarker064"/>are of the same type, since 2*5 and 10 are <a id="_idIndexMarker065"/>two expressions evaluated to the same compile-time value. You can easily check this with the following statement:</p>
			<pre class="source-code">static_assert(std::is_same_v&lt;decltype(b1), decltype(b2)&gt;);</pre>
			<p>This is not the case anymore, for the type of the <strong class="source-inline">b3</strong> object is declared as follows:</p>
			<pre class="source-code">buffer&lt;int, 3*5&gt; b3;</pre>
			<p>In this example, <strong class="source-inline">b3</strong> is a <strong class="source-inline">buffer</strong> holding 15 integers, which is different from the <strong class="source-inline">buffer</strong> type from the previous example that held 10 integers. Conceptually, the compiler generates the following code:</p>
			<pre class="source-code">template &lt;typename T, size_t S&gt;</pre>
			<pre class="source-code">class buffer</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   T data_[S];</pre>
			<pre class="source-code">public:</pre>
			<pre class="source-code">   constexpr T* data() const { return data_; }</pre>
			<pre class="source-code">   constexpr T&amp; operator[](size_t const index)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      return data_[index];</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   constexpr T const &amp; operator[](size_t const index) const</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      return data_[index];</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<p>This is the <a id="_idIndexMarker066"/>code for the primary template but there are also <a id="_idIndexMarker067"/>a couple of specializations shown next:</p>
			<pre class="source-code">template&lt;&gt;</pre>
			<pre class="source-code">class buffer&lt;int, 10&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">  int data_[10];</pre>
			<pre class="source-code">public: </pre>
			<pre class="source-code">  constexpr int * data() const;</pre>
			<pre class="source-code">  constexpr int &amp; operator[](const size_t index); </pre>
			<pre class="source-code">  constexpr const int &amp; operator[](</pre>
			<pre class="source-code">    const size_t index) const;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template&lt;&gt;</pre>
			<pre class="source-code">class buffer&lt;int, 15&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">  int data_[15]; </pre>
			<pre class="source-code">public: </pre>
			<pre class="source-code">  constexpr int * data() const;</pre>
			<pre class="source-code">  constexpr int &amp; operator[](const size_t index);</pre>
			<pre class="source-code">  constexpr const int &amp; operator[](</pre>
			<pre class="source-code">    const size_t index) const;</pre>
			<pre class="source-code">};</pre>
			<p>The concept of specialization, seen in this code sample, is detailed further on in this chapter, in the <em class="italic">Understanding template specialization</em> section. For the time being, you should notice the two different <strong class="source-inline">buffer</strong> types. Again, it's possible to verify that the types of <strong class="source-inline">b1</strong> and <strong class="source-inline">b3</strong> are different with the following statement:</p>
			<pre class="source-code">static_assert(!std::is_same_v&lt;decltype(b1), decltype(b3)&gt;);</pre>
			<p>The use of structural types such as integer, floating-point, or enumeration types is encountered <a id="_idIndexMarker068"/>in practice more often than the rest. It's probably <a id="_idIndexMarker069"/>easier to understand their use and find useful examples for them. However, there are scenarios where pointers or references are used. In the following example, we will examine the use of a pointer to function parameter. Let's see the code first:</p>
			<pre class="source-code">struct device</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   virtual void output() = 0;</pre>
			<pre class="source-code">   virtual ~device() {}</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;void (*action)()&gt;</pre>
			<pre class="source-code">struct smart_device : device</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void output() override</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      (*action)();</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<p>In this snippet, <strong class="source-inline">device</strong> is a base class with a pure virtual function called <strong class="source-inline">output</strong> (and a virtual destructor). This is the base class for a class template called <strong class="source-inline">smart_device</strong> that <a id="_idIndexMarker070"/>implements the <strong class="source-inline">output</strong> virtual function by calling a <a id="_idIndexMarker071"/>function through a function pointer. This function pointer is passed an argument for the non-type template parameter of the class template. The following sample shows how it can be used:</p>
			<pre class="source-code">void say_hello_in_english()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   std::cout &lt;&lt; "Hello, world!\n";</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">void say_hello_in_spanish()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   std::cout &lt;&lt; "Hola mundo!\n";</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">auto w1 =</pre>
			<pre class="source-code">   std::make_unique&lt;smart_device&lt;&amp;say_hello_in_english&gt;&gt;();</pre>
			<pre class="source-code">w1-&gt;output();</pre>
			<pre class="source-code">auto w2 =</pre>
			<pre class="source-code">   std::make_unique&lt;smart_device&lt;&amp;say_hello_in_spanish&gt;&gt;();</pre>
			<pre class="source-code">w2-&gt;output();</pre>
			<p>Here, <strong class="source-inline">w1</strong> and <strong class="source-inline">w2</strong> are two <strong class="source-inline">unique_ptr</strong> objects. Although, apparently, they point to objects of the same type, that is not true, because <strong class="source-inline">smart_device&lt;&amp;say_hello_in_english&gt;</strong> and <strong class="source-inline">smart_device&lt;&amp;say_hello_in_spanish&gt;</strong> are different types since they are instantiated with different values for the function pointer. This can be easily checked with the following statement:</p>
			<pre class="source-code">static_assert(!std::is_same_v&lt;decltype(w1), decltype(w2)&gt;);</pre>
			<p>If we, on the other hand, change the <strong class="source-inline">auto</strong> specifier with <strong class="source-inline">std::unique_ptr&lt;device&gt;</strong>, as shown in the following snippet, then <strong class="source-inline">w1</strong> and <strong class="source-inline">w2</strong> are smart <a id="_idIndexMarker072"/>pointers to the base class device, and therefore <a id="_idIndexMarker073"/>have the same type:</p>
			<pre class="source-code">std::unique_ptr&lt;device&gt; w1 = </pre>
			<pre class="source-code">   std::make_unique&lt;smart_device&lt;&amp;say_hello_in_english&gt;&gt;();</pre>
			<pre class="source-code">w1-&gt;output();</pre>
			<pre class="source-code">std::unique_ptr&lt;device&gt; w2 = </pre>
			<pre class="source-code">   std::make_unique&lt;smart_device&lt;&amp;say_hello_in_spanish&gt;&gt;();</pre>
			<pre class="source-code">w2-&gt;output();</pre>
			<pre class="source-code">static_assert(std::is_same_v&lt;decltype(w1), decltype(w2)&gt;);</pre>
			<p>Although this example uses a pointer to function, a similar example can be conceived for pointer to member functions. The previous example can be transformed to the following (still using the same base class device):</p>
			<pre class="source-code">template &lt;typename Command, void (Command::*action)()&gt;</pre>
			<pre class="source-code">struct smart_device : device</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   smart_device(Command&amp; command) : cmd(command) {}</pre>
			<pre class="source-code">   void output() override</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      (cmd.*action)();</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">private:</pre>
			<pre class="source-code">   Command&amp; cmd;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">struct hello_command</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void say_hello_in_english()</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      std::cout &lt;&lt; "Hello, world!\n";</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   void say_hello_in_spanish()</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      std::cout &lt;&lt; "Hola mundo!\n";</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<p>These <a id="_idIndexMarker074"/>classes can <a id="_idIndexMarker075"/>be used as follows:</p>
			<pre class="source-code">hello_command cmd;</pre>
			<pre class="source-code">auto w1 = std::make_unique&lt;</pre>
			<pre class="source-code">   smart_device&lt;hello_command, </pre>
			<pre class="source-code">      &amp;hello_command::say_hello_in_english&gt;&gt;(cmd);</pre>
			<pre class="source-code">w1-&gt;output();</pre>
			<pre class="source-code">auto w2 = std::make_unique&lt;</pre>
			<pre class="source-code">   smart_device&lt;hello_command, </pre>
			<pre class="source-code">      &amp;hello_command::say_hello_in_spanish&gt;&gt;(cmd);</pre>
			<pre class="source-code">w2-&gt;output();</pre>
			<p>In C++17, a new form of specifying non-type template parameters was introduced, using the <strong class="source-inline">auto</strong> specifier (including the <strong class="source-inline">auto*</strong> and <strong class="source-inline">auto&amp;</strong> forms) or <strong class="source-inline">decltype(auto)</strong> instead <a id="_idIndexMarker076"/>of the name of the type. This allows the compiler <a id="_idIndexMarker077"/>to deduce the type of the parameter from the expression supplied as the argument. If the deduced type is not permitted for a non-type template parameter the compiler will generate an error. Let's see an example:</p>
			<pre class="source-code">template &lt;auto x&gt;</pre>
			<pre class="source-code">struct foo</pre>
			<pre class="source-code">{ /* … */ };</pre>
			<p>This class template can be used as follows:</p>
			<pre class="source-code">foo&lt;42&gt;   f1;  // foo&lt;int&gt;</pre>
			<pre class="source-code">foo&lt;42.0&gt; f2;  // foo&lt;double&gt; in C++20, error for older </pre>
			<pre class="source-code">               // versions</pre>
			<pre class="source-code">foo&lt;"42"&gt; f3;  // error</pre>
			<p>In the first example, for <strong class="source-inline">f1</strong>, the compiler deduces the type of the argument as <strong class="source-inline">int</strong>. In the second example, for <strong class="source-inline">f2</strong>, the compiler deduces the type as <strong class="source-inline">double</strong>. However, this is only the case for C++20. In previous versions of the standard, this line would yield an error, since floating-point types were not permitted as arguments for non-type template parameters prior to C++20. The last line, however, produces an error because <strong class="source-inline">"42"</strong> is a string literal and string literals cannot be used as arguments for non-type template parameters.</p>
			<p>The last example can be, however, worked around in C++20 by wrapping the literal string in a structural literal class. This class would store the characters of the string literal in a fixed-length array. This is exemplified in the following snippet:</p>
			<pre class="source-code">template&lt;size_t N&gt;</pre>
			<pre class="source-code">struct string_literal</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   constexpr string_literal(const char(&amp;str)[N])</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      std::copy_n(str, N, value);</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   char value[N];</pre>
			<pre class="source-code">};</pre>
			<p>However, the <strong class="source-inline">foo</strong> class template shown previously needs to be modified to use <strong class="source-inline">string_literal</strong> explicitly and not the <strong class="source-inline">auto</strong> specifier:</p>
			<pre class="source-code">template &lt;string_literal x&gt;</pre>
			<pre class="source-code">struct foo</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">};</pre>
			<p>With this is in place, the <strong class="source-inline">foo&lt;"42"&gt; f;</strong> declaration shown earlier will compile without any errors in C++20.</p>
			<p>The <strong class="source-inline">auto</strong> specifier <a id="_idIndexMarker078"/>can also be used with a non-type template <a id="_idIndexMarker079"/>parameter pack. In this case, the type is deduced independently for each template argument. The types of the template arguments do not need to be the same. This is shown in the following snippet:</p>
			<pre class="source-code">template&lt;auto... x&gt;</pre>
			<pre class="source-code">struct foo</pre>
			<pre class="source-code">{ /* ... */ };</pre>
			<pre class="source-code">foo&lt;42, 42.0, false, 'x'&gt; f;</pre>
			<p>In this example, the <a id="_idIndexMarker080"/>compiler deduces the types of the <a id="_idIndexMarker081"/>template arguments as <strong class="source-inline">int</strong>, <strong class="source-inline">double</strong>, <strong class="source-inline">bool</strong>, and <strong class="source-inline">char</strong>, respectively.</p>
			<p>The third and last category of template parameters are <strong class="bold">template template parameters</strong>. We will look at them next.</p>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor031"/>Template template parameters</h2>
			<p>Although the name may sound a bit strange, it refers to a category of template parameters that <a id="_idIndexMarker082"/>are themselves templates. These can be specified similarly to type template parameters, with or without a name, with or without a default value, and as a parameter pack with or without a name. As of C++17, both the keywords <strong class="source-inline">class</strong> and<a id="_idTextAnchor032"/> <strong class="source-inline">typename</strong> can be used to introduce a template template parameter. Prior to this version, only the <strong class="source-inline">class</strong> keyword c<a id="_idTextAnchor033"/>ould be used.</p>
			<p>To showcase the use of template template parameters, let's consider the following two class templates first:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">class simple_wrapper</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">public:</pre>
			<pre class="source-code">   T value;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">class fancy_wrapper</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">public:</pre>
			<pre class="source-code">   fancy_wrapper(T const v) :value(v)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   T const&amp; get() const { return value; }</pre>
			<pre class="source-code">   template &lt;typename U&gt;</pre>
			<pre class="source-code">   U as() const</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      return static_cast&lt;U&gt;(value);</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">private:</pre>
			<pre class="source-code">   T value;</pre>
			<pre class="source-code">};</pre>
			<p>The <strong class="source-inline">simple_wrapper</strong> class is a very simple class template that holds a value of the type template parameter <strong class="source-inline">T</strong>. On the other hand, <strong class="source-inline">fancy_wrapper</strong> is a more complex wrapper <a id="_idIndexMarker083"/>implementation that hides the wrapped value and exposes member functions for data access. Next, we implement a class template called <strong class="source-inline">wrapping_pair</strong> that contains two values of a wrapping type. This can be either <strong class="source-inline">simpler_wrapper</strong>, <strong class="source-inline">fancy_wrapper</strong>, or anything else that is similar:</p>
			<pre class="source-code">template &lt;typename T, typename U, </pre>
			<pre class="source-code">          template&lt;typename&gt; typename W = fancy_wrapper&gt;</pre>
			<pre class="source-code">class wrapping_pair</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">public:</pre>
			<pre class="source-code">   wrapping_pair(T const a, U const b) :</pre>
			<pre class="source-code">      item1(a), item2(b)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   W&lt;T&gt; item1;</pre>
			<pre class="source-code">   W&lt;U&gt; item2;</pre>
			<pre class="source-code">};   </pre>
			<p>The <strong class="source-inline">wrapping_pair</strong> class template has three parameters. The first two are type template <a id="_idIndexMarker084"/>parameters, n<a id="_idTextAnchor034"/>amed <strong class="source-inline">T</strong> and <strong class="source-inline">U</strong>. The third parameter is a template template parameter, called <strong class="source-inline">W</strong>, that has a default value, which is the <strong class="source-inline">fancy_wrapper</strong> type. We can use this class template as shown in the following snippet:</p>
			<pre class="source-code">wrapping_pair&lt;int, double&gt; p1(42, 42.0);</pre>
			<pre class="source-code">std::cout &lt;&lt; p1.item1.get() &lt;&lt; ' '</pre>
			<pre class="source-code">          &lt;&lt; p1.item2.get() &lt;&lt; '\n';</pre>
			<pre class="source-code">wrapping_pair&lt;int, double, simple_wrapper&gt; p2(42, 42.0);</pre>
			<pre class="source-code">std::cout &lt;&lt; p2.item1.value &lt;&lt; ' '</pre>
			<pre class="source-code">          &lt;&lt; p2.item2.value &lt;&lt; '\n';</pre>
			<p>In this example, <strong class="source-inline">p1</strong> is a <strong class="source-inline">wrapping_pair</strong> object that contains two values, an <strong class="source-inline">int</strong> and a <strong class="source-inline">double</strong>, each wrapped in a <strong class="source-inline">fancy_wrapper</strong> object. This is not explicitly spe<a id="_idTextAnchor035"/>cified but is the default value of the template template parameter. On the other hand, <strong class="source-inline">p2</strong> is also a <strong class="source-inline">wrapping_pair</strong> object, also containing an <strong class="source-inline">int</strong> and a <strong class="source-inline">double</strong>, but these are wrapped by a <strong class="source-inline">simple_wrapper</strong> object, which is now specified explicitly in the template instantiation.</p>
			<p>In this example, we have seen the use of a default template argument for a template parameter. This topic is explored in detail in the next section.</p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor036"/>Default template arguments</h2>
			<p>Default template arguments are specified similarly to default function arguments, in the parameter list <a id="_idIndexMarker085"/>after the equal sign. The following rules <a id="_idIndexMarker086"/>apply to default template arguments:</p>
			<ul>
				<li>They can be used with any kind of template parameters with the exception of parameter packs.</li>
				<li>If a default value is specified for a template parameter of a class template, variable template, or type alias, then all subsequent template parameters must also have a default value. The exception is the last parameter if it is a template parameter pack.</li>
				<li>If a default value is specified for a template parameter in a function template, then subsequent template parameters are not restricted to also have a default value.</li>
				<li>In a function template, a parameter pack may be followed by more type parameters only if they have default arguments or their value can be deduced by the compiler from the function arguments.</li>
				<li>They are not allowed in declarations of friend class templates.</li>
				<li>They are <a id="_idIndexMarker087"/>allowed in the declaration of a friend <a id="_idIndexMarker088"/>function template only if the declaration is also a definition and there is no other declaration of the function in the same translation unit.</li>
				<li>They are not allowed in the declaration or definition of an explicit specialization of a function template or member function template.</li>
			</ul>
			<p>The following snippet shows examples for using default template arguments:</p>
			<pre class="source-code">template &lt;typename T = int&gt;</pre>
			<pre class="source-code">class foo { /*...*/ };</pre>
			<pre class="source-code">template &lt;typename T = int, typename U = double&gt;</pre>
			<pre class="source-code">class bar { /*...*/ };</pre>
			<p>As mentioned previously, a template parameter with a default argument cannot be followed by parameters without a default argument when declaring a class template but this restriction does not apply to function templates. This is shown in the next snippet:</p>
			<pre class="source-code">template &lt;typename T = int, typename U&gt;</pre>
			<pre class="source-code">class bar { };   // error</pre>
			<pre class="source-code">template &lt;typename T = int, typename U&gt;</pre>
			<pre class="source-code">void func() {}   // OK</pre>
			<p>A template may have multiple declarations (but only one definition). The default template <a id="_idIndexMarker089"/>arguments from all the declarations and the definition <a id="_idIndexMarker090"/>are merged (the same way they are merged for default function arguments). Let's look at an example to understand how it works:</p>
			<pre class="source-code">template &lt;typename T, typename U = double&gt;</pre>
			<pre class="source-code">struct foo;</pre>
			<pre class="source-code">template &lt;typename T = int, typename U&gt;</pre>
			<pre class="source-code">struct foo;</pre>
			<pre class="source-code">template &lt;typename T, typename U&gt;</pre>
			<pre class="source-code">struct foo</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   T a;</pre>
			<pre class="source-code">   U b;</pre>
			<pre class="source-code">};</pre>
			<p>This is semantically equivalent to the following definition:</p>
			<pre class="source-code">template &lt;typename T = int, typename U = double&gt;</pre>
			<pre class="source-code">struct foo</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   T a;</pre>
			<pre class="source-code">   U b;</pre>
			<pre class="source-code">};</pre>
			<p>However, these multiple declarations with different default template arguments cannot be <a id="_idIndexMarker091"/>provided in any order. The rules mentioned earlier <a id="_idIndexMarker092"/>still apply. Therefore, a declaration of a class template where the first parameter has a default argument and the ensuing parameters do not have one is illegal:</p>
			<pre class="source-code">template &lt;typename T = int, typename U&gt;</pre>
			<pre class="source-code">struct foo;  // error, U does not have a default argument</pre>
			<pre class="source-code">template &lt;typename T, typename U = double&gt;</pre>
			<pre class="source-code">struct foo;</pre>
			<p>Another restriction on default template arguments is that the same template parameter cannot be given multiple defaults in the same scope. Therefore, the next example will produce an error:</p>
			<pre class="source-code">template &lt;typename T = int&gt;</pre>
			<pre class="source-code">struct foo;</pre>
			<pre class="source-code">template &lt;typename T = int&gt; // error redefinition</pre>
			<pre class="source-code">                            // of default parameter</pre>
			<pre class="source-code">struct foo {};</pre>
			<p>When a default template argument uses names from a class, the member access restrictions are checked at the declaration, not at the instantiation of the template:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct foo</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">protected:</pre>
			<pre class="source-code">   using value_type = T;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;typename T, typename U = typename T::value_type&gt;</pre>
			<pre class="source-code">struct bar</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   using value_type = U;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">bar&lt;foo&lt;int&gt;&gt; x;</pre>
			<p>When <a id="_idIndexMarker093"/>the <strong class="source-inline">x</strong> variable is defined, the bar class template <a id="_idIndexMarker094"/>is instantiated, but the <strong class="source-inline">foo::value_type</strong> typedef is protected and therefore cannot be used outside of <strong class="source-inline">foo</strong>. The result is a compiler error at the declaration of the <strong class="source-inline">bar</strong> class template.</p>
			<p>With these mentions, we wrap up the topic of template parameters. The next one we will explore in the following section is template instantiation, which is the creation of a new definition of a function, class, or variable from a template definition and a set of template arguments.</p>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor037"/>Understanding template instantiation</h1>
			<p>As mentioned before, templates are only blueprints from which the compiler creates actual code <a id="_idIndexMarker095"/>when it encounters their use. The act of creating a definition for a function, a class, or a variable from the template declaration is called <strong class="bold">template instantiation</strong>. This can be either <strong class="bold">explicit</strong>, when you tell the compiler when it should generate a definition, or <strong class="bold">implicit</strong>, when the compiler generates a new definition as needed. We will look at these two forms in detail in the next sections.</p>
			<h2 id="_idParaDest-35"><a id="_idTextAnchor038"/>Implicit instantiation</h2>
			<p>Implicit instantiation occurs when the compiler generates definitions based on the use of templates <a id="_idIndexMarker096"/>and when no explicit instantiation <a id="_idIndexMarker097"/>is present. Implicitly instantiated templates are defined in the same namespace as the template. However, the way compilers create definitions from templates may differ. This is something we will see in the following example. Let's consider this code:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct foo</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">  void f() {}</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">int main()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">  foo&lt;int&gt; x;</pre>
			<pre class="source-code">}</pre>
			<p>Here, we have a class template called <strong class="source-inline">foo</strong> with a member function <strong class="source-inline">f</strong>. In <strong class="source-inline">main</strong>, we define a variable of the type <strong class="source-inline">foo&lt;int&gt;</strong> but do not use any of its members. Because it encounters this use of <strong class="source-inline">foo</strong>, the compiler implicitly defines a specialization of <strong class="source-inline">foo</strong> for the <strong class="source-inline">int</strong> type. If you use <a href="http://cppinsights.io">cppinsights.io</a>, which runs in Clang, you will see the following code:</p>
			<pre class="source-code">template&lt;&gt;</pre>
			<pre class="source-code">struct foo&lt;int&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">  inline void f();</pre>
			<pre class="source-code">};</pre>
			<p>Because the function <strong class="source-inline">f</strong> is not invoked in our code, it is only declared but not defined. Should we add a call <strong class="source-inline">f</strong> in <strong class="source-inline">main</strong>, the specialization would change as follows:</p>
			<pre class="source-code">template&lt;&gt;</pre>
			<pre class="source-code">struct foo&lt;int&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">  inline void f() { }</pre>
			<pre class="source-code">};</pre>
			<p>However, if we <a id="_idIndexMarker098"/>add one more function, <strong class="source-inline">g</strong>, with <a id="_idIndexMarker099"/>the following implementation that contains an error, we will get different behaviors with different compilers:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct foo</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">  void f() {}</pre>
			<pre class="source-code">  void g() {int a = "42";}</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">int main()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">  foo&lt;int&gt; x;</pre>
			<pre class="source-code">  x.f();</pre>
			<pre class="source-code">}</pre>
			<p>The body of <strong class="source-inline">g</strong> contains an error (you could also use a <strong class="source-inline">static_assert(false)</strong> statement as an alternative). This code compiles without any problem with VC++, but fails with Clang and GCC. This is because VC++ ignores the parts of the template that are not used, provided that the code is syntactically correct, but the others perform semantic validation before proceeding with template instantiation.</p>
			<p>For function templates, implicit instantiation occurs when the user code refers to a function in a <a id="_idIndexMarker100"/>context that requires its definition to <a id="_idIndexMarker101"/>exist. For class templates, implicit instantiation occurs when the user code refers to a template in a context when a complete type is required or when the completeness of the type affects the code. The typical example of such a context is when an object of such a type is constructed. However, this is not the case when declaring pointers to a class template. To understand how this works, let's consider the following example:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct foo</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">  void f() {}</pre>
			<pre class="source-code">  void g() {}</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">int main()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">  foo&lt;int&gt;* p;</pre>
			<pre class="source-code">  foo&lt;int&gt; x;</pre>
			<pre class="source-code">  foo&lt;double&gt;* q;</pre>
			<pre class="source-code">}</pre>
			<p>In this snippet, we use the same <strong class="source-inline">foo</strong> class template from the previous examples, and we declare several variables: <strong class="source-inline">p</strong> which is a pointer to <strong class="source-inline">foo&lt;int&gt;</strong>, <strong class="source-inline">x</strong> which is a <strong class="source-inline">foo&lt;int&gt;</strong>, and <strong class="source-inline">q</strong> which is a pointer to <strong class="source-inline">foo&lt;double&gt;</strong>. The compiler is required to instantiate only <strong class="source-inline">foo&lt;int&gt;</strong> at this point because of the declaration of <strong class="source-inline">x</strong>. Now, let's consider some invocations of the member functions <strong class="source-inline">f</strong> and <strong class="source-inline">g</strong> as follows:</p>
			<pre class="source-code">int main()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">  foo&lt;int&gt;* p;</pre>
			<pre class="source-code">  foo&lt;int&gt; x;</pre>
			<pre class="source-code">  foo&lt;double&gt;* q;</pre>
			<pre class="source-code">  x.f();</pre>
			<pre class="source-code">  q-&gt;g();</pre>
			<pre class="source-code">}</pre>
			<p>With these changes, the compiler is required to instantiate the following:</p>
			<ul>
				<li><strong class="source-inline">foo&lt;int&gt;</strong> when the <strong class="source-inline">x</strong> variable is declared</li>
				<li><strong class="source-inline">foo&lt;int&gt;::f()</strong> when the <strong class="source-inline">x.f()</strong> call occurs</li>
				<li><strong class="source-inline">foo&lt;double&gt;</strong> and <strong class="source-inline">foo&lt;double&gt;::g()</strong> when the <strong class="source-inline">q-&gt;g()</strong> call occurs.</li>
			</ul>
			<p>On the other hand, the compiler is not required to instantiate <strong class="source-inline">foo&lt;int&gt;</strong> when the <strong class="source-inline">p</strong> pointer is <a id="_idIndexMarker102"/>declared nor <strong class="source-inline">foo&lt;double&gt;</strong> when <a id="_idIndexMarker103"/>the <strong class="source-inline">q</strong> pointer is declared. However, the compiler does need to implicitly instantiate a class template specialization when it is involved in pointer conversion. This is shown in the following example:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct control</pre>
			<pre class="source-code">{};</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct button : public control&lt;T&gt;</pre>
			<pre class="source-code">{};</pre>
			<pre class="source-code">void show(button&lt;int&gt;* ptr)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   control&lt;int&gt;* c = ptr;</pre>
			<pre class="source-code">}</pre>
			<p>In the function <strong class="source-inline">show</strong>, a conversion between <strong class="source-inline">button&lt;int&gt;*</strong> and <strong class="source-inline">control&lt;int&gt;*</strong> takes place. Therefore, at this point, the compiler must instantiate <strong class="source-inline">button&lt;int&gt;</strong>.</p>
			<p>When a class template contains static members, those members are not implicitly instantiated <a id="_idIndexMarker104"/>when the compiler implicitly <a id="_idIndexMarker105"/>instantiates the class template but only when the compiler needs their definition. On the other hand, every specialization of a class template has its own copy of static members as exemplified in the following snippet:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct foo</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   static T data;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;typename T&gt; T foo&lt;T&gt;::data = 0;</pre>
			<pre class="source-code">int main()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   foo&lt;int&gt; a;</pre>
			<pre class="source-code">   foo&lt;double&gt; b;</pre>
			<pre class="source-code">   foo&lt;double&gt; c;</pre>
			<pre class="source-code">   std::cout &lt;&lt; a.data &lt;&lt; '\n'; // 0</pre>
			<pre class="source-code">   std::cout &lt;&lt; b.data &lt;&lt; '\n'; // 0</pre>
			<pre class="source-code">   std::cout &lt;&lt; c.data &lt;&lt; '\n'; // 0</pre>
			<pre class="source-code">   b.data = 42;</pre>
			<pre class="source-code">   std::cout &lt;&lt; a.data &lt;&lt; '\n'; // 0</pre>
			<pre class="source-code">   std::cout &lt;&lt; b.data &lt;&lt; '\n'; // 42</pre>
			<pre class="source-code">   std::cout &lt;&lt; c.data &lt;&lt; '\n'; // 42</pre>
			<pre class="source-code">}</pre>
			<p>The class template <strong class="source-inline">foo</strong> has a static member variable called <strong class="source-inline">data</strong> that is initialized after the definition <a id="_idIndexMarker106"/>of <strong class="source-inline">foo</strong>. In the <strong class="source-inline">main</strong> function, we declare <a id="_idIndexMarker107"/>the variable <strong class="source-inline">a</strong> as an object of <strong class="source-inline">foo&lt;int&gt;</strong> and <strong class="source-inline">b</strong> and <strong class="source-inline">c</strong> as objects of <strong class="source-inline">foo&lt;double&gt;</strong>. Initially, all of them have the member field <strong class="source-inline">data</strong> initialized with 0. However, the variables <strong class="source-inline">b</strong> and <strong class="source-inline">c</strong> share the same copy of data. Therefore, after the assignment <strong class="source-inline">b.data = 42</strong>, <strong class="source-inline">a.data</strong> is still 0, but both <strong class="source-inline">b.data</strong> and <strong class="source-inline">c.data</strong> are <strong class="source-inline">42</strong>.</p>
			<p>Having learned how implicit instantiation works, it is time to move forward and understand the other form of template instantiation, which is explicit instantiation.</p>
			<h2 id="_idParaDest-36"><a id="_idTextAnchor039"/>Explicit instantiation</h2>
			<p>As a user, you can <a id="_idIndexMarker108"/>explicitly tell the compiler to instantiate <a id="_idIndexMarker109"/>a class template or a function template. This <a id="_idIndexMarker110"/>is called explicit instantiation and it has <a id="_idIndexMarker111"/>two forms: <strong class="bold">explicit instantiation definition</strong> and <strong class="bold">explicit instantiation declaration</strong>. We will discuss them in this order.</p>
			<h3>Explicit instantiation definition</h3>
			<p>An explicit instantiation definition may appear anywhere in a program but after the definition of the <a id="_idIndexMarker112"/>template it refers to. The syntax for explicit template instantiation definitions takes the following forms:</p>
			<ul>
				<li>The syntax for class templates is as follows:<p class="source-code">template class-key template-name &lt;argument-list&gt;</p></li>
				<li>The syntax for function templates is as follows:<p class="source-code">template return-type name&lt;argument-list&gt;(parameter-list);</p><p class="source-code">template return-type name(parameter-list);</p></li>
			</ul>
			<p>As you can see, in all cases, the explicit instantiation definition is introduced with the <strong class="source-inline">template</strong> keyword <a id="_idIndexMarker113"/>but not followed by any parameter list. For class templates, the <strong class="source-inline">class-key</strong> can be any of the <strong class="source-inline">class</strong>, <strong class="source-inline">struct</strong>, or <strong class="source-inline">union</strong> keywords. For both class and function templates, an explicit instantiation definition with a given argument list can only appear once in the entire program.</p>
			<p>We will look at some examples to understand how this works. Here is the first example:</p>
			<pre class="source-code">namespace ns</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   template &lt;typename T&gt;</pre>
			<pre class="source-code">   struct wrapper</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      T value;</pre>
			<pre class="source-code">   };</pre>
			<pre class="source-code">   template struct wrapper&lt;int&gt;;       // [1]</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template struct ns::wrapper&lt;double&gt;;   // [2]</pre>
			<pre class="source-code">int main() {}</pre>
			<p>In this snippet, <strong class="source-inline">wrapper&lt;T&gt;</strong> is a class template defined in the <strong class="source-inline">ns</strong> namespace. The statements marked with <strong class="source-inline">[1]</strong> and <strong class="source-inline">[2]</strong> in the code are both representing an explicit instantiation definition, for <strong class="source-inline">wrapper&lt;int&gt;</strong> and <strong class="source-inline">wrapper&lt;double&gt;</strong> respectively. An explicit instantiation definition can only appear in the same namespace as the template it refers to (as in <strong class="source-inline">[1]</strong>) to or it must be fully qualified (as in <strong class="source-inline">[2]</strong>). We can write similar explicit template definitions for a function template:</p>
			<pre class="source-code">namespace ns</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   template &lt;typename T&gt;</pre>
			<pre class="source-code">   T add(T const a, T const b)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      return a + b;</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   template int add(int, int);           // [1]</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template double ns::add(double, double); // [2]</pre>
			<pre class="source-code">int main() { }</pre>
			<p>This second example has a striking <a id="_idIndexMarker114"/>resemblance to the first. Both <strong class="source-inline">[1]</strong> and <strong class="source-inline">[2]</strong> represent explicit template definitions for <strong class="source-inline">add&lt;int&gt;()</strong> and <strong class="source-inline">add&lt;double&gt;()</strong>.</p>
			<p>If the explicit instantiation definition is not in the same namespace as the template, the name must be fully qualified. The use of a <strong class="source-inline">using</strong> statement does not make the name visible in the current namespace. This is shown in the following example:</p>
			<pre class="source-code">namespace ns</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   template &lt;typename T&gt;</pre>
			<pre class="source-code">   struct wrapper { T value; };</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">using namespace ns;</pre>
			<pre class="source-code">template struct wrapper&lt;double&gt;;   // error</pre>
			<p>The last line in this example generates a compile error because <strong class="source-inline">wrapper</strong> is an unknown name and must be qualified with the namespace name, as in <strong class="source-inline">ns::wrapper</strong>.</p>
			<p>When class members are used for return <a id="_idIndexMarker115"/>types or parameter types, member access specification is ignored in explicit instantiation definitions. An example is shown in the following snippet:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">class foo</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   struct bar {};</pre>
			<pre class="source-code">   T f(bar const arg)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      return {};</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template int foo&lt;int&gt;::f(foo&lt;int&gt;::bar);</pre>
			<p>Both the class <strong class="source-inline">X&lt;T&gt;::bar</strong> and the function <strong class="source-inline">foo&lt;T&gt;::f()</strong> are private to the <strong class="source-inline">foo&lt;T&gt;</strong> class, but they can be used in the explicit instantiation definition shown on the last line. </p>
			<p>Having seen what explicit instantiation definition is and how it works, the question that arises is when is it useful. Why would you tell the compiler to generate instantiation from a template? The answer is that it helps distribute libraries, reduce build times, and executable sizes. If you are building a library that you want to distribute as a <strong class="source-inline">.lib</strong> file and that library uses templates, the template definitions that are not instantiated are not put into the library. But that leads to increased build times of your user code every time you use the library. By forcing instantiations of templates in the library, those definitions are put into the object files and the <strong class="source-inline">.lib</strong> file you are distributing. As a result, your user code only needs to be linked to those available functions in the library file. This is what the Microsoft MSVC CRT libraries do for all the stream, locale, and string classes. The <strong class="source-inline">libstdc++</strong> library does the same for string classes and others.</p>
			<p>A problem that can arise with template instantiations is that you can end up with multiple definitions, one per translation unit. If the <a id="_idIndexMarker116"/>same header that contains a template is included in multiple translation units (<strong class="source-inline">.cpp</strong> files) and the same template instantiation is used (let's say <strong class="source-inline">wrapper&lt;int&gt;</strong> from our previous examples), then identical copies of these instantiations are put in each translation unit. This leads to increased object sizes. The problem can be solved with the help of explicit instantiation declarations, which we will look at next.</p>
			<h3>Explicit instantiation declaration</h3>
			<p>An explicit instantiation declaration (available with C++11) is the way you can tell the compiler that the <a id="_idIndexMarker117"/>definition of a template instantiation is found in a different translation unit and that a new definition should not be generated. The syntax is the same as for explicit instantiation definitions except that the keyword <strong class="source-inline">extern</strong> is used in front of the declaration:</p>
			<ul>
				<li>The syntax for class templates is as follows:<p class="source-code">extern template class-key template-name &lt;argument-list&gt;</p></li>
				<li>The syntax for function templates is as follows:<p class="source-code">extern template return-type name&lt;argument-list&gt;(parameter-list);</p><p class="source-code">extern template return-type name(parameter-list);</p></li>
			</ul>
			<p>If you provide an explicit instantiation declaration but no instantiation definition exists in any translation unit of the program, then the result is a compiler warning and a linker error. The technique is to declare an explicit template instantiation in one source file and explicit template declarations in the remaining ones. This will reduce both compilation times and object file sizes.</p>
			<p>Let's look <a id="_idIndexMarker118"/>at the following example:</p>
			<pre class="source-code">// wrapper.h</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct wrapper</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   T data;</pre>
			<pre class="source-code">}; </pre>
			<pre class="source-code">extern template wrapper&lt;int&gt;;   // [1]</pre>
			<pre class="source-code">// source1.cpp</pre>
			<pre class="source-code">#include "wrapper.h"</pre>
			<pre class="source-code">#include &lt;iostream&gt;</pre>
			<pre class="source-code">template wrapper&lt;int&gt;;          // [2]</pre>
			<pre class="source-code">void f()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   ext::wrapper&lt;int&gt; a{ 42 };</pre>
			<pre class="source-code">   std::cout &lt;&lt; a.data &lt;&lt; '\n';</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">// source2.cpp</pre>
			<pre class="source-code">#include "wrapper.h"</pre>
			<pre class="source-code">#include &lt;iostream&gt;</pre>
			<pre class="source-code">void g()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   wrapper&lt;int&gt; a{ 100 };</pre>
			<pre class="source-code">   std::cout &lt;&lt; a.data &lt;&lt; '\n';</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">// main.cpp</pre>
			<pre class="source-code">#include "wrapper.h"</pre>
			<pre class="source-code">int main()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   wrapper&lt;int&gt; a{ 0 };</pre>
			<pre class="source-code">}</pre>
			<p>In this example, we can see the following:</p>
			<ul>
				<li>The <strong class="source-inline">wrapper.h</strong> header contains a class template called <strong class="source-inline">wrapper&lt;T&gt;</strong>. On the line marked with <strong class="source-inline">[1]</strong> there is an explicit instantiation declaration for <strong class="source-inline">wrapper&lt;int&gt;</strong> that tells the compiler not to generate definitions for this instantiation when a source file (translation unit) including this header is compiled.</li>
				<li>The <strong class="source-inline">source1.cpp</strong> file includes <strong class="source-inline">wrapper.h</strong> and on the line marked with <strong class="source-inline">[2]</strong> contains <a id="_idIndexMarker119"/>an explicit instantiation definition for <strong class="source-inline">wrapper&lt;int&gt;</strong>. This is the only definition for this instantiation within the entire program.</li>
				<li>The source files <strong class="source-inline">source2.cpp</strong> and <strong class="source-inline">main.cpp</strong> are both using <strong class="source-inline">wrapper&lt;int&gt;</strong> but without any explicit instantiation definition or declaration. That is because the explicit declaration from <strong class="source-inline">wrapper.h</strong> is visible when the header is included in each of these files.</li>
			</ul>
			<p>Alternatively, the explicit instantiation declaration could be taken away from the header file but then it must be added to each source file that includes the header and that is likely to be forgotten.</p>
			<p>When you do explicit template declarations, keep in mind that a class member function that is defined within <a id="_idIndexMarker120"/>the body of the class is always considered inline and therefore it will always be instantiated. Therefore, you can only use the <strong class="source-inline">extern</strong> keyword for member functions that are defined outside of the class body.</p>
			<p>Now that we have looked at what template instantiation is, we will continue with another important topic, <strong class="bold">template specialization</strong>, which is the term used for the definition created from a template instantiation to handle a specific set of template arguments.</p>
			<h1 id="_idParaDest-37"><a id="_idTextAnchor040"/>Understanding template specialization</h1>
			<p>A <strong class="bold">template specialization</strong> is the definition created from a template instantiation. The template that is <a id="_idIndexMarker121"/>being specialized is called the <strong class="bold">primary template</strong>. You can provide an explicit specialized definition for a given set of template arguments, therefore <a id="_idIndexMarker122"/>overwriting the implicit code the compiler would generate instead. This is the technique that powers features such as type traits and conditional compilation, which are metaprogramming concepts we will explore in <a href="B18367_05_ePub.xhtml#_idTextAnchor080"><em class="italic">Chapter 5</em></a>, <em class="italic">Type Traits and Conditional Compilation</em>.</p>
			<p>There are two forms of template specialization: <strong class="bold">explicit (full) specialization</strong> and <strong class="bold">partial specialization</strong>. We will look in detail at these two in the following sections.</p>
			<h2 id="_idParaDest-38"><a id="_idTextAnchor041"/>Explicit specialization</h2>
			<p>Explicit specialization (also called full specialization) occurs when you provide a definition for <a id="_idIndexMarker123"/>a template instantiation <a id="_idIndexMarker124"/>with the full set of template arguments. The following can be fully specialized:</p>
			<ul>
				<li>Function templates</li>
				<li>Class templates</li>
				<li>Variable templates (as of C++14)</li>
				<li>Member functions, classes, and enumerations of a class template</li>
				<li>Member function templates and class templates of a class or class template</li>
				<li>Static data members of a class template</li>
			</ul>
			<p>Let's start <a id="_idIndexMarker125"/>by looking at the following <a id="_idIndexMarker126"/>example:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct is_floating_point</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   constexpr static bool value = false;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;&gt;</pre>
			<pre class="source-code">struct is_floating_point&lt;float&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   constexpr static bool value = true;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;&gt;</pre>
			<pre class="source-code">struct is_floating_point&lt;double&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   constexpr static bool value = true;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;&gt;</pre>
			<pre class="source-code">struct is_floating_point&lt;long double&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   constexpr static bool value = true;</pre>
			<pre class="source-code">};</pre>
			<p>In this code snippet, <strong class="source-inline">is_floating_point</strong> is the primary template. It contains a <strong class="source-inline">constexpr</strong> static <a id="_idIndexMarker127"/>Boolean data member <a id="_idIndexMarker128"/>called <strong class="source-inline">value</strong> that is initialized with the <strong class="source-inline">false</strong> value. Then, we have three full specializations of this primary template, for the <strong class="source-inline">float</strong>, <strong class="source-inline">double</strong>, and <strong class="source-inline">long double</strong> types. These new definitions change the way <strong class="source-inline">value</strong> is being initialized using <strong class="source-inline">true</strong> instead of <strong class="source-inline">false</strong>. As a result, we can use this template to write code as follows:</p>
			<pre class="source-code">std::cout &lt;&lt; is_floating_point&lt;int&gt;::value         &lt;&lt; '\n';</pre>
			<pre class="source-code">std::cout &lt;&lt; is_floating_point&lt;float&gt;::value       &lt;&lt; '\n';</pre>
			<pre class="source-code">std::cout &lt;&lt; is_floating_point&lt;double&gt;::value      &lt;&lt; '\n';</pre>
			<pre class="source-code">std::cout &lt;&lt; is_floating_point&lt;long double&gt;::value &lt;&lt; '\n';</pre>
			<pre class="source-code">std::cout &lt;&lt; is_floating_point&lt;std::string&gt;::value &lt;&lt; '\n';</pre>
			<p>The first and last lines print <strong class="source-inline">0</strong> (for <strong class="source-inline">false</strong>); the other lines print <strong class="source-inline">1</strong> (for <strong class="source-inline">true</strong>). This example is a demonstration of how <strong class="source-inline">type</strong> traits work. In fact, the standard library contains a class template called <strong class="source-inline">is_floating_point</strong> in the <strong class="source-inline">std</strong> namespace, defined in the <strong class="source-inline">&lt;type_traits&gt;</strong> header. We will learn more about this topic in <a href="B18367_05_ePub.xhtml#_idTextAnchor080"><em class="italic">Chapter 5</em></a>, <em class="italic">Type Traits and Conditional Compilation</em>.</p>
			<p>As you can see in this example, static class members can be fully specialized. However, each specialization has its own copy of any static members, which is demonstrated with the following example:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct foo</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   static T value;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;typename T&gt; T foo&lt;T&gt;::value = 0;</pre>
			<pre class="source-code">template &lt;&gt; int foo&lt;int&gt;::value = 42;</pre>
			<pre class="source-code">foo&lt;double&gt; a, b;  // a.value=0, b.value=0</pre>
			<pre class="source-code">foo&lt;int&gt; c;        // c.value=42</pre>
			<pre class="source-code">a.value = 100;     // a.value=100, b.value=100, c.value=42</pre>
			<p>Here, <strong class="source-inline">foo&lt;T&gt;</strong> is a class template with a single static member, called <strong class="source-inline">value</strong>. This is initialized with <strong class="source-inline">0</strong> for the primary template and with <strong class="source-inline">42</strong> for the <strong class="source-inline">int</strong> specialization. After declaring the variables <strong class="source-inline">a</strong>, <strong class="source-inline">b</strong>, and <strong class="source-inline">c</strong>, <strong class="source-inline">a.value</strong> is <strong class="source-inline">0</strong> and <strong class="source-inline">b.value</strong> is <strong class="source-inline">0</strong> while <strong class="source-inline">c.value</strong> is <strong class="source-inline">42</strong>. However, after assigning the value <strong class="source-inline">100</strong> to <strong class="source-inline">a.value</strong>, <strong class="source-inline">b.value</strong> is also <strong class="source-inline">100</strong>, while <strong class="source-inline">c.value</strong> remains <strong class="source-inline">42</strong>. </p>
			<p>Explicit specialization <a id="_idIndexMarker129"/>must appear after the primary <a id="_idIndexMarker130"/>template declaration. It does not require a definition of the primary template to be available prior to the explicit specialization. The following code is therefore valid:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct is_floating_point;</pre>
			<pre class="source-code">template &lt;&gt;</pre>
			<pre class="source-code">struct is_floating_point&lt;float&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   constexpr static bool value = true;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct is_floating_point</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   constexpr static bool value = false;</pre>
			<pre class="source-code">};</pre>
			<p>Template specializations can also be only declared without being defined. Such a template specialization can be used like any other incomplete type. You can see an example of this here:</p>
			<pre class="source-code">template &lt;typename&gt;</pre>
			<pre class="source-code">struct foo {};    // primary template</pre>
			<pre class="source-code">template &lt;&gt;</pre>
			<pre class="source-code">struct foo&lt;int&gt;;  // explicit specialization declaration</pre>
			<pre class="source-code">foo&lt;double&gt; a; // OK</pre>
			<pre class="source-code">foo&lt;int&gt;* b;   // OK</pre>
			<pre class="source-code">foo&lt;int&gt; c;    // error, foo&lt;int&gt; incomplete type</pre>
			<p>In this example, <strong class="source-inline">foo&lt;T&gt;</strong> is the primary template for which a declaration of an explicit specialization for the <strong class="source-inline">int</strong> type exists. This makes it possible to use <strong class="source-inline">foo&lt;double&gt;</strong> and <strong class="source-inline">foo&lt;int&gt;*</strong> (declaring pointers to partial types is supported). However, at the point of declaring the <strong class="source-inline">c</strong> variable, the complete type <strong class="source-inline">foo&lt;int&gt;</strong> is not available, since a definition of the full specialization for <strong class="source-inline">int</strong> is missing. This generates a compiler error.</p>
			<p>When specializing <a id="_idIndexMarker131"/>a function template, if the <a id="_idIndexMarker132"/>compiler can deduce a template argument from the type of the function arguments, then that template argument is optional. This is demonstrated by the following example:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct foo {};</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">void func(foo&lt;T&gt;) </pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   std::cout &lt;&lt; "primary template\n";</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template&lt;&gt;</pre>
			<pre class="source-code">void func(foo&lt;int&gt;) </pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   std::cout &lt;&lt; "int specialization\n";</pre>
			<pre class="source-code">}</pre>
			<p>The syntax for the full specialization for <strong class="source-inline">int</strong> of the <strong class="source-inline">func</strong> function template should be <strong class="source-inline">template&lt;&gt; func&lt;int&gt;(foo&lt;int&gt;)</strong>. However, the compiler is able to deduce the actual type that <strong class="source-inline">T</strong> represents from the function argument. Therefore, we don't have to specify it when defining the specialization.</p>
			<p>On the other <a id="_idIndexMarker133"/>hand, declarations or definitions of <a id="_idIndexMarker134"/>function templates and member function templates are not allowed to contain default function arguments. Therefore, in the following example, the compiler will issue an error:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">void func(T a)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   std::cout &lt;&lt; "primary template\n";</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template &lt;&gt;</pre>
			<pre class="source-code">void func(int a = 0) // error: default argument not allowed</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   std::cout &lt;&lt; "int specialization\n";</pre>
			<pre class="source-code">}</pre>
			<p>In all these examples, the templates had a single template argument. However, in practice, many <a id="_idIndexMarker135"/>templates have multiple <a id="_idIndexMarker136"/>arguments. Explicit specialization requires a definition with the full set of arguments being specified. This is demonstrated with the following snippet:</p>
			<pre class="source-code">template &lt;typename T, typename U&gt;</pre>
			<pre class="source-code">void func(T a, U b)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   std::cout &lt;&lt; "primary template\n";</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template &lt;&gt;</pre>
			<pre class="source-code">void func(int a, int b)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   std::cout &lt;&lt; "int-int specialization\n";</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template &lt;&gt;</pre>
			<pre class="source-code">void func(int a, double b)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   std::cout &lt;&lt; "int-double specialization\n";</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">func(1, 2);      // int-int specialization</pre>
			<pre class="source-code">func(1, 2.0);    // int-double specialization</pre>
			<pre class="source-code">func(1.0, 2.0);  // primary template</pre>
			<p>With these <a id="_idIndexMarker137"/>covered, we can move forward and <a id="_idIndexMarker138"/>look into partial specialization, which is basically a generalization of explicit (full) specialization.</p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor042"/>Partial specialization</h2>
			<p>Partial specialization occurs when you specialize a primary template but only specify some of the <a id="_idIndexMarker139"/>template arguments. This means a partial specialization has <a id="_idIndexMarker140"/>both a template parameter list (which follows the template keyword) and a template argument list (which follows the template name). However, only classes can be partially specialized.</p>
			<p>Let's explore the following example to understand how this works:</p>
			<pre class="source-code">template &lt;typename T, int S&gt;</pre>
			<pre class="source-code">struct collection</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void operator()()</pre>
			<pre class="source-code">   { std::cout &lt;&lt; "primary template\n"; }</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct collection&lt;T, 10&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void operator()()</pre>
			<pre class="source-code">   { std::cout &lt;&lt; "partial specialization &lt;T, 10&gt;\n"; }</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;int S&gt;</pre>
			<pre class="source-code">struct collection&lt;int, S&gt;</pre>
			<pre class="source-code">{ </pre>
			<pre class="source-code">   void operator()()</pre>
			<pre class="source-code">   { std::cout &lt;&lt; "partial specialization &lt;int, S&gt;\n"; }</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;typename T, int S&gt;</pre>
			<pre class="source-code">struct collection&lt;T*, S&gt;</pre>
			<pre class="source-code">{ </pre>
			<pre class="source-code">   void operator()()</pre>
			<pre class="source-code">   { std::cout &lt;&lt; "partial specialization &lt;T*, S&gt;\n"; }</pre>
			<pre class="source-code">};</pre>
			<p>We have a primary template called <strong class="source-inline">collection</strong> that has two template arguments (a type template <a id="_idIndexMarker141"/>argument and a non-type template argument) and we <a id="_idIndexMarker142"/>have three partial specializations, as follows:</p>
			<ul>
				<li>A specialization for the non-type template argument <strong class="source-inline">S</strong> with the value <strong class="source-inline">10</strong></li>
				<li>A specialization for the <strong class="source-inline">int</strong> type</li>
				<li>A specialization for the pointer type <strong class="source-inline">T*</strong></li>
			</ul>
			<p>These templates can be used as shown in the following snippet:</p>
			<pre class="source-code">collection&lt;char, 42&gt; a;  // primary template</pre>
			<pre class="source-code">collection&lt;int,  42&gt; b;  // partial specialization &lt;int, S&gt;</pre>
			<pre class="source-code">collection&lt;char, 10&gt; c;  // partial specialization &lt;T, 10&gt;</pre>
			<pre class="source-code">collection&lt;int*, 20&gt; d;  // partial specialization &lt;T*, S&gt;</pre>
			<p>As specified in the comments, <strong class="source-inline">a</strong> is instantiated from the primary template, <strong class="source-inline">b</strong> from the partial specialization for <strong class="source-inline">int</strong> (<strong class="source-inline">collection&lt;int, S&gt;</strong>), <strong class="source-inline">c</strong> from the partial specialization for <strong class="source-inline">10</strong> (<strong class="source-inline">collection&lt;T, 10&gt;</strong>), and <strong class="source-inline">d</strong> from the partial specialization for pointers (<strong class="source-inline">collection&lt;T*, S&gt;</strong>). However, some combinations are not possible because they are ambiguous and the compiler cannot select which template instantiation to use. Here are a couple of examples:</p>
			<pre class="source-code">collection&lt;int,   10&gt; e; // error: collection&lt;T,10&gt; or </pre>
			<pre class="source-code">                         //        collection&lt;int,S&gt;</pre>
			<pre class="source-code">collection&lt;char*, 10&gt; f; // error: collection&lt;T,10&gt; or </pre>
			<pre class="source-code">                         //        collection&lt;T*,S&gt;</pre>
			<p>In the first case, both <strong class="source-inline">collection&lt;T, 10&gt;</strong> and <strong class="source-inline">collection&lt;int, S&gt;</strong> partial specializations match the type <strong class="source-inline">collection&lt;int, 10&gt;</strong>, while in the second case it can be either <strong class="source-inline">collection&lt;T, 10&gt;</strong> or <strong class="source-inline">collection&lt;T*, S&gt;</strong>.</p>
			<p>When defining <a id="_idIndexMarker143"/>specializations of a primary template, you need to <a id="_idIndexMarker144"/>keep in mind the following:</p>
			<ul>
				<li>Parameters in the template parameters list of the partial specialization cannot have default values.</li>
				<li>The template parameters list implies an order of the arguments in the template arguments list, which is featured only in a partial specialization. This template arguments list of a partial specialization cannot be the same as the one implied by the template parameters list.</li>
				<li>In the template argument list, you can only use identifiers for non-type template parameters. Expressions are not allowed in this context. This is demonstrated with the following example:<p class="source-code">template &lt;int A, int B&gt; struct foo {};</p><p class="source-code">template &lt;int A&gt; struct foo&lt;A, A&gt; {};     // OK</p><p class="source-code">template &lt;int A&gt; struct foo&lt;A, A + 1&gt; {}; // error</p></li>
			</ul>
			<p>When a class template has partial specializations, the compiler must decide what is the best match to generate a definition from. For this purpose, it matches the template arguments of the template specialization with the template argument list of the primary template and partial specializations. Depending on the result of this matching process, the compiler does the following:</p>
			<ul>
				<li>If no match is found, a definition is generated from the primary template.</li>
				<li>If a single partial specialization is found, a definition is generated from that specialization.</li>
				<li>If more than a single partial specialization is found, then a definition is generated from the most specialized partial specialization but only if it is unique. Otherwise, the compiler generates an error (as we have seen previously). A template <strong class="source-inline">A</strong> is considered more specialized than a template <strong class="source-inline">B</strong> if it accepts a subset of the types that <strong class="source-inline">B</strong> accepts, but not the other way around.</li>
			</ul>
			<p>However, partial specializations are not found by name lookup and are considered only if the primary template is found by name lookup.</p>
			<p>To understand how partial specialization is useful, let's take a look at a real-world example. </p>
			<p>In this example, we want to create a function that formats the content of an array in a nice way and outputs <a id="_idIndexMarker145"/>it to a stream. The content of a formatted array should <a id="_idIndexMarker146"/>look like <em class="italic">[1,2,3,4,5]</em>. However, for arrays of <strong class="source-inline">char</strong> elements, the elements should not be separated by a comma but instead displayed as a string within square brackets, such as <em class="italic">[demo]</em>. For this purpose, we will consider the use of the <strong class="source-inline">std::array</strong> class. The following implementation formats the content of the array with delimiters between the elements:</p>
			<pre class="source-code">template &lt;typename T, size_t S&gt;</pre>
			<pre class="source-code">std::ostream&amp; pretty_print(std::ostream&amp; os, </pre>
			<pre class="source-code">                           std::array&lt;T, S&gt; const&amp; arr)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   os &lt;&lt; '[';</pre>
			<pre class="source-code">   if (S &gt; 0)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      size_t i = 0;</pre>
			<pre class="source-code">      for (; i &lt; S - 1; ++i)</pre>
			<pre class="source-code">         os &lt;&lt; arr[i] &lt;&lt; ',';</pre>
			<pre class="source-code">      os &lt;&lt; arr[S-1];</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   os &lt;&lt; ']';</pre>
			<pre class="source-code">   return os;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">std::array&lt;int, 9&gt; arr {1, 1, 2, 3, 5, 8, 13, 21};</pre>
			<pre class="source-code">pretty_print(std::cout, arr);  // [1,1,2,3,5,8,13,21]</pre>
			<pre class="source-code">std::array&lt;char, 9&gt; str;</pre>
			<pre class="source-code">std::strcpy(str.data(), "template");</pre>
			<pre class="source-code">pretty_print(std::cout, str);  // [t,e,m,p,l,a,t,e]</pre>
			<p>In this snippet, <strong class="source-inline">pretty_print</strong> is a function template with two template parameters, matching the <a id="_idIndexMarker147"/>template parameters of the <strong class="source-inline">std::array</strong> class. When called <a id="_idIndexMarker148"/>with the <strong class="source-inline">arr</strong> array as an argument, it prints <em class="italic">[1,1,2,3,5,8,13,21]</em>. When called with the <strong class="source-inline">str</strong> array as an argument, it prints <em class="italic">[t,e,m,p,l,a,t,e]</em>. However, our intention is to print <em class="italic">[template]</em> in this latter case. For this, we need another implementation, which is specialized for the <strong class="source-inline">char</strong> type:</p>
			<pre class="source-code">template &lt;size_t S&gt;</pre>
			<pre class="source-code">std::ostream&amp; pretty_print(std::ostream&amp; os, </pre>
			<pre class="source-code">                           std::array&lt;char, S&gt; const&amp; arr)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   os &lt;&lt; '[';</pre>
			<pre class="source-code">   for (auto const&amp; e : arr)</pre>
			<pre class="source-code">      os &lt;&lt; e;</pre>
			<pre class="source-code">   os &lt;&lt; ']';</pre>
			<pre class="source-code">   return os;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">std::array&lt;char, 9&gt; str;</pre>
			<pre class="source-code">std::strcpy(str.data(), "template");</pre>
			<pre class="source-code">pretty_print(std::cout, str);  // [template]</pre>
			<p>In this second implementation, <strong class="source-inline">pretty_print</strong> is a function template with a single template parameter, which is a non-type template parameter indicating the size of the array. The type <a id="_idIndexMarker149"/>template parameter is explicitly specified as <strong class="source-inline">char</strong>, in <strong class="source-inline">std::array&lt;char, S&gt;</strong>. This <a id="_idIndexMarker150"/>time, the call to <strong class="source-inline">pretty_print</strong> with the <strong class="source-inline">str</strong> array prints <strong class="source-inline">[template]</strong> to the console.</p>
			<p>What is key to understand here is that it's not the <strong class="source-inline">pretty_print</strong> function template that is partially specialized but the <strong class="source-inline">std::array</strong> class template. Function templates cannot be specialized and what we have here are overloaded functions. However, <strong class="source-inline">std::array&lt;char,S&gt;</strong> is a specialization of the primary class template <strong class="source-inline">std::array&lt;T, S&gt;</strong>.</p>
			<p>All the examples we have seen in this chapter were either function templat<a id="_idTextAnchor043"/>es or class templates. However, variables can also be templates and this will be the topic of the next section.</p>
			<h1 id="_idParaDest-40"><a id="_idTextAnchor044"/>Defining variable templates</h1>
			<p>Variable templates were introduced in C++14 and allow us to define variables that are templates either <a id="_idIndexMarker151"/>at namespace scope, in which case they represent a family of global variables, or at class scope, in which case they represent static data members.</p>
			<p>A variable template is declared at a namespace scope as shown in the following code snippet. This is a typical example that you can find in the literature, but we can use it to elaborate on the benefits of variable templates:</p>
			<pre class="source-code">template&lt;class T&gt;</pre>
			<pre class="source-code">constexpr T PI = T(3.1415926535897932385L);</pre>
			<p>The syntax is similar to declaring a variable (or data member) but combined with the syntax for declaring templates.</p>
			<p>The question that arises is how variable templates are actually helpful. To answer this, let's build up an example to demonstrate the point. Let's consider we want to write a function template that, given the radius of a sphere, returns its volume. The volume of a sphere is <strong class="source-inline">4πr^3 / 3</strong>. Therefore, a possible implementation is as follows:</p>
			<pre class="source-code">constexpr double PI = 3.1415926535897932385L;</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">T sphere_volume(T const r)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return 4 * PI * r * r * r / 3;</pre>
			<pre class="source-code">}</pre>
			<p>In this example, <strong class="source-inline">PI</strong> is defined as a compile-time constant of the <strong class="source-inline">double</strong> type. This will generate a compiler warning if we use <strong class="source-inline">float</strong>, for instance, for the type template parameter <strong class="source-inline">T</strong>:</p>
			<pre class="source-code">float v1 = sphere_volume(42.0f); // warning</pre>
			<pre class="source-code">double v2 = sphere_volume(42.0); // OK</pre>
			<p>A potential solution to this problem is to make <strong class="source-inline">PI</strong> a static data member of a template class with its type determined by the type template parameter. This implementation can look as follows:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct PI</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   static const T value;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;typename T&gt; </pre>
			<pre class="source-code">const T PI&lt;T&gt;::value = T(3.1415926535897932385L);</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">T sphere_volume(T const r)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return 4 * PI&lt;T&gt;::value * r * r * r / 3;</pre>
			<pre class="source-code">}</pre>
			<p>This works, although the use of <strong class="source-inline">PI&lt;T&gt;::value</strong> is not ideal. It would be nicer if we could simply write <strong class="source-inline">PI&lt;T&gt;</strong>. This is exactly what the variable template <strong class="source-inline">PI</strong> shown at the beginning of the <a id="_idIndexMarker152"/>section allows us to do. Here it is again, with the complete solution:</p>
			<pre class="source-code">template&lt;class T&gt;</pre>
			<pre class="source-code">constexpr T PI = T(3.1415926535897932385L);</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">T sphere_volume(T const r)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return 4 * PI&lt;T&gt; * r * r * r / 3;</pre>
			<pre class="source-code">}</pre>
			<p>The next example <a id="_idIndexMarker153"/>shows yet another possible use case and also demonstrates the explicit specialization of variable templates: </p>
			<pre class="source-code">template&lt;typename T&gt; </pre>
			<pre class="source-code">constexpr T SEPARATOR = '\n';</pre>
			<pre class="source-code">template&lt;&gt; </pre>
			<pre class="source-code">constexpr wchar_t SEPARATOR&lt;wchar_t&gt; = L'\n';</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">std::basic_ostream&lt;T&gt;&amp; show_parts(</pre>
			<pre class="source-code">   std::basic_ostream&lt;T&gt;&amp; s, </pre>
			<pre class="source-code">   std::basic_string_view&lt;T&gt; const&amp; str)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   using size_type = </pre>
			<pre class="source-code">      typename std::basic_string_view&lt;T&gt;::size_type;</pre>
			<pre class="source-code">   size_type start = 0;</pre>
			<pre class="source-code">   size_type end;</pre>
			<pre class="source-code">   do</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      end = str.find(SEPARATOR&lt;T&gt;, start);</pre>
			<pre class="source-code">      s &lt;&lt; '[' &lt;&lt; str.substr(start, end - start) &lt;&lt; ']' </pre>
			<pre class="source-code">        &lt;&lt; SEPARATOR&lt;T&gt;;</pre>
			<pre class="source-code">      start = end+1;</pre>
			<pre class="source-code">   } while (end != std::string::npos);</pre>
			<pre class="source-code">   return s;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">show_parts&lt;char&gt;(std::cout, "one\ntwo\nthree");</pre>
			<pre class="source-code">show_parts&lt;wchar_t&gt;(std::wcout, L"one line");</pre>
			<p>In this example, we have a function template called <strong class="source-inline">show_parts</strong> that processes an input string after splitting it into parts delimited by a separator. The separator is a variable template defined at (global) namespace scope and is explicitly specialized for the <strong class="source-inline">wchar_t</strong> type.</p>
			<p>As previously mentioned, variable templates can be members of classes. In this case, they represent static <a id="_idIndexMarker154"/>data members and need to be declared using the <strong class="source-inline">static</strong> keyword. The following example demonstrates this:</p>
			<pre class="source-code">struct math_constants</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   template&lt;class T&gt;</pre>
			<pre class="source-code">   static constexpr T PI = T(3.1415926535897932385L);</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">T sphere_volume(T const r)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return 4 * math_constants::PI&lt;T&gt; *r * r * r / 3;</pre>
			<pre class="source-code">}</pre>
			<p>You can declare a variable template in a class and then provide its definition outside the class. Notice that in this case, the variable template must be declared with <strong class="source-inline">static const</strong> and not <strong class="source-inline">static constexpr</strong>, since the latter one requires in-class initialization:</p>
			<pre class="source-code">struct math_constants</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   template&lt;class T&gt;</pre>
			<pre class="source-code">   static const T PI;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template&lt;class T&gt;</pre>
			<pre class="source-code">const T math_constants::PI = T(3.1415926535897932385L);</pre>
			<p>Variable templates are used to simplify the use of type traits. The <em class="italic">Explicit specialization</em> section <a id="_idIndexMarker155"/>contained an example for a type trait called <strong class="source-inline">is_floating_point</strong>. Here is, again, the primary template:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct is_floating_point</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   constexpr static bool value = false;</pre>
			<pre class="source-code">};</pre>
			<p>There were several explicit specializations that I will not list here again. However, this <strong class="source-inline">type</strong> trait can be used as follows:</p>
			<pre class="source-code">std::cout &lt;&lt; is_floating_point&lt;float&gt;::value &lt;&lt; '\n';</pre>
			<p>The use of <strong class="source-inline">is_floating_point&lt;float&gt;::value</strong> is rather cumbersome, but can be avoided with the help of a variable template that can be defined as follows:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">inline constexpr bool is_floating_point_v = </pre>
			<pre class="source-code">   is_floating_point&lt;T&gt;::value;</pre>
			<p>This <strong class="source-inline">is_floating_point_v</strong> variable template helps write code that is arguably simpler and easier to read. The following snippet is the form I prefer over the verbose variant with <strong class="source-inline">::value</strong>:</p>
			<pre class="source-code">std::cout &lt;&lt; is_floating_point_v&lt;float&gt; &lt;&lt; '\n';</pre>
			<p>The standard library defines a series of variable templates suffixed with <strong class="source-inline">_v</strong> for <strong class="source-inline">::value</strong>, just as in our example (such as <strong class="source-inline">std::is_floating_point_v</strong> or <strong class="source-inline">std::is_same_v</strong>). We will discuss this topic in more detail in <a href="B18367_05_ePub.xhtml#_idTextAnchor080"><em class="italic">Chapter 5</em></a>, <em class="italic">Type Traits and Conditional Compilation</em>.</p>
			<p>Variable templates are instantiated similarly to function templates and class templates. This happens <a id="_idIndexMarker156"/>either with an explicit instantiation or explicit specialization, or implicitly by the compiler. The compiler generates a definition when the variable template is used in a context where a variable definition must exist, or the variable is needed for constant evaluation of an expression.</p>
			<p>After this, we move to the topic of alias templates, which allow us to define aliases for class templates.</p>
			<h1 id="_idParaDest-41"><a id="_idTextAnchor045"/>Defining alias templates</h1>
			<p>In C++, an <strong class="bold">alias</strong> is a name used to refer to a type that has been previously defined, whether a built-in type <a id="_idIndexMarker157"/>or a user-defined type. The primary purpose of aliases is to give shorter names to types that have a long name or provide semantically meaningful names for some types. This can be done either with a <strong class="source-inline">typedef</strong> declaration or with a <strong class="source-inline">using</strong> declaration (the latter was introduced in C++11). Here are several examples using <strong class="source-inline">typedef</strong>:</p>
			<pre class="source-code">typedef int index_t;</pre>
			<pre class="source-code">typedef std::vector&lt;</pre>
			<pre class="source-code">           std::pair&lt;int, std::string&gt;&gt; NameValueList;</pre>
			<pre class="source-code">typedef int (*fn_ptr)(int, char);</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct foo</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   typedef T value_type;</pre>
			<pre class="source-code">};</pre>
			<p>In this example, <strong class="source-inline">index_t</strong> is an alias for <strong class="source-inline">int</strong>, <strong class="source-inline">NameValueList</strong> is an alias for <strong class="source-inline">std::vector&lt;std::pair&lt;int, std::string&gt;&gt;</strong>, while <strong class="source-inline">fn_ptr</strong> is an alias for the type of a pointer <a id="_idIndexMarker158"/>to a function that returns an <strong class="source-inline">int</strong> and has two parameters of type <strong class="source-inline">int</strong> and <strong class="source-inline">char</strong>. Lastly, <strong class="source-inline">foo::value_type</strong> is an alias for the type template <strong class="source-inline">T</strong>.</p>
			<p>Since C++11, these type aliases can be created with the help of <strong class="bold">using declarations</strong>, which look as follows:</p>
			<pre class="source-code">using index_t = int;</pre>
			<pre class="source-code">using NameValueList = </pre>
			<pre class="source-code">   std::vector&lt;std::pair&lt;int, std::string&gt;&gt;;</pre>
			<pre class="source-code">using fn_ptr = int(*)(int, char);</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct foo</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   using value_type = T;</pre>
			<pre class="source-code">};</pre>
			<p>Using declarations are now preferred over <strong class="source-inline">typedef</strong> declarations because they are simpler to use and are also more natural to read (from left to right). However, they have an important advantage over <strong class="source-inline">typedef</strong>s as they allow us to create aliases for templates. An <strong class="bold">alias template</strong> is a name that refers not to a type but a family of types. Remember, a template is <a id="_idIndexMarker159"/>not a class, function, or variable but a blueprint that allows the creation of a family of types, functions, or variables.</p>
			<p>To understand how alias templates work, let's consider the following example:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">using customer_addresses_t = </pre>
			<pre class="source-code">   std::map&lt;int, std::vector&lt;T&gt;&gt;;            // [1]</pre>
			<pre class="source-code">struct delivery_address_t {};</pre>
			<pre class="source-code">struct invoice_address_t {};</pre>
			<pre class="source-code">using customer_delivery_addresses_t =</pre>
			<pre class="source-code">   customer_addresses_t&lt;delivery_address_t&gt;; // [2]</pre>
			<pre class="source-code">using customer_invoice_addresses_t =</pre>
			<pre class="source-code">   customer_addresses_t&lt;invoice_address_t&gt;;  // [3]</pre>
			<p>The declaration on line <strong class="source-inline">[1]</strong> introduces the alias template <strong class="source-inline">customer_addresses_t</strong>. It's an alias for a map type where the key type is <strong class="source-inline">int</strong> and the value type is <strong class="source-inline">std::vector&lt;T&gt;</strong>. Since <strong class="source-inline">std::vector&lt;T&gt;</strong> is not a type, but a family of types, <strong class="source-inline">customer_addresses_t&lt;T&gt;</strong> defines a family of types. The <strong class="source-inline">using</strong> declarations at <strong class="source-inline">[2]</strong> and <strong class="source-inline">[3]</strong> introduce two type aliases, <strong class="source-inline">customer_delivery_addresses_t</strong> and <strong class="source-inline">customer_invoice_addresses_t</strong>, from the aforementioned family of types.</p>
			<p>Alias templates can appear at namespace or class scope just like any template declaration. On the <a id="_idIndexMarker160"/>other hand, they can neither be fully nor partially specialized. However, there are ways to overcome this limitation. A solution is to create a class template with a type alias member and specialize the class. Then you can create an alias template that refers to the type alias member. Let's demonstrate this with the help of an example.</p>
			<p>Although the following is not valid C++ code, it represents the end goal I want to achieve, had the specialization of alias templates been possible:</p>
			<pre class="source-code">template &lt;typename T, size_t S&gt;</pre>
			<pre class="source-code">using list_t = std::vector&lt;T&gt;;</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">using list_t&lt;T, 1&gt; = T;</pre>
			<p>In this example, <strong class="source-inline">list_t</strong> is an alias template for <strong class="source-inline">std::vector&lt;T&gt;</strong> provided the size of the collection is greater than <strong class="source-inline">1</strong>. However, if there is a single element, then <strong class="source-inline">list_t</strong> should be an alias for the type template parameter <strong class="source-inline">T</strong>. The way this can be actually achieved is shown in the following snippet:</p>
			<pre class="source-code">template &lt;typename T, size_t S&gt;</pre>
			<pre class="source-code">struct list</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   using type = std::vector&lt;T&gt;;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct list&lt;T, 1&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   using type = T;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;typename T, size_t S&gt;</pre>
			<pre class="source-code">using list_t = typename list&lt;T, S&gt;::type;</pre>
			<p>In this example, <strong class="source-inline">list&lt;T,S&gt;</strong> is a class template that has a member type alias called <strong class="source-inline">T</strong>. In the primary <a id="_idIndexMarker161"/>template, this is an alias for <strong class="source-inline">std::vector&lt;T&gt;</strong>. In the partial specialization <strong class="source-inline">list&lt;T,1&gt;</strong> it's an alias for <strong class="source-inline">T</strong>. Then, <strong class="source-inline">list_t</strong> is defined as an alias template for <strong class="source-inline">list&lt;T, S&gt;::type</strong>. The following asserts prove this mechanism works:</p>
			<pre class="source-code">static_assert(std::is_same_v&lt;list_t&lt;int, 1&gt;, int&gt;);</pre>
			<pre class="source-code">static_assert(std::is_same_v&lt;list_t&lt;int, 2&gt;, std::vector&lt;int&gt;&gt;);</pre>
			<p>Before we end this chapter, there is one more topic that needs to be addressed: generic lambdas and their C++20 improvement, lambda templates.</p>
			<h1 id="_idParaDest-42"><a id="_idTextAnchor046"/>Exploring generic lambdas and lambda templates</h1>
			<p>Lambdas, which are formally called <strong class="bold">lambda expressions</strong>, are a simplified way to define function <a id="_idIndexMarker162"/>objects in the place where they are needed. This typically <a id="_idIndexMarker163"/>includes predicates or comparison functions passed <a id="_idIndexMarker164"/>to algorithms. Although we will not discuss lambda expressions in general, let's take a look at the following examples:</p>
			<pre class="source-code">int arr[] = { 1,6,3,8,4,2,9 };</pre>
			<pre class="source-code">std::sort(</pre>
			<pre class="source-code">   std::begin(arr), std::end(arr),</pre>
			<pre class="source-code">   [](int const a, int const b) {return a &gt; b; });</pre>
			<pre class="source-code">int pivot = 5;</pre>
			<pre class="source-code">auto count = std::count_if(</pre>
			<pre class="source-code">   std::begin(arr), std::end(arr),</pre>
			<pre class="source-code">   [pivot](int const a) {return a &gt; pivot; });</pre>
			<p>Lambda expressions are syntactic sugar, a simplified way of defining anonymous function objects. When encountering a lambda expression, the compiler generates a class with a function-call operator. For the previous example, these could look as follows:</p>
			<pre class="source-code">struct __lambda_1</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   inline bool operator()(const int a, const int b) const</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      return a &gt; b;</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">struct __lambda_2</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   __lambda_2(int &amp; _pivot) : pivot{_pivot}</pre>
			<pre class="source-code">   {} </pre>
			<pre class="source-code">   inline bool operator()(const int a) const</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      return a &gt; pivot;</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">private: </pre>
			<pre class="source-code">   int pivot;</pre>
			<pre class="source-code">};</pre>
			<p>The names chosen here are arbitrary and each compiler will generate different names. Also, the implementation <a id="_idIndexMarker165"/>details may differ and the ones seen here are <a id="_idIndexMarker166"/>the bare minimum a compiler is supposed to generate. Notice that the difference between the first lambda and the second is that the latter contains state that it captures by value. </p>
			<p>Lambda expressions, which were introduced in C++11, have received several updates in later versions of the standard. There are notably two, which will be discussed in this chapter:</p>
			<ul>
				<li><strong class="bold">Generic lambdas</strong>, introduced in C++14, allow us to use the <strong class="source-inline">auto</strong> specifier instead of explicitly <a id="_idIndexMarker167"/>specifying types. This transforms the generated function object into one with a template function-call operator.</li>
				<li><strong class="bold">Template lambdas</strong>, introduced in C++20, allow us to use the template syntax to explicitly specify the shape <a id="_idIndexMarker168"/>of the templatized function-call operator.</li>
			</ul>
			<p>To understand the difference between these and how generic and template lambdas are helpful, let's explore the following examples:</p>
			<pre class="source-code">auto l1 = [](int a) {return a + a; };  // C++11, regular </pre>
			<pre class="source-code">                                       // lambda</pre>
			<pre class="source-code">auto l2 = [](auto a) {return a + a; }; // C++14, generic </pre>
			<pre class="source-code">                                       // lambda</pre>
			<pre class="source-code">auto l3 = []&lt;typename T&gt;(T a) </pre>
			<pre class="source-code">          { return a + a; };   // C++20, template lambda</pre>
			<pre class="source-code">auto v1 = l1(42);                      // OK</pre>
			<pre class="source-code">auto v2 = l1(42.0);                    // warning</pre>
			<pre class="source-code">auto v3 = l1(std::string{ "42" });     // error</pre>
			<pre class="source-code">auto v5 = l2(42);                      // OK</pre>
			<pre class="source-code">auto v6 = l2(42.0);                    // OK</pre>
			<pre class="source-code">auto v7 = l2(std::string{"42"});       // OK</pre>
			<pre class="source-code">auto v8 = l3(42);                      // OK</pre>
			<pre class="source-code">auto v9 = l3(42.0);                    // OK</pre>
			<pre class="source-code">auto v10 = l3(std::string{ "42" });    // OK</pre>
			<p>Here, we have three different lambdas: <strong class="source-inline">l1</strong> is a regular lambda, <strong class="source-inline">l2</strong> is a generic lambda, as at least one of the <a id="_idIndexMarker169"/>parameters is defined with the <strong class="source-inline">auto</strong> specifier, and <strong class="source-inline">l3</strong> is a template <a id="_idIndexMarker170"/>lambda, defined with the template syntax but without the use of the <strong class="source-inline">template</strong> keyword.</p>
			<p>We can invoke <strong class="source-inline">l1</strong> with an integer; we can also invoke it with a <strong class="source-inline">double</strong>, but this time the compiler will produce a warning about the possible loss of data. However, trying to invoke it with a string argument will produce a compile error, because <strong class="source-inline">std::string</strong> cannot be converted to <strong class="source-inline">int</strong>. On the other hand, <strong class="source-inline">l2</strong> is a generic lambda. The compiler proceeds to instantiate specializations of it for all the types of the arguments it's invoked with, in this example <strong class="source-inline">int</strong>, <strong class="source-inline">double</strong>, and <strong class="source-inline">std::string</strong>. The following snippet <a id="_idIndexMarker171"/>shows how the generated function object may look, at <a id="_idIndexMarker172"/>least conceptually:</p>
			<pre class="source-code">struct __lambda_3</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   template&lt;typename T1&gt;</pre>
			<pre class="source-code">   inline auto operator()(T1 a) const</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">     return a + a;</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   template&lt;&gt;</pre>
			<pre class="source-code">   inline int operator()(int a) const</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">     return a + a;</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   template&lt;&gt;</pre>
			<pre class="source-code">   inline double operator()(double a) const</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">     return a + a;</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   template&lt;&gt;</pre>
			<pre class="source-code">   inline std::string operator()(std::string a) const</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">     return std::operator+(a, a);</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<p>You can see here the primary template for the function-call operator, as well as the three specializations <a id="_idIndexMarker173"/>that we mentioned. Not surprisingly, the <a id="_idIndexMarker174"/>compiler will generate the same code for the third lambda expression, <strong class="source-inline">l3</strong>, which is a template lambda, only available in C++20. The question that arises from this is how are generic lambdas and lambda templates different? To answer this question, let's modify the previous example a bit:</p>
			<pre class="source-code">auto l1 = [](int a, int b) {return a + b; };</pre>
			<pre class="source-code">auto l2 = [](auto a, auto b) {return a + b; };</pre>
			<pre class="source-code">auto l3 = []&lt;typename T, typename U&gt;(T a, U b) </pre>
			<pre class="source-code">          { return a + b; };</pre>
			<pre class="source-code">auto v1 = l1(42, 1);                    // OK</pre>
			<pre class="source-code">auto v2 = l1(42.0, 1.0);                // warning</pre>
			<pre class="source-code">auto v3 = l1(std::string{ "42" }, '1'); // error</pre>
			<pre class="source-code">auto v4 = l2(42, 1);                    // OK</pre>
			<pre class="source-code">auto v5 = l2(42.0, 1);                  // OK</pre>
			<pre class="source-code">auto v6 = l2(std::string{ "42" }, '1'); // OK</pre>
			<pre class="source-code">auto v7 = l2(std::string{ "42" }, std::string{ "1" }); // OK </pre>
			<pre class="source-code">auto v8 = l3(42, 1);                    // OK</pre>
			<pre class="source-code">auto v9 = l3(42.0, 1);                  // OK</pre>
			<pre class="source-code">auto v10 = l3(std::string{ "42" }, '1'); // OK</pre>
			<pre class="source-code">auto v11 = l3(std::string{ "42" }, std::string{ "42" }); // OK </pre>
			<p>The new lambda expressions take two parameters. Again, we can call <strong class="source-inline">l1</strong> with two integers or an <strong class="source-inline">int</strong> and a <strong class="source-inline">double</strong> (although this again generates a warning) but we can't call it with a <a id="_idIndexMarker175"/>string and <strong class="source-inline">char</strong>. However, we can do all these with the <a id="_idIndexMarker176"/>generic lambda <strong class="source-inline">l2</strong> and the lambda template <strong class="source-inline">l3</strong>. The code the compiler generates is identical for <strong class="source-inline">l2</strong> and <strong class="source-inline">l3</strong> and looks, semantically, as follows:</p>
			<pre class="source-code">struct __lambda_4</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   template&lt;typename T1, typename T2&gt;</pre>
			<pre class="source-code">   inline auto operator()(T1 a, T2 b) const</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">     return a + b;</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   template&lt;&gt;</pre>
			<pre class="source-code">   inline int operator()(int a, int b) const</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">     return a + b;</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   template&lt;&gt;</pre>
			<pre class="source-code">   inline double operator()(double a, int b) const</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">     return a + static_cast&lt;double&gt;(b);</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   template&lt;&gt;</pre>
			<pre class="source-code">   inline std::string operator()(std::string a, </pre>
			<pre class="source-code">                                 char b) const</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">     return std::operator+(a, b);</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   template&lt;&gt;</pre>
			<pre class="source-code">   inline std::string operator()(std::string a, </pre>
			<pre class="source-code">                                 std::string b) const</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">     return std::operator+(a, b);</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<p>We see, in this snippet, the primary template for the function-call operator, and several full explicit specializations: for two <strong class="source-inline">int</strong> values, for a <strong class="source-inline">double</strong> and an <strong class="source-inline">int</strong>, for a string and a <strong class="source-inline">char</strong>, and for <a id="_idIndexMarker177"/>two string objects. But what if we want to restrict the <a id="_idIndexMarker178"/>use of the generic lambda <strong class="source-inline">l2</strong> to arguments of the same type? This is not possible. The compiler cannot deduce our intention and, therefore, it would generate a different type template parameter for each occurrence of the <strong class="source-inline">auto</strong> specifier in the parameter list. However, the lambda templates from C++20 do allow us to specify the form of the function-call operator. Take a look at the following example:</p>
			<pre class="source-code">auto l5 = []&lt;typename T&gt;(T a, T b) { return a + b; };</pre>
			<pre class="source-code">auto v1 = l5(42, 1);        // OK</pre>
			<pre class="source-code">auto v2 = l5(42, 1.0);      // error</pre>
			<pre class="source-code">auto v4 = l5(42.0, 1.0);    // OK</pre>
			<pre class="source-code">auto v5 = l5(42, false);    // error</pre>
			<pre class="source-code">auto v6 = l5(std::string{ "42" }, std::string{ "1" }); // OK </pre>
			<pre class="source-code">auto v6 = l5(std::string{ "42" }, '1'); // error               </pre>
			<p>Invoking the lambda template with any two arguments of different types, even if they are implicitly convertible such as from <strong class="source-inline">int</strong> to <strong class="source-inline">double</strong>, is not possible. The compiler will generate an error. It's not possible to explicitly provide the template arguments when invoking the template lambda, such as in <strong class="source-inline">l5&lt;double&gt;(42, 1.0)</strong>. This also generates a compiler error.</p>
			<p>The <strong class="source-inline">decltype</strong> type specifier allows us to tell the compiler to deduce the type from an expression. This topic is <a id="_idIndexMarker179"/>covered in detail in <a href="B18367_04_ePub.xhtml#_idTextAnchor064"><em class="italic">Chapter 4</em></a>, <em class="italic">Advanced Template Concepts</em>. However, in C++14, we can use this in a generic lambda to declare the <a id="_idIndexMarker180"/>second parameter in the previous generic lambda expression to have the same type as the first parameter. More precisely, this would look as follows:</p>
			<pre class="source-code">auto l4 = [](auto a, decltype(a) b) {return a + b; };</pre>
			<p>However, this implies that the type of the second parameter, <strong class="source-inline">b</strong>, must be convertible to the type of the first parameter, <strong class="source-inline">a</strong>. This allows us to write the following calls:</p>
			<pre class="source-code">auto v1 = l4(42.0, 1);                  // OK</pre>
			<pre class="source-code">auto v2 = l4(42, 1.0);                  // warning</pre>
			<pre class="source-code">auto v3 = l4(std::string{ "42" }, '1'); // error</pre>
			<p>The first call is compiled without any problems because <strong class="source-inline">int</strong> is implicitly convertible to <strong class="source-inline">double</strong>. The second call compiles with a warning, because converting from <strong class="source-inline">double</strong> to <strong class="source-inline">int</strong> may incur a loss of data. The third call, however, generates an error, because <strong class="source-inline">char</strong> cannot be implicitly convertible to <strong class="source-inline">std::string</strong>. Although the <strong class="source-inline">l4</strong> lambda is an improvement over the generic lambda <strong class="source-inline">l2</strong> seen previously, it still does not help restrict calls completely if the arguments are of different types. This is only possible with lambda templates as shown earlier.</p>
			<p>Another example <a id="_idIndexMarker181"/>of a lambda template is shown in the next snippet. This lambda has a single argument, a <strong class="source-inline">std::array</strong>. However, the type of the elements <a id="_idIndexMarker182"/>of the array and the size of the array are specified as template parameters of the lambda template:</p>
			<pre class="source-code">auto l = []&lt;typename T, size_t N&gt;(</pre>
			<pre class="source-code">            std::array&lt;T, N&gt; const&amp; arr) </pre>
			<pre class="source-code">{ </pre>
			<pre class="source-code">   return std::accumulate(arr.begin(), arr.end(), </pre>
			<pre class="source-code">                          static_cast&lt;T&gt;(0));</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">auto v1 = l(1);                           // error</pre>
			<pre class="source-code">auto v2 = l(std::array&lt;int, 3&gt;{1, 2, 3}); // OK</pre>
			<p>Attempting to call this lambda with anything other than an <strong class="source-inline">std::array</strong> object produces a compiler error. The compiler-generated function object may look as follows:</p>
			<pre class="source-code">struct __lambda_5</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   template&lt;typename T, size_t N&gt;</pre>
			<pre class="source-code">   inline auto operator()(</pre>
			<pre class="source-code">      const std::array&lt;T, N&gt; &amp; arr) const</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">     return std::accumulate(arr.begin(), arr.end(), </pre>
			<pre class="source-code">                            static_cast&lt;T&gt;(0));</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   template&lt;&gt;</pre>
			<pre class="source-code">   inline int operator()(</pre>
			<pre class="source-code">      const std::array&lt;int, 3&gt; &amp; arr) const</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">     return std::accumulate(arr.begin(), arr.end(), </pre>
			<pre class="source-code">                            static_cast&lt;int&gt;(0));</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<p>An interesting benefit of generic lambdas over regular lambdas concerns recursive lambdas. Lambdas do not have names; they are anonymous, therefore, you cannot recursively call them <a id="_idIndexMarker183"/>directly. Instead, you have to define <a id="_idIndexMarker184"/>a <strong class="source-inline">std::function</strong> object, assign the lambda expression to it, and also capture it by reference in the capture list. The following is an example of a recursive lambda that computes the factorial of a number:</p>
			<pre class="source-code">std::function&lt;int(int)&gt; factorial;</pre>
			<pre class="source-code">factorial = [&amp;factorial](int const n) {</pre>
			<pre class="source-code">   if (n &lt; 2) return 1;</pre>
			<pre class="source-code">      else return n * factorial(n - 1);</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">factorial(5);</pre>
			<p>This can be simplified with the use of generic lambdas. They don't require a <strong class="source-inline">std::function</strong> and its capture. A recursive generic lambda can be implemented as follows:</p>
			<pre class="source-code">auto factorial = [](auto f, int const n) {</pre>
			<pre class="source-code">   if (n &lt; 2) return 1;</pre>
			<pre class="source-code">   else return n * f(f, n - 1);</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">factorial(factorial, 5);</pre>
			<p>If understanding <a id="_idIndexMarker185"/>how this works is hard, the compiler-generated <a id="_idIndexMarker186"/>code should help you figure it out:</p>
			<pre class="source-code">struct __lambda_6</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   template&lt;class T1&gt;</pre>
			<pre class="source-code">   inline auto operator()(T1 f, const int n) const</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">     if(n &lt; 2) return 1;</pre>
			<pre class="source-code">     else return n * f(f, n - 1);</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   template&lt;&gt;</pre>
			<pre class="source-code">   inline int operator()(__lambda_6 f, const int n) const</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">     if(n &lt; 2) return 1;</pre>
			<pre class="source-code">     else return n * f.operator()(__lambda_6(f), n - 1);</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">__lambda_6 factorial = __lambda_6{};</pre>
			<pre class="source-code">factorial(factorial, 5);</pre>
			<p>A generic lambda is a function object with a template function-call operator. The first argument, specified <a id="_idIndexMarker187"/>with <strong class="source-inline">auto</strong>, can be anything, including the lambda itself. Therefore, the <a id="_idIndexMarker188"/>compiler will provide a full explicit specialization of the call operator for the type of the generated class. </p>
			<p>Lambda expressions help us avoid writing explicit code when we need to pass function objects as arguments to other functions. The compiler, instead, generates that code for us. Generic lambdas, introduced in C++14, help us avoid writing the same lambdas for different types. The lambda templates for C++20 allow us to specify the form of the generated call operator with the help of template syntax and semantics.</p>
			<h1 id="_idParaDest-43"><a id="_idTextAnchor047"/>Summary</h1>
			<p>This chapter was a walk through of the core features of C++ templates. We have learned how to define class templates, function templates, variable templates, and alias templates. Along the way, we looked in detail at template instantiation and template specialization after learning about template parameters. We also learned about generic lambdas and lambda templates and what benefits they have compared to regular lambdas. By completing this chapter, you are now familiar with the template fundamentals, which should allow you to understand large parts of template code as well as write templates yourself.</p>
			<p>In the next chapter, we will look at another important topic, which is templates with a variable number of arguments called variadic templates.</p>
			<h1 id="_idParaDest-44"><a id="_idTextAnchor048"/>Questions</h1>
			<ol>
				<li>What category of types can be used for non-type template parameters?</li>
				<li>Where are default template arguments not allowed?</li>
				<li>What is explicit instantiation declaration and how does it differ syntactically from explicit instantiation definition?</li>
				<li>What is an alias template?</li>
				<li>What are template lambdas?</li>
			</ol>
			<h1 id="_idParaDest-45"><a id="_idTextAnchor049"/>Further reading</h1>
			<ul>
				<li>C++ Template: A Quick UpToDate Look(C++11/14/17/20), <a href="http://www.vishalchovatiya.com/c-template-a-quick-uptodate-look/">http://www.vishalchovatiya.com/c-template-a-quick-uptodate-look/</a></li>
				<li>Templates aliases for C++<a id="_idTextAnchor050"/>, <a href="https://www.stroustrup.com/template-aliases.pdf">https://www.stroustrup.com/template-aliases.pdf</a></li>
				<li>Lambdas: From C++11 to C++20, Part 2, <a href="https://www.cppstories.com/2019/03/lambdas-story-part2/">https://www.cppstories.com/2019/03/lambdas-story-part2/</a></li>
			</ul>
		</div>
	</div></body></html>