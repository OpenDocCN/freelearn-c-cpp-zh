<html><head></head><body><div><div><div><h1 class="chapterNumber">5</h1>
    <h1 id="_idParaDest-132" class="chapterTitle">Saving and Loading the Configuration</h1>
    <p class="normal">Welcome to <a href=""><em class="italic">Chapter 5</em></a>! In the previous chapter, we added a separate view mode to the application. In this view-only mode, the user interface and selection functionality are disabled. Then, we added a simplified and, eventually, a full version of undo/redo for the instances. Setting changes to an instance can now be reverted, or reapplied.</p>
    <p class="normal">In this chapter, we will add the ability to save the configuration of the application to a file. First, we will explore different file types to store the data. After considering the pros and cons of each type of file and determining a suitable file format, we will dive into the structure of the file format. Then, we’ll implement a parser class that will allow us to load and save our configuration. Finally, we will load a default configuration at application startup, allowing the user to play around with the application.</p>
    <p class="normal">For any bigger application, it is crucial to be able to save the current state of data that was created or changed, stop the application, and load the data again to continue working. It’s also crucial to recover from a hanging or crashed application by restoring the latest saved version. You don’t want to risk losing hours of your work because the application cannot save the data properly to local or remote storage.</p>
    <p class="normal">In this chapter, we will cover the following topics:</p>
    <ul>
      <li class="bulletList">Textual or binary file formats – pros and cons</li>
      <li class="bulletList">Choosing a text format to save our data</li>
      <li class="bulletList">Exploring the structure of a YAML file</li>
      <li class="bulletList">Adding a YAML parser</li>
      <li class="bulletList">Saving and loading the configuration file</li>
      <li class="bulletList">Loading a default configuration file at startup</li>
    </ul>
    <h1 id="_idParaDest-133" class="heading-1">Technical requirements</h1>
    <p class="normal"> The example source code for this chapter is in the <code class="inlineCode">chapter05</code> folder, in the <code class="inlineCode">01_opengl_load_sve</code> subfolder for OpenGL and <code class="inlineCode">02_vulkan_load_save</code> for Vulkan.</p>
    <p class="normal">Before we add save and load functionality to our application, let’s take a look at some ways to save the data to a storage device.</p>
    <h1 id="_idParaDest-134" class="heading-1">Textual or binary file formats – pros and Cons</h1>
    <p class="normal">Whenever you play a game, cut a video, edit a photo, or write a piece of text or a book, you will make use of the integrated load and save functions integrated with the software you are using. Saving a game at a safe spot, storing a video sequence after making a large number of edits, or pressing <em class="italic">Ctrl</em> + <em class="italic">S</em> every now <a id="_idIndexMarker188"/>and then in the text editor has become normal to us.</p>
    <p class="normal">But have you ever thought about the <a id="_idIndexMarker189"/>data that is saved and loaded? You might have some questions regarding the following functions, like:</p>
    <ul>
      <li class="bulletList">What needs to be stored to fully restore your latest state?</li>
      <li class="bulletList">What format should be used to save the data?</li>
      <li class="bulletList">What happens if a program is updated? Will I be able to load the saved data?</li>
      <li class="bulletList">Can I read or change the saved file without the original program?</li>
    </ul>
    <p class="normal">For all programs you only use, the decision about the format and amount of data lies in the hands of their developers. But, for our application, we must decide which data needs to be saved, and how to save the data to the storage.</p>
    <p class="normal">All types of data formats have pros and cons; here is a short round-up.</p>
    <h2 id="_idParaDest-135" class="heading-2">Saving and loading binary data</h2>
    <p class="normal">In the early times of the computer era, storage space and computation time were expensive, precious, and scarce. To minimize space and time during the save and restore process, the data was more or less only a memory dump.</p>
    <p class="normal">The data to save was stored in internal data types, into a memory area of the computer and then literally copied byte by byte to <a id="_idIndexMarker190"/>a floppy disk or a hard drive. </p>
    <p class="normal">Loading the same data was as easy and fast as saving it: read the data from the storage device to the computer’s memory (again, byte by byte) and interpret it as the same internal data types that were used while saving.</p>
    <p class="normal">Let’s take a look at some of the advantages and disadvantages of binary data:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Advantages</strong>:<ul>
          <li class="bulletList level-2">Files are small.</li>
          <li class="bulletList level-2">Saving and loading the data can be done by just copying the data, leading to a higher speed for save and load operations.</li>
        </ul>
      </li>
      <li class="bulletList"><strong class="keyWord">Disadvantages</strong>:<ul>
          <li class="bulletList level-2">To change the data outside the application, special knowledge is needed.</li>
          <li class="bulletList level-2">Corrupted data could cause unpredictable side effects or crashes.</li>
          <li class="bulletList level-2">Updates to the save file format may be hard. <em class="italic">Magic bytes</em> are needed to find the actual version and to map the loaded data to the correct internal data types.</li>
        </ul>
      </li>
    </ul>
    <p class="normal">Binary data may not be portable across architectures due to different endianness. For this reason, it is generally good advice to avoid binary save files unless absolutely necessary. We can still read <code class="inlineCode">CONFIG.SYS</code> and <code class="inlineCode">AUTOEXEC.BAT</code> files created on MS-DOS systems 30 years ago, but the binary save files from spreadsheet calculators<a id="_idIndexMarker191"/> or word processors of the same time are unusable, at least without the correct tools or hard work to reverse-engineer the file format. Outside of well-documented and standardized formats, like pictures or sound files, saving binary data <strong class="keyWord">will</strong> cause trouble, as you may not be able to open the binary files on a different operating system, or even just a newer version of the same system. Also, loading the file on a different CPU architecture, bit width, or endianness will most probably fail due to a different memory layout of the data types.</p>
    <p class="normal">Since CPU time and storage space are no longer limited, the advantages of text formats now clearly outweigh those of binary saves.</p>
    <h2 id="_idParaDest-136" class="heading-2">Saving and loading textual data</h2>
    <p class="normal">After more and more CPU power, network bandwidth, and storage space became available, textual formats started to become the first choice to save data. Developing code is much easier when you can create or adjust the<a id="_idIndexMarker192"/> saved files with a simple text editor, or when you can find errors by printing the text lines to log files.</p>
    <p class="normal">For a text-based save file, the conditions differ from those for a binary save:</p>
    <ul>
      <li class="bulletList">Files are larger, except <a id="_idIndexMarker193"/>when they are compressed into a .zip file or similar. Then, another transformation step (pack/unpack) is needed.</li>
      <li class="bulletList">Data must be transformed from binary representation to text and back, every time the data is loaded and saved.</li>
      <li class="bulletList">Domain-specific knowledge of the file format may be required for larger changes, or to create a save file <em class="italic">from scratch</em>. But for simple value changes, a text editor is the only tool we need.</li>
      <li class="bulletList">Corrupted data can be fixed, or the corrupt data elements may be simply deleted from the text file. Better to lose only some data than all of it.</li>
      <li class="bulletList">File format updates can be detected by advancing a version number in the file, helping the application to use the correct transformations.</li>
      <li class="bulletList">Loading the same file on a computer with a different architecture or operating system is no problem at all. The textual representation is the same, and due to the transformation from text to binary data types, endianness or data type lengths do not matter.</li>
      <li class="bulletList">Some caveats still exist for cross-platform usage, like different path separators in Windows and Linux, or the different interpretation of points and commas in the locale settings of the system.</li>
      <li class="bulletList">If the configuration needs to be split into multiple files, packing all files into a compressed file is the most common way. By adding all configuration files in a <code class="inlineCode">.zip</code> or <code class="inlineCode">.tar.gz</code> file, you end up with only a single file, and save some disk space due to the compression.</li>
    </ul>
    <p class="normal">Using a textual representation for <a id="_idIndexMarker194"/>our save file is the way to go. And, by defining a simple file format, it is <a id="_idIndexMarker195"/>even possible to create a configuration file by hand.</p>
    <p class="normal">But, before we start creating a file format on our own, let’s check some available file formats. By using a well-known file format, we can save a lot of time since we don’t have to create the functions to parse and write a file.</p>
    <h1 id="_idParaDest-137" class="heading-1">Choosing a text format to save our data</h1>
    <p class="normal">We will look at three popular <a id="_idIndexMarker196"/>configuration file formats in this section:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">INI</strong></li>
      <li class="bulletList"><strong class="keyWord">JSON</strong></li>
      <li class="bulletList"><strong class="keyWord">YAML</strong></li>
    </ul>
    <p class="normal">All three formats find applications in certain fields but may not be suitable in others.</p>
    <h2 id="_idParaDest-138" class="heading-2">The INI file format</h2>
    <p class="normal">One of the oldest formats to <a id="_idIndexMarker197"/>store configuration data is the so-called INI format. The name<a id="_idIndexMarker198"/> comes from the file extension <code class="inlineCode">.ini</code>, which is a three-letter abbreviation for initialization. An INI file is mostly used to configure programs.</p>
    <p class="normal">In the INI file, simple key/value pairs are stored and organized in optional sections. A section name is enclosed in square brackets, and the section scope runs from the start of the section to the start of another section, or the end of the file.</p>
    <p class="normal">Here is an example of a section and some key/value pairs for a database connection:</p>
    <pre class="programlisting code"><code class="hljs-code">[database-config]
type = mysql
host = mysql
port = 3306
user = app1
password = ASafePassWord1#
</code></pre>
    <p class="normal">Sections can be nested to create some sort of hierarchy by separating sections and subsections by special characters, like a dot (<code class="inlineCode">.</code>) or a backslash (<code class="inlineCode">\</code>). It’s crucial for the parser to recognize these section divisions; otherwise, each section will be treated independently, without considering their hierarchical relationship.</p>
    <p class="normal">The lack of duplicate key names makes it hard to store hierarchical or non-trivial data where the same key may occur more than once, like a model file or an instance configuration.</p>
    <h2 id="_idParaDest-139" class="heading-2">The JSON file format</h2>
    <p class="normal">JSON, short for JavaScript Object Notation, made<a id="_idIndexMarker199"/> its debut in the early 2000s. As in the INI file, key/value pairs are stored in a JSON file. Sections similar to the INI file sections do not exist; instead, a JSON file allows the creation of complex, tree-like hierarchies. Also, arrays of the same data type can be defined.</p>
    <p class="normal">The main usage for JSON files is electronic data interchange, for instance, between web applications and backend<a id="_idIndexMarker200"/> servers. Good readability of the file format by humans is only a side effect; JSON files are mostly read and written by applications.</p>
    <p class="normal">This is an example of a JSON file, containing the same data as the INI file example:</p>
    <pre class="programlisting code"><code class="hljs-code">{
  "database-config": {
    "type": "mysql",
    "host": "mysql",
    "port": 3306,
    "user": "app1",
    "password": "ASafePassWord1#"
  }
}
</code></pre>
    <p class="normal">Sadly, due to the large number of braces, the file format is hard to write correctly on the first try. Also, no comments are allowed, so testing different options <em class="italic">on the fly</em> can only be done by saving a copy of the original file and adjusting the content.</p>
    <h2 id="_idParaDest-140" class="heading-2">The YAML file format</h2>
    <p class="normal">The name YAML was originally an acronym for <em class="italic">Yet Another Markup Language</em>. At the start of the 2000s, the <em class="italic">yet another</em> prefix for a <a id="_idIndexMarker201"/>product name was used as computer-related humor, stating the ever-growing repetition of unoriginal ideas. But, since YAML is not a markup<a id="_idIndexMarker202"/> language like HTML or XML, the meaning of the name was changed to the recursive acronym <em class="italic">YAML Ain’t Markup Language</em>.</p>
    <p class="normal">YAML and JSON are closely related. A JSON file can be transformed into a YAML file, and vice versa. The main difference between the two formats is that instead of using curly braces, the hierarchy in YAML is created by indents.</p>
    <p class="normal">YAML’s main goal was to be readable by humans. The YAML format is widely used to create and maintain structured and hierarchical configuration files (i.e., in configuration management systems and cloud environments).</p>
    <p class="normal">Here is an example of the YAML file format, again with the same data as INI and JSON:</p>
    <pre class="programlisting code"><code class="hljs-code">database-config:
  type: mysql
  host: mysql
  port: 3306
  user: app1
  password: ASafePassWord1#
</code></pre>
    <p class="normal">Since the YAML format is simple and powerful, has all the features we need, and can be read and written without stumbling over <a id="_idIndexMarker203"/>missing braces, like in JSON, we will use a YAML file to store the configuration data for our application.</p>
    <h1 id="_idParaDest-141" class="heading-1">Exploring the structure of a YAML file</h1>
    <p class="normal">Let’s look at the three main <a id="_idIndexMarker204"/>components of a YAML file:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Nodes</strong></li>
      <li class="bulletList"><strong class="keyWord">Maps</strong></li>
      <li class="bulletList"><strong class="keyWord">Sequences</strong></li>
    </ul>
    <p class="normal">Let’s start with the node.</p>
    <h2 id="_idParaDest-142" class="heading-2">The YAML node</h2>
    <p class="normal">The main object of a YAML file is a so-called node. A node represents the data structure below it, which can be a scalar <a id="_idIndexMarker205"/>value, a map, or a sequence.</p>
    <pre>of a configuration file as an example:</pre>
    <pre class="programlisting code"><code class="hljs-code">database-config:
  type: mysql
</code></pre>
    <p class="normal">Both <code class="inlineCode">database-config</code> and <code class="inlineCode">type</code> are YAML nodes. While the <code class="inlineCode">database-config</code> node holds a map containing the key <code class="inlineCode">type</code> and the value <code class="inlineCode">mysql</code>, the node type just has the scalar value <code class="inlineCode">mysql</code> in it.</p>
    <h2 id="_idParaDest-143" class="heading-2">The YAML map</h2>
    <p class="normal">A YAML map contains between zero <a id="_idIndexMarker207"/>and an arbitrary number of key/value pairs. Plus, there is <a id="_idIndexMarker208"/>an interesting correlation between nodes and maps: the key and the value may be another node, creating the hierarchy in the file.</p>
    <p class="normal">Let’s extend the configuration snippet from the node section before:</p>
    <pre class="programlisting code"><code class="hljs-code">database-config:
  type: mysql
  host: mysql
  port: 3306
</code></pre>
    <p class="normal">As stated before, <code class="inlineCode">database-config</code> is both a node and a map. The key of the map named <code class="inlineCode">database-config</code> is the name <code class="inlineCode">database-config</code>, and the value is another map, containing the three key/value pairs.</p>
    <h2 id="_idParaDest-144" class="heading-2">The YAML sequence</h2>
    <p class="normal">To enumerate similar elements, a YAML sequence is used. A sequence can be seen as a C++ <code class="inlineCode">std::vector</code>, where all elements must be<a id="_idIndexMarker209"/> of the same kind. Like the C++ vector, you iterate over the sequence, reading the data elements one by one.</p>
    <p class="normal">Sequences come in two different flavors: the <em class="italic">block style</em> and the <em class="italic">flow style</em>.</p>
    <p class="normal">In the block style, an indented dash (<code class="inlineCode">-</code>) is used as an indicator of the elements:</p>
    <pre class="programlisting code"><code class="hljs-code">colors:
  - red
  - green
  - blue
</code></pre>
    <p class="normal">In contrast, the flow style uses square brackets, and the elements are separated by commas:</p>
    <pre class="programlisting code"><code class="hljs-code">colors: [red, green, blue]
</code></pre>
    <p class="normal">Both styles represent the same data. It is a matter of personal preference and readability.</p>
    <p class="normal">By combining maps and sequences, complex data structures can be created.</p>
    <h2 id="_idParaDest-145" class="heading-2">Combinations of maps and sequences</h2>
    <p class="normal">A powerful way to <a id="_idIndexMarker210"/>represent data can be achieved by mixing maps and sequences. For instance, we could store the <code class="inlineCode">position</code> and <code class="inlineCode">rotation</code> of all our model instances like this:</p>
    <pre class="programlisting code"><code class="hljs-code">instances:
  - position: [0, 0, 0]
    rotation: [0, 0, 0]
  - position: [1, 0, -3]
    rotation: [0, 90, 0]
  - position: [3, 0, 3]
    rotation: [0, -90, 0]
</code></pre>
    <p class="normal">Here, both combinations of maps and sequences are used.</p>
    <p class="normal">First, we create a map out of the keys <code class="inlineCode">position</code> and <code class="inlineCode">rotation</code>; the values are flow-style sequences of numbers, representing a <code class="inlineCode">glm::vec3</code>. YAML always stores the shortest possible representation of a scalar number. So, as long as values have no fractional part, an integer value will be used, even for <code class="inlineCode">float</code> and <code class="inlineCode">double</code> types. Then, the map of <code class="inlineCode">position</code> and <code class="inlineCode">rotation</code> is used in a block sequence to create an array-style representation of the model instances.</p>
    <p class="normal">To read the data of the instances into our application, we must first iterate over the model instance sequence, and for every instance, we can extract the position and rotation values.</p>
    <p class="normal">After the basic excurse into the YAML file format, we will now implement a YAML parser and writer class for our application to save and load its configuration. Having the configuration stored on disk is like saving a text document – we can quit the application and continue to work in the virtual world later. We can also use the saved files to return to the previous state of the virtual world.</p>
    <h1 id="_idParaDest-146" class="heading-1">Adding a YAML parser</h1>
    <p class="normal">Like other tools we are <a id="_idIndexMarker211"/>already using (the Open Asset Import Library, GLFW, or ImGui), we will use a freely available open source solution: <code class="inlineCode">yaml-cpp</code>.</p>
    <p class="normal">By integrating <code class="inlineCode">yaml-cpp</code>, we can read and write YAML files from C++ with minimal effort. The biggest step is to make sure our custom data types are known to <code class="inlineCode">yaml-cpp</code>. Plus, we have to think about a proper structure for the data file.</p>
    <p class="normal">Let’s start by exploring how to integrate <code class="inlineCode">yaml-cpp</code> into our project.</p>
    <h2 id="_idParaDest-147" class="heading-2">Getting yaml-cpp</h2>
    <p class="normal">For Linux systems, getting <code class="inlineCode">yaml-cpp</code> is easy. Similar to the other tools, most distributions already contain the <code class="inlineCode">yaml-cpp</code> library and<a id="_idIndexMarker212"/> header files. For instance, in Ubuntu 22.04 or later, <code class="inlineCode">yaml-cpp</code> and its development files can be installed with the following <a id="_idIndexMarker213"/>command:</p>
    <pre class="programlisting con"><code class="hljs-con">sudo apt install libyaml-cpp-dev
</code></pre>
    <p class="normal">If you are using an Arch based Linux distribution, you can install <code class="inlineCode">yaml-cpp</code> with the following command:</p>
    <pre class="programlisting con"><code class="hljs-con">sudo pacman –S yaml-cpp
</code></pre>
    <p class="normal">For Windows, we are also in luck. <code class="inlineCode">yaml-cpp</code> uses CMake, and by using the CMake <code class="inlineCode">FetchContent</code> commands, downloading <code class="inlineCode">yaml-cpp</code> can be added to the project with only a couple of lines. First, we add the <code class="inlineCode">FetchContent</code> declaration to the <code class="inlineCode">CMakeLists.txt</code> file in the project root. We are using version <code class="inlineCode">0.8.0</code> of <code class="inlineCode">yaml-cpp</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">  FetchContent_Declare(
    yaml-cpp
    GIT_REPOSITORY https://github.com/jbeder/yaml-cpp
    GIT_TAG 0.8.0
  )
</code></pre>
    <p class="normal">Make sure we are inside a <code class="inlineCode">WIN32</code> section in the <code class="inlineCode">CMakeLists.txt</code> file. We do not need to download the library on Linux.</p>
    <p class="normal">Then, we trigger the download of <code class="inlineCode">yaml-cpp</code> and add the variables for the directories:</p>
    <pre class="programlisting code"><code class="hljs-code">  FetchContent_MakeAvailable(yaml-cpp)
  FetchContent_GetProperties(yaml-cpp)
  if(NOT yaml-cpp_POPULATED)
    FetchContent_Populate(yaml-cpp)
    add_subdirectory(${yaml-cpp_SOURCE_DIR}
      ${yaml-cpp_BINARY_DIR} EXCLUDE_FROM_ALL)
  endif()
</code></pre>
    <p class="normal">Windows also needs a script to detect the downloaded dependency. The detection script must be named <code class="inlineCode">Findyaml-cpp.cmake</code> and placed into the <code class="inlineCode">cmake</code> folder.</p>
    <p class="normal">The main function of the script boils down to these two CMake functions:</p>
    <pre class="programlisting code"><code class="hljs-code">find_path(YAML-CPP_INCLUDE_DIR yaml-cpp/yaml.h
          PATHS ${YAML-CPP_DIR}/include/)
find_library(YAML-CPP_LIBRARY
             NAMES ${YAML-CPP_STATIC} yaml-cpp
             PATHS  ${YAML-CPP_DIR}/lib)
</code></pre>
    <p class="normal">Thanks to CMake’s <code class="inlineCode">FetchContent</code>, the <code class="inlineCode">YAML-CPP_DIR</code> variable is populated with the path to the downloaded <code class="inlineCode">yaml-cpp</code> code. So, the script <a id="_idIndexMarker214"/>only checks if the header and library <a id="_idIndexMarker215"/>can be found.</p>
    <h2 id="_idParaDest-148" class="heading-2">Integrating yaml-cpp into the CMake build</h2>
    <p class="normal">For Linux and Windows, we must set the proper include path for the compiler, and we must add the <code class="inlineCode">yaml-cpp</code> libraries to the list<a id="_idIndexMarker216"/> of linked libraries.</p>
    <p class="normal">To update the <code class="inlineCode">include</code> path, add the <code class="inlineCode">YAML_CPP_INCLUDE_DIR</code> variable to the <code class="inlineCode">include_directories</code> directive:</p>
    <pre class="programlisting code"><code class="hljs-code">include_directories(... ${YAML_CPP_INCLUDE_DIR})
</code></pre>
    <p class="normal">And for the linker, add <code class="inlineCode">yaml-cpp::yaml-cpp</code> to <code class="inlineCode">target_link_libraries</code> in Windows:</p>
    <pre class="programlisting code"><code class="hljs-code">target_link_libraries(... yaml-cpp::yaml-cpp)
</code></pre>
    <p class="normal">For Linux, only the name <code class="inlineCode">yaml-cpp</code> of the shared library is needed:</p>
    <pre class="programlisting code"><code class="hljs-code">target_link_libraries(... yaml-cpp)
</code></pre>
    <p class="normal">After running CMake again, <code class="inlineCode">yaml-cpp</code> will be downloaded and made available to the rest of the code.</p>
    <h2 id="_idParaDest-149" class="heading-2">Adding the parser class</h2>
    <p class="normal">Parsing the YAML file for loading<a id="_idIndexMarker217"/> and creating the content for writing will be done in a<a id="_idIndexMarker218"/> new class called <code class="inlineCode">YamlParser</code>, located in the <code class="inlineCode">tools</code> directory. We can use <code class="inlineCode">yaml-cpp</code> in our code after including the header file:</p>
    <pre class="programlisting code"><code class="hljs-code">#include &lt;yaml-cpp/yaml.h&gt;
</code></pre>
    <p class="normal">To store the intermediate data while loading or creating a data structure to save to disk, two additional private members are needed:</p>
    <pre class="programlisting code"><code class="hljs-code">    YAML::Node mYamlNode{};
    YAML::Emitter mYamlEmit{};
</code></pre>
    <p class="normal"><code class="inlineCode">YAML::Node</code> transforms the nodes of a YAML file from the disk into a C++ data structure, simplifying the access to the data that has been loaded. <code class="inlineCode">YAML::Emitter</code> is used to create a YAML file in memory by appending data elements, eventually writing the structured data to a file.</p>
    <h3 id="_idParaDest-150" class="heading-3">Using the node type of yaml-cpp</h3>
    <p class="normal">Accessing the structured or <a id="_idIndexMarker219"/>scalar data of a <code class="inlineCode">yaml-cpp</code> node is done by using the node name as the index to the C++ map stored in the <code class="inlineCode">YAML::Node</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code">  mYamlNode = YAML::LoadFile(fileName);
  YAML::Node settingsNode = mYamlNode["settings"];
</code></pre>
    <p class="normal">To retrieve the scalar value of a simple key/value map, the special operator <code class="inlineCode">as</code> exists:</p>
    <pre class="programlisting code"><code class="hljs-code">  int value = dataNode.as&lt;int&gt;();
</code></pre>
    <p class="normal">Since a YAML file has no knowledge of the data types stored in the value, we have to explicitly tell <code class="inlineCode">yaml-cpp</code> how to interpret the incoming data. Here, <code class="inlineCode">yaml-cpp</code> will try to get the value of the <code class="inlineCode">dataNode</code> node as <code class="inlineCode">int</code>.</p>
    <p class="normal">After defining a transformation template, custom data types like structs can also be read directly into a variable of the same type:</p>
    <pre class="programlisting code"><code class="hljs-code">InstanceSetting instSet = instNode.as&lt;InstanceSettings&gt;();
</code></pre>
    <p class="normal">We will handle transformation templates in the <em class="italic">Saving and loading the configuration file</em> section.</p>
    <h3 id="_idParaDest-151" class="heading-3">Accessing sequences and maps</h3>
    <p class="normal">In <code class="inlineCode">yaml-cpp</code>, sequences<a id="_idIndexMarker220"/> can be read by iterating over them using a <code class="inlineCode">for</code> loop, and accessing the element by the index:</p>
    <pre class="programlisting code"><code class="hljs-code">for (size_t i = 0; i &lt; instNode.size(); ++i) {
  instSettings.emplace_back(
    instNode[i].as&lt;InstanceSettings&gt;());
}
</code></pre>
    <p class="normal">The elements of the sequence are made available in the same order as they appear in the YAML file.</p>
    <p class="normal">For maps, an iterator-style <code class="inlineCode">for</code> loop is needed:</p>
    <pre class="programlisting code"><code class="hljs-code">for(auto it = settingsNode.begin();
    it != settingsNode.end(); ++it) {
  if (it-&gt;first.as&lt;std::string&gt;() == "selected-model") {
    ....
  }
}
</code></pre>
    <p class="normal">The key of the map element can be read via the <code class="inlineCode">first</code> accessor of the C++ map container. Again, we must tell <code class="inlineCode">yaml-cpp</code> which data type the map key is. Then, the value can be retrieved with the <code class="inlineCode">second</code> accessor of the C++ map container.</p>
    <p class="normal">If reading a value fails, for instance, because the type is wrong or no such node exists, an exception will be thrown. To<a id="_idIndexMarker221"/> avoid our program being terminated, we must handle all thrown exceptions.</p>
    <h3 id="_idParaDest-152" class="heading-3">Handling exceptions thrown by yaml-cpp</h3>
    <p class="normal">Instead of returning an error code, <code class="inlineCode">yaml-cpp</code> throws exceptions whenever something goes wrong. By default, any <a id="_idIndexMarker222"/>unhandled exception terminates the program. Handling an exception in C++ is done like in other languages:</p>
    <pre class="programlisting code"><code class="hljs-code">  try {
    mYamlNode = YAML::LoadFile(fileName);
  } catch(...) {
    return false;
  }
</code></pre>
    <p class="normal">The call that may cause an exception will be enclosed in a <code class="inlineCode">try</code> block, and in case of an exception, the <code class="inlineCode">catch</code> block will be executed.</p>
    <p class="normal">We can simply catch all exceptions since any parsing failure may result in an empty or incomplete configuration file. If you want to have more detailed exception handling, you can explore the <code class="inlineCode">yaml-cpp</code> source code.</p>
    <p class="normal">Armed with the basics of <code class="inlineCode">yaml-cpp</code>, we can start implementing the code to save and load a YAML file. We will start with the save functionality because after we have created a file on disk, loading the data elements back into the application will be much easier compared to hand-crafting a configuration file first.</p>
    <h1 id="_idParaDest-153" class="heading-1">Saving and loading the configuration file</h1>
    <p class="normal">Building our configuration<a id="_idIndexMarker223"/> file starts with the decision of what needs to be stored and how we want to store the elements. By reusing our custom data types like the <code class="inlineCode">InstanceSettings</code>, creating the functions to save and load a file can be simplified. Now we no longer have to read each value individually, but we can use calls like <code class="inlineCode">getInstanceSettings()</code> and <code class="inlineCode">setInstanceSettings()</code> from the <code class="inlineCode">AssimpInstance</code> class to transfer the values directly between the<a id="_idIndexMarker224"/> parser and the instance.</p>
    <p class="normal">We will start by exploring what we want to save, and after adding the code to write our custom data to the file, a user interface dialog will be added, allowing a simple way to save the file to disk. Finally, we will step through the process of loading the configuration back into the application.</p>
    <h2 id="_idParaDest-154" class="heading-2">Deciding what to store in the configuration file</h2>
    <p class="normal">As mentioned in the <em class="italic">Saving and loading textual data</em> section, adding a version number can help a lot during the <a id="_idIndexMarker225"/>development of an application. If we need to change the data format, even slightly, raising the version number can help us to simplify branching between the old and new format(s) when reading a file.</p>
    <p class="normal">Next, we should store the information about the selection. Restoring the selected model and instance, we can continue exactly from the same spot where we saved the configuration file.</p>
    <p class="normal">Also, we should store the camera information. When working with more complex scenes later in the book, restoring the camera to the default position and angles may confuse the application user.</p>
    <p class="normal">As the most important parts, we must store all information about the models and all instances on the screen required to restore the application to the same state as at the time of saving the configuration.</p>
    <p class="normal">For the model, the file name and path are sufficient, as we use the file name as the model’s name. The path to the model file will be saved relative to the application executable, and not as an absolute path, at least as long as the model resides on the same partition as the executable (Windows only). Both methods have their pros and cons:</p>
    <ul>
      <li class="bulletList">A relative path allows the user to check out the code from the book anywhere on their system, being able to use the example configuration file and example models <em class="italic">out of the box</em>. However, moving the executable to another directory or partition requires all configuration data and models to be moved too, or the configuration files must be manually adjusted.</li>
      <li class="bulletList">Using an absolute<a id="_idIndexMarker226"/> path may become handy to store a new configuration at a fixed location on the PC (i.e., in the home directory of the user). This way, the application could be started from any place on the PC and still find the configuration files and models.</li>
    </ul>
    <p class="normal">To restore all instances, we need all information stored in the <code class="inlineCode">InstanceSetting</code>s struct plus the model name. To simplify restoring the instance via the model name, we add the model name as a <code class="inlineCode">std::string</code> to the <code class="inlineCode">InstanceSettings</code> struct. Having the model name in the struct allows us to hand over a <code class="inlineCode">std::vector</code> of <code class="inlineCode">InstanceSettings</code> values from the YAML parser to the renderer class; we don’t need more complex data structures.</p>
    <p class="normal">Let’s start the implementation by creating custom element writer overloads.</p>
    <h2 id="_idParaDest-155" class="heading-2">Overloading the output operator of the emitter</h2>
    <p class="normal">The creators of <code class="inlineCode">yaml-cpp</code> added a nice<a id="_idIndexMarker227"/> method to output the contents of complex structures to the <code class="inlineCode">YAML::Emitter</code>. We only have to overload the <code class="inlineCode">operator&lt;&lt;</code> in the <code class="inlineCode">YamlParser.cpp</code> file in the <code class="inlineCode">tools</code> folder:</p>
    <pre class="programlisting code"><code class="hljs-code">YAML::Emitter&amp; operator&lt;&lt;(YAML::Emitter&amp; out,
    const glm::vec3&amp; vec) {
  out &lt;&lt; YAML::Flow;
  out &lt;&lt; YAML::BeginSeq;
  out &lt;&lt; vec.x &lt;&lt; vec.y &lt;&lt; vec.z;
  out &lt;&lt; YAML::EndSeq;
  return out;
}
</code></pre>
    <p class="normal">For the <code class="inlineCode">glm::vec3</code> data type, we add a flow type sequence, and then the three elements of the vector will be added to the stream. In the final file, a default YAML sequence will appear, containing the values of the <code class="inlineCode">glm::vec3</code> vector as in this example:</p>
    <pre class="programlisting code"><code class="hljs-code">[1, 2, 3]
</code></pre>
    <p class="normal">Our <code class="inlineCode">InstanceSettings</code> struct must be added as the key/value pairs of a YAML map. The start and end of the map are set in the <a id="_idIndexMarker228"/>function storing the <code class="inlineCode">InstanceSettings</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">YAML::Emitter&amp; operator&lt;&lt;(YAML::Emitter&amp; out,
    const InstanceSettings&amp; settings) {
  out &lt;&lt; YAML::Key &lt;&lt; "model-file";
  out &lt;&lt; YAML::Value &lt;&lt; settings.isModelFile;
  out &lt;&lt; YAML::Key &lt;&lt; "position";
  out &lt;&lt; YAML::Value &lt;&lt; settings.isWorldPosition;
  out &lt;&lt; YAML::Key &lt;&lt; "rotation";
  out &lt;&lt; YAML::Value &lt;&lt; settings.isWorldRotation
  ...
}
</code></pre>
    <p class="normal">The resulting maps will be added as the value of a YAML sequence, storing all relevant instance data in the configuration file.</p>
    <h2 id="_idParaDest-156" class="heading-2">Creating and writing the configuration file</h2>
    <p class="normal">To create a<a id="_idIndexMarker229"/> configuration file, the renderer will instantiate a local object of our <code class="inlineCode">YamlParser</code> class, and call <code class="inlineCode">createConfigFile()</code> on it:</p>
    <pre class="programlisting code"><code class="hljs-code">YamlParser parser;
if (!parser.createConfigFile(mRenderData, mModelInstData)) {
    return false;
  }
</code></pre>
    <p class="normal">In the <code class="inlineCode">createConfigFile()</code> method, the <code class="inlineCode">YAML::Emitter</code> will be filled with the structures of our data. As an example, we will add a comment at the top of the file, and save the version number in the second line:</p>
    <pre class="programlisting code"><code class="hljs-code">  mYamlEmit &lt;&lt; YAML::Comment("Application viewer
    config file");
  mYamlEmit &lt;&lt; YAML::BeginMap;
  mYamlEmit &lt;&lt; YAML::Key &lt;&lt; "version";
  mYamlEmit &lt;&lt; YAML::Value &lt;&lt; 1.0f;
  mYamlEmit &lt;&lt; YAML::EndMap;
  ...
</code></pre>
    <p class="normal">In the final YAML file, the following first lines will appear:</p>
    <pre class="programlisting code"><code class="hljs-code"># Application viewer config file
version: 1
</code></pre>
    <p class="normal">Aa another example, to store the instance settings, we create a map named <code class="inlineCode">instances</code>, and start creating a sequence as the value:</p>
    <pre class="programlisting code"><code class="hljs-code">  mYamlEmit &lt;&lt; YAML::BeginMap;
  mYamlEmit &lt;&lt; YAML::Key &lt;&lt; "instances";
  mYamlEmit &lt;&lt; YAML::Value;
  mYamlEmit &lt;&lt; YAML::BeginSeq;
</code></pre>
    <p class="normal">Then, we can create a <code class="inlineCode">for</code> loop <a id="_idIndexMarker230"/>over the instances and use the <code class="inlineCode">getInstanceSettings()</code> call of the<a id="_idIndexMarker231"/> instance to directly store the instance settings to the emitter stream:</p>
    <pre class="programlisting code"><code class="hljs-code">for (const auto&amp; instance : modInstData.miAssimpInstances) {
  mYamlEmit &lt;&lt; YAML::BeginMap;
  mYamlEmit &lt;&lt; instance-&gt;getInstanceSettings();
  mYamlEmit &lt;&lt; YAML::EndMap;
}
</code></pre>
    <p class="normal">Thanks to the <code class="inlineCode">operator&lt;&lt;</code> overload, no complex handling inside the loop is required.</p>
    <p class="normal">As the last step, we close the sequence of instance settings, and close the map for the <code class="inlineCode">instances</code> key:</p>
    <pre class="programlisting code"><code class="hljs-code">  mYamlEmit &lt;&lt; YAML::EndSeq;
  mYamlEmit &lt;&lt; YAML::EndMap
</code></pre>
    <p class="normal">The final YAML file will contain a sequence of all instances, including the newly added model file name:</p>
    <pre class="programlisting code"><code class="hljs-code">instances:
  - model-file: Woman.gltf
    position: [0, 0, 0]
    rotation: [0, 0, 0]
    scale: 1
    swap-axes: false
    anim-clip-number: 0
    anim-clip-speed: 1
</code></pre>
    <p class="normal">If we want to view the contents of the created configuration file before doing any disk writes, we can create a C string and output the string via the logger class:</p>
    <pre class="programlisting code"><code class="hljs-code">  Logger::log(1, "%s\n", mYamlEmit.c_str());
</code></pre>
    <p class="normal">Writing the file to disk will be done with a <code class="inlineCode">std::ostream</code>. The error handling for the stream has been excluded for brevity in the following listing, but saving the file to disk is essentially done in just three lines:</p>
    <pre class="programlisting code"><code class="hljs-code">bool YamlParser::writeYamlFile(std::string fileName) {
  std::ofstream fileToWrite(fileName);
  fileToWrite &lt;&lt; mYamlEmit.c_str();
  fileToWrite.close();
  return true;
}
</code></pre>
    <p class="normal">First, we create the output stream with the given file name. Then, we convert the <code class="inlineCode">std::string</code> of the <code class="inlineCode">YAML::Emitter</code> to a <a id="_idIndexMarker232"/>C string and write the string to the output stream. By closing the<a id="_idIndexMarker233"/> stream, the file will be flushed to the storage device.</p>
    <h2 id="_idParaDest-157" class="heading-2">Adding a file dialog to the user interface</h2>
    <p class="normal">To allow the user to store the configuration file in an arbitrary location and with a custom name, we will add a file dialog in the <a id="_idIndexMarker234"/>user interface. We are already using the ImGui-based file dialog to load a model file, and we can reuse the same dialog instance to present a <strong class="screenText">Save File</strong> dialog to the user.</p>
    <p class="normal">To create a dialog that lets the user choose a file name and location, three changes to the <code class="inlineCode">IGFD::FileDialogConfig</code> variable named <code class="inlineCode">config</code> must be made.</p>
    <p class="normal">First, by selecting an existing file, we need an extra dialog to confirm an overwriting of the file. Luckily, the file dialog has such a confirmation dialog already built in. All we must do is add the flag <code class="inlineCode">ImGuiFileDialogFlags_ConfirmOverwrite</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">    config.flags = ImGuiFileDialogFlags_Modal |
      ImGuiFileDialogFlags_ConfirmOverwrite;
</code></pre>
    <p class="normal">If we select an existing file, a new dialog will be shown, asking the user to confirm whether to replace the existing file or not.</p>
    <p class="normal">Next, we will present a default path and file name for the configuration:</p>
    <pre class="programlisting code"><code class="hljs-code">    const std::string defaultFileName = "config/conf.acfg";
    config.filePathName = defaultFileName.c_str();
</code></pre>
    <p class="normal">Here, we are using the <code class="inlineCode">config</code> folder and a file named <code class="inlineCode">config.acfg</code> to present a default file to the user. The file dialog code will automatically enter the <code class="inlineCode">config</code> folder and fill out the file name and extension.</p>
    <p class="normal">As a last step, we add <code class="inlineCode">.acfg</code> as the only file extension to the dialog:</p>
    <pre class="programlisting code"><code class="hljs-code">    ImGuiFileDialog::Instance()-&gt;OpenDialog(
      "SaveConfigFile", "Save Configuration File",
      ".acfg", config);
</code></pre>
    <p class="normal">By using a new extension for the configuration file, we avoid trouble, like attempts to load a different file format or overwriting other files on the system.</p>
    <p class="normal">The <strong class="screenText">OK</strong> button of the file dialog retrieves the selected file name, and calls the callback function responsible for saving the configuration to disk:</p>
    <pre class="programlisting code"><code class="hljs-code">    if (ImGuiFileDialog::Instance()-&gt;IsOk()) {
      std::string filePathName =
        ImGuiFileDialog::Instance()-&gt;GetFilePathName();
      saveSuccessful =
        modInstData.miSaveConfigCallbackFunction(
        filePathName);
    }
</code></pre>
    <p class="normal">We store the result of the callback function in the Boolean <code class="inlineCode">saveSuccessful</code>. This way, we can check for any errors and present the user a dialog in case saving the configuration was not successful.</p>
    <p class="normal">To inform the user about save<a id="_idIndexMarker235"/> errors, only a simple dialog is implemented, notifying the user to check the output messages of the application for details about the cause of the write error.</p>
    <p class="normal">If you load some models now, create instances or clones, and save the configuration, you can inspect the created configuration file. All data from the <em class="italic">Deciding what to store in the configuration file</em> section should be in the configuration file.</p>
    <p class="normal">Saving the data to disk is only half the job. To continue working from the same spot where we saved the file, we need to load the configuration file back into the application.</p>
    <h2 id="_idParaDest-158" class="heading-2">Loading the configuration file back and parsing the nodes</h2>
    <p class="normal">To support parsing custom data types in a YAML file, <code class="inlineCode">yaml-cpp</code> allows us to define a C++ template for a struct named <code class="inlineCode">convert</code>, located in the YAML <code class="inlineCode">namespace</code>. The <code class="inlineCode">convert</code> struct must implement two methods <a id="_idIndexMarker236"/>called <code class="inlineCode">encode</code> and <code class="inlineCode">decode</code>, doing the process of serializing the C++ types to YAML (<code class="inlineCode">encode</code>) and deserializing from YAML back to C++ (<code class="inlineCode">decode</code>). By using these two methods, <code class="inlineCode">yaml-cpp</code> allows a seamless transformation <a id="_idIndexMarker237"/>between C++ types and YAML entries. The <code class="inlineCode">encode</code> method creates a new YAML node from a primitive or custom data type, while the <code class="inlineCode">decode</code> method reads the YAML node data and returns the primitive or custom data type.</p>
    <p class="normal">For writing a <code class="inlineCode">glm::vec3</code> element to a YAML node and reading back a YAML node to a <code class="inlineCode">glm::vec3</code>, the following template code must be implemented in a header file:</p>
    <pre class="programlisting code"><code class="hljs-code">namespace YAML {
  template&lt;&gt;
  struct convert&lt;glm::vec3&gt; {
    static Node encode(const glm::vec3&amp; rhs) {
      Node node;
      node.push_back(rhs.x);
      node.push_back(rhs.y);
      node.push_back(rhs.z);
      return node;
    }
</code></pre>
    <p class="normal">To save the data from the <code class="inlineCode">glm::vec3</code>, we create a new YAML node called <code class="inlineCode">node</code> and add the three elements <code class="inlineCode">x</code>, <code class="inlineCode">y</code>, and <code class="inlineCode">z</code> of the <code class="inlineCode">glm::vec3</code> to the node. The node is then returned to the caller of the <code class="inlineCode">encode()</code> method.</p>
    <p class="normal">Reading back the data from a node into a <code class="inlineCode">glm::vec3</code> variable is done with the <code class="inlineCode">decode()</code> method:</p>
    <pre class="programlisting code"><code class="hljs-code">    static bool decode(const Node&amp; node, glm::vec3&amp; rhs) {
      if(!node.IsSequence() || node.size() != 3) {
        return false;
      }
</code></pre>
    <p class="normal">Checking the node type for the right type and size is optional, but it is a good style assuring we have the correct data for the custom data <a id="_idIndexMarker238"/>type to prevent runtime errors. Skipping this check and trying to parse the wrong <a id="_idIndexMarker239"/>data type will lead to an exception, terminating the entire program if unhandled.</p>
    <p class="normal">Then, we read the data from a node by the sequence index, and set the three elements <code class="inlineCode">x</code>, <code class="inlineCode">y</code>, and <code class="inlineCode">z</code> of the <code class="inlineCode">glm::vec3</code> to the float values from the node:</p>
    <pre class="programlisting code"><code class="hljs-code">      rhs.x = node[0].as&lt;float&gt;();
      rhs.y = node[1].as&lt;float&gt;();
      rhs.z = node[2].as&lt;float&gt;();
      return true;
    }
  };
</code></pre>
    <p class="normal">After defining the <code class="inlineCode">encode()</code> and <code class="inlineCode">decode()</code> methods, we can exchange data between a YAML <code class="inlineCode">node</code> and a <code class="inlineCode">glm::vec3</code> by a normal assignment:</p>
    <pre class="programlisting code"><code class="hljs-code">glm::vec3 data;
node["rotation"] = data.isWorldRotation;
data.isWorldRotation = node["rotation"].as&lt;glm::vec3&gt;();
</code></pre>
    <p class="normal">The same two methods are implemented for the <code class="inlineCode">InstanceSettings</code> struct, helping us to read the settings of the instance directly back into a variable of the type <code class="inlineCode">InstanceSettings</code>. To avoid polluting the header for our parser class, a new header called <code class="inlineCode">YamlParserTypes.h</code> has been created in the <code class="inlineCode">tools</code> folder. The <code class="inlineCode">YamlParserTypes.h</code> header will be included in the header of the <code class="inlineCode">YamlParser</code> class to make the new conversions available.</p>
    <p class="normal">Once the configuration file is successfully parsed, all settings, model paths, and instance settings are extracted. But before we can load the models and create new instances, we must first clear the current list of models and instances.</p>
    <h2 id="_idParaDest-159" class="heading-2">Cleaning up and recreating the scene from the saved values</h2>
    <p class="normal">Removing all models and<a id="_idIndexMarker240"/> instances is a simple and straightforward process. In the renderer, we must do the following steps to have a fresh environment:</p>
    <ol>
      <li class="numberedList" value="1">Set <code class="inlineCode">miSelectedInstance</code> and <code class="inlineCode">miSelectedModel</code> containing the currently selected instance and model to zero. The variables from this step and from <em class="italic">steps 2 and 3</em> were introduced in the <em class="italic">Dynamic model and instance management</em> section of <a href="Chapter_1.xhtml"><em class="italic">Chapter 1</em></a>. Then, at index zero, the new null model and null instance will be created.</li>
      <li class="numberedList">Erase the <code class="inlineCode">miAssimpInstances</code> vector and clear the <code class="inlineCode">miAssimpInstancesPerModel</code> map. Now, all models are unused.</li>
      <li class="numberedList">Erase the <code class="inlineCode">miModelList</code> vector. Since all instances were already deleted, the shared pointers of the models will be no longer referenced, and the models will be deleted.</li>
      <li class="numberedList">Add a new null model and a null instance. Both the null model and the null instance must be the first elements of the model list and the instances vector and map.</li>
      <li class="numberedList">Clear the undo and redo stacks. In the stacks, we used only weak pointers, so this step can be done at any time.</li>
      <li class="numberedList">Update the triangle count. After all models and instances were removed, the triangle count should be zero.</li>
    </ol>
    <p class="normal">The entire procedure of cleaning up all models and instances has been added to the new <code class="inlineCode">removeAllModelsAndInstances()</code> method of the renderer class, simplifying the usage whenever we need a clean and fresh environment.</p>
    <p class="normal">Now, we can load the model files from disk, but without creating the default instance. After all models are loaded, we search the model from the <code class="inlineCode">InstanceSettings</code> in the model list, create a new instance, and apply the settings from the configuration file.</p>
    <p class="normal">Next, we should enumerate the instances as the instance index number is not stored in the <code class="inlineCode">InstanceSettings</code>. But the instance should remain at the same index they had at save time, due to the linear reading of the <code class="inlineCode">miAssimpInstances</code> vector when the YAML emitter is created and the same linear reading of the nodes when parsing the YAML file.</p>
    <p class="normal">Finally, we restore the camera settings, selected model, and instance plus the status of the selection highlight from the parser.</p>
    <p class="normal">At this point, the configuration should be fully loaded, and the application should contain the same models, instances, and settings as at the time of the save operation.</p>
    <p class="normal">One question remains for the load process: What should we do if parsing the configuration file fails only partially? Maybe a model file was renamed or deleted, or the file was truncated or corrupted and the settings of the last instance are incomplete.</p>
    <h2 id="_idParaDest-160" class="heading-2">Strict or relaxed configuration file loading</h2>
    <p class="normal">One option to overcome parsing errors is<a id="_idIndexMarker241"/> to discard the entire configuration prior to deleting all current content of the application. This strict loading type is easy to implement; any kind of parsing error invalidates the configuration file at parsing time. We ignore the loading request and present just an error message to the user.</p>
    <p class="normal">The other option is relaxed parsing. We try our best to load the valid models and fill in the missing configuration parts with default values but also tell the user that parts of the configuration file cannot be loaded.</p>
    <p class="normal">In both cases, the error message should give detailed hints at which point the parsing failed. Therefore, the exception handling could be extended to know exactly what went wrong, and where. For relaxed handling, as much additional information about affected models, instances, or settings as possible should be presented to the user.</p>
    <p class="normal">It is up to the creator <a id="_idIndexMarker242"/>of an application to decide which strategy fits best. Usually, an attempt to recover as much data as possible should be made. Losing only a small part of the created work is better than losing all data.</p>
    <h2 id="_idParaDest-161" class="heading-2">Common errors leading to corrupted files</h2>
    <p class="normal">A couple of factors<a id="_idIndexMarker243"/> can render your saved configuration file corrupt. Some common causes are listed here:</p>
    <ul>
      <li class="bulletList">Disk or partition is filled up to 100% while writing the file: Even with the large amount of storage we have today, this may happen, and you have only parts of your data saved.</li>
      <li class="bulletList">Permission problems: Sometimes, you might have permission to create files but not to write file content. So, your files seem to be saved, but the file has a length of zero bytes.</li>
      <li class="bulletList">Connection errors when saving to remote places: Your connection may be interrupted while writing a larger file, resulting in a partially written file.</li>
      <li class="bulletList">Conversion errors, for instance, by sending files per email: A mail program or a mail server may convert the file in an incorrect manner, leading to a partially corrupt file with some replaced characters.</li>
      <li class="bulletList">Incompatible locale setting: The machine where the file was saved could have used the comma as a decimal separator while your computer uses a point as the decimal separator. The numbers in the file will be misinterpreted or even set to zero if parsing fails. This problem is tricky to find and gets overlooked easily.</li>
      <li class="bulletList">Coding errors, like wrong version handling, wrong conversions, or incomplete error/exception handling: You might save not all data, convert the data by accident to a wrong format, or miss parsing some of the data in the file. You should test the code reading and writing files for as many possible data types and object combinations as possible to find such errors.</li>
      <li class="bulletList">You should be aware that your save files could get corrupted on your machine or on the way from or to you. So, save your work often, use a versioning system like Git to store different versions of the files, and back up all your configuration files on a regular basis.</li>
    </ul>
    <p class="normal">Now that we have the code to save and load the state of the application, we can provide a predefined default configuration at <a id="_idIndexMarker244"/>application startup.</p>
    <h1 id="_idParaDest-162" class="heading-1">Loading a default configuration file at startup</h1>
    <p class="normal">To help a user explore a new application, next to an extensive tutorial, a simple example of the content created with the application can be loaded at the first start, or maybe at any start of the application. Tinkering around with<a id="_idIndexMarker245"/> the available options helps us understand how the application works, and what kind of content manipulations are possible.</p>
    <p class="normal">Loading a default configuration at startup can be achieved in different ways. A configuration file could be added at compile time (<em class="italic">baked</em> into the application), or one or more example files could be placed in a reachable folder, and the example file loaded at startup. Often, a separate configuration setting for the application is available to disable the automated loading of an example file.</p>
    <p class="normal">As an example, we will load the configuration file <code class="inlineCode">config/conf.acfg</code> from the load and save dialogs at application startup. Thanks to the already implemented YAML parser and file-loading code, the changes to the renderer class can be done with only a couple of lines.</p>
    <p class="normal">First, we define the default configuration file as a new <code class="inlineCode">private</code> member variable <code class="inlineCode">mDefaultConfigFileName</code> of the renderer class:</p>
    <pre class="programlisting code"><code class="hljs-code">    const std::string mDefaultConfigFileName =
      "config/conf.acfg";
</code></pre>
    <p class="normal">Hard-coding file paths or file names should be avoided in general, but for the first configuration file, we end up in a chicken/egg problem. If we want to store the name of the default configuration in another configuration file, instead of hard-coding the file name in the code, we will need another hard-<a id="_idIndexMarker246"/>coded file name. Such a bootstrapping problem can only be solved by hard-coding the first value.</p>
    <p class="normal">Then, in the <code class="inlineCode">init()</code> method of the renderer, we try to load the default configuration file:</p>
    <pre class="programlisting code"><code class="hljs-code">  if (!loadConfigFile(mDefaultConfigFileName)) {
    addNullModelAndInstance();
  }
</code></pre>
    <p class="normal">If the file cannot be found or fails to load, we only create the null model and the null instance. Since all other values are set as defaults at the first start, we end up with the same application as if we would have no default configuration at all.</p>
    <p class="normal">Implementing load and save functionality to an application requires a bit of research for the right type of save file, and some more work to actually implement the features into the existing code. All changes and new features should be reflected in the save file of the application, thus requiring more work to keep the load and<a id="_idIndexMarker247"/> save code up to date as application features change. By adding a versioning schema to the configuration file, we are even able to load configurations from different development stages of the application.</p>
    <h1 id="_idParaDest-163" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we added the ability to save the current configuration of the application to a file and load the same configuration back into the application. First, we evaluated the advantages and disadvantages of binary and textual save files and checked three common text file types to find a fitting format for our save files. Next, we explored the chosen YAML file format and implemented the save and load functionalities. Finally, we added a default file to load at application startup to help the user with the first steps of the application handling.</p>
    <p class="normal">In the next chapter, will take care of custom cameras in the application. Currently, we use only the <em class="italic">internal</em> camera to fly around in the virtual world. By adding custom camera types, more visualization options for the virtual world are possible. We will add a third-person-style camera, following one of the instances similar to an action game, and a stationary camera that follows one instance. Additionally, a simple camera manager will be added, and the configuration of the cameras will be also saved in the configuration file.</p>
    <h1 id="_idParaDest-164" class="heading-1">Practical sessions</h1>
    <p class="normal">There are some additions you could make to the code:</p>
    <ul>
      <li class="bulletList">Add a menu entry to create a new, empty scene.</li>
    </ul>
    <p class="normal-one">Right now, we can only load and save a configuration file. Removing all models and instances must still be done by hand. Add a menu entry plus code to remove all models and instances at once, giving the user a simple way to start from nothing.</p>
    <ul>
      <li class="bulletList">Add a flag and confirmation dialogs if a setting is changed.</li>
    </ul>
    <p class="normal-one">If the settings of one model are altered, set a <code class="inlineCode">dirty</code> flag to remember that the user of the application changed the loaded model instance or a saved state. Then, if the user wants to load another configuration file, start over with an empty configuration or exit the application and show a confirmation dialog to make sure a chance is given to save the current settings.</p>
    <ul>
      <li class="bulletList">Add a <code class="inlineCode">dirty</code> marker to the title.</li>
    </ul>
    <p class="normal-one">Several other applications are presenting some kind of notice to the user, stating that changes have been made since the last save. The title of the application window gets adjusted to show whether we are in edit or view mode, so adding a star (*) to the window title, or some words like “Not saved” should be easy.</p>
    <h1 id="_idParaDest-165" class="heading-1">Additional resource</h1>
    <p class="normal">Here is the GitHub repository for <code class="inlineCode">yaml-cpp</code>: <a href="https://github.com/jbeder/yaml-cpp">https://github.com/jbeder/yaml-cpp</a>.</p>
    <h1 id="_idParaDest-166" class="heading-1">Join our community on Discord</h1>
    <p class="normal">Join our community’s Discord space for discussions with the author and other readers: <a href="https://packt.link/cppgameanimation">https://packt.link/cppgameanimation</a></p>
    <p class="normal"><img src="img/QR_code_Discord.png" alt="A qr code with black squares  AI-generated content may be incorrect." width="150" height="150"/></p>
  </div>
</div></div></body></html>