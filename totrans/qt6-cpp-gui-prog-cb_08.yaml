- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Threading Basics –Asynchronous Programming
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程基础 – 异步编程
- en: Most modern software runs its processes in parallel and offloads tasks to different
    threads to take advantage of modern CPU multicore architecture. This way, software
    can be more efficient by running multiple processes simultaneously without affecting
    performance. In this chapter, we will learn how to make use of **threads** to
    boost our Qt 6 application’s performance and efficiency.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代软件都并行运行其进程，并将任务卸载到不同的线程，以利用现代 CPU 多核架构。这样，软件可以通过同时运行多个进程来提高效率，而不会影响性能。在本章中，我们将学习如何利用
    **线程** 来提高我们的 Qt 6 应用程序的性能和效率。
- en: 'This chapter will cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下食谱：
- en: Using threads
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用线程
- en: '`QObject` and `QThread`'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QObject` 和 `QThread`'
- en: Data protection and sharing data between threads
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据保护和线程间数据共享
- en: Working with `QRunnable` processes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 `QRunnable` 进程一起工作
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The technical requirements for this chapter include Qt 6.6.1 and Qt Creator
    12.0.2\. All the code used in this chapter can be downloaded from the following
    GitHub repository: [https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter08](https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter08).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的技术要求包括 Qt 6.6.1 和 Qt Creator 12.0.2。本章使用的所有代码都可以从以下 GitHub 仓库下载：[https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter08](https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter08)。
- en: Using threads
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用线程
- en: Qt 6 provides multiple methods to create and use threads. You can choose between
    high-level methods and low-level ones. High-level methods are much easier to get
    started but are limited in what you can do with them. Conversely, low-level methods
    are more flexible but not beginner-friendly. In this recipe, we will learn how
    to use one of the high-level methods to easily create a multithreading Qt 6 application.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 6 提供了多种创建和使用线程的方法。你可以选择高级方法或低级方法。高级方法更容易上手，但功能有限。相反，低级方法更灵活，但不适合初学者。在本食谱中，我们将学习如何使用一种高级方法轻松创建多线程
    Qt 6 应用程序。
- en: How to do it…
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Let’s learn how to create multithreading applications by following these steps:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤学习如何创建多线程应用程序：
- en: 'Create a `main.cpp`. Then, add the following headers at the top of the file:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `main.cpp` 文件。然后，在文件顶部添加以下头文件：
- en: '[PRE0]'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, create a function called `printText()` before the `main()` function:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在 `main()` 函数之前创建一个名为 `printText()` 的函数：
- en: '[PRE1]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After that, add the following code to the `main()` function:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在 `main()` 函数之前添加以下代码：
- en: '[PRE2]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you build and run the program now, you should see that `A` gets printed
    first before `B`. Note that their thread IDs are all the same. This is because
    we are running the `printText()` functions in the main thread:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在构建并运行程序，你应该会看到 `A` 在 `B` 之前被打印出来。请注意，它们的线程 ID 都是一样的。这是因为我们正在主线程中运行 `printText()`
    函数：
- en: '[PRE3]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To separate them into different threads, let’s use a high-level class provided
    by Qt 6 called `QFuture`. Comment out the two `printText()` functions in `main()`
    and use the following code instead:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了将它们分离到不同的线程中，让我们使用 Qt 6 提供的一个高级类 `QFuture`。在 `main()` 中注释掉两个 `printText()`
    函数，并使用以下代码代替：
- en: '[PRE4]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you build and run the program again, you should see something like the following
    being printed out on the debug window, which means that the three `printText()`
    functions now run in parallel:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你再次构建并运行程序，你应该在调试窗口中看到以下类似内容被打印出来，这意味着三个 `printText()` 函数现在并行运行：
- en: '[PRE5]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can also use the `QFutureWatcher` class to notify a `QObject` class through
    a signals and slots mechanism. The `QFutureWatcher` class allows us to monitor
    `QFuture` using signals and slots:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以使用 `QFutureWatcher` 类通过信号和槽机制通知一个 `QObject` 类。`QFutureWatcher` 类允许我们使用信号和槽来监控
    `QFuture`：
- en: '[PRE6]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After that, open up `mainwindow.h` and declare the slot function:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，打开 `mainwindow.h` 并声明槽函数：
- en: '[PRE7]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `mySlot()` function looks like this in `mainwindow.cpp`:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`mySlot()` 函数在 `mainwindow.cpp` 中的样子如下：'
- en: '[PRE8]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you build and run the program again, this time, you will see results like
    this:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你再次构建并运行程序，这次，你会看到以下结果：
- en: '[PRE9]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works…
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: By default, there is a main thread (also known as a GUI thread) in any Qt 6
    application. Other threads that you create are called the **worker threads**.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，任何 Qt 6 应用程序中都有一个主线程（也称为 GUI 线程）。你创建的其他线程被称为 **工作线程**。
- en: GUI-related classes, such as `QWidget` and `QPixmap`, can only exist in the
    main thread, so you must be extra careful when dealing with these classes.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 与GUI相关的类，如`QWidget`和`QPixmap`，只能存在于主线程中，因此处理这些类时必须格外小心。
- en: '`QFuture` is a high-level class that deals with **asynchronous computation**.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`QFuture`是一个处理**异步计算**的高级类。'
- en: We use the `QFutureWatcher` class to let `QFuture` interact with signals and
    slots. You can even use this to display the progress of the operation on a progress
    bar.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`QFutureWatcher`类让`QFuture`与信号和槽交互。你甚至可以使用它来在进度条上显示操作的进度。
- en: QObject and QThread
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QObject和QThread
- en: Next, we want to explore some other methods so that we can use threads in Qt
    6 applications. Qt 6 provides a class called `QThread`, which gives you more control
    over how you create and execute a thread. A `QThread` object begins to execute
    its event loops in a thread by calling the `run()` function. In this example,
    we will learn how to make the `QObject` class work together asynchronously through
    the `Qthread` class.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要探索一些其他方法，以便我们可以在Qt 6应用程序中使用线程。Qt 6提供了一个名为`QThread`的类，它允许你更灵活地创建和执行线程。一个`QThread`对象通过调用`run()`函数开始在一个线程中执行其事件循环。在这个例子中，我们将学习如何通过`Qthread`类使`QObject`类异步工作。
- en: How to do it…
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let’s get started by performing the following steps:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤开始：
- en: 'Create a new Qt widget application project. Then, go to **File** | **New File
    or Project...** and create a **C++** **Class** file:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Qt小部件应用程序项目。然后，转到**文件** | **新建文件或项目...**并创建一个**C++** **类**文件：
- en: '![Figure 8.1 – Create a new C++ class](img/B20976_08_001.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1 – 创建一个新的C++类](img/B20976_08_001.jpg)'
- en: Figure 8.1 – Create a new C++ class
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 创建一个新的C++类
- en: 'After that, name the new class `MyWorker` and make it inherit from the `QObject`
    class. Don’t forget to include the `QObject` class by default as well:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，将新类命名为`MyWorker`并使其继承自`QObject`类。别忘了默认包含`QObject`类：
- en: '![Figure 8.2 – Define the MyWorker C++ class](img/B20976_08_002.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2 – 定义MyWorker C++类](img/B20976_08_002.jpg)'
- en: Figure 8.2 – Define the MyWorker C++ class
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 定义MyWorker C++类
- en: 'Once you have created the `MyWorker` class, open up `myworker.h` and add the
    following headers at the top:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦创建了`MyWorker`类，打开`myworker.h`并在顶部添加以下头文件：
- en: '[PRE10]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After that, add the following signals and slot functions to the file as well:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，将以下信号和槽函数也添加到文件中：
- en: '[PRE11]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, open up `myworker.cpp` and implement the `process()` function:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开`myworker.cpp`并实现`process()`函数：
- en: '[PRE12]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After that, open up `mainwindow.h` and add the following headers at the top:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，打开`mainwindow.h`并在顶部添加以下头文件：
- en: '[PRE13]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, declare a slot function, as shown in the following code:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，声明一个槽函数，如下面的代码所示：
- en: '[PRE14]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Once you’re done, open up `mainwindow.cpp` and implement the `handResults()`
    function:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，打开`mainwindow.cpp`并实现`handResults()`函数：
- en: '[PRE15]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Lastly, we will add the following code to the class constructor of the `MainWindow`
    class:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将以下代码添加到`MainWindow`类的构造函数中：
- en: '[PRE16]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Build and run the program now. You should see that the main window pops out
    and does nothing for a couple of seconds before a line of message is printed on
    the debug window:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在构建并运行程序。你应该会看到主窗口弹出，几秒钟内没有任何动作，然后会在调试窗口中打印出一行消息：
- en: '[PRE17]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The result was calculated in a separate thread, which is why the main window
    can display smoothly and can even be moved around by a mouse during the calculation.
    To see the difference when running the calculation on the main thread, let’s comment
    out some of the code and call the `process()` function directly:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果是在一个单独的线程中计算的，这就是为什么主窗口可以在计算过程中平滑显示，甚至可以通过鼠标在计算过程中移动。为了看到在主线程上运行计算时的差异，让我们注释掉一些代码并直接调用`process()`函数：
- en: '[PRE18]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Build and run the project now. This time, the main window will only appear on
    the screen once the calculation has been done. This is because the calculation
    was blocking the main thread (or GUI thread) and prevented the main window from
    being displayed.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在构建并运行项目。这次，主窗口只有在计算完成后才会出现在屏幕上。这是因为计算阻塞了主线程（或GUI线程），阻止了主窗口的显示。
- en: How it works…
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`QThread` is an alternative method to run a process asynchronously, besides
    using the `QFuture` class. It gives us more control compared with `QFuture`, which
    we will demonstrate in the following recipe.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`QThread`是除了使用`QFuture`类之外运行异步过程的一个替代方法。与`QFuture`相比，它提供了更多的控制，我们将在下面的菜谱中演示。'
- en: Do note that the `QObject` class that gets moved to the working thread cannot
    have any parent, as Qt is designed in such a way that an entire object tree must
    exist in the same thread. Therefore, all of the children of a `QObject` class
    will also be moved to the working thread when you call `moveToThread()`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，被移动到工作线程的`QObject`类不能有任何父类，因为Qt的设计方式是整个对象树必须存在于同一个线程中。因此，当你调用`moveToThread()`时，`QObject`类的所有子类也将被移动到工作线程。
- en: Use a signals and slots mechanism if you want your working thread to communicate
    with the main thread. We use the started signal that’s provided by the `QThread`
    class to inform our working object to start the calculation, since the working
    thread has already been created.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想让你的工作线程与主线程通信，请使用信号和槽机制。我们使用`QThread`类提供的`started`信号来通知我们的工作对象开始计算，因为工作线程已经创建。
- en: Then, when the calculation has been completed, we emit the `showResult` and
    `doneProcess` signals to inform the thread to quit, while passing the final result
    to the main thread for it to be printed.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当计算完成后，我们发出`showResult`和`doneProcess`信号来通知线程退出，同时将最终结果传递给主线程以便打印。
- en: Lastly, we also use the signals and slots mechanism to safely delete both the
    working thread and working object when everything is done.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们也使用信号和槽机制在一切完成后安全地删除工作线程和工作对象。
- en: Data protection and sharing data between threads
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据保护和线程间数据共享
- en: Even though multithreading makes processes run asynchronously, there will be
    times when threads must stop and wait for other threads. This usually happens
    when both threads modify the same variable simultaneously. It is common to force
    threads to wait for one another to protect shared resources, such as data. Qt
    6 also provides both low-level methods and high-level mechanisms to synchronize
    threads.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管多线程使进程异步运行，但有时线程必须停止并等待其他线程。这通常发生在两个线程同时修改同一个变量时。通常，强制线程相互等待以保护共享资源，如数据。Qt
    6还提供了低级方法和高级机制来同步线程。
- en: How to do it…
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We will continue to use the code from the previous example project, since we
    have already established a working program with multithreading:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用前一个示例项目中的代码，因为我们已经建立了一个具有多线程的运行程序：
- en: 'Open up `myworker.h` and add the following header:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`myworker.h`并添加以下头文件：
- en: '[PRE19]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, we will add two new variables and make some changes to the class constructor:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将添加两个新变量并对类构造函数进行一些修改：
- en: '[PRE20]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'After that, open up `myworker.cpp` and change the class constructor to look
    like the following code. We no longer require the parent input, since the object
    will not have a parent:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，打开`myworker.cpp`并将类构造函数更改为以下代码。由于对象将没有父类，我们不再需要父类输入：
- en: '[PRE21]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We will also change the `process()` function to look like this:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将更改`process()`函数，使其看起来像这样：
- en: '[PRE22]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once you’re done, open up `mainwindow.cpp` and make some changes to the code:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，打开`mainwindow.cpp`并对代码进行一些修改：
- en: '[PRE23]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After that, we will set the `myInputNumber` variable of the worker object to
    `myNumber`. Note that we are referencing its pointer instead of the value:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们将工作对象的`myInputNumber`变量设置为`myNumber`。请注意，我们引用的是其指针而不是值：
- en: '[PRE24]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Repeat the previous step twice more to set `workerObject2`, `workerThread2`,
    `workerObject3`, and `workerThread3`:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复执行前面的步骤两次，以设置`workerObject2`、`workerThread2`、`workerObject3`和`workerThread3`：
- en: '[PRE25]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, we will start running those threads by calling `start()`:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将通过调用`start()`来启动这些线程：
- en: '[PRE26]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If you build and run the program now, you should see a consistent result, no
    matter how many times you run it:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在构建并运行程序，你应该看到一致的结果，无论你运行多少次：
- en: '[PRE27]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We get results every time we run the program because the mutex lock ensures
    that only one of the threads can modify the data while other threads await their
    completion. To see the difference without mutex locking, let’s comment out the
    code:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每次运行程序时我们都会得到结果，因为互斥锁确保只有一条线程可以修改数据，而其他线程则等待其完成。为了看到没有互斥锁的差异，让我们注释掉代码：
- en: '[PRE28]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Build and run the program again. This time, you will get a very different result
    when you run the program. For example, I’ve obtained the following results when
    running it on three occasions:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次构建和运行程序。这次，当你运行程序时，你会得到一个非常不同的结果。例如，我在运行它三次时获得了以下结果：
- en: '[PRE29]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This happens because the `myNumber` data is manipulated by all the threads simultaneously
    in a random order, due to the nature of parallel computation. By locking the mutex,
    we make sure that the data can only be modified by a single thread and, hence,
    eliminate this issue.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是因为 `myNumber` 数据由于并行计算的性质，所有线程同时以随机顺序进行操作。通过锁定互斥锁，我们确保数据只能由单个线程修改，从而消除这个问题。
- en: How it works…
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Qt 6 provides two classes, namely `QMutex` and `QReadWriteLock`, for data protection
    when multiple threads access and modify the same data. We only used `QMutex` in
    the previous example, but both classes are very similar in nature. The only difference
    is that `QReadWriteLock` allows data to be read simultaneously by other threads
    while the data is written. Unlike `QMutex`, it separates the read and write states,
    but only one can occur at a time (either lock for read or lock for write), and
    not both. For complex functions and statements, use the high-level `QMutexLocker`
    class instead of `QMutex` for simplifying the code and easier debugging.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 6 提供了两个类，即 `QMutex` 和 `QReadWriteLock`，用于在多个线程访问和修改相同数据时的数据保护。我们之前只使用了 `QMutex`，但这两个类在本质上非常相似。唯一的区别是
    `QReadWriteLock` 允许其他线程在数据写入时同时读取数据。与 `QMutex` 不同，它将读取和写入状态分开，但一次只能发生一个（要么锁定以读取，要么锁定以写入），不能同时发生。对于复杂函数和语句，请使用高级的
    `QMutexLocker` 类来简化代码并更容易调试。
- en: The downside of this method is that all of the other threads will stand idle
    while the data is modified by a single thread. It is best not to share data with
    multiple threads unless there is no other way to do so, as it will halt the other
    threads and defeat the object of parallel computation.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是，当单个线程修改数据时，其他所有线程都将处于空闲状态。除非没有其他方法，否则最好不要在多个线程之间共享数据，因为这会阻止其他线程并违背并行计算的目的。
- en: Working with QRunnable processes
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 QRunnable 进程一起工作
- en: In this recipe, we will learn how to use another type of high-level method to
    easily create a multithreading Qt 6 application. We will use the `QRunnable` and
    `QThreadPool` classes in this recipe.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何使用另一种高级方法轻松创建多线程 Qt 6 应用程序。我们将在这个菜谱中使用 `QRunnable` 和 `QThreadPool`
    类。
- en: How to do it…
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: Create a new Qt widget application project and then a new C++ class called `MyProcess`,
    which inherits the `QRunnable` class.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Qt 小部件应用程序项目，然后创建一个新的名为 `MyProcess` 的 C++ 类，该类继承自 `QRunnable` 类。
- en: 'Next, open up `myprocess.h` and add the following headers:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开 `myprocess.h` 并添加以下头文件：
- en: '[PRE30]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, declare the `run()` function, as follows:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，声明 `run()` 函数，如下所示：
- en: '[PRE31]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After that, open up `myprocess.cpp` and define the `run()` function:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，打开 `myprocess.cpp` 并定义 `run()` 函数：
- en: '[PRE32]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Once you’re done, add the following headers to `mainwindow.h`:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，将以下头文件添加到 `mainwindow.h` 中：
- en: '[PRE33]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'After that, we will implement the class constructor by adding the following
    code:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们将通过添加以下代码来实现类构造函数：
- en: '[PRE34]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now, build and run the project. You should see that the processes are successfully
    run in different threads where the active thread count is four.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，构建并运行项目。你应该会看到进程在不同的线程中成功运行，其中活动线程数为四个。
- en: 'The `QThreadPool` class automatically deactivates threads when its last process
    has been executed. Let’s try and prove that by pausing the program for three seconds
    and printing out the active thread count again:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QThreadPool` 类在其最后一个进程执行完毕后会自动停用线程。让我们通过暂停程序三秒并再次打印活动线程数来尝试并证明这一点：'
- en: '[PRE35]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Build and run the program again. This time, you should see that the active thread
    count is four, and then, after three seconds, the active thread count becomes
    zero. This is because all of the processes have been executed.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次构建并运行程序。这次，你应该会看到活动线程数为四个，然后，在经过三秒后，活动线程数变为零。这是因为所有进程都已执行完毕。
- en: How it works…
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `QRunnable` class works hand in hand with the `QThreadPool` class, which
    manages a collection of threads. The `QThreadPool` class automatically manages
    and recycles individual `QThreads` objects to avoid creating and destroying threads
    too frequently, which helps in reducing computing costs.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`QRunnable` 类与 `QThreadPool` 类紧密协作，后者管理线程集合。`QThreadPool` 类自动管理和回收单个 `QThreads`
    对象，以避免频繁创建和销毁线程，这有助于降低计算成本。'
- en: To use `QThreadPool`, you must sub-class the `QRunnable` object and implement
    the virtual function called `run()`. By default, `QThreadPool` will automatically
    delete the `QRunnable` object when the last thread exits the `run` function. You
    can change this behavior by calling `setAutoDelete()` to change the `autoDelete`
    variable to `false`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `QThreadPool`，您必须对 `QRunnable` 对象进行子类化并实现名为 `run()` 的虚拟函数。默认情况下，`QThreadPool`
    将在最后一个线程退出 `run` 函数时自动删除 `QRunnable` 对象。您可以通过调用 `setAutoDelete()` 来改变 `autoDelete`
    变量设置为 `false` 来改变这种行为。
- en: By default, threads that are unused for more than 30 seconds will expire. You
    can change this duration by calling `setExpiryTimeout()` before the thread runs.
    Otherwise, there will be no effect on the timeout setting.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，超过 30 秒未被使用的线程将过期。您可以在线程运行之前调用 `setExpiryTimeout()` 来改变这个持续时间。否则，超时设置将不会产生任何效果。
- en: You can also set the maximum number of threads that can be used by calling `setMaxThreadCount()`.
    To get the total number of currently active threads, simply call `activeThreadCount()`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过调用 `setMaxThreadCount()` 来设置可使用的最大线程数。要获取当前活动线程的总数，只需调用 `activeThreadCount()`。
