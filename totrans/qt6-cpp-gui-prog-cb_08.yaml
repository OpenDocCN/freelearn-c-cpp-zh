- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Threading Basics –Asynchronous Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most modern software runs its processes in parallel and offloads tasks to different
    threads to take advantage of modern CPU multicore architecture. This way, software
    can be more efficient by running multiple processes simultaneously without affecting
    performance. In this chapter, we will learn how to make use of **threads** to
    boost our Qt 6 application’s performance and efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Using threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QObject` and `QThread`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data protection and sharing data between threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with `QRunnable` processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The technical requirements for this chapter include Qt 6.6.1 and Qt Creator
    12.0.2\. All the code used in this chapter can be downloaded from the following
    GitHub repository: [https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter08](https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter08).'
  prefs: []
  type: TYPE_NORMAL
- en: Using threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt 6 provides multiple methods to create and use threads. You can choose between
    high-level methods and low-level ones. High-level methods are much easier to get
    started but are limited in what you can do with them. Conversely, low-level methods
    are more flexible but not beginner-friendly. In this recipe, we will learn how
    to use one of the high-level methods to easily create a multithreading Qt 6 application.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s learn how to create multithreading applications by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `main.cpp`. Then, add the following headers at the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, create a function called `printText()` before the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, add the following code to the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you build and run the program now, you should see that `A` gets printed
    first before `B`. Note that their thread IDs are all the same. This is because
    we are running the `printText()` functions in the main thread:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To separate them into different threads, let’s use a high-level class provided
    by Qt 6 called `QFuture`. Comment out the two `printText()` functions in `main()`
    and use the following code instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you build and run the program again, you should see something like the following
    being printed out on the debug window, which means that the three `printText()`
    functions now run in parallel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can also use the `QFutureWatcher` class to notify a `QObject` class through
    a signals and slots mechanism. The `QFutureWatcher` class allows us to monitor
    `QFuture` using signals and slots:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, open up `mainwindow.h` and declare the slot function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `mySlot()` function looks like this in `mainwindow.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you build and run the program again, this time, you will see results like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, there is a main thread (also known as a GUI thread) in any Qt 6
    application. Other threads that you create are called the **worker threads**.
  prefs: []
  type: TYPE_NORMAL
- en: GUI-related classes, such as `QWidget` and `QPixmap`, can only exist in the
    main thread, so you must be extra careful when dealing with these classes.
  prefs: []
  type: TYPE_NORMAL
- en: '`QFuture` is a high-level class that deals with **asynchronous computation**.'
  prefs: []
  type: TYPE_NORMAL
- en: We use the `QFutureWatcher` class to let `QFuture` interact with signals and
    slots. You can even use this to display the progress of the operation on a progress
    bar.
  prefs: []
  type: TYPE_NORMAL
- en: QObject and QThread
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we want to explore some other methods so that we can use threads in Qt
    6 applications. Qt 6 provides a class called `QThread`, which gives you more control
    over how you create and execute a thread. A `QThread` object begins to execute
    its event loops in a thread by calling the `run()` function. In this example,
    we will learn how to make the `QObject` class work together asynchronously through
    the `Qthread` class.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s get started by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Qt widget application project. Then, go to **File** | **New File
    or Project...** and create a **C++** **Class** file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Create a new C++ class](img/B20976_08_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – Create a new C++ class
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, name the new class `MyWorker` and make it inherit from the `QObject`
    class. Don’t forget to include the `QObject` class by default as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Define the MyWorker C++ class](img/B20976_08_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – Define the MyWorker C++ class
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have created the `MyWorker` class, open up `myworker.h` and add the
    following headers at the top:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, add the following signals and slot functions to the file as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, open up `myworker.cpp` and implement the `process()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, open up `mainwindow.h` and add the following headers at the top:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, declare a slot function, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once you’re done, open up `mainwindow.cpp` and implement the `handResults()`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, we will add the following code to the class constructor of the `MainWindow`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build and run the program now. You should see that the main window pops out
    and does nothing for a couple of seconds before a line of message is printed on
    the debug window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The result was calculated in a separate thread, which is why the main window
    can display smoothly and can even be moved around by a mouse during the calculation.
    To see the difference when running the calculation on the main thread, let’s comment
    out some of the code and call the `process()` function directly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build and run the project now. This time, the main window will only appear on
    the screen once the calculation has been done. This is because the calculation
    was blocking the main thread (or GUI thread) and prevented the main window from
    being displayed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`QThread` is an alternative method to run a process asynchronously, besides
    using the `QFuture` class. It gives us more control compared with `QFuture`, which
    we will demonstrate in the following recipe.'
  prefs: []
  type: TYPE_NORMAL
- en: Do note that the `QObject` class that gets moved to the working thread cannot
    have any parent, as Qt is designed in such a way that an entire object tree must
    exist in the same thread. Therefore, all of the children of a `QObject` class
    will also be moved to the working thread when you call `moveToThread()`.
  prefs: []
  type: TYPE_NORMAL
- en: Use a signals and slots mechanism if you want your working thread to communicate
    with the main thread. We use the started signal that’s provided by the `QThread`
    class to inform our working object to start the calculation, since the working
    thread has already been created.
  prefs: []
  type: TYPE_NORMAL
- en: Then, when the calculation has been completed, we emit the `showResult` and
    `doneProcess` signals to inform the thread to quit, while passing the final result
    to the main thread for it to be printed.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we also use the signals and slots mechanism to safely delete both the
    working thread and working object when everything is done.
  prefs: []
  type: TYPE_NORMAL
- en: Data protection and sharing data between threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though multithreading makes processes run asynchronously, there will be
    times when threads must stop and wait for other threads. This usually happens
    when both threads modify the same variable simultaneously. It is common to force
    threads to wait for one another to protect shared resources, such as data. Qt
    6 also provides both low-level methods and high-level mechanisms to synchronize
    threads.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will continue to use the code from the previous example project, since we
    have already established a working program with multithreading:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up `myworker.h` and add the following header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we will add two new variables and make some changes to the class constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, open up `myworker.cpp` and change the class constructor to look
    like the following code. We no longer require the parent input, since the object
    will not have a parent:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will also change the `process()` function to look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once you’re done, open up `mainwindow.cpp` and make some changes to the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, we will set the `myInputNumber` variable of the worker object to
    `myNumber`. Note that we are referencing its pointer instead of the value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Repeat the previous step twice more to set `workerObject2`, `workerThread2`,
    `workerObject3`, and `workerThread3`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we will start running those threads by calling `start()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you build and run the program now, you should see a consistent result, no
    matter how many times you run it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We get results every time we run the program because the mutex lock ensures
    that only one of the threads can modify the data while other threads await their
    completion. To see the difference without mutex locking, let’s comment out the
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build and run the program again. This time, you will get a very different result
    when you run the program. For example, I’ve obtained the following results when
    running it on three occasions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This happens because the `myNumber` data is manipulated by all the threads simultaneously
    in a random order, due to the nature of parallel computation. By locking the mutex,
    we make sure that the data can only be modified by a single thread and, hence,
    eliminate this issue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Qt 6 provides two classes, namely `QMutex` and `QReadWriteLock`, for data protection
    when multiple threads access and modify the same data. We only used `QMutex` in
    the previous example, but both classes are very similar in nature. The only difference
    is that `QReadWriteLock` allows data to be read simultaneously by other threads
    while the data is written. Unlike `QMutex`, it separates the read and write states,
    but only one can occur at a time (either lock for read or lock for write), and
    not both. For complex functions and statements, use the high-level `QMutexLocker`
    class instead of `QMutex` for simplifying the code and easier debugging.
  prefs: []
  type: TYPE_NORMAL
- en: The downside of this method is that all of the other threads will stand idle
    while the data is modified by a single thread. It is best not to share data with
    multiple threads unless there is no other way to do so, as it will halt the other
    threads and defeat the object of parallel computation.
  prefs: []
  type: TYPE_NORMAL
- en: Working with QRunnable processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use another type of high-level method to
    easily create a multithreading Qt 6 application. We will use the `QRunnable` and
    `QThreadPool` classes in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new Qt widget application project and then a new C++ class called `MyProcess`,
    which inherits the `QRunnable` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, open up `myprocess.h` and add the following headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, declare the `run()` function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, open up `myprocess.cpp` and define the `run()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once you’re done, add the following headers to `mainwindow.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, we will implement the class constructor by adding the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, build and run the project. You should see that the processes are successfully
    run in different threads where the active thread count is four.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `QThreadPool` class automatically deactivates threads when its last process
    has been executed. Let’s try and prove that by pausing the program for three seconds
    and printing out the active thread count again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build and run the program again. This time, you should see that the active thread
    count is four, and then, after three seconds, the active thread count becomes
    zero. This is because all of the processes have been executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `QRunnable` class works hand in hand with the `QThreadPool` class, which
    manages a collection of threads. The `QThreadPool` class automatically manages
    and recycles individual `QThreads` objects to avoid creating and destroying threads
    too frequently, which helps in reducing computing costs.
  prefs: []
  type: TYPE_NORMAL
- en: To use `QThreadPool`, you must sub-class the `QRunnable` object and implement
    the virtual function called `run()`. By default, `QThreadPool` will automatically
    delete the `QRunnable` object when the last thread exits the `run` function. You
    can change this behavior by calling `setAutoDelete()` to change the `autoDelete`
    variable to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: By default, threads that are unused for more than 30 seconds will expire. You
    can change this duration by calling `setExpiryTimeout()` before the thread runs.
    Otherwise, there will be no effect on the timeout setting.
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the maximum number of threads that can be used by calling `setMaxThreadCount()`.
    To get the total number of currently active threads, simply call `activeThreadCount()`.
  prefs: []
  type: TYPE_NORMAL
