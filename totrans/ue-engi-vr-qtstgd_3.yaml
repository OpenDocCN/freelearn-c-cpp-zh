- en: Exploring Riveting Gameplay in Virtual Reality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our custom game files in place, it's time to start making some decisions
    about gameplay. In *Server 17*, the player takes on the role of a futuristic hacker
    trying to crack open a corporate server and plunder its secrets for personal gain.
    So, how might we present this in VR as an experience? Before we think about that,
    let's do a bit of research and discovery. The best way to learn which mechanics
    will challenge and entertain our players is to first look at the unique elements
    that VR brings to a game. After that, we can take a look at which titles are being
    played right now and why. Armed with that information, we can then make some decisions
    about how best to design our own gameplay for *Server 17*. We have a lot to discover,
    so let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What does VR bring to video games?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Popular gameplay mechanics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing the gameplay for *Server 17*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What does VR bring to video games?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: VR is the new frontier in games and entertainment. It's able to put the player
    in the shoes of their favorite heroes, or in a front-row seat for some of their 
    favorite experiences. In most experiences, player movement is translated into
    near one-to-one movement inside the game—something that's usually impossible in
    traditional video games. VR also has the power to immerse our player in an alternate
    world and make them truly feel as if they're there. It's these special abilities
    that mark VR as the future of gaming.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to understand that the input and controls in VR can go beyond
    the locomotion methods that we discussed in the last chapter. Each controller
    for the Vive or Oculus brings at least six different buttons that can be mapped
    to different functions within a game. Each of these can then be combined with
    a location or specific player movement to create almost infinite variety. Let's
    take a look at some of the gunplay in Epic Game's *Robo Recall*.
  prefs: []
  type: TYPE_NORMAL
- en: In this game, you destroy robots with a variety of weapons that are holstered
    on the player. The character has a pair of pistols holstered at their hips and
    a second pair of weapons holstered at their shoulders. This seems simple enough,
    right? Where the designers utilized the advantages of VR was in the hand placement
    needed to use your weapons. The player has to reach down to their waist to grab
    a pistol or reach behind their shoulder to grab a weapon. This simple addition
    of hand location to the input to equip a gun adds to the immersion and visceral
    quality of the gameplay.
  prefs: []
  type: TYPE_NORMAL
- en: Popular gameplay mechanics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the last few years, many developers have embraced VR technology as their
    chosen medium. This has lead to a variety of VR games spanning many different
    genres and ideas. Each game has approached the input and immersion that VR brings
    in their own way. Some, such as Bethesda and ID Software, chose to use the technology
    to bring their blockbuster games *Fallout 4* and *Doom* into the VR era (to mixed
    reviews). Others have found more success building their game specifically for
    the medium, such as Beat Games'' *Beat Saber,* and Schell Games'' *I Expect You
    To Die*. For our research into what might work for *Server 17*, we''re going to
    look at seven different types of gameplay:'
  prefs: []
  type: TYPE_NORMAL
- en: Shooter experiences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Action/adventure experiences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vehicle experiences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Physics-based experiences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Puzzle experiences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rhythm experiences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Educational experiences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shooter experiences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last year, more than a dozen of the top 25 VR titles sold on Valve's
    Steam download service fell into the shooter category. A shooter is defined as
    any game that includes gunplay as a major part of experience. Many variations
    on the shooter experience in VR take advantage of unique mechanics. Still near
    the top of the charts is *Robo Recall*.
  prefs: []
  type: TYPE_NORMAL
- en: Epic Games was able to combine the frantic action of a wave shooter with the
    immersive environment and mechanics that VR can bring. Much of the gameplay centers
    around using your hands. *Robo Recall* uses interesting mechanics when it comes
    to arming yourself. Players grab their chosen weapons from holsters located at
    their waist and shoulders. Each one is filled with a variety of customized weapons,
    all great for scrapping the game's robot enemies. The grab mechanism is also applied
    to a specific brand of melee combat from *Robo Recall*. Player's can grab many
    robot enemies by a handle that's conveniently located in the center of their chest.
    Once grabbed, enemies can be ripped apart by grabbing limbs, thrown into other
    enemies, or held up as shields to protect yourself.
  prefs: []
  type: TYPE_NORMAL
- en: '*Superhot VR* by Superhot Team is another game that takes gunplay to a whole
    new level. The game combines physics and shooting gameplay with their exclusive
    time mechanics to create a rare experience. Just about every object in its minimalist
    environments is a weapon in *Superhot VR*. These items can be thrown at an enemy
    to liberate their weapon, causing it to fly into the air so that it can be snatched
    up by the player. Combined with the fact that time only moves forward when you
    do, each level becomes a combat puzzle. Which enemy do you confront first? What
    weapon or object is available within arm''s reach? Each decision and movement
    is important for discovering the level''s solution, and progressing.'
  prefs: []
  type: TYPE_NORMAL
- en: The most important elements of a popular VR shooter are active gunplay combined
    with another unique mechanic. This can be grabbing, physics gameplay, or a particular
    locomotion mechanism. Other great examples in this category include *Sairento
    VR*, for its locomotion mechanic and combination of gun and swordplay, as well
    as *Damaged Core*, a game that has the player utilizing the ability to teleport
    from enemy to enemy, possessing them and using their weapons.
  prefs: []
  type: TYPE_NORMAL
- en: Action/adventure experiences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Action/adventure experiences combine combat experiences with exploration and
    story-based gameplay. These games feature impressive environments and visuals
    that take advantage of the fact that VR places the player directly into the game
    world. Yet, with such a large world in which to explore, designers must use artificial
    locomotion methods to allow the player to explore such a large space. For many
    players, the ability to experience the story firsthand outweighs any discomfort
    caused by using a thumbstick or snap turning for locomotion. In this category,
    the biggest contenders both come to us from *Bethesda Softworks : Fallout 4 VR
    and Skyrim VR*.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Fallout 4 VR* is a direct port of the popular 2015 title, redesigned to work
    with VR. Players travel the wasteland building settlements, crafting equipment,
    and experiencing the story from a first-person perspective. Combat is an in-your-face
    affair. The majority of the early enemies favor close combat, meaning there isn''t
    much of a chance for the player to use a firearm before their opponent is right
    on top of them. Luckily, melee combat is as simple as equipping the right weapon,
    or none at all, and swinging away. Ranged combat also feels good, though not nearly
    as satisfying as in a VR shooter. Still, *Fallout 4* ticks all of the right boxes.
    It''s an action/adventure experience that gives players a massive, awe-inspiring
    environment. In it, they may craft, build, and interact, as well as take part
    in a deep story with a variety of interesting characters.'
  prefs: []
  type: TYPE_NORMAL
- en: Vehicle experiences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vehicle experiences solve the locomotion problem by placing the player at the
    helm of a ship, mech, or other method of travel and destruction. The brain processes
    it much the same as when we go for a ride in the car. We don't question that we're
    moving because we're sitting down and controlling the vehicle. This gives the
    designers the opportunity to give players a vehicle-piloting experience. There
    are many great examples in this space. However, I want to give you one that represents
    some of the best gameplay in this category, Frontier Developments' *Elite Dangerous*.
  prefs: []
  type: TYPE_NORMAL
- en: The most current entry in the *Elite* saga is a space adventure, combat, and
    trading sim that puts the player in the role of an elite commander. Players earn
    money, rank, and influence with the major factions of a one-to-one, open-world
    version of our Milky Way galaxy. The game can be played without VR hardware, but
    it truly shines when the player dons the headgear. When played in VR, the player
    is able to see the inside of the ship and see their own customized player character
    sitting at the helm.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating the systems and menus of the ship becomes easier as menus open with
    a glance. Combat and piloting become effortless, since the player can look through
    the canopy of their ship to help track their location. All of these VR-specific
    features add depth to an amazing experience as the players fight, trade, and explore
    their way to fortune and fame within the game world.
  prefs: []
  type: TYPE_NORMAL
- en: The addition of an internal ship environment, customizable player character,
    and eye tracking-based menus are only possible thanks to the first-person perspective
    that VR provides. Being able to see themselves in the interior of their vehicle
    connects the player to their surroundings. This makes them feel as if they're
    a living part of the game. Whether it's racing in a tricked-out high-performance
    street car or fighting aliens in the depths of space, the player's vehicle-piloting
    experience is enhanced by the VR perspective.
  prefs: []
  type: TYPE_NORMAL
- en: Physics-based experiences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Not as well known in the gaming world, physics-based games take advantage of
    the player's ability to aim and throw objects using a standing or room-space experience.
    This goes beyond simply picking up and throwing everyday objects, such as the
    gameplay found in *Superhot VR*. It takes advantage of a game engine's ability
    to simulate real-world physics to create gameplay. In this genre, the games tend
    to take the form of phyiscs-based fighting games and physics puzzle games. Let's
    take a look at the physics-based combat game, *Gorn*.
  prefs: []
  type: TYPE_NORMAL
- en: '*Gorn*, from Devolver Digital, casts the player as a gladiator fighting for
    the amusement of several large-headed patrons. The game features cartoon-style
    art and violence, centered around comical physics-based brawling. Each round starts
    with the player entering the arena, sometimes with a selection of weapons and
    sometimes unarmed. The rules are simple: knock out the other guys before they
    do the same to you. The fun comes when the player picks a weapon to use. As the
    game translates their movement into the game world, it adds a bit of cartoon physics.
    Movements become exaggerated. Weapons feel as if they''re made of foam or rubber,
    making combat a strange affair. Together, these features come together to create
    a brawling experience that feels visceral and absurd at the same time. *Gorn*
    is currently available for HTC Vive, Oculus Rift, and PlayStation VR.'
  prefs: []
  type: TYPE_NORMAL
- en: In contrast to the fighting gameplay of *Gorn* is the physics-based puzzler, *Bounce*.
    *Bounce*, developed by Steel Wool Studios, has the player helping a ball-shaped
    robot navigate the corridors of an intergalactic spaceship. Players are given
    an array of physics gadgets designed to propel their robot friend from one side
    of the level to the exit portal. To get there, the robot must navigate around
    laser walls, gravity wells, and other sci-fi obstructions. Beating the game unlocks
    style mode. This allows the player to play each of the game's 50 levels again
    and rewards them for the most creative solutions.
  prefs: []
  type: TYPE_NORMAL
- en: In both games, we can again see the unique movement mechanic and first-person
    perspective often seen in VR, used to great effect. *Gorn* uses player arm movement
    with cartoon physics to create a gaming experience that feels fun and intense.
    In contrast, *Bounce* uses the first-person perspective to allow the player see
    what placing a particular physics gadget will do when the ball hits it. This gives
    the player the ability to see firsthand the effects of their actions and allows
    the player to feel more in control of the experience.
  prefs: []
  type: TYPE_NORMAL
- en: Puzzle experiences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With their use of object manipulation as a major mechanism and often fantasy
    environments, puzzle experiences lend themselves very well to the VR treatment.
    Since the time of *Myst* and it's sequels, players have shown time and again that
    they love solving the mysteries of ancient ruins, dark dungeons, and castles in
    the sky. However, until now, players haven't been able to truly reach eye level
    with some of these puzzles and environments, which can make solving problems where
    you have to aim a laser or shoot a bow much harder. Take as an example the laser
    puzzles from the game *The* *Talos Principle VR* by Croteam, a port of the popular
    puzzle game from 2014\. Players are required in several puzzles to use a device
    to bend a laser beam to hit a particular target. Some players have reported that
    this task is considerably easier in VR due to their ability to bend down and see
    where the laser will travel from eye level.
  prefs: []
  type: TYPE_NORMAL
- en: Another great example of VR principles applied to puzzle gameplay can be found
    in the standout title *I Expect You to Die* by Schell Games. In this game, the
    player takes on the role of a telekinetic super spy, charged with completing various
    missions to defeat the evil Zoraxis Organization. Each of the five locations in
    the game feels a bit like an escape room. The player is given the task of escaping
    the area and must use the tools they find to complete the mission. For instance,
    the first mission of the game has the player tasked with driving the evil Dr.
    Zor's weaponized car out of the back of a cargo plane while the plane is slowly
    filling with poison gas and using only the tools found in the car or dismantled
     ones from the car's many attempts to kill you. The game gets around the locomotion
    issue by giving the player the choice of making it a sitting or room-scale experience
    and by giving the player telekinesis so they never have to move. Together, the
    game uses the uniqueness of VR and creativity to great effect to create an experience
    that has players singing its praises.
  prefs: []
  type: TYPE_NORMAL
- en: Rhythm experiences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In many ways, VR mechanics are breathing new life into the game genres that
    we love. This is especially true of rhythm games whose basic gameplay mechanics
    of *press this button at this time* seem old by today's standards. However, the
    application of VR-specific gameplay mechanics such as one-to-one arm movement
    have revitalized the genre and given rise to several unique rhythm experiences.
    At the top of that list is certainly *Beat Saber*, developed and published by
    Beat Games.
  prefs: []
  type: TYPE_NORMAL
- en: '*Beat Saber* combines rhythm gameplay with VR saber combat to create a unique
    title that has players swinging virtual red and blue energy sabers to hit the
    corresponding color blocks in time with the music. Players must strike the blocks
    with the correct color saber at the correct angle while ducking and dodging wall
    obstacles  and mines that shouldn''t be hit. All of this action is set to the
    tempo of the song. With a variety of tracks and difficulty settings, *Beat Saber*
    sets a new standard for rhythm experiences in the age of VR. In this game, we
    see two types of gameplay collide: VR combat (swinging at stuff and dodging) and
    rhythm mechanics. The combination creates an almost dancing experience that makes
    it easy to enjoy. Though be prepared for a workout even if you''re playing this
    as a seated experience, as some of the songs get very energetic at times.'
  prefs: []
  type: TYPE_NORMAL
- en: Educational experiences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since its inception, educators have been interested in VR as a way to instruct
    and train the next generation in a way that''s engaging and allows the learner
    to see the material from a new perspective. New generations of students are looking
    for education institutions to embrace technology while providing a unique and
    experiential style of learning. To meet this demand, education software developers,
    college development teams, and even some game developers have begun creating VR
    experiences that allow students to experience history close up or to learn to
    use high-end equipment without fear of hurting themselves. Besides immersion and
    unique mechanics, VR can allow those who wish to learn something that takes expensive
    equipment or rare resources the opportunity to do so. Here are some of the titles
    currently available:'
  prefs: []
  type: TYPE_NORMAL
- en: '*The Body VR: Journey Inside a Cell*: This game uses the immersion of VR to
    allow the player to experience traveling in the bloodstream of a human being and
    enter a blood cell to see the inner workings at the cellular level.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Sharecare VR*: This application allows the player to explore the anatomy of
    the human body, simulate disease, and show how treatment interacts with the body.
    Players can also call up specific organs and enable the display of tags to show
    specific structures. This allows players to learn and study the human anatomy
    in ways that weren''t possible previously.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Apollo 11 VR*: *Apollo 11* combines a passive viewing experience with occasional
    mini games to allow the player to live the Apollo 11 mission firsthand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I also want to mention *Tribe XR* here. Though the developers have chosen to
    teach users how to DJ using high-end equipment, the goal is to create a creative
    education platform that can be used to teach many skills and take advantage of
    what they refer to as exponential learning. As part of the plan for their platform,
    they're allowing vetted users, in this case other DJs, to teach those new to the
    platform both in recorded and live lessons. This mechanism has amazing potential
    for revolutionizing how schools and businesses teach and train their students.
  prefs: []
  type: TYPE_NORMAL
- en: VR has the ability to bring the user into the game worlds that we create and
    turn their movements into real in-game action. These two unique features have
    the potential to revolutionize how players enjoy video games and create new avenues
    for designers to express themselves creatively. However, we need to make sure
    that these new techniques for creating interaction within game worlds to become
    a crutch that props up poor design. Like the graphics advances of the early 20's,
    we mustn't let VR become a novelty and an excuse for bad games.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the gameplay for Server 17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've discovered some of the great VR games that our potential users
    are playing and dug deep into how VR helps to make them unique, let's look at
    how VR can really make the experience that lets *Server 17* shine. This is where
    we move from the Discovery and Empathy phases of our design process into the Ideate
    phase. Ideate is where the magic happens and where ideas are brainstormed and
    transformed into something more. For our user (first-time VR user, sci-fi fan,
    and nostalgic), we need to take into account that their status as first time users
    will mean that a basic locomotion scheme is important. We also want to make sure
    that the gameplay is intuitive and easy to learn. Current VR controllers are capable
    of several button-based functions, but we'll want to keep our control scheme simple
    to lower the learning curve and make our game accessible. Lastly, we want to make
    our environment simple yet really embrace the cyberpunk and future aesthetic.
  prefs: []
  type: TYPE_NORMAL
- en: 'With these things in mind, let''s design. To keep locomotion easy and minimize
    VR sickness, we can use teleportation while keeping the gameplay area small. This
    will have the added benefit of playing into our cyberpunk background and the fact
    that the game level is meant to take place in a form of VR itself. We''ll have
    the player press buttons and manipulate objects using some avatar hands. This
    allows us to make the gameplay as natural as possible, as well as making it easy
    to grasp quickly (pun intended). Gameplay will be centered around hacking a corporate
    server, reimagined as a techy-looking puzzle box in the center of the room that
    the player will have to solve by grasping parts to push and slide. We also want
    to provide the player with some special tools to speed the process up. These tools
    will be provided at different tool stations spread around the virtual room that
    represents the inside of the player''s computer. Finally, to represent the danger
    of being discovered, the player will have to complete the puzzle box within a
    certain time frame. Here is a rough idea of the level:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f1fa23a9-23b1-4cf5-8d42-23d01a5018ba.png)'
  prefs: []
  type: TYPE_IMG
- en: Level map with design markings
  prefs: []
  type: TYPE_NORMAL
- en: Now, your instinct might be next to decide on the art style or to start making
    static meshes and shaders. Resist that urge! Despite the fact that the design
    sounds fun on paper, we don't know whether all of the features will work as intended
    or whether they're even as fun as we think they'll be. To test our assumptions,
    we need to move to the prototype stage of our design process and build a quick
    functional mock up and have our user test it to gain feedback. That way, we don't
    waste time or resources on game elements we might not use.
  prefs: []
  type: TYPE_NORMAL
- en: We'll start by implementing the hands.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the hand functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want the player's experience with their in-game representation to be as smooth
    and as seamless as possible. To that end, the hand solution we implement needs
    to be able to do a few different things. First, the player needs to be able to
    see the hands. Second, the player needs to be able to know which objects can be
    interacted with and which ones might simply be there as scenery. Third, the player
    needs to be able to grab, pick up, and potentially throw objects that we want
    them to interact with. Fourth, we need the player to be able to press buttons
    inside the level to utilize the tools found at the different tool stations and
    to solve the puzzle cube.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step in following our design is to add the hand models to our `Server17PlayerPawn`
    to give our player a representation of themselves in the game. To do this, we''ll
    add the standard hands provided for us by Epic Games to our pawn:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/03daea4b-be39-4c19-a297-23ace88d7d62.png)'
  prefs: []
  type: TYPE_IMG
- en: Hands added in the Class Blueprint screen
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how we add the hands:'
  prefs: []
  type: TYPE_NORMAL
- en: To have the hand meshes read the position of the player's motion controls, we'll
    start by adding a skeletal mesh component that's attached to the MotionController_L
    component in our pawn. Click on the MotionController_L component, and then click
    the Add Component button at the top of the Components panel. Select the Skeletal
    Mesh option and name the new component `SkeletalMesh_L`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Details panel, find the Skeletal Mesh drop-down menu and select the MannequinHand_Right.
    This will add the hand to the end of the player's motion controller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since the hand is meant to be a right hand, we need to change a few settings
    to make it work correctly as a left hand. Find the Transform portion of the Details
    panel and change the X field of the Location property to -10\. This will align
    the mesh more with where the player's physical hand is on the controller and will
    feel more natural.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move down to the Rotation property and change the X value to 90 degrees. This
    rotates the hand to a more natural position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move down one more property to the Scale property, and change the Z value to
    -1\. This will flip the orientation of the hand to truly represent a left hand.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the left hand complete, repeat steps one through four to create the right
    hand and name it `MotionController_R`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we test now, we can see that the player pawn now has hands! Wave them in
    the air like you just don''t care. However, they don''t really do much other than
    look plastic, yet well manicured. Let''s start to give them some functionality
    with the edition of some collision shapes so we can record when they overlap with
    an object. Let''s start with the left hand:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the MotionController_L component and navigate to the Add Component menu.
    Find the Sphere Collision component under the Collision section of the drop-down
    menu and select it. Name it `Sphere_L`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Details panel, change the sphere radius to 10\. This will define the
    area in which objects are considered overlapping with the player's hands.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat steps one and two to create a collision sphere for the right hand and
    name it `Sphere_R`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our hands are now set up to record overlap events so that we can manipulate
    objects in our game world. At this point, there are several actions we want these
    objects to perform. We want them to be able to detect when they're being looked
    at and when they're not. We also need them to know when we've performed some kind
    of action on them, an activated and a deactivated state. For this, we'll use something
    called a **Blueprint Interface**. A Blueprint Interface can be defined as a collection
    of one or more functions that can be assigned to objects that need to share data
    and functionality. It allows us to create a number of functions that each object
    that uses the interface can then define in a unique manner. In our game, we'll
    create an interface that contains all the functions that control how the hands
    manipulate gameplay objects.
  prefs: []
  type: TYPE_NORMAL
- en: '*Tribe XR* makes extensive use of Blueprint Interfaces to facilitate the creation
    and communication of its different user interfaces, since many of them share common
    elements. From the interface elements used to display music track information
    to the Options screen, they all have in common that they''re 2D interfaces projected
    on to 3D planes. As we''ll see from the following screenshot, creating a Blueprint
    Interface of common functions ahead of time can facilitate the creation of these
    menus:![](img/38d621c0-e383-461c-9d07-6511d4c23db1.png)'
  prefs: []
  type: TYPE_NORMAL
- en: The Blueprint Interface option in the right-click menu
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a new Blueprint Interface:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure we're in our `Sever17\Blueprints` folder. Right-click in the Content
    Broswer and navigate to the Create Advanced Asset section of the menu. Find the
    Blueprints option and select Blueprint Interface. Name it `ObjectInteractionInterface`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click `ObjectInteractionInterface` to open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We'll need to create several functions here. Over on the right-hand side of
    the screen in the Functions section of the My Blueprints panel, click the plus
    (+) button to create a new function. Name it `TraceHitObject`. This will fire
    whenever our object is hit by a line trace from either the motion controller or
    the HMD, signifying that we're looking at it or interacting with it in some way.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With our new function selected, look at the Details panel. This panel allows
    us to add input and output to our function to handle our data. Let's add an input
    named `Hit` and use the type Hit Result. Passing the hit data to the object allows
    us to access important information later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To finish the function, we need to add a Boolean output named Return. Unreal
    Engine reads a function without an output as an Event, which isn't what we want.
    To avoid this, we use a dummy Boolean variable to complete the function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next function we need to create will be able to read when a trace leaves
    the object, giving us additional options for functionality. Head back to the Functions
    section of the `MyBlueprint` panel and create another function. Name it `TraceLeaveObject`.
    Create an input variable called `Hit` of the Hit Result type. Finish the function
    by creating a Boolean output and name it `Return`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that the object can tell whether it's being looked at, let's take that functionality
    to the next level. It would be useful to have the object know what part of it's
    being looked at. We can do this by detecting the trace at the component level.
    Create a new function and name it `TraceHitComponent`. Just like our other functions,
    we need to create an input called `Hit` of the Hit Result type and an output called
    `Return` of the Boolean type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To be able to read what component is being hit, we need to also add another
    input. Create a second input named `Component` and make it be of the type Primitive
    Component. This way, we can pass in what specific component is being hit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's finish this functionality. Create another function and name it `TraceLeaveComponent`.
    This should have the same inputs and outputs as the `TraceHitComponent`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Just a few more functions and we'll be finished! Let's create a function that
    can be called every frame to track the potential movement of an object. Create
    another function and name it `TraceMove`. This should have an input named `Hit`
    of the Hit Result type, and an output named `Return` of the Boolean type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`TraceMove` needs one more change to make it function correctly. Since this
    is a function designed to be called every frame, performance is definitely a concern.
    To optimize this function, we''ll check two options. First, under the `Hit` input,
    click the little arrow next to the name of the variable and click the checkbox
    to make the function Pass-by-Reference. Passing by reference allows the `Hit`
    variable to be passed on by name without passing the value. Because we''re selecting
    to pass the variable in this manner, we need to select the Const option in the
    Graph section of the Details panel. If you can''t see the option, click the down
    arrow at the bottom of the section to expose the checkbox.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, let's create one more bit of functionality. We want to be able to activate
    and deactivate some kind of effect on an object. This covers a variety of potential
    scenarios, such as being able to turn a flashlight you picked up on and off. To
    create this effect, we need two more functions. First, create a new function and
    name it `TraceActivateDown`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`TraceActivateDown` will signify when a button has been pressed to activate
    the object. It needs two inputs. The first is named `Hit` and has a Hit Result type
    (so that a lot of great information is packed into a hit result). The second is
    named `Instigator` and is of the Pawn type. This way, we can pass in the Pawn
    that activated the object. Finish by creating an output named `Return` of the
    Boolean type.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `TraceActivateDown` represents a button press, then we need our final function
    for our interface to represent the release of that button. Create one final function
    named `TraceActivateUp`. This should have the same inputs and outputs as `TraceActivateDown`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With everything completed, your interface should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/29a2c328-aeec-4a3b-ae12-3735ca8c44ce.png)'
  prefs: []
  type: TYPE_IMG
- en: The My Blueprint section of ObjectInteractionInterface
  prefs: []
  type: TYPE_NORMAL
- en: '`ObjectInteractionInterface` now encapsulates many of the functions we would
    want an object to be able to perform. However, many of them depend on being the
    target of a line trace to be able to operate. A **line trace** is a function that
    can be called that will draw a line from one point to another and report anything
    that''s hit by the line. Using that hit data, we can do all kinds of things! For
    instance, we can find the distance from the player to the object. We can act on
    the object to change color, emit sound, or other behaviors. We can even cause
    the object to delete itself if we wanted to. In shooter games, this is how direct-damage
    weapons, such as lasers, sniper rifles, or other weapons that don''t really have
    a projectile, work. Since our line trace will be checking where our player is
    looking and will likely be used to figure out where they can teleport, we''ll
    use a parabola, or curved line, rather than a straight line for our trace. To
    do this, we''ll create a custom component that can be added to our HMD or motion
    controller that projects the line trace:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5a5ca50d-8920-4c4f-9734-7d35dd30fc11.png)'
  prefs: []
  type: TYPE_IMG
- en: Created Interaction Component
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to create a custom Scene Component that can be added to our custom
    pawn:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Content Browser, right-click in the `Server17\Blueprints` folder and
    click the Blueprint Class option. In the bottom section of the Pick Parent Class
    window, search for Scene Component using the search box. Click it and then click
    the Select button. Name this new component `InteractionComponent`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This new component is going to handle our line trace and any data that it collects.
    It'll then distribute the hit data through our interface to all of our interaction
    functions. Start by creating a new function by clicking the +Function button that's
    part of the My Blueprints panel. Name this new function `ParabolicLineTrace`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We calculate the parabolic curve by taking the direction the interaction component
    is facing and calculate the projected curve based on a fixed point in time and
    a speed value. The formula is *z = (t * v[z]) - (0.5 * g * t²)*, where *z* is
    the projected end of the arc in the *z* axis, *v* is the velocity, *g* is gravity,
    and *t* is time. The distance the arc will cover is estimated by *y = t * v[y]*
    where *y* is the end of the arc in the *y* axis. To have our function calculate
    our arc, it'll need three inputs. The first is named `Steps` and has a type of
    Integer. The second is named `TimeStep`, which is a Float value. Last, we have
    `Speed` of the Float type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you don't understand the math, don't worry! The arc it creates is perfect
    for estimating the final location of our future teleport. Once complete, Unreal
    Engine 4 will be able to visually represent our line trace to us, and it'll make
    sense.
  prefs: []
  type: TYPE_NORMAL
- en: Double-click on our new function to open it. `ParabolicLineTrace` needs six
    local variables to work. Find the Local Variables section at the bottom of the
    My Blueprints panel. Click the +Local Variable button and create a new variable
    named Init Loc of the type Vector. Next, create one named Prev Loc, also of the
    type Vector. These will store the initial locations for our curve calculation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create another local variable named `Velocity` of the type Vector. This is our
    speed value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we need two local variables to handle our time calculation. Create two new
    local variables named `InTimeStep` of the type Float and In Steps of the type
    Integer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is the last one! We need one more local variable to hold the hit data
    from the line trace. Create one final local variable named `TempHit` and make
    sure its type is set to Hit Result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/38982226-4f8d-42f4-8b7d-a6e3469824ad.png)'
  prefs: []
  type: TYPE_IMG
- en: Setting up the variables in the Parabolic Line Trace
  prefs: []
  type: TYPE_NORMAL
- en: With all of our variables finally set up, we can move on to creating our curve
    calculation.
  prefs: []
  type: TYPE_NORMAL
- en: The first step in our function is to store our location data. From your Local
    Variables section, drag in a copy of your `InitLoc` variable and choose Set. Do
    the same for your `PrevLoc` variable. Connect the execute output of the beginning
    of the function to the input on Init Loc. Connect the execute output on Init Loc
    to the input on Prev Loc.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we need to fill them with data. We need to start by knowing the location
    of the interaction component within the game world. Right-click in the blueprint
    window or use the Palette to grab a GetWorldLocation node. Connect the output
    of our new node into the Init Loc vector input, and then connect the vector output
    on Init Loc to the vector input on Prev Loc.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go back to the Local Variables section in My Blueprint and grab the In Steps
    and the `InTimeStep` variables, and choose Set for both of them. Connect the execute
    output of our Prev Loc node to the execute input on the In Steps node. Then, connect
    the execute output of In Steps to the input on In Time Step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To finish this section, we need to connect In Steps and In Time Step to their
    appropriate data input. Take the `Steps` input from our function and connect that
    to the integer input on In Steps. Finally, take the TimeStep input from the function
    and plug that into the float input on In Time Step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's one last bit of data to initialize before we calculate the curve. To
    get the velocity we'll use for the calculation, we'll need to determine the forward
    vector of our interaction component and multiply that by the `Speed` variable
    we take as an input into our function. Head back to the Local Variables portion
    of the screen and drag in a copy of the `Velocity` variable. Choose Set from the
    menu. Connect the execute output from our In Time Step node and plug it into our
    new Velocity node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Right-click in the blueprint and use the menu to find the Get Forward Vector
    node where the target is a Scene Component. Drag a line off the Return Value of
    the node and drop it to bring up the search menu and search for the `Vector *
    Float` node. The vector input will be the Return Value of the Get Forward Vector,
    and the float value will be the Speed input from the start of our function. The
    resulting value will become the input for the vector on the Set Velocity node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bf18caee-e945-4b91-aa93-299aae8065aa.png)'
  prefs: []
  type: TYPE_IMG
- en: Calculating a parabolic line trace in blueprints
  prefs: []
  type: TYPE_NORMAL
- en: With all of our variables straightened out, it's time for the fun part! Start
    the calculation by creating a ForLoopWithBreak node. Connect the execute output
    from our set Velocity to the execute input on ForLoopWithBreak. Drag in a copy
    of our local variable In Steps and plug that into the Last Index input on ForLoopWithBreak.
    Lastly, set the First Index integer to 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, create a Line Trace By Channel node. This node will do all of the heavy
    lifting and create the actual line trace. Plug the Loop Body output from the ForLoopWithBreak
    into the execute input on our new line trace. On the line trace node, change the
    Draw Debug Type to For One Frame. This will help us to visualize the parabolic
    arc. We can always turn it off later. Now grab a copy of the `PrevLoc` variable
    and plug that into the `Start` input on the line trace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bring on the math! Let's start by getting a copy of the `Velocity` local variable.
    Right-click on the output of the variable and choose the Split Struct Pin option.
    This displays all the values that make up our velocity vector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now create three copies of the `Float * Float` node. We're going to plug the
    *X*, *Y*, and *Z* values we just exposed on the Velocity node into the top input
    on each of the multiplication nodes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a copy of the `InTimeStep` local variable and an `Integer * Float` node.
    Plug the output of the variable into the float input on the multiplication node.
    The input for the integer section of the node comes from the `Index` output of
    the ForLoopWithBreak node. The output from this bit of math will be used by many
    nodes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take the output and plug it into the second float input on the multiplication
    nodes we created earlier in *step 17*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Don't forget, you can create reroute nodes to help clean your code! Right-click
    in the Blueprint as if you're creating a new node and find the Reroute node down
    toward the bottom of the menu.
  prefs: []
  type: TYPE_NORMAL
- en: It's time to compensate for gravity in our calculation. Create a `Float * Float`
    node and place it near the multiplication node created in *step 18*. On the newly
    created node, there's a button labeled + Add Pin. Let's click that twice to create
    two more input pins. Plug the output of the multiplication node from *step 18*
    into the first two input values of our new node (this represents time being squared
    in our equation). In the third input, change the value to 0.5\. In the final input,
    change the value to 980.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We've almost finished the math. Create a `Float - Float` node and plug the output
    of the multiplication node we use with the *Z* value from our `Velocity` variable
    into the first input and the output of the multiplication node we created in *step
    20* into the second input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, create one final math node, `Vector + Vector`, and right-click on the
    first `Vector` input pin. Select Split Struct Pin from the menu. The *X* value
    will be the output of the X Velocity multiplication node. The *Y* will be the
    output of the Y Velocity multiplication node. The *Z* value will be the output
    of the `Float - Float` we created in the last step. All of that will be added
    to the value of Init Loc. Create a copy of the variable and plug into the last
    input. The output of this node will become the End vector input on our line trace
    node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There''s one last section regarding this function. With our Line Trace by Channel
    node getting all of the information it needs, we need to set up the output values
    to store the information that we receive from the trace. We''ll do this by updating
    the location we''ve stored in our Prev Loc node and saving the hit result information
    into the TempHit node:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/80611f4e-3dcf-41e5-8d81-20a1bb0d0696.png)'
  prefs: []
  type: TYPE_IMG
- en: Completing the line trace
  prefs: []
  type: TYPE_NORMAL
- en: Let's wrap this thing up!
  prefs: []
  type: TYPE_NORMAL
- en: Create a SET node for our `PrevLoc` variable and connect the execute output
    from the line trace to its execute input. To update the vector input, drag a connection
    from the `Vector + Vector` node we created in *step 22* and plug it into the input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, create a Set node for the Temp Hit local variable and connect the execute
    output from our set Prev Loc node to the execute input. Connect the Out Hit output
    from the line trace into the input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To make sure that we aren't making any unnecessary hit calculations when no
    hit is found, let's add a Branch node. Add a Branch node and connect the execute
    output from the set TempHit node to it. Pass the Return Value output from the
    line trace into the Condition input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bring the execute output from this node all of the way back to the ForLoopWithBreak
    node and plug it into the Break input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finish this by connecting the complete execute output to the input on the function's
    Return node. Create a copy of TempHit and pass that into the function's output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that the Parabolic Line Trace function is finally complete (wow! There''s
    a lot going on there), it''s time to do something with the hit information that
    it collects. The Interact With Hit function will take the hit data from the line
    trace and pass it to our functions we created in the Object Interaction Interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d02b1a4b-07b4-47bb-ae1b-f2bf7f53a4e7.png)'
  prefs: []
  type: TYPE_IMG
- en: The variables for the InteractWithHit function
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating some variables:'
  prefs: []
  type: TYPE_NORMAL
- en: In the My Blueprints panel, find the Variables section and click the +Variable
    button. The first one we'll create will be named the `FocusComponent`. Set the
    Variable Type to Primitive Component. This will allow us to work with the individual
    components of an object as well as the object itself. Next, create a new variable
    named `FocusObject` and set the type to `Actor`. This will store the current object
    being hit. Finally, create a variable named `CurrentHit` and make its type `Hit
    Result` to store the hit information we collected from the line trace. Once we've
    created all three variables, click on each one and mark them Private in the Details
    panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It's time to create our second function. In the Functions section of My Blueprint,
    click the +Function button and name the new function `InteractWithHit`. The new
    function needs to have the ability to pass hit data into it. Click on the function,
    and in the Details panel create a new input named `Hit` of the type Hit Result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we need to set up three Local Variables inside our new function. Double-click
    the `InteractWithHit` function and head to the Local Variables section. Click
    the +Local Variable button and name the new variable `InHitComponent` of the type
    Primitive Component. Create a second local variable and name it In Hit of the
    type Hit Result. Lastly, create a third local variable and name it In Hit Actor,
    and make it of the type Actor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The initial setup is complete! With our variables created, we can now start
    initializing them with data. Starting at the function node, grab a copy of our
    In Hit local variable, and choose Set from the resulting menu. Connect the execute
    output from the function node to the input on the set In Hit node. We also want
    to pass the Hit data coming from outside of the function, so we''ll connect the
    Hit pin on the function node to the input on the set In Hit node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1eb18fcf-bc24-4fd3-82f4-c47b62d9f77f.png)'
  prefs: []
  type: TYPE_IMG
- en: Taking in the hit data and storing it in our variables
  prefs: []
  type: TYPE_NORMAL
- en: Next, we're going to break the hit down and pass the Hit Actor and the Hit Component
    data to our local variables so that we can work with them. Right-click in the
    blueprint and create a Break Hit Result node. Connect the variable output of the
    Set In Hit node to the input on our new node. This will break the hit information
    down into its parts. Next, bring in a copy of our In Hit Actor and the `InHitComponent`
    variables, and choose Set from the menu. With the two setters created, connect
    them in the order you see in the previous screenshot. Then, connect the Hit Actor
    output from Break Hit Result to the input on the set In Hit Actor node. Be sure
    to do the same for Hit Component and the `InHitComponent` node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Much of what we''re doing here is checking the data to see whether what we''re
    looking at can be interacted with and then passing that information through the
    interface we created earlier. We also need to be able to clear our variables if
    we''re no longer looking at something that has interaction. The first step in
    this process is to check to see whether the object we''re looking at (stored in
    Focus Object) is equal to the one we''re currently looking at, and for that we
    need a `Branch` node. Create a new `Branch` node and connect its execute input
    to the output from the Set `InHitComponent`. Now we need the two variables we
    want to compare. Get a copy of our Focus Object variable and our In Hit Actor
    local variable. Drag a connection off FocusObject and drop it to open the search
    menu. Look for the Equal (Object) node. This will compare two objects passed into
    it and return a Boolean showing whether they match. Connect the In Hit Actor to
    the second input and run the Boolean output into the input pin on the Branch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/84cdf136-01e1-4a65-affb-22e455f437d2.png)'
  prefs: []
  type: TYPE_IMG
- en: Passing the data through our interface
  prefs: []
  type: TYPE_NORMAL
- en: With our Branch ready, it's time to pass the information. From the `True` output,
    drag a connection off and drop it to search for our Trace Move (message) function
    that we created earlier in the Object Interaction Interface. Get a copy of the
    Focus Object variable and pass that into the Target pin on Trace Move. Now get
    a copy of the In Hit variable and connect that to the `Hit` input on Trace Move.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create another Branch node and connect its execution input to the output from
    Trace Move. This time, we'll be checking to see whether the Focus Object is equal
    to the `InHitComponent` and passing the new information along if it's not. To
    do that, we need to get the Focus Object and the `InHitComponent` and use our
    Equal (object) node to compare them. Take the Boolean output of that comparison
    and plug it into the input on the new Branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next node we need is another function from our interface. Right-click and
    search for Trace Leave Component (message). Create it and connect it to the False
    output on the last Branch. For input, we'll need to get a copy of the FocusObject
    and pass that into Target, In Hit, and pass that into Hit, and the FocusComponent
    and pass that into Component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we've called leave on the current focused component, we'll call the Trace
    Hit Component and have it pass the current component we're looking at. Create
    a copy of the Trace Hit Component (message) and connect it to the Trace Leave
    Component. Pass FocusObject into Target, In Hit into Hit, and `InHitComponent`
    into Component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is one final step in this branch of the process. We need to set the FocusComponent
    to our new the `InHitComponent`. Create a Set node for the FocusComponent, and
    get a copy of the `InHitComponent`. Connect the execute output from the Trace
    Hit Component to set the FocusComponent and pass the `InHitComponent` into the
    variable input pin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The branch we created was all about passing component data if the Focus Object
    and the In Hit object we''re looking at are the same, but what if they''re different?
    If they are, we need to clear the hit data and pass the new hit information through
    the interface. Go back to the Branch we created way back in *step 6*. Drag a connection
    from the `False` output and drop it. Search for the Trace Leave Object function
    and create the node. The Trace Leave Object has two input values. Into the Target
    input, we''ll pass the object we''re currently storing in the FocusObject. For
    the `Hit` input, get the current value of In Hit and connect it to the input pin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/af012a2b-f0d3-4b15-b019-ecc85c8ca521.png)'
  prefs: []
  type: TYPE_IMG
- en: Clearing the variables
  prefs: []
  type: TYPE_NORMAL
- en: Since we're leaving the object and turning our focus elsewhere, we'll need to
    clear the values stored in the FocusObject and the FocusComponent. Create a Set
    version of each of the variables. Connect the new set FocusObject node to the
    execute output from Trace Leave Object. Connect the new set FocusComponent node
    to the set FocusObject node. We're leaving both of their input values empty to
    clear their values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before we pass the new hit data forward, there''s still one more check we need
    to do. We only want to pass on the hit information if the object we''re looking
    at makes use of the Object Interaction Interface, since anything else wouldn''t
    matter to us. It''s our way as designers of creating objects that are interactable
    and others that are only meant to be scenery. To do this, we''ll use another Branch
    node. Connect the input for the new branch to the execution output from the set
    FocusComponent. To check to see whether the object we''re looking at uses the
    interface, we need to use the Does Implement Interface function. This function
    takes in an Actor and checks to see whether it has a specific interface attached
    to it, then returns a Boolean value—perfect for using with the Branch node. Create
    a copy of the Does Implement Interface. Pass in the value of the In Hit Actor
    as the Test Object and then click the drop-down menu under Interface. Use the
    search box at the top of the menu to find our Object Interaction Interface. With
    that set, plug the Return value from the node into the `Condition` input on our
    Branch. Our check is all set up:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d57977ce-159a-491d-b73e-f71be8d77dac.png)'
  prefs: []
  type: TYPE_IMG
- en: Passing in the new hit data
  prefs: []
  type: TYPE_NORMAL
- en: Now all that's left is to pass on is the new hit data. Right-click in the blueprint
    and search for Trace Hit Object (message). Connect it to the True output from
    the Branch and pass the In Hit Actor into the Target input and the In Hit into
    the Hit input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, create a copy of the Trace Hit Component (message) function. Pass the In
    Hit Actor into the Target input, In Hit into the Hit input, and the InHitComponent
    into the Component input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the final step for this branch, we'll need to update the values store in
    the FocusObject and the FocusComponent with the values from the In Hit Actor and
    the `InHitComponent`. Create a set FocusObject node and connect it to the execute
    output of the Trace Hit Component function. Pass the value of the In Hit Actor
    into the variable input. Lastly, connect the set FocusComponent execute input
    to the execute output from set the `FocusActor` and pass in the value from the `InHitComponent`.
    We've now completely finished using this function!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It''s taken quite a bit of programming to get here, hasn''t it? However, we
    have made a huge amount of progress in building our hand interactions. Our Interaction
    Component now has the ability to do a parabolic line trace to find objects and
    safe locations to teleport. It can now pass information through the Object Interaction
    Interface we created to allow our interactable objects to work with the hands,
    to create gameplay. It''s now time to bring that all together in the Event Graph
    to implement all of the functionality we''ve created. For this, we''ll use the
    Event Tick node:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dd5d5567-f1f3-4d9c-aa24-29b45998457e.png)'
  prefs: []
  type: TYPE_IMG
- en: Triggering the Parabolic Line Trace
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a couple of Custom Events:'
  prefs: []
  type: TYPE_NORMAL
- en: We'll need two custom events to represent the on and off states that we want
    the Interaction Component to have. The Custom Events will be called by elements
    outside this blueprint to trigger interaction using button presses on the player's
    motion controllers. Right-click near the Event Tick node and find the Add Event
    section of the menu. Open it and select the Add Custom Event option. Name this
    new event `Enable`. Repeat the process to create a second custom event and name
    it `Disable`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we'll use a Gate node to only allow the player to interact with objects
    when they've enabled the interaction component with a button. A Gate is a flow-control
    node that opens and shuts to allow data through only when the programmer allows
    it. Right-click in the blueprint and search for the Gate node. We'll connect the
    Event Tick output to the Enter input on the Gate. To control the flow of data,
    we'll connect the Execution output from our Enable custom event to the Open input
    and the execution output from the Disable custom event to the Close input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we'll add in our Parabolic Line Trace function. Grab a copy of it from the
    My Blueprints panel and drag it into the blueprint. Connect the execute output
    from the Gate to the execution input on the function. To make sure our parabola
    functions correctly, set the number of Steps to `10`, the Time Step to `0.1`,
    and the Speed to `500`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The output from our line trace needs to be stored so that we can pass it to
    the Interact With Hit function. Luckily, we already created a variable to hold
    it. Create a copy of our `CurrentHit` hit variable by dragging it in from the
    My Blueprint panel and select Set from the menu. Connect it to the execute output
    from the line trace function and pass the Hit output from the line trace into
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: End the sequence by bringing in the Interact With Hit function and connecting
    the execute output from the set CurrentHit node to it. Connect the variable output
    from the set CurrentHit as the Hit input on the function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There''s one final piece to this interaction puzzle. We need to add the interaction
    component to `Server17PlayerPawn` and map the functionality to buttons on the
    player''s motion controllers. Let''s start by adding two more custom events to
    the Interaction Component blueprint:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e743e973-8b7f-4860-9a67-4ca3d1d3bdd2.png)'
  prefs: []
  type: TYPE_IMG
- en: Activation section of the Interaction Blueprint
  prefs: []
  type: TYPE_NORMAL
- en: 'Every button has two states: an up and a down. We''ll define these states by
    creating two Custom Events:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click in a new section of the blueprint, find the Add Event section of
    the menu, and open it and choose Add Custom Event. Name the first one `ActivateUp`.
    Create a second custom event and name it `ActivateDown`. Both events need to have
    a single input. Click on each of the custom events and click the + button in the
    Inputs section of the Details panel. Name the input `Instigator` and make its
    type Pawn.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a connection off ActivateUp and search for Trace Activate Up (message).
    We created this function as part of our interface. Connect its execution to the
    ActivateUp event and connect the Instigator output from the event to the Instigator
    input on the function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Trace Activate Up still needs two more input values to work correctly. Get a
    copy of the `FocusObject` variable and connect that to the Target input. Lastly,
    get a copy of the `CurrentHit` variable and connect that to the `Hit` input on
    the function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We're going to repeat this process for `ActivateDown`—only, this time, we'll
    connect the Trace Activate Down (message) function from our interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It''s time to finish the setup in the player pawn:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7886b243-86b5-4373-94a3-dbfad3fbc1ba.png)'
  prefs: []
  type: TYPE_IMG
- en: Components setup in the player pawn
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by adding a copy of the Interaction Component to each of the hands:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Content Browser, find the `Server17PlayerPawn` and double-click to open
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Viewport tab, head over to the Components panel and click the Add Component
    button. Use the search box to find our Interaction Component that we created.
    It'll be under the heading Custom. Click on it and name the new component `InteractionComponent_L`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag and drop the new component on to the MotionController_L component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat *step 2* and *step 3* to create a second interaction component that's
    a child of the right motion controller. Name this one `InteractionComponent_R`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we can tie our new interaction components to buttons on the controllers.
    This will give the player the power to finally interact with the world! Click
    on the Event Graph tab. In an empty section of the graph, right-click and search
    for the MotionController (L) Trigger event. Repeat the process to create a node
    for the MotionController (R) Trigger event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1dcf543a-67bd-4ed9-95ff-2fb87fcb877e.png)'
  prefs: []
  type: TYPE_IMG
- en: Mapping actions to our motion controllers in the player pawn
  prefs: []
  type: TYPE_NORMAL
- en: For each of our button events, we need to create two references to our custom
    events that we created back in the interaction component blueprint. Start by grabbing
    a reference to the left interaction component from the My Blueprints panel. Position
    it near the MotionController (L) Trigger event. Drag a line off it and drop it.
    Use the search box to find our Activate Down function. Connect it to the Pressed
    execute output on the left trigger event. Next, drag a connection off the Instigator
    input pin on the Activate Down function and drop it to bring up the search menu.
    Search for a reference to the `Self` variable. In this case, the player is the
    instigator of the activation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat the process for the MotionController (R) Trigger event by using a reference
    to the right interaction component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I chose to use the left and right triggers for interactions for a couple different
    reasons. First, it's a button that's natural for a first-time user to press to
    activate something or to make something happen. It's intuitive. Second, the button
    event exists with the Oculus Touch controllers and Vive motion controllers, so
    I wouldn't have to change anything to go between hardware. Later, we'll create
    a pickup interaction, and I will use the grip buttons for the same reasons.
  prefs: []
  type: TYPE_NORMAL
- en: In this first section of programming, we set up the hand static meshes and programmed
    the `ObjectInteractionInterface`, a collection of functions that can be utilized
    by the object we want the player to be able to interact with. This blueprint interface
    connects to our Interfaction Component, a custom Scene Component that has the
    ability to utilize a parabolic line trace function to find interactive objects.
    Finally, we mapped our Activate functionality to buttons on the Motion Controller
    as part of Player Pawn blueprint. In the next section, we'll build on to this
    new functionality to create a teleport mechanic.
  prefs: []
  type: TYPE_NORMAL
- en: Building the teleportation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that the code for line tracing and interaction has been implemented, we
    can turn our attention to the teleport system itself. The goal of using teleportation
    in *Server 17* is to give our player an intuitive method of moving around our
    environment. Though teleportation is often seen as immersion breaking, I feel
    that the cyberspace environment in our game supports the idea of the player character
    being able to teleport around the space. To get started, let''s first think about
    the parts of a VR teleport system:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Visuals**: Players need to be able to visualize where they''ll be moving
    to when they click the button. This can be done by projecting a line or an arc
    to where they''ll land (we''ve done this through the debug option on our line
    trace that we set earlier). We should also have a visual on the surface they''ll
    land on, to further highlight their landing point. Lastly, we might think about
    a particle effect and/or a sound effect to help enhance the player experience.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Teleport code**: This would be the actual functionality that''s built within
    the blueprint. The code will need to handle the displaying of the visual elements,
    as well as the teleport itself. It would also be nice to build in some kinds of
    controls for us as designers to restrict the player to certain areas so that they
    can''t teleport outside the area we''ve built for them or see things they aren''t
    supposed to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Contrary to how we would normally start building a feature such as this (functionality,
    then art), here we''ll start with a bit of the visual components. In this case,
    we need some visuals to be able to turn on and off to make sure our code is working.
    Building this system will also be an excellent test of how our interface and line
    trace code is working. Let''s start with a visual on the ground for teleporting:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c95d7262-db3f-4cf4-bdf2-c8327bd1c4aa.png)'
  prefs: []
  type: TYPE_IMG
- en: TeleportViz viewport
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by creating a new actor blueprint:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click in the `Server17\Blueprints` folder of the Content Browser and select
    the Blueprint Class option from the Create Basic Asset section of the menu. Choose
    Actor from the Pick Parent Class menu and name this new blueprint TeleportViz.
    Double-click the blueprint to open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Viewport tab, head over to the Components panel and click the Add Component
    button. Choose Static Mesh from the menu. This should create a new static mesh
    component that's a child of the Default Scene Root.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on it and search for the Static Mesh section of the Details panel. There's
    an option called Static Mesh where we can set the shape we want to use. Click
    the drop-down menu and search for SM_FatCylinder, though you may use any shape
    you like. Name the piece `Visualizer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The static mesh looks a bit plain. Let''s spruce it up a bit with a custom
    Material to make it glow a bit and stand out. This will also serve as a great
    test for a potential art style for the overall environment of the game. In the
    Content Browser, navigate to the `Server17` folder, right-click in the Content
    Browser window, and create a New Folder. Name it `Materials`. Double-click the
    new folder and right-click in it to create a new Material. Name this material
    `M_TeleportViz`. Double-click the new material to open it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5df6e4d1-f23b-404d-85c5-59ebf3fede5f.png)'
  prefs: []
  type: TYPE_IMG
- en: TeleportViz Material
  prefs: []
  type: TYPE_NORMAL
- en: When we open the material, we're greeted with one large Result Node to get us
    started. Click on it, and let's tweak a few of the settings in the Details panel.
    Find the option labeled Blend Mode. We want our new material to feel high-tech,
    so let's change the mode to Translucent to give it a little bit of that feel.
    Next, find the Shading Model. Since we're going to give this element an emissive
    glow, let's change the model to Unlit. Lastly, check the box to make the material
    Two Sided.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now it's time to choose a color. Create a Constant 3 Vector by grabbing it from
    the Palette panel or holding the *3* key and clicking in the material blueprint.
    If you don't have the Palette open and would like it to be, click on the window
    button at the top right of your screen and choose Palette from the menu. Right-click
    on the new vector and select Convert to Parameter at the top of the resulting
    menu. Name the parameter Color. By making it a parameter, we're making it possible
    to use blueprints to change it if we needed to. This could be handy in the future.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Color node and click on the block of color in the Details panel
    to bring up the color picker. Choose any color you like and click the Ok button.
    If you would like to use the light blue color I have, set your RGB values to *R=0.84*,
    *G=0.74*, and *B=1.0*. Make sure you Alpha is set to *A=1.0*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To give the material a bit of glow, let's create a Constant value and multiply
    that by our Color. Search for Constant in the Palette or right-click and use the
    search box. Right-click on the new node and select Convert to Parameter as we
    did for Color in *step 6*. Over in the Details panel, name this value Strength
    and set the default value to `10`. Finally, create a Multiply node and connect
    the output of the Color parameter as value `A` and the output of Strength as value
    `B`. Finish by connecting the output of the multiply to the Emissive slot on the
    Result node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To give our new Color a bit of a gradient effect, we'll manipulate the texture
    coordinates a bit. Create a Texture Coordinate node by either using the Palette
    or holding the *U* key and clicking in the blueprint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we'll need a Component Mask. Create a copy of the node using the Palette
    or right-click in the blueprint and use the search box. In the Details panel,
    turn off the option to use the R channel. Connect the output from the Texture
    Coordinate to the input on the Component Mask.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now create a Cosine node. A Cosine will ensure that the gradient starts from
    both ends of the material. This will connect to the output from the Component
    Mask.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cosine outputs a value between -1 and 1\. We need the resulting value to be
    positive only, so we'll use a One Minus node. This will give us values between
    0 and 2\. Create the One Minus node and connect it to the output of the Cosine
    node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To bring the value back to between 0 and 1, we can divide the answer by 2\.
    Using the Divide node, connect the output of the One Minus node as the `A` value.
    Click on the Divide node and find the value for `B` in the Details panel. Change
    this value to `2.0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we're going to build in some control over the distance the gradient takes
    to go from opaque to clear. This is called **Falloff**. Create a new Power node
    and connect the output of our Divide node into the Base input on the new node.
    Next, create a Constant. This can be done using the Palette or the search menu,
    or by holding the one key and clicking in the blueprint. Right-click on it and
    Convert to Parameter. Name the parameter `GradientFalloff` and set the Default
    Value to `3`. Plug the output of this parameter into the Exponent, or Exp, input
    on the Power node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To ensure the resulting value can never go above 1, we'll need to clamp the
    value. Create a new Clamp node and bring in the output from the Power node. Plug
    the output of the Clamp node into the Opacity slot on the result node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check that out! The result should be glowing and partially see-through. You
    can tweak the materials by adjusting the GradientFalloff, Strength, and Color
    parameters until it feels right to you. To complete the visual, head back to our
    TeleportViz class blueprint and click on the static mesh component. Using the
    Details panel, apply our new material and bask in the high-tech glow.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the visual component sorted, we can now build the functionality. To meet
    our needs of a system that can control where a player can teleport, we''re going
    to create a volume that only allows players to teleport where we place it. It''ll
    display our visual elements when it detects a line trace and will contain our
    teleport code. Start by right clicking in the `Server17\Blueprints` folder of
    the Content Browser and create a new Blueprint Class. Choose Actor from the Pick
    Parent Class menu and name it `TeleportVol`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/125c1126-9f18-4e83-a2a5-a064e534b8d8.png)'
  prefs: []
  type: TYPE_IMG
- en: The TeleportVol component
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start in the Viewport tab:'
  prefs: []
  type: TYPE_NORMAL
- en: TeleportVol has two components that make it work. The first is a box volume
    to detect collisions and line traces. The second is the visual elements we created
    earlier that we can turn on and off. Start by heading to the Components panel
    and creating a new Box Collision. Name the new component `TeleportVol`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on TeleportVol in the Component panel. We want the collision box to cover
    a fair amount of space, but it really doesn't have to be that tall. In the Details
    Panel, find the Box Extents entry and change the values to *X=200*, *Y=200*, and
    *Z=1.0*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we need to customize the collision a bit. In the Collision section of the
    Details panel, find the Collision section. Choose the Collision Presets drop-down
    menu and change it to Custom. Under Trace Responses, we want to set both options
    to Block. In the Object Responses section, change all of the options to Ignore.
    This will make the volume available for line traces, but nothing else.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the volume customized, we can move on to the second component. In the Components
    panel, click the Add Component button and select Child Actor from the menu. This
    is a copy of a class blueprint that we can place inside this blueprint. We can
    essentially build a class blueprint out of class blueprints! Click the component
    and find the Child Actor Class option in the Details panel. Using the drop-down
    menu, set this option to TeleportViz. We also don't want it to be visible unless
    it's being hit by a line trace, so turn off the Visible option in the Rendering
    section of the Details.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we will move on to the code! We need this object to be able to react to
    line traces, right? Well, we wrote a whole interface for exactly that. This will
    be the first application of our Object Interaction Interface. To add the functions
    from the interface to this object, click on the Class Defaults that's just above
    the area where the Event Graph and Viewport tabs are located. This will open the
    default options for this class over in the Details panel. Find the Interfaces
    section and click the Add button. Search for the Object Interaction Interface
    in the menu and select it to add its functions to our teleport volume.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We now have access to every function we wrote in the interface. These can be
    found in the Interfaces section of the My Blueprint panel. Simply click the Arrow
    next to the word Interfaces to see them. We can even double-click on their names
    to open them. Open the following functions: `TraceMove`, `TraceHit`, `TraceLeaveObject`,
    and `TraceActivateUp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/309921df-2090-4589-abc5-a451b0967525.png)'
  prefs: []
  type: TYPE_IMG
- en: The Trace Move function
  prefs: []
  type: TYPE_NORMAL
- en: For Trace Move, we need to program what happens as a line trace moves across
    our object. For the teleport volume, we want the visual element we created earlier
    (the glowing ring, TeleportViz) to move to wherever our line trace is hitting.
    To do this, we'll use a SetWorldLocation node. Right-click in the blueprint and
    search for Set World location. Choose SetWorldLocation (TeleportViz) from the
    list. Connect the execute output of the function node to its input and the execute
    output to the Return node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: SetWorldLocation needs a New Location input to know where to move TeleportViz
    to, and we can find that by breaking down the Hit result that comes as an input
    into the function. Create a Break Hit Result node and bring in the Hit from the
    function node as the input. We can take the Location output from the break and
    use that as the New Location input on the Set World Location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, choose the TraceHit function. In this function, we want to turn on the
    visibility of our TeleportViz mesh so that our player can see where they'll appear.
    Right-click in the blueprint and create a Set Visibility (TeleportViz) node. Connect
    it to the function node and to the Return node. On the node, turn on the New Visibility
    checkbox and the propagate to children checkbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s move on to the TraceLeaveObject function. This function will do
    something very similar to the TraceHit function, except we''ll be turning the
    visibility back to off. Similar to the preceding, create a Set Visibility (TeleportViz)
    node and connect it to both the function node and the Return node. On the node
    itself, leave the box next to New Visibility unchecked, but do click the checkbox
    next to Propagate to Children:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e6c7b19f-a084-49ef-afdc-24edcebd4f6b.png)'
  prefs: []
  type: TYPE_IMG
- en: The Teleport function
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on to the `TraceActivateUp`, we need to create a function that
    can handle the mechanics of the teleport. Over in the Functions section of the
    My Blueprint panel, click the + button and name the new function Teleport Player.
    Teleport Player needs to have a couple of input values to work. The first is named
    `Player` and will be of the type Actor. The second will be named `Loc` and this
    will be of the type Vector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The teleport itself will require a little bit of math and will need a bit of
    info from our Player Controller. Let's start the sequence by dragging an execute
    line from the function node and dropping it to open the search menu. Search for
    the Cast to PlayerController node and create it. Casting allows us to pretend
    to be another blueprint and is just one of many ways that allow us to communicate
    data between blueprints.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Casting requires an Object input, a reference to the specific object we're pretending
    to be to access its data. To get the exact PlayerController we need, click and
    drag a line off the Player input on the function node and drop it. Search for
    the Get Controller node and connect its output to the input on the Cast to PlayerController
    node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, create a SetActorLocation node. This will do the actual teleporting by
    moving the player to the designated vector coordinates. Connect the execution
    output from the cast into the execution input on SetActorLocation. The target
    input should be set to the Player by dragging a connection from the Player input
    on the function node to the Target input on SetActorLocation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It''s now time to calculate the new location! To start, we''ll need to get
    the location of two things: the player and the player camera. To get the player''s
    location, drag a line off the Player input on the function node and drop it to
    open the search box. Search for the GetActorLocation node and create one. We''ll
    need this data in a moment.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a line off the as Player Controller output from our Cast to PlayerController
    node and use it to search for the Get Player Camera Manager node. Drag off the
    output of that and search for the Get Camera Location node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is the math part: We need to subtract the location of the player''s camera
    from the location of the player itself to find the true location of the HMD for
    our teleport. For that, we''ll need a Vector - Vector node. The top input will
    be the vector output from our GetActorLocation node. The bottom input will be
    the vector from the GetCameraLocation node.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We're almost there! Right-click on the output pin of our `Vector - Vector` node
    and split the struct pin. We only need the X and Y value for the next part of
    the calculation. Create a new `Vector + Vector` node and split the struct pin
    on the top input. Connect the X and Y output values from `Vector - Vector` into
    the *X* and *Y* input values on the `Vector + Vector` node. The bottom vector
    input comes from the Loc input from the function node. Drag a connection from
    the Loc input on the function node and connect it to the bottom vector input on
    the `Vector + Vector`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Don't forget that you can use reroute nodes to clean up your code to make it
    organized and readable. Reroute nodes can be found in the search menu if you drag
    off a connection and drop it. They can also be created by double-clicking on the
    connection where you would like to create one.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that, the calculation is complete! Plug the output from the `Vector +
    Vector` node into the New Location input on SetActorLocation to complete the sequence:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/30b5f54e-1ce3-42e8-8e02-6c0fdfae4215.png)'
  prefs: []
  type: TYPE_IMG
- en: Trace Activate Up
  prefs: []
  type: TYPE_NORMAL
- en: The last function to program is Trace Activate Up, or what happens when a player
    releases the button of their motion controller. Click the tab we opened earlier
    or double-click the function name in the Functions section of the My Blueprint
    panel. Using our new Teleport Player function, we're going to move the player
    to the new location. Grab a copy of our Teleport Player function and drag it into
    the blueprint. Connect the Instigator input from the function node to the Player
    input on Teleport Player.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculating the exact location to teleport to just a bit more math. Drag a line
    off the Hit input on the function node and drop it to open the search menu. Create
    a Break Hit Result node and right-click on the Location output to split the struct.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Get Actor Location node and position it near the Break Hit node. Right-click
    on the vector output and split that struct pin as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, right-click on the Loc input on the Teleport Player node and (you guessed
    it!) split the struct pin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It's time to pass in the *XYZ* values! Connect the Location X and Location Y
    outputs from Break Hit to the Loc X and Loc Y inputs on Teleport Player. Also,
    connect the Z output from the Get Actor Location node to the Loc Z input on Teleport
    Player.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finish the sequence by connecting the execute output from Teleport Player to
    the Function Return node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the teleport volume complete, we can now test our ability to teleport,
    as well as all of the systems that support it (parabolic line tracing and the
    Object Interaction Interface). Throw a few of the TeleportVol blueprints down
    in your test level and go nuts trying it out! If everything works, we can move
    on to building a prototype puzzle box.
  prefs: []
  type: TYPE_NORMAL
- en: The server – Building the puzzle box
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the player now having the ability to touch things and teleport around
    our test level, it''s now time tackle the puzzle box. In *Server 17*, the puzzle
    box is a graphical representation of the player hacking into a remote server and
    stealing data. The final version may contain several puzzles to solve and dozens
    of steps to complete. However, for this first prototype version, we''re going
    to design and build a simple three-step box as shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/22b17ba4-639d-4bce-bb60-576804297a58.png)'
  prefs: []
  type: TYPE_IMG
- en: This design requires the player to find and remove a panel on the box to reveal
    a button that unlocks the front of the box. This panel can then be removed by
    grabbing it and moving it to the side revealing another switch. The final step
    is to then press the switch and find the removable panel to steal the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Building this in Unreal Engine 4 will have us creating a few things:'
  prefs: []
  type: TYPE_NORMAL
- en: We'll need to create additional functionality for the hands that our interface
    currently doesn't cover, such as grabbing, dragging, and pressing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We'll need an object that responds to the player's touch and can be grabbed,
    moved, and thrown.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We'll need interactive buttons that can trigger events.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We'll need to build the box itself using child actors and code to turn the interactive
    elements on and off.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When complete, we''ll have an amazing test platform that can be used to prove
    that *Server 17* is fun and that can be tested by our target demographic. The
    first step in moving forward is to build a second interface to hold our button
    interactions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a7325795-74eb-4ff8-973e-92780b0956bd.png)'
  prefs: []
  type: TYPE_IMG
- en: Button Interaction Interface
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s time to create the Button Interaction Interface:'
  prefs: []
  type: TYPE_NORMAL
- en: Head to the Content Browser and navigate to our `Server17\Blueprints` folder.
    Right-click in the browser and navigate to the Create Advanced Asset section of
    the menu. Highlight the Blueprint Entry and choose the Blueprint Interface option.
    Name the new interface `ButtonInteractionInterface`. Double-click the new interface
    to open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this interface, we'll create nine different functions that represent the
    different states of the actions we're creating. The first is a function to determine
    what to do when we're hovering our hand over something. Find the Functions section
    of the My Blueprint panel and click the + button. Name the new function `OnHover`.
    `OnHover` will need one input named `Interactor` of the type Interaction Component.
    It'll also need an output named Return of the Boolean type to make it function
    properly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next function will be named `EndHover` and controls what happens when the
    player's hand leaves an object. It has the same input and output as the previous
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we'll create the `OnPickup` function to cover what happens when we want
    to pick up an object, which is a very common interaction in VR. It has the same
    input and output as the last two functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next is the  `OnDrop` function; this will give us the opportunity to create
    additional functions when the player drops an object. It also has the same input
    and output as the last few functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next three functions control the dragging of objects and allow us the opportunity
    to create even more gameplay with these actions. Create functions named `OnDrag`,
    `OnDragStart`, and `OnDragEnd`. They have the same input and output as all of
    the other functions that we've created here so far.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, here''s one that''s different! Create a new function and name it `CanPickUp`.
    This function controls a Boolean that determines whether something is allowed
    to be picked up. It only has one output: a Boolean with the name `PickUp`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is the last one. Create one more function. This one is named `OnUse` and
    allows us to create objects that can be used as power ups. `OnUse` has input and
    output identical to `OnHover`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We now have a second interface that allows us as designers as much freedom
    to create interactions as we have imagination. To test out our new player abilities,
    let''s build a basic cube that can be interacted with in several different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2d15ebff-52b5-4770-b564-b8a5776b9cfd.png)'
  prefs: []
  type: TYPE_IMG
- en: InteractCube with interface
  prefs: []
  type: TYPE_NORMAL
- en: 'To test our systems (and have a little fun), we''re going to create a cube
    that utilizes many of the new functions that we''ve created in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you're in the `Server17\Blueprints` folder and right-click in the Content Browser
    to create a new Blueprint Class. Choose Actor in the Pick Parent Class menu and
    name our new blueprint `InteractCube`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the Add Component button in the Components panel and choose the Cube option
    from the Common section of the menu. In the Details panel, find the Scale values
    near the top and set the values so that X=0.3, Y=0.3, and Z=0.3.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It's time to add the interfaces. Click the Class Defaults button at the top
    of the screen. In the Details panel, click the Add button in the Interfaces section.
    Search for and add both the Object Interaction Interface and the Button Interaction
    Interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we have a load of functions to play with! Let's start with a way to tell
    when the cube is being hit by a line trace. Open the Interfaces section of the
    My Blueprints panel and open the `TraceHitObject` function. Right-click in the
    blueprint and search for the set Vector Parameter Value (Cube) on the Materials
    node. This node allows us to access the Color parameter on the cube's default
    material. Connect it to the function node and the Return node. Next, set the value
    of Parameter Name to Color. Finally, let's turn the cube red by changing the Parameter
    Value X value to 1.0\. Now the cube will turn red when hit by a line trace!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's set the color back to white when the line trace leaves the cube. Double-click
    the `TraceLeaveObject` function in the Interfaces menu. Grab the same set Vector
    Parameter Value (Cube) node we used before, only, this time, set the values of
    Parameter Value to X=1.0, Y=1.0, and Z=1.0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Having fun yet? Let's open the `TraceActivateDown` function from the Interfaces
    menu. Using the same preceding technique, create the Set Vector Parameter Value
    (Cube) node, type in the Color for the Parameter Name, and set the values of Parameter
    Value to X=0, Y=1.0, and Z=0\. Our cube now turns green when we click the button
    to interact with it!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we use `TraceActivateDown`, we should probably use `TraceActivateUp`. Let's
    set it up to change the color back to red when we release the button. Open the
    function and create another set Vector Parameter Value (Cube) node. Wire it into
    the function, set the value of Parameter Name to Color, and change the values
    of Parameter Value to X=1.0, Y=0, and Z=0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Want to have a little more fun with our functions? Use the Add Impulse node where
    the target of the node is a Scene Component to create a sudden upward acceleration.
    Replace one of the set Vector Parameter Value nodes with Add Impulse and change
    the Z value of the Impulse parameter to 5000\. Make sure to turn on the checkbox
    for Velocity Change. This will shoot the cube skyward when the button is pressed
    or released!
  prefs: []
  type: TYPE_NORMAL
- en: How about we try the cube able to be picked up and thrown? To create this mechanism,
    we'll have Unreal simulate physics on our cube and then toggle this feature off
    and on when we pick up and drop the cube. Open the `OnPickup` and `OnDrop` functions. In
    `OnPickup`, right-click in the blueprint and search for the node set Simulate
    Physics (Cube). Wire the execution input and output the the function node and
    the Return node, as it'll be the only node we use in this function. This will
    disable the physics when the cube is picked up so it won't fall out of the player's
    hands or exhibit other strange behavior. Now open `OnDrop` and create another
    copy of set Simulate Physics (Cube). This time, turn on the checkbox next to the
    option to Simulate Physics on the node. This will enable the physics when the
    cube is dropped so it behaves the way we intend. Finally, head back to the Viewport
    tab and click on the cube. Check the Details panel to make sure the Simulate Physics
    option is turned on. If it's not, enable it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's one more function to set up. Go back to the Interfaces section of the
    My Blueprints panel and open the `CanPickUp` function. To make it so we can toggle
    this feature on and off, we're going to need a Boolean that we can toggle. In
    the Variables section, click the + button and create a new Boolean variable named
    `PickUpActive`. Back in the `CanPickUp` function, drag in a copy of our new variable
    and choose get from the menu. Plug the output of `PickUpActive` into the `PickUp`
    input on the Return node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To make use of these new functions, we''ll need to set up a way to call them
    in the Interaction Component, as well as map them to buttons in `Server17PlayerPawn`.
    This is exactly like what we did when we created the Object Interaction Interface
    earlier in this chapter. Head back to the Content Browser and open the Interaction
    Component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3aff3444-e764-42b6-bb2e-d0e8560ed210.png)'
  prefs: []
  type: TYPE_IMG
- en: The Hover interaction component code
  prefs: []
  type: TYPE_NORMAL
- en: Inside the Interaction Component, we need to add some of the new player functionality,
    but the current code doesn't allow for that kind of expansion. To change that,
    we're going to use a Sequence node. The Sequence node is a flow-control node that
    implements the code connected to each of its output pins in order. To implement
    our new functions, we'll want to add the Sequence node after the Gate. Right-click
    in the blueprint and search for the Sequence node. Once created, click the Add
    Pin button in the bottom-left portion of the node. This will add an additional
    execution output. Connect the Sequence right after the Gate and connect the Parabolic
    Line Trace node to the execution output labeled Then 0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before we begin implementing the Hover, Drag, and Pickup features, we'll need
    a few more variables. Click the + button in Variables section of the My Blueprint
    panel and create a new Float variable named `InteractRadius`. Compile the blueprint
    and give it a default value of 10\. Next, create two variables of the type Actor,
    one named `HoverObject` and the other named `HeldObject`. Finally, create one
    more Boolean variable and name it `Dragging`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's start by implementing the Hovering and Dragging behavior. Drag an execute
    line from the Then 1 output on our new Sequence node and drop it in a clear area
    of the blueprint. The node we're looking for is called SphereOverlapActors and
    is designed to return the objects that it detects within a specific radius.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: SphereOverlapActors needs four different input values. The first is Sphere Position
    (or Pos). We want the sphere to detect from wherever the interaction component
    is located. Drag a line from the Sphere Pos input and drop it. Search for the
    GetWordlocation node. This will give us an input of where the interaction components
    are in world space.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the next input, grab a copy of our InteractRadius variable and choose Get
    from the menu. This will give a 10 cm detection radius for our interactions and
    make that radius easily adjustable through the variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we want to filter what the player can interact with. Drag a line off the
    Object Types input and search for the Make Array node. Click the Add Pin button
    on the node and use the two drop-down menus to choose the WorldDynamic and PhysicsBody
    options.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we want the player to ignore anything classified as itself so one motion
    controller can't interact with the other motion controller, for example. Right-click
    in the blueprint and use the search box to find the Get Owner node. This will
    return a reference to the player as an Actor. Since SphereOverlapActors only accepts
    an array as an input for Actors To Ignore, we'll need to insert the output from
    Get Owner into an array. Drag off from the Return value on Get Owner and drop
    it. Find the Make Array node and plug the resulting array into the final input
    on SphereOverlapActors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'SphereOverlapActors will now return an array of objects that match our criteria.
    With the output, we need to do a quick check to see whether the HoverObject we''ve
    stored in the variable is the same as the one we just took in. If they''re the
    same, there''s no reason to proceed; this will save us a bit of performance. Drag
    off the Out Actors output and search for the Get node. This will retrieve the
    item from the area at index 0 (the array should only contain one object). Next,
    get a reference to our HoverObject variable. Finally, to compare them, drag off
    the HoverObject variable and search for the NotEqual node. One input should be
    our HoverObject and the other should be the output of our Get node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f2bf60cc-79da-45c4-b2df-6ac9f309ee46.png)'
  prefs: []
  type: TYPE_IMG
- en: The second part of the Hover code
  prefs: []
  type: TYPE_NORMAL
- en: NotEqual will return a Boolean, so we'll need a Branch to continue. Connect
    the Branch to the execution output from the SphereOverlapActors node. The condition
    will be the result of the NotEqual node and we'll move forward only if it's `True`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If our comparison is True and the two objects aren't the same, we're going to
    need to end the hovering behavior on the current object and set up the hovering
    or dragging behavior to work with the new object. Drag off from the True output
    on the Branch and search for our EndHover function from our Button Interaction
    Interface. Get a copy of our HoverObject variable and plug that into the Target
    input and use a Reference to Self as the Interactor input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, create a copy of our EndDrag function and connect it to the execution
    output from our EndHover node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we need to update the HoverObject variable with the new object we're hovering
    over. Drag in a copy of HoverObject  and choose Set from the menu. The input will
    be the output from our Get node from earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, we'll call the `OnHover` function to complete the sequence. Create a
    copy of our `OnHover` function and connect that to the execute output from the
    set HoverObject. The variable output from set the HoverObject can be used as the
    Target. Use a Reference to Self as as the Interactor input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our hovering code allows us to detect what the player might be reaching out
    for or holding their hand over, such as a button or an other component. Next,
    we''ll tackle Dragging:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/09a90731-f6c6-4f8d-b1c6-f9a9eab29e41.png)'
  prefs: []
  type: TYPE_IMG
- en: Dragging code
  prefs: []
  type: TYPE_NORMAL
- en: 'For Dragging, we''ll need to create two Custom Events that can be called from
    outside the blueprint. This is exactly the same technique we used to implement
    our ActivateUp and ActivateDown behavior earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: To start, we'll create two Custom Events. Right-click in the blueprint and choose
    the Add Custom Event option. Name the first one `StartDrag` and the second one
    `EndDrag`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For both of our new events, we basically want to turn our Dragging Boolean on
    and off while calling our OnDragStart and OnDragEnd functions. Let's start with
    StartDrag. Grab a copy of our Dragging variable and choose Set from the menu.
    Connect the execution output from our event to set Dragging and click the checkbox
    on the node to set it to True.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we'll call our OnDragStart function. Drag a copy of OnDragStart into the
    blueprint from the Interfaces section of My Blueprint and connect an execution
    line from set Dragging. Plug in a copy of our HoverObject variable as the Target
    and use a Reference to Self as the Interactor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we can work with our EndDrag custom event. The first step is to check
    to see whether our Dragging Boolean is True; if it is, then we can end the current
    drag. Create a new Branch node and connect the execute output from our event to
    it. Get a copy of Dragging and connect this to the Condition input on the Branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If Dragging is True, we need to update the variable and end the drag. Create
    another copy of Dragging, only this time choose Set from the menu and connect
    the True output from the Branch to it. Make sure the checkbox on Dragging is clear.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It's time to create a copy of our OnDragEnd function. Connect the execute output
    from set Dragging to the execute input on our new node. Just as we did for OnDragStart earlier,
    connect HoverObject as our Target and use a Reference to Self as the Interactor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It's time to bring these two sequences together. We'll use a Gate to control
    whether or not something can be dragged with our custom events controlling whether
    the Gate is open or closed. Create a new Gate node and connect the output from OnDragStart to
    the Open input and bring in the output from OnDragEnd into the Close input. We'll
    connect the Enter input to the Then 2 input on our Sequence node from earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The final step to completing the drag is calling the OnDrag function. Create
    a copy and connect it to the Exit output from our Gate node we created in the
    last step. Just as we did for our previous drag functions, we'll connect a copy
    of our HoverObject variable to the Target input and plug in a Reference to Self
    as the Interactor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can now drag objects! Such a behavior might be useful in programming levers
    and other similar pieces that can be moved but not necessarily picked up. Speaking
    of picking up, the next feature we''ll tackle is the ability to pick things up
    and throw them. Much like hovering or dragging, there''s a similar trick to the
    pick-up-and drop behavior that happens behind the scenes. Most of the objects,
    but not all, will start with their Simulate Physics option enabled. The trick
    is this: when the object is picked up in VR, we''ll attach the object to the player''s
    hand so it can''t get away from them. We will also disable the physics on the
    object (we set this up earlier in the OnPickup function of our InteractCube).
    When we put down the object, we detach it from the player and re-enable the physics.
    Since the player never sees any of the changes, it looks to them as if they just
    picked up the object and then put it down. Cool, huh?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s build it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c209bda3-9713-4d48-9023-2d7cd141b16f.png)'
  prefs: []
  type: TYPE_IMG
- en: Pickup code
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as we did for the dragging behavior, we''ll start by creating two custom
    events: one for Pickup and one for Drop:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click in our blueprint and create two new custom events with the Add Custom
    Event option. Name the first `Pickup` and the second `Drop`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We'll start by building the pickup behavior. We need to start by checking whether
    the object the player is hovering over is a valid object. Right-click in the blueprint
    and search for the IsValid node. The version we need is marked with a question
    mark as its icon. Connect it to our Pickup event and create a copy of our HoverObject
    variable, which will serve as the input for the Input object pin on the node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we know whether the object is real (in a manner of speaking), we can
    check to see whether we can pick it up! Create a copy of our CanPickUp function
    and connect HoverObject as the Target. This will return a True or False, which
    will determine whether the player can pick up the object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we need a Branch to process the Boolean from CanPickUp. We only want the
    player to pick things up if this is True. Create a new Branch node and connect
    it to the execute output from CanPickUp. The Condition input will be the PickUp
    output from CanPickUp.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We know now whether the object is real. We also know whether we're allowed to
    pickup it. Now it's the time to do the heavy lifting. Create a copy of our HeldObject
    variable and choose set from the menu. The input for Set HeldObject will be the
    current value of HoverObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, create a copy of the AttachToComponent node, making sure we're using the
    Target is Actor version. Connect it to the output of  the set HeldObject. Also,
    pass the variable output of set HeldObject into the Target input on AttachToComponent.
    Now create a Reference to Self and plug that into the Parent input. Lastly, set
    the Location Rule, Rotation Rule, and Scale Rule settings in the node to the Keep
    World option. This will maintain the basic attributes of the object we pick up
    so that, when we drop it, everything will remain the same.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next step is to call our OnPickup function to trigger any special behaviors
    we might want for that object. Create a copy of OnPickup and connect the output
    from AttachToComponent to it. Connect a copy of the HeldObject variable to the
    Target input and use a Reference to Self as the Interactor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have the ability to pick things up and drop them, we may want the
    player to be able to use something they''re hovering over. To create this behavior,
    we''ll need to create a custom event named UseHovered. Next, create a copy of
    our `OnUse` function and connect it to our custom event. Get a copy of our HoverObject
    variable to use as the Target. Finish the node with a Reference to Self to use
    as the Interactor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/90ff10c8-2d12-499d-b05a-605af0ccfc64.png)'
  prefs: []
  type: TYPE_IMG
- en: Pickup/Drop and Hover/Drag code in player pawn
  prefs: []
  type: TYPE_NORMAL
- en: To be able to utilize our new behaviors (Hover, Drag, Pickup, and Drop), we'll
    need to map them to buttons on the player's motion controller. Let's add hover
    and drag to the triggers. Open `Server17PlayerPawn` and find where we mapped ActivateUp
    and ActivateDown to the motion controller triggers. We'll start with the left
    trigger. Extend an execute line from ActivateDown and drop it to search for our
    UseHovered function (referencing the left interaction component). Next, drag off
    the reference to InteractionComponent_L and search for the StartDrag function.
    Connect this to the execute output on the UseHovered function. Finish by dragging
    off the reference to InteractionComponent_L again and searching for EndDrag. We'll
    connect this to the execution output from ActivateUp. Now we can use hovered objects,
    as well as start and end drag sequences!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat the same process for the right motion controller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, it's time to map the pickup and drop behaviors. Many games map this
    type of behavior to the grip buttons as players seem to naturally gravitate toward
    using these buttons, for this interaction. Right-click in the blueprint and search
    for the MotionController L Grip1 event. Drag an execution line from the Pressed
    output and search for our Pickup function (referencing the left interaction component).
    Now drag off the reference to InteractionComponent_L and search for the Drop function.
    Connect this new function to the Released output on the event. As before, repeat
    this process for the right motion controller as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Done! To test the behavior, let''s drop a few of these wonderful cubes in our
    level and test their functionality. Pick them up, throw them, and watch them change
    color. Pretty cool, right? Just think about all of the possibilities for gameplay
    with the power you now hold within this cube. It gives you ideas, doesn''t it?
    Before we get to implementing those ideas, why don''t we add one more tool to
    our toolbox in the form of a button our players can press:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8001be16-b35c-49bd-b788-a72c4621d8d2.png)'
  prefs: []
  type: TYPE_IMG
- en: Button press code
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start building our button in the Viewport:'
  prefs: []
  type: TYPE_NORMAL
- en: Our button will be built from three different components. In the Viewport tab,
    click the Add Component button and create a new Scene Component. Name this `ButtonRoot`
    . Next, create a Cylinder component and name it `Button`. We'll need to scale
    the cylinder down a bit so change the X, Y, and Z values for the Scale property
    to 0.05\. Also, change its Collision Preset to OverlapAllDynamic. Make sure the
    button is a child of the ButtonRoot. Lastly, create one more Cylinder component
    named `ButtonBase` and make sure that it's a child of the Default Scene Root.
    We'll need to change the Scale property here too. Change the scale values to X=0.15,
    Y=0.15, and Z=0.05\. Finally, set its Collision Preset to NoCollision.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that the visual components have been created, we can move on to the blueprint.
    We want to create a button that animates a bit when the player hovers their hand
    on it, and, for that, we'll need a few variables. The first we'll create is named
    `InitOverlapLoc` of the type Vector. This will store the location where the player's
    hand started overlapping. The second is `MaxPressAmout` of the type Float. This
    will be an adjustable variable so that we can fine tune how much the player needs
    to press the button for it to fire. Compile the blueprint and set the default
    value of this variable to 4\. The third variable we need is named `PressAmount`
    of the type Float. This will store the amount that the player has pressed the
    button. Lastly, we need to store the name of the component that over lapped the
    button. Create one more variable and name it `OverlapComponent`. Make sure its
    type is Primitive Component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We're going to start our first code sequence with two events. Click on the Button
    component we created earlier and head to the Details panel. Near the very bottom
    of the list in the Events section of the menu is a collection of buttons that
    allows you to create almost every event compatible with our Button. We need to
    create two: OnComponentBeginOverlap and OnComponentEndOverlap. This will detect
    when the player's hand is pressing the button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: OnComponentBeginOverlap feels like a good place to start, since it's the event
    that kicks everything off. The first step is to check and see whether the component
    overlapping the button is valid. Create a copy of the IsValid node (remember the
    one with the question mark?). Connect it to the event and get a copy of our OverlapComponent
    variable to be pluged into the Input Object pin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If our OverlapComponent isn't valid (meaning the variable is empty), we need
    to store whatever overlapped the button as our new value for OverlapComponent.
    Grab another copy of OverlapComponent, only, this time, choose Set from the menu.
    The input for the new node will be the Other Comp input from the event node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the OverlapComponent set, we now also need to set its location in our InitOverlapLoc variable.
    Right-click in the blueprint and grab a copy of the GetWorldLocation node where
    the target of the node is a Scene Component. Connect the execute input to the
    execute output of set OverlapComponent. Have the variable input for GetWorldLocation by
    the variable output for the set OverlapComponent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we need to store the new location in InitOverlapLoc. Create a new set InitOverlapLoc node.
    The variable input for this new node will be the output from GetWorldLocation.
    Don't forget to connect the execute connection!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It's time to tackle the OnComponentEndOverlap event. When we end the overlap,
    all we want to do is check to see whether the object that was removed from overlapping
    is the same that we've stored in the OverlapComponent variable and whether it's
    we want to clear that variable. Start the sequence by creating a Branch and connecting
    it to the execution output of the event. To compare our objects, create a copy
    of the Equals (object) node. The top input with be the OtherComp output from the
    event. The bottom will be a copy of our OverlapComponent variable. Finally, connect
    the Boolean output from the Equals node to the Condition input on the Branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the final step in this sequence, create a copy of OverlapComponent and choose
    Set from the menu. Connect it to the True execution output on the Branch. We'll
    leave its variable input blank so that we can clear its value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next step in our code is to build the nodes that will control the short
    animation. We begin with the Event Tick node. Next, right-click and create a Sequence
    node, since this will be a two-step process. Connect the Sequence to the execute
    output from Even Tick:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/33194035-ebcc-46c9-82e6-fedb35148c27.png)'
  prefs: []
  type: TYPE_IMG
- en: Button down code
  prefs: []
  type: TYPE_NORMAL
- en: Dragging off the Then 0 output, drop the connection and use the search box to
    find the IsValid node (remember to use the one marked with a ? in the menu). The
    Input Object we'll be checking this time will be a copy of our OverlapComponent. We'll
    use this setup to determine whether the player is still overlapping with the button.
    If they are, we'll animate the button going down. If they aren't, we'll animate
    the button, returning to the original position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, drag in a copy of our PressAmount variable and choose the Set option from
    the menu. Connect this to the IsValid output. We'll leave its variable input blank
    for now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To do the actual animating, we'll need to create a copy of a SetRelativeLocation
    node. Connect its execute input to the execute output from the set PressAmount and
    use a reference to the Button component as the Target.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the basics of the code set up for the animation, it's time to do some quick
    math. Pressing a Button is a basic motion that involves moving the button component
    moving up and down in the *Z* axis when the player overlaps it. To figure out
    how far the button needs to travel, we'll take the distance the overlapping actor
    has traveled and subtract it from the initial position of that same actor. We'll
    compare that distance to our MaxPressAmount to determine whether the button has
    been truly pressed. This will all be calculated relative to the position of the
    button to ensure that it'll work in whatever situation you decide to use it. We'll
    start with converting our stored InitOverlapLoc value to be in relation to the
    button. Get a reference to the ButtonBase from the Components panel, drag a connection
    off of it, and drop it to open the search menu. Create a copy of GetWorldTransform.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dragging a line from the return value of GetWorldTransform, drop the connection,
    and search for the InverseTransformLocation node. This node is designed to take
    in a location and convert it from World Space over into Local Space, based on
    the transform that we supply. In this case, we're converting the initial overlap
    location to be relative to the ButtonBase. Get a copy of our InitOverlapLoc variable
    and connect that to the Location input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now create a `Vector - Vector` node and take the Return value of the InverseTransformLocation and
    plug that into the top input. We'll calculate the second value in the following
    steps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag another connection off the reference to ButtonBase and create another copy
    of GetWorldTransform and another copy of InverseTransformLocation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This time, we'll need to get the location of the component we've stored in OverlapComponent.
    Get a copy of the OverlapComponent variable and drag a connection off it. Drop
    it and search for GetWorldLocation. The Return Value of this node will be the
    Location input on the copy of the InverseTransformLocation we created in *step
    17*. The Return Value of this InverseTransformLocation can now be connected to
    the lower input on our `Vector - Vector`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since the button only travels in the *Z* axis, we're only interested in the
    *Z* output of the subtraction node. Right-click on the output of the `Vector -
    Vector` and split the struct pin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To make sure the *Z* value doesn't go outside what we need, we're going to use
    a Clamp node to limit it. A Clamp node takes in a value and tells it that it can
    only be between a certain minimum and maximum. In this case, we're going to bring
    in the *Z* value and not let it go lower than zero or higher than our MaxPressAmount.
    Right-click and create a Clamp (float) node. Use the *Z* ouput from our `Vector
    - Vector` as the Value input and a copy of our MaxPressAmount variable as the
    Max. We should leave the minimum value at 0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We're almost there! Our clamped float value is now ready to become the input
    for the set PressAmount node we created earlier. Connect the output of the Clamp
    to the set PressAmount input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since the button will always be moving down to show that it's being pressed,
    the value we need to pass into our SetRelativeLocation node should be negative.
    Take the variable output from set PressAmount, drag off from it, and create a
    `Float * Float` node. Set the second value to -1.0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To finish the animation, right-click on the New Location input on the SetRelativeLocation
    and split the struct. Connect the output from `Float * Float` and connect to the
    New Location Z input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f3d61845-a45e-40cc-b411-3694a8f33377.png)'
  prefs: []
  type: TYPE_IMG
- en: Code that returns the button to the start position
  prefs: []
  type: TYPE_NORMAL
- en: Once the overlap is complete, we'll need to move the button back to its original
    location. Head back to the IsValid that we created back in *step 11* and drag
    a connection of the IsNotValid output, drop it, and search for a copy of the node
    SetRelativeLocation. Set a reference to our Button component as the Target.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click in the blueprint and search for the VinterpTo. This will help the
    button achieve a smooth animation back to an unpressed state. To fill the Current
    input, grab a reference to the Button component and drag a connection off it.
    Drop and search for a GetRelativeLocation node. Plug the output from this node
    into the Current input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To fill the Delta Time input, connect the Delta Time value from the Event Tick
    node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, connect the Return Value from VinterpTo to the New Location input on SetRelativeLocation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The last thing needed to finish the button is a way to process what happens
    when the button is pressed. For that, we''ll use an Event Dispatcher. By using
    an Event Dispatcher, we can bind different commands to the button, depending on
    what we need it for, leaving us with a flexible and reusable system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b4a8a587-cb18-463f-8a7d-dd48d28fcf97.png)'
  prefs: []
  type: TYPE_IMG
- en: What happens when it's pressed?
  prefs: []
  type: TYPE_NORMAL
- en: 'To continue, drag off the Then 1 output on our Sequence node and create a new
    Branch:'
  prefs: []
  type: TYPE_NORMAL
- en: It's now time to compare the amount we have pressed the button to the max press
    amount. Right-click and create a `Float >= Float` node. Get a copy of PressAmount
    and connect that to the top input. Get a copy of MaxPressAmount and connect that
    to the bottom input. Lastly, plug the output of the node into the Condition input
    on the Branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now create a DoOnce node. This node stops something from happening again until
    it has been reset. We'll plug the True output from the Branch into the execute
    input and the False output into the Reset input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, create an Event Dispatcher. Find the Event Dispatchers section of the
    My Blueprint panel and click the + button. Name the new dispatcher Pressed. Back
    in the blueprint, drag off the Completed output of DoOnce and search for the Call
    Pressed node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last step in implementing our button-press behavior is to add some code
    to the interaction component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now have a working button that the player can mash in VR. To test the feature,
    drop a copy of our button into the level where you can press it and open the Level
    Blueprint. We are going to build from the Event BeginPlay node that should be
    present in the blueprint by default. If it isn't there, go ahead and drop one
    in.
  prefs: []
  type: TYPE_NORMAL
- en: Right-click in the blueprint and create a reference to the InteractButton that's
    in the level. Drag off from the output and search for the AssignPressed node and
    connect the execute output from the event to its input. This will allow you to
    assign a custom event to Pressed. It can be anything you want! I created a simple
    way to end the level in the previous screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: Wow! We've come a long way from where we began. The player now has hands. They
    can use them to interact with the world around them. They can touch, pick up,
    throw, press buttons, and anything else that we can dream up. They can also teleport
    around the level to explore whatever we decide to create—and all of this with
    controls in place so that they may only do these things with whatever we as the
    designers let them. It's time to put that power to good use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember the puzzle box we designed at the beginning of the section? We now
    have all of the pieces we need to make this a reality. Since it''s a prototype,
    we''re going to build the box out of static mesh components and another type of
    component called a Child Actor. Child Actors are copies of class blueprints and
    allow us to build objects within a class blueprint out of other actors, meaning
    that we can piece together our simple puzzle box with Box components, copies of
    our InteractCube, and a couple copies of InteractButton:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/73d07a01-03ca-4880-b60c-6709f21bccdd.png)'
  prefs: []
  type: TYPE_IMG
- en: Building the PuzzleCubeTest
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a new Class Blueprint:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click in the `Server17\Blueprint` folder in the Content Browser and create
    a new Class Blueprint based on Actor. Name this new blueprint PuzzleCubeTest,
    since this puzzle cube represents our first prototype. Double-click it to open
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's create the visual components. The best place to start would be with the
    non-interactive components first. In the Components section of My Blueprints,
    click the Add Components button, and create a new Box component. Change the Scale
    properties X=1.0, Y=2.0, and Z=0.1\. Name this component `Bottom`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create another Box component and name it `RightSide`. Change the Scale properties
    X=0.5, Y=2.0, and Z=0.1 and rotate it 90 degrees around the *Y* axis. Line it
    up along the right edge of the bottom component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the Right component and press *Ctrl* *+ W*. This will create a copy that
    you can align with the left edge of the bottom piece. Name this new piece `LeftSide`.
    Change its Y Scale property to 1.5\. This space will allow for the hidden compartment
    in the back.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the bottom component and press *Ctrl+W* to create a copy. Name this
    new component Top. Move this component 60 cm up in the positive *Z* direction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The box is slowly coming together, but now we need a back plate to finish the
    enclosure. Create a new Box component and change the Scale property to X=0.9,
    Y=0.5, and Z=0.1\. Name it BackPlate. Finally, rotate it 90 degrees around the
    *X* axis.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we're going to create the non-interactive bottom and top supports. Create
    a new Box component and name it BottomSupport_1\. Set the Scale property to X=0.5,
    Y=1.25, and Z=0.1\. Move it below the Bottom Component and align it with the front
    and side edges.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With BottomSupport_1 selected, press *Ctrl + W* and name this new component `BottomSupport_2.`
    Rotate it 90 degrees around the *Z* axis and move it back to the center of the
    bottom of the box. The easy way to do this would be to set the *Y* value of its
    location property back to 0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create another copy of BottomSupport_1 and name it BottomSupport_3\. Rotate
    it 90 around the *Z* axis and align this component with the back edge of the bottom
    component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select all of the BottomSupport components in the Components list by clicking
    the first one and holding *Ctrl* while selecting the other two. If necessary,
    rotate the components 90 degrees so that they're back in the correct orientation.
    Then move them 80 cm up in the *Z* axis so that their bottom edges align with
    the top edge of the Top component. Name them `TopSupport_1`, `TopSupport_2`, and `TopSupport_3`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To give one of our buttons inside the box a surface to sit on, we're going to
    create one more non-interactive component. Click on the BackPlate component and
    create a copy with *Ctrl + W*. Name this new component `MiddlePlate` and make
    the value of it's Location property X=0, Y=60, and Z=30.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To create the interactive surfaces in our puzzle box, we're going utilize Child
    Actor components, which will be copies of our InteractCube object. This will allow
    us to have all of the functionality that we programmed into InteractCube and utilize
    them as components of our puzzle box without reprogramming them in a new component
    (though we may want to in the future). Create a new Child Actor component and
    name it `SideDecoy_R1`. In the Details panel, set the Child Actor class property
    to InteractCube. Se the Scale value to X=0.5, Y=0.13, and Z=0.7 and rotate it
    90 degrees around the *Z* axis. Move this component into position in between the
    first set of the top and bottom supports on the right side, aligned to the front
    edge of the RightSide component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a copy of SideDecoy_R1 using *Ctrl + W* and name the new Child Actor `SideDecoy_R2`.
    Move it between the rear set of the top and bottom supports on the right side,
    aligned with the back edge of the Right component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now for the left side, create a copy of `SideDecoy_R1` using *Ctrl + W* and
    name the new Child Actor  `SideDecoy_L1`. Move it to the left side of the box between
    the first set of top and bottom supports and align it with the front edge of the
    LeftSide component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a copy of `SideDecoy_L1` and move it to the center set of the top and bottom
    supports.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The decoy components are there to divert the players attention while they look
    for the buttons to press to unlock the puzzle box. With them all in place, we
    can now add our interactive button components. On the right-hand side of our puzzle
    box, create a new Child Actor component and set the Child Actor class property
    to InteractButton. Name this new `Child Actor Button_Step1`. Lastly, move it to
    the center of the area between the middle top and bottom supports and align it
    with the surface of the RightSide component by rotating it -90 degrees around
    the *Y* axis. Players will need to uncover and find this button before they can
    open the front of the box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a copy of Button_Step1 with *Ctrl + W* and name the new component Button_Step2\.
    Set the button's Rotation property to X=0, Y=90, and Z=90\. Align this button
    with the center of our MiddlePlate component. This button will be found behind
    a plate that covers the front of the puzzle box that can only be removed after Button_Step1
    has been pressed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now let's cover up those buttons! Create a copy of SideDecoy_R1 and name the
    new component `ButtonCover_Step1`. Move this new object to cover up Button_Step1
    by aligning it between the center set of the top and bottom supports on the right
    side.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To cover the front, we'll need a new Child Actor sized to fit that compartment.
    Create a new Child Actor, set the Child Actor class property to InteractCube,
    and name it `ButtonCover_Step2`. Set the value of the Scale property to X=0.8,
    Y=0.5, and Z=0.1\. Rotate it around the *X* axis 90 degrees. Lastly, align it
    to cover Button_Step2 and fit it flush with the front of the puzzle box. This
    will unlock after the player presses the first button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's one more cover. This one will cover the compartment we have in the back.
    Click on SideDecoy_L2 and use *Ctrl + W* to create a copy of it. Name the new
    copy `CompartmentCover_Step3`. Align it between the back top and bottom supports
    to cover the compartment. This cover will unlock when the player presses the second
    button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What good is a puzzle box if there's no prize at the end? Create one more Child
    Actor component and set the Child Actor class property to InteractCube. Name it
    StolenData. This will represent the prize the player is after. Set the value of
    the Scale property to X=0.1, Y=0.1, and Z=0.1\. Place inside of rear compartment
    that we just covered with CompartmentCover_Step3.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's one last detail. To make the InteractCube work as a stand-in for more
    detailed components that we'll create later, we need to open the InteractCube
    blueprint and turn off the Simulate Physics option. This will make it so the cubes
    won't have physics enabled by default, so the puzzle cube won't fall apart. Physics
    will still enable once the player has interacted with the cube.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Based on our design, the code for the prototype puzzle box needs to be able
    to do the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Disable the ability to pick up the button covers when we start
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bind the correct button press events to our two buttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enable the front button cover after button 1 has been pressed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enable the compartment cover after button 2 has been pressed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Disabling the components that we don''t want the player to be able to interact
    with what could be accomplished by toggling their individual PickUpActive Boolean
    variables. This will leave all of their other functions available but make it
    so the player can''t remove them before we want them to have that ability. To
    give them that ability, we can bind a couple of custom events to our two buttons
    that re-enable them after the buttons have been found and pressed. Let''s head
    to the Event Graph of PuzzleCubeTest and get to work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f317a5a2-c0b5-44cd-8c68-ba1fdb9f90e7.png)'
  prefs: []
  type: TYPE_IMG
- en: PuzzleBoxTest code
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll build this code from the Event BeginPlay node:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click in the blueprint and search for a Sequence node. We are going to
    use this to fire off the steps that we mentioned previously in the correct order.
    Click the Add Pin button on the node until we have four output pins to work with.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start by dragging off the Then 0 output and search for the Cast To InteractCube
    node. For the Object input on the cast, we need to reference our Child Actor ButtonCover_Step2\.
    However, if we try to plug in a simple reference to it, the cast won't work correctly.
    To make sure it references the correct object, we need to add a GetChildActor
    node. Create a reference to ButtonCover_Step2 and drag a connection from its output.
    Search for the GetChildActor node and connect its output to the Object input on
    the cast.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the cast set up, we can now pretend to be the button cover and turn off
    its ability to be picked up. Drag a connection off the As InteractCube output
    and search for the set PickUpActive. On the set PickUpActive node, make sure the
    checkbox is turned off.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's repeat the process for CompartmentCover_Step3\. Create the cast by dragging
    off the Then 1 output on the Sequence and connecting a reference to the Child
    Actor version of CompartmentCover_Step3 to the Object input through a GetChildActor
    node. As the child actor, set PickUpActive to false by turning off the checkbox
    on the Set node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we need to connect the button presses to a couple of custom events. Drag
    a connection off the Then 2 output on the Sequence node and search for the node
    Cast To InteractButton. Use the same method as the previous one to create a reference
    to the child actor, Button_Step1, and connect that to the Object input on the
    cast. We'll use our event dispatcher we created as part of the button to connect
    a custom event to the pressing of the button. Drag a connection off the As InteractButton
    output and search for Bind Event to Pressed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new custom event and name it UnlockStep2\. Drag a connection off the
    little box next to the event node's name and plug it into the event input on the Bind
    Event to Pressed node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a connection from the As InteractCube output from *step 3* and create a
    set PickUpActive node. Connect it to the execution output from the UnlockStep2
    event and make sure the checkbox on the Set node is turned on. We've now re-enabled ButtonCover_Step2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat the steps to set up the ability to re-enable CompartmentCover_Step3\.
    Create a Cast To InteractButton node and pass in a reference to the child actor
    version of Button_Step2\. As the button, create a Bind Event to Pressed node and
    connect it to a custom event named UnlockStep3\. Drag off the As InteractCube
    output from *step 4* and create a set PickUpActive node. Make sure that the checkbox
    on this new node is set to on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And there we have it, a working puzzle cube that takes three steps to solve.
    Using our teleport volumes, create a space where you can teleport around the box
    and then drop a copy of the puzzle box in the center. Move around it. Test the
    steps and see whether they work. Once everything is working, I have a challenge
    for you. When we started this section, I provided a sketch of the plan for the
    puzzle box, as well as a prototype level for the player to test it. Build the
    level and test your puzzle box in it. Interested in a greater challenge? Design
    and build your own puzzle cube and test level!
  prefs: []
  type: TYPE_NORMAL
- en: Building the first tool station
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An integral part of the gameplay for *Server 17* is the idea of the Tool Station,
    a location located near the puzzle box that contains some type of tool, device,
    or hint-generator that can be used by the player to help solve the puzzle at hand.
    The tools at each station would vary from brute-force hacking tools that could
    solve a step of the puzzle at the cost of a time penalty, to a simple hint tool
    that could highlight the next piece the player has to interact with. For the prototype,
    we''re going to design a simple rotation tool that will highlight how easy it
    is to use the tools that we created. Let''s take a look at the prototype visuals:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d288f312-9d20-4f01-a0d1-dbef7d91d455.png)'
  prefs: []
  type: TYPE_IMG
- en: Prototype visuals
  prefs: []
  type: TYPE_NORMAL
- en: 'The build is relatively basic. Using the Content Browser, head to the `Shapes`
    folder of the Starter Content and grab yourself a cylinder. Use the Scale tool
    to shrink it by half. Then grab a Wedge shape and place that on top of the cylinder.
    Shrink this by half as well. I also used a Text Render to create the text you
    see in the image. The final piece to this tool station is a new class blueprint:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/469fd5e5-b079-40f5-a94e-100d5c560701.png)'
  prefs: []
  type: TYPE_IMG
- en: StationButton code
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class Blueprint and select Actor from the menu:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the new class Blueprint, select the Actor class from the Pick Parent
    Class menu, and name it `StationButton`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Similar to our InteractCube, this blueprint contains only one component. I used
    a Cone component; however, feel free to use whatever you feel might be appropriate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let's code this thing! To utilize some of the functions that we've spent
    this chapter creating, click on the Class Defaults button and find the Interfaces
    section in the Details panel. Click the Add button and choose our Object Interaction
    Interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the interface added, head over to the My Blueprint panel and open the
    Interfaces section of the menu. Double-click and open the following functions:
    `TraceHitObject`, `TraceLeaveObject`, `TraceActivateUp`, and `TraceActivateDown`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's start with `TraceHitObject`. This covers what happens when our line trace
    touches the object. Drag a reference to the Cone into the blueprint from the Components
    panel and drag a connection from it. Create a copy of the SetVectorParameterValueOnMaterial
    and connect it to the function node and Return node. Set the value of the Parameter
    Name field to Color. Finally, set the *Y* value of the Parameter Value input to
    1.0\. This will highlight the button Green when we land a trace on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For `TraceLeaveObject`, we'll have to create a variable that can store whether
    or not our button is being used. Head over to the Variables section of My Blueprint
    and create a new Boolean variable. Name it `ButtonPressed` and set its default
    value to False. Along with changing the color of the button back to the default
    white, we want to make sure the button no longer registers as pressed if it's
    no longer being touched by a line trace. Repeat the preceding step to create the SetVectorParameterValueOnMaterial
    node and set the value of the Parameter Value input to X=1.0, Y=1.0, and Z=1.0\.
    This will set the button color back to white. After SetVectorParameterValueOnMaterial,
    connect a set ButtonPressed node and make sure the checkbox is set to off. Connect
    that to the output of SetVectorParameterValueOnMaterial and the ReturnNode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let's move on to `TraceActivateDown`. When the player activates the button,
    all we want to do is set ButtonPressed to True. We'll handle the rotating in the
    level blueprint. Connect a copy of the set ButtonPressed to the function. Make
    sure the checkbox on the node is turned on. After the Set node, create another
    copy of SetVectorParameterValueOnMaterial using the Cone as the Target. Set it
    up the same way as we did in the previous steps in this section and set the *X*
    value of the Parameter Value input to 1.0\. This will turn the button red when
    it's used.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, we have `TraceActivateUp`. When the player releases the trigger, we
    need to change the color back to green (the color it is when getting hit by a
    line trace) and change ButtonPressed back to false. Connect a copy of SetVectorParameterValueOnMaterial
    to the function node, set it up as we have in previous steps, and set the *Y*
    value of the Parameter Value input to 1.0\. Connect a copy of set ButtonPressed
    to the output of the SetVectorParameterValueOnMaterial node and connect its output
    to the Return node, making sure the checkbox is set to off.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Back in our level, add a copy of StationButton to the tools station that we've
    created and name it StationButton_Rotate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To make the puzzle box rotate when our station button is pressed, we''re going
    to build a bit of functionality into the level blueprint, since this ability is
    limited to the prototype level. Open the Level Blueprint using the Blueprints
    button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/48159940-23d4-4ef4-a513-5c01b5e86c7b.png)'
  prefs: []
  type: TYPE_IMG
- en: The level blueprint code
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start to build this sequence with a custom event:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click in the blueprint and create a new custom event. We are going to
    name it ButtonCheck.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, right-click and create a new Branch node. This will read whether the button
    has been pressed. Create a reference to our StationButton_Rotate and drag a connection
    from it. Drop it and search for Get ButtonPressed. Connect the output from this
    node to the Condition node on the Branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, create an Event Tick node. We want the game to check every frame if the
    button is being pressed. Drag a connection from the event and search for our ButtonCheck
    function to create a copy of it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we've done for previous buttons, we're going to use a Gate to control whether 
    the code executes, based on whether ButtonPressed is True or False. Create a Gate
    node and connect the Enter input to the output from the ButtonCheck function.
    Connect the True output from our Branch to the Open input and the False output
    from the Branch to the Close input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It's time to create the rotation. Create a new `Float` variable over in the
    Variables section of My Blueprint and name it RotSpeed. This will control how
    fast the puzzle cube rotates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, right-click and search for the Make Rotator node. Connect a copy of RotSpeed
    to the Z (Yaw) input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last major node we need is AddActorLocalRotation. Connect it to the Exit
    output of our Gate node and use a reference to our puzzle cube in the level as
    the Target.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Delta Rotation input needs a bit of math. Drag a connection from the output
    of Make Rotator and search for the ScaleRotator node. For the float input, use
    the Delta Seconds output from Event Tick. This will create a smooth rotation over
    time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, plug the output of our ScaleRotator node into the Delta Rotation input
    on the AddActorLocalRotation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We now have rotation! Obviously, there''s quite a bit more that can be done
    with the idea of hacking tools in *Server 17*, but this will work fine for our
    prototype stage. It looks as though this is finally coming together. There is
    one last gameplay element we still haven''t created  though: our level timer.'
  prefs: []
  type: TYPE_NORMAL
- en: Building the Timer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the world of *Server 17*, players hack corporate servers looking for valuable
    company secrets. However, those corporations don't just lie down and take it!
    Powerful system administrators, corporate hackers, and AI countermeasures mobilize
    to stop the player, giving them limited time to crack each server. To represent
    this in the game, we'll implement a level timer in the game that will cause the
    player to lose when it reaches zero. Since this is a only a prototype, we'll have
    the game quit when the timer is complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since this is a gameplay element independent of any level, we''ll build this
    feature in our custom game state. Head to our `Sever17\Blueprints` server and
    double-click the `S17GameState` to open it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4555d7fd-b068-4804-bf13-c6eeea193c38.png)'
  prefs: []
  type: TYPE_IMG
- en: Game timer code setup in the Game State
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: This feature makes user of the Timer system built into the Blueprint system.
    Using the SetTimerByEvent node, we can call a custom event when a timer (in seconds)
    completes. Start by creating a copy of the Event BeginPlay node and dragging an
    execute connection off the output. Search for the SetTimerByEvent node and select
    it from the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, create a Custom Event named `EndGame`. Connect this custom event to the
    Event input on SetTimerByEvent by dragging a connection from the square pin next
    to the custom event's name and connecting to the input pin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dragging off the EndGame event, search for the ExecuteConsoleCommand node. In
    the Command field, type in the command `quit`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To finish the sequence, we need to set a value for Time on SetTimerByEvent.
    To keep the system flexible, we'll create a variable for the game time that can
    easily be adjusted from outside the game state to take into account things such
    as level difficulty or story elements. Create a new `Float` variable and name
    it GameTime. Compile the blueprint and set the default value to 300\. Get a copy
    of it and connect it to the Time input on SetTimerByEvent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Awesome! Our intrepid players now have five minutes to complete our puzzle cube
    or be kicked out of the game. Feel free to adjust the default value of GameTime
    to whatever feels appropriate for your players or to adjust the challenge for
    yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wow! What a ride. We began this chapter with some interesting discussions about
    gameplay and ended it with creating a whole game prototype from scratch! In this
    chapter, we explored the many different types of gameplay that successfully implement
    the mechanics that VR is uniquely capable of. Using that knowledge, we designed
    our game elements to take advantage of the near one-to-one translation of player
    movement into the game and the ability to have the player interact with the world
    from a true first-person perspective. Through the rest of this chapter, we built
    all of our systems from scratch from hand interactions to VR buttons, and even
    a puzzle box  for the player to solve within a time limit.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going to expand our gameplay by discussing the user
    experience we've created so far and how we can improve that experience through
    the use of user interfaces. We'll talk about the use and viability of 2D and 3D
    elements within our game world and what works best with VR. Using that knowledge,
    we'll design and build our own elements for use in *Server 17*.
  prefs: []
  type: TYPE_NORMAL
