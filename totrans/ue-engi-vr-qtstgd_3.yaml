- en: Exploring Riveting Gameplay in Virtual Reality
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索虚拟现实中的引人入胜的游戏玩法
- en: With our custom game files in place, it's time to start making some decisions
    about gameplay. In *Server 17*, the player takes on the role of a futuristic hacker
    trying to crack open a corporate server and plunder its secrets for personal gain.
    So, how might we present this in VR as an experience? Before we think about that,
    let's do a bit of research and discovery. The best way to learn which mechanics
    will challenge and entertain our players is to first look at the unique elements
    that VR brings to a game. After that, we can take a look at which titles are being
    played right now and why. Armed with that information, we can then make some decisions
    about how best to design our own gameplay for *Server 17*. We have a lot to discover,
    so let's get started!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的自定义游戏文件就绪后，是时候开始做出一些关于游戏玩法的决定了。在 *Server 17* 中，玩家扮演一个未来黑客的角色，试图破解企业服务器并为其个人利益窃取其秘密。那么，我们如何将这种体验在
    VR 中呈现出来呢？在我们思考这一点之前，让我们先做一些研究和探索。了解哪些机制将挑战和娱乐我们的玩家，首先需要看看 VR 带给游戏的独特元素。之后，我们可以看看现在正在玩哪些游戏以及为什么。有了这些信息，我们就可以做出一些关于如何最好地为
    *Server 17* 设计我们自己的游戏玩法的决定了。我们有很多东西要探索，让我们开始吧！
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What does VR bring to video games?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟现实（VR）给电子游戏带来了什么？
- en: Popular gameplay mechanics
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流行的游戏玩法机制
- en: Designing the gameplay for *Server 17*
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计 *Server 17* 的游戏玩法
- en: What does VR bring to video games?
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟现实（VR）给电子游戏带来了什么？
- en: VR is the new frontier in games and entertainment. It's able to put the player
    in the shoes of their favorite heroes, or in a front-row seat for some of their 
    favorite experiences. In most experiences, player movement is translated into
    near one-to-one movement inside the game—something that's usually impossible in
    traditional video games. VR also has the power to immerse our player in an alternate
    world and make them truly feel as if they're there. It's these special abilities
    that mark VR as the future of gaming.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟现实是游戏和娱乐的新前沿。它能够让玩家置身于他们最喜欢的英雄的鞋子中，或者坐在他们最喜欢的体验的前排座位上。在大多数体验中，玩家的移动被转换成游戏内的几乎一对一的移动——这在传统电子游戏中通常是做不到的。VR
    还能够将我们的玩家沉浸在一个不同的世界中，让他们真正感觉到自己就在那里。正是这些特殊能力标志着 VR 是游戏未来的标志。
- en: It's important to understand that the input and controls in VR can go beyond
    the locomotion methods that we discussed in the last chapter. Each controller
    for the Vive or Oculus brings at least six different buttons that can be mapped
    to different functions within a game. Each of these can then be combined with
    a location or specific player movement to create almost infinite variety. Let's
    take a look at some of the gunplay in Epic Game's *Robo Recall*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，在 VR 中的输入和控制可以超越我们在上一章中讨论的移动方法。Vive 或 Oculus 的每个控制器至少都有六个不同的按钮，可以映射到游戏中的不同功能。这些按钮中的每一个都可以与位置或特定的玩家移动相结合，创造出几乎无限的变化。让我们看看
    Epic Games 的 *Robo Recall* 中的枪战。
- en: In this game, you destroy robots with a variety of weapons that are holstered
    on the player. The character has a pair of pistols holstered at their hips and
    a second pair of weapons holstered at their shoulders. This seems simple enough,
    right? Where the designers utilized the advantages of VR was in the hand placement
    needed to use your weapons. The player has to reach down to their waist to grab
    a pistol or reach behind their shoulder to grab a weapon. This simple addition
    of hand location to the input to equip a gun adds to the immersion and visceral
    quality of the gameplay.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这款游戏中，玩家使用挂在玩家身上的各种武器来摧毁机器人。角色在臀部两侧别着一把手枪，在肩膀上别着另一对武器。这似乎很简单，对吧？设计师利用 VR 的优势在于使用武器的手部放置。玩家必须弯腰到腰部去抓一把手枪，或者伸手到肩膀后面去抓武器。这种简单地将手部位置添加到装备枪械的输入中，增加了游戏玩法的沉浸感和直观性。
- en: Popular gameplay mechanics
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流行的游戏玩法机制
- en: 'In the last few years, many developers have embraced VR technology as their
    chosen medium. This has lead to a variety of VR games spanning many different
    genres and ideas. Each game has approached the input and immersion that VR brings
    in their own way. Some, such as Bethesda and ID Software, chose to use the technology
    to bring their blockbuster games *Fallout 4* and *Doom* into the VR era (to mixed
    reviews). Others have found more success building their game specifically for
    the medium, such as Beat Games'' *Beat Saber,* and Schell Games'' *I Expect You
    To Die*. For our research into what might work for *Server 17*, we''re going to
    look at seven different types of gameplay:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，许多开发者将VR技术作为他们首选的媒介。这导致了各种不同类型和想法的VR游戏。每款游戏都以自己的方式处理VR带来的输入和沉浸感。一些，如Bethesda和ID
    Software，选择使用这项技术将他们的热门游戏*《辐射4》*和*《毁灭战士》*带入VR时代（评价褒贬不一）。其他人则发现为该媒介专门制作游戏更为成功，例如Beat
    Games的*《节奏光剑》*和Schell Games的*I Expect You To Die*。为了研究什么可能适用于*《服务器17》*，我们将研究七种不同的游戏玩法：
- en: Shooter experiences
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 射击体验
- en: Action/adventure experiences
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动作/冒险体验
- en: Vehicle experiences
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 车辆体验
- en: Physics-based experiences
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于物理的体验
- en: Puzzle experiences
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 智力挑战体验
- en: Rhythm experiences
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节奏体验
- en: Educational experiences
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 教育体验
- en: Shooter experiences
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 射击体验
- en: In the last year, more than a dozen of the top 25 VR titles sold on Valve's
    Steam download service fell into the shooter category. A shooter is defined as
    any game that includes gunplay as a major part of experience. Many variations
    on the shooter experience in VR take advantage of unique mechanics. Still near
    the top of the charts is *Robo Recall*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去一年中，Valve的Steam下载服务上销售的25款顶级VR游戏中，超过一打属于射击类别。射击游戏被定义为任何将枪战作为体验主要部分的游戏。许多VR射击体验的变体都利用了独特的机制。仍然位于排行榜前列的是*《机器人回忆》*。
- en: Epic Games was able to combine the frantic action of a wave shooter with the
    immersive environment and mechanics that VR can bring. Much of the gameplay centers
    around using your hands. *Robo Recall* uses interesting mechanics when it comes
    to arming yourself. Players grab their chosen weapons from holsters located at
    their waist and shoulders. Each one is filled with a variety of customized weapons,
    all great for scrapping the game's robot enemies. The grab mechanism is also applied
    to a specific brand of melee combat from *Robo Recall*. Player's can grab many
    robot enemies by a handle that's conveniently located in the center of their chest.
    Once grabbed, enemies can be ripped apart by grabbing limbs, thrown into other
    enemies, or held up as shields to protect yourself.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Epic Games能够将波射击的狂热动作与VR带来的沉浸式环境和机制相结合。大部分游戏玩法都集中在使用你的双手。*《机器人回忆》*在武装自己时使用了有趣的机制。玩家从腰间和肩膀上的皮套中抓取他们选择的武器。每个皮套都装满了各种定制的武器，非常适合与游戏中的机器人敌人战斗。抓取机制也应用于*《机器人回忆》*中的一种特定品牌近战战斗。玩家可以通过位于他们胸中心方便位置的把手抓住许多机器人敌人。一旦抓住，敌人可以通过抓住肢体、扔向其他敌人或举起作为盾牌来保护自己。
- en: '*Superhot VR* by Superhot Team is another game that takes gunplay to a whole
    new level. The game combines physics and shooting gameplay with their exclusive
    time mechanics to create a rare experience. Just about every object in its minimalist
    environments is a weapon in *Superhot VR*. These items can be thrown at an enemy
    to liberate their weapon, causing it to fly into the air so that it can be snatched
    up by the player. Combined with the fact that time only moves forward when you
    do, each level becomes a combat puzzle. Which enemy do you confront first? What
    weapon or object is available within arm''s reach? Each decision and movement
    is important for discovering the level''s solution, and progressing.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Superhot Team的*《超级热VR》*是另一款将枪战提升到全新水平的游戏。该游戏将物理和射击游戏玩法与它们独有的时间机制相结合，创造了一种罕见体验。在它的简约环境中，几乎每个物体都是*《超级热VR》*中的武器。这些物品可以被扔向敌人以解放他们的武器，使其飞入空中，然后被玩家抓起。结合时间只有在玩家行动时才会前进的事实，每个关卡都变成了一场战斗谜题。你首先面对哪个敌人？在手臂范围内有什么武器或物品可用？每个决定和动作对于发现关卡解决方案和进步都至关重要。
- en: The most important elements of a popular VR shooter are active gunplay combined
    with another unique mechanic. This can be grabbing, physics gameplay, or a particular
    locomotion mechanism. Other great examples in this category include *Sairento
    VR*, for its locomotion mechanic and combination of gun and swordplay, as well
    as *Damaged Core*, a game that has the player utilizing the ability to teleport
    from enemy to enemy, possessing them and using their weapons.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 流行VR射击游戏最重要的元素是结合了活跃的枪战和另一种独特的机制。这可以是抓取、物理游戏玩法或特定的移动机制。这个类别中其他优秀的例子包括*Sairento
    VR*，因其移动机制和枪战与剑术的结合，以及*Damaged Core*，这款游戏让玩家利用从敌人到敌人传送的能力，控制他们并使用他们的武器。
- en: Action/adventure experiences
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动作/冒险体验
- en: 'Action/adventure experiences combine combat experiences with exploration and
    story-based gameplay. These games feature impressive environments and visuals
    that take advantage of the fact that VR places the player directly into the game
    world. Yet, with such a large world in which to explore, designers must use artificial
    locomotion methods to allow the player to explore such a large space. For many
    players, the ability to experience the story firsthand outweighs any discomfort
    caused by using a thumbstick or snap turning for locomotion. In this category,
    the biggest contenders both come to us from *Bethesda Softworks : Fallout 4 VR
    and Skyrim VR*.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 动作/冒险体验将战斗体验与探索和基于故事的游戏玩法相结合。这些游戏拥有令人印象深刻的环境和视觉效果，利用了VR将玩家直接带入游戏世界的事实。然而，在这样一个广阔的世界中探索，设计师必须使用人工移动方法来允许玩家探索如此大的空间。对于许多玩家来说，亲身体验故事的能力超过了使用摇杆或快速转向进行移动带来的任何不适。在这个类别中，最大的竞争者都来自*Bethesda
    Softworks*：*Fallout 4 VR*和*Skyrim VR*。
- en: '*Fallout 4 VR* is a direct port of the popular 2015 title, redesigned to work
    with VR. Players travel the wasteland building settlements, crafting equipment,
    and experiencing the story from a first-person perspective. Combat is an in-your-face
    affair. The majority of the early enemies favor close combat, meaning there isn''t
    much of a chance for the player to use a firearm before their opponent is right
    on top of them. Luckily, melee combat is as simple as equipping the right weapon,
    or none at all, and swinging away. Ranged combat also feels good, though not nearly
    as satisfying as in a VR shooter. Still, *Fallout 4* ticks all of the right boxes.
    It''s an action/adventure experience that gives players a massive, awe-inspiring
    environment. In it, they may craft, build, and interact, as well as take part
    in a deep story with a variety of interesting characters.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*Fallout 4 VR*是2015年流行游戏的直接移植，重新设计以适应VR。玩家在荒野中建立定居点，制作装备，并以第一人称视角体验故事。战斗是直面敌人的。大多数早期敌人偏好近战，这意味着玩家在对手站在他们面前之前几乎没有使用枪械的机会。幸运的是，近战战斗就像装备正确的武器，或者根本不装备，然后挥舞武器一样简单。远程战斗感觉也不错，但远不如VR射击游戏中的那样令人满意。尽管如此，*Fallout
    4*还是满足了所有正确的条件。这是一次动作/冒险体验，为玩家提供了一个巨大、令人敬畏的环境。在这里，他们可以制作、建造和互动，还可以参与一个深刻的故事，故事中有各种有趣的角色。'
- en: Vehicle experiences
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 车辆体验
- en: Vehicle experiences solve the locomotion problem by placing the player at the
    helm of a ship, mech, or other method of travel and destruction. The brain processes
    it much the same as when we go for a ride in the car. We don't question that we're
    moving because we're sitting down and controlling the vehicle. This gives the
    designers the opportunity to give players a vehicle-piloting experience. There
    are many great examples in this space. However, I want to give you one that represents
    some of the best gameplay in this category, Frontier Developments' *Elite Dangerous*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 车辆体验通过让玩家驾驶船只、机甲或其他旅行和破坏方式来解决移动问题。大脑处理方式与我们在车内驾驶时几乎相同。我们不会质疑我们在移动，因为我们坐着并控制着车辆。这给了设计师机会为玩家提供驾驶体验。这个领域有许多优秀的例子。然而，我想给你一个代表这个类别中最好游戏玩法的例子，那就是Frontier
    Developments的*Elite Dangerous*。
- en: The most current entry in the *Elite* saga is a space adventure, combat, and
    trading sim that puts the player in the role of an elite commander. Players earn
    money, rank, and influence with the major factions of a one-to-one, open-world
    version of our Milky Way galaxy. The game can be played without VR hardware, but
    it truly shines when the player dons the headgear. When played in VR, the player
    is able to see the inside of the ship and see their own customized player character
    sitting at the helm.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*精英*系列最新作品是一部太空冒险、战斗和贸易模拟游戏，玩家将扮演一名精英指挥官。在银河系一对一、开放世界的版本中，玩家可以通过与主要势力的互动赚取金钱、提升等级和扩大影响力。游戏无需VR硬件即可游玩，但玩家戴上头戴式设备后，游戏体验将更加出色。在VR模式下，玩家能够看到飞船内部，并看到自己定制的玩家角色坐在驾驶舱中。'
- en: Navigating the systems and menus of the ship becomes easier as menus open with
    a glance. Combat and piloting become effortless, since the player can look through
    the canopy of their ship to help track their location. All of these VR-specific
    features add depth to an amazing experience as the players fight, trade, and explore
    their way to fortune and fame within the game world.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 随着菜单通过一瞥即可打开，操作飞船的系统和管理菜单变得更加容易。战斗和驾驶变得轻松自如，因为玩家可以通过查看飞船的机舱来帮助追踪自己的位置。所有这些VR特有的功能都为玩家在游戏世界中战斗、交易和探索以获得财富和名声的体验增添了深度。
- en: The addition of an internal ship environment, customizable player character,
    and eye tracking-based menus are only possible thanks to the first-person perspective
    that VR provides. Being able to see themselves in the interior of their vehicle
    connects the player to their surroundings. This makes them feel as if they're
    a living part of the game. Whether it's racing in a tricked-out high-performance
    street car or fighting aliens in the depths of space, the player's vehicle-piloting
    experience is enhanced by the VR perspective.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 内置飞船环境、可定制的玩家角色和基于眼动追踪的菜单，都得益于VR提供的第一人称视角。能够在车辆内部看到自己，使玩家与周围环境产生了联系。这让他们感觉自己像是游戏中的活生生的一部分。无论是驾驶改装的高性能赛车比赛，还是在太空深处与外星人战斗，VR视角都增强了玩家的驾驶体验。
- en: Physics-based experiences
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于物理的体验
- en: Not as well known in the gaming world, physics-based games take advantage of
    the player's ability to aim and throw objects using a standing or room-space experience.
    This goes beyond simply picking up and throwing everyday objects, such as the
    gameplay found in *Superhot VR*. It takes advantage of a game engine's ability
    to simulate real-world physics to create gameplay. In this genre, the games tend
    to take the form of phyiscs-based fighting games and physics puzzle games. Let's
    take a look at the physics-based combat game, *Gorn*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏世界中，基于物理的游戏并不像其他游戏那样广为人知，它们利用了玩家使用站立或房间空间体验瞄准和投掷物体的能力。这不仅仅局限于简单地捡起和扔日常物品，如*Superhot
    VR*中的游戏玩法。它们利用游戏引擎模拟真实世界物理的能力来创造游戏玩法。在这个类型中，游戏通常以基于物理的格斗游戏和物理解谜游戏的形式出现。让我们来看看基于物理的格斗游戏*Gorn*。
- en: '*Gorn*, from Devolver Digital, casts the player as a gladiator fighting for
    the amusement of several large-headed patrons. The game features cartoon-style
    art and violence, centered around comical physics-based brawling. Each round starts
    with the player entering the arena, sometimes with a selection of weapons and
    sometimes unarmed. The rules are simple: knock out the other guys before they
    do the same to you. The fun comes when the player picks a weapon to use. As the
    game translates their movement into the game world, it adds a bit of cartoon physics.
    Movements become exaggerated. Weapons feel as if they''re made of foam or rubber,
    making combat a strange affair. Together, these features come together to create
    a brawling experience that feels visceral and absurd at the same time. *Gorn*
    is currently available for HTC Vive, Oculus Rift, and PlayStation VR.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Devolver Digital的*Gorn*让玩家扮演一名角斗士，为几个大头颅的观众提供娱乐。游戏采用卡通风格的艺术和暴力元素，围绕基于物理的打斗展开。每一轮开始时，玩家进入竞技场，有时可以选择武器，有时则赤手空拳。规则很简单：在别人击败你之前先击败他们。乐趣在于玩家选择使用的武器。当游戏将他们的动作转换到游戏世界中时，会加入一些卡通物理元素。动作变得夸张。武器感觉像是泡沫或橡胶制成的，使得战斗变得既奇特又荒谬。这些特点共同创造了一种既直观又荒诞的打斗体验。*Gorn*目前可在HTC
    Vive、Oculus Rift和PlayStation VR上玩。
- en: In contrast to the fighting gameplay of *Gorn* is the physics-based puzzler, *Bounce*.
    *Bounce*, developed by Steel Wool Studios, has the player helping a ball-shaped
    robot navigate the corridors of an intergalactic spaceship. Players are given
    an array of physics gadgets designed to propel their robot friend from one side
    of the level to the exit portal. To get there, the robot must navigate around
    laser walls, gravity wells, and other sci-fi obstructions. Beating the game unlocks
    style mode. This allows the player to play each of the game's 50 levels again
    and rewards them for the most creative solutions.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 与*Gorn*的战斗游戏玩法形成对比的是基于物理的拼图游戏*Bounce*。由Steel Wool Studios开发的*Bounce*让玩家帮助一个球形机器人穿越星际飞船的走廊。玩家被赋予了各种物理装置，旨在推动他们的机器人朋友从关卡的一侧到达出口传送门。为了到达那里，机器人必须绕过激光墙、重力井和其他科幻障碍。通关游戏解锁风格模式。这允许玩家再次玩游戏的50个关卡，并奖励他们最富有创意的解决方案。
- en: In both games, we can again see the unique movement mechanic and first-person
    perspective often seen in VR, used to great effect. *Gorn* uses player arm movement
    with cartoon physics to create a gaming experience that feels fun and intense.
    In contrast, *Bounce* uses the first-person perspective to allow the player see
    what placing a particular physics gadget will do when the ball hits it. This gives
    the player the ability to see firsthand the effects of their actions and allows
    the player to feel more in control of the experience.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两款游戏中，我们再次看到了在VR中经常看到的独特移动机制和第一人称视角，它们被有效地运用。*Gorn*使用玩家的手臂动作和卡通物理来创造一种既有趣又紧张的游戏体验。相比之下，*Bounce*使用第一人称视角，让玩家看到当球体撞击特定的物理装置时会发生什么。这给了玩家亲身体验他们行动效果的能力，并让玩家感觉更能控制体验。
- en: Puzzle experiences
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拼图体验
- en: With their use of object manipulation as a major mechanism and often fantasy
    environments, puzzle experiences lend themselves very well to the VR treatment.
    Since the time of *Myst* and it's sequels, players have shown time and again that
    they love solving the mysteries of ancient ruins, dark dungeons, and castles in
    the sky. However, until now, players haven't been able to truly reach eye level
    with some of these puzzles and environments, which can make solving problems where
    you have to aim a laser or shoot a bow much harder. Take as an example the laser
    puzzles from the game *The* *Talos Principle VR* by Croteam, a port of the popular
    puzzle game from 2014\. Players are required in several puzzles to use a device
    to bend a laser beam to hit a particular target. Some players have reported that
    this task is considerably easier in VR due to their ability to bend down and see
    where the laser will travel from eye level.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们使用物体操作作为主要机制，并且常常是幻想环境，拼图体验非常适合VR体验。自*Myst*及其续作以来，玩家一次又一次地表明他们喜欢解决古老遗迹、黑暗地牢和天空中的城堡的谜题。然而，直到现在，玩家还没有真正能够与一些这些谜题和环境达到眼平视的高度，这可能会使得需要瞄准激光或射箭的问题解决变得更加困难。以Croteam开发的2014年流行的拼图游戏*The*
    *Talos Principle VR*中的激光谜题为例。在几个谜题中，玩家需要使用设备弯曲激光束以击中特定的目标。一些玩家报告称，由于他们能够弯腰并从眼平视的高度看到激光的路径，这项任务在VR中要容易得多。
- en: Another great example of VR principles applied to puzzle gameplay can be found
    in the standout title *I Expect You to Die* by Schell Games. In this game, the
    player takes on the role of a telekinetic super spy, charged with completing various
    missions to defeat the evil Zoraxis Organization. Each of the five locations in
    the game feels a bit like an escape room. The player is given the task of escaping
    the area and must use the tools they find to complete the mission. For instance,
    the first mission of the game has the player tasked with driving the evil Dr.
    Zor's weaponized car out of the back of a cargo plane while the plane is slowly
    filling with poison gas and using only the tools found in the car or dismantled
     ones from the car's many attempts to kill you. The game gets around the locomotion
    issue by giving the player the choice of making it a sitting or room-scale experience
    and by giving the player telekinesis so they never have to move. Together, the
    game uses the uniqueness of VR and creativity to great effect to create an experience
    that has players singing its praises.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个将VR原则应用于解谜游戏的杰出例子可以在Schell Games的突出作品*I Expect You to Die*中找到。在这款游戏中，玩家扮演一个心灵感应超级间谍的角色，负责完成各种任务以击败邪恶的Zoraxis组织。游戏中的五个地点中的每一个都让人感觉有点像逃脱室。玩家被赋予逃离该地区的任务，必须使用他们找到的工具来完成使命。例如，游戏的第一项任务要求玩家在飞机慢慢充满毒气的同时，驾驶邪恶的Dr.
    Zor的武器化汽车从货机的后面开出去，而飞机上只有汽车或从汽车多次试图杀死你而拆卸的工具。游戏通过让玩家选择将其作为坐着或房间规模体验，以及赋予玩家心灵感应能力，使他们永远不必移动，来解决运动问题。游戏利用VR的独特性和创造力，创造出一种让玩家赞不绝口的体验。
- en: Rhythm experiences
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 节奏体验
- en: In many ways, VR mechanics are breathing new life into the game genres that
    we love. This is especially true of rhythm games whose basic gameplay mechanics
    of *press this button at this time* seem old by today's standards. However, the
    application of VR-specific gameplay mechanics such as one-to-one arm movement
    have revitalized the genre and given rise to several unique rhythm experiences.
    At the top of that list is certainly *Beat Saber*, developed and published by
    Beat Games.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多方面，VR机制正在为我们所爱的游戏类型注入新的活力。这尤其适用于节奏游戏，其基本的游戏玩法机制“在这个时间按这个按钮”在今天看来似乎已经过时了。然而，VR特定的游戏玩法机制，如一对一的手臂运动的应用，使这个类型焕发了新生，并催生了几个独特的节奏体验。其中最突出的无疑是Beat
    Games开发和发布的*Beat Saber*。
- en: '*Beat Saber* combines rhythm gameplay with VR saber combat to create a unique
    title that has players swinging virtual red and blue energy sabers to hit the
    corresponding color blocks in time with the music. Players must strike the blocks
    with the correct color saber at the correct angle while ducking and dodging wall
    obstacles  and mines that shouldn''t be hit. All of this action is set to the
    tempo of the song. With a variety of tracks and difficulty settings, *Beat Saber*
    sets a new standard for rhythm experiences in the age of VR. In this game, we
    see two types of gameplay collide: VR combat (swinging at stuff and dodging) and
    rhythm mechanics. The combination creates an almost dancing experience that makes
    it easy to enjoy. Though be prepared for a workout even if you''re playing this
    as a seated experience, as some of the songs get very energetic at times.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*Beat Saber* 将节奏游戏与VR光剑战斗相结合，创造了一个独特的游戏，玩家需要挥舞虚拟的红蓝能量光剑，在音乐的节奏下击中相应的颜色方块。玩家必须用正确的颜色光剑以正确的角度击中方块，同时躲避墙壁障碍和不应该击中的地雷。所有这些动作都随着歌曲的节奏进行。凭借各种曲目和难度设置，*Beat
    Saber* 为VR时代的节奏体验设定了新的标准。在这款游戏中，我们看到两种游戏玩法相互碰撞：VR战斗（挥击和躲避）和节奏机制。这种结合创造了一种几乎像跳舞一样的体验，让人容易享受。尽管如果你以坐着的方式玩这款游戏，也要做好锻炼的准备，因为有些歌曲有时会非常充满活力。'
- en: Educational experiences
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 教育体验
- en: 'Since its inception, educators have been interested in VR as a way to instruct
    and train the next generation in a way that''s engaging and allows the learner
    to see the material from a new perspective. New generations of students are looking
    for education institutions to embrace technology while providing a unique and
    experiential style of learning. To meet this demand, education software developers,
    college development teams, and even some game developers have begun creating VR
    experiences that allow students to experience history close up or to learn to
    use high-end equipment without fear of hurting themselves. Besides immersion and
    unique mechanics, VR can allow those who wish to learn something that takes expensive
    equipment or rare resources the opportunity to do so. Here are some of the titles
    currently available:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 自其诞生以来，教育工作者一直对VR作为教授和培训下一代的一种引人入胜的方式感兴趣，并允许学习者从新的视角看待材料。新一代的学生正在寻找教育机构拥抱技术，同时提供独特和体验式的学习风格。为了满足这一需求，教育软件开发者、大学发展团队，甚至一些游戏开发者已经开始创建VR体验，让学生能够近距离体验历史或学习使用高端设备而无需担心受伤。除了沉浸感和独特的机制外，VR还可以为那些希望学习需要昂贵设备或稀有资源的人提供机会。以下是目前可用的部分标题：
- en: '*The Body VR: Journey Inside a Cell*: This game uses the immersion of VR to
    allow the player to experience traveling in the bloodstream of a human being and
    enter a blood cell to see the inner workings at the cellular level.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*The Body VR: Journey Inside a Cell*：这款游戏利用VR的沉浸感，让玩家体验在人体血液中旅行并进入血细胞，以观察细胞层面的内部运作。'
- en: '*Sharecare VR*: This application allows the player to explore the anatomy of
    the human body, simulate disease, and show how treatment interacts with the body.
    Players can also call up specific organs and enable the display of tags to show
    specific structures. This allows players to learn and study the human anatomy
    in ways that weren''t possible previously.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Sharecare VR*：这款应用程序允许玩家探索人体解剖学，模拟疾病，并展示治疗如何与身体相互作用。玩家还可以调用特定的器官，并启用显示标签以显示特定结构。这允许玩家以前所未有的方式学习和研究人体解剖学。'
- en: '*Apollo 11 VR*: *Apollo 11* combines a passive viewing experience with occasional
    mini games to allow the player to live the Apollo 11 mission firsthand.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Apollo 11 VR*：*阿波罗11号*结合了被动观看体验和偶尔的小游戏，让玩家亲身体验阿波罗11号任务。'
- en: I also want to mention *Tribe XR* here. Though the developers have chosen to
    teach users how to DJ using high-end equipment, the goal is to create a creative
    education platform that can be used to teach many skills and take advantage of
    what they refer to as exponential learning. As part of the plan for their platform,
    they're allowing vetted users, in this case other DJs, to teach those new to the
    platform both in recorded and live lessons. This mechanism has amazing potential
    for revolutionizing how schools and businesses teach and train their students.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我还想在这里提及 *Tribe XR*。尽管开发者选择教授用户如何使用高端设备进行DJ，但目标是创建一个可以用来教授多种技能并利用他们所说的指数学习法的创意教育平台。作为他们平台计划的一部分，他们允许经过审查的用户，在这种情况下是其他DJ，通过录制和现场课程教授那些新加入平台的人。这种机制有巨大的潜力改变学校和企业在教学和培训学生方面的方式。
- en: VR has the ability to bring the user into the game worlds that we create and
    turn their movements into real in-game action. These two unique features have
    the potential to revolutionize how players enjoy video games and create new avenues
    for designers to express themselves creatively. However, we need to make sure
    that these new techniques for creating interaction within game worlds to become
    a crutch that props up poor design. Like the graphics advances of the early 20's,
    we mustn't let VR become a novelty and an excuse for bad games.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: VR有能力将用户带入我们创造的虚拟游戏世界，并将他们的动作转化为真实的游戏动作。这两个独特功能有潜力彻底改变玩家享受电子游戏的方式，并为设计师创造新的创造性表达途径。然而，我们需要确保这些在游戏世界中创建交互的新技术不会成为支撑糟糕设计的拐杖。就像20年代初期的图形进步一样，我们绝不能让VR成为一种新奇的借口，为糟糕的游戏开脱。
- en: Designing the gameplay for Server 17
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计服务器17的游戏玩法
- en: Now that we've discovered some of the great VR games that our potential users
    are playing and dug deep into how VR helps to make them unique, let's look at
    how VR can really make the experience that lets *Server 17* shine. This is where
    we move from the Discovery and Empathy phases of our design process into the Ideate
    phase. Ideate is where the magic happens and where ideas are brainstormed and
    transformed into something more. For our user (first-time VR user, sci-fi fan,
    and nostalgic), we need to take into account that their status as first time users
    will mean that a basic locomotion scheme is important. We also want to make sure
    that the gameplay is intuitive and easy to learn. Current VR controllers are capable
    of several button-based functions, but we'll want to keep our control scheme simple
    to lower the learning curve and make our game accessible. Lastly, we want to make
    our environment simple yet really embrace the cyberpunk and future aesthetic.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经发现了一些我们潜在用户正在玩的优秀VR游戏，并深入了解了VR如何使它们变得独特，让我们来看看VR如何真正让“服务器17”这个体验熠熠生辉。这就是我们从设计过程的发现和同理心阶段过渡到构思阶段的地方。构思阶段是魔法发生的地方，也是想法被头脑风暴并转化为更具体事物的地方。对于我们的用户（第一次使用VR的用户、科幻迷和怀旧者），我们需要考虑到他们作为新用户的事实意味着基本移动方案很重要。我们还想确保游戏玩法直观且易于学习。当前的VR控制器能够实现多种基于按钮的功能，但我们将保持我们的控制方案简单，以降低学习曲线并使我们的游戏易于接触。最后，我们希望我们的环境简单，同时真正融入赛博朋克和未来美学。
- en: 'With these things in mind, let''s design. To keep locomotion easy and minimize
    VR sickness, we can use teleportation while keeping the gameplay area small. This
    will have the added benefit of playing into our cyberpunk background and the fact
    that the game level is meant to take place in a form of VR itself. We''ll have
    the player press buttons and manipulate objects using some avatar hands. This
    allows us to make the gameplay as natural as possible, as well as making it easy
    to grasp quickly (pun intended). Gameplay will be centered around hacking a corporate
    server, reimagined as a techy-looking puzzle box in the center of the room that
    the player will have to solve by grasping parts to push and slide. We also want
    to provide the player with some special tools to speed the process up. These tools
    will be provided at different tool stations spread around the virtual room that
    represents the inside of the player''s computer. Finally, to represent the danger
    of being discovered, the player will have to complete the puzzle box within a
    certain time frame. Here is a rough idea of the level:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些因素，让我们开始设计。为了使移动简单并最大限度地减少VR不适，我们可以在保持游戏区域较小的情况下使用传送。这将带来额外的优势，即与我们的赛博朋克背景以及游戏关卡意在以VR形式进行的事实相契合。我们将让玩家按下按钮并使用一些虚拟手来操作物体。这使我们能够使游戏玩法尽可能自然，同时使其易于快速掌握（有意为之）。游戏玩法将围绕破解企业服务器展开，重新构想为房间中央一个看起来很科技的谜题盒，玩家将通过抓住部分来推动和滑动来解决问题。我们还希望为玩家提供一些特殊工具来加快这个过程。这些工具将分布在代表玩家电脑内部的虚拟房间中的不同工具站上。最后，为了表示被发现的危险，玩家必须在一定时间内完成谜题盒。以下是关卡的一个粗略想法：
- en: '![](img/f1fa23a9-23b1-4cf5-8d42-23d01a5018ba.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f1fa23a9-23b1-4cf5-8d42-23d01a5018ba.png)'
- en: Level map with design markings
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 带有设计标记的水平地图
- en: Now, your instinct might be next to decide on the art style or to start making
    static meshes and shaders. Resist that urge! Despite the fact that the design
    sounds fun on paper, we don't know whether all of the features will work as intended
    or whether they're even as fun as we think they'll be. To test our assumptions,
    we need to move to the prototype stage of our design process and build a quick
    functional mock up and have our user test it to gain feedback. That way, we don't
    waste time or resources on game elements we might not use.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你的直觉可能是在决定艺术风格或开始制作静态网格和着色器。抵制这种冲动！尽管在设计纸上听起来很有趣，但我们不知道所有功能是否都能按预期工作，或者它们是否真的像我们想象的那样有趣。为了测试我们的假设，我们需要进入设计过程的原型阶段，快速构建一个功能原型，并让用户测试以获取反馈。这样，我们不会在可能不使用的游戏元素上浪费时间和资源。
- en: We'll start by implementing the hands.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从实现手部功能开始。
- en: Adding the hand functionality
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加手部功能
- en: We want the player's experience with their in-game representation to be as smooth
    and as seamless as possible. To that end, the hand solution we implement needs
    to be able to do a few different things. First, the player needs to be able to
    see the hands. Second, the player needs to be able to know which objects can be
    interacted with and which ones might simply be there as scenery. Third, the player
    needs to be able to grab, pick up, and potentially throw objects that we want
    them to interact with. Fourth, we need the player to be able to press buttons
    inside the level to utilize the tools found at the different tool stations and
    to solve the puzzle cube.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望玩家在游戏中的表现尽可能平滑和无缝。为此，我们实施的解决方案需要能够完成几件事情。首先，玩家需要能够看到手。其次，玩家需要能够知道哪些物体可以交互，哪些可能只是作为场景存在。第三，玩家需要能够抓取、拿起，并可能抛出我们希望他们与之交互的物体。第四，我们需要玩家能够按下关卡内的按钮，以利用在不同工具站找到的工具，并解决拼图立方体。
- en: 'The first step in following our design is to add the hand models to our `Server17PlayerPawn`
    to give our player a representation of themselves in the game. To do this, we''ll
    add the standard hands provided for us by Epic Games to our pawn:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 跟随我们的设计的第一步是将手部模型添加到我们的`Server17PlayerPawn`中，以便我们的玩家在游戏中有一个自己的代表。为此，我们将添加Epic
    Games为我们提供的标准手部模型到我们的pawn中：
- en: '![](img/03daea4b-be39-4c19-a297-23ace88d7d62.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/03daea4b-be39-4c19-a297-23ace88d7d62.png)'
- en: Hands added in the Class Blueprint screen
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在类蓝图屏幕中添加的手部
- en: 'Here''s how we add the hands:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们添加手部的步骤：
- en: To have the hand meshes read the position of the player's motion controls, we'll
    start by adding a skeletal mesh component that's attached to the MotionController_L
    component in our pawn. Click on the MotionController_L component, and then click
    the Add Component button at the top of the Components panel. Select the Skeletal
    Mesh option and name the new component `SkeletalMesh_L`.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让手部网格读取玩家运动控制器的位置，我们首先在我们的pawn中添加一个附加到MotionController_L组件的骨骼网格组件。点击MotionController_L组件，然后点击组件面板顶部的添加组件按钮。选择骨骼网格选项，并将新组件命名为`SkeletalMesh_L`。
- en: In the Details panel, find the Skeletal Mesh drop-down menu and select the MannequinHand_Right.
    This will add the hand to the end of the player's motion controller.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在详细信息面板中，找到骨骼网格下拉菜单，并选择MannequinHand_Right。这将把手添加到玩家的运动控制器末端。
- en: Since the hand is meant to be a right hand, we need to change a few settings
    to make it work correctly as a left hand. Find the Transform portion of the Details
    panel and change the X field of the Location property to -10\. This will align
    the mesh more with where the player's physical hand is on the controller and will
    feel more natural.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于手部是为了作为右手设计的，我们需要更改一些设置，使其正确地作为左手工作。在详细信息面板中找到变换部分，并将位置属性的X字段更改为-10。这将使网格与玩家在控制器上的物理手更对齐，感觉更自然。
- en: Move down to the Rotation property and change the X value to 90 degrees. This
    rotates the hand to a more natural position.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向下移动到旋转属性，并将X值更改为90度。这将使手旋转到更自然的位置。
- en: Move down one more property to the Scale property, and change the Z value to
    -1\. This will flip the orientation of the hand to truly represent a left hand.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向下移动一个属性到缩放属性，并将Z值更改为-1。这将翻转手的朝向，真正地代表左手。
- en: With the left hand complete, repeat steps one through four to create the right
    hand and name it `MotionController_R`.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 左手完成之后，重复步骤一至四来创建右手，并将其命名为`MotionController_R`。
- en: 'If we test now, we can see that the player pawn now has hands! Wave them in
    the air like you just don''t care. However, they don''t really do much other than
    look plastic, yet well manicured. Let''s start to give them some functionality
    with the edition of some collision shapes so we can record when they overlap with
    an object. Let''s start with the left hand:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在测试，我们可以看到玩家pawn现在有了手！像你不在乎一样在空中挥舞它们。然而，它们实际上并没有做什么，除了看起来像塑料，但打理得很好。让我们开始通过添加一些碰撞形状来赋予它们一些功能，这样我们就可以记录它们与物体重叠时的情况。让我们从左手开始：
- en: Select the MotionController_L component and navigate to the Add Component menu.
    Find the Sphere Collision component under the Collision section of the drop-down
    menu and select it. Name it `Sphere_L`.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择MotionController_L组件，并导航到添加组件菜单。在下拉菜单的碰撞部分找到Sphere Collision组件，并选择它。将其命名为`Sphere_L`。
- en: In the Details panel, change the sphere radius to 10\. This will define the
    area in which objects are considered overlapping with the player's hands.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在详细信息面板中，将球体半径更改为10。这将定义对象被认为与玩家的手重叠的区域。
- en: Repeat steps one and two to create a collision sphere for the right hand and
    name it `Sphere_R`.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤一和二以创建右手的一个碰撞球体，并将其命名为`Sphere_R`。
- en: Our hands are now set up to record overlap events so that we can manipulate
    objects in our game world. At this point, there are several actions we want these
    objects to perform. We want them to be able to detect when they're being looked
    at and when they're not. We also need them to know when we've performed some kind
    of action on them, an activated and a deactivated state. For this, we'll use something
    called a **Blueprint Interface**. A Blueprint Interface can be defined as a collection
    of one or more functions that can be assigned to objects that need to share data
    and functionality. It allows us to create a number of functions that each object
    that uses the interface can then define in a unique manner. In our game, we'll
    create an interface that contains all the functions that control how the hands
    manipulate gameplay objects.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的手现在已设置好以记录重叠事件，这样我们就可以在游戏世界中操纵对象。此时，我们希望这些对象执行几个动作。我们希望它们能够检测到它们被注视和未被注视的情况。我们还需要它们知道我们对它们执行了某种动作，即激活和未激活状态。为此，我们将使用一种称为**蓝图接口**的东西。蓝图接口可以被定义为可以分配给需要共享数据和功能的对象的一个或多个函数的集合。它允许我们创建许多函数，每个使用该接口的对象都可以以独特的方式定义这些函数。在我们的游戏中，我们将创建一个包含控制双手如何操纵游戏对象的全部功能的接口。
- en: '*Tribe XR* makes extensive use of Blueprint Interfaces to facilitate the creation
    and communication of its different user interfaces, since many of them share common
    elements. From the interface elements used to display music track information
    to the Options screen, they all have in common that they''re 2D interfaces projected
    on to 3D planes. As we''ll see from the following screenshot, creating a Blueprint
    Interface of common functions ahead of time can facilitate the creation of these
    menus:![](img/38d621c0-e383-461c-9d07-6511d4c23db1.png)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*Tribe XR*广泛使用蓝图接口来促进其不同用户界面的创建和通信，因为其中许多共享共同元素。从用于显示音乐曲目信息的界面元素到选项屏幕，它们都有一个共同点，即它们都是投影到三维平面上的二维界面。正如我们将在下面的屏幕截图中所看到的，提前创建一个通用函数的蓝图接口可以促进这些菜单的创建！![img/38d621c0-e383-461c-9d07-6511d4c23db1.png](img/38d621c0-e383-461c-9d07-6511d4c23db1.png)'
- en: The Blueprint Interface option in the right-click menu
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 右键菜单中的蓝图接口选项
- en: 'Start by creating a new Blueprint Interface:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个新的蓝图接口：
- en: Make sure we're in our `Sever17\Blueprints` folder. Right-click in the Content
    Broswer and navigate to the Create Advanced Asset section of the menu. Find the
    Blueprints option and select Blueprint Interface. Name it `ObjectInteractionInterface`.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保我们位于`Sever17\Blueprints`文件夹中。在内容浏览器中右键单击，并导航到菜单的创建高级资产部分。找到蓝图选项并选择蓝图接口。将其命名为`ObjectInteractionInterface`。
- en: Double-click `ObjectInteractionInterface` to open it.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击`ObjectInteractionInterface`以打开它。
- en: We'll need to create several functions here. Over on the right-hand side of
    the screen in the Functions section of the My Blueprints panel, click the plus
    (+) button to create a new function. Name it `TraceHitObject`. This will fire
    whenever our object is hit by a line trace from either the motion controller or
    the HMD, signifying that we're looking at it or interacting with it in some way.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在这里创建几个函数。在屏幕右侧的我的蓝图面板的函数部分，点击加号（+）按钮创建一个新函数。将其命名为`TraceHitObject`。每当我们的对象被运动控制器或HMD的线迹击中时，它就会触发，这表示我们正在以某种方式查看或与之交互。
- en: With our new function selected, look at the Details panel. This panel allows
    us to add input and output to our function to handle our data. Let's add an input
    named `Hit` and use the type Hit Result. Passing the hit data to the object allows
    us to access important information later.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择我们的新函数后，查看详细信息面板。此面板允许我们向我们的函数添加输入和输出以处理我们的数据。让我们添加一个名为`Hit`的输入，并使用击中结果类型。将击中数据传递给对象允许我们在以后访问重要信息。
- en: To finish the function, we need to add a Boolean output named Return. Unreal
    Engine reads a function without an output as an Event, which isn't what we want.
    To avoid this, we use a dummy Boolean variable to complete the function.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要完成函数，我们需要添加一个名为Return的布尔输出。虚幻引擎将没有输出的函数读取为事件，这不是我们想要的。为了避免这种情况，我们使用一个虚拟的布尔变量来完成函数。
- en: The next function we need to create will be able to read when a trace leaves
    the object, giving us additional options for functionality. Head back to the Functions
    section of the `MyBlueprint` panel and create another function. Name it `TraceLeaveObject`.
    Create an input variable called `Hit` of the Hit Result type. Finish the function
    by creating a Boolean output and name it `Return`.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个我们需要创建的函数将能够读取当痕迹离开对象时的情况，为我们提供额外的功能选项。返回到 `MyBlueprint` 面板的函数部分，并创建另一个函数。将其命名为
    `TraceLeaveObject`。创建一个名为 `Hit` 的输入变量，其类型为 Hit Result。通过创建一个布尔型输出并将其命名为 `Return`
    来完成函数。
- en: Now that the object can tell whether it's being looked at, let's take that functionality
    to the next level. It would be useful to have the object know what part of it's
    being looked at. We can do this by detecting the trace at the component level.
    Create a new function and name it `TraceHitComponent`. Just like our other functions,
    we need to create an input called `Hit` of the Hit Result type and an output called
    `Return` of the Boolean type.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在对象能够判断是否被注视，让我们将这一功能提升到下一个层次。让对象知道正在被注视的哪一部分将非常有用。我们可以通过在组件级别检测痕迹来实现这一点。创建一个新函数，并将其命名为
    `TraceHitComponent`。就像我们的其他函数一样，我们需要创建一个名为 `Hit` 的输入，其类型为 Hit Result，以及一个名为 `Return`
    的输出，其类型为布尔型。
- en: To be able to read what component is being hit, we need to also add another
    input. Create a second input named `Component` and make it be of the type Primitive
    Component. This way, we can pass in what specific component is being hit.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了能够读取被击中的组件，我们还需要添加另一个输入。创建第二个输入，并将其命名为 `Component`，使其类型为原始组件。这样，我们就可以传递被击中的特定组件。
- en: Let's finish this functionality. Create another function and name it `TraceLeaveComponent`.
    This should have the same inputs and outputs as the `TraceHitComponent`.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们完成这个功能。创建另一个函数，并将其命名为 `TraceLeaveComponent`。这个函数应该具有与 `TraceHitComponent`
    相同的输入和输出。
- en: Just a few more functions and we'll be finished! Let's create a function that
    can be called every frame to track the potential movement of an object. Create
    another function and name it `TraceMove`. This should have an input named `Hit`
    of the Hit Result type, and an output named `Return` of the Boolean type.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只需再创建几个函数，我们就能完成！让我们创建一个可以在每一帧调用的函数，以跟踪对象的潜在移动。创建另一个函数，并将其命名为 `TraceMove`。这个函数应该有一个名为
    `Hit` 的输入，其类型为 Hit Result，以及一个名为 `Return` 的输出，其类型为布尔型。
- en: '`TraceMove` needs one more change to make it function correctly. Since this
    is a function designed to be called every frame, performance is definitely a concern.
    To optimize this function, we''ll check two options. First, under the `Hit` input,
    click the little arrow next to the name of the variable and click the checkbox
    to make the function Pass-by-Reference. Passing by reference allows the `Hit`
    variable to be passed on by name without passing the value. Because we''re selecting
    to pass the variable in this manner, we need to select the Const option in the
    Graph section of the Details panel. If you can''t see the option, click the down
    arrow at the bottom of the section to expose the checkbox.'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TraceMove` 需要一个额外的更改才能正确工作。由于这是一个每帧调用的函数，性能肯定是一个考虑因素。为了优化这个函数，我们将检查两个选项。首先，在
    `Hit` 输入下，点击变量名称旁边的小箭头，然后点击复选框以使函数通过引用传递。通过引用传递允许 `Hit` 变量通过名称传递而不传递值。因为我们选择以这种方式传递变量，所以我们需要在详细信息面板的图形部分中选择常量选项。如果你看不到选项，请点击该部分底部的向下箭头以显示复选框。'
- en: Finally, let's create one more bit of functionality. We want to be able to activate
    and deactivate some kind of effect on an object. This covers a variety of potential
    scenarios, such as being able to turn a flashlight you picked up on and off. To
    create this effect, we need two more functions. First, create a new function and
    name it `TraceActivateDown`.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们再创建一点功能。我们希望能够激活和关闭对象上的某种效果。这涵盖了各种潜在场景，例如能够打开和关闭你捡起的闪光灯。为了创建这种效果，我们需要两个额外的函数。首先，创建一个新函数，并将其命名为
    `TraceActivateDown`。
- en: '`TraceActivateDown` will signify when a button has been pressed to activate
    the object. It needs two inputs. The first is named `Hit` and has a Hit Result type
    (so that a lot of great information is packed into a hit result). The second is
    named `Instigator` and is of the Pawn type. This way, we can pass in the Pawn
    that activated the object. Finish by creating an output named `Return` of the
    Boolean type.'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TraceActivateDown`将表示按下按钮以激活对象。它需要两个输入。第一个名为`Hit`，具有击中结果类型（这样就可以在击中结果中包含大量信息）。第二个名为`Instigator`，类型为兵种。这样，我们可以传递激活对象的兵种。最后，创建一个名为`Return`的布尔类型输出。'
- en: If `TraceActivateDown` represents a button press, then we need our final function
    for our interface to represent the release of that button. Create one final function
    named `TraceActivateUp`. This should have the same inputs and outputs as `TraceActivateDown`.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`TraceActivateDown`代表按钮按下，那么我们需要为我们的接口创建一个最终函数来表示该按钮的释放。创建一个名为`TraceActivateUp`的最终函数。这个函数应该具有与`TraceActivateDown`相同的输入和输出。
- en: 'With everything completed, your interface should look something like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 完成所有操作后，你的界面应该看起来像这样：
- en: '![](img/29a2c328-aeec-4a3b-ae12-3735ca8c44ce.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/29a2c328-aeec-4a3b-ae12-3735ca8c44ce.png)'
- en: The My Blueprint section of ObjectInteractionInterface
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对象交互接口的“我的蓝图”部分
- en: '`ObjectInteractionInterface` now encapsulates many of the functions we would
    want an object to be able to perform. However, many of them depend on being the
    target of a line trace to be able to operate. A **line trace** is a function that
    can be called that will draw a line from one point to another and report anything
    that''s hit by the line. Using that hit data, we can do all kinds of things! For
    instance, we can find the distance from the player to the object. We can act on
    the object to change color, emit sound, or other behaviors. We can even cause
    the object to delete itself if we wanted to. In shooter games, this is how direct-damage
    weapons, such as lasers, sniper rifles, or other weapons that don''t really have
    a projectile, work. Since our line trace will be checking where our player is
    looking and will likely be used to figure out where they can teleport, we''ll
    use a parabola, or curved line, rather than a straight line for our trace. To
    do this, we''ll create a custom component that can be added to our HMD or motion
    controller that projects the line trace:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`ObjectInteractionInterface`现在封装了我们希望对象能够执行的大多数函数。然而，许多函数依赖于成为线迹的目标才能操作。**线迹**是一个可以调用的函数，它将从一点绘制到另一点，并报告被线迹击中的任何东西。使用这些击中数据，我们可以做各种事情！例如，我们可以找到玩家到物体的距离。我们可以对物体进行操作以改变颜色、发出声音或执行其他行为。我们甚至可以导致物体删除自己。在射击游戏中，这是直接伤害武器，如激光、狙击步枪或其他没有实际弹丸的武器的工作方式。由于我们的线迹将检查玩家正在看的地方，并且可能会用来确定他们可以传送的地方，因此我们将使用抛物线或曲线而不是直线进行追踪。为此，我们将创建一个自定义组件，可以添加到我们的HMD或动作控制器中，以投射线迹：'
- en: '![](img/5a5ca50d-8920-4c4f-9734-7d35dd30fc11.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5a5ca50d-8920-4c4f-9734-7d35dd30fc11.png)'
- en: Created Interaction Component
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 创建交互组件
- en: 'We need to create a custom Scene Component that can be added to our custom
    pawn:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个自定义场景组件，可以添加到我们的自定义兵种中：
- en: In the Content Browser, right-click in the `Server17\Blueprints` folder and
    click the Blueprint Class option. In the bottom section of the Pick Parent Class
    window, search for Scene Component using the search box. Click it and then click
    the Select button. Name this new component `InteractionComponent`.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在内容浏览器中，在`Server17\Blueprints`文件夹中右键单击，然后点击蓝图类选项。在“选择父类”窗口的底部部分，使用搜索框搜索场景组件。点击它，然后点击选择按钮。将这个新组件命名为`InteractionComponent`。
- en: This new component is going to handle our line trace and any data that it collects.
    It'll then distribute the hit data through our interface to all of our interaction
    functions. Start by creating a new function by clicking the +Function button that's
    part of the My Blueprints panel. Name this new function `ParabolicLineTrace`.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个新组件将处理我们的线迹追踪以及它收集到的任何数据。然后，它将通过我们的接口将击中数据分发到所有交互函数。首先，通过点击“我的蓝图”面板中的+函数按钮创建一个新的函数。将这个新函数命名为`ParabolicLineTrace`。
- en: We calculate the parabolic curve by taking the direction the interaction component
    is facing and calculate the projected curve based on a fixed point in time and
    a speed value. The formula is *z = (t * v[z]) - (0.5 * g * t²)*, where *z* is
    the projected end of the arc in the *z* axis, *v* is the velocity, *g* is gravity,
    and *t* is time. The distance the arc will cover is estimated by *y = t * v[y]*
    where *y* is the end of the arc in the *y* axis. To have our function calculate
    our arc, it'll need three inputs. The first is named `Steps` and has a type of
    Integer. The second is named `TimeStep`, which is a Float value. Last, we have
    `Speed` of the Float type.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过获取交互组件面向的方向并基于固定时间和速度值计算投影曲线来计算抛物线曲线。公式是 *z = (t * v[z]) - (0.5 * g * t²)*，其中
    *z* 是 *z* 轴上弧线的投影终点，*v* 是速度，*g* 是重力，*t* 是时间。弧线将覆盖的距离通过 *y = t * v[y]* 来估算，其中 *y*
    是 *y* 轴上弧线的终点。为了使我们的函数计算弧线，它需要三个输入。第一个名为 `Steps`，类型为整数。第二个名为 `TimeStep`，是一个浮点值。最后，我们有
    `Speed`，类型为浮点。
- en: If you don't understand the math, don't worry! The arc it creates is perfect
    for estimating the final location of our future teleport. Once complete, Unreal
    Engine 4 will be able to visually represent our line trace to us, and it'll make
    sense.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不懂数学，不用担心！它创建的弧线非常适合估算我们未来传送的最终位置。一旦完成，Unreal Engine 4 将能够为我们直观地表示线迹，这将变得有意义。
- en: Double-click on our new function to open it. `ParabolicLineTrace` needs six
    local variables to work. Find the Local Variables section at the bottom of the
    My Blueprints panel. Click the +Local Variable button and create a new variable
    named Init Loc of the type Vector. Next, create one named Prev Loc, also of the
    type Vector. These will store the initial locations for our curve calculation.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击我们的新函数以打开它。`ParabolicLineTrace` 需要六个局部变量才能工作。在 My Blueprints 面板的底部找到局部变量部分。点击
    +Local Variable 按钮并创建一个名为 Init Loc 的新变量，类型为 Vector。接下来，创建一个名为 Prev Loc 的变量，类型也是
    Vector。这些将存储我们曲线计算的初始位置。
- en: Create another local variable named `Velocity` of the type Vector. This is our
    speed value.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个名为 `Velocity` 的局部变量，类型为 Vector。这是我们的速度值。
- en: Now we need two local variables to handle our time calculation. Create two new
    local variables named `InTimeStep` of the type Float and In Steps of the type
    Integer.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要两个局部变量来处理我们的时间计算。创建两个新的局部变量，名为 `InTimeStep`，类型为 Float，以及名为 In Steps，类型为
    Integer。
- en: 'This is the last one! We need one more local variable to hold the hit data
    from the line trace. Create one final local variable named `TempHit` and make
    sure its type is set to Hit Result:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是最后一个了！我们需要一个额外的局部变量来存储从线迹获取的命中数据。创建一个名为 `TempHit` 的最终局部变量，并确保其类型设置为命中结果：
- en: '![](img/38982226-4f8d-42f4-8b7d-a6e3469824ad.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/38982226-4f8d-42f4-8b7d-a6e3469824ad.png)'
- en: Setting up the variables in the Parabolic Line Trace
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在抛物线线迹中设置变量
- en: With all of our variables finally set up, we can move on to creating our curve
    calculation.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于设置好了所有变量，现在可以继续创建曲线计算了。
- en: The first step in our function is to store our location data. From your Local
    Variables section, drag in a copy of your `InitLoc` variable and choose Set. Do
    the same for your `PrevLoc` variable. Connect the execute output of the beginning
    of the function to the input on Init Loc. Connect the execute output on Init Loc
    to the input on Prev Loc.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们函数的第一步是存储我们的位置数据。从你的局部变量部分，拖入一个 `InitLoc` 变量的副本并选择设置。同样，对你的 `PrevLoc` 变量也这样做。将函数开始处的执行输出连接到
    Init Loc 的输入。将 Init Loc 的执行输出连接到 Prev Loc 的输入。
- en: Now we need to fill them with data. We need to start by knowing the location
    of the interaction component within the game world. Right-click in the blueprint
    window or use the Palette to grab a GetWorldLocation node. Connect the output
    of our new node into the Init Loc vector input, and then connect the vector output
    on Init Loc to the vector input on Prev Loc.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要填充它们的数据。我们首先需要知道交互组件在游戏世界中的位置。在蓝图窗口中右键单击或使用调色板获取 GetWorldLocation 节点。将我们新节点的输出连接到
    Init Loc 向量输入，然后将 Init Loc 的向量输出连接到 Prev Loc 的向量输入。
- en: Go back to the Local Variables section in My Blueprint and grab the In Steps
    and the `InTimeStep` variables, and choose Set for both of them. Connect the execute
    output of our Prev Loc node to the execute input on the In Steps node. Then, connect
    the execute output of In Steps to the input on In Time Step.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回 My Blueprint 中的局部变量部分，获取 In Steps 和 `InTimeStep` 变量，并对它们都选择设置。将 Prev Loc
    节点的执行输出连接到 In Steps 节点的执行输入。然后，将 In Steps 的执行输出连接到 In Time Step 的输入。
- en: To finish this section, we need to connect In Steps and In Time Step to their
    appropriate data input. Take the `Steps` input from our function and connect that
    to the integer input on In Steps. Finally, take the TimeStep input from the function
    and plug that into the float input on In Time Step.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成这一部分，我们需要将“步骤”和“时间步长”连接到它们适当的数据输入。从函数中获取“步骤”输入并将其连接到“步骤”的整数输入。最后，从函数中获取时间步长输入并将其连接到“时间步长”的浮点输入。
- en: There's one last bit of data to initialize before we calculate the curve. To
    get the velocity we'll use for the calculation, we'll need to determine the forward
    vector of our interaction component and multiply that by the `Speed` variable
    we take as an input into our function. Head back to the Local Variables portion
    of the screen and drag in a copy of the `Velocity` variable. Choose Set from the
    menu. Connect the execute output from our In Time Step node and plug it into our
    new Velocity node.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在计算曲线之前，我们还需要初始化一些最后的数据。为了得到用于计算的速率，我们需要确定交互组件的前进向量，并将其乘以函数输入的`Speed`变量。回到屏幕的局部变量部分，拖入一个`Velocity`变量的副本。从菜单中选择“设置”。将我们的“In
    Time Step”节点的执行输出连接到新的速度节点。
- en: 'Right-click in the blueprint and use the menu to find the Get Forward Vector
    node where the target is a Scene Component. Drag a line off the Return Value of
    the node and drop it to bring up the search menu and search for the `Vector *
    Float` node. The vector input will be the Return Value of the Get Forward Vector,
    and the float value will be the Speed input from the start of our function. The
    resulting value will become the input for the vector on the Set Velocity node:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在蓝图上右键单击并使用菜单找到目标为场景组件的“获取前进向量”节点。从节点的返回值拖出一条线，将其拖到搜索菜单中，并搜索“`Vector * Float`”节点。向量输入将是“获取前进向量”的返回值，浮点值将是函数起始处的速度输入。得到的值将成为“设置速度”节点上向量的输入：
- en: '![](img/bf18caee-e945-4b91-aa93-299aae8065aa.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bf18caee-e945-4b91-aa93-299aae8065aa.png)'
- en: Calculating a parabolic line trace in blueprints
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在蓝图中进行抛物线轨迹计算
- en: With all of our variables straightened out, it's time for the fun part! Start
    the calculation by creating a ForLoopWithBreak node. Connect the execute output
    from our set Velocity to the execute input on ForLoopWithBreak. Drag in a copy
    of our local variable In Steps and plug that into the Last Index input on ForLoopWithBreak.
    Lastly, set the First Index integer to 1.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在所有变量都整理好之后，是时候进行有趣的部分了！通过创建一个`ForLoopWithBreak`节点开始计算。将我们的设置速度的执行输出连接到`ForLoopWithBreak`的执行输入。拖入一个本地变量“步骤”的副本，并将其连接到`ForLoopWithBreak`的最后一个索引输入。最后，将第一个索引整数设置为1。
- en: Next, create a Line Trace By Channel node. This node will do all of the heavy
    lifting and create the actual line trace. Plug the Loop Body output from the ForLoopWithBreak
    into the execute input on our new line trace. On the line trace node, change the
    Draw Debug Type to For One Frame. This will help us to visualize the parabolic
    arc. We can always turn it off later. Now grab a copy of the `PrevLoc` variable
    and plug that into the `Start` input on the line trace.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个“通过通道进行线迹”节点。这个节点将完成所有繁重的工作并创建实际的线迹。将`ForLoopWithBreak`的循环体输出连接到新线迹的执行输入。在线迹节点上，将“绘制调试类型”更改为“为一帧”。这将帮助我们可视化抛物线弧。我们总是可以在之后将其关闭。现在，获取一个`PrevLoc`变量的副本，并将其连接到线迹的“开始”输入。
- en: Bring on the math! Let's start by getting a copy of the `Velocity` local variable.
    Right-click on the output of the variable and choose the Split Struct Pin option.
    This displays all the values that make up our velocity vector.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始数学运算！让我们先获取一个`Velocity`局部变量的副本。在变量的输出上右键单击并选择“拆分结构引脚”选项。这将显示组成我们的速度向量的所有值。
- en: Now create three copies of the `Float * Float` node. We're going to plug the
    *X*, *Y*, and *Z* values we just exposed on the Velocity node into the top input
    on each of the multiplication nodes.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建三个`Float * Float`节点的副本。我们将把刚刚在速度节点上公开的`X`、`Y`和`Z`值连接到每个乘法节点的顶部输入。
- en: Create a copy of the `InTimeStep` local variable and an `Integer * Float` node.
    Plug the output of the variable into the float input on the multiplication node.
    The input for the integer section of the node comes from the `Index` output of
    the ForLoopWithBreak node. The output from this bit of math will be used by many
    nodes.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`InTimeStep`局部变量和一个`Integer * Float`节点的副本。将变量的输出连接到乘法节点上的浮点输入。节点的整数部分输入来自`ForLoopWithBreak`节点的`Index`输出。这段数学计算的结果将被许多节点使用。
- en: Take the output and plug it into the second float input on the multiplication
    nodes we created earlier in *step 17*.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将输出结果插入到我们在*步骤17*中创建的乘法节点之前的第二个浮点输入。
- en: Don't forget, you can create reroute nodes to help clean your code! Right-click
    in the Blueprint as if you're creating a new node and find the Reroute node down
    toward the bottom of the menu.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记，你可以创建重路由节点来帮助你清理代码！在Blueprint中右键单击，就像你正在创建一个新节点一样，并在菜单底部找到Reroute节点。
- en: It's time to compensate for gravity in our calculation. Create a `Float * Float`
    node and place it near the multiplication node created in *step 18*. On the newly
    created node, there's a button labeled + Add Pin. Let's click that twice to create
    two more input pins. Plug the output of the multiplication node from *step 18*
    into the first two input values of our new node (this represents time being squared
    in our equation). In the third input, change the value to 0.5\. In the final input,
    change the value to 980.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候在我们的计算中补偿重力了。创建一个`Float * Float`节点，并将其放置在*步骤18*中创建的乘法节点附近。在新创建的节点上，有一个标有+
    Add Pin的按钮。让我们点击两次以创建两个额外的输入引脚。将*步骤18*中乘法节点的输出插入到我们新节点的第一个两个输入值（这代表方程中的时间平方）。在第三个输入中，将值更改为0.5。在最后一个输入中，将值更改为980。
- en: We've almost finished the math. Create a `Float - Float` node and plug the output
    of the multiplication node we use with the *Z* value from our `Velocity` variable
    into the first input and the output of the multiplication node we created in *step
    20* into the second input.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们几乎完成了数学计算。创建一个`Float - Float`节点，并将我们用于*Z*值的乘法节点的输出插入到第一个输入，将我们在*步骤20*中创建的乘法节点的输出插入到第二个输入。
- en: Finally, create one final math node, `Vector + Vector`, and right-click on the
    first `Vector` input pin. Select Split Struct Pin from the menu. The *X* value
    will be the output of the X Velocity multiplication node. The *Y* will be the
    output of the Y Velocity multiplication node. The *Z* value will be the output
    of the `Float - Float` we created in the last step. All of that will be added
    to the value of Init Loc. Create a copy of the variable and plug into the last
    input. The output of this node will become the End vector input on our line trace
    node.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建一个最终的数学节点，`Vector + Vector`，并在第一个`Vector`输入引脚上右键单击。从菜单中选择Split Struct Pin。*X*值将是X速度乘法节点的输出。*Y*将是Y速度乘法节点的输出。*Z*值将是我们在上一步中创建的`Float
    - Float`的输出。所有这些都将添加到Init Loc的值。创建变量的副本并将其插入到最后一个输入。此节点的输出将成为线迹节点上的End向量输入。
- en: 'There''s one last section regarding this function. With our Line Trace by Channel
    node getting all of the information it needs, we need to set up the output values
    to store the information that we receive from the trace. We''ll do this by updating
    the location we''ve stored in our Prev Loc node and saving the hit result information
    into the TempHit node:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 关于此函数的最后一段内容。随着我们的Line Trace by Channel节点获取所有所需的信息，我们需要设置输出值以存储我们从追踪中接收到的信息。我们将通过更新我们存储在Prev
    Loc节点中的位置并将击中结果信息保存到TempHit节点中来实现这一点：
- en: '![](img/80611f4e-3dcf-41e5-8d81-20a1bb0d0696.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/80611f4e-3dcf-41e5-8d81-20a1bb0d0696.png)'
- en: Completing the line trace
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 完成线迹追踪
- en: Let's wrap this thing up!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把这个东西完成！
- en: Create a SET node for our `PrevLoc` variable and connect the execute output
    from the line trace to its execute input. To update the vector input, drag a connection
    from the `Vector + Vector` node we created in *step 22* and plug it into the input.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的`PrevLoc`变量创建一个SET节点，并将线迹的执行输出连接到其执行输入。要更新向量输入，从我们在*步骤22*中创建的`Vector + Vector`节点拖动一个连接并将其插入到输入。
- en: Next, create a Set node for the Temp Hit local variable and connect the execute
    output from our set Prev Loc node to the execute input. Connect the Out Hit output
    from the line trace into the input.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，为Temp Hit局部变量创建一个Set节点，并将我们的set Prev Loc节点的执行输出连接到执行输入。将线迹的Out Hit输出连接到输入。
- en: To make sure that we aren't making any unnecessary hit calculations when no
    hit is found, let's add a Branch node. Add a Branch node and connect the execute
    output from the set TempHit node to it. Pass the Return Value output from the
    line trace into the Condition input.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保在没有找到击中时，我们不会进行任何不必要的击中计算，让我们添加一个Branch节点。添加一个Branch节点，并将set TempHit节点的执行输出连接到它。将线迹的Return
    Value输出传递到条件输入。
- en: Bring the execute output from this node all of the way back to the ForLoopWithBreak
    node and plug it into the Break input.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此节点的执行输出全部返回到ForLoopWithBreak节点，并将其插入到Break输入。
- en: Finish this by connecting the complete execute output to the input on the function's
    Return node. Create a copy of TempHit and pass that into the function's output.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将完整的执行输出连接到函数的返回节点输入来完成此操作。创建TempHit的副本并将其传递到函数的输出。
- en: 'Now that the Parabolic Line Trace function is finally complete (wow! There''s
    a lot going on there), it''s time to do something with the hit information that
    it collects. The Interact With Hit function will take the hit data from the line
    trace and pass it to our functions we created in the Object Interaction Interface:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在抛物线射线追踪函数终于完成了（哇！那里有很多东西），是时候对它收集到的击中信息做些处理了。`InteractWithHit`函数将接收来自射线追踪的击中数据并将其传递到我们在对象交互接口中创建的函数：
- en: '![](img/d02b1a4b-07b4-47bb-ae1b-f2bf7f53a4e7.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d02b1a4b-07b4-47bb-ae1b-f2bf7f53a4e7.png)'
- en: The variables for the InteractWithHit function
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`InteractWithHit`函数的变量'
- en: 'Let''s start by creating some variables:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一些变量开始：
- en: In the My Blueprints panel, find the Variables section and click the +Variable
    button. The first one we'll create will be named the `FocusComponent`. Set the
    Variable Type to Primitive Component. This will allow us to work with the individual
    components of an object as well as the object itself. Next, create a new variable
    named `FocusObject` and set the type to `Actor`. This will store the current object
    being hit. Finally, create a variable named `CurrentHit` and make its type `Hit
    Result` to store the hit information we collected from the line trace. Once we've
    created all three variables, click on each one and mark them Private in the Details
    panel.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我的蓝图面板中，找到变量部分并点击+变量按钮。我们将创建的第一个变量将被命名为`FocusComponent`。将变量类型设置为原始组件。这将允许我们处理对象的各个组件以及对象本身。接下来，创建一个名为`FocusObject`的新变量，类型设置为`Actor`。这将存储当前被击中的对象。最后，创建一个名为`CurrentHit`的变量，类型设置为`Hit
    Result`，用于存储我们从射线追踪中收集到的击中信息。一旦创建了所有三个变量，点击每个变量并在详细信息面板中将它们标记为私有。
- en: It's time to create our second function. In the Functions section of My Blueprint,
    click the +Function button and name the new function `InteractWithHit`. The new
    function needs to have the ability to pass hit data into it. Click on the function,
    and in the Details panel create a new input named `Hit` of the type Hit Result.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候创建我们的第二个函数了。在我的蓝图函数部分，点击+函数按钮并将新函数命名为`InteractWithHit`。新函数需要能够将击中数据传递给它。点击函数，并在详细信息面板中创建一个名为`Hit`的新输入，类型为击中结果。
- en: Now we need to set up three Local Variables inside our new function. Double-click
    the `InteractWithHit` function and head to the Local Variables section. Click
    the +Local Variable button and name the new variable `InHitComponent` of the type
    Primitive Component. Create a second local variable and name it In Hit of the
    type Hit Result. Lastly, create a third local variable and name it In Hit Actor,
    and make it of the type Actor.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要在我们的新函数内部设置三个局部变量。双击`InteractWithHit`函数并转到局部变量部分。点击+局部变量按钮，并将新变量命名为`InHitComponent`，类型为原始组件。创建第二个局部变量，并将其命名为In
    Hit，类型为击中结果。最后，创建第三个局部变量，并将其命名为In Hit Actor，类型为演员。
- en: 'The initial setup is complete! With our variables created, we can now start
    initializing them with data. Starting at the function node, grab a copy of our
    In Hit local variable, and choose Set from the resulting menu. Connect the execute
    output from the function node to the input on the set In Hit node. We also want
    to pass the Hit data coming from outside of the function, so we''ll connect the
    Hit pin on the function node to the input on the set In Hit node:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始设置已完成！随着我们的变量创建完成，我们现在可以开始用数据初始化它们。从函数节点开始，复制我们的In Hit局部变量，并从结果菜单中选择设置。将函数节点的执行输出连接到设置In
    Hit节点的输入。我们还想传递从函数外部来的击中数据，所以我们将函数节点的Hit引脚连接到设置In Hit节点的输入：
- en: '![](img/1eb18fcf-bc24-4fd3-82f4-c47b62d9f77f.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1eb18fcf-bc24-4fd3-82f4-c47b62d9f77f.png)'
- en: Taking in the hit data and storing it in our variables
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 将击中数据接收并存储在我们的变量中
- en: Next, we're going to break the hit down and pass the Hit Actor and the Hit Component
    data to our local variables so that we can work with them. Right-click in the
    blueprint and create a Break Hit Result node. Connect the variable output of the
    Set In Hit node to the input on our new node. This will break the hit information
    down into its parts. Next, bring in a copy of our In Hit Actor and the `InHitComponent`
    variables, and choose Set from the menu. With the two setters created, connect
    them in the order you see in the previous screenshot. Then, connect the Hit Actor
    output from Break Hit Result to the input on the set In Hit Actor node. Be sure
    to do the same for Hit Component and the `InHitComponent` node.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将分解击中信息，并将击中演员和击中组件数据传递到我们的局部变量中，这样我们就可以处理它们了。在蓝图上右键单击并创建一个分解击中结果节点。将设置`In
    Hit`节点的变量输出连接到新节点的输入上。这将把击中信息分解成各个部分。接下来，引入我们的`In Hit Actor`和`InHitComponent`变量的副本，并从菜单中选择设置。创建了两个设置器后，按照之前截图中的顺序将它们连接起来。然后，将分解击中结果中的击中演员输出连接到设置`In
    Hit Actor`节点的输入上。务必为击中组件和`InHitComponent`节点做同样的事情。
- en: 'Much of what we''re doing here is checking the data to see whether what we''re
    looking at can be interacted with and then passing that information through the
    interface we created earlier. We also need to be able to clear our variables if
    we''re no longer looking at something that has interaction. The first step in
    this process is to check to see whether the object we''re looking at (stored in
    Focus Object) is equal to the one we''re currently looking at, and for that we
    need a `Branch` node. Create a new `Branch` node and connect its execute input
    to the output from the Set `InHitComponent`. Now we need the two variables we
    want to compare. Get a copy of our Focus Object variable and our In Hit Actor
    local variable. Drag a connection off FocusObject and drop it to open the search
    menu. Look for the Equal (Object) node. This will compare two objects passed into
    it and return a Boolean showing whether they match. Connect the In Hit Actor to
    the second input and run the Boolean output into the input pin on the Branch:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在这里所做的大部分工作都是检查数据，看看我们正在查看的内容是否可以交互，然后通过我们之前创建的接口传递这些信息。我们还需要能够清除我们的变量，如果我们不再查看具有交互性的内容。这个过程的第一步是检查我们正在查看的对象（存储在焦点对象中）是否等于我们当前正在查看的对象，为此我们需要一个`Branch`节点。创建一个新的`Branch`节点，并将其执行输入连接到设置`InHitComponent`的输出。现在我们需要比较的两个变量。获取我们的焦点对象变量和`In
    Hit Actor`局部变量的副本。从`FocusObject`拖动一个连接并放置到打开搜索菜单。寻找相等（对象）节点。这将比较传递给它的两个对象，并返回一个布尔值，显示它们是否匹配。将`In
    Hit Actor`连接到第二个输入，并将布尔输出运行到分支的输入引脚上：
- en: '![](img/84cdf136-01e1-4a65-affb-22e455f437d2.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/84cdf136-01e1-4a65-affb-22e455f437d2.png)'
- en: Passing the data through our interface
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们的接口传递数据
- en: With our Branch ready, it's time to pass the information. From the `True` output,
    drag a connection off and drop it to search for our Trace Move (message) function
    that we created earlier in the Object Interaction Interface. Get a copy of the
    Focus Object variable and pass that into the Target pin on Trace Move. Now get
    a copy of the In Hit variable and connect that to the `Hit` input on Trace Move.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的分支已经准备好了，现在是时候传递信息了。从`True`输出拖动一个连接并将其放置到我们之前在对象交互界面中创建的追踪移动（消息）函数上。获取焦点对象变量的副本并将其传递到追踪移动的目标引脚上。现在获取`In
    Hit`变量的副本并将其连接到追踪移动的`Hit`输入上。
- en: Create another Branch node and connect its execution input to the output from
    Trace Move. This time, we'll be checking to see whether the Focus Object is equal
    to the `InHitComponent` and passing the new information along if it's not. To
    do that, we need to get the Focus Object and the `InHitComponent` and use our
    Equal (object) node to compare them. Take the Boolean output of that comparison
    and plug it into the input on the new Branch.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个分支节点，并将其执行输入连接到追踪移动的输出。这次，我们将检查焦点对象是否等于`InHitComponent`，如果不等于，则传递新的信息。为此，我们需要获取`Focus
    Object`和`InHitComponent`，并使用我们的相等（对象）节点来比较它们。将比较的布尔输出插入到新分支的输入上。
- en: The next node we need is another function from our interface. Right-click and
    search for Trace Leave Component (message). Create it and connect it to the False
    output on the last Branch. For input, we'll need to get a copy of the FocusObject
    and pass that into Target, In Hit, and pass that into Hit, and the FocusComponent
    and pass that into Component.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个我们需要的是接口中的另一个函数。右键单击并搜索Trace Leave Component（消息）。创建它并将其连接到上一个分支的False输出。对于输入，我们需要获取FocusObject的副本并将其传递到Target，将In
    Hit传递到Hit，并将FocusComponent传递到Component。
- en: Now that we've called leave on the current focused component, we'll call the Trace
    Hit Component and have it pass the current component we're looking at. Create
    a copy of the Trace Hit Component (message) and connect it to the Trace Leave
    Component. Pass FocusObject into Target, In Hit into Hit, and `InHitComponent`
    into Component.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经对当前关注的组件调用了leave，我们将调用Trace Hit Component并让它传递我们正在查看的当前组件。创建Trace Hit
    Component（消息）的副本并将其连接到Trace Leave Component。将FocusObject传递到Target，将In Hit传递到Hit，并将`InHitComponent`传递到Component。
- en: There is one final step in this branch of the process. We need to set the FocusComponent
    to our new the `InHitComponent`. Create a Set node for the FocusComponent, and
    get a copy of the `InHitComponent`. Connect the execute output from the Trace
    Hit Component to set the FocusComponent and pass the `InHitComponent` into the
    variable input pin.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个流程分支中，还有最后一步。我们需要将FocusComponent设置为新的`InHitComponent`。为FocusComponent创建一个Set节点，并获取`InHitComponent`的副本。将Trace
    Hit Component的执行输出连接到设置FocusComponent，并将`InHitComponent`传递到变量输入引脚。
- en: 'The branch we created was all about passing component data if the Focus Object
    and the In Hit object we''re looking at are the same, but what if they''re different?
    If they are, we need to clear the hit data and pass the new hit information through
    the interface. Go back to the Branch we created way back in *step 6*. Drag a connection
    from the `False` output and drop it. Search for the Trace Leave Object function
    and create the node. The Trace Leave Object has two input values. Into the Target
    input, we''ll pass the object we''re currently storing in the FocusObject. For
    the `Hit` input, get the current value of In Hit and connect it to the input pin:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建的分支是关于如果查看的Focus Object和In Hit对象相同，则传递组件数据，但如果它们不同怎么办？如果它们不同，我们需要清除击中数据并通过接口传递新的击中信息。回到我们之前在*步骤6*中创建的分支。从`False`输出拖动一个连接并放下。搜索Trace
    Leave Object函数并创建节点。Trace Leave Object有两个输入值。将当前存储在FocusObject中的对象传递到Target输入。对于`Hit`输入，获取当前In
    Hit的值并将其连接到输入引脚：
- en: '![](img/af012a2b-f0d3-4b15-b019-ecc85c8ca521.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/af012a2b-f0d3-4b15-b019-ecc85c8ca521.png)'
- en: Clearing the variables
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 清除变量
- en: Since we're leaving the object and turning our focus elsewhere, we'll need to
    clear the values stored in the FocusObject and the FocusComponent. Create a Set
    version of each of the variables. Connect the new set FocusObject node to the
    execute output from Trace Leave Object. Connect the new set FocusComponent node
    to the set FocusObject node. We're leaving both of their input values empty to
    clear their values.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们正在离开对象并将注意力转向其他地方，我们需要清除FocusObject和FocusComponent中存储的值。为每个变量创建一个Set版本。将新的设置FocusObject节点连接到Trace
    Leave Object的执行输出。将新的设置FocusComponent节点连接到设置FocusObject节点。我们为它们的输入值留空以清除它们的值。
- en: 'Before we pass the new hit data forward, there''s still one more check we need
    to do. We only want to pass on the hit information if the object we''re looking
    at makes use of the Object Interaction Interface, since anything else wouldn''t
    matter to us. It''s our way as designers of creating objects that are interactable
    and others that are only meant to be scenery. To do this, we''ll use another Branch
    node. Connect the input for the new branch to the execution output from the set
    FocusComponent. To check to see whether the object we''re looking at uses the
    interface, we need to use the Does Implement Interface function. This function
    takes in an Actor and checks to see whether it has a specific interface attached
    to it, then returns a Boolean value—perfect for using with the Branch node. Create
    a copy of the Does Implement Interface. Pass in the value of the In Hit Actor
    as the Test Object and then click the drop-down menu under Interface. Use the
    search box at the top of the menu to find our Object Interaction Interface. With
    that set, plug the Return value from the node into the `Condition` input on our
    Branch. Our check is all set up:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们将新的命中数据传递之前，我们还需要进行一个检查。我们只想在查看的对象使用了对象交互接口时传递命中信息，因为其他任何东西对我们来说都不重要。这是作为设计师的我们创建可交互对象和仅作为场景的对象的方式。为此，我们将使用另一个分支节点。将新分支的输入连接到设置焦点组件的执行输出。为了检查我们正在查看的对象是否使用了该接口，我们需要使用“是否实现接口”函数。此函数接受一个演员并检查它是否附加了特定的接口，然后返回一个布尔值——非常适合与分支节点一起使用。创建一个“是否实现接口”的副本。将“命中演员输入”的值作为测试对象传递，然后点击菜单下的下拉菜单。使用菜单顶部的搜索框找到我们的对象交互接口。设置完成后，将节点的返回值插入到分支的“条件”输入。我们的检查已经设置好了：
- en: '![](img/d57977ce-159a-491d-b73e-f71be8d77dac.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d57977ce-159a-491d-b73e-f71be8d77dac.png)'
- en: Passing in the new hit data
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 传递新的命中数据
- en: Now all that's left is to pass on is the new hit data. Right-click in the blueprint
    and search for Trace Hit Object (message). Connect it to the True output from
    the Branch and pass the In Hit Actor into the Target input and the In Hit into
    the Hit input.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在剩下要传递的就是新的命中数据。在蓝图上右键点击并搜索“追踪命中对象（消息）”。将其连接到分支的“真”输出，并将“命中演员输入”传递到目标输入，将“命中输入”传递到命中输入。
- en: Next, create a copy of the Trace Hit Component (message) function. Pass the In
    Hit Actor into the Target input, In Hit into the Hit input, and the InHitComponent
    into the Component input.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个“追踪命中组件（消息）”函数的副本。将“命中演员输入”传递到目标输入，将“命中输入”传递到命中输入，并将“命中组件输入”传递到组件输入。
- en: In the final step for this branch, we'll need to update the values store in
    the FocusObject and the FocusComponent with the values from the In Hit Actor and
    the `InHitComponent`. Create a set FocusObject node and connect it to the execute
    output of the Trace Hit Component function. Pass the value of the In Hit Actor
    into the variable input. Lastly, connect the set FocusComponent execute input
    to the execute output from set the `FocusActor` and pass in the value from the `InHitComponent`.
    We've now completely finished using this function!
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此分支的最后一步，我们需要更新存储在“焦点对象”和“焦点组件”中的值，使用“命中演员输入”和“命中组件输入”的值。创建一个设置焦点对象节点并将其连接到追踪命中组件函数的执行输出。将“命中演员输入”的值传递到变量输入。最后，将设置焦点组件的执行输入连接到设置“焦点演员”的执行输出，并传递“命中组件输入”的值。我们现在已经完全完成了这个函数的使用！
- en: 'It''s taken quite a bit of programming to get here, hasn''t it? However, we
    have made a huge amount of progress in building our hand interactions. Our Interaction
    Component now has the ability to do a parabolic line trace to find objects and
    safe locations to teleport. It can now pass information through the Object Interaction
    Interface we created to allow our interactable objects to work with the hands,
    to create gameplay. It''s now time to bring that all together in the Event Graph
    to implement all of the functionality we''ve created. For this, we''ll use the
    Event Tick node:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 到这里已经编写了相当多的代码，不是吗？然而，我们在构建我们的手部交互方面已经取得了巨大的进步。我们的交互组件现在能够进行抛物线线迹以找到对象和安全的传送位置。它现在可以通过我们创建的对象交互接口传递信息，使我们的交互对象能够与手部协同工作，以创建游戏玩法。现在是时候在事件图中将所有这些整合在一起，以实现我们创建的所有功能。为此，我们将使用事件计时节点：
- en: '![](img/dd5d5567-f1f3-4d9c-aa24-29b45998457e.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dd5d5567-f1f3-4d9c-aa24-29b45998457e.png)'
- en: Triggering the Parabolic Line Trace
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 触发抛物线线迹
- en: 'Start by creating a couple of Custom Events:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建几个自定义事件：
- en: We'll need two custom events to represent the on and off states that we want
    the Interaction Component to have. The Custom Events will be called by elements
    outside this blueprint to trigger interaction using button presses on the player's
    motion controllers. Right-click near the Event Tick node and find the Add Event
    section of the menu. Open it and select the Add Custom Event option. Name this
    new event `Enable`. Repeat the process to create a second custom event and name
    it `Disable`.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要两个自定义事件来表示我们希望交互组件具有的开和关状态。自定义事件将由蓝图外的元素调用，以通过玩家的动作控制器上的按钮点击触发交互。在事件计时节点附近右键单击并找到菜单中的添加事件部分。打开它并选择添加自定义事件选项。将这个新事件命名为`Enable`。重复此过程创建第二个自定义事件并将其命名为`Disable`。
- en: Next, we'll use a Gate node to only allow the player to interact with objects
    when they've enabled the interaction component with a button. A Gate is a flow-control
    node that opens and shuts to allow data through only when the programmer allows
    it. Right-click in the blueprint and search for the Gate node. We'll connect the
    Event Tick output to the Enter input on the Gate. To control the flow of data,
    we'll connect the Execution output from our Enable custom event to the Open input
    and the execution output from the Disable custom event to the Close input.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用一个门节点来仅允许玩家在通过按钮启用交互组件时与对象交互。门是一个流控制节点，它打开和关闭以允许程序员允许时才通过数据。在蓝图上右键单击并搜索门节点。我们将事件计时输出连接到门上的进入输入。为了控制数据流，我们将我们的启用自定义事件的执行输出连接到打开输入，并将禁用自定义事件的执行输出连接到关闭输入。
- en: Now we'll add in our Parabolic Line Trace function. Grab a copy of it from the
    My Blueprints panel and drag it into the blueprint. Connect the execute output
    from the Gate to the execution input on the function. To make sure our parabola
    functions correctly, set the number of Steps to `10`, the Time Step to `0.1`,
    and the Speed to `500`.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将添加我们的抛物线线迹函数。从我的蓝图面板中获取它的副本并将其拖入蓝图。将门节点的执行输出连接到函数的执行输入。为了确保我们的抛物线函数正确运行，将步骤数设置为`10`，时间步长设置为`0.1`，速度设置为`500`。
- en: The output from our line trace needs to be stored so that we can pass it to
    the Interact With Hit function. Luckily, we already created a variable to hold
    it. Create a copy of our `CurrentHit` hit variable by dragging it in from the
    My Blueprint panel and select Set from the menu. Connect it to the execute output
    from the line trace function and pass the Hit output from the line trace into
    it.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要存储我们的线迹输出，以便我们可以将其传递给与击中交互函数。幸运的是，我们已创建了一个变量来保存它。通过从我的蓝图面板中拖动它创建我们的`CurrentHit`击中变量的副本，并从菜单中选择设置。将其连接到线迹函数的执行输出，并将线迹的击中输出传递给它。
- en: End the sequence by bringing in the Interact With Hit function and connecting
    the execute output from the set CurrentHit node to it. Connect the variable output
    from the set CurrentHit as the Hit input on the function.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过引入“与击中交互”函数并连接从设置当前击中节点执行输出到它来结束序列。将设置当前击中的变量输出作为函数上的击中输入连接。
- en: 'There''s one final piece to this interaction puzzle. We need to add the interaction
    component to `Server17PlayerPawn` and map the functionality to buttons on the
    player''s motion controllers. Let''s start by adding two more custom events to
    the Interaction Component blueprint:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这个交互谜题还有最后一个部分。我们需要将交互组件添加到`Server17PlayerPawn`并将功能映射到玩家的动作控制器上的按钮。让我们首先向交互组件蓝图添加两个更多的自定义事件：
- en: '![](img/e743e973-8b7f-4860-9a67-4ca3d1d3bdd2.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e743e973-8b7f-4860-9a67-4ca3d1d3bdd2.png)'
- en: Activation section of the Interaction Blueprint
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 交互蓝图激活部分
- en: 'Every button has two states: an up and a down. We''ll define these states by
    creating two Custom Events:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 每个按钮都有两种状态：上和下。我们将通过创建两个自定义事件来定义这些状态：
- en: Right-click in a new section of the blueprint, find the Add Event section of
    the menu, and open it and choose Add Custom Event. Name the first one `ActivateUp`.
    Create a second custom event and name it `ActivateDown`. Both events need to have
    a single input. Click on each of the custom events and click the + button in the
    Inputs section of the Details panel. Name the input `Instigator` and make its
    type Pawn.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在蓝图的新部分中右键单击，找到菜单中的添加事件部分，打开它并选择添加自定义事件。将第一个命名为`ActivateUp`。创建第二个自定义事件并将其命名为`ActivateDown`。这两个事件都需要一个输入。单击每个自定义事件，然后在详细信息面板的输入部分单击+按钮。将输入命名为`Instigator`并将其类型设置为Pawn。
- en: Drag a connection off ActivateUp and search for Trace Activate Up (message).
    We created this function as part of our interface. Connect its execution to the
    ActivateUp event and connect the Instigator output from the event to the Instigator
    input on the function.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从ActivateUp拖动一条连接并搜索Trace Activate Up（消息）。我们作为接口的一部分创建了此函数。将其执行连接到ActivateUp事件，并将事件的Instigator输出连接到函数的Instigator输入。
- en: Trace Activate Up still needs two more input values to work correctly. Get a
    copy of the `FocusObject` variable and connect that to the Target input. Lastly,
    get a copy of the `CurrentHit` variable and connect that to the `Hit` input on
    the function.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Trace Activate Up还需要两个更多的输入值才能正确工作。获取`FocusObject`变量的副本并将其连接到目标输入。最后，获取`CurrentHit`变量的副本并将其连接到函数的`Hit`输入。
- en: We're going to repeat this process for `ActivateDown`—only, this time, we'll
    connect the Trace Activate Down (message) function from our interface.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将重复此过程为`ActivateDown`——只是这次，我们将连接来自我们接口的Trace Activate Down（消息）函数。
- en: 'It''s time to finish the setup in the player pawn:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候完成玩家 pawn 中的设置了：
- en: '![](img/7886b243-86b5-4373-94a3-dbfad3fbc1ba.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7886b243-86b5-4373-94a3-dbfad3fbc1ba.png)'
- en: Components setup in the player pawn
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在玩家 pawn 中设置组件
- en: 'Start by adding a copy of the Interaction Component to each of the hands:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 首先为每只手添加交互组件的副本：
- en: In the Content Browser, find the `Server17PlayerPawn` and double-click to open
    it.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在内容浏览器中找到`Server17PlayerPawn`并双击以打开它。
- en: In the Viewport tab, head over to the Components panel and click the Add Component
    button. Use the search box to find our Interaction Component that we created.
    It'll be under the heading Custom. Click on it and name the new component `InteractionComponent_L`.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在视口选项卡中，转到组件面板并点击添加组件按钮。使用搜索框找到我们创建的交互组件。它将在自定义标题下。点击它并命名新组件为`InteractionComponent_L`。
- en: Drag and drop the new component on to the MotionController_L component.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新组件拖放到MotionController_L组件上。
- en: Repeat *step 2* and *step 3* to create a second interaction component that's
    a child of the right motion controller. Name this one `InteractionComponent_R`.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复*步骤2*和*步骤3*以创建一个作为右侧运动控制器子组件的第二交互组件。将其命名为`InteractionComponent_R`。
- en: 'Now we can tie our new interaction components to buttons on the controllers.
    This will give the player the power to finally interact with the world! Click
    on the Event Graph tab. In an empty section of the graph, right-click and search
    for the MotionController (L) Trigger event. Repeat the process to create a node
    for the MotionController (R) Trigger event:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以将我们的新交互组件绑定到控制器上的按钮。这将赋予玩家最终与世界交互的能力！点击事件图选项卡。在图的空白部分右键单击并搜索MotionController
    (L) 触发事件。重复此过程以创建一个用于MotionController (R) 触发事件的节点：
- en: '![](img/1dcf543a-67bd-4ed9-95ff-2fb87fcb877e.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1dcf543a-67bd-4ed9-95ff-2fb87fcb877e.png)'
- en: Mapping actions to our motion controllers in the player pawn
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在玩家 pawn 中将动作映射到我们的运动控制器
- en: For each of our button events, we need to create two references to our custom
    events that we created back in the interaction component blueprint. Start by grabbing
    a reference to the left interaction component from the My Blueprints panel. Position
    it near the MotionController (L) Trigger event. Drag a line off it and drop it.
    Use the search box to find our Activate Down function. Connect it to the Pressed
    execute output on the left trigger event. Next, drag a connection off the Instigator
    input pin on the Activate Down function and drop it to bring up the search menu.
    Search for a reference to the `Self` variable. In this case, the player is the
    instigator of the activation.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们每个按钮事件，我们需要为我们在交互组件蓝图中所创建的自定义事件创建两个引用。首先从我的蓝图面板中获取左侧交互组件的引用。将其放置在MotionController
    (L) 触发事件附近。从它拖动一条线并放下。使用搜索框找到我们的Activate Down函数。将其连接到左侧触发事件的Pressed执行输出。接下来，从Activate
    Down函数的Instigator输入引脚上拖动一条连接并将其拖到搜索菜单中。搜索对`Self`变量的引用。在这种情况下，玩家是激活的施动者。
- en: Repeat the process for the MotionController (R) Trigger event by using a reference
    to the right interaction component.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用右侧交互组件的引用重复此过程以处理MotionController (R) 触发事件。
- en: I chose to use the left and right triggers for interactions for a couple different
    reasons. First, it's a button that's natural for a first-time user to press to
    activate something or to make something happen. It's intuitive. Second, the button
    event exists with the Oculus Touch controllers and Vive motion controllers, so
    I wouldn't have to change anything to go between hardware. Later, we'll create
    a pickup interaction, and I will use the grip buttons for the same reasons.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择使用左右触发器进行交互，有几个不同的原因。首先，这是一个对于初次用户来说自然可以按下的按钮，用于激活某物或使其发生。它是直观的。其次，按钮事件存在于Oculus
    Touch控制器和Vive运动控制器中，因此我无需在硬件之间进行任何更改。稍后，我们将创建一个拾取交互，我将出于相同的原因使用握把按钮。
- en: In this first section of programming, we set up the hand static meshes and programmed
    the `ObjectInteractionInterface`, a collection of functions that can be utilized
    by the object we want the player to be able to interact with. This blueprint interface
    connects to our Interfaction Component, a custom Scene Component that has the
    ability to utilize a parabolic line trace function to find interactive objects.
    Finally, we mapped our Activate functionality to buttons on the Motion Controller
    as part of Player Pawn blueprint. In the next section, we'll build on to this
    new functionality to create a teleport mechanic.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个编程的第一个部分，我们设置了手的静态网格并编程了`ObjectInteractionInterface`，这是一个可以被我们希望玩家能够与之交互的对象利用的函数集合。这个蓝图界面连接到我们的交互组件，这是一个具有利用抛物线线迹功能查找交互对象能力的自定义场景组件。最后，我们将激活功能映射到运动控制器的按钮上，作为玩家蓝图的一部分。在下一节中，我们将在此基础上构建新的功能来创建传送机制。
- en: Building the teleportation
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建传送
- en: 'Now that the code for line tracing and interaction has been implemented, we
    can turn our attention to the teleport system itself. The goal of using teleportation
    in *Server 17* is to give our player an intuitive method of moving around our
    environment. Though teleportation is often seen as immersion breaking, I feel
    that the cyberspace environment in our game supports the idea of the player character
    being able to teleport around the space. To get started, let''s first think about
    the parts of a VR teleport system:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经实现了线迹和交互的代码，我们可以将注意力转向传送系统本身。在*Server 17*中使用传送的目标是给我们的玩家提供一个直观的环境移动方法。尽管传送通常被视为破坏沉浸感，但我认为我们游戏中的网络空间环境支持玩家角色能够在空间中传送的想法。为了开始，让我们首先考虑VR传送系统的各个部分：
- en: '**Visuals**: Players need to be able to visualize where they''ll be moving
    to when they click the button. This can be done by projecting a line or an arc
    to where they''ll land (we''ve done this through the debug option on our line
    trace that we set earlier). We should also have a visual on the surface they''ll
    land on, to further highlight their landing point. Lastly, we might think about
    a particle effect and/or a sound effect to help enhance the player experience.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视觉**：玩家需要能够可视化当他们点击按钮时将移动到的地方。这可以通过将一条线或一个弧投影到他们将要着陆的地方来完成（我们通过之前设置的线迹调试选项完成了这个操作）。我们还应该在他们会着陆的表面上有一个视觉元素，以进一步突出他们的着陆点。最后，我们可能还会考虑粒子效果和/或声音效果来增强玩家体验。'
- en: '**Teleport code**: This would be the actual functionality that''s built within
    the blueprint. The code will need to handle the displaying of the visual elements,
    as well as the teleport itself. It would also be nice to build in some kinds of
    controls for us as designers to restrict the player to certain areas so that they
    can''t teleport outside the area we''ve built for them or see things they aren''t
    supposed to.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传送代码**：这将是在蓝图内构建的实际功能。代码需要处理显示视觉元素以及传送本身。对于设计师来说，构建一些控制也很不错，以限制玩家只能在特定区域内传送，这样他们就不能传送出我们为他们构建的区域或看到他们不应该看到的东西。'
- en: 'Contrary to how we would normally start building a feature such as this (functionality,
    then art), here we''ll start with a bit of the visual components. In this case,
    we need some visuals to be able to turn on and off to make sure our code is working.
    Building this system will also be an excellent test of how our interface and line
    trace code is working. Let''s start with a visual on the ground for teleporting:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们通常开始构建此类功能（功能，然后是艺术）的方式相反，这里我们将从一些视觉组件开始。在这种情况下，我们需要一些可以打开和关闭的视觉元素来确保我们的代码正常工作。构建这个系统也将是对我们的界面和线迹代码工作情况的一个极好的测试。让我们从地面上的一个用于传送的视觉元素开始：
- en: '![](img/c95d7262-db3f-4cf4-bdf2-c8327bd1c4aa.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c95d7262-db3f-4cf4-bdf2-c8327bd1c4aa.png)'
- en: TeleportViz viewport
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: TeleportViz视口
- en: 'We start by creating a new actor blueprint:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个新的演员蓝图：
- en: Right-click in the `Server17\Blueprints` folder of the Content Browser and select
    the Blueprint Class option from the Create Basic Asset section of the menu. Choose
    Actor from the Pick Parent Class menu and name this new blueprint TeleportViz.
    Double-click the blueprint to open it.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在内容浏览器中，在`Server17\Blueprints`文件夹上右键单击，并从菜单的创建基本资产部分选择蓝图类选项。从选择父类菜单中选择Actor，并将这个新蓝图命名为TeleportViz。双击蓝图以打开它。
- en: In the Viewport tab, head over to the Components panel and click the Add Component
    button. Choose Static Mesh from the menu. This should create a new static mesh
    component that's a child of the Default Scene Root.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在视口选项卡中，转到组件面板，并点击添加组件按钮。从菜单中选择静态网格。这应该创建一个新的静态网格组件，它是默认场景根的子组件。
- en: Click on it and search for the Static Mesh section of the Details panel. There's
    an option called Static Mesh where we can set the shape we want to use. Click
    the drop-down menu and search for SM_FatCylinder, though you may use any shape
    you like. Name the piece `Visualizer`.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击它，并在详情面板的静态网格部分中搜索。有一个名为静态网格的选项，我们可以设置我们想要使用的形状。点击下拉菜单，搜索SM_FatCylinder，尽管你可以使用你喜欢的任何形状。将部件命名为`Visualizer`。
- en: 'The static mesh looks a bit plain. Let''s spruce it up a bit with a custom
    Material to make it glow a bit and stand out. This will also serve as a great
    test for a potential art style for the overall environment of the game. In the
    Content Browser, navigate to the `Server17` folder, right-click in the Content
    Browser window, and create a New Folder. Name it `Materials`. Double-click the
    new folder and right-click in it to create a new Material. Name this material
    `M_TeleportViz`. Double-click the new material to open it:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个静态网格看起来有点单调。让我们用自定义材质让它发光一点，使其突出。这还将作为游戏整体环境潜在艺术风格的一个很好的测试。在内容浏览器中，导航到`Server17`文件夹，在内容浏览器窗口中右键单击，并创建一个新的文件夹。将其命名为`Materials`。双击新文件夹，并在其中右键单击以创建一个新的材质。将这个材质命名为`M_TeleportViz`。双击新材质以打开它：
- en: '![](img/5df6e4d1-f23b-404d-85c5-59ebf3fede5f.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5df6e4d1-f23b-404d-85c5-59ebf3fede5f.png)'
- en: TeleportViz Material
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: TeleportViz材质
- en: When we open the material, we're greeted with one large Result Node to get us
    started. Click on it, and let's tweak a few of the settings in the Details panel.
    Find the option labeled Blend Mode. We want our new material to feel high-tech,
    so let's change the mode to Translucent to give it a little bit of that feel.
    Next, find the Shading Model. Since we're going to give this element an emissive
    glow, let's change the model to Unlit. Lastly, check the box to make the material
    Two Sided.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们打开材质时，我们会看到一个大的结果节点来开始。点击它，让我们在详情面板中调整一些设置。找到标签为混合模式的选项。我们希望我们的新材质感觉高科技，所以让我们将其模式更改为半透明，以给它一点这种感觉。接下来，找到着色模型。由于我们将给这个元素一个自发光的光芒，让我们将其模型更改为不发光。最后，勾选复选框以使材质双面。
- en: Now it's time to choose a color. Create a Constant 3 Vector by grabbing it from
    the Palette panel or holding the *3* key and clicking in the material blueprint.
    If you don't have the Palette open and would like it to be, click on the window
    button at the top right of your screen and choose Palette from the menu. Right-click
    on the new vector and select Convert to Parameter at the top of the resulting
    menu. Name the parameter Color. By making it a parameter, we're making it possible
    to use blueprints to change it if we needed to. This could be handy in the future.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是选择颜色的时候了。通过从调色板面板中抓取它或在材质蓝图上按*3*键并点击来创建一个常量3向量。如果你没有打开调色板，并希望它打开，请点击屏幕右上角的窗口按钮，并在菜单中选择调色板。在新的向量上右键单击，并在结果菜单的顶部选择转换为参数。将参数命名为颜色。通过将其设置为参数，我们使其在需要时能够使用蓝图来更改它。这将来可能很有用。
- en: Click on the Color node and click on the block of color in the Details panel
    to bring up the color picker. Choose any color you like and click the Ok button.
    If you would like to use the light blue color I have, set your RGB values to *R=0.84*,
    *G=0.74*, and *B=1.0*. Make sure you Alpha is set to *A=1.0*.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击颜色节点，然后在详情面板中点击颜色块，以打开颜色选择器。选择你喜欢的任何颜色，然后点击确定按钮。如果你想使用我使用的浅蓝色，请将你的RGB值设置为*R=0.84*，*G=0.74*，和*B=1.0*。确保你的Alpha设置为*A=1.0*。
- en: To give the material a bit of glow, let's create a Constant value and multiply
    that by our Color. Search for Constant in the Palette or right-click and use the
    search box. Right-click on the new node and select Convert to Parameter as we
    did for Color in *step 6*. Over in the Details panel, name this value Strength
    and set the default value to `10`. Finally, create a Multiply node and connect
    the output of the Color parameter as value `A` and the output of Strength as value
    `B`. Finish by connecting the output of the multiply to the Emissive slot on the
    Result node.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了给材料添加一些发光效果，让我们创建一个常量值并将其乘以我们的颜色。在调色板中搜索Constant或右键单击并使用搜索框。右键单击新节点并选择转换为参数，就像我们在*步骤6*中为颜色所做的那样。在详细信息面板中，将此值命名为Strength并将默认值设置为`10`。最后，创建一个Multiply节点并将颜色参数的输出作为值`A`连接，将Strength的输出作为值`B`连接。最后，将乘法节点的输出连接到结果节点的Emissive槽。
- en: To give our new Color a bit of a gradient effect, we'll manipulate the texture
    coordinates a bit. Create a Texture Coordinate node by either using the Palette
    or holding the *U* key and clicking in the blueprint.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了给我们的新颜色添加一些渐变效果，我们将稍微调整纹理坐标。通过使用调色板或按住*U*键并在蓝图上点击来创建一个纹理坐标节点。
- en: Next, we'll need a Component Mask. Create a copy of the node using the Palette
    or right-click in the blueprint and use the search box. In the Details panel,
    turn off the option to use the R channel. Connect the output from the Texture
    Coordinate to the input on the Component Mask.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个组件遮罩。使用调色板或右键单击蓝图并使用搜索框来复制节点。在详细信息面板中，关闭使用R通道的选项。将纹理坐标的输出连接到组件遮罩的输入。
- en: Now create a Cosine node. A Cosine will ensure that the gradient starts from
    both ends of the material. This will connect to the output from the Component
    Mask.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建一个余弦节点。余弦函数将确保渐变从材料的两端开始。这将连接到组件遮罩的输出。
- en: Cosine outputs a value between -1 and 1\. We need the resulting value to be
    positive only, so we'll use a One Minus node. This will give us values between
    0 and 2\. Create the One Minus node and connect it to the output of the Cosine
    node.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 余弦函数输出介于-1和1之间的值。我们需要结果值仅为正值，因此我们将使用一个One Minus节点。这将给我们介于0和2之间的值。创建One Minus节点并将其连接到余弦节点的输出。
- en: To bring the value back to between 0 and 1, we can divide the answer by 2\.
    Using the Divide node, connect the output of the One Minus node as the `A` value.
    Click on the Divide node and find the value for `B` in the Details panel. Change
    this value to `2.0`.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了将值恢复到0到1之间，我们可以将答案除以2。使用Divide节点，将One Minus节点的输出作为`A`值连接。在详细信息面板中找到`B`值的值。将此值更改为`2.0`。
- en: Now we're going to build in some control over the distance the gradient takes
    to go from opaque to clear. This is called **Falloff**. Create a new Power node
    and connect the output of our Divide node into the Base input on the new node.
    Next, create a Constant. This can be done using the Palette or the search menu,
    or by holding the one key and clicking in the blueprint. Right-click on it and
    Convert to Parameter. Name the parameter `GradientFalloff` and set the Default
    Value to `3`. Plug the output of this parameter into the Exponent, or Exp, input
    on the Power node.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将添加一些控制渐变从不透明到透明距离的功能。这被称为**衰减**。创建一个新的Power节点，并将我们的Divide节点的输出连接到新节点的Base输入。接下来，创建一个Constant。这可以通过调色板或搜索菜单完成，或者通过按下一个键并在蓝图上点击。右键单击它，将其转换为参数。将参数命名为`GradientFalloff`并将默认值设置为`3`。将此参数的输出连接到Power节点的指数或Exp输入。
- en: To ensure the resulting value can never go above 1, we'll need to clamp the
    value. Create a new Clamp node and bring in the output from the Power node. Plug
    the output of the Clamp node into the Opacity slot on the result node.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保结果值永远不会超过1，我们需要夹紧这个值。创建一个新的Clamp节点并将Power节点的输出引入。将Clamp节点的输出连接到结果节点的不透明度槽。
- en: Check that out! The result should be glowing and partially see-through. You
    can tweak the materials by adjusting the GradientFalloff, Strength, and Color
    parameters until it feels right to you. To complete the visual, head back to our
    TeleportViz class blueprint and click on the static mesh component. Using the
    Details panel, apply our new material and bask in the high-tech glow.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查一下！结果应该是发光且部分透明的。你可以通过调整渐变衰减、强度和颜色参数来调整材料，直到感觉合适为止。为了完成视觉效果，回到我们的TeleportViz类蓝图，点击静态网格组件。使用详细信息面板，应用我们新的材料，享受高科技的发光效果。
- en: 'With the visual component sorted, we can now build the functionality. To meet
    our needs of a system that can control where a player can teleport, we''re going
    to create a volume that only allows players to teleport where we place it. It''ll
    display our visual elements when it detects a line trace and will contain our
    teleport code. Start by right clicking in the `Server17\Blueprints` folder of
    the Content Browser and create a new Blueprint Class. Choose Actor from the Pick
    Parent Class menu and name it `TeleportVol`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 视觉组件处理完毕后，我们现在可以构建功能。为了满足我们需要的能够控制玩家可以传送到的位置的系统的需求，我们将创建一个只允许玩家在我们放置的位置传送的体积。当它检测到线追踪时，它将显示我们的视觉元素，并包含我们的传送代码。首先，在内容浏览器中的
    `Server17\Blueprints` 文件夹上右键单击，创建一个新的蓝图类。从选择父类菜单中选择演员，并将其命名为 `TeleportVol`：
- en: '![](img/125c1126-9f18-4e83-a2a5-a064e534b8d8.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/125c1126-9f18-4e83-a2a5-a064e534b8d8.png)'
- en: The TeleportVol component
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: TeleportVol 组件
- en: 'We''ll start in the Viewport tab:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从视口选项卡开始：
- en: TeleportVol has two components that make it work. The first is a box volume
    to detect collisions and line traces. The second is the visual elements we created
    earlier that we can turn on and off. Start by heading to the Components panel
    and creating a new Box Collision. Name the new component `TeleportVol`.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TeleportVol 有两个组件使其工作。第一个是用于检测碰撞和线追踪的盒体体积。第二个是我们之前创建的可以打开和关闭的视觉元素。首先，前往组件面板并创建一个新的盒体碰撞。将新组件命名为
    `TeleportVol`。
- en: Click on TeleportVol in the Component panel. We want the collision box to cover
    a fair amount of space, but it really doesn't have to be that tall. In the Details
    Panel, find the Box Extents entry and change the values to *X=200*, *Y=200*, and
    *Z=1.0*.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件面板中点击 TeleportVol。我们希望碰撞盒覆盖相当大的空间，但它实际上不需要那么高。在详细信息面板中找到盒体范围条目，并将值更改为 *X=200*，*Y=200*，和
    *Z=1.0*。
- en: Now we need to customize the collision a bit. In the Collision section of the
    Details panel, find the Collision section. Choose the Collision Presets drop-down
    menu and change it to Custom. Under Trace Responses, we want to set both options
    to Block. In the Object Responses section, change all of the options to Ignore.
    This will make the volume available for line traces, but nothing else.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要对碰撞进行一些定制。在详细信息面板的碰撞部分，找到碰撞条目。选择碰撞预设下拉菜单，将其更改为自定义。在追踪响应下，我们希望将两个选项都设置为阻止。在对象响应部分，将所有选项更改为忽略。这将使体积可用于线追踪，但其他则不行。
- en: With the volume customized, we can move on to the second component. In the Components
    panel, click the Add Component button and select Child Actor from the menu. This
    is a copy of a class blueprint that we can place inside this blueprint. We can
    essentially build a class blueprint out of class blueprints! Click the component
    and find the Child Actor Class option in the Details panel. Using the drop-down
    menu, set this option to TeleportViz. We also don't want it to be visible unless
    it's being hit by a line trace, so turn off the Visible option in the Rendering
    section of the Details.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 体积定制完成后，我们可以继续到第二个组件。在组件面板中，点击添加组件按钮，从菜单中选择子演员。这是一个类蓝图副本，我们可以将其放置在这个蓝图内部。我们实际上可以用类蓝图构建一个类蓝图！点击组件，在详细信息面板中找到子演员类选项。使用下拉菜单，将此选项设置为
    TeleportViz。我们也不希望它在未被射线追踪击中时可见，所以请在详细信息面板的渲染部分关闭可见选项。
- en: Now we will move on to the code! We need this object to be able to react to
    line traces, right? Well, we wrote a whole interface for exactly that. This will
    be the first application of our Object Interaction Interface. To add the functions
    from the interface to this object, click on the Class Defaults that's just above
    the area where the Event Graph and Viewport tabs are located. This will open the
    default options for this class over in the Details panel. Find the Interfaces
    section and click the Add button. Search for the Object Interaction Interface
    in the menu and select it to add its functions to our teleport volume.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将进入代码部分！我们需要这个对象能够对线追踪做出反应，对吧？嗯，我们为此编写了一个完整的接口。这将是我们对象交互接口的第一个应用。要将接口中的函数添加到这个对象中，请点击位于事件图和视口选项卡区域上方的类默认值。这将在详细信息面板中打开此类的默认选项。找到接口部分，并点击添加按钮。在菜单中搜索对象交互接口，并选择它以将它的函数添加到我们的传送体积中。
- en: 'We now have access to every function we wrote in the interface. These can be
    found in the Interfaces section of the My Blueprint panel. Simply click the Arrow
    next to the word Interfaces to see them. We can even double-click on their names
    to open them. Open the following functions: `TraceMove`, `TraceHit`, `TraceLeaveObject`,
    and `TraceActivateUp`:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以访问我们在界面中编写的每个函数。这些可以在 My Blueprint 面板的 Interfaces 部分找到。只需单击 Interfaces
    旁边的箭头即可查看它们。我们甚至可以双击它们的名称来打开它们。打开以下函数：`TraceMove`、`TraceHit`、`TraceLeaveObject`
    和 `TraceActivateUp`：
- en: '![](img/309921df-2090-4589-abc5-a451b0967525.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/309921df-2090-4589-abc5-a451b0967525.png)'
- en: The Trace Move function
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Trace Move 函数
- en: For Trace Move, we need to program what happens as a line trace moves across
    our object. For the teleport volume, we want the visual element we created earlier
    (the glowing ring, TeleportViz) to move to wherever our line trace is hitting.
    To do this, we'll use a SetWorldLocation node. Right-click in the blueprint and
    search for Set World location. Choose SetWorldLocation (TeleportViz) from the
    list. Connect the execute output of the function node to its input and the execute
    output to the Return node.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 Trace Move，我们需要编写当线迹穿过我们的对象时会发生什么。对于传送体积，我们希望将我们之前创建的视觉元素（发光的环，TeleportViz）移动到线迹击中的任何地方。为此，我们将使用一个
    SetWorldLocation 节点。在蓝图上右键单击并搜索 Set World location。从列表中选择 SetWorldLocation (TeleportViz)。将函数节点的执行输出连接到其输入，并将执行输出连接到
    Return 节点。
- en: SetWorldLocation needs a New Location input to know where to move TeleportViz
    to, and we can find that by breaking down the Hit result that comes as an input
    into the function. Create a Break Hit Result node and bring in the Hit from the
    function node as the input. We can take the Location output from the break and
    use that as the New Location input on the Set World Location.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SetWorldLocation 需要一个 New Location 输入来知道将 TeleportViz 移动到何处，我们可以通过将作为函数输入传入的
    Hit 结果分解来找到它。创建一个 Break Hit Result 节点并将函数节点上的 Hit 作为输入。我们可以从分解中获取 Location 输出并将其用作
    Set World Location 上的 New Location 输入。
- en: Next, choose the TraceHit function. In this function, we want to turn on the
    visibility of our TeleportViz mesh so that our player can see where they'll appear.
    Right-click in the blueprint and create a Set Visibility (TeleportViz) node. Connect
    it to the function node and to the Return node. On the node, turn on the New Visibility
    checkbox and the propagate to children checkbox.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，选择 TraceHit 函数。在这个函数中，我们希望打开我们的 TeleportViz 网格的可见性，以便我们的玩家可以看到他们将会出现的位置。在蓝图上右键单击并创建一个
    Set Visibility (TeleportViz) 节点。将其连接到函数节点和 Return 节点。在节点上，勾选 New Visibility 复选框和
    propagate to children 复选框。
- en: 'Now, let''s move on to the TraceLeaveObject function. This function will do
    something very similar to the TraceHit function, except we''ll be turning the
    visibility back to off. Similar to the preceding, create a Set Visibility (TeleportViz)
    node and connect it to both the function node and the Return node. On the node
    itself, leave the box next to New Visibility unchecked, but do click the checkbox
    next to Propagate to Children:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们继续到 TraceLeaveObject 函数。这个函数将与 TraceHit 函数执行非常类似的功能，除了我们将把可见性重新设置为关闭。类似于前面的步骤，创建一个
    Set Visibility (TeleportViz) 节点并将其连接到函数节点和 Return 节点。在节点本身上，不要勾选 New Visibility
    旁边的框，但请点击 Propagate to Children 旁边的复选框：
- en: '![](img/e6c7b19f-a084-49ef-afdc-24edcebd4f6b.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e6c7b19f-a084-49ef-afdc-24edcebd4f6b.png)'
- en: The Teleport function
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: Teleport 函数
- en: Before we move on to the `TraceActivateUp`, we need to create a function that
    can handle the mechanics of the teleport. Over in the Functions section of the
    My Blueprint panel, click the + button and name the new function Teleport Player.
    Teleport Player needs to have a couple of input values to work. The first is named
    `Player` and will be of the type Actor. The second will be named `Loc` and this
    will be of the type Vector.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们继续到 `TraceActivateUp` 之前，我们需要创建一个可以处理传送机制的功能。在 My Blueprint 面板的 Functions
    部分中，点击 + 按钮，并将新功能命名为 Teleport Player。Teleport Player 需要一些输入值才能工作。第一个名为 `Player`，类型为
    Actor。第二个将命名为 `Loc`，类型为 Vector。
- en: The teleport itself will require a little bit of math and will need a bit of
    info from our Player Controller. Let's start the sequence by dragging an execute
    line from the function node and dropping it to open the search menu. Search for
    the Cast to PlayerController node and create it. Casting allows us to pretend
    to be another blueprint and is just one of many ways that allow us to communicate
    data between blueprints.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 传送本身需要一点数学计算，并且需要从我们的Player Controller获取一些信息。让我们通过从函数节点拖动一个执行线并将其放下以打开搜索菜单来开始序列。搜索“Cast
    to PlayerController”节点并创建它。转换允许我们假装成另一个蓝图，并且只是许多允许我们在蓝图之间通信数据的方法之一。
- en: Casting requires an Object input, a reference to the specific object we're pretending
    to be to access its data. To get the exact PlayerController we need, click and
    drag a line off the Player input on the function node and drop it. Search for
    the Get Controller node and connect its output to the input on the Cast to PlayerController
    node.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转换需要一个对象输入，即我们要假装成以访问其数据的特定对象的引用。为了获取我们需要的精确PlayerController，点击并从函数节点的Player输入拖动一条线并将其放下。搜索“Get
    Controller”节点并将其输出连接到“Cast to PlayerController”节点的输入。
- en: Next, create a SetActorLocation node. This will do the actual teleporting by
    moving the player to the designated vector coordinates. Connect the execution
    output from the cast into the execution input on SetActorLocation. The target
    input should be set to the Player by dragging a connection from the Player input
    on the function node to the Target input on SetActorLocation.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个“SetActorLocation”节点。这将通过将玩家移动到指定的向量坐标来完成实际传送。将转换的执行输出连接到“SetActorLocation”的执行输入。目标输入应设置为Player，通过从函数节点的Player输入拖动一个连接并将其连接到“SetActorLocation”的目标输入。
- en: 'It''s now time to calculate the new location! To start, we''ll need to get
    the location of two things: the player and the player camera. To get the player''s
    location, drag a line off the Player input on the function node and drop it to
    open the search box. Search for the GetActorLocation node and create one. We''ll
    need this data in a moment.'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是计算新位置的时候了！首先，我们需要获取两样东西的位置：玩家和玩家相机。为了获取玩家的位置，从函数节点的Player输入拖动一条线并将其放下以打开搜索框。搜索“GetActorLocation”节点并创建一个。我们很快就需要这些数据。
- en: Drag a line off the as Player Controller output from our Cast to PlayerController
    node and use it to search for the Get Player Camera Manager node. Drag off the
    output of that and search for the Get Camera Location node.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从我们的“Cast to PlayerController”节点的“as Player Controller”输出拖动一条线，并使用它来搜索“Get Player
    Camera Manager”节点。从该节点的输出拖动并搜索“Get Camera Location”节点。
- en: 'Here is the math part: We need to subtract the location of the player''s camera
    from the location of the player itself to find the true location of the HMD for
    our teleport. For that, we''ll need a Vector - Vector node. The top input will
    be the vector output from our GetActorLocation node. The bottom input will be
    the vector from the GetCameraLocation node.'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面是数学部分：我们需要从玩家的相机位置减去玩家本身的位置，以找到我们传送的真确位置。为此，我们需要一个“Vector - Vector”节点。顶部输入将是“GetActorLocation”节点的向量输出。底部输入将是“GetCameraLocation”节点的向量。
- en: We're almost there! Right-click on the output pin of our `Vector - Vector` node
    and split the struct pin. We only need the X and Y value for the next part of
    the calculation. Create a new `Vector + Vector` node and split the struct pin
    on the top input. Connect the X and Y output values from `Vector - Vector` into
    the *X* and *Y* input values on the `Vector + Vector` node. The bottom vector
    input comes from the Loc input from the function node. Drag a connection from
    the Loc input on the function node and connect it to the bottom vector input on
    the `Vector + Vector`.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们几乎完成了！在“Vector - Vector”节点的输出引脚上右键单击并拆分结构引脚。我们只需要计算下一部分所需的X和Y值。创建一个新的“Vector
    + Vector”节点，并在顶部输入上拆分结构引脚。将“Vector - Vector”的X和Y输出值连接到“Vector + Vector”节点的X和Y输入值。底部向量输入来自函数节点的Loc输入。从函数节点的Loc输入拖动一个连接并将其连接到“Vector
    + Vector”的底部向量输入。
- en: Don't forget that you can use reroute nodes to clean up your code to make it
    organized and readable. Reroute nodes can be found in the search menu if you drag
    off a connection and drop it. They can also be created by double-clicking on the
    connection where you would like to create one.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记，您可以使用重定向节点来清理代码，使其有组织且易于阅读。如果您拖动一个连接并将其放下，可以在搜索菜单中找到重定向节点。您还可以通过在想要创建重定向节点的连接上双击来创建它们。
- en: 'With that, the calculation is complete! Plug the output from the `Vector +
    Vector` node into the New Location input on SetActorLocation to complete the sequence:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这样，计算就完成了！将`Vector + Vector`节点的输出连接到SetActorLocation的New Location输入以完成序列：
- en: '![](img/30b5f54e-1ce3-42e8-8e02-6c0fdfae4215.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/30b5f54e-1ce3-42e8-8e02-6c0fdfae4215.png)'
- en: Trace Activate Up
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Trace Activate Up
- en: The last function to program is Trace Activate Up, or what happens when a player
    releases the button of their motion controller. Click the tab we opened earlier
    or double-click the function name in the Functions section of the My Blueprint
    panel. Using our new Teleport Player function, we're going to move the player
    to the new location. Grab a copy of our Teleport Player function and drag it into
    the blueprint. Connect the Instigator input from the function node to the Player
    input on Teleport Player.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后要编程的功能是Trace Activate Up，或者当玩家释放动作控制器的按钮时会发生什么。点击我们之前打开的选项卡或双击My Blueprint面板的函数部分中的函数名称。使用我们新的Teleport
    Player函数，我们将玩家移动到新位置。从函数节点拖取我们的Teleport Player函数副本并将其拖入蓝图。将函数节点的激发者输入连接到Teleport
    Player的玩家输入。
- en: Calculating the exact location to teleport to just a bit more math. Drag a line
    off the Hit input on the function node and drop it to open the search menu. Create
    a Break Hit Result node and right-click on the Location output to split the struct.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算精确的传送位置只需要一点数学知识。从函数节点的Hit输入拖出一条线并将其拖到打开搜索菜单。创建一个Break Hit Result节点，并右键单击位置输出以拆分结构。
- en: Create a Get Actor Location node and position it near the Break Hit node. Right-click
    on the vector output and split that struct pin as well.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个获取演员位置节点并将其放置在Break Hit节点附近。右键单击矢量输出并将该结构引脚也拆分。
- en: Next, right-click on the Loc input on the Teleport Player node and (you guessed
    it!) split the struct pin.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，右键单击Teleport Player节点上的Loc输入，并（不出所料！）拆分结构引脚。
- en: It's time to pass in the *XYZ* values! Connect the Location X and Location Y
    outputs from Break Hit to the Loc X and Loc Y inputs on Teleport Player. Also,
    connect the Z output from the Get Actor Location node to the Loc Z input on Teleport
    Player.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候传递*XYZ*值了！将Break Hit的Location X和Location Y输出连接到Teleport Player的Loc X和Loc
    Y输入。同时，将Get Actor Location节点的Z输出连接到Teleport Player的Loc Z输入。
- en: Finish the sequence by connecting the execute output from Teleport Player to
    the Function Return node.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将Teleport Player的执行输出连接到函数返回节点来完成序列。
- en: With the teleport volume complete, we can now test our ability to teleport,
    as well as all of the systems that support it (parabolic line tracing and the
    Object Interaction Interface). Throw a few of the TeleportVol blueprints down
    in your test level and go nuts trying it out! If everything works, we can move
    on to building a prototype puzzle box.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成传送体积后，我们现在可以测试我们的传送能力，以及支持它的所有系统（抛物线线追踪和对象交互界面）。在你的测试级别中放下几个TeleportVol蓝图，尽情尝试！如果一切正常，我们可以继续构建原型拼图盒。
- en: The server – Building the puzzle box
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器 – 构建拼图盒
- en: 'With the player now having the ability to touch things and teleport around
    our test level, it''s now time tackle the puzzle box. In *Server 17*, the puzzle
    box is a graphical representation of the player hacking into a remote server and
    stealing data. The final version may contain several puzzles to solve and dozens
    of steps to complete. However, for this first prototype version, we''re going
    to design and build a simple three-step box as shown as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在玩家有了触摸物体和在我们测试级别中传送的能力，现在是时候解决拼图盒了。在*Server 17*中，拼图盒是玩家远程入侵服务器并窃取数据的图形表示。最终版本可能包含多个需要解决的谜题和数十个需要完成的步骤。然而，对于这个第一个原型版本，我们将设计和构建一个简单的三步盒，如下所示：
- en: '![](img/22b17ba4-639d-4bce-bb60-576804297a58.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/22b17ba4-639d-4bce-bb60-576804297a58.png)'
- en: This design requires the player to find and remove a panel on the box to reveal
    a button that unlocks the front of the box. This panel can then be removed by
    grabbing it and moving it to the side revealing another switch. The final step
    is to then press the switch and find the removable panel to steal the data.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 此设计要求玩家找到并移除盒子上的一个面板，以露出一个解锁盒子前部的按钮。然后可以通过抓住它并将其移动到一边来移除该面板，从而露出另一个开关。最后一步是按下开关并找到可移除的面板以窃取数据。
- en: 'Building this in Unreal Engine 4 will have us creating a few things:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unreal Engine 4中构建此功能将使我们创建一些东西：
- en: We'll need to create additional functionality for the hands that our interface
    currently doesn't cover, such as grabbing, dragging, and pressing.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要为我们的界面目前未涵盖的手创建额外的功能，例如抓取、拖动和按下。
- en: We'll need an object that responds to the player's touch and can be grabbed,
    moved, and thrown.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个能够对玩家的触摸做出反应、可以被抓住、移动和扔出的对象。
- en: We'll need interactive buttons that can trigger events.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要可以触发事件的交互式按钮。
- en: We'll need to build the box itself using child actors and code to turn the interactive
    elements on and off.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要使用子演员和代码来构建盒子本身，以打开和关闭交互元素。
- en: 'When complete, we''ll have an amazing test platform that can be used to prove
    that *Server 17* is fun and that can be tested by our target demographic. The
    first step in moving forward is to build a second interface to hold our button
    interactions:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 当完成时，我们将拥有一个令人惊叹的测试平台，可以用来证明*服务器17*很有趣，并且可以由我们的目标受众进行测试。向前推进的第一步是构建第二个界面来容纳我们的按钮交互：
- en: '![](img/a7325795-74eb-4ff8-973e-92780b0956bd.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a7325795-74eb-4ff8-973e-92780b0956bd.png)'
- en: Button Interaction Interface
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮交互界面
- en: 'It''s time to create the Button Interaction Interface:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候创建按钮交互界面了：
- en: Head to the Content Browser and navigate to our `Server17\Blueprints` folder.
    Right-click in the browser and navigate to the Create Advanced Asset section of
    the menu. Highlight the Blueprint Entry and choose the Blueprint Interface option.
    Name the new interface `ButtonInteractionInterface`. Double-click the new interface
    to open it.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往内容浏览器，导航到我们的`Server17\Blueprints`文件夹。在浏览器中右键单击，并导航到菜单中的创建高级资产部分。突出显示蓝图条目，并选择蓝图界面选项。将新界面命名为`ButtonInteractionInterface`。双击新界面以打开它。
- en: In this interface, we'll create nine different functions that represent the
    different states of the actions we're creating. The first is a function to determine
    what to do when we're hovering our hand over something. Find the Functions section
    of the My Blueprint panel and click the + button. Name the new function `OnHover`.
    `OnHover` will need one input named `Interactor` of the type Interaction Component.
    It'll also need an output named Return of the Boolean type to make it function
    properly.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个界面中，我们将创建九个不同的函数，代表我们创建的动作的不同状态。第一个是一个确定当我们把手悬停在某个东西上时要做什么的函数。在My Blueprint面板的函数部分找到并点击+按钮。将新函数命名为`OnHover`。`OnHover`需要一个名为`Interactor`的输入，类型为Interaction
    Component。它还需要一个名为Return的布尔类型输出，以便它能够正常工作。
- en: The next function will be named `EndHover` and controls what happens when the
    player's hand leaves an object. It has the same input and output as the previous
    function.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个函数将被命名为`EndHover`，它控制当玩家的手离开一个对象时会发生什么。它有与上一个函数相同的输入和输出。
- en: Now we'll create the `OnPickup` function to cover what happens when we want
    to pick up an object, which is a very common interaction in VR. It has the same
    input and output as the last two functions.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建`OnPickup`函数来覆盖当我们想要拾取一个对象时会发生什么，这在VR中是一个非常常见的交互。它的输入和输出与最后两个函数相同。
- en: Next is the  `OnDrop` function; this will give us the opportunity to create
    additional functions when the player drops an object. It also has the same input
    and output as the last few functions.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是`OnDrop`函数；这个函数将给我们机会在玩家丢弃一个对象时创建额外的函数。它也有与最后几个函数相同的输入和输出。
- en: The next three functions control the dragging of objects and allow us the opportunity
    to create even more gameplay with these actions. Create functions named `OnDrag`,
    `OnDragStart`, and `OnDragEnd`. They have the same input and output as all of
    the other functions that we've created here so far.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来的三个函数控制对象的拖动，并允许我们通过这些动作创建更多的游戏玩法。创建名为`OnDrag`、`OnDragStart`和`OnDragEnd`的函数。它们的输入和输出与迄今为止我们创建的所有其他函数相同。
- en: 'Finally, here''s one that''s different! Create a new function and name it `CanPickUp`.
    This function controls a Boolean that determines whether something is allowed
    to be picked up. It only has one output: a Boolean with the name `PickUp`.'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，这里有一个不同！创建一个新的函数，并将其命名为`CanPickUp`。这个函数控制一个布尔值，用于确定是否允许拾取某个东西。它只有一个输出：名为`PickUp`的布尔值。
- en: This is the last one. Create one more function. This one is named `OnUse` and
    allows us to create objects that can be used as power ups. `OnUse` has input and
    output identical to `OnHover`.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是最后一个。再创建一个函数。这个函数被命名为`OnUse`，允许我们创建可以作为加成使用的对象。`OnUse`的输入和输出与`OnHover`相同。
- en: 'We now have a second interface that allows us as designers as much freedom
    to create interactions as we have imagination. To test out our new player abilities,
    let''s build a basic cube that can be interacted with in several different ways:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了第二个接口，它允许我们作为设计师有足够的自由，根据我们的想象力来创建交互。为了测试我们新的玩家能力，让我们构建一个基本的立方体，它可以以几种不同的方式进行交互：
- en: '![](img/2d15ebff-52b5-4770-b564-b8a5776b9cfd.png)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2d15ebff-52b5-4770-b564-b8a5776b9cfd.png)'
- en: InteractCube with interface
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 与界面交互的立方体
- en: 'To test our systems (and have a little fun), we''re going to create a cube
    that utilizes many of the new functions that we''ve created in this chapter:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的系统（并有点乐趣），我们将创建一个立方体，它利用了我们在本章中创建的许多新功能：
- en: Make sure you're in the `Server17\Blueprints` folder and right-click in the Content Browser
    to create a new Blueprint Class. Choose Actor in the Pick Parent Class menu and
    name our new blueprint `InteractCube`.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你处于`Server17\Blueprints`文件夹中，并在内容浏览器中右键单击以创建一个新的蓝图类。在“选择父类”菜单中选择Actor，并将我们的新蓝图命名为`InteractCube`。
- en: Click the Add Component button in the Components panel and choose the Cube option
    from the Common section of the menu. In the Details panel, find the Scale values
    near the top and set the values so that X=0.3, Y=0.3, and Z=0.3.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件面板中点击“添加组件”按钮，并在菜单的通用部分选择立方体选项。在详细信息面板中，找到顶部附近的缩放值，并将值设置为X=0.3，Y=0.3，Z=0.3。
- en: It's time to add the interfaces. Click the Class Defaults button at the top
    of the screen. In the Details panel, click the Add button in the Interfaces section.
    Search for and add both the Object Interaction Interface and the Button Interaction
    Interface.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候添加接口了。在屏幕顶部点击“类默认值”按钮。在详细信息面板中，在接口部分点击“添加”按钮。搜索并添加对象交互接口和按钮交互接口。
- en: Now we have a load of functions to play with! Let's start with a way to tell
    when the cube is being hit by a line trace. Open the Interfaces section of the
    My Blueprints panel and open the `TraceHitObject` function. Right-click in the
    blueprint and search for the set Vector Parameter Value (Cube) on the Materials
    node. This node allows us to access the Color parameter on the cube's default
    material. Connect it to the function node and the Return node. Next, set the value
    of Parameter Name to Color. Finally, let's turn the cube red by changing the Parameter
    Value X value to 1.0\. Now the cube will turn red when hit by a line trace!
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有很多功能可以玩！让我们从检测立方体被线迹击中的方式开始。打开我的蓝图面板的界面部分，并打开`TraceHitObject`函数。在蓝图上右键单击并搜索材料节点上的“设置向量参数值（立方体）”。此节点允许我们访问立方体默认材质上的颜色参数。将其连接到函数节点和返回节点。接下来，将参数名称的值设置为颜色。最后，通过将参数值X的值更改为1.0，让我们将立方体变成红色。现在，当立方体被线迹击中时，它将变成红色！
- en: Let's set the color back to white when the line trace leaves the cube. Double-click
    the `TraceLeaveObject` function in the Interfaces menu. Grab the same set Vector
    Parameter Value (Cube) node we used before, only, this time, set the values of
    Parameter Value to X=1.0, Y=1.0, and Z=1.0.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在线迹离开立方体时将颜色重新设置为白色。在界面菜单中双击`TraceLeaveObject`函数。抓取我们之前使用的相同的“设置向量参数值（立方体）”节点，这次，将参数值的X设置为1.0，Y设置为1.0，Z设置为1.0。
- en: Having fun yet? Let's open the `TraceActivateDown` function from the Interfaces
    menu. Using the same preceding technique, create the Set Vector Parameter Value
    (Cube) node, type in the Color for the Parameter Name, and set the values of Parameter
    Value to X=0, Y=1.0, and Z=0\. Our cube now turns green when we click the button
    to interact with it!
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还在玩得开心吗？让我们从界面菜单中打开`TraceActivateDown`函数。使用相同的前置技术，创建一个“设置向量参数值（立方体）”节点，输入参数名称的“颜色”，并将参数值的X设置为0，Y设置为1.0，Z设置为0。现在，当我们点击按钮与之交互时，我们的立方体变成了绿色！
- en: If we use `TraceActivateDown`, we should probably use `TraceActivateUp`. Let's
    set it up to change the color back to red when we release the button. Open the
    function and create another set Vector Parameter Value (Cube) node. Wire it into
    the function, set the value of Parameter Name to Color, and change the values
    of Parameter Value to X=1.0, Y=0, and Z=0.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们使用`TraceActivateDown`，我们可能还需要使用`TraceActivateUp`。让我们设置它，以便在释放按钮时将颜色重新变回红色。打开函数并创建另一个“设置向量参数值（立方体）”节点。将其连接到函数，将参数名称的值设置为颜色，并将参数值的X设置为1.0，Y设置为0，Z设置为0。
- en: Want to have a little more fun with our functions? Use the Add Impulse node where
    the target of the node is a Scene Component to create a sudden upward acceleration.
    Replace one of the set Vector Parameter Value nodes with Add Impulse and change
    the Z value of the Impulse parameter to 5000\. Make sure to turn on the checkbox
    for Velocity Change. This will shoot the cube skyward when the button is pressed
    or released!
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 想要在我们的函数中玩得更开心吗？使用添加冲量节点，其中节点的目标是场景组件，以创建突然向上的加速度。将设置向量参数值节点中的一个替换为添加冲量，并将冲量参数的Z值更改为5000。确保勾选速度变化复选框。这样，当按钮被按下或释放时，立方体将向天空射击！
- en: How about we try the cube able to be picked up and thrown? To create this mechanism,
    we'll have Unreal simulate physics on our cube and then toggle this feature off
    and on when we pick up and drop the cube. Open the `OnPickup` and `OnDrop` functions. In
    `OnPickup`, right-click in the blueprint and search for the node set Simulate
    Physics (Cube). Wire the execution input and output the the function node and
    the Return node, as it'll be the only node we use in this function. This will
    disable the physics when the cube is picked up so it won't fall out of the player's
    hands or exhibit other strange behavior. Now open `OnDrop` and create another
    copy of set Simulate Physics (Cube). This time, turn on the checkbox next to the
    option to Simulate Physics on the node. This will enable the physics when the
    cube is dropped so it behaves the way we intend. Finally, head back to the Viewport
    tab and click on the cube. Check the Details panel to make sure the Simulate Physics
    option is turned on. If it's not, enable it.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们尝试让立方体可以被捡起和扔出去怎么样？为了创建这个机制，我们将让虚幻引擎对我们的立方体进行物理模拟，然后在捡起和放下立方体时切换这个功能的开和关。打开`OnPickup`和`OnDrop`函数。在`OnPickup`中，在蓝图上右键点击并搜索设置物理模拟（立方体）的节点。将执行输入和输出连接到函数节点和返回节点，因为这将是我们在这个函数中使用的唯一节点。这样，当立方体被捡起时，将禁用物理模拟，这样它就不会从玩家的手中掉落或表现出其他奇怪的行为。现在打开`OnDrop`并创建另一个设置物理模拟（立方体）的副本。这次，在节点旁边的“模拟物理”选项旁边勾选复选框。这样，当立方体被放下时，将启用物理模拟，使其按我们的意图行事。最后，回到视口选项卡，点击立方体。检查详细信息面板，确保已启用模拟物理选项。如果未启用，请启用它。
- en: There's one more function to set up. Go back to the Interfaces section of the
    My Blueprints panel and open the `CanPickUp` function. To make it so we can toggle
    this feature on and off, we're going to need a Boolean that we can toggle. In
    the Variables section, click the + button and create a new Boolean variable named
    `PickUpActive`. Back in the `CanPickUp` function, drag in a copy of our new variable
    and choose get from the menu. Plug the output of `PickUpActive` into the `PickUp`
    input on the Return node.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还有一个函数需要设置。回到我的蓝图面板的接口部分，打开`CanPickUp`函数。为了能够开关这个功能，我们需要一个可以切换的布尔值。在变量部分，点击+按钮并创建一个名为`PickUpActive`的新布尔变量。回到`CanPickUp`函数，拖入我们新变量的副本并从菜单中选择获取。将`PickUpActive`的输出连接到返回节点的`PickUp`输入。
- en: 'To make use of these new functions, we''ll need to set up a way to call them
    in the Interaction Component, as well as map them to buttons in `Server17PlayerPawn`.
    This is exactly like what we did when we created the Object Interaction Interface
    earlier in this chapter. Head back to the Content Browser and open the Interaction
    Component:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这些新功能，我们需要在交互组件中设置调用它们的方法，并将它们映射到`Server17PlayerPawn`中的按钮。这就像我们在本章早期创建对象交互接口时做的那样。回到内容浏览器，打开交互组件：
- en: '![](img/3aff3444-e764-42b6-bb2e-d0e8560ed210.png)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3aff3444-e764-42b6-bb2e-d0e8560ed210.png)'
- en: The Hover interaction component code
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 悬停交互组件代码
- en: Inside the Interaction Component, we need to add some of the new player functionality,
    but the current code doesn't allow for that kind of expansion. To change that,
    we're going to use a Sequence node. The Sequence node is a flow-control node that
    implements the code connected to each of its output pins in order. To implement
    our new functions, we'll want to add the Sequence node after the Gate. Right-click
    in the blueprint and search for the Sequence node. Once created, click the Add
    Pin button in the bottom-left portion of the node. This will add an additional
    execution output. Connect the Sequence right after the Gate and connect the Parabolic
    Line Trace node to the execution output labeled Then 0.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在交互组件内部，我们需要添加一些新的玩家功能，但当前的代码不允许这种扩展。为了改变这一点，我们将使用一个序列节点。序列节点是一个流程控制节点，它按照每个输出引脚连接的代码顺序执行。为了实现我们的新功能，我们希望在门之后添加序列节点。在蓝图上右键单击并搜索序列节点。一旦创建，点击节点左下角的“添加引脚”按钮。这将添加一个额外的执行输出。将序列直接连接在门之后，并将抛物线线迹节点连接到标记为Then
    0的执行输出。
- en: Before we begin implementing the Hover, Drag, and Pickup features, we'll need
    a few more variables. Click the + button in Variables section of the My Blueprint
    panel and create a new Float variable named `InteractRadius`. Compile the blueprint
    and give it a default value of 10\. Next, create two variables of the type Actor,
    one named `HoverObject` and the other named `HeldObject`. Finally, create one
    more Boolean variable and name it `Dragging`.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开始实现悬停、拖拽和拾取功能之前，我们还需要一些额外的变量。在“我的蓝图”面板的变量部分点击“+”按钮并创建一个名为`InteractRadius`的新浮点变量。编译蓝图并为其设置默认值10。接下来，创建两个类型为Actor的变量，一个命名为`HoverObject`，另一个命名为`HeldObject`。最后，创建一个布尔变量并命名为`Dragging`。
- en: Let's start by implementing the Hovering and Dragging behavior. Drag an execute
    line from the Then 1 output on our new Sequence node and drop it in a clear area
    of the blueprint. The node we're looking for is called SphereOverlapActors and
    is designed to return the objects that it detects within a specific radius.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先实现悬停和拖拽行为。从我们新序列节点的Then 1输出拖动一条执行线并将其放置在蓝图的一个空白区域。我们要找的节点叫做SphereOverlapActors，它被设计用来返回它在特定半径内检测到的对象。
- en: SphereOverlapActors needs four different input values. The first is Sphere Position
    (or Pos). We want the sphere to detect from wherever the interaction component
    is located. Drag a line from the Sphere Pos input and drop it. Search for the
    GetWordlocation node. This will give us an input of where the interaction components
    are in world space.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SphereOverlapActors需要四个不同的输入值。第一个是“球体位置”（或Pos）。我们希望球体从交互组件所在的位置进行检测。从Sphere
    Pos输入拖动一条线并放下。搜索“获取位置”节点。这将给我们一个输入，表示交互组件在世界空间中的位置。
- en: For the next input, grab a copy of our InteractRadius variable and choose Get
    from the menu. This will give a 10 cm detection radius for our interactions and
    make that radius easily adjustable through the variable.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于下一个输入，获取我们的InteractRadius变量的副本并从菜单中选择“获取”。这将为我们交互提供一个10厘米的检测半径，并通过变量轻松调整该半径。
- en: Now we want to filter what the player can interact with. Drag a line off the
    Object Types input and search for the Make Array node. Click the Add Pin button
    on the node and use the two drop-down menus to choose the WorldDynamic and PhysicsBody
    options.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们想要过滤玩家可以与之交互的对象。从对象类型输入拖动一条线并搜索“创建数组”节点。在节点上点击“添加引脚”按钮并使用两个下拉菜单选择“世界动态”和“物理体”选项。
- en: Finally, we want the player to ignore anything classified as itself so one motion
    controller can't interact with the other motion controller, for example. Right-click
    in the blueprint and use the search box to find the Get Owner node. This will
    return a reference to the player as an Actor. Since SphereOverlapActors only accepts
    an array as an input for Actors To Ignore, we'll need to insert the output from
    Get Owner into an array. Drag off from the Return value on Get Owner and drop
    it. Find the Make Array node and plug the resulting array into the final input
    on SphereOverlapActors.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们希望玩家忽略任何被归类为自身的对象，这样就不会出现一个动作控制器与另一个动作控制器交互的情况，例如。在蓝图上右键单击并使用搜索框查找“获取所有者”节点。这将返回一个指向玩家的Actor引用。由于SphereOverlapActors只接受一个数组作为忽略Actors的输入，我们需要将“获取所有者”的输出插入到一个数组中。从“获取所有者”的返回值拖动一条线并放下。找到“创建数组”节点并将结果数组连接到SphereOverlapActors的最终输入。
- en: 'SphereOverlapActors will now return an array of objects that match our criteria.
    With the output, we need to do a quick check to see whether the HoverObject we''ve
    stored in the variable is the same as the one we just took in. If they''re the
    same, there''s no reason to proceed; this will save us a bit of performance. Drag
    off the Out Actors output and search for the Get node. This will retrieve the
    item from the area at index 0 (the array should only contain one object). Next,
    get a reference to our HoverObject variable. Finally, to compare them, drag off
    the HoverObject variable and search for the NotEqual node. One input should be
    our HoverObject and the other should be the output of our Get node:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SphereOverlapActors 现在将返回一个符合我们标准的对象数组。使用输出，我们需要快速检查我们存储在变量中的 HoverObject 是否与我们刚刚获取的对象相同。如果它们相同，就没有继续的理由；这将节省我们一些性能。从
    Out Actors 输出拖出，并搜索 Get 节点。这将检索索引 0（数组应只包含一个对象）区域的项目。接下来，获取我们的 HoverObject 变量的引用。最后，为了比较它们，从
    HoverObject 变量拖出并搜索 NotEqual 节点。一个输入应该是我们的 HoverObject，另一个应该是我们的 Get 节点的输出：
- en: '![](img/f2bf60cc-79da-45c4-b2df-6ac9f309ee46.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f2bf60cc-79da-45c4-b2df-6ac9f309ee46.png)'
- en: The second part of the Hover code
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: Hover 代码的第二部分
- en: NotEqual will return a Boolean, so we'll need a Branch to continue. Connect
    the Branch to the execution output from the SphereOverlapActors node. The condition
    will be the result of the NotEqual node and we'll move forward only if it's `True`.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: NotEqual 将返回一个布尔值，因此我们需要一个分支来继续。将分支连接到来自 SphereOverlapActors 节点的执行输出。条件将是 NotEqual
    节点的结果，并且只有当它是 `True` 时我们才会继续前进。
- en: If our comparison is True and the two objects aren't the same, we're going to
    need to end the hovering behavior on the current object and set up the hovering
    or dragging behavior to work with the new object. Drag off from the True output
    on the Branch and search for our EndHover function from our Button Interaction
    Interface. Get a copy of our HoverObject variable and plug that into the Target
    input and use a Reference to Self as the Interactor input.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们的比较结果是 True，并且两个对象不相同，我们需要在当前对象上结束悬停行为，并设置悬停或拖动行为以与新对象一起工作。从分支的 True 输出拖出，并搜索我们的
    Button Interaction Interface 中的 EndHover 函数。获取 HoverObject 变量的副本并将其插入到目标输入中，并使用
    Self 引用作为交互者输入。
- en: Next, create a copy of our EndDrag function and connect it to the execution
    output from our EndHover node.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建 EndDrag 函数的副本并将其连接到 EndHover 节点的执行输出。
- en: Now we need to update the HoverObject variable with the new object we're hovering
    over. Drag in a copy of HoverObject  and choose Set from the menu. The input will
    be the output from our Get node from earlier.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要更新 HoverObject 变量，以包含我们正在悬停的新对象。拖入 HoverObject 的副本并从菜单中选择设置。输入将是之前 Get
    节点的输出。
- en: Lastly, we'll call the `OnHover` function to complete the sequence. Create a
    copy of our `OnHover` function and connect that to the execute output from the
    set HoverObject. The variable output from set the HoverObject can be used as the
    Target. Use a Reference to Self as as the Interactor input.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将调用 `OnHover` 函数来完成序列。创建 `OnHover` 函数的副本并将其连接到 set HoverObject 的执行输出。set
    HoverObject 的变量输出可以用作目标。使用 Self 引用作为交互者输入。
- en: 'Our hovering code allows us to detect what the player might be reaching out
    for or holding their hand over, such as a button or an other component. Next,
    we''ll tackle Dragging:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们悬停的代码使我们能够检测玩家可能伸手去拿或手放在其上的对象，例如按钮或其他组件。接下来，我们将处理拖动：
- en: '![](img/09a90731-f6c6-4f8d-b1c6-f9a9eab29e41.png)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![](img/09a90731-f6c6-4f8d-b1c6-f9a9eab29e41.png)'
- en: Dragging code
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 拖动代码
- en: 'For Dragging, we''ll need to create two Custom Events that can be called from
    outside the blueprint. This is exactly the same technique we used to implement
    our ActivateUp and ActivateDown behavior earlier:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 对于拖动，我们需要创建两个可以从蓝图外部调用的自定义事件。这正是我们之前用来实现 ActivateUp 和 ActivateDown 行为的技术：
- en: To start, we'll create two Custom Events. Right-click in the blueprint and choose
    the Add Custom Event option. Name the first one `StartDrag` and the second one
    `EndDrag`.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建两个自定义事件。在蓝图上右键单击并选择添加自定义事件选项。将第一个命名为 `StartDrag`，第二个命名为 `EndDrag`。
- en: For both of our new events, we basically want to turn our Dragging Boolean on
    and off while calling our OnDragStart and OnDragEnd functions. Let's start with
    StartDrag. Grab a copy of our Dragging variable and choose Set from the menu.
    Connect the execution output from our event to set Dragging and click the checkbox
    on the node to set it to True.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们这两个新事件，我们基本上想要在调用 OnDragStart 和 OnDragEnd 函数的同时打开和关闭 Dragging 布尔值。让我们从 StartDrag
    开始。获取我们的 Dragging 变量的副本，并从菜单中选择 Set。将事件的执行输出连接到 set Dragging，并点击节点上的复选框将其设置为 True。
- en: Now we'll call our OnDragStart function. Drag a copy of OnDragStart into the
    blueprint from the Interfaces section of My Blueprint and connect an execution
    line from set Dragging. Plug in a copy of our HoverObject variable as the Target
    and use a Reference to Self as the Interactor.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将调用 OnDragStart 函数。从 My Blueprint 的接口部分拖动 OnDragStart 的副本到蓝图，并连接一个从 set
    Dragging 的执行线。将我们的 HoverObject 变量的副本作为目标，并使用 Self 作为交互者。
- en: Next, we can work with our EndDrag custom event. The first step is to check
    to see whether our Dragging Boolean is True; if it is, then we can end the current
    drag. Create a new Branch node and connect the execute output from our event to
    it. Get a copy of Dragging and connect this to the Condition input on the Branch.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用我们的 EndDrag 自定义事件。第一步是检查我们的 Dragging 布尔值是否为 True；如果是，那么我们可以结束当前的拖动。创建一个新的
    Branch 节点，并将我们事件中的执行输出连接到它。获取一个 Dragging 的副本，并将其连接到 Branch 上的条件输入。
- en: If Dragging is True, we need to update the variable and end the drag. Create
    another copy of Dragging, only this time choose Set from the menu and connect
    the True output from the Branch to it. Make sure the checkbox on Dragging is clear.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 Dragging 为 True，我们需要更新变量并结束拖动。创建 Dragging 的另一个副本，这次从菜单中选择 Set 并将其连接到 True
    的分支输出。确保 Dragging 的复选框是空的。
- en: It's time to create a copy of our OnDragEnd function. Connect the execute output
    from set Dragging to the execute input on our new node. Just as we did for OnDragStart earlier,
    connect HoverObject as our Target and use a Reference to Self as the Interactor.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候创建 OnDragEnd 函数的副本了。将 set Dragging 的执行输出连接到我们新节点的执行输入。就像我们之前为 OnDragStart
    所做的那样，将 HoverObject 作为目标，并使用 Self 作为交互者。
- en: It's time to bring these two sequences together. We'll use a Gate to control
    whether or not something can be dragged with our custom events controlling whether
    the Gate is open or closed. Create a new Gate node and connect the output from OnDragStart to
    the Open input and bring in the output from OnDragEnd into the Close input. We'll
    connect the Enter input to the Then 2 input on our Sequence node from earlier.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候将这两个序列组合在一起了。我们将使用一个 Gate 来控制是否可以使用自定义事件拖动某个东西。创建一个新的 Gate 节点，将 OnDragStart
    的输出连接到打开输入，并将 OnDragEnd 的输出连接到关闭输入。我们将连接早期 Sequence 节点的 Then 2 输入到进入输入。
- en: The final step to completing the drag is calling the OnDrag function. Create
    a copy and connect it to the Exit output from our Gate node we created in the
    last step. Just as we did for our previous drag functions, we'll connect a copy
    of our HoverObject variable to the Target input and plug in a Reference to Self
    as the Interactor.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成拖动的最后一步是调用 OnDrag 函数。创建一个副本并将其连接到我们在上一步创建的 Gate 节点的退出输出。就像我们之前为拖动函数所做的那样，我们将
    HoverObject 变量的副本连接到目标输入，并将 Self 作为交互者插入。
- en: 'We can now drag objects! Such a behavior might be useful in programming levers
    and other similar pieces that can be moved but not necessarily picked up. Speaking
    of picking up, the next feature we''ll tackle is the ability to pick things up
    and throw them. Much like hovering or dragging, there''s a similar trick to the
    pick-up-and drop behavior that happens behind the scenes. Most of the objects,
    but not all, will start with their Simulate Physics option enabled. The trick
    is this: when the object is picked up in VR, we''ll attach the object to the player''s
    hand so it can''t get away from them. We will also disable the physics on the
    object (we set this up earlier in the OnPickup function of our InteractCube).
    When we put down the object, we detach it from the player and re-enable the physics.
    Since the player never sees any of the changes, it looks to them as if they just
    picked up the object and then put it down. Cool, huh?'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以拖动物体了！这种行为可能在编程杠杆和其他可以移动但不必定能捡起的类似部件时很有用。说到捡起，我们将要解决的下个特性是捡起物品并扔掉的能力。与悬停或拖动类似，捡起和放下行为背后有一个类似的技巧。大多数物体，但并非全部，都会启用它们的模拟物理选项。这个技巧是这样的：当物体在VR中被捡起时，我们将物体附加到玩家的手上，这样它就不会从他们手中逃走。我们还将禁用物体的物理（我们在InteractCube的OnPickup函数中之前已经设置过）。当我们放下物体时，我们将它从玩家那里分离出来并重新启用物理。由于玩家从未看到任何变化，所以对他们来说，就像他们只是捡起物体然后放下一样。酷吧？
- en: 'Let''s build it:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始构建：
- en: '![](img/c209bda3-9713-4d48-9023-2d7cd141b16f.png)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c209bda3-9713-4d48-9023-2d7cd141b16f.png)'
- en: Pickup code
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 捡起代码
- en: 'Just as we did for the dragging behavior, we''ll start by creating two custom
    events: one for Pickup and one for Drop:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们对拖动行为所做的那样，我们首先创建两个自定义事件：一个用于捡起，另一个用于放下：
- en: Right-click in our blueprint and create two new custom events with the Add Custom
    Event option. Name the first `Pickup` and the second `Drop`.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的蓝图上右键单击，并使用添加自定义事件选项创建两个新的自定义事件。将第一个命名为“捡起”，第二个命名为“放下”。
- en: We'll start by building the pickup behavior. We need to start by checking whether
    the object the player is hovering over is a valid object. Right-click in the blueprint
    and search for the IsValid node. The version we need is marked with a question
    mark as its icon. Connect it to our Pickup event and create a copy of our HoverObject
    variable, which will serve as the input for the Input object pin on the node.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先构建捡起行为。我们需要首先检查玩家悬停的物体是否是有效的物体。在蓝图上右键单击并搜索IsValid节点。我们需要的是图标上带有问号的版本。将其连接到我们的捡起事件，并创建HoverObject变量的副本，它将作为节点上输入对象引脚的输入。
- en: Now that we know whether the object is real (in a manner of speaking), we can
    check to see whether we can pick it up! Create a copy of our CanPickUp function
    and connect HoverObject as the Target. This will return a True or False, which
    will determine whether the player can pick up the object.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 既然我们知道物体是否真实（从某种意义上说），我们可以检查我们是否可以捡起它！创建CanPickUp函数的副本，并将HoverObject作为目标连接。这将返回True或False，这将决定玩家是否可以捡起该物体。
- en: Next, we need a Branch to process the Boolean from CanPickUp. We only want the
    player to pick things up if this is True. Create a new Branch node and connect
    it to the execute output from CanPickUp. The Condition input will be the PickUp
    output from CanPickUp.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个分支来处理从CanPickUp传来的布尔值。我们只希望当这个值为True时，玩家才能捡起物品。创建一个新的分支节点，并将其连接到CanPickUp的执行输出。条件输入将是来自CanPickUp的PickUp输出。
- en: We know now whether the object is real. We also know whether we're allowed to
    pickup it. Now it's the time to do the heavy lifting. Create a copy of our HeldObject
    variable and choose set from the menu. The input for Set HeldObject will be the
    current value of HoverObject.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在知道物体是否真实。我们也知道我们是否允许捡起它。现在是时候进行重头戏了。创建HeldObject变量的副本，并从菜单中选择设置。设置HeldObject的输入将是HoverObject的当前值。
- en: Next, create a copy of the AttachToComponent node, making sure we're using the
    Target is Actor version. Connect it to the output of  the set HeldObject. Also,
    pass the variable output of set HeldObject into the Target input on AttachToComponent.
    Now create a Reference to Self and plug that into the Parent input. Lastly, set
    the Location Rule, Rotation Rule, and Scale Rule settings in the node to the Keep
    World option. This will maintain the basic attributes of the object we pick up
    so that, when we drop it, everything will remain the same.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个 AttachToComponent 节点的副本，确保我们使用的是 Target 是 Actor 版本。将其连接到 set HeldObject
    的输出。也将 set HeldObject 的变量输出传递到 AttachToComponent 的 Target 输入。现在创建一个 Self 引用并将其插入到
    Parent 输入。最后，在节点中设置 Location Rule、Rotation Rule 和 Scale Rule 设置为 Keep World 选项。这将保持我们拾取的物体的基本属性，以便当我们放下它时，一切都将保持不变。
- en: The next step is to call our OnPickup function to trigger any special behaviors
    we might want for that object. Create a copy of OnPickup and connect the output
    from AttachToComponent to it. Connect a copy of the HeldObject variable to the
    Target input and use a Reference to Self as the Interactor.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是调用我们的 OnPickup 函数来触发我们可能想要为该对象执行的特殊行为。创建 OnPickup 的一个副本，并将 AttachToComponent
    的输出连接到它。将 HeldObject 变量的一个副本连接到 Target 输入，并使用 Self 引用作为 Interactor。
- en: 'Now that we have the ability to pick things up and drop them, we may want the
    player to be able to use something they''re hovering over. To create this behavior,
    we''ll need to create a custom event named UseHovered. Next, create a copy of
    our `OnUse` function and connect it to our custom event. Get a copy of our HoverObject
    variable to use as the Target. Finish the node with a Reference to Self to use
    as the Interactor:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了拾取和放下物品的能力，我们可能想让玩家能够使用他们悬停的物品。为了创建这种行为，我们需要创建一个名为 UseHovered 的自定义事件。接下来，创建我们的
    `OnUse` 函数的副本并将其连接到我们的自定义事件。获取我们的 HoverObject 变量的一个副本作为 Target。完成节点时，使用 Self 引用作为
    Interactor：
- en: '![](img/90ff10c8-2d12-499d-b05a-605af0ccfc64.png)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/90ff10c8-2d12-499d-b05a-605af0ccfc64.png)'
- en: Pickup/Drop and Hover/Drag code in player pawn
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家 pawn 中的拾取/放下和悬停/拖拽代码
- en: To be able to utilize our new behaviors (Hover, Drag, Pickup, and Drop), we'll
    need to map them to buttons on the player's motion controller. Let's add hover
    and drag to the triggers. Open `Server17PlayerPawn` and find where we mapped ActivateUp
    and ActivateDown to the motion controller triggers. We'll start with the left
    trigger. Extend an execute line from ActivateDown and drop it to search for our
    UseHovered function (referencing the left interaction component). Next, drag off
    the reference to InteractionComponent_L and search for the StartDrag function.
    Connect this to the execute output on the UseHovered function. Finish by dragging
    off the reference to InteractionComponent_L again and searching for EndDrag. We'll
    connect this to the execution output from ActivateUp. Now we can use hovered objects,
    as well as start and end drag sequences!
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了能够利用我们新的行为（悬停、拖拽、拾取和放下），我们需要将它们映射到玩家的运动控制器上的按钮。让我们将悬停和拖拽添加到触发器上。打开 `Server17PlayerPawn`
    并找到我们映射 ActivateUp 和 ActivateDown 到运动控制器触发器的位置。我们将从左侧触发器开始。从 ActivateDown 扩展一条执行线并将其拖动到搜索我们的
    UseHovered 函数（引用左侧交互组件）。接下来，从 InteractionComponent_L 的引用拖动出来并搜索 StartDrag 函数。将其连接到
    UseHovered 函数的执行输出。最后，再次从 InteractionComponent_L 的引用拖动出来并搜索 EndDrag。我们将将其连接到 ActivateUp
    的执行输出。现在我们可以使用悬停的物体，以及开始和结束拖拽序列！
- en: Repeat the same process for the right motion controller.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为右侧运动控制器重复相同的步骤。
- en: Finally, it's time to map the pickup and drop behaviors. Many games map this
    type of behavior to the grip buttons as players seem to naturally gravitate toward
    using these buttons, for this interaction. Right-click in the blueprint and search
    for the MotionController L Grip1 event. Drag an execution line from the Pressed
    output and search for our Pickup function (referencing the left interaction component).
    Now drag off the reference to InteractionComponent_L and search for the Drop function.
    Connect this new function to the Released output on the event. As before, repeat
    this process for the right motion controller as well.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，是时候映射拾取和放下行为。许多游戏将这种行为映射到握把按钮，因为玩家似乎自然地倾向于使用这些按钮进行交互。在蓝图上右键单击并搜索 MotionController
    L Grip1 事件。从 Pressed 输出拖动一条执行线并搜索我们的 Pickup 函数（引用左交互组件）。现在从 InteractionComponent_L
    的引用拖动出来并搜索 Drop 函数。将这个新函数连接到事件的 Released 输出。像之前一样，也为右侧运动控制器重复此过程。
- en: 'Done! To test the behavior, let''s drop a few of these wonderful cubes in our
    level and test their functionality. Pick them up, throw them, and watch them change
    color. Pretty cool, right? Just think about all of the possibilities for gameplay
    with the power you now hold within this cube. It gives you ideas, doesn''t it?
    Before we get to implementing those ideas, why don''t we add one more tool to
    our toolbox in the form of a button our players can press:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！为了测试行为，让我们在我们的关卡中放置几个这些神奇的立方体并测试它们的功能。拿起它们，扔出去，观察它们改变颜色。很酷，对吧？想想你现在在这个立方体中拥有的游戏玩法可能性。这给你带来了灵感，不是吗？在我们开始实现这些想法之前，为什么不给我们工具箱中再添加一个按钮，让玩家可以按下它：
- en: '![](img/8001be16-b35c-49bd-b788-a72c4621d8d2.png)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8001be16-b35c-49bd-b788-a72c4621d8d2.png)'
- en: Button press code
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮按下代码
- en: 'We can start building our button in the Viewport:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在视口（Viewport）中开始构建我们的按钮：
- en: Our button will be built from three different components. In the Viewport tab,
    click the Add Component button and create a new Scene Component. Name this `ButtonRoot`
    . Next, create a Cylinder component and name it `Button`. We'll need to scale
    the cylinder down a bit so change the X, Y, and Z values for the Scale property
    to 0.05\. Also, change its Collision Preset to OverlapAllDynamic. Make sure the
    button is a child of the ButtonRoot. Lastly, create one more Cylinder component
    named `ButtonBase` and make sure that it's a child of the Default Scene Root.
    We'll need to change the Scale property here too. Change the scale values to X=0.15,
    Y=0.15, and Z=0.05\. Finally, set its Collision Preset to NoCollision.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们按钮将由三个不同的组件构建。在视口选项卡中，点击添加组件按钮并创建一个新的场景组件。将其命名为 `ButtonRoot`。接下来，创建一个圆柱体组件并命名为
    `Button`。我们需要将圆柱体缩小一点，所以将缩放属性的 X、Y 和 Z 值更改为 0.05。同时，将其碰撞预设更改为 OverlapAllDynamic。确保按钮是
    ButtonRoot 的子组件。最后，创建另一个名为 `ButtonBase` 的圆柱体组件，并确保它是默认场景根的子组件。我们在这里也需要更改缩放属性。将缩放值更改为
    X=0.15, Y=0.15, 和 Z=0.05。最后，将其碰撞预设设置为 NoCollision。
- en: Now that the visual components have been created, we can move on to the blueprint.
    We want to create a button that animates a bit when the player hovers their hand
    on it, and, for that, we'll need a few variables. The first we'll create is named
    `InitOverlapLoc` of the type Vector. This will store the location where the player's
    hand started overlapping. The second is `MaxPressAmout` of the type Float. This
    will be an adjustable variable so that we can fine tune how much the player needs
    to press the button for it to fire. Compile the blueprint and set the default
    value of this variable to 4\. The third variable we need is named `PressAmount`
    of the type Float. This will store the amount that the player has pressed the
    button. Lastly, we need to store the name of the component that over lapped the
    button. Create one more variable and name it `OverlapComponent`. Make sure its
    type is Primitive Component.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在视觉组件已经创建，我们可以继续到蓝图。我们想要创建一个按钮，当玩家将手悬停在它上面时，它会稍微动画化，为此，我们需要一些变量。第一个我们将创建的变量名为
    `InitOverlapLoc`，类型为 Vector。这将存储玩家手开始重叠的位置。第二个是 `MaxPressAmount`，类型为 Float。这将是一个可调整的变量，这样我们就可以微调玩家需要按下按钮多少次才能触发它。编译蓝图并将此变量的默认值设置为
    4。第三个我们需要变量名为 `PressAmount`，类型为 Float。这将存储玩家按下的按钮量。最后，我们需要存储重叠按钮的组件名称。创建另一个变量并命名为
    `OverlapComponent`。确保其类型为 Primitive Component。
- en: We're going to start our first code sequence with two events. Click on the Button
    component we created earlier and head to the Details panel. Near the very bottom
    of the list in the Events section of the menu is a collection of buttons that
    allows you to create almost every event compatible with our Button. We need to
    create two: OnComponentBeginOverlap and OnComponentEndOverlap. This will detect
    when the player's hand is pressing the button.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将开始我们的第一个代码序列，包含两个事件。点击我们之前创建的按钮组件，并转到详细信息面板。在菜单的事件部分列表的底部附近，有一组按钮，允许你创建几乎与我们的按钮兼容的每个事件。我们需要创建两个： OnComponentBeginOverlap
    和 OnComponentEndOverlap。这将检测当玩家的手按下按钮时的情况。
- en: OnComponentBeginOverlap feels like a good place to start, since it's the event
    that kicks everything off. The first step is to check and see whether the component
    overlapping the button is valid. Create a copy of the IsValid node (remember the
    one with the question mark?). Connect it to the event and get a copy of our OverlapComponent
    variable to be pluged into the Input Object pin.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 ComponentBeginOverlap 事件开始似乎是个好地方，因为这个事件是启动一切的事件。第一步是检查重叠按钮的组件是否有效。创建一个 IsValid
    节点的副本（记得那个带问号的？）。将其连接到事件并获取我们的 OverlapComponent 变量的副本以插入到输入对象引脚。
- en: If our OverlapComponent isn't valid (meaning the variable is empty), we need
    to store whatever overlapped the button as our new value for OverlapComponent.
    Grab another copy of OverlapComponent, only, this time, choose Set from the menu.
    The input for the new node will be the Other Comp input from the event node.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们的 OverlapComponent 无效（意味着变量为空），我们需要将按钮重叠的任何内容存储为我们 OverlapComponent 的新值。获取另一个
    OverlapComponent 的副本，但这次，从菜单中选择设置。新节点的输入将是事件节点中的 Other Comp 输入。
- en: With the OverlapComponent set, we now also need to set its location in our InitOverlapLoc variable.
    Right-click in the blueprint and grab a copy of the GetWorldLocation node where
    the target of the node is a Scene Component. Connect the execute input to the
    execute output of set OverlapComponent. Have the variable input for GetWorldLocation by
    the variable output for the set OverlapComponent.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 OverlapComponent 设置后，我们还需要在 InitOverlapLoc 变量中设置其位置。在蓝图上右键单击并复制一个 GetWorldLocation
    节点，其中节点的目标是 Scene Component。将执行输入连接到设置 OverlapComponent 的执行输出。让 GetWorldLocation
    的变量输入通过设置 OverlapComponent 的变量输出。
- en: Now we need to store the new location in InitOverlapLoc. Create a new set InitOverlapLoc node.
    The variable input for this new node will be the output from GetWorldLocation.
    Don't forget to connect the execute connection!
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要将新位置存储在 InitOverlapLoc 中。创建一个新的节点 InitOverlapLoc。这个新节点的变量输入将是 GetWorldLocation
    的输出。别忘了连接执行连接！
- en: It's time to tackle the OnComponentEndOverlap event. When we end the overlap,
    all we want to do is check to see whether the object that was removed from overlapping
    is the same that we've stored in the OverlapComponent variable and whether it's
    we want to clear that variable. Start the sequence by creating a Branch and connecting
    it to the execution output of the event. To compare our objects, create a copy
    of the Equals (object) node. The top input with be the OtherComp output from the
    event. The bottom will be a copy of our OverlapComponent variable. Finally, connect
    the Boolean output from the Equals node to the Condition input on the Branch.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候处理 OnComponentEndOverlap 事件了。当我们结束重叠时，我们只想检查从重叠中移除的对象是否与我们在 OverlapComponent
    变量中存储的对象相同，以及我们是否想要清除该变量。通过创建一个分支并将其连接到事件的执行输出来启动序列。为了比较我们的对象，创建一个 Equals (object)
    节点的副本。顶部的输入将是事件中的 OtherComp 输出。底部将是我们的 OverlapComponent 变量的副本。最后，将 Equals 节点的布尔输出连接到分支上的条件输入。
- en: For the final step in this sequence, create a copy of OverlapComponent and choose
    Set from the menu. Connect it to the True execution output on the Branch. We'll
    leave its variable input blank so that we can clear its value.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个序列的最后一步，创建一个 OverlapComponent 的副本并从菜单中选择设置。将其连接到分支的 True 执行输出。我们将留其变量输入为空，这样我们就可以清除其值。
- en: 'The next step in our code is to build the nodes that will control the short
    animation. We begin with the Event Tick node. Next, right-click and create a Sequence
    node, since this will be a two-step process. Connect the Sequence to the execute
    output from Even Tick:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们代码的下一步是构建将控制简短动画的节点。我们从 Event Tick 节点开始。接下来，右键单击并创建一个 Sequence 节点，因为这将是一个两步过程。将
    Sequence 连接到 Even Tick 的执行输出：
- en: '![](img/33194035-ebcc-46c9-82e6-fedb35148c27.png)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![](img/33194035-ebcc-46c9-82e6-fedb35148c27.png)'
- en: Button down code
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮下代码
- en: Dragging off the Then 0 output, drop the connection and use the search box to
    find the IsValid node (remember to use the one marked with a ? in the menu). The
    Input Object we'll be checking this time will be a copy of our OverlapComponent. We'll
    use this setup to determine whether the player is still overlapping with the button.
    If they are, we'll animate the button going down. If they aren't, we'll animate
    the button, returning to the original position.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Then 0 输出拖动连接，并将其放下，并使用搜索框找到 IsValid 节点（记得使用菜单中标记为 ? 的那个）。我们将检查这次输入对象是否是 OverlapComponent
    的副本。我们将使用这个设置来确定玩家是否仍然与按钮重叠。如果是，我们将动画按钮向下移动。如果不是，我们将动画按钮，使其返回到原始位置。
- en: Next, drag in a copy of our PressAmount variable and choose the Set option from
    the menu. Connect this to the IsValid output. We'll leave its variable input blank
    for now.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，拖入我们的PressAmount变量的一个副本，并从菜单中选择Set选项。将其连接到IsValid输出。我们现在将其变量输入留空。
- en: To do the actual animating, we'll need to create a copy of a SetRelativeLocation
    node. Connect its execute input to the execute output from the set PressAmount and
    use a reference to the Button component as the Target.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了进行实际的动画，我们需要创建一个SetRelativeLocation节点的副本。将其执行输入连接到设置PressAmount的执行输出，并使用按钮组件的引用作为目标。
- en: With the basics of the code set up for the animation, it's time to do some quick
    math. Pressing a Button is a basic motion that involves moving the button component
    moving up and down in the *Z* axis when the player overlaps it. To figure out
    how far the button needs to travel, we'll take the distance the overlapping actor
    has traveled and subtract it from the initial position of that same actor. We'll
    compare that distance to our MaxPressAmount to determine whether the button has
    been truly pressed. This will all be calculated relative to the position of the
    button to ensure that it'll work in whatever situation you decide to use it. We'll
    start with converting our stored InitOverlapLoc value to be in relation to the
    button. Get a reference to the ButtonBase from the Components panel, drag a connection
    off of it, and drop it to open the search menu. Create a copy of GetWorldTransform.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当代码的基本设置完成动画后，是时候做一些快速的计算了。按下按钮是一个基本的动作，当玩家重叠时，涉及按钮组件在*Z*轴上上下移动。为了确定按钮需要移动多远，我们将重叠的演员移动的距离从该演员的初始位置中减去。我们将比较这个距离与我们的MaxPressAmount，以确定按钮是否真正被按下。所有这些计算都将相对于按钮的位置进行，以确保它在您选择的任何情况下都能正常工作。我们将从将存储的InitOverlapLoc值转换为与按钮相关联开始。从组件面板获取ButtonBase的引用，从它那里拖动一个连接，并将其拖到打开搜索菜单。创建GetWorldTransform的副本。
- en: Dragging a line from the return value of GetWorldTransform, drop the connection,
    and search for the InverseTransformLocation node. This node is designed to take
    in a location and convert it from World Space over into Local Space, based on
    the transform that we supply. In this case, we're converting the initial overlap
    location to be relative to the ButtonBase. Get a copy of our InitOverlapLoc variable
    and connect that to the Location input.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从GetWorldTransform的返回值拖动一条线，放下连接，并搜索InverseTransformLocation节点。此节点旨在接收一个位置，并根据我们提供的转换将其从世界空间转换为本地空间。在这种情况下，我们将初始重叠位置转换为相对于ButtonBase的相对位置。获取我们的InitOverlapLoc变量的一个副本，并将其连接到Location输入。
- en: Now create a `Vector - Vector` node and take the Return value of the InverseTransformLocation and
    plug that into the top input. We'll calculate the second value in the following
    steps.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建一个`Vector - Vector`节点，并将InverseTransformLocation的返回值插入到顶部输入。我们将在以下步骤中计算第二个值。
- en: Drag another connection off the reference to ButtonBase and create another copy
    of GetWorldTransform and another copy of InverseTransformLocation.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从ButtonBase的引用拖动另一个连接，并创建GetWorldTransform和InverseTransformLocation的另一个副本。
- en: This time, we'll need to get the location of the component we've stored in OverlapComponent.
    Get a copy of the OverlapComponent variable and drag a connection off it. Drop
    it and search for GetWorldLocation. The Return Value of this node will be the
    Location input on the copy of the InverseTransformLocation we created in *step
    17*. The Return Value of this InverseTransformLocation can now be connected to
    the lower input on our `Vector - Vector`.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这次，我们需要获取存储在OverlapComponent中的组件的位置。获取OverlapComponent变量的一个副本，并从它那里拖动一个连接。放下它，搜索GetWorldLocation。此节点的返回值将是我们在*步骤17*中创建的InverseTransformLocation副本的Location输入。现在，InverseTransformLocation的返回值可以连接到我们的`Vector
    - Vector`的较低输入。
- en: Since the button only travels in the *Z* axis, we're only interested in the
    *Z* output of the subtraction node. Right-click on the output of the `Vector -
    Vector` and split the struct pin.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于按钮只在*Z*轴上移动，我们只对减法节点的*Z*输出感兴趣。在`Vector - Vector`的输出上右键单击，并拆分结构引脚。
- en: To make sure the *Z* value doesn't go outside what we need, we're going to use
    a Clamp node to limit it. A Clamp node takes in a value and tells it that it can
    only be between a certain minimum and maximum. In this case, we're going to bring
    in the *Z* value and not let it go lower than zero or higher than our MaxPressAmount.
    Right-click and create a Clamp (float) node. Use the *Z* ouput from our `Vector
    - Vector` as the Value input and a copy of our MaxPressAmount variable as the
    Max. We should leave the minimum value at 0.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保*Z*值不会超出我们需要的范围，我们将使用一个Clamp节点来限制它。Clamp节点接收一个值并告诉它它只能介于一定的最小值和最大值之间。在这种情况下，我们将引入*Z*值，并确保它不会低于零或高于我们的MaxPressAmount。右键单击并创建一个Clamp
    (float)节点。使用我们的`Vector - Vector`的*Z*输出作为Value输入，并使用我们的MaxPressAmount变量的副本作为Max。我们应该将最小值留在0。
- en: We're almost there! Our clamped float value is now ready to become the input
    for the set PressAmount node we created earlier. Connect the output of the Clamp
    to the set PressAmount input.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们几乎完成了！我们的钳位浮点值现在可以成为我们之前创建的set PressAmount节点的输入。将Clamp的输出连接到set PressAmount输入。
- en: Since the button will always be moving down to show that it's being pressed,
    the value we need to pass into our SetRelativeLocation node should be negative.
    Take the variable output from set PressAmount, drag off from it, and create a
    `Float * Float` node. Set the second value to -1.0.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于按钮总是会向下移动以显示它被按下，因此我们需要传递给SetRelativeLocation节点的值应该是负数。从set PressAmount的变量输出拖出，并创建一个`Float
    * Float`节点。将第二个值设置为-1.0。
- en: 'To finish the animation, right-click on the New Location input on the SetRelativeLocation
    and split the struct. Connect the output from `Float * Float` and connect to the
    New Location Z input:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成动画，右键单击SetRelativeLocation的New Location输入并拆分结构。将`Float * Float`的输出连接到New
    Location Z输入：
- en: '![](img/f3d61845-a45e-40cc-b411-3694a8f33377.png)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f3d61845-a45e-40cc-b411-3694a8f33377.png)'
- en: Code that returns the button to the start position
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 返回按钮起始位置的代码
- en: Once the overlap is complete, we'll need to move the button back to its original
    location. Head back to the IsValid that we created back in *step 11* and drag
    a connection of the IsNotValid output, drop it, and search for a copy of the node
    SetRelativeLocation. Set a reference to our Button component as the Target.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦重叠完成，我们需要将按钮移回其原始位置。回到我们之前在*步骤11*中创建的IsValid，将IsNotValid输出的连接拖动，放下，并搜索节点SetRelativeLocation的副本。将我们的Button组件作为目标设置引用。
- en: Right-click in the blueprint and search for the VinterpTo. This will help the
    button achieve a smooth animation back to an unpressed state. To fill the Current
    input, grab a reference to the Button component and drag a connection off it.
    Drop and search for a GetRelativeLocation node. Plug the output from this node
    into the Current input.
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在蓝图上右键单击并搜索VinterpTo。这将帮助按钮实现平滑的动画回到未按下状态。为了填充Current输入，获取按钮组件的引用并将其拖出连接。放下并搜索GetRelativeLocation节点。将此节点的输出连接到Current输入。
- en: To fill the Delta Time input, connect the Delta Time value from the Event Tick
    node.
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要填充Delta Time输入，将Event Tick节点中的Delta Time值连接过来。
- en: Finally, connect the Return Value from VinterpTo to the New Location input on SetRelativeLocation.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将VinterpTo的Return Value连接到SetRelativeLocation的New Location输入。
- en: 'The last thing needed to finish the button is a way to process what happens
    when the button is pressed. For that, we''ll use an Event Dispatcher. By using
    an Event Dispatcher, we can bind different commands to the button, depending on
    what we need it for, leaving us with a flexible and reusable system:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 完成按钮的最后一步是处理按钮被按下时发生的情况。为此，我们将使用事件分发器。通过使用事件分发器，我们可以根据需要将不同的命令绑定到按钮上，从而为我们提供一个灵活且可重用的系统：
- en: '![](img/b4a8a587-cb18-463f-8a7d-dd48d28fcf97.png)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b4a8a587-cb18-463f-8a7d-dd48d28fcf97.png)'
- en: What happens when it's pressed?
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮被按下时会发生什么？
- en: 'To continue, drag off the Then 1 output on our Sequence node and create a new
    Branch:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 要继续，从Sequence节点的Then 1输出拖出，并创建一个新的Branch：
- en: It's now time to compare the amount we have pressed the button to the max press
    amount. Right-click and create a `Float >= Float` node. Get a copy of PressAmount
    and connect that to the top input. Get a copy of MaxPressAmount and connect that
    to the bottom input. Lastly, plug the output of the node into the Condition input
    on the Branch.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候比较我们按下的按钮数量与最大按下数量的差异了。右键单击并创建一个`Float >= Float`节点。获取PressAmount的副本并将其连接到顶部输入。获取MaxPressAmount的副本并将其连接到底部输入。最后，将节点的输出连接到分支的Condition输入。
- en: Now create a DoOnce node. This node stops something from happening again until
    it has been reset. We'll plug the True output from the Branch into the execute
    input and the False output into the Reset input.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建一个DoOnce节点。此节点停止再次发生某些事情，直到它被重置。我们将从分支的True输出连接到执行输入，并将False输出连接到重置输入。
- en: Finally, create an Event Dispatcher. Find the Event Dispatchers section of the
    My Blueprint panel and click the + button. Name the new dispatcher Pressed. Back
    in the blueprint, drag off the Completed output of DoOnce and search for the Call
    Pressed node.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建一个事件分发器。在My Blueprint面板的事件分发器部分找到并点击+按钮。将新分发器命名为Pressed。回到蓝图，从DoOnce的Completed输出拖动并搜索Call
    Pressed节点。
- en: The last step in implementing our button-press behavior is to add some code
    to the interaction component.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现按钮按下行为的最后一步是在交互组件中添加一些代码。
- en: We now have a working button that the player can mash in VR. To test the feature,
    drop a copy of our button into the level where you can press it and open the Level
    Blueprint. We are going to build from the Event BeginPlay node that should be
    present in the blueprint by default. If it isn't there, go ahead and drop one
    in.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个可以供玩家在VR中猛按的工作按钮。为了测试功能，将按钮的副本放入可以按下并打开关卡蓝图的关卡中。我们将从蓝图默认应该存在的Event BeginPlay节点开始构建。如果它不在那里，请继续添加一个。
- en: Right-click in the blueprint and create a reference to the InteractButton that's
    in the level. Drag off from the output and search for the AssignPressed node and
    connect the execute output from the event to its input. This will allow you to
    assign a custom event to Pressed. It can be anything you want! I created a simple
    way to end the level in the previous screenshot.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在蓝图上右键单击，创建一个指向级别中InteractButton的引用。从输出拖动并搜索AssignPressed节点，将事件的执行输出连接到其输入。这将允许您为Pressed分配一个自定义事件。它可以是你想要的任何东西！我在上一个屏幕截图中创建了一个简单的方法来结束关卡。
- en: Wow! We've come a long way from where we began. The player now has hands. They
    can use them to interact with the world around them. They can touch, pick up,
    throw, press buttons, and anything else that we can dream up. They can also teleport
    around the level to explore whatever we decide to create—and all of this with
    controls in place so that they may only do these things with whatever we as the
    designers let them. It's time to put that power to good use.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经从起点走了很长的路。现在玩家有了手。他们可以使用它们来与周围的世界互动。他们可以触摸、拿起、扔、按按钮，以及我们可以想到的任何其他事情。他们还可以在关卡中传送以探索我们决定创建的内容——所有这些都有控制措施，以便他们只能做我们作为设计师允许他们做的事情。是时候将这种力量用于良好的用途了。
- en: 'Remember the puzzle box we designed at the beginning of the section? We now
    have all of the pieces we need to make this a reality. Since it''s a prototype,
    we''re going to build the box out of static mesh components and another type of
    component called a Child Actor. Child Actors are copies of class blueprints and
    allow us to build objects within a class blueprint out of other actors, meaning
    that we can piece together our simple puzzle box with Box components, copies of
    our InteractCube, and a couple copies of InteractButton:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们在本节开头设计的拼图盒吗？我们现在拥有了实现这一目标所需的所有部件。由于这是一个原型，我们将使用静态网格组件和另一种称为子演员的组件来构建盒子。子演员是类蓝图的副本，允许我们在类蓝图中使用其他演员构建对象，这意味着我们可以使用Box组件、InteractCube的副本和几个InteractButton的副本来拼凑我们的简单拼图盒：
- en: '![](img/73d07a01-03ca-4880-b60c-6709f21bccdd.png)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/73d07a01-03ca-4880-b60c-6709f21bccdd.png)'
- en: Building the PuzzleCubeTest
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 构建 PuzzleCubeTest
- en: 'Start by creating a new Class Blueprint:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个新的类蓝图：
- en: Right-click in the `Server17\Blueprint` folder in the Content Browser and create
    a new Class Blueprint based on Actor. Name this new blueprint PuzzleCubeTest,
    since this puzzle cube represents our first prototype. Double-click it to open
    it.
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在内容浏览器中的`Server17\Blueprint`文件夹上右键单击，并基于Actor创建一个新的类蓝图。将这个新蓝图命名为PuzzleCubeTest，因为这个拼图方块代表我们的第一个原型。双击它以打开它。
- en: Let's create the visual components. The best place to start would be with the
    non-interactive components first. In the Components section of My Blueprints,
    click the Add Components button, and create a new Box component. Change the Scale
    properties X=1.0, Y=2.0, and Z=0.1\. Name this component `Bottom`.
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建视觉组件。最好的开始方式是从非交互式组件开始。在My Blueprints的组件部分，点击添加组件按钮，并创建一个新的Box组件。将缩放属性更改为X=1.0，Y=2.0，Z=0.1。将此组件命名为`Bottom`。
- en: Create another Box component and name it `RightSide`. Change the Scale properties
    X=0.5, Y=2.0, and Z=0.1 and rotate it 90 degrees around the *Y* axis. Line it
    up along the right edge of the bottom component.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个盒子组件，并将其命名为`RightSide`。将缩放属性更改为X=0.5，Y=2.0，Z=0.1，并围绕*Y*轴旋转90度。将其沿底部组件的右侧对齐。
- en: Select the Right component and press *Ctrl* *+ W*. This will create a copy that
    you can align with the left edge of the bottom piece. Name this new piece `LeftSide`.
    Change its Y Scale property to 1.5\. This space will allow for the hidden compartment
    in the back.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择右侧组件并按*Ctrl* *+ W*。这将创建一个副本，您可以将其与底部组件的左侧对齐。将这个新部件命名为`LeftSide`。将其Y缩放属性更改为1.5。这个空间将允许在后面隐藏一个隔间。
- en: Click on the bottom component and press *Ctrl+W* to create a copy. Name this
    new component Top. Move this component 60 cm up in the positive *Z* direction.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击底部组件并按*Ctrl+W*创建一个副本。将这个新组件命名为Top。将此组件沿正*Z*方向向上移动60厘米。
- en: The box is slowly coming together, but now we need a back plate to finish the
    enclosure. Create a new Box component and change the Scale property to X=0.9,
    Y=0.5, and Z=0.1\. Name it BackPlate. Finally, rotate it 90 degrees around the
    *X* axis.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 箱子正在慢慢组装起来，但现在我们需要一块背板来完成外壳。创建一个新的盒子组件，并将缩放属性更改为X=0.9，Y=0.5，Z=0.1。将其命名为BackPlate。最后，围绕*X*轴旋转90度。
- en: Now we're going to create the non-interactive bottom and top supports. Create
    a new Box component and name it BottomSupport_1\. Set the Scale property to X=0.5,
    Y=1.25, and Z=0.1\. Move it below the Bottom Component and align it with the front
    and side edges.
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将创建非交互式的底部和顶部支撑。创建一个新的盒子组件，并将其命名为BottomSupport_1。将缩放属性设置为X=0.5，Y=1.25，Z=0.1。将其移到Bottom
    Component下方，并与前部和侧面边缘对齐。
- en: With BottomSupport_1 selected, press *Ctrl + W* and name this new component `BottomSupport_2.`
    Rotate it 90 degrees around the *Z* axis and move it back to the center of the
    bottom of the box. The easy way to do this would be to set the *Y* value of its
    location property back to 0.
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`BottomSupport_1`，按*Ctrl + W*并命名这个新组件为`BottomSupport_2`。围绕*Z*轴旋转90度，并将其移回箱子底部的中心。这样做的一个简单方法是将其位置属性的*Y*值设置为0。
- en: Create another copy of BottomSupport_1 and name it BottomSupport_3\. Rotate
    it 90 around the *Z* axis and align this component with the back edge of the bottom
    component.
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建BottomSupport_1的另一个副本，并将其命名为BottomSupport_3。围绕*Z*轴旋转90度，并将此组件与底部组件的后边缘对齐。
- en: Select all of the BottomSupport components in the Components list by clicking
    the first one and holding *Ctrl* while selecting the other two. If necessary,
    rotate the components 90 degrees so that they're back in the correct orientation.
    Then move them 80 cm up in the *Z* axis so that their bottom edges align with
    the top edge of the Top component. Name them `TopSupport_1`, `TopSupport_2`, and `TopSupport_3`.
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过单击第一个并按住*Ctrl*同时选择其他两个，在组件列表中选择所有BottomSupport组件。如有必要，旋转组件90度，使它们恢复到正确的方向。然后沿*Z*轴向上移动80厘米，使它们的底部边缘与Top组件的顶部边缘对齐。将它们命名为`TopSupport_1`，`TopSupport_2`和`TopSupport_3`。
- en: To give one of our buttons inside the box a surface to sit on, we're going to
    create one more non-interactive component. Click on the BackPlate component and
    create a copy with *Ctrl + W*. Name this new component `MiddlePlate` and make
    the value of it's Location property X=0, Y=60, and Z=30.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了给箱子内的一个按钮提供一个放置的表面，我们将创建一个额外的非交互式组件。点击BackPlate组件，并使用*Ctrl + W*创建一个副本。将这个新组件命名为`MiddlePlate`，并使其位置属性的X=0，Y=60，Z=30。
- en: To create the interactive surfaces in our puzzle box, we're going utilize Child
    Actor components, which will be copies of our InteractCube object. This will allow
    us to have all of the functionality that we programmed into InteractCube and utilize
    them as components of our puzzle box without reprogramming them in a new component
    (though we may want to in the future). Create a new Child Actor component and
    name it `SideDecoy_R1`. In the Details panel, set the Child Actor class property
    to InteractCube. Se the Scale value to X=0.5, Y=0.13, and Z=0.7 and rotate it
    90 degrees around the *Z* axis. Move this component into position in between the
    first set of the top and bottom supports on the right side, aligned to the front
    edge of the RightSide component.
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了在我们的拼图盒中创建交互式表面，我们将利用子演员组件，这些组件将是InteractCube对象的副本。这将使我们能够使用我们编程到InteractCube中的所有功能，并将它们作为拼图盒的组件使用，而无需在新的组件中重新编程它们（尽管我们可能在未来想要这样做）。创建一个新的子演员组件，并将其命名为`SideDecoy_R1`。在详细信息面板中，将子演员类属性设置为InteractCube。将缩放值设置为X=0.5，Y=0.13，Z=0.7，并围绕*Z*轴旋转90度。将此组件移动到右侧顶部和底部支撑之间的位置，与RightSide组件的前边缘对齐。
- en: Create a copy of SideDecoy_R1 using *Ctrl + W* and name the new Child Actor `SideDecoy_R2`.
    Move it between the rear set of the top and bottom supports on the right side,
    aligned with the back edge of the Right component.
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*Ctrl + W*复制`SideDecoy_R1`，并将新子演员命名为`SideDecoy_R2`。将其移动到右侧顶部和底部支撑的后方，与Right组件的后边缘对齐。
- en: Now for the left side, create a copy of `SideDecoy_R1` using *Ctrl + W* and
    name the new Child Actor  `SideDecoy_L1`. Move it to the left side of the box between
    the first set of top and bottom supports and align it with the front edge of the
    LeftSide component.
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，对于左侧，使用*Ctrl + W*复制`SideDecoy_R1`，并将新子演员命名为`SideDecoy_L1`。将其移动到盒子左侧的顶部和底部支撑之间，并与LeftSide组件的前边缘对齐。
- en: Make a copy of `SideDecoy_L1` and move it to the center set of the top and bottom
    supports.
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制`SideDecoy_L1`并将其移动到顶部和底部支撑的中心位置。
- en: The decoy components are there to divert the players attention while they look
    for the buttons to press to unlock the puzzle box. With them all in place, we
    can now add our interactive button components. On the right-hand side of our puzzle
    box, create a new Child Actor component and set the Child Actor class property
    to InteractButton. Name this new `Child Actor Button_Step1`. Lastly, move it to
    the center of the area between the middle top and bottom supports and align it
    with the surface of the RightSide component by rotating it -90 degrees around
    the *Y* axis. Players will need to uncover and find this button before they can
    open the front of the box.
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 诱饵组件是为了在玩家寻找要按下的按钮以解锁拼图盒时分散他们的注意力。当它们全部就位后，我们现在可以添加我们的交互式按钮组件。在拼图盒的右侧，创建一个新的子演员组件，并将子演员类属性设置为InteractButton。将这个新组件命名为`Child
    Actor Button_Step1`。最后，将其移动到中间顶部和底部支撑之间的中心位置，并通过围绕*Y*轴旋转-90度与RightSide组件的表面对齐。玩家需要在揭开并找到这个按钮之前才能打开盒子的前面。
- en: Create a copy of Button_Step1 with *Ctrl + W* and name the new component Button_Step2\.
    Set the button's Rotation property to X=0, Y=90, and Z=90\. Align this button
    with the center of our MiddlePlate component. This button will be found behind
    a plate that covers the front of the puzzle box that can only be removed after Button_Step1
    has been pressed.
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*Ctrl + W*复制Button_Step1，并将新组件命名为Button_Step2。将按钮的旋转属性设置为X=0，Y=90，Z=90。将此按钮与MiddlePlate组件的中心对齐。此按钮位于覆盖拼图盒前部的板上，只有按下Button_Step1后才能将其移除。
- en: Now let's cover up those buttons! Create a copy of SideDecoy_R1 and name the
    new component `ButtonCover_Step1`. Move this new object to cover up Button_Step1
    by aligning it between the center set of the top and bottom supports on the right
    side.
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们遮盖那些按钮！复制`SideDecoy_R1`并将其命名为`ButtonCover_Step1`。将这个新对象移动到覆盖Button_Step1，通过在右侧顶部和底部支撑之间的中心位置对其进行对齐。
- en: To cover the front, we'll need a new Child Actor sized to fit that compartment.
    Create a new Child Actor, set the Child Actor class property to InteractCube,
    and name it `ButtonCover_Step2`. Set the value of the Scale property to X=0.8,
    Y=0.5, and Z=0.1\. Rotate it around the *X* axis 90 degrees. Lastly, align it
    to cover Button_Step2 and fit it flush with the front of the puzzle box. This
    will unlock after the player presses the first button.
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了覆盖前面，我们需要一个新的大小的 Child Actor 来适应那个隔间。创建一个新的 Child Actor，将 Child Actor 类属性设置为
    InteractCube，并将其命名为 `ButtonCover_Step2`。将缩放属性的值设置为 X=0.8, Y=0.5, 和 Z=0.1。围绕 *X*
    轴旋转 90 度。最后，将其对齐以覆盖 Button_Step2 并使其与拼图盒的前面齐平。这将在玩家按下第一个按钮后解锁。
- en: There's one more cover. This one will cover the compartment we have in the back.
    Click on SideDecoy_L2 and use *Ctrl + W* to create a copy of it. Name the new
    copy `CompartmentCover_Step3`. Align it between the back top and bottom supports
    to cover the compartment. This cover will unlock when the player presses the second
    button.
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还有一个盖子。这个盖子将覆盖我们后面的隔间。点击 SideDecoy_L2 并使用 *Ctrl + W* 创建它的副本。将新副本命名为 `CompartmentCover_Step3`。将其对齐在后面顶部和底部支撑之间以覆盖隔间。这个盖子将在玩家按下第二个按钮时解锁。
- en: What good is a puzzle box if there's no prize at the end? Create one more Child
    Actor component and set the Child Actor class property to InteractCube. Name it
    StolenData. This will represent the prize the player is after. Set the value of
    the Scale property to X=0.1, Y=0.1, and Z=0.1\. Place inside of rear compartment
    that we just covered with CompartmentCover_Step3.
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果拼图盒的结尾没有奖品，那还有什么意义？创建另一个 Child Actor 组件并将 Child Actor 类属性设置为 InteractCube。将其命名为
    StolenData。这代表玩家追求的奖品。将缩放属性的值设置为 X=0.1, Y=0.1, 和 Z=0.1。将其放置在 CompartmentCover_Step3
    覆盖的后部隔间内。
- en: There's one last detail. To make the InteractCube work as a stand-in for more
    detailed components that we'll create later, we need to open the InteractCube
    blueprint and turn off the Simulate Physics option. This will make it so the cubes
    won't have physics enabled by default, so the puzzle cube won't fall apart. Physics
    will still enable once the player has interacted with the cube.
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后还有一个细节。为了让 InteractCube 作为我们稍后创建的更详细组件的替代品，我们需要打开 InteractCube 蓝图并关闭 Simulate
    Physics 选项。这将使得立方体不会默认启用物理，因此拼图立方体不会散开。一旦玩家与立方体交互，物理仍然会被启用。
- en: 'Based on our design, the code for the prototype puzzle box needs to be able
    to do the following things:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的设计，原型拼图盒的代码需要能够完成以下几件事情：
- en: Disable the ability to pick up the button covers when we start
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开始时禁用拾取按钮盖的能力
- en: Bind the correct button press events to our two buttons
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将正确的按钮按下事件绑定到我们的两个按钮上
- en: Enable the front button cover after button 1 has been pressed
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在按下按钮 1 后启用前按钮盖
- en: Enable the compartment cover after button 2 has been pressed
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在按下按钮 2 后启用隔间盖
- en: 'Disabling the components that we don''t want the player to be able to interact
    with what could be accomplished by toggling their individual PickUpActive Boolean
    variables. This will leave all of their other functions available but make it
    so the player can''t remove them before we want them to have that ability. To
    give them that ability, we can bind a couple of custom events to our two buttons
    that re-enable them after the buttons have been found and pressed. Let''s head
    to the Event Graph of PuzzleCubeTest and get to work:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 禁用玩家无法与之交互的组件可以通过切换它们的单个 PickUpActive 布尔变量来实现。这将保留它们的所有其他功能，但使得玩家在我们希望他们拥有这种能力之前无法移除它们。为了给他们这种能力，我们可以将几个自定义事件绑定到我们的两个按钮上，在按钮被找到并按下后重新启用它们。让我们转到
    PuzzleCubeTest 的事件图并开始工作：
- en: '![](img/f317a5a2-c0b5-44cd-8c68-ba1fdb9f90e7.png)'
  id: totrans-421
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f317a5a2-c0b5-44cd-8c68-ba1fdb9f90e7.png)'
- en: PuzzleBoxTest code
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: PuzzleBoxTest 代码
- en: 'We''ll build this code from the Event BeginPlay node:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从 Event BeginPlay 节点构建此代码：
- en: Right-click in the blueprint and search for a Sequence node. We are going to
    use this to fire off the steps that we mentioned previously in the correct order.
    Click the Add Pin button on the node until we have four output pins to work with.
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在蓝图上右键单击并搜索 Sequence 节点。我们将使用这个节点来按正确顺序触发之前提到的步骤。点击节点的添加引脚按钮，直到我们有四个输出引脚可供使用。
- en: Start by dragging off the Then 0 output and search for the Cast To InteractCube
    node. For the Object input on the cast, we need to reference our Child Actor ButtonCover_Step2\.
    However, if we try to plug in a simple reference to it, the cast won't work correctly.
    To make sure it references the correct object, we need to add a GetChildActor
    node. Create a reference to ButtonCover_Step2 and drag a connection from its output.
    Search for the GetChildActor node and connect its output to the Object input on
    the cast.
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，从Then 0输出拖动，并搜索Cast To InteractCube节点。对于cast的Object输入，我们需要引用我们的子演员ButtonCover_Step2。然而，如果我们尝试插入一个简单的引用，cast将无法正确工作。为了确保它引用正确的对象，我们需要添加一个GetChildActor节点。创建对ButtonCover_Step2的引用，并从其输出拖动一个连接。搜索GetChildActor节点，并将其输出连接到cast的Object输入。
- en: With the cast set up, we can now pretend to be the button cover and turn off
    its ability to be picked up. Drag a connection off the As InteractCube output
    and search for the set PickUpActive. On the set PickUpActive node, make sure the
    checkbox is turned off.
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设置好cast之后，我们现在可以假装自己是按钮盖，并关闭其被拾取的能力。从As InteractCube输出拖动一个连接，并搜索设置PickUpActive。在设置PickUpActive节点上，确保复选框是关闭的。
- en: Let's repeat the process for CompartmentCover_Step3\. Create the cast by dragging
    off the Then 1 output on the Sequence and connecting a reference to the Child
    Actor version of CompartmentCover_Step3 to the Object input through a GetChildActor
    node. As the child actor, set PickUpActive to false by turning off the checkbox
    on the Set node.
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们重复这个过程为CompartmentCover_Step3。通过在序列的Then 1输出上拖动创建cast，并通过GetChildActor节点将子演员版本的CompartmentCover_Step3的引用连接到Object输入。作为子演员，通过在设置节点上关闭复选框将PickUpActive设置为false。
- en: Next, we need to connect the button presses to a couple of custom events. Drag
    a connection off the Then 2 output on the Sequence node and search for the node
    Cast To InteractButton. Use the same method as the previous one to create a reference
    to the child actor, Button_Step1, and connect that to the Object input on the
    cast. We'll use our event dispatcher we created as part of the button to connect
    a custom event to the pressing of the button. Drag a connection off the As InteractButton
    output and search for Bind Event to Pressed.
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要将按钮按下与几个自定义事件连接起来。从序列节点上的Then 2输出拖动一个连接，并搜索节点Cast To InteractButton。使用与之前相同的方法创建对子演员Button_Step1的引用，并将其连接到cast的Object输入。我们将使用作为按钮一部分创建的事件调度器来将自定义事件连接到按钮的按下。从As
    InteractButton输出拖动一个连接，并搜索绑定事件到Pressed。
- en: Create a new custom event and name it UnlockStep2\. Drag a connection off the
    little box next to the event node's name and plug it into the event input on the Bind
    Event to Pressed node.
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的自定义事件，并将其命名为UnlockStep2。从事件节点名称旁边的小方块拖动一个连接，并将其插入到Bind Event to Pressed节点的事件输入。
- en: Drag a connection from the As InteractCube output from *step 3* and create a
    set PickUpActive node. Connect it to the execution output from the UnlockStep2
    event and make sure the checkbox on the Set node is turned on. We've now re-enabled ButtonCover_Step2.
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从步骤3的As InteractCube输出拖动一个连接，并创建一个设置PickUpActive节点。将其连接到UnlockStep2事件的执行输出，并确保设置节点上的复选框已打开。我们现在已重新启用了ButtonCover_Step2。
- en: Repeat the steps to set up the ability to re-enable CompartmentCover_Step3\.
    Create a Cast To InteractButton node and pass in a reference to the child actor
    version of Button_Step2\. As the button, create a Bind Event to Pressed node and
    connect it to a custom event named UnlockStep3\. Drag off the As InteractCube
    output from *step 4* and create a set PickUpActive node. Make sure that the checkbox
    on this new node is set to on.
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复这些步骤来设置重新启用CompartmentCover_Step3的能力。创建一个Cast To InteractButton节点，并传递对Button_Step2子演员版本的引用。作为按钮，创建一个绑定事件到Pressed节点，并将其连接到名为UnlockStep3的自定义事件。从步骤4的As
    InteractCube输出拖动，并创建一个设置PickUpActive节点。确保这个新节点上的复选框设置为开启。
- en: And there we have it, a working puzzle cube that takes three steps to solve.
    Using our teleport volumes, create a space where you can teleport around the box
    and then drop a copy of the puzzle box in the center. Move around it. Test the
    steps and see whether they work. Once everything is working, I have a challenge
    for you. When we started this section, I provided a sketch of the plan for the
    puzzle box, as well as a prototype level for the player to test it. Build the
    level and test your puzzle box in it. Interested in a greater challenge? Design
    and build your own puzzle cube and test level!
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，我们得到了一个需要三步解决的实用拼图方块。使用我们的传送体积，创建一个可以在方块周围传送的空间，然后在中心放置一个拼图方块的副本。围绕它移动。测试步骤，看看它们是否工作。一旦一切正常，我有一个挑战给你。当我们开始这个部分时，我提供了拼图盒的计划草图，以及一个原型关卡供玩家测试。构建关卡并在其中测试你的拼图盒。想要更大的挑战吗？设计和构建你自己的拼图方块和测试关卡！
- en: Building the first tool station
  id: totrans-433
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建第一个工具站
- en: 'An integral part of the gameplay for *Server 17* is the idea of the Tool Station,
    a location located near the puzzle box that contains some type of tool, device,
    or hint-generator that can be used by the player to help solve the puzzle at hand.
    The tools at each station would vary from brute-force hacking tools that could
    solve a step of the puzzle at the cost of a time penalty, to a simple hint tool
    that could highlight the next piece the player has to interact with. For the prototype,
    we''re going to design a simple rotation tool that will highlight how easy it
    is to use the tools that we created. Let''s take a look at the prototype visuals:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '*Server 17* 游戏的一个关键部分是工具站的概念，这是一个位于拼图盒附近的位置，包含某种工具、设备或提示生成器，玩家可以使用它来帮助解决当前的问题。每个站点的工具会有所不同，从可能以时间惩罚为代价解决拼图步骤的暴力破解工具，到可以突出显示玩家必须与之交互的下一个部件的简单提示工具。对于原型，我们将设计一个简单的旋转工具，以突出我们创建的工具的易用性。让我们看看原型视觉：'
- en: '![](img/d288f312-9d20-4f01-a0d1-dbef7d91d455.png)'
  id: totrans-435
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d288f312-9d20-4f01-a0d1-dbef7d91d455.png)'
- en: Prototype visuals
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 原型视觉
- en: 'The build is relatively basic. Using the Content Browser, head to the `Shapes`
    folder of the Starter Content and grab yourself a cylinder. Use the Scale tool
    to shrink it by half. Then grab a Wedge shape and place that on top of the cylinder.
    Shrink this by half as well. I also used a Text Render to create the text you
    see in the image. The final piece to this tool station is a new class blueprint:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 构建相对简单。使用内容浏览器，转到入门内容中的`Shapes`文件夹，并取一个圆柱体。使用缩放工具将其缩小一半。然后取一个楔形并将其放在圆柱体顶部。也将这个缩小一半。我还使用文本渲染器创建了图像中看到的文本。这个工具站最后的部件是一个新的类蓝图：
- en: '![](img/469fd5e5-b079-40f5-a94e-100d5c560701.png)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/469fd5e5-b079-40f5-a94e-100d5c560701.png)'
- en: StationButton code
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: StationButton代码
- en: 'Create a new class Blueprint and select Actor from the menu:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的类蓝图并从菜单中选择Actor：
- en: Create the new class Blueprint, select the Actor class from the Pick Parent
    Class menu, and name it `StationButton`.
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建新的类蓝图，从“选择父类”菜单中选择Actor类，并将其命名为`StationButton`。
- en: Similar to our InteractCube, this blueprint contains only one component. I used
    a Cone component; however, feel free to use whatever you feel might be appropriate.
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与我们的InteractCube类似，这个蓝图只包含一个组件。我使用了圆锥组件；然而，请随意使用您认为可能合适的任何组件。
- en: Now, let's code this thing! To utilize some of the functions that we've spent
    this chapter creating, click on the Class Defaults button and find the Interfaces
    section in the Details panel. Click the Add button and choose our Object Interaction
    Interface.
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们为这个玩意儿编写代码！为了利用我们在这章中创建的一些功能，点击类默认按钮，并在详细信息面板中找到接口部分。点击添加按钮并选择我们的对象交互接口。
- en: 'With the interface added, head over to the My Blueprint panel and open the
    Interfaces section of the menu. Double-click and open the following functions:
    `TraceHitObject`, `TraceLeaveObject`, `TraceActivateUp`, and `TraceActivateDown`.'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加接口后，转到My Blueprint面板并打开菜单中的接口部分。双击并打开以下功能：`TraceHitObject`、`TraceLeaveObject`、`TraceActivateUp`和`TraceActivateDown`。
- en: Let's start with `TraceHitObject`. This covers what happens when our line trace
    touches the object. Drag a reference to the Cone into the blueprint from the Components
    panel and drag a connection from it. Create a copy of the SetVectorParameterValueOnMaterial
    and connect it to the function node and Return node. Set the value of the Parameter
    Name field to Color. Finally, set the *Y* value of the Parameter Value input to
    1.0\. This will highlight the button Green when we land a trace on it.
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从`TraceHitObject`开始。这涵盖了我们的线迹接触到对象时会发生什么。从组件面板中将圆锥的引用拖到蓝图，并从它拖出一条连接。创建`SetVectorParameterValueOnMaterial`的副本，并将其连接到函数节点和返回节点。将参数名称字段的值设置为Color。最后，将参数值输入的*Y*值设置为1.0。这将在我们对按钮进行线迹追踪时将其突出显示为绿色。
- en: For `TraceLeaveObject`, we'll have to create a variable that can store whether
    or not our button is being used. Head over to the Variables section of My Blueprint
    and create a new Boolean variable. Name it `ButtonPressed` and set its default
    value to False. Along with changing the color of the button back to the default
    white, we want to make sure the button no longer registers as pressed if it's
    no longer being touched by a line trace. Repeat the preceding step to create the SetVectorParameterValueOnMaterial
    node and set the value of the Parameter Value input to X=1.0, Y=1.0, and Z=1.0\.
    This will set the button color back to white. After SetVectorParameterValueOnMaterial,
    connect a set ButtonPressed node and make sure the checkbox is set to off. Connect
    that to the output of SetVectorParameterValueOnMaterial and the ReturnNode.
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`TraceLeaveObject`，我们需要创建一个变量来存储我们的按钮是否正在使用。转到My Blueprint的变量部分，创建一个新的布尔变量。将其命名为`ButtonPressed`，并将其默认值设置为False。除了将按钮颜色变回默认的白色外，我们还想确保如果按钮不再被线迹触摸，它不再被注册为按下。重复前面的步骤创建`SetVectorParameterValueOnMaterial`节点，并将参数值输入的值设置为X=1.0，Y=1.0，Z=1.0。这将使按钮颜色变回白色。在`SetVectorParameterValueOnMaterial`之后，连接一个设置`ButtonPressed`的节点，并确保复选框设置为关闭。将其连接到`SetVectorParameterValueOnMaterial`的输出和`ReturnNode`。
- en: Now, let's move on to `TraceActivateDown`. When the player activates the button,
    all we want to do is set ButtonPressed to True. We'll handle the rotating in the
    level blueprint. Connect a copy of the set ButtonPressed to the function. Make
    sure the checkbox on the node is turned on. After the Set node, create another
    copy of SetVectorParameterValueOnMaterial using the Cone as the Target. Set it
    up the same way as we did in the previous steps in this section and set the *X*
    value of the Parameter Value input to 1.0\. This will turn the button red when
    it's used.
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们继续到`TraceActivateDown`。当玩家激活按钮时，我们只想将`ButtonPressed`设置为True。我们将在关卡蓝图中处理旋转。将设置`ButtonPressed`的副本连接到函数。确保节点上的复选框已打开。在设置节点之后，使用圆锥作为目标创建另一个`SetVectorParameterValueOnMaterial`的副本。按照本节前面的步骤设置它，并将参数值输入的*X*值设置为1.0。这将使按钮在使用时变为红色。
- en: Lastly, we have `TraceActivateUp`. When the player releases the trigger, we
    need to change the color back to green (the color it is when getting hit by a
    line trace) and change ButtonPressed back to false. Connect a copy of SetVectorParameterValueOnMaterial
    to the function node, set it up as we have in previous steps, and set the *Y*
    value of the Parameter Value input to 1.0\. Connect a copy of set ButtonPressed
    to the output of the SetVectorParameterValueOnMaterial node and connect its output
    to the Return node, making sure the checkbox is set to off.
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们有`TraceActivateUp`。当玩家释放扳机时，我们需要将颜色变回绿色（这是被线迹击中的颜色），并将`ButtonPressed`重置为false。将`SetVectorParameterValueOnMaterial`的副本连接到函数节点，按照我们之前步骤设置好，并将参数值输入的*Y*值设置为1.0。将`set
    ButtonPressed`的副本连接到`SetVectorParameterValueOnMaterial`节点的输出，并将其输出连接到返回节点，确保复选框设置为关闭。
- en: Back in our level, add a copy of StationButton to the tools station that we've
    created and name it StationButton_Rotate.
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的关卡中，将`StationButton`的副本添加到我们创建的工具站中，并将其命名为StationButton_Rotate。
- en: 'To make the puzzle box rotate when our station button is pressed, we''re going
    to build a bit of functionality into the level blueprint, since this ability is
    limited to the prototype level. Open the Level Blueprint using the Blueprints
    button:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 要使拼图盒在按下我们的站按钮时旋转，我们需要在关卡蓝图中构建一些功能，因为这种能力仅限于原型级别。使用蓝图按钮打开Level Blueprint。
- en: '![](img/48159940-23d4-4ef4-a513-5c01b5e86c7b.png)'
  id: totrans-451
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/48159940-23d4-4ef4-a513-5c01b5e86c7b.png)'
- en: The level blueprint code
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 关卡蓝图代码
- en: 'We''ll start to build this sequence with a custom event:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个自定义事件来开始构建这个序列：
- en: Right-click in the blueprint and create a new custom event. We are going to
    name it ButtonCheck.
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在蓝图上右键单击并创建一个新的自定义事件。我们将将其命名为ButtonCheck。
- en: Next, right-click and create a new Branch node. This will read whether the button
    has been pressed. Create a reference to our StationButton_Rotate and drag a connection
    from it. Drop it and search for Get ButtonPressed. Connect the output from this
    node to the Condition node on the Branch.
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，右键单击并创建一个新的Branch节点。这将读取按钮是否被按下。创建对StationButton_Rotate的引用并从它拖动一个连接。放下它并搜索Get
    ButtonPressed。将此节点的输出连接到Branch上的条件节点。
- en: Now, create an Event Tick node. We want the game to check every frame if the
    button is being pressed. Drag a connection from the event and search for our ButtonCheck
    function to create a copy of it.
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个Event Tick节点。我们希望游戏每帧检查按钮是否被按下。从事件拖动一个连接并搜索我们的ButtonCheck函数以创建它的副本。
- en: As we've done for previous buttons, we're going to use a Gate to control whether 
    the code executes, based on whether ButtonPressed is True or False. Create a Gate
    node and connect the Enter input to the output from the ButtonCheck function.
    Connect the True output from our Branch to the Open input and the False output
    from the Branch to the Close input.
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像我们对之前的按钮所做的那样，我们将使用一个Gate来控制代码是否执行，基于ButtonPressed是True还是False。创建一个Gate节点并将Enter输入连接到ButtonCheck函数的输出。将Branch的True输出连接到Open输入，将Branch的False输出连接到Close输入。
- en: It's time to create the rotation. Create a new `Float` variable over in the
    Variables section of My Blueprint and name it RotSpeed. This will control how
    fast the puzzle cube rotates.
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候创建旋转功能了。在“我的蓝图”的变量部分创建一个新的`Float`变量，命名为RotSpeed。这将控制谜题立方体的旋转速度。
- en: Next, right-click and search for the Make Rotator node. Connect a copy of RotSpeed
    to the Z (Yaw) input.
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，右键单击并搜索Make Rotator节点。将RotSpeed的一个副本连接到Z（偏航）输入。
- en: The last major node we need is AddActorLocalRotation. Connect it to the Exit
    output of our Gate node and use a reference to our puzzle cube in the level as
    the Target.
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要的最后一个主要节点是AddActorLocalRotation。将其连接到Gate节点的Exit输出，并使用关卡中谜题立方体的引用作为目标。
- en: The Delta Rotation input needs a bit of math. Drag a connection from the output
    of Make Rotator and search for the ScaleRotator node. For the float input, use
    the Delta Seconds output from Event Tick. This will create a smooth rotation over
    time.
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Delta Rotation输入需要一点数学计算。从Make Rotator的输出拖动一个连接并搜索ScaleRotator节点。对于浮点输入，使用Event
    Tick的Delta Seconds输出。这将创建一个随时间平滑的旋转。
- en: Finally, plug the output of our ScaleRotator node into the Delta Rotation input
    on the AddActorLocalRotation.
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将ScaleRotator节点的输出插入到AddActorLocalRotation的Delta Rotation输入上。
- en: 'We now have rotation! Obviously, there''s quite a bit more that can be done
    with the idea of hacking tools in *Server 17*, but this will work fine for our
    prototype stage. It looks as though this is finally coming together. There is
    one last gameplay element we still haven''t created  though: our level timer.'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了旋转功能！显然，在*Server 17*中，关于黑客工具的想法还有很多可以做的，但这对我们的原型阶段来说已经足够了。看起来这个功能终于要完成了。尽管如此，我们仍然还没有创建最后一个游戏元素：我们的关卡计时器。
- en: Building the Timer
  id: totrans-464
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建计时器
- en: In the world of *Server 17*, players hack corporate servers looking for valuable
    company secrets. However, those corporations don't just lie down and take it!
    Powerful system administrators, corporate hackers, and AI countermeasures mobilize
    to stop the player, giving them limited time to crack each server. To represent
    this in the game, we'll implement a level timer in the game that will cause the
    player to lose when it reaches zero. Since this is a only a prototype, we'll have
    the game quit when the timer is complete.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 在*Server 17*的世界里，玩家破解公司服务器以寻找有价值的公司机密。然而，那些公司不会坐视不管！强大的系统管理员、公司黑客和AI反制措施动员起来阻止玩家，给他们有限的时间来破解每个服务器。为了在游戏中表示这一点，我们将在游戏中实现一个关卡计时器，当计时器达到零时，玩家将失败。由于这只是一个原型，当计时器完成时，游戏将退出。
- en: 'Since this is a gameplay element independent of any level, we''ll build this
    feature in our custom game state. Head to our `Sever17\Blueprints` server and
    double-click the `S17GameState` to open it:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个独立于任何级别的游戏元素，我们将在自定义游戏状态中构建这个功能。前往我们的`Sever17\Blueprints`服务器，双击`S17GameState`以打开它：
- en: '![](img/4555d7fd-b068-4804-bf13-c6eeea193c38.png)'
  id: totrans-467
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4555d7fd-b068-4804-bf13-c6eeea193c38.png)'
- en: Game timer code setup in the Game State
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏状态中设置游戏计时器代码
- en: 'Let''s get started:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: This feature makes user of the Timer system built into the Blueprint system.
    Using the SetTimerByEvent node, we can call a custom event when a timer (in seconds)
    completes. Start by creating a copy of the Event BeginPlay node and dragging an
    execute connection off the output. Search for the SetTimerByEvent node and select
    it from the menu.
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此功能利用了蓝图系统中内置的计时器系统。使用 SetTimerByEvent 节点，当计时器（以秒为单位）完成时，我们可以调用自定义事件。首先，创建 Event
    BeginPlay 节点的副本，并从输出拖动一个执行连接。搜索 SetTimerByEvent 节点，并从菜单中选择它。
- en: Next, create a Custom Event named `EndGame`. Connect this custom event to the
    Event input on SetTimerByEvent by dragging a connection from the square pin next
    to the custom event's name and connecting to the input pin.
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为 `EndGame` 的自定义事件。通过将自定义事件旁边的方块引脚拖动并连接到 SetTimerByEvent 的输入引脚，将此自定义事件连接到
    SetTimerByEvent 的事件输入。
- en: Dragging off the EndGame event, search for the ExecuteConsoleCommand node. In
    the Command field, type in the command `quit`.
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 EndGame 事件拖动开，搜索 ExecuteConsoleCommand 节点。在命令字段中，输入命令 `quit`。
- en: To finish the sequence, we need to set a value for Time on SetTimerByEvent.
    To keep the system flexible, we'll create a variable for the game time that can
    easily be adjusted from outside the game state to take into account things such
    as level difficulty or story elements. Create a new `Float` variable and name
    it GameTime. Compile the blueprint and set the default value to 300\. Get a copy
    of it and connect it to the Time input on SetTimerByEvent.
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要完成序列，我们需要为 SetTimerByEvent 上的时间设置一个值。为了保持系统的灵活性，我们将创建一个游戏时间的变量，可以从游戏状态外部轻松调整，以考虑诸如关卡难度或故事元素等因素。创建一个新的
    `Float` 变量，并将其命名为 GameTime。编译蓝图，并将默认值设置为 300。获取它的副本，并将其连接到 SetTimerByEvent 的时间输入。
- en: Awesome! Our intrepid players now have five minutes to complete our puzzle cube
    or be kicked out of the game. Feel free to adjust the default value of GameTime
    to whatever feels appropriate for your players or to adjust the challenge for
    yourself.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们勇敢的玩家现在有五分钟的时间来完成我们的拼图魔方，否则将被踢出游戏。请随意调整 GameTime 的默认值，使其适合您的玩家或根据您的挑战进行调整。
- en: Summary
  id: totrans-475
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Wow! What a ride. We began this chapter with some interesting discussions about
    gameplay and ended it with creating a whole game prototype from scratch! In this
    chapter, we explored the many different types of gameplay that successfully implement
    the mechanics that VR is uniquely capable of. Using that knowledge, we designed
    our game elements to take advantage of the near one-to-one translation of player
    movement into the game and the ability to have the player interact with the world
    from a true first-person perspective. Through the rest of this chapter, we built
    all of our systems from scratch from hand interactions to VR buttons, and even
    a puzzle box  for the player to solve within a time limit.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！这是一段多么精彩的旅程。我们以一些关于游戏玩法的有意思的讨论开始这一章，并以从头开始创建整个游戏原型结束！在这一章中，我们探讨了成功实现 VR 独特功能的多种不同类型的游戏玩法。利用这些知识，我们设计了游戏元素，以充分利用玩家动作与游戏之间几乎一对一的转换，以及玩家能够从真正的第一人称视角与世界互动的能力。在本章的剩余部分，我们从手部交互到
    VR 按钮，甚至为玩家在时间限制内解决谜题的谜盒，从头开始构建了所有系统。
- en: In the next chapter, we're going to expand our gameplay by discussing the user
    experience we've created so far and how we can improve that experience through
    the use of user interfaces. We'll talk about the use and viability of 2D and 3D
    elements within our game world and what works best with VR. Using that knowledge,
    we'll design and build our own elements for use in *Server 17*.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过讨论我们迄今为止创建的用户体验以及如何通过使用用户界面来改进该体验来扩展我们的游戏玩法。我们将讨论在游戏世界中使用 2D 和 3D
    元素的使用和可行性，以及什么最适合与 VR 一起使用。利用这些知识，我们将设计和构建我们自己的元素，用于在 *Server 17* 中使用。
