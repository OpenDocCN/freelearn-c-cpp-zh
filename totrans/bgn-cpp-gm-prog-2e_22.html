<html><head></head><body>
		<div><h1 id="_idParaDest-418"><a id="_idTextAnchor432"/><em class="italic">Chapter 21</em>: File I/O and the Game Object Factory</h1>
			<p>This chapter handles how a <code>GameObject</code> gets into the <code>m_GameObjects vector</code> that's used in the game. We will look at how we can describe individual objects and an entire level in a text file. We will write code to interpret the text and then load up values into a class that will be a blueprint for a game object. We will also code a class called <code>LevelManager</code> that oversees the whole process, starting from the initial request to load a level sent from an <code>InputHandler</code> via the <code>ScreenManager</code>, right through to the factory pattern class that assembles a game object from components and delivers it to the <code>LevelManager</code>, neatly packed away in the <code>m_GameObjects vector</code>.</p>
			<p>The following are the steps we will go through in this chapter:</p>
			<ul>
				<li>Examine how we will describe game objects and their components in a text file</li>
				<li>Code the <code>GameObjectBlueprint</code> class where the data from the text file will be temporarily stored</li>
				<li>Code the <code>ObjectTags</code> class to help describe game objects consistently and without errors</li>
				<li>Code <code>BluePrintObjectParser</code>, which will be responsible for loading the data from a game object description in the text file into a <code>GameObjectBlueprint</code> instance</li>
				<li>Code <code>PlayModeObjectLoader</code>, which will open the text file and receive the <code>GameObjectBlueprint</code> instances one at a time from <code>BlueprintObjectParser</code></li>
				<li>Code the <code>GameObjectFactoryPlayMode</code> class, which will construct <code>GameObject</code> instances from <code>GameObjectBlueprint</code> instances</li>
				<li>Code the <code>LevelManager</code> class, which oversees this entire process after receiving an instruction from the <code>ScreenManager</code> class</li>
				<li>Add the code to the <code>ScreenManager</code> class so that we can begin using the new system that we will code in this chapter</li>
			</ul>
			<p>Let's start by examining exactly how we describe a game object such as a space invader or a bullet in a text file, let alone a whole wave of them.</p>
			<h1 id="_idParaDest-419"><a id="_idTextAnchor433"/>The structure of the file I/O and factory classes</h1>
			<p>Have a look at the following diagram, which gives an overview of the classes we will code in this chapter and how the <code>vector</code> of <code>GameObject</code> instances will be shared with the <code>ScreenManager</code> class that we coded in <a href="B14278_19_Final_AG_ePub.xhtml#_idTextAnchor372"><em class="italic">Chapter 19</em></a>, <em class="italic">Game Programming Design Patterns – Starting the Space Invaders ++ Game</em>:</p>
			<div><div><img src="img/Image93956.jpg" alt=""/>
				</div>
			</div>
			<p>The preceding diagram shows that there is a <code>vector</code> of <code>GameObject</code> instances that's shared between four classes. This is achieved by passing the <code>vector</code> between the functions of the classes by reference. Each class can then carry out its role with the <code>vector</code> and its contents. The <code>ScreenManager</code> class will trigger the <code>LevelManager</code> class when a new level needs to be loaded into the <code>vector</code>. The individual <code>Screen</code> classes and their <code>InputHandler</code>-derived classes, as we saw in <a href="B14278_19_Final_AG_ePub.xhtml#_idTextAnchor372"><em class="italic">Chapter 19</em></a>, <em class="italic">Game Programming Design Patterns – Starting the Space Invaders ++ Game</em>, have access to <code>ScreenManager</code> via <code>ScreenManagerRemoteControl</code>. </p>
			<p>The <code>LevelManager</code> class is ultimately responsible for creating and sharing the vector. <code>PlayModeObjectLoader</code> will use <code>BlueprintObjectParser</code> to create <code>GameObjectBlueprint</code> instances.</p>
			<p>The <code>GameObjectFactoryPlayMode</code> class will complete the <code>GameObject</code> creation process using these <code>GameObjectBlueprint</code> instances and pack <code>GameObject</code> instances into the <code>vector</code> when prompted to do so by <code>PlayModeObjectLoader</code>. </p>
			<p>So, where do the different component, position, size, and appearance configurations for each <code>GameObject</code> instance come from?</p>
			<p>We can also see that three classes have access to a <code>GameObjectBlueprint</code> instance. This instance is created by the <code>LevelManager</code> class and passed around by reference. <code>BlueprintObjectParser</code> will read the <code>level1.txt</code> file, which has all the details of each of the game objects. It will initialize all the variables of the <code>GameObjectBlueprint</code> class. <code>PlayModeObjectLoader</code> will then pass a reference to the <code>vector</code> of <code>GameObject</code> instances, and also pass a reference to the fully configured <code>GameObjectBlueprint</code> instance to the <code>GameObjectFactoryPlayMode</code> class. This is repeated until all the <code>GameObject</code> instances are packed away in the <code>vector</code>. </p>
			<p>You might be wondering why I have used slightly cumbersome class names such as <code>GameObjectFactoryPlayMode</code> and <code>PlayModeObjectLoader</code>. The reason is that, once you see how convenient this system is, you might like to build tools that allow you to design your levels in a visual way by dragging and dropping them where required and then have the text file auto-generated rather than typed. This is not especially complicated, but I had to stop adding features to the game at some point. Therefore, you might well end up with a <code>GameObjectFactoryDesignMode</code> and a <code>DesignModeObjectLoader</code>.</p>
			<h1 id="_idParaDest-420"><a id="_idTextAnchor434"/>Describing an object in the world</h1>
			<p>We have already added the <code>level1.txt</code> file in the <code>world</code> folder in <a href="B14278_19_Final_AG_ePub.xhtml#_idTextAnchor372"><em class="italic">Chapter 19</em></a>, <em class="italic">Game Programming Design Patterns – Starting the Space Invaders ++ Game</em>. Let's discuss its uses, future intended uses, and its contents.</p>
			<p>First, I would like to point out that a shooter game is not the best way to demonstrate how to describe a game world in a text file like this. The reason for this is that there are only a few types of game object and the most common one, invaders, are all lined up uniformly like soldiers on parade. They would actually be more efficiently described programmatically, perhaps in a nested <code>for</code> loop. However, the intention of this project was to show the ideas, rather than learn how to make a Space Invaders clone.</p>
			<p>Take a look at the following text, which is a sample from the <code>level1.txt</code> file in the <code>world</code> folder:</p>
			<pre>[START OBJECT]
[NAME]invader[-NAME]
[COMPONENT]Standard Graphics[-COMPONENT]
[COMPONENT]Invader Update[-COMPONENT]
[COMPONENT]Transform[-COMPONENT]
[LOCATION X]0[-LOCATION X]
[LOCATION Y]0[-LOCATION Y]
[WIDTH]2[-WIDTH]
[HEIGHT]2[-HEIGHT]
[BITMAP NAME]invader1[-BITMAP NAME]
[ENCOMPASSING RECT COLLIDER]invader[-ENCOMPASSING_RECT COLLIDER]
[END OBJECT]</pre>
			<p>The preceding text describes a single object in the game; in this case, an invader. The object begins with the following text:</p>
			<pre>[START OBJECT]</pre>
			<p>That will inform our code we'll write that a new object is being described. Next in the text, we can see the following:</p>
			<pre>[NAME]invader[-NAME]</pre>
			<p>This informs the code that the type of object is an invader. This will eventually be set as the <code>m_Tag</code> of the <code>ColliderComponent</code> class. The invader will be identifiable for what it is. The text that comes next is as follows:</p>
			<pre>[COMPONENT]Standard Graphics[-COMPONENT]
[COMPONENT]Invader Update[-COMPONENT]
[COMPONENT]Transform[-COMPONENT]</pre>
			<p>This tells our system that this object will have three components added to it: a <code>StandardGraphicsComponent</code> instance, an <code>InvaderUpdateComponent</code> instance, and a <code>TransformComponent</code> instance. This means the object will be drawn in the standard way and will behave according to the rules we coded for an invader. It will also mean it has a location and scale in the game world. It is possible to have objects that don't have any components or fewer components. An object that takes no action and doesn't move will not need an update component, an object that is invisible will not need a graphics component (perhaps just an invisible collider which triggers some action), and an object that has no position in the world (perhaps a debugging object) will not need a transform component.</p>
			<p>The position and scale of an object are determined by the following four lines of text:</p>
			<pre>[LOCATION X]0[-LOCATION X]
[LOCATION Y]0[-LOCATION Y]
[WIDTH]2[-WIDTH]
[HEIGHT]2[-HEIGHT]</pre>
			<p>The following line of text determines what graphics file will be used for the texture of this object:</p>
			<pre>[BITMAP NAME]invader1[-BITMAP NAME]</pre>
			<p>The following line means that the object can be collided with. A decorative object, perhaps floating clouds (or a bee), would not need a collider:</p>
			<pre>[ENCOMPASSING RECT COLLIDER]invader[-ENCOMPASSING_RECT COLLIDER]</pre>
			<p>The final line of text will inform our system that the object has finished describing itself:</p>
			<pre>[END OBJECT]</pre>
			<p>Now, let's have a look at how we describe a bullet object:</p>
			<pre>[START OBJECT]
[NAME]bullet[-NAME]
[COMPONENT]Standard Graphics[-COMPONENT]
[COMPONENT]Transform[-COMPONENT]
[COMPONENT]Bullet Update[-COMPONENT]
[LOCATION X]-1[-LOCATION X]
[LOCATION Y]-1[-LOCATION Y]
[WIDTH]0.1[-WIDTH]
[HEIGHT]2.0[-HEIGHT]
[BITMAP NAME]bullet[-BITMAP NAME]
[ENCOMPASSING RECT COLLIDER]bullet[-ENCOMPASSING_RECT COLLIDER]
[SPEED]75.0[-SPEED]
[END OBJECT]</pre>
			<p>This is very similar but not the same as an invader. A bullet object has additional data, such as a set speed. The invader's speed is set in the logic of the <code>InvaderUpdateComponent</code> class. We could have done this for the bullet's speed as well, but this demonstrates that you can describe the object in as much or as little detail as the specific game design requires. Also, as we would expect, a bullet has a <code>BulletUpdateComponent</code> and a different value for the <code>[BITMAP NAME]</code> element. Notice that the location of the bullet is set to -1, -1. This means the bullets are outside of the playable area at the start of the game. In the next chapter, we will see how an invader, or the player, can spawn them into action when required.</p>
			<p>Now, study the following text, which describes the player's ship:</p>
			<pre>[START OBJECT]
[NAME]Player[-NAME]
[COMPONENT]Standard Graphics[-COMPONENT]
[COMPONENT]Transform[-COMPONENT]
[COMPONENT]Player Update[-COMPONENT]
[LOCATION X]50[-LOCATION X]
[LOCATION Y]40[-LOCATION Y]
[WIDTH]3.0[-WIDTH]
[HEIGHT]2.0[-HEIGHT]
[BITMAP NAME]playership[-BITMAP NAME]
[ENCOMPASSING RECT COLLIDER]player[-ENCOMPASSING_RECT COLLIDER]
[SPEED]10.0[-SPEED]
[END OBJECT]</pre>
			<p>The preceding text was probably quite predictable based on our discussion so far. Now that we've gone through this, we can get to work on coding the system that will interpret these object descriptions and convert them into usable <code>GameObject</code> instances.</p>
			<h1 id="_idParaDest-421"><a id="_idTextAnchor435"/>Coding the GameObjectBlueprint class</h1>
			<p>Create a new header file in the <code>Header Files/FileIO</code> filter called <code>GameObjectBlueprint.h</code> and add the following code:</p>
			<pre>#pragma once
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;map&gt;
using namespace std;
class GameObjectBlueprint {
private:
    string m_Name = "";
    vector&lt;string&gt; m_ComponentList;
    string m_BitmapName = "";
    float m_Width;
    float m_Height;
    float m_LocationX;
    float m_LocationY;
    float m_Speed;
    bool m_EncompassingRectCollider = false;
    string m_EncompassingRectColliderLabel = "";    
public:
    float getWidth();
    void setWidth(float width);
    float getHeight();
    void setHeight(float height);
    float getLocationX();
    void setLocationX(float locationX);
    float getLocationY();
    void setLocationY(float locationY);
    void setName(string name);
    string getName();
    vector&lt;string&gt;&amp; getComponentList();
    void addToComponentList(string newComponent);
    string getBitmapName();
    void setBitmapName(string bitmapName);    
    string getEncompassingRectColliderLabel();
    bool getEncompassingRectCollider();
    void setEncompassingRectCollider(string label);
};</pre>
			<p><code>GameObjectBlueprint</code> has a member variable for every possible property that could go into a game object. Note that it does not compartmentalize the properties by component. For example, it just has variables for things such as width, height, and location; it doesn't go to the trouble of identifying these as part of the transform component. These details are handled in the factory. It also provides getters and setters so that the <code>BlueprintObjectParser</code> class can pack away all the values from the <code>level1.txt</code> file and the <code>GameObjectFactoryPlayMode</code> class can extract all the values, instantiate the appropriate components, and add them to an instance of <code>GameObject</code>.</p>
			<p>Create a new source file in the <code>Source Files/FileIO</code> filter called <code>GameObjectBlueprint.cpp</code> and add the following code, which is for the definitions of the functions we have just declared:</p>
			<pre>#include "GameObjectBlueprint.h"
float GameObjectBlueprint::getWidth() 
{
    return m_Width;
}
void GameObjectBlueprint::setWidth(float width) 
{
    m_Width = width;
}
float GameObjectBlueprint::getHeight() 
{
    return m_Height;
}
void GameObjectBlueprint::setHeight(float height) 
{
    m_Height = height;
}
float GameObjectBlueprint::getLocationX() 
{
    return m_LocationX;
}
void GameObjectBlueprint::setLocationX(float locationX) 
{
    m_LocationX = locationX;
}
float GameObjectBlueprint::getLocationY() 
{
    return m_LocationY;
}
void GameObjectBlueprint::setLocationY(float locationY) 
{
    m_LocationY = locationY;
}
void GameObjectBlueprint::setName(string name)
{
    m_Name = "" + name;
}
string GameObjectBlueprint::getName()
{
    return m_Name;
}
vector&lt;string&gt;&amp; GameObjectBlueprint::getComponentList()
{
    return m_ComponentList;
}
void GameObjectBlueprint::addToComponentList(string newComponent)
{
    m_ComponentList.push_back(newComponent);
}
string GameObjectBlueprint::getBitmapName()
{
    return m_BitmapName;
}
void GameObjectBlueprint::setBitmapName(string bitmapName)
{
    m_BitmapName = "" + bitmapName;
}
string GameObjectBlueprint::getEncompassingRectColliderLabel() 
{
    return m_EncompassingRectColliderLabel;
}
bool GameObjectBlueprint::getEncompassingRectCollider() 
{
    return m_EncompassingRectCollider;
}
void GameObjectBlueprint::setEncompassingRectCollider(
    string label) 
{
    m_EncompassingRectCollider = true;
    m_EncompassingRectColliderLabel = "" + label;
}</pre>
			<p>Although this is a long class, there is nothing here we haven't seen before. The setter functions receive values which are copied into a vector or a variable, while the getters allow access to these values.</p>
			<h1 id="_idParaDest-422"><a id="_idTextAnchor436"/>Coding the ObjectTags class</h1>
			<p>The way in which we describe the game objects in the <code>level1.txt</code> file needs to be precise because the <code>BlueprintObjectParser</code> class we will code after this class will be reading the text from the file and looking for matches. For example, the <code>[START OBJECT]</code> tag will trigger the start of a new object. If that tag is misspelled as, say, <code>[START OBJECR]</code>, then the whole system falls apart and there will be all kinds of bugs, and even crashes when we run the game. To avoid this happening, we will define constant (programmatically unchangeable) <code>string</code> variables for all the tags we need to describe the game objects. We can use these <code>string</code> variables instead of typing something such as <code>[START OBJECT]</code> and have much less chance of making a mistake.</p>
			<p>Create a new header file in the <code>Header Files/FileIO</code> filter called <code>ObjectTags.h</code> and add the following code:</p>
			<pre>#pragma once
#include &lt;string&gt;
using namespace std;
static class ObjectTags {
public:
    static const string START_OF_OBJECT;
    static const string END_OF_OBJECT;
    static const string COMPONENT;
    static const string COMPONENT_END;
    static const string NAME;
    static const string NAME_END;
    static const string WIDTH;
    static const string WIDTH_END;
    static const string HEIGHT;
    static const string HEIGHT_END;
    static const string LOCATION_X;
    static const string LOCATION_X_END;
    static const string LOCATION_Y;
    static const string LOCATION_Y_END;
    static const string BITMAP_NAME;
    static const string BITMAP_NAME_END;
    static const string ENCOMPASSING_RECT_COLLIDER;
    static const string ENCOMPASSING_RECT_COLLIDER_END;
};</pre>
			<p>We have declared a <code>const string</code> for every tag we will use to describe the game objects. Now, we can initialize them.</p>
			<p>Create a new source file in the <code>Source Files/FileIO</code> filter called <code>ObjectTags.cpp</code> and add the following code:</p>
			<pre>#include "DevelopState.h"
#include "objectTags.h"
const string ObjectTags::START_OF_OBJECT = "[START OBJECT]";
const string ObjectTags::END_OF_OBJECT = "[END OBJECT]";
const string ObjectTags::COMPONENT = "[COMPONENT]";
const string ObjectTags::COMPONENT_END = "[-COMPONENT]";
const string ObjectTags::NAME = "[NAME]";
const string ObjectTags::NAME_END = "[-NAME]";
const string ObjectTags::WIDTH = "[WIDTH]";
const string ObjectTags::WIDTH_END = "[-WIDTH]";
const string ObjectTags::HEIGHT = "[HEIGHT]";
const string ObjectTags::HEIGHT_END = "[-HEIGHT]";
const string ObjectTags::LOCATION_X = "[LOCATION X]";
const string ObjectTags::LOCATION_X_END = "[-LOCATION X]";
const string ObjectTags::LOCATION_Y = "[LOCATION Y]";
const string ObjectTags::LOCATION_Y_END = "[-LOCATION Y]";
const string ObjectTags::BITMAP_NAME = "[BITMAP NAME]";
const string ObjectTags::BITMAP_NAME_END = "[-BITMAP NAME]";
const string ObjectTags::ENCOMPASSING_RECT_COLLIDER = 
    "[ENCOMPASSING RECT COLLIDER]";
    
const string ObjectTags::ENCOMPASSING_RECT_COLLIDER_END 
    = "[-ENCOMPASSING_RECT COLLIDER]";</pre>
			<p>That's all the <code>string</code> variables initialized. We can now use them in the next class and be sure we are describing the game objects consistently.</p>
			<h1 id="_idParaDest-423"><a id="_idTextAnchor437"/>Coding the BlueprintObjectParser class</h1>
			<p>This class will have the code that actually reads the text from the <code>level1.txt</code> file we have discussed. It will parse one object at a time, as identified by the start and end tags we saw previously. </p>
			<p>Create a new header file in the <code>Header Files/FileIO</code> filter called <code>BlueprintObjectParser.h</code> and add the following code:</p>
			<pre>#pragma once
#include "GameObjectBlueprint.h"
#include &lt;string&gt;
using namespace std;
class BlueprintObjectParser {
private:
    string extractStringBetweenTags(
        string stringToSearch, string startTag, string endTag);
public:
    void parseNextObjectForBlueprint(
        ifstream&amp; reader, GameObjectBlueprint&amp; bp);
};</pre>
			<p>The <code>extractStringBetweenTags</code> private function will capture the content between two tags. The parameters are three <code>string</code> instances. The first <code>string</code> is a full line of text from <code>level1.txt</code>, while the second and third are the start and end tags, which need to be discarded. The text between the two tags is then returned to the calling code.</p>
			<p>The <code>parseNextObjectForBlueprint</code> function receives an <code>ifstream</code> reader, just like the one we used in the Zombie shooter and the Thomas Was Late games. It is used to read from the file. The second parameter is a reference to a <code>GameObjectBlueprint</code> instance. The function will populate the <code>GameObjectBlueprint</code> instance with the values that were read from the <code>level1.txt</code> file, which can then be used back in the calling code to create an actual <code>GameObject</code>. We will see how that happens when we code the <code>PlayModeObjectLoader</code> class next and the <code>GameObjectFactoryPlayMode</code> class after that.</p>
			<p>Let's code the definitions we have just discussed.</p>
			<p>Create a new source file in the <code>Source Files/FileIO</code> filter called <code>BlueprintObjectParser.cpp</code> and add the following code:</p>
			<pre>#include "BlueprintObjectParser.h"
#include "ObjectTags.h"
#include &lt;iostream&gt;
#include &lt;fstream&gt;
void BlueprintObjectParser::parseNextObjectForBlueprint(
    ifstream&amp; reader, GameObjectBlueprint&amp; bp)
{
    string lineFromFile;
    string value = "";
    while (getline(reader, lineFromFile)) 
    {
        if (lineFromFile.find(ObjectTags::COMPONENT) 
            != string::npos) 
          {
            value = extractStringBetweenTags(lineFromFile, 
                ObjectTags::COMPONENT, 
                ObjectTags::COMPONENT_END);
            bp.addToComponentList(value);
        }
        else if (lineFromFile.find(ObjectTags::NAME) 
            != string::npos) 
          {
            value = extractStringBetweenTags(lineFromFile, 
                ObjectTags::NAME, ObjectTags::NAME_END);
            bp.setName(value);
        }
        else if (lineFromFile.find(ObjectTags::WIDTH) 
            != string::npos) 
          {
            value = extractStringBetweenTags(lineFromFile, 
                ObjectTags::WIDTH, ObjectTags::WIDTH_END);
            bp.setWidth(stof(value));
        }
        else if (lineFromFile.find(ObjectTags::HEIGHT) 
            != string::npos) 
          {
            value = extractStringBetweenTags(lineFromFile, 
                ObjectTags::HEIGHT, ObjectTags::HEIGHT_END);
            bp.setHeight(stof(value));
        }
        else if (lineFromFile.find(ObjectTags::LOCATION_X) 
            != string::npos) 
          {
            value = extractStringBetweenTags(lineFromFile, 
                ObjectTags::LOCATION_X, 
                ObjectTags::LOCATION_X_END);
            bp.setLocationX(stof(value));
        }
        else if (lineFromFile.find(ObjectTags::LOCATION_Y) 
            != string::npos) 
          {
            value = extractStringBetweenTags(
                      lineFromFile, 
                      ObjectTags::LOCATION_Y, 
                      ObjectTags::LOCATION_Y_END);
            bp.setLocationY(stof(value));
        }
        else if (lineFromFile.find(ObjectTags::BITMAP_NAME) 
            != string::npos) 
          {
            value = extractStringBetweenTags(lineFromFile, 
             ObjectTags::BITMAP_NAME, 
             ObjectTags::BITMAP_NAME_END);
            bp.setBitmapName(value);
        }
        
        else if (lineFromFile.find(
            ObjectTags::ENCOMPASSING_RECT_COLLIDER) 
            != string::npos) 
          {
            value = extractStringBetweenTags(lineFromFile, 
                ObjectTags::ENCOMPASSING_RECT_COLLIDER, 
                ObjectTags::ENCOMPASSING_RECT_COLLIDER_END);
            bp.setEncompassingRectCollider(value);
        }
        
        else if (lineFromFile.find(ObjectTags::END_OF_OBJECT) 
            != string::npos) 
        {
            return;
        }
    }
}
string BlueprintObjectParser::extractStringBetweenTags(
    string stringToSearch, string startTag, string endTag)
{
    int start = startTag.length();
    int count = stringToSearch.length() - startTag.length() 
        - endTag.length();
    string stringBetweenTags = stringToSearch.substr(
        start, count);
    return stringBetweenTags;
}</pre>
			<p>The code in <code>parseNextObjectForBlueprint</code> is lengthy but straightforward. The series of <code>if</code> statements identifies the starting tag at the beginning of the line of text and then passes the line of text to the <code>extractStringBetweenTags</code> function, which returns the value that is then loaded into the <code>GameObjectBlueprint</code> reference in the appropriate place. Notice that the function exits when <code>GameObjectBlueprint</code> has had all the data loaded into it. This point is recognized when <code>ObjectTags::END_OF_OBJECT</code> is found.</p>
			<h1 id="_idParaDest-424"><a id="_idTextAnchor438"/>Coding the PlayModeObjectLoader class</h1>
			<p>This is the class that will pass <code>GameObjectBlueprint</code> instances to <code>BlueprintObjectParser</code>. When it gets the completed blueprint back, it will pass them to the <code>GameObjectFactoryPlayMode</code> class, which will construct the <code>GameObject</code> instance and pack it away in the <code>vector</code> instance. Once all the <code>GameObject</code> instances have been built and stored, responsibility will be handed to the <code>LevelManager</code> class, which will control access to the vector for other parts of the game engine. This is a very small class with just one function, but it links many other classes together. Refer to the diagram at the start of this chapter for clarification.</p>
			<p>Create a new header file in the <code>Header Files/FileIO</code> filter called <code>PlayModeObjectLoader.h</code> and add the following code:</p>
			<pre>#pragma once
#include &lt;vector&gt;
#include &lt;string&gt;
#include "GameObject.h"
#include "BlueprintObjectParser.h"
#include "GameObjectFactoryPlayMode.h"
using namespace std;
class PlayModeObjectLoader {
private:
    BlueprintObjectParser m_BOP;
    GameObjectFactoryPlayMode m_GameObjectFactoryPlayMode;
public:
    void loadGameObjectsForPlayMode(
        string pathToFile, vector&lt;GameObject&gt;&amp; mGameObjects);
};</pre>
			<p>The <code>PlayModeObjectLoader</code> class has an instance of the previous class we coded, that is, the <code>BluePrintObjectParser</code> class. It also has an instance of the class we will code next, that is, the <code>GameObjectFactoryPlayMode</code> class. It has a single public function, which receives a reference to a <code>vector</code> that holds <code>GameObject</code> instances.</p>
			<p>Now, we will code the definition of the <code>loadGameObjectsForPlayMode</code> function. Create a new source file in the <code>Source Files/FileIO</code> filter called <code>PlayModeObjectLoader.cpp</code> and add the following code:</p>
			<pre>#include "PlayModeObjectLoader.h"
#include "ObjectTags.h"
#include &lt;iostream&gt;
#include &lt;fstream&gt;
void PlayModeObjectLoader::
    loadGameObjectsForPlayMode(
        string pathToFile, vector&lt;GameObject&gt;&amp; gameObjects)
{
    ifstream reader(pathToFile);
    string lineFromFile;
    float x = 0, y = 0, width = 0, height = 0;
    string value = "";
    while (getline(reader, lineFromFile)) {
        if (lineFromFile.find(
            ObjectTags::START_OF_OBJECT) != string::npos) {
            GameObjectBlueprint bp;
            m_BOP.parseNextObjectForBlueprint(reader, bp);
            m_GameObjectFactoryPlayMode.buildGameObject(
                bp, gameObjects);
        }
    }       
}</pre>
			<p>The function receives a <code>string</code>, which is the path to the file that needs to be loaded. This game only has one such file, but you could add more files with different layouts, varying numbers of invaders, or totally different game objects if you wanted to.</p>
			<p>An <code>ifstream</code> instance is used to read one line at a time from the file. In the <code>while</code> loop, the start tag is identified using <code>ObjectTags::START_OF_OBJECT</code>, and the <code>parseNextObjectForBlueprint</code> function of <code>BlueprintObjectParser</code> is called. You probably remember from the <code>BlueprintObjectParser</code> class that the completed blueprint is returned when <code>ObjectTags::END_OF_OBJECT</code> is reached.</p>
			<p>The next line of code calls the <code>buildGameObject</code> of the <code>GameObjectFactoryPlayMode</code> class and passes in the <code>GameObjectBlueprint</code> instance. We will code the <code>GameObjectFactory</code> class now.</p>
			<h1 id="_idParaDest-425"><a id="_idTextAnchor439"/>Coding the GameObjectFactoryPlayMode class</h1>
			<p>Now, we will code our factory, which will construct working game objects from the <code>GameObject</code> class and all the component related classes that we coded in the previous chapter. We will make extensive use of smart pointers, so we don't have to worry about deleting memory when we have finished with it.</p>
			<p>Create a new header file in the <code>Header Files/FileIO</code> filter called <code>GameObjectFactoryPlayMode.h</code> and add the following code:</p>
			<pre>#pragma once
#include "GameObjectBlueprint.h"
#include "GameObject.h"
#include &lt;vector&gt;
class GameObjectFactoryPlayMode {
public:
    void buildGameObject(GameObjectBlueprint&amp; bp, 
        std::vector &lt;GameObject&gt;&amp; gameObjects);
};</pre>
			<p>The factory class has just one function, <code>buildGameObject</code>. We have already seen the code that calls this function in the previous code we wrote for the <code>PlayModeObjectLoader</code> class. The function receives a reference to the blueprint, as well as a reference to the <code>vector</code> of <code>GameObject</code> instances.</p>
			<p>Create a new source file in the <code>Source Files/FileIO</code> filter called <code>GameObjectFactoryPlayMode.cpp</code> and add the following code:</p>
			<pre>#include "GameObjectFactoryPlayMode.h"
#include &lt;iostream&gt;
#include "TransformComponent.h"
#include "StandardGraphicsComponent.h"
#include "PlayerUpdateComponent.h"
#include "RectColliderComponent.h"
#include "InvaderUpdateComponent.h"
#include "BulletUpdateComponent.h"
void GameObjectFactoryPlayMode::buildGameObject(
    GameObjectBlueprint&amp; bp, 
    std::vector&lt;GameObject&gt;&amp; gameObjects)
{
    GameObject gameObject;
    gameObject.setTag(bp.getName());
    auto it = bp.getComponentList().begin();
    auto end = bp.getComponentList().end();
    for (it;
        it != end;
        ++it)
    {
        if (*it == "Transform")
        {
            gameObject.addComponent(
                make_shared&lt;TransformComponent&gt;(
                bp.getWidth(),
                bp.getHeight(),
                Vector2f(bp.getLocationX(),
                 bp.getLocationY())));
        }
        else if (*it == "Player Update")
        {
            gameObject.addComponent(make_shared
                &lt;PlayerUpdateComponent&gt;());
        }
        else if (*it == "Invader Update")
        {
            gameObject.addComponent(make_shared
                &lt;InvaderUpdateComponent&gt;());
        }
        else if (*it == "Bullet Update")
        {
            gameObject.addComponent(make_shared
                &lt;BulletUpdateComponent&gt;());
        }
        else if (*it == "Standard Graphics")
        {
            shared_ptr&lt;StandardGraphicsComponent&gt; sgp =
                make_shared&lt;StandardGraphicsComponent&gt;();
            gameObject.addComponent(sgp);
            sgp-&gt;initializeGraphics(
                bp.getBitmapName(),
                Vector2f(bp.getWidth(), 
                    bp.getHeight()));
        }        
    }
    if (bp.getEncompassingRectCollider()) {
        shared_ptr&lt;RectColliderComponent&gt; rcc = 
            make_shared&lt;RectColliderComponent&gt;(
            bp.getEncompassingRectColliderLabel());
        gameObject.addComponent(rcc);
        rcc-&gt;setOrMoveCollider(bp.getLocationX(),
            bp.getLocationY(),
            bp.getWidth(),
            bp.getHeight());
    }   
    
    gameObjects.push_back(gameObject);
}</pre>
			<p>The first thing that happens in the <code>buildGameObject</code> function is that a new <code>GameObject</code> instance is created and the <code>setTag</code> function of the <code>GameObject</code> class is used to pass in the name of the current object being built:</p>
			<pre>GameObject gameObject;
gameObject.setTag(bp.getName());</pre>
			<p>Next, a <code>for</code> loop loops through all the components in the <code>m_Components vector</code>. For each component that is found, a different <code>if </code>statement creates a component of the appropriate type. The way that each component is created varies, as you would expect since the way they are coded varies.</p>
			<p>The following code creates a shared pointer to a <code>TransformComponent</code> instance. You can see the necessary arguments being passed to the constructor, that is, width, height, and location. The result of creating the new shared pointer to a <code>TransformComponent</code> instance is passed to the <code>addComponent</code> function of the <code>GameObject</code> class. The <code>GameObject</code> instance now has its size and place in the world:</p>
			<pre>if (*it == "Transform")
{
    gameObject.addComponent(make_shared&lt;TransformComponent&gt;(
        bp.getWidth(),
        bp.getHeight(),
        Vector2f(bp.getLocationX(), bp.getLocationY())));
}</pre>
			<p>The following code executes when a <code>PlayerUpdateComponent</code> is required. Again, the code creates a new shared pointer to the appropriate class and passes it in to the <code>addComponent</code> function of the <code>GameObject</code> instance:</p>
			<pre>else if (*it == "Player Update")
{
    gameObject.addComponent(make_shared
        &lt;PlayerUpdateComponent&gt;());
}</pre>
			<p>The following three blocks of code use exactly the same technique to add either an <code>InvaderUpdateComponent</code>, <code>BulletUpdateComponent</code>, or <code>StandardGraphicsComponent</code> instance. Notice the extra line of code after adding a <code>StandardGraphicsComponent</code> instance that calls the <code>initialize</code> function, which adds a <code>Texture</code> instance (if required) to the <code>BitmapStore</code> singleton and prepares the component to be drawn:</p>
			<pre>else if (*it == "Invader Update")
{
    gameObject.addComponent(make_shared
        &lt;InvaderUpdateComponent&gt;());
}
else if (*it == "Bullet Update")
{
    gameObject.addComponent(make_shared
        &lt;BulletUpdateComponent&gt;());
}
else if (*it == "Standard Graphics")
{
    shared_ptr&lt;StandardGraphicsComponent&gt; sgp =
        make_shared&lt;StandardGraphicsComponent&gt;();
    gameObject.addComponent(sgp);
    sgp-&gt;initializeGraphics(
        bp.getBitmapName(),
        Vector2f(bp.getWidth(), 
            bp.getHeight()));
}</pre>
			<p>The final <code>if </code>block, as shown in the following code, handles adding a <code>RectColliderComponent</code> instance. The first line of code creates the shared pointer, while the second line of code calls the <code>addComponent</code> function to add the instance to the <code>GameObject</code> instance. The third line of code calls the <code>setOrMoveCollider</code> and passes in the location and size of the object. At this stage, the object is ready to be collided with. Obviously, we still need to write the code that tests for collisions. We will do so in the next chapter:</p>
			<pre>if (bp.getEncompassingRectCollider()) {
        shared_ptr&lt;RectColliderComponent&gt; rcc = 
            make_shared&lt;RectColliderComponent&gt;(
            bp.getEncompassingRectColliderLabel());
        gameObject.addComponent(rcc);
        rcc-&gt;setOrMoveCollider(bp.getLocationX(),
            bp.getLocationY(),
            bp.getWidth(),
            bp.getHeight());
}</pre>
			<p>The following line of code in the class adds the just-constructed <code>GameObject</code> instance to the <code>vector</code> that will be shared with the <code>GameScreen</code> class and used to make the game come to life:</p>
			<pre>gameObjects.push_back(gameObject);</pre>
			<p>The next class we will write makes it easy to share the <code>vector</code> we have just filled with <code>GameObject</code> instances around the various classes of the project.</p>
			<h1 id="_idParaDest-426"><a id="_idTextAnchor440"/>Coding the GameObjectSharer class</h1>
			<p>This class will have two pure virtual functions that share <code>GameObject</code> instances with other classes.</p>
			<p>Create a new header file in the <code>Header Files/FileIO</code> filter called <code>GameObjectSharer.h</code> and add the following code:</p>
			<pre>#pragma once
#include&lt;vector&gt;
#include&lt;string&gt;
class GameObject;
class GameObjectSharer {
public:
    virtual std::vector&lt;GameObject&gt;&amp; getGameObjectsWithGOS() = 0;
    virtual GameObject&amp; findFirstObjectWithTag(
             std::string tag) = 0;
};</pre>
			<p>The <code>getGameObjectsWithGOS</code> function returns a reference to the entire vector of <code>GameObject</code> instances. The <code>findFirstObjectWithTag</code> function returns just a single <code>GameObject</code> reference. We will see how we implement these functions when we inherit from <code>GameObjectSharer</code> when we code the <code>LevelManager</code> class next.</p>
			<p>Briefly, before the <code>LevelManager</code> class, create a new source file in the <code>Source Files/FileIO</code> filter called <code>GameObjectSharer.cpp</code> and add the following code:</p>
			<pre>/*********************************
******THIS IS AN INTERFACE********
*********************************/</pre>
			<p>Again, this is just a placeholder file and the full functionality goes in any of the classes that inherit from <code>GameObjectSharer</code>; in this case, the <code>LevelManager</code> class.</p>
			<h1 id="_idParaDest-427"><a id="_idTextAnchor441"/>Coding the LevelManager class</h1>
			<p>The <code>LevelManager</code> class is the connection between what we coded in <a href="B14278_19_Final_AG_ePub.xhtml#_idTextAnchor372"><em class="italic">Chapter 19</em></a>, <em class="italic">Game Programming Design Patterns – Starting the Space Invaders ++ Game</em>, and everything we coded in this chapter. The <code>ScreenManager</code> class will have an instance of the <code>LevelManager</code> class, and the <code>LevelManager</code> class will instigate loading levels (using all the classes we have just coded) and share <code>GameObject</code> instances with any classes that need them.</p>
			<p>Create a new header file in the <code>Header Files/Engine</code> filter called <code>LevelManager.h</code> and add the following code:</p>
			<pre>#pragma once
#include "GameObject.h"
#include &lt;vector&gt;
#include &lt;string&gt;
#include "GameObjectSharer.h"
using namespace std;
class LevelManager : public GameObjectSharer {
private:
    vector&lt;GameObject&gt; m_GameObjects;
    const std::string WORLD_FOLDER = "world";
    const std::string SLASH = "/";
    void runStartPhase();
    void activateAllGameObjects();
public:
    vector&lt;GameObject&gt;&amp; getGameObjects();
    void loadGameObjectsForPlayMode(string screenToLoad);
    /****************************************************
    *****************************************************
    From GameObjectSharer interface
    *****************************************************
    *****************************************************/
    vector&lt;GameObject&gt;&amp; GameObjectSharer::getGameObjectsWithGOS()
    {
        return m_GameObjects;
    }
    GameObject&amp; GameObjectSharer::findFirstObjectWithTag(
         string tag)
    {
        auto it = m_GameObjects.begin();
        auto end = m_GameObjects.end();
        for (it;
            it != end;
            ++it)
        {
            if ((*it).getTag() == tag)
            {
                return (*it);
            }
        }
        
#ifdef debuggingErrors        
    cout &lt;&lt; 
        "LevelManager.h findFirstGameObjectWithTag() " 
        &lt;&lt; "- TAG NOT FOUND ERROR!" 
        &lt;&lt; endl;
#endif    
        return m_GameObjects[0];
    }
};</pre>
			<p>This class provides two different ways to get the <code>vector</code> full of the game objects. One way is via a simple call to <code>getGameObjects</code>, but another is via the <code>getGameObjectsWithGOS</code> function. The latter is the implementation of a pure virtual function from the <code>GameObjectSharer</code> class and will be a way to pass access to each and every game object so that is has access to all the other game objects. You may recall from <a href="B14278_20_Final_AG_ePub.xhtml#_idTextAnchor414"><em class="italic">Chapter 20</em></a>, <em class="italic">Game Objects and Components</em>, that a <code>GameObjectSharer</code> instance is passed in during the <code>start</code> function call of the <code>GameObject</code> class. It was in this function that, among other things, the invaders could get access to the location of the player.</p>
			<p>There are also two private functions: <code>runStartPhase</code>, which loops through all the <code>GameObject</code> instances calling start, and <code>activateAllGameObjects</code>, which loops through and sets all the <code>GameObject</code> instances to the active status.</p>
			<p>Also, part of the <code>LevelManager</code> class is the <code>loadGameObjectsForPlayMode</code> function, which will trigger the entire game object creation process that the rest of this chapter has described.</p>
			<p>The final function in the <code>LevelManger.h</code> file is the implementation of the other <code>GameObjectSharer</code> pure virtual function, <code>findFirstObjectWithTag</code>. This allows any class with a <code>GameObjectSharer</code> instance to track down a specific game object using its tag. The code loops through all the <code>GameObject</code> instances in the <code>vector</code> and returns the first match. Note, that if no match is found, a null pointer will be returned and crash the game. We use an <code>#ifdef</code> statement to output some text to the console to tell us what caused the crash so that we won't be scratching our heads for hours should we accidentally search for a tag that doesn't exist.</p>
			<p>We can now code the implementations of the functions. </p>
			<p>Create a new source file in the <code>Source Files/Engine</code> filter called <code>LevelManager.cpp</code> and add the following code:</p>
			<pre>#include "LevelManager.h"
#include "PlayModeObjectLoader.h"
#include &lt;iostream&gt;
void LevelManager::
    loadGameObjectsForPlayMode(string screenToLoad)
{
    m_GameObjects.clear();
    string levelToLoad = "" 
        + WORLD_FOLDER + SLASH + screenToLoad;
    PlayModeObjectLoader pmol;
    pmol.loadGameObjectsForPlayMode(
        levelToLoad, m_GameObjects);
    runStartPhase();
}
vector&lt;GameObject&gt;&amp; LevelManager::getGameObjects()
{
    return m_GameObjects;
}
void LevelManager::runStartPhase()
{
    auto it = m_GameObjects.begin();
    auto end = m_GameObjects.end();
    for (it;
        it != end;
        ++it)
    {
        (*it).start(this);
    }
    activateAllGameObjects();
}
void LevelManager::activateAllGameObjects()
{
    auto it = m_GameObjects.begin();
    auto end = m_GameObjects.end();
    for (it;
        it != end;
        ++it)
    {
        (*it).setActive();
    }
}</pre>
			<p>The <code>loadLevelForPlayMode</code> function clears the <code>vector</code>, instantiates a <code>PlayModeObjectLoader</code> instance that does all the file reading, and packs the <code>GameObject</code> instances in the <code>vector</code>. Finally, the <code>runStartPhase</code> function is called. In the <code>runStartPhase</code> function, all the <code>GameObject</code> instances are passed a <code>GameObjectSharer</code> (<code>this</code>) and given the opportunity to set themselves up, ready to be played. Remember that, inside the <code>GameObject</code> class in the <code>start</code> function, each of the derived <code>Component</code> instances is given access to <code>GameObjectSharer</code>. Refer to <a href="B14278_20_Final_AG_ePub.xhtml#_idTextAnchor414"><em class="italic">Chapter 20</em></a>, <em class="italic">Game Objects and Components</em>, to see what we did with this when we coded the <code>Component</code> classes.</p>
			<p>The <code>runStartPhase</code> function concludes by calling <code>activateAllGameObjects</code>, which loops through the <code>vector</code>, calling <code>setActive</code> on every <code>GameObject</code> instance.</p>
			<p>The <code>getGameObjects</code> function passes a reference to the <code>vector</code> of <code>GameObject</code> instances.</p>
			<p>Now that we have coded the <code>LevelManager</code> class, we can update the <code>ScreenManager</code> and the <code>ScreenManagerRemoteControl</code> classes that it implements.</p>
			<h1 id="_idParaDest-428"><a id="_idTextAnchor442"/>Updating the ScreenManager and ScreenManagerRemoteControl classes</h1>
			<p>Open the <code>ScreenManagerRemoteControl.h</code> file and uncomment everything so that the code is the same as the following. I have highlighted the lines that have been uncommented:</p>
			<pre>#pragma once
#include &lt;string&gt;
#include &lt;vector&gt;
<strong class="bold">#include "GameObject.h"</strong>
<strong class="bold">#include "GameObjectSharer.h"</strong>
using namespace std;
class ScreenManagerRemoteControl
{
public:
    virtual void SwitchScreens(string screenToSwitchTo) = 0;
    virtual void loadLevelInPlayMode(string screenToLoad) = 0;
<strong class="bold">    virtual vector&lt;GameObject&gt;&amp; getGameObjects() = 0;</strong>
<strong class="bold">    virtual GameObjectSharer&amp; shareGameObjectSharer() = 0;</strong>
};</pre>
			<p>Next, open <code>ScreenManager.h</code>, which implements this interface and uncomments all the commented-out code. The code in question is abbreviated and highlighted as follows:</p>
			<pre>...
#include "SelectScreen.h"
<strong class="bold">//#include "LevelManager.h"</strong>
#include "BitmapStore.h"
...
...
private:
    map &lt;string, unique_ptr&lt;Screen&gt;&gt; m_Screens;
<strong class="bold">    //LevelManager m_LevelManager;</strong>
protected:
    ...
    ...
/****************************************************
*****************************************************
From ScreenManagerRemoteControl interface
*****************************************************
*****************************************************/
    ...
    ...
<strong class="bold">    //vector&lt;GameObject&gt;&amp; </strong>
<strong class="bold">        //ScreenManagerRemoteControl::getGameObjects()</strong>
<strong class="bold">    //{</strong>
<strong class="bold">        //return m_LevelManager.getGameObjects();</strong>
<strong class="bold">    //}</strong>
<strong class="bold">    //GameObjectSharer&amp; shareGameObjectSharer()</strong>
<strong class="bold">    //{</strong>
<strong class="bold">        //return m_LevelManager;</strong>
<strong class="bold">    //}</strong>
    ...
    ...</pre>
			<p>Be sure to uncomment the include directive, the <code>m_LevelManager</code> instance, as well as the two functions. </p>
			<p>The <code>ScreenManager</code> and <code>ScreenManagerRemoteControl</code> classes are now fully functional and the <code>getGameObjects</code> and <code>shareGameObjectSharer</code> functions are usable by any class with a reference to the <code>ScreenManager</code> class.</p>
			<h1 id="_idParaDest-429"><a id="_idTextAnchor443"/>Where are we now?</h1>
			<p>At this point, all the errors in our <code>GameObject</code> class, as well as all component-related classes, are gone. We are making good progress.</p>
			<p>Furthermore, we can revisit the <code>ScreenManager.h</code> file and uncomment all the commented-out code.</p>
			<p>Open <code>ScreenManager.h</code> and uncomment the <code>#include</code> directive, as follows:</p>
			<pre>//#include "LevelManager.h"</pre>
			<p>Change it to this:</p>
			<pre>#include "LevelManager.h"</pre>
			<p>Do the same for the functions from the <code>ScreenManagerRemoteControl</code> interface that are implemented in <code>ScreenManager.h</code>. They look like the following:</p>
			<pre>void ScreenManagerRemoteControl::
        loadLevelInPlayMode(string screenToLoad)
    {
        //m_LevelManager.getGameObjects().clear();
        //m_LevelManager.
            //loadGameObjectsForPlayMode(screenToLoad);
        SwitchScreens("Game");
    }
//vector&lt;GameObject&gt;&amp; 
    //ScreenManagerRemoteControl::getGameObjects()
//{
    //return m_LevelManager.getGameObjects();
//}</pre>
			<p>Change them as follows:</p>
			<pre>void ScreenManagerRemoteControl::
    loadLevelInPlayMode(string screenToLoad)
{
    m_LevelManager.getGameObjects().clear();
    m_LevelManager.
        loadGameObjectsForPlayMode(screenToLoad);
    SwitchScreens("Game");
}
vector&lt;GameObject&gt;&amp; 
    ScreenManagerRemoteControl::getGameObjects()
{
    return m_LevelManager.getGameObjects();
}</pre>
			<p>We aren't quite ready to run the game, however, because there are still some missing classes that are used in the code, such as <code>BulletSpawner</code> in the <code>InvaderUpdateComponent</code> class.</p>
			<h1 id="_idParaDest-430"><a id="_idTextAnchor444"/>Summary</h1>
			<p>In this chapter, we have put in place a way to describe a level in a game and a system to interpret the description and build usable <code>GameObject</code> instances. The Factory pattern is used in many types of programming, not just game development. The implementation we have used is the simplest possible implementation and I encourage you to put the Factory pattern on your list of patterns to research and develop further. The implementation we have used should serve you well if you wish to build some deep and interesting games, however.</p>
			<p>In the next chapter, we will finally make the game come to life by adding collision detection, bullet spawning, and the logic of the game itself.</p>
		</div>
	</body></html>