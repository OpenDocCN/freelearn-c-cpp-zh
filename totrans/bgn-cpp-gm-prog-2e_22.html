<html><head></head><body>
		<div id="_idContainer129">
			<h1 id="_idParaDest-418"><a id="_idTextAnchor432"/><em class="italic">Chapter 21</em>: File I/O and the Game Object Factory</h1>
			<p>This chapter handles how a <strong class="source-inline">GameObject</strong> gets into the <strong class="source-inline">m_GameObjects vector</strong> that's used in the game. We will look at how we can describe individual objects and an entire level in a text file. We will write code to interpret the text and then load up values into a class that will be a blueprint for a game object. We will also code a class called <strong class="source-inline">LevelManager</strong> that oversees the whole process, starting from the initial request to load a level sent from an <strong class="source-inline">InputHandler</strong> via the <strong class="source-inline">ScreenManager</strong>, right through to the factory pattern class that assembles a game object from components and delivers it to the <strong class="source-inline">LevelManager</strong>, neatly packed away in the <strong class="source-inline">m_GameObjects vector</strong>.</p>
			<p>The following are the steps we will go through in this chapter:</p>
			<ul>
				<li>Examine how we will describe game objects and their components in a text file</li>
				<li>Code the <strong class="source-inline">GameObjectBlueprint</strong> class where the data from the text file will be temporarily stored</li>
				<li>Code the <strong class="source-inline">ObjectTags</strong> class to help describe game objects consistently and without errors</li>
				<li>Code <strong class="source-inline">BluePrintObjectParser</strong>, which will be responsible for loading the data from a game object description in the text file into a <strong class="source-inline">GameObjectBlueprint</strong> instance</li>
				<li>Code <strong class="source-inline">PlayModeObjectLoader</strong>, which will open the text file and receive the <strong class="source-inline">GameObjectBlueprint</strong> instances one at a time from <strong class="source-inline">BlueprintObjectParser</strong></li>
				<li>Code the <strong class="source-inline">GameObjectFactoryPlayMode</strong> class, which will construct <strong class="source-inline">GameObject</strong> instances from <strong class="source-inline">GameObjectBlueprint</strong> instances</li>
				<li>Code the <strong class="source-inline">LevelManager</strong> class, which oversees this entire process after receiving an instruction from the <strong class="source-inline">ScreenManager</strong> class</li>
				<li>Add the code to the <strong class="source-inline">ScreenManager</strong> class so that we can begin using the new system that we will code in this chapter</li>
			</ul>
			<p>Let's start by examining exactly how we describe a game object such as a space invader or a bullet in a text file, let alone a whole wave of them.</p>
			<h1 id="_idParaDest-419"><a id="_idTextAnchor433"/>The structure of the file I/O and factory classes</h1>
			<p>Have a look at the following diagram, which gives an overview of the classes we will code in this chapter and how the <strong class="source-inline">vector</strong> of <strong class="source-inline">GameObject</strong> instances will be shared with the <strong class="source-inline">ScreenManager</strong> class that we coded in <a href="B14278_19_Final_AG_ePub.xhtml#_idTextAnchor372"><em class="italic">Chapter 19</em></a>, <em class="italic">Game Programming Design Patterns – Starting the Space Invaders ++ Game</em>:</p>
			<div>
				<div id="_idContainer128" class="IMG---Figure">
					<img src="image/Image93956.jpg" alt=""/>
				</div>
			</div>
			<p>The preceding diagram shows that there is a <strong class="source-inline">vector</strong> of <strong class="source-inline">GameObject</strong> instances that's shared between four classes. This is achieved by passing the <strong class="source-inline">vector</strong> between the functions of the classes by reference. Each class can then carry out its role with the <strong class="source-inline">vector</strong> and its contents. The <strong class="source-inline">ScreenManager</strong> class will trigger the <strong class="source-inline">LevelManager</strong> class when a new level needs to be loaded into the <strong class="source-inline">vector</strong>. The individual <strong class="source-inline">Screen</strong> classes and their <strong class="source-inline">InputHandler</strong>-derived classes, as we saw in <a href="B14278_19_Final_AG_ePub.xhtml#_idTextAnchor372"><em class="italic">Chapter 19</em></a>, <em class="italic">Game Programming Design Patterns – Starting the Space Invaders ++ Game</em>, have access to <strong class="source-inline">ScreenManager</strong> via <strong class="source-inline">ScreenManagerRemoteControl</strong>. </p>
			<p>The <strong class="source-inline">LevelManager</strong> class is ultimately responsible for creating and sharing the vector. <strong class="source-inline">PlayModeObjectLoader</strong> will use <strong class="source-inline">BlueprintObjectParser</strong> to create <strong class="source-inline">GameObjectBlueprint</strong> instances.</p>
			<p>The <strong class="source-inline">GameObjectFactoryPlayMode</strong> class will complete the <strong class="source-inline">GameObject</strong> creation process using these <strong class="source-inline">GameObjectBlueprint</strong> instances and pack <strong class="source-inline">GameObject</strong> instances into the <strong class="source-inline">vector</strong> when prompted to do so by <strong class="source-inline">PlayModeObjectLoader</strong>. </p>
			<p>So, where do the different component, position, size, and appearance configurations for each <strong class="source-inline">GameObject</strong> instance come from?</p>
			<p>We can also see that three classes have access to a <strong class="source-inline">GameObjectBlueprint</strong> instance. This instance is created by the <strong class="source-inline">LevelManager</strong> class and passed around by reference. <strong class="source-inline">BlueprintObjectParser</strong> will read the <strong class="source-inline">level1.txt</strong> file, which has all the details of each of the game objects. It will initialize all the variables of the <strong class="source-inline">GameObjectBlueprint</strong> class. <strong class="source-inline">PlayModeObjectLoader</strong> will then pass a reference to the <strong class="source-inline">vector</strong> of <strong class="source-inline">GameObject</strong> instances, and also pass a reference to the fully configured <strong class="source-inline">GameObjectBlueprint</strong> instance to the <strong class="source-inline">GameObjectFactoryPlayMode</strong> class. This is repeated until all the <strong class="source-inline">GameObject</strong> instances are packed away in the <strong class="source-inline">vector</strong>. </p>
			<p>You might be wondering why I have used slightly cumbersome class names such as <strong class="source-inline">GameObjectFactoryPlayMode</strong> and <strong class="source-inline">PlayModeObjectLoader</strong>. The reason is that, once you see how convenient this system is, you might like to build tools that allow you to design your levels in a visual way by dragging and dropping them where required and then have the text file auto-generated rather than typed. This is not especially complicated, but I had to stop adding features to the game at some point. Therefore, you might well end up with a <strong class="source-inline">GameObjectFactoryDesignMode</strong> and a <strong class="source-inline">DesignModeObjectLoader</strong>.</p>
			<h1 id="_idParaDest-420"><a id="_idTextAnchor434"/>Describing an object in the world</h1>
			<p>We have already added the <strong class="source-inline">level1.txt</strong> file in the <strong class="source-inline">world</strong> folder in <a href="B14278_19_Final_AG_ePub.xhtml#_idTextAnchor372"><em class="italic">Chapter 19</em></a>, <em class="italic">Game Programming Design Patterns – Starting the Space Invaders ++ Game</em>. Let's discuss its uses, future intended uses, and its contents.</p>
			<p>First, I would like to point out that a shooter game is not the best way to demonstrate how to describe a game world in a text file like this. The reason for this is that there are only a few types of game object and the most common one, invaders, are all lined up uniformly like soldiers on parade. They would actually be more efficiently described programmatically, perhaps in a nested <strong class="source-inline">for</strong> loop. However, the intention of this project was to show the ideas, rather than learn how to make a Space Invaders clone.</p>
			<p>Take a look at the following text, which is a sample from the <strong class="source-inline">level1.txt</strong> file in the <strong class="source-inline">world</strong> folder:</p>
			<p class="source-code">[START OBJECT]</p>
			<p class="source-code">[NAME]invader[-NAME]</p>
			<p class="source-code">[COMPONENT]Standard Graphics[-COMPONENT]</p>
			<p class="source-code">[COMPONENT]Invader Update[-COMPONENT]</p>
			<p class="source-code">[COMPONENT]Transform[-COMPONENT]</p>
			<p class="source-code">[LOCATION X]0[-LOCATION X]</p>
			<p class="source-code">[LOCATION Y]0[-LOCATION Y]</p>
			<p class="source-code">[WIDTH]2[-WIDTH]</p>
			<p class="source-code">[HEIGHT]2[-HEIGHT]</p>
			<p class="source-code">[BITMAP NAME]invader1[-BITMAP NAME]</p>
			<p class="source-code">[ENCOMPASSING RECT COLLIDER]invader[-ENCOMPASSING_RECT COLLIDER]</p>
			<p class="source-code">[END OBJECT]</p>
			<p>The preceding text describes a single object in the game; in this case, an invader. The object begins with the following text:</p>
			<p class="source-code">[START OBJECT]</p>
			<p>That will inform our code we'll write that a new object is being described. Next in the text, we can see the following:</p>
			<p class="source-code">[NAME]invader[-NAME]</p>
			<p>This informs the code that the type of object is an invader. This will eventually be set as the <strong class="source-inline">m_Tag</strong> of the <strong class="source-inline">ColliderComponent</strong> class. The invader will be identifiable for what it is. The text that comes next is as follows:</p>
			<p class="source-code">[COMPONENT]Standard Graphics[-COMPONENT]</p>
			<p class="source-code">[COMPONENT]Invader Update[-COMPONENT]</p>
			<p class="source-code">[COMPONENT]Transform[-COMPONENT]</p>
			<p>This tells our system that this object will have three components added to it: a <strong class="source-inline">StandardGraphicsComponent</strong> instance, an <strong class="source-inline">InvaderUpdateComponent</strong> instance, and a <strong class="source-inline">TransformComponent</strong> instance. This means the object will be drawn in the standard way and will behave according to the rules we coded for an invader. It will also mean it has a location and scale in the game world. It is possible to have objects that don't have any components or fewer components. An object that takes no action and doesn't move will not need an update component, an object that is invisible will not need a graphics component (perhaps just an invisible collider which triggers some action), and an object that has no position in the world (perhaps a debugging object) will not need a transform component.</p>
			<p>The position and scale of an object are determined by the following four lines of text:</p>
			<p class="source-code">[LOCATION X]0[-LOCATION X]</p>
			<p class="source-code">[LOCATION Y]0[-LOCATION Y]</p>
			<p class="source-code">[WIDTH]2[-WIDTH]</p>
			<p class="source-code">[HEIGHT]2[-HEIGHT]</p>
			<p>The following line of text determines what graphics file will be used for the texture of this object:</p>
			<p class="source-code">[BITMAP NAME]invader1[-BITMAP NAME]</p>
			<p>The following line means that the object can be collided with. A decorative object, perhaps floating clouds (or a bee), would not need a collider:</p>
			<p class="source-code">[ENCOMPASSING RECT COLLIDER]invader[-ENCOMPASSING_RECT COLLIDER]</p>
			<p>The final line of text will inform our system that the object has finished describing itself:</p>
			<p class="source-code">[END OBJECT]</p>
			<p>Now, let's have a look at how we describe a bullet object:</p>
			<p class="source-code">[START OBJECT]</p>
			<p class="source-code">[NAME]bullet[-NAME]</p>
			<p class="source-code">[COMPONENT]Standard Graphics[-COMPONENT]</p>
			<p class="source-code">[COMPONENT]Transform[-COMPONENT]</p>
			<p class="source-code">[COMPONENT]Bullet Update[-COMPONENT]</p>
			<p class="source-code">[LOCATION X]-1[-LOCATION X]</p>
			<p class="source-code">[LOCATION Y]-1[-LOCATION Y]</p>
			<p class="source-code">[WIDTH]0.1[-WIDTH]</p>
			<p class="source-code">[HEIGHT]2.0[-HEIGHT]</p>
			<p class="source-code">[BITMAP NAME]bullet[-BITMAP NAME]</p>
			<p class="source-code">[ENCOMPASSING RECT COLLIDER]bullet[-ENCOMPASSING_RECT COLLIDER]</p>
			<p class="source-code">[SPEED]75.0[-SPEED]</p>
			<p class="source-code">[END OBJECT]</p>
			<p>This is very similar but not the same as an invader. A bullet object has additional data, such as a set speed. The invader's speed is set in the logic of the <strong class="source-inline">InvaderUpdateComponent</strong> class. We could have done this for the bullet's speed as well, but this demonstrates that you can describe the object in as much or as little detail as the specific game design requires. Also, as we would expect, a bullet has a <strong class="source-inline">BulletUpdateComponent</strong> and a different value for the <strong class="source-inline">[BITMAP NAME]</strong> element. Notice that the location of the bullet is set to -1, -1. This means the bullets are outside of the playable area at the start of the game. In the next chapter, we will see how an invader, or the player, can spawn them into action when required.</p>
			<p>Now, study the following text, which describes the player's ship:</p>
			<p class="source-code">[START OBJECT]</p>
			<p class="source-code">[NAME]Player[-NAME]</p>
			<p class="source-code">[COMPONENT]Standard Graphics[-COMPONENT]</p>
			<p class="source-code">[COMPONENT]Transform[-COMPONENT]</p>
			<p class="source-code">[COMPONENT]Player Update[-COMPONENT]</p>
			<p class="source-code">[LOCATION X]50[-LOCATION X]</p>
			<p class="source-code">[LOCATION Y]40[-LOCATION Y]</p>
			<p class="source-code">[WIDTH]3.0[-WIDTH]</p>
			<p class="source-code">[HEIGHT]2.0[-HEIGHT]</p>
			<p class="source-code">[BITMAP NAME]playership[-BITMAP NAME]</p>
			<p class="source-code">[ENCOMPASSING RECT COLLIDER]player[-ENCOMPASSING_RECT COLLIDER]</p>
			<p class="source-code">[SPEED]10.0[-SPEED]</p>
			<p class="source-code">[END OBJECT]</p>
			<p>The preceding text was probably quite predictable based on our discussion so far. Now that we've gone through this, we can get to work on coding the system that will interpret these object descriptions and convert them into usable <strong class="source-inline">GameObject</strong> instances.</p>
			<h1 id="_idParaDest-421"><a id="_idTextAnchor435"/>Coding the GameObjectBlueprint class</h1>
			<p>Create a new header file in the <strong class="source-inline">Header Files/FileIO</strong> filter called <strong class="source-inline">GameObjectBlueprint.h</strong> and add the following code:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#include&lt;vector&gt;</p>
			<p class="source-code">#include&lt;string&gt;</p>
			<p class="source-code">#include&lt;map&gt;</p>
			<p class="source-code">using namespace std;</p>
			<p class="source-code">class GameObjectBlueprint {</p>
			<p class="source-code">private:</p>
			<p class="source-code">    string m_Name = "";</p>
			<p class="source-code">    vector&lt;string&gt; m_ComponentList;</p>
			<p class="source-code">    string m_BitmapName = "";</p>
			<p class="source-code">    float m_Width;</p>
			<p class="source-code">    float m_Height;</p>
			<p class="source-code">    float m_LocationX;</p>
			<p class="source-code">    float m_LocationY;</p>
			<p class="source-code">    float m_Speed;</p>
			<p class="source-code">    bool m_EncompassingRectCollider = false;</p>
			<p class="source-code">    string m_EncompassingRectColliderLabel = "";    </p>
			<p class="source-code">public:</p>
			<p class="source-code">    float getWidth();</p>
			<p class="source-code">    void setWidth(float width);</p>
			<p class="source-code">    float getHeight();</p>
			<p class="source-code">    void setHeight(float height);</p>
			<p class="source-code">    float getLocationX();</p>
			<p class="source-code">    void setLocationX(float locationX);</p>
			<p class="source-code">    float getLocationY();</p>
			<p class="source-code">    void setLocationY(float locationY);</p>
			<p class="source-code">    void setName(string name);</p>
			<p class="source-code">    string getName();</p>
			<p class="source-code">    vector&lt;string&gt;&amp; getComponentList();</p>
			<p class="source-code">    void addToComponentList(string newComponent);</p>
			<p class="source-code">    string getBitmapName();</p>
			<p class="source-code">    void setBitmapName(string bitmapName);    </p>
			<p class="source-code">    string getEncompassingRectColliderLabel();</p>
			<p class="source-code">    bool getEncompassingRectCollider();</p>
			<p class="source-code">    void setEncompassingRectCollider(string label);</p>
			<p class="source-code">};</p>
			<p><strong class="source-inline">GameObjectBlueprint</strong> has a member variable for every possible property that could go into a game object. Note that it does not compartmentalize the properties by component. For example, it just has variables for things such as width, height, and location; it doesn't go to the trouble of identifying these as part of the transform component. These details are handled in the factory. It also provides getters and setters so that the <strong class="source-inline">BlueprintObjectParser</strong> class can pack away all the values from the <strong class="source-inline">level1.txt</strong> file and the <strong class="source-inline">GameObjectFactoryPlayMode</strong> class can extract all the values, instantiate the appropriate components, and add them to an instance of <strong class="source-inline">GameObject</strong>.</p>
			<p>Create a new source file in the <strong class="source-inline">Source Files/FileIO</strong> filter called <strong class="source-inline">GameObjectBlueprint.cpp</strong> and add the following code, which is for the definitions of the functions we have just declared:</p>
			<p class="source-code">#include "GameObjectBlueprint.h"</p>
			<p class="source-code">float GameObjectBlueprint::getWidth() </p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_Width;</p>
			<p class="source-code">}</p>
			<p class="source-code">void GameObjectBlueprint::setWidth(float width) </p>
			<p class="source-code">{</p>
			<p class="source-code">    m_Width = width;</p>
			<p class="source-code">}</p>
			<p class="source-code">float GameObjectBlueprint::getHeight() </p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_Height;</p>
			<p class="source-code">}</p>
			<p class="source-code">void GameObjectBlueprint::setHeight(float height) </p>
			<p class="source-code">{</p>
			<p class="source-code">    m_Height = height;</p>
			<p class="source-code">}</p>
			<p class="source-code">float GameObjectBlueprint::getLocationX() </p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_LocationX;</p>
			<p class="source-code">}</p>
			<p class="source-code">void GameObjectBlueprint::setLocationX(float locationX) </p>
			<p class="source-code">{</p>
			<p class="source-code">    m_LocationX = locationX;</p>
			<p class="source-code">}</p>
			<p class="source-code">float GameObjectBlueprint::getLocationY() </p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_LocationY;</p>
			<p class="source-code">}</p>
			<p class="source-code">void GameObjectBlueprint::setLocationY(float locationY) </p>
			<p class="source-code">{</p>
			<p class="source-code">    m_LocationY = locationY;</p>
			<p class="source-code">}</p>
			<p class="source-code">void GameObjectBlueprint::setName(string name)</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_Name = "" + name;</p>
			<p class="source-code">}</p>
			<p class="source-code">string GameObjectBlueprint::getName()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_Name;</p>
			<p class="source-code">}</p>
			<p class="source-code">vector&lt;string&gt;&amp; GameObjectBlueprint::getComponentList()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_ComponentList;</p>
			<p class="source-code">}</p>
			<p class="source-code">void GameObjectBlueprint::addToComponentList(string newComponent)</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_ComponentList.push_back(newComponent);</p>
			<p class="source-code">}</p>
			<p class="source-code">string GameObjectBlueprint::getBitmapName()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_BitmapName;</p>
			<p class="source-code">}</p>
			<p class="source-code">void GameObjectBlueprint::setBitmapName(string bitmapName)</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_BitmapName = "" + bitmapName;</p>
			<p class="source-code">}</p>
			<p class="source-code">string GameObjectBlueprint::getEncompassingRectColliderLabel() </p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_EncompassingRectColliderLabel;</p>
			<p class="source-code">}</p>
			<p class="source-code">bool GameObjectBlueprint::getEncompassingRectCollider() </p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_EncompassingRectCollider;</p>
			<p class="source-code">}</p>
			<p class="source-code">void GameObjectBlueprint::setEncompassingRectCollider(</p>
			<p class="source-code">    string label) </p>
			<p class="source-code">{</p>
			<p class="source-code">    m_EncompassingRectCollider = true;</p>
			<p class="source-code">    m_EncompassingRectColliderLabel = "" + label;</p>
			<p class="source-code">}</p>
			<p>Although this is a long class, there is nothing here we haven't seen before. The setter functions receive values which are copied into a vector or a variable, while the getters allow access to these values.</p>
			<h1 id="_idParaDest-422"><a id="_idTextAnchor436"/>Coding the ObjectTags class</h1>
			<p>The way in which we describe the game objects in the <strong class="source-inline">level1.txt</strong> file needs to be precise because the <strong class="source-inline">BlueprintObjectParser</strong> class we will code after this class will be reading the text from the file and looking for matches. For example, the <strong class="source-inline">[START OBJECT]</strong> tag will trigger the start of a new object. If that tag is misspelled as, say, <strong class="source-inline">[START OBJECR]</strong>, then the whole system falls apart and there will be all kinds of bugs, and even crashes when we run the game. To avoid this happening, we will define constant (programmatically unchangeable) <strong class="source-inline">string</strong> variables for all the tags we need to describe the game objects. We can use these <strong class="source-inline">string</strong> variables instead of typing something such as <strong class="source-inline">[START OBJECT]</strong> and have much less chance of making a mistake.</p>
			<p>Create a new header file in the <strong class="source-inline">Header Files/FileIO</strong> filter called <strong class="source-inline">ObjectTags.h</strong> and add the following code:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#include &lt;string&gt;</p>
			<p class="source-code">using namespace std;</p>
			<p class="source-code">static class ObjectTags {</p>
			<p class="source-code">public:</p>
			<p class="source-code">    static const string START_OF_OBJECT;</p>
			<p class="source-code">    static const string END_OF_OBJECT;</p>
			<p class="source-code">    static const string COMPONENT;</p>
			<p class="source-code">    static const string COMPONENT_END;</p>
			<p class="source-code">    static const string NAME;</p>
			<p class="source-code">    static const string NAME_END;</p>
			<p class="source-code">    static const string WIDTH;</p>
			<p class="source-code">    static const string WIDTH_END;</p>
			<p class="source-code">    static const string HEIGHT;</p>
			<p class="source-code">    static const string HEIGHT_END;</p>
			<p class="source-code">    static const string LOCATION_X;</p>
			<p class="source-code">    static const string LOCATION_X_END;</p>
			<p class="source-code">    static const string LOCATION_Y;</p>
			<p class="source-code">    static const string LOCATION_Y_END;</p>
			<p class="source-code">    static const string BITMAP_NAME;</p>
			<p class="source-code">    static const string BITMAP_NAME_END;</p>
			<p class="source-code">    static const string ENCOMPASSING_RECT_COLLIDER;</p>
			<p class="source-code">    static const string ENCOMPASSING_RECT_COLLIDER_END;</p>
			<p class="source-code">};</p>
			<p>We have declared a <strong class="source-inline">const string</strong> for every tag we will use to describe the game objects. Now, we can initialize them.</p>
			<p>Create a new source file in the <strong class="source-inline">Source Files/FileIO</strong> filter called <strong class="source-inline">ObjectTags.cpp</strong> and add the following code:</p>
			<p class="source-code">#include "DevelopState.h"</p>
			<p class="source-code">#include "objectTags.h"</p>
			<p class="source-code">const string ObjectTags::START_OF_OBJECT = "[START OBJECT]";</p>
			<p class="source-code">const string ObjectTags::END_OF_OBJECT = "[END OBJECT]";</p>
			<p class="source-code">const string ObjectTags::COMPONENT = "[COMPONENT]";</p>
			<p class="source-code">const string ObjectTags::COMPONENT_END = "[-COMPONENT]";</p>
			<p class="source-code">const string ObjectTags::NAME = "[NAME]";</p>
			<p class="source-code">const string ObjectTags::NAME_END = "[-NAME]";</p>
			<p class="source-code">const string ObjectTags::WIDTH = "[WIDTH]";</p>
			<p class="source-code">const string ObjectTags::WIDTH_END = "[-WIDTH]";</p>
			<p class="source-code">const string ObjectTags::HEIGHT = "[HEIGHT]";</p>
			<p class="source-code">const string ObjectTags::HEIGHT_END = "[-HEIGHT]";</p>
			<p class="source-code">const string ObjectTags::LOCATION_X = "[LOCATION X]";</p>
			<p class="source-code">const string ObjectTags::LOCATION_X_END = "[-LOCATION X]";</p>
			<p class="source-code">const string ObjectTags::LOCATION_Y = "[LOCATION Y]";</p>
			<p class="source-code">const string ObjectTags::LOCATION_Y_END = "[-LOCATION Y]";</p>
			<p class="source-code">const string ObjectTags::BITMAP_NAME = "[BITMAP NAME]";</p>
			<p class="source-code">const string ObjectTags::BITMAP_NAME_END = "[-BITMAP NAME]";</p>
			<p class="source-code">const string ObjectTags::ENCOMPASSING_RECT_COLLIDER = </p>
			<p class="source-code">    "[ENCOMPASSING RECT COLLIDER]";</p>
			<p class="source-code">    </p>
			<p class="source-code">const string ObjectTags::ENCOMPASSING_RECT_COLLIDER_END </p>
			<p class="source-code">    = "[-ENCOMPASSING_RECT COLLIDER]";</p>
			<p>That's all the <strong class="source-inline">string</strong> variables initialized. We can now use them in the next class and be sure we are describing the game objects consistently.</p>
			<h1 id="_idParaDest-423"><a id="_idTextAnchor437"/>Coding the BlueprintObjectParser class</h1>
			<p>This class will have the code that actually reads the text from the <strong class="source-inline">level1.txt</strong> file we have discussed. It will parse one object at a time, as identified by the start and end tags we saw previously. </p>
			<p>Create a new header file in the <strong class="source-inline">Header Files/FileIO</strong> filter called <strong class="source-inline">BlueprintObjectParser.h</strong> and add the following code:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#include "GameObjectBlueprint.h"</p>
			<p class="source-code">#include &lt;string&gt;</p>
			<p class="source-code">using namespace std;</p>
			<p class="source-code">class BlueprintObjectParser {</p>
			<p class="source-code">private:</p>
			<p class="source-code">    string extractStringBetweenTags(</p>
			<p class="source-code">        string stringToSearch, string startTag, string endTag);</p>
			<p class="source-code">public:</p>
			<p class="source-code">    void parseNextObjectForBlueprint(</p>
			<p class="source-code">        ifstream&amp; reader, GameObjectBlueprint&amp; bp);</p>
			<p class="source-code">};</p>
			<p>The <strong class="source-inline">extractStringBetweenTags</strong> private function will capture the content between two tags. The parameters are three <strong class="source-inline">string</strong> instances. The first <strong class="source-inline">string</strong> is a full line of text from <strong class="source-inline">level1.txt</strong>, while the second and third are the start and end tags, which need to be discarded. The text between the two tags is then returned to the calling code.</p>
			<p>The <strong class="source-inline">parseNextObjectForBlueprint</strong> function receives an <strong class="source-inline">ifstream</strong> reader, just like the one we used in the Zombie shooter and the Thomas Was Late games. It is used to read from the file. The second parameter is a reference to a <strong class="source-inline">GameObjectBlueprint</strong> instance. The function will populate the <strong class="source-inline">GameObjectBlueprint</strong> instance with the values that were read from the <strong class="source-inline">level1.txt</strong> file, which can then be used back in the calling code to create an actual <strong class="source-inline">GameObject</strong>. We will see how that happens when we code the <strong class="source-inline">PlayModeObjectLoader</strong> class next and the <strong class="source-inline">GameObjectFactoryPlayMode</strong> class after that.</p>
			<p>Let's code the definitions we have just discussed.</p>
			<p>Create a new source file in the <strong class="source-inline">Source Files/FileIO</strong> filter called <strong class="source-inline">BlueprintObjectParser.cpp</strong> and add the following code:</p>
			<p class="source-code">#include "BlueprintObjectParser.h"</p>
			<p class="source-code">#include "ObjectTags.h"</p>
			<p class="source-code">#include &lt;iostream&gt;</p>
			<p class="source-code">#include &lt;fstream&gt;</p>
			<p class="source-code">void BlueprintObjectParser::parseNextObjectForBlueprint(</p>
			<p class="source-code">    ifstream&amp; reader, GameObjectBlueprint&amp; bp)</p>
			<p class="source-code">{</p>
			<p class="source-code">    string lineFromFile;</p>
			<p class="source-code">    string value = "";</p>
			<p class="source-code">    while (getline(reader, lineFromFile)) </p>
			<p class="source-code">    {</p>
			<p class="source-code">        if (lineFromFile.find(ObjectTags::COMPONENT) </p>
			<p class="source-code">            != string::npos) </p>
			<p class="source-code">          {</p>
			<p class="source-code">            value = extractStringBetweenTags(lineFromFile, </p>
			<p class="source-code">                ObjectTags::COMPONENT, </p>
			<p class="source-code">                ObjectTags::COMPONENT_END);</p>
			<p class="source-code">            bp.addToComponentList(value);</p>
			<p class="source-code">        }</p>
			<p class="source-code">        else if (lineFromFile.find(ObjectTags::NAME) </p>
			<p class="source-code">            != string::npos) </p>
			<p class="source-code">          {</p>
			<p class="source-code">            value = extractStringBetweenTags(lineFromFile, </p>
			<p class="source-code">                ObjectTags::NAME, ObjectTags::NAME_END);</p>
			<p class="source-code">            bp.setName(value);</p>
			<p class="source-code">        }</p>
			<p class="source-code">        else if (lineFromFile.find(ObjectTags::WIDTH) </p>
			<p class="source-code">            != string::npos) </p>
			<p class="source-code">          {</p>
			<p class="source-code">            value = extractStringBetweenTags(lineFromFile, </p>
			<p class="source-code">                ObjectTags::WIDTH, ObjectTags::WIDTH_END);</p>
			<p class="source-code">            bp.setWidth(stof(value));</p>
			<p class="source-code">        }</p>
			<p class="source-code">        else if (lineFromFile.find(ObjectTags::HEIGHT) </p>
			<p class="source-code">            != string::npos) </p>
			<p class="source-code">          {</p>
			<p class="source-code">            value = extractStringBetweenTags(lineFromFile, </p>
			<p class="source-code">                ObjectTags::HEIGHT, ObjectTags::HEIGHT_END);</p>
			<p class="source-code">            bp.setHeight(stof(value));</p>
			<p class="source-code">        }</p>
			<p class="source-code">        else if (lineFromFile.find(ObjectTags::LOCATION_X) </p>
			<p class="source-code">            != string::npos) </p>
			<p class="source-code">          {</p>
			<p class="source-code">            value = extractStringBetweenTags(lineFromFile, </p>
			<p class="source-code">                ObjectTags::LOCATION_X, </p>
			<p class="source-code">                ObjectTags::LOCATION_X_END);</p>
			<p class="source-code">            bp.setLocationX(stof(value));</p>
			<p class="source-code">        }</p>
			<p class="source-code">        else if (lineFromFile.find(ObjectTags::LOCATION_Y) </p>
			<p class="source-code">            != string::npos) </p>
			<p class="source-code">          {</p>
			<p class="source-code">            value = extractStringBetweenTags(</p>
			<p class="source-code">                      lineFromFile, </p>
			<p class="source-code">                      ObjectTags::LOCATION_Y, </p>
			<p class="source-code">                      ObjectTags::LOCATION_Y_END);</p>
			<p class="source-code">            bp.setLocationY(stof(value));</p>
			<p class="source-code">        }</p>
			<p class="source-code">        else if (lineFromFile.find(ObjectTags::BITMAP_NAME) </p>
			<p class="source-code">            != string::npos) </p>
			<p class="source-code">          {</p>
			<p class="source-code">            value = extractStringBetweenTags(lineFromFile, </p>
			<p class="source-code">             ObjectTags::BITMAP_NAME, </p>
			<p class="source-code">             ObjectTags::BITMAP_NAME_END);</p>
			<p class="source-code">            bp.setBitmapName(value);</p>
			<p class="source-code">        }</p>
			<p class="source-code">        </p>
			<p class="source-code">        else if (lineFromFile.find(</p>
			<p class="source-code">            ObjectTags::ENCOMPASSING_RECT_COLLIDER) </p>
			<p class="source-code">            != string::npos) </p>
			<p class="source-code">          {</p>
			<p class="source-code">            value = extractStringBetweenTags(lineFromFile, </p>
			<p class="source-code">                ObjectTags::ENCOMPASSING_RECT_COLLIDER, </p>
			<p class="source-code">                ObjectTags::ENCOMPASSING_RECT_COLLIDER_END);</p>
			<p class="source-code">            bp.setEncompassingRectCollider(value);</p>
			<p class="source-code">        }</p>
			<p class="source-code">        </p>
			<p class="source-code">        else if (lineFromFile.find(ObjectTags::END_OF_OBJECT) </p>
			<p class="source-code">            != string::npos) </p>
			<p class="source-code">        {</p>
			<p class="source-code">            return;</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">string BlueprintObjectParser::extractStringBetweenTags(</p>
			<p class="source-code">    string stringToSearch, string startTag, string endTag)</p>
			<p class="source-code">{</p>
			<p class="source-code">    int start = startTag.length();</p>
			<p class="source-code">    int count = stringToSearch.length() - startTag.length() </p>
			<p class="source-code">        - endTag.length();</p>
			<p class="source-code">    string stringBetweenTags = stringToSearch.substr(</p>
			<p class="source-code">        start, count);</p>
			<p class="source-code">    return stringBetweenTags;</p>
			<p class="source-code">}</p>
			<p>The code in <strong class="source-inline">parseNextObjectForBlueprint</strong> is lengthy but straightforward. The series of <strong class="source-inline">if</strong> statements identifies the starting tag at the beginning of the line of text and then passes the line of text to the <strong class="source-inline">extractStringBetweenTags</strong> function, which returns the value that is then loaded into the <strong class="source-inline">GameObjectBlueprint</strong> reference in the appropriate place. Notice that the function exits when <strong class="source-inline">GameObjectBlueprint</strong> has had all the data loaded into it. This point is recognized when <strong class="source-inline">ObjectTags::END_OF_OBJECT</strong> is found.</p>
			<h1 id="_idParaDest-424"><a id="_idTextAnchor438"/>Coding the PlayModeObjectLoader class</h1>
			<p>This is the class that will pass <strong class="source-inline">GameObjectBlueprint</strong> instances to <strong class="source-inline">BlueprintObjectParser</strong>. When it gets the completed blueprint back, it will pass them to the <strong class="source-inline">GameObjectFactoryPlayMode</strong> class, which will construct the <strong class="source-inline">GameObject</strong> instance and pack it away in the <strong class="source-inline">vector</strong> instance. Once all the <strong class="source-inline">GameObject</strong> instances have been built and stored, responsibility will be handed to the <strong class="source-inline">LevelManager</strong> class, which will control access to the vector for other parts of the game engine. This is a very small class with just one function, but it links many other classes together. Refer to the diagram at the start of this chapter for clarification.</p>
			<p>Create a new header file in the <strong class="source-inline">Header Files/FileIO</strong> filter called <strong class="source-inline">PlayModeObjectLoader.h</strong> and add the following code:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#include &lt;vector&gt;</p>
			<p class="source-code">#include &lt;string&gt;</p>
			<p class="source-code">#include "GameObject.h"</p>
			<p class="source-code">#include "BlueprintObjectParser.h"</p>
			<p class="source-code">#include "GameObjectFactoryPlayMode.h"</p>
			<p class="source-code">using namespace std;</p>
			<p class="source-code">class PlayModeObjectLoader {</p>
			<p class="source-code">private:</p>
			<p class="source-code">    BlueprintObjectParser m_BOP;</p>
			<p class="source-code">    GameObjectFactoryPlayMode m_GameObjectFactoryPlayMode;</p>
			<p class="source-code">public:</p>
			<p class="source-code">    void loadGameObjectsForPlayMode(</p>
			<p class="source-code">        string pathToFile, vector&lt;GameObject&gt;&amp; mGameObjects);</p>
			<p class="source-code">};</p>
			<p>The <strong class="source-inline">PlayModeObjectLoader</strong> class has an instance of the previous class we coded, that is, the <strong class="source-inline">BluePrintObjectParser</strong> class. It also has an instance of the class we will code next, that is, the <strong class="source-inline">GameObjectFactoryPlayMode</strong> class. It has a single public function, which receives a reference to a <strong class="source-inline">vector</strong> that holds <strong class="source-inline">GameObject</strong> instances.</p>
			<p>Now, we will code the definition of the <strong class="source-inline">loadGameObjectsForPlayMode</strong> function. Create a new source file in the <strong class="source-inline">Source Files/FileIO</strong> filter called <strong class="source-inline">PlayModeObjectLoader.cpp</strong> and add the following code:</p>
			<p class="source-code">#include "PlayModeObjectLoader.h"</p>
			<p class="source-code">#include "ObjectTags.h"</p>
			<p class="source-code">#include &lt;iostream&gt;</p>
			<p class="source-code">#include &lt;fstream&gt;</p>
			<p class="source-code">void PlayModeObjectLoader::</p>
			<p class="source-code">    loadGameObjectsForPlayMode(</p>
			<p class="source-code">        string pathToFile, vector&lt;GameObject&gt;&amp; gameObjects)</p>
			<p class="source-code">{</p>
			<p class="source-code">    ifstream reader(pathToFile);</p>
			<p class="source-code">    string lineFromFile;</p>
			<p class="source-code">    float x = 0, y = 0, width = 0, height = 0;</p>
			<p class="source-code">    string value = "";</p>
			<p class="source-code">    while (getline(reader, lineFromFile)) {</p>
			<p class="source-code">        if (lineFromFile.find(</p>
			<p class="source-code">            ObjectTags::START_OF_OBJECT) != string::npos) {</p>
			<p class="source-code">            GameObjectBlueprint bp;</p>
			<p class="source-code">            m_BOP.parseNextObjectForBlueprint(reader, bp);</p>
			<p class="source-code">            m_GameObjectFactoryPlayMode.buildGameObject(</p>
			<p class="source-code">                bp, gameObjects);</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }       </p>
			<p class="source-code">}</p>
			<p>The function receives a <strong class="source-inline">string</strong>, which is the path to the file that needs to be loaded. This game only has one such file, but you could add more files with different layouts, varying numbers of invaders, or totally different game objects if you wanted to.</p>
			<p>An <strong class="source-inline">ifstream</strong> instance is used to read one line at a time from the file. In the <strong class="source-inline">while</strong> loop, the start tag is identified using <strong class="source-inline">ObjectTags::START_OF_OBJECT</strong>, and the <strong class="source-inline">parseNextObjectForBlueprint</strong> function of <strong class="source-inline">BlueprintObjectParser</strong> is called. You probably remember from the <strong class="source-inline">BlueprintObjectParser</strong> class that the completed blueprint is returned when <strong class="source-inline">ObjectTags::END_OF_OBJECT</strong> is reached.</p>
			<p>The next line of code calls the <strong class="source-inline">buildGameObject</strong> of the <strong class="source-inline">GameObjectFactoryPlayMode</strong> class and passes in the <strong class="source-inline">GameObjectBlueprint</strong> instance. We will code the <strong class="source-inline">GameObjectFactory</strong> class now.</p>
			<h1 id="_idParaDest-425"><a id="_idTextAnchor439"/>Coding the GameObjectFactoryPlayMode class</h1>
			<p>Now, we will code our factory, which will construct working game objects from the <strong class="source-inline">GameObject</strong> class and all the component related classes that we coded in the previous chapter. We will make extensive use of smart pointers, so we don't have to worry about deleting memory when we have finished with it.</p>
			<p>Create a new header file in the <strong class="source-inline">Header Files/FileIO</strong> filter called <strong class="source-inline">GameObjectFactoryPlayMode.h</strong> and add the following code:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#include "GameObjectBlueprint.h"</p>
			<p class="source-code">#include "GameObject.h"</p>
			<p class="source-code">#include &lt;vector&gt;</p>
			<p class="source-code">class GameObjectFactoryPlayMode {</p>
			<p class="source-code">public:</p>
			<p class="source-code">    void buildGameObject(GameObjectBlueprint&amp; bp, </p>
			<p class="source-code">        std::vector &lt;GameObject&gt;&amp; gameObjects);</p>
			<p class="source-code">};</p>
			<p>The factory class has just one function, <strong class="source-inline">buildGameObject</strong>. We have already seen the code that calls this function in the previous code we wrote for the <strong class="source-inline">PlayModeObjectLoader</strong> class. The function receives a reference to the blueprint, as well as a reference to the <strong class="source-inline">vector</strong> of <strong class="source-inline">GameObject</strong> instances.</p>
			<p>Create a new source file in the <strong class="source-inline">Source Files/FileIO</strong> filter called <strong class="source-inline">GameObjectFactoryPlayMode.cpp</strong> and add the following code:</p>
			<p class="source-code">#include "GameObjectFactoryPlayMode.h"</p>
			<p class="source-code">#include &lt;iostream&gt;</p>
			<p class="source-code">#include "TransformComponent.h"</p>
			<p class="source-code">#include "StandardGraphicsComponent.h"</p>
			<p class="source-code">#include "PlayerUpdateComponent.h"</p>
			<p class="source-code">#include "RectColliderComponent.h"</p>
			<p class="source-code">#include "InvaderUpdateComponent.h"</p>
			<p class="source-code">#include "BulletUpdateComponent.h"</p>
			<p class="source-code">void GameObjectFactoryPlayMode::buildGameObject(</p>
			<p class="source-code">    GameObjectBlueprint&amp; bp, </p>
			<p class="source-code">    std::vector&lt;GameObject&gt;&amp; gameObjects)</p>
			<p class="source-code">{</p>
			<p class="source-code">    GameObject gameObject;</p>
			<p class="source-code">    gameObject.setTag(bp.getName());</p>
			<p class="source-code">    auto it = bp.getComponentList().begin();</p>
			<p class="source-code">    auto end = bp.getComponentList().end();</p>
			<p class="source-code">    for (it;</p>
			<p class="source-code">        it != end;</p>
			<p class="source-code">        ++it)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        if (*it == "Transform")</p>
			<p class="source-code">        {</p>
			<p class="source-code">            gameObject.addComponent(</p>
			<p class="source-code">                make_shared&lt;TransformComponent&gt;(</p>
			<p class="source-code">                bp.getWidth(),</p>
			<p class="source-code">                bp.getHeight(),</p>
			<p class="source-code">                Vector2f(bp.getLocationX(),</p>
			<p class="source-code">                 bp.getLocationY())));</p>
			<p class="source-code">        }</p>
			<p class="source-code">        else if (*it == "Player Update")</p>
			<p class="source-code">        {</p>
			<p class="source-code">            gameObject.addComponent(make_shared</p>
			<p class="source-code">                &lt;PlayerUpdateComponent&gt;());</p>
			<p class="source-code">        }</p>
			<p class="source-code">        else if (*it == "Invader Update")</p>
			<p class="source-code">        {</p>
			<p class="source-code">            gameObject.addComponent(make_shared</p>
			<p class="source-code">                &lt;InvaderUpdateComponent&gt;());</p>
			<p class="source-code">        }</p>
			<p class="source-code">        else if (*it == "Bullet Update")</p>
			<p class="source-code">        {</p>
			<p class="source-code">            gameObject.addComponent(make_shared</p>
			<p class="source-code">                &lt;BulletUpdateComponent&gt;());</p>
			<p class="source-code">        }</p>
			<p class="source-code">        else if (*it == "Standard Graphics")</p>
			<p class="source-code">        {</p>
			<p class="source-code">            shared_ptr&lt;StandardGraphicsComponent&gt; sgp =</p>
			<p class="source-code">                make_shared&lt;StandardGraphicsComponent&gt;();</p>
			<p class="source-code">            gameObject.addComponent(sgp);</p>
			<p class="source-code">            sgp-&gt;initializeGraphics(</p>
			<p class="source-code">                bp.getBitmapName(),</p>
			<p class="source-code">                Vector2f(bp.getWidth(), </p>
			<p class="source-code">                    bp.getHeight()));</p>
			<p class="source-code">        }        </p>
			<p class="source-code">    }</p>
			<p class="source-code">    if (bp.getEncompassingRectCollider()) {</p>
			<p class="source-code">        shared_ptr&lt;RectColliderComponent&gt; rcc = </p>
			<p class="source-code">            make_shared&lt;RectColliderComponent&gt;(</p>
			<p class="source-code">            bp.getEncompassingRectColliderLabel());</p>
			<p class="source-code">        gameObject.addComponent(rcc);</p>
			<p class="source-code">        rcc-&gt;setOrMoveCollider(bp.getLocationX(),</p>
			<p class="source-code">            bp.getLocationY(),</p>
			<p class="source-code">            bp.getWidth(),</p>
			<p class="source-code">            bp.getHeight());</p>
			<p class="source-code">    }   </p>
			<p class="source-code">    </p>
			<p class="source-code">    gameObjects.push_back(gameObject);</p>
			<p class="source-code">}</p>
			<p>The first thing that happens in the <strong class="source-inline">buildGameObject</strong> function is that a new <strong class="source-inline">GameObject</strong> instance is created and the <strong class="source-inline">setTag</strong> function of the <strong class="source-inline">GameObject</strong> class is used to pass in the name of the current object being built:</p>
			<p class="source-code">GameObject gameObject;</p>
			<p class="source-code">gameObject.setTag(bp.getName());</p>
			<p>Next, a <strong class="source-inline">for</strong> loop loops through all the components in the <strong class="source-inline">m_Components vector</strong>. For each component that is found, a different <strong class="source-inline">if </strong>statement creates a component of the appropriate type. The way that each component is created varies, as you would expect since the way they are coded varies.</p>
			<p>The following code creates a shared pointer to a <strong class="source-inline">TransformComponent</strong> instance. You can see the necessary arguments being passed to the constructor, that is, width, height, and location. The result of creating the new shared pointer to a <strong class="source-inline">TransformComponent</strong> instance is passed to the <strong class="source-inline">addComponent</strong> function of the <strong class="source-inline">GameObject</strong> class. The <strong class="source-inline">GameObject</strong> instance now has its size and place in the world:</p>
			<p class="source-code">if (*it == "Transform")</p>
			<p class="source-code">{</p>
			<p class="source-code">    gameObject.addComponent(make_shared&lt;TransformComponent&gt;(</p>
			<p class="source-code">        bp.getWidth(),</p>
			<p class="source-code">        bp.getHeight(),</p>
			<p class="source-code">        Vector2f(bp.getLocationX(), bp.getLocationY())));</p>
			<p class="source-code">}</p>
			<p>The following code executes when a <strong class="source-inline">PlayerUpdateComponent</strong> is required. Again, the code creates a new shared pointer to the appropriate class and passes it in to the <strong class="source-inline">addComponent</strong> function of the <strong class="source-inline">GameObject</strong> instance:</p>
			<p class="source-code">else if (*it == "Player Update")</p>
			<p class="source-code">{</p>
			<p class="source-code">    gameObject.addComponent(make_shared</p>
			<p class="source-code">        &lt;PlayerUpdateComponent&gt;());</p>
			<p class="source-code">}</p>
			<p>The following three blocks of code use exactly the same technique to add either an <strong class="source-inline">InvaderUpdateComponent</strong>, <strong class="source-inline">BulletUpdateComponent</strong>, or <strong class="source-inline">StandardGraphicsComponent</strong> instance. Notice the extra line of code after adding a <strong class="source-inline">StandardGraphicsComponent</strong> instance that calls the <strong class="source-inline">initialize</strong> function, which adds a <strong class="source-inline">Texture</strong> instance (if required) to the <strong class="source-inline">BitmapStore</strong> singleton and prepares the component to be drawn:</p>
			<p class="source-code">else if (*it == "Invader Update")</p>
			<p class="source-code">{</p>
			<p class="source-code">    gameObject.addComponent(make_shared</p>
			<p class="source-code">        &lt;InvaderUpdateComponent&gt;());</p>
			<p class="source-code">}</p>
			<p class="source-code">else if (*it == "Bullet Update")</p>
			<p class="source-code">{</p>
			<p class="source-code">    gameObject.addComponent(make_shared</p>
			<p class="source-code">        &lt;BulletUpdateComponent&gt;());</p>
			<p class="source-code">}</p>
			<p class="source-code">else if (*it == "Standard Graphics")</p>
			<p class="source-code">{</p>
			<p class="source-code">    shared_ptr&lt;StandardGraphicsComponent&gt; sgp =</p>
			<p class="source-code">        make_shared&lt;StandardGraphicsComponent&gt;();</p>
			<p class="source-code">    gameObject.addComponent(sgp);</p>
			<p class="source-code">    sgp-&gt;initializeGraphics(</p>
			<p class="source-code">        bp.getBitmapName(),</p>
			<p class="source-code">        Vector2f(bp.getWidth(), </p>
			<p class="source-code">            bp.getHeight()));</p>
			<p class="source-code">}</p>
			<p>The final <strong class="source-inline">if </strong>block, as shown in the following code, handles adding a <strong class="source-inline">RectColliderComponent</strong> instance. The first line of code creates the shared pointer, while the second line of code calls the <strong class="source-inline">addComponent</strong> function to add the instance to the <strong class="source-inline">GameObject</strong> instance. The third line of code calls the <strong class="source-inline">setOrMoveCollider</strong> and passes in the location and size of the object. At this stage, the object is ready to be collided with. Obviously, we still need to write the code that tests for collisions. We will do so in the next chapter:</p>
			<p class="source-code">if (bp.getEncompassingRectCollider()) {</p>
			<p class="source-code">        shared_ptr&lt;RectColliderComponent&gt; rcc = </p>
			<p class="source-code">            make_shared&lt;RectColliderComponent&gt;(</p>
			<p class="source-code">            bp.getEncompassingRectColliderLabel());</p>
			<p class="source-code">        gameObject.addComponent(rcc);</p>
			<p class="source-code">        rcc-&gt;setOrMoveCollider(bp.getLocationX(),</p>
			<p class="source-code">            bp.getLocationY(),</p>
			<p class="source-code">            bp.getWidth(),</p>
			<p class="source-code">            bp.getHeight());</p>
			<p class="source-code">}</p>
			<p>The following line of code in the class adds the just-constructed <strong class="source-inline">GameObject</strong> instance to the <strong class="source-inline">vector</strong> that will be shared with the <strong class="source-inline">GameScreen</strong> class and used to make the game come to life:</p>
			<p class="source-code">gameObjects.push_back(gameObject);</p>
			<p>The next class we will write makes it easy to share the <strong class="source-inline">vector</strong> we have just filled with <strong class="source-inline">GameObject</strong> instances around the various classes of the project.</p>
			<h1 id="_idParaDest-426"><a id="_idTextAnchor440"/>Coding the GameObjectSharer class</h1>
			<p>This class will have two pure virtual functions that share <strong class="source-inline">GameObject</strong> instances with other classes.</p>
			<p>Create a new header file in the <strong class="source-inline">Header Files/FileIO</strong> filter called <strong class="source-inline">GameObjectSharer.h</strong> and add the following code:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#include&lt;vector&gt;</p>
			<p class="source-code">#include&lt;string&gt;</p>
			<p class="source-code">class GameObject;</p>
			<p class="source-code">class GameObjectSharer {</p>
			<p class="source-code">public:</p>
			<p class="source-code">    virtual std::vector&lt;GameObject&gt;&amp; getGameObjectsWithGOS() = 0;</p>
			<p class="source-code">    virtual GameObject&amp; findFirstObjectWithTag(</p>
			<p class="source-code">             std::string tag) = 0;</p>
			<p class="source-code">};</p>
			<p>The <strong class="source-inline">getGameObjectsWithGOS</strong> function returns a reference to the entire vector of <strong class="source-inline">GameObject</strong> instances. The <strong class="source-inline">findFirstObjectWithTag</strong> function returns just a single <strong class="source-inline">GameObject</strong> reference. We will see how we implement these functions when we inherit from <strong class="source-inline">GameObjectSharer</strong> when we code the <strong class="source-inline">LevelManager</strong> class next.</p>
			<p>Briefly, before the <strong class="source-inline">LevelManager</strong> class, create a new source file in the <strong class="source-inline">Source Files/FileIO</strong> filter called <strong class="source-inline">GameObjectSharer.cpp</strong> and add the following code:</p>
			<p class="source-code">/*********************************</p>
			<p class="source-code">******THIS IS AN INTERFACE********</p>
			<p class="source-code">*********************************/</p>
			<p>Again, this is just a placeholder file and the full functionality goes in any of the classes that inherit from <strong class="source-inline">GameObjectSharer</strong>; in this case, the <strong class="source-inline">LevelManager</strong> class.</p>
			<h1 id="_idParaDest-427"><a id="_idTextAnchor441"/>Coding the LevelManager class</h1>
			<p>The <strong class="source-inline">LevelManager</strong> class is the connection between what we coded in <a href="B14278_19_Final_AG_ePub.xhtml#_idTextAnchor372"><em class="italic">Chapter 19</em></a>, <em class="italic">Game Programming Design Patterns – Starting the Space Invaders ++ Game</em>, and everything we coded in this chapter. The <strong class="source-inline">ScreenManager</strong> class will have an instance of the <strong class="source-inline">LevelManager</strong> class, and the <strong class="source-inline">LevelManager</strong> class will instigate loading levels (using all the classes we have just coded) and share <strong class="source-inline">GameObject</strong> instances with any classes that need them.</p>
			<p>Create a new header file in the <strong class="source-inline">Header Files/Engine</strong> filter called <strong class="source-inline">LevelManager.h</strong> and add the following code:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#include "GameObject.h"</p>
			<p class="source-code">#include &lt;vector&gt;</p>
			<p class="source-code">#include &lt;string&gt;</p>
			<p class="source-code">#include "GameObjectSharer.h"</p>
			<p class="source-code">using namespace std;</p>
			<p class="source-code">class LevelManager : public GameObjectSharer {</p>
			<p class="source-code">private:</p>
			<p class="source-code">    vector&lt;GameObject&gt; m_GameObjects;</p>
			<p class="source-code">    const std::string WORLD_FOLDER = "world";</p>
			<p class="source-code">    const std::string SLASH = "/";</p>
			<p class="source-code">    void runStartPhase();</p>
			<p class="source-code">    void activateAllGameObjects();</p>
			<p class="source-code">public:</p>
			<p class="source-code">    vector&lt;GameObject&gt;&amp; getGameObjects();</p>
			<p class="source-code">    void loadGameObjectsForPlayMode(string screenToLoad);</p>
			<p class="source-code">    /****************************************************</p>
			<p class="source-code">    *****************************************************</p>
			<p class="source-code">    From GameObjectSharer interface</p>
			<p class="source-code">    *****************************************************</p>
			<p class="source-code">    *****************************************************/</p>
			<p class="source-code">    vector&lt;GameObject&gt;&amp; GameObjectSharer::getGameObjectsWithGOS()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        return m_GameObjects;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    GameObject&amp; GameObjectSharer::findFirstObjectWithTag(</p>
			<p class="source-code">         string tag)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        auto it = m_GameObjects.begin();</p>
			<p class="source-code">        auto end = m_GameObjects.end();</p>
			<p class="source-code">        for (it;</p>
			<p class="source-code">            it != end;</p>
			<p class="source-code">            ++it)</p>
			<p class="source-code">        {</p>
			<p class="source-code">            if ((*it).getTag() == tag)</p>
			<p class="source-code">            {</p>
			<p class="source-code">                return (*it);</p>
			<p class="source-code">            }</p>
			<p class="source-code">        }</p>
			<p class="source-code">        </p>
			<p class="source-code">#ifdef debuggingErrors        </p>
			<p class="source-code">    cout &lt;&lt; </p>
			<p class="source-code">        "LevelManager.h findFirstGameObjectWithTag() " </p>
			<p class="source-code">        &lt;&lt; "- TAG NOT FOUND ERROR!" </p>
			<p class="source-code">        &lt;&lt; endl;</p>
			<p class="source-code">#endif    </p>
			<p class="source-code">        return m_GameObjects[0];</p>
			<p class="source-code">    }</p>
			<p class="source-code">};</p>
			<p>This class provides two different ways to get the <strong class="source-inline">vector</strong> full of the game objects. One way is via a simple call to <strong class="source-inline">getGameObjects</strong>, but another is via the <strong class="source-inline">getGameObjectsWithGOS</strong> function. The latter is the implementation of a pure virtual function from the <strong class="source-inline">GameObjectSharer</strong> class and will be a way to pass access to each and every game object so that is has access to all the other game objects. You may recall from <a href="B14278_20_Final_AG_ePub.xhtml#_idTextAnchor414"><em class="italic">Chapter 20</em></a>, <em class="italic">Game Objects and Components</em>, that a <strong class="source-inline">GameObjectSharer</strong> instance is passed in during the <strong class="source-inline">start</strong> function call of the <strong class="source-inline">GameObject</strong> class. It was in this function that, among other things, the invaders could get access to the location of the player.</p>
			<p>There are also two private functions: <strong class="source-inline">runStartPhase</strong>, which loops through all the <strong class="source-inline">GameObject</strong> instances calling start, and <strong class="source-inline">activateAllGameObjects</strong>, which loops through and sets all the <strong class="source-inline">GameObject</strong> instances to the active status.</p>
			<p>Also, part of the <strong class="source-inline">LevelManager</strong> class is the <strong class="source-inline">loadGameObjectsForPlayMode</strong> function, which will trigger the entire game object creation process that the rest of this chapter has described.</p>
			<p>The final function in the <strong class="source-inline">LevelManger.h</strong> file is the implementation of the other <strong class="source-inline">GameObjectSharer</strong> pure virtual function, <strong class="source-inline">findFirstObjectWithTag</strong>. This allows any class with a <strong class="source-inline">GameObjectSharer</strong> instance to track down a specific game object using its tag. The code loops through all the <strong class="source-inline">GameObject</strong> instances in the <strong class="source-inline">vector</strong> and returns the first match. Note, that if no match is found, a null pointer will be returned and crash the game. We use an <strong class="source-inline">#ifdef</strong> statement to output some text to the console to tell us what caused the crash so that we won't be scratching our heads for hours should we accidentally search for a tag that doesn't exist.</p>
			<p>We can now code the implementations of the functions. </p>
			<p>Create a new source file in the <strong class="source-inline">Source Files/Engine</strong> filter called <strong class="source-inline">LevelManager.cpp</strong> and add the following code:</p>
			<p class="source-code">#include "LevelManager.h"</p>
			<p class="source-code">#include "PlayModeObjectLoader.h"</p>
			<p class="source-code">#include &lt;iostream&gt;</p>
			<p class="source-code">void LevelManager::</p>
			<p class="source-code">    loadGameObjectsForPlayMode(string screenToLoad)</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_GameObjects.clear();</p>
			<p class="source-code">    string levelToLoad = "" </p>
			<p class="source-code">        + WORLD_FOLDER + SLASH + screenToLoad;</p>
			<p class="source-code">    PlayModeObjectLoader pmol;</p>
			<p class="source-code">    pmol.loadGameObjectsForPlayMode(</p>
			<p class="source-code">        levelToLoad, m_GameObjects);</p>
			<p class="source-code">    runStartPhase();</p>
			<p class="source-code">}</p>
			<p class="source-code">vector&lt;GameObject&gt;&amp; LevelManager::getGameObjects()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_GameObjects;</p>
			<p class="source-code">}</p>
			<p class="source-code">void LevelManager::runStartPhase()</p>
			<p class="source-code">{</p>
			<p class="source-code">    auto it = m_GameObjects.begin();</p>
			<p class="source-code">    auto end = m_GameObjects.end();</p>
			<p class="source-code">    for (it;</p>
			<p class="source-code">        it != end;</p>
			<p class="source-code">        ++it)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        (*it).start(this);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    activateAllGameObjects();</p>
			<p class="source-code">}</p>
			<p class="source-code">void LevelManager::activateAllGameObjects()</p>
			<p class="source-code">{</p>
			<p class="source-code">    auto it = m_GameObjects.begin();</p>
			<p class="source-code">    auto end = m_GameObjects.end();</p>
			<p class="source-code">    for (it;</p>
			<p class="source-code">        it != end;</p>
			<p class="source-code">        ++it)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        (*it).setActive();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">loadLevelForPlayMode</strong> function clears the <strong class="source-inline">vector</strong>, instantiates a <strong class="source-inline">PlayModeObjectLoader</strong> instance that does all the file reading, and packs the <strong class="source-inline">GameObject</strong> instances in the <strong class="source-inline">vector</strong>. Finally, the <strong class="source-inline">runStartPhase</strong> function is called. In the <strong class="source-inline">runStartPhase</strong> function, all the <strong class="source-inline">GameObject</strong> instances are passed a <strong class="source-inline">GameObjectSharer</strong> (<strong class="source-inline">this</strong>) and given the opportunity to set themselves up, ready to be played. Remember that, inside the <strong class="source-inline">GameObject</strong> class in the <strong class="source-inline">start</strong> function, each of the derived <strong class="source-inline">Component</strong> instances is given access to <strong class="source-inline">GameObjectSharer</strong>. Refer to <a href="B14278_20_Final_AG_ePub.xhtml#_idTextAnchor414"><em class="italic">Chapter 20</em></a>, <em class="italic">Game Objects and Components</em>, to see what we did with this when we coded the <strong class="source-inline">Component</strong> classes.</p>
			<p>The <strong class="source-inline">runStartPhase</strong> function concludes by calling <strong class="source-inline">activateAllGameObjects</strong>, which loops through the <strong class="source-inline">vector</strong>, calling <strong class="source-inline">setActive</strong> on every <strong class="source-inline">GameObject</strong> instance.</p>
			<p>The <strong class="source-inline">getGameObjects</strong> function passes a reference to the <strong class="source-inline">vector</strong> of <strong class="source-inline">GameObject</strong> instances.</p>
			<p>Now that we have coded the <strong class="source-inline">LevelManager</strong> class, we can update the <strong class="source-inline">ScreenManager</strong> and the <strong class="source-inline">ScreenManagerRemoteControl</strong> classes that it implements.</p>
			<h1 id="_idParaDest-428"><a id="_idTextAnchor442"/>Updating the ScreenManager and ScreenManagerRemoteControl classes</h1>
			<p>Open the <strong class="source-inline">ScreenManagerRemoteControl.h</strong> file and uncomment everything so that the code is the same as the following. I have highlighted the lines that have been uncommented:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#include &lt;string&gt;</p>
			<p class="source-code">#include &lt;vector&gt;</p>
			<p class="source-code"><strong class="bold">#include "GameObject.h"</strong></p>
			<p class="source-code"><strong class="bold">#include "GameObjectSharer.h"</strong></p>
			<p class="source-code">using namespace std;</p>
			<p class="source-code">class ScreenManagerRemoteControl</p>
			<p class="source-code">{</p>
			<p class="source-code">public:</p>
			<p class="source-code">    virtual void SwitchScreens(string screenToSwitchTo) = 0;</p>
			<p class="source-code">    virtual void loadLevelInPlayMode(string screenToLoad) = 0;</p>
			<p class="source-code"><strong class="bold">    virtual vector&lt;GameObject&gt;&amp; getGameObjects() = 0;</strong></p>
			<p class="source-code"><strong class="bold">    virtual GameObjectSharer&amp; shareGameObjectSharer() = 0;</strong></p>
			<p class="source-code">};</p>
			<p>Next, open <strong class="source-inline">ScreenManager.h</strong>, which implements this interface and uncomments all the commented-out code. The code in question is abbreviated and highlighted as follows:</p>
			<p class="source-code">...</p>
			<p class="source-code">#include "SelectScreen.h"</p>
			<p class="source-code"><strong class="bold">//#include "LevelManager.h"</strong></p>
			<p class="source-code">#include "BitmapStore.h"</p>
			<p class="source-code">...</p>
			<p class="source-code">...</p>
			<p class="source-code">private:</p>
			<p class="source-code">    map &lt;string, unique_ptr&lt;Screen&gt;&gt; m_Screens;</p>
			<p class="source-code"><strong class="bold">    //LevelManager m_LevelManager;</strong></p>
			<p class="source-code">protected:</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    ...</p>
			<p class="source-code">/****************************************************</p>
			<p class="source-code">*****************************************************</p>
			<p class="source-code">From ScreenManagerRemoteControl interface</p>
			<p class="source-code">*****************************************************</p>
			<p class="source-code">*****************************************************/</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    ...</p>
			<p class="source-code"><strong class="bold">    //vector&lt;GameObject&gt;&amp; </strong></p>
			<p class="source-code"><strong class="bold">        //ScreenManagerRemoteControl::getGameObjects()</strong></p>
			<p class="source-code"><strong class="bold">    //{</strong></p>
			<p class="source-code"><strong class="bold">        //return m_LevelManager.getGameObjects();</strong></p>
			<p class="source-code"><strong class="bold">    //}</strong></p>
			<p class="source-code"><strong class="bold">    //GameObjectSharer&amp; shareGameObjectSharer()</strong></p>
			<p class="source-code"><strong class="bold">    //{</strong></p>
			<p class="source-code"><strong class="bold">        //return m_LevelManager;</strong></p>
			<p class="source-code"><strong class="bold">    //}</strong></p>
			<p class="source-code">    ...</p>
			<p class="source-code">    ...</p>
			<p>Be sure to uncomment the include directive, the <strong class="source-inline">m_LevelManager</strong> instance, as well as the two functions. </p>
			<p>The <strong class="source-inline">ScreenManager</strong> and <strong class="source-inline">ScreenManagerRemoteControl</strong> classes are now fully functional and the <strong class="source-inline">getGameObjects</strong> and <strong class="source-inline">shareGameObjectSharer</strong> functions are usable by any class with a reference to the <strong class="source-inline">ScreenManager</strong> class.</p>
			<h1 id="_idParaDest-429"><a id="_idTextAnchor443"/>Where are we now?</h1>
			<p>At this point, all the errors in our <strong class="source-inline">GameObject</strong> class, as well as all component-related classes, are gone. We are making good progress.</p>
			<p>Furthermore, we can revisit the <strong class="source-inline">ScreenManager.h</strong> file and uncomment all the commented-out code.</p>
			<p>Open <strong class="source-inline">ScreenManager.h</strong> and uncomment the <strong class="source-inline">#include</strong> directive, as follows:</p>
			<p class="source-code">//#include "LevelManager.h"</p>
			<p>Change it to this:</p>
			<p class="source-code">#include "LevelManager.h"</p>
			<p>Do the same for the functions from the <strong class="source-inline">ScreenManagerRemoteControl</strong> interface that are implemented in <strong class="source-inline">ScreenManager.h</strong>. They look like the following:</p>
			<p class="source-code">void ScreenManagerRemoteControl::</p>
			<p class="source-code">        loadLevelInPlayMode(string screenToLoad)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        //m_LevelManager.getGameObjects().clear();</p>
			<p class="source-code">        //m_LevelManager.</p>
			<p class="source-code">            //loadGameObjectsForPlayMode(screenToLoad);</p>
			<p class="source-code">        SwitchScreens("Game");</p>
			<p class="source-code">    }</p>
			<p class="source-code">//vector&lt;GameObject&gt;&amp; </p>
			<p class="source-code">    //ScreenManagerRemoteControl::getGameObjects()</p>
			<p class="source-code">//{</p>
			<p class="source-code">    //return m_LevelManager.getGameObjects();</p>
			<p class="source-code">//}</p>
			<p>Change them as follows:</p>
			<p class="source-code">void ScreenManagerRemoteControl::</p>
			<p class="source-code">    loadLevelInPlayMode(string screenToLoad)</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_LevelManager.getGameObjects().clear();</p>
			<p class="source-code">    m_LevelManager.</p>
			<p class="source-code">        loadGameObjectsForPlayMode(screenToLoad);</p>
			<p class="source-code">    SwitchScreens("Game");</p>
			<p class="source-code">}</p>
			<p class="source-code">vector&lt;GameObject&gt;&amp; </p>
			<p class="source-code">    ScreenManagerRemoteControl::getGameObjects()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_LevelManager.getGameObjects();</p>
			<p class="source-code">}</p>
			<p>We aren't quite ready to run the game, however, because there are still some missing classes that are used in the code, such as <strong class="source-inline">BulletSpawner</strong> in the <strong class="source-inline">InvaderUpdateComponent</strong> class.</p>
			<h1 id="_idParaDest-430"><a id="_idTextAnchor444"/>Summary</h1>
			<p>In this chapter, we have put in place a way to describe a level in a game and a system to interpret the description and build usable <strong class="source-inline">GameObject</strong> instances. The Factory pattern is used in many types of programming, not just game development. The implementation we have used is the simplest possible implementation and I encourage you to put the Factory pattern on your list of patterns to research and develop further. The implementation we have used should serve you well if you wish to build some deep and interesting games, however.</p>
			<p>In the next chapter, we will finally make the game come to life by adding collision detection, bullet spawning, and the logic of the game itself.</p>
		</div>
	</body></html>