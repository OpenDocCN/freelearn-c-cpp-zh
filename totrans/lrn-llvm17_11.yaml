- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: The TableGen Language
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TableGen语言
- en: Large parts of backends in LLVM are written in the TableGen language, a special
    language used to generate fragments of C++ source code to avoid implementing code
    similar for each backend and to shorten the amount of source code. Having knowledge
    of TableGen is therefore important.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM后端的大部分内容是用TableGen语言编写的，这是一种用于生成C++源代码片段的特殊语言，以避免为每个后端实现相似代码并缩短源代码量。因此，了解TableGen是很重要的。
- en: 'In this chapter, you will learn the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下内容：
- en: In *Understanding the TableGen language*, you will learn about the main idea
    behind TableGen
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*理解TableGen语言*中，你将了解TableGen背后的主要思想
- en: In *Experimenting with the TableGen language*, you will define your own TableGen
    classes and records, and learn the syntax of the TableGen language
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*实验TableGen语言*中，你将定义自己的TableGen类和记录，并学习TableGen语言的语法
- en: In *Generating C++ code from a TableGen file*, you will develop your own TableGen
    backend
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*从TableGen文件生成C++代码*中，你将开发自己的TableGen后端
- en: Drawbacks of TableGen
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TableGen的缺点
- en: By the end of the chapter, you will be able to use existing TableGen classes
    to define your own records. You will also acquire knowledge of how to create TableGen
    classes and records from scratch, and how to develop a TableGen backend to emit
    source code.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够使用现有的TableGen类来定义你自己的记录。你还将获得如何从头创建TableGen类和记录的知识，以及如何开发一个TableGen后端以生成源代码。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find the source code used in this chapter on GitHub: [https://github.com/PacktPublishing/Learn-LLVM-17/tree/main/Chapter08](https://github.com/PacktPublishing/Learn-LLVM-17/tree/main/Chapter08).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到本章使用的源代码：[https://github.com/PacktPublishing/Learn-LLVM-17/tree/main/Chapter08](https://github.com/PacktPublishing/Learn-LLVM-17/tree/main/Chapter08)。
- en: Understanding the TableGen language
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解TableGen语言
- en: LLVM comes with its own **domain-specific language** (**DSL**) called **TableGen**.
    It is used to generate C++ code for a wide range of use cases, thus reducing the
    amount of code a developer has to produce. The TableGen language is not a full-fledged
    programming language. It is only used to define records, which is a fancy word
    for a collection of names and values. To understand why such a restricted language
    is useful, let’s examine two examples.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM自带一种名为**TableGen**的**领域特定语言**（**DSL**）。它被用于生成适用于广泛用例的C++代码，从而减少了开发者需要编写的代码量。TableGen语言不是一个完整的编程语言。它仅用于定义记录，这是一个指代名称和值集合的术语。为了理解为什么这种受限的语言是有用的，让我们考察两个例子。
- en: 'Typical data you need to define one machine instruction of a CPU is:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 定义CPU的一个机器指令通常需要以下典型数据：
- en: The mnemonic of the instruction
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指令的助记符
- en: The bit pattern
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位模式
- en: The number and types of operands
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作数数量和类型
- en: Possible restrictions or side effects
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能的限制或副作用
- en: It is easy to see that this data can be represented as a record. For example,
    a field named `asmstring` could hold the value of the mnemonic; say, `"add"`.
    Also, a field named `opcode` could hold the binary representation of the instruction.
    Together, the record would describe an additional instruction. Each LLVM backend
    describes the instruction set in this way.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易看出这些数据可以表示为一个记录。例如，一个名为`asmstring`的字段可以保存助记符的值；比如说，`"add"`。还有一个名为`opcode`的字段可以保存指令的二进制表示。这些字段共同描述了一个额外的指令。每个LLVM后端都以这种方式描述指令集。
- en: 'Records are such a general concept that you can describe a wide variety of
    data with them. Another example is the definition of command-line options. A command-line
    option:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 记录是一个如此通用的概念，以至于你可以用它们描述各种各样的数据。另一个例子是命令行选项的定义。一个命令行选项：
- en: Has a name
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个名称
- en: May have an optional argument
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能有一个可选参数
- en: Has a help text
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有帮助文本
- en: May belong to a group of options
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能属于一组选项
- en: Again, this data can be easily seen as a record. Clang uses this approach for
    the command-line options of the Clang driver.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这些数据可以很容易地被视为一个记录。Clang使用这种方法为Clang驱动器的命令行选项。
- en: The TableGen language
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: TableGen语言
- en: In LLVM, the TableGen language is used for a variety of tasks. Large parts of
    a backend are written in the TableGen language; for example, the definition of
    a register file, all instructions with mnemonic and binary encoding, calling conventions,
    patterns for instruction selection, and scheduling models for instruction scheduling.
    Other uses of LLVM are the definition of intrinsic functions, the definition of
    attributes, and the definition of command-line options.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在LLVM中，TableGen语言被用于各种任务。后端的大部分内容是用TableGen语言编写的；例如，寄存器文件的定义，所有带有助记符和二进制编码的指令，调用约定，指令选择的模式，以及指令调度的调度模型。LLVM的其他用途包括内建函数的定义，属性的定义，以及命令行选项的定义。
- en: You’ll find the *Programmer’s Reference* at [https://llvm.org/docs/TableGen/ProgRef.html](https://llvm.org/docs/TableGen/ProgRef.html)
    and the *Backend Developer’s Guide* at [https://llvm.org/docs/TableGen/BackGuide.html](https://llvm.org/docs/TableGen/BackGuide.html).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://llvm.org/docs/TableGen/ProgRef.html](https://llvm.org/docs/TableGen/ProgRef.html)找到《程序员参考》，在[https://llvm.org/docs/TableGen/BackGuide.html](https://llvm.org/docs/TableGen/BackGuide.html)找到《后端开发者指南》。
- en: To achieve this flexibility, the parsing and the semantics of the TableGen language
    are implemented in a library. To generate C++ code from the records, you need
    to create a tool that takes the parsed records and generates C++ code from it.
    In LLVM, that tool is called `llvm-tblgen`, and in Clang, it is called `clang-tblgen`.
    Those tools contain the code generators required by the project. But they can
    also be used to learn more about the TableGen language, which is what we’ll do
    in the next section.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这种灵活性，TableGen语言的解析和语义是在一个库中实现的。要从记录生成C++代码，你需要创建一个工具，该工具接受解析后的记录并从中生成C++代码。在LLVM中，这个工具被称为`llvm-tblgen`，在Clang中被称为`clang-tblgen`。这些工具包含项目所需的代码生成器。但它们也可以用来学习更多关于TableGen语言的知识，这就是我们在下一节将要做的。
- en: Experimenting with the TableGen language
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试使用TableGen语言
- en: Very often, beginners feel overwhelmed by the TableGen language. But as soon
    as you start experimenting with the language, it becomes much easier.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 初学者往往觉得TableGen语言令人不知所措。但一旦你开始尝试使用这种语言，它就会变得容易得多。
- en: Defining records and classes
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义记录和类
- en: 'Let’s define a simple record for an instruction:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个简单的指令记录：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `def` keyword signals that you define a record. It is followed by the name
    of the record. The record body is surrounded by curly braces, and the body consists
    of field definitions, similar to a structure in C++.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`def` 关键字表示定义一个记录。其后跟随记录的名称。记录体被大括号包围，体由字段定义组成，类似于C++中的结构体。'
- en: 'You can use the `llvm-tblgen` tool to see the generated records. Save the preceding
    source code in an `inst.td` file and run the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`llvm-tblgen`工具查看生成的记录。将前面的源代码保存为`inst.td`文件，然后运行以下命令：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is not yet exciting; it only shows the defined record was parsed correctly.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这还不是特别令人兴奋；它只表明定义的记录被正确解析。
- en: 'Defining instructions using single records is not very comfortable. A modern
    CPU has hundreds of instructions, and with this amount of records, it is very
    easy to introduce typing errors in the field names. And if you decide to rename
    a field or add a new field, then the number of records to change becomes a challenge.
    Therefore, a blueprint is needed. In C++, classes have a similar purpose, and
    in TableGen, it is also called a `Inst` class and two records based on that class:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单个记录定义指令并不太方便。现代CPU有数百条指令，这么多记录，很容易在字段名称中引入打字错误。如果你决定重命名一个字段或添加一个新字段，那么需要更改的记录数量就成为一个挑战。因此，需要一个蓝图。在C++中，类有类似的作用，在TableGen中，它也被称为`Inst`类和基于该类的两个记录：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The syntax for classes is similar to that of records. The `class` keyword signals
    that a class is defined, followed by the name of the class. A class can have a
    parameter list. Here, the `Inst` class has two parameters, `mnemonic` and `opcode`,
    which are used to initialize the records’ fields. The values for those fields
    are given when the class is instantiated. The `ADD` and `SUB` records show two
    instantiations of the class. Again, let’s use `llvm-tblgen` to look at the records:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 类的语法与记录类似。`class`关键字表示定义了一个类，其后跟随类的名称。类可以有一个参数列表。在这里，`Inst`类有两个参数，`mnemonic`和`opcode`，它们用于初始化记录的字段。这些字段的值在类实例化时给出。`ADD`和`SUB`记录展示了类的两个实例。再次使用`llvm-tblgen`来查看记录：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, you have one class definition and two records. The name of the class used
    to define the records is shown as a comment. Please note that the arguments of
    the class have the default value `?`, which indicates `int` is uninitialized.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你有一个类定义和两个记录。用于定义记录的类的名称显示为注释。请注意，类的参数默认值为 `?`，表示 `int` 未初始化。
- en: Tip for debugging
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 调试技巧
- en: To get a more detailed dump of the records, you can use the `–-print-detailed-records`
    option. The output includes the line numbers of record and class definitions,
    and where record fields are initialized. They can be very helpful if you try to
    track down why a record field was assigned a certain value.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取记录的更详细输出，可以使用 `–-print-detailed-records` 选项。输出包括记录和类定义的行号，以及记录字段初始化的位置。如果你试图追踪为什么记录字段被赋予某个特定的值，它们可能非常有帮助。
- en: 'In general, the `ADD` and `SUB` instructions have a lot in common, but there
    is also a difference: addition is a commutative operation but subtraction is not.
    Let’s capture that fact in the record, too. A small challenge is that TableGen
    only supports a limited set of data types. You already used `string` and `int`
    in the examples. The other available data types are `bit`, `bits<n>`, `list<type>`,
    and `dag`. The `bit` type represents a single bit; that is, `0` or `1`. If you
    need a fixed number of bits, then you use the `bits<n>` type. For example, `bits<5>`
    is an integer type 5 bits wide. To define a list based on another type, you use
    the `list<type>` type. For example, `list<int>` is a list of integers, and `list<Inst>`
    is a list of records of the `Inst` class from the example. The `dag` type represents
    **directed acyclic graph** (**DAG**) nodes. This type is useful for defining patterns
    and operations and is used extensively in LLVM backends.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`ADD` 和 `SUB` 指令有很多共同之处，但也有区别：加法是交换律操作，而减法不是。我们也要在记录中捕捉这一事实。一个小挑战是 TableGen
    只支持有限的数据类型。你已经在示例中使用了 `string` 和 `int`。其他可用的数据类型有 `bit`、`bits<n>`、`list<type>`
    和 `dag`。`bit` 类型表示单个位；即 `0` 或 `1`。如果你需要一个固定数量的位，那么你将使用 `bits<n>` 类型。例如，`bits<5>`
    是一个 5 位宽的整型。要基于其他类型定义列表，你将使用 `list<type>` 类型。例如，`list<int>` 是一个整数列表，而 `list<Inst>`
    是从示例中 `Inst` 类的记录列表。`dag` 类型表示 **有向无环图**（DAG）节点。这种类型对于定义模式和操作非常有用，并且在 LLVM 后端中被广泛使用。
- en: 'To represent a flag, a single bit is sufficient, so you can use one to mark
    an instruction as commutable. The majority of instructions are not commutable,
    so you can take advantage of default values:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示一个标志，一个单独的位就足够了，所以你可以使用一个来标记指令为可交换的。大多数指令都不是可交换的，所以你可以利用默认值：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You should run `llvm-tblgen` to verify that the records are defined as expected.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该运行 `llvm-tblgen` 来验证记录是否按预期定义。
- en: 'There is no requirement for a class to have parameters. It is also possible
    to assign values later. For example, you can define that all instructions are
    not commutable:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 类不需要有参数。也可以稍后分配值。例如，你可以定义所有指令都不是可交换的：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Using a `let` statement, you can overwrite that value:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `let` 语句，你可以覆盖该值：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Alternatively, you can open a record body to overwrite the value:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以打开记录体来覆盖该值：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Again, please use `llvm-tblgen` to verify that the `Commutable` flag is set
    to `1` in both cases.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，请使用 `llvm-tblgen` 验证在两种情况下 `Commutable` 标志是否设置为 `1`。
- en: 'Classes and records can be inherited from multiple classes, and it is always
    possible to add new fields or overwrite the value of existing fields. You can
    use inheritance to introduce a new `CommutableInst` class:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 类和记录可以从多个类继承，并且总是可以添加新字段或覆盖现有字段的值。你可以使用继承来引入一个新的 `CommutableInst` 类：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The resulting records are always the same, but the language allows you to define
    records in different ways. Please note that, in the latter example, the `Commutable`
    flag may be superfluous: the code generator can query a record for the classes
    it is based on, and if that list contains the `CommutableInst` class, then it
    can set the flag internally.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 结果记录始终相同，但语言允许你以不同的方式定义记录。请注意，在后一个示例中，`Commutable` 标志可能是多余的：代码生成器可以查询记录所基于的类，如果该列表包含
    `CommutableInst` 类，则它可以内部设置该标志。
- en: Creating multiple records at once with multiclasses
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用多类一次创建多个记录
- en: Another often-used statement is `multiclass`. A multiclass allows you to define
    multiple records at once. Let’s expand the example to show why this can be useful.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个经常使用的语句是 `multiclass`。多类允许你一次定义多个记录。让我们扩展示例来展示这为什么有用。
- en: The definition of an `add` instruction is very simplistic. In reality, a CPU
    often has several `add` instructions. A common variant is that one instruction
    has two register operands while another instruction has one register operand and
    an immediate operand, which is a small number. Assume that for the instruction
    having an immediate operand, the designer of the instruction set decided to mark
    them with `i` as a suffix. So, we end up with the `add` and `addi` instructions.
    Further, assume that the opcodes differ by `1`. Many arithmetic and logical instructions
    follow this scheme; therefore, you want the definition to be as compact as possible.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`add`指令的定义非常简单。在现实中，CPU通常有几个`add`指令。一个常见的变体是，一个指令有两个寄存器操作数，而另一个指令有一个寄存器操作数和一个立即数操作数，这是一个小的数字。假设对于具有立即数操作的指令，指令集的设计者决定用`i`作为后缀来标记它们。因此，我们最终得到`add`和`addi`指令。进一步假设操作码相差`1`。许多算术和逻辑指令遵循此方案；因此，您希望定义尽可能紧凑。'
- en: 'The first challenge is that you need to manipulate values. There is a limited
    number of operators that you can use to modify a value. For example, to produce
    the sum of `1` and the value of the field opcode, you write:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个挑战是您需要操作值。您可以使用有限数量的运算符来修改一个值。例如，要生成`1`和字段opcode值的和，您可以这样写：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Such an expression is best used as an argument for a class. Testing a field
    value and then changing it based on the found value is generally not possible
    because it requires dynamic statements that are not available. Always remember
    that all calculations are done while the records are constructed!
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的表达式最好用作类的参数。测试字段值并根据找到的值进行更改通常是不可能的，因为这需要动态语句，而这些语句是不可用的。始终记住，所有计算都是在记录构建时完成的！
- en: 'In a similar way, strings can be concatenated:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，字符串可以连接：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Because all operators begin with an exclamation mark (`!`), they are also called
    **bang operators**. You find a full list of bang operators in the *Programmer’s*
    *Reference*: [https://llvm.org/docs/TableGen/ProgRef.html#appendix-a-bang-operators](https://llvm.org/docs/TableGen/ProgRef.html#appendix-a-bang-operators).'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因为所有运算符都以感叹号（`!`）开头，它们也被称为**感叹号运算符**。您可以在*程序员参考*中找到完整的感叹号运算符列表：[https://llvm.org/docs/TableGen/ProgRef.html#appendix-a-bang-operators](https://llvm.org/docs/TableGen/ProgRef.html#appendix-a-bang-operators)。
- en: 'Now, you can define a multiclass. The `Inst` class serves again as the base:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以定义一个多类。`Inst`类再次作为基类：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The definition of a multiclass is a bit more involved, so let’s do it in steps:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 多类的定义稍微复杂一些，所以让我们分步骤来做：
- en: 'The definition of a multiclass uses a similar syntax to classes. The new multiclass
    is named `InstWithImm` and has two parameters, `mnemonic` and `opcode`:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 多类定义使用的语法与类类似。新的多类名为`InstWithImm`，有两个参数，`mnemonic`和`opcode`：
- en: '[PRE12]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'First, you define an instruction with two register operands. As in a normal
    record definition, you use the `def` keyword to define the record, and you use
    the `Inst` class to create the record content. You also need to define an empty
    name. We will explain later why this is necessary:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您需要使用两个寄存器操作数定义一个指令。就像在正常的记录定义中一样，您使用`def`关键字来定义记录，并使用`Inst`类来创建记录内容。您还需要定义一个空名称。我们稍后会解释为什么这是必要的：
- en: '[PRE13]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, you define an instruction with the immediate operand. You derive the
    values for the mnemonic and the opcode from the parameters of the multiclass,
    using bang operators. The record is named `I`:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您使用立即数操作数定义一个指令。您使用感叹号运算符从多类的参数中推导出助记符和操作码的值。记录命名为`I`：
- en: '[PRE14]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'That is all; the class body can be closed, like so:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 那就是全部了；类体可以像这样关闭：
- en: '[PRE15]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To instantiate the records, you must use the `defm` keyword:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要实例化记录，您必须使用`defm`关键字：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'These statements result in the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这些语句的结果如下：
- en: The `Inst<"add", 0xA0>` record is instantiated. The name of the record is the
    concatenation of the name following the `defm` keyword and of the name following
    `def` inside the multiclass statement, which results in the name `ADD`.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Inst<"add", 0xA0>`记录被实例化。记录的名称是`defm`关键字后面的名称和多层语句中`def`后面的名称的连接，结果为名称`ADD`。'
- en: The `Inst<"addi", 0xA1>` record is instantiated and, following the same scheme,
    is given the name `ADDI`.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Inst<"addi", 0xA1>`记录被实例化，并按照相同的方案，被赋予名称`ADDI`。'
- en: 'Let’s verify this claim with `llvm-tblgen`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用`llvm-tblgen`验证这个说法：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Using a multiclass, it is very easy to generate multiple records at once. This
    feature is used very often!
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多类，一次生成多个记录非常容易。这个特性被非常频繁地使用！
- en: 'A record does not need to have a name. Anonymous records are perfectly fine.
    Omitting the name is all you need to do to define an anonymous record. The name
    of a record generated by a multiclass is made up of two names, and both names
    must be given to create a named record. If you omit the name after `defm`, then
    only anonymous records are created. Similarly, if the `def` inside the multiclass
    is not followed by a name, an anonymous record is created. This is the reason
    why the first definition in the multiclass example used the empty name `""`: without
    it, the record would be anonymous.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Simulating function calls
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In some cases, using a multiclass like in the previous example can lead to
    repetitions. Assume that the CPU also supports memory operands, in a way similar
    to immediate operands. You can support this by adding a new record definition
    to the multiclass:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is perfectly fine. But now, imagine you do not have 3 but 16 records to
    define, and you need to do this multiple times. A typical scenario where such
    a situation can arise is when the CPU supports many vector types, and the vector
    instructions vary slightly based on the used type.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Please note that all three lines with the `def` statement have the same structure.
    The variation is only in the suffix of the name and of the mnemonic, and the delta
    value is added to the opcode. In C, you could put the data into an array and implement
    a function that returns the data based on an index value. Then, you could create
    a loop over the data instead of manually repeating statements.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'Amazingly, you can do something similar in the TableGen language! Here is how
    to transform the example:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'To store the data, you define a class with all required fields. The class is
    called `InstDesc`, because it describes some properties of an instruction:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, you can define records for each operand type. Note that it exactly captures
    the differences observed in the data:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Imagine you have a loop enumerating the numbers `0`, `1`, and `2`, and you
    want to select one of the previously defined records based on the index. How can
    you do this? The solution is to create a `getDesc` class that takes the index
    as a parameter. It has a single field, `ret`, that you can interpret as a return
    value. To assign the correct value to this field, the `!cond` operator is used:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This operator works similarly to a `switch`/`case` statement in C.
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, you are ready to define the multiclass. The TableGen language has a `loop`
    statement, and it also allows us to define variables. But remember that there
    is no dynamic execution! As a consequence, the loop range is statically defined,
    and you can assign a value to a variable, but you cannot change that value later.
    However, this is enough to retrieve the data. Please note how the use of the `getDesc`
    class resembles a function call. But there is no function call! Instead, an anonymous
    record is created, and the values are taken from that record. Lastly, the past
    operator (`#`) performs a string concatenation, similar to the `!strconcat` operator
    used earlier:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你准备好定义多类。TableGen语言有一个`loop`语句，它还允许我们定义变量。但请记住，没有动态执行！因此，循环范围是静态定义的，你可以给变量赋值，但之后不能改变这个值。然而，这足以检索数据。请注意，使用`getDesc`类的方式类似于函数调用。但没有函数调用！相反，创建了一个匿名记录，值是从该记录中取出的。最后，过去操作符（`#`）执行字符串连接，类似于之前使用的`!strconcat`操作符：
- en: '[PRE22]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, you use the multiclass as before to define records:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你使用多类定义记录，就像之前一样：
- en: '[PRE23]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Please run `llvm-tblgen` and examine the records. Besides the various `ADD`
    records, you will also see a couple of anonymous records generated by the use
    of the `getDesc` class.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 请运行`llvm-tblgen`并检查记录。除了各种`ADD`记录外，你还会看到一些由`getDesc`类使用生成的匿名记录。
- en: This technique is used in the instruction definition of several LLVM backends.
    With the knowledge you have acquired, you should have no problem understanding
    those files.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术被用于几个LLVM后端的指令定义中。凭借你获得的知识，你应该没有问题理解这些文件。
- en: 'The `foreach` statement used the syntax `0-2` to denote the bounds of the range.
    This is called a `0...3`), which is useful if the numbers are negative. Lastly,
    you are not restricted to numerical ranges; you can also loop over a list of elements,
    which allows you to use strings or previously defined records. For example, you
    may like the use of the `foreach` statement, but you think that using the `getDesc`
    class is too complicated. In this case, looping over the `InstDesc` records is
    the solution:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`foreach`语句使用`0-2`语法来表示范围的界限。这被称为`0...3`，如果数字是负数时很有用。最后，你不仅限于数值范围；你还可以遍历元素列表，这允许你使用字符串或先前定义的记录。例如，你可能喜欢使用`foreach`语句，但认为使用`getDesc`类太复杂。在这种情况下，遍历`InstDesc`记录是解决方案：'
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: So far, you only defined records in the TableGen language, using the most commonly
    used statements. In the next section, you’ll learn how to generate C++ source
    code from records defined in the TableGen language.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你只使用TableGen语言定义了记录，使用了最常用的语句。在下一节中，你将学习如何从TableGen语言中定义的记录生成C++源代码。
- en: Generating C++ code from a TableGen file
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从TableGen文件生成C++代码
- en: In the previous section, you defined records in the TableGen language. To make
    use of those records, you need to write your own TableGen backend that can produce
    C++ source code or do other things using the records as input.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你使用TableGen语言定义了记录。为了使用这些记录，你需要编写自己的TableGen后端，该后端可以生成C++源代码或使用记录作为输入执行其他操作。
- en: In [*Chapter 3*](B19561_03.xhtml#_idTextAnchor055), *Turning the Source File
    into an Abstract Syntax Tree*, the implementation of the `Lexer` class uses a
    database file to define tokens and keywords. Various query functions make use
    of that database file. Besides that, the database file is used to implement a
    keyword filter. The keyword filter is a hash map, implemented using the `llvm::StringMap`
    class. Whenever an identifier is found, the keyword filter is called to find out
    if the identifier is actually a keyword. If you take a closer look at the implementation
    using the `ppprofiler` pass from [*Chapter 6*](B19561_06.xhtml#_idTextAnchor101),
    *Advanced IR Generation*, then you will see that this function is called quite
    often. Therefore, it may be useful to experiment with different implementations
    to make that functionality as fast as possible.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第3章*](B19561_03.xhtml#_idTextAnchor055)，“将源文件转换为抽象语法树”，`Lexer`类的实现使用数据库文件来定义标记和关键字。各种查询函数都利用了那个数据库文件。除此之外，数据库文件还用于实现关键字过滤器。关键字过滤器是一个哈希表，使用`llvm::StringMap`类实现。每当找到一个标识符时，都会调用关键字过滤器来检查该标识符是否实际上是一个关键字。如果你仔细查看[*第6章*](B19561_06.xhtml#_idTextAnchor101)“高级IR生成”中使用的`ppprofiler`传递的实现，你会发现这个函数被调用得相当频繁。因此，尝试不同的实现来使该功能尽可能快可能是有用的。
- en: However, this is not as easy as it seems. For example, you can try to replace
    the lookup in the hash map with a binary search. This requires that the keywords
    in the database file are sorted. Currently, this seems to be the case, but during
    development, a new keyword might be added in the wrong place undetected. The only
    way to make sure that the keywords are in the right order is to add some code
    that checks the order at runtime.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不像看起来那么简单。例如，你可以尝试用二分搜索替换哈希表中的查找。这要求数据库文件中的关键字是有序的。目前这似乎是正确的，但在开发过程中，可能会在不被发现的情况下在错误的位置添加一个新的关键字。确保关键字顺序正确的方法是添加一些在运行时检查顺序的代码。
- en: You can speed up the standard binary search by changing the memory layout. For
    example, instead of sorting the keywords, you can use the Eytzinger layout, which
    enumerates the search tree in breadth-first order. This layout increases the cache
    locality of the data and therefore speeds up the search. Personally speaking,
    maintaining the keywords in breadth-first order manually in the database file
    is not possible.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过改变内存布局来加速标准的二分搜索。例如，你不必对关键字进行排序，可以使用 Eytzinger 布局，该布局按广度优先顺序枚举搜索树。这种布局增加了数据的缓存局部性，因此加快了搜索速度。就个人而言，在数据库文件中手动以广度优先顺序维护关键字是不可能的。
- en: Another popular approach for searching is the generation of minimal perfect
    hash functions. If you insert a new key into a dynamic hash table such as `llvm::StringMap`,
    then that key might be mapped to an already occupied slot. This is called a `gperf`
    GNU tool.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种流行的搜索方法是生成最小完美哈希函数。如果你将一个新的键插入到像 `llvm::StringMap` 这样的动态哈希表中，那么这个键可能会映射到一个已经占用的槽位。这被称为
    `gperf` GNU 工具。
- en: In summary, there is some incentive to be able to generate a lookup function
    from keywords. So, let’s move the database file to TableGen!
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，有一些动力能够从关键字生成查找函数。因此，让我们将数据库文件移动到 TableGen！
- en: Defining data in the TableGen language
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 TableGen 语言中定义数据
- en: The `TokenKinds.def` database file defines three different macros. The `TOK`
    macro is used for tokens that do not have a fixed spelling – for example, for
    integer literals. The `PUNCTUATOR` macro is used for all kinds of punctuation
    marks and includes a preferred spelling. Lastly, the `KEYWORD` macro defines a
    keyword that is made up of a literal and a flag, which is used to indicate at
    which language level this literal is a keyword. For example, the `thread_local`
    keyword was added to C++11.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`TokenKinds.def` 数据库文件定义了三个不同的宏。`TOK` 宏用于没有固定拼写的标记，例如用于整型字面量。`PUNCTUATOR` 宏用于所有类型的标点符号，并包含一个首选拼写。最后，`KEYWORD`
    宏定义了一个由字面量和标志组成的关键字，该标志用于指示这个字面量在哪个语言级别上是关键字。例如，`thread_local` 关键字被添加到 C++11 中。'
- en: 'One way to express this in the TableGen language is to create a `Token` class
    that holds all the data. You can then add subclasses of that class to make the
    usage more comfortable. You also need a `Flag` class for flags defined together
    with a keyword. And last, you need a class to define a keyword filter. These classes
    define the basic data structure and can be potentially reused in other projects.
    Therefore, you create a `Keyword.td` file for it. Here are the steps:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TableGen 语言中表达这一点的办法是创建一个 `Token` 类来保存所有数据。然后你可以添加该类的子类以使使用更加方便。你还需要一个 `Flag`
    类来定义与关键字一起定义的标志。最后，你需要一个类来定义关键字过滤器。这些类定义了基本的数据结构，并且可以在其他项目中潜在地重用。因此，你为它创建了一个 `Keyword.td`
    文件。以下是步骤：
- en: 'A flag is modeled as a name and an associated value. This makes it easy to
    generate an enumeration from this data:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标志被建模为一个名称和一个相关联的值。这使得从这个数据生成枚举变得容易：
- en: '[PRE25]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `Token` class is used as the base class. It just carries a name. Please
    note that this class has no parameters:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Token` 类用作基类。它只携带一个名称。请注意，这个类没有参数：'
- en: '[PRE26]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `Tok` class has the same function as the corresponding `TOK` macro from
    the database file. it represents a token without fixed spellings. It derives from
    the base class, `Token`, and just adds initialization for the name:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Tok` 类与数据库文件中相应的 `TOK` 宏具有相同的功能。它表示一个没有固定拼写的标记。它从基类 `Token` 继承，并仅添加了名称的初始化：'
- en: '[PRE27]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the same way, the `Punctuator` class resembles the `PUNCTUATOR` macro. It
    adds a field for the spelling of the token:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样地，`Punctuator` 类类似于 `PUNCTUATOR` 宏。它为标记的拼写添加了一个字段：
- en: '[PRE28]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'And last, the `Keyword` class needs a list of flags:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`Keyword` 类需要一个标志列表：
- en: '[PRE29]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'With these definitions in place, you can now define a class for the keyword
    filter, called `TokenFilter`. It takes a list of tokens as a parameter:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这些定义到位后，你现在可以定义一个名为`TokenFilter`的关键字过滤器类。它接受一个标记列表作为参数：
- en: '[PRE30]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'With these class definitions, you are certainly able to capture all the data
    from the `TokenKinds.def` database file. The TinyLang language does not utilize
    the flags, since there is only this version of the language. Real-world languages
    such as C and C++ have undergone a couple of revisions, and they usually require
    flags. Therefore, we use keywords from C and C++ as an example. Let’s create a
    `KeywordC.td` file, as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些类定义，你当然能够从`TokenKinds.def`数据库文件中捕获所有数据。TinyLang语言不利用标志，因为只有这个语言版本。现实世界的语言，如C和C++，已经经历了几次修订，并且通常需要标志。因此，我们以C和C++的关键字为例。让我们创建一个`KeywordC.td`文件，如下所示：
- en: 'First, you include the class definitions created earlier:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你包含之前创建的类定义：
- en: '[PRE31]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, you define flags. The value is the binary value of the flag. Note how
    the `!or` operator is used to create a value for the `KEYALL` flag:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你定义标志。标志的值是标志的二进制值。注意`!or`运算符是如何用来为`KEYALL`标志创建值的：
- en: '[PRE32]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'There are tokens without a fixed spelling – for example, a comment:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有些标记没有固定的拼写——例如，一个注释：
- en: '[PRE33]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Operators are defined using the `Punctuator` class, as in this example:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运算符使用`Punctuator`类定义，就像这个例子一样：
- en: '[PRE34]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Keywords need to use different flags:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关键字需要使用不同的标志：
- en: '[PRE35]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'And last, here’s the definition of the keyword filter:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，这是关键字过滤器的定义：
- en: '[PRE36]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Of course, this file does not include all tokens from C and C++. However, it
    demonstrates all possible usages of the defined TableGen classes.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个文件并没有包含C和C++中所有的标记。然而，它展示了定义的TableGen类所有可能的用法。
- en: Based on these TableGen files, you’ll implement a TableGen backend in the next
    section.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些TableGen文件，你将在下一节实现TableGen后端。
- en: Implementing a TableGen backend
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现TableGen后端
- en: Since parsing and creation of records are done through an LLVM library, you
    only need to care about the backend implementation, which consists mostly of generating
    C++ source code fragments based on the information in the records. First, you
    need to be clear about what source code to generate before you can put it into
    the backend.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 由于解析和记录的创建是通过LLVM库完成的，你只需要关注后端实现，这主要是由基于记录信息生成C++源代码片段组成的。首先，你需要明确要生成什么源代码，然后才能将其放入后端。
- en: Sketching the source code to be generated
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制要生成的源代码草图
- en: 'The output of the TableGen tool is a single file containing C++ fragments.
    The fragments are guarded by macros. The goal is to replace the `TokenKinds.def`
    database file. Based on the information in the TableGen file, you can generate
    the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: TableGen工具的输出是一个包含C++片段的单个文件。这些片段由宏保护。目标是替换`TokenKinds.def`数据库文件。根据TableGen文件中的信息，你可以生成以下内容：
- en: 'The enumeration members used to define flags. The developer is free to name
    the type; however, it should be based on the `unsigned` type. If the generated
    file is named `TokenKinds.inc`, then the intended use is this:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于定义标志的枚举成员。开发者可以自由命名类型；然而，它应该基于`unsigned`类型。如果生成的文件命名为`TokenKinds.inc`，那么预期的用途如下：
- en: '[PRE37]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `TokenKind` enumeration, and the prototypes and definitions of the `getTokenName()`,
    `getPunctuatorSpelling()`, and `getKeywordSpelling()` functions. This code replaces
    the `TokenKinds.def` database file, most of the `TokenKinds.h` include file and
    the `TokenKinds.cpp`. source file.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TokenKind`枚举，以及`getTokenName()`、`getPunctuatorSpelling()`和`getKeywordSpelling()`函数的原型和定义。这段代码替换了`TokenKinds.def`数据库文件，大多数`TokenKinds.h`包含文件和`TokenKinds.cpp`源文件。'
- en: A new `lookupKeyword()` function that can be used instead of the current implementation
    using the `llvm::StringMap`. type. This is the function you want to optimize.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个新的`lookupKeyword()`函数，它可以用来替代当前使用`llvm::StringMap`类型的实现。这是你想要优化的函数。
- en: Knowing what you want to generate, you can now turn to implementing the backend.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 了解你想要生成的内容后，你现在可以转向实现后端。
- en: Creating a new TableGen tool
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个新的TableGen工具
- en: 'A simple structure for your new tool is to have a driver that evaluates the
    command-line options and calls the generation functions and the actual generator
    functions in a different file. Let’s call the driver file `TableGen.cpp` and the
    file containing the generator `TokenEmitter.cpp`. You also need a `TableGenBackends.h`
    header file. Let’s begin the implementation with the generation of the C++ code
    in the `TokenEmitter.cpp` file:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为您的新工具创建一个简单的结构，可以有一个驱动程序来评估命令行选项，并在不同的文件中调用生成函数和实际的生成函数。让我们将驱动程序文件命名为 `TableGen.cpp`，将包含生成器的文件命名为
    `TokenEmitter.cpp`。您还需要一个 `TableGenBackends.h` 头文件。让我们从在 `TokenEmitter.cpp` 文件中生成
    C++ 代码开始实现：
- en: 'As usual, the file begins with including the required headers. The most important
    one is `llvm/TableGen/Record.h`, which defines a `Record` class, used to hold
    records generated by parsing the `.``td` file:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如同往常，文件以包含所需的头文件开始。其中最重要的是 `llvm/TableGen/Record.h`，它定义了一个 `Record` 类，用于存储由解析
    `.td` 文件生成的记录：
- en: '[PRE38]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To simplify coding, the `llvm` namespace is imported:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了简化编码，导入了 `llvm` 命名空间：
- en: '[PRE39]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `TokenAndKeywordFilterEmitter` class is responsible for generating the
    C++ source code. The `emitFlagsFragment()`, `emitTokenKind()`, and `emitKeywordFilter()`
    methods emit the source code, as described in the previous section, *Sketching
    the source code to be generated*. The only public method, `run()`, calls all the
    code-emitting methods. The records are held in an instance of `RecordKeeper`,
    which is passed as a parameter to the constructor. The class is inside an anonymous
    namespace:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TokenAndKeywordFilterEmitter` 类负责生成 C++ 源代码。`emitFlagsFragment()`、`emitTokenKind()`
    和 `emitKeywordFilter()` 方法发出源代码，正如上一节中所述的 *绘制要生成的源代码*。唯一的公共方法是 `run()`，它调用所有代码发出方法。记录存储在
    `RecordKeeper` 实例中，该实例作为参数传递给构造函数。该类位于匿名命名空间内：'
- en: '[PRE40]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `run()` method calls all the emitting methods. It also times the length
    of each phase. You specify the `--time-phases` option, and then the timing is
    shown after all code is generated:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`run()` 方法调用所有发出方法。它还记录了每个阶段的长度。您指定 `--time-phases` 选项，然后所有代码生成完成后会显示计时：'
- en: '[PRE41]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `emitFlagsFragment()` method shows the typical structure of a function
    emitting C++ source code. The generated code is guarded by the `GET_TOKEN_FLAGS`
    macro. To emit the C++ source fragment, you loop over all records that are derived
    from the `Flag` class in the TableGen file. Having such a record, it is easy to
    query the record for the name and the value. Please note that the names `Flag`,
    `Name`, and `Val` must be written exactly as in the TableGen file. If you rename
    `Val` to `Value` in the TableGen file, then you also need to change the string
    in this function. All the generated source code is written to the provided stream,
    `OS`:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`emitFlagsFragment()` 方法展示了函数发出 C++ 源代码的典型结构。生成的代码由 `GET_TOKEN_FLAGS` 宏保护。要发出
    C++ 源代码片段，您需要遍历 TableGen 文件中从 `Flag` 类派生的所有记录。拥有这样的记录后，查询记录的名称和值就变得很容易。请注意，名称
    `Flag`、`Name` 和 `Val` 必须与 TableGen 文件中的完全一致。如果您在 TableGen 文件中将 `Val` 重命名为 `Value`，那么您也需要更改此函数中的字符串。所有生成的源代码都写入提供的流
    `OS` 中：'
- en: '[PRE42]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `emitTokenKind()` method emits a declaration and definition of token classification
    functions. Let’s have a look at emitting the declarations first. The overall structure
    is the same as the previous method – only more C++ source code is emitted. The
    generated source fragment is guarded by the `GET_TOKEN_KIND_DECLARATION` macro.
    Please note that this method tries to generate nicely formatted C++ code, using
    new lines and indentation as a human developer would do. In case the emitted source
    code is not correct, and you need to examine it to find the error, this will be
    tremendously helpful. It is also easy to make such errors: after all, you are
    writing a C++ function that emits C++ source code.'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`emitTokenKind()` 方法发出标记分类函数的声明和定义。让我们先看看如何发出声明。整体结构与上一个方法相同——只是发出的 C++ 源代码更多。生成的源代码片段由
    `GET_TOKEN_KIND_DECLARATION` 宏保护。请注意，此方法试图生成格式良好的 C++ 代码，使用换行和缩进来模拟人类开发者。如果发出的源代码不正确，并且您需要检查它以找到错误，这将非常有帮助。这样的错误也很容易犯：毕竟，您正在编写一个发出
    C++ 源代码的 C++ 函数。'
- en: 'First, the `TokenKind` enumeration is emitted. The name for a keyword should
    be prefixed with a `kw_` string. The loop goes over all records of the `Token`
    class, and you can query the records if they are also a subclass of the `Keyword`
    class, which enables you to emit the prefix:'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，发出 `TokenKind` 枚举。关键字的名称应该以 `kw_` 字符串为前缀。循环遍历 `Token` 类的所有记录，您可以查询记录是否也是
    `Keyword` 类的子类，这使您能够发出前缀：
- en: '[PRE43]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Next, the function declarations are emitted. This is only a constant string,
    so nothing exciting happens. This finishes emitting the declarations:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，发出函数声明。这只是一个常量字符串，所以没有发生什么激动人心的事情。这完成了声明的发出：
- en: '[PRE44]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, let’s turn to emitting the definitions. Again, this generated code is
    guarded by a macro called `GET_TOKEN_KIND_DEFINITION`. First, the token names
    are emitted into a `TokNames` array, and the `getTokenName()` function uses that
    array to retrieve the name. Please note that the quote symbol must be escaped
    as `\"` when used inside a string:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们转向发出定义。同样，生成的代码由一个名为 `GET_TOKEN_KIND_DEFINITION` 的宏保护。首先，令牌名称被发出到 `TokNames`
    数组中，`getTokenName()` 函数使用该数组来检索名称。请注意，当在字符串内部使用时，引号符号必须转义为 `\"`：
- en: '[PRE45]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next, the `getPunctuatorSpelling()` function is emitted. The only notable difference
    to the other parts is that the loop goes over all records derived from the `Punctuator`
    class. Also, a `switch` statement is generated instead of an array:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，发出 `getPunctuatorSpelling()` 函数。与其他部分相比，唯一的显著区别是循环遍历从 `Punctuator` 类派生的所有记录。此外，生成一个
    `switch` 语句而不是数组：
- en: '[PRE46]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'And finally, the `getKeywordSpelling()` function is emitted. The coding is
    similar to emitting `getPunctuatorSpelling()`. This time, the loop goes over all
    records of the `Keyword` class, and the name is again prefixed with `kw_`:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，发出 `getKeywordSpelling()` 函数。编码与发出 `getPunctuatorSpelling()` 类似。这次，循环遍历 `Keyword`
    类的所有记录，并且名称再次以 `kw_` 前缀：
- en: '[PRE47]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `emitKeywordFilter()` method is more complex than the previous methods since
    emitting the filter requires collecting some data from the records. The generated
    source code uses the `std::lower_bound()` function, thus implementing a binary
    search.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`emitKeywordFilter()` 方法比之前的方法更复杂，因为发出过滤器需要从记录中收集一些数据。生成的源代码使用 `std::lower_bound()`
    函数，从而实现二分搜索。'
- en: 'Now, let’s make a shortcut. There can be several records of the `TokenFilter`
    class defined in the TableGen file. For demonstration purposes, just emit at most
    one token filter method:'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，让我们简化一下。在 TableGen 文件中可以定义多个 `TokenFilter` 类的记录。为了演示目的，只需发出最多一个令牌过滤器方法：
- en: '[PRE48]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The keywords used for the filter are in the list named `Tokens`. To get access
    to that list, you first need to look up the `Tokens` field in the record. This
    returns a pointer to an instance of the `RecordVal` class, from which you can
    retrieve the `Initializer` instance via the calling method, `getValue()`. The
    `Tokens` field is defined as a list, so you cast the initializer instance to `ListInit`.
    If this fails, then exit the function:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于过滤的关键字位于名为 `Tokens` 的列表中。为了访问该列表，您首先需要查找记录中的 `Tokens` 字段。这返回一个指向 `RecordVal`
    类实例的指针，您可以通过调用方法 `getValue()` 从该实例中检索 `Initializer` 实例。`Tokens` 字段定义为列表，因此您将初始化器实例转换为
    `ListInit`。如果失败，则退出函数：
- en: '[PRE49]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, you are ready to construct a filter table. For each keyword stored in
    the `TokenFilter`, list, you need the name and the value of the `Flag` field.
    That field is again defined as a list, so you need to loop over those elements
    to calculate the final value. The resulting name/flag value pair is stored in
    a `Table` vector:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您已经准备好构建一个过滤器表。对于存储在 `TokenFilter` 列表中的每个关键字，您需要 `Flag` 字段的名称和值。该字段再次定义为列表，因此您需要遍历这些元素来计算最终值。结果名称/标志值对存储在
    `Table` 向量中：
- en: '[PRE50]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'To be able to perform a binary search, the table needs to be sorted. The comparison
    function is provided by a lambda function:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了能够执行二分搜索，该表需要排序。比较函数由一个 lambda 函数提供：
- en: '[PRE51]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, you can emit the C++ source code. First, you emit the sorted table containing
    the name of the keyword and the associated flag value:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以发出 C++ 源代码。首先，您需要发出包含关键字名称和相关标志值的排序表：
- en: '[PRE52]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Next, you look up the keyword in the sorted table, using the `std::lower_bound()`
    standard C++ function. If the keyword is in the table, then the `Value` parameter
    receives the value of the flags associated with the keyword, and the function
    returns `true`. Otherwise, the function simply returns `false`:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你使用`std::lower_bound()`标准C++函数在排序表中查找关键字。如果关键字在表中，则`Value`参数接收与关键字关联的标志值，函数返回`true`。否则，函数简单地返回`false`：
- en: '[PRE53]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The only missing part now is a way to call this implementation, for which you
    define a global function, `EmitTokensAndKeywordFilter()`. The `emitSourceFileHeader()`
    function declared in the `llvm/TableGen/TableGenBackend.h` header emits a comment
    at the top of the generated file:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在唯一缺少的部分是调用此实现的方法，为此你定义了一个全局函数`EmitTokensAndKeywordFilter()`。在`llvm/TableGen/TableGenBackend.h`头文件中声明的`emitSourceFileHeader()`函数在生成的文件顶部输出一个注释：
- en: '[PRE54]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: With that, you finished the implementation of the source emitter in the `TokenEmitter.cpp`
    file. Overall, the coding is not too complicated.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，你就在`TokenEmitter.cpp`文件中完成了源发射器的实现。总体来说，代码并不复杂。
- en: 'The `TableGenBackends.h` header file only contains the declaration of the `EmitTokensAndKeywordFilter()`
    function. To avoid including other files, you use forward declarations for the
    `raw_ostream` and `RecordKeeper` classes:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`TableGenBackends.h`头文件只包含`EmitTokensAndKeywordFilter()`函数的声明。为了避免包含其他文件，你使用前向声明为`raw_ostream`和`RecordKeeper`类：'
- en: '[PRE55]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The missing part is the implementation of the driver. Its task is to parse
    the TableGen file and emit the records according to the command-line options.
    The implementation is in the `TableGen.cpp` file:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 缺失的部分是驱动程序的实现。其任务是解析TableGen文件并根据命令行选项输出记录。实现位于`TableGen.cpp`文件中：
- en: 'As usual, the implementation begins with including the required headers. The
    most important one is `llvm/TableGen/Main.h` because this header declares the
    frontend of TableGen:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如同往常，实现从包含所需的头文件开始。最重要的是`llvm/TableGen/Main.h`，因为这个头文件声明了TableGen的前端：
- en: '[PRE56]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'To simplify coding, the `llvm` namespace is imported:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了简化编码，导入了`llvm`命名空间：
- en: '[PRE57]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The user can choose one action. The `ActionType` enumeration contains all possible
    actions:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户可以选择一个操作。`ActionType`枚举包含所有可能的操作：
- en: '[PRE58]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'A single command-line option object called `Action` is used. The user needs
    to specify the `--gen-tokens` option to emit the token filter you implemented.
    The other two options, `--print-records` and `--dump-json`, are standard options
    to dump read records. Note that the object is in an anonymous namespace:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一个名为`Action`的单个命令行选项对象。用户需要指定`--gen-tokens`选项来输出你实现的令牌过滤器。其他两个选项`--print-records`和`--dump-json`是用于输出读取记录的标准选项。注意，该对象位于匿名命名空间中：
- en: '[PRE59]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The `Main()` function performs the requested action based on the value of `Action`.
    Most importantly, your `EmitTokensAndKeywordFilter()` function is called if `--gen-tokens`
    was specified on the command line. After the end of the function, the anonymous
    namespace is closed:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Main()`函数根据`Action`的值执行请求的操作。最重要的是，如果命令行中指定了`--gen-tokens`，则会调用你的`EmitTokensAndKeywordFilter()`函数。函数结束后，匿名命名空间关闭：'
- en: '[PRE60]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'And lastly, you define a `main()` function. After setting up the stack trace
    handler and parsing the command-line options, the `TableGenMain()` function is
    called to parse the TableGen file and create records. That function also calls
    your `Main()` function if there are no errors:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你定义了一个`main()`函数。在设置堆栈跟踪处理程序和解析命令行选项后，调用`TableGenMain()`函数来解析TableGen文件并创建记录。如果没有任何错误，该函数还会调用你的`Main()`函数：
- en: '[PRE61]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Your own TableGen tool is now implemented. After compiling, you can run it
    with the `KeywordC.td` sample input file as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你自己的TableGen工具现在已经实现。编译后，你可以使用`KeywordC.td`样本输入文件运行它，如下所示：
- en: '[PRE62]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The generated C++ source code is written to the `TokenFilter.inc` file.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的C++源代码被写入`TokenFilter.inc`文件。
- en: Performance of the token filter
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌过滤器的性能
- en: Using a plain binary search for the keyword filter does not give a better performance
    than the implementation based on the `llvm::StringMap` type. To beat the performance
    of the current implementation, you need to generate a perfect hash function.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 使用简单的二分搜索进行关键字过滤器搜索并不比基于`llvm::StringMap`类型的实现有更好的性能。要超越当前实现的性能，你需要生成一个完美的哈希函数。
- en: The classic algorithm from Czech, Havas, and Majewski can be easily implemented,
    and it gives you a very good performance. It is described in *An optimal algorithm
    for generating minimal perfect hash functions*, *Information Processing Letters*,
    *Volume 43*, *Issue 5*, *1992*. See https://www.sciencedirect.com/science/article/abs/pii/002001909290220P.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 来自捷克共和国的Havas和Majewski的经典算法可以轻松实现，并且提供了非常好的性能。它描述在*生成最小完美哈希函数的最优算法*，*信息处理信件*，*第43卷*，*第5期*，*1992年*。见https://www.sciencedirect.com/science/article/abs/pii/002001909290220P。
- en: 'A state-of-the-art algorithm is PTHash from Pibiri and Trani, described in
    *PTHash: Revisiting FCH Minimal Perfect Hashing*, *SIGIR ’21*. See [https://arxiv.org/pdf/2104.10402.pdf](https://arxiv.org/pdf/2104.10402.pdf).'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 最先进的算法是Pibiri和Trani的PTHash，在*PTHash：重新审视FCH最小完美哈希*，*SIGIR’21*中描述。见[https://arxiv.org/pdf/2104.10402.pdf](https://arxiv.org/pdf/2104.10402.pdf)。
- en: Both algorithms are good candidates for generating a token filter that is actually
    faster than `llvm::StringMap`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种算法都是生成一个比`llvm::StringMap`实际更快的标记过滤器的好候选。
- en: Drawbacks of TableGen
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TableGen的缺点
- en: 'Here are a few drawbacks of TableGen:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些TableGen的缺点：
- en: The TableGen language is built on a simple concept. As a consequence, it does
    not have the same computing capabilities as other DSLs. Obviously, some programmers
    would like to replace TableGen with a different, more powerful language, and this
    topic comes up from time to time in the LLVM discussion forum.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TableGen语言建立在简单概念之上。因此，它不具备其他DSLs相同的计算能力。显然，一些程序员希望用一种不同、更强大的语言来替换TableGen，这个话题在LLVM讨论论坛上时不时会出现。
- en: With the possibility of implementing your own backends, the TableGen language
    is very flexible. However, it also means that the semantics of a given definition
    are hidden inside the backend. Thus, you can create TableGen files that are basically
    not understandable by other developers.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有可能实现自己的后端，TableGen语言非常灵活。然而，这也意味着给定定义的语义隐藏在后台中。因此，你可以创建其他开发者基本上无法理解的TableGen文件。
- en: And last, the backend implementation can be very complex if you try to solve
    a non-trivial task. It is reasonable to expect that this effort would be lower
    if the TableGen language were more powerful.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，如果你尝试解决一个非平凡的任务，后端实现可能会非常复杂。如果TableGen语言更加强大，预期这种努力会降低，这是合理的。
- en: Even if not all developers are happy with the capabilities of TableGen, the
    tool is used widely in LLVM, and for a developer, it is important to understand
    it.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 即使不是所有开发者都对TableGen的功能感到满意，这个工具在LLVM中仍然被广泛使用，对于开发者来说，理解它是很重要的。
- en: Summary
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you first learned the main idea behind TableGen. Then, you
    defined your first classes and records in the TableGen language, and you acquired
    knowledge of the syntax of TableGen. Finally, you developed a TableGen backend
    emitting fragments of C++ source code, based on the TableGen classes you defined.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你首先学习了TableGen背后的主要思想。然后，你在TableGen语言中定义了你的第一个类和记录，并获得了TableGen语法的知识。最后，你基于定义的TableGen类开发了一个生成C++源代码片段的TableGen后端。
- en: 'In the next chapter, we examine another unique feature of LLVM: generating
    and executing code in one step, also known as **Just-In-Time** (**JIT**) compilation.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨LLVM的另一个独特特性：一步生成和执行代码，也称为**即时编译**（**JIT**）。
