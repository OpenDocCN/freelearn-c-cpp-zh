- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The TableGen Language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Large parts of backends in LLVM are written in the TableGen language, a special
    language used to generate fragments of C++ source code to avoid implementing code
    similar for each backend and to shorten the amount of source code. Having knowledge
    of TableGen is therefore important.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In *Understanding the TableGen language*, you will learn about the main idea
    behind TableGen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In *Experimenting with the TableGen language*, you will define your own TableGen
    classes and records, and learn the syntax of the TableGen language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In *Generating C++ code from a TableGen file*, you will develop your own TableGen
    backend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawbacks of TableGen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you will be able to use existing TableGen classes
    to define your own records. You will also acquire knowledge of how to create TableGen
    classes and records from scratch, and how to develop a TableGen backend to emit
    source code.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find the source code used in this chapter on GitHub: [https://github.com/PacktPublishing/Learn-LLVM-17/tree/main/Chapter08](https://github.com/PacktPublishing/Learn-LLVM-17/tree/main/Chapter08).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the TableGen language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: LLVM comes with its own **domain-specific language** (**DSL**) called **TableGen**.
    It is used to generate C++ code for a wide range of use cases, thus reducing the
    amount of code a developer has to produce. The TableGen language is not a full-fledged
    programming language. It is only used to define records, which is a fancy word
    for a collection of names and values. To understand why such a restricted language
    is useful, let’s examine two examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typical data you need to define one machine instruction of a CPU is:'
  prefs: []
  type: TYPE_NORMAL
- en: The mnemonic of the instruction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The bit pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number and types of operands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Possible restrictions or side effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is easy to see that this data can be represented as a record. For example,
    a field named `asmstring` could hold the value of the mnemonic; say, `"add"`.
    Also, a field named `opcode` could hold the binary representation of the instruction.
    Together, the record would describe an additional instruction. Each LLVM backend
    describes the instruction set in this way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Records are such a general concept that you can describe a wide variety of
    data with them. Another example is the definition of command-line options. A command-line
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: Has a name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: May have an optional argument
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has a help text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: May belong to a group of options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Again, this data can be easily seen as a record. Clang uses this approach for
    the command-line options of the Clang driver.
  prefs: []
  type: TYPE_NORMAL
- en: The TableGen language
  prefs: []
  type: TYPE_NORMAL
- en: In LLVM, the TableGen language is used for a variety of tasks. Large parts of
    a backend are written in the TableGen language; for example, the definition of
    a register file, all instructions with mnemonic and binary encoding, calling conventions,
    patterns for instruction selection, and scheduling models for instruction scheduling.
    Other uses of LLVM are the definition of intrinsic functions, the definition of
    attributes, and the definition of command-line options.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll find the *Programmer’s Reference* at [https://llvm.org/docs/TableGen/ProgRef.html](https://llvm.org/docs/TableGen/ProgRef.html)
    and the *Backend Developer’s Guide* at [https://llvm.org/docs/TableGen/BackGuide.html](https://llvm.org/docs/TableGen/BackGuide.html).
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this flexibility, the parsing and the semantics of the TableGen language
    are implemented in a library. To generate C++ code from the records, you need
    to create a tool that takes the parsed records and generates C++ code from it.
    In LLVM, that tool is called `llvm-tblgen`, and in Clang, it is called `clang-tblgen`.
    Those tools contain the code generators required by the project. But they can
    also be used to learn more about the TableGen language, which is what we’ll do
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Experimenting with the TableGen language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Very often, beginners feel overwhelmed by the TableGen language. But as soon
    as you start experimenting with the language, it becomes much easier.
  prefs: []
  type: TYPE_NORMAL
- en: Defining records and classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s define a simple record for an instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `def` keyword signals that you define a record. It is followed by the name
    of the record. The record body is surrounded by curly braces, and the body consists
    of field definitions, similar to a structure in C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `llvm-tblgen` tool to see the generated records. Save the preceding
    source code in an `inst.td` file and run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This is not yet exciting; it only shows the defined record was parsed correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Defining instructions using single records is not very comfortable. A modern
    CPU has hundreds of instructions, and with this amount of records, it is very
    easy to introduce typing errors in the field names. And if you decide to rename
    a field or add a new field, then the number of records to change becomes a challenge.
    Therefore, a blueprint is needed. In C++, classes have a similar purpose, and
    in TableGen, it is also called a `Inst` class and two records based on that class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax for classes is similar to that of records. The `class` keyword signals
    that a class is defined, followed by the name of the class. A class can have a
    parameter list. Here, the `Inst` class has two parameters, `mnemonic` and `opcode`,
    which are used to initialize the records’ fields. The values for those fields
    are given when the class is instantiated. The `ADD` and `SUB` records show two
    instantiations of the class. Again, let’s use `llvm-tblgen` to look at the records:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, you have one class definition and two records. The name of the class used
    to define the records is shown as a comment. Please note that the arguments of
    the class have the default value `?`, which indicates `int` is uninitialized.
  prefs: []
  type: TYPE_NORMAL
- en: Tip for debugging
  prefs: []
  type: TYPE_NORMAL
- en: To get a more detailed dump of the records, you can use the `–-print-detailed-records`
    option. The output includes the line numbers of record and class definitions,
    and where record fields are initialized. They can be very helpful if you try to
    track down why a record field was assigned a certain value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, the `ADD` and `SUB` instructions have a lot in common, but there
    is also a difference: addition is a commutative operation but subtraction is not.
    Let’s capture that fact in the record, too. A small challenge is that TableGen
    only supports a limited set of data types. You already used `string` and `int`
    in the examples. The other available data types are `bit`, `bits<n>`, `list<type>`,
    and `dag`. The `bit` type represents a single bit; that is, `0` or `1`. If you
    need a fixed number of bits, then you use the `bits<n>` type. For example, `bits<5>`
    is an integer type 5 bits wide. To define a list based on another type, you use
    the `list<type>` type. For example, `list<int>` is a list of integers, and `list<Inst>`
    is a list of records of the `Inst` class from the example. The `dag` type represents
    **directed acyclic graph** (**DAG**) nodes. This type is useful for defining patterns
    and operations and is used extensively in LLVM backends.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To represent a flag, a single bit is sufficient, so you can use one to mark
    an instruction as commutable. The majority of instructions are not commutable,
    so you can take advantage of default values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You should run `llvm-tblgen` to verify that the records are defined as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is no requirement for a class to have parameters. It is also possible
    to assign values later. For example, you can define that all instructions are
    not commutable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Using a `let` statement, you can overwrite that value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can open a record body to overwrite the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Again, please use `llvm-tblgen` to verify that the `Commutable` flag is set
    to `1` in both cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Classes and records can be inherited from multiple classes, and it is always
    possible to add new fields or overwrite the value of existing fields. You can
    use inheritance to introduce a new `CommutableInst` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting records are always the same, but the language allows you to define
    records in different ways. Please note that, in the latter example, the `Commutable`
    flag may be superfluous: the code generator can query a record for the classes
    it is based on, and if that list contains the `CommutableInst` class, then it
    can set the flag internally.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating multiple records at once with multiclasses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another often-used statement is `multiclass`. A multiclass allows you to define
    multiple records at once. Let’s expand the example to show why this can be useful.
  prefs: []
  type: TYPE_NORMAL
- en: The definition of an `add` instruction is very simplistic. In reality, a CPU
    often has several `add` instructions. A common variant is that one instruction
    has two register operands while another instruction has one register operand and
    an immediate operand, which is a small number. Assume that for the instruction
    having an immediate operand, the designer of the instruction set decided to mark
    them with `i` as a suffix. So, we end up with the `add` and `addi` instructions.
    Further, assume that the opcodes differ by `1`. Many arithmetic and logical instructions
    follow this scheme; therefore, you want the definition to be as compact as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first challenge is that you need to manipulate values. There is a limited
    number of operators that you can use to modify a value. For example, to produce
    the sum of `1` and the value of the field opcode, you write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Such an expression is best used as an argument for a class. Testing a field
    value and then changing it based on the found value is generally not possible
    because it requires dynamic statements that are not available. Always remember
    that all calculations are done while the records are constructed!
  prefs: []
  type: TYPE_NORMAL
- en: 'In a similar way, strings can be concatenated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Because all operators begin with an exclamation mark (`!`), they are also called
    **bang operators**. You find a full list of bang operators in the *Programmer’s*
    *Reference*: [https://llvm.org/docs/TableGen/ProgRef.html#appendix-a-bang-operators](https://llvm.org/docs/TableGen/ProgRef.html#appendix-a-bang-operators).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can define a multiclass. The `Inst` class serves again as the base:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The definition of a multiclass is a bit more involved, so let’s do it in steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The definition of a multiclass uses a similar syntax to classes. The new multiclass
    is named `InstWithImm` and has two parameters, `mnemonic` and `opcode`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'First, you define an instruction with two register operands. As in a normal
    record definition, you use the `def` keyword to define the record, and you use
    the `Inst` class to create the record content. You also need to define an empty
    name. We will explain later why this is necessary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, you define an instruction with the immediate operand. You derive the
    values for the mnemonic and the opcode from the parameters of the multiclass,
    using bang operators. The record is named `I`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That is all; the class body can be closed, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To instantiate the records, you must use the `defm` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'These statements result in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Inst<"add", 0xA0>` record is instantiated. The name of the record is the
    concatenation of the name following the `defm` keyword and of the name following
    `def` inside the multiclass statement, which results in the name `ADD`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Inst<"addi", 0xA1>` record is instantiated and, following the same scheme,
    is given the name `ADDI`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s verify this claim with `llvm-tblgen`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Using a multiclass, it is very easy to generate multiple records at once. This
    feature is used very often!
  prefs: []
  type: TYPE_NORMAL
- en: 'A record does not need to have a name. Anonymous records are perfectly fine.
    Omitting the name is all you need to do to define an anonymous record. The name
    of a record generated by a multiclass is made up of two names, and both names
    must be given to create a named record. If you omit the name after `defm`, then
    only anonymous records are created. Similarly, if the `def` inside the multiclass
    is not followed by a name, an anonymous record is created. This is the reason
    why the first definition in the multiclass example used the empty name `""`: without
    it, the record would be anonymous.'
  prefs: []
  type: TYPE_NORMAL
- en: Simulating function calls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In some cases, using a multiclass like in the previous example can lead to
    repetitions. Assume that the CPU also supports memory operands, in a way similar
    to immediate operands. You can support this by adding a new record definition
    to the multiclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is perfectly fine. But now, imagine you do not have 3 but 16 records to
    define, and you need to do this multiple times. A typical scenario where such
    a situation can arise is when the CPU supports many vector types, and the vector
    instructions vary slightly based on the used type.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that all three lines with the `def` statement have the same structure.
    The variation is only in the suffix of the name and of the mnemonic, and the delta
    value is added to the opcode. In C, you could put the data into an array and implement
    a function that returns the data based on an index value. Then, you could create
    a loop over the data instead of manually repeating statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Amazingly, you can do something similar in the TableGen language! Here is how
    to transform the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To store the data, you define a class with all required fields. The class is
    called `InstDesc`, because it describes some properties of an instruction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, you can define records for each operand type. Note that it exactly captures
    the differences observed in the data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Imagine you have a loop enumerating the numbers `0`, `1`, and `2`, and you
    want to select one of the previously defined records based on the index. How can
    you do this? The solution is to create a `getDesc` class that takes the index
    as a parameter. It has a single field, `ret`, that you can interpret as a return
    value. To assign the correct value to this field, the `!cond` operator is used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This operator works similarly to a `switch`/`case` statement in C.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, you are ready to define the multiclass. The TableGen language has a `loop`
    statement, and it also allows us to define variables. But remember that there
    is no dynamic execution! As a consequence, the loop range is statically defined,
    and you can assign a value to a variable, but you cannot change that value later.
    However, this is enough to retrieve the data. Please note how the use of the `getDesc`
    class resembles a function call. But there is no function call! Instead, an anonymous
    record is created, and the values are taken from that record. Lastly, the past
    operator (`#`) performs a string concatenation, similar to the `!strconcat` operator
    used earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, you use the multiclass as before to define records:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Please run `llvm-tblgen` and examine the records. Besides the various `ADD`
    records, you will also see a couple of anonymous records generated by the use
    of the `getDesc` class.
  prefs: []
  type: TYPE_NORMAL
- en: This technique is used in the instruction definition of several LLVM backends.
    With the knowledge you have acquired, you should have no problem understanding
    those files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `foreach` statement used the syntax `0-2` to denote the bounds of the range.
    This is called a `0...3`), which is useful if the numbers are negative. Lastly,
    you are not restricted to numerical ranges; you can also loop over a list of elements,
    which allows you to use strings or previously defined records. For example, you
    may like the use of the `foreach` statement, but you think that using the `getDesc`
    class is too complicated. In this case, looping over the `InstDesc` records is
    the solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: So far, you only defined records in the TableGen language, using the most commonly
    used statements. In the next section, you’ll learn how to generate C++ source
    code from records defined in the TableGen language.
  prefs: []
  type: TYPE_NORMAL
- en: Generating C++ code from a TableGen file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, you defined records in the TableGen language. To make
    use of those records, you need to write your own TableGen backend that can produce
    C++ source code or do other things using the records as input.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 3*](B19561_03.xhtml#_idTextAnchor055), *Turning the Source File
    into an Abstract Syntax Tree*, the implementation of the `Lexer` class uses a
    database file to define tokens and keywords. Various query functions make use
    of that database file. Besides that, the database file is used to implement a
    keyword filter. The keyword filter is a hash map, implemented using the `llvm::StringMap`
    class. Whenever an identifier is found, the keyword filter is called to find out
    if the identifier is actually a keyword. If you take a closer look at the implementation
    using the `ppprofiler` pass from [*Chapter 6*](B19561_06.xhtml#_idTextAnchor101),
    *Advanced IR Generation*, then you will see that this function is called quite
    often. Therefore, it may be useful to experiment with different implementations
    to make that functionality as fast as possible.
  prefs: []
  type: TYPE_NORMAL
- en: However, this is not as easy as it seems. For example, you can try to replace
    the lookup in the hash map with a binary search. This requires that the keywords
    in the database file are sorted. Currently, this seems to be the case, but during
    development, a new keyword might be added in the wrong place undetected. The only
    way to make sure that the keywords are in the right order is to add some code
    that checks the order at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: You can speed up the standard binary search by changing the memory layout. For
    example, instead of sorting the keywords, you can use the Eytzinger layout, which
    enumerates the search tree in breadth-first order. This layout increases the cache
    locality of the data and therefore speeds up the search. Personally speaking,
    maintaining the keywords in breadth-first order manually in the database file
    is not possible.
  prefs: []
  type: TYPE_NORMAL
- en: Another popular approach for searching is the generation of minimal perfect
    hash functions. If you insert a new key into a dynamic hash table such as `llvm::StringMap`,
    then that key might be mapped to an already occupied slot. This is called a `gperf`
    GNU tool.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, there is some incentive to be able to generate a lookup function
    from keywords. So, let’s move the database file to TableGen!
  prefs: []
  type: TYPE_NORMAL
- en: Defining data in the TableGen language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `TokenKinds.def` database file defines three different macros. The `TOK`
    macro is used for tokens that do not have a fixed spelling – for example, for
    integer literals. The `PUNCTUATOR` macro is used for all kinds of punctuation
    marks and includes a preferred spelling. Lastly, the `KEYWORD` macro defines a
    keyword that is made up of a literal and a flag, which is used to indicate at
    which language level this literal is a keyword. For example, the `thread_local`
    keyword was added to C++11.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to express this in the TableGen language is to create a `Token` class
    that holds all the data. You can then add subclasses of that class to make the
    usage more comfortable. You also need a `Flag` class for flags defined together
    with a keyword. And last, you need a class to define a keyword filter. These classes
    define the basic data structure and can be potentially reused in other projects.
    Therefore, you create a `Keyword.td` file for it. Here are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A flag is modeled as a name and an associated value. This makes it easy to
    generate an enumeration from this data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `Token` class is used as the base class. It just carries a name. Please
    note that this class has no parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `Tok` class has the same function as the corresponding `TOK` macro from
    the database file. it represents a token without fixed spellings. It derives from
    the base class, `Token`, and just adds initialization for the name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the same way, the `Punctuator` class resembles the `PUNCTUATOR` macro. It
    adds a field for the spelling of the token:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And last, the `Keyword` class needs a list of flags:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With these definitions in place, you can now define a class for the keyword
    filter, called `TokenFilter`. It takes a list of tokens as a parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With these class definitions, you are certainly able to capture all the data
    from the `TokenKinds.def` database file. The TinyLang language does not utilize
    the flags, since there is only this version of the language. Real-world languages
    such as C and C++ have undergone a couple of revisions, and they usually require
    flags. Therefore, we use keywords from C and C++ as an example. Let’s create a
    `KeywordC.td` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you include the class definitions created earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, you define flags. The value is the binary value of the flag. Note how
    the `!or` operator is used to create a value for the `KEYALL` flag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There are tokens without a fixed spelling – for example, a comment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Operators are defined using the `Punctuator` class, as in this example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Keywords need to use different flags:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And last, here’s the definition of the keyword filter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Of course, this file does not include all tokens from C and C++. However, it
    demonstrates all possible usages of the defined TableGen classes.
  prefs: []
  type: TYPE_NORMAL
- en: Based on these TableGen files, you’ll implement a TableGen backend in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a TableGen backend
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since parsing and creation of records are done through an LLVM library, you
    only need to care about the backend implementation, which consists mostly of generating
    C++ source code fragments based on the information in the records. First, you
    need to be clear about what source code to generate before you can put it into
    the backend.
  prefs: []
  type: TYPE_NORMAL
- en: Sketching the source code to be generated
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The output of the TableGen tool is a single file containing C++ fragments.
    The fragments are guarded by macros. The goal is to replace the `TokenKinds.def`
    database file. Based on the information in the TableGen file, you can generate
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The enumeration members used to define flags. The developer is free to name
    the type; however, it should be based on the `unsigned` type. If the generated
    file is named `TokenKinds.inc`, then the intended use is this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `TokenKind` enumeration, and the prototypes and definitions of the `getTokenName()`,
    `getPunctuatorSpelling()`, and `getKeywordSpelling()` functions. This code replaces
    the `TokenKinds.def` database file, most of the `TokenKinds.h` include file and
    the `TokenKinds.cpp`. source file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A new `lookupKeyword()` function that can be used instead of the current implementation
    using the `llvm::StringMap`. type. This is the function you want to optimize.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Knowing what you want to generate, you can now turn to implementing the backend.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new TableGen tool
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A simple structure for your new tool is to have a driver that evaluates the
    command-line options and calls the generation functions and the actual generator
    functions in a different file. Let’s call the driver file `TableGen.cpp` and the
    file containing the generator `TokenEmitter.cpp`. You also need a `TableGenBackends.h`
    header file. Let’s begin the implementation with the generation of the C++ code
    in the `TokenEmitter.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, the file begins with including the required headers. The most important
    one is `llvm/TableGen/Record.h`, which defines a `Record` class, used to hold
    records generated by parsing the `.``td` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To simplify coding, the `llvm` namespace is imported:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `TokenAndKeywordFilterEmitter` class is responsible for generating the
    C++ source code. The `emitFlagsFragment()`, `emitTokenKind()`, and `emitKeywordFilter()`
    methods emit the source code, as described in the previous section, *Sketching
    the source code to be generated*. The only public method, `run()`, calls all the
    code-emitting methods. The records are held in an instance of `RecordKeeper`,
    which is passed as a parameter to the constructor. The class is inside an anonymous
    namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `run()` method calls all the emitting methods. It also times the length
    of each phase. You specify the `--time-phases` option, and then the timing is
    shown after all code is generated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `emitFlagsFragment()` method shows the typical structure of a function
    emitting C++ source code. The generated code is guarded by the `GET_TOKEN_FLAGS`
    macro. To emit the C++ source fragment, you loop over all records that are derived
    from the `Flag` class in the TableGen file. Having such a record, it is easy to
    query the record for the name and the value. Please note that the names `Flag`,
    `Name`, and `Val` must be written exactly as in the TableGen file. If you rename
    `Val` to `Value` in the TableGen file, then you also need to change the string
    in this function. All the generated source code is written to the provided stream,
    `OS`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `emitTokenKind()` method emits a declaration and definition of token classification
    functions. Let’s have a look at emitting the declarations first. The overall structure
    is the same as the previous method – only more C++ source code is emitted. The
    generated source fragment is guarded by the `GET_TOKEN_KIND_DECLARATION` macro.
    Please note that this method tries to generate nicely formatted C++ code, using
    new lines and indentation as a human developer would do. In case the emitted source
    code is not correct, and you need to examine it to find the error, this will be
    tremendously helpful. It is also easy to make such errors: after all, you are
    writing a C++ function that emits C++ source code.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, the `TokenKind` enumeration is emitted. The name for a keyword should
    be prefixed with a `kw_` string. The loop goes over all records of the `Token`
    class, and you can query the records if they are also a subclass of the `Keyword`
    class, which enables you to emit the prefix:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, the function declarations are emitted. This is only a constant string,
    so nothing exciting happens. This finishes emitting the declarations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s turn to emitting the definitions. Again, this generated code is
    guarded by a macro called `GET_TOKEN_KIND_DEFINITION`. First, the token names
    are emitted into a `TokNames` array, and the `getTokenName()` function uses that
    array to retrieve the name. Please note that the quote symbol must be escaped
    as `\"` when used inside a string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, the `getPunctuatorSpelling()` function is emitted. The only notable difference
    to the other parts is that the loop goes over all records derived from the `Punctuator`
    class. Also, a `switch` statement is generated instead of an array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And finally, the `getKeywordSpelling()` function is emitted. The coding is
    similar to emitting `getPunctuatorSpelling()`. This time, the loop goes over all
    records of the `Keyword` class, and the name is again prefixed with `kw_`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `emitKeywordFilter()` method is more complex than the previous methods since
    emitting the filter requires collecting some data from the records. The generated
    source code uses the `std::lower_bound()` function, thus implementing a binary
    search.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let’s make a shortcut. There can be several records of the `TokenFilter`
    class defined in the TableGen file. For demonstration purposes, just emit at most
    one token filter method:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The keywords used for the filter are in the list named `Tokens`. To get access
    to that list, you first need to look up the `Tokens` field in the record. This
    returns a pointer to an instance of the `RecordVal` class, from which you can
    retrieve the `Initializer` instance via the calling method, `getValue()`. The
    `Tokens` field is defined as a list, so you cast the initializer instance to `ListInit`.
    If this fails, then exit the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, you are ready to construct a filter table. For each keyword stored in
    the `TokenFilter`, list, you need the name and the value of the `Flag` field.
    That field is again defined as a list, so you need to loop over those elements
    to calculate the final value. The resulting name/flag value pair is stored in
    a `Table` vector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To be able to perform a binary search, the table needs to be sorted. The comparison
    function is provided by a lambda function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, you can emit the C++ source code. First, you emit the sorted table containing
    the name of the keyword and the associated flag value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, you look up the keyword in the sorted table, using the `std::lower_bound()`
    standard C++ function. If the keyword is in the table, then the `Value` parameter
    receives the value of the flags associated with the keyword, and the function
    returns `true`. Otherwise, the function simply returns `false`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The only missing part now is a way to call this implementation, for which you
    define a global function, `EmitTokensAndKeywordFilter()`. The `emitSourceFileHeader()`
    function declared in the `llvm/TableGen/TableGenBackend.h` header emits a comment
    at the top of the generated file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With that, you finished the implementation of the source emitter in the `TokenEmitter.cpp`
    file. Overall, the coding is not too complicated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `TableGenBackends.h` header file only contains the declaration of the `EmitTokensAndKeywordFilter()`
    function. To avoid including other files, you use forward declarations for the
    `raw_ostream` and `RecordKeeper` classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The missing part is the implementation of the driver. Its task is to parse
    the TableGen file and emit the records according to the command-line options.
    The implementation is in the `TableGen.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, the implementation begins with including the required headers. The
    most important one is `llvm/TableGen/Main.h` because this header declares the
    frontend of TableGen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To simplify coding, the `llvm` namespace is imported:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The user can choose one action. The `ActionType` enumeration contains all possible
    actions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A single command-line option object called `Action` is used. The user needs
    to specify the `--gen-tokens` option to emit the token filter you implemented.
    The other two options, `--print-records` and `--dump-json`, are standard options
    to dump read records. Note that the object is in an anonymous namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `Main()` function performs the requested action based on the value of `Action`.
    Most importantly, your `EmitTokensAndKeywordFilter()` function is called if `--gen-tokens`
    was specified on the command line. After the end of the function, the anonymous
    namespace is closed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And lastly, you define a `main()` function. After setting up the stack trace
    handler and parsing the command-line options, the `TableGenMain()` function is
    called to parse the TableGen file and create records. That function also calls
    your `Main()` function if there are no errors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Your own TableGen tool is now implemented. After compiling, you can run it
    with the `KeywordC.td` sample input file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The generated C++ source code is written to the `TokenFilter.inc` file.
  prefs: []
  type: TYPE_NORMAL
- en: Performance of the token filter
  prefs: []
  type: TYPE_NORMAL
- en: Using a plain binary search for the keyword filter does not give a better performance
    than the implementation based on the `llvm::StringMap` type. To beat the performance
    of the current implementation, you need to generate a perfect hash function.
  prefs: []
  type: TYPE_NORMAL
- en: The classic algorithm from Czech, Havas, and Majewski can be easily implemented,
    and it gives you a very good performance. It is described in *An optimal algorithm
    for generating minimal perfect hash functions*, *Information Processing Letters*,
    *Volume 43*, *Issue 5*, *1992*. See https://www.sciencedirect.com/science/article/abs/pii/002001909290220P.
  prefs: []
  type: TYPE_NORMAL
- en: 'A state-of-the-art algorithm is PTHash from Pibiri and Trani, described in
    *PTHash: Revisiting FCH Minimal Perfect Hashing*, *SIGIR ’21*. See [https://arxiv.org/pdf/2104.10402.pdf](https://arxiv.org/pdf/2104.10402.pdf).'
  prefs: []
  type: TYPE_NORMAL
- en: Both algorithms are good candidates for generating a token filter that is actually
    faster than `llvm::StringMap`.
  prefs: []
  type: TYPE_NORMAL
- en: Drawbacks of TableGen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few drawbacks of TableGen:'
  prefs: []
  type: TYPE_NORMAL
- en: The TableGen language is built on a simple concept. As a consequence, it does
    not have the same computing capabilities as other DSLs. Obviously, some programmers
    would like to replace TableGen with a different, more powerful language, and this
    topic comes up from time to time in the LLVM discussion forum.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the possibility of implementing your own backends, the TableGen language
    is very flexible. However, it also means that the semantics of a given definition
    are hidden inside the backend. Thus, you can create TableGen files that are basically
    not understandable by other developers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And last, the backend implementation can be very complex if you try to solve
    a non-trivial task. It is reasonable to expect that this effort would be lower
    if the TableGen language were more powerful.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even if not all developers are happy with the capabilities of TableGen, the
    tool is used widely in LLVM, and for a developer, it is important to understand
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you first learned the main idea behind TableGen. Then, you
    defined your first classes and records in the TableGen language, and you acquired
    knowledge of the syntax of TableGen. Finally, you developed a TableGen backend
    emitting fragments of C++ source code, based on the TableGen classes you defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we examine another unique feature of LLVM: generating
    and executing code in one step, also known as **Just-In-Time** (**JIT**) compilation.'
  prefs: []
  type: TYPE_NORMAL
