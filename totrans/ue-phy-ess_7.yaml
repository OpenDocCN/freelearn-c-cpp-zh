- en: Chapter 7. Creating a Vehicle Blueprint
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章 创建车辆蓝图
- en: 'In this chapter, we will create a working **Vehicle Blueprint** from scratch
    using the default assets provided by Unreal Engine 4 with the **VehicleGame**
    project example as well as using assets which we will be creating by ourselves.
    First, we will start with an overview of what **Vehicle Blueprint** will be composed
    of and then move on to the specifics on how to create the different blueprints
    for all of their aspects. Following the overview, we will cover the following
    topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从头开始创建一个可工作的**车辆蓝图**，使用虚幻引擎4提供的默认资产以及**车辆游戏**项目示例，以及我们将自己创建的资产。首先，我们将从概述**车辆蓝图**将包含的内容开始，然后转到创建所有方面不同蓝图的具体方法。在概述之后，我们将涵盖以下主题：
- en: Creating Vehicle Blueprints
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建车辆蓝图
- en: Editing Vehicle Blueprints
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑车辆蓝图
- en: Setting up user controls
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置用户控制
- en: Testing the vehicle
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试车辆
- en: There is a lot of content to cover in this chapter, so let's get started.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖大量内容，让我们开始吧。
- en: Vehicle Blueprint – a content overview
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 车辆蓝图 – 内容概述
- en: 'A vehicle in Unreal Engine 4 contains a number of different types of assets:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚幻引擎4中的车辆包含多种不同类型的资产：
- en: A **Skeletal Mesh**
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**骨骼网格**'
- en: A **Physics Asset**
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**物理资产**'
- en: An **Animation Blueprint**
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动画蓝图**'
- en: A **Vehicle Blueprint**
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**车辆蓝图**'
- en: One or more **Wheel Blueprints**
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个或多个**车轮蓝图**
- en: A **Tire Type Data Asset**
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轮胎类型数据资产**'
- en: 'Let''s start by creating the necessary game project so that we have access
    to a **Vehicle Skeletal Mesh** by default, and we don''t have to create our own
    in a third-party 3D modeling program. To do so, let''s open the Epic GamesUnreal
    launcher and navigate to the **Learn** tab. Here, scroll down to the **Example
    Game Projects** section and find the **Vehicle Game** project template. Select
    this project and then the **Download** option:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建必要的游戏项目，这样我们就可以默认访问**车辆骨骼网格**，而无需在第三方3D建模程序中创建自己的网格。为此，让我们打开Epic Games虚幻引擎启动器并导航到**学习**标签页。在这里，滚动到**示例游戏项目**部分并找到**车辆游戏**项目模板。选择此项目，然后选择**下载**选项：
- en: '![Vehicle Blueprint – a content overview](img/image00322.jpeg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![车辆蓝图 – 内容概述](img/image00322.jpeg)'
- en: 'Once successfully downloaded, we can create the project by navigating to the
    **Library** tab of the Unreal Engine launcher, scroll to the very bottom of the
    page to the **Vault** section, and select the **Create Project** option for **Vehicle
    Game**:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦成功下载，我们可以通过导航到虚幻引擎启动器的**库**标签页，滚动到页面底部的**保险库**部分，并选择**车辆游戏**的**创建项目**选项来创建项目：
- en: '![Vehicle Blueprint – a content overview](img/image00323.jpeg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![车辆蓝图 – 内容概述](img/image00323.jpeg)'
- en: When we select the **Create Project** option, it will ask us for a name of the
    project. Let's call this project `Vehicle_PhyProject`. After the Unreal Engine
    launcher creates the vehicle project for us, we should see it available in our
    list of projects in the **My Projects** section of the **Library** tab. Now, double-click
    on the project image to open the Unreal Engine 4 editor for this project. By default,
    this project contains all the assets necessary to create a working **Vehicle Blueprint**,
    such as a **Skeletal Mesh**, **Wheel Blueprints**, a **Vehicle Animation Blueprint**,
    and so on, but we will only use the **Skeletal Mesh** that the project provides,
    and we will create every other aspect of the **Vehicle Blueprint** from scratch
    step by step.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们选择**创建项目**选项时，它会要求我们输入项目的名称。让我们把这个项目命名为`Vehicle_PhyProject`。在虚幻引擎启动器为我们创建车辆项目之后，我们应该在我们的项目列表中看到它出现在**库**标签页的**我的项目**部分。现在，双击项目图像以打开此项目的虚幻引擎4编辑器。默认情况下，此项目包含创建一个可工作的**车辆蓝图**所需的所有资产，例如**骨骼网格**、**车轮蓝图**、**车辆动画蓝图**等等，但我们只会使用项目提供的**骨骼网格**，并且我们将从零开始逐步创建**车辆蓝图**的每个其他方面。
- en: Now that we have successfully created the **Vehicle Game Project**, feel free
    to explore some of the content that it contains and play the game in the **Desert
    Rally Race** level to see how our final result will be for this chapter. Once
    we are satisfied exploring the game project, let's begin by creating a new folder
    in **Content Browser** that will house all of our content for this chapter. First,
    navigate to **Content Browser** and highlight the **Content** folder at the very
    top of the content hierarchy in the top-left corner of the browser. Once highlighted,
    we can either right-click on the **Content** folder, select the **New Folder**
    option, or left-click on the **Add New** drop-down menu and select **New Folder**.
    Name this folder `VehicleContent`. With the folder in place, we will now navigate
    to the **Vehicles** folder, the **VH_Buggy** folder and then to the **Mesh** folder;
    this folder contains the **SK_Buggy_Vehicle Skeletal Mesh** that we need to begin
    this lesson. Let's left-click and drag the **SK_Buggy_Vehicle** asset to our **VehicleContent**
    folder and select it to create a copy. Name this copy `SK_Buggy_NewVehicle`. If
    we want to create our own **Skeletal Mesh**, here are some of the things we should
    keep in mind.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功创建了**车辆游戏项目**，请随意探索其中的一些内容，并在**沙漠拉力赛**级别中玩游戏，看看我们这一章的最终结果会怎样。一旦我们对游戏项目感到满意，让我们首先在**内容浏览器**中创建一个新的文件夹，用于存放这一章的所有内容。首先，导航到**内容浏览器**，在浏览器的左上角突出显示内容层次结构中最顶部的**内容**文件夹。一旦突出显示，我们可以在**内容**文件夹上右键单击，选择**新建文件夹**选项，或者左键单击**添加新**下拉菜单并选择**新建文件夹**。将这个文件夹命名为`VehicleContent`。有了这个文件夹，我们现在将导航到**车辆**文件夹、**VH_Buggy**文件夹，然后是**网格**文件夹；这个文件夹包含我们开始这一课所需的**SK_Buggy_Vehicle
    Skeletal Mesh**。让我们左键单击并拖动**SK_Buggy_Vehicle**资产到我们的**VehicleContent**文件夹，并选择它以创建一个副本。将这个副本命名为`SK_Buggy_NewVehicle`。如果我们想创建自己的**骨骼网格**，以下是一些我们应该注意的事项。
- en: The basic, bare minimum, art setup required to create a proper vehicle is just
    a **Skeletal Mesh**. The type of vehicle will dictate how complicated an art setup
    we will need, and special considerations may need to be given to the suspension.
    For example, a tank does not require a special suspension setup, whereas a dune
    buggy (such as the one in the **Vehicle Game** project example) will require additional
    joints to make the exposed components move in a believable way.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 创建合适的车辆所需的基本、最基本的艺术设置只是一个**骨骼网格**。车辆类型将决定我们需要多么复杂的艺术设置，并且可能需要对悬挂进行特殊考虑。例如，坦克不需要特殊的悬挂设置，而沙丘车（例如**车辆游戏**项目示例中的那种）将需要额外的关节来使暴露的部件以可信的方式移动。
- en: 'Some of the more important basic information we need to know about setting
    up our vehicle in a third-party art program (such as 3ds Max or Maya) is that
    we want the vehicle mesh to point to the positive *X* direction. Next, we will
    need to measure the radius of our wheels in centimeters for use in Unreal Engine
    4 because we had discussed earlier in this book that Unreal Engine 4 uses centimeters
    as its unit of measurement, where 1 **Unreal** **Unit** (**uu**) is equal to 1
    **centimeter** (**cm**). The minimum number of **Joints** required for a four-wheeled
    vehicle is 5:1 and 4 wheels; this will change depending on the number of wheels
    the vehicle has (remember what we discussed in [Chapter 5](part0055.xhtml#aid-1KEEU2
    "Chapter 5. Physics Damping, Friction, and Physics Bodies"), *Physics Damping,
    Friction, and Physics Bodies*). The wheel and root joints should be aligned with
    the *X* direction looking forward and the *Z* direction looking upwards. By doing
    so, this will ensure that the wheel will roll on the *Y* axis and steer on the
    *Z* axis. All the other joints can be arranged as required, but it should be noted
    that things such as **Look At** nodes for the **Animation Blueprint** assume that
    the *X* direction is forward. To prevent visual oddities, the joints for our wheels
    should be accurately centered, as shown in the following screenshot:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在设置第三方艺术程序（如3ds Max或Maya）中的车辆时需要了解的一些基本重要信息是，我们希望车辆网格指向正*X*方向。接下来，我们需要用厘米来测量我们车轮的半径，以便在虚幻引擎4中使用，因为我们之前在这本书中讨论过，虚幻引擎4使用厘米作为其度量单位，其中1
    **虚幻** **单位**（**uu**）等于1 **厘米**（**cm**）。四轮车辆所需的**关节**的最小数量是5:1和4个车轮；这将根据车辆的车轮数量而变化（记住我们在[第5章](part0055.xhtml#aid-1KEEU2
    "第5章。物理阻尼、摩擦和物理体")中讨论的内容，*物理阻尼、摩擦和物理体*）。车轮和根关节应与向前看的*X*方向和向上看的*Z*方向对齐。这样做将确保车轮将在*Y*轴上滚动并在*Z*轴上转向。所有其他关节可以按需排列，但应注意，例如，**动画蓝图**中的**Look
    At**节点假定*X*方向是向前。为了防止视觉上的不协调，我们的车轮关节应准确居中，如下面的截图所示：
- en: '![Vehicle Blueprint – a content overview](img/image00324.jpeg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![车辆蓝图 – 内容概述](img/image00324.jpeg)'
- en: The visual mesh will not be used for collision detection; however, if the wheel
    mesh is off-center, it will look as if the wheel is broken and will be really
    noticeable due to motion blur.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 视觉网格将不会用于碰撞检测；然而，如果车轮网格偏离中心，看起来就像车轮坏了，并且由于运动模糊，这将会非常明显。
- en: For binding purposes, we can use either the standard smooth bind for Maya or
    the skin modifier for 3ds Max. Wheels should only have weights on one joint so
    that they can spin free with no odd deformation. For shocks and struts, we can
    get away with some fancy skinning, but it will require more thought on the Unreal
    Engine Editor side.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于绑定目的，我们可以使用Maya的标准平滑绑定或3ds Max的皮肤修改器。车轮应该只在单个关节上有权重，这样它们可以自由旋转而不会出现奇异的变形。对于避震器和支撑杆，我们可以使用一些花哨的皮肤，但这将需要在虚幻引擎编辑器方面进行更多思考。
- en: Lastly, vehicles are simply exported as **Skeletal Meshes** with no special
    considerations when you import the asset to Unreal Engine 4.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当将资产导入虚幻引擎4时，车辆简单地以**骨骼网格**的形式导出，无需特殊考虑。
- en: 'Now that we have our own copy of the **Skeletal Mesh** vehicle, we can create
    our **Physics Asset** for this vehicle by right-clicking on **SK_Buggy_NewVehicle**
    from our **VehicleContent** folder, selecting the **Create** option from the drop-down
    menu and then **Physics Asset**. Then, name this asset `PA_Buggy_NewVehicle` and
    leave all the setup options to their default values, as shown in the following
    screenshot:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了自己的**骨骼网格**车辆副本，我们可以通过在**VehicleContent**文件夹中的**SK_Buggy_NewVehicle**上右键单击，从下拉菜单中选择**创建**选项，然后选择**物理资产**来为这辆车创建**物理资产**。然后，将此资产命名为`PA_Buggy_NewVehicle`，并将所有设置选项保留为默认值，如下面的截图所示：
- en: '![Vehicle Blueprint – a content overview](img/image00325.jpeg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![车辆蓝图 – 内容概述](img/image00325.jpeg)'
- en: 'Now, double-click on the new **Physics Asset**, and we should see something
    similar to this screenshot in **PhAT**:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，双击新的**物理资产**，我们应该在**PhAT**中看到类似下面的截图：
- en: '![Vehicle Blueprint – a content overview](img/image00326.jpeg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![车辆蓝图 – 内容概述](img/image00326.jpeg)'
- en: We obtain this result because the **Physics Asset Tool (PhAT)** in Unreal Engine
    4 attempts to wrap the vertices that are skinned to a joint as best as it can.
    **PhAT** does not currently have a way to effectively handle the recreation of
    the constraints that hold all the **Physics Bodies** together, so what we need
    to do is delete all the existing **Physics Bodies** in **Hierarchy** so that we
    can start building them from the root joint. By doing so, all of our constraints
    will be created correctly.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到这个结果是因为Unreal Engine 4中的**Physics Asset Tool (PhAT)**试图尽可能好地包裹绑定到关节上的顶点。**PhAT**目前还没有有效处理所有**Physics
    Bodies**约束重建的方法，因此我们需要删除**Hierarchy**中所有现有的**Physics Bodies**，这样我们就可以从根关节开始构建它们。通过这样做，我们所有的约束都将被正确创建。
- en: 'To do this, navigate to **Hierarchy**, press *Shift* and left-click on all
    the options, and press the *Delete* key; this will remove all the **Physics Bodies**
    from the asset:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，导航到**Hierarchy**，按*Shift*键并左键点击所有选项，然后按*Delete*键；这将从资产中移除所有**Physics Bodies**：
- en: '![Vehicle Blueprint – a content overview](img/image00327.jpeg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![车辆蓝图 – 内容概述](img/image00327.jpeg)'
- en: 'Starting with the root joint: **rootJNT**, let''s create the **Physics Bodies**
    on the joints of our vehicles. Keep in mind that we only need a **Physics Body**
    on a joint that either needs to be physically simulated or affects the bounds
    of our vehicle. For our vehicle, a box shape for the root/main body and spheres
    for each of the wheels will serve us just fine, but we will add additional **Physics
    Bodies** to get the desired behavior that we want for other parts of the vehicle
    (such as the antenna).'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 从根关节**rootJNT**开始：让我们在我们的车辆关节上创建**Physics Bodies**。请注意，我们只需要在需要物理模拟或影响车辆边界的关节上放置**Physics
    Body**。对于我们的车辆，根/主体使用盒子形状，每个轮子使用球体形状将非常适合我们，但我们将添加额外的**Physics Bodies**以获得我们想要的其他车辆部分（如天线）的行为。
- en: 'For our **Buggy Vehicle**, we will have a total of 10 **Physics Bodies**. The
    end result should look similar to the following image:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的**Buggy Vehicle**，我们将总共拥有10个**Physics Bodies**。最终结果应该类似于以下图像：
- en: '![Vehicle Blueprint – a content overview](img/image00328.jpeg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![车辆蓝图 – 内容概述](img/image00328.jpeg)'
- en: To accomplish this, we will first create the large bounding box that surrounds
    the main body of **Buggy Vehicle**. Select the **rootJNT** option from the **Hierarchy**
    panel on the right-hand side and then right-click and select the **Add Box** option.
    Make sure to use the **Translation** and **Scale** tools to shape the **Physics
    Body** box to match the shape of the body of the buggy as best as you can. Next,
    let's navigate to the **Collision** section of the **Details** panel and make
    sure that **Simulation Generates Hit Events** is set to `True`. Lastly, in the
    **Details** panel of the newly created box, **Physics Body**, make sure that **Physics
    Type** is set to `Default`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个任务，我们首先需要创建一个包围**Buggy Vehicle**主体的大边界框。从右侧的**Hierarchy**面板中选择**rootJNT**选项，然后右键点击并选择**Add
    Box**选项。确保使用**Translation**和**Scale**工具来调整**Physics Body**框的形状，使其尽可能匹配车辆的形状。接下来，让我们导航到**Details**面板的**Collision**部分，并确保**Simulation
    Generates Hit Events**设置为`True`。最后，在新创建的框的**Details**面板中，**Physics Body**，确保**Physics
    Type**设置为`Default`。
- en: 'Now, let''s create the **Physics Bodies** for the four wheels of our vehicle.
    Each **Physics Body** will be of the same size and shape, and have the same properties
    associated to them. Let''s select **F_L_wheelJNT** from the **Hierarchy** panel,
    right-click on this option, and select the **Add Sphere** option. Use the **Scale**
    and **Translation** tools to position the spherical **Physics Body** around the
    front-left wheel of the vehicle and change its **Physics Type** to **Kinematic**.
    Follow this process for the remaining three wheels: **F_R_wheelJNT**, **B_R_wheelJNT**,
    and **B_K_wheelJNT**. Lastly, let''s navigate to the **Collision** section of
    the **Details** panel for each of the four wheels and make sure that **Simulation
    Generates Hit Events** is set to `True`.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为我们的车辆的四轮创建**Physics Bodies**。每个**Physics Body**将具有相同的大小和形状，并具有与之相关的相同属性。让我们从**Hierarchy**面板中选择**F_L_wheelJNT**，右键点击此选项，并选择**Add
    Sphere**选项。使用**Scale**和**Translation**工具将球形**Physics Body**定位在车辆的前左轮周围，并将其**Physics
    Type**更改为**Kinematic**。按照此过程为剩余的三个轮子执行：**F_R_wheelJNT**、**B_R_wheelJNT**和**B_K_wheelJNT**。最后，让我们为四个轮子中的每一个导航到**Details**面板的**Collision**部分，并确保**Simulation
    Generates Hit Events**设置为`True`。
- en: '![Vehicle Blueprint – a content overview](img/image00329.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![车辆蓝图 – 内容概述](img/image00329.jpeg)'
- en: Moving on, let's now create the **Physics Bodies** for the front and back bumpers
    of the vehicle by right-clicking on **rootJNT** and selecting the **Add Sphyl**
    option, which will create a capsule-shaped **Physics Body**. Use the **Scale**
    and **Translation** tools to position this **Physics Body** around the front bumper
    of the vehicle and set its **Physics Type** to `Default`. Repeat this process
    for the back bumper of the vehicle as well. Lastly, let's navigate to the **Collision**
    section of the **Details** option for both. Make sure that **Simulation Generates
    Hit Events** is set to `True`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们通过在**rootJNT**上右键单击并选择**添加Sphyl**选项来创建车辆的正面和背面保险杠的**物理体**，这将创建一个胶囊形状的**物理体**。使用**缩放**和**平移**工具将此**物理体**定位在车辆的前保险杠周围，并将其**物理类型**设置为`默认`。同样地为车辆的背面保险杠重复此过程。最后，让我们导航到两个的**细节**选项的**碰撞**部分。确保**模拟生成碰撞事件**设置为`True`。
- en: 'Before we move on to creating the **Physics Body** for the antenna, let''s
    first create the two box shapes for the left-hand side and the right-hand side
    suspensions for the buggy. With the **rootJNT** bone joint selected in **Hierarchy**
    on the right-hand side, right-click and select the **Add Box** option. Lastly,
    let''s navigate to the **Collision** section of the **Details** panel and make
    sure that **Simulation Generates Hit Events** is set to `True`. Then, the scale
    and position of the box should look similar to the following screenshot:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建天线**物理体**之前，让我们首先为越野车的左右悬挂创建两个盒子形状。在**层次**面板的右侧选择**rootJNT**骨骼关节，右键单击并选择**添加盒子**选项。最后，让我们导航到**细节**面板的**碰撞**部分，并确保**模拟生成碰撞事件**设置为`True`。然后，盒子的缩放和位置应类似于以下截图：
- en: '![Vehicle Blueprint – a content overview](img/image00330.jpeg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![车辆蓝图 – 内容概述](img/image00330.jpeg)'
- en: Now, create an additional **Box Physics Body** and shape and transform it so
    that it covers the other side of the buggy's suspensions. Then, set both their
    **Physics Type** parameters to `Default`. Next, let's navigate to the **Collision**
    section of the **Details** panel and make sure that **Simulation Generates Hit
    Events** is set to `True`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建一个额外的**盒子物理体**，并对其进行形状和变换，使其覆盖越野车悬挂的另一侧。然后，将它们的**物理类型**参数都设置为`默认`。接下来，让我们导航到**细节**面板的**碰撞**部分，并确保**模拟生成碰撞事件**设置为`True`。
- en: 'Lastly, let''s set up the **Physics Body** for the antenna of our vehicle so
    that we can simulate a responsive antenna when we move in our vehicle. To do this,
    select the **Antenna_01** option from the **Hierarchy** panel, right-click on
    it, and select the **Add Sphyl** option. Next, set **Physics Type** to `Default`,
    and set the following parameters in the **Details** panel for our antenna''s **Physics
    Body**:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们设置我们车辆天线的**物理体**，以便在我们在车内移动时模拟一个响应式的天线。为此，从**层次**面板中选择**Antenna_01**选项，右键单击它，并选择**添加Sphyl**选项。接下来，将**物理类型**设置为`默认`，并在**细节**面板中为我们的天线**物理体**设置以下参数：
- en: '**Mass Scale**: Set this parameter to `0.01`'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**质量比例**: 将此参数设置为 `0.01`'
- en: '**Angular Damping**: Set this parameter to `10.0`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**角阻尼**: 将此参数设置为 `10.0`'
- en: '**Linear Damping**: Set this parameter to `3.0`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线性阻尼**: 将此参数设置为 `3.0`'
- en: 'To finish off the **Physics Body** for our antenna, make sure that the **Antenna_01**
    joint is selected in the **Hierarchy** panel. Then, select **Constraint Mode**
    from the **Body Mode** drop-down menu:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们天线**物理体**的设置，请确保在**层次**面板中选择了**Antenna_01**关节。然后，从**体模式**下拉菜单中选择**约束模式**：
- en: '![Vehicle Blueprint – a content overview](img/image00331.jpeg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![车辆蓝图 – 内容概述](img/image00331.jpeg)'
- en: 'While in **Constraint Mode** and with the **Antenna_01** joint selected, set
    the following parameters in the **Details Panel**:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在**约束模式**下，并且选择了**Antenna_01**关节时，在**细节面板**中设置以下参数：
- en: '**Angular Swing 1 Motion**: Set this parameter to `Limited`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**角摆动1运动**: 将此参数设置为 `Limited`'
- en: '**Angular Twist Motion**: Set this parameter to `Locked`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**角扭曲运动**: 将此参数设置为 `Locked`'
- en: '**Angular Swing 2 Motion**: Set this parameter to `Limited`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**角摆动2运动**: 将此参数设置为 `Limited`'
- en: '**Swing 1 Limit** **Angle**: Set this parameter to `1.0`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**摆动1限制** **角度**: 将此参数设置为 `1.0`'
- en: '**Swing 2 Limit Angle**: Set this parameter to `1.0`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**摆动2限制角度**: 将此参数设置为 `1.0`'
- en: '**Swing Limit Stiffness**: Set this parameter to `500.0`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**摆动限制刚度**: 将此参数设置为 `500.0`'
- en: '**Swing Limit Damping**: Set this parameter to `50.0`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**摆动限制阻尼**: 将此参数设置为 `50.0`'
- en: 'With these changes in place, let''s return to **Body Mode**, select **rootJNT**
    from the **Hierarchy** panel and then the **Selected Simulation** option, and
    select **Simulate** to see how our **Physics Bodies** are affected by the gravity
    of simulation:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些更改到位后，让我们回到**车身模式**，从**层次结构**面板中选择**rootJNT**，然后选择**所选模拟**选项，并选择**模拟**来查看我们的**物理体**如何受到模拟重力的作用：
- en: '![Vehicle Blueprint – a content overview](img/image00332.jpeg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![车辆蓝图 - 内容概述](img/image00332.jpeg)'
- en: We can see that the wheels rotate in a strange manner that don't make too much
    sense in the context of a working vehicle for a racing game, but we will change
    this behavior later when we create the blueprints for the vehicle.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，车轮以奇怪的方式旋转，这在赛车游戏的工作车辆背景下并不太合理，但当我们为车辆创建蓝图时，我们会改变这种行为。
- en: Vehicle Blueprints – a section overview
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 车辆蓝图 - 概述部分
- en: In this section, we discussed the necessary components that make up a working
    **Vehicle Blueprint**, and we looked at the necessary details of how to create
    the **Physics Bodies** for our vehicle. Lastly, we used **PhAT** in Unreal Engine
    4 to recreate the necessary **Physics Body** components of the **Buggy Vehicle**
    to establish a working **Physical Body** for the vehicle. Now that we have created
    the **Physics Asset** from the premade **Skeletal Mesh** that is created by default
    when working with the **VehicleGame** project, we can now move on and work on
    **Vehicle Blueprints**.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了构成一个工作**车辆蓝图**的必要组件，并查看了我们车辆创建**物理体**的必要细节。最后，我们使用Unreal Engine 4中的**PhAT**重新创建了**越野车**的必要**物理体**组件，为车辆建立了一个工作的**物理体**。现在，我们已经从默认创建的**骨骼网格**中创建了**物理资产**，我们可以继续工作，创建**车辆蓝图**。
- en: Creating the Vehicle Blueprints
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建车辆蓝图
- en: To create a new **Vehicle Blueprint**, let's first navigate to our **VehicleContent**
    folder in **Content Browser** and then right-click on an area that is empty. From
    the context drop-menu, we will select the **Blueprint Class** option, click on
    the drop-down **All Classes** menu, search for the **WheeledVehicle Pawn** class,
    and name this blueprint `BP_NewVehicle`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的**车辆蓝图**，让我们首先导航到**内容浏览器**中的**VehicleContent**文件夹，然后在一个空白区域右键单击。从上下文菜单中，我们将选择**蓝图类**选项，点击**所有类**下拉菜单，搜索**WheeledVehicle
    Pawn**类，并将此蓝图命名为`BP_NewVehicle`。
- en: '![Creating the Vehicle Blueprints](img/image00333.jpeg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![创建车辆蓝图](img/image00333.jpeg)'
- en: The **WheeledVehicle Pawn** blueprint contains an inherited component called
    **VehicleMovement**. This component allows you to have more control over the wheels
    and the overall behavior for the vehicle.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**WheeledVehicle Pawn**蓝图包含一个继承的组件，称为**VehicleMovement**。此组件允许您对车轮和车辆的整体行为有更多的控制。'
- en: Next, we will need to create two different types of **Wheel Blueprints** for
    our vehicle (one for the front wheels and one for the back wheels). To get this
    going, let's navigate to the **VehicleContent** folder in **Content Browser**,
    right-click on an area of **Content Browser** that is empty, and select the **Blueprint
    Class** option. Now, in the context sensitive drop-down menu, enter `Vehicle Wheel`
    to locate the **VehicleWheel Blueprint Object** class. We will create two different
    **VehicleWheel Blueprint** classes (one named `BP_FrontWheel` and another named
    `BP_BackWheel`).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要为我们的车辆创建两种不同类型的**车轮蓝图**（一个用于前轮，一个用于后轮）。为了开始这个过程，让我们导航到**内容浏览器**中的**VehicleContent**文件夹，在**内容浏览器**的一个空白区域右键单击，并选择**蓝图类**选项。现在，在上下文相关下拉菜单中，输入`Vehicle
    Wheel`以定位**VehicleWheel 蓝图对象**类。我们将创建两个不同的**VehicleWheel 蓝图**类（一个命名为`BP_FrontWheel`，另一个命名为`BP_BackWheel`）。
- en: 'In most cases, we will want to have at least two wheel types: that is, one
    wheel type that is affected by steering and another that is affected by the vehicle
    handbrake. Additionally, we can set differing radii, mass, width, handbrake effect,
    suspension, and many other properties to give our vehicle the handling we desire.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，我们希望至少有两种车轮类型：也就是说，一种受转向影响的车轮类型，另一种受车辆手刹影响的车轮类型。此外，我们可以设置不同的半径、质量、宽度、手刹效果、悬挂以及许多其他属性，以赋予我们的车辆所需的操控性。
- en: 'Now, we can move on and create the **TireType** data asset that we will need
    for our **VehicleWheel** blueprint. To create a new **TireType** data asset in
    **Content Browser**, we need to right-click on an area of the **VehicleContent**
    folder that is empty, select the **Miscellaneous** option and then the **TireType**
    option from the context sensitive drop-down menu that appears:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续创建我们需要的**TireType**数据资产，用于我们的**VehicleWheel**蓝图。要在**内容浏览器**中创建新的**TireType**数据资产，我们需要在**VehicleContent**文件夹的空白区域右键单击，选择**杂项**选项，然后从出现的上下文相关下拉菜单中选择**TireType**选项：
- en: '![Creating the Vehicle Blueprints](img/image00334.jpeg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![创建车辆蓝图](img/image00334.jpeg)'
- en: 'Let''s name this asset `DA_TireType` and then right-click onthe asset to open
    **Generic Asset Editor**. The **TireType** data asset has only one single value:
    **Friction Scale**. This value not only affects the raw friction of the wheel,
    but also scales the value for how difficult or easy it is for a wheel to slide
    during a hard turn. There is a property slot in the **VehicleWheel** blueprint
    for the **TireType** data asset that we will use once the time comes.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把这个资产命名为`DA_TireType`，然后右键单击该资产以打开**通用资产编辑器**。**TireType**数据资产只有一个单一值：**摩擦系数**。这个值不仅影响车轮的原始摩擦力，还根据车轮在急转弯时滑动难度或容易程度来缩放值。在**VehicleWheel**蓝图中有**TireType**数据资产的属性槽，我们将在需要时使用它。
- en: 'Lastly, we have to create the **Animation** blueprint. We will use this to
    animate our **Buggy Vehicle**. To do this, navigate to **Content Browser** and
    then go to the **VehicleContent** folder. Now, in an empty area, right-click and
    select the **Animation** option from the drop-down menu and then select **Animation
    Blueprint**:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须创建**动画**蓝图。我们将使用它来动画化我们的**越野车**。为此，导航到**内容浏览器**，然后转到**VehicleContent**文件夹。现在，在空白区域右键单击，从下拉菜单中选择**动画**选项，然后选择**动画蓝图**：
- en: '![Creating the Vehicle Blueprints](img/image00335.jpeg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![创建车辆蓝图](img/image00335.jpeg)'
- en: When we first create an **Animation Blueprint**, it will ask us for a **Target
    Skeleton** to use; we will select the **SK_Buggy_Vehicle_Skeleton** option from
    the **Target Skeleton** drop-down list. We also want to make sure that we select
    the **VehicleAnimInstance** option from the **Parent** **Class** context sensitive
    drop-down list and name this animation blueprint `BP_VehicleAnimation`. Before
    we move on and discuss how to edit the different blueprints and data assets we
    created to complete our vehicle, let's briefly discuss what animation blueprints
    are.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们首次创建**动画蓝图**时，它会要求我们选择要使用的**目标骨骼**；我们将从**目标骨骼**下拉列表中选择**SK_Buggy_Vehicle_Skeleton**选项。我们还想要确保从**父****类**上下文相关下拉列表中选择**VehicleAnimInstance**选项，并将此动画蓝图命名为`BP_VehicleAnimation`。在我们继续讨论如何编辑我们创建的不同蓝图和数据资产以完成我们的车辆之前，让我们简要讨论一下动画蓝图是什么。
- en: An **Animation Blueprint** is a specialized blueprint that contains graphs used
    to control the animation of a skeletal mesh. It can perform blending of animations,
    has direct control of the bones in a skeleton, and outputs a final pose for our
    skeletal mesh in each frame. The **Controller** directs the pawn or character
    to move based on the player input or decisions made based on what the game play
    dictates. Each pawn has a **Skeletal Mesh** component that references the **Skeletal
    Mesh** to animate and has an instance of an **Animation Blueprint**.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**动画蓝图**是一种特殊的蓝图，其中包含用于控制骨骼网格动画的图表。它可以执行动画混合，直接控制骨骼中的骨骼，并在每一帧输出我们骨骼网格的最终姿态。**控制器**根据玩家输入或基于游戏玩法做出的决策来指导兵或角色移动。每个兵都有一个**骨骼网格**组件，该组件引用用于动画的**骨骼网格**，并有一个**动画蓝图**的实例。'
- en: Through the use of its two graphs, the **Animation Blueprint** can access properties
    of the owning pawn, compute the values used for blending, state transitions, or
    driving **Anim Montages**, and can calculate the current pose of the skeletal
    mesh based on the blending of animation sequences and direct transformations of
    the skeleton from **Skeletal Controls**. When we work with animation blueprints,
    we have to keep in mind that there are two main components that work in correlation
    with one another to create the final animation for each frame. One is **Event
    Graph** that we can recognize from other blueprints. This is in charge of performing
    updates to values that can be used in **Anim Graph** to drive **State Machines**,
    **Blend Spaces**, or other nodes that allows you to blend between multiple animation
    sequences or poses that fire off notifications to other systems, thereby enabling
    dynamically-driven animation effects to take place.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用其两个图，**动画蓝图**可以访问拥有者的属性，计算用于混合、状态转换或驾驶**动画蒙太奇**的值，并可以根据动画序列的混合和从**骨骼控制**的直接变换来计算骨骼网格的当前姿态。当我们处理动画蓝图时，我们必须记住有两个主要组件相互关联以创建每帧的最终动画。一个是我们可以从其他蓝图识别出的**事件图**。它负责更新可以在**动画图**中使用的值，以驱动**状态机**、**混合空间**或其他允许你在多个动画序列或姿态之间混合的节点，从而实现动态驱动的动画效果。
- en: There is one **Event Graph** in every **Animation Blueprint** that uses a collection
    of special animation-based events to initiate sequences of actions. The most common
    use of **Event Graph** is to update the values used by **Blend Spaces** and other
    blend nodes to drive animations in the **Anim Graph**.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 每个**动画蓝图**中都有一个**事件图**，它使用一组特殊的基于动画的事件来启动一系列动作。**事件图**最常见的使用是更新**混合空间**和其他混合节点使用的值，以驱动**动画图**中的动画。
- en: The **Anim Graph** is used to evaluate the final pose of a skeletal mesh for
    the current frame. By default, each **Animation Blueprint** has an **Anim Graph**.
    This graph can contain animation nodes that are placed in it to sample animation
    sequences, perform animation blends, or control bone transformations using **Skeletal
    Controls**. The resulting pose is then applied to our **Skeletal Mesh** for each
    frame in the game.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**动画图**用于评估当前帧骨骼网格的最终姿态。默认情况下，每个**动画蓝图**都有一个**动画图**。此图可以包含放置其中的动画节点，用于采样动画序列、执行动画混合或使用**骨骼控制**来控制骨骼变换。然后，将得到的姿态应用于游戏中每一帧的**骨骼网格**。'
- en: '![Creating the Vehicle Blueprints](img/image00336.jpeg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![创建车辆蓝图](img/image00336.jpeg)'
- en: Creating the Vehicle Blueprints – a section review
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建车辆蓝图 – 一节回顾
- en: In this section, we looked at the necessary blueprints and data assets. We will
    move on and edit their properties to obtain the behaviors we need for our working
    **Buggy Vehicle**. First, we created the **WheeledVehicle** blueprint. This is
    the main blueprint for our vehicle. Then, we created two types of **Wheel Blueprints**
    (one for our front wheels and another for our back wheels). Further, we created
    the **TireType** data asset. This is necessary to control the **Friction** property
    for our wheels. Lastly, we created our animation blueprint for the **Buggy** skeletal
    mesh, and we discussed about **Animation Blueprints** and its functionalities
    in detail. Now that we have created the necessary blueprint and data assets for
    our vehicle, we can move on and edit the properties of these assets.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了必要的蓝图和数据资产。我们将继续编辑它们的属性，以获得我们为工作**越野车**所需的**行为**。首先，我们创建了**WheeledVehicle**蓝图。这是我们的车辆的主要蓝图。然后，我们创建了两种类型的**轮蓝图**（一个用于我们的前轮，另一个用于我们的后轮）。此外，我们创建了**TireType**数据资产。这是控制我们车轮的**摩擦**属性所必需的。最后，我们为**越野车**骨骼网格创建了动画蓝图，并详细讨论了**动画蓝图**及其功能。现在我们已经为我们的车辆创建了必要的蓝图和数据资产，我们可以继续编辑这些资产的属性。
- en: Editing the Vehicle Blueprints
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编辑车辆蓝图
- en: 'With the vehicle blueprints created, let''s now move on and edit the properties
    of these blueprints in order to obtain the behaviors we want for our vehicle.
    We will begin by working with the **BP_VehicleAnimation** blueprint by double-clicking
    on our **Content Browser** and opening its **Anim Graph**; which opens by default.
    The first node we will create is the **Mesh Space Ref Pose** node, and this is
    used to return the mesh space reference pose for our skeletal mesh in the **Animation
    Blueprint**. To create this node, right-click on an area of the **Anim Graph**
    that is empty. Now, from the context menu, we will search for the **Mesh Space
    Ref Pose** node:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了车辆蓝图之后，我们现在继续并编辑这些蓝图的属性，以便获得我们想要的车辆行为。我们将通过双击**Content Browser**并打开其**Anim
    Graph**来开始与**BP_VehicleAnimation**蓝图一起工作；它默认打开。我们将创建的第一个节点是**Mesh Space Ref Pose**节点，它用于返回**Animation
    Blueprint**中骨骼网格的网格空间参考姿态。要创建此节点，在**Anim Graph**上的空白区域右键单击。现在，从上下文菜单中，我们将搜索**Mesh
    Space Ref Pose**节点：
- en: '![Editing the Vehicle Blueprints](img/image00337.jpeg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![编辑车辆蓝图](img/image00337.jpeg)'
- en: 'Next, we will need a **Wheel Handler** node. This is used to alter the wheel
    transformation based on the setup in the **Wheeled Vehicle** blueprint; keep in
    mind that this will only work when the owner is of the **Wheeled Vehicle** class.
    The **Wheel Handler** node also handles the animation needs of our wheels, such
    as the spinning, the steering, the handbrake, and the suspension. There is no
    additional setup required; this node obtains all the necessary information from
    the wheels and transforms it into animation on the bone that the wheel is associated
    with. To create the **Wheel Handler** node in the **Anim Graph** of our **Vehicle
    Animation** blueprint, we need to right-click on an area of the graph that is
    empty. Then, from the context-sensitive menu, we can search for **Wheel Handler**.
    Finally, we can connect the **Component Pose** output of the **Mesh Space Ref
    Pose** node to the **Component Pose** input of **Wheel Handler**, as shown in
    the following screenshot:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个**Wheel Handler**节点。这个节点用于根据**Wheeled Vehicle**蓝图中的设置更改车轮变换；请注意，这仅在拥有**Wheeled
    Vehicle**类的所有者时才会生效。**Wheel Handler**节点还处理车轮的动画需求，例如旋转、转向、手刹和悬挂。不需要额外的设置；此节点从车轮获取所有必要的信息，并将其转换为与车轮关联的骨骼上的动画。要在我们的**Vehicle
    Animation**蓝图中的**Anim Graph**中创建**Wheel Handler**节点，我们需要在图上的空白区域右键单击。然后，从上下文菜单中，我们可以搜索**Wheel
    Handler**。最后，我们可以将**Mesh Space Ref Pose**节点的**Component Pose**输出连接到**Wheel Handler**的**Component
    Pose**输入，如图下截图所示：
- en: '![Editing the Vehicle Blueprints](img/image00338.jpeg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![编辑车辆蓝图](img/image00338.jpeg)'
- en: 'Unless we have additional struts or other suspension needs, we would connect
    the **Component Pose** output of the **Wheeler Handler** node to the **Result**
    output node of the **Final Animation Pose**; if we do this, a **Component to Local**
    node will automatically be generated between the **Wheel Handler** and the **Final
    Animation Pose** nodes so that it can convert **Component Space Pose** to **Local
    Space Pose**. As our **Vehicle Physics Asset** and **Vehicle Skeletal Mesh** contain
    bones for the vehicle suspension, we will want to create additional nodes to handle
    the joints that affect the suspension polygons. To do this, pull the output of
    the **Wheel Handler** node and use the context-sensitive drop-down menu; we will
    search for the **Look At** node. In the **Details** panel under the **Skeletal
    Control** section of the **Look At** node, we will want to edit the **Bone to
    Modify** and **Look at Bone** properties so that we can modify the four bones
    we have on our vehicle''s skeletal mesh, and we have the **Look at Bone** look
    at our wheel joints. Let''s create four different **Look At** nodes and set each
    individual property for the **Bone to Modify** and **Look at Bone** settings:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 除非我们还需要额外的支撑或其他悬挂需求，否则我们会将**Wheeler Handler**节点的**Component Pose**输出连接到**Final
    Animation Pose**的**Result**输出节点；如果我们这样做，将在**Wheel Handler**和**Final Animation
    Pose**节点之间自动生成一个**Component to Local**节点，以便它可以将**Component Space Pose**转换为**Local
    Space Pose**。由于我们的**Vehicle Physics Asset**和**Vehicle Skeletal Mesh**包含车辆悬挂的骨骼，我们将需要创建额外的节点来处理影响悬挂多边形的关节。为此，从**Wheel
    Handler**节点的输出拉出，并使用上下文相关下拉菜单；我们将搜索**Look At**节点。在**Look At**节点的**Skeletal Control**部分下的**Details**面板中，我们将想要编辑**Bone
    to Modify**和**Look at Bone**属性，以便我们可以修改我们车辆骨骼网格上的四个骨骼，并且让**Look at Bone**观察我们的车轮关节。让我们创建四个不同的**Look
    At**节点，并为每个**Bone to Modify**和**Look at Bone**设置设置单独的属性：
- en: 'First node:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个节点：
- en: '**Bone to Modify**: Select this property as `F_L_Suspension`'
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**要修改的骨骼**: 选择此属性为`F_L_Suspension`'
- en: '**Look at Bone**: Select this property as `F_L_wheelJNT`'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**看向骨骼**: 选择此属性为`F_L_wheelJNT`'
- en: 'Second node:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个节点：
- en: '**Bone to Modify**: Select this property as `F_R_Suspension`'
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**要修改的骨骼**: 选择此属性为`F_R_Suspension`'
- en: '**Look at Bone**: Select this property as `F_R_wheelJNT`'
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**看向骨骼**: 选择此属性为`F_R_wheelJNT`'
- en: 'Third node:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三个节点：
- en: '**Bone to Modify**: Select this property as `B_R_Suspension`'
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**要修改的骨骼**: 选择此属性为`B_R_Suspension`'
- en: '**Look at Bone**: Select this property as `B_R_wheelJNT`'
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**看向骨骼**: 选择此属性为`B_R_wheelJNT`'
- en: 'Fourth node:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第四个节点：
- en: '**Bone to Modify**: Select this property as `B_L_Suspension`'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**要修改的骨骼**: 选择此属性为`B_L_Suspension`'
- en: '**Look at Bone**: Select this property as `B_L_wheelJNT`'
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**看向骨骼**: 选择此属性为`B_L_wheelJNT`'
- en: 'With the four **Look At** nodes in place, we can now connect the output of
    the last **Look At** node to the **Result** input node of the **Final Animation
    Pose** node. Our final **Vehicle Animation** blueprint should look similar to
    the following screenshot:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在放置了四个**看向**节点后，我们现在可以将最后一个**看向**节点的输出连接到**最终动画姿态**节点的**结果**输入节点。我们的最终**车辆动画**蓝图应类似于以下截图：
- en: '![Editing the Vehicle Blueprints](img/image00339.jpeg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![编辑车辆蓝图](img/image00339.jpeg)'
- en: With these nodes in place, we are done with the **Vehicle Animation** blueprint.
    We can now move on and edit our **Tire** data asset.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些节点就位后，我们就完成了**车辆动画**蓝图。现在我们可以继续前进并编辑我们的**轮胎**数据资产。
- en: 'Similar to what we have discussed earlier, the **Tire** data asset only has
    one property value to edit: **Friction Scale**. Let''s navigate back to **Content
    Browser** and to our **VehicleContent** folder. Now, we double-click on the **DA_Tire
    Tire Type** asset. In the **Generic Asset Editor**, let''s change the **Friction
    Scale** property from its default value of `1.0` to a new value of `2.0`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前讨论的类似，**轮胎**数据资产只有一个属性值可以编辑：**摩擦比例**。让我们导航回**内容浏览器**到我们的**VehicleContent**文件夹。现在，我们双击**DA_Tire
    Tire Type**资产。在**通用资产编辑器**中，我们将**摩擦比例**属性从默认值`1.0`更改为新值`2.0`：
- en: '![Editing the Vehicle Blueprints](img/image00340.jpeg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![编辑车辆蓝图](img/image00340.jpeg)'
- en: With this change to our **Tire** data asset in place, we can now move on and
    edit our **Wheel** blueprints. Navigate back to **Content Browser** and to our
    **VehicleContent** folder so that we can double-click our **BP_BackWheel** blueprint
    and edit its properties. As discussed previously, the properties of the front
    and back wheels will vary slightly because the front wheels will be responsible
    for steering, whereas the back wheels will be responsible for responding to the
    handbrake.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的**轮胎**数据资产中的此更改到位后，我们现在可以继续前进并编辑我们的**车轮**蓝图。导航回**内容浏览器**到我们的**VehicleContent**文件夹，以便我们可以双击我们的**BP_BackWheel**蓝图并编辑其属性。如前所述，前轮和后轮的属性会有所不同，因为前轮将负责转向，而后轮将负责响应手刹。
- en: 'The properties that we need to initially set are as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要最初设置的属性如下：
- en: '**Shape Radius**: This property determines the radius of the shape used for
    the vehicle wheel.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**形状半径**: 此属性确定用于车辆轮胎的形状半径。'
- en: '**Shape Width**: This property determines the width of the shape used for the
    vehicle wheel.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**形状宽度**: 此属性确定用于车辆轮胎的形状宽度。'
- en: '**Affected by Handbrake**: This property determines whether or not the wheel
    is affected by the handbrake that the player uses to stop the vehicle. This parameter
    is typically used for back wheels only, not for the front wheels.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**受手刹影响**: 此属性确定车轮是否受玩家用于停止车辆的**手刹**影响。此参数通常仅用于后轮，不用于前轮。'
- en: '**Steer Angle**: This specifies the maximum angle that the wheel can rotate
    in both the positive and negative directions, that is, turning left and right.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**转向角度**: 这指定了车轮在正负方向上可以旋转的最大角度，即向左和向右转向。'
- en: '**Tire Type**: This property determines the **TireType** data asset that the
    wheel will use for its **Friction Scale** property.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轮胎类型**: 此属性确定车轮将用于其**摩擦比例**属性的**TireType**数据资产。'
- en: 'The **Shape Radius** and **Shape Width** properties are determined by the size
    of the wheels, and in this specific case, these are the back wheels on our vehicle,
    so for these settings, let''s set the following parameters:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**形状半径**和**形状宽度**属性由车轮的大小决定，在这个特定案例中，这些是我们车辆的后轮，因此对于这些设置，让我们设置以下参数：'
- en: '**Shape Radius**: Set this parameter as `57.0`'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**形状半径**: 将此参数设置为`57.0`'
- en: '**Shape Width**: Set this parameter as `30.0`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**形状宽度**: 将此参数设置为`30.0`'
- en: Again, keep in mind that these values will change depending on the vehicle being
    used and the size of the wheels. Next, we will need to change the value of the
    **Steer Angle** property. As we will work with the **BP_BackWheel Wheel** blueprint,
    and the back wheel will not control the steering; we will set the **Steer Angle**
    property from its default value of `70.0` to a value of `0.0`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，这些值将根据使用的车辆和车轮的大小而变化。接下来，我们需要更改**Steer Angle**属性的值。由于我们将使用**BP_BackWheel
    Wheel**蓝图，后轮不会控制转向；我们将**Steer Angle**属性从其默认值`70.0`更改为`0.0`。
- en: Moving on, we need to make sure that the **BP_BackWheel Wheel** blueprint has
    the **Affected by Handbrake** property set to `True` so that these wheels are
    affected when the player uses the brakes of the vehicle to slow it down and allow
    it to stop. Lastly, we need to set **Tire Type** from its default value of `DefaultTireType`
    to `DA_Tire` from the drop-down menu so that this **Tire Type** is used by our
    **BP_BackWheel**.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要确保**BP_BackWheel Wheel**蓝图中的**Affected by Handbrake**属性设置为`True`，这样当玩家使用车辆的刹车来减速并使其停止时，这些车轮才会受到影响。最后，我们需要从下拉菜单中将**Tire
    Type**从其默认值`DefaultTireType`更改为`DA_Tire`，以便我们的**BP_BackWheel**使用此**Tire Type**。
- en: '![Editing the Vehicle Blueprints](img/image00341.jpeg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![Editing the Vehicle Blueprints](img/image00341.jpeg)'
- en: 'Now that we have completed the **BP_BackWheel** blueprint, let''s navigate
    back to **Content Browser** and to our **VehicleContent** folder and then double-click
    and open the **BP_FrontWheel** blueprint. If we take a look at the skeletal mesh
    for our vehicle, we will see that the back wheels are slightly larger than the
    front wheels; this will be important when you set the values for the **Shape Radius**
    and **Shape Width** parameters of the **BP_FrontWheel** blueprint. Set the following
    values for the **Shape Radius** and **Shape Width** properties:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了**BP_BackWheel**蓝图，让我们导航回**Content Browser**和我们的**VehicleContent**文件夹，然后双击并打开**BP_FrontWheel**蓝图。如果我们查看我们车辆的骨骼网格，我们会看到后轮略大于前轮；当你设置**BP_FrontWheel**蓝图的**Shape
    Radius**和**Shape Width**参数的值时，这将很重要。为**Shape Radius**和**Shape Width**属性设置以下值：
- en: '**Shape Radius**: Set this parameter to `52.0`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Shape Radius**：将此参数设置为`52.0`'
- en: '**Shape Width**: Set this parameter to `23.0`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Shape Width**：将此参数设置为`23.0`'
- en: We can see that the shape radius is only 5 units less than the **BP_BackWheel**
    value and the shape width is only 7.0 units less; this is the difference in **Unreal
    Units** (**uu**) between the two types of wheels.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，形状半径比**BP_BackWheel**值小5个单位，形状宽度只小7.0个单位；这是两种类型车轮之间的**Unreal Units**（**uu**）差异。
- en: As we will work with the **BP_FrontWheel** blueprint, we will want to uncheck
    the **Affected by Handbrake** property so that it is `False` because the front
    wheels of our vehicle should not react at all to the handbrake. Before we set
    the **Steer Angle** parameter, we have to understand that this angle is the max
    angle that the wheel can rotate in both the positive and negative directions,
    that is, turning left and right. For our **Buggy Vehicle**, any value between
    `50` and `60` works best, but for the sake of providing a value for testing purposes,
    let's set the **Steering Angle** value to `55`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用**BP_FrontWheel**蓝图，我们希望取消选中**Affected by Handbrake**属性，使其为`False`，因为我们的车辆的前轮不应对手刹有任何反应。在我们设置**Steer
    Angle**参数之前，我们必须理解这个角度是车轮在正负方向上可以旋转的最大角度，即向左和向右转动。对于我们的**Buggy Vehicle**，任何在`50`到`60`之间的值都最佳，但为了测试目的提供一个值，让我们将**Steering
    Angle**值设置为`55`。
- en: Last but not least, let's make sure that the **TireType** parameter is using
    our **DA_Tire** data asset.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，让我们确保**TireType**参数正在使用我们的**DA_Tire**数据资产。
- en: '![Editing the Vehicle Blueprints](img/image00342.jpeg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![Editing the Vehicle Blueprints](img/image00342.jpeg)'
- en: 'Before we move on to editing the **BP_NewVehicle Vehicle** blueprint, let''s
    take some time here to briefly define some of the parameters of our **Wheel**
    blueprints that we didn''t edit so that we have a better understanding of the
    overall functionality of the **Wheel** blueprint. Here are the additional properties
    we can manipulate for our **Wheel** blueprint for further customization:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续编辑**BP_NewVehicle Vehicle**蓝图之前，让我们在这里花些时间简要定义一些我们没有编辑的**Wheel**蓝图参数，以便我们更好地理解**Wheel**蓝图的总体功能。以下是我们可以操纵的**Wheel**蓝图附加属性，以进行进一步定制：
- en: '**Lat Stiff Max Load**: This is the maximum normalized tire load, in which
    the tire can deliver no more lateral (sideways) stiffness, irrespective of how
    much extra load is applied to the tire.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**横向刚度最大载荷**：这是最大标准化轮胎载荷，在此载荷下，轮胎无法提供更多的横向（侧向）刚度，无论施加多少额外的载荷到轮胎上。'
- en: '**Lat Stiff Value**: This determines how much lateral stiffness can be given
    to the lateral slip.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**横向刚度值**：这决定了可以给予横向滑移多少横向刚度。'
- en: '**Long Stiff Value**: This determines how much longitudinal stiffness can be
    given to the longitudinal slip.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**纵向刚度值**：这决定了可以给予纵向滑移多少纵向刚度。'
- en: '**Suspension Force Offset**: This is the vertical offset from the vehicle center
    of mass where suspension forces are applied.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**悬挂力偏移**：这是悬挂力作用在车辆质心垂直偏移的位置。'
- en: '**Suspension Max Raise**: This value determines how far the wheel can go above
    its resting position.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**悬挂最大提升**：此值决定了车轮可以高于其静止位置多远。'
- en: '**Suspension Max Drop**: This value determines how far the wheel can go below
    its resting position.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**悬挂最大下降**：此值决定了车轮可以低于其静止位置多远。'
- en: '**Suspension Natural Frequency**: This determines the oscillation frequency
    of suspension; most cars have values between `5` and `10`.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**悬挂自然频率**：这决定了悬挂的振荡频率；大多数汽车的值在`5`到`10`之间。'
- en: '**Suspension Damping Ratio**: This value is the rate at which energy is dissipated
    from the spring of the vehicle. Most cars have values between `0.8` and `1.2`;
    values less than `1` are more sluggish, whereas values greater than `1` is twitchier.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**悬挂阻尼比**：此值是车辆弹簧能量耗散的速率。大多数汽车的值在`0.8`到`1.2`之间；小于`1`的值更迟钝，而大于`1`的值更易抽搐。'
- en: '**Max Brake Torque**: This sets the maximum brake torque of our vehicle in
    **Newton** **Meters** (**Nm**).'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最大制动力矩**：这设置了我们车辆的制动力矩最大值，单位为牛顿米（Nm）。'
- en: '**Max Hand** **Brake Torque**: This property sets the maximum handbrake torque
    for this wheel in Nm. A handbrake should have a stronger brake torque than the
    brake. This will be ignored for wheels that are not affected by the handbrake.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最大手刹制动力矩**：此属性设置了此车轮的最大手刹制动力矩，单位为Nm。手刹应该比制动器具有更强的制动力矩。对于不受手刹影响的车轮，此值将被忽略。'
- en: Now that we have a better understanding of **Wheel Blueprints**, let's move
    on to our **Vehicle Blueprint**. Navigate back to **Content Browser** and to our
    **VehicleContent** folder. Let's double-click on **BP_NewVehicle** and focus on
    the **Details** panel when we select the **Mesh (Inherited)** component from the
    **Components** tab in the top-left corner of our blueprint. Keep in mind that
    we need to click on the **Open Full** blueprint editor before viewing the **Viewport**,
    **Construction Script**, and **Event Graph** tabs in the blueprint.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对**车轮蓝图**有了更好的理解，让我们继续到我们的**车辆蓝图**。导航回**内容浏览器**到我们的**VehicleContent**文件夹。双击**BP_NewVehicle**，并从蓝图左上角的**组件**选项卡中选择**网格（继承）**组件时，关注**详细信息**面板。请注意，在查看蓝图中的**视口**、**构造脚本**和**事件图**选项卡之前，我们需要点击**打开完整**蓝图编辑器。
- en: The first thing we will do is select the **Mesh (Inherited)** component in the
    **Components** tab. Then, in its **Details** panel, we will change the **Anim
    Blueprint Generated Class** property and the **Skeletal Mesh** property. For the
    **Anim Blueprint Generated Class** property, we want to ensure that our `BP_VehicleAnimation`
    blueprint is selected from the context-sensitive drop-down menu; we do this because
    we want our vehicle to use the animation blueprint that we set up earlier. For
    the **Skeletal Mesh** property, we will use the `SK_Buggy_NewVehicle` skeletal
    mesh that we made a copy of in the **VehicleContent** folder. With these properties
    in place, we can now edit the parameters of the **VehicleMovement (Inherited)**
    component, where we will implement the **Wheel Blueprints** for our vehicle.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将要做的是在**组件**选项卡中选择**网格（继承）**组件。然后，在其**详细信息**面板中，我们将更改**动画蓝图生成类**属性和**骨骼网格**属性。对于**动画蓝图生成类**属性，我们希望确保从上下文相关的下拉菜单中选择我们的`BP_VehicleAnimation`蓝图；我们这样做是因为我们希望我们的车辆使用我们之前设置的动画蓝图。对于**骨骼网格**属性，我们将使用在**VehicleContent**文件夹中复制的`SK_Buggy_NewVehicle`骨骼网格。有了这些属性，我们现在可以编辑**车辆运动（继承）**组件的参数，我们将在此处实现车辆的**车轮蓝图**。
- en: 'Select the **VehicleMovement (Inherited)** component from the **Components**
    tab. Then, in its **Details** panel, let''s find the **Wheel Setups** parameters,
    where we can set **Wheel Class** and **Bone Names** that we want to use for each
    individual wheel for our vehicle. In the **Wheel Setups** section, set the following
    parameters for the four wheels:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 从**组件**选项卡中选择**VehicleMovement (Inherited)**组件。然后，在其**细节**面板中，让我们找到**轮子设置**参数，在那里我们可以为车辆中的每个单独的轮子设置我们想要使用的**轮子类别**和**骨骼名称**。在**轮子设置**部分，为四个轮子设置以下参数：
- en: '**Wheel 0**:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**轮子 0**:'
- en: '**Wheel Class**: Set this parameter to `BP_FrontWheel`'
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轮子类别**：将此参数设置为`BP_FrontWheel`'
- en: '**Bone Name**: Set this parameter to `F_L_wheelJNT`'
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**骨骼名称**：将此参数设置为`F_L_wheelJNT`'
- en: '**Wheel 1**:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**轮子 1**:'
- en: '**Wheel Class**: Set this parameter to `BP_FrontWheel`'
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轮子类别**：将此参数设置为`BP_FrontWheel`'
- en: '**Bone Name**: Set this parameter to `F_R_wheelJNT`'
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**骨骼名称**：将此参数设置为`F_R_wheelJNT`'
- en: '**Wheel 2**:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**轮子 2**:'
- en: '**Wheel Class**: Set this parameter to `BP_BackWheel`'
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轮子类别**：将此参数设置为`BP_BackWheel`'
- en: '**Bone Name**: Set this parameter to `B_L_wheelJNT`'
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**骨骼名称**：将此参数设置为`B_L_wheelJNT`'
- en: '**Wheel 3**:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**轮子 3**:'
- en: '**Wheel Class**: Set this parameter to `BP_BackWheel`'
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轮子类别**：将此参数设置为`BP_BackWheel`'
- en: '**Bone Name**: Set this parameter to `B_R_wheelJNT`'
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**骨骼名称**：将此参数设置为`B_R_wheelJNT`'
- en: '![Editing the Vehicle Blueprints](img/image00343.jpeg)'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![编辑车辆蓝图](img/image00343.jpeg)'
- en: Keep in mind that when we use a unique skeletal mesh, the **Bone Name** properties
    will be different depending on how they are named. We can also add more wheels
    to the vehicle setup by clicking on the **+** sign next to the **Wheel Setups**
    option.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，当我们使用独特的骨骼网格时，**骨骼名称**属性将根据它们的命名方式而有所不同。我们还可以通过点击**轮子设置**选项旁边的**+**号来向车辆设置中添加更多轮子。
- en: 'The last thing we need to do for this **Vehicle Blueprint** is implement a
    third-person view camera position behind and slightly above our vehicle. To create
    a **Camera** component, we need to navigate to the **Components** tab. From the
    **Add Component** option, we can search the **Camera** component. Name this component
    `VehicleCamera` and set its position and rotation values as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个**车辆蓝图**，我们最后需要做的是实现一个位于车辆后方和略微上方的第三人称视角相机位置。要创建一个**相机**组件，我们需要导航到**组件**选项卡。从**添加组件**选项，我们可以搜索**相机**组件。将此组件命名为`VehicleCamera`，并设置其位置和旋转值如下：
- en: '**Location**:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位置**:'
- en: '**X**: Set value to `-490.0`'
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**X**：将值设置为`-490.0`'
- en: '**Y**: Set value to `0.0`'
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Y**：将值设置为`0.0`'
- en: '**Z**: Set value to `310.0`'
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Z**：将值设置为`310.0`'
- en: '**Rotation**:'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**旋转**:'
- en: '**Roll (X)**: Set value to `0.0`'
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**滚动（X）**：将值设置为`0.0`'
- en: '**Pitch (Y)**: Set value to `-10.0`'
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**俯仰（Y）**：将值设置为`-10.0`'
- en: '**Yaw (Z)**: Set value to `0.0`'
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**偏航（Z）**：将值设置为`0.0`'
- en: Finally, we want to make sure that the **Use Pawn Control Rotation** option
    from the **Details** panel of the **VehicleCamera** component is unchecked so
    that it is set to `False`. With these parameters in place, we are now ready to
    start setting up our **User Controls** so that we can begin to test our **Vehicle
    Blueprint**.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们想要确保**车辆相机**组件的**细节**面板中的**使用Pawn控制旋转**选项未选中，以便将其设置为`False`。有了这些参数，我们现在可以开始设置我们的**用户控制**，以便我们可以开始测试我们的**车辆蓝图**。
- en: Editing the Vehicle Blueprints – a section review
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编辑车辆蓝图 – 一节回顾
- en: In this section, we set up the basic functionality for all of our vehicle blueprints.
    First, we added the functionality to our **Vehicle** animation blueprint by creating
    a **Mesh Space Ref Pose** node, connected it to a **Wheel Handler** node, and
    implemented four different **Look At** nodes for each of our **Suspension Bones**
    that are attached to our vehicle. Next, we set up the **Friction Scale** value
    for our **Tire Type** data asset. Then, we set up the parameters required for
    our two different **Wheel Blueprints** so that we get the appropriate behaviors
    for our front and back wheels. Lastly, we set up the parameters for our **Vehicle
    Blueprint** by applying the necessary skeletal mesh and animal blueprint for the
    vehicle. We also took the time to implement the two **Wheel Blueprints** and associated
    them with the four wheel bones of the vehicle's skeletal mesh. With these blueprints
    in place, we can now implement the user controls for our vehicle so that the player
    can actually drive the vehicle in the game environment.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们为所有车辆蓝图设置了基本功能。首先，我们在**Vehicle**动画蓝图上添加了功能，通过创建一个**Mesh Space Ref Pose**节点，将其连接到一个**Wheel
    Handler**节点，并为每个连接到我们车辆的**Suspension Bones**实现了四个不同的**Look At**节点。接下来，我们为**Tire
    Type**数据资产设置了**Friction Scale**值。然后，我们设置了两个不同的**Wheel Blueprints**所需的参数，以便我们获得前后轮的适当行为。最后，我们通过应用必要的骨骼网格和车辆蓝图，为**Vehicle
    Blueprint**设置了参数。我们还花时间实现了两个**Wheel Blueprints**，并将它们与车辆骨骼网格的四个车轮骨骼关联起来。有了这些蓝图，我们现在可以实施车辆的用户控制，以便玩家实际上可以在游戏环境中驾驶车辆。
- en: Setting up user controls
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置用户控制
- en: 'When we use the **Vehicle Game** project example, there are default **User
    Inputs** already in place that allows you to control the vehicle in the game,
    but we will take a look at the input settings so that we have a better understanding
    of what they are. To view the current input controls, let''s navigate to **Project
    Settings** by first left-clicking on the **Edit** drop-down and selecting **Project
    Settings**; be sure to either be in a blueprint or a level to gain access to **Edit**
    options:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用**Vehicle Game**项目示例时，已经有默认的**User Inputs**就位，允许你在游戏中控制车辆，但我们将查看输入设置，以便我们更好地理解它们。要查看当前输入控制，让我们通过首先左键单击**Edit**下拉菜单并选择**Project
    Settings**来导航到**Project Settings**；确保你在一个蓝图或级别中，以便获得**Edit**选项：
- en: '![Setting up user controls](img/image00344.jpeg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![设置用户控制](img/image00344.jpeg)'
- en: 'From **Project Settings**, navigate to the **Input** option in the **Engine**
    section so that we gain access to **Action Mappings** and **Axis Mappings** for
    our controls. By default, we already have the **MoveForward** mapping and the
    **MoveRight** mapping in place that utilize a combination of keyboard keys and
    gamepad buttons; for our purposes, we will only need to use a few of these buttons.
    Let''s expand the **Axis Mappings** drop-down list and first view the **MoveForward**
    option; we will see multiple buttons that are used to move our vehicle forward,
    such as the *W*, *S*, up, and down keys for example. We will remove all the options,
    except the *W* and *S* keys to ensure that we don''t have any unnecessary key
    bindings for our controls; to do this, just click on the **X** button located
    next to each option to remove it. We will also see a **Scale** value next to each
    key binding: `1` and `-1`. This refers to the direction that the **MoveForward**
    control will actually move the player or vehicle forward or backward; the same
    idea applies to the **MoveRight** option as well. Let''s expand the **MoveRight
    Axis** mapping and remove all the key bindings, except the *A* and *D* keys.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 从**Project Settings**，导航到**Engine**部分的**Input**选项，以便我们能够访问控制器的**Action Mappings**和**Axis
    Mappings**。默认情况下，我们已经有**MoveForward**映射和**MoveRight**映射就位，它们使用键盘键和游戏手柄按钮的组合；对于我们的目的，我们只需要使用其中的一些按钮。让我们展开**Axis
    Mappings**下拉列表，首先查看**MoveForward**选项；我们将看到多个用于使我们的车辆前进的按钮，例如*W*、*S*、上和下键等。我们将移除所有选项，除了*W*和*S*键，以确保我们没有不必要的键绑定；为此，只需点击每个选项旁边的**X**按钮即可移除它。我们还会在每个键绑定旁边看到一个**Scale**值：`1`和`-1`。这指的是**MoveForward**控制将实际移动玩家或车辆前进或后退的方向；同样的概念也适用于**MoveRight**选项。让我们展开**MoveRight
    Axis**映射，并移除所有键绑定，除了*A*和*D*键。
- en: 'The last thing we want to do here is evaluate **Handbrake Action Mapping**.
    By default, we have multiple key bindings, but we want to remove all of them,
    except the **Space Bar** option:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里最后想做的事情是评估**手刹动作映射**。默认情况下，我们有多个键绑定，但我们要移除所有这些绑定，除了**空格键**选项：
- en: '![Setting up user controls](img/image00345.jpeg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![设置用户控件](img/image00345.jpeg)'
- en: 'Before we move on, let''s briefly discuss the differences between **Action
    Mappings** and **Axis Mappings**:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们简要讨论一下**动作映射**和**轴映射**之间的区别：
- en: '**Action Mapping**: These mappings are for key presses and releases, such as
    the pressing and releasing of *spacebar*'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动作映射**：这些映射用于按键和释放，例如按下和释放*空格键*'
- en: '**Axis Mapping**: These mappings allow inputs that have a continuous range
    and direction'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轴映射**：这些映射允许具有连续范围和方向的输入'
- en: Overall, **Action** and **Axis Mappings** provide a mechanism to easily map
    keys and axes to input behaviors by inserting a layer of indirection between an
    input behavior and the keys or the game pad buttons that initiate it.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，**动作**和**轴映射**提供了一种机制，通过在输入行为和触发它的键或游戏手柄按钮之间插入一层间接性，来轻松地将键和轴映射到输入行为。
- en: The final step is for us to create a **Game Mode** blueprint so that when we
    play in-editor, we are able to drive around in our vehicle. Let's navigate back
    to **Content Browser** and to our **VehicleContent** folder so that we can create
    the **Game Mode** blueprint. Once in the **VehicleContent** folder, let's right-click
    `o`n an area of the **Content** folder that is empty, select the **Blueprint Class**
    option. Then, from **Common Classes**, select the **Game Mode** option and name
    this new blueprint `BP_VehicleGameMode`. Now, double-click on this new blueprint,
    and under the **Details** panel, we will find the section labeled as **Classes**.
    We will change the **Default Pawn** class from `DefaultPawn` to `BP_NewVehicle`.
    This ensures that when we play the game, by default, it will use our **BP_NewVehicle
    Pawn** class.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是为我们创建一个**游戏模式**蓝图，这样当我们编辑器内游玩时，我们能够驾驶我们的车辆。让我们导航回**内容浏览器**和我们的**VehicleContent**文件夹，以便我们可以创建**游戏模式**蓝图。一旦进入**VehicleContent**文件夹，让我们在**Content**文件夹的一个空白区域右键点击，选择**蓝图类**选项。然后，从**常用类**中选择**游戏模式**选项，并将这个新蓝图命名为`BP_VehicleGameMode`。现在，双击这个新蓝图，在**详情**面板下，我们将找到标记为**类**的部分。我们将把**默认Pawn**类从`DefaultPawn`改为`BP_NewVehicle`。这确保了当我们玩游戏时，默认情况下，它将使用我们的**BP_NewVehicle
    Pawn**类。
- en: The last thing we need to do is apply this new **BP_VehicleGameMode** to our
    **Project Settings** by navigating back to **Project Settings**, and under the
    **Project** section, we will find the **Maps & Modes** option. It's here that
    we can apply **BP_VehicleGameMode** by expanding the **Default Modes** section.
    Now, from the **Default Game Mode** drop-down list, we can select the `BP_VehicleGameMode`
    option. For future reference, when we create levels, we can navigate to the **Settings**
    option while in the main **Level Editor** and select **World Settings**. This
    allows you to view your **World Settings** located next to the **Details** panel
    on the right-hand side of the screen. In **World Settings**, we will find the
    **Game Mode** section. Here, we can see the **Game Mode Override** parameter and
    select **BP_VehicleGameMode**. With this in place, we can play the game and see
    our vehicle in action, but we will see that we are unable to move our vehicle
    when we press the *W*, *A*, *S*, and *D* keys.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后需要做的是通过导航回**项目设置**并将这个新的**BP_VehicleGameMode**应用到我们的**项目设置**中。在**项目**部分，我们将找到**地图和模式**选项。在这里，我们可以通过展开**默认模式**部分来应用**BP_VehicleGameMode**。现在，从**默认游戏模式**下拉列表中，我们可以选择`BP_VehicleGameMode`选项。为了将来参考，当我们创建关卡时，我们可以在主**关卡编辑器**中导航到**设置**选项并选择**世界设置**。这允许你在屏幕右侧的**详情**面板旁边查看你的**世界设置**。在**世界设置**中，我们将找到**游戏模式**部分。在这里，我们可以看到**游戏模式覆盖**参数并选择**BP_VehicleGameMode**。有了这个设置，我们可以在游戏中玩耍并看到我们的车辆在行动，但我们会发现当我们按下*W*、*A*、*S*和*D*键时，我们无法移动我们的车辆。
- en: '![Setting up user controls](img/image00346.jpeg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![设置用户控件](img/image00346.jpeg)'
- en: We can now move on and add the input action events in our **BP_NewVehicle**
    so that we are able to move around and control our vehicle.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以继续并添加我们的**BP_NewVehicle**中的输入动作事件，这样我们就能四处移动并控制我们的车辆。
- en: Setting up user controls – a section review
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置用户控件 - 章节回顾
- en: In this section, we created the **Axis Mappings** so that the vehicle could
    gain the ability to move forward/backward and right/left. We also implemented
    the ability to use the handbrake with the **Action Mapping** in **Project Settings**.
    Lastly, we created a new **Game Mode** blueprint and implemented the **Game Mode**
    in the **Project** and **World Settings** of our level. With these in place, we
    can move on and add behaviors to our **BP_NewVehicle Event Graph**. This allows
    you to control your vehicle.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们创建了**轴映射**，以便车辆能够获得前进/后退和左右移动的能力。我们还通过**项目设置**中的**动作映射**实现了使用手刹的功能。最后，我们创建了一个新的**游戏模式**蓝图，并在我们的关卡**项目**和**世界设置**中实现了**游戏模式**。有了这些，我们可以继续添加行为到我们的**BP_NewVehicle
    事件图**。这允许你控制你的车辆。
- en: Scripting movement behaviors
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写移动行为脚本
- en: Before we can have our vehicle move through various player controls, we need
    to script the blueprint behaviors in **BP_NewVehicle Event Graph** by taking advantage
    of the **VehicleMovement (Inherited) Component** variable. To start with, let's
    navigate to **Content Browser** and to our **VehicleContent** folder so that we
    can double-click and open **BP_NewVehicle**.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的车辆可以通过各种玩家控制移动之前，我们需要通过利用**VehicleMovement (Inherited) Component**变量在**BP_NewVehicle
    事件图**中编写蓝图行为脚本。首先，让我们导航到**内容浏览器**和我们的**VehicleContent**文件夹，以便我们可以双击并打开**BP_NewVehicle**。
- en: 'In an empty area of **Event Graph**, let''s right-click and use the context-sensitive
    drop-down menu to search for our **Input Axis MoveForward** event node so that
    we can control the forward and backward throttle of our vehicle. Next, we need
    to grab a **Get** variable of the **VehicleMovement (Inherited)** component. To
    do this, we have to hold down the *CTRL* key and then click and drag the **VehicleMovement**
    component from the **Components** tab onto our **Event Graph**. Then, we can pull
    the **VehicleMovement** variable and search for the **Set Throttle Input** action
    node from the context-sensitive drop-down menu that appears. Finally, we can connect
    the main executable pin of **Input Axis MoveForward Event** to the input executable
    pin of the **Set Throttle Input** node, and we need to connect the **Axis Value**
    float output of our event to the **Throttle** float value input, as shown in the
    following screenshot:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在**事件图**的空白区域，让我们右键单击并使用上下文相关下拉菜单搜索我们的**Input Axis MoveForward**事件节点，以便我们可以控制车辆的向前和向后油门。接下来，我们需要获取**VehicleMovement
    (Inherited)**组件的**Get**变量。为此，我们必须按住*CTRL*键，然后从**组件**选项卡点击并拖动**VehicleMovement**组件到我们的**事件图**。然后，我们可以拉取**VehicleMovement**变量并从出现的上下文相关下拉菜单中搜索**Set
    Throttle Input**动作节点。最后，我们可以将**Input Axis MoveForward Event**的主可执行引脚连接到**Set Throttle
    Input**节点的输入可执行引脚，并且我们需要将事件的可执行**Axis Value**浮点输出连接到**Throttle**浮点值输入，如图下截图所示：
- en: '![Scripting movement behaviors](img/image00347.jpeg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![编写移动行为脚本](img/image00347.jpeg)'
- en: What this logic does is it uses **Axis Value** for our **Input Axis MoveForward**
    option, which will either be `1` or `-1` depending on the keys that are pressed,
    and applies this value to the **Throttle** of our vehicle, which results in our
    vehicle moving forward or backward.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 此逻辑所做的就是使用**Axis Value**为我们**Input Axis MoveForward**选项，这将根据按下的键是`1`或`-1`，并将此值应用到车辆的**油门**上，从而使车辆向前或向后移动。
- en: 'Next, let''s set up the logic to steer our vehicle by right-clicking on an
    empty area of our **Event Graph** and search for the **Input Axis MoveRight**
    event. We will also need a copy of the **Vehicle Movement Component** variable
    so that we can pull this copy and search for the **Set Steering** **Input** action
    node from the context sensitive drop-down menu. Connect the output executable
    pin of the **Input Axis MoveRight** event node to the input executable pin of
    the **Set Steering Input** node. Also, connect the **Axis Value Float** output
    to the **Steering Float** input, as shown in the following screenshot:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们设置逻辑，通过在**事件图**的空白区域右键单击并搜索**Input Axis MoveRight**事件来控制我们的车辆。我们还需要**Vehicle
    Movement Component**变量的副本，以便我们可以从上下文相关下拉菜单中拉取此副本并搜索**Set Steering Input**动作节点。将**Input
    Axis MoveRight**事件节点的输出可执行引脚连接到**Set Steering Input**节点的输入可执行引脚。此外，将**Axis Value
    Float**输出连接到**Steering Float**输入，如图下截图所示：
- en: '![Scripting movement behaviors](img/image00348.jpeg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![编写移动行为脚本](img/image00348.jpeg)'
- en: Lastly, we need to set up the logic for the handbrake so that when the player
    presses and releases the *spacebar*, the handbrake will react appropriately to
    the input. To begin with, let's right-click `o`n an empty area of **Event Graph**
    and search for the **Input Action Handbrake** event node. Next, we will need to
    create a copy of the **Vehicle Movement Component** variable, and from this variable,
    we need to pull from it and search for the **Set Handbrake Input** action node
    from the context-sensitive drop-down menu. We then need to check the **New Handbrake
    Boolean** input variable of the **Set Handbrake Input** node so that it uses the
    handbrake of our vehicle to come to a halt. Next, we need to create a copy of
    the **Vehicle Movement Component** variable and the **Set Handbrake Input** node,
    but for this copy, we want to make sure that the **New Handbrake Boolean** input
    variable is unchecked. Lastly, we need to connect the **Pressed** output executable
    pin of the **Input Action Handbrake** node to the input executable pin of the
    **Set Handbrake Input** node that has its **New Handbrake Boolean** set to `True`.
    Then, connect the **Released** output executable pin of the **Input Action Handbrake**
    node to the input executable pin of the **Set Handbrake Input** node that has
    its **New Handbrake** set to `False`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要设置手刹的逻辑，以便当玩家按下并释放空格键时，手刹能够适当地对输入做出反应。首先，让我们在**Event Graph**的空白区域右键单击，并搜索**Input
    Action Handbrake**事件节点。接下来，我们需要创建**Vehicle Movement Component**变量的副本，并从该变量中拉取，在上下文相关的下拉菜单中搜索**Set
    Handbrake Input**动作节点。然后，我们需要检查**Set Handbrake Input**节点的**New Handbrake Boolean**输入变量，以确保它使用我们车辆的手刹来停车。接下来，我们需要创建**Vehicle
    Movement Component**变量和**Set Handbrake Input**节点的副本，但对于这个副本，我们想要确保**New Handbrake
    Boolean**输入变量未被勾选。最后，我们需要将**Input Action Handbrake**节点的**Pressed**输出可执行引脚连接到其**New
    Handbrake Boolean**设置为`True`的**Set Handbrake Input**节点的输入可执行引脚。然后，将**Input Action
    Handbrake**节点的**Released**输出可执行引脚连接到其**New Handbrake**设置为`False`的**Set Handbrake
    Input**节点的输入可执行引脚。
- en: '![Scripting movement behaviors](img/image00349.jpeg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![编写移动行为脚本](img/image00349.jpeg)'
- en: With the logic in place in our **BP_NewVehicle Vehicle** blueprint, we can compile
    and save the content and then navigate to the **DesertRallyRace** level so that
    we can play in-editor and test our vehicle. Again, make sure that **World Settings**
    has the **GameMode Override** parameter set to our **BP_VehicleGameMode** blueprint
    before the testing phase.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的**BP_NewVehicle Vehicle**蓝图中的逻辑就绪后，我们可以编译并保存内容，然后导航到**DesertRallyRace**关卡，以便在编辑器中游玩并测试我们的车辆。再次提醒，在测试阶段之前，确保**World
    Settings**中的**GameMode Override**参数设置为我们的**BP_VehicleGameMode**蓝图。
- en: Now, when we play the game, we will be able to move our vehicle forward and
    backward with the *W* and *S* keys, steer the vehicle with the *A* and *D* keys,
    and use the handbrake with *spacebar* to have our vehicle come to a halt. We will
    also see that the wheels spin when it moves either forward or backward, the front
    wheels turn in the direction we press, and the physics of our vehicle work as
    expected.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们玩游戏时，我们将能够使用*W*和*S*键前进和后退移动我们的车辆，使用*A*和*D*键操控车辆，并通过空格键使用手刹使车辆停止。我们还将看到，当车辆向前或向后移动时，车轮会旋转，前轮会转向我们按下的方向，并且我们车辆的物理表现符合预期。
- en: Scripting movement behaviors – a section review
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写移动行为脚本 – 章节回顾
- en: In this section, we worked on scripting the necessary behaviors of our vehicle
    so that when we play the game, we were able to move and steer our vehicle. First,
    we implemented **Set Throttle Input** in conjunction with our **Input Axis MoveForward**
    event node. Then, we used the **Set Steering Input** node with our **Input Axis
    MoveRight** event. Lastly, we associated the **Set Handbrake** node functionality
    with the **Input Action Handbrake** event node. Now that we are able to drive
    our vehicle in the game, we can evaluate its behavior and test how it feels.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们致力于编写车辆所需的必要行为脚本，以便在游戏中，我们能够移动和操控我们的车辆。首先，我们实现了与我们的**Input Axis MoveForward**事件节点相结合的**Set
    Throttle Input**。然后，我们使用**Input Axis MoveRight**事件节点与**Set Steering Input**节点。最后，我们将**Set
    Handbrake**节点功能与**Input Action Handbrake**事件节点关联起来。现在，我们能够在游戏中驾驶我们的车辆，从而评估其行为并测试其感觉。
- en: Testing the vehicle
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试车辆
- en: When we test our vehicle, we have to keep in mind the controls and the feel
    we are trying to create when we drive the vehicle. The behaviors of a vehicle
    will drastically differ depending on the type of gameplay we are going for, such
    as the drastic difference between the vehicles in Mario Kart as compared to the
    ones from the Forza series.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们测试我们的车辆时，我们必须记住我们在驾驶车辆时试图创造的控件和感觉。车辆的行为将根据我们追求的游戏类型而有很大差异，例如，与马里奥赛车中的车辆相比，与《极限竞速》系列中的车辆相比，差异很大。
- en: If tweaks or changes are necessary to obtain the desired behavior, the main
    aspect to view is the **VehicleMovement (Inherited)** component in the **BP_NewVehicle**
    blueprint, where it has various parameters in its **Details** panel that we can
    change in order to change the behavior of the vehicle, such as **Differential
    Setup** or **Transmission Setup**. We can also use **VH_Buggy** and the other
    default vehicle content that is provided by Epic Games when we use the **Vehicle
    Game Project** example as a reference point to change the way our vehicle behaves.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要调整或更改以获得所需的行为，主要需要查看**BP_NewVehicle**蓝图中的**VehicleMovement (Inherited)**组件，其中在其**详细信息**面板中有各种参数，我们可以更改以改变车辆的行为，例如**差速器设置**或**传动设置**。我们还可以使用Epic
    Games提供的**VH_Buggy**和其他默认车辆内容，作为参考点来改变我们车辆的行为方式。
- en: Use the vehicle we have created in this chapter as a stepping stone to create
    a unique vehicle that behaves in different ways. Also, feel free to play around
    with the settings in the **Animation**, **Wheel**, and **Vehicle** **Blueprints**
    to see what we can create.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本章中创建的车辆作为垫脚石，创建一个具有不同行为的独特车辆。同时，也可以自由地调整**动画**、**车轮**和**车辆****蓝图**中的设置，看看我们可以创造出什么。
- en: Summary
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we created our own working vehicle with the **Vehicle Game
    Project Example** template step by step from scratch. In the process of doing
    so, we accomplished certain tasks.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们逐步从头开始使用**车辆游戏项目示例**模板创建了自己的工作车辆。在这个过程中，我们完成了一些任务。
- en: First, we downloaded and created a project using the **Vehicle Game Project
    Example** template so that we could have access to several resources and content
    available to create a basic vehicle and a template racing game. Then, we created
    our own **Physics Asset** using **PhAT** with the default buggy skeletal mesh
    as a base and implemented our own **Physics Bodies** to the vehicle.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们下载并使用**车辆游戏项目示例**模板创建了一个项目，以便我们可以访问创建基本车辆和模板赛车游戏所需的一些资源和内容。然后，我们使用**PhAT**创建了自己的**物理资产**，以默认的越野车骨骼网格为基础，并将我们自己的**物理体**应用到车辆上。
- en: Next, we created all the necessary blueprints and data assets required in constructing
    a working vehicle for our game. To begin with, we created a **Wheel Vehicle Blueprint**
    component that contained the **VehicleMovement (Inherited) Component** class.
    Then, we created two different types of **Wheel Blueprints** (one for the front
    wheels and another for the back wheels). Each has its own set of unique parameters.
    Lastly, we created the **Vehicle Animation Blueprint** component required to obtain
    the proper motion of our wheels when we drive.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建了构建游戏中的工作车辆所需的所有必要的蓝图和数据资产。首先，我们创建了一个包含**VehicleMovement (Inherited)
    组件**类的**轮式车辆蓝图**组件。然后，我们创建了两种不同类型的**车轮蓝图**（一个用于前轮，另一个用于后轮）。每种都有自己的独特参数。最后，我们创建了所需的**车辆动画蓝图**组件，以便在驾驶时获得车轮的正确运动。
- en: Additionally, we then edited each of these blueprints so that we could obtain
    the proper behavior for our vehicle. We also set up the user controls for our
    vehicle by editing **Input Action** and **Axis Mappings** so that the appropriate
    key bindings were set for our vehicle to move forward/backward in order to use
    the handbrake and steer left/right.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还编辑了这些蓝图，以便能够获得我们车辆的适当行为。我们还通过编辑**输入动作**和**轴映射**来设置用户控制，以便为我们的车辆设置适当的按键绑定，以便车辆可以向前/向后移动，以便使用手刹并左右转向。
- en: Then, we implemented the **Blueprint** logic within our **BP_NewVehicle Wheeled
    Vehicle Blueprint** by implementing the **Input Action** and **Axis Mapping**
    event nodes to the appropriate **Vehicle Movement** actions such as setting the
    throttle value, and the steering input values.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在**BP_NewVehicle 轮式车辆蓝图**中实现了**蓝图**逻辑，通过将**输入动作**和**轴映射**事件节点应用到适当的**车辆移动**动作中，例如设置油门值和转向输入值。
- en: Lastly, we set up our own **Game Mode Blueprint** that utilizes our **BP_NewVehicle
    Pawn Blueprint** class and implemented that **Game Mode** into the **Project Settings**,
    as well as to the **World Settings** of our level. From there, we were able to
    play in-game and drive our vehicle around the level, and we posed the challenge
    of changing the parameters of our **BP_NewVehicle** in order to obtain unique
    behaviors for our vehicle.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们建立了自己的**游戏模式蓝图**，该蓝图利用了我们的**BP_NewVehicle Pawn Blueprint**类，并将该**游戏模式**实施到**项目设置**中，以及我们级别的**世界设置**中。从那时起，我们能够在游戏中玩耍，并在级别中驾驶我们的车辆，我们还提出了改变我们**BP_NewVehicle**参数的挑战，以便为我们的车辆获得独特的行为。
- en: In the next chapter, we will be covering advanced physics topics and troubleshooting
    concepts like pragmatic physics.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍高级物理主题和故障排除概念，如实用物理。
