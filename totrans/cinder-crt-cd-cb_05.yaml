- en: Chapter 5. Building Particle Systems
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章：构建粒子系统
- en: 'In this chapter we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Creating a particle system in 2D
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 2D 中创建粒子系统
- en: Applying repulsion and attraction forces
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用排斥力和吸引力
- en: Simulating particles flying in the wind
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟粒子随风飘动
- en: Simulating flocking behavior
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟集群行为
- en: Making our particles sound reactive
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使我们的粒子对声音做出反应
- en: Aligning particles to processed images
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将粒子与处理后的图像对齐
- en: Aligning particles to mesh surfaces
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将粒子与网格表面对齐
- en: Creating springs
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建弹簧
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Particle systems are a computational technique of using a large number of small
    graphic objects to perform different types of simulations such as explosions,
    wind, fire, water, and flocking.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子系统是一种计算技术，使用大量小图形对象执行不同类型的模拟，如爆炸、风、火、水和集群。
- en: In this chapter, we are going to learn how to create and animate particles using
    popular and versatile physics algorithms.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用流行的多功能物理算法创建和动画化粒子。
- en: Creating a particle system in 2D
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 2D 中创建粒子系统
- en: In this recipe, we are going to learn how we can build a basic particle system
    in two dimensions using the Verlet algorithm.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将学习如何使用 Verlet 算法在二维空间中构建一个基本的粒子系统。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will need to create two classes, a `Particle` class representing a single
    particle, and a `ParticleSystem` class to manage our particles.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建两个类，一个 `Particle` 类代表单个粒子，一个 `ParticleSystem` 类来管理我们的粒子。
- en: 'Using your IDE of choice, create the following files:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您选择的 IDE 创建以下文件：
- en: '`Particle.h`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Particle.h`'
- en: '`Particle.cpp`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Particle.cpp`'
- en: '`ParticleSystem.h`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ParticleSystem.h`'
- en: '`ParticleSystem.cpp`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ParticleSystem.cpp`'
- en: How to do it…
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做呢...
- en: 'We will learn how we can create a basic particle system. Perform the following
    steps to do so:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习如何创建一个基本的粒子系统。执行以下步骤：
- en: 'First, let''s declare our `Particle` class in the `Particle.h` file and include
    the necessary Cinder files:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们在 `Particle.h` 文件中声明我们的 `Particle` 类并包含必要的 Cinder 文件：
- en: '[PRE0]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let's add, to the class declaration, the necessary member variables – `ci::Vec2f`
    to store the position, previous position, and applied forces; and `float` to store
    particle radius, mass, and drag.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在类声明中添加必要的成员变量 - 使用 `ci::Vec2f` 存储位置、前一个位置和施加的力；以及使用 `float` 存储粒子半径、质量和阻力。
- en: '[PRE1]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The last thing needed to finalize the `Particle` declaration is to add a constructor
    that takes the particle's initial position, radius, mass, and drag, and methods
    to update and draw the particle.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了最终完成 `Particle` 声明，还需要添加一个构造函数，该构造函数接受粒子的初始位置、半径、质量和阻力，以及更新和绘制粒子的方法。
- en: 'The following is the final `Particle` class declaration:'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是最终的 `Particle` 类声明：
- en: '[PRE2]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let's move on to the `Particle.cpp` file and implement the `Particle` class.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续到 `Particle.cpp` 文件并实现 `Particle` 类。
- en: 'The first necessary step is to include the `Particle.h` file, as follows:'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一个必要的步骤是包含 `Particle.h` 文件，如下所示：
- en: '[PRE3]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We initialize the member variables to the values passed in the constructor.
    We also initialize `forces` to `zero` and `prevPosition` to the initial position.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将成员变量初始化为构造函数中传递的值。我们还初始化 `forces` 为 `zero` 和 `prevPosition` 为初始位置。
- en: '[PRE4]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the `update` method, we need to create a temporary `ci::Vec2f` variable to
    store the particle's position before it is updated.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `update` 方法中，我们需要创建一个临时的 `ci::Vec2f` 变量来存储更新前的粒子位置。
- en: '[PRE5]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We calculate the velocity of the particle by finding the difference between
    current and previous positions and multiplying it by `drag`. We store this value
    in `ci::Vec2f` temporarily for clarity.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过计算当前位置与前一个位置之间的差异并乘以 `drag` 来计算粒子的速度。为了清晰起见，我们将此值暂时存储在 `ci::Vec2f` 中。
- en: '[PRE6]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To update the particle's position, we add the previously calculated velocity
    and add `forces` divided by `mass`.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要更新粒子的位置，我们将之前计算的速度加上 `forces` 除以 `mass`。
- en: '[PRE7]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The final steps in the `update` method are to copy the previously stored position
    to `prevPosition` and reset `forces` to a `zero` vector.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`update` 方法中的最后一步是将之前存储的位置复制到 `prevPosition` 并将 `forces` 重置为零向量。'
- en: 'The following is the complete `update` method implementation:'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是完全的 `update` 方法实现：
- en: '[PRE8]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the `draw` implementation, we simply draw a circle at the particle's position
    using its radius.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `draw` 实现中，我们只需在粒子的位置处绘制一个圆，使用其半径。
- en: '[PRE9]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now with the `Particle` class complete, we need to begin working on the `ParticleSystem`
    class. Move to the `ParticleSystem.h` file, include the necessary files, and create
    the `ParticleSystem` class declaration.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在随着`Particle`类的完成，我们需要开始着手于`ParticleSystem`类的开发。切换到`ParticleSystem.h`文件，包含必要的文件，并创建`ParticleSystem`类的声明。
- en: '[PRE10]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s add a destructor and methods to update and draw our particles. We''ll
    also need to create methods to add and destroy particles and finally a `std::vector`
    variable to store the particles in this system. The following is the final class
    declaration:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加一个析构函数和更新和绘制粒子的方法。我们还需要创建添加和销毁粒子的方法，以及一个`std::vector`变量来存储系统中的粒子。以下是最终的类声明：
- en: '[PRE11]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Moving to the `ParticleSystem.cpp` file, let's begin working on the implementation.
    The first thing we need to do is include the file with the class declaration.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`ParticleSystem.cpp`文件，让我们开始实现。首先我们需要做的是包含包含类声明的文件。
- en: '[PRE12]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now let's implement the methods one by one. In the destructor, we iterate through
    all the particles and delete them.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们逐一实现这些方法。在析构函数中，我们遍历所有粒子并将它们删除。
- en: '[PRE13]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `update` method will be used to iterate all the particles and call `update`
    on each of them.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`update`方法将用于遍历所有粒子并对每个粒子调用`update`。'
- en: '[PRE14]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `draw` method will iterate all the particles and call `draw` on each of
    them.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`draw`方法将遍历所有粒子，并对每个粒子调用`draw`。'
- en: '[PRE15]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `addParticle` method will insert the particle on the `particles` container.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`addParticle`方法将粒子插入到`particles`容器中。'
- en: '[PRE16]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Finally, `destroyParticle` will delete the particle and remove it from the particles'
    list.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`destroyParticle`将删除粒子并从粒子列表中移除。
- en: We'll find the particles' iterator and use it to delete and later remove the
    object from the container.
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将找到粒子的迭代器，并使用它来从容器中删除和稍后移除对象。
- en: '[PRE17]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: With our classes ready, let's go to our application's class and create some
    particles.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的类准备就绪后，让我们转到应用程序类并创建一些粒子。
- en: 'In our application''s class, we need to include the `ParticleSystem` header
    file and the necessary header to use random numbers at the top of the source file:'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的应用程序类中，我们需要在源文件顶部包含`ParticleSystem`头文件和必要的头文件以使用随机数：
- en: '[PRE18]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Declare a `ParticleSystem` object on our class declaration.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类声明中声明一个`ParticleSystem`对象。
- en: '[PRE19]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the `setup` method we can create 100 particles with random positions on our
    window and random radius. We'll define the mass to be the same as the radius as
    a way to have a relation between size and mass. `drag` will be set to 9.5.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`setup`方法中，我们可以在窗口上创建100个具有随机位置和随机半径的粒子。我们将质量定义为与半径相同，以此作为大小和质量的关联方式。`drag`将被设置为9.5。
- en: 'Add the following code snippet inside the setup method:'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`setup`方法内部添加以下代码片段：
- en: '[PRE20]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the `update` method, we need to update the particles by calling the `update`
    method on `mParticleSystem`.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`update`方法中，我们需要通过在`mParticleSystem`上调用`update`方法来更新粒子。
- en: '[PRE21]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the `draw` method we need to clear the screen, set up the window's matrices,
    and call the `draw` method on `mParticleSystem`.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`draw`方法中，我们需要清除屏幕，设置窗口的矩阵，并在`mParticleSystem`上调用`draw`方法。
- en: '[PRE22]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Build and run the application and you will see 100 random circles on screen,
    as shown in the following screenshot:![How to do it…](img/8703OS_5_1.jpg)
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行应用程序，你将在屏幕上看到100个随机圆圈，如下面的截图所示：![如何做到这一点…](img/8703OS_5_1.jpg)
- en: In the next recipes we will learn how to animate the particles in organic and
    appealing ways.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的菜谱中，我们将学习如何以有机和吸引人的方式动画化粒子。
- en: How it works...
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The method described previously uses a popular and versatile Verlet integrator.
    One of its main characteristics is an implicit approximation of velocity. This
    is accomplished by calculating, on each update of the simulation, the distance
    traveled since the last update of the simulation. This allows for greater stability
    as velocity is implicit to position and there is less chance these will ever get
    out of sync.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 之前描述的方法使用了一个流行且通用的Verlet积分器。其主要特点是对速度的隐式近似。这是通过在每次模拟更新时计算自上次模拟更新以来所经过的距离来实现的。这允许有更高的稳定性，因为速度是隐式地与位置相关联的，并且不太可能发生不同步。
- en: 'The `drag` member variable represents resistance to movement and should be
    a number between 0.0 and 1.0\. A value of 0.0 represents such a great resistance
    that the particle will not be able to move. A value of 1.0 represents absence
    of resistance and will make the particle move indefinitely. We applied `drag`
    in step 7, where we multiplied `drag` by the velocity:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`drag` 成员变量代表运动阻力，应该是一个介于 0.0 和 1.0 之间的数字。0.0 的值表示如此大的阻力，以至于粒子将无法移动。1.0 的值表示没有阻力，将使粒子无限期地移动。我们在第
    7 步中应用了 `drag`，其中我们将 `drag` 乘以速度：'
- en: '[PRE23]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: There's more...
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: To create a particle system in 3D it is necessary to use a 3D vector instead
    of a 2D one.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 3D 中创建粒子系统，必须使用 3D 向量而不是 2D 向量。
- en: Since Cinder's vector 2D and 3D vector classes have a very similar class structure,
    we simply need to change `position`, `prevPosition`, and `forces` to be `ci::Vec3f`
    objects.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Cinder 的 2D 向量和 3D 向量类具有非常相似的类结构，我们只需将 `position`、`prevPosition` 和 `forces`
    改为 `ci::Vec3f` 对象。
- en: The constructor will also need to take a `ci::Vec3f` object as an argument instead.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数也需要接受一个 `ci::Vec3f` 对象作为参数。
- en: 'The following is the class declaration with these changes:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是根据这些更改的类声明：
- en: '[PRE24]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `draw` method should also be changed to allow for 3D drawing; we could,
    for example, draw a sphere instead of a circle:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw` 方法也应更改以允许 3D 绘制；例如，我们可以绘制一个球体而不是圆形：'
- en: '[PRE25]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: See also
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: For more information on the implementation of the Verlet algorithm, please refer
    to the paper by Thomas Jakobsen, located at [http://www.pagines.ma1.upc.edu/~susin/contingut/AdvancedCharacterPhysics.pdf](http://www.pagines.ma1.upc.edu/~susin/contingut/AdvancedCharacterPhysics.pdf)
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 Verlet 算法的实现，请参阅托马斯·雅各布森的论文，位于 [http://www.pagines.ma1.upc.edu/~susin/contingut/AdvancedCharacterPhysics.pdf](http://www.pagines.ma1.upc.edu/~susin/contingut/AdvancedCharacterPhysics.pdf)
- en: For more information on the Verlet integration, please read the wiki at [http://en.wikipedia.org/wiki/Verlet_integration](http://en.wikipedia.org/wiki/Verlet_integration)
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 Verlet 积分的更多信息，请阅读维基百科 [http://en.wikipedia.org/wiki/Verlet_integration](http://en.wikipedia.org/wiki/Verlet_integration)。
- en: Applying repulsion and attraction forces
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用排斥力和吸引力
- en: In this recipe, we will show how you can apply repulsion and attraction forces
    to the particle system that we have implemented in the previous recipe.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将展示如何将排斥力和吸引力应用到我们在前一个菜谱中实现的粒子系统中。
- en: Getting ready
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we are going to use the code from the *Creating particle system
    in 2D* recipe.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用 *Creating particle system in 2D* 菜谱中的代码。
- en: How to do it…
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'We will illustrate how you can apply forces to the particle system. Perform
    the following steps:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将展示如何将力应用到粒子系统中。执行以下步骤：
- en: Add properties to your application's main class.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向你的应用程序的主类添加属性。
- en: '[PRE26]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Set the default value inside the `setup` method.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `setup` 方法中设置默认值。
- en: '[PRE27]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Implement the `mouseMove` and `mouseDown` methods, as follows:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现以下 `mouseMove` 和 `mouseDown` 方法：
- en: '[PRE28]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'At the beginning of the `update` method, add the following code snippet:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`update`方法的开始处，添加以下代码片段：
- en: '[PRE29]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How it works…
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In this example we added interaction to the particles engine introduced in the
    first recipe. The attraction force is pointing to your mouse cursor position but
    the repulsion vector points in the opposite direction. These forces were calculated
    and applied to each particle in steps 3 and 4, and then we made the particles
    follow your mouse cursor, but when you click on the left mouse button, they are
    suddenly moves away from the mouse cursor. This effect can be achieved with basic
    vector operations. Cinder lets you perform vector calculations pretty much the
    same way you usually do on scalars.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们为第一个菜谱中引入的粒子引擎添加了交互。吸引力指向你的鼠标光标位置，而排斥向量指向相反方向。这些力在第 3 和 4 步中计算并应用到每个粒子上，然后我们让粒子跟随你的鼠标光标，但是当你点击左键时，它们会突然远离鼠标光标。这种效果可以通过基本的向量运算实现。Cinder
    允许你以与通常对标量进行操作相同的方式执行向量计算。
- en: The repulsion force is calculated in step 3\. We are using the normalized vector
    beginning at the mouse cursor position and the end of the particle position, multiplied
    by the repulsion factor, calculated on the basis of the distance between the particle
    and the mouse cursor position. Using the `repulsionRadius` value, we can limit
    the range of the repulsion.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 排斥力在第 3 步计算。我们使用从鼠标光标位置到粒子位置的归一化向量，乘以基于粒子与鼠标光标位置之间的距离计算的排斥因子。使用 `repulsionRadius`
    值，我们可以限制排斥力的范围。
- en: We are calculating the attraction force in step 4 taking the vector beginning
    at the particle position and the end at the mouse cursor position. We are multiplying
    this vector by the `attrFactor` value, which controls the strength of the attraction.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第4步计算吸引力，取从粒子位置开始到鼠标光标位置的向量。我们将此向量乘以`attrFactor`值，该值控制吸引力的强度。
- en: '![How it works…](img/8703OS_5_2.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/8703OS_5_2.jpg)'
- en: Simulating particles flying in the wind
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟风中飞行的粒子
- en: In this recipe, we will explain how you can apply Brownian motion to your particles.
    Particles are going to behave like snowflakes or leaves flying in the wind.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将解释如何将布朗运动应用于您的粒子。粒子将表现得像雪花或随风飘动的树叶。
- en: Getting ready
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe we are going to use the code base from the *Creating a particle
    system in 2D* recipe.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将使用*在2D中创建粒子系统*配方的代码库。
- en: How to do it…
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现它...
- en: 'We will add movement to particles calculated from the Perlin noise and sine
    function. Perform the following steps to do so:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加来自Perlin噪声和正弦函数计算的粒子运动。执行以下步骤来完成此操作：
- en: Add the necessary headers.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加必要的头文件。
- en: '[PRE30]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Add properties to your application's main class.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向应用程序的主类添加属性。
- en: '[PRE31]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Set the default value inside the `setup` method.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`setup`方法中设置默认值。
- en: '[PRE32]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Change the number of the particles, their radius, and mass.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 改变粒子的数量、半径和质量。
- en: '[PRE33]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'At the beginning of the `update` method, add the following code snippet:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`update`方法的开头添加以下代码片段：
- en: '[PRE34]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: How it works…
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作…
- en: The main movement calculations and forces are applied in step 5\. As you can
    see we are using the Perlin noise algorithm implemented as a part of Cinder. It
    provides a method to retrieve Brownian motion vectors for each particle. We also
    add `oscilationVec` that makes particles swing from left-to-right and backwards,
    adding more realistic behavior.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的运动计算和力在第5步应用。如您所见，我们正在使用作为Cinder一部分实现的Perlin噪声算法。它为每个粒子提供检索布朗运动向量的方法。我们还添加了`oscilationVec`，使粒子从左到右和向后摆动，增加更真实的行为。
- en: '![How it works…](img/8703OS_5_3.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/8703OS_5_3.jpg)'
- en: See also
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '**Perlin noise original source**: [http://mrl.nyu.edu/~perlin/doc/oscar.html#noise](http://mrl.nyu.edu/~perlin/doc/oscar.html#noise)'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Perlin噪声原始来源**: [http://mrl.nyu.edu/~perlin/doc/oscar.html#noise](http://mrl.nyu.edu/~perlin/doc/oscar.html#noise)'
- en: '**Brownian motion**: [http://en.wikipedia.org/wiki/Brownian_motion](http://en.wikipedia.org/wiki/Brownian_motion)'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**布朗运动**: [http://en.wikipedia.org/wiki/Brownian_motion](http://en.wikipedia.org/wiki/Brownian_motion)'
- en: Simulating flocking behavior
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟群聚行为
- en: Flocking is a term applied to the behavior of birds and other flying animals
    that are organized into a swarm or flock.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 群聚是应用于组织成鸟群或其他飞行动物的行为的术语。
- en: 'From our point of view, it is especially interesting that flocking behavior
    can be simulated by applying only three rules to each particle (Boid). These rules
    are as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的角度来看，特别有趣的是，通过仅对每个粒子（Boid）应用三条规则就可以模拟群聚行为。这些规则如下：
- en: '**Separation**: Avoid neighbors that are too near'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分离**: 避免过于靠近的邻居'
- en: '**Alignment**: Steer towards the average velocity of neighbors'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对齐**: 驶向邻居的平均速度'
- en: '**Cohesion**: Steer towards the average position of neighbors'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聚合**: 驶向邻居的平均位置'
- en: Getting ready
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we are going to use the code from the *Creating a particle system
    in 2D* recipe.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将使用来自*在2D中创建粒子系统*配方的代码。
- en: How to do it…
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现它…
- en: 'We will implement the rules for flocking behavior. Perform the following steps
    to do so:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现群聚行为的规则。执行以下步骤来完成此操作：
- en: Change the number of the particles, their radius, and mass.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 改变粒子的数量、半径和质量。
- en: '[PRE35]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Add a definition for new methods and properties to the `Particle` class inside
    the `Particle.h` header file.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Particle.h`头文件中为`Particle`类添加新方法和属性的定义。
- en: '[PRE36]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Set the default values for `maxspeed` and `maxforce` at the end of the `Particle`
    constructor inside the `Particle.cpp` source file.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Particle.cpp`源文件中的`Particle`构造函数末尾设置`maxspeed`和`maxforce`的默认值。
- en: '[PRE37]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Implement the new methods of the `Particle` class inside the `Particle.cpp`
    source file.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Particle.cpp`源文件中实现`Particle`类的新方法。
- en: '[PRE38]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Add a method for the separation rule.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加分离规则的方法。
- en: '[PRE39]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Add a method for the alignment rule.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加对齐规则的方法。
- en: '[PRE40]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Add a method for the cohesion rule.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加聚合规则的方法。
- en: '[PRE41]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Change the `update` method to read as follows
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`update`方法更改为以下内容
- en: '[PRE42]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Change the `drawing` method of `Particle`, as follows:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 改变`Particle`的`drawing`方法，如下所示：
- en: '[PRE43]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Change the `update` method of `ParticleSystem` inside the `ParticleSystem.cpp`
    source file, as follows:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ParticleSystem.cpp`源文件中更改`ParticleSystem`的`update`方法，如下所示：
- en: '[PRE44]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: How it works…
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Three rules for flocking—separation, alignment, and cohesion—were implemented
    starting from step 4 and they were applied to each particle in step 10\. In this
    step, we also prevented Boids from going out of the window boundaries by resetting
    their positions.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 从第4步开始实现了三个群聚规则——分离、对齐和凝聚力——并在第10步应用于每个粒子。在这一步中，我们还通过重置它们的位置来防止Boids超出窗口边界。
- en: '![How it works…](img/8703OS_5_12.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/8703OS_5_12.jpg)'
- en: See also
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '**Flocking**: [http://en.wikipedia.org/wiki/Flocking_(behavior)](http://en.wikipedia.org/wiki/Flocking_(behavior))'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**群聚**：[http://en.wikipedia.org/wiki/Flocking_(behavior)](http://en.wikipedia.org/wiki/Flocking_(behavior))'
- en: Making our particles sound reactive
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使我们的粒子响应用户
- en: In this recipe we will pick on the previous particle system and add animations
    based on **fast Fourier transform** (**FFT**) analysis from an audio file.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将基于从音频文件中进行的**快速傅里叶变换**（**FFT**）分析来选择之前的粒子系统并添加动画。
- en: The FFT analysis will return a list of values representing the amplitudes of
    several frequency windows. We will match each particle to a frequency window and
    use its value to animate the repulsion that each particle applies to all other
    particles.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: FFT分析将返回一个表示几个频率窗口振幅的值的列表。我们将每个粒子与一个频率窗口相匹配，并使用其值来动画化每个粒子对其他所有粒子施加的排斥力。
- en: This example uses Cinder's FFT processor, which is only available on Mac OS
    X.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子使用了Cinder的FFT处理器，它仅在Mac OS X上可用。
- en: Getting ready
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will be using the same particle system developed in the previous recipe,
    *Creating a particle system in 2D*. Create the `Particle` and `ParticleSystem`
    classes described in that recipe, and include the `ParticleSystem.h` file at the
    top of the application's source file.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用之前菜谱中开发的相同粒子系统，*在2D中创建粒子系统*。创建该菜谱中描述的`Particle`和`ParticleSystem`类，并在应用程序源文件的顶部包含`ParticleSystem.h`文件。
- en: How to do it…
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Using values from the FFT analysis we will animate our particles. Perform the
    following steps to do so:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用FFT分析中的值来动画化我们的粒子。执行以下步骤来完成：
- en: Declare a `ParticleSystem` object on your application's class and a variable
    to store the number of particles we will create.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序的类中声明一个`ParticleSystem`对象和一个变量来存储我们将创建的粒子数量。
- en: '[PRE45]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In the `setup` method we'll create 256 random particles. The number of particles
    will match the number of values we will receive from the audio analysis.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`setup`方法中，我们将创建256个随机粒子。粒子的数量将与我们从音频分析中接收到的值的数量相匹配。
- en: The particles will begin at a random position on the window and have a random
    size and mass. `drag` will be `0.9`.
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 粒子将在窗口的随机位置开始，具有随机的大小和质量。`drag`将设置为`0.9`。
- en: '[PRE46]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In the `update` method, we have to call the `update` method on the particle
    system.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`update`方法中，我们必须调用粒子系统的`update`方法。
- en: '[PRE47]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In the `draw` method, we have to clear the background, calculate the window's
    matrices, and call the `draw` method on the particle system.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`draw`方法中，我们必须清除背景，计算窗口的矩阵，并调用粒子系统的`draw`方法。
- en: '[PRE48]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now let''s load and play an audio file. We start by including the necessary
    files to load, play, and perform the FFT analysis. Add the following code snippet
    at the top of the source file:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们加载并播放一个音频文件。我们首先包括加载、播放和执行FFT分析的必要文件。在源文件顶部添加以下代码片段：
- en: '[PRE49]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Now declare `ci::audio::TrackRef`, which is a reference to an audio track.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在声明`ci::audio::TrackRef`，它是一个音频轨道的引用。
- en: '[PRE50]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In the `setup` method we will open a file dialog to allow the user to select
    which audio file to play.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`setup`方法中，我们将打开一个文件对话框，允许用户选择要播放的音频文件。
- en: If the retrieved path is not empty, we will use it to load and add a new audio
    track.
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果检索到的路径不为空，我们将使用它来加载并添加一个新的音频轨道。
- en: '[PRE51]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We'll check if `mAudio` was successfully loaded and played. We will also enable
    the PCM buffer and looping.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将检查`mAudio`是否成功加载并播放。我们还将启用PCM缓冲区和循环。
- en: '[PRE52]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Now that we have an audio file playing, we need to start animating the particles.
    First we need to apply an elastic force towards the center of the window. We do
    so by iterating the over all particles and adding a force, which is one-tenth
    of the difference between the particle's position and the window's center position.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经播放了一个音频文件，我们需要开始动画化粒子。首先，我们需要向窗口中心应用一个弹性力。我们通过迭代所有粒子并添加一个力来完成，这个力是粒子位置与窗口中心位置差值的十分之一。
- en: 'Add the following code snippet to the `update` method:'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将以下代码片段添加到`update`方法中：
- en: '[PRE53]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Now we have to calculate the FFT analysis. This will be done once after every
    frame in the update.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们必须计算FFT分析。这将在每次更新帧后进行一次。
- en: Declare a local variable `std::shared_ptr<float>`, where the result of the FFT
    will be stored.
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 声明一个局部变量`std::shared_ptr<float>`，用于存储FFT的结果。
- en: We will get a reference to the PCM buffer of `mAudio` and perform an FFT analysis
    on its left channel. It is a good practice to perform a test to check the validity
    of `mAudio` and its buffer.
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将获取`mAudio`的PCM缓冲区的引用，并在其左通道上执行FFT分析。对`mAudio`及其缓冲区进行测试以检查其有效性是一个好的实践。
- en: '[PRE54]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We will use the values from the FFT analysis to scale the repulsion each particle
    is applying.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用FFT分析的结果来调整每个粒子施加的排斥力。
- en: 'Add the following code snippet to the `update` method:'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将以下代码片段添加到`update`方法中：
- en: '[PRE55]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Build and run the application; you will be prompted to select an audio file.
    Select it and it will begin playing. The particles will move and push each other
    around according to the audio's frequencies.![How to do it…](img/8703OS_5_6.jpg)
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行应用程序；您将被提示选择一个音频文件。选择它，它将开始播放。粒子将根据音频的频率移动并相互推挤。![如何操作…](img/8703OS_5_6.jpg)
- en: How it works…
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: We created a particle for each one of the values the FFT analysis returns and
    made each particle repulse every other particle according to its correspondent
    frequency window amplitude. As the music evolves, the animation will react accordingly.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为FFT分析返回的每个值创建了一个粒子，并根据相应的频率窗口幅度使每个粒子排斥其他粒子。随着音乐的演变，动画将相应地做出反应。
- en: See also
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: To learn more about fast Fourier transform please visit [http://en.wikipedia.org/wiki/Fast_Fourier_transform](http://en.wikipedia.org/wiki/Fast_Fourier_transform)
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解更多关于快速傅里叶变换的信息，请访问[http://en.wikipedia.org/wiki/Fast_Fourier_transform](http://en.wikipedia.org/wiki/Fast_Fourier_transform)
- en: Aligning particles to a processed image
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将粒子对齐到处理后的图像
- en: In this recipe, we will show how you can use techniques you were introduced
    to in the previous recipes to make particles align to the edge detected in the
    image.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将展示如何使用在前面的食谱中介绍的技术使粒子对齐到图像中检测到的边缘。
- en: Getting ready
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we are going to use the particles' implementation from the *Creating
    a particle system in 2D* recipe; the image processing example from the *Detecting
    edges* recipe in [Chapter 3](ch03.html "Chapter 3. Using Image Processing Techniques"),
    *Using Image Processing Techniques*; as well as simulating repulsion covered in
    the *Applying repulsion and attraction forces* recipe.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将使用来自*在2D中创建粒子系统*食谱的粒子实现；来自[第3章](ch03.html "第3章。使用图像处理技术")的*检测边缘*食谱中的图像处理示例；以及*应用排斥和吸引力量*食谱中涵盖的模拟排斥。
- en: How to do it…
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'We will create particles aligning to the detected edges in the image. Perform
    the following steps to do so:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建与图像中检测到的边缘对齐的粒子。为此，请执行以下步骤：
- en: Add an `anchor` property to the `Particle` class in the `Particle.h` file.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Particle.h`文件中为`Particle`类添加一个`anchor`属性。
- en: '[PRE56]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Set the `anchor` value at the end of the `Particle` class constructor in the
    `Particle.cpp` source file.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Particle.cpp`源文件的`Particle`类构造函数末尾设置`anchor`值。
- en: '[PRE57]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Add a new property to your application's main class.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向您应用程序的主类添加一个新属性。
- en: '[PRE58]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'At the end of the `setup` method, after image processing, add new particles,
    as follows:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`setup`方法末尾，在图像处理之后，添加新粒子，如下所示：
- en: '[PRE59]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Implement the `update` method for your main class, as follows:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您的主类实现`update`方法，如下所示：
- en: '[PRE60]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Change the `draw` method for `Particle` inside the `Particle.cpp` source file
    to read as follows
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Particle.cpp`源文件中的`Particle`类的`draw`方法更改为以下内容
- en: '[PRE61]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: How it works…
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The first major step was to allocate particles at some characteristic points
    of the image. To do so, we detected the edges, which was covered in the *Detecting
    edges* recipe in [Chapter 3](ch03.html "Chapter 3. Using Image Processing Techniques"),
    *Using Image Processing Techniques*. In step 4 you can see that we iterated through
    each pixel of each processed image and placed particles only at detected features.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个主要步骤是在图像的一些特征点上分配粒子。为此，我们检测了边缘，这在[第3章](ch03.html "第3章。使用图像处理技术")的*检测边缘*食谱中有介绍，*使用图像处理技术*。在第4步中，您可以看到我们遍历了每个处理图像的每个像素，并在检测到的特征处放置粒子。
- en: You can find another important calculation in step 5, where we tried to move
    back the particles to their original positions stored in the `anchor` property.
    To disorder particles, we used the same repulsion code that we used in the *Applying
    repulsion and attraction forces* recipe.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在第5步找到一个重要的计算，我们尝试将粒子移动回存储在`anchor`属性中的原始位置。为了使粒子无序，我们使用了与*应用排斥和吸引力的力*菜谱中相同的排斥代码。
- en: '![How it works…](img/8703OS_5_8.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/8703OS_5_8.jpg)'
- en: See also
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: To learn more about fast Fourier transform, please visit [http://en.wikipedia.org/wiki/Fast_Fourier_transform](http://en.wikipedia.org/wiki/Fast_Fourier_transform)
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解更多关于快速傅里叶变换的信息，请访问[http://en.wikipedia.org/wiki/Fast_Fourier_transform](http://en.wikipedia.org/wiki/Fast_Fourier_transform)
- en: Aligning particles to the mesh surface
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将粒子对齐到网格表面
- en: In this recipe, we are going to use a 3D version of the particles' code base
    from the *Creating a particle system in 2D* recipe. To navigate in 3D space, we
    will use `MayaCamUI` covered in the *Using MayaCamUI* recipe in [Chapter 2](ch02.html
    "Chapter 2. Preparing for Development"), *Preparing for Development*.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用来自*在2D中创建粒子系统*菜谱的粒子代码库的3D版本。为了在3D空间中导航，我们将使用在第2章*为开发做准备*中介绍的*使用MayaCamUI*菜谱中的`MayaCamUI`。请参阅[第2章](ch02.html
    "第2章。为开发做准备")。
- en: Getting ready
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To simulate repulsion, we are using the code from the *Applying repulsion and
    attraction forces* recipe with slight modifications for three-dimensional space.
    For this example, we are using the `ducky.mesh` mesh file that you can find in
    the `resources` directory of the Picking3D sample inside the Cinder package. Please
    copy this file to the `assets` folder in your project.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟排斥力，我们使用了来自*应用排斥和吸引力的力*菜谱的代码，并对三维空间进行了轻微修改。对于这个例子，我们使用了位于Cinder包内Picking3D样本的`resources`目录中的`ducky.mesh`网格文件。请将此文件复制到您项目中的`assets`文件夹。
- en: How to do it…
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We will create particles aligned to the mesh. Perform the following steps to
    do so:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建与网格对齐的粒子。执行以下步骤：
- en: Add an `anchor` property to the `Particle` class in the `Particle.h` file.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Particle.h`文件中将`anchor`属性添加到`Particle`类中。
- en: '[PRE62]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Set the `anchor` value at the end of the `Particle` class constructor in the
    `Particle.cpp` source file.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Particle.cpp`源文件的`Particle`类构造函数的末尾设置`anchor`值。
- en: '[PRE63]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Add the necessary headers in your main class.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的主类中添加必要的头文件。
- en: '[PRE64]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Add the new properties to your application's main class.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新属性添加到您应用程序的主类中。
- en: '[PRE65]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Set the default values inside the `setup` method.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`setup`方法中设置默认值。
- en: '[PRE66]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'At the end of the `setup` method, add the following code snippet:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`setup`方法的末尾添加以下代码片段：
- en: '[PRE67]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Add methods for camera navigation.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加相机导航的方法。
- en: '[PRE68]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Implement the `update` and `draw` methods for your main application class.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您的应用程序主类实现`update`和`draw`方法。
- en: '[PRE69]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Replace the `draw` method for `Particle` inside the `Particle.cpp` source file
    to read as follows
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Particle.cpp`源文件中的`Particle`的`draw`方法替换为以下内容
- en: '[PRE70]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: How it works…
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作…
- en: Firstly, we created particles in place of vertices of the mesh that you can
    see in step 6.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在第6步中创建的粒子代替了网格的顶点。
- en: '![How it works…](img/8703OS_5_9.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/8703OS_5_9.jpg)'
- en: You can find another important calculation in step 8 where we tried to move
    particles back to their original positions stored in the `anchor` property. To
    displace the particles, we used the same repulsion code that we used in the *Applying
    repulsion and attraction forces* recipe but with slight modifications for three-dimensional
    space. Basically, it is about using `Vec3f` types instead of `Vec2f`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在第8步找到一个重要的计算，我们尝试将粒子移动回存储在`anchor`属性中的原始位置。为了使粒子偏移，我们使用了与*应用排斥和吸引力的力*菜谱中相同的排斥代码，但对其进行了三维空间的轻微修改。基本上，它涉及到使用`Vec3f`类型而不是`Vec2f`。
- en: '![How it works…](img/8703OS_5_10.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/8703OS_5_10.jpg)'
- en: Creating springs
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建弹簧
- en: In this recipe, we will learn how we can create springs.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何创建弹簧。
- en: '**Springs** are objects that connect two particles and force them to be at
    a defined rest distance.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '**弹簧**是连接两个粒子并使它们保持在定义的静止距离的对象。'
- en: In this example, we will create random particles, and whenever the user presses
    a mouse button, two random particles will be connected by a new spring with a
    random rest distance.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将创建随机粒子，并且每当用户按下鼠标按钮时，两个随机粒子将通过一个新的弹簧连接，弹簧的静止距离是随机的。
- en: Getting ready
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will be using the same particle system developed in the previous recipe,
    *Creating a particle system in 2D*. Create the `Particle` and `ParticleSystem`
    classes described in that recipe and include the `ParticleSystem.h` file at the
    top of the application source file.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用之前菜谱中开发的相同粒子系统，即*在2D中创建粒子系统*。创建该菜谱中描述的`Particle`和`ParticleSystem`类，并在应用程序源文件顶部包含`ParticleSystem.h`文件。
- en: 'We will be creating a `Spring` class, so it is necessary to create the following
    files:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个`Spring`类，因此有必要创建以下文件：
- en: '`Spring.h`'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Spring.h`'
- en: '`Spring.cpp`'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Spring.cpp`'
- en: How to do it…
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现它...
- en: 'We will create springs that constrain the movement of particles. Perform the
    following steps to do so:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建约束粒子运动的弹簧。执行以下步骤以实现此目的：
- en: In the `Spring.h` file, we will declare a `Spring` class. The first thing we
    need to do is to add the `#pragma once` macro and include the necessary files.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Spring.h`文件中，我们将声明一个`Spring`类。首先，我们需要添加`#pragma once`宏并包含必要的文件。
- en: '[PRE71]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Next, declare the `Spring` class.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，声明`Spring`类。
- en: '[PRE72]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: We will add member variables, two `Particle` pointers to reference the particles
    that will be connected by this spring, and the `rest` and `strengthfloat` variables.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将添加成员变量，两个`Particle`指针以引用将通过此弹簧连接的粒子，以及`rest`和`strengthfloat`变量。
- en: '[PRE73]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Now we will declare the constructor that will take pointers to two `Particle`
    objects, and the `rest` and `strength` values.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将声明一个构造函数，它将接受两个`Particle`对象的指针以及`rest`和`strength`值。
- en: We will also declare the `update` and `draw` methods.
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还将声明`update`和`draw`方法。
- en: 'The following is the final `Spring` class declaration:'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下为最终的`Spring`类声明：
- en: '[PRE74]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Let's implement the `Spring` class in the `Spring.cpp` file.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`Spring.cpp`文件中实现`Spring`类。
- en: In the constructor, we will set the values of the member values to the ones
    passed in the arguments.
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在构造函数中，我们将成员变量的值设置为通过参数传入的值。
- en: '[PRE75]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: In the `update` method of the `Spring` class, we will calculate the difference
    between the particles' distance and the spring's rest distance, and adjust them
    accordingly.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Spring`类的`update`方法中，我们将计算粒子之间的距离与弹簧的平衡距离之间的差异，并相应地调整它们。
- en: '[PRE76]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: In the `draw` method of the `Spring` class, we will simply draw a line connecting
    both particles.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Spring`类的`draw`方法中，我们将简单地绘制一条连接两个粒子的线。
- en: '[PRE77]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Now we will have to make some changes in the `ParticleSystem` class to allow
    the addition of springs.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们必须在`ParticleSystem`类中进行一些更改，以允许添加弹簧。
- en: In the `ParticleSystem` file, include the `Spring.h` file.
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`ParticleSystem`文件中，包含`Spring.h`文件。
- en: '[PRE78]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Declare the `std::vector<Spring*>` member in the class declaration.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类声明中声明`std::vector<Spring*>`成员。
- en: '[PRE79]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Declare the `addSpring` and `destroySpring` methods to add and destroy springs
    to the system.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明`addSpring`和`destroySpring`方法，用于向系统中添加和销毁弹簧。
- en: 'The following is the final `ParticleSystem` class declaration:'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下为最终的`ParticleSystem`类声明：
- en: '[PRE80]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Let''s implement the `addSpring` method. In the `ParticleSystem.cpp` file,
    add the following code snippet:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们实现`addSpring`方法。在`ParticleSystem.cpp`文件中，添加以下代码片段：
- en: '[PRE81]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: In the implementation of `destroySpring`, we will find the correspondent iterator
    for the argument `Spring` and remove it from springs. We will also delete the
    object.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`destroySpring`方法的实现中，我们将找到对应于参数`Spring`的迭代器，并将其从弹簧中移除。我们还将删除该对象。
- en: 'Add the following code snippet in the `ParticleSystem.cpp` file:'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`ParticleSystem.cpp`文件中添加以下代码片段：
- en: '[PRE82]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: It is necessary to alter the `update` method to update all springs.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 必须修改`update`方法以更新所有弹簧。
- en: 'The following code snippet shows what the final update should look like:'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下代码片段显示了最终的更新应该看起来像什么：
- en: '[PRE83]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: In the `draw` method, we will also need to iterate over all springs and call
    the `draw` method on them.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`draw`方法中，我们还需要遍历所有弹簧并调用它们的`draw`方法。
- en: 'The final implementation of the `ParticleSystem::draw` method should be as
    follows:'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ParticleSystem::draw`方法的最终实现应该如下所示：'
- en: '[PRE84]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: We have finished creating the `Spring` class and making all necessary changes
    to the `ParticleSystem` class.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经完成了`Spring`类的创建和对`ParticleSystem`类所有必要更改的制作。
- en: 'Let''s go to our application''s class and include the `ParticleSystem.h` file:'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们转到我们的应用程序类并包含`ParticleSystem.h`文件：
- en: '[PRE85]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Declare a `ParticleSystem` object.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`ParticleSystem`对象。
- en: '[PRE86]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Create some random particles by adding the following code snippet to the `setup`
    method:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将以下代码片段添加到`setup`方法中，创建一些随机粒子：
- en: '[PRE87]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: In the `update` method, we will need to call the `update` method on `ParticleSystem`.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`update`方法中，我们需要调用`ParticleSystem`上的`update`方法。
- en: '[PRE88]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: In the `draw` method, clear the background, define the window's matrices, and
    call the `draw` method on `mParticleSystem`.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`draw`方法中，清除背景，定义窗口的矩阵，并在`mParticleSystem`上调用`draw`方法。
- en: '[PRE89]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Since we want to create springs whenever the user presses the mouse, we will
    need to declare the `mouseDown` method.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们希望在用户按下鼠标时创建弹簧，因此我们需要声明`mouseDown`方法。
- en: 'Add the following code snippet to your application''s class declaration:'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将以下代码片段添加到应用程序的类声明中：
- en: '[PRE90]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: In the `mouseDown` implementation we will connect two random particles.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`mouseDown`实现中，我们将连接两个随机粒子。
- en: Start by declaring a `Particle` pointer and defining it as a random particle
    in the particle system.
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先声明一个`Particle`指针并将其定义为粒子系统中的一个随机粒子。
- en: '[PRE91]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Now declare a second `Particle` pointer and make it equal to the first one.
    In the `while` loop, we will set its value to a random particle in `mParticleSystem`
    until both particles are different. This will avoid the case where both pointers
    point to the same particle.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在声明第二个`Particle`指针并将其设置为等于第一个指针。在`while`循环中，我们将将其值设置为`mParticleSystem`中的随机粒子，直到两个粒子不同。这将避免两个指针都指向同一粒子的情形。
- en: '[PRE92]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Now we'll create a `Spring` object that will connect both particles, define
    a random rest distance, and set `strength` to `1.0`. Add the created spring to
    `mParticleSystem`.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将创建一个`Spring`对象，它将连接两个粒子，定义一个随机的静止距离，并将`strength`设置为`1.0`。将创建的弹簧添加到`mParticleSystem`中。
- en: 'The following is the final `mouseDown` implementation:'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是最终的`mouseDown`实现：
- en: '[PRE93]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Build and run the application. Every time a mouse button is pressed, two particles
    will become connected with a white line and their distance will remain unchangeable.![How
    to do it…](img/87030s_5_11.jpg)
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行应用程序。每次按下鼠标按钮时，两个粒子将通过一条白色线条连接，并且它们的距离将保持不变。![如何操作…](img/87030s_5_11.jpg)
- en: How it works…
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A `Spring` object will calculate the difference between two particles and correct
    their positions, so that the distance between the two particles will be equal
    to the springs' rest value.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`Spring`对象将计算两个粒子之间的差异并修正它们的位置，以便两个粒子之间的距离等于弹簧的静止值。'
- en: By using their masses, we will also take into account each particle's mass,
    so that the correction will take into account the particles' weight.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用它们的质量，我们还将考虑每个粒子的质量，因此修正将考虑粒子的重量。
- en: There's more…
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The same principle can also be applied to particle systems in 3D.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的原理也可以应用于3D粒子系统。
- en: If you are using a 3D particle, as explained in the *There's more…* section
    of the *Creating a particle system in 2D* recipe, the `Spring` class simply needs
    to change its calculations to use `ci::Vec3f` instead of `ci::Vec2f`.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用3D粒子，如*在2D中创建粒子系统*食谱的*更多内容…*部分所述，`Spring`类只需将其计算更改为使用`ci::Vec3f`而不是`ci::Vec2f`。
- en: 'The `update` method of the `Spring` class would need to look like the following
    code snippet:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '`Spring`类的`update`方法将类似于以下代码片段：'
- en: '[PRE94]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
