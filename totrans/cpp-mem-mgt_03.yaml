- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Casts and cv-qualifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are progressing. In [*Chapter 1*](B21071_01.xhtml#_idTextAnchor016), we looked
    at what memory, objects, and pointers are, as we know we will need to understand
    these basic ideas if we are to take control of memory management mechanisms. Then,
    in [*Chapter 2*](B21071_02.xhtml#_idTextAnchor027), we looked at some low-level
    constructs that could get us in trouble if misused are essential to understand
    in certain situations to take control of how our programs manage memory. That’s
    a somewhat dry way to start, but that also means the fun parts of our work are
    still to come. I hope that’s encouraging!
  prefs: []
  type: TYPE_NORMAL
- en: At the end of [*Chapter 2*](B21071_02.xhtml#_idTextAnchor027), we examined approaches
    to type punning, a way to subvert the type system, including some that are believed
    to work by some but actually do not. C++ offers a number of controlled and explicit
    ways to interact with the type system, informing the compiler that it should see
    the type of an expression as something different than what it can otherwise infer
    from the source code. These tools, the **type casts** (or simply *casts*), are
    the subject of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We will first examine what casts are in the general sense, distinguishing the
    various fundamental reasons to perform casts and showing why C-style casts are
    mostly inappropriate (except for some specific cases) in a C++ program. Then,
    we will take a quick look at a safety-related aspect of the C++ system, **cv-qualifications**,
    and discuss the role of cv-qualifiers in the hygiene and overall quality of C++
    code. After that, we will examine the six C++ casts at our disposal. Finally,
    we will return to the C casts to show the limited situations in which they might
    still be appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: What casts are and what they mean in a program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What cv-qualifications are and how they interact with casts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What C++ casts are, including the C cast, and when they should be used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find the code files for this chapter in the book’s GitHub repository
    here: [https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter3](https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter3).'
  prefs: []
  type: TYPE_NORMAL
- en: What is a cast?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will use a cast to adjust the compiler’s view on the type of an expression.
    The thing is, the compiler sees our source code and understands what we wrote
    and what other people’s code expresses. Most of the time (hopefully), this code
    will make sense, and the compiler will translate your sources into proper binaries
    without complaining.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, of course, there will be (hopefully temporary) discrepancies between
    programmer intent and code, as expressed through the sources seen by the compiler.
    Most of the time, the compiler will be right, and the programmer will rewrite
    the source code, at least in part, in order to better express the intent, inspired
    by the error or warning messages that revealed (in their own poetic way) a problem.
    Sometimes, of course, the source code matches the programmer’s intent, but there
    are still disagreements with the compiler and adjustments required to attain some
    agreement with it. For example, suppose a programmer wants to allocate a buffer
    large enough to store `lots` of integers (`lots` being a value that’s either too
    large to reasonably use the stack or one that’s not known at compile time); one
    (low-level and error-prone but legal nonetheless) way to achieve this would be
    to call the `std::malloc()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This code excerpt, as you might know, is not valid C++ – `std::malloc()` returns
    `void*` (a pointer to a chunk of raw memory of at least the requested size, or
    `nullptr` if the allocation failed), and `void*` is not implicitly convertible
    to `int*` in C++ (the reverse is, of course, true –`int*` is indeed implicitly
    convertible to `void*`).
  prefs: []
  type: TYPE_NORMAL
- en: Note that we could have replaced `std::malloc(lots*sizeof(int))` with `new int[lots]`
    in this (oversimplified) case, but things are not always so simple, and sometimes,
    we need to lie to the type system, if only for a moment. And that’s where casts
    come in.
  prefs: []
  type: TYPE_NORMAL
- en: So, what are casts? Casts are a controlled way to guide the compiler’s type
    system in understanding programmer intent. Casts also provide information in source
    code about the reasons behind such temporary lies; they document what the programmer
    intended to do at the very moment when a lie was required. The C++ casts are very
    clear in the intent they are conveying and very precise in their effect; the C-style
    cast (also seen in other languages) is much more vague in matters of intent, as
    we will see later in this chapter, and can perform inappropriate transformations
    in a language with such a rich type system as C++.
  prefs: []
  type: TYPE_NORMAL
- en: Safety in the type system – cv-qualifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ provides two safety-related qualifiers in its type system. These are named
    `const` and `volatile`, and they are related in many ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `const` qualifier means the object thus qualified is considered immutable
    in the current scope, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Marking an object as `const` means that in the context where it is marked as
    such, it cannot be mutated. In the case of class members, the `const` guarantee
    is maintained transitively through `const` member functions, in the sense that
    a `const` member function cannot modify the members of `*this`, and nor can it
    call a non-`const` member function of the same object. In the preceding example,
    `X::f` is `const`, and as such, it could not call `X::g`, which does not offer
    that guarantee; allowing `X::f` to call `X::g` would effectively break the `const`
    guarantee, as `X::g` can mutate `*this` but `X::f` cannot.
  prefs: []
  type: TYPE_NORMAL
- en: The `const` qualifier is well-known and well-documented in C++. Being “`const`-correct”
    is generally seen as good code hygiene and is something you should strive to do
    in practice; using `const` wherever it makes sense is one of the strongest assets
    of the C++ language, and many languages claiming to be “type-safe” lack this essential
    feature, without which, correctness is so much harder to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: The `volatile` keyword is the counterpart to `const`; hence, the term *cv-qualifier*
    refers to both these terms. Woefully underdefined in the standard, `volatile`
    has a few meanings.
  prefs: []
  type: TYPE_NORMAL
- en: When applied to a fundamental type (for example, `volatile int`), it means that
    the object it qualifies could be accessed through ways unknown to the compiler
    and not necessarily visible from the source code. As such, this term is mostly
    useful when writing device drivers where some action external to the program itself
    (such as the physical pressure of a key) could change the memory associated with
    the object, or when some hardware or software component external to the source
    code could observe changes in that object’s state.
  prefs: []
  type: TYPE_NORMAL
- en: Informally, if the source code states, *“Please read the value of that volatile
    object,”* the code that will be generated should read that value even if the program
    does not seem to modify it in any way; likewise, if the source code states “*Please
    write to that* `volatile` *object,”* then a write to that memory location should
    occur, even if nothing in the program seems to read from that memory location
    subsequently. Thus, `volatile` can be seen as something that prevents optimizations
    that the compiler would otherwise be allowed to perform.
  prefs: []
  type: TYPE_NORMAL
- en: In C++’s abstract machine, accessing a `volatile`-qualified object is the moral
    equivalent of an I/O operation – it can change the state of the program. On an
    object of some class type, `volatile` can be applied to a member function just
    as `const` can. Indeed, a non-`static` member function can be qualified `const`,
    `volatile`, `const volatile`, or none of these (among other things).
  prefs: []
  type: TYPE_NORMAL
- en: The meaning of applying the `const` qualifier on a member function was described
    earlier with the `X::f` member function – `*this` is `const`; its non-`mutable`,
    non-`static` data members are `const` in that function, and the only non-`static`
    member functions that can be called through `*this` are those that are `const`-qualified.
    A non-`static` member function qualified as `volatile` is, likewise, quite similar
    – `*this` is `volatile` during that function’s execution, and so are all of its
    members, which impacts what operations you can perform with these objects. For
    example, taking the address of `volatile int` yields `volatile int*`, which is
    not implicitly convertible to `int*`, since the conversion would drop some security
    guarantees. This is one of the reasons why we have casts.
  prefs: []
  type: TYPE_NORMAL
- en: The C++ casts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Traditionally, C++ has supported four ways to perform those explicit type conversions
    we call casts – `static_cast`, `dynamic_cast`, `const_cast`, and `reinterpret_cast`.
    C++11 has added a fifth one, `duration_cast`, which is tangentially related to
    this book but will sometimes show up in examples, particularly when we measure
    the execution time of a function. Finally, C++20 introduced a sixth case, `bit_cast`,
    which is of interest to our work in this book.
  prefs: []
  type: TYPE_NORMAL
- en: The following sections give a brief overview of each C++ cast, along with a
    few examples of how and when they can be useful.
  prefs: []
  type: TYPE_NORMAL
- en: Your best friend (most of the time) – static_cast
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The best, most efficient tool in our type-casting toolset is `static_cast`.
    It’s mostly safe, costs essentially nothing in most cases, and can be used in
    a `constexpr` context, which makes it amenable to compile-time maneuvers.
  prefs: []
  type: TYPE_NORMAL
- en: You can use `static_cast` in situations involving potential risks, such as converting
    an `int` to a `float` or vice versa. In the latter case, it explicitly acknowledges
    the loss of the decimal part. You can also use `static_cast` to cast a pointer
    or a reference from a derived class to one of its direct or indirect bases (as
    long as there’s no ambiguity), which is totally safe and could be done implicitly,
    as well as from a base to one of its derived classes. Casting from a base class
    to a derived class using `static_cast` is highly efficient but extremely risky
    if the cast is incorrect, as it does not perform runtime checks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Pay special attention to the last use of `static_cast` of the preceding example
    – converting from a base class to one of its derived classes is appropriately
    done with `static_cast`. However, you must ensure that the conversion leads to
    an object of the chosen type, as there is no runtime verification made of the
    validity of that conversion; as the name implies, only compile-time checks are
    done with this cast. If you’re not sure of what you’re doing with a downcast,
    this is not the tool for you.
  prefs: []
  type: TYPE_NORMAL
- en: '`static_cast` does not only change the perspective of the compiler to the type
    of an expression; it also can adjust the memory address being accessed to take
    into account the types involved in the conversion. For example, when a `D` class
    has at least two non-empty base classes, `B0` and `B1`, these two parts of the
    derived class are not at the same address within a `D` object (if they were, they
    would overlap!), so `static_cast` from `D*` to one of its bases might yield a
    different address than that of `D*` itself. We will return to this when discussing
    `reinterpret_cast`, for which the behavior is different (and more dangerous).'
  prefs: []
  type: TYPE_NORMAL
- en: A sign something’s wrong – dynamic_cast
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There will be cases where you have a pointer or a reference to an object of
    some class type, and that type happens to be different from (but related to) the
    type needed. This often happens – for example, in game engines where most classes
    derive from some `Component` base and functions tend to take `Component*` arguments
    but need to access members from an object of the derived class they expect.
  prefs: []
  type: TYPE_NORMAL
- en: The main problem here is, typically, that the function’s interface is wrong
    – it accepts arguments of types that are insufficiently precise. Still, we all
    have software to deliver, and sometimes, we need to make things work even though
    we made some choices along the way that we will probably want to revisit later
    on.
  prefs: []
  type: TYPE_NORMAL
- en: The safe way to do such casts is `dynamic_cast`. This cast lets you convert
    a pointer or a reference from one type to another, related type in a way that
    lets you test whether the conversion worked or not; with pointers, an incorrect
    conversion yields `nullptr`, whereas with references, an incorrect conversion
    throws `std::bad_cast`. The relatedness of types with `dynamic_cast` is not limited
    to base-derived relationships and includes casting from one base to another base
    in a multiple inheritance design. However, note that, in most cases, `dynamic_cast`
    requires that the expression that is cast to another type is of the polymorphic
    type, in the sense that it must have at least one `virtual` member function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note that even though this example displays a message when `std::bad_cast` is
    thrown, this is in no way what we could call exception handling; we did not solve
    the “problem,” and code execution continues in a potentially corrupt state, which
    could make things worse in more serious code. In a toy example such as this, just
    letting code fail and stop executing would also have been a reasonable choice.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, the use of `dynamic_cast` should be rare, as it tends to be a sign
    that we chose our function interfaces in a perfectible manner. Note that `dynamic_cast`
    requires binaries to be compiled with **runtime type information** (**RTTI**)
    included, leading to larger binaries. Unsurprisingly, due to these costs, some
    application domains will tend to avoid this cast, and so will we.
  prefs: []
  type: TYPE_NORMAL
- en: Playing tricks with safety – const_cast
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Neither `static_cast` nor `dynamic_cast` (nor `reinterpret_cast`, for that matter)
    can change the cv-qualifiers of an expression; to do this, you need `const_cast`.
    With `const_cast`, you can add or remove the `const` or `volatile` qualifiers
    from an expression. As you might have guessed, this only makes sense on a pointer
    or on a reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why would you do something such as remove `const`-ness from an expression?
    Surprisingly, there are many situations where this comes in handy, but a common
    one is allowing the use of a `const`-correct type in a setting where `const`-ness
    was not used appropriately – for example, legacy code that did not use `const`,
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`const_cast` is a tool to play with the security of the type system; it should
    be used in specific, controlled situations and not to do unreasonable things such
    as changing the value of a mathematical constant, such as pi. If try something
    like that, you’ll incur **Undefined Behavior** (**UB**) – and rightfully so.'
  prefs: []
  type: TYPE_NORMAL
- en: “Believe me, compiler” – reinterpret_cast
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, you just have to make the compiler believe you. For example, knowing
    `sizeof(int)==4` on your platform, you might want to treat `int` as `char[4]`
    to interoperate with an existing API that expects that type. Note that you should
    ensure that this property holds (maybe through `static_assert`), rather than relying
    on the belief that this property holds on all platforms (it does not).
  prefs: []
  type: TYPE_NORMAL
- en: That’s what `reinterpret_cast` gives you – the ability to cast a pointer of
    some type to a pointer of an unrelated type. This can be used in situations where
    you seek to benefit from pointer-interconvertibility, as we saw in [*Chapter 2*](B21071_02.xhtml#_idTextAnchor027),
    just as this can be used to lie to the type system in several rather dangerous
    and non-portable ways.
  prefs: []
  type: TYPE_NORMAL
- en: Take the aforementioned conversion from an integer to an array of four bytes
    – if the aim is to facilitate addressing individual bytes, you have to be aware
    that the endianness of integers depends on the platform, as well as that the code
    written will probably be non-portable unless some careful measures are taken.
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that `reinterpret_cast` only changes the type associated with an
    expression – for example, it does not perform the slight address adjustments that
    `static_cast` would make when converting from a derived class to a base class
    in multiple inheritance situations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows the difference between these two casts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Use `reinterpret_cast` sparingly. Relatively safe uses include converting a
    pointer to an integral representation when given a sufficiently wide integral
    type (and vice versa), converting between null pointers of different types, and
    converting between function pointer types – although in that case, the results
    of calling the function through the resulting pointer are undefined. The complete
    list of conversions that can be performed with this cast can be found at [wg21.link/expr.reinterpret.cast](http://wg21.link/expr.reinterpret.cast)
    if you want to know more.
  prefs: []
  type: TYPE_NORMAL
- en: I know the bits are right – bit_cast
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C++20 introduced `bit_cast`, a new cast that can be used to copy bits from one
    object to another of the same width, starting the lifetime of the destination
    object (and the objects enclosed therein, if any) along the way, as long as both
    the source and destination types are trivially copyable. This somewhat magical
    library function can be found in the `<bit>` header and is `constexpr`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As can be seen in this example, both `A` and `B` are constructed at compile
    time and are bitwise identical to one another, but their addresses are different,
    as they are entirely different objects. Their data members are partially of different
    types but are of the same sizes, in the same order, and are all trivially copyable.
  prefs: []
  type: TYPE_NORMAL
- en: Also, note the use of a C-style cast on the last line of this example. As we
    will soon discuss, this is one of the few reasonable uses of C-style casts (we
    could have used `static_cast` here too and it would have been just as efficient).
  prefs: []
  type: TYPE_NORMAL
- en: Somewhat unrelated, but still – duration_cast
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We won’t dwell too long on `duration_cast`, as it is only tangentially related
    to our topic of interest, but since it will be part of our toolset for micro-benchmarking
    in this book, it at least deserves a mention.
  prefs: []
  type: TYPE_NORMAL
- en: The `duration_cast` library function can be found in the `<chrono>` header and
    is part of the `std::chrono` namespace. It is `constexpr` and can be used to convert
    between expressions of different measurement units.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose that we want to measure the time it took to execute some
    function, `f()`, using the `system_clock` provided by our library vendor. We can
    read that clock using its `now()` static member function before and after calling
    `f()`, which gives us two `time_point` objects for that clock (two moments in
    time), and then compute the difference between them to get a `duration` for that
    clock. We do not know what measurement unit was used to represent that duration,
    but if we want to use it expressed as, say, `microseconds`, we use `duration_cast`
    to perform than conversion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We will systematize our benchmarking practices later in this book, showing a
    more formal way to measure the execution time of functions or code blocks, but
    `duration_cast` will be our tool of choice to ensure that the format in which
    we present the results is appropriate for our needs.
  prefs: []
  type: TYPE_NORMAL
- en: The reviled one – the C cast
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You might be tempted to use C-style casts when type conversions are needed,
    as the C syntax appears in other languages and tends to be short to express –
    `(T)expr` treats expression, `expr`, as being of type `T`. That terseness is actually
    a downside, not an upside, as we will see. Limit C-style casts to a minimum in
    C++ code:'
  prefs: []
  type: TYPE_NORMAL
- en: The C-style casts are harder to find when performing an automated search through
    source code text, since they look like arguments in a function call. Since casts
    are ways through which we lie to the type system, revisiting the decision to use
    them from time to time is worthwhile, so being able to find them is valuable.
    In comparison, the C++ casts are keywords, which makes them easier to find.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A C-style cast does not convey information about why a conversion occurred.
    When writing `(T)expr`, we are not saying whether we want to change cv-qualifiers,
    navigate a class hierarchy, simply change to type of a pointer, and so on. In
    particular, when converting between pointers to different types, a C-style cast
    will generally behave as `reinterpret_cast`, which, as we have seen, can lead
    to disastrous results in some circumstances.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will sometimes see C-style casts in C++ code, mostly for situations where
    the intent is absolutely clear. We saw an example at the end of our `bit_cast`
    section. Another example would be to silence compiler warnings – for example,
    when calling a function that’s `[[nodiscard]]` but still really wanting to discard
    the results nonetheless for some reason.
  prefs: []
  type: TYPE_NORMAL
- en: 'In yet another example, consider the following generic function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This function iterates through two sequences that are delimited, respectively,
    by `[bA,eA)` and `[bB,eB)` (making sure to stop as soon as the shortest sequence
    has been processed), compares the elements at the “same position” in these two
    sequences, and yields `true` only if all comparisons between elements of those
    two sequences are equal.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the cast to `void` uses a C-style cast between the increments of `bA`
    and `bB` in this code, which cast the result of `++bB` to `void`. This may look
    strange, but this is code that can be used in many situations by pretty much anyone,
    including hostile (or distracted) users. Suppose someone with a twisted mind had
    decided to overload the comma operator (yes, you can do that) between the types
    of `operator++(ItA)` and `operator++(ItB)`. That person could then essentially
    hijack our function to run unexpected code. By casting one of the arguments to
    `void`, we ensure that this is not possible.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That concludes our quick overview of casts and cv-qualifications in C++. Now
    that we’ve seen some ways to trick the type system and get in trouble, as well
    as know why we should do these things carefully (if at all), we can start building
    beautiful things with C++ and work toward safe, efficient abstractions in our
    endeavor to write correct programs that control how we manage memory.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will start by using one of the language’s defining features,
    the destructor, to automate the way our code handles resources, with an eye in
    particular on the way memory is handled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 2: Implicit Memory Management Techniques'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, we will examine some well-known approaches to implicit resource
    management (including memory management) in C++. These are all techniques you
    can use in your daily programming practices that will lead to simpler and safer
    programs than what you would get if you wanted to manage memory explicitly. You
    could say that the chapters in this part concern what people call “modern” or
    “contemporary” C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 4*](B21071_04.xhtml#_idTextAnchor062), *Using Destructors*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B21071_05.xhtml#_idTextAnchor079), *Using Standard Smart Pointers*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B21071_06.xhtml#_idTextAnchor096), *Writing Smart Pointers*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
