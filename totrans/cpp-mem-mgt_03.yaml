- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Casts and cv-qualifications
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型转换和cv-qualifications
- en: We are progressing. In [*Chapter 1*](B21071_01.xhtml#_idTextAnchor016), we looked
    at what memory, objects, and pointers are, as we know we will need to understand
    these basic ideas if we are to take control of memory management mechanisms. Then,
    in [*Chapter 2*](B21071_02.xhtml#_idTextAnchor027), we looked at some low-level
    constructs that could get us in trouble if misused are essential to understand
    in certain situations to take control of how our programs manage memory. That’s
    a somewhat dry way to start, but that also means the fun parts of our work are
    still to come. I hope that’s encouraging!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在进步。在[*第1章*](B21071_01.xhtml#_idTextAnchor016)中，我们探讨了内存、对象和指针是什么，因为我们知道如果我们想要掌握内存管理机制，我们就需要理解这些基本概念。然后在[*第2章*](B21071_02.xhtml#_idTextAnchor027)中，我们查看了一些低级构造，如果误用可能会给我们带来麻烦，但在某些情况下理解这些构造对于掌握程序如何管理内存是至关重要的。这是一个相对枯燥的开端，但也意味着我们工作的有趣部分还在后面。我希望这能给你带来鼓舞！
- en: At the end of [*Chapter 2*](B21071_02.xhtml#_idTextAnchor027), we examined approaches
    to type punning, a way to subvert the type system, including some that are believed
    to work by some but actually do not. C++ offers a number of controlled and explicit
    ways to interact with the type system, informing the compiler that it should see
    the type of an expression as something different than what it can otherwise infer
    from the source code. These tools, the **type casts** (or simply *casts*), are
    the subject of this chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第2章*](B21071_02.xhtml#_idTextAnchor027)的结尾，我们探讨了类型欺骗的方法，这是一种绕过类型系统的方法，包括一些被认为可以工作但实际上并不奏效的方法。C++提供了一些受控和明确的方式来与类型系统交互，通知编译器它应该将表达式的类型视为与从源代码中推断出的不同。这些工具，即**类型转换**（或简称*转换*），是本章的主题。
- en: We will first examine what casts are in the general sense, distinguishing the
    various fundamental reasons to perform casts and showing why C-style casts are
    mostly inappropriate (except for some specific cases) in a C++ program. Then,
    we will take a quick look at a safety-related aspect of the C++ system, **cv-qualifications**,
    and discuss the role of cv-qualifiers in the hygiene and overall quality of C++
    code. After that, we will examine the six C++ casts at our disposal. Finally,
    we will return to the C casts to show the limited situations in which they might
    still be appropriate.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将探讨在一般意义上什么是类型转换，区分进行类型转换的各种基本原因，并说明为什么在C++程序中C风格类型转换通常是不合适的（除了某些特定情况）。然后，我们将快速查看C++系统的一个与安全相关的方面，即**cv-qualifications**，并讨论cv限定符在C++代码的卫生性和整体质量中的作用。之后，我们将检查我们可用的六个C++类型转换。最后，我们将回到C类型转换，以展示它们在何种有限情况下可能仍然适用。
- en: 'In this chapter, we will learn the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下内容：
- en: What casts are and what they mean in a program
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型转换是什么以及它们在程序中的含义
- en: What cv-qualifications are and how they interact with casts
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: cv-qualifications是什么以及它们如何与类型转换交互
- en: What C++ casts are, including the C cast, and when they should be used
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++类型转换是什么，包括C类型转换，以及何时应该使用它们
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find the code files for this chapter in the book’s GitHub repository
    here: [https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter3](https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter3).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书的GitHub仓库中找到本章的代码文件：[https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter3](https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter3)。
- en: What is a cast?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是类型转换？
- en: You will use a cast to adjust the compiler’s view on the type of an expression.
    The thing is, the compiler sees our source code and understands what we wrote
    and what other people’s code expresses. Most of the time (hopefully), this code
    will make sense, and the compiler will translate your sources into proper binaries
    without complaining.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用类型转换来调整编译器对表达式类型的看法。问题是，编译器看到我们的源代码，理解我们写了什么，以及别人的代码表达了什么。大多数时候（希望如此），这段代码是有意义的，编译器将把你的源代码转换为适当的二进制文件而不会抱怨。
- en: 'Sometimes, of course, there will be (hopefully temporary) discrepancies between
    programmer intent and code, as expressed through the sources seen by the compiler.
    Most of the time, the compiler will be right, and the programmer will rewrite
    the source code, at least in part, in order to better express the intent, inspired
    by the error or warning messages that revealed (in their own poetic way) a problem.
    Sometimes, of course, the source code matches the programmer’s intent, but there
    are still disagreements with the compiler and adjustments required to attain some
    agreement with it. For example, suppose a programmer wants to allocate a buffer
    large enough to store `lots` of integers (`lots` being a value that’s either too
    large to reasonably use the stack or one that’s not known at compile time); one
    (low-level and error-prone but legal nonetheless) way to achieve this would be
    to call the `std::malloc()` function:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有时程序员意图与代码之间会有（希望是暂时的）差异，这种差异通过编译器看到的源代码表达出来。大多数时候，编译器是正确的，程序员会重写源代码，至少部分地，以便更好地表达意图，受到揭示问题的错误或警告信息的启发（以它们自己诗意的方式）。当然，有时源代码与程序员的意图相匹配，但仍然与编译器存在分歧，需要调整以达到某种程度的共识。例如，假设程序员想要分配一个足够大的缓冲区来存储大量的整数（`lots`
    是一个太大以至于无法合理使用栈或编译时未知的值）；实现这一目标的一种（低级且容易出错但仍然合法）方法就是调用 `std::malloc()` 函数：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This code excerpt, as you might know, is not valid C++ – `std::malloc()` returns
    `void*` (a pointer to a chunk of raw memory of at least the requested size, or
    `nullptr` if the allocation failed), and `void*` is not implicitly convertible
    to `int*` in C++ (the reverse is, of course, true –`int*` is indeed implicitly
    convertible to `void*`).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，这段代码摘录不是有效的C++代码 – `std::malloc()` 返回 `void*`（一个指向至少请求大小的原始内存块的指针，如果分配失败则返回
    `nullptr`），而在C++中 `void*` 不能隐式转换为 `int*`（反之亦然，当然，`int*` 可以隐式转换为 `void*`）。
- en: Note that we could have replaced `std::malloc(lots*sizeof(int))` with `new int[lots]`
    in this (oversimplified) case, but things are not always so simple, and sometimes,
    we need to lie to the type system, if only for a moment. And that’s where casts
    come in.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这种情况下，我们可以用 `new int[lots]` 替换 `std::malloc(lots*sizeof(int))`（这是一个过于简化的例子），但事情并不总是这么简单，有时我们需要对类型系统撒谎，即使只是一瞬间。这就是类型转换的作用所在。
- en: So, what are casts? Casts are a controlled way to guide the compiler’s type
    system in understanding programmer intent. Casts also provide information in source
    code about the reasons behind such temporary lies; they document what the programmer
    intended to do at the very moment when a lie was required. The C++ casts are very
    clear in the intent they are conveying and very precise in their effect; the C-style
    cast (also seen in other languages) is much more vague in matters of intent, as
    we will see later in this chapter, and can perform inappropriate transformations
    in a language with such a rich type system as C++.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是类型转换呢？类型转换是一种受控的方式来引导编译器的类型系统理解程序员的意图。类型转换还在源代码中提供了关于这种暂时性谎言背后原因的信息；它们记录了程序员在需要撒谎的那一刻的意图。C++的类型转换在传达意图方面非常明确，在效果上非常精确；C风格类型转换（在其他语言中也可见）在意图方面更为模糊，正如我们将在本章后面看到的那样，并且可以在具有如此丰富类型系统的C++语言中执行不适当的转换。
- en: Safety in the type system – cv-qualifications
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型系统中的安全性 – cv-资格
- en: C++ provides two safety-related qualifiers in its type system. These are named
    `const` and `volatile`, and they are related in many ways.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: C++在其类型系统中提供了两个与安全性相关的资格符。这些被称为 `const` 和 `volatile`，它们在许多方面都有关联。
- en: 'The `const` qualifier means the object thus qualified is considered immutable
    in the current scope, such as the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`const` 资格符表示被此资格符指定的对象在当前作用域中被认为是不可变的，例如以下情况：'
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Marking an object as `const` means that in the context where it is marked as
    such, it cannot be mutated. In the case of class members, the `const` guarantee
    is maintained transitively through `const` member functions, in the sense that
    a `const` member function cannot modify the members of `*this`, and nor can it
    call a non-`const` member function of the same object. In the preceding example,
    `X::f` is `const`, and as such, it could not call `X::g`, which does not offer
    that guarantee; allowing `X::f` to call `X::g` would effectively break the `const`
    guarantee, as `X::g` can mutate `*this` but `X::f` cannot.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个对象标记为 `const` 意味着在它被标记为这样的上下文中，它不能被修改。在类成员的情况下，`const` 保证通过 `const` 成员函数传递，也就是说，一个
    `const` 成员函数不能修改 `*this` 的成员，也不能调用同一对象的非 `const` 成员函数。在前面的例子中，`X::f` 是 `const`
    的，因此它不能调用 `X::g`，后者不提供这种保证；允许 `X::f` 调用 `X::g` 将实际上破坏 `const` 保证，因为 `X::g` 可以修改
    `*this`，而 `X::f` 不能。
- en: The `const` qualifier is well-known and well-documented in C++. Being “`const`-correct”
    is generally seen as good code hygiene and is something you should strive to do
    in practice; using `const` wherever it makes sense is one of the strongest assets
    of the C++ language, and many languages claiming to be “type-safe” lack this essential
    feature, without which, correctness is so much harder to achieve.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`const` 标记在 C++ 中是众所周知且文档齐全的。通常认为“`const`-correct”是良好的代码卫生习惯，并且在实践中应该努力做到；在合理的地方使用
    `const` 是 C++ 语言最强大的特性之一，许多声称自己是“类型安全”的语言缺乏这一基本特性，没有它，正确性就难以实现。'
- en: The `volatile` keyword is the counterpart to `const`; hence, the term *cv-qualifier*
    refers to both these terms. Woefully underdefined in the standard, `volatile`
    has a few meanings.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`volatile` 关键字是 `const` 的对应词；因此，术语 *cv-qualifier* 指的是这两个术语。在标准中定义得相当不充分，`volatile`
    有几种含义。'
- en: When applied to a fundamental type (for example, `volatile int`), it means that
    the object it qualifies could be accessed through ways unknown to the compiler
    and not necessarily visible from the source code. As such, this term is mostly
    useful when writing device drivers where some action external to the program itself
    (such as the physical pressure of a key) could change the memory associated with
    the object, or when some hardware or software component external to the source
    code could observe changes in that object’s state.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用于基本类型（例如，`volatile int`）时，它意味着它所指定的对象可能通过编译器所不知的方式访问，并且不一定从源代码中可见。因此，这个术语在编写设备驱动程序时非常有用，其中程序本身之外的动作（例如，按键的物理压力）可能会改变与对象关联的内存，或者当某些硬件或软件组件（在源代码之外）可以观察该对象状态的变化时。
- en: Informally, if the source code states, *“Please read the value of that volatile
    object,”* the code that will be generated should read that value even if the program
    does not seem to modify it in any way; likewise, if the source code states “*Please
    write to that* `volatile` *object,”* then a write to that memory location should
    occur, even if nothing in the program seems to read from that memory location
    subsequently. Thus, `volatile` can be seen as something that prevents optimizations
    that the compiler would otherwise be allowed to perform.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 非正式地说，如果源代码声明“*请读取那个 `volatile` 对象的值”，那么生成的代码应该读取那个值，即使程序看起来没有以任何方式修改它；同样，如果源代码声明“*请写入那个*
    `volatile` 对象”，那么应该向那个内存位置写入，即使程序看起来在随后的操作中没有从那个内存位置读取。因此，`volatile` 可以被视为一种防止编译器执行其本可以执行优化的机制。
- en: In C++’s abstract machine, accessing a `volatile`-qualified object is the moral
    equivalent of an I/O operation – it can change the state of the program. On an
    object of some class type, `volatile` can be applied to a member function just
    as `const` can. Indeed, a non-`static` member function can be qualified `const`,
    `volatile`, `const volatile`, or none of these (among other things).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 的抽象机器中，访问 `volatile` 标记的对象相当于 I/O 操作的道德等价物——它可以改变程序的状态。对于某些类类型的对象，`volatile`
    可以应用于成员函数，就像 `const` 一样。实际上，一个非 `static` 成员函数可以是 `const`、`volatile`、`const volatile`
    或这些都不是（以及其他事项）。
- en: The meaning of applying the `const` qualifier on a member function was described
    earlier with the `X::f` member function – `*this` is `const`; its non-`mutable`,
    non-`static` data members are `const` in that function, and the only non-`static`
    member functions that can be called through `*this` are those that are `const`-qualified.
    A non-`static` member function qualified as `volatile` is, likewise, quite similar
    – `*this` is `volatile` during that function’s execution, and so are all of its
    members, which impacts what operations you can perform with these objects. For
    example, taking the address of `volatile int` yields `volatile int*`, which is
    not implicitly convertible to `int*`, since the conversion would drop some security
    guarantees. This is one of the reasons why we have casts.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的描述中，关于在成员函数上应用`const`限定符的意义是通过`X::f`成员函数来阐述的——`*this`是`const`；在该函数中，其非`mutable`、非`static`的数据成员是`const`的，并且只有那些带有`const`限定符的成员函数才能通过`*this`来调用。同样，被`volatile`限定的非`static`成员函数也非常相似——在该函数执行期间，`*this`是`volatile`的，以及它的所有成员也都是`volatile`的，这会影响你可以对这些对象执行的操作。例如，取`volatile
    int`的地址会得到`volatile int*`，这不能隐式转换为`int*`，因为转换会丢失一些安全保证。这也是我们为什么有类型转换的原因之一。
- en: The C++ casts
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++的类型转换
- en: Traditionally, C++ has supported four ways to perform those explicit type conversions
    we call casts – `static_cast`, `dynamic_cast`, `const_cast`, and `reinterpret_cast`.
    C++11 has added a fifth one, `duration_cast`, which is tangentially related to
    this book but will sometimes show up in examples, particularly when we measure
    the execution time of a function. Finally, C++20 introduced a sixth case, `bit_cast`,
    which is of interest to our work in this book.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，C++支持四种执行我们称为类型转换的显式类型转换方式——`static_cast`、`dynamic_cast`、`const_cast`和`reinterpret_cast`。C++11添加了第五种，`duration_cast`，它与本书相关，但有时会出现在示例中，尤其是在我们测量函数执行时间时。最后，C++20引入了第六种情况，`bit_cast`，这对于本书中的工作很有兴趣。
- en: The following sections give a brief overview of each C++ cast, along with a
    few examples of how and when they can be useful.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几节简要概述了每种C++类型转换，并附带了一些示例，说明它们何时以及如何有用。
- en: Your best friend (most of the time) – static_cast
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你最好的朋友（大多数时候）——`static_cast`
- en: The best, most efficient tool in our type-casting toolset is `static_cast`.
    It’s mostly safe, costs essentially nothing in most cases, and can be used in
    a `constexpr` context, which makes it amenable to compile-time maneuvers.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的类型转换工具集中，`static_cast`是最好的、最有效的工具。它大多数情况下是安全的，基本上不花费任何成本，并且可以在`constexpr`上下文中使用，这使得它适合于编译时操作。
- en: You can use `static_cast` in situations involving potential risks, such as converting
    an `int` to a `float` or vice versa. In the latter case, it explicitly acknowledges
    the loss of the decimal part. You can also use `static_cast` to cast a pointer
    or a reference from a derived class to one of its direct or indirect bases (as
    long as there’s no ambiguity), which is totally safe and could be done implicitly,
    as well as from a base to one of its derived classes. Casting from a base class
    to a derived class using `static_cast` is highly efficient but extremely risky
    if the cast is incorrect, as it does not perform runtime checks.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在涉及潜在风险的情境中使用`static_cast`，例如将`int`转换为`float`或相反。在后一种情况下，它明确承认了小数部分的丢失。你还可以使用`static_cast`将指针或引用从派生类转换为它的直接或间接基类（只要没有歧义），这是完全安全的，也可以隐式地进行，以及从基类转换为它的派生类。使用`static_cast`从基类到派生类的转换效率很高，但如果转换不正确，风险极高，因为它不执行运行时检查。
- en: 'Here are some examples:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 下面有一些示例：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Pay special attention to the last use of `static_cast` of the preceding example
    – converting from a base class to one of its derived classes is appropriately
    done with `static_cast`. However, you must ensure that the conversion leads to
    an object of the chosen type, as there is no runtime verification made of the
    validity of that conversion; as the name implies, only compile-time checks are
    done with this cast. If you’re not sure of what you’re doing with a downcast,
    this is not the tool for you.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意前一个示例中`static_cast`的最后使用——从基类转换为其派生类之一是适当地使用`static_cast`完成的。然而，你必须确保转换会导致所选类型的对象，因为不会对转换的有效性进行运行时验证；正如其名称所暗示的，这个转换只进行编译时检查。如果你不确定如何使用向下转换，这不是你需要的工具。
- en: '`static_cast` does not only change the perspective of the compiler to the type
    of an expression; it also can adjust the memory address being accessed to take
    into account the types involved in the conversion. For example, when a `D` class
    has at least two non-empty base classes, `B0` and `B1`, these two parts of the
    derived class are not at the same address within a `D` object (if they were, they
    would overlap!), so `static_cast` from `D*` to one of its bases might yield a
    different address than that of `D*` itself. We will return to this when discussing
    `reinterpret_cast`, for which the behavior is different (and more dangerous).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`static_cast` 不仅改变编译器对表达式类型的看法；它还可以调整访问的内存地址，以考虑转换中涉及的类型。例如，当 `D` 类至少有两个非空的基类
    `B0` 和 `B1` 时，这个派生类的这两个部分在 `D` 对象中的地址并不相同（如果它们是相同的，它们就会重叠！），所以从 `D*` 到其基类之一的 `static_cast`
    可能会产生与 `D*` 本身不同的地址。我们将在讨论 `reinterpret_cast` 时回到这一点，对于 `reinterpret_cast`，其行为不同（且更危险）。'
- en: A sign something’s wrong – dynamic_cast
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 出现问题的迹象——`dynamic_cast`
- en: There will be cases where you have a pointer or a reference to an object of
    some class type, and that type happens to be different from (but related to) the
    type needed. This often happens – for example, in game engines where most classes
    derive from some `Component` base and functions tend to take `Component*` arguments
    but need to access members from an object of the derived class they expect.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有时会遇到这样的情况，你有一个指向某个类类型对象的指针或引用，而这个类型恰好与所需的类型不同（但相关）。这种情况经常发生——例如，在游戏引擎中，大多数类都从某个
    `Component` 基类派生，函数通常接受 `Component*` 参数，但需要访问期望的派生类对象的成员。
- en: The main problem here is, typically, that the function’s interface is wrong
    – it accepts arguments of types that are insufficiently precise. Still, we all
    have software to deliver, and sometimes, we need to make things work even though
    we made some choices along the way that we will probably want to revisit later
    on.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要问题是，通常，函数的接口是错误的——它接受类型不足够精确的参数。尽管如此，我们都有软件要交付，有时，即使我们在过程中做出了我们可能希望以后重新审视的一些选择，我们也需要让事情工作。
- en: The safe way to do such casts is `dynamic_cast`. This cast lets you convert
    a pointer or a reference from one type to another, related type in a way that
    lets you test whether the conversion worked or not; with pointers, an incorrect
    conversion yields `nullptr`, whereas with references, an incorrect conversion
    throws `std::bad_cast`. The relatedness of types with `dynamic_cast` is not limited
    to base-derived relationships and includes casting from one base to another base
    in a multiple inheritance design. However, note that, in most cases, `dynamic_cast`
    requires that the expression that is cast to another type is of the polymorphic
    type, in the sense that it must have at least one `virtual` member function.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 进行此类转换的安全方法是 `dynamic_cast`。这种转换允许你将指针或引用从一个类型转换为另一个相关类型，以便你可以测试转换是否成功；对于指针，不正确的转换会产生
    `nullptr`，而对于引用，不正确的转换会抛出 `std::bad_cast`。`dynamic_cast` 的类型相关性不仅限于基类派生关系，还包括在多重继承设计中从一个基类到另一个基类的转换。然而，请注意，在大多数情况下，`dynamic_cast`
    要求要转换的表达式是具有至少一个 `virtual` 成员函数的多态类型。
- en: 'Here are some examples:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些例子：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that even though this example displays a message when `std::bad_cast` is
    thrown, this is in no way what we could call exception handling; we did not solve
    the “problem,” and code execution continues in a potentially corrupt state, which
    could make things worse in more serious code. In a toy example such as this, just
    letting code fail and stop executing would also have been a reasonable choice.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管这个例子在抛出 `std::bad_cast` 时显示了一条消息，但这绝对不能称为异常处理；我们没有解决“问题”，代码执行在可能已损坏的状态下继续，这可能会在更严重的代码中使事情变得更糟。在这个玩具示例中，只是让代码失败并停止执行也是一个合理的选择。
- en: In practice, the use of `dynamic_cast` should be rare, as it tends to be a sign
    that we chose our function interfaces in a perfectible manner. Note that `dynamic_cast`
    requires binaries to be compiled with **runtime type information** (**RTTI**)
    included, leading to larger binaries. Unsurprisingly, due to these costs, some
    application domains will tend to avoid this cast, and so will we.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，`dynamic_cast` 的使用应该是罕见的，因为它往往是我们以可完善的方式选择了函数接口的标志。请注意，`dynamic_cast` 需要编译时包含
    **运行时类型信息**（**RTTI**），这会导致二进制文件更大。不出所料，由于这些成本，一些应用领域可能会避免使用这种转换，我们也会这样做。
- en: Playing tricks with safety – const_cast
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 玩弄安全性的把戏——`const_cast`
- en: Neither `static_cast` nor `dynamic_cast` (nor `reinterpret_cast`, for that matter)
    can change the cv-qualifiers of an expression; to do this, you need `const_cast`.
    With `const_cast`, you can add or remove the `const` or `volatile` qualifiers
    from an expression. As you might have guessed, this only makes sense on a pointer
    or on a reference.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是 `static_cast` 还是 `dynamic_cast`（甚至包括 `reinterpret_cast`），都不能改变表达式的 cv-限定符；要实现这一点，你需要
    `const_cast`。使用 `const_cast`，你可以从表达式中添加或移除 `const` 或 `volatile` 限定符。正如你可能已经猜到的，这仅在指针或引用上才有意义。
- en: 'Why would you do something such as remove `const`-ness from an expression?
    Surprisingly, there are many situations where this comes in handy, but a common
    one is allowing the use of a `const`-correct type in a setting where `const`-ness
    was not used appropriately – for example, legacy code that did not use `const`,
    such as the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么你会做诸如从表达式中移除 `const` 限定符之类的事情呢？令人惊讶的是，有许多情况下这很有用，但一个常见的情况是允许在 `const` 限定符未适当使用的情况下使用
    `const`-correct 类型——例如，未使用 `const` 的遗留代码，如下所示：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`const_cast` is a tool to play with the security of the type system; it should
    be used in specific, controlled situations and not to do unreasonable things such
    as changing the value of a mathematical constant, such as pi. If try something
    like that, you’ll incur **Undefined Behavior** (**UB**) – and rightfully so.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`const_cast` 是一个用于玩弄类型系统安全性的工具；它应在特定、受控的情况下使用，而不是做不合理的事情，比如改变数学常数（如 pi）的值。如果你尝试这样做，你将遇到
    **未定义行为**（**UB**）——这是理所当然的。'
- en: “Believe me, compiler” – reinterpret_cast
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “相信我，编译器”—— reinterpret_cast
- en: Sometimes, you just have to make the compiler believe you. For example, knowing
    `sizeof(int)==4` on your platform, you might want to treat `int` as `char[4]`
    to interoperate with an existing API that expects that type. Note that you should
    ensure that this property holds (maybe through `static_assert`), rather than relying
    on the belief that this property holds on all platforms (it does not).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你只是要让编译器相信你。例如，知道在你的平台上 `sizeof(int)==4`，你可能想将 `int` 作为 `char[4]` 来与期望该类型的现有
    API 进行交互。请注意，你应该确保这个属性成立（可能通过 `static_assert`），而不是依赖于所有平台上这个属性都成立（它并不成立）。
- en: That’s what `reinterpret_cast` gives you – the ability to cast a pointer of
    some type to a pointer of an unrelated type. This can be used in situations where
    you seek to benefit from pointer-interconvertibility, as we saw in [*Chapter 2*](B21071_02.xhtml#_idTextAnchor027),
    just as this can be used to lie to the type system in several rather dangerous
    and non-portable ways.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 `reinterpret_cast` 给你的——将某种类型的指针转换为无关类型的指针的能力。这可以在我们看到的[*第2章*](B21071_02.xhtml#_idTextAnchor027)中寻求利用指针互转换性的情况下使用，就像这也可以以几种相当危险且不便携的方式欺骗类型系统一样。
- en: Take the aforementioned conversion from an integer to an array of four bytes
    – if the aim is to facilitate addressing individual bytes, you have to be aware
    that the endianness of integers depends on the platform, as well as that the code
    written will probably be non-portable unless some careful measures are taken.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以从整数到四个字节的数组的上述转换为例——如果目的是为了便于对单个字节进行寻址，你必须意识到整数的字节序取决于平台，以及除非采取一些谨慎的措施，否则所编写的代码可能是不便携的。
- en: Also, note that `reinterpret_cast` only changes the type associated with an
    expression – for example, it does not perform the slight address adjustments that
    `static_cast` would make when converting from a derived class to a base class
    in multiple inheritance situations.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，`reinterpret_cast` 只改变与表达式关联的类型——例如，它不会执行 `static_cast` 在多重继承情况下从派生类转换为基类时所做的轻微地址调整。
- en: 'The following example shows the difference between these two casts:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了这两种转换之间的区别：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Use `reinterpret_cast` sparingly. Relatively safe uses include converting a
    pointer to an integral representation when given a sufficiently wide integral
    type (and vice versa), converting between null pointers of different types, and
    converting between function pointer types – although in that case, the results
    of calling the function through the resulting pointer are undefined. The complete
    list of conversions that can be performed with this cast can be found at [wg21.link/expr.reinterpret.cast](http://wg21.link/expr.reinterpret.cast)
    if you want to know more.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 请谨慎使用 `reinterpret_cast`。相对安全的使用包括在给定足够宽的整型类型时将指针转换为整型表示（反之亦然），在转换不同类型的空指针之间，以及在函数指针类型之间进行转换——尽管在这种情况下，通过结果指针调用函数的结果是未定义的。如果您想了解更多，可以查看使用此转换可以执行的所有转换的完整列表，请参阅
    [wg21.link/expr.reinterpret.cast](http://wg21.link/expr.reinterpret.cast)。
- en: I know the bits are right – bit_cast
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我知道位是正确的——`bit_cast`
- en: C++20 introduced `bit_cast`, a new cast that can be used to copy bits from one
    object to another of the same width, starting the lifetime of the destination
    object (and the objects enclosed therein, if any) along the way, as long as both
    the source and destination types are trivially copyable. This somewhat magical
    library function can be found in the `<bit>` header and is `constexpr`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: C++20 引入了 `bit_cast`，这是一种新的转换，可以用来从一个对象复制位到另一个相同宽度的对象，在复制过程中开始目标对象（以及其中可能包含的对象）的生命周期，只要源和目标类型都是简单可复制的。这个有点神奇的库函数可以在
    `<bit>` 头文件中找到，并且是 `constexpr` 的。
- en: 'Here’s an example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As can be seen in this example, both `A` and `B` are constructed at compile
    time and are bitwise identical to one another, but their addresses are different,
    as they are entirely different objects. Their data members are partially of different
    types but are of the same sizes, in the same order, and are all trivially copyable.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如此例所示，`A` 和 `B` 都是在编译时构建的，并且它们在位上是相同的，但它们的地址是不同的，因为它们是完全不同的对象。它们的数据成员部分是不同类型的，但大小相同，顺序相同，并且都是简单可复制的。
- en: Also, note the use of a C-style cast on the last line of this example. As we
    will soon discuss, this is one of the few reasonable uses of C-style casts (we
    could have used `static_cast` here too and it would have been just as efficient).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意在此示例的最后一行使用了 C 风格的转换。正如我们很快将要讨论的，这是 C 风格转换的少数合理用途之一（我们也可以在这里使用 `static_cast`，它同样高效）。
- en: Somewhat unrelated, but still – duration_cast
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有点不相关，但仍然——`duration_cast`
- en: We won’t dwell too long on `duration_cast`, as it is only tangentially related
    to our topic of interest, but since it will be part of our toolset for micro-benchmarking
    in this book, it at least deserves a mention.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会过多地讨论 `duration_cast`，因为它与我们感兴趣的主题只有间接关系，但既然它将是本书中微基准测试工具集的一部分，它至少值得提一下。
- en: The `duration_cast` library function can be found in the `<chrono>` header and
    is part of the `std::chrono` namespace. It is `constexpr` and can be used to convert
    between expressions of different measurement units.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`duration_cast` 库函数可以在 `<chrono>` 头文件中找到，它是 `std::chrono` 命名空间的一部分。它是 `constexpr`
    的，并且可以用来在表示不同测量单位的表达式之间进行转换。'
- en: 'For example, suppose that we want to measure the time it took to execute some
    function, `f()`, using the `system_clock` provided by our library vendor. We can
    read that clock using its `now()` static member function before and after calling
    `f()`, which gives us two `time_point` objects for that clock (two moments in
    time), and then compute the difference between them to get a `duration` for that
    clock. We do not know what measurement unit was used to represent that duration,
    but if we want to use it expressed as, say, `microseconds`, we use `duration_cast`
    to perform than conversion:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想要测量执行某个函数 `f()` 所花费的时间，使用我们库供应商提供的 `system_clock`。我们可以在调用 `f()` 之前和之后使用它的
    `now()` 静态成员函数来读取那个时钟，这给了我们该时钟的两个 `time_point` 对象（两个时间点），然后计算它们之间的差异以获得该时钟的 `duration`。我们不知道用来表示该持续时间的测量单位是什么，但如果我们想以，比如说，`microseconds`
    的形式使用它，我们使用 `duration_cast` 来执行那个转换：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We will systematize our benchmarking practices later in this book, showing a
    more formal way to measure the execution time of functions or code blocks, but
    `duration_cast` will be our tool of choice to ensure that the format in which
    we present the results is appropriate for our needs.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的后面部分系统地介绍我们的基准测试实践，展示一种更正式的方式来衡量函数或代码块的执行时间，但 `duration_cast` 将成为我们选择用来确保我们展示结果格式的工具。
- en: The reviled one – the C cast
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可恶的一个——C 转换
- en: 'You might be tempted to use C-style casts when type conversions are needed,
    as the C syntax appears in other languages and tends to be short to express –
    `(T)expr` treats expression, `expr`, as being of type `T`. That terseness is actually
    a downside, not an upside, as we will see. Limit C-style casts to a minimum in
    C++ code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要类型转换时，你可能想使用C风格的转换，因为C语法出现在其他语言中，并且通常可以简洁地表达——`(T)expr`将表达式`expr`视为类型`T`。这种简洁性实际上是一个缺点，而不是优点，正如我们将看到的。在C++代码中将C风格的转换限制在最小范围内：
- en: The C-style casts are harder to find when performing an automated search through
    source code text, since they look like arguments in a function call. Since casts
    are ways through which we lie to the type system, revisiting the decision to use
    them from time to time is worthwhile, so being able to find them is valuable.
    In comparison, the C++ casts are keywords, which makes them easier to find.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在源代码文本中执行自动搜索时，C风格的转换更难找到，因为它们看起来像函数调用中的参数。由于转换是我们欺骗类型系统的方式，因此时不时地回顾使用它们的决定是值得的，因此能够找到它们是有价值的。相比之下，C++的转换是关键字，这使得它们更容易找到。
- en: A C-style cast does not convey information about why a conversion occurred.
    When writing `(T)expr`, we are not saying whether we want to change cv-qualifiers,
    navigate a class hierarchy, simply change to type of a pointer, and so on. In
    particular, when converting between pointers to different types, a C-style cast
    will generally behave as `reinterpret_cast`, which, as we have seen, can lead
    to disastrous results in some circumstances.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C风格的转换不传达关于转换发生原因的信息。当编写`(T)expr`时，我们并没有说明我们是否想要更改cv限定符、导航类层次结构、仅更改指针类型，等等。特别是，当在指向不同类型的指针之间进行转换时，C风格的转换通常表现得像`reinterpret_cast`，正如我们所看到的，在某些情况下可能会导致灾难性的结果。
- en: You will sometimes see C-style casts in C++ code, mostly for situations where
    the intent is absolutely clear. We saw an example at the end of our `bit_cast`
    section. Another example would be to silence compiler warnings – for example,
    when calling a function that’s `[[nodiscard]]` but still really wanting to discard
    the results nonetheless for some reason.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你有时会在C++代码中看到C风格的转换，大多数情况下是因为意图非常明确。我们在`bit_cast`部分的末尾看到了一个例子。另一个例子是消除编译器警告——例如，当调用一个标记为`[[nodiscard]]`的函数，但出于某种原因仍然想要丢弃结果时。
- en: 'In yet another example, consider the following generic function:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个例子中，考虑以下泛型函数：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This function iterates through two sequences that are delimited, respectively,
    by `[bA,eA)` and `[bB,eB)` (making sure to stop as soon as the shortest sequence
    has been processed), compares the elements at the “same position” in these two
    sequences, and yields `true` only if all comparisons between elements of those
    two sequences are equal.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数遍历两个分别由`[bA,eA)`和`[bB,eB)`（确保在处理完最短序列后立即停止）分隔的序列，比较这两个序列中“相同位置”的元素，并且只有在那些两个序列之间的所有元素比较都相等时才返回`true`。
- en: Note that the cast to `void` uses a C-style cast between the increments of `bA`
    and `bB` in this code, which cast the result of `++bB` to `void`. This may look
    strange, but this is code that can be used in many situations by pretty much anyone,
    including hostile (or distracted) users. Suppose someone with a twisted mind had
    decided to overload the comma operator (yes, you can do that) between the types
    of `operator++(ItA)` and `operator++(ItB)`. That person could then essentially
    hijack our function to run unexpected code. By casting one of the arguments to
    `void`, we ensure that this is not possible.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个代码中，将类型转换为`void`使用了C风格的转换，在`bA`和`bB`的增量之间进行转换，将`++bB`的结果转换为`void`。这看起来可能有些奇怪，但这是几乎任何人，包括敌对（或分心的）用户都可以在许多情况下使用的代码。假设有人决定在`operator++(ItA)`和`operator++(ItB)`的类型之间重载逗号运算符（是的，你可以这样做）。那个人就可以基本上劫持我们的函数来运行意外的代码。通过将其中一个参数转换为`void`，我们确保这是不可能的。
- en: Summary
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: That concludes our quick overview of casts and cv-qualifications in C++. Now
    that we’ve seen some ways to trick the type system and get in trouble, as well
    as know why we should do these things carefully (if at all), we can start building
    beautiful things with C++ and work toward safe, efficient abstractions in our
    endeavor to write correct programs that control how we manage memory.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对C++中转换和cv限定符的快速概述。现在我们已经看到了一些欺骗类型系统并陷入麻烦的方法，以及为什么我们应该谨慎（如果有的话）做这些事情的原因，我们可以开始用C++构建美丽的事物，并朝着在编写正确程序以控制我们管理内存的尝试中实现安全、高效的抽象而努力。
- en: In the next chapter, we will start by using one of the language’s defining features,
    the destructor, to automate the way our code handles resources, with an eye in
    particular on the way memory is handled.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将首先使用语言的一个定义性特征，即析构函数，来自动化我们代码处理资源的方式，特别是关注内存的处理方式。
- en: 'Part 2: Implicit Memory Management Techniques'
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：隐式内存管理技术
- en: In this part, we will examine some well-known approaches to implicit resource
    management (including memory management) in C++. These are all techniques you
    can use in your daily programming practices that will lead to simpler and safer
    programs than what you would get if you wanted to manage memory explicitly. You
    could say that the chapters in this part concern what people call “modern” or
    “contemporary” C++.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，我们将探讨一些在C++中实现隐式资源管理（包括内存管理）的知名方法。这些都是你可以在日常编程实践中使用的技巧，它们将使你的程序比显式管理内存时更加简单和安全。可以说，这部分章节涉及人们所说的“现代”或“当代”C++。
- en: 'This part has the following chapters:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 4*](B21071_04.xhtml#_idTextAnchor062), *Using Destructors*'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第4章*](B21071_04.xhtml#_idTextAnchor062), *使用析构函数*'
- en: '[*Chapter 5*](B21071_05.xhtml#_idTextAnchor079), *Using Standard Smart Pointers*'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第5章*](B21071_05.xhtml#_idTextAnchor079), *使用标准智能指针*'
- en: '[*Chapter 6*](B21071_06.xhtml#_idTextAnchor096), *Writing Smart Pointers*'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B21071_06.xhtml#_idTextAnchor096), *编写智能指针*'
