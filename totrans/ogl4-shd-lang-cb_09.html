<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Using Noise in Shaders</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Creating a noise texture using GLM</li>
<li>Creating a seamless noise texture</li>
<li>Creating a cloud-like effect</li>
<li>Creating a wood-grain effect</li>
<li>Creating a disintegration effect</li>
<li>Creating a paint-spatter effect</li>
<li>Creating a rusted metal effect</li>
<li>Creating a night-vision effect</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>It's easy to use shaders to create a smooth-looking surface, but that is not always the desired goal. If we want to create realistic-looking objects, we need to simulate the imperfections of real surfaces. That includes things such as scratches, rust, dents, and erosion. It is somewhat surprising how challenging it can be to make surfaces look like they have really been subjected to these natural processes. Similarly, we sometimes want to represent natural surfaces such as wood grain or natural phenomena such as clouds to be as realistic as possible without giving the impression of them being synthetic or exhibiting a repetitive pattern or structure.</p>
<p>Most effects or patterns in nature exhibit a certain degree of randomness and non-linearity. Therefore, you might imagine that we could generate them by simply using random data. However, random data such as the kind that is generated from a pseudo-random number generator is not very useful in computer graphics. There are two main reasons:</p>
<ul>
<li>First, we need data that is repeatable, so that the object will render in the same way during each frame of the animation. (We could achieve this by using an appropriate seed value for each frame, but that only solves half of the problem.)</li>
<li>Second, in order to model most of these natural phenomena, we actually need data that is continuous, but still gives the appearance of randomness. Continuous data more accurately represents many of these natural materials and phenomena. Purely random data does not have this continuity property. Each value has no dependence on the previous value.</li>
</ul>
<p>Thanks to the groundbreaking work of Ken Perlin, we have the concept of <strong>noise</strong> (as it applies to computer graphics). His work defined noise as a function that has certain qualities such as the following:</p>
<ul>
<li>It is a continuous function</li>
<li>It is repeatable (generates the same output from the same input)</li>
<li>It can be defined for any number of dimensions</li>
<li>It does not have any regular patterns and gives the appearance of randomness</li>
</ul>
<p>Such a noise function is a valuable tool for computer graphics and it can be used to create an endless array of interesting effects. For instance, in this chapter, we'll use noise to create clouds, wood, disintegration, and other effects.</p>
<p><strong>Perlin </strong><strong>noise</strong> is the noise function originally defined by Ken Perlin (see <a href="http://mrl.nyu.edu/~perlin/doc/oscar.html">h<span class="URLPACKT">ttp://mrl.nyu.edu/~perlin/doc/oscar.html</span></a>). A full discussion of the details behind Perlin noise is outside the scope of this book.</p>
<p>To use Perlin noise within a shader, we have the following three main choices:</p>
<ul>
<li>We can use the built-in GLSL noise functions</li>
<li>We can create our own GLSL noise functions</li>
<li>We can use a texture map to store pre-computed noise data</li>
</ul>
<p>At the time of writing this book, the GLSL noise functions are not implemented in some of the commercial OpenGL drivers, and therefore cannot be relied upon to be available, so I have decided not to use them in this chapter. As creating our own noise functions is a bit beyond the scope of this book, and because choice three in the preceding list gives the best performance on modern hardware, the recipes in this chapter will use the third approach (using a pre-computed noise texture).</p>
<div class="packt_infobox"><span>Many books use a 3D noise texture rather than a 2D one, to provide another dimension of noise that is available to the shaders. To keep things simple, and to focus on using surface texture coordinates, I've chosen to use a 2D noise texture in the recipes within this chapter. If desired, it should be straightforward to extend these recipes to use a 3D source of noise.</span></div>
<p>We'll start out with two recipes that demonstrate how to generate a noise texture using GLM. Then, we'll move on to several examples that use noise textures to produce natural and artificial effects such as wood grain, clouds, electrical interference, splattering, and erosion.</p>
<p>The recipes in this chapter are meant to be a starting point for you to experiment with. They are certainly not intended to be the definitive way of implementing any of these effects. One<br/>
of the best things about computer graphics is the element of creativity. Try tweaking the shaders in these recipes to produce similar results and then try creating your own effects. Most of all, have fun!</p>
<div class="packt_infobox"><span>Refer to the the book</span> <span><em><span>Texturing and Modeling: A Procedural Approach</span></em></span><span>, by Ken Musgrave et al., for more information on the topic.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a noise texture using GLM</h1>
                </header>
            
            <article>
                
<p>To create a texture for use as a source of noise, we need some way to generate noise values. Implementing a proper noise generator from scratch can be a fairly daunting task. Luckily, GLM provides some functions for noise generation that are straightforward and easy to use.</p>
<p>In this recipe, we'll use GLM to generate a 2D texture of noise values created using a <strong>Perlin </strong><strong>noise</strong> generator. GLM can generate 2D, 3D, and 4D Perlin noise via the <kbd>glm::perlin</kbd> function.</p>
<p>It is a common practice to use Perlin noise by summing the values of the noise function with increasing frequencies and decreasing amplitudes. Each frequency is commonly referred to as an <strong>octave</strong> (double the frequency). For example, in the following image, we show the results of the 2D Perlin noise function sampled at four different octaves. The sampling frequencies increase from left to right.</p>
<p>The leftmost image in the following image is the function sampled at our base frequency, and each image to the right shows the function sampled at twice the frequency of the one to its left:</p>
<div class="packt_figure">
<div class="CDPAlignCenter CDPAlign"><img src="assets/542e5eee-8f2c-4118-a67e-1b00df85a67d.png" style="width:29.67em;height:7.42em;"/></div>
</div>
<p>In mathematical terms, if our coherent 2D Perlin noise function is <em>P(x, y)</em>, then each previous image represents the following equation:</p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/cccbbb5d-cded-4734-9220-a2a1afeaba44.png" style="width:12.67em;height:1.75em;"/></div>
<p>Here, <em>i</em> = 0, 1, 2, and 3 from left to right.</p>
<p>As mentioned previously, the common practice is to sum octaves together to get the final result. We add each octave to the previous equation, scaling the amplitude down by some factor. So, for <em>N</em> octaves, we have the following sum:</p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/4e6eb96d-6c33-4855-8aad-34049d09cfcf.png" style="width:15.17em;height:3.92em;"/></div>
<p><em>a</em> and <em>b</em> are tuneable constants. The following image shows the sum of 2, 3, and 4 octaves (left to right) with <em>a</em> = 1 and <em>b</em> = 2:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f018bd99-aff3-460d-8ffc-ebd57b5af090.png" style="width:22.58em;height:7.50em;"/></p>
<p>Summed noise involving higher octaves will have more high-frequency variation than noise involving only lower octaves. However, it is possible to quickly reach frequencies that exceed the resolution of the buffer used to store the noise data, so care must be taken not to do unnecessary computation.</p>
<p>In practice, it is both an art and a science. The previous equation can be used as a starting point; feel free to tweak it until you get the desired effect.</p>
<p class="mce-root"/>
<p>We'll store four noise values in a single 2D texture. We'll store Perlin noise with one octave in the first component (red channel), two octaves in the green channel, three octaves in the blue channel, and four octaves in the alpha channel.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Make sure that you have the GLM library installed and placed in the include path.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To create a 2D noise texture with GLM, perform the following steps:</p>
<ol>
<li>Include the GLM header that includes the noise functions:</li>
</ol>
<pre style="padding-left: 60px">#include &lt;glm/gtc/noise.hpp&gt; </pre>
<ol start="2">
<li>Generate the noise data using the previous equation:</li>
</ol>
<pre style="padding-left: 60px">GLubyte *data = new GLubyte[ width * height * 4 ]; 
 
float xFactor = 1.0f / (width - 1); 
float yFactor = 1.0f / (height - 1); 
 
for( int row = 0; row &lt; height; row++ ) { 
  for( int col = 0 ; col &lt; width; col++ ) { 
    float x = xFactor * col; 
    float y = yFactor * row; 
    float sum = 0.0f; 
    float freq = a; 
    float scale = b; 
     
    // Compute the sum for each octave 
    for( int oct = 0; oct &lt; 4; oct++ ) { 
      glm::vec2 p(x * freq, y * freq); 
      float val = glm::perlin(p) / scale; 
      sum += val; 
      float result = (sum + 1.0f)/ 2.0f; 
 
      // Store in texture buffer 
      data[((row * width + col) * 4) + oct] =  
                   (GLubyte) ( result * 255.0f ); 
      freq *= 2.0f;   // Double the frequency 
      scale *= b;     // Next power of b 
    } 
  } 
} </pre>
<ol start="3">
<li>Load the data into an OpenGL texture:</li>
</ol>
<pre style="padding-left: 60px">GLuint texID; 
glGenTextures(1, &amp;texID); 
 
glBindTexture(GL_TEXTURE_2D, texID); 
glTexStorage2D(GL_TEXTURE_2D, 1, GL_RGBA8, width, height); 
glTexSubImage2D(GL_TEXTURE_2D,0,0,0,width,height,<br/>   GL_RGBA,GL_UNSIGNED_BYTE,data); 
 
delete [] data; </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The GLM library provides 2D, 3D, and 4D coherent noise via the <kbd>glm::perlin</kbd> function. It returns a float roughly between -1 and 1. We start by allocating a buffer named <kbd>data</kbd> to hold the generated noise values.</p>
<p>Next, we loop over each texel and compute the <kbd>x</kbd> and <kbd>y</kbd> coordinates (normalized). Then, we loop over octaves. Here, we compute the sum of the previous equation, storing the first term in the first component, the first two terms in the second, and so on. The value is scaled into the range from 0 to 1, then multiplied by 255 and cast to a byte.</p>
<p>The next few lines of code should be familiar. Texture memory is allocated with <kbd>glTexStorage2D</kbd> and the data is loaded into GPU memory using <kbd>glTexSubImage2D</kbd>.</p>
<p>Finally, the array named <kbd>data</kbd> is deleted, as it is no longer needed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Rather than using unsigned byte values, we could get more resolution in our noise data by using a floating-point texture. This might provide better results if the effect needs a high degree of fine detail. The preceding code needs relatively few changes to achieve this. Just use an internal format of <kbd>GL_RGBA32F</kbd> instead of <kbd>GL_RGBA</kbd>, use the <kbd>GL_FLOAT</kbd> type, and don't multiply by 255 when storing the noise values in the array.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>GLM also provides periodic Perlin noise via an overload of the <kbd>glm::perlin</kbd> function. This makes it easy to create noise textures that tile without seams. We'll see how to use this in the next recipe.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>The <kbd>chapter09/noisetex.cpp</kbd> file in the example code</li>
<li>For general information about coherent noise, take a look at the book <em>Graphics </em><em>Shaders</em> by Mike Bailey and Steve Cunningham</li>
<li>The <em>Applying </em><em>a 2D texture</em> recipe in <a href="a5d0db76-6dbb-470d-8685-42ab8ae077b1.xhtml"><span class="ChapterrefPACKT">Chapter 5</span></a><span class="ChapterrefPACKT">, </span><em>Using Textures</em></li>
<li>The <em>Creating a seamless noise texture</em> recipe</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a seamless noise texture</h1>
                </header>
            
            <article>
                
<p>It can be particularly useful to have a noise texture that tiles well. If we simply create a noise texture as a finite slice of noise values, then the values will not wrap smoothly across the boundaries of the texture. This can cause hard edges (seams) to appear in the rendered surface if the texture coordinates extend outside of the range of zero to one.</p>
<p>Fortunately, GLM provides a periodic variant of Perlin noise that can be used to create a seamless noise texture.</p>
<p>The following image shows an example of regular (left) and periodic (right) four-octave Perlin noise. Note that in the left image, the seams are clearly visible, while they are hidden in the right image:</p>
<div class="chapter-content CDPAlignCenter CDPAlign"><img src="assets/7be4a130-dfa7-4a19-9a47-198d3b3d780b.png" style="width:20.33em;height:10.17em;"/></div>
<p>In this example, we'll modify the code from the previous recipe to produce a seamless noise texture.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>For this recipe, we'll start with the code from the previous <em>Creating a noise texture using GLM</em> recipe.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Modify the code from the previous recipe in the following way.</p>
<p>Within the innermost loop, instead of calling <kbd>glm::perlin</kbd>, we'll instead call the overload that provides periodic Perlin noise. You will need to replace the following statement:</p>
<pre>float val = glm::perlin(p) / scale; </pre>
<p>Replace it with the following:</p>
<pre>float val = 0.0f; 
if( periodic ) { 
  val = glm::perlin(p, glm::vec2(freq)) / scale; 
} else { 
  val = glm::perlin(p) / scale; 
} </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The second parameter to <kbd>glm::perlin</kbd> determines the period in <kbd>x</kbd> and <kbd>y</kbd> of the noise values. We use <kbd>freq</kbd> as the period because we are sampling the noise in the range from <kbd>0</kbd> to <kbd>freq</kbd> for each octave.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>The <kbd>chapter09/noisetex.cpp</kbd> file in the example code</li>
<li>The <em>Creating a noise texture using GLM</em> recipe</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a cloud-like effect</h1>
                </header>
            
            <article>
                
<p>To create a texture that resembles a sky with clouds, we can use the noise values as a blending factor between the sky color and the cloud color. As clouds usually have large-scale structure, it makes sense to use low-octave noise. However, the large-scale structure often has higher frequency variations, so some contribution from higher octave noise may be desired.</p>
<p>The following image shows an example of clouds generated by the technique in this recipe:</p>
<div class="chapter-content CDPAlignCenter CDPAlign"><img src="assets/585061c8-f96f-4a78-aeb1-e95f212df5de.png" style="width:15.50em;height:11.58em;"/></div>
<p>To create this effect, we take the cosine of the noise value and use the result as the blending factor between the cloud color.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Set up your program to generate a seamless noise texture and make it available to the shaders through the <kbd>NoiseTex</kbd> <span>uniform sampler variable.</span></p>
<p>There are two uniforms in the fragment shader that can be assigned from the OpenGL program:</p>
<ul>
<li><kbd>SkyColor</kbd>: The background sky color</li>
<li><kbd>CloudColor</kbd>: The color of the clouds</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To build a shader program that uses a noise texture to create a cloud-like effect, perform the following steps:</p>
<ol>
<li>Set up your vertex shader to pass the texture coordinates to the fragment shader via the <kbd>TexCoord</kbd> variable.</li>
<li>Use the following code for the fragment shader:</li>
</ol>
<pre style="padding-left: 60px">#define PI 3.14159265 
 
layout( binding=0 ) uniform sampler2D NoiseTex; 
 
uniform vec4 SkyColor = vec4( 0.3, 0.3, 0.9, 1.0 ); 
uniform vec4 CloudColor = vec4( 1.0, 1.0, 1.0, 1.0 ); 
 
in vec2 TexCoord; 
 
layout ( location = 0 ) out vec4 FragColor; 
 
void main() {
  vec4 noise = texture(NoiseTex, TexCoord); 
  float t = (cos( noise.g * PI ) + 1.0) / 2.0; 
  vec4 color = mix( SkyColor, CloudColor, t ); 
  FragColor = vec4( color.rgb , 1.0 ); 
} </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>We start by retrieving the noise value from the noise texture (the <kbd>noise</kbd> variable). The green channel contains two octave noises, so we use the value stored in that channel (<kbd>noise.g</kbd>). Feel free to try out other channels and determine what looks right to you.</p>
<p>We use a cosine function to make a sharper transition between the cloud and sky color. The noise value will be between zero and one, and the cosine of that value will range between -1 and 1, so we add 1.0 and divide by 2.0. The result that is stored in <kbd>t</kbd> should again range between zero and one. Without this cosine transformation, the clouds look a bit too spread out over the sky. However, if that is the desired effect, one could remove the cosine and just use the noise value directly.</p>
<p>Next, we mix the sky color and the cloud color using the value of <kbd>t</kbd>. The result is used as the final output fragment color.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>If you desire less clouds and more sky, you could translate and clamp the value of <kbd>t</kbd> prior to using it to mix the cloud and sky colors. For example, you could use the following code:</p>
<pre>float t = (cos( noise.g * PI ) + 1.0 ) / 2.0; 
t = clamp( t - 0.25, 0.0, 1.0 ); </pre>
<p>This causes the cosine term to shift down (toward negative values), and the <kbd>clamp</kbd> function sets all negative values to zero. This has the effect of increasing the amount of sky and decreasing the size and intensity of the clouds.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>The <kbd>chapter09/scenesky.cpp</kbd> file in the example code</li>
<li>Further reading on cloud generation: <a href="http://vterrain.org/Atmosphere/Clouds/"><span class="URLPACKT">http://vterrain.org/Atmosphere/Clouds/</span></a></li>
<li>The <em>Creating a seamless noise texture</em> recipe</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a wood-grain effect</h1>
                </header>
            
            <article>
                
<p>To create the look of wood, we can start by creating a virtual "log" with perfectly cylindrical growth rings. Then, we'll take a slice of the log and perturb the growth rings using noise from our noise texture.</p>
<p>The following diagram illustrates our virtual <em>log</em>. It is aligned with the <em>y </em>axis, and extends infinitely in all directions. The growth rings are aligned with integer distances from the <em>y</em> axis. Each ring is given a darker color, with a lighter color in-between rings. Each growth ring spans a narrow distance around the integer distances:</p>
<div class="chapter-content CDPAlignCenter CDPAlign"><img src="assets/4273364f-9fa6-4596-8769-e44db96d8713.png" style="width:9.25em;height:11.08em;"/></div>
<p class="chapter-content">To take a "slice," we'll simply define a 2D region of the log's space based on the texture coordinates. Initially, the texture coordinates define a square region, with coordinates ranging from zero to one. We'll assume that the region is aligned with the x-y plane, so that the <em>s</em> coordinate corresponds to <em>x</em>, the <em>t</em> coordinate corresponds to <em>y</em>, and the value of <em>z</em> is zero. We can then transform this region in any way that suits our fancy, to create an arbitrary 2D slice. After defining the slice, we'll determine the color based on the distance from the <em>y</em> axis. However, before doing so, we'll perturb that distance based on a value from the noise texture. The result has a general look that is similar to real wood. The following image shows an example of this:</p>
<div class="packt_figure">
<div class="CDPAlignCenter CDPAlign"><img src="assets/d8a0660c-31d6-43ed-920a-74e44a0f07e5.png" style="width:12.17em;height:12.17em;"/></div>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p class="mce-root">Set up your program to generate a noise texture and make it available to the shaders through the uniform variable <kbd>NoiseTex</kbd>. There are three uniforms in the fragment shader that can be assigned from the OpenGL program. They are as follows:</p>
<ul>
<li><kbd>LightWoodColor</kbd>: The lightest wood color</li>
<li><kbd>DarkWoodColor</kbd>: The darkest wood color</li>
<li><kbd>Slice</kbd>: A matrix that defines the slice of the virtual "log" and transforms the default region defined by the texture coordinates to some other arbitrary rectangular region</li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p class="mce-root">To create a shader program that generates a wood-grain effect using a noise texture, perform the following steps:</p>
<ol>
<li>Set up your vertex shader to pass the texture coordinate to the fragment shader via the <kbd>TexCoord</kbd> variable.</li>
<li>Use the following code for the fragment shader:</li>
</ol>
<pre style="padding-left: 60px">layout(binding=0) uniform sampler2D NoiseTex; 
 
uniform vec4 DarkWoodColor = vec4( 0.8, 0.5, 0.1, 1.0 ); 
uniform vec4 LightWoodColor = vec4( 1.0, 0.75, 0.25, 1.0 ); 
uniform mat4 Slice; 
 
in vec2 TexCoord; 
 
layout ( location = 0 ) out vec4 FragColor; 
 
void main() {
  // Transform the texture coordinates to define the 
  // "slice" of the log. 
  vec4 cyl = Slice * vec4( TexCoord.st, 0.0, 1.0 ); 
 
  // The distance from the log's y axis. 
  float dist = length(cyl.xz); 
 
  // Perturb the distance using the noise texture 
  vec4 noise = texture(NoiseTex, TexCoord); 
  dist += noise.b; 
 
  // Determine the color as a mixture of the light and  
  // dark wood colors. 
  float t = 1.0 - abs( fract( dist ) * 2.0 - 1.0 ); 
  t = smoothstep( 0.2, 0.5, t ); 
  vec4 color = mix( DarkWoodColor, LightWoodColor, t ); 
 
  FragColor = vec4( color.rgb , 1.0 ); 
}</pre>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p class="mce-root">The first line of the <kbd>main</kbd> function within the fragment shader expands the texture coordinates to a 3D (homogeneous) value with a <em>z</em> coordinate of zero (s, t, 0, 1), and then transforms the value via the <kbd>Slice</kbd> matrix. This matrix can scale, translate, and/or rotate the texture coordinates to define the 2D region of the virtual <em>log</em>.</p>
<div class="packt_infobox"><span>One way to visualize this is to think of the slice as a 2D unit square embedded in the log with its lower-left corner at the origin. The matrix is then used to transform that square within the log to define a slice through the log. For example, I might just translate the square by (-0.5, -0.5, -0.5) and scale by 20 in <em>x</em> and <em>y</em> to get a slice through the middle of the log.</span></div>
<p class="mce-root">Next, the distance from the <em>y</em> axis is determined by using the built-in <kbd>length</kbd> function (<kbd>length(cyl.xz)</kbd>). This will be used to determine how close we are to a growth ring. The color will be a light wood color if we are between growth rings, and a dark color when we are close to a growth ring. However, before determining the color, we perturb the distance slightly using a value from our noise texture by using the following line of code:</p>
<pre>dist += noise.b; </pre>
<p class="mce-root">The next step is just a bit of numerical trickery to determine the color based on how close we are to a whole number. We start by taking the fractional part of the distance (<kbd>fract(dist)</kbd>), multiplying by two, subtracting one, and taking the absolute value. As <kbd>fract(dist)</kbd> is a value between zero and one, multiplying by two, subtracting one, and taking the absolute value will result in a value that is also between zero and one. However, the value will range from 1.0 when <kbd>dist</kbd> is 0.0, to 0.0 when <kbd>dist</kbd> is 0.5, and back to 1.0 when <kbd>dist</kbd> is 1.0 (a <kbd>v</kbd> shape).</p>
<p class="chapter-content">We then invert the <kbd>v</kbd> by subtracting from one, and storing the result in <kbd>t</kbd>. Next, we use the <kbd>smoothstep</kbd> function to create a somewhat sharp transition between the light and dark colors. In other words, we want a dark color when <kbd>t</kbd> is less than 0.2, a light color when it is greater than 0.5, and a smooth transition in between. The result is used to mix the light and dark colors via the GLSL <kbd>mix</kbd> function.</p>
<div class="packt_infobox"><span>The </span><kbd>smoothstep( a, b, x )</kbd><span> function works in the following way. It returns <kbd>0.0</kbd> when </span><kbd>x &lt;= a</kbd><span>, <kbd>1.0</kbd> when </span><kbd>x &gt;= b</kbd><span>, and uses Hermite interpolation between 0 and 1 when </span><kbd>x</kbd><span> is between </span><kbd>a</kbd><span> and </span><kbd>b</kbd><span>.</span></div>
<p class="mce-root">The result of all of this is a narrow band of the dark color around integer distances, and a light color in-between, with a rapid but smooth transition. Finally, we simply apply the final color to the fragment.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p class="mce-root">A book-matched pair of boards is a pair that is cut from the same log and then glued together. The result is a larger board that has symmetry in the grain from one side to the other. We can approximate this effect by mirroring the texture coordinate. For example, we could use the following in place of the first line of the preceding <kbd>main</kbd> function:</p>
<pre>vec2 tc = TexCoord; 
if( tc.s &gt; 0.5 ) tc.s = 1.0 - tc.s; 
vec4 cyl = Slice * vec4( tc, 0.0, 1.0 ); </pre>
<p class="mce-root">The following image shows an example of the results:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/eb282a0b-77f8-4f56-a01f-10628999a0df.png" style="width:17.42em;height:13.08em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>The <kbd>chapter09/scenewood.cpp</kbd> file in the example code</li>
<li>The <em>Creating a noise texture using GLM</em> recipe</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a disintegration effect</h1>
                </header>
            
            <article>
                
<p class="mce-root">It is straightforward to use the GLSL <kbd>discard</kbd> keyword in combination with noise to simulate erosion or decay. We can simply discard fragments that correspond to a noise value that is above or below a certain threshold. The following image shows a teapot with this effect.</p>
<p class="mce-root"/>
<p class="mce-root">Fragments are discarded when the noise value corresponding to the texture coordinate is outside a certain threshold range:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/9a768420-0b98-49df-9d73-909cf90796ff.png" style="width:22.17em;height:13.50em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p class="mce-root">Set up your OpenGL program to provide position, normal, and texture coordinates to the shader. Make sure that you pass the texture coordinate along to the fragment shader. Set up any uniforms needed to implement the shading model of your choice.</p>
<p class="chapter-content">Create a seamless noise texture (see <em>Creating a seamless noise texture</em>), and place it in the appropriate texture channel.</p>
<p class="chapter-content">The following uniforms are defined in the fragment shader, and should be set via the OpenGL program:</p>
<ul>
<li><kbd>NoiseTex</kbd>: The noise texture</li>
<li><kbd>LowThreshold</kbd>: Fragments are discarded if the noise value is below this value</li>
<li><kbd>HighThreshold</kbd>: Fragments are discarded if the noise value is above this value</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p class="mce-root">To create a shader program that provides a disintegration effect, perform the following steps:</p>
<ol>
<li>Create a vertex shader that sends the texture coordinate to the fragment shader via the <kbd>TexCoord</kbd> <span>output variable. </span>It should also pass the position and normal to the fragment shader through the <kbd>Position</kbd> and <kbd>Normal</kbd> variables.</li>
</ol>
<ol start="2">
<li>Use the following code for the fragment shader:</li>
</ol>
<pre style="padding-left: 60px">// Insert uniforms needed for the Phong shading model 
 
layout(binding=0) uniform sampler2D NoiseTex; 
 
in vec4 Position; 
in vec3 Normal; 
in vec2 TexCoord; 
 
uniform float LowThreshold; 
uniform float HighThreshold; 
 
layout ( location = 0 ) out vec4 FragColor; 
 
vec3 phongModel() { 
  // Compute Phong shading model... 
} 
void main() 
{ 
  // Get the noise value at TexCoord 
  vec4 noise = texture( NoiseTex, TexCoord ); 
 
  // If the value is outside the threshold, discard 
  if( noise.a &lt; LowThreshold || noise.a &gt; HighThreshold) 
    discard; 
 
  // Color the fragment using the shading model 
  vec3 color = phongModel(); 
  FragColor = vec4( color , 1.0 ); 
} </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p class="mce-root">The fragment shader starts by retrieving a noise value from the noise texture (<kbd>NoiseTex</kbd>), and storing the result in the <kbd>noise</kbd> variable. We want noise that has a large amount of high-frequency fluctuation, so we choose four-octave noise, which is stored in the alpha channel (<kbd>noise.a</kbd>).</p>
<p class="chapter-content">We then discard the fragment if the noise value is below <kbd>LowThreshold</kbd> or above <kbd>HighThreshold</kbd>. As the <kbd>discard</kbd> keyword causes the execution of the shader to stop, the rest of the shader will not execute if the fragment is discarded.</p>
<div class="packt_infobox"><span>The discard operation can have a performance impact due to how it might affect early depth tests.</span></div>
<p class="mce-root">Finally, we compute the shading model and apply the result to the fragment.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>The <kbd>chapter09/scenedecay.cpp</kbd> file in the example code</li>
<li>The <em>Creating a seamless noise texture</em> recipe</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a paint-spatter effect</h1>
                </header>
            
            <article>
                
<p class="mce-root">Using high-frequency noise, it is easy to create the effect of random spatters of paint on the surface of an object. The following image shows an example of this:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/87f51c07-6e29-4b3b-85d0-76a84f36df03.png" style="width:21.17em;height:12.33em;"/></div>
<p class="chapter-content">We use the noise texture to vary the color of the object, with a sharp transition between the base color and the paint color. We'll use either the base color or paint color as the diffuse reflectivity of the shading model. If the noise value is above a certain threshold, we'll use the paint color; otherwise, we'll use the base color of the object.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p class="mce-root">Start with a basic setup for rendering using the Phong shading model (or whatever model you prefer). Include texture coordinates and pass them along to the fragment shader.</p>
<p class="chapter-content">There are a couple of uniform variables that define the parameters of the paint spatters:</p>
<ul>
<li><kbd>PaintColor</kbd>: The color of the paint spatters</li>
<li><kbd>Threshold</kbd>: The minimum noise value where a spatter will appear</li>
</ul>
<p class="mce-root">Create a noise texture with high-frequency noise.</p>
<p class="chapter-content">Make your noise texture available to the fragment shader via the <kbd>NoiseTex</kbd> <span>uniform sampler variable.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p class="mce-root">To create a shader program that generates a paint-spatter effect, perform the following steps:</p>
<ol>
<li>Create a vertex shader that sends the texture coordinates to the fragment shader via the <kbd>TexCoord</kbd> <span>output variable. </span>It should also pass the position and normal to the fragment shader through the variables <kbd>Position</kbd> and <kbd>Normal</kbd>.</li>
<li>Use the following code for the fragment shader:</li>
</ol>
<pre style="padding-left: 60px">// Uniforms for the Phong shading model 
...
 
// The noise texture 
layout(binding=0) uniform sampler2D NoiseTex; 
// Input from the vertex shader 
in vec4 Position; 
in vec3 Normal; 
in vec2 TexCoord; 
 
// The paint-spatter uniforms 
uniform vec3 PaintColor = vec3(1.0); 
uniform float Threshold = 0.65; 
 
layout ( location = 0 ) out vec4 FragColor; 
 
vec3 phongModel(vec3 kd) { 
  // Evaluate the Phong shading model 
} 
 
void main() { 
  vec4 noise = texture( NoiseTex, TexCoord ); 
  vec3 color = Material.Kd; 
  if( noise.g&gt; Threshold ) color = PaintColor; 
  FragColor = vec4( phongModel(color) , 1.0 ); 
} </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p class="mce-root">The main function of the fragment shader retrieves a noise value from <kbd>NoiseTex</kbd> and stores it in the <kbd>noise</kbd> variable. The next two lines set the variable <kbd>color</kbd> to either the base diffuse reflectivity (<kbd>Material.Kd</kbd>) or <kbd>PaintColor</kbd>, depending on whether or not the noise value is greater than the threshold value (<kbd>Threshold</kbd>). This will cause a sharp transition between the two colors, and the size of the spatters will be related to the frequency of the noise.</p>
<p class="chapter-content">Finally, the Phong shading model is evaluated using <kbd>color</kbd> as the diffuse reflectivity. The result is applied to the fragment.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p class="mce-root">As indicated in the <em>Creating a noise texture using GLM</em> recipe, using lower frequency noise will cause the spatters to be larger in size and more spread out. A lower threshold will also increase the size without it spreading over the surface, but as the threshold gets lower, it starts to look more uniform and less like random spattering.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>The <kbd>chapter09/scenepaint.cpp</kbd> file in the example code</li>
<li>The <em>Creating a seamless noise texture</em> recipe</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a rusted metal effect</h1>
                </header>
            
            <article>
                
<p>This recipe combines a noise texture with the reflection effect covered in <a href="a5d0db76-6dbb-470d-8685-42ab8ae077b1.xhtml">Chapter 5</a>, <em>Using Textures</em> to create a simple rusted metal effect.</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2c249282-60fa-4e06-9a82-fdb9951af278.png" style="width:27.42em;height:14.75em;"/></p>
<p class="mce-root"/>
<p>This technique is very similar to the previous recipe, <em>Creating a paint-spatter effect</em>.  We'll use our noise texture to modulate the reflection from the teapot. If the noise is above a certain threshold, we'll use the rust color, otherwise, we'll use the reflected color.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We'll combine the technique described in the <em>Simulating reflection with cube maps</em> recipe in <a href="a5d0db76-6dbb-470d-8685-42ab8ae077b1.xhtml">Chapter 5</a>, <em>Using Textures</em>, with a noise texture. Start with the shaders from that recipe.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>In the fragment shader, we'll access our noise texture and if the value is below the threshold value <kbd>Threshold</kbd>, we'll use the reflected color (from the cube map), otherwise, we'll use a rust color:</p>
<pre>in vec3 ReflectDir;<br/>in vec2 TexCoord;<br/><br/>uniform samplerCube CubeMapTex;<br/>uniform sampler2D NoiseTex;<br/><br/>uniform float ReflectFactor;<br/>uniform vec4 MaterialColor;<br/><br/>layout( location = 0 ) out vec4 FragColor;<br/><br/>uniform float Threshold = 0.58;<br/><br/>void main() {<br/>    // Access the noise texture<br/>    float noise = texture( NoiseTex, TexCoord ).a;<br/>    float scale = floor( noise + (1 - Threshold) );<br/><br/>    // Access the cube map texture<br/>    vec3 cubeMapColor = texture(CubeMapTex, ReflectDir).rgb;<br/><br/>    // Gamma correct<br/>    cubeMapColor = pow(cubeMapColor, vec3(1.0/2.2));<br/><br/>    vec3 rustColor = mix( MaterialColor.rgb, vec3(0.01), noise.a );<br/><br/>    FragColor = vec4( mix( cubeMapColor, rustColor, scale), 1);<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>We start by accessing the noise texture, and store it's value in the variable <kbd>noise</kbd>. The variable <kbd>scale</kbd> will store a value that is either zero or one. We use the <kbd>floor</kbd> function to set it to zero if the value of <kbd>noise</kbd> is less than <kbd>Threshold</kbd> and to one otherwise. </p>
<p>Next, we access the cube map to get the reflected color and apply a gamma correction.</p>
<p>We compute <kbd>rustColor</kbd> by mixing <kbd>MaterialColor</kbd> with a dark color (nearly black) using the noise texture as a scale. This should give some additional variation in the rust color.</p>
<p>Finally, we use <kbd>scale</kbd> to mix the <kbd>cubeMapColor</kbd> with <kbd>rustColor</kbd> and apply the result to the fragment.  Since the value of <kbd>scale</kbd> will be either zero or one, we will get a sharp transition between the reflected color and the rust color.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>The <kbd>chapter09/scenerust.cpp</kbd> file in the example code</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a night-vision effect</h1>
                </header>
            
            <article>
                
<p class="mce-root">Noise can be useful to simulate static or other kinds of electronic interference effects. This recipe is a fun example of that. We'll create the look of night-vision goggles with some noise thrown in to simulate some random static in the signal. Just for fun, we'll also outline the scene in the classic <em>binocular</em> view. The following image shows an example of this:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/1c83dd2b-fb39-410b-ac67-f8122cb53127.png" style="width:19.33em;height:14.50em;"/></div>
<p class="chapter-content">We'll apply the night-vision effect as a second pass to the rendered scene. The first pass will render the scene to a texture (see <a href="a5d0db76-6dbb-470d-8685-42ab8ae077b1.xhtml"><span class="ChapterrefPACKT">Chapter 5</span></a>, <em>Using Textures</em>), and the second pass will apply the night-vision effect.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p class="mce-root">Create a <strong>framebuffer object</strong> (<strong>FBO</strong>) for the first pass. Attach a texture to the first color attachment of the FBO. For more information on how to do this, see <a href="a5d0db76-6dbb-470d-8685-42ab8ae077b1.xhtml"/><a href="a5d0db76-6dbb-470d-8685-42ab8ae077b1.xhtml"><span class="ChapterrefPACKT">Chapter 5</span></a>, <em>Using Textures</em>.</p>
<p class="chapter-content">Create and assign any uniform variables needed for the shading model. Set the following uniforms defined in the fragment shader:</p>
<ul>
<li><kbd>Width</kbd>: The width of the viewport in pixels</li>
<li><kbd>Height</kbd>: The height of the viewport in pixels</li>
<li><kbd>Radius</kbd>: The radius of each circle in the <em>binocular</em> effect (in pixels)</li>
<li><kbd>RenderTex</kbd>: The texture containing the render from the first pass</li>
<li><kbd>NoiseTex</kbd>: The noise texture</li>
<li><kbd>RenderPass</kbd>: The subroutine uniform used to select the functionality for each pass</li>
</ul>
<p class="mce-root">Create a noise texture with high-frequency noise and make it available to the shader via <kbd>NoiseTex</kbd>. Associate the texture with the FBO available via <kbd>RenderTex</kbd>.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p class="mce-root">To create a shader program that generates a night-vision effect, perform the following steps:</p>
<ol>
<li>Set up your vertex shader to pass along the position, normal, and texture coordinates via the <kbd>Position</kbd>, <kbd>Normal</kbd>, and <kbd>TexCoord</kbd> variables, respectively.</li>
<li>Use the following code for the fragment shader:</li>
</ol>
<pre style="padding-left: 60px">in vec3 Position; 
in vec3 Normal; 
in vec2 TexCoord; 
 
uniform int Width; 
uniform int Height; 
uniform float Radius; 
layout(binding=0) uniform sampler2D RenderTex; 
layout(binding=1) uniform sampler2D NoiseTex; 
 
subroutine vec4 RenderPassType(); 
subroutine uniform RenderPassType RenderPass; 
 
// Define any uniforms needed for the shading model. 
 
layout( location = 0 ) out vec4 FragColor; 
 
vec3 phongModel( vec3 pos, vec3 norm ) {
  // Compute the Phong shading model 
} 
 
// Returns the relative luminance of the color value 
float luminance( vec3 color ) { 
  return dot( color.rgb, vec3(0.2126, 0.7152, 0.0722) ); 
} 
 
subroutine (RenderPassType) 
vec4 pass1() {
  return vec4(phongModel( Position, Normal ),1.0); 
} 
 
subroutine( RenderPassType ) 
vec4 pass2() {
  vec4 noise = texture(NoiseTex, TexCoord); 
  vec4 color = texture(RenderTex, TexCoord); 
  float green = luminance( color.rgb ); 
 
  float dist1 = length(gl_FragCoord.xy - <br/>       vec2(Width*0.25, Height*0.5));  <br/>       float dist2 = length(gl_FragCoord.xy - <br/>       vec2(3.0*Width*0.25, Height*0.5)); 
  if( dist1 &gt; Radius &amp;&amp; dist2 &gt; Radius ) green = 0.0; 
 
  return vec4(0.0, green * clamp(noise.a + 0.25, 0.0, 1.0),<br/>       0.0 ,1.0); 
} 
 
void main() {
  // This will call either pass1() or pass2() 
  FragColor = RenderPass(); 
} </pre>
<ol start="3">
<li>In the render function of your OpenGL program, perform the following steps:
<ol>
<li><span>Bind to the FBO that you set up for rendering the scene to a texture.</span></li>
<li>Select the <kbd>pass1</kbd> subroutine function in the fragment shader via <kbd>RenderPass</kbd>.</li>
<li class="chapter-content">Render the scene.</li>
<li class="chapter-content">Bind to the default FBO.</li>
<li class="chapter-content">Select the <kbd>pass2</kbd> subroutine function in the fragment shader via <kbd>RenderPass</kbd>.</li>
<li class="chapter-content">Draw a single quad that fills the viewport using texture coordinates that range from 0 to 1 in each direction.</li>
</ol>
</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p class="mce-root">The fragment shader is broken into two subroutine functions, one for each pass. Within the <kbd>pass1</kbd> function, we simply apply the Phong shading model to the fragment. The result is written to the FBO, which contains a texture to be used in the second pass.</p>
<p class="mce-root">In the second pass, the <kbd>pass2</kbd> function is executed. We start by retrieving a noise value (<kbd>noise</kbd>), and the color from the render texture from the first pass (<kbd>color</kbd>). Then, we compute the <kbd>luminance</kbd> value for the color and store that result in the <kbd>green</kbd> variable. This will eventually be used as the green component of the final color.</p>
<div class="packt_tip">We use the same texture coordinates here, assuming that the noise texture is the same size as the render texture. It would be more space efficient to use a smaller noise texture and tile it across the surface.</div>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root">The next step involves determining whether or not the fragment is inside the <em>binocular</em> lenses. We compute the distance to the center of the left lens (<kbd>dist1</kbd>), which is located in the viewport halfway from top to bottom and one quarter of the way from left to right. The right lens is located at the same vertical location, but three quarters of the way from left to right. The distance from the center of the right-hand lens is stored in <kbd>dist2</kbd>. If both <kbd>dist1</kbd> and <kbd>dist2</kbd> are greater than the radius of the virtual lenses, then we set <kbd>green</kbd> to <kbd>0</kbd>.</p>
<p class="mce-root">Finally, we return the final color, which has only a <kbd>green</kbd> component; the other two are set to zero. The value of <kbd>green</kbd> is multiplied by the noise value in order to add some noise to the image to simulate random interference in the signal. We add <kbd>0.25</kbd> to the noise value and clamp it between zero and one, in order to brighten the overall image. I have found that it appears a bit too dark if the noise value isn't biased in this way.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p class="mce-root">It would make this shader even more effective if the noise varied in each frame during animation to simulate interference that is constantly changing. We can accomplish this roughly by modifying the texture coordinates used to access the noise texture in a time-dependent way. See the blog post mentioned in the following <em>See also</em> section for an example.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>The <kbd>chapter09/scenenightvision.cpp</kbd> file in the example code</li>
<li>The <em>Rendering to a texture</em> recipe in <a href="a5d0db76-6dbb-470d-8685-42ab8ae077b1.xhtml"/><a href="a5d0db76-6dbb-470d-8685-42ab8ae077b1.xhtml"/><a href="a5d0db76-6dbb-470d-8685-42ab8ae077b1.xhtml"><span class="ChapterrefPACKT">Chapter 5</span></a>, <em>Using Textures</em></li>
<li>The <em>Creating a noise texture using GLM</em> recipe</li>
<li>This recipe was inspired by a blog post by Wojciech Toman (no longer publicly available)</li>
</ul>


            </article>

            
        </section>
    </body></html>