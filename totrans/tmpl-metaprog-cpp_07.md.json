["```cpp\ntemplate <typename T>\n```", "```cpp\nstruct is_floating_point\n```", "```cpp\n{\n```", "```cpp\n   static const bool value = false;\n```", "```cpp\n};\n```", "```cpp\ntemplate <>\n```", "```cpp\nstruct is_floating_point<float>\n```", "```cpp\n{\n```", "```cpp\n   static const bool value = true;\n```", "```cpp\n};\n```", "```cpp\ntemplate <>\n```", "```cpp\nstruct is_floating_point<double>\n```", "```cpp\n{\n```", "```cpp\n   static const bool value = true;\n```", "```cpp\n};\n```", "```cpp\ntemplate <>\n```", "```cpp\nstruct is_floating_point<long double>\n```", "```cpp\n{\n```", "```cpp\n   static const bool value = true;\n```", "```cpp\n};\n```", "```cpp\nint main()\n```", "```cpp\n{\n```", "```cpp\n   static_assert(is_floating_point<float>::value);\n```", "```cpp\n   static_assert(is_floating_point<double>::value);\n```", "```cpp\n   static_assert(is_floating_point<long double>::value);\n```", "```cpp\n   static_assert(!is_floating_point<int>::value);\n```", "```cpp\n   static_assert(!is_floating_point<bool>::value);\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nvoid process_real_number(T const value)\n```", "```cpp\n{\n```", "```cpp\n   static_assert(is_floating_point<T>::value);\n```", "```cpp\n   std::cout << \"processing a real number: \" << value \n```", "```cpp\n             << '\\n';\n```", "```cpp\n}\n```", "```cpp\nint main()\n```", "```cpp\n{\n```", "```cpp\n   process_real_number(42.0);\n```", "```cpp\n   process_real_number(42); // error: \n```", "```cpp\n                            // static assertion failed\n```", "```cpp\n}\n```", "```cpp\nstruct widget\n```", "```cpp\n{\n```", "```cpp\n   int         id;\n```", "```cpp\n   std::string name;\n```", "```cpp\n   std::ostream& write(std::ostream& os) const\n```", "```cpp\n   {\n```", "```cpp\n      os << id << ',' << name << '\\n';\n```", "```cpp\n      return os;\n```", "```cpp\n   }\n```", "```cpp\n};\n```", "```cpp\nstruct gadget\n```", "```cpp\n{\n```", "```cpp\n   int         id;\n```", "```cpp\n   std::string name;\n```", "```cpp\n   friend std::ostream& operator <<(std::ostream& os, \n```", "```cpp\n                                    gadget const& o);\n```", "```cpp\n};\n```", "```cpp\nstd::ostream& operator <<(std::ostream& os, \n```", "```cpp\n                          gadget const& o)\n```", "```cpp\n{\n```", "```cpp\n   os << o.id << ',' << o.name << '\\n';\n```", "```cpp\n   return os;\n```", "```cpp\n}\n```", "```cpp\nwidget w{ 1, \"one\" };\n```", "```cpp\nw.write(std::cout);\n```", "```cpp\ngadget g{ 2, \"two\" };\n```", "```cpp\nstd::cout << g;\n```", "```cpp\nserialize(std::cout, w);\n```", "```cpp\nserialize(std::cout, g);\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct uses_write\n```", "```cpp\n{\n```", "```cpp\n   static constexpr bool value = false;\n```", "```cpp\n};\n```", "```cpp\ntemplate <>\n```", "```cpp\nstruct uses_write<widget>\n```", "```cpp\n{\n```", "```cpp\n   static constexpr bool value = true;\n```", "```cpp\n};\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\ninline constexpr bool uses_write_v = uses_write<T>::value;\n```", "```cpp\ntemplate <bool>\n```", "```cpp\nstruct serializer\n```", "```cpp\n{\n```", "```cpp\n   template <typename T>\n```", "```cpp\n   static void serialize(std::ostream& os, T const& value)\n```", "```cpp\n   {\n```", "```cpp\n      os << value;\n```", "```cpp\n   }\n```", "```cpp\n};\n```", "```cpp\ntemplate<>\n```", "```cpp\nstruct serializer<true>\n```", "```cpp\n{\n```", "```cpp\n   template <typename T>\n```", "```cpp\n   static void serialize(std::ostream& os, T const& value)\n```", "```cpp\n   {\n```", "```cpp\n      value.write(os);\n```", "```cpp\n   }\n```", "```cpp\n};\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nvoid serialize(std::ostream& os, T const& value)\n```", "```cpp\n{\n```", "```cpp\n   serializer<uses_write_v<T>>::serialize(os, value);\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nauto begin(T& c) { return c.begin(); }   // [1]\n```", "```cpp\ntemplate <typename T, size_t N>\n```", "```cpp\nT* begin(T(&arr)[N]) {return arr; }      // [2]\n```", "```cpp\nstd::array<int, 5> arr1{ 1,2,3,4,5 };\n```", "```cpp\nstd::cout << *begin(arr1) << '\\n';       // [3] prints 1\n```", "```cpp\nint arr2[]{ 5,4,3,2,1 };\n```", "```cpp\nstd::cout << *begin(arr2) << '\\n';       // [4] prints 5\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nvoid increment(T& val) { val++; }\n```", "```cpp\nint a = 42;\n```", "```cpp\nincrement(a);  // OK\n```", "```cpp\nstd::string s{ \"42\" };\n```", "```cpp\nincrement(s);  // error\n```", "```cpp\ntemplate <typename T, size_t N>\n```", "```cpp\nvoid handle(T(&arr)[N], char(*)[N % 2 == 0] = 0)\n```", "```cpp\n{\n```", "```cpp\n   std::cout << \"handle even array\\n\";\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename T, size_t N>\n```", "```cpp\nvoid handle(T(&arr)[N], char(*)[N % 2 == 1] = 0)\n```", "```cpp\n{\n```", "```cpp\n   std::cout << \"handle odd array\\n\";\n```", "```cpp\n}\n```", "```cpp\nint arr1[]{ 1,2,3,4,5 };\n```", "```cpp\nhandle(arr1);\n```", "```cpp\nint arr2[]{ 1,2,3,4 };\n```", "```cpp\nhandle(arr2);\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct foo\n```", "```cpp\n{\n```", "```cpp\n   using foo_type = T;\n```", "```cpp\n};\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct bar\n```", "```cpp\n{\n```", "```cpp\n   using bar_type = T;\n```", "```cpp\n};\n```", "```cpp\nstruct int_foo : foo<int> {};\n```", "```cpp\nstruct int_bar : bar<int> {};\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\ndecltype(typename T::foo_type(), void()) handle(T const& v)\n```", "```cpp\n{\n```", "```cpp\n   std::cout << \"handle a foo\\n\";\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\ndecltype(typename T::bar_type(), void()) handle(T const& v)\n```", "```cpp\n{\n```", "```cpp\n   std::cout << \"handle a bar\\n\";\n```", "```cpp\n}\n```", "```cpp\nint_foo fi;\n```", "```cpp\nint_bar bi;\n```", "```cpp\nint x = 0;\n```", "```cpp\nhandle(fi); // OK\n```", "```cpp\nhandle(bi); // OK\n```", "```cpp\nhandle(x);  // error\n```", "```cpp\ntemplate<bool B, typename T = void>\n```", "```cpp\nstruct enable_if {};\n```", "```cpp\ntemplate<typename T>\n```", "```cpp\nstruct enable_if<true, T> { using type = T; };\n```", "```cpp\ntemplate <typename T, \n```", "```cpp\n          typename std::enable_if<\n```", "```cpp\n             uses_write_v<T>>::type* = nullptr>\n```", "```cpp\nvoid serialize(std::ostream& os, T const& value)\n```", "```cpp\n{\n```", "```cpp\n   value.write(os);\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename T,\n```", "```cpp\n          typename std::enable_if<\n```", "```cpp\n             !uses_write_v<T>>::type*=nullptr>\n```", "```cpp\nvoid serialize(std::ostream& os, T const& value)\n```", "```cpp\n{\n```", "```cpp\n   os << value;\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nvoid serialize(\n```", "```cpp\n   std::ostream& os, T const& value, \n```", "```cpp\n   typename std::enable_if<\n```", "```cpp\n               uses_write_v<T>>::type* = nullptr)\n```", "```cpp\n{\n```", "```cpp\n   value.write(os);\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nvoid serialize(\n```", "```cpp\n   std::ostream& os, T const& value,\n```", "```cpp\n   typename std::enable_if<\n```", "```cpp\n               !uses_write_v<T>>::type* = nullptr)\n```", "```cpp\n{\n```", "```cpp\n   os << value;\n```", "```cpp\n}\n```", "```cpp\nwidget w{ 1, \"one\" };\n```", "```cpp\ngadget g{ 2, \"two\" };\n```", "```cpp\nserialize(std::cout, w);\n```", "```cpp\nserialize(std::cout, g);\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\ntypename std::enable_if<uses_write_v<T>>::type serialize(\n```", "```cpp\n   std::ostream& os, T const& value)\n```", "```cpp\n{\n```", "```cpp\n   value.write(os);\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\ntypename std::enable_if<!uses_write_v<T>>::type serialize(\n```", "```cpp\n   std::ostream& os, T const& value)\n```", "```cpp\n{\n```", "```cpp\n   os << value;\n```", "```cpp\n}\n```", "```cpp\ntemplate <\n```", "```cpp\n   typename T,\n```", "```cpp\n   typename=typenamestd::enable_if_t<\n```", "```cpp\n                        std::is_integral_v<T>>>\n```", "```cpp\nstruct integral_wrapper\n```", "```cpp\n{\n```", "```cpp\n   T value;\n```", "```cpp\n};\n```", "```cpp\ntemplate <\n```", "```cpp\n   typename T,\n```", "```cpp\n   typename=typename std::enable_if_t<\n```", "```cpp\n                        std::is_floating_point_v<T>>>\n```", "```cpp\nstruct floating_wrapper\n```", "```cpp\n{\n```", "```cpp\n   T value;\n```", "```cpp\n};\n```", "```cpp\n    template <bool B, typename T = void>\n    using enable_if_t = typename enable_if<B,T>::type;\n    ```", "```cpp\nintegral_wrapper w1{ 42 };   // OK\n```", "```cpp\nintegral_wrapper w2{ 42.0 }; // error\n```", "```cpp\nintegral_wrapper w3{ \"42\" }; // error\n```", "```cpp\nfloating_wrapper w4{ 42 };   // error\n```", "```cpp\nfloating_wrapper w5{ 42.0 }; // OK\n```", "```cpp\nfloating_wrapper w6{ \"42\" }; // error\n```", "```cpp\ntemplate <\n```", "```cpp\n   typename T,\n```", "```cpp\n   typename=typenamestd::enable_if_t<\n```", "```cpp\n                        std::is_integral_v<T>>>\n```", "```cpp\nstruct integral_wrapper\n```", "```cpp\n{\n```", "```cpp\n   T value;\n```", "```cpp\n   integral_wrapper(T v) : value(v) {}\n```", "```cpp\n};\n```", "```cpp\ntemplate <\n```", "```cpp\n   typename T,\n```", "```cpp\n   typename=typename std::enable_if_t<\n```", "```cpp\n                        std::is_floating_point_v<T>>>\n```", "```cpp\nstruct floating_wrapper\n```", "```cpp\n{\n```", "```cpp\n   T value;\n```", "```cpp\n   floating_wrapper(T v) : value(v) {}\n```", "```cpp\n};\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nvoid serialize(std::ostream& os, T const& value)\n```", "```cpp\n{\n```", "```cpp\n   if constexpr (uses_write_v<T>)\n```", "```cpp\n      value.write(os);\n```", "```cpp\n   else\n```", "```cpp\n      os << value;\n```", "```cpp\n}\n```", "```cpp\ntemplate<>\n```", "```cpp\nvoid serialize<widget>(std::ostream & os,\n```", "```cpp\n                      widget const & value)\n```", "```cpp\n{\n```", "```cpp\n   if constexpr(true)\n```", "```cpp\n   {\n```", "```cpp\n      value.write(os);\n```", "```cpp\n   }\n```", "```cpp\n}\n```", "```cpp\ntemplate<>\n```", "```cpp\nvoid serialize<gadget>(std::ostream & os,\n```", "```cpp\n                       gadget const & value)\n```", "```cpp\n{\n```", "```cpp\n   if constexpr(false) \n```", "```cpp\n   {\n```", "```cpp\n   } \n```", "```cpp\n   else\n```", "```cpp\n   {\n```", "```cpp\n      os << value;\n```", "```cpp\n   } \n```", "```cpp\n}\n```", "```cpp\ntemplate<>\n```", "```cpp\nvoid serialize<widget>(std::ostream & os,\n```", "```cpp\n                       widget const & value)\n```", "```cpp\n{\n```", "```cpp\n   value.write(os);\n```", "```cpp\n}\n```", "```cpp\ntemplate<>\n```", "```cpp\nvoid serialize<gadget>(std::ostream & os,\n```", "```cpp\n                       gadget const & value)\n```", "```cpp\n{\n```", "```cpp\n   os << value;\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename T, typename... Args>\n```", "```cpp\nT sum(T a, Args... args)\n```", "```cpp\n{\n```", "```cpp\n   if constexpr (sizeof...(args) == 0)\n```", "```cpp\n      return a;\n```", "```cpp\n   else\n```", "```cpp\n      return a + sum(args...);\n```", "```cpp\n}\n```", "```cpp\ntemplate <unsigned int n>\n```", "```cpp\nconstexpr unsigned int factorial()\n```", "```cpp\n{\n```", "```cpp\n   return n * factorial<n - 1>();\n```", "```cpp\n}\n```", "```cpp\ntemplate<> \n```", "```cpp\nconstexpr unsigned int factorial<1>() { return 1; }\n```", "```cpp\ntemplate<> \n```", "```cpp\nconstexpr unsigned int factorial<0>() { return 1; }\n```", "```cpp\ntemplate <unsigned int n>\n```", "```cpp\nconstexpr unsigned int factorial()\n```", "```cpp\n{\n```", "```cpp\n   if constexpr (n > 1)\n```", "```cpp\n      return n * factorial<n - 1>();\n```", "```cpp\n   else\n```", "```cpp\n      return 1;\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nbool are_equal(T const& a, T const& b)\n```", "```cpp\n{\n```", "```cpp\n   if constexpr (std::is_floating_point_v<T>)\n```", "```cpp\n      return std::abs(a - b) < 0.001;\n```", "```cpp\n   else\n```", "```cpp\n      return a == b;\n```", "```cpp\n}\n```", "```cpp\nare_equal(1, 1);                                   // OK\n```", "```cpp\nare_equal(1.999998, 1.999997);                     // OK\n```", "```cpp\nare_equal(std::string{ \"1\" }, std::string{ \"1\" }); // OK\n```", "```cpp\nare_equal(widget{ 1, \"one\" }, widget{ 1, \"two\" }); // error\n```", "```cpp\ntemplate< class T >\n```", "```cpp\ninline constexpr bool is_arithmetic_v =\n```", "```cpp\n   is_arithmetic<T>::value;\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstd::string as_string(T value)\n```", "```cpp\n{\n```", "```cpp\n   if constexpr (std::is_null_pointer_v<T>)\n```", "```cpp\n      return \"null\";\n```", "```cpp\n   else if constexpr (std::is_arithmetic_v<T>)\n```", "```cpp\n      return std::to_string(value);\n```", "```cpp\n   else\n```", "```cpp\n      static_assert(always_false<T>);\n```", "```cpp\n}\n```", "```cpp\nstd::cout << as_string(nullptr) << '\\n'; // prints null\n```", "```cpp\nstd::cout << as_string(true) << '\\n';    // prints 1\n```", "```cpp\nstd::cout << as_string('a') << '\\n';     // prints a\n```", "```cpp\nstd::cout << as_string(42) << '\\n';      // prints 42\n```", "```cpp\nstd::cout << as_string(42.0) << '\\n';   // prints 42.000000\n```", "```cpp\nstd::cout << as_string(\"42\") << '\\n';    // error\n```", "```cpp\ntemplate<class T> \n```", "```cpp\nconstexpr bool always_false = std::false_type::value;\n```", "```cpp\nstruct foo\n```", "```cpp\n{\n```", "```cpp\n   int a;\n```", "```cpp\n};\n```", "```cpp\nstruct bar\n```", "```cpp\n{\n```", "```cpp\n   int a = 0;\n```", "```cpp\n};\n```", "```cpp\nstruct tar\n```", "```cpp\n{\n```", "```cpp\n   int a = 0;\n```", "```cpp\n   tar() : a(0) {}\n```", "```cpp\n};\n```", "```cpp\nstd::cout << std::is_trivial_v<foo> << '\\n'; // true\n```", "```cpp\nstd::cout << std::is_trivial_v<bar> << '\\n'; // false\n```", "```cpp\nstd::cout << std::is_trivial_v<tar> << '\\n'; // false\n```", "```cpp\nstd::cout << std::is_trivially_copyable_v<foo> \n```", "```cpp\n          << '\\n';                                 // true\n```", "```cpp\nstd::cout << std::is_trivially_copyable_v<bar> \n```", "```cpp\n          << '\\n';                                 // true\n```", "```cpp\nstd::cout << std::is_trivially_copyable_v<tar> \n```", "```cpp\n          << '\\n';                                 // true\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstd::string as_string(T value)\n```", "```cpp\n{\n```", "```cpp\n   if constexpr (std::is_null_pointer_v<T>)\n```", "```cpp\n      return \"null\";\n```", "```cpp\n   else if constexpr (std::is_same_v<T, bool>)\n```", "```cpp\n      return value ? \"true\" : \"false\";\n```", "```cpp\n   else if constexpr (std::is_arithmetic_v<T>)\n```", "```cpp\n      return std::to_string(value);\n```", "```cpp\n   else\n```", "```cpp\n      static_assert(always_false<T>);\n```", "```cpp\n}\n```", "```cpp\nstd::cout << as_string(true) << '\\n';    // prints true\n```", "```cpp\nstd::cout << as_string(false) << '\\n';   // prints false\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstd::string as_string(T&& value)\n```", "```cpp\n{\n```", "```cpp\n   if constexpr (std::is_null_pointer_v<T>)\n```", "```cpp\n      return \"null\";\n```", "```cpp\n   else if constexpr (std::is_same_v<T, bool>)\n```", "```cpp\n      return value ? \"true\" : \"false\";\n```", "```cpp\n   else if constexpr (std::is_arithmetic_v<T>)\n```", "```cpp\n      return std::to_string(value);\n```", "```cpp\n   else\n```", "```cpp\n      static_assert(always_false<T>);\n```", "```cpp\n}\n```", "```cpp\nstd::cout << as_string(true) << '\\n';  // OK\n```", "```cpp\nstd::cout << as_string(42) << '\\n';    // OK\n```", "```cpp\nbool f = true;\n```", "```cpp\nstd::cout << as_string(f) << '\\n';     // error\n```", "```cpp\nint n = 42;\n```", "```cpp\nstd::cout << as_string(n) << '\\n';     // error\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct decay\n```", "```cpp\n{\n```", "```cpp\nprivate:\n```", "```cpp\n    using U = typename std::remove_reference_t<T>;\n```", "```cpp\npublic:\n```", "```cpp\n    using type = typename std::conditional_t< \n```", "```cpp\n        std::is_array_v<U>,\n```", "```cpp\n        typename std::remove_extent_t<U>*,\n```", "```cpp\n        typename std::conditional_t< \n```", "```cpp\n            std::is_function<U>::value,\n```", "```cpp\n            typename std::add_pointer_t<U>,\n```", "```cpp\n            typename std::remove_cv_t<U>\n```", "```cpp\n        >\n```", "```cpp\n    >;\n```", "```cpp\n};\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstd::string as_string(T&& value)\n```", "```cpp\n{\n```", "```cpp\n   using value_type = std::decay_t<T>;\n```", "```cpp\n   if constexpr (std::is_null_pointer_v<value_type>)\n```", "```cpp\n      return \"null\";\n```", "```cpp\n   else if constexpr (std::is_same_v<value_type, bool>)\n```", "```cpp\n      return value ? \"true\" : \"false\";\n```", "```cpp\n   else if constexpr (std::is_arithmetic_v<value_type>)\n```", "```cpp\n      return std::to_string(value);\n```", "```cpp\n   else\n```", "```cpp\n      static_assert(always_false<T>);\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename T, size_t S>\n```", "```cpp\nstruct list\n```", "```cpp\n{\n```", "```cpp\n   using type = std::vector<T>;\n```", "```cpp\n};\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct list<T, 1>\n```", "```cpp\n{\n```", "```cpp\n   using type = T;\n```", "```cpp\n};\n```", "```cpp\ntemplate <typename T, size_t S>\n```", "```cpp\nusing list_t = typename list<T, S>::type;\n```", "```cpp\ntemplate <typename T, size_t S>\n```", "```cpp\nusing list_t = \n```", "```cpp\n   typename std::conditional<S == \n```", "```cpp\n                 1, T, std::vector<T>>::type;\n```", "```cpp\nstatic_assert(std::is_same_v<list_t<int, 1>, int>);\n```", "```cpp\nstatic_assert(std::is_same_v<list_t<int, 2>,\n```", "```cpp\n                             std::vector<int>>);\n```", "```cpp\ntemplate <typename InputIt, typename OutputIt>\n```", "```cpp\nconstexpr OutputIt copy(InputIt first, InputIt last,\n```", "```cpp\n                        OutputIt d_first);\n```", "```cpp\ntemplate <typename InputIt, typename OutputIt>\n```", "```cpp\nconstexpr OutputIt copy(InputIt first, InputIt last,\n```", "```cpp\n                        OutputIt d_first)\n```", "```cpp\n{\n```", "```cpp\n   while (first != last)\n```", "```cpp\n   {\n```", "```cpp\n      *d_first++ = *first++;\n```", "```cpp\n   }\n```", "```cpp\n   return d_first;\n```", "```cpp\n}\n```", "```cpp\nnamespace detail\n```", "```cpp\n{\n```", "```cpp\n   template <bool b>\n```", "```cpp\n   struct copy_fn\n```", "```cpp\n   {\n```", "```cpp\n      template<typename InputIt, typename OutputIt>\n```", "```cpp\n      constexpr static OutputIt copy(InputIt first, \n```", "```cpp\n                                     InputIt last, \n```", "```cpp\n                                     OutputIt d_first)\n```", "```cpp\n      {\n```", "```cpp\n         while (first != last)\n```", "```cpp\n         {\n```", "```cpp\n            *d_first++ = *first++;\n```", "```cpp\n         }\n```", "```cpp\n         return d_first;\n```", "```cpp\n      }\n```", "```cpp\n   };\n```", "```cpp\n   template <>\n```", "```cpp\n   struct copy_fn<true>\n```", "```cpp\n   {\n```", "```cpp\n      template<typename InputIt, typename OutputIt>\n```", "```cpp\n      constexpr static OutputIt* copy(\n```", "```cpp\n         InputIt* first, InputIt* last,\n```", "```cpp\n         OutputIt* d_first)\n```", "```cpp\n      {\n```", "```cpp\n         std::memmove(d_first, first, \n```", "```cpp\n                      (last - first) * sizeof(InputIt));\n```", "```cpp\n         return d_first + (last - first);\n```", "```cpp\n      }\n```", "```cpp\n   };\n```", "```cpp\n}\n```", "```cpp\ntemplate<typename InputIt, typename OutputIt>\n```", "```cpp\nconstexpr OutputIt copy(InputIt first, InputIt last, \n```", "```cpp\n                        OutputIt d_first)\n```", "```cpp\n{\n```", "```cpp\n   using input_type = std::remove_cv_t<\n```", "```cpp\n      typename std::iterator_traits<InputIt>::value_type>;\n```", "```cpp\n   using output_type = std::remove_cv_t<\n```", "```cpp\n      typename std::iterator_traits<OutputIt>::value_type>;\n```", "```cpp\n   constexpr bool opt =\n```", "```cpp\n      std::is_same_v<input_type, output_type> &&\n```", "```cpp\n      std::is_pointer_v<InputIt> &&\n```", "```cpp\n      std::is_pointer_v<OutputIt> &&\n```", "```cpp\n      std::is_trivially_copy_assignable_v<input_type>;\n```", "```cpp\n   return detail::copy_fn<opt>::copy(first, last, d_first);\n```", "```cpp\n}\n```", "```cpp\nstd::vector<int> v1{ 1, 2, 3, 4, 5 };\n```", "```cpp\nstd::vector<int> v2(5);\n```", "```cpp\n// calls the generic implementation\n```", "```cpp\ncopy(std::begin(v1), std::end(v1), std::begin(v2));\n```", "```cpp\nint a1[5] = { 1,2,3,4,5 };\n```", "```cpp\nint a2[5];\n```", "```cpp\n// calls the optimized implementation\n```", "```cpp\ncopy(a1, a1 + 5, a2);\n```", "```cpp\nn520::copy(std::begin(v1), std::end(v1), std::begin(v2));\n```", "```cpp\ntemplate<typename... Ts>\n```", "```cpp\nvoid process(Ts&&... ts) {}\n```", "```cpp\nprocess(1, 2, 3);\n```", "```cpp\nprocess(1, 2.0, '3');\n```", "```cpp\nprocess(1, 2.0, \"3\");\n```", "```cpp\ntemplate <typename, typename... Ts>\n```", "```cpp\nstruct has_common_type : std::false_type {};\n```", "```cpp\ntemplate <typename... Ts>\n```", "```cpp\nstruct has_common_type<\n```", "```cpp\n          std::void_t<std::common_type_t<Ts...>>, \n```", "```cpp\n          Ts...>\n```", "```cpp\n   : std::true_type {};\n```", "```cpp\ntemplate <typename... Ts>\n```", "```cpp\nconstexpr bool has_common_type_v =\n```", "```cpp\n   sizeof...(Ts) < 2 ||\n```", "```cpp\n   has_common_type<void, Ts...>::value;\n```", "```cpp\ntemplate<class T, T v>\n```", "```cpp\nstruct integral_constant\n```", "```cpp\n{\n```", "```cpp\n   static constexpr T value = v;\n```", "```cpp\n   using value_type = T;\n```", "```cpp\n};\n```", "```cpp\ntemplate<typename... Ts,\n```", "```cpp\n         typename = std::enable_if_t<\n```", "```cpp\n                       has_common_type_v<Ts...>>>\n```", "```cpp\nvoid process(Ts&&... ts) \n```", "```cpp\n{ }\n```"]