- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Work Environment and Workflow Optimization
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作环境和工作流程优化
- en: The first step toward a successful software project is choosing the right tools.
    Embedded development requires a set of hardware and software instruments that
    make the developer’s life easier and may significantly improve productivity and
    cut down the total development time. This chapter provides a description of these
    tools and gives advice on how to use them to improve the workflow.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 成功软件项目的第一步是选择合适的工具。嵌入式开发需要一套硬件和软件工具，这些工具可以简化开发者的工作，并可能显著提高生产率和缩短总开发时间。本章提供了这些工具的描述，并给出了如何使用它们来改进工作流程的建议。
- en: The first section gives us an overview of the workflow in native C programming,
    and gradually reveals the changes necessary to translate the model to an embedded
    development environment. The **GCC toolchain**, a set of development tools to
    build the embedded application, is introduced through the analysis of its components.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分为我们概述了原生C编程中的工作流程，并逐步揭示了将模型转换为嵌入式开发环境所需的必要变化。通过对其组件的分析，介绍了**GCC工具链**，这是一套用于构建嵌入式应用的开发工具。
- en: Finally, in the last two sections, strategies of interaction with the target
    are proposed, to provide mechanisms for the debugging and validation of the embedded
    software running on the platform.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在最后两节中，提出了与目标机交互的策略，以提供对在平台上运行的嵌入式软件进行调试和验证的机制。
- en: 'The topics covered in this chapter are the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题如下：
- en: Workflow overview
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作流程概述
- en: Text editors versus integrated environments
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本编辑器与集成环境
- en: The GCC toolchain
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GCC工具链
- en: Interaction with the target
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与目标机的交互
- en: Validation
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证
- en: By the end of this chapter, you will have learned how to create an optimized
    workflow by following a few basic rules, keeping the focus on test preparation,
    and a smart approach to debugging.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将学会如何通过遵循一些基本规则，保持对测试准备的关注，以及一种智能的调试方法，来创建一个优化的工作流程。
- en: Workflow overview
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作流程概述
- en: Writing software in C, as well as in every other compiled language, requires
    the code to be transformed into an executable format for a specific target to
    run it. C is portable across different architectures and execution environments.
    Programmers rely on a set of tools to compile, link, execute, and debug software
    to a specific target.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 使用C语言编写软件，以及在其他任何编译型语言中，都需要将代码转换成特定目标机的可执行格式才能运行。C语言可以在不同的架构和执行环境中进行移植。程序员依赖于一系列工具来编译、链接、执行和调试软件到特定目标。
- en: Building the firmware image of an embedded system relies on a similar set of
    tools, which can produce firmware images for specific targets, called a **toolchain**.
    This section gives an overview of the common sets of tools required to write software
    in C and produce programs that are directly executable on the machine that compiled
    them. The workflow must then be extended and adapted to integrate the toolchain
    components and produce executable code for the target platform.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 构建嵌入式系统的固件映像依赖于一套类似的工具，这些工具可以为特定目标生成固件映像，称为**工具链**。本节概述了编写C语言软件和生成可直接在编译它们的机器上运行的程序的常用工具集。然后，工作流程必须扩展并适应，以集成工具链组件并为目标平台生成可执行代码。
- en: The C compiler
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C编译器
- en: The **C compiler** is a tool responsible for translating source code into machine
    code, which can be interpreted by a specific CPU. Each compiler can produce machine
    code for one environment only, as it translates the functions into machine-specific
    instructions, and it is configured to use the address model and the register layout
    of one specific architecture. The native compiler included in most GNU/Linux distributions
    is the **GNU Compiler Collection**, commonly known as **GCC**. The GCC is a free
    software compiler system distributed under the GNU general public license since
    1987, and since then, it has been successfully used to build UNIX-like systems.
    The GCC included in the system can compile C code into applications and libraries
    capable of running on the same architecture as that of the machine running the
    compiler.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**C编译器**是一种负责将源代码翻译成机器代码的工具，该代码可以被特定的CPU解释。每个编译器只能为一种环境生成机器代码，因为它将函数翻译成特定机器的指令，并且它被配置为使用特定架构的地址模型和寄存器布局。大多数GNU/Linux发行版中包含的本地编译器是**GNU编译器集合**，通常称为**GCC**。GCC是一个自1987年以来在GNU通用公共许可证下分发的免费软件编译器系统，自那时起，它已成功用于构建类UNIX系统。系统中的GCC可以编译C代码，生成能够在与编译器运行的机器相同架构上运行的应用程序和库。'
- en: The GCC compiler takes source code files as input, with the `.c` extension,
    and produces object files, with `.o` extensions, containing the functions and
    the initial values of the variables, translated from the input source code into
    machine instructions. The compiler can be configured to perform additional optimization
    steps at the end of the compilation that are specific to the target platform and
    insert debug data to facilitate debugging at a later stage.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: GCC编译器以`.c`扩展名的源代码文件作为输入，并生成包含函数和变量初始值的对象文件，这些函数和变量从输入源代码翻译成机器指令。编译器可以被配置在编译结束时执行针对目标平台的特定优化步骤，并插入调试数据以方便后续调试。
- en: 'A minimalist command line used to compile a source file into an object using
    the host compiler only requires the `-c` option, instructing the GCC program to
    compile the sources into an object of the same name:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用主机编译器将源文件编译成对象的简约命令行只需要`-c`选项，指示GCC程序将源代码编译成同名的对象：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This statement will try to compile the C source contained in the `hello.c` file
    and transform it into machine-specific code that is stored in the newly created
    `hello.o` file.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此声明将尝试编译包含在`hello.c`文件中的C源代码，并将其转换为存储在新建的`hello.o`文件中的特定机器代码。
- en: Compiling code for a specific target platform requires a set of tools designed
    for that purpose. Architecture-specific compilers exist, which provide compilers
    creating machine instructions for a specific target, different from the building
    machine. The process of generating code for a different target is called **cross
    compilation**. The **cross compiler** runs on a development machine, the host,
    to produce machine-specific code that can execute on the target.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为特定目标平台编译代码需要一套为此目的设计的工具。存在针对特定架构的编译器，它们提供创建特定目标机器指令的编译器，与构建机器不同。为不同目标生成代码的过程称为**交叉编译**。**交叉编译器**在开发机器（主机）上运行，以生成可在目标上执行的特定机器代码。
- en: In the next section, a GCC-based toolchain is introduced as the tool to create
    the firmware for an embedded target. The syntax and the characteristics of the
    GCC compiler are described there.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，介绍了一个基于GCC的工具链，作为为嵌入式目标创建固件的工具。那里描述了GCC编译器的语法和特性。
- en: The first step for building a program made of separate modules is to compile
    all the sources into object files so that the components needed by the system
    are grouped and organized together in the final step, consisting of linking together
    all the required symbols and arranging the memory areas to prepare the final executable,
    which is done by another dedicated component in the toolchain.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 构建由单独模块组成的程序的第一步是将所有源代码编译成目标文件，以便系统所需的组件在最终步骤中分组和组织在一起，该步骤包括链接所有必需的符号并安排内存区域以准备最终的可执行文件，这由工具链中的另一个专用组件完成。
- en: Linker
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链接器
- en: The **linker** is the tool that composes executable programs and resolves the
    dependencies among object files provided as input.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**链接器**是组合可执行程序并解决作为输入提供的对象文件之间依赖关系的工具。'
- en: The default executable format that is produced by the linker is the **Executable
    and Linkable Format** (**ELF**). The ELF is the default standard format for programs,
    objects, shared libraries, and even GDB core dumps on many Unix and Unix-like
    systems. The format has been designed to store programs on disks and other media
    supports, so the host operating system can execute it by loading the instructions
    in RAM and allocating the space for the program data.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 链接器生成的默认可执行格式是**可执行和链接格式**（**ELF**）。在许多Unix和Unix-like系统中，ELF是程序的默认标准格式，对象、共享库甚至GDB核心转储。该格式已被设计用于在磁盘和其他媒体上存储程序，以便宿主操作系统可以通过在RAM中加载指令并分配程序数据的空间来执行它。
- en: Executable files are divided into sections, which can be mapped to specific
    areas in memory needed by the program to execute. The ELF file starts with a header
    containing the pointer to the various sections within the file itself, which contains
    the program’s code and data.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 可执行文件被划分为多个部分，这些部分可以映射到程序执行所需的内存中的特定区域。ELF文件以一个包含指向文件内部各个部分的指针的头部开始，这些部分包含程序的代码和数据。
- en: 'The linker maps the content of the areas describing an executable program into
    sections conventionally starting with a `.` (dot). The minimum set of sections
    required to run the executable consists of the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 链接器将描述可执行程序内容的区域映射到以`.`（点）开头的一般部分。运行可执行文件所需的最小部分集合包括以下内容：
- en: '`.text`: Contains the code of the program, accessed in read-only mode. It contains
    the executable instructions of the program. The functions compiled into object
    files are arranged by the linker in this section, and the program always executes
    instructions within this memory area.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.text`：包含程序的代码，以只读模式访问。它包含程序的执行指令。编译进对象文件中的函数由链接器安排在这个部分，程序总是在这个内存区域中执行指令。'
- en: '`.rodata`: Contains the value of constants that cannot be altered at runtime.
    It is used by the compiler as the default section to store constants because it
    is not allowed to modify the stored values at runtime.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.rodata`：包含不能在运行时更改的常量值。编译器将其作为存储常量的默认部分，因为它不允许在运行时修改存储的值。'
- en: '`.data`: Contains the values of all the initialized variables of the program
    that are accessible in the read/write mode at runtime. It is the section that
    contains all the variables (static or global) that have been initialized in the
    code. Before executing, this area is generally remapped to a writable location
    in RAM, and the content of the ELF is automatically copied during the initialization
    of the program, at runtime, before executing the main function.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.data`：包含程序所有初始化变量的值，在运行时以读写模式访问。它是包含所有变量（静态或全局）的部分，这些变量已在代码中初始化。在执行之前，该区域通常被重新映射到RAM中的可写位置，并在程序初始化期间自动复制ELF的内容，在运行时，在执行主函数之前。'
- en: '`.bss`: This is a section reserved for uninitialized data, accessible in the
    read/write mode at runtime. It derives its name from an ancient assembly instruction
    of old microcode written for the IBM 704 in the 1950s. It was originally an acronym
    for `main()` function.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.bss`：这是一个为未初始化数据保留的部分，在运行时以读写模式访问。它的名字来源于20世纪50年代为IBM 704编写的旧微代码中的古老汇编指令。它最初是`main()`函数的缩写。'
- en: 'When building native software on the host machine, much of the complexity of
    the linking step is hidden, but the linker is configured by default to arrange
    the compiled symbols into specific sections, which can be later used by the operating
    system to assign the corresponding segments in the process virtual address space
    when executing the program. It is possible to create a working executable for
    the host machine by simply invoking `gcc`, this time without the `-c` option,
    providing the list of the object files that must be linked together to produce
    the ELF file. The `-o` option is used to specify the output filename, which otherwise
    would default to `a.out`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当在宿主机器上构建本地软件时，链接步骤的许多复杂性都被隐藏了，但链接器默认配置为将编译的符号安排到特定的部分，这些部分可以在程序执行时由操作系统用于在进程虚拟地址空间中分配相应的段。可以通过简单地调用`gcc`来为宿主机器创建一个可工作的可执行文件，这次不使用`-c`选项，提供必须链接在一起以生成ELF文件的对象文件列表。`-o`选项用于指定输出文件名，否则默认为`a.out`：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This command will try to build the `helloworld` file, which is an ELF executable
    for the host system, using the symbols previously compiled into the two objects.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将尝试构建`helloworld`文件，这是一个主机系统的ELF可执行文件，使用先前编译到两个对象中的符号。
- en: In an embedded system things change a bit, as booting a bare-metal application
    implies that the sections must be mapped to physical areas in memory at linking
    time. To instruct the linker to associate the sections to well-known physical
    addresses, a custom linker script file must be provided, describing the memory
    layout of the executable bare-metal application, and providing additional custom
    sections that may be required by the target system.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌入式系统中，情况略有不同，因为引导裸机应用程序意味着在链接时必须将部分映射到内存中的物理区域。为了指示链接器将部分关联到已知的物理地址，必须提供一个自定义链接脚本文件，描述可执行裸机应用程序的内存布局，并提供可能由目标系统需要的附加自定义部分。
- en: A more detailed explanation of the linking step is provided later, in the *Linking
    the* *executable* section.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在“链接可执行文件”部分将提供对链接步骤的更详细解释。
- en: 'Make: a build automation tool'
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Make：构建自动化工具
- en: Several open source tools are available to automate a build process, and a few
    of them are widely used in different development environments. **Make** is the
    standard UNIX tool to automate the steps required to create the required binary
    images from the sources, check the dependencies for each component, and execute
    the steps in the right order. Make is a standard **POSIX tool**, and it is part
    of many UNIX-like systems. In a GNU/Linux distribution, it is implemented as a
    standalone tool, which is part of the GNU project. From this point on, the GNU
    Make implementation is simply referred to as Make.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种开源工具可用于自动化构建过程，其中一些在不同开发环境中被广泛使用。**Make**是标准的UNIX工具，用于自动化从源代码创建所需二进制图像的步骤，检查每个组件的依赖关系，并按正确顺序执行步骤。Make是一个标准的**POSIX工具**，它是许多类UNIX系统的一部分。在GNU/Linux发行版中，它作为一个独立工具实现，是GNU项目的一部分。从现在开始，GNU
    Make实现将简单地称为Make。
- en: Make is designed to execute the default build by simply invoking the `make`
    command with no arguments from the command line, provided that a **makefile**
    is present in the working directory. A makefile is a special instruction file,
    containing rules and recipes to build all the files needed until the expected
    output files are generated. Open source alternatives offering similar solutions
    for build automation exist, such as CMake and SCons, but all the examples in this
    book are built using Make because it provides a simple and essential enough environment
    to control the build system, and it is the one standardized by **POSIX**.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Make设计为通过在命令行上不带参数简单地调用`make`命令来执行默认构建，前提是工作目录中存在**makefile**。makefile是一个特殊的指令文件，包含构建所有所需文件直到生成预期输出文件的规则和配方。提供类似构建自动化解决方案的开源替代品存在，例如CMake和SCons，但本书中的所有示例都是使用Make构建的，因为它提供了一个简单且足够基本的构建系统控制环境，并且它是**POSIX**标准化的。
- en: Some integrated development environments use built-in mechanisms to coordinate
    the building steps or generate makefiles before invoking Make automatically when
    the user requests to build the output files. However, editing makefiles manually
    gives complete control over the intermediate steps to generate the final images,
    where the user can customize the recipes and rules used to generate the desired
    output files.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一些集成开发环境使用内置机制来协调构建步骤或生成makefile，在用户请求构建输出文件时自动调用Make。然而，手动编辑makefile可以完全控制生成最终图像的中间步骤，用户可以自定义用于生成所需输出文件的配方和规则。
- en: There is no specific version that needs to be installed to cross compile code
    for the Cortex-M target, but some extra parameters, such as the location of the
    toolchain binaries, or the specific flags needed by the compiler, need to be taken
    care of when writing targets and directives within the makefile.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于交叉编译针对Cortex-M目标的代码，不需要安装特定版本，但在编写makefile中的目标和指令时，需要考虑一些额外参数，例如工具链二进制文件的位置或编译器需要的特定标志。
- en: One of the advantages of using a build process is that targets may have implicit
    dependencies from other intermediate components that are automatically resolved
    at compile time. If all the dependencies are correctly configured, a makefile
    ensures that the intermediate steps are executed only when needed, reducing the
    compile time of the whole project when only a few sources are altered or when
    single object files have been deleted.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用构建过程的一个优点是，目标可能具有来自其他中间组件的隐式依赖关系，这些依赖关系在编译时自动解决。如果所有依赖关系都正确配置，makefile 确保仅在需要时执行中间步骤，当只有少数源文件被更改或单个目标文件被删除时，可以减少整个项目的编译时间。
- en: 'Makefiles have a specific syntax to describe rules. Each rule begins with the
    target files expected as the output of the rule, a colon, and the list of prerequisites,
    which are the files necessary to execute the rule. A set of recipe items follow,
    each one describing the actions that Make will execute to create the desired target:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Makefile 有特定的语法来描述规则。每个规则以期望作为规则输出的目标文件开始，后面跟着一个冒号和先决条件的列表，这些先决条件是执行规则所需的文件。随后是一系列配方项，每个配方项描述
    Make 将执行的动作以创建所需的目标：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: By default, Make will execute the first rule encountered while parsing the file
    if no rule name is specified from the command line. If any of the prerequisites
    are not available, Make automatically looks for a rule in the same makefile that
    can create the required file recursively until the chain of requirements is satisfied.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Make 将在解析文件时执行遇到的第一个规则，如果命令行中没有指定规则名称。如果任何先决条件不可用，Make 将自动在相同的 makefile
    中查找可以递归创建所需文件的规则，直到满足需求链。
- en: 'Makefiles can assign a custom string of text to internal variables while executing.
    Variable names can be assigned using the `=` operator and referred to by prefixing
    them with `$`. For example, the following assignment is used to put the name of
    two object files into the `OBJS` variable:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Makefile 可以在执行时将自定义文本字符串分配给内部变量。变量名可以使用 `=` 运算符分配，并通过在它们前面加上 `$` 来引用。例如，以下赋值用于将两个目标文件的名称放入
    `OBJS` 变量中：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A few important variables that are assigned automatically within the rules
    are the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在规则中自动分配的一些重要变量如下：
- en: '![Table 2.1 – Some automatic variables that can be used in makefile recipes
    ](img/011.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![表 2.1 – 可用于 makefile 脚本中的某些自动变量](img/011.jpg)'
- en: Table 2.1 – Some automatic variables that can be used in makefile recipes
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.1 – 可用于 makefile 脚本中的某些自动变量
- en: 'These variables are handy to use within the recipe action lines. For example,
    the recipe to generate a `helloworld` ELF file from the two object files can be
    written as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量在配方动作行中使用起来很方便。例如，从两个目标文件生成 `helloworld` ELF 文件的配方可以写成如下：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Some of the rules are implicitly defined by Make. For example, the rule to create
    the `hello.o` and `world.o` files from their respective source files can be omitted,
    as Make expects to be able to obtain each one of these object files in the most
    obvious way, which is by compiling the corresponding C source files with the same
    name if present. This means that this minimalist makefile is already able to compile
    the two objects from the sources and link them together using the default set
    of options for the host system.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一些规则是由 Make 隐式定义的。例如，从各自的源文件创建 `hello.o` 和 `world.o` 文件的规则可以省略，因为 Make 期望能够以最明显的方式获得这些目标文件中的每一个，即如果存在，通过编译同名
    C 源文件。这意味着这个最小化 makefile 已经能够从源文件编译这两个目标文件，并使用宿主系统的默认选项将它们链接在一起。
- en: 'The linking recipe can also be implicit if the executable has the same name
    as one of its prerequisite objects minus its `.o` extension. If the final ELF
    file is called `hello`, our makefile could simply become the following one-liner:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可执行文件与其中一个先决条件对象（去掉 `.o` 扩展名）同名，链接配方也可以是隐式的。如果最终的 ELF 文件名为 `hello`，我们的 makefile
    可以简单地变成以下单行：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This would automatically resolve the `hello.o` and `world.o` dependencies, and
    then link them together using an implicit linker recipe similar to the one we
    used in the explicit target.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这将自动解决 `hello.o` 和 `world.o` 的依赖关系，然后使用类似于我们在显式目标中使用的隐式链接器配方将它们链接在一起。
- en: 'Implicit rules use predefined variables, which are assigned automatically before
    the rules are executed, but can be modified within the makefile. For example,
    it is possible to change the default compiler by altering the `CC` variable. Here
    is a short list of the most important variables that may be used to alter implicit
    rules and recipes:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式规则使用预定义变量，这些变量在规则执行之前自动分配，但可以在makefile中修改。例如，可以通过更改`CC`变量来更改默认的编译器。以下是一个重要的变量列表，这些变量可能用于更改隐式规则和配方：例如，它可能更改默认的编译器。以下是一个重要的变量列表，这些变量可能用于更改隐式规则和配方：
- en: '![Table 2.2 – Implicit, predefined variables that specify the default toolchain
    and flags ](img/02.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![表2.2 – 指定默认工具链和标志的隐式、预定义变量](img/02.jpg)'
- en: Table 2.2 – Implicit, predefined variables that specify the default toolchain
    and flags
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.2 – 指定默认工具链和标志的隐式、预定义变量
- en: When linking a bare-metal application for embedded platforms, the makefile must
    be modified accordingly, and as shown later in this chapter, several flags are
    required to properly cross compile the sources and instruct the linker to use
    the desired memory layout to organize the memory sections. Moreover, additional
    steps are generally needed to manipulate the ELF file and translate it to a format
    that can be transferred to the target system. However, the syntax of the makefile
    is the same, and the simple rules shown here are not too different from those
    used to build the example. The default variables still need to be adjusted to
    modify the default behavior if implicit rules are used.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当为嵌入式平台链接裸机应用程序时，必须相应地修改makefile，正如本章后面所示，需要几个标志来正确交叉编译源文件并指示链接器使用所需的内存布局来组织内存部分。此外，通常还需要额外的步骤来操作ELF文件并将其转换为可以传输到目标系统的格式。然而，makefile的语法是相同的，这里显示的简单规则与用于构建示例的规则没有太大区别。如果使用隐式规则，默认变量仍然需要调整以修改默认行为。
- en: When all the dependencies are correctly configured in the makefile, Make ensures
    that the rules are only executed when the target is older than its dependencies,
    thus reducing the compile time of the whole project when only a few sources are
    altered or when single object files have been deleted.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当在makefile中正确配置所有依赖项时，Make确保只有在目标文件比其依赖项旧时才执行规则，因此当只有少数源文件被修改或单个目标文件被删除时，可以减少整个项目的编译时间。
- en: Make is a very powerful tool, and its range of possibilities goes far beyond
    the few features used to generate the examples in this book. Mastering the automation
    process of builds may lead to optimized build processes. The syntax of makefiles
    includes useful features, such as conditionals, which can be used to produce different
    results by invoking a makefile using different targets or environment variables.
    For a better understanding of the capabilities of Make, please refer to the GNU
    Make manual available at [https://www.gnu.org/software/make/manual](https://www.gnu.org/software/make/manual).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Make是一个非常强大的工具，其功能范围远远超出了本书中用于生成示例的少数功能。掌握构建过程的自动化可能有助于优化构建过程。makefile的语法包括有用的功能，例如条件语句，可以通过使用不同的目标或环境变量调用makefile来产生不同的结果。为了更好地理解Make的能力，请参阅可用的GNU
    Make手册，网址为[https://www.gnu.org/software/make/manual](https://www.gnu.org/software/make/manual)。
- en: Debugger
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试器
- en: In the host environment, debugging an application that runs on top of the operating
    system is done by running a debugger tool, which can attach to an existing process
    or spawn a new one given an executable ELF file and its command-line arguments.
    The default debugging option provided by the GCC suite is called **GDB**, an acronym
    for the **GNU Debugger**. While GDB is a command-line tool, several frontends
    have been developed to provide better visualization of the state of the execution,
    and some integrated development environments provide built-in frontends for interacting
    with the debugger while tracing the single lines being executed.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在宿主环境中，调试在操作系统上运行的应用程序是通过运行调试器工具来完成的，该工具可以附加到现有进程或根据可执行ELF文件及其命令行参数启动一个新的进程。GCC套件提供的默认调试选项称为**GDB**，即**GNU调试器**的缩写。虽然GDB是一个命令行工具，但已经开发了几个前端来提供更好的执行状态可视化，并且一些集成开发环境在跟踪正在执行的单独行时提供了与调试器交互的内置前端。
- en: Once again, the situation is slightly changed when the software to debug is
    running on a remote platform. A version of GDB, distributed with the toolchain
    and specific to the target platform, can be run on the development machine to
    connect to a remote debug session. A debug session on a remote target requires
    an intermediate tool that is configured to translate GDB commands into actual
    actions on the core CPU and the related hardware infrastructure to establish communication
    with the core.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，当要调试的软件在远程平台上运行时，情况略有变化。可以在开发机上运行与工具链一起分发的GDB版本，以连接到远程调试会话。在远程目标上进行的调试会话需要一个中间工具，该工具配置为将GDB命令转换为对核心CPU和相关硬件基础设施的实际操作，以建立与核心的通信。
- en: Some embedded platforms provide hardware breakpoints, which are used to trigger
    system exceptions every time the selected instructions are executed.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一些嵌入式平台提供了硬件断点，这些断点用于在执行所选指令时触发系统异常。
- en: Later in this chapter, we will see how a remote GDB session can be established
    with the target in order to interrupt its execution at the current point, proceed
    to step through the code, place breakpoints and watchpoints, and inspect and modify
    the values in memory.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将看到如何与目标建立远程GDB会话，以便在当前点中断其执行，逐步执行代码，设置断点和观察点，并检查和修改内存中的值。
- en: A handful of GDB commands are introduced, giving a quick reference to some of
    the functionalities provided by the GDB command-line interface, which can be effectively
    used to debug embedded applications.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 介绍了一些GDB命令，为GDB命令行界面提供的某些功能提供快速参考，这些功能可以有效地用于调试嵌入式应用程序。
- en: The debugger gives the best possible understanding of what the software is doing
    at runtime and facilitates the hunt for programming errors while directly looking
    at the effects of the execution on memory and CPU registers.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器提供了对软件在运行时正在做什么的最佳理解，并便于在直接查看执行对内存和CPU寄存器的影响的同时查找编程错误。
- en: Embedded workflow
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌入式工作流程
- en: 'If compared to other domains, the embedded development life cycle includes
    some additional steps. The code must be cross compiled, the image manipulated
    then uploaded to a target, tests must be run, and possibly hardware tools are
    involved in the measurement and verification phases. The life cycle of native
    application software, when using compiled languages, looks like this diagram:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果与其他领域相比，嵌入式开发生命周期包括一些额外的步骤。代码必须进行交叉编译，然后处理映像并上传到目标，必须运行测试，并且在测量和验证阶段可能需要涉及硬件工具。使用编译语言时，本地应用程序软件的生命周期看起来像这个图表：
- en: '![Figure 2.1 – A typical life cycle of application development](img/B18730_02_01.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1 – 应用程序开发的典型生命周期](img/B18730_02_01.jpg)'
- en: Figure 2.1 – A typical life cycle of application development
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – 应用程序开发的典型生命周期
- en: When writing software within the same architecture, tests and debugging can
    be performed right after compiling, and it is often easier to detect issues. This
    results in a shorter time for the typical loop. Moreover, if the application crashes
    because of a bug, the underlying operating system can produce a core dump, which
    can be analyzed using the debugger at a later time by restoring the content of
    the virtual memory and the context of the CPU registers right at the moment when
    the bug shows up.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当在同一架构内编写软件时，测试和调试可以在编译后立即进行，通常更容易发现问题。这导致典型循环的时间更短。此外，如果应用程序由于错误而崩溃，底层操作系统可以生成核心转储，这可以在稍后通过调试器进行分析，方法是恢复虚拟内存内容和CPU寄存器上下文，在错误出现的那一刻。
- en: On the other hand, intercepting fatal errors on an embedded target might be
    slightly more challenging because of the potential side effect of memory and register
    corruption in the absence of virtual addresses and memory segmentation provided
    by the operating systems in other contexts. Even if some targets can intercept
    abnormal situations by triggering diagnostic interrupts, such as the hard fault
    handler in Cortex-M, restoring the original context that generated the error is
    often impossible.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，由于缺乏其他环境中操作系统提供的虚拟地址和内存分段，在嵌入式目标上拦截致命错误可能稍微更具挑战性，因为可能会出现内存和寄存器损坏的潜在副作用。即使某些目标可以通过触发诊断中断来拦截异常情况，例如Cortex-M中的硬故障处理程序，恢复生成错误的原始上下文通常是不可能的。
- en: 'Furthermore, every time new software is generated, there are a few time-consuming
    steps to perform, such as the translation of the image to a specific format, and
    uploading the image to the target itself, which may take anywhere from a few seconds
    up to a minute, depending on the size of the image and the speed of the interface
    used to communicate with the target:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，每次生成新的软件时，都需要执行一些耗时步骤，例如将图像转换为特定格式，以及将图像上传到目标本身，这可能需要几秒钟到一分钟的时间，具体取决于图像的大小和与目标通信所使用的接口速度：
- en: '![Figure 2.2 – The embedded development life cycle, including additional steps
    required by the environment](img/B18730_02_02.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2 – 嵌入式开发生命周期，包括环境所需的其他步骤](img/B18730_02_02.jpg)'
- en: Figure 2.2 – The embedded development life cycle, including additional steps
    required by the environment
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – 嵌入式开发生命周期，包括环境所需的其他步骤
- en: In some of the phases of the development, when multiple consecutive iterations
    may be required to finalize a feature implementation or detect a defect, the timing
    between compiling and testing the software has an impact on the efficiency of
    the whole life cycle. Specific tasks implemented in the software, which involve
    communication through serial or network interfaces, can only be verified with
    signal analysis or by observing the effect on the peripheral or the remote system
    involved. Analyzing the electrical effects on the embedded system requires some
    hardware setup and instrument configuration, which add more time to the equation.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发的一些阶段，当可能需要多次连续迭代以最终实现功能或检测缺陷时，编译和测试软件之间的时机会影响整个生命周期的效率。软件中实现的具体任务，涉及通过串行或网络接口进行通信，只能通过信号分析或观察对涉及的外围或远程系统的影响来验证。分析嵌入式系统上的电气效应需要一些硬件设置和仪器配置，这会增加更多的时间。
- en: Finally, developing a distributed embedded system composed of several devices
    running different software images may result in repeating the preceding iterations
    for each of these devices. Whenever possible, these steps should be eliminated
    by using the same image and different set configuration parameters on each device
    and by implementing parallel firmware upgrade mechanisms. Protocols such as JTAG
    support uploading the software image to multiple targets sharing the same bus,
    significantly cutting down the time required for the firmware upgrades, especially
    in those distributed systems with a larger number of devices involved.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，开发由运行不同软件映像的多个设备组成的分布式嵌入式系统可能会导致为这些设备中的每一个重复前面的迭代。在可能的情况下，应通过在每个设备上使用相同的映像和不同的设置配置参数，以及通过实现并行固件升级机制来消除这些步骤。例如，JTAG协议支持将软件映像上传到共享相同总线的多个目标，这显著减少了固件升级所需的时间，尤其是在涉及更多设备的分布式系统中。
- en: No matter how complex the project is expected to be, it is, in general, worth
    spending as much time as needed to optimize the life cycle of the software development
    at the beginning in order to increase efficiency later on. No developer likes
    to switch the focus away from the actual coding steps for too long, and it might
    be frustrating to work in a suboptimal environment where stepping through the
    process requires too much time or human interaction.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 无论预期的项目有多复杂，通常都值得在开始时投入所需的时间来优化软件开发的生命周期，以便在以后提高效率。没有开发者喜欢长时间将注意力从实际的编码步骤上移开，在一个需要太多时间或人工交互才能完成过程的次优环境中工作可能会令人沮丧。
- en: An embedded project can be started from scratch using a text editor or by creating
    a new project in an integrated development environment.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用文本编辑器从头开始创建嵌入式项目，或者通过在集成开发环境中创建新项目。
- en: Text editors versus integrated environments
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本编辑器与集成环境之间的比较
- en: While mostly a matter of developer preferences, the debate is still open in
    the embedded community between those who use a standalone text editor and those
    who prefer to have all the components of the toolchain integrated into one GUI.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这主要取决于开发者的个人喜好，但在嵌入式社区中，关于是使用独立的文本编辑器还是更喜欢将工具链的所有组件集成到一个图形用户界面中的争论仍然存在。
- en: 'Modern IDEs incorporate tools for the following tasks:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现代集成开发环境（IDE）集成了以下任务的工具：
- en: Managing the components of the project
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理项目的组件
- en: Quickly accessing all the files for editing as well as extensions to upload
    the software on the board
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速访问所有用于编辑的文件以及上传软件到板上的扩展
- en: Starting a debugging session with a single click
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过单击开始调试会话
- en: Microcontroller manufacturers often distribute their development kits along
    with IDEs that make it easy to access advanced features that are specific to the
    microcontroller, thanks to preconfigured setups and wizards facilitating the creation
    of new projects. Most IDEs include widgets to automatically generate the setup
    code for pin multiplexing for specific microcontrollers, starting from a graphical
    interface. Some of them even offer simulators and tools to predict runtime resource
    usage, such as dynamic memory and power consumption.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 微控制器制造商通常将他们的开发套件与 IDE 一起分发，这使得访问特定于微控制器的先进功能变得容易，这得益于预配置的设置和向导，它们简化了新项目的创建。大多数
    IDE 包含用于自动生成特定微控制器引脚复用设置的设置代码的控件，从图形界面开始。其中一些甚至提供模拟器和工具来预测运行时资源使用情况，例如动态内存和功耗。
- en: The majority of these tools are based on some customization of Eclipse, a popular
    open source desktop IDE, originally designed as a tool for Java software development,
    then later on very successful in many other fields thanks to the possibilities
    to extend and customize its interface.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具中的大多数都是基于 Eclipse 的某种定制，Eclipse 是一个流行的开源桌面集成开发环境（IDE），最初设计为 Java 软件开发的工具，后来由于扩展和自定义界面的可能性，在许多其他领域也非常成功。
- en: There are downsides to the IDE approach too. IDEs, in general, do not embed
    the actual toolchain in the code. Rather, they provide a frontend interface to
    interact with a compiler, linker, debugger, and other tools. To do so, they have
    to store all the flags, configuration options, the paths of included files, and
    compile-time-defined symbols in a machine-readable configuration file. Some users
    find those options difficult to access by navigating through the multiple menus
    of the GUI. Other key components of the project, such as the linker script, may
    also be well hidden under the hood, in some cases even automatically generated
    by the IDE and difficult to read. For most IDE users, however, these downsides
    are compensated by the perks of developing with an integrated environment.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 IDE 方法也有其缺点。IDE 通常不将实际的工具链嵌入到代码中。相反，它们提供了一个前端界面来与编译器、链接器、调试器和其他工具交互。为此，它们必须将所有标志、配置选项、包含文件的路径以及编译时定义的符号存储在一个机器可读的配置文件中。一些用户发现通过导航
    GUI 的多个菜单来访问这些选项很困难。项目的一些其他关键组件，如链接脚本，也可能隐藏在底层，在某些情况下甚至由 IDE 自动生成，难以阅读。然而，对于大多数
    IDE 用户来说，这些缺点被集成环境开发的优点所抵消。
- en: 'There is one last caveat that has to be considered, though. The project will
    sooner or later be built and tested automatically, as previously analyzed in the
    *Make: a build automation tool* section. Robots are, in general, terrible users
    of IDEs, while they can build and run any test, even interacting with real targets,
    using a command-line interface. A development team using an IDE for embedded development
    should always consider providing an option to build and test any software through
    a command-line alternate strategy.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，还有一个必须考虑的注意事项。项目迟早会被自动构建和测试，正如在 *Make：构建自动化工具* 部分中分析的那样。机器人通常在 IDE 中是糟糕的用户，尽管它们可以使用命令行界面构建和运行任何测试，甚至与真实目标交互。使用
    IDE 进行嵌入式开发的开发团队应始终考虑提供通过命令行替代策略构建和测试任何软件的选项。
- en: While some complexity of the toolchain can be abstracted with a GUI, it is useful
    to understand the functions of the set of applications under the hood. The remaining
    sections of this chapter explore the GCC toolchain, the most popular cross-architecture
    set of compilers for many 32-bit microcontrollers.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管工具链的一些复杂性可以通过图形用户界面（GUI）进行抽象，但了解底层应用程序集的功能仍然很有用。本章的剩余部分将探讨 GCC 工具链，这是许多 32
    位微控制器最受欢迎的跨架构编译器集。
- en: The GCC toolchain
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GCC 工具链
- en: While in the case of the IDE, its complexity is abstracted through the user
    interface, a toolchain is a set of standalone software applications, each one
    serving a specific purpose.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IDE 的情况下，其复杂性是通过用户界面进行抽象的，而工具链是一组独立的软件应用程序，每个应用程序都服务于特定的目的。
- en: GCC is one of the reference toolchains to build embedded systems due to its
    modular structure allowing backends for multiple architectures. Thanks to its
    open source model, and the flexibility in building tailored toolchains from it,
    GCC-based toolchains are among the most popular development tools in embedded
    systems.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: GCC 是构建嵌入式系统的参考工具链之一，因为它具有模块化结构，允许为多个架构提供后端。由于其开源模型以及从其构建定制工具链的灵活性，基于 GCC 的工具链是嵌入式系统中最受欢迎的开发工具之一。
- en: Building software using a command-line-based toolchain has several advantages,
    including the possibility of automating the intermediate steps that would build
    all the modules up from the source code into the final image. This is particularly
    useful when it is required to program multiple devices in a row or to automate
    builds on a continuous integration server.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于命令行的工具链构建软件具有多个优点，包括自动化中间步骤的可能性，这些步骤将所有模块从源代码构建成最终映像。这在需要连续编程多个设备或需要在持续集成服务器上自动化构建时尤其有用。
- en: ARM distributes the GNU Arm Embedded Toolchain for all the most popular development
    hosts. Toolchains are prefixed with a triplet describing the target. In the case
    of the GNU Arm Embedded Toolchain, the prefix is `arm-none-eabi`, indicating that
    the cross compiler backend is configured to produce objects for ARM, with no specific
    support for an operating system API, and with the embedded ABI.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ARM 为所有最受欢迎的开发主机分发 GNU Arm Embedded Toolchain。工具链以描述目标的三元组为前缀。在 GNU Arm Embedded
    Toolchain 的情况下，前缀是 `arm-none-eabi`，表示交叉编译器后端配置为为 ARM 生成对象，没有特定于操作系统的 API 支持，并且具有嵌入式
    ABI。
- en: The cross compiler
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交叉编译器
- en: The cross compiler distributed with a toolchain is a variant of GCC, with the
    backend configured to build object files that contain machine code for a specific
    architecture. The output of the compilation is one set of object files containing
    symbols that can only be interpreted by the specific target. `Arm-none-eabi-gcc`,
    the GCC variant provided by ARM to build software for microcontrollers, can compile
    C code into machine instructions and CPU optimizations for several different targets.
    Each architecture needs its own specific toolchain that will produce target-specific
    executables.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 与工具链一起分发的交叉编译器是 GCC 的一个变体，后端配置为构建包含特定架构机器代码的对象文件。编译的输出是一组包含只能由特定目标解释的符号的对象文件。`Arm-none-eabi-gcc`，ARM
    提供的用于构建微控制器软件的 GCC 变体，可以将 C 代码编译成适用于多个不同目标的机器指令和 CPU 优化。每个架构都需要自己的特定工具链，该工具链将生成特定目标的可执行文件。
- en: The GCC backend for the ARM architecture supports several machine-specific options
    to select the correct instruction set for the CPU and the machine-specific optimization
    parameters.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: GCC 后端对 ARM 架构支持多个机器特定选项，用于选择 CPU 的正确指令集和机器特定优化参数。
- en: 'The following table lists some of the ARM-specific machine options available
    on the GCC backend as `-``m` flags:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 下表列出了 GCC 后端作为 `-m` 标志提供的某些 ARM 特定机器选项：
- en: '![Table 2.3 – Architecture-specific compiler options for GCC ARM ](img/03.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![表 2.3 – GCC ARM 特定架构的编译器选项](img/03.jpg)'
- en: Table 2.3 – Architecture-specific compiler options for GCC ARM
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.3 – GCC ARM 特定架构的编译器选项
- en: 'To compile code that is compatible with a generic ARM Cortex M4, the `-mthumb`
    and `-mcpu=cortex-m4` options must be specified every time the compiler is invoked:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译与通用 ARM Cortex M4 兼容的代码，每次调用编译器时都必须指定 `-mthumb` 和 `-mcpu=cortex-m4` 选项：
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `test.o` file that is the result of this compile step is very different
    from the one that can be compiled, from the same source, using the `gcc` host.
    The difference can be better appreciated if, instead of the two object files,
    the intermediate assembly code is compared. The compiler is, in fact, capable
    of creating intermediate assembly code files instead of compiled and assembled
    objects when it is invoked with the `-``S` option.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个编译步骤产生的 `test.o` 文件与使用 `gcc` 主机从相同源代码编译的文件非常不同。如果比较的不是两个对象文件，而是中间汇编代码，这种差异将更容易理解。实际上，当使用
    `-S` 选项调用编译器时，编译器能够创建中间汇编代码文件，而不是编译和组装的对象。
- en: 'In a similar way to the host GCC compiler, there are different levels of possible
    optimization available to activate. In some cases, it makes sense to activate
    the size optimization to generate smaller object files. It is preferable, though,
    that the non-optimized image can fit the flash during the development to facilitate
    the debugging procedures, as optimized code flow is more difficult to follow when
    the compiler may change the order of the execution of the code and hide away the
    content of some variables. The optimization parameter can be provided at the command
    line to select the desired optimization level:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 与主机 GCC 编译器类似，有不同级别的可能优化可供激活。在某些情况下，激活大小优化以生成更小的目标文件是有意义的。然而，在开发过程中，非优化映像适合闪存以方便调试过程更为可取，因为编译器可能会更改代码执行的顺序并隐藏某些变量的内容，这使得优化后的代码流更难跟踪。优化参数可以提供在命令行中，以选择所需的优化级别：
- en: '![Table 2.4 – GCC levels of optimization ](img/04.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![表2.4 – GCC优化级别](img/04.jpg)'
- en: Table 2.4 – GCC levels of optimization
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.4 – GCC优化级别
- en: Another generic GCC command-line option that is often used while debugging and
    prototyping is the `-g` flag, which instructs the compiler to keep the debugging-related
    data in the final object in order to facilitate access to functions’ and variables’
    readable handles while running within the debugger.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个在调试和原型设计过程中经常使用的通用 GCC 命令行选项是 `-g` 标志，它指示编译器在最终对象中保留调试相关数据，以便在调试器中运行时便于访问函数和变量的可读句柄。
- en: To inform the compiler that we are running a bare-metal application, the `-ffreestanding`
    command-line option is used. In GCC jargon, a freestanding environment is defined
    by the possible lack of a standard library in the linking step, and most importantly,
    this option alerts the compiler that it should not expect to use the main function
    as the entry point of the program or provide any preamble code before the beginning
    of the execution. This option is required when compiling code for the embedded
    platforms, as it enables the boot mechanism described in [*Chapter 4*](B18730_04.xhtml#_idTextAnchor115),
    *The* *Boot-Up Procedure*.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通知编译器我们正在运行裸机应用程序，使用 `-ffreestanding` 命令行选项。在 GCC 术语中，独立环境由在链接步骤中可能缺少标准库定义，并且最重要的是，此选项会通知编译器它不应期望使用主函数作为程序的入口点或在执行开始之前提供任何前导代码。当为嵌入式平台编译代码时，此选项是必需的，因为它启用了在[*第4章*](B18730_04.xhtml#_idTextAnchor115)，“*启动过程*”中描述的启动机制。
- en: The GCC program supports many more command-line options than those quickly introduced
    here. For a more complete overview of the functionalities offered, please refer
    to the GNU GCC manual, available at [https://gcc.gnu.org/onlinedocs/](https://gcc.gnu.org/onlinedocs/).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: GCC 程序支持的命令行选项比这里快速介绍的多得多。要获得功能性的更完整概述，请参阅可用的 GNU GCC 手册，网址为 [https://gcc.gnu.org/onlinedocs/](https://gcc.gnu.org/onlinedocs/)。
- en: To integrate the cross compiling toolchain in the automated build using Make,
    a few changes are required in the makefile.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Make 的自动构建中集成交叉编译工具链，需要在 makefile 中进行一些更改。
- en: 'Assuming that the toolchain is correctly installed on the development host
    and reachable in its executing path, it is sufficient to change the default compiler
    command using the `CC` Make variable in the makefile:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 假设工具链已正确安装在开发主机上，并且可在其执行路径中访问，则只需更改 makefile 中的默认编译器命令即可使用 `CC` Make 变量：
- en: '[PRE7]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The custom command-line options required to run the compile options may be
    exported through the `CFLAGS` variable:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 运行编译选项所需的自定义命令行选项可以通过 `CFLAGS` 变量导出：
- en: '[PRE8]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Using default makefile variables, such as `CC` and `CFLAGS`, enables implicit
    makefile rules, building object files from `C` sources with the same name, and
    a custom compiler configuration.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认的 makefile 变量，如 `CC` 和 `CFLAGS`，可以启用隐式 makefile 规则，从具有相同名称的 `C` 源文件构建目标文件，以及自定义编译器配置。
- en: Compiling the compiler
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译编译器
- en: Binary distributions of the GCC toolchain are available to download for several
    specific targets and host machines. To compile the code for the ARM Cortex-M microprocessors,
    the `arm-none-eabi` toolchain is made available for most GNU/Linux distributions.
    However, in some cases, it might be handy to build the toolchain entirely from
    the sources. This might be, for example, when the compiler for a certain target
    does not exist yet or is not shipped in binary format for our favorite development
    environment. This process is also useful to better understand the various components
    that are required to build the tools.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: GCC工具链的二进制发行版可用于下载到几个特定的目标和主机机器。为了编译适用于ARM Cortex-M微处理器的代码，`arm-none-eabi`工具链对大多数GNU/Linux发行版可用。然而，在某些情况下，从头开始构建工具链可能很有用。例如，当某个目标的编译器尚未存在或未以二进制格式提供给我们喜欢的开发环境时。这个过程也有助于更好地理解构建工具所需的各个组件。
- en: '`menuconfig` kernel. After installing crosstool-NG, the configurator can be
    invoked by using the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`menuconfig`内核。在安装crosstool-NG后，可以通过以下方式调用配置器：'
- en: '[PRE9]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Once the configuration has been created, the build process can be started.
    Since the operation requires retrieving all the components, patching them, and
    building the toolchain, it may take several minutes, depending on the speed of
    the host machine and the internet connection, to retrieve all the components.
    The build process can be started by issuing the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了配置，就可以开始构建过程。由于操作需要检索所有组件、修补它们并构建工具链，因此根据主机机器的速度和互联网连接速度，检索所有组件可能需要几分钟。可以通过以下命令启动构建过程：
- en: '[PRE10]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Predefined configurations are available for compiling commonly used toolchains,
    mostly for targets running Linux. When compiling a toolchain for a Linux target,
    there are a few C libraries to choose from. In our case, since we want a bare-metal
    toolchain, `newlib` is the default choice. Several other libraries provide an
    implementation of a subset of the C standard library, such as `uClibc` and `musl`.
    The `newlib` library is a small cross-platform C library mostly designed for embedded
    systems with no operating system on board, and it is provided as the default in
    many GCC distributions, including the `arm-none-eabi` cross compiler distributed
    by ARM.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 预定义的配置可用于编译常用的工具链，主要用于运行Linux的目标。当为Linux目标编译工具链时，有几个C库可供选择。在我们的案例中，因为我们想要一个裸机工具链，所以`newlib`是默认选择。其他几个库提供了C标准库子集的实现，例如`uClibc`和`musl`。`newlib`库是一个小型跨平台C库，主要设计用于没有操作系统在板上的嵌入式系统，并且作为默认库在许多GCC发行版中提供，包括ARM分发的`arm-none-eabi`交叉编译器。
- en: Linking the executable
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链接可执行文件
- en: '`-T filename` option at the command line, the linker is asked to replace the
    default memory layout for the program with a custom script, contained in the filename.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行中使用`-T filename`选项，链接器被要求用包含在filename中的自定义脚本替换程序的默认内存布局。
- en: The `.ld` extension, and it is written in a specific language. As a rule of
    thumb, all the symbols from every single compiled object are grouped in the sections
    of the final executable image.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`.ld`扩展名，并且是用特定语言编写的。一般来说，每个编译对象的符号都被分组在最终可执行映像的各个部分中。'
- en: The script can interact with the C code, exporting symbols defined within the
    script and following indications provided in the code using GCC-specific attributes
    associated with symbols. The `__attribute__` keyword is provided by GCC to be
    put in front of the symbol definition to activate GCC-specific, non-standard attributes
    for each symbol.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本可以与C代码交互，通过GCC特定的与符号关联的属性，导出脚本内部定义的符号，并遵循代码中提供的指示。GCC提供了`__attribute__`关键字，用于在符号定义前添加，以激活针对每个符号的GCC特定、非标准属性。
- en: 'Some GCC attributes can be used to communicate to the linker about the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一些GCC属性可以用来向链接器传达以下信息：
- en: Weak symbols, which can be overridden by symbols with the same name
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弱符号，可以被具有相同名称的符号覆盖
- en: Symbols to be stored in a specific section in the ELF file, defined in the linker
    script
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要存储在ELF文件特定部分的符号，在链接脚本中定义
- en: Implicitly used symbols, which prevent the linker from discarding the symbol
    because it is referred to nowhere in the code
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐式使用的符号，这可以防止链接器丢弃符号，因为代码中没有任何地方引用它
- en: 'The `weak` attribute is used to define weak symbols, which can be overridden
    anywhere else in the code by another definition with the same name. Consider,
    for example, the following definition:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`weak`属性用于定义弱符号，可以在代码的任何其他地方通过具有相同名称的另一个定义来覆盖。例如，考虑以下定义：'
- en: '[PRE11]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In this case, the procedure is defined to do nothing, but it is possible to
    override it anywhere else in the code base by defining it again, using the same
    name, but this time without the `weak` attribute:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，过程被定义为不执行任何操作，但可以在代码库的任何其他地方通过再次定义它来覆盖它，使用相同的名称，但这次不带`weak`属性：
- en: '[PRE12]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The linker step ensures that the final executable contains exactly one copy
    of each defined symbol, which is the one without the attribute, if available.
    This mechanism introduces the possibility of having several different implementations
    of the same functionality within the code, which can be altered by including different
    object files in the linking phase. This is particularly useful when writing code
    that is portable to different targets while still maintaining the same abstractions.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 链接步骤确保最终的可执行文件恰好包含每个定义的符号的一个副本，如果没有属性，则是指不带属性的副本。这种机制引入了在代码中具有相同功能的不同实现的可能性，这些实现可以通过在链接阶段包含不同的目标文件来更改。这在编写可移植到不同目标的同时仍保持相同抽象的代码时特别有用。
- en: Besides the default sections required in the ELF description, custom sections
    may be added to store specific symbols, such as functions and variables, at fixed
    memory addresses. This is useful when storing data at the beginning of a flash
    page, which might be uploaded to flash at a different time than the software itself.
    This is the case for target-specific settings in some cases.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在ELF描述中所需的默认部分之外，还可以添加自定义部分来存储特定的符号，例如函数和变量，在固定的内存地址。当数据存储在可能在不同时间上传到闪存的闪存页的起始位置时，这很有用，而软件本身可能在不同的时间上传。在某些情况下，这是针对特定目标的设置的情况。
- en: 'Using the custom GCC `section` attribute when defining a symbol ensures that
    the symbol ends up at the desired position in the final image. Sections may have
    custom names as long as an entry exists in the linker to locate them. The `section`
    attribute can be added to a symbol definition as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义符号时使用自定义GCC `section`属性确保符号最终位于最终映像中的期望位置。只要在链接器中存在条目来定位它们，部分可以具有自定义名称。以下是如何将`section`属性添加到符号定义的示例：
- en: '[PRE13]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this example, the array is placed in the `.keys` section, which requires
    its own entry in the linker script as well.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，数组被放置在`.keys`部分，这需要在链接器脚本中为其创建自己的条目。
- en: It is considered good practice to have the linker discard the unused symbols
    in the final image, especially when using third-party libraries that are not completely
    utilized by the embedded application. This can be done in GCC using the linker
    garbage collector, activated via the `-gc-sections` command-line option. If this
    flag is provided, the sections that are unused in the code are automatically discarded,
    and the unused symbols will be kept out of the final image.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 被认为是一种良好的实践，让链接器在最终映像中丢弃未使用的符号，尤其是在使用嵌入式应用程序未完全利用的第三方库时。这可以通过GCC使用链接器垃圾收集器来完成，通过`-gc-sections`命令行选项激活。如果提供了此标志，代码中未使用的部分将被自动丢弃，未使用的符号也将被排除在最终映像之外。
- en: 'To prevent the linker from discarding symbols associated with a particular
    section, the `used` attribute marks the symbol as implicitly used by the program.
    Multiple attributes can be listed in the same declaration, separated by commas,
    as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止链接器丢弃与特定部分关联的符号，`used`属性将符号标记为程序隐式使用。可以在同一声明中列出多个属性，用逗号分隔，如下所示：
- en: '[PRE14]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this example, the attributes indicate both that the `private_key` array belongs
    to the `.keys` section and that it must not be discarded by the linker garbage
    collector because it is marked as used.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，属性既表明`private_key`数组属于`.keys`部分，又表明它不能被链接器垃圾收集器丢弃，因为它被标记为已使用。
- en: 'A simple linker script for an embedded target defines at least the two sections
    relative to `RAM` and `FLASH` mapping and exports some predefined symbols to instruct
    the assembler of the toolchain about the memory areas. A bare-metal system based
    on the GNU toolchain usually starts with a `MEMORY` section, describing the mapping
    of the two different areas in the system, such as the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一个用于嵌入式目标的简单链接脚本至少定义了与`RAM`和`FLASH`映射相关的两个部分，并将一些预定义的符号导出以指导工具链的汇编器了解内存区域。基于GNU工具链的裸机系统通常从一个`MEMORY`部分开始，描述系统内两个不同区域的映射，如下所示：
- en: '[PRE15]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding code snippet describes two memory areas used in the system. The
    first block is 256k mapped to `FLASH`, with the *r and x flags* indicating that
    the area is accessible for *read* and *execute* operations. This enforces the
    read-only attribute of the whole area and ensures that no variant sections are
    placed there. RAM, on the other hand, can be accessed in write mode directly,
    which means that variables are going to be placed in a section within that area.
    In this specific example, the target maps the FLASH mapping at the beginning of
    the address space, while the RAM is mapped starting at 512 MB. Each target has
    its address space mapping and flash/RAM size, which makes the linker script target-specific.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段描述了系统使用的两个内存区域。第一个块是256k映射到`FLASH`，其中*r和x标志*表示该区域可进行*读取*和*执行*操作。这强制了整个区域的只读属性，并确保没有变体部分被放置在那里。另一方面，RAM可以直接以写入模式访问，这意味着变量将被放置在该区域内的某个部分。在这个特定示例中，目标将FLASH映射在地址空间的开头，而RAM从512
    MB开始映射。每个目标都有自己的地址空间映射和闪存/RAM大小，这使得链接脚本针对特定目标。
- en: As mentioned earlier in this chapter, the `.text` and `.rodata` ELF sections
    can only be accessed for reading, so they can safely be stored in the FLASH area
    since they will not be modified while the target is running. On the other hand,
    both `.data` and `.bss` must be mapped in RAM to ensure that they are modifiable.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所述，`.text`和`.rodata` ELF部分只能进行读取访问，因此它们可以安全地存储在FLASH区域，因为它们在目标运行时不会被修改。另一方面，`.data`和`.bss`必须映射到RAM以确保它们可修改。
- en: Additional custom sections can be added to the script where it is necessary
    to store additional sections at a specific location in memory. The linker script
    can also export symbols related to a specific position in memory or to the length
    of dynamically sized sections in memory, which can be referred to as external
    symbols and accessed in the C source code.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在脚本中添加额外的自定义部分，在需要将额外的部分存储在内存的特定位置时。链接脚本还可以导出与内存中特定位置或动态大小部分的长度相关的符号，这些符号可以称为外部符号，并在C源代码中访问。
- en: The second block of statements in the linker script is called `SECTIONS` and
    contains the allocation of the sections in specific positions of the defined memory
    areas. The `.` symbol, when associated with a variable in the script, represents
    the current position in the area, which is filled progressively from the lower
    addresses available.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 链接脚本中的第二个语句块称为`SECTIONS`，包含在定义的内存区域特定位置的部分分配。当脚本中的`.`符号与一个变量相关联时，它代表该区域中的当前位置，该位置从可用的低地址开始逐步填充。
- en: 'Each section must specify the area where it has to be mapped. The following
    example, though still incomplete to run the binary executable, shows how the different
    sections can be deployed using the linker script. The `.text` and `.rodata` sections
    are mapped in the flash memory:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 每个部分都必须指定它必须映射到的区域。以下示例虽然仍然不完整，无法运行二进制可执行文件，但它展示了如何使用链接脚本部署不同的部分。`.text`和`.rodata`部分映射到闪存内存：
- en: '[PRE16]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The modifiable sections are mapped in RAM, with two special cases to notice
    here.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 可修改的部分映射在RAM中，这里有两个特殊情况需要注意。
- en: The `AT` keyword is used to indicate the load address to the linker, which is
    the area where the original values of the variables in `.data` are stored, while
    the actual addresses used in the execution are in a different memory region. More
    details about the load address and the virtual address for the `.data` section
    are explained in [*Chapter 4*](B18730_04.xhtml#_idTextAnchor115), *The* *Boot-Up
    Procedure*.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`AT`关键字用于向链接器指示加载地址，这是`.data`中变量的原始值存储的区域，而实际使用的执行地址在另一个内存区域。关于`.data`部分的加载地址和虚拟地址的更多详细信息，请参阅[*第4章*](B18730_04.xhtml#_idTextAnchor115)，*启动过程*。'
- en: 'The `NOLOAD` attribute used for the `.bss` section ensures that no predefined
    values are stored in the ELF file for this section. Uninitialized global and static
    variables are mapped by the linker in the RAM area, which is allocated by the
    linker:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 用于 `.bss` 段的 `NOLOAD` 属性确保该段在 ELF 文件中不存储预定义的值。未初始化的全局和静态变量由链接器映射到由链接器分配的 RAM
    区域：
- en: '[PRE17]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The alternative way to force the linker to keep sections in the final executable,
    avoiding their removal due to the linker garbage collector, is the use of the
    `KEEP` instruction to mark sections. Please note that this is an alternative to
    the `__attribute__((used))` mechanism explained earlier:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 强制链接器保留段在最终可执行文件中的另一种方法是使用 `KEEP` 指令标记段。请注意，这是之前解释的 `__attribute__((used))`
    机制的替代方案：
- en: '[PRE18]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'It is useful, and advisable in general, to have the linker create a `.map`
    file alongside the resultant binary. This is done by appending the `-Map=filename`
    option to the link step, such as in the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，让链接器创建一个与结果二进制文件并存的 `.map` 文件是有用的，可以通过在链接步骤中添加 `-Map=filename` 选项来实现，如下所示：
- en: '[PRE19]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The map file contains the location and the description of all the symbols, grouped
    by sections. This is useful for looking for the specific location of symbols in
    the image, as well as for verifying that useful symbols are not accidentally discarded
    due to a misconfiguration.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 映射文件包含了所有符号的位置和描述，按段分组。这对于在图像中查找符号的具体位置以及验证由于配置错误而意外丢弃的有用符号非常有用。
- en: Cross compiling toolchains provide standard C libraries for generic functionalities,
    such as string manipulation or standard type declarations. These are substantially
    a subset of the library calls available in the application space of an operating
    system, including standard input/output functions. The backend implementation
    of these functions is often left to the applications, so calling a function from
    the library that requires interaction with the hardware, such as `printf`, implies
    that a write function is implemented outside of the library, providing the final
    transfer to a device or peripheral.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 交叉编译工具链为通用功能提供标准 C 库，例如字符串操作或标准类型声明。这些实际上是操作系统应用程序空间中可用的库调用子集，包括标准输入/输出函数。这些函数的后端实现通常留给应用程序，因此调用需要与硬件交互的库函数，如
    `printf`，意味着在库外实现了一个写入函数，提供最终的设备或外围设备传输。
- en: The implementation of the backend write function determines which channel would
    act as the standard output for the embedded application. The linker is capable
    of resolving the dependencies towards standard library calls automatically, using
    the built-in `newlib` implementation. To exclude the standard C library symbols
    from the linking process, the `-nostdlib` option can be added to the options passed
    to GCC during the linking step.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 后端写入函数的实现决定了哪个通道将作为嵌入式应用程序的标准输出。链接器能够自动解析对标准库调用的依赖，使用内置的 `newlib` 实现。为了在链接过程中排除标准
    C 库符号，可以将 `-nostdlib` 选项添加到传递给 GCC 的链接步骤的选项中。
- en: Binary format conversion
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二进制格式转换
- en: 'Despite containing all the compiled symbols in binary format, an ELF file is
    prefixed with a header that contains a description of the content and pointers
    to the positions where the sections start within the file. All this extra information
    is not needed to run on an embedded target, so the ELF file produced by the linker
    has to be transformed into a plain binary file. A tool in the toolchain, called
    `objcopy`, converts images from one standard format to others, and what is generally
    done is a conversion of the ELF into a raw binary image without altering the symbols.
    To transform the image from ELF to binary format, invoke the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管包含所有编译符号的二进制格式，ELF 文件前面有一个包含内容描述和指向文件中各段起始位置指针的头部。所有这些额外信息在嵌入式目标上运行时并不需要，因此链接器生成的
    ELF 文件必须转换为一个纯二进制文件。工具链中的一个工具 `objcopy` 可以将图像从一种标准格式转换为其他格式，通常的做法是将 ELF 转换为不带符号的原始二进制图像。要将图像从
    ELF 转换为二进制格式，请调用以下命令：
- en: '[PRE20]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This creates a new file, called `image.bin`, from the symbols contained in the
    original ELF executable, which can be uploaded to the target.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为 `image.bin` 的新文件，该文件包含原始 ELF 可执行文件中的符号，可以上传到目标设备。
- en: 'Even if not suitable in general for direct upload on the target with third-party
    tools, it is possible to load the symbols through the debugger and upload them
    to the flash address. The original ELF file is also useful as the target of other
    diagnostic tools in the GNU toolchain, such as `nm` and `readelf`, which display
    the symbols in each module, with their type and relative address within the binary
    image. Furthermore, by using the `objdump` tool on the final image, or even on
    single object files, several details about the image can be retrieved, including
    the visualization of the entire assembly code, using the `-d` disassemble option:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 即使通常不适用于使用第三方工具直接上传到目标设备，也可以通过调试器加载符号并将它们上传到闪存地址。原始的 ELF 文件对于 GNU 工具链中的其他诊断工具（如
    `nm` 和 `readelf`）的目标也很有用，这些工具显示每个模块中的符号，包括它们的类型和相对于二进制图像的相对地址。此外，通过在最终图像或单个对象文件上使用
    `objdump` 工具，可以检索到关于图像的多个细节，包括使用 `-d` 反汇编选项可视化整个汇编代码：
- en: '[PRE21]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: At this point, the toolchain has provided us with all the artifacts needed to
    run, debug, and analyze the compiled software on a target microcontroller. In
    order to transfer the image or start a debugging session, we need additional specific
    tools, described in the next section.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，工具链已为我们提供了在目标微控制器上运行、调试和分析编译软件所需的所有工件。为了传输图像或开始调试会话，我们需要额外的特定工具，下一节将进行描述。
- en: Interacting with the target
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与目标交互
- en: For development purposes, embedded platforms are usually accessed through a
    JTAG or an SWD interface. Through these communication channels, it is possible
    to upload the software onto the flash of the target and access the on-chip debug
    functionality. Several self-contained JTAG/SWD adapters on the market can be controlled
    through a USB from the host, while some development boards are equipped with an
    extra chip controlling the JTAG channel that connects to the host through a USB.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开发目的，嵌入式平台通常通过 JTAG 或 SWD 接口进行访问。通过这些通信通道，可以将软件上传到目标设备的闪存中，并访问片上调试功能。市场上存在一些自包含的
    JTAG/SWD 适配器，可以通过主机上的 USB 进行控制，而一些开发板配备了额外的芯片，用于控制连接到主机的 JTAG 通道。
- en: A powerful generic open source tool to access JTAG/SWD functionalities on the
    target is the **Open On-Chip Debugger** (**OpenOCD**). Once properly configured,
    it creates local sockets that can be used as a command console and for interaction
    with the debugger frontend. Some development boards are distributed with additional
    interfaces to communicate with the core CPU. For example, STMicroelectronics prototyping
    boards for **Cortex-M** are rarely shipped without a chip technology called ST-Link,
    which allows direct access to debug and flash manipulation functionalities. Thanks
    to its flexible backend, OpenOCD can communicate with these devices using different
    transport types and physical interfaces, including ST-Link and other protocols.
    Several different boards are supported and the configuration files can be found
    by OpenOCD.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一个强大的通用开源工具，用于访问目标上的 JTAG/SWD 功能，是 **Open On-Chip Debugger** (**OpenOCD**)。一旦正确配置，它将创建可以用于命令控制台和与调试器前端交互的本地套接字。一些开发板配备了额外的接口，用于与核心
    CPU 通信。例如，STMicroelectronics 为 **Cortex-M** 设计的原理图板很少不配备 ST-Link 芯片技术，这允许直接访问调试和闪存操作功能。得益于其灵活的后端，OpenOCD
    可以使用不同的传输类型和物理接口（包括 ST-Link 和其他协议）与这些设备通信。支持多种不同的板，配置文件可以在 OpenOCD 中找到。
- en: When started, OpenOCD opens two local TCP server sockets on preconfigured ports,
    providing communication services with the target platform. One socket provides
    an interactive command console that can be accessed through Telnet, while the
    other is a GDB server used for remote debugging, as described in the next section.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当启动时，OpenOCD 在预配置的端口上打开两个本地 TCP 服务器套接字，为目标平台提供通信服务。一个套接字提供了一个可以通过 Telnet 访问的交互式命令控制台，而另一个是用于远程调试的
    GDB 服务器，如下一节所述。
- en: OpenOCD is distributed along with two sets of configuration files that describe
    the target microcontroller and peripherals (in the `target/` directory), and the
    debugging interface used to communicate to it via JTAG or SWD (in the `interface/`
    directory). A third set of configuration files (in the `board/` directory) contain
    configuration files for well-known systems, such as development boards equipped
    with an interface chip, which combines both interfaces and target settings by
    including the correct files.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: OpenOCD 伴随两套配置文件集一起分发，这些配置文件描述了目标微控制器和外设（在 `target/` 目录中），以及用于通过 JTAG 或 SWD
    与其通信的调试接口（在 `interface/` 目录中）。第三套配置文件（在 `board/` 目录中）包含针对知名系统的配置文件，例如配备接口芯片的开发板，该芯片通过包含正确的文件将两个接口和目标设置结合起来。
- en: 'In order to configure OpenOCD for the `openocd.cfg` configuration file:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了配置 OpenOCD 以使用 `openocd.cfg` 配置文件：
- en: '[PRE22]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The board-specific configuration file, which was imported from `openocd.cfg`,
    through the `source` directive, instructs OpenOCD to use the ST-Link interface
    to communicate with the target and sets all the CPU-specific options for the STM32F7
    family of microcontrollers.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `openocd.cfg` 通过 `source` 指令导入的特定于板的配置文件，指示 OpenOCD 使用 ST-Link 接口与目标通信，并为
    STM32F 系列微控制器设置所有 CPU 特定选项。
- en: The two ports specified in the main configuration file, using the `telnet_port`
    and `gdb_port` directives, instruct OpenOCD to open two listening TCP sockets.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 主配置文件中指定的两个端口，使用 `telnet_port` 和 `gdb_port` 指令，指示 OpenOCD 打开两个监听 TCP 套接字。
- en: 'The first socket, often referred to as the monitor console, can be accessed
    by connecting to the local **4444 TCP port**, using a Telnet client from the command
    line:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 通常称为监视控制台的第一个套接字可以通过连接到本地的 **4444 TCP 端口**，使用命令行中的 Telnet 客户端来访问：
- en: '[PRE23]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The sequence of OpenOCD directives to initialize, erase the flash, and transfer
    the image starts with the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: OpenOCD 初始化、擦除闪存和传输映像的指令序列以以下内容开始：
- en: '[PRE24]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The execution is stopped at the beginning of the software image. After the
    `probe` command, the flash is initialized, and OpenOCD will print out some information,
    including the address mapped to write on the flash. The following information
    shows up with the STM32F746:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 执行在软件映像的开始处停止。在 `probe` 命令之后，闪存被初始化，OpenOCD 将打印一些信息，包括映射到闪存上写入的地址。以下信息显示在 STM32F746
    上：
- en: '[PRE25]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The geometry of the flash can be retrieved using this command:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令检索闪存的几何形状：
- en: '[PRE26]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Which, on STM32F746 shows as the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在 STM32F746 上显示如下：
- en: '[PRE27]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This flash contains eight sectors. If the OpenOCD target supports it, the flash
    can be completely erased by issuing the following command from the console:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 该闪存包含八个扇区。如果 OpenOCD 目标支持，可以通过从控制台发出以下命令来完全擦除闪存：
- en: '[PRE28]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Once the flash memory is erased, we can upload a software image to it, linked
    and converted to raw binary format using the `flash write_image` directive. As
    the raw binary format does not contain any information about its destination address
    in the mapped area, the starting address in the flash must be provided as the
    last argument, as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦擦除闪存内存，我们可以使用 `flash write_image` 指令将其上传软件映像，并将其链接并转换为原始二进制格式。由于原始二进制格式不包含关于其在映射区域中目标地址的信息，因此必须将闪存中的起始地址作为最后一个参数提供，如下所示：
- en: '[PRE29]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: These directives can be appended to the `openocd.cfg` file, or to different
    configuration files, in order to automate all the steps needed for a specific
    action, such as erasing the flash and uploading an updated image.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令可以附加到 `openocd.cfg` 文件中，或者附加到不同的配置文件中，以便自动化执行特定操作所需的所有步骤，例如擦除闪存和上传更新后的映像。
- en: Some hardware manufacturers offer their own set of tools to interact with the
    devices. STMicroelectronics devices can be programmed using the ST-Link utilities,
    an open source project that includes a flash tool (`st-flash`), and a GDB server
    counterpart (`st-util`). Some platforms have built-in bootloaders that accept
    alternative formats or binary transfer procedures. A common example is `dfu-util`,
    which is a free software tool.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 一些硬件制造商提供自己的工具集以与设备交互。STMicroelectronics 设备可以使用 ST-Link 工具进行编程，这是一个开源项目，包括一个闪存工具
    (`st-flash`) 和一个 GDB 服务器对应工具 (`st-util`)。一些平台内置了接受替代格式或二进制传输过程的引导加载程序。一个常见的例子是
    `dfu-util`，这是一个免费软件工具。
- en: Each tool, either generic or specific, tends to meet the same goal of communicating
    with the device and providing an interface for debugging the code, although often
    exposing a different interface toward the development tools.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 每个工具，无论是通用的还是特定的，都倾向于达到相同的目标，即与设备通信并提供调试代码的接口，尽管它们通常向开发工具暴露不同的接口。
- en: Most IDEs provided by manufacturers to work with a specific family of microcontrollers
    incorporate in the IDE their own tools or third-party applications to access flash
    mapping and control the execution on the target. While, on one hand, they promise
    to hide the unnecessary complexity of the operation and provide firmware upload
    in one click, on the other, they generally do not provide a convenient interface
    for programming multiple targets at the same time, or at least efficiently, when
    it comes to production in large batches requiring to upload of the initial factory
    firmware.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数制造商提供的用于与特定系列微控制器一起工作的 IDE，在 IDE 中集成了他们自己的工具或第三方应用程序，以访问闪存映射并控制目标上的执行。虽然，一方面，他们承诺隐藏操作的不必要复杂性并提供一键式固件上传，但另一方面，他们通常不提供方便的界面用于同时编程多个目标，或者至少在需要批量上传初始工厂固件的生产中，效率不高。
- en: Knowing the mechanisms and procedures from a command-line interface allows for
    understanding what is happening behind the scenes every time a new firmware is
    uploaded to the target, and anticipating the issues that would impact the life
    cycle during this phase.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 了解从命令行界面了解机制和流程，可以让我们理解每次将新固件上传到目标设备时幕后发生的事情，并预测在此阶段可能影响生命周期的相关问题。
- en: The GDB session
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GDB 会话
- en: Regardless of the programmer’s accuracy or the complexity of the project we
    are working on, most of the development time will be spent trying to understand
    what our software does, or most likely, what has gone wrong and why the software
    is not behaving as we would expect when the code was written for the first time.
    The debugger is the most powerful tool in our toolchain, allowing us to communicate
    directly with the CPU, place breakpoints, control the execution flow instruction
    by instruction, and check the values of CPU registers, local variables, and memory
    areas. Good knowledge of the debugger means less time spent trying to figure out
    what is going on, and a more effective hunt for bugs and defects.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 无论程序员的准确性如何或我们正在工作的项目的复杂性如何，大部分的开发时间都将花费在试图理解我们的软件做什么，或者更有可能的是，什么出了问题以及为什么软件在代码首次编写时没有按照预期行为。调试器是我们工具链中最强大的工具，它允许我们直接与
    CPU 通信，设置断点，逐条控制执行流程，并检查 CPU 寄存器、局部变量和内存区域的值。对调试器的良好了解意味着花费在试图弄清楚发生了什么的时间更少，并且更有效地寻找错误和缺陷。
- en: The `arm-none-eabi` toolchain includes a GDB capable of interpreting the memory
    and the register layout of the remote target and can be accessed with the same
    interfaces as the host GDB, provided that its backend can communicate with the
    embedded platform, using OpenOCD or a similar host tool providing communication
    with the target through the GDB server protocol. As previously described, OpenOCD
    can be configured to provide a GDB server interface, which in the proposed configuration
    is on port `3333`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`arm-none-eabi` 工具链包括一个能够解释远程目标内存和寄存器布局的 GDB，并且可以通过与主机 GDB 相同的接口访问，前提是其后端能够与嵌入式平台通信，使用
    OpenOCD 或类似的宿主工具通过 GDB 服务器协议与目标通信。如前所述，OpenOCD 可以配置为提供 GDB 服务器接口，在所提出的配置中，该接口位于端口
    `3333`。'
- en: 'After starting `arm-none-eabi-gdb`, we may connect to the running tool using
    the GDB `target` command. Connecting to the GDB server while OpenOCD is running
    can be done using the `target` command:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动 `arm-none-eabi-gdb` 之后，我们可以使用 GDB 的 `target` 命令连接到正在运行的工具。在 OpenOCD 运行时连接到
    GDB 服务器可以使用 `target` 命令：
- en: '[PRE30]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'All GDB commands can be abbreviated, so the command often becomes the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 GDB 命令都可以缩写，因此命令通常变为以下形式：
- en: '[PRE31]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Once connected, the target would typically stop the execution, allowing GDB
    to retrieve the information about the instruction that is currently being executed,
    the stack trace, and the values of the CPU registers.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 连接后，目标设备通常会停止执行，允许 GDB 获取当前正在执行的指令、堆栈跟踪和 CPU 寄存器值的信息。
- en: From this moment on, the debugger interface can be used normally to step through
    the code, place breakpoints and watchpoints, and inspect and alter CPU registers
    and writable memory areas at runtime.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，可以使用调试器界面正常地逐步执行代码，设置断点和观察点，并在运行时检查和修改 CPU 寄存器和可写内存区域。
- en: GDB can be used entirely from its command-line interface, using shortcuts and
    commands to start and stop the execution, and access memory and registers.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: GDB 可以完全通过其命令行界面使用，使用快捷键和命令来启动和停止执行，以及访问内存和寄存器。
- en: 'The following reference table enumerates a few of the GDB commands available
    in a debug session and provides a quick explanation of their usage:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 以下参考表列举了调试会话中可用的几个 GDB 命令，并提供了它们用法的快速解释：
- en: '![Table 2.5 – A few commonly used GDB commands](img/05a.jpg)![Table 2.5 – A
    few commonly used GDB commands](img/05b.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![表 2.5 – 一些常用的 GDB 命令](img/05a.jpg)![表 2.5 – 一些常用的 GDB 命令](img/05b.jpg)'
- en: Table 2.5 – A few commonly used GDB commands
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.5 – 一些常用的 GDB 命令
- en: GDB is a very powerful and complete debugger, and the commands that have been
    shown in this section are a small portion of its actual potential. We advise you
    to discover the other features offered by GDB by going through its manual in order
    to find the set of commands that best fit your needs.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: GDB 是一个非常强大和完整的调试器，本节中展示的命令只是其实际潜力的一个小部分。我们建议您通过阅读其手册来发现 GDB 提供的其他功能，以找到最适合您需求的命令集。
- en: IDEs often offer a separate graphic mode to deal with debugging sessions, which
    is integrated with the editor and allows you to set breakpoints, watch variables,
    and explore the content of memory areas while the system is running in *debug
    mode*.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: IDE 通常提供单独的图形模式来处理调试会话，该模式与编辑器集成，允许你在系统以 *调试模式* 运行时设置断点、观察变量和探索内存区域的内容。
- en: Validation
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证
- en: Debugging alone, or even simple output analysis is often not enough when verifying
    system behavior and identifying issues and unwanted effects in the code. Different
    approaches may be taken to validate the implementation of single components, as
    well as the behavior of the entire system under different conditions. While, in
    some cases, the results can be directly measurable from the host machine, in more
    specific contexts, it is often difficult to reproduce the exact scenario or to
    acquire the necessary information from the system output.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 仅调试或甚至简单的输出分析在验证系统行为和识别代码中的问题和不良影响时通常是不够的。为了验证单个组件的实现以及在不同条件下的整个系统的行为，可以采取不同的方法。虽然在某些情况下，结果可以直接从主机机器测量，但在更具体的情况下，通常很难重现确切的场景或从系统输出中获取必要的信息。
- en: External tools may come in handy, especially in the analysis of communication
    interfaces and network devices in a more complex, distributed system. In other
    cases, single modules can be tested off-target using simulated or emulated environments
    to run smaller portions of the code base.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 外部工具在分析更复杂、分布式系统中的通信接口和网络设备时可能很有用。在其他情况下，可以使用模拟或仿真环境在目标之外测试单个模块，以运行代码库的小部分。
- en: Different tests, validation strategies, and tools are considered in this section
    to provide solutions for any scenario.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 本节考虑了不同的测试、验证策略和工具，以提供任何场景的解决方案。
- en: Functional tests
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功能测试
- en: Writing test cases before writing the code is generally considered an optimal
    practice in modern programming. Writing tests first not only speeds up the development
    phases but also improves the structure of the workflow. By setting clear and measurable
    goals from the beginning, it is harder to introduce conceptual defects in the
    design of the single components, and it also forces a clearer separation among
    the modules. More specifically, an embedded developer has less possibility to
    verify the correct behavior of the system through direct interaction; thus **test-driven
    development** (**TDD**) is the preferred approach for the verification of single
    components as well as the functional behavior of the entire system, as long as
    the expected results can be directly measurable from the host system.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码之前编写测试用例通常被认为是现代编程中的最佳实践。首先编写测试不仅加快了开发阶段，还改善了工作流程的结构。通过从一开始就设定明确和可衡量的目标，更难在单个组件的设计中引入概念性缺陷，并且它还强制模块之间有更清晰的分离。更具体地说，嵌入式开发者通过直接交互验证系统正确行为的可能性较小；因此，只要预期的结果可以从主机系统直接测量，**测试驱动开发**（**TDD**）就是验证单个组件以及整个系统的功能行为的首选方法。
- en: However, it must be considered that testing often introduces dependencies on
    specific hardware, and sometimes the output of an embedded system can only be
    validated through specific hardware tools or in a very unique and peculiar usage
    scenario. In all these cases, the usual TDD paradigm is less applicable, and the
    project can instead benefit from a modular design to give the possibility to test
    as many components as possible in a synthetic environment, such as emulators or
    unit test platforms.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，必须考虑的是，测试往往引入了对特定硬件的依赖，有时嵌入式系统的输出只能通过特定的硬件工具或非常独特和特殊的用法场景来验证。在这些所有情况下，传统的TDD范式不太适用，项目可以通过模块化设计受益，从而在合成环境中（如仿真器或单元测试平台）测试尽可能多的组件。
- en: Writing tests often involves programming the host so that it can retrieve information
    about the running target while the embedded software is executing or alongside
    an ongoing debugging session while the target executes in between breakpoints.
    The target can be configured to provide immediate output through a communication
    interface, such as a UART-based serial port, which can, in turn, be parsed by
    the host. It is usually more convenient to write test tools on the host using
    a higher-level interpreted programming language to better organize the test cases
    and easily integrate the parsing of test results using regular expressions. Python,
    Perl, Ruby, and other languages with similar characteristics, are often a good
    fit for this purpose, also thanks to the availability of libraries and components
    designed for collecting and analyzing test results and interacting with continuous
    integration engines. A good organization of the test and verification infrastructure
    contributes more than everything else to the stability of the project because
    regressions can be detected at the right time only if all the existing tests are
    repeated at every modification. Constantly running all the test cases while the
    development is ongoing not only improves the efficiency of detecting undesired
    effects as early as possible but helps keep the development goals visible at all
    times by directly measuring the number of failures and makes the refactoring of
    components more affordable at any stage in the project lifetime.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 编写测试通常涉及编程主机，以便在嵌入式软件执行或在与断点之间的执行过程中，可以检索有关运行目标的信息。目标可以配置为通过通信接口（如基于UART的串行端口）提供即时输出，该接口可以由主机解析。通常，在主机上使用高级解释型编程语言编写测试工具更为方便，这样可以更好地组织测试用例，并轻松地使用正则表达式集成测试结果的解析。Python、Perl、Ruby和其他具有类似特性的语言，通常非常适合此目的，也得益于为收集和分析测试结果以及与持续集成引擎交互而设计的库和组件。良好的测试和验证基础设施组织比其他任何因素都更有利于项目的稳定性，因为只有当所有现有测试在每次修改时都重复执行，才能在正确的时间检测到回归。在开发过程中持续运行所有测试用例不仅提高了尽早检测到不期望的影响的效率，而且通过直接测量失败次数，有助于始终使开发目标可见，并使项目生命周期的任何阶段对组件的重构更加可行。
- en: Efficiency is the key because embedded programming is an iterative process with
    several steps being repeated over and over, and the approach required from the
    developers is much more predictive than reactive.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 效率是关键，因为嵌入式编程是一个迭代的过程，其中多个步骤需要反复执行，并且对开发者的要求是预测性的，而不是反应性的。
- en: Hardware tools
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 硬件工具
- en: If there is a tool that is absolutely indispensable in assisting embedded software
    developers, it is the logic analyzer. By scoping the input and output signals
    involving the microcontroller, it is possible to detect the electrical behavior
    of the signals, their timing, and even the digital encoding of the single bits
    in the interface protocols. Most logic analyzers can identify and decode sequences
    of symbols by sensing the voltage of the wires, which is often the most effective
    way to verify that protocols are correctly implemented and compliant with the
    contracts to communicate with peripherals and network endpoints. While historically
    available only as standalone dedicated computers, a logic analyzer is often available
    in other forms, such as electronic instruments that can be connected to the host
    machine using USB or Ethernet interfaces, and use PC-based software to capture
    and decode the signals. The result of this process is a complete discrete analysis
    of the signals involved, which are sampled at a constant rate and then visualized
    on a screen.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一个工具对于辅助嵌入式软件开发人员来说是绝对不可或缺的，那就是逻辑分析仪。通过测量涉及微控制器的输入和输出信号，可以检测信号的电气行为、它们的时序，甚至接口协议中单个比特的数字编码。大多数逻辑分析仪可以通过感应线缆的电压来识别和解码符号序列，这通常是验证协议是否正确实现以及是否符合与外围设备和网络端点通信的合同的最有效方式。虽然逻辑分析仪在历史上仅作为独立的专用计算机提供，但它们通常以其他形式提供，例如可以通过USB或以太网接口连接到主机的电子仪器，并使用基于PC的软件来捕获和解码信号。这个过程的结果是对涉及信号的完整离散分析，这些信号以恒定的速率采样，然后在屏幕上可视化。
- en: While a similar task can be performed by oscilloscopes, they are often more
    complex to configure than logic analyzers when dealing with discrete signals.
    Nevertheless, an oscilloscope is the best tool for the analysis of analog signals,
    such as analog audio and communication among radio transceivers. Depending on
    the task, it might be better to use one or the other, but in general, the biggest
    advantage of a logic analyzer is that it provides better insight into discrete
    signals. Mixed-signal logic analyzers are often a good compromise between the
    flexibility of an oscilloscope, with the simplicity and insights of discrete signal-logic
    analysis.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然示波器可以执行类似任务，但在处理离散信号时，它们通常比逻辑分析仪配置得更复杂。尽管如此，示波器是分析模拟信号（如模拟音频和无线电收发器之间的通信）的最佳工具。根据任务，可能最好使用其中一个，但总的来说，逻辑分析仪最大的优势是它提供了对离散信号的更好洞察。混合信号逻辑分析仪通常是在示波器的灵活性和离散信号逻辑分析的简单性及洞察力之间的一种良好折衷。
- en: Oscilloscopes and logic analyzers are often used to capture the activity of
    signals in a specific time window, which might be challenging to synchronize with
    the running software. Instead of capturing those signals continuously, the beginning
    of the capture can be synchronized with a physical event, such as a digital signal
    changing its value for the first time or an analog signal crossing a predefined
    threshold. This is done by configuring the instrument to initiate the capture
    using a trigger, which guarantees that the information captured only contains
    a time slice that is interesting for the ongoing diagnostic.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 示波器和逻辑分析仪通常用于捕获特定时间窗口内信号的活动，这可能难以与运行中的软件同步。而不是连续捕获这些信号，捕获的开始可以与一个物理事件同步，例如数字信号首次改变其值或模拟信号超过预定义的阈值。这是通过配置仪器使用触发器来启动捕获来实现的，这保证了所捕获的信息只包含对当前诊断有意义的时序片段。
- en: Testing off-target
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试非目标
- en: Another efficient way to speed up the development is by limiting the interaction,
    as much as possible, with the actual target. This is, of course, not always possible,
    especially when developing device drivers that need to be tested on actual hardware,
    but tools and methodologies to partially test the software directly on the development
    machine exist.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种提高开发效率的有效方法是尽可能减少与实际目标的交互。当然，这并不总是可能的，尤其是在开发需要在实际硬件上测试的设备驱动程序时，但存在工具和方法可以在开发机上直接部分测试软件。
- en: Portions of code that are not CPU-specific can be compiled for the host machine
    architecture and run directly, as long as their surroundings are properly abstracted
    to simulate the real environment. The software to test can be as small as a single
    function, and in this case, a unit test can be written specifically for the development
    architecture.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 非特定于CPU的代码部分可以编译为主机机器架构，并直接运行，只要它们的周围环境被适当抽象以模拟真实环境。可测试的软件可以小到单个函数，在这种情况下，可以专门为开发架构编写单元测试。
- en: 'Unit tests are, in general, small applications that verify the behavior of
    a single component by feeding them with well-known input and verifying its output.
    Several tools are available on a Linux system to assist in writing unit tests.
    The `check` library provides an interface for defining unit tests by writing a
    few preprocessor macros. The result is small self-contained applications that
    can be run every time the code is changed, directly on the host machine. Those
    components of the system that the function under test depends on are abstracted
    using mocks. For example, the following code detects and discards a specific escape
    sequence, *Esc* + *C*, from the input from a serial line interface, reading from
    the serial line until the `\0` character is returned:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试通常是小型的应用程序，通过提供已知输入并验证其输出来验证单个组件的行为。Linux系统上有几个工具可以帮助编写单元测试。`check`库提供了一个接口，通过编写几个预处理器宏来定义单元测试。结果是小型自包含的应用程序，每次代码更改时都可以在主机机器上运行。测试函数所依赖的系统组件使用模拟进行抽象。例如，以下代码检测并丢弃来自串行线接口的特定转义序列，*Esc*
    + *C*，从串行线读取，直到返回`\0`字符：
- en: '[PRE32]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'A set of unit tests to verify this function using a check test suite may look
    like the following:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 一组单元测试，使用检查测试套件来验证此函数，可能看起来如下：
- en: '[PRE33]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Each test case can be contained in its `START_TEST()/END_TEST` block and provide
    a different initial configuration:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 每个测试用例都可以包含在其`START_TEST()/END_TEST`块中，并提供不同的初始配置：
- en: '[PRE34]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This first `test_plain` test ensures that a string with no escape characters
    is parsed correctly. The second test ensures that the escape sequence is skipped,
    and the third one verifies that a similar escape string is left untouched by the
    output buffer.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一个`test_plain`测试确保没有转义字符的字符串被正确解析。第二个测试确保跳过了转义序列，第三个测试验证类似的转义字符串没有被输出缓冲区修改。
- en: 'Serial communication is simulated using a mock function that replaces the original
    `serial_read` functionality provided by the driver when running the code on the
    target. This is a simple mock that feeds the parser with a constant buffer that
    can be reinitialized using the `set_serial_buffer` helper function. The mock code
    looks like this:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 串行通信是通过一个模拟函数来模拟的，该函数在代码在目标上运行时替换了驱动程序提供的原始`serial_read`功能。这是一个简单的模拟，它向解析器提供了一个可以使用`set_serial_buffer`辅助函数重新初始化的常量缓冲区。模拟代码如下：
- en: '[PRE35]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Unit tests are very useful to improve the quality of the code, but of course,
    achieving high code coverage consumes a large amount of time and resources in
    the economy of the project. Functional tests can also be run directly in the development
    environment by grouping functions into self-contained modules and implementing
    simulators that are slightly more complex than mocks for specific test cases.
    In the example of the serial parser, it would be possible to test the entire application
    logic on top of a different serial driver on the host machine, which is also able
    to simulate an entire conversation over the serial line, and interact with other
    components in the system, such as virtual terminals and other applications generating
    input sequences.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试对于提高代码质量非常有用，但当然，在项目经济中实现高代码覆盖率需要消耗大量的时间和资源。功能测试也可以通过将函数分组到自包含的模块中，并实现比模拟更复杂的模拟器来直接在开发环境中运行，这些模拟器针对特定测试用例。在串行解析器的例子中，可以在主机机器上的不同串行驱动程序上测试整个应用程序逻辑，该驱动程序也能够模拟整个串行线的对话，并与系统中的其他组件交互，例如虚拟终端和其他生成输入序列的应用程序。
- en: While covering a larger portion of the code within a single test case, the complexity
    of the simulated environment increases, and so does the amount of work required
    to reproduce the surroundings of the embedded system on the host machine. Nevertheless,
    it is good practice, especially when they could be used as verification tools
    throughout the whole development cycle and even integrated into the automated
    test process.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当在单个测试用例中覆盖更大部分的代码时，模拟环境的复杂性会增加，并且需要复制嵌入式系统在主机上的环境的工作量也会随之增加。尽管如此，将它们作为整个开发周期中的验证工具，甚至集成到自动化测试过程中，是一种良好的实践。
- en: 'Sometimes, implementing a simulator allows for a much more complete set of
    tests, or it might be the only viable option. Think, for example, about those
    embedded systems using a GPS receiver for positioning: testing the application
    logic with negative latitude values would be impossible while sitting in the northern
    hemisphere, so writing a simulator that imitates the data coming from such a receiver
    is the quickest way to verify that our final device will not stop working across
    the equator.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，实现一个模拟器可以提供更完整的测试集，或者可能是唯一可行的选择。例如，考虑那些使用GPS接收器进行定位的嵌入式系统：在北半球测试带有负纬度的应用程序逻辑是不可能的，因此编写一个模拟器来模仿来自这种接收器的数据是验证我们的最终设备不会在赤道停止工作的最快方式。
- en: Emulators
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟器
- en: Another valid approach to running the code on the development machine, which
    is much less invasive for our code base and loosens the specific portability requirements,
    is emulating the whole platform on the host PC. An emulator is a computer program
    that can replicate the functionality of an entire system, including its core CPU,
    memory, and a set of peripherals. Some of the modern virtualization hypervisors
    for PCs are derived from `lm3s6965evb`, an old Cortex-M-based microcontroller,
    no longer recommended for new designs by the manufacturer, that is fully supported
    by QEMU.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发机上运行代码的另一种有效方法，这对我们的代码库影响较小，并放宽了特定的可移植性要求，是在主机PC上模拟整个平台。模拟器是一种计算机程序，可以复制整个系统的功能，包括其核心CPU、内存和一组外围设备。一些现代的PC虚拟化管理程序源自`lm3s6965evb`，这是一个基于Cortex-M的旧微控制器，制造商不再推荐用于新设计，但它完全由QEMU支持。
- en: 'Once a binary image has been created using `lm3s6965evb` as a target, and properly
    converted to raw binary format using `objcopy`, a fully emulated system can be
    run by invoking QEMU as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦使用`lm3s6965evb`作为目标创建了一个二进制镜像，并且使用`objcopy`正确转换为原始二进制格式后，可以通过以下方式调用QEMU来运行一个完全模拟的系统：
- en: '[PRE36]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `--kernel` option instructs the emulator to run the image at startup, and
    while it might sound misnamed, it is called `kernel` because QEMU is widely used
    to emulate headless Linux systems on other synthetic targets. Similarly, a convenient
    debugging session can be started by using QEMU’s built-in GDB server through the
    `-gdb` option, which can also halt the system until our GDB client is connected
    to it:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`--kernel`选项指示模拟器在启动时运行镜像，虽然这个名字可能听起来不合适，但它被称为`kernel`是因为QEMU广泛用于在其他合成目标上模拟无头Linux系统。同样，可以通过使用QEMU内置的GDB服务器通过`-gdb`选项启动一个方便的调试会话，该选项还可以使系统停止，直到我们的GDB客户端连接到它：'
- en: '[PRE37]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the same way, as with the real target, we can connect `arm-none-eabi-gdb`
    to TCP port `3333` on `localhost` and start debugging the software image exactly
    as it was running on the actual platform.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，与实际目标一样，我们可以将`arm-none-eabi-gdb`连接到`localhost`上的TCP端口`3333`，并开始调试软件镜像，就像它在实际平台上运行时一样。
- en: The limit of the emulation approach is that QEMU can only be used to debug generic
    features that do not involve interaction with actual modern hardware. Nevertheless,
    running QEMU with a Cortex-M3 target can be a quick way to learn about generic
    Cortex-M features, such as memory management, system interrupt handling, and processor
    modes, because many features of the Cortex-M CPU are accurately emulated.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟方法的局限性在于，QEMU只能用于调试不涉及与实际现代硬件交互的通用特性。尽管如此，使用Cortex-M3目标运行QEMU可以快速了解通用Cortex-M特性，如内存管理、系统中断处理和处理器模式，因为Cortex-M
    CPU的许多特性都得到了精确的模拟。
- en: More accurate emulation of microcontroller systems can be achieved using **Renode**
    ([https://renode.io](https://renode.io)). Renode is an open source, configurable
    emulator for many different microcontrollers and CPU-based embedded systems. The
    emulation includes peripherals, sensors, LEDs, and even wireless and wired interfaces
    to interconnect multiple emulated systems and the host network.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **Renode** ([https://renode.io](https://renode.io)) 可以实现更精确的微控制器系统模拟。Renode
    是一个开源、可配置的模拟器，适用于许多不同的微控制器和基于 CPU 的嵌入式系统。仿真包括外围设备、传感器、LED，甚至无线和有线接口，用于连接多个模拟系统和主机网络。
- en: 'Renode is a desktop application with a command-line console. A single configuration
    file must be provided from the command-line invocation, with several platforms
    and development board configurations provided under the `/scripts` directory.
    This means that once installed, the emulator for the *STM32F4 discovery board*
    can be started by invoking the following command:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: Renode 是一个带有命令行控制台桌面应用程序。必须从命令行调用提供一个配置文件，在 `/scripts` 目录下提供了多个平台和开发板配置。这意味着一旦安装，可以通过以下命令启动
    *STM32F4 开发板* 的模拟器：
- en: '[PRE38]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This command will load the demo firmware on an emulated STM32F4 target flash
    memory and redirect the I/O of one of the emulated UART serial ports to a console
    in a new window. To start the demo, type `start` in the Renode console.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将在模拟的 STM32F4 目标闪存中加载演示固件，并将模拟的 UART 串行端口之一的重定向到新窗口中的控制台。要启动演示，请在 Renode
    控制台中输入 `start`。
- en: 'The example script comes with a demo firmware image running *Contiki OS*. The
    firmware image is loaded by the script via the Renode command:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 示例脚本包含一个运行 *Contiki 操作系统* 的演示固件映像。固件映像通过 Renode 命令由脚本加载：
- en: '[PRE39]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Where `$bin` is a variable pointing to the path (or the URL) of the firmware
    ELF file to load on the emulated flash memory. This option, as well as the UART
    analyzer port and other specific commands to execute when the emulator is started,
    can be easily changed by customizing the script file.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `$bin` 是一个指向要加载到模拟闪存中的固件 ELF 文件路径（或 URL）的变量。此选项，以及 UART 分析器端口和其他在启动模拟器时执行的特定命令，可以通过自定义脚本文件轻松更改。
- en: 'Renode integrates a GDB server that can be spawned from the Renode console
    or the startup script before starting the emulation, for example, using the following:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Renode 集成了一个 GDB 服务器，可以在启动仿真之前从 Renode 控制台或启动脚本中启动，例如，使用以下命令：
- en: '[PRE40]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In this case, `3333` is the TCP port the GDB server will be listening to, as
    in the other cases with QEMU and a debugger on the physical target.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`3333` 是 GDB 服务器将监听的 TCP 端口，正如其他情况下使用 QEMU 和物理目标上的调试器一样。
- en: Unlike QEMU, which is a very generic emulator, Renode is a project created with
    the purpose of assisting embedded developers throughout the entire life cycle.
    The possibility to emulate different complete platforms, creating mocks for sensors
    on several architectures, including RISC-V, makes it a unique tool to automate
    testing on multiple targets quickly or test on systems even when the actual hardware
    is not available.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 与非常通用的模拟器 QEMU 不同，Renode 是一个旨在协助嵌入式开发人员在整个生命周期中工作的项目。能够模拟不同的完整平台，为包括 RISC-V
    在内的多个架构上的传感器创建模拟，使其成为快速自动化测试多个目标或测试即使实际硬件不可用时的系统独特工具。
- en: Last but not least, thanks to its own scripting language, Renode is perfectly
    integrated with test automation systems, where the execution of the emulated target
    can be started, stopped, and resumed, and the configuration of all devices and
    peripherals altered while the test is running.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，得益于其自己的脚本语言，Renode 与测试自动化系统完美集成，其中可以启动、停止和恢复模拟目标，并在测试运行时更改所有设备和外围设备的配置。
- en: The approaches proposed for the definition of test strategies take into account
    different scenarios. The idea has been to introduce a range of possible solutions
    for software validation, from lab equipment to tests off-target in simulated and
    emulated environments, for the developer to choose from in a specific scenario.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 提出的测试策略定义方法考虑了不同的场景。想法是引入一系列可能的软件验证解决方案，从实验室设备到在模拟和仿真环境中进行的离目标测试，供开发者在特定场景中选择。
- en: Summary
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduced the tools for working on the development of embedded
    systems. A hands-on approach has been proposed to get you up and running with
    the toolchain and the utilities required to communicate with the hardware platform.
    Using appropriate tools can make embedded development easier and shorten workflow
    iterations.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了用于嵌入式系统开发的工具。提出了一种实用方法，帮助您快速上手工具链以及与硬件平台通信所需的实用工具。使用适当的工具可以使嵌入式开发更加容易并缩短工作流程迭代。
- en: In the next chapter, we provide indications for workflow organization when working
    with larger teams. Based on real-life experiences, we propose solutions for splitting
    and organizing tasks, executing tests, iterating throughout the phases of design,
    and the definition and implementation of an embedded project.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们提供了与大型团队协作时工作流程组织的指示。基于实际经验，我们提出了分割和组织任务、执行测试、在设计阶段迭代以及嵌入式项目定义和实施的解决方案。
- en: Part 2 – Core System Architecture
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分 – 核心系统架构
- en: This part goes a little deeper into the rabbit hole, by introducing you to pragmatic
    software design at first and then guiding you step by step through the code needed
    for proper boot-up mechanisms and memory management, with a strong focus on a
    memory-safe approach.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分会深入探讨一些内容，首先向您介绍实用软件设计，然后逐步引导您了解正确启动机制和内存管理所需的代码，重点在于内存安全方法。
- en: 'This part has the following chapters:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 3*](B18730_03.xhtml#_idTextAnchor079), *Architectural Patterns*'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第3章*](B18730_03.xhtml#_idTextAnchor079), *建筑模式*'
- en: '[*Chapter 4*](B18730_04.xhtml#_idTextAnchor115), *The Boot-Up Procedure*'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第4章*](B18730_04.xhtml#_idTextAnchor115), *启动程序*'
- en: '[*Chapter 5*](B18730_05.xhtml#_idTextAnchor149), *Memory Management*'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第5章*](B18730_05.xhtml#_idTextAnchor149), *内存管理*'
