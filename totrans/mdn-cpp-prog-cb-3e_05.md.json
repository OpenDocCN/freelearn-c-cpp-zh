["```cpp\ndouble d[3];           // a statically allocated array of 3 doubles\nint* arr = new int[5]; // a dynamically allocated array of 5 ints \n```", "```cpp\n    std::vector<int> v1 { 1, 2, 3, 4, 5 }; \n    ```", "```cpp\n    int arr[] = { 1, 2, 3, 4, 5 };\n    std::vector<int> v21(arr, arr + 5); // v21 = { 1, 2, 3, 4, 5 }\n    std::vector<int> v22(arr+1, arr+4); // v22 = { 2, 3, 4 } \n    ```", "```cpp\n    std::list<int> l{ 1, 2, 3, 4, 5 };\n    std::vector<int> v3(l.begin(), l.end()); //{ 1, 2, 3, 4, 5 } \n    ```", "```cpp\n    std::vector<int> v4(5, 1); // {1, 1, 1, 1, 1} \n    ```", "```cpp\n    std::vector<int> v1{ 1, 2, 3, 4, 5 };\n    v1.push_back(6); // v1 = { 1, 2, 3, 4, 5, 6 } \n    ```", "```cpp\n    v1.pop_back();   // v1 = { 1, 2, 3, 4, 5 } \n    ```", "```cpp\n    int arr[] = { 1, 2, 3, 4, 5 };\n    std::vector<int> v21;\n    v21.insert(v21.begin(), arr, arr + 5); // v21 = { 1, 2, 3, 4, 5 }\n    std::vector<int> v22;\n    v22.insert(v22.begin(), arr, arr + 3); // v22 = { 1, 2, 3 } \n    ```", "```cpp\n    struct foo\n    {\n      int a;\n      double b;\n      std::string c;\n      foo(int a, double b, std::string const & c) :\n        a(a), b(b), c(c) {}\n    };\n    std::vector<foo> v3;\n    v3.emplace_back(1, 1.0, \"one\"s);\n    // v3 = { foo{1, 1.0, \"one\"} } \n    ```", "```cpp\n    v3.emplace(v3.begin(), 2, 2.0, \"two\"s);\n    // v3 = { foo{2, 2.0, \"two\"}, foo{1, 1.0, \"one\"} } \n    ```", "```cpp\n    std::vector<int> v1{ 1, 2, 3, 4, 5 };\n    std::vector<int> v2{ 10, 20, 30 };\n    v2 = v1; // v2 = { 1, 2, 3, 4, 5 } \n    ```", "```cpp\n    int arr[] = { 1, 2, 3, 4, 5 };\n    std::vector<int> v31;\n    v31.assign(arr, arr + 5);     // v31 = { 1, 2, 3, 4, 5 }\n    std::vector<int> v32;\n    v32.assign(arr + 1, arr + 4); // v32 = { 2, 3, 4 } \n    ```", "```cpp\n    std::vector<int> v4{ 1, 2, 3, 4, 5 };\n    std::vector<int> v5{ 10, 20, 30 };\n    v4.swap(v5); // v4 = { 10, 20, 30 }, v5 = { 1, 2, 3, 4, 5 } \n    ```", "```cpp\n    std::vector<int> v6{ 1, 2, 3, 4, 5 };\n    v6.clear(); // v6 = { } \n    ```", "```cpp\n    std::vector<int> v7{ 1, 2, 3, 4, 5 };\n    v7.erase(v7.begin() + 2, v7.begin() + 4); // v7 = { 1, 2, 5 } \n    ```", "```cpp\n    std::vector<int> v8{ 1, 2, 3, 4, 5 };\n    auto iterToNext = v8.erase(\n       std::remove_if(v8.begin(), v8.end(), \n          [](const int n) {return n % 2 == 0; }),\n       v8.end());                            // v8 = { 1, 3, 5 } \n    ```", "```cpp\n    std::vector<int> v9{ 1, 2, 3, 4, 5 };\n    auto erasedCount = std::erase_if(v9, [](const int n) {\n       return n % 2 == 0; });                // v9 = { 1, 3, 5 } \n    ```", "```cpp\n    void process(int const * const arr, size_t const size)\n    { /* do something */ }\n    std::vector<int> v{ 1, 2, 3, 4, 5 };\n    process(v.data(), v.size()); \n    ```", "```cpp\n    process(&v[0], v.size()); \n    ```", "```cpp\n    process(&v.front(), v.size()); \n    ```", "```cpp\n    process(&*v.begin(), v.size()); \n    ```", "```cpp\nstd::list<int>   l{ 1, 2, 3, 4, 5 };\nstd::vector<int> v;\nv.assign_range(l); // v = {1, 2, 3, 4, 5} \n```", "```cpp\nstd::list<int>   l{ 3, 4, 5 };\nstd::vector<int> v{ 1, 2 };\nv.append_range(l);  // v = {1, 2, 3, 4, 5} \n```", "```cpp\nstd::list<int>   l{ 2, 3, 4 };\nstd::vector<int> v{ 1, 5 };\nv.insert_range(v.begin() + 1, l); // v = {1, 2, 3, 4, 5} \n```", "```cpp\nstd::vector<int> v{ 1, 2, 3, 4, 5 };\nstd::vector<int>().swap(v); // v.size = 0, v.capacity = 0 \n```", "```cpp\n    std::bitset<8> b1;            // [0,0,0,0,0,0,0,0] \n    ```", "```cpp\n    std::bitset<8> b2{ 10 };      // [0,0,0,0,1,0,1,0] \n    ```", "```cpp\n    std::bitset<8> b3{ \"1010\"s }; // [0,0,0,0,1,0,1,0] \n    ```", "```cpp\n    std::bitset<8> b4\n      { \"ooooxoxo\"s, 0, std::string::npos, 'o', 'x' };\n      // [0,0,0,0,1,0,1,0] \n    ```", "```cpp\n    std::bitset<8> bs{ 10 };\n    std::cout << \"has \" << bs.count() << \" 1s\" << '\\n'; \n    ```", "```cpp\n    if (bs.any()) std::cout << \"has some 1s\" << '\\n'; \n    ```", "```cpp\n    if (bs.all()) std::cout << \"has only 1s\" << '\\n'; \n    ```", "```cpp\n    if (bs.none()) std::cout << \"has no 1s\" << '\\n'; \n    ```", "```cpp\n    if (!bs.test(0)) std::cout << \"even\" << '\\n'; \n    ```", "```cpp\n    if(!bs[0]) std::cout << \"even\" << '\\n'; \n    ```", "```cpp\n    std::bitset<8> b1{ 42 }; // [0,0,1,0,1,0,1,0]\n    std::bitset<8> b2{ 11 }; // [0,0,0,0,1,0,1,1]\n    auto b3 = b1 | b2;       // [0,0,1,0,1,0,1,1]\n    auto b4 = b1 & b2;       // [0,0,0,0,1,0,1,0]\n    auto b5 = b1 ^ b2;       // [0,0,1,0,0,0,0,1]\n    auto b6 = ~b1;           // [1,1,0,1,0,1,0,1] \n    ```", "```cpp\n    auto b7 = b1 << 2;       // [1,0,1,0,1,0,0,0]\n    auto b8 = b1 >> 2;       // [0,0,0,0,1,0,1,0] \n    ```", "```cpp\n    b1.flip();               // [1,1,0,1,0,1,0,1]\n    b1.flip(0);              // [1,1,0,1,0,1,0,0] \n    ```", "```cpp\n    b1.set(0, true);         // [1,1,0,1,0,1,0,1]\n    b1.set(0, false);        // [1,1,0,1,0,1,0,0] \n    ```", "```cpp\n    b1.reset(2);             // [1,1,0,1,0,0,0,0] \n    ```", "```cpp\n    std::bitset<8> bs{ 42 };\n    auto n1 = bs.to_ulong();  // n1 = 42UL\n    auto n2 = bs.to_ullong(); // n2 = 42ULL \n    ```", "```cpp\n    auto s1 = bs.to_string();         // s1 = \"00101010\"\n    auto s2 = bs.to_string('o', 'x'); // s2 = \"ooxoxoxo\" \n    ```", "```cpp\n#define BORDER_NONE   0x00\n#define BORDER_LEFT   0x01\n#define BORDER_TOP    0x02\n#define BORDER_RIGHT  0x04\n#define BORDER_BOTTOM 0x08\nvoid apply_style(unsigned int const style)\n{\n  if (style & BORDER_BOTTOM) { /* do something */ }\n}\n// initialize with no flags\nunsigned int style = BORDER_NONE;\n// set a flag\nstyle = BORDER_BOTTOM;\n// add more flags\nstyle |= BORDER_LEFT | BORDER_RIGHT | BORDER_TOP;\n// remove some flags\nstyle &= ~BORDER_LEFT;\nstyle &= ~BORDER_RIGHT;\n// test if a flag is set\nif ((style & BORDER_BOTTOM) == BORDER_BOTTOM) {}\n// pass the flags as argument to a function\napply_style(style); \n```", "```cpp\nstruct border_flags\n{\n  static const int left = 0;\n  static const int top = 1;\n  static const int right = 2;\n  static const int bottom = 3;\n};\n// initialize with no flags\nstd::bitset<4> style;\n// set a flag\nstyle.set(border_flags::bottom);\n// set more flags\nstyle\n  .set(border_flags::left)\n  .set(border_flags::top)\n  .set(border_flags::right);\n// remove some flags\nstyle[border_flags::left] = 0;\nstyle.reset(border_flags::right);\n// test if a flag is set\nif (style.test(border_flags::bottom)) {}\n// pass the flags as argument to a function\napply_style(style.to_ulong()); \n```", "```cpp\ntemplate <size_t N>\nstd::vector<unsigned long> bitset_to_vectorulong(std::bitset<N> bs)\n{\n  auto result = std::vector<unsigned long> {};\n  auto const size = 8 * sizeof(unsigned long);\n  auto const mask = std::bitset<N>{ static_cast<unsigned long>(-1)};\n  auto totalbits = 0;\n  while (totalbits < N)\n  {\n    auto value = (bs & mask).to_ulong();\n    result.push_back(value);\n    bs >>= size;\n    totalbits += size;\n  }\n  return result;\n} \n```", "```cpp\nstd::bitset<128> bs =\n    (std::bitset<128>(0xFEDC) << 96) |\n    (std::bitset<128>(0xBA98) << 64) |\n    (std::bitset<128>(0x7654) << 32) |\n    std::bitset<128>(0x3210);\nstd::cout << bs << '\\n'; \n```", "```cpp\n00000000000000001111111011011100000000000000000010111010100110000000000000000000011101100101010000000000000000000011001000010000 \n```", "```cpp\nauto result = bitset_to_vectorulong(bs);\nfor (auto const v : result)\n  std::cout << std::hex << v << '\\n'; \n```", "```cpp\n3210\n7654\nba98\nfedc \n```", "```cpp\n    std::vector<bool> bv; // [] \n    ```", "```cpp\n    bv.push_back(true);  // [1]\n    bv.push_back(true);  // [1, 1]\n    bv.push_back(false); // [1, 1, 0]\n    bv.push_back(false); // [1, 1, 0, 0]\n    bv.push_back(true);  // [1, 1, 0, 0, 1] \n    ```", "```cpp\n    bv[3] = true;        // [1, 1, 0, 1, 1] \n    ```", "```cpp\n    auto count_of_ones = std::count(bv.cbegin(), bv.cend(), true); \n    ```", "```cpp\n    bv.erase(bv.begin() + 2); // [1, 1, 1, 1] \n    ```", "```cpp\n    std::vector<bool> bv;\n    bv.resize(10);\n    auto& bit = bv[0];      // error \n    ```", "```cpp\n    auto& bit = *bv.begin(); // error \n    ```", "```cpp\nclass bitvector\n{\n  std::vector<bool> bv;\npublic:\n  bitvector(std::vector<bool> const & bv) : bv(bv) {}\n  bool operator[](size_t const i) { return bv[i]; }\n  inline bool any() const {\n    for (auto b : bv) if (b) return true;\n    return false;\n  }\n  inline bool all() const {\n    for (auto b : bv) if (!b) return false;\n    return true;\n  }\n  inline bool none() const { return !any(); }\n  inline size_t count() const {\n    return std::count(bv.cbegin(), bv.cend(), true);\n  }\n  inline size_t size() const { return bv.size(); }\n  inline bitvector & add(bool const value) {\n    bv.push_back(value);\n    return *this;\n  }\n  inline bitvector & remove(size_t const index) {\n    if (index >= bv.size())\n      throw std::out_of_range(\"Index out of range\");\n    bv.erase(bv.begin() + index);\n    return *this;\n  }\n  inline bitvector & set(bool const value = true) {\n    for (size_t i = 0; i < bv.size(); ++i)\n      bv[i] = value;\n    return *this;\n  }\n  inline bitvector& set(size_t const index, bool const value = true) {\n    if (index >= bv.size())\n      throw std::out_of_range(\"Index out of range\");\n    bv[index] = value;\n    return *this;\n  }\n  inline bitvector & reset() {\n    for (size_t i = 0; i < bv.size(); ++i) bv[i] = false;\n    return *this;\n  }\n  inline bitvector & reset(size_t const index) {\n    if (index >= bv.size())\n      throw std::out_of_range(\"Index out of range\");\n    bv[index] = false;\n    return *this;\n  }\n  inline bitvector & flip() {\n    bv.flip();\n    return *this;\n  }\n  std::vector<bool>& data() { return bv; }\n}; \n```", "```cpp\nbitvector bv;\nbv.add(true).add(true).add(false); // [1, 1, 0]\nbv.add(false);                     // [1, 1, 0, 0]\nbv.add(true);                      // [1, 1, 0, 0, 1]\nif (bv.any()) std::cout << \"has some 1s\" << '\\n';\nif (bv.all()) std::cout << \"has only 1s\" << '\\n';\nif (bv.none()) std::cout << \"has no 1s\" << '\\n';\nstd::cout << \"has \" << bv.count() << \" 1s\" << '\\n';\nbv.set(2, true);                   // [1, 1, 1, 0, 1]\nbv.set();                          // [1, 1, 1, 1, 1]\nbv.reset(0);                       // [0, 1, 1, 1, 1]\nbv.reset();                        // [0, 0, 0, 0, 0]\nbv.flip();                         // [1, 1, 1, 1, 1] \n```", "```cpp\n    unsigned char n = 0b00111100;\n    auto vl1 = std::rotl(n, 0); // 0b00111100\n    auto vl2 = std::rotl(n, 1); // 0b01111000\n    auto vl3 = std::rotl(n, 3); // 0b11100001\n    auto vl4 = std::rotl(n, 9); // 0b01111000\n    auto vl5 = std::rotl(n, -2);// 0b00001111\n    auto vr1 = std::rotr(n, 0);  // 0b00111100\n    auto vr2 = std::rotr(n, 1);  // 0b00011110\n    auto vr3 = std::rotr(n, 3);  // 0b10000111\n    auto vr4 = std::rotr(n, 9);  // 0b00011110\n    auto vr5 = std::rotr(n, -2); // 0b11110000 \n    ```", "```cpp\n    std::cout << std::countl_zero(0b00000000u) << '\\n'; // 8\n    std::cout << std::countl_zero(0b11111111u) << '\\n'; // 0\n    std::cout << std::countl_zero(0b00111010u) << '\\n'; // 2\n    std::cout << std::countr_zero(0b00000000u) << '\\n'; // 8\n    std::cout << std::countr_zero(0b11111111u) << '\\n'; // 0\n    std::cout << std::countr_zero(0b00111010u) << '\\n'; // 1 \n    ```", "```cpp\n    std::cout << std::countl_one(0b00000000u) << '\\n'; // 0\n    std::cout << std::countl_one(0b11111111u) << '\\n'; // 8\n    std::cout << std::countl_one(0b11000101u) << '\\n'; // 2\n    std::cout << std::countr_one(0b00000000u) << '\\n'; // 0\n    std::cout << std::countr_one(0b11111111u) << '\\n'; // 8\n    std::cout << std::countr_one(0b11000101u) << '\\n'; // 1 \n    ```", "```cpp\n    std::cout << std::popcount(0b00000000u) << '\\n'; // 0\n    std::cout << std::popcount(0b11111111u) << '\\n'; // 8\n    std::cout << std::popcount(0b10000001u) << '\\n'; // 2 \n    ```", "```cpp\n    std::cout << std::boolalpha << std::has_single_bit(0u) << '\\n'; // false\n    std::cout << std::boolalpha << std::has_single_bit(1u) << '\\n'; // true\n    std::cout << std::boolalpha << std::has_single_bit(2u) << '\\n'; // true\n    std::cout << std::boolalpha << std::has_single_bit(3u) << '\\n'; // false\n    std::cout << std::boolalpha << std::has_single_bit(4u) << '\\n'; // true \n    ```", "```cpp\n    std::cout << std::bit_ceil(0u)  << '\\n'; // 0\n    std::cout << std::bit_ceil(3u)  << '\\n'; // 4\n    std::cout << std::bit_ceil(4u)  << '\\n'; // 4\n    std::cout << std::bit_ceil(31u) << '\\n'; // 32\n    std::cout << std::bit_ceil(42u) << '\\n'; // 64\n    std::cout << std::bit_floor(0u)  << '\\n'; // 0\n    std::cout << std::bit_floor(3u)  << '\\n'; // 2\n    std::cout << std::bit_floor(4u)  << '\\n'; // 4\n    std::cout << std::bit_floor(31u) << '\\n'; // 16\n    std::cout << std::bit_floor(42u) << '\\n'; // 32 \n    ```", "```cpp\n    std::cout << std::bit_width(0u)    << '\\n'; // 0\n    std::cout << std::bit_width(2u)    << '\\n'; // 2\n    std::cout << std::bit_width(15u)   << '\\n'; // 4\n    std::cout << std::bit_width(16u)   << '\\n'; // 5\n    std::cout << std::bit_width(1000u) << '\\n'; // 10 \n    ```", "```cpp\n    const double   pi   = 3.1415927;\n    const uint64_t bits = std::bit_cast<uint64_t>(pi);\n    const double   pi2  = std::bit_cast<double>(bits);\n    std::cout\n       << std::fixed << pi   << '\\n' // 3.1415923\n       << std::hex   << bits << '\\n' // 400921fb5a7ed197\n       << std::fixed << pi2  << '\\n';  // 3.1415923 \n    ```", "```cpp\n    std::vector<int> v{ 13, 1, 5, 3, 2, 8, 1 };\n    auto it = std::find(v.cbegin(), v.cend(), 3);\n    if (it != v.cend()) std::cout << *it << '\\n'; // prints 3 \n    ```", "```cpp\n    std::vector<int> v{ 13, 1, 5, 3, 2, 8, 1 };\n    auto it = std::find_if(v.cbegin(), v.cend(),\n                           [](int const n) {return n > 10; });\n    if (it != v.cend()) std::cout << *it << '\\n'; // prints 13 \n    ```", "```cpp\n    std::vector<int> v{ 13, 1, 5, 3, 2, 8, 1 };\n    auto it = std::find_if_not(v.cbegin(), v.cend(),\n                        [](int const n) {return n % 2 == 1; });\n    if (it != v.cend()) std::cout << *it << '\\n'; // prints 2 \n    ```", "```cpp\n    std::vector<int> v{ 13, 1, 5, 3, 2, 8, 1 };\n    std::vector<int> p{ 5, 7, 11 };\n    auto it = std::find_first_of(v.cbegin(), v.cend(),\n                                 p.cbegin(), p.cend());\n    if (it != v.cend())\n      std::cout << \"found \" << *it\n                << \" at index \" << std::distance(v.cbegin(), it)\n                << '\\n'; \n    // found 5 at index 2 \n    ```", "```cpp\n    std::vector<int> v1{ 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1 };\n    std::vector<int> v2{ 1, 0, 1 };\n    auto it = std::find_end(v1.cbegin(), v1.cend(),\n                            v2.cbegin(), v2.cend());\n    if (it != v1.cend())\n      std::cout << \"found at index \"\n                << std::distance(v1.cbegin(), it) << '\\n';\n    // found at index 8 \n    ```", "```cpp\n    std::vector<int> v{ 1, 5, -2, 9, 6 };\n    auto minit = std::min_element(v.begin(), v.end());\n    std::cout << \"min=\" << *minit << '\\n';           // min=-2\n    auto maxit = std::max_element(v.begin(), v.end());\n    std::cout << \"max=\" << *maxit << '\\n';           // max=9\n    auto minmaxit = std::minmax_element(v.begin(), v.end());\n    std::cout << \"min=\" << *minmaxit.first << '\\n';  // min=-2\n    std::cout << \"max=\" << *minmaxit.second << '\\n'; // max=9 \n    ```", "```cpp\n    auto text = \"The quick brown fox jumps over the lazy dog\"s;\n    auto word = \"over\"s;\n    auto it = std::search(text.cbegin(), text.cend(),\n                          word.cbegin(), word.cend());\n    if (it != text.cend())\n      std::cout << \"found \" << word\n                << \" at index \"\n                << std::distance(text.cbegin(), it) << '\\n'; \n    ```", "```cpp\n    auto text = \"The quick brown fox jumps over the lazy dog\"s;\n    auto word = \"over\"s;\n    auto it = std::search(\n      text.cbegin(), text.cend(),\n      std::make_boyer_moore_searcher(word.cbegin(), word.cend()));\n    if (it != text.cend())\n      std::cout << \"found \" << word\n                << \" at index \"\n                << std::distance(text.cbegin(), it) << '\\n'; \n    ```", "```cpp\n    std::vector<int> v{ 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1 };\n    auto it = std::search_n(v.cbegin(), v.cend(), 2, 0);\n    if (it != v.cend())\n      std::cout << \"found at index \"\n                << std::distance(v.cbegin(), it) << '\\n'; \n    ```", "```cpp\n    std::vector<int> v{ 1, 1, 2, 3, 5, 8, 13 };\n    auto it = std::adjacent_find(v.cbegin(), v.cend());\n    if (it != v.cend())\n      std::cout << \"found at index \"\n                << std::distance(v.cbegin(), it) << '\\n';\n    auto it = std::adjacent_find(\n      v.cbegin(), v.cend(),\n      [](int const a, int const b) {\n        return IsPrime(a) && IsPrime(b); });\n    if (it != v.cend())\n      std::cout << \"found at index \"\n                << std::distance(v.cbegin(), it) << '\\n'; \n    ```", "```cpp\n    std::vector<int> v{ 1, 1, 2, 3, 5, 8, 13 };\n    auto success = std::binary_search(v.cbegin(), v.cend(), 8);\n    if (success) std::cout << \"found\" << '\\n'; \n    ```", "```cpp\n    std::vector<int> v{ 1, 1, 2, 3, 5, 8, 13 };\n    auto it = std::lower_bound(v.cbegin(), v.cend(), 1);\n    if (it != v.cend())\n      std::cout << \"lower bound at \"\n                << std::distance(v.cbegin(), it) << '\\n'; \n    ```", "```cpp\n    std::vector<int> v{ 1, 1, 2, 3, 5, 8, 13 };\n    auto it = std::upper_bound(v.cbegin(), v.cend(), 1);\n    if (it != v.cend())\n      std::cout << \"upper bound at \"\n                << std::distance(v.cbegin(), it) << '\\n'; \n    ```", "```cpp\n    std::vector<int> v{ 1, 1, 2, 3, 5, 8, 13 };\n    auto bounds = std::equal_range(v.cbegin(), v.cend(), 1);\n    std::cout << \"range between indexes \"\n              << std::distance(v.cbegin(), bounds.first)\n              << \" and \"\n              << std::distance(v.cbegin(), bounds.second)\n              << '\\n'; \n    ```", "```cpp\ntemplate<class ForwardIterator, class Searcher>\nForwardIterator search(ForwardIterator first, ForwardIterator last,\n const Searcher& searcher ); \n```", "```cpp\n    std::vector<int> v{3, 13, 5, 8, 1, 2, 1};\n    std::sort(v.begin(), v.end());\n    // v = {1, 1, 2, 3, 5, 8, 13}\n    std::sort(v.begin(), v.end(), std::greater<>());\n    // v = {13, 8, 5, 3, 2, 1, 1} \n    ```", "```cpp\n    struct Task\n    {\n      int priority;\n      std::string name;\n    };\n    bool operator<(Task const & lhs, Task const & rhs) {\n      return lhs.priority < rhs.priority;\n    }\n    bool operator>(Task const & lhs, Task const & rhs) {\n      return lhs.priority > rhs.priority;\n    }\n    std::vector<Task> v{\n      { 10, \"Task 1\"s }, { 40, \"Task 2\"s }, { 25, \"Task 3\"s },\n      { 10, \"Task 4\"s }, { 80, \"Task 5\"s }, { 10, \"Task 6\"s },\n    };\n    std::stable_sort(v.begin(), v.end());\n    // {{ 10, \"Task 1\" },{ 10, \"Task 4\" },{ 10, \"Task 6\" },\n    //  { 25, \"Task 3\" },{ 40, \"Task 2\" },{ 80, \"Task 5\" }}\n    std::stable_sort(v.begin(), v.end(), std::greater<>());\n    // {{ 80, \"Task 5\" },{ 40, \"Task 2\" },{ 25, \"Task 3\" },\n    //  { 10, \"Task 1\" },{ 10, \"Task 4\" },{ 10, \"Task 6\" }} \n    ```", "```cpp\n    std::vector<int> v{ 3, 13, 5, 8, 1, 2, 1 };\n    std::partial_sort(v.begin(), v.begin() + 4, v.end());\n    // v = {1, 1, 2, 3, ?, ?, ?}\n    std::partial_sort(v.begin(), v.begin() + 4, v.end(),\n                      std::greater<>());\n    // v = {13, 8, 5, 3, ?, ?, ?} \n    ```", "```cpp\n    std::vector<int> v{ 3, 13, 5, 8, 1, 2, 1 };\n    std::vector<int> vc(v.size());\n    std::partial_sort_copy(v.begin(), v.end(), vc.begin(), vc.end());\n    // v = {3, 13, 5, 8, 1, 2, 1}\n    // vc = {1, 1, 2, 3, 5, 8, 13}\n    std::partial_sort_copy(v.begin(), v.end(),\n                           vc.begin(), vc.end(),\n                           std::greater<>());\n    // vc = {13, 8, 5, 3, 2, 1, 1} \n    ```", "```cpp\n    std::vector<int> v{ 3, 13, 5, 8, 1, 2, 1 };\n    std::nth_element(v.begin(), v.begin() + 3, v.end());\n    // v = {1, 1, 2, 3, 5, 8, 13}\n    std::nth_element(v.begin(), v.begin() + 3, v.end(), std::greater<>());\n    // v = {13, 8, 5, 3, 2, 1, 1} \n    ```", "```cpp\n    std::vector<int> v { 1, 1, 2, 3, 5, 8, 13 };\n    auto sorted = std::is_sorted(v.cbegin(), v.cend());\n    sorted = std::is_sorted(v.cbegin(), v.cend(), std::greater<>()); \n    ```", "```cpp\n    std::vector<int> v{ 3, 13, 5, 8, 1, 2, 1 };\n    auto it = std::is_sorted_until(v.cbegin(), v.cend());\n    auto length = std::distance(v.cbegin(), it); \n    ```", "```cpp\n    std::vector<int> v(5);\n    std::fill(v.begin(), v.end(), 42);\n    // v = {42, 42, 42, 42, 42} \n    ```", "```cpp\n    std::vector<int> v(10);\n    std::fill_n(v.begin(), 5, 42);\n    // v = {42, 42, 42, 42, 42, 0, 0, 0, 0, 0} \n    ```", "```cpp\n    std::random_device rd{};\n    std::mt19937 mt{ rd() };\n    std::uniform_int_distribution<> ud{1, 10};\n    std::vector<int> v(5);\n    std::generate(v.begin(), v.end(),\n                  [&ud, &mt] {return ud(mt); }); \n    ```", "```cpp\n    std::vector<int> v(5);\n    auto i = 1;\n    std::generate_n(v.begin(), v.size(), [&i] { return i*i++; });\n    // v = {1, 4, 9, 16, 25} \n    ```", "```cpp\n    std::vector<int> v(5);\n    std::iota(v.begin(), v.end(), 1);\n    // v = {1, 2, 3, 4, 5} \n    ```", "```cpp\nstruct color\n{\n   unsigned char red   = 0;\n   unsigned char blue  = 0;\n   unsigned char green = 0;\n}; \n```", "```cpp\nstd::vector<color> make_gradient(color const& c1, color const& c2, size_t points)\n{\n   std::vector<color> colors(points);\n   auto rstep = static_cast<double>(c2.red - c1.red) / points;\n   auto gstep = static_cast<double>(c2.green - c1.green) / points;\n   auto bstep = static_cast<double>(c2.blue - c1.blue) / points;\n   auto r = c1.red;\n   auto g = c1.green;\n   auto b = c1.blue;\n   std::generate_n(colors.begin(), \n                   points, \n                   [&r, &g, &b, rstep, gstep, bstep] {\n      color c {\n         static_cast<unsigned char>(r),\n         static_cast<unsigned char>(g),\n         static_cast<unsigned char>(b) \n      };\n      r += rstep;\n      g += gstep;\n      b += bstep;\n      return c;\n   });\n   return colors;\n} \n```", "```cpp\ncolor white { 255, 255, 255 };\ncolor black { 0, 0, 0 };\nstd::vector<color> grayscale = make_gradient(white, black, 256);\nstd::for_each(\n   grayscale.begin(), grayscale.end(),\n   [](color const& c) {\n      std::cout << \n         static_cast<int>(c.red) << \", \"\n         << static_cast<int>(c.green) << \", \"\n         << static_cast<int>(c.blue) << '\\n';\n   }); \n```", "```cpp\n255, 255, 255\n254, 254, 254\n253, 253, 253\nâ€¦\n1, 1, 1\n0, 0, 0 \n```", "```cpp\nstd::vector<int> v1{ 1, 2, 3, 4, 4, 5 };\nstd::vector<int> v2{ 2, 3, 3, 4, 6, 8 };\nstd::vector<int> v3; \n```", "```cpp\n    std::set_union(v1.cbegin(), v1.cend(),\n                   v2.cbegin(), v2.cend(),\n                   std::back_inserter(v3));\n    // v3 = {1, 2, 3, 3, 4, 4, 5, 6, 8} \n    ```", "```cpp\n    std::merge(v1.cbegin(), v1.cend(),\n               v2.cbegin(), v2.cend(),\n               std::back_inserter(v3));\n    // v3 = {1, 2, 2, 3, 3, 3, 4, 4, 4, 5, 6, 8} \n    ```", "```cpp\n    std::set_intersection(v1.cbegin(), v1.cend(),\n                          v2.cbegin(), v2.cend(),\n                          std::back_inserter(v3));\n    // v3 = {2, 3, 4} \n    ```", "```cpp\n    std::set_difference(v1.cbegin(), v1.cend(),\n                        v2.cbegin(), v2.cend(),\n                        std::back_inserter(v3));\n    // v3 = {1, 4, 5} \n    ```", "```cpp\n    std::set_symmetric_difference(v1.cbegin(), v1.cend(),\n                                  v2.cbegin(), v2.cend(),\n                                  std::back_inserter(v3));\n    // v3 = {1, 3, 4, 5, 6, 8} \n    ```", "```cpp\n    std::vector<int> v1{ 1, 2, 3, 4, 4, 5 };\n    std::vector<int> v2{ 2, 3, 3, 4, 6, 8 };\n    std::vector<int> v3{ 1, 2, 4 };\n    std::vector<int> v4{ };\n    auto i1 = std::includes(v1.cbegin(), v1.cend(),\n                            v2.cbegin(), v2.cend()); // i1 = false\n    auto i2 = std::includes(v1.cbegin(), v1.cend(),\n                            v3.cbegin(), v3.cend()); // i2 = true\n    auto i3 = std::includes(v1.cbegin(), v1.cend(),\n                            v4.cbegin(), v4.cend()); // i3 = true \n    ```", "```cpp\nstruct Task\n{\n  int         priority;\n  std::string name;\n};\nbool operator<(Task const & lhs, Task const & rhs) {\n  return lhs.priority < rhs.priority;\n}\nbool operator>(Task const & lhs, Task const & rhs) {\n  return lhs.priority > rhs.priority;\n}\nstd::vector<Task> v1{\n  { 10, \"Task 1.1\"s },\n  { 20, \"Task 1.2\"s },\n  { 20, \"Task 1.3\"s },\n  { 20, \"Task 1.4\"s },\n  { 30, \"Task 1.5\"s },\n  { 50, \"Task 1.6\"s },\n};\nstd::vector<Task> v2{\n  { 20, \"Task 2.1\"s },\n  { 30, \"Task 2.2\"s },\n  { 30, \"Task 2.3\"s },\n  { 30, \"Task 2.4\"s },\n  { 40, \"Task 2.5\"s },\n  { 50, \"Task 2.6\"s },\n}; \n```", "```cpp\n    std::vector<Task> v3;\n    std::set_union(v1.cbegin(), v1.cend(),\n                   v2.cbegin(), v2.cend(),\n                   std::back_inserter(v3));\n    // v3 = {{10, \"Task 1.1\"},{20, \"Task 1.2\"},{20, \"Task 1.3\"},\n    //       {20, \"Task 1.4\"},{30, \"Task 1.5\"},{30, \"Task 2.3\"},\n    //       {30, \"Task 2.4\"},{40, \"Task 2.5\"},{50, \"Task 1.6\"}} \n    ```", "```cpp\n    std::vector<Task> v4;\n    std::merge(v1.cbegin(), v1.cend(),\n               v2.cbegin(), v2.cend(),\n               std::back_inserter(v4));\n    // v4 = {{10, \"Task 1.1\"},{20, \"Task 1.2\"},{20, \"Task 1.3\"},\n    //       {20, \"Task 1.4\"},{20, \"Task 2.1\"},{30, \"Task 1.5\"},\n    //       {30, \"Task 2.2\"},{30, \"Task 2.3\"},{30, \"Task 2.4\"},\n    //       {40, \"Task 2.5\"},{50, \"Task 1.6\"},{50, \"Task 2.6\"}} \n    ```", "```cpp\n    std::vector<Task> v5;\n    std::set_intersection(v1.cbegin(), v1.cend(),\n                          v2.cbegin(), v2.cend(),\n                          std::back_inserter(v5));\n    // v5 = {{20, \"Task 1.2\"},{30, \"Task 1.5\"},{50, \"Task 1.6\"}} \n    ```", "```cpp\n    std::vector<Task> v6;\n    std::set_difference(v1.cbegin(), v1.cend(),\n                        v2.cbegin(), v2.cend(),\n                        std::back_inserter(v6));\n    // v6 = {{10, \"Task 1.1\"},{20, \"Task 1.3\"},{20, \"Task 1.4\"}} \n    ```", "```cpp\n    std::vector<Task> v7;\n    std::set_symmetric_difference(v1.cbegin(), v1.cend(),\n                                  v2.cbegin(), v2.cend(),\n                                  std::back_inserter(v7));\n    // v7 = {{10, \"Task 1.1\"},{20, \"Task 1.3\"},{20, \"Task 1.4\"}\n    //       {30, \"Task 2.3\"},{30, \"Task 2.4\"},{40, \"Task 2.5\"}} \n    ```", "```cpp\n    std::vector<int> v{ 1,2,3,4,5 };\n    std::fill_n(std::back_inserter(v), 3, 0);\n    // v={1,2,3,4,5,0,0,0} \n    ```", "```cpp\n    std::list<int> l{ 1,2,3,4,5 };\n    std::fill_n(std::front_inserter(l), 3, 0);\n    // l={0,0,0,1,2,3,4,5} \n    ```", "```cpp\n    std::vector<int> v{ 1,2,3,4,5 };\n    std::fill_n(std::inserter(v, v.begin()), 3, 0);\n    // v={0,0,0,1,2,3,4,5}\n    std::list<int> l{ 1,2,3,4,5 };\n    auto it = l.begin();\n    std::advance(it, 3);\n    std::fill_n(std::inserter(l, it), 3, 0);\n    // l={1,2,3,0,0,0,4,5} \n    ```", "```cpp\ntemplate<class C>\nclass back_insert_iterator {\npublic:\n  typedef back_insert_iterator<C> T;\n  typedef typename C::value_type V;\n  explicit back_insert_iterator( C& c ) :container( &c ) { }\n  T& operator=( const V& val ) {\n    container->push_back( val );\n    return *this;\n  }\n  T& operator*() { return *this; }\n  T& operator++() { return *this; }\n  T& operator++( int ) { return *this; }\nprotected:\n  C* container;\n}; \n```", "```cpp\nstd::vector<int> v{ 1,2,3,4,5 };\nstd::fill_n(std::inserter(v, v.begin()), 3, 0);\n// v={0,0,0,1,2,3,4,5} \n```", "```cpp\nT& operator=(const V& v)\n{\n  iter = container->insert(iter, v);\n  ++iter;\n  return (*this);\n} \nstd::inserter_iterator adapter. You can see that it first calls the insert() member function of the container and then increments the returned iterator. Because all the standard containers have a method called insert() with this signature, this adapter can be used with all these containers.\n```", "```cpp\nstd::vector<int> v{ 1,2,3,4,5 };\n*std::back_inserter(v) = 6; // v = {1,2,3,4,5,6}\nstd::back_insert_iterator<std::vector<int>> it(v);\n*it = 7;                    // v = {1,2,3,4,5,6,7} \n```", "```cpp\ntemplate <typename Type, size_t const SIZE>\nclass dummy_array\n{\n  Type data[SIZE] = {};\npublic:\n  Type& operator[](size_t const index)\n  {\n    if (index < SIZE) return data[index];\n    throw std::out_of_range(\"index out of range\");\n  }\n  Type const & operator[](size_t const index) const\n  {\n    if (index < SIZE) return data[index];\n    throw std::out_of_range(\"index out of range\");\n  }\n  size_t size() const { return SIZE; }\n}; \n```", "```cpp\nstruct Tag\n{\n   int id;\n   std::string name;\n   Tag(int const id = 0, std::string const& name = \"\"s) :\n      id(id), name(name)\n   {}\n}; \n```", "```cpp\n    template <typename T, size_t const Size>\n    class dummy_array_iterator\n    {\n    public:\n      using self_type         = dummy_array_iterator;\n      using value_type        = T;\n      using reference         = T&;\n      using pointer           = T* ;\n      using iterator_category = std::random_access_iterator_tag;\n      using difference_type   = ptrdiff_t;\n    }; \n    ```", "```cpp\n    private:\n      pointer ptr = nullptr;\n      size_t index = 0; \n    ```", "```cpp\n    private:\n      bool compatible(self_type const & other) const\n     {\n        return ptr == other.ptr;\n      } \n    ```", "```cpp\n    public:\n      explicit dummy_array_iterator(pointer ptr,\n     size_t const index)\n      : ptr(ptr), index(index) { } \n    ```", "```cpp\n    dummy_array_iterator(dummy_array_iterator const & o)\n        = default;\n    dummy_array_iterator& operator=(dummy_array_iterator const & o)\n        = default;\n    ~dummy_array_iterator() = default;\n    self_type & operator++ ()\n    {\n      if (index >= Size)\n        throw std::out_of_range(\"Iterator cannot be incremented \n                                 past the end of range.\");\n      ++index;\n      return *this;\n    }\n    self_type operator++ (int)\n    {\n      self_type tmp = *this;\n      ++*this;\n      return tmp;\n    } \n    ```", "```cpp\n    bool operator== (self_type const & other) const\n    {\n      assert(compatible(other));\n      return index == other.index;\n    }\n    bool operator!= (self_type const & other) const\n    {\n      return !(*this == other);\n    }\n    reference operator* () const\n    {\n      if (ptr == nullptr)\n        throw std::bad_function_call();\n      return *(ptr + index);\n    }\n    reference operator-> () const\n    {\n      if (ptr == nullptr)\n        throw std::bad_function_call();\n      return *(ptr + index);\n    } \n    ```", "```cpp\n    dummy_array_iterator() = default; \n    ```", "```cpp\n    self_type & operator--()\n    {\n      if (index <= 0)\n        throw std::out_of_range(\"Iterator cannot be decremented\n                                 past the end of range.\");\n      --index;\n      return *this;\n    }\n    self_type operator--(int)\n    {\n      self_type tmp = *this;\n      --*this;\n      return tmp;\n    } \n    ```", "```cpp\n    self_type operator+(difference_type offset) const\n    {\n      self_type tmp = *this;\n      return tmp += offset;\n    }\n    self_type operator-(difference_type offset) const\n    {\n      self_type tmp = *this;\n      return tmp -= offset;\n    }\n    difference_type operator-(self_type const & other) const\n    {\n      assert(compatible(other));\n      return (index - other.index);\n    }\n    bool operator<(self_type const & other) const\n    {\n      assert(compatible(other));\n      return index < other.index;\n    }\n    bool operator>(self_type const & other) const\n    {\n      return other < *this;\n    }\n    bool operator<=(self_type const & other) const\n    {\n      return !(other < *this);\n    }\n    bool operator>=(self_type const & other) const\n    {\n      return !(*this < other);\n    }\n    self_type & operator+=(difference_type const offset)\n    {\n      if (index + offset < 0 || index + offset > Size)\n        throw std::out_of_range(\"Iterator cannot be incremented \n                                 past the end of range.\");\n      index += offset;\n      return *this;\n    }\n    self_type & operator-=(difference_type const offset)\n    {\n      return *this += -offset;\n    }\n    value_type & operator[](difference_type const offset)\n    {\n      return (*(*this + offset));\n    }\n    value_type const & operator[](difference_type const offset)\n    const\n    {\n      return (*(*this + offset));\n    } \n    ```", "```cpp\n    public:\n      using iterator = dummy_array_iterator<Type, SIZE>;\n      using constant_iterator = dummy_array_iterator<Type const, \n                                                     SIZE>; \n    ```", "```cpp\n    iterator begin()\n    {\n      return iterator(data, 0);\n    }\n    iterator end()\n    {\n      return iterator(data, SIZE);\n    }\n    constant_iterator begin() const\n    {\n      return constant_iterator(data, 0);\n    }\n    constant_iterator end() const\n    {\n      return constant_iterator(data, SIZE);\n    } \n    ```", "```cpp\n// defining and initializing an array of integers\ndummy_array<int, 3> a;\na[0] = 10;\na[1] = 20;\na[2] = 30;\n// modifying the elements of the array\nstd::transform(a.begin(), a.end(), a.begin(),\n               [](int const e) {return e * 2; });\n// iterating through and printing the values of the array\nfor (auto&& e : a) std::cout << e << '\\n'; \n```", "```cpp\n20\n40\n60 \n```", "```cpp\nauto lp = [](dummy_array<int, 3> const & ca)\n{\n  for (auto const & e : ca)\n    std::cout << e << '\\n';\n};\nlp(a); \n```", "```cpp\n20\n40\n60 \n```", "```cpp\n// defining and initializing an array of smart pointers\ndummy_array<std::unique_ptr<Tag>, 3> ta;\nta[0] = std::make_unique<Tag>(1, \"Tag 1\");\nta[1] = std::make_unique<Tag>(2, \"Tag 2\");\nta[2] = std::make_unique<Tag>(3, \"Tag 3\");\n// iterating through and printing the pointed values\nfor (auto it = ta.begin(); it != ta.end(); ++it)\n  std::cout << it->id << \" \" << it->name << '\\n'; \n```", "```cpp\n1 Tag 1\n2 Tag 2\n3 Tag 3 \n```", "```cpp\n    std::vector<int> v1{ 1, 2, 3, 4, 5 };\n    auto sv1 = std::size(v1);  // sv1 = 5\n    auto ev1 = std::empty(v1); // ev1 = false\n    auto dv1 = std::data(v1);  // dv1 = v1.data()\n    for (auto i = std::begin(v1); i != std::end(v1); ++i)\n      std::cout << *i << '\\n';\n    std::vector<int> v2;\n    std::copy(std::cbegin(v1), std::cend(v1),\n              std::back_inserter(v2)); \n    ```", "```cpp\n    int a[5] = { 1, 2, 3, 4, 5 };\n    auto pos = std::find_if(std::crbegin(a), std::crend(a),\n                            [](int const n) {return n % 2 == 0; });\n    auto sa = std::size(a);  // sa = 5\n    auto ea = std::empty(a); // ea = false\n    auto da = std::data(a);  // da = a \n    ```", "```cpp\n    dummy_array<std::string, 5> sa;\n    dummy_array<int, 5> sb;\n    sa[0] = \"1\"s;\n    sa[1] = \"2\"s;\n    sa[2] = \"3\"s;\n    sa[3] = \"4\"s;\n    sa[4] = \"5\"s;\n    std::transform(\n      std::begin(sa), std::end(sa),\n      std::begin(sb),\n      [](std::string const & s) {return std::stoi(s); });\n    // sb = [1, 2, 3, 4, 5]\n    auto sa_size = std::size(sa); // sa_size = 5 \n    ```", "```cpp\n    template <typename F, typename C>\n    void process(F&& f, C const & c)\n    {\n      std::for_each(std::begin(c), std::end(c),\n                    std::forward<F>(f));\n    }\n    auto l = [](auto const e) {std::cout << e << '\\n'; };\n    process(l, v1); // std::vector<int>\n    process(l, a);  // int[5]\n    process(l, sa); // dummy_array<std::string, 5> \n    ```", "```cpp\ntemplate<class C>\nconstexpr auto inline begin(C& c) -> decltype(c.begin())\n{\n  return c.begin();\n}\ntemplate<class C>\nconstexpr auto inline end(C& c) -> decltype(c.end())\n{\n  return c.end();\n}\ntemplate<class T, std::size_t N>\nconstexpr T* inline begin(T (&array)[N])\n{\n  return array;\n}\ntemplate<class T, std::size_t N>\nconstexpr T* inline begin(T (&array)[N])\n{\n  return array+N;\n} \n```", "```cpp\n    template <class C>\n    constexpr auto data(C& c) -> decltype(c.data())\n    {\n      return c.data();\n    }\n    template <class C>\n    constexpr auto data(const C& c) -> decltype(c.data())\n    {\n      return c.data();\n    }\n    template <class T, std::size_t N>\n    constexpr T* data(T (&array)[N]) noexcept\n    {\n      return array;\n    }\n    template <class E>\n    constexpr const E* data(std::initializer_list<E> il) noexcept\n    {\n      return il.begin();\n    } \n    ```", "```cpp\n    template <class C>\n    constexpr auto size(const C& c) -> decltype(c.size())\n    {\n      return c.size();\n    }\n    template <class T, std::size_t N>\n    constexpr std::size_t size(const T (&array)[N]) noexcept\n    {\n      return N;\n    } \n    ```", "```cpp\n    template <class C>\n    constexpr auto empty(const C& c) -> decltype(c.empty())\n    {\n      return c.empty();\n    }\n    template <class T, std::size_t N>\n    constexpr bool empty(const T (&array)[N]) noexcept\n    {\n      return false;\n    }\n    template <class E>\n    constexpr bool empty(std::initializer_list<E> il) noexcept\n    {\n      return il.size() == 0;\n    } \n    ```", "```cpp\ntemplate <class C>\nconstexpr auto ssize(const C& c)\n    -> std::common_type_t<std::ptrdiff_t,\n                          std::make_signed_t<decltype(c.size())>>\n{\n    using R = std::common_type_t<std::ptrdiff_t,\n                      std::make_signed_t<decltype(c.size())>>;\n    return static_cast<R>(c.size());\n}\ntemplate <class T, std::ptrdiff_t N>\nconstexpr std::ptrdiff_t ssize(const T (&array)[N]) noexcept\n{\n    return N;\n} \n```", "```cpp\nstd::vector<int> v{ 1, 1, 2, 3, 5, 8 };\nv.push_back(13); // insert at the end \n```", "```cpp\nstd::vector<int> v{ 1, 1, 2, 3, 5, 8 };\nv.insert(v.begin() + 3, 13); // insert in the middle \n```", "```cpp\nstd::deque<int> d{ 1,2,3,5,8 };\nd.push_front(1); // insert at the beginning\nd.push_back(13); // insert at the end \n```", "```cpp\nstd::list<int> l{ 1, 1, 2, 3, 5, 8 };\nauto it = std::find(l.begin(), l.end(), 3);\nl.insert(it, 13); \n```"]