<html><head></head><body>
        

                            
                    <h1 class="header-title">In-scene Video and Visual Effects</h1>
                
            
            
                


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>UE4 has some amazing in-game visual effects. Media Framework is a very cool tool and is used to add in-scene video to a game. Unreal also has some significantly-developed, but not entirely ready-to-go, tools for capturing realtime video. In this chapter, we'll capture a section of video from gameplay, then project it onto a surface as in-scene video playback. Unreal also offers a huge variety of visual FX, and to spice up our weapon impacts, we'll add some impact particles with physics to have a basis for these kinds of options as well. This chapter will focus on:</p>
<ul>
<li>Creating an in-game video player with Media Framework
<ul>
<li>Create assets and a material to add this to any actor in the map</li>
<li>Triggering and repeating our video</li>
</ul>
</li>
<li>Adding physics-based particles to the game
<ul>
<li>Creating an emitter for our projectiles and spawning it on hit-events</li>
<li>Orienting and modifying particles to have a cool motion/feel</li>
</ul>
</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>This chapter will implement its components in the <kbd>Chapter 12</kbd> branch of our project on GitHub: <a href="https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-12">https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-12</a>.</p>
<p>We used Engine version 4.19.2.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Playing in-scene video with Media Framework</h1>
                
            
            
                
<p>Media Framework adds several helpful key systems to play videos in-engine. However, the one we will focus on here is playing an in-scene video with audio playback on a "screen" triggered by our player. This is a very common and popular feature in many games, and using Unreal's render target materials, you can put realtime renders of other areas of your map anywhere. The classic example being security cameras showing you other areas. But to reiterate, we're just focusing on how to get a movie into the game to prove what can be done and learn what's involved in adding it to a game. First, however, we'll need a few new items.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating our assets</h1>
                
            
            
                
<p>There are several components needed to make a nice in-scene video player, let's quickly enumerate them here:</p>
<ul>
<li>The source video, of course! In Epic's documentation, they list supported files, but a nice short version is: when in doubt, use MP4s, as they work across every platform (more on the specific one here in a moment).</li>
<li>A File Media Source object that references, well, this source media (in our case, our video).</li>
<li>A Media Player object that does the work at runtime.</li>
<li>An associated Media Texture asset.</li>
<li>A Material that uses this texture.</li>
</ul>
<p>Now, the great news about UE4 is that lot of this is automated for you, so don't get intimidated by that list, this will go surprisingly quickly.</p>
<p>As a quick aside, I'll describe generally where this specific video came from, as the actual video file is key to this whole concept. There are, of course, a number of ways to capture video. While this book is not meant to be an endorsement of any specific outside products (other than recognizing what development tools and versions were used), doing an internet search on "Windows screen capture," is an easy solution. Also, using some of the game-streaming tools and apps on mobile devices can do this too: many have a "game mode" that captures the video and saves it.</p>
<p class="mce-root"/>
<p>Check out the Sequence Recorder in the editor (Windows | Sequence Recorder), as this may be just what you need. I found a few issues with using it in the past; but there is constant work being done with systems like that, and if you can get comfortable with a supported system built in to UE4, it's the best way to go.</p>
<p>The checked-in asset you can see is literally just me walking over to our Countess introduction in-game scene and capturing it out to an MP4 video that will be uploaded with the branch to GitHub. So with this video file added to our content folder, we can get back to the editor, and making items in our content browser:</p>
<p>The next thing needed, as noted, is a File Media Source:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/94bba451-c2a6-47b3-8078-fe72ea895525.png"/></p>
<p>And as you'll see, there's really not much to this particular object, just point it to the source media and note there are options for platform player overrides:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/fc4142d4-1e5e-4446-a745-f7d5b5406dc9.png"/></p>
<p>The last thing we'll add here is our Media Player. Note that when making a new media player, you'll get this popup and definitely want to check the box (as it is what automates making the media texture and wiring it up for us):</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/04f11ba2-7f72-4ec5-9583-dfea740d1370.png" style="width:28.58em;height:13.33em;"/></p>
<p class="mce-root"/>
<p>After clicking ok, we can continue:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/0efda684-9634-489c-950b-d6b3e6281ca9.png"/></p>
<p>And in here, simply drag and drop the CountessVid asset we just made into its list in the bottom left and the player is ready with its default settings. Our texture asset is now automatically created and associated (again, a great streamlining feature of modern UE4!). Now all we need is a material that we can generate by dragging the texture onto an actor, so let's progress to that.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Building and playing the video in-scene</h1>
                
            
            
                
<p>Theoretically, you can now play a video on any static mesh actor or a number of surfaces. Typically, though, it is just a plane, which can be dragged from the modes window right into the level. We'll generate a material by dragging the media texture directly on to the actor we want to use (our plane in this case), and then you can see a dead-simple material is added and is set on the surface. So after doing all of that, as seen here, there's one tricky part left: the audio that will fail to play if we don't right-click the +Add Component for our in-scene screen (plane), add a Media Sound component, and hook its media to our player:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/6deb5680-765e-4133-b22e-7dd11ada8c2c.png"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Manually hooking up the audio this way is one of the only complaints I have about the process these days, so now that we're pretty close to having everything we need, it's just a matter of triggering the video and checking it out:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/0bf9c68e-d2bc-4909-b874-88269bf738e7.png"/></p>
<p>Here a simple trigger volume is added in front of our screen, a blueprint-level variable (of Media Player type) is added on the left in the level blueprint, and with the volume selected, right-clicking in the blueprint event area lets you directly drop its on-actor-overlap event in and trigger an Open Source node, which is also set to point to our new asset. So note, this logic will trigger any and all instances of this material, which uses our media player, which can be great, but also may not be exactly what you want. There are a number of solutions there – the most obvious, but not nicest for asset cleanliness, is just to duplicate the player for each individual thing you want to play separately. Anyway, there you have it, we can now walk over to the screen to see and hear the Countess' intro sequence as many times as we like, as we trigger our MP4 video thereof!</p>
<p>One last point: when playing, this video comes across pretty dark in the scene:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/89c0251d-3826-4711-a1ec-75fcb723d52e.png"/></p>
<p class="mce-root"/>
<p>To correct that, I just did a very simple multiply on the color output in the material. Once again, there are a number of ways you could approach this; I always start with the simplest and if that does the job, move on! You can check that change out here, modify the constant value in the material, see the effect it has on our output in the game:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/45abc86b-83f2-462d-bbb4-59b3d86eeb2f.png"/></p>
<p>Now let's check out a couple more great visual FX that can be made with UE4 as we haven't used their particle system much yet.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding physics particles</h1>
                
            
            
                
<p>Our goal here will have two parts: first, to add some sparks off of our projectile hits when they impact, but then to get those sparks bouncing around in the physics universe without utterly killing our framerate. One great piece of news is that UE4 supports GPU particles across all kinds of platforms for you, and in general this is where you want to be doing that kind of work. Should you find yourself in a game that is GPU-bound because of its complex visuals (or low-bar for platform hardware specifications), these kinds of things are often the first to go; but let's not worry about that now, let's make some pretty sparks first. </p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating our initial emitter on projectile hit</h1>
                
            
            
                
<p>So some of you may remember way back at the beginning of the book that we added the starter content pack. Well, now we can finally put a bit more of that to use. Scrolling down near the bottom of the folders is StarterContent/Particles (or just do a wildcard search for P_Sparks in the search box). This is not exactly what we want, but it's close, which is always saves time. Notice that it is already using some spark and smoke GPU Sprite emitters (the other being a flash/burst). It seems pretty close, so why not start here? Similarly for C++ classes and all other aspects of game development, if you can begin with something that is at least partially already doing the job you want, always put that to use and begin modifying from there for efficiency. Now, let's take a look at these sparks:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/638b0e7e-a827-445d-abd9-83eb5fcabb05.png"/></p>
<p>As we'll be modifying them to behave a bit differently, I simply copy and paste the emitter (P_Sparks asset) up to FirstPersonCPP/FX. I also renamed it to P_ImpactSparks so as to avoid confusion when browsing for it. Now we have our own fresh copy and can begin modifying it. First, though, let's take a step back and just get them to spawn upon projectile impacts. We'll need to add a new variable to our MasteringProjectile class and spawn them around where we spawn impact sounds:</p>
<p>First in our projectile's header file we add:</p>
<pre>UPROPERTY(EditAnywhere, BlueprintReadWrite)
class UParticleSystem* ImpactParticles;</pre>
<p>Then in <kbd>OnHit</kbd> down at the bottom in the <kbd>.cpp</kbd> file we add:</p>
<pre>const float minVelocity = 1000.0f;
if (cueToPlay != nullptr &amp;&amp; GetVelocity().Size() &gt; minVelocity)
{
        UGameplayStatics::PlaySoundAtLocation(this, cueToPlay, Hit.Location);
 
        UGameplayStatics::SpawnEmitterAtLocation(GetWorld(), ImpactParticles, Hit.Location, GetActorRotation(), true);
}</pre>
<p>And just like that, we have particles spawning at the hit locations. Simply go to each projectile in the <kbd>FirstPersonCPP/Blueprints/Weapons</kbd> folder and set all of their ImpactParticle variables to use the newly copied P_ImpactSparks asset. For those going through this step by step, you'll notice some problems at this point:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/eaf700c3-cdef-4030-ae77-29ef1aba06e8.png" style="width:65.00em;height:40.75em;"/></p>
<p>First, our particle systems (emitters) live forever, and second, they always spawn straight up and down with no imparted sense of velocity and simply flow to the ground as a stationary fountain would. The first is trivial to fix: open P_ImpactSparks in Cascade (double click the asset) and you'll see three emitters in its main window. Click on the Required bar on each and scroll down on the Details menu, and you'll see all three have a looping count set to 0 (loop forever) – set it to 1 as that fixes our infinite systems here:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/92dd359d-834f-4032-a7b0-642ae60d36ee.png"/></p>
<p class="mce-root"/>
<p>I'm not a huge fan of the user interface in Cascade, but with practice I have seen FX artists that work in it masterfully and can find and modify systems very quickly. In this case, we'll likely want to increase the sparks' velocity and reduce that emitter's lifetime, but these are all more or less cosmetic things. Our last issues are to get them orienting properly for the way the projectiles hit the surfaces and make sure we can tune the spark behavior coming off of them if needed for performance reasons.</p>
<p>So why not use Niagara, the newer editor for the particles? Honestly, in this instance, it was my own familiarity with Cascade; but of course anyone is welcome to use Niagara and I will add a link to it (which starts with a link to the differences and similarities to Cascade) in Further Reading. Similar to Matinee vs. Sequencer earlier, both will remain and be supported, but long-term, it probably <em>is</em> a good idea to move to Niagara.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Orienting and adjusting physics of the particles</h1>
                
            
            
                
<p>Having particle systems just rain down boring-looking sparks is not going to cut it with this type of effect, we need the sparks to align in a way that makes sense from the projectile impact. This will take just a little bit more code work and a little bit more Cascade work; but should come out looking good.</p>
<div><strong>Note:</strong> If you use blueprints to spawn various effects, it makes it much easier to hook up outside factors to these emitters and systems. Technical artists often find this invaluable to allow for a quick iteration of systems until they get things looking right. Just be aware that a well-meaning content creator can make one small node that ends up testing a huge amount of physics collisions accidentally, so this kind of experimentation can be dangerous for performance!</div>
<p>First, the quick code change:</p>
<pre>FRotator rot =  GetVelocity().ToOrientationRotator();
UGameplayStatics::SpawnEmitterAttached(ImpactParticles, GetRootComponent(), NAME_None, FVector::ZeroVector, rot, EAttachLocation::SnapToTargetIncludingScale, true);</pre>
<p>There are a <em>lot</em> of options here, you can use Hit.Normal/Hit.ImpactNormal instead of the velocity to build your rotation, and not attach the particles if desired, for example. I found here that attaching the system made the particles feel like they were being "pulled with" the projectile and made for a bit of a chaotic look, which I liked, setting the rotation along the velocity as well. In Cascade, only the smoke system was currently set to inherit the parent's velocity; I made the sparks do so as well (right-click in the emitter's column area, add that field, and select it). Note the reduced Emitter Duration tuned value on the left:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/1e14d42b-b119-4799-a233-168754f44efb.png"/></p>
<p>The end result is not quite ready for professional quality, knowing your limits is an important trait in growing with a team as well. Still, hopefully the journey here helped to boost your confidence in Unreal's awesome visual effects. There's so much more to explore, but having the fundamentals to take a project forward is what this book is all about.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>We've touched on just about all of the major systems traditional UE4 has to offer. While there are a few more specialized systems, at this point, you should be comfortable making a traditional game on whatever platform is desired in UE4. The Unreal community has a huge amount of visual FX that can be downloaded for free, knowing the above you should have the confidence to go explore its deep options! There's only one area we haven't really explored yet; it's one of the newest to UE4 and what we'll cover in the next chapter: AR and VR, Unreal's Augmented Reality and Virtual Reality API and projects. This is also the end of the updates for our main GitHub project: from its humble origins as the FirstPersonCPP template, to FrozenCove, its fog and lighting, to the Countess and her AI, to loading and saving, and effects and optimizations. I hope you have found it an inspiring and meaningful journey. Now on to the new worlds of AR and VR!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Questions</h1>
                
            
            
                
<ol>
<li>Why is MP4 typically the best choice for videos in UE4? (Hint: see the <em>Further reading</em> section for some details)</li>
<li>If a single Media Player is referenced on multiple actors, what happens when opening that media?</li>
<li>What's the quick simple way to get your video texture and video material?</li>
<li>Why was the constant multiplier added to color output of the material here?</li>
<li>What's a good strategy to save time in both C++ and asset creation that we used with the particle emitter?</li>
<li>Why should we attach the emitter to our projectile rather than have it stay still in space, as first implemented?</li>
<li>How did we get the emitters aligned with the projectile direction?</li>
<li>When is it disadvantageous to have particles simulate on the GPU (which can easily be changed in Cascade)?</li>
</ol>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Further reading</h1>
                
            
            
                
<p>Supported video types in Media Framework:</p>
<p><a href="https://docs.unrealengine.com/en-US/Engine/MediaFramework/TechReference">https://docs.unrealengine.com/en-US/Engine/MediaFramework/TechReference</a></p>
<p>Niagara particle editor:</p>
<p><a href="https://docs.unrealengine.com/en-us/Engine/Niagara">https://docs.unrealengine.com/en-us/Engine/Niagara</a></p>


            

            
        
    </body></html>