- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust Will Replace C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*If 4 things* *happen concomitantly*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rust rose as a contender for systems programming and C++ in the past years.
    There are good reasons for this: Rust is a modern language, providing a good toolset,
    simple syntax, and innovations that help reason about the code. The question of
    whether Rust will replace C++ is therefore on the minds of many programmers who
    would like to know where to invest their efforts for the future of their careers.
    We will look next at what makes Rust interesting and at what would need to happen
    for it to replace C++.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Why the competition?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Core features of Rust
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rust’s advantages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where C++ is better
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What C++ still needs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code for this chapter is available in the GitHub repository ( [https://github.com/PacktPublishing/Debunking-C-Myths](https://github.com/PacktPublishing/Debunking-C-Myths)
    ), in the **ch12** folder. To run the code, you will need Rust, using the instructions
    from their website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.rust-lang.org/tools/install](https://www.rust-lang.org/tools/install)'
  prefs: []
  type: TYPE_NORMAL
- en: Why the competition?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a junior C++ programmer working abroad in Paris around 2001, my biggest
    challenge was to make my code do what it needed to do. The project was a knowledge
    base for industrial printing presses, allowing operators to identify the source
    of printing errors. Back then, the main option for such desktop applications was
    C++ under Windows, developed with Visual C++, **Microsoft Foundation Class** (
    **MFC** ), and Windows APIs, designed with the Document-View model, a weaker cousin
    of Model-View-Controller promoted by Microsoft. The project challenged me to the
    maximum: not only was I struggling with C++ memory management but I also had to
    deal with the quirks of MFC and Windows APIs. My support back then was the official
    documentation, the [https://codeproject.com](https://codeproject.com) website,
    and one more experienced colleague who was rarely available. Basically, I had
    to deal with a complex technology, as a sole developer, without a lot of support.
    Welcome to software development in the 2000s! Don’t get me wrong, I’m not complaining:
    because of its challenges, the experience was deeply helpful and educational.'
  prefs: []
  type: TYPE_NORMAL
- en: My sole focus at that point was the technology I was using. I had heard of things
    such as PHP, and I had used Java before for applets and web applications, but
    C++, MFC, and Windows APIs were filling my bandwidth. It didn’t help that the
    commute took around 90 minutes, enough time to read the whole *Lord of the Rings*
    book on public transport over the course of a year.
  prefs: []
  type: TYPE_NORMAL
- en: 'A second important project in my career was completely different: still C++,
    but a very structured and mentored approach to building a NoSQL database engine
    before such a thing was named. At that time, I learned how to write tests, and
    we wrote our own testing engine since there was none for C++. I learned a lot
    about software design by writing design documents and reviewing them with colleagues.
    I learned about code reviews. I learned C++ ins and outs through a deep dive into
    seminal books that included Scott Meyers’ *Effective C++* and *More Effective
    C++* , and Andrei Alexandrescu’s *Modern C++ Design* . So, I went even deeper
    into the same technology.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then C# appeared, and I decided to switch technologies. After doing some Java,
    having a deep knowledge of C++, and going in a structured manner into C#, I realized
    two things: changing technologies is easier the more you do it, and each technology
    has its own advantages and disadvantages. Desktop applications were much easier
    to build in C# since we had to pay less attention to memory management and its
    potential issues. Programming was more fun, and more importantly, we were developing
    faster. We traded these two benefits for two downsides: less control and a less
    rigorous approach to programming.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Later in my career, I started wondering about the plethora of programming languages
    available in the marketplace. In my estimation, we would need about 5-7 programming
    languages for purely technical reasons: one for web, one for systems programming,
    one for scripting, and the rest for various niches like AI, workflows, solving
    equations, and so on. Let’s say I’m wrong and we would need 20. However, the reality
    is that we can use hundreds of programming languages today, including mainstream,
    niche, and esoteric languages such as Brainfuck or Whitespace. We can see many
    of them in the TIOBE Programming Community index that monitors the popularity
    of programming languages. Why are there so many?'
  prefs: []
  type: TYPE_NORMAL
- en: 'My best guess is that it’s not a matter of technical needs, but one of culture.
    Sure, the technical aspects are important. Object-oriented and later functional
    programming features were introduced in all mainstream languages. Security, parallelism
    and concurrency, ease of programming, the community, and the ecosystem are all
    important aspects of a programming language. However, the decision to make a new
    programming language comes from people, and the decisions they make when designing
    the language come from their personal preferences. Trends in literature and philosophy
    follow the same pattern: current and counter-current or reactionary. In literature,
    Romanticism was a reaction to Classicism, and realism was a reaction to Romanticism.
    Something similar happens with programming languages: Java was a reaction to C++,
    and Ruby on Rails was a reaction to Java. While in literature, currents are partially
    determined by societal changes, in technology, the currents are determined both
    by the movements in the landscape and the preferences of younger generations of
    programmers, added at a very high pace. An example of the technological landscape
    change is the rise of the internet, which has favored the rise of Java as a reaction
    to C++ for web applications. Interestingly, the movement of computation from server
    to client nowadays seems to favor the apparition of Web Assembly applications
    that currently require low-level programming in C++ or Rust. As for the new generations
    of programmers, Ruby on Rails was very much a reaction to the perceived old-style
    Java language. Rails offered freedoms of expression that Java didn’t, along with
    a feeling of satisfaction with the progress. This feeling had little technical
    basis, but technical aspects aren’t everything for people, not even for software
    developers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see now where this is going: Rust is a reaction to C++. It is a
    reaction both to current technical annoyances of C++ and to the ways C++ does
    things. Let’s therefore look at what Rust brings to the table.'
  prefs: []
  type: TYPE_NORMAL
- en: Core features of Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first place we can use for understanding Rust’s core features is the official
    website, [https://www.rust-lang.org/](https://www.rust-lang.org/) . The site does
    a very good job of emphasizing the most important features of Rust:'
  prefs: []
  type: TYPE_NORMAL
- en: Fast and memory-efficient
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No garbage collector
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrates with other languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory safety and thread safety through a rich type system and ownership model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Great documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Friendly compiler with useful error messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrated package manager and build tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Auto formatter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smart multi-editor support with auto-completion and type inspections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'From this description only, we can already see a few similarities with C++,
    along with improvements on the current state of C++. The similarities are in the
    level of control: native compilation, no garbage collector, speed, and memory
    efficiency are qualities that C++ touts as well. The differences point to things
    that we discussed at length in this book: standard package manager, standard tooling,
    and friendly compiler. This last quality is music to the ears of any C++ programmer
    who got huge error messages; I remember back in the 2000s, I got an error in Visual
    C++ that said something along the lines of “error messages are too long and we
    can’t display them”. While today’s C++ is friendlier, figuring out what didn’t
    work while using templates is still a pain.'
  prefs: []
  type: TYPE_NORMAL
- en: However, let’s look beyond what’s written on the front page of the website.
    We’ll look next at a few features that I selected because I found them very useful
    and interesting compared to C++.
  prefs: []
  type: TYPE_NORMAL
- en: Project templates and package management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As an avid user of the command line and neovim code editor, I love technologies
    that allow me to create projects directly from the command line. Rust comes with
    the **cargo** tool that allows creating projects, building, running, packaging,
    and publishing. To create a new project, just call **cargo new project-name**
    . You run it with **cargo run** , check that it doesn’t have compile errors with
    **cargo check** , compile it with **cargo build** , package it with – you guessed
    it! – **cargo package** , and publish it with (drum rolls) ... **cargo publish**
    .
  prefs: []
  type: TYPE_NORMAL
- en: We can, of course, create libraries and executables with **cargo** . More than
    that, we can use the cargo generate tool found at [https://cargo-generate.github.io/cargo-generate/](https://cargo-generate.github.io/cargo-generate/)
    to start from a project template.
  prefs: []
  type: TYPE_NORMAL
- en: 'I know this might not look like much to most of the C++ developers out there
    because you rarely create a new project. This has been one of my surprises when
    teaching unit testing or test-driven development to C++ programmers: we had to
    work together to set up a test project with a production project and the corresponding
    references, something I took for granted. Believe me when I say that this is very
    nice to have not only at the beginning of a project but also for small experiments,
    personal or practice code bases, and reducing compilation times. A simple thing
    C++ offers you if your project compiles too slowly is to create a new compilation
    unit formed out of the few files you are modifying and refer to the rest as a
    binary. I used this technique extensively before SSD hard drives sped up compilation
    considerably.'
  prefs: []
  type: TYPE_NORMAL
- en: Enough on new projects. Let’s write some code. Let’s modify some variables...
    or maybe not.
  prefs: []
  type: TYPE_NORMAL
- en: Immutability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Rust features immutability by default. The way the documentation puts it is
    *“once a value is bound to a name, you can’t change that value.”* Let’s look at
    a simple example where I assign a string value to a variable, display it, and
    then try to modify it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Trying to compile this program results in a **cannot assign twice to immutable
    variable `the_message`** compilation error. Helpfully, the error message includes
    the **For more information about this error, try `rustc –explain E0384`** notice.
    The explanation for the error message contains an example for the error, and a
    very helpful notice on how to make variables mutable:'
  prefs: []
  type: TYPE_NORMAL
- en: '**"By default, variables in Rust are immutable. To fix this error, add the
    keyword must after the keyword let when declaring** **the variable"**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is a code example that, when adapted, makes the program compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, mutable variables must be specified as **mut** , so the default
    is immutability. As we’ve seen in previous chapters, this helps with a lot of
    problems such as parallelism and concurrency, automated testing, and code simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: Simple syntax for compound types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Rust borrows from languages such as Python or Ruby the syntax for arrays and
    tuples. Here’s what that looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This might not look like much, but it helps simplify code.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s worth mentioning here that C++ has introduced a similar syntax in C++
    11 and has improved it in consequent versions, through the list initializer, using
    curly braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: I would love to see further improvements on this front, but the C++ syntax is
    already complex, so I don’t expect it.
  prefs: []
  type: TYPE_NORMAL
- en: Optional return keyword
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Functions in Rust allow the return of the last value in the function. The next
    example uses this construct to increment a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: I usually avoid this in functions such as the preceding, but avoiding the **return**
    keyword simplifies closures, as we’ll see next.
  prefs: []
  type: TYPE_NORMAL
- en: Closures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s increment all elements of a vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As usual for functional programming constructs, and similarly to the **ranges**
    library in C++, we need to get an iterator, call the map function – equivalent
    to the transform algorithm in C++ – with a closure, and call **collect** to obtain
    the results. The closure has a very simple syntax, made possible by the optional
    return statement.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests in Standard Library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unit testing is a very important practice in software development, and it’s
    surprising that only a few languages offer support for it in the standard library.
    Rust does it by default, and it’s quite easy to use. Let’s add a unit test to
    verify that our **increment_all** function works as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As a plus, I like that it’s very easy to write unit tests in the same compilation
    unit (called a **crate** in Rust) as the production code. This might not seem
    like much if you see unit tests as an obligation, but I often use unit tests to
    experiment and to design so I love this facility a lot.
  prefs: []
  type: TYPE_NORMAL
- en: Traits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A big difference between Rust (or Go) and the other mainstream languages is
    that Rust does not support inheritance, instead favoring composition. To allow
    for polymorphic behavior without inheritance, Rust offers traits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rust traits are similar to interfaces in object-oriented languages in that
    they define a set of methods that need to be implemented for every object that
    derives from them. However, Rust traits have a specific feature: you can add a
    trait to a type you don’t own. This is similar to extension methods in C#, although
    not the same.'
  prefs: []
  type: TYPE_NORMAL
- en: The Rust documentation provides an example of traits by using two structures,
    one representing a tweet and the other a news article, and adding the **Summary**
    trait to both is meant to create a summary of the corresponding message. As you
    can see in the example that follows, the trait implementation is separate from
    both the structure implementation and the trait definition, which makes it very
    flexible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by looking at the two structures. First, the **NewsArticle** contains
    a few fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the **Tweet** structure contains its own fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Separately, we define the **Summary** trait with a single method summarize
    returning a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s now implement the **Summary** trait for the **Tweet** structure. This
    is done by specifying that the implementation of this trait applies to the structure,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The test works perfectly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let’s implement the trait for the news article:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Traits in Rust have much more capabilities. We can implement a default behavior,
    specify that the type of a parameter needs to be of one or multiple trait types,
    implement traits generically on multiple types, and so on. In fact, Rust traits
    are a combination of OO interfaces, C# extension methods, and C++ concepts. However,
    this is outside the scope of this chapter. What’s worth remembering is that Rust
    treats inheritance very differently from C++.
  prefs: []
  type: TYPE_NORMAL
- en: Ownership model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An interesting characteristic of Rust, and perhaps its most advertised feature,
    is the ownership model. This is Rust’s reaction to memory safety issues in C++,
    only instead of going into garbage collectors like Java or C# do, the designers
    have solved the problem with a more explicit ownership of memory. We’ll look at
    a quote from the Rust book ( [https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html
    ):](https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html):)
  prefs: []
  type: TYPE_NORMAL
- en: “ *Memory is managed through a system of ownership with a set of rules that
    the compiler checks. If any of the rules are violated, the program won’t compile.
    None of the features of ownership will slow down your program while* *it’s running.*
    ”
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three rules of ownership in Rust:'
  prefs: []
  type: TYPE_NORMAL
- en: Each value in Rust has an *owner*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There can only be one owner at a time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the owner goes out of scope, the value will be dropped
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s first look at an example that works the same as in C++. If we have a
    variable allocated on the stack, such as an integer, then copying the variable
    works in a very familiar way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Both variables have the same value, as expected. However, if we try the same
    code with a variable allocated on the heap, we get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When running this, we get the **error[E0382]: borrow of moved value: `heap_value`**
    error. What happens?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, when we assign the value of **heap_value** to **copied_heap_value** ,
    the **heap_value** variable is invalidated. This behaves the same as the move
    semantics in C++, only without any additional work from the programmer. Behind
    the scenes, this works through the use of two traits: **Copy** and **Drop** .
    If a type implements the **Copy** trait then it works as in the first example,
    while if it implements the **Drop** trait then it works as in the second. No type
    can implement both traits.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the above example work, we need to clone the value instead of using
    the default move mechanism:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This example works fine, so the value is cloned. This indicates, however, a
    new allocation on the heap, not a reference to the same value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The move semantics work the same for function calls. Let’s initialize a value
    and pass it to a function that returns it unchanged to see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'When trying to compile this code, we get the same error as before: **error[E0382]:
    borrow of moved value: `heap_value`** . The value is created on the heap, moved
    into the **call_me** function, and therefore dropped from the current scope. We
    can make this code work by specifying that the function called should only borrow
    the ownership instead of taking it over. This is done through the use of reference
    and dereference operators, which are the same as in C++:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The important difference between C++ references and Rust references is that
    Rust references are immutable by default.
  prefs: []
  type: TYPE_NORMAL
- en: There is, of course, a lot more to learn about the ownership model in Rust,
    but I believe this is enough to give you a taste of how it works and how it’s
    meant to prevent memory safety issues.
  prefs: []
  type: TYPE_NORMAL
- en: Rust’s advantages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To summarize, Rust has a few advantages over C++. By being a newer language,
    it has the advantage of learning from its predecessors and using the best patterns
    available. I find the combination of immutability with the ownership model to
    be very good at code that works well by default. It might take a bit to learn
    since it’s not the typical memory management style, but once you understand how
    to use it, it allows you to write code that works without much challenge.
  prefs: []
  type: TYPE_NORMAL
- en: The unit testing support in the standard library, the package manager, and the
    multi-editor support should be part of any modern programming language. The syntax
    is nicer when it comes to closures and compound types.
  prefs: []
  type: TYPE_NORMAL
- en: 'We might wonder at this point: does C++ stand a chance? Why and where?'
  prefs: []
  type: TYPE_NORMAL
- en: Where C++ is better
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C++ is a very capable, advanced programming language, under continuous improvement.
    The language is progressing quite fast. It’s very difficult to equal the C++ ecosystem:
    its community, the staggering number of libraries and frameworks available, and
    the articles, blogs, and books that teach you how to use C++ in various ways for
    any possible problem you might have. For all its benefits, Rust is a young language
    compared to C++, which should give you pause when considering the choice of technology
    for systems programming. However, Rust has been adopted for subsystems of Linux
    and Android, so it proves itself a worthy competitor.'
  prefs: []
  type: TYPE_NORMAL
- en: The C++ standardization committee has shown a continuous focus on simplifying
    syntax and reducing the mental burden of programmers for various code constructs.
    Part of the effort comes from the competition, with many of the features introduced
    in C++17 and later being an answer to the Rust design choices. While I don’t expect
    C++’s syntax to evolve to be as simple as Rust, the other factors mentioned here
    must contribute to the choice just as much, if not more.
  prefs: []
  type: TYPE_NORMAL
- en: What C++ still needs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this book, we have seen some of the challenges of C++. A standard package
    manager would be very helpful, even if the community follows in the footsteps
    of Java and C# and picks an open source de-facto standard. A standard unit testing
    library would be very beneficial, even if the existing code might take a long
    while to migrate if it ever does.
  prefs: []
  type: TYPE_NORMAL
- en: Unicode and utf-8 support still need improvement. Standard support for multithreading
    is at the beginning. Safety profiles would be extremely useful for minimizing
    memory safety issues.
  prefs: []
  type: TYPE_NORMAL
- en: It’s clear from this list that C++ has a lot of things to improve. The good
    news is that the standardization committee is hard at work on some of these issues.
    The less good news is that it takes time to define these improvements, more time
    to adapt compilers, and even more time to adapt existing code. Hopefully, Gen
    AI will be capable enough to speed up these improvements while maintaining code
    integrity.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw, in this chapter, that Rust is a very interesting language, whose designers
    knew to take advantage of the knowledge gathered by their predecessors and to
    innovate in the right places. The result is a nice syntax, a more natural way
    to deal with memory without using a garbage collector, and an overall modern development
    experience. We explored this in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: However, C++ is hard to compete with. The sheer number of libraries, frameworks,
    blogs, articles, code examples, books, and experience available in the world on
    C++ is impossible to equal in a short time. Rust has found its niches in Web Assembly
    applications and various tools, but it’s far from replacing C++.
  prefs: []
  type: TYPE_NORMAL
- en: Still, we have to remember that languages are not necessarily picked based on
    technical reasons and that cultural reasons matter as well. Newer generations
    of programmers might enjoy Rust much more than C++, and with the NSA and the White
    House leading the focus on memory-safe languages, Rust might gain ground for newer
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The conclusion? It’s hard to predict the future, but we can imagine how Rust
    could take over. The way I see it, it would require four factors: Rust is preferred
    by more and more programmers, it is required by regulation, C++ fails to evolve
    on memory safety fast enough, and generative AI gets good enough at translating
    from C++ to Rust.'
  prefs: []
  type: TYPE_NORMAL
- en: So, there’s a chance, but I think it’s safe to say that it’s over 50% that C++
    is here to stay at least for another decade.
  prefs: []
  type: TYPE_NORMAL
