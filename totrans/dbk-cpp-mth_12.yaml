- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Rust Will Replace C++
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust将取代C++
- en: '*If 4 things* *happen concomitantly*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果4件事情* *同时发生*'
- en: 'Rust rose as a contender for systems programming and C++ in the past years.
    There are good reasons for this: Rust is a modern language, providing a good toolset,
    simple syntax, and innovations that help reason about the code. The question of
    whether Rust will replace C++ is therefore on the minds of many programmers who
    would like to know where to invest their efforts for the future of their careers.
    We will look next at what makes Rust interesting and at what would need to happen
    for it to replace C++.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Rust在过去几年中作为系统编程和C++的竞争者崛起。这有很好的理由：Rust是一种现代语言，提供了一套良好的工具集、简单的语法以及有助于推理代码的创新。因此，Rust是否会取代C++的问题，许多希望了解自己职业未来投资方向的程序员都在思考。接下来，我们将探讨Rust的有趣之处以及它需要发生什么才能取代C++。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Why the competition?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么有竞争？
- en: Core features of Rust
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust的核心特性
- en: Rust’s advantages
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust的优势
- en: Where C++ is better
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++的优势在哪里
- en: What C++ still needs
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++还需要什么
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code for this chapter is available in the GitHub repository ( [https://github.com/PacktPublishing/Debunking-C-Myths](https://github.com/PacktPublishing/Debunking-C-Myths)
    ), in the **ch12** folder. To run the code, you will need Rust, using the instructions
    from their website:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可在GitHub仓库（[https://github.com/PacktPublishing/Debunking-C-Myths](https://github.com/PacktPublishing/Debunking-C-Myths)）中的**ch12**文件夹找到。要运行代码，您需要Rust，并按照他们网站上的说明操作：
- en: '[https://www.rust-lang.org/tools/install](https://www.rust-lang.org/tools/install)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.rust-lang.org/tools/install](https://www.rust-lang.org/tools/install)'
- en: Why the competition?
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么有竞争？
- en: 'As a junior C++ programmer working abroad in Paris around 2001, my biggest
    challenge was to make my code do what it needed to do. The project was a knowledge
    base for industrial printing presses, allowing operators to identify the source
    of printing errors. Back then, the main option for such desktop applications was
    C++ under Windows, developed with Visual C++, **Microsoft Foundation Class** (
    **MFC** ), and Windows APIs, designed with the Document-View model, a weaker cousin
    of Model-View-Controller promoted by Microsoft. The project challenged me to the
    maximum: not only was I struggling with C++ memory management but I also had to
    deal with the quirks of MFC and Windows APIs. My support back then was the official
    documentation, the [https://codeproject.com](https://codeproject.com) website,
    and one more experienced colleague who was rarely available. Basically, I had
    to deal with a complex technology, as a sole developer, without a lot of support.
    Welcome to software development in the 2000s! Don’t get me wrong, I’m not complaining:
    because of its challenges, the experience was deeply helpful and educational.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 作为大约2001年在巴黎工作的初级C++程序员，我最大的挑战是让我的代码完成所需的功能。该项目是一个工业印刷机的知识库，允许操作员识别打印错误的原因。当时，此类桌面应用的主要选项是在Windows下使用C++，通过Visual
    C++、**微软基础类库**（**MFC**）和Windows API开发，后者是微软推广的模型-视图-控制器（Model-View-Controller）的一个较弱的分支。这个项目让我面临了极大的挑战：我不仅要与C++的内存管理作斗争，还要处理MFC和Windows
    API的怪癖。那时的支持主要来自官方文档、[https://codeproject.com](https://codeproject.com)网站以及一位很少有空闲的资深同事。基本上，我必须作为一个独立开发者，在没有太多支持的情况下处理复杂的技术。欢迎来到21世纪初的软件开发！请别误会，我并不是在抱怨：正是因为其挑战，这段经历对我来说非常有帮助，并且具有教育意义。
- en: My sole focus at that point was the technology I was using. I had heard of things
    such as PHP, and I had used Java before for applets and web applications, but
    C++, MFC, and Windows APIs were filling my bandwidth. It didn’t help that the
    commute took around 90 minutes, enough time to read the whole *Lord of the Rings*
    book on public transport over the course of a year.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个阶段，我唯一关注的是我正在使用的科技。我听说过PHP，之前也用Java开发过小程序和Web应用，但C++、MFC和Windows API占据了大部分精力。通勤大约需要90分钟，足够一年内在公共交通工具上读完整本《指环王》。
- en: 'A second important project in my career was completely different: still C++,
    but a very structured and mentored approach to building a NoSQL database engine
    before such a thing was named. At that time, I learned how to write tests, and
    we wrote our own testing engine since there was none for C++. I learned a lot
    about software design by writing design documents and reviewing them with colleagues.
    I learned about code reviews. I learned C++ ins and outs through a deep dive into
    seminal books that included Scott Meyers’ *Effective C++* and *More Effective
    C++* , and Andrei Alexandrescu’s *Modern C++ Design* . So, I went even deeper
    into the same technology.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的职业生涯中，第二个重要的项目完全不同：仍然是C++，但在一个NoSQL数据库引擎被命名之前，采用了一种非常结构化和指导性的方法来构建。当时，我学会了如何编写测试，因为我们没有为C++编写自己的测试引擎。通过编写设计文档并与同事审查它们，我学到了很多关于软件设计的东西。我学习了代码审查。通过深入研究包括Scott
    Meyers的《Effective C++》和《More Effective C++》以及Andrei Alexandrescu的《Modern C++ Design》等经典书籍，我深入了解了C++的方方面面。因此，我甚至更深入地研究了同一技术。
- en: 'Then C# appeared, and I decided to switch technologies. After doing some Java,
    having a deep knowledge of C++, and going in a structured manner into C#, I realized
    two things: changing technologies is easier the more you do it, and each technology
    has its own advantages and disadvantages. Desktop applications were much easier
    to build in C# since we had to pay less attention to memory management and its
    potential issues. Programming was more fun, and more importantly, we were developing
    faster. We traded these two benefits for two downsides: less control and a less
    rigorous approach to programming.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，C#出现了，我决定转换技术。在做过一些Java，对C++有深入的了解，并以一种结构化的方式学习C#之后，我意识到两件事：转换技术做得越多，就越容易，每种技术都有其自身的优缺点。在C#中构建桌面应用程序要容易得多，因为我们不必过多关注内存管理和其潜在问题。编程更有趣，更重要的是，我们开发速度更快。我们用这两个好处交换了两个缺点：更少的控制和编程方法上的不够严谨。
- en: 'Later in my career, I started wondering about the plethora of programming languages
    available in the marketplace. In my estimation, we would need about 5-7 programming
    languages for purely technical reasons: one for web, one for systems programming,
    one for scripting, and the rest for various niches like AI, workflows, solving
    equations, and so on. Let’s say I’m wrong and we would need 20. However, the reality
    is that we can use hundreds of programming languages today, including mainstream,
    niche, and esoteric languages such as Brainfuck or Whitespace. We can see many
    of them in the TIOBE Programming Community index that monitors the popularity
    of programming languages. Why are there so many?'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的职业生涯后期，我开始思考市场上可用的众多编程语言。据我估计，我们可能需要大约5-7种编程语言，纯粹出于技术原因：一种用于网页开发，一种用于系统编程，一种用于脚本编写，其余的用于各种细分市场，如人工智能、工作流程、解方程等。假设我错了，我们可能需要20种。然而，现实是，今天我们可以使用数百种编程语言，包括主流、细分和古怪的语言，如Brainfuck或Whitespace。我们可以在TIOBE编程社区指数中看到许多这样的语言，该指数监控编程语言的流行度。为什么会有这么多？
- en: 'My best guess is that it’s not a matter of technical needs, but one of culture.
    Sure, the technical aspects are important. Object-oriented and later functional
    programming features were introduced in all mainstream languages. Security, parallelism
    and concurrency, ease of programming, the community, and the ecosystem are all
    important aspects of a programming language. However, the decision to make a new
    programming language comes from people, and the decisions they make when designing
    the language come from their personal preferences. Trends in literature and philosophy
    follow the same pattern: current and counter-current or reactionary. In literature,
    Romanticism was a reaction to Classicism, and realism was a reaction to Romanticism.
    Something similar happens with programming languages: Java was a reaction to C++,
    and Ruby on Rails was a reaction to Java. While in literature, currents are partially
    determined by societal changes, in technology, the currents are determined both
    by the movements in the landscape and the preferences of younger generations of
    programmers, added at a very high pace. An example of the technological landscape
    change is the rise of the internet, which has favored the rise of Java as a reaction
    to C++ for web applications. Interestingly, the movement of computation from server
    to client nowadays seems to favor the apparition of Web Assembly applications
    that currently require low-level programming in C++ or Rust. As for the new generations
    of programmers, Ruby on Rails was very much a reaction to the perceived old-style
    Java language. Rails offered freedoms of expression that Java didn’t, along with
    a feeling of satisfaction with the progress. This feeling had little technical
    basis, but technical aspects aren’t everything for people, not even for software
    developers.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我的最佳猜测是，这不仅仅是一个技术需求的问题，而是一个文化问题。当然，技术方面很重要。面向对象和后来的函数式编程特性被引入到所有主流语言中。安全性、并行性和并发性、编程的易用性、社区和生态系统都是编程语言的重要方面。然而，决定创建一种新的编程语言来自人们，他们在设计语言时所做的决定来自他们的个人偏好。文学和哲学的趋势遵循相同的模式：主流和逆流或反动。在文学中，浪漫主义是对古典主义的反应，现实主义是对浪漫主义的反应。在编程语言中也有类似的情况：Java是对C++的反应，Ruby
    on Rails是对Java的反应。在文学中，主流部分由社会变革决定，而在技术中，主流既由景观中的运动决定，也由年轻一代程序员的偏好决定，这些偏好以非常高的速度增加。技术景观变化的例子是互联网的兴起，这有利于Java作为对C++的回应，用于Web应用程序。有趣的是，计算从服务器到客户端的移动现在似乎有利于Web
    Assembly应用程序的出现，这些应用程序目前需要用C++或Rust进行低级编程。至于新一代程序员，Ruby on Rails在很大程度上是对感知到的旧式Java语言的反应。Rails提供了Java没有的表达自由，以及随着进步而感到的满足感。这种感觉几乎没有技术基础，但技术方面对人们来说并不全是，甚至对软件开发者来说也是如此。
- en: 'You should see now where this is going: Rust is a reaction to C++. It is a
    reaction both to current technical annoyances of C++ and to the ways C++ does
    things. Let’s therefore look at what Rust brings to the table.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该能看出这是怎么回事：Rust是对C++的反应。它是对C++当前技术烦恼的反应，也是对C++做事方式的反应。因此，让我们看看Rust带来了什么。
- en: Core features of Rust
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust的核心特性
- en: 'The first place we can use for understanding Rust’s core features is the official
    website, [https://www.rust-lang.org/](https://www.rust-lang.org/) . The site does
    a very good job of emphasizing the most important features of Rust:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用来理解Rust核心特性的第一个地方是官方网站，[https://www.rust-lang.org/](https://www.rust-lang.org/)。该网站非常出色地强调了Rust最重要的特性：
- en: Fast and memory-efficient
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速且内存高效
- en: No runtime
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无运行时
- en: No garbage collector
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无垃圾回收器
- en: Integrates with other languages
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其他语言集成
- en: Memory safety and thread safety through a rich type system and ownership model
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过丰富的类型系统和所有权模型实现内存安全和线程安全
- en: Great documentation
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优秀的文档
- en: Friendly compiler with useful error messages
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 友好的编译器，带有有用的错误信息
- en: Integrated package manager and build tool
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成软件包管理和构建工具
- en: Auto formatter
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动格式化
- en: Smart multi-editor support with auto-completion and type inspections
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 智能多编辑器支持，包括自动完成和类型检查
- en: 'From this description only, we can already see a few similarities with C++,
    along with improvements on the current state of C++. The similarities are in the
    level of control: native compilation, no garbage collector, speed, and memory
    efficiency are qualities that C++ touts as well. The differences point to things
    that we discussed at length in this book: standard package manager, standard tooling,
    and friendly compiler. This last quality is music to the ears of any C++ programmer
    who got huge error messages; I remember back in the 2000s, I got an error in Visual
    C++ that said something along the lines of “error messages are too long and we
    can’t display them”. While today’s C++ is friendlier, figuring out what didn’t
    work while using templates is still a pain.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 仅从这一描述中，我们就可以看到一些与C++的相似之处，以及C++当前状态的改进。这些相似之处在于控制级别：原生编译、没有垃圾回收器、速度和内存效率是C++也吹嘘的品质。而不同之处则指向我们在本书中详细讨论过的事情：标准包管理器、标准工具和友好的编译器。最后这个品质对于收到大量错误信息的任何C++程序员来说都是美妙的；我记得在2000年代，我在Visual
    C++中遇到了一个错误，错误信息的大致内容是“错误信息太长，我们无法显示它们”。而今天的C++更加友好，但在使用模板时找出哪里出了问题仍然是一件痛苦的事情。
- en: However, let’s look beyond what’s written on the front page of the website.
    We’ll look next at a few features that I selected because I found them very useful
    and interesting compared to C++.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，让我们超越网站首页上所写的内容。接下来，我们将看看一些我认为与C++相比非常有用和有趣的功能。
- en: Project templates and package management
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目模板和包管理
- en: As an avid user of the command line and neovim code editor, I love technologies
    that allow me to create projects directly from the command line. Rust comes with
    the **cargo** tool that allows creating projects, building, running, packaging,
    and publishing. To create a new project, just call **cargo new project-name**
    . You run it with **cargo run** , check that it doesn’t have compile errors with
    **cargo check** , compile it with **cargo build** , package it with – you guessed
    it! – **cargo package** , and publish it with (drum rolls) ... **cargo publish**
    .
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名热衷于使用命令行和neovim代码编辑器的用户，我喜欢那些允许我从命令行直接创建项目的技术。Rust附带了一个**cargo**工具，允许创建项目、构建、运行、打包和发布。要创建一个新的项目，只需调用**cargo
    new project-name**。你可以用**cargo run**运行它，用**cargo check**检查它是否有编译错误，用**cargo build**编译它，用–你猜对了！–**cargo
    package**打包它，并用（敲锣打鼓）...**cargo publish**发布它。
- en: We can, of course, create libraries and executables with **cargo** . More than
    that, we can use the cargo generate tool found at [https://cargo-generate.github.io/cargo-generate/](https://cargo-generate.github.io/cargo-generate/)
    to start from a project template.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当然可以用**cargo**创建库和可执行文件。不仅如此，我们还可以使用位于[https://cargo-generate.github.io/cargo-generate/](https://cargo-generate.github.io/cargo-generate/)的cargo
    generate工具，从项目模板开始。
- en: 'I know this might not look like much to most of the C++ developers out there
    because you rarely create a new project. This has been one of my surprises when
    teaching unit testing or test-driven development to C++ programmers: we had to
    work together to set up a test project with a production project and the corresponding
    references, something I took for granted. Believe me when I say that this is very
    nice to have not only at the beginning of a project but also for small experiments,
    personal or practice code bases, and reducing compilation times. A simple thing
    C++ offers you if your project compiles too slowly is to create a new compilation
    unit formed out of the few files you are modifying and refer to the rest as a
    binary. I used this technique extensively before SSD hard drives sped up compilation
    considerably.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道这对大多数C++开发者来说可能看起来不多，因为你们很少创建新的项目。这是我教C++程序员单元测试或测试驱动开发时的一个惊喜：我们必须共同努力设置一个与生产项目相对应的测试项目以及相应的引用，这是我理所当然的事情。当我说这不仅在项目开始时很有用，而且在小型实验、个人或练习代码库中，以及减少编译时间方面也非常有用时，请相信我。如果你发现项目编译得太慢，C++为你提供的一个简单方法是创建一个新的编译单元，由你正在修改的少数文件组成，并将其余部分作为二进制文件引用。在我使用SSD硬盘大大加快编译速度之前，我广泛地使用了这种技术。
- en: Enough on new projects. Let’s write some code. Let’s modify some variables...
    or maybe not.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 新项目已经足够了。让我们来写一些代码。让我们修改一些变量...或者也许不。
- en: Immutability
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不可变性
- en: 'Rust features immutability by default. The way the documentation puts it is
    *“once a value is bound to a name, you can’t change that value.”* Let’s look at
    a simple example where I assign a string value to a variable, display it, and
    then try to modify it:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 默认使用不可变性。文档中的说法是 *“一旦值绑定到名称，就不能更改该值。”* 让我们看看一个简单的例子，我将一个字符串值赋给一个变量，显示它，然后尝试修改它：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Trying to compile this program results in a **cannot assign twice to immutable
    variable `the_message`** compilation error. Helpfully, the error message includes
    the **For more information about this error, try `rustc –explain E0384`** notice.
    The explanation for the error message contains an example for the error, and a
    very helpful notice on how to make variables mutable:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试编译这个程序会导致 **无法将不可变变量 `the_message` 赋值两次** 的编译错误。幸运的是，错误信息中包含了 **关于此错误的更多信息，请尝试
    `rustc –explain E0384`** 的提示。错误信息的解释包含了一个错误示例，以及如何使变量可变的非常有帮助的提示：
- en: '**"By default, variables in Rust are immutable. To fix this error, add the
    keyword must after the keyword let when declaring** **the variable"**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**"默认情况下，Rust 中的变量是不可变的。要修复此错误，在声明变量时在 let 关键字后添加关键字 must。"**'
- en: 'Following is a code example that, when adapted, makes the program compile:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个代码示例，当进行适配时，可以使程序编译：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, mutable variables must be specified as **mut** , so the default
    is immutability. As we’ve seen in previous chapters, this helps with a lot of
    problems such as parallelism and concurrency, automated testing, and code simplicity.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，可变变量必须指定为 **mut**，因此默认是不可变的。正如我们在前面的章节中看到的，这有助于解决许多问题，例如并行性和并发性、自动化测试以及代码的简洁性。
- en: Simple syntax for compound types
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复合类型的简单语法
- en: 'Rust borrows from languages such as Python or Ruby the syntax for arrays and
    tuples. Here’s what that looks like:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 从像 Python 或 Ruby 这样的语言中借鉴了数组和解构的语法。下面是它的样子：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This might not look like much, but it helps simplify code.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来不多，但它有助于简化代码。
- en: 'It’s worth mentioning here that C++ has introduced a similar syntax in C++
    11 and has improved it in consequent versions, through the list initializer, using
    curly braces:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，C++ 在 C++ 11 中引入了类似的语法，并在后续版本中通过列表初始化和花括号进行了改进：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: I would love to see further improvements on this front, but the C++ syntax is
    already complex, so I don’t expect it.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我很希望看到这方面的进一步改进，但 C++ 的语法已经相当复杂，所以我不期望它会有所改变。
- en: Optional return keyword
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可选的返回关键字
- en: 'Functions in Rust allow the return of the last value in the function. The next
    example uses this construct to increment a number:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 中的函数允许返回函数中的最后一个值。下一个示例使用这个结构来增加一个数字：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: I usually avoid this in functions such as the preceding, but avoiding the **return**
    keyword simplifies closures, as we’ll see next.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我通常避免在前面这样的函数中使用它，但避免使用 **return** 关键字可以简化闭包，正如我们接下来将要看到的。
- en: Closures
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 闭包
- en: 'Let’s increment all elements of a vector:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们增加向量的所有元素：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As usual for functional programming constructs, and similarly to the **ranges**
    library in C++, we need to get an iterator, call the map function – equivalent
    to the transform algorithm in C++ – with a closure, and call **collect** to obtain
    the results. The closure has a very simple syntax, made possible by the optional
    return statement.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于函数式编程结构，就像 C++ 中的 **ranges** 库一样，我们需要获取一个迭代器，调用 map 函数——在 C++ 中相当于转换算法——使用闭包，然后调用
    **collect** 来获取结果。闭包有一个非常简单的语法，这是由可选的返回语句实现的。
- en: Unit tests in Standard Library
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准库中的单元测试
- en: 'Unit testing is a very important practice in software development, and it’s
    surprising that only a few languages offer support for it in the standard library.
    Rust does it by default, and it’s quite easy to use. Let’s add a unit test to
    verify that our **increment_all** function works as expected:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是软件开发中非常重要的实践，令人惊讶的是，只有少数语言在标准库中提供了对它的支持。Rust 默认提供，而且使用起来相当简单。让我们添加一个单元测试来验证我们的
    **increment_all** 函数是否按预期工作：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As a plus, I like that it’s very easy to write unit tests in the same compilation
    unit (called a **crate** in Rust) as the production code. This might not seem
    like much if you see unit tests as an obligation, but I often use unit tests to
    experiment and to design so I love this facility a lot.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个加分项，我喜欢在同一个编译单元（在 Rust 中称为 **crate**）中编写单元测试，就像生产代码一样。如果你把单元测试看作是一项义务，这可能看起来不多，但我不经常使用单元测试来实验和设计，所以我非常喜欢这个功能。
- en: Traits
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特性
- en: A big difference between Rust (or Go) and the other mainstream languages is
    that Rust does not support inheritance, instead favoring composition. To allow
    for polymorphic behavior without inheritance, Rust offers traits.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Rust（或Go）与其他主流语言的一个重大区别是，Rust不支持继承，而是更倾向于组合。为了在不使用继承的情况下实现多态行为，Rust提供了特质。
- en: 'Rust traits are similar to interfaces in object-oriented languages in that
    they define a set of methods that need to be implemented for every object that
    derives from them. However, Rust traits have a specific feature: you can add a
    trait to a type you don’t own. This is similar to extension methods in C#, although
    not the same.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Rust特质在面向对象语言中类似于接口，因为它们定义了一组需要为从它们派生的每个对象实现的方法。然而，Rust特质有一个特定的特性：你可以将特质添加到你并不拥有的类型上。这类似于C#中的扩展方法，尽管并不完全相同。
- en: The Rust documentation provides an example of traits by using two structures,
    one representing a tweet and the other a news article, and adding the **Summary**
    trait to both is meant to create a summary of the corresponding message. As you
    can see in the example that follows, the trait implementation is separate from
    both the structure implementation and the trait definition, which makes it very
    flexible.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Rust文档通过使用两个结构体来举例说明特质，一个代表推文，另一个代表新闻文章，并将**Summary**特质添加到两者中，目的是创建相应消息的摘要。正如以下示例所示，特质的实现与结构体的实现和特质的定义是分开的，这使得它非常灵活。
- en: 'Let’s start by looking at the two structures. First, the **NewsArticle** contains
    a few fields:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看这两个结构体。首先，**NewsArticle**包含了一些字段：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, the **Tweet** structure contains its own fields:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，**Tweet**结构体包含它自己的字段：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Separately, we define the **Summary** trait with a single method summarize
    returning a string:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 独立地，我们定义了一个带有单个方法`summarize`返回字符串的**Summary**特质：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let’s now implement the **Summary** trait for the **Tweet** structure. This
    is done by specifying that the implementation of this trait applies to the structure,
    as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为**Tweet**结构体实现**Summary**特质。这是通过指定这个特质的实现适用于结构体来完成的，如下所示：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The test works perfectly:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 测试工作得非常完美：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, let’s implement the trait for the news article:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们为新闻文章实现这个特质：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Traits in Rust have much more capabilities. We can implement a default behavior,
    specify that the type of a parameter needs to be of one or multiple trait types,
    implement traits generically on multiple types, and so on. In fact, Rust traits
    are a combination of OO interfaces, C# extension methods, and C++ concepts. However,
    this is outside the scope of this chapter. What’s worth remembering is that Rust
    treats inheritance very differently from C++.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Rust中的特质具有更多功能。我们可以实现默认行为，指定参数的类型需要是单个或多个特质类型，在多个类型上泛型实现特质，等等。实际上，Rust特质是OO接口、C#扩展方法和C++概念的组合。然而，这超出了本章的范围。值得记住的是，Rust对继承的处理与C++非常不同。
- en: Ownership model
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 所有权模型
- en: An interesting characteristic of Rust, and perhaps its most advertised feature,
    is the ownership model. This is Rust’s reaction to memory safety issues in C++,
    only instead of going into garbage collectors like Java or C# do, the designers
    have solved the problem with a more explicit ownership of memory. We’ll look at
    a quote from the Rust book ( [https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html
    ):](https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html):)
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Rust的一个有趣特性，也许是最受宣传的特性，就是所有权模型。这是Rust对C++中内存安全问题的一种反应，但与Java或C#中的垃圾收集器不同，设计者通过更明确的内存所有权来解决这个问题。我们将看看Rust书籍中的一段引文（[https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html]）：）
- en: “ *Memory is managed through a system of ownership with a set of rules that
    the compiler checks. If any of the rules are violated, the program won’t compile.
    None of the features of ownership will slow down your program while* *it’s running.*
    ”
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: “*内存通过一套规则进行管理，这些规则由编译器检查。如果违反了任何规则，程序将无法编译。在程序运行期间，所有权的任何特性都不会减慢你的程序速度。*”
- en: 'There are three rules of ownership in Rust:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Rust中有三个所有权规则：
- en: Each value in Rust has an *owner*
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个Rust中的值都有一个*所有者*
- en: There can only be one owner at a time
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一次只能有一个所有者
- en: When the owner goes out of scope, the value will be dropped
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当所有者超出作用域时，值将被丢弃
- en: 'Let’s first look at an example that works the same as in C++. If we have a
    variable allocated on the stack, such as an integer, then copying the variable
    works in a very familiar way:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看看一个与C++中相同工作的示例。如果我们有一个在栈上分配的变量，比如一个整数，那么复制变量将以非常熟悉的方式工作：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Both variables have the same value, as expected. However, if we try the same
    code with a variable allocated on the heap, we get an error:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 两个变量具有相同的值，正如预期的那样。然而，如果我们尝试用堆上分配的变量执行相同的代码，我们会得到一个错误：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When running this, we get the **error[E0382]: borrow of moved value: `heap_value`**
    error. What happens?'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '当运行这个程序时，我们得到**错误[E0382]: borrow of moved value: `heap_value`**错误。发生了什么？'
- en: 'Well, when we assign the value of **heap_value** to **copied_heap_value** ,
    the **heap_value** variable is invalidated. This behaves the same as the move
    semantics in C++, only without any additional work from the programmer. Behind
    the scenes, this works through the use of two traits: **Copy** and **Drop** .
    If a type implements the **Copy** trait then it works as in the first example,
    while if it implements the **Drop** trait then it works as in the second. No type
    can implement both traits.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，当我们将**heap_value**的值赋给**copied_heap_value**时，**heap_value**变量就失效了。这和C++中的移动语义行为相同，只是程序员不需要做任何额外的工作。在幕后，这是通过使用两个特质：**Copy**和**Drop**来实现的。如果一个类型实现了**Copy**特质，那么它就像第一个示例中那样工作，而如果一个类型实现了**Drop**特质，那么它就像第二个示例中那样工作。没有类型可以同时实现这两个特质。
- en: 'To make the above example work, we need to clone the value instead of using
    the default move mechanism:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使上述示例工作，我们需要克隆值而不是使用默认的移动机制：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This example works fine, so the value is cloned. This indicates, however, a
    new allocation on the heap, not a reference to the same value.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例工作得很好，所以值被克隆了。然而，这表明这是一个新的堆分配，而不是对相同值的引用。
- en: 'The move semantics work the same for function calls. Let’s initialize a value
    and pass it to a function that returns it unchanged to see what happens:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 移动语义对于函数调用也是相同的。让我们初始化一个值并将其传递给一个返回它未更改的函数，看看会发生什么：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When trying to compile this code, we get the same error as before: **error[E0382]:
    borrow of moved value: `heap_value`** . The value is created on the heap, moved
    into the **call_me** function, and therefore dropped from the current scope. We
    can make this code work by specifying that the function called should only borrow
    the ownership instead of taking it over. This is done through the use of reference
    and dereference operators, which are the same as in C++:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '当尝试编译这段代码时，我们得到与之前相同的错误：**错误[E0382]: borrow of moved value: `heap_value`**。值是在堆上创建的，移动到**call_me**函数中，因此从当前作用域中删除。我们可以通过指定被调用的函数应该只借用所有权而不是接管它来使这段代码工作。这是通过使用引用和解除引用运算符来实现的，这与C++中的相同：'
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The important difference between C++ references and Rust references is that
    Rust references are immutable by default.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: C++引用和Rust引用之间的重要区别是，Rust引用默认是不可变的。
- en: There is, of course, a lot more to learn about the ownership model in Rust,
    but I believe this is enough to give you a taste of how it works and how it’s
    meant to prevent memory safety issues.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，关于Rust中的所有权模型还有很多东西要学习，但我相信这已经足够让你了解它是如何工作的，以及它是如何旨在防止内存安全问题的。
- en: Rust’s advantages
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust的优势
- en: To summarize, Rust has a few advantages over C++. By being a newer language,
    it has the advantage of learning from its predecessors and using the best patterns
    available. I find the combination of immutability with the ownership model to
    be very good at code that works well by default. It might take a bit to learn
    since it’s not the typical memory management style, but once you understand how
    to use it, it allows you to write code that works without much challenge.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，Rust相对于C++有一些优势。作为一个较新的语言，它有从其前辈学习并使用最佳模式的优势。我发现将不可变性与所有权模型结合起来，对于默认工作良好的代码来说非常好。由于它不是典型的内存管理风格，所以学习起来可能需要一点时间，但一旦你了解了如何使用它，它就允许你编写几乎无挑战性的代码。
- en: The unit testing support in the standard library, the package manager, and the
    multi-editor support should be part of any modern programming language. The syntax
    is nicer when it comes to closures and compound types.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中的单元测试支持、包管理器和多编辑器支持应该是任何现代编程语言的一部分。当涉及到闭包和复合类型时，语法更优雅。
- en: 'We might wonder at this point: does C++ stand a chance? Why and where?'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们可能会想：C++有机会吗？为什么，在哪里？
- en: Where C++ is better
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++的优势在哪里
- en: 'C++ is a very capable, advanced programming language, under continuous improvement.
    The language is progressing quite fast. It’s very difficult to equal the C++ ecosystem:
    its community, the staggering number of libraries and frameworks available, and
    the articles, blogs, and books that teach you how to use C++ in various ways for
    any possible problem you might have. For all its benefits, Rust is a young language
    compared to C++, which should give you pause when considering the choice of technology
    for systems programming. However, Rust has been adopted for subsystems of Linux
    and Android, so it proves itself a worthy competitor.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: C++是一种非常强大、先进的编程语言，正在不断改进。语言进步很快。很难与C++生态系统相提并论：其社区、可用的库和框架数量惊人，以及教你如何以各种方式使用C++解决任何可能问题的文章、博客和书籍。尽管有这些好处，与C++相比，Rust是一种较新的语言，这在考虑系统编程技术选择时应该让你三思。然而，Rust已被用于Linux和Android的子系统，这证明了它是一个值得尊敬的竞争对手。
- en: The C++ standardization committee has shown a continuous focus on simplifying
    syntax and reducing the mental burden of programmers for various code constructs.
    Part of the effort comes from the competition, with many of the features introduced
    in C++17 and later being an answer to the Rust design choices. While I don’t expect
    C++’s syntax to evolve to be as simple as Rust, the other factors mentioned here
    must contribute to the choice just as much, if not more.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准化委员会一直致力于简化语法和减轻程序员在处理各种代码结构时的心理负担。部分努力源于竞争，许多在C++17及以后版本中引入的特性是对Rust设计选择的回应。虽然我不期望C++的语法会像Rust那样简单，但这里提到的其他因素也必须对选择产生同样甚至更大的影响。
- en: What C++ still needs
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++仍需改进之处
- en: In this book, we have seen some of the challenges of C++. A standard package
    manager would be very helpful, even if the community follows in the footsteps
    of Java and C# and picks an open source de-facto standard. A standard unit testing
    library would be very beneficial, even if the existing code might take a long
    while to migrate if it ever does.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们看到了C++的一些挑战。一个标准的包管理器将非常有帮助，即使社区效仿Java和C#，选择一个开源的既定标准。一个标准的单元测试库将非常有益，即使现有的代码可能需要很长时间才能迁移，如果它真的迁移了的话。
- en: Unicode and utf-8 support still need improvement. Standard support for multithreading
    is at the beginning. Safety profiles would be extremely useful for minimizing
    memory safety issues.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode和utf-8的支持仍需改进。标准的多线程支持才刚刚开始。安全配置文件将非常有助于最小化内存安全问题。
- en: It’s clear from this list that C++ has a lot of things to improve. The good
    news is that the standardization committee is hard at work on some of these issues.
    The less good news is that it takes time to define these improvements, more time
    to adapt compilers, and even more time to adapt existing code. Hopefully, Gen
    AI will be capable enough to speed up these improvements while maintaining code
    integrity.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 从这份清单中可以看出，C++有很多需要改进的地方。好消息是标准化委员会正在努力解决这些问题。不那么好的消息是，定义这些改进需要时间，适应编译器需要更多时间，适应现有代码则需要更多时间。希望通用人工智能能够足够强大，以加快这些改进的速度，同时保持代码的完整性。
- en: Summary
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We saw, in this chapter, that Rust is a very interesting language, whose designers
    knew to take advantage of the knowledge gathered by their predecessors and to
    innovate in the right places. The result is a nice syntax, a more natural way
    to deal with memory without using a garbage collector, and an overall modern development
    experience. We explored this in this chapter.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了Rust是一个非常有趣的编程语言，其设计者知道如何利用前辈们积累的知识，并在正确的地方进行创新。结果是语法简洁，处理内存的方式更自然，无需使用垃圾回收器，整体开发体验现代化。我们在这章中探讨了这一点。
- en: However, C++ is hard to compete with. The sheer number of libraries, frameworks,
    blogs, articles, code examples, books, and experience available in the world on
    C++ is impossible to equal in a short time. Rust has found its niches in Web Assembly
    applications and various tools, but it’s far from replacing C++.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，C++很难与之竞争。世界上关于C++的库、框架、博客、文章、代码示例、书籍和经验数量庞大，短时间内无法匹敌。Rust在Web Assembly应用和各种工具中找到了自己的
    niche，但它还远未取代C++。
- en: Still, we have to remember that languages are not necessarily picked based on
    technical reasons and that cultural reasons matter as well. Newer generations
    of programmers might enjoy Rust much more than C++, and with the NSA and the White
    House leading the focus on memory-safe languages, Rust might gain ground for newer
    projects.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们还得记住，语言的选择并不一定基于技术原因，文化因素也同样重要。新一代的程序员可能比C++更喜欢Rust，而且随着国家安全局和白宫将焦点放在内存安全语言上，Rust可能在新的项目中获得优势。
- en: 'The conclusion? It’s hard to predict the future, but we can imagine how Rust
    could take over. The way I see it, it would require four factors: Rust is preferred
    by more and more programmers, it is required by regulation, C++ fails to evolve
    on memory safety fast enough, and generative AI gets good enough at translating
    from C++ to Rust.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 结论是什么？预测未来很难，但我们可以想象Rust如何接管。在我看来，这需要四个因素：越来越多的程序员选择Rust，它受到法规的要求，C++在内存安全方面的进化速度不够快，以及生成式AI在将C++转换为Rust方面变得足够好。
- en: So, there’s a chance, but I think it’s safe to say that it’s over 50% that C++
    is here to stay at least for another decade.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，存在机会，但我认为可以安全地说，至少在未来十年内，C++还将继续存在。
