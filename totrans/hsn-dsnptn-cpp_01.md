# 1

# 继承和多态简介

**C++**首先是一种面向对象的语言，对象是 C++程序的基本构建块。类层次结构用于表达软件系统不同部分之间的关系和交互，定义和实现组件之间的接口，以及组织和代码。虽然这不是一本专门教授 C++的书，但本章的目的是让读者对与类和继承相关的 C++语言特性有足够的了解，这些特性将在后面的章节中使用。为此，我们不会试图完全描述用于处理类的 C++工具，而是介绍本书中将使用的概念和语言结构。

本章将涵盖以下主题：

+   什么是类以及它们在 C++中的作用？

+   什么是类层次结构以及 C++是如何使用继承的？

+   运行时多态是什么以及如何在 C++中使用它？

# 类和对象

面向对象编程是一种通过将算法及其操作的数据组合成单个实体（称为**对象**）来结构化程序的方法。大多数面向对象的语言，包括 C++，都是基于类的。**类**是对对象的定义——它描述了算法和数据，其格式以及与其他类的关系。对象是类的具体实例化，即变量。对象有一个地址，它是内存中的一个位置。类是用户定义的类型。一般来说，可以从类提供的定义中实例化任意数量的对象（有些类限制了可以创建的对象数量，但这是一种例外，而不是常态）。

在 C++中，类中包含的数据被组织为不同类型的数据成员或变量的集合。算法通过函数实现——类的成员方法。虽然没有语言要求类中的数据成员必须以某种方式与方法的实现相关，但当数据在类中得到良好的封装，并且方法与外部数据的交互有限时，这是良好设计的一个标志。

这种**封装**的概念是 C++ 中类的基础——该语言允许我们控制哪些数据成员和方法是公共的——在类外可见，哪些是内部的——私有的。一个设计良好的类主要或只有私有数据成员，唯一的公共方法是需要表达类的公共接口的方法——换句话说，类做什么。这个公共接口就像一份合同——类的设计者承诺这个类提供某些特性和操作。类的私有数据和方法是实现的一部分，只要公共接口，我们承诺的合同保持有效，它们就可以被更改。例如，以下类表示一个有理数并支持增量操作，如其公共接口所公开的：

```cpp
class Rational { public:
  Rational& operator+=(const Rational& rhs);
};
```

一个设计良好的类不会通过其公共接口暴露比它必须暴露的更多实现细节。实现不是合同的一部分，尽管文档化的接口可能对它施加一些限制。例如，如果我们承诺所有有理数在分子和分母中不包含任何公共的乘数，那么加法应该包括取消这些乘数的步骤。这将是一个很好的使用私有成员函数的例子——实现其他几个操作将需要调用它，但类的客户端永远不需要调用它，因为每个有理数在暴露给调用者之前都已经化简到最简形式：

```cpp
class Rational {
  public:
  Rational& operator+=(const Rational& rhs); private:
  long n_; // numerator
  long d_; // denominator
  void  reduce();
};
Rational& Rational::operator+=(const Rational& rhs) {
  n_ = n_*rhs.d_ + rhs.n_*d_;
  d_ = d_*rhs.d_; reduce();
  return *this;
}
Rational a, b; a += b;
```

类方法可以特殊访问数据成员——它们可以访问类的私有数据。注意这里类和对象的区别——`operator+=()` 是 `Rational` 类的方法，并在对象 `a` 上调用。然而，它也可以访问 `b` 对象的私有数据，因为 `a` 和 `b` 是同一类的对象。如果一个成员函数通过名称引用类成员而没有任何额外的限定符，那么它是在访问它所调用的同一类的成员（我们可以通过写入 `this->n_` 和 `this->d_` 来使其更明确）。访问同一类中另一个对象的成员需要一个指向该对象的指针或引用，但除此之外没有其他限制，就像我们尝试从一个非成员函数访问私有数据成员时的情况一样。

顺便说一下，C++ 也支持 C 风格的结构体。但在 C++ 中，结构体不仅仅是一个数据成员的聚合——它可以有方法、公有和私有访问修饰符，以及类具有的一切。从语言的角度来看，类和结构体之间的唯一区别是默认访问——在类中，所有成员和方法默认为私有，而在结构体中它们是公有的。除此之外，使用结构体而不是类是一个约定问题——传统上，结构体用于 C 风格的结构体（在 C 中合法的结构体）以及*几乎*是 C 风格的结构体，例如，只添加了构造函数的结构体。当然，这个边界并不精确，是每个项目或团队编码风格和实践的问题。

除了我们看到的 方法和数据成员之外，C++ 还支持静态数据和静态方法。静态方法与常规的非成员函数非常相似——它不会在特定的对象上调用，它能够访问任何类型的对象的方式只有通过其参数。然而，与非成员函数不同，静态方法保留了其对类私有数据的特权访问。

类本身是一种将算法和它们操作的数据（封装）在一起的有用方式，并限制对某些数据的访问。然而，C++ 最强大的面向对象特性是继承和由此产生的类层次。

# 继承和类层次

C++ 中的类层次具有双重作用。一方面，它们允许我们表达对象之间的关系。另一方面，它们使我们能够从更简单的类型组合出更复杂的类型。这两种用途都是通过继承实现的。

继承的概念是 C++ 中类和对象使用的关键。继承使我们能够将新类定义为现有类的扩展。当一个派生类从基类继承时，它以某种形式包含了基类中的所有数据和算法，并添加了一些自己的。在 C++ 中，区分两种主要的继承类型——公有继承和私有继承——非常重要。

公有继承继承了类的公共接口。它也继承了实现——基类的数据成员也是派生类的一部分。但接口的继承是区分公有继承的关键——派生类作为其公共接口的一部分，包含了基类的公共成员函数。

记住，公共接口就像一份契约——我们向类的客户端承诺它支持某些操作，维护某些不变性，并遵守指定的限制。通过从基类公开继承，我们将派生类绑定到相同的契约（以及如果我们决定定义额外的公共接口，契约的任何扩展）。因为派生类也尊重基类的接口契约，所以我们可以将派生类用于代码中任何期望基类的地方——我们无法使用接口的任何扩展（代码期望基类，我们不知道在那个点有任何扩展），但基类接口及其限制必须是有效的。

这通常被表达为“is-a 原则”——派生类的实例也是基类的实例。然而，我们在 C++中对“is-a”关系的解释并不完全直观。例如，正方形是矩形吗？如果是的话，那么我们可以从`Rectangle`类派生出`Square`类：

```cpp
class Rectangle {
  public:
  double Length() const { return length_; }
  double Width() const { return width_; }
  ...
  private:
  double l_;
  double w_;
};
class Square : public Rectangle {
  ...
};
```

立刻就有一些事情看起来不对——派生类有两个表示尺寸的数据成员，但实际上只需要一个。我们必须以某种方式强制它们始终相同。这看起来并不那么糟糕——`Rectangle`类有一个接口，允许长度和宽度的任何正值，而`Square`施加了额外的限制。但问题更严重——`Rectangle`类有一个允许用户使尺寸不同的契约。这可以非常明确：

```cpp
class Rectangle {
  public:
  void Scale(double sl, double sw) {
     // Scale the dimensions
    length_ *= sl;
    width_ *= sw;
  }
  ...
};
```

现在，我们有一个公共方法，允许我们扭曲矩形，改变其宽高比。与其他任何公共方法一样，它被派生类继承，所以现在`Square`类也有这个方法。实际上，通过使用公共继承，我们断言一个`Square`对象可以在任何需要`Rectangle`对象的地方使用，即使不知道它实际上是一个`Square`。显然，这是一个我们无法兑现的承诺——当我们的类层次结构的客户端试图改变正方形的宽高比时，我们无法做到。我们可以忽略这个调用或在运行时报告错误。无论如何，我们都违反了基类提供的契约。唯一的解决方案是——在 C++中，正方形不是矩形。注意，矩形通常也不是正方形——`Square`接口提供的契约可能包含任何我们无法维持的保证，如果我们从`Square`派生出`Rectangle`类。

类似地，在 C++中，如果鸟类接口包括飞行，那么企鹅不是鸟类。对于这种情况的正确设计通常包括一个更抽象的基类`Bird`，它不做出任何承诺，即至少有一个派生类无法保持（例如，`Bird`对象不保证它可以飞行）。然后，我们创建基于中间类的类，例如`FlyingBird`和`FlightlessBird`，这些类是从公共基类派生出来的，并作为更具体类（如`Eagle`或`Penguin`）的基类。这里的重要教训是，企鹅在 C++中是否是鸟类取决于我们如何定义鸟类，或者用 C++术语来说，`Bird`类的公共接口是什么。

由于公有继承隐含了`is-a`关系，语言允许在同一层次结构中不同类的引用和指针之间进行广泛的转换。首先，从派生类指针到基类指针的转换是隐式的（这同样适用于引用）：

```cpp
class Base { ... };
class Derived : public Base { ... };
Derived* d = new Derived;
Base* b = d;    // Implicit conversion
```

这种转换始终有效，因为派生类的实例也是基类的实例。逆转换是可能的，但必须明确进行：

```cpp
Base* b = new Derived;     // *b is really Derived
Derived* d = b; // Does not compile, not implicit Derived*
Derived* d1 =
     static_cast<Derived*>(b);    // Explicit conversion
```

这个转换不是隐式的，因为只有在基类指针确实指向一个派生对象时才是有效的（否则行为是未定义的）。因此，程序员必须显式地断言，通过程序的逻辑、先前的测试或其他方式，已知这种转换是有效的。如果你不确定转换是否有效，有一种更安全的方法来尝试它而不会导致未定义的行为；我们将在下一节中了解这一点。

注意，基类和派生类指针之间的静态（或隐式）转换并不像你想象的那么简单。任何对象的第一个基类始终具有与派生对象本身相同的地址，但之后事情就变得复杂了。对于具有多个基类的派生类的内存布局通常没有标准要求：

```cpp
class Base1 { ... };
class Base2 { ... };
class Derived : public Base1, public Base2 { ... };
```

大多数编译器会首先布局基类，然后是派生类的数据成员：

![](img/Figure_1.1_B19262.jpg)

图 1.1 – 派生类的可能内存布局

从**图 1.1**可以看出，基类和派生类之间的指针转换通常涉及偏移量计算。我们可以在一个例子中轻松地看到这一点：

```cpp
// Example 01_cast.C
Derived d;
Derived* p = &d;
std::cout << "Derived: " << (void*)(p) <<
  " Base1: " << (void*)(static_cast<Base1*>(p)) <<
  " Base2: " << (void*)(static_cast<Base2*>(p)) <<
  std::endl;
```

程序会打印出类似以下内容：

```cpp
Derived: 0x7f97e550 Base1: 0x7f97e550 Base2: 0x7f97e560
```

你可以看到 `Base1` 对象位于与 `Derived` 对象相同的地址，而 `Base2` 从一个偏移量（在我们的例子中是 16 字节）开始。看起来类型转换是一个简单的计算：如果你有一个指向 `Derived` 的指针，并且想要转换到 `Base2`，就加 16。基类之间的偏移量在编译时是已知的，编译器知道它使用的布局。指针偏移量计算通常在硬件中实现（所有现代 CPU 都支持它们，并且不需要单独的加法指令）。这听起来并不那么困难。

现在，如果指针是 `null`，你会怎么做？指针的值为 0。如果你应用相同的 *转换*，你会得到 `16 (0x10)`，现在你的 `null` 检查失败了：

```cpp
void f(Base2* p) {
  if (p != nullptr) do_work(*p);
}
Derived* p = nullptr;
f(p); // Will it try to dereference 0x10?
```

显然，这会很糟糕，因此我们可以假设 `null` 指针仍然保持原样。确实如此：

```cpp
Derived* p = nullptr;
std::cout << "Derived: " << (void*)(p) <<
  " Base1: " << (void*)(static_cast<Base1*>(p)) <<
  " Base2: " << (void*)(static_cast<Base2*>(p)) <<
  std::endl;
```

这会为所有指针打印相同的值：

```cpp
Derived: 0x0 Base1: 0x0 Base2: 0x0
```

这是进行类型转换的唯一方法，但它意味着从 `Derived*` 到 `Base*` 的简单隐式转换隐藏在一个带有 `null` 指针检查的条件计算中。

C++ 中的另一种继承类型是 **私有继承**。当私有继承时，派生类不会扩展基类的公共接口——所有基类方法在派生类中都变为私有。任何公共接口都必须由派生类创建，从一张白纸开始。没有假设派生类的对象可以替代基类的对象。派生类从基类获得的是实现细节——方法和数据成员都可以由派生类用来实现自己的算法。因此，可以说私有继承实现了 *has-a* 关系——派生对象在其内部包含基类的一个实例。

因此，私有派生类与其基类之间的关系类似于类与其数据成员之间的关系。后者实现技术被称为 `using` 声明：

```cpp
class Container : private std::vector<int> {
  public:
  using std::vector<int>::size;
  ...
};
```

这种方法在罕见情况下可能很有用，但它也相当于一个内联转发函数：

```cpp
class Container {
  private:
  std::vector<int> v_;
  public:
  size_t size() const { return v_.size(); }
  ...
};
```

其次，派生对象的指针或引用可以转换为基对象的指针或引用，但仅限于派生类成员函数内部。同样，组合的等效功能是通过取数据成员的地址来提供的。到目前为止，我们还没有看到使用私有继承的好理由，确实，常见的建议是优先考虑组合。但接下来的两个理由更为重要，任何一个都可能是使用私有继承的动机。

使用私有继承的一个好理由与组合或派生对象的大小有关。基类只提供方法而不提供数据成员的情况并不少见。这样的类没有自己的数据，因此不应该占用任何内存。但在 C++中，它们必须被赋予一个非零的大小。这与任何两个不同的对象或变量都必须有不同的唯一地址的要求有关。通常，如果我们连续声明两个变量，第二个变量的地址将是第一个变量的地址加上第一个变量的大小：

```cpp
int x;     // Created at address 0xffff0000, size is 4
int y;     // Created at address 0xffff0004
```

为了避免需要以不同的方式处理零大小对象，C++ 将空对象的大小分配为 1。如果这样的对象被用作类的数据成员，它至少占用 1 个字节（下一个数据成员的对齐要求可能会增加这个值）。这是浪费的内存；它永远不会被用于任何事情。另一方面，如果空类被用作基类，没有要求对象的部分必须有非零的大小。派生类的整个对象必须有非零的大小，但派生对象的地址、其基对象和其第一个数据成员都可以在同一个地址。因此，在 C++中，即使 `sizeof()` 返回 1，也可以为空基类分配零内存。虽然这是合法的，但这种空基类优化不是必需的，并且被认为是一种优化。尽管如此，大多数现代编译器都会进行这种优化：

```cpp
class Empty {
  public:
  void useful_function();
};
class Derived : private Empty {
  int i;
};    // sizeof(Derived) == 4
class Composed {
  int i;
  Empty e;
};    // sizeof(Composed) == 8
```

如果我们创建许多派生对象，空基优化可以节省显著的内存。

使用私有继承的第二个理由与虚函数有关，这将在下一节中解释。

# 多态性和虚函数

当我们之前讨论公有继承时，我们提到派生对象可以在任何期望基对象的地方使用。即使有这个要求，了解对象的实际类型通常很有用——换句话说，对象被创建的类型：

```cpp
Derived d;
Base& b = d;
...
b.some_method(); // b is really a Derived object
```

`some_method()` 是 `Base` 类公共接口的一部分，并且对于 `Derived` 类也必须有效。但是，在基类接口合同允许的灵活性内，它可以执行不同的操作。作为一个例子，我们之前已经使用鸟类层次结构来表示不同的鸟类，特别是会飞的鸟类。可以假设 `FlyingBird` 类有一个 `fly()` 方法，并且从它派生出的每个特定鸟类类都必须支持飞行。但是老鹰和秃鹫的飞行方式不同，因此 `Eagle` 和 `Vulture` 两个派生类中 `fly()` 方法的实现可以不同。任何操作任意 `FlyingBird` 对象的代码都可以调用 `fly()` 方法，但结果将取决于对象的实际类型。

这种功能在 C++中是通过虚函数实现的。必须在一个基类中声明虚公有函数：

```cpp
class FlyingBird : public Bird {
  public:
  virtual void fly(double speed, double direction) {
    ... move the bird at the specified speed
        in the given direction ...
  }
  ...
};
```

派生类继承了该函数的声明和实现。必须遵守声明及其提供的契约。如果实现满足派生类的需求，则无需做任何事情。但如果派生类需要更改实现，它可以覆盖基类的实现：

```cpp
class Vulture : public FlyingBird {
  public:
  virtual void fly(double speed, double direction) {
    ... move the bird but accumulate
        exhaustion if too fast ...
  }
};
```

注意，当在派生类中使用关键字`virtual`来覆盖基类虚函数的方法时，这是完全可选的，并且没有任何效果；我们稍后会看到省略它的原因。

当调用虚函数时，C++运行时系统必须确定对象的实际类型。通常，这种信息在编译时并不为人所知，必须在运行时确定：

```cpp
void hunt(FlyingBird& b) {
  b.fly(...);    // Could be Vulture or Eagle
  ...
};
Eagle e;
hunt(e);   // Now b in hunt() is Eagle
           // FlyingBird::fly() is called
Vulture v;
hunt(v);   // Now b in hunt() is Vulture
           // Vulture::fly() is called
```

一种编程技术，其中某些代码可以作用于任意数量的基类对象，并调用相同的方法，但结果取决于这些对象的实际类型，这种技术被称为**运行时多态**，支持这种技术的对象被称为**多态**。在 C++中，多态对象必须至少有一个虚函数，并且只有它们接口中使用虚函数实现的部分才是多态的。

从这个解释中应该很明显，虚函数的声明及其重写应该是相同的——程序员在基类对象上调用该函数，但运行的是派生类中实现的版本。这只有在两个函数具有相同的参数和返回类型的情况下才会发生。一个例外是，如果基类中的虚函数返回某种类型的指针或对该类型的对象的引用，则重写可以返回对该类型派生对象的指针或对该类型派生对象的引用（这被称为**协变****返回类型**）。

多态层次结构的一个非常常见的特殊情况是基类没有好的**默认**虚函数实现。例如，所有飞行的鸟都会飞，但它们的飞行速度各不相同，因此没有必要选择一个速度作为默认值。在 C++中，我们可以拒绝在基类中为虚函数提供任何实现。

这样的函数被称为**纯虚函数**，任何包含纯虚函数的基类都被称为**抽象类**：

```cpp
class FlyingBird {
  public:
  virtual void fly(...) = 0;     // Pure virtual function
};
```

抽象类仅定义了一个接口；具体派生类的任务是实现它。如果基类包含一个纯虚函数，程序中实例化的每个派生类都必须提供实现。换句话说，不能创建基类对象（派生类也可以是抽象类，但那时也不能直接实例化，我们必须从它派生另一个类）。然而，我们可以有一个指向基类对象的指针或引用——它们实际上指向派生类，但我们可以通过基类接口来操作它。

关于 C++语法的几点说明——在重写虚函数时，不需要重复`virtual`关键字。如果基类声明了一个具有相同名称和参数的虚函数，派生类中的函数将始终是虚函数，并覆盖基类中的函数。注意，如果参数不同，派生类函数不会覆盖任何内容，而是会隐藏基类函数的名称。这可能导致程序员意图覆盖基类函数但未正确复制声明的微妙错误：

```cpp
class Eagle : public FlyingBird {
  public:
  void fly(int speed, double direction);
};
```

在这里，参数的类型略有不同。`Eagle::fly()`函数也是虚函数，但它没有覆盖`FlyingBird::fly()`。如果后者是一个纯虚函数，错误将被捕获，因为每个纯虚函数都必须在派生类中实现。但如果`FlyingBird::fly()`有默认实现，那么错误将不会被编译器检测到。C++11 提供了一个非常有用的功能，可以极大地简化查找此类错误——任何打算覆盖基类虚函数的函数都可以使用`override`关键字声明：

```cpp
class Eagle : public FlyingBird {
  public:
  void fly(int speed, double direction) override;
};
```

`virtual`关键字仍然是可选的，但如果`FlyingBird`类没有我们可以用此声明覆盖的虚函数，则此代码无法编译。

还可以通过将虚函数声明为`final`来防止派生类覆盖虚函数：

```cpp
class Eagle : public FlyingBird {
  public:
  // All Eagles fly the same way, derived classes BaldEagle
  // and GoldenEagle cannot change this.
  void fly(int speed, double direction) final;
};
```

注意，使用`final`关键字的情况很少：通常情况下，设计不需要从这一点开始禁用层次结构中的自定义设置。`final`关键字也可以应用于整个类：这意味着不能从这个类派生出更多的类。同样，这也是一种罕见的情况。

那么，是否应该在覆盖时使用`virtual`关键字呢？这是一个风格问题，但风格会影响代码的可读性和可维护性。以下是一种推荐的做法：

+   任何不覆盖基类中函数的虚函数都必须使用`virtual`关键字。这包括没有基类的类中的函数和在派生类中添加的函数。

+   任何其他虚拟函数都不应该使用 `virtual` 关键字。所有覆盖都应该使用 `override` 关键字，以下例外除外，这也是另一条规则。

+   最终覆盖必须使用 `final` 关键字，并且不应该使用 `override` 关键字。

这种方法有两个优点。第一个是清晰度和可读性：如果你看到 `virtual`，这是一个没有覆盖任何内容的虚拟函数。如果你看到 `override`，这必须是一个覆盖（否则代码将无法编译）。如果你看到 `final`，这也是一个覆盖（否则代码将无法编译），并且是层次结构中的最后一个。第二个优点在代码维护期间显现出来。维护层次结构最大的问题之一是基类脆弱性：你编写了一组基类和派生类，其他人随后向基类函数添加了一个参数，突然间，所有派生类函数都没有覆盖基类函数，并且永远不会被调用。通过一致地使用 `override` 关键字，这种情况不会发生。

虚拟函数最常见的使用是在使用公共继承的层次结构中——因为每个派生对象也是一个基类对象（*is-a* 关系），程序通常可以像处理同一类型的对象集合一样处理派生对象集合，而虚拟函数覆盖确保对每个对象都执行正确的处理：

```cpp
void MakeLoudBoom(std::vector<FlyingBird*> birds)
  for (auto bird : birds) {
    bird->fly(...);   // Same action, different results
  }
}
```

但虚拟函数也可以与私有继承一起使用。这种用法不太直接（并且远不如公共继承常见）——毕竟，通过私有继承派生的对象无法通过基类指针访问（私有基类被称为**不可访问基类**，尝试将派生类指针强制转换为基类指针将失败）。然而，有一种情况下这种转换是被允许的，那就是在派生类的成员函数内部。那么，从私有继承的基类到派生类的虚拟函数调用可以这样安排：

```cpp
class Base {
  public:
  virtual void f() {
      std::cout << "Base::f()" << std::endl;
    }
  void g() { f(); }
};
class Derived : private Base {
  public:
  virtual void f() {
    std::cout << "Derived::f()" << std::endl;
  }
  void h() { g(); }
};
Derived d;
d.h(); // Prints "Derived::f()"
```

`Base` 类的公共方法在 `Derived` 类中变为私有，因此我们无法直接调用它们。然而，我们可以从 `Derived` 类的另一个方法中调用它们，例如公共方法 `h()`。然后我们可以直接从 `h()` 中调用 `f()`，但这并不能证明什么——如果 `Derived::h()` 调用了 `Derived::f()`，这并不会让人感到惊讶。

相反，我们调用从 `Base` 类继承的 `Base::g()` 函数。在该函数内部，我们处于 `Base` 类中——这个函数的主体可能是在 `Derived` 类实现之前编写和编译的。然而，在这个上下文中，虚拟函数覆盖仍然可以正确工作，并且会调用 `Derived::f()`，就像继承是公共的一样。

在上一节中，我们建议，除非有其他原因，否则优先使用组合而不是私有继承。没有好的方法使用组合来实现类似的功能；因此，如果需要虚函数行为，私有继承是唯一的选择。

具有虚方法的类必须将其类型编码到每个对象中——这是在运行时知道对象在构造时的类型，在我们将指针转换为基类指针并丢失任何其他原始类型信息之后的唯一方法。这种类型信息不是免费的；它需要空间——多态对象总是比具有相同数据成员但没有虚函数的对象大（通常是一个指针的大小）。

额外的空间大小并不取决于类有多少个虚函数——只要有一个，类型信息就必须编码在对象中。现在，回想一下，基类指针可以被转换为派生类指针，但前提是我们知道派生类的正确类型。使用静态转换，我们无法测试我们的知识是否正确。对于非多态类（没有虚函数的类），没有更好的方法；一旦它们的原始类型丢失，就无法恢复。但对于多态对象，类型信息编码在对象中，因此必须有一种方法来使用这些信息来检查我们的假设是否正确，即这个派生对象的真实类型是什么。确实，有一种方法。它由动态转换提供：

```cpp
class Base { ... };
class Derived : public Base { ... };
Base* b1 = new Derived;     // Really Derived
Base* b2 = new Base;   // Not Derived
Derived* d1 = dynamic_cast<Derived*>(b1);  // Succeeds
Derived* d2 = dynamic_cast<Derived*>(b2);  // d2 == nullptr
```

动态转换不会告诉我们对象的真正类型；相反，它允许我们提出问题——这个对象的真正类型是`Derived`吗？如果我们的类型猜测正确，转换成功并返回派生对象的指针。如果真实类型是其他类型，转换失败并返回一个`null`指针。动态转换也可以与引用一起使用，效果相似，但有一个例外——没有`null`引用。返回引用的函数必须始终返回对某个有效对象的引用。由于动态转换无法在请求的类型与实际类型不匹配时返回对有效对象的引用，唯一的替代方案是抛出异常。

对于注重性能的代码，了解动态转换的运行时成本非常重要。天真地认为，虚拟函数调用和动态转换花费的时间差不多：两者都归结为同一个问题——这个指向`Base`的指针是否真的是指向`Derived`的指针？一个简单的基准测试表明并非如此：

```cpp
// Example 02_dynamic_cast.C
class Base {
  protected:
  int i = 0;
  public:
  virtual ~Base() {}
  virtual int f() { return ++i; }
};
class Derived : public Base {
  int f() override { return --i; }
};
Derived* p = new Derived;
// Measure the runtime of p->f();
// Measure the runtime of dynamic_cast<Derived*>(p);
```

基准结果应该看起来像这样（绝对数值将取决于硬件）：虚函数调用为 1 纳秒，动态转换为 5 到 10 纳秒。为什么动态转换如此昂贵？在我们能够回答这个问题之前，我们需要更多地了解层次结构。

到目前为止，我们只限制了自己使用一个基类。虽然如果我们想象它们作为树，基类是根，分支是多个类从同一个基类派生，这样思考类层次结构会容易得多，但 C++并没有强加这样的限制。接下来，我们将学习一次性从多个基类继承。

# 多重继承

在 C++中，一个类可以从多个基类派生。回到我们的鸟类，让我们做一个观察——虽然飞行的鸟类彼此之间有很多共同之处，但它们也与其他飞行动物有共同之处，特别是飞行的能力。由于飞行并不局限于鸟类，我们可能希望将处理飞行相关的数据和算法移动到一个单独的基类中。但也不能否认，老鹰也是一种鸟类。如果我们使用两个基类来构建`Eagle`类，我们可以表达这种关系：

```cpp
class Eagle : public Bird, public FlyingAnimal { ... };
```

在这种情况下，从两个基类的继承都是公开的，这意味着派生类继承了两个接口，并且必须满足两个单独的合同。如果两个接口定义了具有相同名称的方法会发生什么？如果这个方法不是虚拟的，那么在派生类上调用它的尝试是模糊的，程序无法编译。如果方法是虚拟的，并且派生类有对它的重写，那么由于派生类的方法被调用，因此没有歧义。此外，`Eagle`现在既是`Bird`也是`FlyingAnimal`：

```cpp
Eagle* e = new Eagle;
Bird* b = e;
FlyingAnimal* f = e;
```

从派生类转换为基类指针的转换是允许的。反向转换必须显式地使用静态或动态转换。还有一个有趣的转换——如果我们有一个指向`FlyingAnimal`类的指针，它也是一个`Bird`类，我们能否从一个类转换到另一个类？是的，我们可以使用动态转换：

```cpp
Bird* b = new Eagle;   // Also a FlyingAnimal
FlyingAnimal* f = dynamic_cast<FlyingAnimal*>(b);
```

在这个上下文中，动态转换有时被称为**交叉转换**——我们不是在层次结构（派生类和基类之间）的上下文中进行转换，而是在层次结构之间进行转换——在层次结构树的不同分支上的类之间。

交叉转换也主要是我们之前章节中看到的动态转换高运行时成本的原因。虽然`dynamic_cast`最常见的使用是从`Base*`到`Derived*`转换以验证给定的对象确实是派生类，但这种转换也可以用于在相同派生类的基类之间进行转换。这是一个更难的问题。如果你只想检查基类对象确实是派生类，编译器此时知道`Derived`类型（你不能在未完成类型上使用动态转换）。

因此，编译器确切地知道这个派生类型有哪些基类，并且可以轻易地检查你的类型是否是其中之一。但是，在跨越层次结构进行类型转换时，编译器只知道两个基类：在编写此代码时，可能不存在同时结合这两个基类的派生类，它将在以后被编写。但是，编译器必须现在就生成正确的代码。因此，编译器必须生成在运行时挖掘所有可能从这两个基类派生出来的类，以查看你的类型是否是其中之一（实际的实现比这更直接且更高效，但需要完成的任务仍然是相同的）。

实际上，这种开销通常是不必要的，因为，大多数时候，动态类型转换确实用于确定基类指针是否真正指向一个派生对象。在许多情况下，这种开销并不显著。但是，如果需要更好的性能，就没有办法使动态类型转换更快。如果你想快速检查一个多态对象是否确实是给定类型，你必须使用虚函数，而且不幸的是，你必须使用所有可能的类型（或者至少是你可能感兴趣的）的列表：

```cpp
enum type_t { typeBase, typeDerived1, typeDerived2 };
class Base {
  virtual type_t type() const { return typeBase; }
};
class Derived1 : public Base {
  type_t type() const override { return typeDerived1; }
};
…
void process_derived1(Derived1* p);
void do_work(Base* p) {
  if (p->type() == typeDerived1) {
    process_derived1(static_cast<Derived1*>(p));
  }
}
```

在 C++中，多重继承经常受到诋毁和不被青睐。大部分这些建议已经过时，并且源于编译器在实现多重继承时表现不佳且效率低下的时候。如今，随着现代编译器的出现，这已不再是问题。人们常说多重继承使得类层次结构更难以理解和推理。或许更准确的说法是，设计一个能够准确反映不同属性之间关系的良好多重继承层次结构更困难，而设计不良的层次结构则难以理解和推理。

这些担忧主要适用于使用公有继承的层次结构。多重继承也可以是私有的。与使用单一私有继承相比，没有更多的理由使用多重私有继承而不是组合。然而，在多个空基类上进行空基优化仍然是一个有效的理由来使用私有继承，如果适用的话：

```cpp
class Empty1 {};
class Empty2 {};
class Derived : private Empty1, private Empty2 {
  int i;
};   // sizeof(Derived) == 4
class Composed {
  int i;
  Empty1 e1;
  Empty2 e2;
};   // sizeof(Composed) == 8
```

当派生类代表一个结合了几个不相关、不重叠属性的系统时，多重继承可以特别有效。在我们探索各种设计模式和它们的 C++表示时，本书中我们将遇到这样的案例。

# 摘要

尽管这绝对不是类和对象的完整指南或参考，但本章介绍了并解释了您需要理解本书其余部分示例和解释的概念。由于我们的兴趣和将会是表示 C++ 中的设计模式，本章重点介绍了类和继承的正确使用。我们特别注意了通过不同的 C++ 特征表达的关系——正是通过这些特征，我们将表达构成设计模式的不同组件之间的关系和交互。

下一章将类似地涵盖 C++ 模板的知识，这对于理解本书后续章节是必要的。

# 问题

+   C++ 中对象的重要性是什么？

+   公共继承和私有继承分别表达了哪种关系？多态对象是什么？

+   动态转换和静态转换之间的区别是什么？为什么动态转换如此昂贵？

# 进一步阅读

+   *用 C++ 解密面向对象编程*：[`www.packtpub.com/product/deciphering-object-oriented-programming-with-c/9781804613900`](https://www.packtpub.com/product/deciphering-object-oriented-programming-with-c/9781804613900)

+   *使用 C++ 进行软件架构*：[`www.packtpub.com/product/software-architecture-with-c/9781838554590`](https://www.packtpub.com/product/software-architecture-with-c/9781838554590)

+   *C++* 基础：[`www.packtpub.com/product/c-fundamentals`](https://www.packtpub.com/product/c-fundamentals)

+   *C++ 数据结构和算法*：[`www.packtpub.com/product/c-data-structures-and-algorithm-design-principles`](https://www.packtpub.com/product/c-data-structures-and-algorithm-design-principles)

+   *精通 C++* 编程：[`www.packtpub.com/product/mastering-c-programming`](https://www.packtpub.com/product/mastering-c-programming)

+   *C++ 编程入门*：[`www.packtpub.com/product/beginning-c-programming`](https://www.packtpub.com/product/beginning-c-programming)
