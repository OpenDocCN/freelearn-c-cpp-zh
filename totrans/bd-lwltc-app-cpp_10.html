<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-249"><a id="_idTextAnchor262"/>10</h1>
<h1 id="_idParaDest-250"><a id="_idTextAnchor263"/>Building the C++ Market Making and Liquidity Taking Algorithms</h1>
<p>In this chapter, we will implement a C++ market making algorithm on top of all the components we built in the previous chapters. This market making algorithm will connect to and send orders to the trading exchange we built previously. Additionally, we will implement a C++ liquidity taking algorithm in the same trading engine framework. This liquidity taking algorithm will also connect to and send orders to the trading exchange.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Understanding the behavior of our trading algorithms</li>
<li>Managing the passive liquidity provided in the order book</li>
<li>Opening and closing positions aggressively</li>
<li>Building the trade engine framework</li>
<li>Building and running the main trading application</li>
</ul>
<h1 id="_idParaDest-251"><a id="_idTextAnchor264"/>Technical requirements</h1>
<p>All the code for this book can be found in its GitHub repository at <a href="https://github.com/PacktPublishing/Building-Low-Latency-Applications-with-CPP">https://github.com/PacktPublishing/Building-Low-Latency-Applications-with-CPP</a>. The source for this chapter is in the <code>Chapter10</code> directory in the repository.</p>
<p>It is important that you have read and understood the design of the electronic trading ecosystem presented in the <em class="italic">Designing Our Trading Ecosystem</em> chapter, especially the <em class="italic">Designing a framework for low latency C++ trading algorithms</em> section. It is also expected that you are quite familiar with the previous two chapters – <em class="italic">Processing Market Data and Sending Orders to the Exchange in C++</em> and <em class="italic">Building the C++ Trading Algorithm Building Blocks</em>, since we will be using every single component that we built in those two chapters in this chapter.</p>
<p>The specifications of the environment in which the source code for this book was developed are shown here. We present the details of this environment since all the C++ code presented in this book is not necessarily portable and might require some minor changes to work in your environment:</p>
<ul>
<li>OS: <code>Linux 5.19.0-41-generic #42~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Tue Apr 18 17:40:00 UTC 2 x86_64 x86_64 </code><code>x86_64 GNU/Linux</code></li>
<li>GCC: <code>g++ (Ubuntu </code><code>11.3.0-1ubuntu1~22.04.1) 11.3.0</code></li>
<li>CMake: <code>cmake </code><code>version 3.23.2</code></li>
<li>Ninja: <code>1.10.2</code></li>
</ul>
<h1 id="_idParaDest-252"><a id="_idTextAnchor265"/>Understanding the behavior of our trading algorithms</h1>
<p>In this section, we will discuss some additional details about the behavior and motivation behind the two trading strategies we will build in this chapter – the market making trading <a id="_idIndexMarker1321"/>strategy and the liquidity taking trading strategy. With the use of a hypothetical example for each strategy, we will also try to understand the strategy order flow mechanics and try to further our understanding when we implement these trading strategies in our C++ system, towards the end of this chapter.</p>
<h2 id="_idParaDest-253"><a id="_idTextAnchor266"/>Understanding the market making trading algorithm</h2>
<p>The market making trading strategies seek to make profits by seeking to <em class="italic">capture the spread</em>, which just <a id="_idIndexMarker1322"/>means buying at the best bid price in the <a id="_idIndexMarker1323"/>market passively and quickly selling at the best ask price in the market passively (or selling first and buying after). The market making strategies, profitability depends on the spread of the trading instrument, how many buy and sell trades the strategy can execute over time, and how much market prices move between the buy and sell trades. It <a id="_idIndexMarker1324"/>should be clear that the market making strategies will trade only against other strategies that <em class="italic">cross the spread</em> and send aggressive buy and sell orders, which is what we refer to as <strong class="bold">liquidity taking trading strategies</strong>. What this means is that market making trading strategies rarely expect to trade against other market making trading strategies, since all instances of such strategies seek to execute their <a id="_idIndexMarker1325"/>orders passively. To achieve this, market making trading strategies <a id="_idIndexMarker1326"/>send and manage passive limit orders in the order book and try to use intelligence to modify the prices on these orders, thereby improving their execution and the probability of successfully capturing the spread as often as possible. In the next subsection, we will discuss a hypothetical example of how a market making trading strategy would manage its orders.</p>
<h2 id="_idParaDest-254"><a id="_idTextAnchor267"/>Inspecting market making mechanics with an example</h2>
<p>In this subsection, we will discuss the mechanics of how our market making trading strategy would <a id="_idIndexMarker1327"/>behave under a hypothetical market condition. This will help strengthen your understanding of how the market making algorithm behaves. Before we do that, let us try to understand the following table.</p>
<p>The table presents a state of the market book known as the <strong class="bold">price level-aggregated order book</strong>. What this term means is that all the orders on the same side and same price are grouped/aggregated together into a single price level, so if there are 12 orders on the bid side, all at the same price (10.21), that add up to a total quantity of 2,500, they can be presented <a id="_idIndexMarker1328"/>as a single entry. This is shown as follows, along with similar grouping on the next buy price level of 10.20 and ask levels of 10.22 and 10.23 prices.</p>
<div><div><img alt="Figure 10.1 – A snapshot of an order book, arranged as a price level-aggregated book" src="img/B19434_10_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 – A snapshot of an order book, arranged as a price level-aggregated book</p>
<p>In the preceding diagram, the columns mean the following things (from left to right):</p>
<ul>
<li><strong class="bold">Our MM strategy bid</strong>: This represents the quantity of the buy order that our <strong class="bold">Market Making</strong> (<strong class="bold">MM</strong>) strategy has at this price level, which in this case is none</li>
<li><strong class="bold">Market bid order count</strong>: This represents the number of buy orders in the market that make up this price level</li>
<li><strong class="bold">Market bid quantity</strong>: The sum of the quantities on all the buy orders at this price level</li>
<li><strong class="bold">Market bid price</strong>: This represents the price of this bid price level</li>
<li><strong class="bold">Market ask price</strong>: This represents the price of this ask price level</li>
<li><strong class="bold">Market ask quantity</strong>: The sum of the quantities of all the sell orders at this price level</li>
<li><strong class="bold">Market ask order count</strong>: This represents the number of sell orders in the market that make up this price level</li>
<li><strong class="bold">Our MM strategy ask</strong>: This represents the quantity of the sell order that our MM strategy has at this price level, which in this case is none</li>
</ul>
<p>Now, let us suppose our MM strategy starts running at the time that the market is in the state we described here. Let us also assume that, for this example, our strategy will send a single passive <a id="_idIndexMarker1329"/>bid order and a single passive ask order, and each has a quantity of 100 shares. Let us say that the strategy decides to join the best bid price level and the best ask price level at prices 10.21 and 10.22, respectively. It does this by sending a single buy order and a single sell order of a quantity of 100 at those prices. The following diagram represents this event, and the blocks highlighted in gold represent the things that changed because of this action.</p>
<div><div><img alt="Figure 10.2 – An event where our MM order has joined the market on both sides" src="img/B19434_10_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2 – An event where our MM order has joined the market on both sides</p>
<p>Finally, for one last scenario, let us assume that the orders on the best bid at 10.21 are either fully executed due to trade events and removed, or just canceled by the market participants that owned them. If the drop in quantity is large enough, let us assume that our MM trading strategy also decides to not be present at the price level. The state of the price <a id="_idIndexMarker1330"/>aggregated order book looks like this right before our strategy decides to move its best bid order at a price one price level away from its current price, i.e., from price 10.21 to 10.20:</p>
<div><div><img alt="Figure 10.3 – The state of the price level book when our MM order decides to move its bid" src="img/B19434_10_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3 – The state of the price level book when our MM order decides to move its bid</p>
<p>This decision can be due to a wide range of factors, depending on the strategy and its features. However, for this example, let us offer you a simple intuitive thought – a lot of people are less willing to buy at 10.21 (only 600 shares in total) compared to how many people are willing to sell at 10.22 (6,500 shares). You might conclude that perhaps it is no longer wise to try and buy at 10.21 or that the fair market price is perhaps at 10.21, and you want to try and buy at a price that is a little lower than that. The next diagram displays the state of the price level book when the MM strategy decides to cancel its buy order at 10.21 and repositions its buy order to 10.20.</p>
<div><div><img alt="Figure 10.4 – An event where our MM strategy repositions its bid from a price of 10.21 to 10.20" src="img/B19434_10_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.4 – An event where our MM strategy repositions its bid from a price of 10.21 to 10.20</p>
<p>The discussion in this subsection aimed to improve your understanding of the mechanics of a simple MM strategy, and in the next subsection, we will move on to the liquidity taking trading algorithm.</p>
<h2 id="_idParaDest-255"><a id="_idTextAnchor268"/>Understanding the liquidity taking trading algorithm</h2>
<p>The liquidity taking trading algorithm in many ways is the opposite of the MM algorithm. Instead of sending <a id="_idIndexMarker1331"/>passive orders to the book and waiting <a id="_idIndexMarker1332"/>for them to be executed passively, it sends aggressive orders to execute trades when it needs them. In this sense, it <em class="italic">crosses the spread</em> (sends aggressive orders to execute) instead of trying to <em class="italic">capture the spread</em>, like the MM strategy. This strategy bets on getting the direction of the market correct – that is, it buys aggressively when it thinks that prices will increase further and sells aggressively when it thinks that prices will decrease further. The convenient fact about this trading algorithm is that order management is very easy since it does not always maintain live orders in the order book that it needs to manage. Another way to understand this is that when the strategy needs to execute a trade, it sends an order to the order book and gets executed almost immediately, and then it is done from an order management perspective. The inconvenient fact about this trading algorithm is that predicting market directions is extremely difficult, but we will not dive into that, since that is not the focus of this book. In the next subsection, we will understand the trading mechanics for this strategy as we did with the MM strategy.</p>
<h3>Inspecting liquidity taking mechanics with an example</h3>
<p>Once again, let us look at the price level-aggregated view of the order book, as discussed in the section on MM. The columns here mean the same thing, except they do not have the columns for <a id="_idIndexMarker1333"/>the MM strategy orders, since the liquidity taking strategy will not rest orders passively in the order book. Let us assume the initial state of the price level book is as shown here, which was also the same initial state for the MM example.</p>
<div><div><img alt="Figure 10.5 – The state of the price level book at a given time for a hypothetical example" src="img/B19434_10_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.5 – The state of the price level book at a given time for a hypothetical example</p>
<p>Let us assume that, for this example, our liquidity taking strategy has a feature that tries to follow in the same direction as very large trades. What this means is that if a very large trade event happens in the market, our liquidity taking algorithm decides to take the same direction as this trade event. So, if a very large buy trade happens, our liquidity taking algorithm will buy aggressively, and if a very sell trade happens, our liquidity taking algorithm will sell aggressively. As mentioned before, this is only an example feature; in practice, different liquidity taking algorithms will have many such features on which the decision to make a trade depends. For our simple liquidity taking algorithm example, we will use this feature of large aggressive trade in the market.</p>
<p>To understand what that looks like, let us assume that given the previous state of the price level book, a <a id="_idIndexMarker1334"/>very large sell execution of a quantity of 2,200 hits the bid price level of 10.21, which had a total quantity of 2,500 prior to this. This event is shown in the following diagram, where the green arrow represents the trade aggressor in market data.</p>
<div><div><img alt="Figure 10.6 – An event where a large sell aggressor causes a trade event" src="img/B19434_10_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.6 – An event where a large sell aggressor causes a trade event</p>
<p>This trade event will cause the best bid quantity to reduce from 2,500 to 300 – that is, by the quantity of the trade aggressor. Additionally, let us assume that our liquidity taking strategy observes the large trade of a quantity of 2,200 and decides to send an aggressive sell order at the price of 10.21. Let us also assume that, like the MM strategy, our liquidity taking strategy also sends a sell order of a quantity of 100. This event is shown in the following diagram.</p>
<div><div><img alt="Figure 10.7 – An event where our liquidity taking algorithm sends an aggressive sell order of a quantity of 100 at a price of 10.21" src="img/B19434_10_07.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.7 – An event where our liquidity taking algorithm sends an aggressive sell order of a quantity of 100 at a price of 10.21</p>
<p>That concludes the theoretical discussion of the two trading strategies we seek to build as part of our trading system. We will get to their actual implementation inside our framework <a id="_idIndexMarker1335"/>in a few sections’ time, but first, we need to build some additional building blocks for these strategies, which we will do in the next section.</p>
<h2 id="_idParaDest-256"><a id="_idTextAnchor269"/>Adding an enumeration to define the type of algorithm</h2>
<p>We will round up this discussion of our trading strategies by defining an <code>AlgoType</code> enumeration <a id="_idIndexMarker1336"/>in the <code>Chapter10/common/types.h</code> header file. It has the following valid values – <code>MAKER</code> to represent MM, <code>TAKER</code> to represent liquidity taking, and <code>RANDOM</code> to represent the random trading strategy we built before. We also have <code>INVALID</code> and <code>MAX</code> values:</p>
<pre class="source-code">
  enum class AlgoType : int8_t {
    INVALID = 0,
    RANDOM = 1,
    MAKER = 2,
    TAKER = 3,
    MAX = 4
  };</pre>
<p>We will add a standard <code>algoTypeToString()</code> method used to stringify the <code>AlgoType</code> type, as shown here:</p>
<pre class="source-code">
  inline auto algoTypeToString(AlgoType type) -&gt; std::string {
    switch (type) {
      case AlgoType::RANDOM:
        return "RANDOM";
      case AlgoType::MAKER:
        return "MAKER";
      case AlgoType::TAKER:
        return "TAKER";
      case AlgoType::INVALID:
        return "INVALID";
      case AlgoType::MAX:
        return "MAX";
    }
    return "UNKNOWN";
  }</pre>
<p>The <code>stringToAlgoType()</code> method, which we will build next, parses a string and converts it into an <code>AlgoType</code> enumeration value. It does this by iterating through all the possible <code>AlgoType</code> enumeration values and comparing the string argument against the output of <code>algoTypeToString()</code>, called on that <code>AlgoType</code> enumeration <a id="_idIndexMarker1337"/>value. If the string representations match, then it returns the <code>algo_type</code> enumeration:</p>
<pre class="source-code">
  inline auto stringToAlgoType(const std::string &amp;str) -&gt;
    AlgoType {
    for (auto i = static_cast&lt;int&gt;(AlgoType::INVALID); i &lt;=
      static_cast&lt;int&gt;(AlgoType::MAX); ++i) {
      const auto algo_type = static_cast&lt;AlgoType&gt;(i);
      if (algoTypeToString(algo_type) == str)
        return algo_type;
    }
    return AlgoType::INVALID;
  }</pre>
<p>Next, we will move on to building the different building blocks we need to support our trading strategies.</p>
<h1 id="_idParaDest-257"><a id="_idTextAnchor270"/>Managing the passive liquidity provided in the order book</h1>
<p>At this point, we have all the sub-components we need to start building our trading strategies. The first strategy we will build will be the MM algorithm, which sends orders that are expected to <a id="_idIndexMarker1338"/>rest passively in the order book. We <a id="_idIndexMarker1339"/>discussed the details of this trading algorithm earlier in this chapter, so in this section, we will focus on the C++ implementation. All the source code for this <code>MarketMaker</code> trading algorithm can be found in the <code>Chapter10/trading/strategy/market_maker.h</code> and <code>Chapter10/trading/strategy/market_maker.cpp</code> source files.</p>
<h2 id="_idParaDest-258"><a id="_idTextAnchor271"/>Defining the data members in the MarketMaker algorithm</h2>
<p>First, we need <a id="_idIndexMarker1340"/>to define the data members that <a id="_idIndexMarker1341"/>make up the <code>MarketMaker</code> class. The key members are the following:</p>
<ul>
<li>A pointer to a constant <code>FeatureEngine</code> object called <code>feature_engine_</code>, which we will use to fetch the fair market price, using the <code>FeatureEngine::getMktPrice()</code> method we saw earlier</li>
<li>A pointer to an <code>OrderManager</code> object called <code>order_manager_</code>, which will be used to manage the passive orders that this strategy sends</li>
<li>A <code>ticker_cfg_</code> variable of a constant <code>TradeEngineCfgHashMap</code> type to hold the trading parameters for the different trading instruments that this algorithm will trade</li>
</ul>
<p>Let us inspect the class definition, starting with the <code>include</code> files needed in the <code>market_maker.h</code> header file:</p>
<pre class="source-code">
#pragma once
#include "common/macros.h"
#include "common/logging.h"
#include "order_manager.h"
#include "feature_engine.h"
using namespace Common;</pre>
<p>And now, in the <a id="_idIndexMarker1342"/>next code block, we <a id="_idIndexMarker1343"/>can define the <code>MarketMaker</code> class and the aforementioned data members:</p>
<pre class="source-code">
namespace Trading {
  class MarketMaker {
  private:
    const FeatureEngine *feature_engine_ = nullptr;
    OrderManager *order_manager_ = nullptr;
    std::string time_str_;
    Common::Logger *logger_ = nullptr;
    const TradeEngineCfgHashMap ticker_cfg_;
  };
}</pre>
<p>The next section will define the constructor to initialize an instance of this <code>MarketMaker</code> class.</p>
<h2 id="_idParaDest-259"><a id="_idTextAnchor272"/>Initializing the MarketMaker algorithm</h2>
<p>The constructor implemented <a id="_idIndexMarker1344"/>in the <code>market_maker.cpp</code> file is shown in the next code block. The constructor accepts a few arguments in the constructor:</p>
<ul>
<li>A <code>Logger</code> object, which will be saved in the <code>logger_</code> member variable and used for logging purposes.</li>
<li>A pointer to a <code>TradeEngine</code> object, which will be used to bind the <code>algoOnOrderBookUpdate</code>, <code>algoOnTradeUpdate</code>, and <code>algoOnOrderUpdate</code> callbacks in the parent <code>TradeEngine</code> instance to the corresponding methods in the <code>MarketMaker</code> object. This is so that the <code>MarketMaker</code> trading strategy receives and processes the callbacks when <code>TradeEngine</code> receives them.</li>
<li>A pointer to a constant <code>FeatureEngine</code> object, which will be stored in the <code>feature_engine_</code> data member and used to extract the feature values this algorithm needs, as described before.</li>
<li>A pointer to an <code>OrderManager</code> object, which will be used to manage the orders for this strategy, and the constructor will simply be saved in the <code>order_manager_</code> data member.</li>
<li>A reference to a constant <code>TradeEngineCfgHashMap</code>, which will be saved in the <code>ticker_cfg_</code> member and used to make trading decisions, since this contains the trading parameters:<pre class="source-code">
#include "market_maker.h"</pre><pre class="source-code">
#include "trade_engine.h"</pre><pre class="source-code">
namespace Trading {</pre><pre class="source-code">
  MarketMaker::MarketMaker(Common::Logger *logger,</pre><pre class="source-code">
    TradeEngine *trade_engine, const FeatureEngine</pre><pre class="source-code">
      *feature_engine,</pre><pre class="source-code">
OrderManager *order_manager, const</pre><pre class="source-code">
  TradeEngineCfgHashMap &amp;ticker_cfg)</pre><pre class="source-code">
      : feature_engine_(feature_engine),</pre><pre class="source-code">
        order_manager_(order_manager),</pre><pre class="source-code">
          logger_(logger),</pre><pre class="source-code">
        ticker_cfg_(ticker_cfg) {</pre></li>
</ul>
<p>As mentioned before and as shown here, we will override the <code>TradeEngine:</code><code> :algoOnOrderBookUpdate()</code>, <code>TradeEngine::algoOnTradeUpdate()</code>, and <code>TradeEngine::algoOnOrderUpdate()</code> methods using lambda methods to forward <a id="_idIndexMarker1345"/>them to the <code>MarketMaker::onOrderBookUpdate()</code>, <code>MarketMaker::onTradeUpdate()</code>, and <code>MarketMaker::onOrderUpdate()</code> methods, respectively:</p>
<pre class="source-code">
    trade_engine-&gt;algoOnOrderBookUpdate_ = [this](auto
      ticker_id, auto price, auto side, auto book) {
      onOrderBookUpdate(ticker_id, price, side, book);
    };
    trade_engine-&gt;algoOnTradeUpdate_ = [this](auto
      market_update, auto book) {
        onTradeUpdate(market_update, book); };
    trade_engine-&gt;algoOnOrderUpdate_ = [this](auto
      client_response) { onOrderUpdate(client_response); };
  }
}</pre>
<p>The next subsection tackles the most important task in the <code>MarketMaker</code> trading algorithm – handling order book updates and sending orders in reaction to them.</p>
<h2 id="_idParaDest-260"><a id="_idTextAnchor273"/>Handling order book updates and trade events</h2>
<p>The <code>MarketMaker::onOrderBookUpdate()</code> method is called by <code>TradeEngine</code> through the <code>TradeEngine::algoOnOrderBookUpdate_</code> <code>std::function</code> member <a id="_idIndexMarker1346"/>variable. This is where <a id="_idIndexMarker1347"/>the <code>MarketMaker</code> trading strategy <a id="_idIndexMarker1348"/>makes trading decisions with regard to what <a id="_idIndexMarker1349"/>prices it wants its bid and ask orders to be at:</p>
<pre class="source-code">
    auto onOrderBookUpdate(TickerId ticker_id, Price price,
      Side side, const MarketOrderBook *book) noexcept -&gt; void {
      logger_-&gt;log("%:% %() % ticker:% price:% side:%\n",
        __FILE__, __LINE__, __FUNCTION__,
                   Common::getCurrentTimeStr(&amp;time_str_),
                     ticker_id, Common::
                       priceToString(price).c_str(),
                   Common::sideToString(side).c_str());</pre>
<p>It fetches <code>BBO</code> from <code>w</code> using the <code>getBBO()</code> method and saves it in the <code>bbo</code> variable. We also fetch the market quantity-weighted BBO price and save it in the <code>fair_price</code> variable:</p>
<pre class="source-code">
      const auto bbo = book-&gt;getBBO();
      const auto fair_price = feature_engine_-&gt;
        getMktPrice();</pre>
<p>We perform a sanity check on the best <code>bid_price_</code> and <code>ask_price_</code> values from <code>bbo</code> and <code>fair_price</code> to make sure that the prices are not <code>Price_INVALID</code> and the feature value is not <code>Feature_INVALID</code>. Only if this is <code>true</code> will we take any action; otherwise, we risk acting on invalid features or sending orders at invalid prices:</p>
<pre class="source-code">
      if (LIKELY(bbo-&gt;bid_price_ != Price_INVALID &amp;&amp; bbo-&gt;
        ask_price_ != Price_INVALID &amp;&amp; fair_price !=
          Feature_INVALID)) {
        logger_-&gt;log("%:% %() % % fair-price:%\n",
          __FILE__, __LINE__, __FUNCTION__,
                     Common::getCurrentTimeStr(&amp;time_str_),
                     bbo-&gt;toString().c_str(), fair_price);</pre>
<p>We fetch and save the <code>clip</code> quantity from the <code>ticker_cfg_</code> container, which will be the quantity on the passive orders we send to the exchange. We also extract and save the <code>threshold</code> value, which we will use to decide what prices to send the buy and sell orders at:</p>
<pre class="source-code">
        const auto clip = ticker_cfg_.at(ticker_id).clip_;
        const auto threshold =
          ticker_cfg_.at(ticker_id).threshold_;</pre>
<p>We initialize two price variables, <code>bid_price</code> and <code>ask_price</code>, to represent the prices on our buy <a id="_idIndexMarker1350"/>and sell orders, respectively. We <a id="_idIndexMarker1351"/>set <code>bid_price</code> to <a id="_idIndexMarker1352"/>be the best bid price if the difference <a id="_idIndexMarker1353"/>between <code>fair_price</code> we computed from the <code>FeatureEngine::getMktPrice()</code> method and the market bid price exceeds the <code>threshold</code> value. Otherwise, we set <code>bid_price</code> to be a price lower than the best market bid price. We compute <code>ask_price</code> using the same logic – use the best ask price if the difference from the fair price exceeds the threshold and a higher price otherwise. The motivation behind this is straightforward; when we think the fair price is higher than the best bid price, we are willing to buy at the best bid price, expecting the prices to go higher. When we think the fair price is lower than the best ask price, we are willing to sell at the best ask price, expecting the prices to go lower:</p>
<pre class="source-code">
        const auto bid_price = bbo-&gt;bid_price_ -
          (fair_price - bbo-&gt;bid_price_ &gt;= threshold ? 0 :
            1);
        const auto ask_price = bbo-&gt;ask_price_ + (bbo-&gt;
          ask_price_ - fair_price &gt;= threshold ? 0 : 1);</pre>
<p>We use the <code>bid_price</code> and <code>ask_price</code> variables we computed in the preceding code block a and pass them to the <code>OrderManager::moveOrders()</code> method to move the orders to the desired prices:</p>
<pre class="source-code">
        order_manager_-&gt;moveOrders(ticker_id, bid_price,
          ask_price, clip);
      }
    }</pre>
<p>The <code>MarketMaker</code> trading algorithm does not do anything when there are trade events and simply logs the trade message it receives, as shown here:</p>
<pre class="source-code">
    auto onTradeUpdate(const Exchange::MEMarketUpdate
      *market_update, MarketOrderBook * /* book */)
       noexcept -&gt; void {
      logger_-&gt;log("%:% %() % %\n", __FILE__, __LINE__,
        __FUNCTION__, Common::
         getCurrentTimeStr(&amp;time_str_),
                   market_update-&gt;toString().c_str());
    }</pre>
<p>We have one <a id="_idIndexMarker1354"/>more task to complete <a id="_idIndexMarker1355"/>the <code>MarketMaker</code> trading <a id="_idIndexMarker1356"/>strategy – handling order updates for its orders, which <a id="_idIndexMarker1357"/>will be addressed in the next subsection.</p>
<h2 id="_idParaDest-261"><a id="_idTextAnchor274"/>Handling order updates in the MarketMaker algorithm</h2>
<p>The handling of <a id="_idIndexMarker1358"/>order updates for the <code>MarketMaker</code> trading <a id="_idIndexMarker1359"/>algorithm’s orders is simple; it simply forwards the <code>MEClientResponse</code> messages to the <code>order_manager_</code> member it uses to manage orders. This is achieved by calling the <code>OrderManager::onOrderUpdate()</code> method, which we implemented previously:</p>
<pre class="source-code">
    auto onOrderUpdate(const Exchange::MEClientResponse
      *client_response) noexcept -&gt; void {
      logger_-&gt;log("%:% %() % %\n", __FILE__, __LINE__,
        __FUNCTION__, Common::
         getCurrentTimeStr(&amp;time_str_),
                   client_response-&gt;toString().c_str());
      order_manager_-&gt;onOrderUpdate(client_response);
    }</pre>
<p>That concludes our implementation of the MM trading algorithm. In the next section, we will tackle the other type of trading strategy we will build in this book – a liquidity taking algorithm.</p>
<h1 id="_idParaDest-262"><a id="_idTextAnchor275"/>Opening and closing positions aggressively</h1>
<p>In this section, we will build a liquidity taking algorithm, whose behavior we covered in the first section of this chapter. This trading strategy does not send passive orders as the MM algorithm does; instead, it sends aggressive orders that trade against liquidity resting in the book. The source code for the <code>LiquidityTaker</code> algorithm is in the <code>Chapter10/trading/strategy/liquidity_taker.h</code> and <code>Chapter10/trading/strategy/liquidity_taker.cpp</code> source files. First, we will define the data members that make up the <code>LiquidityTaker</code> class in the next subsection.</p>
<h2 id="_idParaDest-263"><a id="_idTextAnchor276"/>Defining the data members in the LiquidityTaker algorithm</h2>
<p>The <code>LiquidityTaker</code> trading strategy has the same data members as the <code>MarketMaker</code> algorithm <a id="_idIndexMarker1360"/>we built in the <a id="_idIndexMarker1361"/>previous section. Before we describe the data members themselves, we will present the header files we need to include in the <code>liquidity_taker.h</code> source file:</p>
<pre class="source-code">
#pragma once
#include "common/macros.h"
#include "common/logging.h"
#include "order_manager.h"
#include "feature_engine.h"
using namespace Common;</pre>
<p>Now, we can define the data members, which are the same ones that the MM algorithm has. The <code>LiquidityTaker</code> class has a <code>feature_engine_</code> member, which is a constant pointer to a <code>FeatureEngine</code> object, an <code>order_manager_</code> pointer to an <code>OrderManager</code> object, and a constant <code>ticker_cfg_</code> member, which is of type <code>TradeEngineCfgHashMap</code>. These members serve the same purpose as they did in the <code>MarketMaker</code> class; <code>feature_engine_</code> is used to extract the ratio of aggressive trade to top-of-book quantity. The <code>order_manager_</code> object is used to send and <a id="_idIndexMarker1362"/>manage the orders for this <a id="_idIndexMarker1363"/>trading strategy. Finally, the <code>ticker_cfg_</code> object holds the trading parameters that will be used by this algorithm to make trading decisions and send orders to the exchange:</p>
<pre class="source-code">
namespace Trading {
  class LiquidityTaker {
  private:
    const FeatureEngine *feature_engine_ = nullptr;
    OrderManager *order_manager_ = nullptr;
    std::string time_str_;
    Common::Logger *logger_ = nullptr;
    const TradeEngineCfgHashMap ticker_cfg_;
  };
}</pre>
<p>In the next section, we will see how to initialize a <code>LiquidityTaker</code> object.</p>
<h2 id="_idParaDest-264"><a id="_idTextAnchor277"/>Initializing the LiquidityTaker trading algorithm</h2>
<p>The initialization for the <code>LiquidityTaker</code> class is identical to the initialization for the <code>MarketMaker</code> class. The <a id="_idIndexMarker1364"/>constructor expects the following arguments – a <code>Logger</code> object, the <code>TradeEngine</code> object within which this algorithm runs, a <code>FeatureEngine</code> object to compute the feature, an <code>OrderManager</code> object used to manage orders for this trading strategy, and a <code>TradeEngineCfgHashMap</code> object containing the trading parameters for this strategy:</p>
<pre class="source-code">
#include "liquidity_taker.h"
#include "trade_engine.h"
namespace Trading {
  LiquidityTaker::LiquidityTaker(Common::Logger *logger,
    TradeEngine *trade_engine, FeatureEngine
      *feature_engine,
    OrderManager *order_manager,
    const TradeEngineCfgHashMap &amp;ticker_cfg):
      feature_engine_(feature_engine),
        order_manager_(order_manager), logger_(logger),
        ticker_cfg_(ticker_cfg) {</pre>
<p>This constructor also overrides the callbacks in the <code>TradeEngine</code> object for order book updates, trade <a id="_idIndexMarker1365"/>events, and updates to the algorithm’s orders like the <code>MarketMaker</code> algorithm. The <code>std::function</code> members, <code>algoOnOrderBookUpdate_</code>, <code>algoOnTradeUpdate_</code>, and <code>algoOnOrderUpdate_</code>, in <code>TradeEngine</code> are bound, respectively, to the <code>onOrderBookUpdate</code>, <code>onTradeUpdate</code>, and <code>onOrderUpdate</code> methods within <code>LiquidityTaker</code> using lambda methods, as shown here (and as we saw before):</p>
<pre class="source-code">
    trade_engine-&gt;algoOnOrderBookUpdate_ = [this](auto
      ticker_id, auto price, auto side, auto book) {
      onOrderBookUpdate(ticker_id, price, side, book);
    };
    trade_engine-&gt;algoOnTradeUpdate_ = [this](auto
      market_update, auto book) {
       onTradeUpdate(market_update, book); };
    trade_engine-&gt;algoOnOrderUpdate_ = [this](auto
      client_response) { onOrderUpdate(client_response); };
  }
}</pre>
<p>Next, we will <a id="_idIndexMarker1366"/>discuss the code for handling trade events and order book updates due to events in the market data in this trading strategy.</p>
<h2 id="_idParaDest-265"><a id="_idTextAnchor278"/>Handling trade events and order book updates</h2>
<p>For the <code>MarketMaker</code> trading strategy, we saw that it only makes trading decisions on order book <a id="_idIndexMarker1367"/>updates and does nothing <a id="_idIndexMarker1368"/>on trade updates. The <code>LiquidityTaker</code> strategy <a id="_idIndexMarker1369"/>does the opposite – it takes trading <a id="_idIndexMarker1370"/>decisions in the <code>onTradeUpdate()</code> method and does nothing in the <code>onOrderBookUpdate()</code> method. We will start by looking at the implementation of the <code>LiquidityTaker::onTradeUpdate()</code> method first in the next code block:</p>
<pre class="source-code">
    auto onTradeUpdate(const Exchange::MEMarketUpdate
      *market_update, MarketOrderBook *book) noexcept -&gt; void {
      logger_-&gt;log("%:% %() % %\n", __FILE__, __LINE__,
        __FUNCTION__, Common::
          getCurrentTimeStr(&amp;time_str_),
                   market_update-&gt;toString().c_str());</pre>
<p>We will fetch and save <code>BBO</code> using the <code>getBBO()</code> method in the <code>bbo</code> local variable. For this trading strategy, we will fetch the aggressive trade quantity ratio feature from the feature engine by calling the <code>FeatureEngine::getAggTradeQtyRatio()</code> method and saving it in the <code>agg_qty_ratio</code> variable:</p>
<pre class="source-code">
      const auto bbo = book-&gt;getBBO();
      const auto agg_qty_ratio = feature_engine_-&gt;
        getAggTradeQtyRatio();</pre>
<p>As we saw before, we will check to make sure that <code>bid_price_</code>, <code>ask_price_</code>, and <code>agg_qty_ratio</code> are valid values before we decide to take an order action:</p>
<pre class="source-code">
      if (LIKELY(bbo-&gt;bid_price_ != Price_INVALID &amp;&amp; bbo-&gt;
        ask_price_ != Price_INVALID &amp;&amp; agg_qty_ratio !=
          Feature_INVALID)) {
        logger_-&gt;log("%:% %() % % agg-qty-ratio:%\n",
          __FILE__, __LINE__, __FUNCTION__,
                     Common::getCurrentTimeStr(&amp;time_str_),
                     bbo-&gt;toString().c_str(),
                       agg_qty_ratio);</pre>
<p>If the validity check passes, we first need to fetch the <code>clip_</code> member from the <code>ticker_cfg_</code> object for the <code>TickerId</code> of this trade message, as shown in the following code block, and save it in the <code>clip</code> local variable. Similarly, we will fetch and save the <code>threshold_</code> member from the <code>ticker_cfg_</code> configuration object for that <code>TickerId</code>:</p>
<pre class="source-code">
        const auto clip = ticker_cfg_.at(market_update-&gt;
          ticker_id_).clip_;
        const auto threshold = ticker_cfg_
          .at(market_update-&gt;ticker_id_).threshold_;</pre>
<p>To decide whether we send or adjust active orders for this algorithm, we will check whether the <code>agg_qty_ratio</code> exceeds the threshold we previously fetched:</p>
<pre class="source-code">
        if (agg_qty_ratio &gt;= threshold) {</pre>
<p>To send orders using the <code>OrderManager::moveOrders()</code> method, we will check whether the <a id="_idIndexMarker1371"/>aggressive trade was a buy trade <a id="_idIndexMarker1372"/>or a sell trade. If it was a buy trade, we <a id="_idIndexMarker1373"/>will send an aggressive buy order to take liquidity at the <a id="_idIndexMarker1374"/>best <code>BBO</code> <code>ask_price_</code> and no sell order by specifying a sell price of <code>Price_INVALID</code>. Conversely, if it was a sell trade and we wanted to send an aggressive sell order to take liquidity, we would specify a sell price to be <code>bid_price_</code> in the <code>BBO</code> object and no buy order by specifying a <code>Price_INVALID</code> buy price. Remember that this trading strategy takes a direction in the market by aggressively sending a buy or sell order one at a time, but not both like the <code>MarketMaker</code> algorithm:</p>
<pre class="source-code">
          if (market_update-&gt;side_ == Side::BUY)
            order_manager_-&gt;moveOrders(market_update-&gt;
              ticker_id_, bbo-&gt;ask_price_, Price_INVALID,
                clip);
          else
            order_manager_-&gt;moveOrders(market_update-&gt;
              ticker_id_, Price_INVALID, bbo-&gt;bid_price_,
                clip);
        }
      }
    }</pre>
<p>As mentioned <a id="_idIndexMarker1375"/>before and as shown in the <a id="_idIndexMarker1376"/>following code <a id="_idIndexMarker1377"/>block, this <code>LiquidityTaker</code> trading strategy does not take any <a id="_idIndexMarker1378"/>action on order updates in the <code>onOrderBookUpdate()</code> method:</p>
<pre class="source-code">
    auto onOrderBookUpdate(TickerId ticker_id, Price price,
      Side side, MarketOrderBook *) noexcept -&gt; void {
      logger_-&gt;log("%:% %() % ticker:% price:% side:%\n",
        __FILE__, __LINE__, __FUNCTION__,
                   Common::getCurrentTimeStr(&amp;time_str_),
                     ticker_id, Common::
                       priceToString(price).c_str(),
                   Common::sideToString(side).c_str());
    }</pre>
<p>The next concluding section related to <code>LiquidityTaker</code> adds handling to the order updates for the strategy’s orders.</p>
<h2 id="_idParaDest-266"><a id="_idTextAnchor279"/>Handling order updates in the LiquidityTaker algorithm</h2>
<p>The <code>LiquidityTaker::onOrderUpdate()</code> method, as shown in the following code block, has <a id="_idIndexMarker1379"/>an identical implementation <a id="_idIndexMarker1380"/>to the <code>MarketMaker::onOrderUpdate()</code> method and simply forwards the order update to the order manager using the <code>OrderManager::onOrderUpdate()</code> method:</p>
<pre class="source-code">
    auto onOrderUpdate(const Exchange::MEClientResponse
      *client_response) noexcept -&gt; void {
      logger_-&gt;log("%:% %() % %\n", __FILE__, __LINE__,
        __FUNCTION__, Common::
          getCurrentTimeStr(&amp;time_str_),
                   client_response-&gt;toString().c_str());
      order_manager_-&gt;onOrderUpdate(client_response);
    }</pre>
<p>That concludes our implementation of the <code>LiquidityTaker</code> trading strategy. In the next section, we <a id="_idIndexMarker1381"/>will shift the discussion to <a id="_idIndexMarker1382"/>building the final form of our trading application so that we can build and run these actual trading strategies in our electronic trading ecosystem.</p>
<h1 id="_idParaDest-267"><a id="_idTextAnchor280"/>Building the trade engine framework</h1>
<p>In this section, we <a id="_idIndexMarker1383"/>will build the trade engine framework in the <code>TradeEngine</code> class. This framework ties all the different components we built together – the <code>OrderGateway</code>, <code>MarketDataConsumer</code>, <code>MarketOrderBook</code>, <code>FeatureEngine</code>, <code>PositionKeeper</code>, <code>OrderManager</code>, <code>RiskManager</code>, <code>MarketMaker</code>, and <code>LiquidityTaker</code> components. As a reminder of the trading engine component, we present a diagram of all the sub-components here. We have built all the sub-components; now, we will just build the trading engine framework in which these sub-components exist.</p>
<div><div><img alt="Figure 10.8 – The components of the trading engine in the client’s trading system" src="img/Figure_9.1_B19434.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.8 – The components of the trading engine in the client’s trading system</p>
<p>We will start this <a id="_idIndexMarker1384"/>section by defining the data members of our class, as usual. All the source code for the basic <code>TradeEngine</code> framework is in the <code>Chapter10/trading/strategy/trade_engine.h</code> and <code>Chapter10/trading/strategy/trade_engine.cpp</code> source files.</p>
<h2 id="_idParaDest-268"><a id="_idTextAnchor281"/>Defining the data members in the trade engine</h2>
<p>Before <a id="_idIndexMarker1385"/>we define the data members in the <code>TradeEngine</code> class, we present the header files that the <code>trade_engine.h</code> source file needs to include:</p>
<pre class="source-code">
#pragma once
#include &lt;functional&gt;
#include "common/thread_utils.h"
#include "common/time_utils.h"
#include "common/lf_queue.h"
#include "common/macros.h"
#include "common/logging.h"
#include "exchange/order_server/client_request.h"
#include "exchange/order_server/client_response.h"
#include "exchange/market_data/market_update.h"
#include "market_order_book.h"
#include "feature_engine.h"
#include "position_keeper.h"
#include "order_manager.h"
#include "risk_manager.h"
#include "market_maker.h"
#include "liquidity_taker.h"</pre>
<p>The <code>TradeEngine</code> class needs the following basic data members:</p>
<ul>
<li>It has a <code>client_id_</code> variable of type <code>ClientId</code> to represent the unique trading application instance.</li>
<li>We create a <code>ticker_order_book_</code> instance of type <code>MarketOrderBookHashMap</code>, which, as a reminder, is <code>std::array</code> of <code>MarketOrderBook</code> objects to represent a hash map from <code>TickerId</code> to <code>MarketOrderBook</code> for that instrument.</li>
<li>We have three <a id="_idIndexMarker1386"/>lock-free queues to receive market data updates, send order requests, and receive order responses from the <code>MarketDataConsumer</code> and <code>OrderGateway</code> components. We receive market data updates using the <code>incoming_md_updates_</code> variable, which is a pointer to type <code>MEMarketUpdateLFQueue</code> (<code>LFQueue</code> of <code>MEMarketUpdate</code> messages). We send client order requests using the <code>outgoing_ogw_requests_</code> variable, which is a pointer to type <code>ClientRequestLFQueue</code> (<code>LFQueue</code> of <code>MEClientRequest</code> messages). We receive client order responses using the <code>incoming_ogw_responses_</code> variable, which is a pointer to type <code>ClientResponseLFQueue</code> (<code>LFQueue</code> of <code>MEClientResponse</code> messages).</li>
<li>We have the usual Boolean <code>run_</code> variable, which will control the execution of the main <code>TradeEngine</code> thread and is marked <code>volatile</code>.</li>
<li>We have a <code>last_event_time_</code> variable of type <code>Nanos</code> to keep track of the time when the last message from the exchange was received.</li>
<li>We will <a id="_idIndexMarker1387"/>also have a <code>Logger</code> variable called <code>logger_</code> to create a log file for <code>TradeEngine</code> to use:</li>
</ul>
<pre class="source-code">
namespace Trading {
  class TradeEngine {
  private:
    const ClientId client_id_;
    MarketOrderBookHashMap ticker_order_book_;
    Exchange::ClientRequestLFQueue *outgoing_ogw_requests_
      = nullptr;
    Exchange::ClientResponseLFQueue
      *incoming_ogw_responses_ = nullptr;
    Exchange::MEMarketUpdateLFQueue *incoming_md_updates_ =
      nullptr;
    Nanos last_event_time_ = 0;
    volatile bool run_ = false;
    std::string time_str_;
    Logger logger_;</pre>
<p>We also need instances of each of our components from the previous chapter, namely the following:</p>
<ul>
<li>A variable of type <code>FeatureEngine</code> called <code>feature_engine_</code> to compute complex feature values</li>
<li>A <code>position_keeper_</code> variable of type <code>PositionKeeper</code> to track trading strategy positions and Profits and Losses (<strong class="bold">PnLs</strong>) money made or lost from our trading</li>
<li>An instance of type <code>OrderManager</code> called <code>order_manager_</code>, which will be used by the trading strategies to send and manage live orders</li>
<li>A <code>RiskManager</code> object named <code>risk_manager_</code> to manage the trading strategy’s risk</li>
<li>A pointer to a <code>MarketMaker</code> object called <code>mm_algo_</code>, which will be initialized if we configure <code>TradeEngine</code> to run a MM trading algorithm</li>
<li>Similarly, a pointer to a <code>LiquidityTaker</code> object called <code>taker_algo_</code>, which <a id="_idIndexMarker1388"/>will be initialized if we configure <code>TradeEngine</code> to run a liquidity taking trading strategy:</li>
</ul>
<pre class="source-code">
    FeatureEngine feature_engine_;
    PositionKeeper position_keeper_;
    OrderManager order_manager_;
    RiskManager risk_manager_;
    MarketMaker *mm_algo_ = nullptr;
    LiquidityTaker *taker_algo_ = nullptr;</pre>
<p>We will also add three <code>std::function</code> member variables, which <code>TradeEngine</code> will use to forward market data and order updates to the trading strategy that it instantiates. These are explained as follows:</p>
<ul>
<li><code>algoOnOrderBookUpdate_</code> <code>std::function</code> has the same signature as the <code>TradeEngine::onOrderBookUpdate()</code> method and is used to forward order book updates to the trading strategy</li>
<li><code>algoOnTradeUpdate_</code> <code>std::function</code> has the same signature as the <code>TradeEngine::onTradeUpdate()</code> method and is used to forward trade events to the trading strategy</li>
<li><code>algoOnOrderUpdate_</code> <code>std::function</code> has the same signature as the <code>TradeEngine::onOrderUpdate()</code> method and is used to forward order updates/responses to the trading strategy:</li>
</ul>
<pre class="source-code">
    std::function&lt;void(TickerId ticker_id, Price price,
      Side side, MarketOrderBook *book)&gt;
        algoOnOrderBookUpdate_;
    std::function&lt;void(const Exchange::MEMarketUpdate
      *market_update, MarketOrderBook *book)&gt;
        algoOnTradeUpdate_;
    std::function&lt;void(const Exchange::MEClientResponse
      *client_response)&gt; algoOnOrderUpdate_;</pre>
<p>To default-initialize <a id="_idIndexMarker1389"/>these three <code>std::function</code> data members, we will create three new methods that simply log the parameters they are passed. They are shown here:</p>
<pre class="source-code">
    auto defaultAlgoOnOrderBookUpdate(TickerId ticker_id,
      Price price, Side side, MarketOrderBook *) noexcept
       -&gt; void {
      logger_.log("%:% %() % ticker:% price:% side:%\n",
        __FILE__, __LINE__, __FUNCTION__,
                  Common::getCurrentTimeStr(&amp;time_str_),
                    ticker_id, Common::
                      priceToString(price).c_str(),
                  Common::sideToString(side).c_str());
    }
    auto defaultAlgoOnTradeUpdate(const
      Exchange::MEMarketUpdate *market_update,
        MarketOrderBook *) noexcept -&gt; void {
      logger_.log("%:% %() % %\n", __FILE__, __LINE__,
        __FUNCTION__, Common::
          getCurrentTimeStr(&amp;time_str_),
                  market_update-&gt;toString().c_str());
    }
    auto defaultAlgoOnOrderUpdate(const
      Exchange::MEClientResponse *client_response) noexcept
        -&gt; void {
      logger_.log("%:% %() % %\n", __FILE__, __LINE__,
        __FUNCTION__, Common::
          getCurrentTimeStr(&amp;time_str_),
                  client_response-&gt;toString().c_str());
    }</pre>
<p>Next, we will discuss the <a id="_idIndexMarker1390"/>code for some methods to initialize the <code>TradeEngine</code> class and its member variables.</p>
<h2 id="_idParaDest-269"><a id="_idTextAnchor282"/>Initializing the trade engine</h2>
<p>The constructor <a id="_idIndexMarker1391"/>for the <code>TradeEngine</code> class requires a <code>ClientId</code> argument to identify the trading application used in the client order requests. It also needs pointers to the three <code>LFQueue</code> of types <code>ClientRequestLFQueue</code>, <code>ClientResponseLFQueue</code>, and <code>MEMarketUpdateLFQueue</code> to initialize the <code>outgoing_ogw_requests_</code>, <code>incoming_ogw_responses_</code> and <code>incoming_md_updates_</code> data members, respectively. It also needs an <code>algo_type</code> argument of type <code>AlgoType</code> to specify the type of trading strategy and a <code>ticker_cfg</code> argument of type reference-to <code>const TradeEngineCfgHashMap</code>, which contains the configuration parameters for the risk manager and the trading strategy.</p>
<p>The constructor also initializes the <code>Logger logger_</code> member variable with a log file and creates a <code>MarketOrderBook</code> component for each possible <code>TickerId</code> value, holding them in the <code>ticker_order_book_</code> container. It calls the <code>setTradeEngine()</code> method on each <code>MarketOrderBook</code> component so that callbacks from the book can be received in <code>TradeEngine</code>. We also initialize the data members corresponding to the trading sub-components – <code>feature_engine_</code>, <code>position_keeper_</code>, <code>order_manager_</code>, and <code>risk_manager_</code>:</p>
<pre class="source-code">
  TradeEngine::TradeEngine(Common::ClientId client_id,
    AlgoType algo_type,
const TradeEngineCfgHashMap &amp;ticker_cfg,
Exchange::ClientRequestLFQueue *client_requests,
Exchange::ClientResponseLFQueue *client_responses,
Exchange::MEMarketUpdateLFQueue *market_updates)
      : client_id_(client_id),
        outgoing_ogw_requests_(client_requests),
          incoming_ogw_responses_(client_responses),
        incoming_md_updates_(market_updates),
          logger_("trading_engine_" + std::
            to_string(client_id) + ".log"),
        feature_engine_(&amp;logger_),
        position_keeper_(&amp;logger_),
        order_manager_(&amp;logger_, this, risk_manager_),
        risk_manager_(&amp;logger_, &amp;position_keeper_,
          ticker_cfg) {
    for (size_t i = 0; i &lt; ticker_order_book_.size(); ++i) {
      ticker_order_book_[i] = new MarketOrderBook(i, &amp;logger_);
      ticker_order_book_[i]-&gt;setTradeEngine(this);
    }</pre>
<p>In the body <a id="_idIndexMarker1392"/>of the constructor, in addition to the order books we previously created, we will initialize our new <code>std::function</code> members – <code>algoOnOrderBookUpdate_</code>, <code>algoOnTradeUpdate_</code>, and <code>algoOnOrderUpdate_</code> – with the defaults – the <code>defaultAlgoOnOrderBookUpdate()</code>, <code>defaultAlgoOnTradeUpdate()</code>, and <code>defaultAlgoOnOrderUpdate()</code> methods:</p>
<pre class="source-code">
    algoOnOrderBookUpdate_ = [this](auto ticker_id, auto
      price, auto side, auto book) {
      defaultAlgoOnOrderBookUpdate(ticker_id, price, side,
        book);
    };
    algoOnTradeUpdate_ = [this](auto market_update, auto
      book) { defaultAlgoOnTradeUpdate(market_update,
        book); };
    algoOnOrderUpdate_ = [this](auto client_response) {
      defaultAlgoOnOrderUpdate(client_response); };</pre>
<p>Finally, we will initialize a trading strategy instance, either <code>mm_algo_</code> of type <code>MarketMaker</code> or <code>taker_algo_</code> of the <code>LiquidityTaker</code> type trading strategy. This initialization is <a id="_idIndexMarker1393"/>shown as follows; remember that the <code>MarketMaker</code> or <code>LiquidityTaker</code> object will update/override the members – <code>algoOnOrderBookUpdate_</code>, <code>algoOnTradeUpdate_</code>, and <code>algoOnOrderUpdate_</code> – to point to their own method implementations:</p>
<pre class="source-code">
    if (algo_type == AlgoType::MAKER) {
      mm_algo_ = new MarketMaker(&amp;logger_, this,
        &amp;feature_engine_, &amp;order_manager_, ticker_cfg);
    } else if (algo_type == AlgoType::TAKER) {
      taker_algo_ = new LiquidityTaker(&amp;logger_, this,
        &amp;feature_engine_, &amp;order_manager_, ticker_cfg);
    }
    for (TickerId i = 0; i &lt; ticker_cfg.size(); ++i) {
      logger_.log("%:% %() % Initialized % Ticker:% %.\n",
        __FILE__, __LINE__, __FUNCTION__,
                  Common::getCurrentTimeStr(&amp;time_str_),
                  algoTypeToString(algo_type), i,
                  ticker_cfg.at(i).toString());
    }
  }</pre>
<p>We have a <code>start()</code> method, as we saw for other components. Again, it sets the <code>run_</code> flag to <code>true</code> to allow the <code>run()</code> method to execute and creates and launches a thread to execute the <code>run()</code> method:</p>
<pre class="source-code">
    auto start() -&gt; void {
      run_ = true;
      ASSERT(Common::createAndStartThread(-1,
        "Trading/TradeEngine", [this] { run(); }) !=
          nullptr, "Failed to start TradeEngine thread.");
    }</pre>
<p>The destructor does some simple de-initialization of the variables. First, it sets the <code>run_</code> flag to <code>false</code> and <a id="_idIndexMarker1394"/>waits a little bit to let the main thread exit, then it proceeds to delete each <code>MarketOrderBook</code> instance and clear out the <code>ticker_order_book_</code> container, and finally, it resets the <code>LFQueue</code> pointers it holds. It also deletes the <code>mm_algo_</code> and <code>taker_algo_</code> members corresponding to the trading strategies:</p>
<pre class="source-code">
  TradeEngine::~TradeEngine() {
    run_ = false;
    using namespace std::literals::chrono_literals;
    std::this_thread::sleep_for(1s);
    delete mm_algo_; mm_algo_ = nullptr;
    delete taker_algo_; taker_algo_ = nullptr;
    for (auto &amp;order_book: ticker_order_book_) {
      delete order_book;
      order_book = nullptr;
    }
    outgoing_ogw_requests_ = nullptr;
    incoming_ogw_responses_ = nullptr;
    incoming_md_updates_ = nullptr;
  }</pre>
<p>The familiar <code>stop()</code> method for this class first waits until all the incoming <code>MEClientResponse</code> and <code>MEMarketUpdate</code> messages are drained from the <code>incoming_ogw_responses_</code> and <code>incoming_md_updates_</code> <code>LFQueue</code> objects. Then, it resets <a id="_idIndexMarker1395"/>the <code>run_</code> flag to stop the main <code>run()</code> thread and returns from the function:</p>
<pre class="source-code">
    auto stop() -&gt; void {
      while(incoming_ogw_responses_-&gt;size() ||
        incoming_md_updates_-&gt;size()) {
        logger_.log("%:% %() % Sleeping till all updates
          are consumed ogw-size:% md-size:%\n", __FILE__,
            __LINE__, __FUNCTION__,
                    Common::getCurrentTimeStr(&amp;time_str_),
                       incoming_ogw_responses_-&gt;size(),
                         incoming_md_updates_-&gt;size());
        using namespace std::literals::chrono_literals;
        std::this_thread::sleep_for(10ms);
      }
      logger_.log("%:% %() % POSITIONS\n%\n", __FILE__,
        __LINE__, __FUNCTION__, Common::
         getCurrentTimeStr(&amp;time_str_),
                  position_keeper_.toString());
      run_ = false;
    }</pre>
<p>The next method we <a id="_idIndexMarker1396"/>will add to this basic framework is meant to be used to send <code>MEClientRequest</code> messages to the exchange.</p>
<h2 id="_idParaDest-270"><a id="_idTextAnchor283"/>Sending client requests</h2>
<p>The <code>sendClientRequest()</code> method in the trading engine framework is extremely simple. It <a id="_idIndexMarker1397"/>receives a <code>MEClientRequest</code> object and simply writes it to the <code>outgoing_ogw_requests_</code> lock-free queue so that the <code>OrderGateway</code> component can pick this up and send it out to the trading exchange:</p>
<pre class="source-code">
  auto TradeEngine::sendClientRequest(const
    Exchange::MEClientRequest *client_request) noexcept -&gt;
    void {
    logger_.log("%:% %() % Sending %\n", __FILE__,
      __LINE__, __FUNCTION__, Common::
        getCurrentTimeStr(&amp;time_str_),
                client_request-&gt;toString().c_str());
    auto next_write = outgoing_ogw_requests_-&gt;
      getNextToWriteTo();
    *next_write = std::move(*client_request);
    outgoing_ogw_requests_-&gt;updateWriteIndex();
  }</pre>
<p>The next subsection presents the main <code>run()</code> loop and shows how we handle incoming data from the exchange.</p>
<h2 id="_idParaDest-271"><a id="_idTextAnchor284"/>Processing market data updates and client responses</h2>
<p>The main thread <a id="_idIndexMarker1398"/>for <code>TradeEngine</code> executes the <code>run()</code> method, which simply checks the incoming data <code>LFQueue</code> and <a id="_idIndexMarker1399"/>reads and processes any available updates.</p>
<p>First, we check and drain the <code>incoming_ogw_responses_</code> queue. For each <code>MEClientResponse</code> message we read here, we call the <code>TradeEngine::onOrderUpdate()</code> method and pass the response message from <code>OrderGateway</code> to it:</p>
<pre class="source-code">
  auto TradeEngine::run() noexcept -&gt; void {
    logger_.log("%:% %() %\n", __FILE__, __LINE__,
      __FUNCTION__, Common::getCurrentTimeStr(&amp;time_str_));
    while (run_) {
      for (auto client_response = incoming_ogw_responses_-&gt;
        getNextToRead(); client_response; client_response =
          incoming_ogw_responses_-&gt;getNextToRead()) {
        logger_.log("%:% %() % Processing %\n", __FILE__,
          __LINE__, __FUNCTION__, Common::
            getCurrentTimeStr(&amp;time_str_),
                    client_response-&gt;toString().c_str());
        onOrderUpdate(client_response);
        incoming_ogw_responses_-&gt;updateReadIndex();
        last_event_time_ = Common::getCurrentNanos();
      }</pre>
<p>We perform <a id="_idIndexMarker1400"/>a similar task with <a id="_idIndexMarker1401"/>the <code>incoming_md_updates_</code> lock-free queue. We read any available <code>MEMarketUpdate</code> messages and pass them to the correct <code>MarketOrderBook</code> instance by calling the <code>MarketOrderBook::onMarketUpdate()</code> method and passing the market update to it:</p>
<pre class="source-code">
      for (auto market_update = incoming_md_updates_-&gt;
        getNextToRead(); market_update; market_update =
          incoming_md_updates_-&gt;getNextToRead()) {
        logger_.log("%:% %() % Processing %\n", __FILE__,
         __LINE__, __FUNCTION__, Common::
           getCurrentTimeStr(&amp;time_str_),
                    market_update-&gt;toString().c_str());
        ASSERT(market_update-&gt;ticker_id_ &lt;
         ticker_order_book_.size(),
               "Unknown ticker-id on update:" +
                 market_update-&gt;toString());
        ticker_order_book_[market_update-&gt;ticker_id_]-&gt;
          onMarketUpdate(market_update);
        incoming_md_updates_-&gt;updateReadIndex();
        last_event_time_ = Common::getCurrentNanos();
      }
    }
  }</pre>
<p>Note that in both <a id="_idIndexMarker1402"/>of the preceding code <a id="_idIndexMarker1403"/>blocks, when we successfully read and dispatch a market data update or an order response, we update the <code>last_event_time_</code> variable to track the time of the event, as we described earlier in this section. We will see some minor miscellaneous placeholder methods in the next subsection.</p>
<h2 id="_idParaDest-272"><a id="_idTextAnchor285"/>Handling order book, trade, and order response updates</h2>
<p>The <code>TradeEngine::onOrderBookUpdate()</code> method performs a couple of tasks. First, it <a id="_idIndexMarker1404"/>fetches <code>BBO</code> from <code>MarketOrderBook</code>, which it <a id="_idIndexMarker1405"/>receives in the method’s <a id="_idIndexMarker1406"/>arguments by calling the <code>MarketOrderBook::getBBO()</code> method. It provides the updated <code>BBO</code> to the <code>position_keeper_</code> and <code>feature_engine_</code> data members. For the <code>FeatureEngine</code> member, it calls the <code>FeatureEngine::onOrderBookUpdate()</code> method to notify the feature engine to update its feature values. The method also needs to call <code>algoOnOrderBookUpdate_()</code> so that the trading strategy can receive the notification about the order book update:</p>
<pre class="source-code">
  auto TradeEngine::onOrderBookUpdate(TickerId ticker_id,
    Price price, Side side, MarketOrderBook *book) noexcept
      -&gt; void {
    logger_.log("%:% %() % ticker:% price:% side:%\n",
      __FILE__, __LINE__, __FUNCTION__,
                Common::getCurrentTimeStr(&amp;time_str_),
                  ticker_id, Common::priceToString
                     (price).c_str(),
                Common::sideToString(side).c_str());
    const auto bbo = book-&gt;getBBO();
    position_keeper_.updateBBO(ticker_id, bbo);
    feature_engine_.onOrderBookUpdate(ticker_id, price,
       side, book);
    algoOnOrderBookUpdate_(ticker_id, price, side, book);
  }</pre>
<p>The <code>TradeEngine::onTradeUpdate()</code> method that is called on trade events also performs a <a id="_idIndexMarker1407"/>couple of tasks, which are like <a id="_idIndexMarker1408"/>the ones in the <code>onOrderBookUpdate()</code> method we just saw. It passes the trade event to <code>FeatureEngine</code> by <a id="_idIndexMarker1409"/>calling the <code>onTradeUpdate()</code> method so that the feature engine can update the features it computes. It also passes the trade event to the trading strategy by invoking the <code>algoOnTradeUpdate_()</code> <code>std::function</code> member:</p>
<pre class="source-code">
  auto TradeEngine::onTradeUpdate(const
    Exchange::MEMarketUpdate *market_update,
      MarketOrderBook *book) noexcept -&gt; void {
    logger_.log("%:% %() % %\n", __FILE__, __LINE__,
      __FUNCTION__, Common::getCurrentTimeStr(&amp;time_str_),
                market_update-&gt;toString().c_str());
    feature_engine_.onTradeUpdate(market_update, book);
    algoOnTradeUpdate_(market_update, book);
  }</pre>
<p>Finally, <code>TradeEngine::onOrderUpdate()</code> does two things. It checks whether <code>MEClientResponse</code> corresponds to <a id="_idIndexMarker1410"/>an execution (<code>ClientResponseType::FILLED</code>) and calls the <code>PositionKeeper::addFill()</code> method to update the position and PnLs. It also invokes <a id="_idIndexMarker1411"/>the <code>algoOnOrderUpdate_()</code> <code>std::function</code> member so that the trading strategy can <a id="_idIndexMarker1412"/>process the <code>MEClientResponse</code>:</p>
<pre class="source-code">
  auto TradeEngine::onOrderUpdate(const
    Exchange::MEClientResponse *client_response) noexcept
      -&gt; void {
    logger_.log("%:% %() % %\n", __FILE__, __LINE__,
      __FUNCTION__, Common::getCurrentTimeStr(&amp;time_str_),
                client_response-&gt;toString().c_str());
    if (UNLIKELY(client_response-&gt;type_ ==
     Exchange::ClientResponseType::FILLED))
      position_keeper_.addFill(client_response);
    algoOnOrderUpdate_(client_response);
  }</pre>
<p>Now, we can conclude the design and implementation of the <code>TradeEngine</code> framework in the next subsection by defining some miscellaneous methods we require.</p>
<h2 id="_idParaDest-273"><a id="_idTextAnchor286"/>Adding some miscellaneous methods</h2>
<p>This section <a id="_idIndexMarker1413"/>defines some miscellaneous methods for the <code>TradeEngine</code> class. The first method, <code>initLastEventTime()</code>, simply initializes the <code>last_event_time_</code> variable with the current time, which is obtained by calling the <code>getCurrentNanos()</code> method:</p>
<pre class="source-code">
    auto initLastEventTime() {
      last_event_time_ = Common::getCurrentNanos();
    }</pre>
<p>The <code>silentSeconds()</code> method returns the time elapsed (in seconds) since the last event was received:</p>
<pre class="source-code">
    auto silentSeconds() {
      return (Common::getCurrentNanos() - last_event_time_)
        / NANOS_TO_SECS;
    }</pre>
<p>The <code>clientId()</code> method is a simple getter method that returns <code>client_id_</code> for this <code>TradeEngine</code> instance:</p>
<pre class="source-code">
    auto clientId() const {
      return client_id_;
    }</pre>
<p>That concludes the design and implementation of our trading engine framework. In the next section, we will build the main trading application binary.</p>
<h1 id="_idParaDest-274"><a id="_idTextAnchor287"/>Building and running the main trading application</h1>
<p>In the last section <a id="_idIndexMarker1414"/>of this chapter, we will finally build the main <a id="_idIndexMarker1415"/>trading application using all the components we built in this chapter, as well as the previous two chapters. First, we will discuss the implementation of the <code>trading_main</code> binary application, which combines the <code>MarketDataConsumer</code>, <code>OrderGateway</code>, <code>MarketOrderBook</code>, and <code>TradeEngine</code> components. After that, we will run our complete electronic trading ecosystem – the electronic trading exchange (the <code>exchange_main</code> application) from the <em class="italic">Communicating with Market Participants</em> chapter and a few instances of the market participants (the <code>trading_main</code> application), which we will build next.</p>
<h2 id="_idParaDest-275"><a id="_idTextAnchor288"/>Building the main trading application</h2>
<p>Now, let us build <a id="_idIndexMarker1416"/>the executable <code>trading_main</code> binary that will initialize and run all the components on the market participant’s trading system. The source code for this application is in the <code>Chapter10/trading/trading_main.cpp</code> source file.</p>
<p>First, we will include the necessary header files and create some basic variables to represent the different components we need. Specifically, we will have a <code>Logger</code> object pointer to be used for logging purposes, a <code>TradeEngine</code> object pointer for the basic trading engine framework, a <code>MarketDataConsumer</code> object pointer to consumer market data, and an <code>OrderGateway</code> object pointer to connect to and communicate with the exchange’s order server:</p>
<pre class="source-code">
#include &lt;csignal&gt;
#include "strategy/trade_engine.h"
#include "order_gw/order_gateway.h"
#include "market_data/market_data_consumer.h"
#include "common/logging.h"
Common::Logger *logger = nullptr;
Trading::TradeEngine *trade_engine = nullptr;
Trading::MarketDataConsumer *market_data_consumer = nullptr;
Trading::OrderGateway *order_gateway = nullptr;</pre>
<p>Now, we start the entry point – the <code>main()</code> method. On the command line, we will accept arguments of the following form – <code>trading_main CLIENT_ID ALGO_TYPE [CLIP_1 THRESH_1 MAX_ORDER_SIZE_1 MAX_POS_1 MAX_LOSS_1] [CLIP_2 THRESH_2 MAX_ORDER_SIZE_2 MAX_POS_2 </code><code>MAX_LOSS_2] …</code></p>
<p>The first argument represents <code>ClientId</code> for this trading application instance. We will also accept <code>AlgoType</code> as the second parameter, and configurations for each trading algorithm instance for each <code>TickerId</code> as the remaining parameters. We will source the random number generator by calling the <code>srand()</code> method and passing it <code>client_id</code> for this specific instance:</p>
<pre class="source-code">
int main(int argc, char **argv) {
  const Common::ClientId client_id = atoi(argv[1]);
  srand(client_id);</pre>
<p>We will extract <code>AlgoType</code>, as shown here:</p>
<pre class="source-code">
  const auto algo_type = stringToAlgoType(argv[2]);</pre>
<p>We will also <a id="_idIndexMarker1417"/>initialize an object of type <code>TradeEngineCfgHashMap</code> from the remaining command-line arguments, as shown in the following code block:</p>
<pre class="source-code">
  TradeEngineCfgHashMap ticker_cfg;
  size_t next_ticker_id = 0;
  for (int i = 3; i &lt; argc; i += 5, ++next_ticker_id) {
    ticker_cfg.at(next_ticker_id) =
      {static_cast&lt;Qty&gt;(std::atoi(argv[i])),
        std::atof(argv[i + 1]),
                                     {static_cast&lt;Qty&gt;(std:
                                     :atoi(argv[i + 2])),
                                      static_cast&lt;Qty&gt;(std:
                                     :atoi(argv[i + 3])),
                                      std::atof(argv[i +
                                       4])}};
  }</pre>
<p>We will initialize the component variables we declared before – <code>Logger</code>, the <code>client_requests</code> <code>LFQueue</code>, the <code>client_responses</code> <code>LFQueue</code>, and the <code>market_updates</code> <code>LFQueue</code>. We will also define a <code>sleep_time</code> variable and set it to 20 microseconds. We <a id="_idIndexMarker1418"/>will use this value to pause between consecutive order requests we send to the trading exchange’s <code>OrderGatewayServer</code> component, only in the random trading strategy:</p>
<pre class="source-code">
  logger = new Common::Logger("trading_main_" +
    std::to_string(client_id) + ".log");
  const int sleep_time = 20 * 1000;
  Exchange::ClientRequestLFQueue
    client_requests(ME_MAX_CLIENT_UPDATES);
  Exchange::ClientResponseLFQueue
    client_responses(ME_MAX_CLIENT_UPDATES);
  Exchange::MEMarketUpdateLFQueue
    market_updates(ME_MAX_MARKET_UPDATES);
  std::string time_str;</pre>
<p>The first component we will initialize and start will be <code>TradeEngine</code>. We will pass <code>client_id</code>, <code>algo_type</code>, the strategy configurations in the <code>ticker_cfg</code> object, and the lock-free queues that <code>TradeEngine</code> needs in the constructor. We then call the <code>start()</code> method to get the main thread to start executing, as shown in the following code block:</p>
<pre class="source-code">
  logger-&gt;log("%:% %() % Starting Trade Engine...\n",
    __FILE__, __LINE__, __FUNCTION__,
     Common::getCurrentTimeStr(&amp;time_str));
  trade_engine = new Trading::TradeEngine(client_id,
    algo_type,ticker_cfg,&amp;client_requests,
        &amp;client_responses,&amp;market_updates);
  trade_engine-&gt;start();</pre>
<p>We perform a similar initialization of the <code>OrderGateway</code> component next by passing it the IP and port <a id="_idIndexMarker1419"/>information of <code>exchange_main</code>’s <code>OrderGateway</code> server component. We also pass it the <code>client_requests</code> and <code>client_responses</code> <code>LFQueue</code> variables to consume <code>MEClientRequest</code> messages from and write <code>MEClientResponse</code> messages to, and then we use <code>start()</code> on the main thread:</p>
<pre class="source-code">
  const std::string order_gw_ip = "127.0.0.1";
  const std::string order_gw_iface = "lo";
  const int order_gw_port = 12345;
  logger-&gt;log("%:% %() % Starting Order Gateway...\n",
    __FILE__, __LINE__, __FUNCTION__,
      Common::getCurrentTimeStr(&amp;time_str));
  order_gateway = new Trading::OrderGateway(client_id,
    &amp;client_requests, &amp;client_responses, order_gw_ip,
      order_gw_iface, order_gw_port);
  order_gateway-&gt;start();</pre>
<p>Finally, we initialize and start the <code>MarketDataConsumer</code> component. It needs the IP and port information of the snapshot stream and the incremental stream on which the exchange’s <code>MarketDataPublisher</code> publishes market data. It also needs the <code>market_updates</code> <code>LFQueue</code> variable, which it will write decoded market data updates to. Finally, since all the components are ready, we will start <code>market_data_consumer</code> so that we can process any market data updates available:</p>
<pre class="source-code">
  const std::string mkt_data_iface = "lo";
  const std::string snapshot_ip = "233.252.14.1";
  const int snapshot_port = 20000;
  const std::string incremental_ip = "233.252.14.3";
  const int incremental_port = 20001;
  logger-&gt;log("%:% %() % Starting Market Data
    Consumer...\n", __FILE__, __LINE__, __FUNCTION__,
      Common::getCurrentTimeStr(&amp;time_str));
  market_data_consumer = new
    Trading::MarketDataConsumer(client_id, &amp;market_updates,
      mkt_data_iface, snapshot_ip, snapshot_port,
        incremental_ip, incremental_port);
  market_data_consumer-&gt;start();</pre>
<p>Now, we are almost ready to start sending orders to the exchange; we just need to perform a few <a id="_idIndexMarker1420"/>more minor tasks first. First, the <code>main()</code> application will sleep briefly so that the threads we just created and started in each of our components can run for a few seconds:</p>
<pre class="source-code">
  usleep(10 * 1000 * 1000);</pre>
<p>We will also initialize the first event time in <code>TradeEngine</code> by calling the <code>TradeEngine::initLastEventTime()</code> method. We intentionally delayed this member’s initialization until we were ready to start trading:</p>
<pre class="source-code">
  trade_engine-&gt;initLastEventTime();</pre>
<p>If <code>AlgoType</code> is <code>AlgoType::RANDOM</code>, we will implement the trading logic right here, since it is super simple. First, we will check the <code>algo_type</code> variable, and branch if the <code>algo_type</code> argument specifies the random trading strategy:</p>
<pre class="source-code">
  if (algo_type == AlgoType::RANDOM) {</pre>
<p>For this random trading algorithm, we will create a starting <code>OrderId</code> value unique to this trading application’s instance, using the <code>client_id</code> we received from the command-line argument:</p>
<pre class="source-code">
  Common::OrderId order_id = client_id * 1000;</pre>
<p>Since we send orders with a random price, quantity, and side in our current test setup, we will initialize a random reference price for each instrument, for which we will send orders. We will send orders with prices that are randomly distributed around this reference price value shortly. We do this purely so that different trading instruments have orders of slightly different and random prices. The random reference price for each instrument is held in the <code>ticker_base_price</code> variable. We will also create <code>std::vector</code> of <code>MEClientRequest</code> messages to store the order requests we send to the exchange. We <a id="_idIndexMarker1421"/>will also send cancellations for some of these orders to exercise that functionality; hence, we will save them for when we try to cancel them:</p>
<pre class="source-code">
  std::vector&lt;Exchange::MEClientRequest&gt;
    client_requests_vec;
  std::array&lt;Price, ME_MAX_TICKERS&gt; ticker_base_price;
  for(size_t i = 0; i &lt; ME_MAX_TICKERS; ++i)
    ticker_base_price[i] = (rand() % 100) + 100;</pre>
<p>Now, we can start sending some orders to the exchange, but first, we will initialize <code>TradeEngine</code>’s <code>last_event_time_</code> variable before we get started:</p>
<pre class="source-code">
  trade_engine-&gt;initLastEventTime();</pre>
<p>In the following loop, which executes 10,000 times, we will perform a few tasks, described as follows.</p>
<p>We will pick a random <code>TickerId</code>, generate a random <code>Price</code> close to the <code>ticker_base_price</code> reference price value for that instrument, generate a random <code>Qty</code>, and generate a random <code>Side</code> for the order we will send:</p>
<pre class="source-code">
  for (size_t i = 0; i &lt; 10000; ++i) {
      const Common::TickerId ticker_id = rand() %
        Common::ME_MAX_TICKERS;
      const Price price = ticker_base_price[ticker_id] +
        (rand() % 10) + 1;
      const Qty qty = 1 + (rand() % 100) + 1;
      const Side side = (rand() % 2 ? Common::Side::BUY :
        Common::Side::SELL);</pre>
<p>We will create an <code>MEClientRequest</code> message of type <code>ClientRequestType::NEW</code> with these attributes and pass it along to <code>TradeEngine</code> using the <code>sendClientRequest()</code> method call. We will pause for <code>sleep_time</code> (20 microseconds) after we send the order request, and we will also save the <code>MEClientRequest</code> message we just sent out in the <code>client_requests_vec</code> container:</p>
<pre class="source-code">
    Exchange::MEClientRequest
      new_request{Exchange::ClientRequestType::NEW,
        client_id, ticker_id, order_id++, side, price,
          qty};
    trade_engine-&gt;sendClientRequest(&amp;new_request);
    usleep(sleep_time);
    client_requests_vec.push_back(new_request);</pre>
<p>After the pause, we <a id="_idIndexMarker1422"/>randomly pick a client request we sent from our container of client requests. We change the request type to <code>ClientRequestType::CANCEL</code> and send it through to <code>TradeEngine</code>. Then, we pause again and continue with the loop iteration:</p>
<pre class="source-code">
    const auto cxl_index = rand() %
      client_requests_vec.size();
    auto cxl_request = client_requests_vec[cxl_index];
    cxl_request.type_ =
      Exchange::ClientRequestType::CANCEL;
    trade_engine-&gt;sendClientRequest(&amp;cxl_request);
    usleep(sleep_time);
  }
}</pre>
<p>After we have sent out all of the order flow, we wait until we encounter a 60-second period where no market update and no order response have been received by <code>TradeEngine</code>. This is a simple method of detecting when there is no market activity due to this client or any other trading client being connected to the exchange:</p>
<pre class="source-code">
  while (trade_engine-&gt;silentSeconds() &lt; 60) {
    logger-&gt;log("%:% %() % Waiting till no activity, been
      silent for % seconds...\n", __FILE__, __LINE__,
        __FUNCTION__,
                Common::getCurrentTimeStr(&amp;time_str),
                  trade_engine-&gt;silentSeconds());
    using namespace std::literals::chrono_literals;
    std::this_thread::sleep_for(10s);
  }</pre>
<p>After a period <a id="_idIndexMarker1423"/>of inactivity, this application exits. We first stop each of our components and pause for a brief period, before de-initializing and exiting the application:</p>
<pre class="source-code">
  trade_engine-&gt;stop();
  market_data_consumer-&gt;stop();
  order_gateway-&gt;stop();
  using namespace std::literals::chrono_literals;
  std::this_thread::sleep_for(10s);
  delete logger;
  logger = nullptr;
  delete trade_engine;
  trade_engine = nullptr;
  delete market_data_consumer;
  market_data_consumer = nullptr;
  delete order_gateway;
  order_gateway = nullptr;
  std::this_thread::sleep_for(10s);
  exit(EXIT_SUCCESS);
}</pre>
<p>This concludes the implementation of the <code>trading_main</code> application. We have included a build script in <code>Chapter10/scripts/build.sh</code>, which uses CMake and Ninja to build the libraries and the <code>trading_main</code> application, in addition to the <code>exchange_main</code> application that we built before. You will have to edit this script to point to the correct binaries on your system or switch to a different build system if you wish. The <code>scripts/build.sh</code> script is expected to be run from the <code>Chapter10</code> <code>root</code> directory, <a id="_idIndexMarker1424"/>and it simply configures the build files, which in this case use <code>Ninja</code>, and cleans and rebuilds the build for the release and debug versions. We want to clarify that the choice of <code>Ninja</code> is completely arbitrary; we do not depend on anything that is <code>Ninja</code>-specific for our system to build and run. The build process generates binaries in the <code>Chapter10/cmake-build-release</code> and <code>Chapter10/cmake-build-debug</code> directories. The scripts to run the trading binaries use the binaries from the <code>Chapter10/cmake-build-release</code> directory.</p>
<h2 id="_idParaDest-276"><a id="_idTextAnchor289"/>Running the final trading ecosystem</h2>
<p>We are finally at the point where we can run our entire electronic trading ecosystem, admittedly with <a id="_idIndexMarker1425"/>a random trading strategy for now. We will present two scripts – one is <code>Chapter10/scripts/run_clients.sh</code>, which is configured to launch five instances of the <code>trading_main</code> application with client IDs of 1 to 5. The second script is <code>Chapter10/scripts/run_exchange_and_clients.sh</code>, which first builds the libraries and the binaries using the <code>build.sh</code> script. Then, it launches the <code>exchange_main</code> application and proceeds to launch the trading client instances using the <code>run_clients.sh</code> script. Finally, it waits for all the trading client instances to finish execution, then terminates the exchange instance, and exits.</p>
<p>We will not look at the full <code>run_clients.sh</code> script, but an example of the first trading client that creates a <code>MarketMaker</code> algorithm is shown here:</p>
<pre class="source-code">
./cmake-build-release/trading_main  1 MAKER 100 0.6 150 300 -100 60 0.6 150 300 -100 150 0.5 250 600 -100 200 0.4 500 3000 -100 1000 0.9 5000 4000 -100 300 0.8 1500 3000 -100 50 0.7 150 300 -100 100 0.3 250 300 -100 &amp;</pre>
<p>In this script, the 1 and 2 client IDs are MM trading algorithms, the 3 and 4 client IDs are liquidity taking trading algorithms, and the last client ID, 5, is a random trading algorithm. The random trading algorithm instance exists to simulate all trades made by the rest of the market participants for any reason. We do this because, in our ecosystem, we only run five trading clients (due to limited resources on our workstation). However, we encourage those interested among you with access to a lot more CPU resources <a id="_idIndexMarker1426"/>to run as many trading clients as the system can handle. Remember that, in practice, the market is composed of orders and trades from thousands of market participants (if not more).</p>
<p>First, we have the output of the build process, which is generated by running the <code>scripts/run_exchange_and_clients.sh</code> script that internally calls the <code>scripts/build.sh</code> script to first build everything. Note that you need to be in the <code>Chapter10</code> root directory, as shown here, for this script to work correctly:</p>
<pre class="source-code">
sghosh@sghosh-ThinkPad-X1-Carbon-3rd:~/Building-Low-Latency-Applications-with-CPP/Chapter10$ bash scripts/run_exchange_and_clients.sh
...
-- Build files have been written to: /home/sghosh/Building-Low-Latency-Applications-with-CPP/Chapter10/cmake-build-release
...
[36/37] Linking CXX executable trading_main
[37/37] Linking CXX executable exchange_main</pre>
<p>Then, we have the output of the <code>exchange_main</code> application starting up:</p>
<pre class="source-code">
-----------------------------------------
Starting Exchange...
-----------------------------------------
Set core affinity for Common/Logger exchange_main.log 140716464399936 to -1
Set core affinity for Common/Logger exchange_matching_engine.log 140716293985856 to -1
...</pre>
<p>Then, the output of the <code>trading_main</code> instances launching is produced:</p>
<pre class="source-code">
-----------------------------------------
Starting TradingClient 1...
-----------------------------------------
Set core affinity for Common/Logger trading_main_1.log 139636947019328 to -1
...
-----------------------------------------
Starting TradingClient 5...
-----------------------------------------
Set core affinity for Common/Logger trading_main_5.log 139837285852736 to -1
...</pre>
<p>Finally, we have the <a id="_idIndexMarker1427"/>output from the trading clients that shut down, and then the exchange exits:</p>
<pre class="source-code">
Set core affinity for Trading/MarketDataConsumer 139836325348928 to –1
...
Thu Apr  6 12:37:04 2023 Flushing and closing Logger for trading_main_1.log
...
Thu Apr  6 12:37:21 2023 Logger for trading_order_gateway_5.log exiting.
-----------------------------------------
Stopping Exchange...
-----------------------------------------
...
Thu Apr  6 12:38:09 2023 Logger for exchange_order_server.log exiting.</pre>
<p>Note that this is just the output displayed on screen. The interesting details are in the log files, which we will inspect and discuss in the next subsection.</p>
<p>One other important note is that the <code>exchange_main</code> application has 10 threads, and each <code>trading_main</code> application has 8 threads. The <code>Logger</code> threads, which are many of these threads (five for <code>exchange_main</code> and four for <code>trading_main</code>), as well as the thread for the <code>main()</code> method (one each for <code>exchange_main</code> and <code>trading_main</code>), are not CPU-intensive and sleep for most of their runtime. The optimal setup would <a id="_idIndexMarker1428"/>need a lot of cores for the entire ecosystem, which is common for production trading servers used for electronic trading. On these production-grade trading servers, we would be able to assign a CPU core to each of the remaining critical threads (four for <code>exchange_main</code> and three for <code>trading_main</code>). Since we are not sure which server we run on, we intentionally avoid setting affinity on those threads. If CPU and/or memory resources are limited on your system, our advice would be to reduce the number of trading clients launched in the <code>run_clients.sh</code> script.</p>
<h2 id="_idParaDest-277"><a id="_idTextAnchor290"/>Inspecting the output of a run</h2>
<p>In this concluding section, we will look at the log files generated by running the <code>run_exchange_and_clients.sh</code> script. We know that the trading strategy we ran in this <a id="_idIndexMarker1429"/>chapter is not interesting since it sends random orders to the exchange, but there are some important observations in these log files. Running the <code>run_exchange_and_clients.sh</code> script should generate log files similar to the following:</p>
<pre class="source-code">
exchange_main.log  exchange_market_data_publisher.log  exchange_matching_engine.log  exchange_order_server.log  exchange_snapshot_synthesizer.log
trading_engine_1.log  trading_main_1.log  trading_market_data_consumer_1.log  trading_order_gateway_1.log
… trading_order_gateway_5.log</pre>
<p>To understand and follow the events, our advice would be to correlate the log lines we generate from our calls to <code>Logger::log()</code> from various components and sub-components and then find them in the log files.</p>
<p>As an example, let us follow the path of a client sending an order to the exchange receiving the request, and generating a client response and a market update for that order request. Let us say, for this example, that we want to find the path followed by <strong class="bold">OrderId=1445</strong> and <strong class="bold">MarketOrderId=53</strong>; the path which this order follows is laid out as follows from <a id="_idIndexMarker1430"/>the log files. Note that this is just an example that was generated from this specific run and might not be reproducible; the goal here is to understand how to track the events in our ecosystem:</p>
<ol>
<li><code>MEClientRequest</code> for the new order gets sent by the <code>TradeEngine</code> component for the <code>trading_main</code> instance with <code>ClientId=1</code>:<pre class="source-code">
trading_engine_5.log:trade_engine.cpp:33 sendClientRequest() Thu Apr  6 12:26:47 2023 Sending MEClientRequest [type:NEW client:1 ticker:0 oid:1445 side:BUY qty:10 price:184]</pre></li>
<li>The <code>OrderGateway</code> component picks up that request from the lock-free queue and sends it out on the TCP connection to the exchange, as shown here:<pre class="source-code">
trading_order_gateway_5.log:order_gateway.cpp:19 run() Thu Apr  6 12:26:47 2023 Sending cid:1 seq:891 MEClientRequest [type:NEW client:1 ticker:0 oid:1445 side:BUY qty:10 price:184]</pre></li>
<li>The <code>OrderServer</code> component inside the <code>exchange_main</code> application receives it from the <code>TCPServer</code> socket, as shown here:<pre class="source-code">
exchange_order_server.log:order_server.h:55 recvCallback() Thu Apr  6 12:26:47 2023 Received OMClientRequest [seq:891 MEClientRequest [type:NEW client:1 ticker:0 oid:1445 side:BUY qty:10 price:184]]</pre></li>
<li>The <code>FifoSequencer</code> sub-component inside <code>OrderServer</code> sequences the client order request (<code>MEClientRequest</code>) based on the software receive time, and publishes it to the <code>MatchingEngine</code> lock-free queue:<pre class="source-code">
exchange_order_server.log:fifo_sequencer.h:38 sequenceAndPublish() Thu Apr  6 12:26:47 2023 Writing RX:1680802007777361000 Req:MEClientRequest [type:NEW client:1 ticker:0 oid:1445 side:BUY qty:10 price:184] to FIFO.</pre></li>
<li>The <code>MatchingEngine</code> component finally receives this request from <code>LFQueue</code> and <a id="_idIndexMarker1431"/>processes it, as displayed in the following log file:<pre class="source-code">
exchange_matching_engine.log:matching_engine.h:66 run() Thu Apr  6 12:26:47 2023 Processing MEClientRequest [type:NEW client:1 ticker:0 oid:1445 side:BUY qty:10 price:184]</pre></li>
<li>In response to the order request it received, the <code>MatchingEngine</code> component generates a <code>MEClientResponse</code> message meant for the client to be published by the <code>OrderServer</code> component:<pre class="source-code">
exchange_matching_engine.log:matching_engine.h:48 sendClientResponse() Thu Apr  6 12:26:47 2023 Sending MEClientResponse [type:ACCEPTED client:1 ticker:0 coid:1445 moid:53 side:BUY exec_qty:0 leaves_qty:10 price:184]</pre></li>
<li>Corresponding to the new order that is added to the limit order book, <code>MatchingEngine</code> also generates an <code>MEMarketUpdate</code> message, as shown here. This is meant for the <code>MarketDataPublisher</code> component to publish and update the snapshot it maintains:<pre class="source-code">
exchange_matching_engine.log:matching_engine.h:55 sendMarketUpdate() Thu Apr  6 12:26:47 2023 Sending MEMarketUpdate [ type:ADD ticker:0 oid:53 side:BUY qty:10 price:184 priority:2]</pre></li>
<li>The <code>OrderServer</code> component picks up the <code>MEClientResponse</code> message from <code>LFQueue</code>, sending out an <code>OMClientResponse</code> message to the client on the <a id="_idIndexMarker1432"/>correct TCP connection with the trading client:<pre class="source-code">
exchange_order_server.log:order_server.h:32 run() Thu Apr  6 12:26:47 2023 Processing cid:1 seq:1343 MEClientResponse [type:ACCEPTED client:1 ticker:0 coid:1445 moid:53 side:BUY exec_qty:0 leaves_qty:10 price:184]</pre></li>
<li>The <code>MarketDataPublisher</code> component picks up the <code>MEMarketUpdate</code> message sent by <code>MatchingEngine</code>, sending out an <code>MDPMarketUpdate</code> message on the incremental market data multicast stream:<pre class="source-code">
exchange_market_data_publisher.log:market_data_publisher.cpp:19 run() Thu Apr  6 12:26:47 2023 Sending seq:902 MEMarketUpdate [ type:ADD ticker:0 oid:53 side:BUY qty:10 price:184 priority:2]</pre></li>
<li>The <code>SnapshotSynthesizer</code> sub-component inside the <code>MarketDataPublisher</code> component also receives this incremental <code>MEMarketUpdate</code> message, adding it to the snapshot it maintains:<pre class="source-code">
exchange_snapshot_synthesizer.log:snapshot_synthesizer.cpp:107 run() Thu Apr  6 12:26:47 2023 Processing MDPMarketUpdate [ seq:902 MEMarketUpdate [ type:ADD ticker:0 oid:53 side:BUY qty:10 price:184 priority:2]]</pre></li>
<li>At some <a id="_idIndexMarker1433"/>point, <code>SnapshotSynthesizer</code> publishes a snapshot of the <code>MDPMarketUpdate</code> messages on the snapshot multicast market data stream, including this market update:<pre class="source-code">
exchange_snapshot_synthesizer.log:snapshot_synthesizer.cpp:88 publishSnapshot() Thu Apr  6 12:27:40 2023 MDPMarketUpdate [ seq:7 MEMarketUpdate [ type:ADD ticker:0 oid:53 side:BUY qty:10 price:184 priority:2]]</pre></li>
<li>The <code>OrderGateway</code> component inside the <code>trading_main</code> application receives the <code>OMClientResponse</code> response for the order request, from the TCPSocket that is connected to the exchange:<pre class="source-code">
trading_order_gateway_5.log:order_gateway.cpp:37 recvCallback() Thu Apr  6 12:26:47 2023 Received OMClientResponse [seq:1343 MEClientResponse [type:ACCEPTED client:1 ticker:0 coid:1445 moid:53 side:BUY exec_qty:0 leaves_qty:10 price:184]]</pre></li>
<li>The <code>MarketDataConsumer</code> component inside the <code>trading_main</code> application <a id="_idIndexMarker1434"/>receives the <code>MDPMarketUpdate</code> message on the incremental market data stream:<pre class="source-code">
trading_market_data_consumer_5.log:market_data_consumer.cpp:177 recvCallback() Thu Apr  6 12:26:47 2023 Received incremental socket len:42 MDPMarketUpdate [ seq:902 MEMarketUpdate [ type:ADD ticker:0 oid:53 side:BUY qty:10 price:184 priority:2]]</pre><pre class="source-code">
trading_market_data_consumer_5.log:market_data_consumer.cpp:193 recvCallback() Thu Apr  6 12:26:47 2023 MDPMarketUpdate [ seq:902 MEMarketUpdate [ type:ADD ticker:0 oid:53 side:BUY qty:10 price:184 priority:2]]</pre></li>
<li>The <code>TradeEngine</code> component finally receives the <code>MEClientResponse</code> message from the <code>OrderGateway</code> component over the lock-free queue. It also forwards the <code>MEClientResponse</code> message via the <code>onOrderUpdate()</code> callback:<pre class="source-code">
trading_engine_5.log:trade_engine.cpp:44 run() Thu Apr  6 12:26:47 2023 Processing MEClientResponse [type:ACCEPTED client:1 ticker:0 coid:1445 moid:53 side:BUY exec_qty:0 leaves_qty:10 price:184]</pre><pre class="source-code">
trading_engine_5.log:trade_engine.cpp:75 onOrderUpdate() Thu Apr  6 12:26:47 2023 MEClientResponse [type:ACCEPTED client:1 ticker:0 coid:1445 moid:53 side:BUY exec_qty:0 leaves_qty:10 price:184]</pre></li>
<li><code>TradeEngine</code> also receives the <code>MEMarketUpdate</code> message, updates <code>MarketOrderBook</code>, and, in turn, receives <code>onOrderBookUpdate()</code> from the order book back in <code>TradeEngine</code>:<pre class="source-code">
trading_engine_5.log:trade_engine.cpp:52 run() Thu Apr  6 12:26:47 2023 Processing MEMarketUpdate [ type:ADD ticker:0 oid:53 side:BUY qty:10 price:184 priority:2]</pre><pre class="source-code">
trading_engine_5.log:trade_engine.cpp:64 onOrderBookUpdate() Thu Apr  6 12:26:47 2023 ticker:0 price:184 side:BUY</pre></li>
</ol>
<p>Hopefully, this <a id="_idIndexMarker1435"/>example provided you with good insight into what the different components in our trading ecosystem do. This should also serve as an example of how to investigate different events in the various applications, components, and sub-components of our electronic trading universe.</p>
<p>Now, let us focus on the entries generated by our other components – <code>FeatureEngine</code>, <code>RiskManager</code>, <code>PositionKeeper</code>, and <code>OrderManager</code> – and the strategies – the <code>MarketMaker</code> and <code>LiquidityTaker</code> algorithms:</p>
<ol>
<li>The following log lines display the feature values that are updated by <code>FeatureEngine</code> as the order book updates or new trade events occur in market data:<pre class="source-code">
trading_engine_1.log:feature_engine.h:23 onOrderBookUpdate() Thu May 11 16:10:45 2023 ticker:7 price:152 side:BUY mkt-price:152.394 agg-trade-ratio:0.0994475</pre><pre class="source-code">
trading_engine_1.log:feature_engine.h:34 onTradeUpdate() Thu May 11 16:10:45 2023 MEMarketUpdate [ type:TRADE ticker:1 oid:INVALID side:SELL qty:50 price:170 priority:INVALID] mkt-price:170.071 agg-trade-ratio:1</pre><pre class="source-code">
trading_engine_1.log:feature_engine.h:23 onOrderBookUpdate() Thu May 11 16:10:45 2023 ticker:2 price:119 side:SELL mkt-price:115.299 agg-trade-ratio:0.262712</pre><pre class="source-code">
trading_engine_1.log:feature_engine.h:34 onTradeUpdate() Thu May 11 16:10:45 2023 MEMarketUpdate [ type:TRADE ticker:3 oid:INVALID side:BUY qty:18 price:180 priority:INVALID] mkt-price:115.299 agg-trade-ratio:0.00628931</pre><pre class="source-code">
trading_engine_1.log:feature_engine.h:23 onOrderBookUpdate() Thu May 11 16:10:45 2023 ticker:3 price:180 side:SELL mkt-price:178.716 agg-trade-ratio:0.00628931</pre><pre class="source-code">
trading_engine_1.log:feature_engine.h:34 onTradeUpdate() Thu May 11 16:10:45 2023 MEMarketUpdate [ type:TRADE ticker:3 oid:INVALID side:BUY qty:30 price:180 priority:INVALID] mkt-price:178.716 agg-trade-ratio:0.0105485</pre></li>
<li>The following <a id="_idIndexMarker1436"/>log lines correspond to <code>PositionKeeper</code> being updated as <code>BBO</code> changes or additional executions are processed:<pre class="source-code">
trading_engine_1.log:position_keeper.h:75 addFill() Thu May 11 16:10:38 2023 Position{pos:476 u-pnl:-120.715 r-pnl:6248.71 t-pnl:6128 vol:8654 vwaps:[114.254X0] BBO{21@115X116@296}} MEClientResponse [type:FILLED client:1 ticker:2 coid:962 moid:1384 side:BUY exec_qty:25 leaves_qty:102 price:114]</pre><pre class="source-code">
trading_engine_1.log:position_keeper.h:98 updateBBO() Thu May 11 16:10:42 2023 Position{pos:194 u-pnl:15.8965 r-pnl:311.103 t-pnl:327 vol:802 vwaps:[180.918X0] BBO{730@180X182@100}} BBO{730@180X182@100}</pre><pre class="source-code">
trading_engine_1.log:position_keeper.h:75 addFill() Thu May 11 16:10:42 2023 Position{pos:392 u-pnl:688.98 r-pnl:6435.02 t-pnl:7124 vol:8782 vwaps:[114.242X0] BBO{44@114X116@150}} MEClientResponse [type:FILLED client:1 ticker:2 coid:970 moid:1394 side:SELL exec_qty:83 leaves_qty:44 price:116]</pre><pre class="source-code">
trading_engine_1.log:position_keeper.h:98 updateBBO() Thu May 11 16:10:44 2023 Position{pos:373 u-pnl:282.585 r-pnl:6468.41 t-pnl:6751 vol:8801 vwaps:[114.242X0] BBO{19@114X116@131}} BBO{19@114X116@131}</pre></li>
<li>Failures <a id="_idIndexMarker1437"/>in <code>RiskManager</code>, due to several reasons we discussed in the <em class="italic">Building the C++ trading algorithm building blocks</em> chapter in the <em class="italic">Computing and managing risk</em> section, show up in the log files as something like the following:<pre class="source-code">
trading_engine_1.log:order_manager.h:69 moveOrder() Thu May 11 16:10:41 2023 Ticker:1 Side:BUY Qty:60 RiskCheckResult:POSITION_TOO_LARGE</pre><pre class="source-code">
trading_engine_1.log:order_manager.h:69 moveOrder() Thu May 11 16:10:41 2023 Ticker:4 Side:SELL Qty:1000 RiskCheckResult:LOSS_TOO_LARGE</pre><pre class="source-code">
trading_engine_1.log:order_manager.h:69 moveOrder() Thu May 11 16:10:42 2023 Ticker:2 Side:BUY Qty:150 RiskCheckResult:POSITION_TOO_LARGE</pre></li>
<li>Events in <code>OrderManager</code> appear as follows in the log files, as attempts are made to <a id="_idIndexMarker1438"/>send order requests and responses are processed:<pre class="source-code">
trading_engine_1.log:order_manager.h:26 onOrderUpdate() Thu May 11 16:10:36 2023 OMOrder[tid:6 oid:965 side:SELL price:125 qty:15 state:PENDING_CANCEL]</pre><pre class="source-code">
trading_engine_1.log:order_manager.cpp:13 newOrder() Thu May 11 16:10:37 2023 Sent new order MEClientRequest [type:NEW client:1 ticker:6 oid:966 side:SELL qty:50 price:126] for OMOrder[tid:6 oid:966 side:SELL price:126 qty:50 state:PENDING_NEW]</pre><pre class="source-code">
trading_engine_1.log:order_manager.h:23 onOrderUpdate() Thu May 11 16:10:37 2023 MEClientResponse [type:ACCEPTED client:1 ticker:6 coid:966 moid:1806 side:SELL exec_qty:0 leaves_qty:50 price:126]</pre><pre class="source-code">
trading_engine_1.log:order_manager.h:26 onOrderUpdate() Thu May 11 16:10:37 2023 OMOrder[tid:6 oid:966 side:SELL price:126 qty:50 state:PENDING_NEW]</pre><pre class="source-code">
trading_engine_1.log:order_manager.cpp:26 cancelOrder() Thu May 11 16:10:37 2023 Sent cancel MEClientRequest [type:CANCEL client:1 ticker:1 oid:927 side:SELL qty:60 price:170] for OMOrder[tid:1 oid:927 side:SELL price:170 qty:60 state:PENDING_CANCEL]</pre><pre class="source-code">
trading_engine_1.log:order_manager.h:23 onOrderUpdate() Thu May 11 16:10:37 2023 MEClientResponse [type:CANCELED client:1 ticker:1 coid:927 moid:1826 side:SELL exec_qty:INVALID leaves_qty:60 price:170]</pre></li>
<li>Events in the <code>LiquidityTaker</code> trading strategy appear as shown here. These correspond <a id="_idIndexMarker1439"/>to order book updates, trade events, and updates to strategy orders:<pre class="source-code">
trading_engine_1.log:liquidity_taker.h:19 onOrderBookUpdate() Thu May 11 16:07:48 2023 ticker:4 price:183 side:SELL</pre><pre class="source-code">
trading_engine_1.log:liquidity_taker.h:19 onOrderBookUpdate() Thu May 11 16:07:48 2023 ticker:7 price:153 side:BUY</pre><pre class="source-code">
trading_engine_1.log:liquidity_taker.h:25 onTradeUpdate() Thu May 11 16:07:48 2023 MEMarketUpdate [ type:TRADE ticker:7 oid:INVALID side:SELL qty:90 price:154 priority:INVALID]</pre><pre class="source-code">
trading_engine_1.log:liquidity_taker.h:32 onTradeUpdate() Thu May 11 16:07:48 2023 BBO{368@154X155@2095} agg-qty-ratio:0.244565</pre><pre class="source-code">
trading_engine_1.log:liquidity_taker.h:19 onOrderBookUpdate() Thu May 11 16:07:48 2023 ticker:7 price:154 side:BUY</pre><pre class="source-code">
trading_engine_1.log:liquidity_taker.h:49 onOrderUpdate() Thu May 11 16:07:48 2023 MEClientResponse [type:FILLED client:3 ticker:7 coid:202 moid:792 side:BUY exec_qty:90 leaves_qty:183 price:154]</pre><pre class="source-code">
trading_engine_1.log:liquidity_taker.h:19 onOrderBookUpdate() Thu May 11 16:07:48 2023 ticker:0 price:180 side:BUY</pre></li>
<li>Similarly, <a id="_idIndexMarker1440"/>events in the <code>MarketMaker</code> trading algorithm appear in the log files, as shown here:<pre class="source-code">
trading_engine_1.log:market_maker.h:47 onOrderUpdate() Thu May 11 16:06:12 2023 MEClientResponse [type:FILLED client:1 ticker:5 coid:418 moid:552 side:BUY exec_qty:62 leaves_qty:160 price:137]</pre><pre class="source-code">
trading_engine_1.log:market_maker.h:42 onTradeUpdate() Thu May 11 16:06:12 2023 MEMarketUpdate [ type:TRADE ticker:3 oid:INVALID side:BUY qty:47 price:180 priority:INVALID]</pre><pre class="source-code">
trading_engine_1.log:market_maker.h:19 onOrderBookUpdate() Thu May 11 16:06:12 2023 ticker:3 price:180 side:SELL</pre><pre class="source-code">
trading_engine_1.log:market_maker.h:27 onOrderBookUpdate() Thu May 11 16:06:12 2023 BBO{2759@178X180@2409} fair-price:179.068</pre><pre class="source-code">
trading_engine_1.log:market_maker.h:19 onOrderBookUpdate() Thu May 11 16:06:12 2023 ticker:0 price:183 side:SELL</pre><pre class="source-code">
trading_engine_1.log:market_maker.h:27 onOrderBookUpdate() Thu May 11 16:06:12 2023 BBO{4395@181X182@534} fair-price:181.892</pre><pre class="source-code">
trading_engine_1.log:market_maker.h:42 onTradeUpdate() Thu May 11 16:06:12 2023 MEMarketUpdate [ type:TRADE ticker:5 oid:INVALID side:SELL qty:62 price:137 priority:INVALID]</pre><pre class="source-code">
trading_engine_1.log:market_maker.h:19 onOrderBookUpdate() Thu May 11 16:06:12 2023 ticker:5 price:137 side:BUY</pre></li>
</ol>
<p>We encourage you <a id="_idIndexMarker1441"/>to inspect the various log files in more detail to understand the processing that occurs in the different components and how our entire electronic trading ecosystem functions.</p>
<h1 id="_idParaDest-278"><a id="_idTextAnchor291"/>Summary</h1>
<p>This chapter focused on using all the components we have built over the last two chapters and leveraging them to build our intelligent trading strategies – the MM trading strategy and the liquidity taking trading algorithm. We spent some time understanding the theory, motivation, and behavior of these two trading algorithms with some examples.</p>
<p>In the next two sections, we implemented the C++ MM trading algorithm, which manages passive orders, and the liquidity taking algorithm, which sends aggressive orders to the market.</p>
<p>Then, we built the trading engine framework that ties together the market data consumer, the order gateway, the feature engine, the position keeper, the order manager, and the risk manager together with the two trading algorithms. This framework is what we use to join all these components together and facilitate the flow of incoming and outgoing data streams and trading intelligence.</p>
<p>Finally, we built the main trading application, <code>trading_main</code>, which is the complement of the <code>exchange_main</code> application on the market participant’s side. We then ran a few different instances of the trading application to run instances of the random trading algorithm, the MM algorithm, and the liquidity taking algorithm in our ecosystem. We inspected the log files generated by running our electronic trading ecosystem as the different trading client systems and strategies interacted with each other through the electronic exchange.</p>
<p>In the next chapter, we will add an instrumentation system to measure the performance of our entire electronic trading ecosystem. We mentioned throughout this book that the first step to optimizing something is measuring the performance of a system and its components individually, and we will start by doing that in the next chapter.</p>
</div>


<div><h1 id="_idParaDest-279"><a id="_idTextAnchor292"/>Part 4:Analyzing and Improving Performance</h1>
<p>In this part, we will measure the performance of all the different C++ components in our trading ecosystem. We will analyze the latency profile of the different components individually, as well as measuring the performance of the end-to-end round-trip path. From there, we will discuss further optimization techniques and see the impact of our C++ optimization efforts. We will also discuss some future enhancements that can be made to our electronic trading ecosystem.</p>
<p>This part contains the following chapters:</p>
<ul>
<li><em class="italic">Chapter 11, Adding Instrumentation and Measuring Performance</em></li>
<li><em class="italic">Chapter 12, Analyzing and Optimizing the Performance of Our C++ System</em></li>
</ul>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
</body></html>