<html><head></head><body>
<div id="_idContainer066">
<h1 class="chapter-number" id="_idParaDest-249"><a id="_idTextAnchor262"/><span class="koboSpan" id="kobo.1.1">10</span></h1>
<h1 id="_idParaDest-250"><a id="_idTextAnchor263"/><span class="koboSpan" id="kobo.2.1">Building the C++ Market Making and Liquidity Taking Algorithms</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In this chapter, we will implement a C++ market making algorithm on top of all the components we built in the previous chapters. </span><span class="koboSpan" id="kobo.3.2">This market making algorithm will connect to and send orders to the trading exchange we built previously. </span><span class="koboSpan" id="kobo.3.3">Additionally, we will implement a C++ liquidity taking algorithm in the same trading engine framework. </span><span class="koboSpan" id="kobo.3.4">This liquidity taking algorithm will also connect to and send orders to the </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">trading exchange.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">Understanding the behavior of our </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">trading algorithms</span></span></li>
<li><span class="koboSpan" id="kobo.9.1">Managing the passive liquidity provided in the </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">order book</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Opening and closing </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">positions aggressively</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Building the trade </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">engine framework</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Building and running the main </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">trading application</span></span></li>
</ul>
<h1 id="_idParaDest-251"><a id="_idTextAnchor264"/><span class="koboSpan" id="kobo.17.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.18.1">All the code for this book can be found in its GitHub repository at </span><a href="https://github.com/PacktPublishing/Building-Low-Latency-Applications-with-CPP"><span class="koboSpan" id="kobo.19.1">https://github.com/PacktPublishing/Building-Low-Latency-Applications-with-CPP</span></a><span class="koboSpan" id="kobo.20.1">. </span><span class="koboSpan" id="kobo.20.2">The source for this chapter is in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.21.1">Chapter10</span></strong><span class="koboSpan" id="kobo.22.1"> directory in </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">the repository.</span></span></p>
<p><span class="koboSpan" id="kobo.24.1">It is important that you have read and understood the design of the electronic trading ecosystem presented in the </span><em class="italic"><span class="koboSpan" id="kobo.25.1">Designing Our Trading Ecosystem</span></em><span class="koboSpan" id="kobo.26.1"> chapter, especially the </span><em class="italic"><span class="koboSpan" id="kobo.27.1">Designing a framework for low latency C++ trading algorithms</span></em><span class="koboSpan" id="kobo.28.1"> section. </span><span class="koboSpan" id="kobo.28.2">It is also expected that you are quite familiar with the previous two chapters – </span><em class="italic"><span class="koboSpan" id="kobo.29.1">Processing Market Data and Sending Orders to the Exchange in C++</span></em><span class="koboSpan" id="kobo.30.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.31.1">Building the C++ Trading Algorithm Building Blocks</span></em><span class="koboSpan" id="kobo.32.1">, since we will be using every single component that we built in those two chapters in </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.34.1">The specifications of the environment in which the source code for this book was developed are shown here. </span><span class="koboSpan" id="kobo.34.2">We present the details of this environment since all the C++ code presented in this book is not necessarily portable and might require some minor changes to work in </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">your environment:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.36.1">OS: </span><strong class="source-inline"><span class="koboSpan" id="kobo.37.1">Linux 5.19.0-41-generic #42~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Tue Apr 18 17:40:00 UTC 2 x86_64 x86_64 </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.38.1">x86_64 GNU/Linux</span></strong></span></li>
<li><span class="koboSpan" id="kobo.39.1">GCC: </span><strong class="source-inline"><span class="koboSpan" id="kobo.40.1">g++ (Ubuntu </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.41.1">11.3.0-1ubuntu1~22.04.1) 11.3.0</span></strong></span></li>
<li><span class="koboSpan" id="kobo.42.1">CMake: </span><strong class="source-inline"><span class="koboSpan" id="kobo.43.1">cmake </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.44.1">version 3.23.2</span></strong></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.45.1">Ninja: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.46.1">1.10.2</span></strong></span></li>
</ul>
<h1 id="_idParaDest-252"><a id="_idTextAnchor265"/><span class="koboSpan" id="kobo.47.1">Understanding the behavior of our trading algorithms</span></h1>
<p><span class="koboSpan" id="kobo.48.1">In this section, we will discuss some additional details about the behavior and motivation behind the two trading strategies we will build in this chapter – the market making trading </span><a id="_idIndexMarker1321"/><span class="koboSpan" id="kobo.49.1">strategy and the liquidity taking trading strategy. </span><span class="koboSpan" id="kobo.49.2">With the use of a hypothetical example for each strategy, we will also try to understand the strategy order flow mechanics and try to further our understanding when we implement these trading strategies in our C++ system, towards the end of </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">this chapter.</span></span></p>
<h2 id="_idParaDest-253"><a id="_idTextAnchor266"/><span class="koboSpan" id="kobo.51.1">Understanding the market making trading algorithm</span></h2>
<p><span class="koboSpan" id="kobo.52.1">The market making trading strategies seek to make profits by seeking to </span><em class="italic"><span class="koboSpan" id="kobo.53.1">capture the spread</span></em><span class="koboSpan" id="kobo.54.1">, which just </span><a id="_idIndexMarker1322"/><span class="koboSpan" id="kobo.55.1">means buying at the best bid price in the </span><a id="_idIndexMarker1323"/><span class="koboSpan" id="kobo.56.1">market passively and quickly selling at the best ask price in the market passively (or selling first and buying after). </span><span class="koboSpan" id="kobo.56.2">The market making strategies, profitability depends on the spread of the trading instrument, how many buy and sell trades the strategy can execute over time, and how much market prices move between the buy and sell trades. </span><span class="koboSpan" id="kobo.56.3">It </span><a id="_idIndexMarker1324"/><span class="koboSpan" id="kobo.57.1">should be clear that the market making strategies will trade only against other strategies that </span><em class="italic"><span class="koboSpan" id="kobo.58.1">cross the spread</span></em><span class="koboSpan" id="kobo.59.1"> and send aggressive buy and sell orders, which is what we refer to as </span><strong class="bold"><span class="koboSpan" id="kobo.60.1">liquidity taking trading strategies</span></strong><span class="koboSpan" id="kobo.61.1">. </span><span class="koboSpan" id="kobo.61.2">What this means is that market making trading strategies rarely expect to trade against other market making trading strategies, since all instances of such strategies seek to execute their </span><a id="_idIndexMarker1325"/><span class="koboSpan" id="kobo.62.1">orders passively. </span><span class="koboSpan" id="kobo.62.2">To achieve this, market making trading strategies </span><a id="_idIndexMarker1326"/><span class="koboSpan" id="kobo.63.1">send and manage passive limit orders in the order book and try to use intelligence to modify the prices on these orders, thereby improving their execution and the probability of successfully capturing the spread as often as possible. </span><span class="koboSpan" id="kobo.63.2">In the next subsection, we will discuss a hypothetical example of how a market making trading strategy would manage </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">its orders.</span></span></p>
<h2 id="_idParaDest-254"><a id="_idTextAnchor267"/><span class="koboSpan" id="kobo.65.1">Inspecting market making mechanics with an example</span></h2>
<p><span class="koboSpan" id="kobo.66.1">In this subsection, we will discuss the mechanics of how our market making trading strategy would </span><a id="_idIndexMarker1327"/><span class="koboSpan" id="kobo.67.1">behave under a hypothetical market condition. </span><span class="koboSpan" id="kobo.67.2">This will help strengthen your understanding of how the market making algorithm behaves. </span><span class="koboSpan" id="kobo.67.3">Before we do that, let us try to understand the </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">following table.</span></span></p>
<p><span class="koboSpan" id="kobo.69.1">The table presents a state of the market book known as the </span><strong class="bold"><span class="koboSpan" id="kobo.70.1">price level-aggregated order book</span></strong><span class="koboSpan" id="kobo.71.1">. </span><span class="koboSpan" id="kobo.71.2">What this term means is that all the orders on the same side and same price are grouped/aggregated together into a single price level, so if there are 12 orders on the bid side, all at the same price (10.21), that add up to a total quantity of 2,500, they can be presented </span><a id="_idIndexMarker1328"/><span class="koboSpan" id="kobo.72.1">as a single entry. </span><span class="koboSpan" id="kobo.72.2">This is shown as follows, along with similar grouping on the next buy price level of 10.20 and ask levels of 10.22 and </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">10.23 prices.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer058">
<span class="koboSpan" id="kobo.74.1"><img alt="Figure 10.1 – A snapshot of an order book, arranged as a price level-aggregated book" src="image/B19434_10_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.75.1">Figure 10.1 – A snapshot of an order book, arranged as a price level-aggregated book</span></p>
<p><span class="koboSpan" id="kobo.76.1">In the preceding diagram, the columns mean the following things (from left </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">to right):</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.78.1">Our MM strategy bid</span></strong><span class="koboSpan" id="kobo.79.1">: This represents the quantity of the buy order that our </span><strong class="bold"><span class="koboSpan" id="kobo.80.1">Market Making</span></strong><span class="koboSpan" id="kobo.81.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.82.1">MM</span></strong><span class="koboSpan" id="kobo.83.1">) strategy has at this price level, which in this case </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">is none</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.85.1">Market bid order count</span></strong><span class="koboSpan" id="kobo.86.1">: This represents the number of buy orders in the market that make up this </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">price level</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.88.1">Market bid quantity</span></strong><span class="koboSpan" id="kobo.89.1">: The sum of the quantities on all the buy orders at this </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">price level</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.91.1">Market bid price</span></strong><span class="koboSpan" id="kobo.92.1">: This represents the price of this bid </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">price level</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.94.1">Market ask price</span></strong><span class="koboSpan" id="kobo.95.1">: This represents the price of this ask </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">price level</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.97.1">Market ask quantity</span></strong><span class="koboSpan" id="kobo.98.1">: The sum of the quantities of all the sell orders at this </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">price level</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.100.1">Market ask order count</span></strong><span class="koboSpan" id="kobo.101.1">: This represents the number of sell orders in the market that make up this </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">price level</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.103.1">Our MM strategy ask</span></strong><span class="koboSpan" id="kobo.104.1">: This represents the quantity of the sell order that our MM strategy has at this price level, which in this case </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">is none</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.106.1">Now, let us suppose our MM strategy starts running at the time that the market is in the state we described here. </span><span class="koboSpan" id="kobo.106.2">Let us also assume that, for this example, our strategy will send a single passive </span><a id="_idIndexMarker1329"/><span class="koboSpan" id="kobo.107.1">bid order and a single passive ask order, and each has a quantity of 100 shares. </span><span class="koboSpan" id="kobo.107.2">Let us say that the strategy decides to join the best bid price level and the best ask price level at prices 10.21 and 10.22, respectively. </span><span class="koboSpan" id="kobo.107.3">It does this by sending a single buy order and a single sell order of a quantity of 100 at those prices. </span><span class="koboSpan" id="kobo.107.4">The following diagram represents this event, and the blocks highlighted in gold represent the things that changed because of </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">this action.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer059">
<span class="koboSpan" id="kobo.109.1"><img alt="Figure 10.2 – An event where our MM order has joined the market on both sides" src="image/B19434_10_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.110.1">Figure 10.2 – An event where our MM order has joined the market on both sides</span></p>
<p><span class="koboSpan" id="kobo.111.1">Finally, for one last scenario, let us assume that the orders on the best bid at 10.21 are either fully executed due to trade events and removed, or just canceled by the market participants that owned them. </span><span class="koboSpan" id="kobo.111.2">If the drop in quantity is large enough, let us assume that our MM trading strategy also decides to not be present at the price level. </span><span class="koboSpan" id="kobo.111.3">The state of the price </span><a id="_idIndexMarker1330"/><span class="koboSpan" id="kobo.112.1">aggregated order book looks like this right before our strategy decides to move its best bid order at a price one price level away from its current price, i.e., from price 10.21 </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">to 10.20:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer060">
<span class="koboSpan" id="kobo.114.1"><img alt="Figure 10.3 – The state of the price level book when our MM order decides to move its bid" src="image/B19434_10_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.115.1">Figure 10.3 – The state of the price level book when our MM order decides to move its bid</span></p>
<p><span class="koboSpan" id="kobo.116.1">This decision can be due to a wide range of factors, depending on the strategy and its features. </span><span class="koboSpan" id="kobo.116.2">However, for this example, let us offer you a simple intuitive thought – a lot of people are less willing to buy at 10.21 (only 600 shares in total) compared to how many people are willing to sell at 10.22 (6,500 shares). </span><span class="koboSpan" id="kobo.116.3">You might conclude that perhaps it is no longer wise to try and buy at 10.21 or that the fair market price is perhaps at 10.21, and you want to try and buy at a price that is a little lower than that. </span><span class="koboSpan" id="kobo.116.4">The next diagram displays the state of the price level book when the MM strategy decides to cancel its buy order at 10.21 and repositions its buy order </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">to 10.20.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer061">
<span class="koboSpan" id="kobo.118.1"><img alt="Figure 10.4 – An event where our MM strategy repositions its bid from a price of 10.21 to 10.20" src="image/B19434_10_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.119.1">Figure 10.4 – An event where our MM strategy repositions its bid from a price of 10.21 to 10.20</span></p>
<p><span class="koboSpan" id="kobo.120.1">The discussion in this subsection aimed to improve your understanding of the mechanics of a simple MM strategy, and in the next subsection, we will move on to the liquidity taking </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">trading algorithm.</span></span></p>
<h2 id="_idParaDest-255"><a id="_idTextAnchor268"/><span class="koboSpan" id="kobo.122.1">Understanding the liquidity taking trading algorithm</span></h2>
<p><span class="koboSpan" id="kobo.123.1">The liquidity taking trading algorithm in many ways is the opposite of the MM algorithm. </span><span class="koboSpan" id="kobo.123.2">Instead of sending </span><a id="_idIndexMarker1331"/><span class="koboSpan" id="kobo.124.1">passive orders to the book and waiting </span><a id="_idIndexMarker1332"/><span class="koboSpan" id="kobo.125.1">for them to be executed passively, it sends aggressive orders to execute trades when it needs them. </span><span class="koboSpan" id="kobo.125.2">In this sense, it </span><em class="italic"><span class="koboSpan" id="kobo.126.1">crosses the spread</span></em><span class="koboSpan" id="kobo.127.1"> (sends aggressive orders to execute) instead of trying to </span><em class="italic"><span class="koboSpan" id="kobo.128.1">capture the spread</span></em><span class="koboSpan" id="kobo.129.1">, like the MM strategy. </span><span class="koboSpan" id="kobo.129.2">This strategy bets on getting the direction of the market correct – that is, it buys aggressively when it thinks that prices will increase further and sells aggressively when it thinks that prices will decrease further. </span><span class="koboSpan" id="kobo.129.3">The convenient fact about this trading algorithm is that order management is very easy since it does not always maintain live orders in the order book that it needs to manage. </span><span class="koboSpan" id="kobo.129.4">Another way to understand this is that when the strategy needs to execute a trade, it sends an order to the order book and gets executed almost immediately, and then it is done from an order management perspective. </span><span class="koboSpan" id="kobo.129.5">The inconvenient fact about this trading algorithm is that predicting market directions is extremely difficult, but we will not dive into that, since that is not the focus of this book. </span><span class="koboSpan" id="kobo.129.6">In the next subsection, we will understand the trading mechanics for this strategy as we did with the </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">MM strategy.</span></span></p>
<h3><span class="koboSpan" id="kobo.131.1">Inspecting liquidity taking mechanics with an example</span></h3>
<p><span class="koboSpan" id="kobo.132.1">Once again, let us look at the price level-aggregated view of the order book, as discussed in the section on MM. </span><span class="koboSpan" id="kobo.132.2">The columns here mean the same thing, except they do not have the columns for </span><a id="_idIndexMarker1333"/><span class="koboSpan" id="kobo.133.1">the MM strategy orders, since the liquidity taking strategy will not rest orders passively in the order book. </span><span class="koboSpan" id="kobo.133.2">Let us assume the initial state of the price level book is as shown here, which was also the same initial state for the </span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">MM example.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer062">
<span class="koboSpan" id="kobo.135.1"><img alt="Figure 10.5 – The state of the price level book at a given time for a hypothetical example" src="image/B19434_10_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.136.1">Figure 10.5 – The state of the price level book at a given time for a hypothetical example</span></p>
<p><span class="koboSpan" id="kobo.137.1">Let us assume that, for this example, our liquidity taking strategy has a feature that tries to follow in the same direction as very large trades. </span><span class="koboSpan" id="kobo.137.2">What this means is that if a very large trade event happens in the market, our liquidity taking algorithm decides to take the same direction as this trade event. </span><span class="koboSpan" id="kobo.137.3">So, if a very large buy trade happens, our liquidity taking algorithm will buy aggressively, and if a very sell trade happens, our liquidity taking algorithm will sell aggressively. </span><span class="koboSpan" id="kobo.137.4">As mentioned before, this is only an example feature; in practice, different liquidity taking algorithms will have many such features on which the decision to make a trade depends. </span><span class="koboSpan" id="kobo.137.5">For our simple liquidity taking algorithm example, we will use this feature of large aggressive trade in </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">the market.</span></span></p>
<p><span class="koboSpan" id="kobo.139.1">To understand what that looks like, let us assume that given the previous state of the price level book, a </span><a id="_idIndexMarker1334"/><span class="koboSpan" id="kobo.140.1">very large sell execution of a quantity of 2,200 hits the bid price level of 10.21, which had a total quantity of 2,500 prior to this. </span><span class="koboSpan" id="kobo.140.2">This event is shown in the following diagram, where the green arrow represents the trade aggressor in </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">market data.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer063">
<span class="koboSpan" id="kobo.142.1"><img alt="Figure 10.6 – An event where a large sell aggressor causes a trade event" src="image/B19434_10_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.143.1">Figure 10.6 – An event where a large sell aggressor causes a trade event</span></p>
<p><span class="koboSpan" id="kobo.144.1">This trade event will cause the best bid quantity to reduce from 2,500 to 300 – that is, by the quantity of the trade aggressor. </span><span class="koboSpan" id="kobo.144.2">Additionally, let us assume that our liquidity taking strategy observes the large trade of a quantity of 2,200 and decides to send an aggressive sell order at the price of 10.21. </span><span class="koboSpan" id="kobo.144.3">Let us also assume that, like the MM strategy, our liquidity taking strategy also sends a sell order of a quantity of 100. </span><span class="koboSpan" id="kobo.144.4">This event is shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">following diagram.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer064">
<span class="koboSpan" id="kobo.146.1"><img alt="Figure 10.7 – An event where our liquidity taking algorithm sends an aggressive sell order of a quantity of 100 at a price of 10.21" src="image/B19434_10_07.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.147.1">Figure 10.7 – An event where our liquidity taking algorithm sends an aggressive sell order of a quantity of 100 at a price of 10.21</span></p>
<p><span class="koboSpan" id="kobo.148.1">That concludes the theoretical discussion of the two trading strategies we seek to build as part of our trading system. </span><span class="koboSpan" id="kobo.148.2">We will get to their actual implementation inside our framework </span><a id="_idIndexMarker1335"/><span class="koboSpan" id="kobo.149.1">in a few sections’ time, but first, we need to build some additional building blocks for these strategies, which we will do in the </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">next section.</span></span></p>
<h2 id="_idParaDest-256"><a id="_idTextAnchor269"/><span class="koboSpan" id="kobo.151.1">Adding an enumeration to define the type of algorithm</span></h2>
<p><span class="koboSpan" id="kobo.152.1">We will round up this discussion of our trading strategies by defining an </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">AlgoType</span></strong><span class="koboSpan" id="kobo.154.1"> enumeration </span><a id="_idIndexMarker1336"/><span class="koboSpan" id="kobo.155.1">in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.156.1">Chapter10/common/types.h</span></strong><span class="koboSpan" id="kobo.157.1"> header file. </span><span class="koboSpan" id="kobo.157.2">It has the following valid values – </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">MAKER</span></strong><span class="koboSpan" id="kobo.159.1"> to represent MM, </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">TAKER</span></strong><span class="koboSpan" id="kobo.161.1"> to represent liquidity taking, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">RANDOM</span></strong><span class="koboSpan" id="kobo.163.1"> to represent the random trading strategy we built before. </span><span class="koboSpan" id="kobo.163.2">We also have </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">INVALID</span></strong><span class="koboSpan" id="kobo.165.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">MAX</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.167.1"> values:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.168.1">
  enum class AlgoType : int8_t {
    INVALID = 0,
    RANDOM = 1,
    MAKER = 2,
    TAKER = 3,
    MAX = 4
  };</span></pre>
<p><span class="koboSpan" id="kobo.169.1">We will add a standard </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">algoTypeToString()</span></strong><span class="koboSpan" id="kobo.171.1"> method used to stringify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">AlgoType</span></strong><span class="koboSpan" id="kobo.173.1"> type, as </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.175.1">
  inline auto algoTypeToString(AlgoType type) -&gt; std::string {
    switch (type) {
      case AlgoType::RANDOM:
        return "RANDOM";
      case AlgoType::MAKER:
        return "MAKER";
      case AlgoType::TAKER:
        return "TAKER";
      case AlgoType::INVALID:
        return "INVALID";
      case AlgoType::MAX:
        return "MAX";
    }
    return "UNKNOWN";
  }</span></pre>
<p><span class="koboSpan" id="kobo.176.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">stringToAlgoType()</span></strong><span class="koboSpan" id="kobo.178.1"> method, which we will build next, parses a string and converts it into an </span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">AlgoType</span></strong><span class="koboSpan" id="kobo.180.1"> enumeration value. </span><span class="koboSpan" id="kobo.180.2">It does this by iterating through all the possible </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">AlgoType</span></strong><span class="koboSpan" id="kobo.182.1"> enumeration values and comparing the string argument against the output of </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">algoTypeToString()</span></strong><span class="koboSpan" id="kobo.184.1">, called on that </span><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">AlgoType</span></strong><span class="koboSpan" id="kobo.186.1"> enumeration </span><a id="_idIndexMarker1337"/><span class="koboSpan" id="kobo.187.1">value. </span><span class="koboSpan" id="kobo.187.2">If the string representations match, then it returns the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">algo_type</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.189.1"> enumeration:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.190.1">
  inline auto stringToAlgoType(const std::string &amp;str) -&gt;
    AlgoType {
    for (auto i = static_cast&lt;int&gt;(AlgoType::INVALID); i &lt;=
      static_cast&lt;int&gt;(AlgoType::MAX); ++i) {
      const auto algo_type = static_cast&lt;AlgoType&gt;(i);
      if (algoTypeToString(algo_type) == str)
        return algo_type;
    }
    return AlgoType::INVALID;
  }</span></pre>
<p><span class="koboSpan" id="kobo.191.1">Next, we will move on to building the different building blocks we need to support our </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">trading strategies.</span></span></p>
<h1 id="_idParaDest-257"><a id="_idTextAnchor270"/><span class="koboSpan" id="kobo.193.1">Managing the passive liquidity provided in the order book</span></h1>
<p><span class="koboSpan" id="kobo.194.1">At this point, we have all the sub-components we need to start building our trading strategies. </span><span class="koboSpan" id="kobo.194.2">The first strategy we will build will be the MM algorithm, which sends orders that are expected to </span><a id="_idIndexMarker1338"/><span class="koboSpan" id="kobo.195.1">rest passively in the order book. </span><span class="koboSpan" id="kobo.195.2">We </span><a id="_idIndexMarker1339"/><span class="koboSpan" id="kobo.196.1">discussed the details of this trading algorithm earlier in this chapter, so in this section, we will focus on the C++ implementation. </span><span class="koboSpan" id="kobo.196.2">All the source code for this </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">MarketMaker</span></strong><span class="koboSpan" id="kobo.198.1"> trading algorithm can be found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">Chapter10/trading/strategy/market_maker.h</span></strong><span class="koboSpan" id="kobo.200.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">Chapter10/trading/strategy/market_maker.cpp</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.202.1">source files.</span></span></p>
<h2 id="_idParaDest-258"><a id="_idTextAnchor271"/><span class="koboSpan" id="kobo.203.1">Defining the data members in the MarketMaker algorithm</span></h2>
<p><span class="koboSpan" id="kobo.204.1">First, we need </span><a id="_idIndexMarker1340"/><span class="koboSpan" id="kobo.205.1">to define the data members that </span><a id="_idIndexMarker1341"/><span class="koboSpan" id="kobo.206.1">make up the </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">MarketMaker</span></strong><span class="koboSpan" id="kobo.208.1"> class. </span><span class="koboSpan" id="kobo.208.2">The key members are </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.210.1">A pointer to a constant </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">FeatureEngine</span></strong><span class="koboSpan" id="kobo.212.1"> object called </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">feature_engine_</span></strong><span class="koboSpan" id="kobo.214.1">, which we will use to fetch the fair market price, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">FeatureEngine::getMktPrice()</span></strong><span class="koboSpan" id="kobo.216.1"> method we </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">saw earlier</span></span></li>
<li><span class="koboSpan" id="kobo.218.1">A pointer to an </span><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">OrderManager</span></strong><span class="koboSpan" id="kobo.220.1"> object called </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">order_manager_</span></strong><span class="koboSpan" id="kobo.222.1">, which will be used to manage the passive orders that this </span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">strategy sends</span></span></li>
<li><span class="koboSpan" id="kobo.224.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">ticker_cfg_</span></strong><span class="koboSpan" id="kobo.226.1"> variable of a constant </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">TradeEngineCfgHashMap</span></strong><span class="koboSpan" id="kobo.228.1"> type to hold the trading parameters for the different trading instruments that this algorithm </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">will trade</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.230.1">Let us inspect the class definition, starting with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">include</span></strong><span class="koboSpan" id="kobo.232.1"> files needed in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">market_maker.h</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.234.1">header file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.235.1">
#pragma once
#include "common/macros.h"
#include "common/logging.h"
#include "order_manager.h"
#include "feature_engine.h"
using namespace Common;</span></pre>
<p><span class="koboSpan" id="kobo.236.1">And now, in the </span><a id="_idIndexMarker1342"/><span class="koboSpan" id="kobo.237.1">next code block, we </span><a id="_idIndexMarker1343"/><span class="koboSpan" id="kobo.238.1">can define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">MarketMaker</span></strong><span class="koboSpan" id="kobo.240.1"> class and the aforementioned </span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">data members:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.242.1">
namespace Trading {
  class MarketMaker {
  private:
    const FeatureEngine *feature_engine_ = nullptr;
    OrderManager *order_manager_ = nullptr;
    std::string time_str_;
    Common::Logger *logger_ = nullptr;
    const TradeEngineCfgHashMap ticker_cfg_;
  };
}</span></pre>
<p><span class="koboSpan" id="kobo.243.1">The next section will define the constructor to initialize an instance of this </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">MarketMaker</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.245.1"> class.</span></span></p>
<h2 id="_idParaDest-259"><a id="_idTextAnchor272"/><span class="koboSpan" id="kobo.246.1">Initializing the MarketMaker algorithm</span></h2>
<p><span class="koboSpan" id="kobo.247.1">The constructor implemented </span><a id="_idIndexMarker1344"/><span class="koboSpan" id="kobo.248.1">in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">market_maker.cpp</span></strong><span class="koboSpan" id="kobo.250.1"> file is shown in the next code block. </span><span class="koboSpan" id="kobo.250.2">The constructor accepts a few arguments in </span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">the constructor:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.252.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">Logger</span></strong><span class="koboSpan" id="kobo.254.1"> object, which will be saved in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">logger_</span></strong><span class="koboSpan" id="kobo.256.1"> member variable and used for </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">logging purposes.</span></span></li>
<li><span class="koboSpan" id="kobo.258.1">A pointer to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">TradeEngine</span></strong><span class="koboSpan" id="kobo.260.1"> object, which will be used to bind the </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">algoOnOrderBookUpdate</span></strong><span class="koboSpan" id="kobo.262.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">algoOnTradeUpdate</span></strong><span class="koboSpan" id="kobo.264.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">algoOnOrderUpdate</span></strong><span class="koboSpan" id="kobo.266.1"> callbacks in the parent </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">TradeEngine</span></strong><span class="koboSpan" id="kobo.268.1"> instance to the corresponding methods in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">MarketMaker</span></strong><span class="koboSpan" id="kobo.270.1"> object. </span><span class="koboSpan" id="kobo.270.2">This is so that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">MarketMaker</span></strong><span class="koboSpan" id="kobo.272.1"> trading strategy receives and processes the callbacks when </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">TradeEngine</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.274.1">receives them.</span></span></li>
<li><span class="koboSpan" id="kobo.275.1">A pointer to a constant </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">FeatureEngine</span></strong><span class="koboSpan" id="kobo.277.1"> object, which will be stored in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">feature_engine_</span></strong><span class="koboSpan" id="kobo.279.1"> data member and used to extract the feature values this algorithm needs, as </span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">described before.</span></span></li>
<li><span class="koboSpan" id="kobo.281.1">A pointer to an </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">OrderManager</span></strong><span class="koboSpan" id="kobo.283.1"> object, which will be used to manage the orders for this strategy, and the constructor will simply be saved in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">order_manager_</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.285.1">data member.</span></span></li>
<li><span class="koboSpan" id="kobo.286.1">A reference to a constant </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">TradeEngineCfgHashMap</span></strong><span class="koboSpan" id="kobo.288.1">, which will be saved in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">ticker_cfg_</span></strong><span class="koboSpan" id="kobo.290.1"> member and used to make trading decisions, since this contains the </span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">trading parameters:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.292.1">
#include "market_maker.h"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.293.1">
#include "trade_engine.h"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.294.1">
namespace Trading {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.295.1">
  MarketMaker::MarketMaker(Common::Logger *logger,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.296.1">
    TradeEngine *trade_engine, const FeatureEngine</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.297.1">
      *feature_engine,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.298.1">
OrderManager *order_manager, const</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.299.1">
  TradeEngineCfgHashMap &amp;ticker_cfg)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.300.1">
      : feature_engine_(feature_engine),</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.301.1">
        order_manager_(order_manager),</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.302.1">
          logger_(logger),</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.303.1">
        ticker_cfg_(ticker_cfg) {</span></pre></li>
</ul>
<p><span class="koboSpan" id="kobo.304.1">As mentioned before and as shown here, we will override </span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">the </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">TradeEngine:</span></strong></span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1"> :algoOnOrderBookUpdate()</span></strong><span class="koboSpan" id="kobo.308.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">TradeEngine::algoOnTradeUpdate()</span></strong><span class="koboSpan" id="kobo.310.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">TradeEngine::algoOnOrderUpdate()</span></strong><span class="koboSpan" id="kobo.312.1"> methods using lambda methods to forward </span><a id="_idIndexMarker1345"/><span class="koboSpan" id="kobo.313.1">them to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">MarketMaker::onOrderBookUpdate()</span></strong><span class="koboSpan" id="kobo.315.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">MarketMaker::onTradeUpdate()</span></strong><span class="koboSpan" id="kobo.317.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">MarketMaker::onOrderUpdate()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.319.1">methods, respectively:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.320.1">
    trade_engine-&gt;algoOnOrderBookUpdate_ = [this](auto
      ticker_id, auto price, auto side, auto book) {
      onOrderBookUpdate(ticker_id, price, side, book);
    };
    trade_engine-&gt;algoOnTradeUpdate_ = [this](auto
      market_update, auto book) {
        onTradeUpdate(market_update, book); };
    trade_engine-&gt;algoOnOrderUpdate_ = [this](auto
      client_response) { onOrderUpdate(client_response); };
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.321.1">The next subsection tackles the most important task in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">MarketMaker</span></strong><span class="koboSpan" id="kobo.323.1"> trading algorithm – handling order book updates and sending orders in reaction </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">to them.</span></span></p>
<h2 id="_idParaDest-260"><a id="_idTextAnchor273"/><span class="koboSpan" id="kobo.325.1">Handling order book updates and trade events</span></h2>
<p><span class="koboSpan" id="kobo.326.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">MarketMaker::onOrderBookUpdate()</span></strong><span class="koboSpan" id="kobo.328.1"> method is called by </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">TradeEngine</span></strong><span class="koboSpan" id="kobo.330.1"> through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">TradeEngine::algoOnOrderBookUpdate_</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.332.1">std::function</span></strong><span class="koboSpan" id="kobo.333.1"> member </span><a id="_idIndexMarker1346"/><span class="koboSpan" id="kobo.334.1">variable. </span><span class="koboSpan" id="kobo.334.2">This is where </span><a id="_idIndexMarker1347"/><span class="koboSpan" id="kobo.335.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">MarketMaker</span></strong><span class="koboSpan" id="kobo.337.1"> trading strategy </span><a id="_idIndexMarker1348"/><span class="koboSpan" id="kobo.338.1">makes trading decisions with regard to what </span><a id="_idIndexMarker1349"/><span class="koboSpan" id="kobo.339.1">prices it wants its bid and ask orders to </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">be at:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.341.1">
    auto onOrderBookUpdate(TickerId ticker_id, Price price,
      Side side, const MarketOrderBook *book) noexcept -&gt; void {
      logger_-&gt;log("%:% %() % ticker:% price:% side:%\n",
        __FILE__, __LINE__, __FUNCTION__,
                   Common::getCurrentTimeStr(&amp;time_str_),
                     ticker_id, Common::
                       priceToString(price).c_str(),
                   Common::sideToString(side).c_str());</span></pre>
<p><span class="koboSpan" id="kobo.342.1">It fetches </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">BBO</span></strong><span class="koboSpan" id="kobo.344.1"> from </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">w</span></strong><span class="koboSpan" id="kobo.346.1"> using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">getBBO()</span></strong><span class="koboSpan" id="kobo.348.1"> method and saves it in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">bbo</span></strong><span class="koboSpan" id="kobo.350.1"> variable. </span><span class="koboSpan" id="kobo.350.2">We also fetch the market quantity-weighted BBO price and save it in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">fair_price</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.352.1"> variable:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.353.1">
      const auto bbo = book-&gt;getBBO();
      const auto fair_price = feature_engine_-&gt;
        getMktPrice();</span></pre>
<p><span class="koboSpan" id="kobo.354.1">We perform a sanity check on the best </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">bid_price_</span></strong><span class="koboSpan" id="kobo.356.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">ask_price_</span></strong><span class="koboSpan" id="kobo.358.1"> values from </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">bbo</span></strong><span class="koboSpan" id="kobo.360.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">fair_price</span></strong><span class="koboSpan" id="kobo.362.1"> to make sure that the prices are not </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">Price_INVALID</span></strong><span class="koboSpan" id="kobo.364.1"> and the feature value is not </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">Feature_INVALID</span></strong><span class="koboSpan" id="kobo.366.1">. </span><span class="koboSpan" id="kobo.366.2">Only if this is </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">true</span></strong><span class="koboSpan" id="kobo.368.1"> will we take any action; otherwise, we risk acting on invalid features or sending orders at </span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">invalid prices:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.370.1">
      if (LIKELY(bbo-&gt;bid_price_ != Price_INVALID &amp;&amp; bbo-&gt;
        ask_price_ != Price_INVALID &amp;&amp; fair_price !=
          Feature_INVALID)) {
        logger_-&gt;log("%:% %() % % fair-price:%\n",
          __FILE__, __LINE__, __FUNCTION__,
                     Common::getCurrentTimeStr(&amp;time_str_),
                     bbo-&gt;toString().c_str(), fair_price);</span></pre>
<p><span class="koboSpan" id="kobo.371.1">We fetch and save the </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">clip</span></strong><span class="koboSpan" id="kobo.373.1"> quantity from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">ticker_cfg_</span></strong><span class="koboSpan" id="kobo.375.1"> container, which will be the quantity on the passive orders we send to the exchange. </span><span class="koboSpan" id="kobo.375.2">We also extract and save the </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">threshold</span></strong><span class="koboSpan" id="kobo.377.1"> value, which we will use to decide what prices to send the buy and sell </span><span class="No-Break"><span class="koboSpan" id="kobo.378.1">orders at:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.379.1">
        const auto clip = ticker_cfg_.at(ticker_id).clip_;
        const auto threshold =
          ticker_cfg_.at(ticker_id).threshold_;</span></pre>
<p><span class="koboSpan" id="kobo.380.1">We initialize two price variables, </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">bid_price</span></strong><span class="koboSpan" id="kobo.382.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">ask_price</span></strong><span class="koboSpan" id="kobo.384.1">, to represent the prices on our buy </span><a id="_idIndexMarker1350"/><span class="koboSpan" id="kobo.385.1">and sell orders, respectively. </span><span class="koboSpan" id="kobo.385.2">We </span><a id="_idIndexMarker1351"/><span class="koboSpan" id="kobo.386.1">set </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">bid_price</span></strong><span class="koboSpan" id="kobo.388.1"> to </span><a id="_idIndexMarker1352"/><span class="koboSpan" id="kobo.389.1">be the best bid price if the difference </span><a id="_idIndexMarker1353"/><span class="koboSpan" id="kobo.390.1">between </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">fair_price</span></strong><span class="koboSpan" id="kobo.392.1"> we computed from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">FeatureEngine::getMktPrice()</span></strong><span class="koboSpan" id="kobo.394.1"> method and the market bid price exceeds the </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">threshold</span></strong><span class="koboSpan" id="kobo.396.1"> value. </span><span class="koboSpan" id="kobo.396.2">Otherwise, we set </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">bid_price</span></strong><span class="koboSpan" id="kobo.398.1"> to be a price lower than the best market bid price. </span><span class="koboSpan" id="kobo.398.2">We compute </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">ask_price</span></strong><span class="koboSpan" id="kobo.400.1"> using the same logic – use the best ask price if the difference from the fair price exceeds the threshold and a higher price otherwise. </span><span class="koboSpan" id="kobo.400.2">The motivation behind this is straightforward; when we think the fair price is higher than the best bid price, we are willing to buy at the best bid price, expecting the prices to go higher. </span><span class="koboSpan" id="kobo.400.3">When we think the fair price is lower than the best ask price, we are willing to sell at the best ask price, expecting the prices to </span><span class="No-Break"><span class="koboSpan" id="kobo.401.1">go lower:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.402.1">
        const auto bid_price = bbo-&gt;bid_price_ -
          (fair_price - bbo-&gt;bid_price_ &gt;= threshold ? </span><span class="koboSpan" id="kobo.402.2">0 :
            1);
        const auto ask_price = bbo-&gt;ask_price_ + (bbo-&gt;
          ask_price_ - fair_price &gt;= threshold ? </span><span class="koboSpan" id="kobo.402.3">0 : 1);</span></pre>
<p><span class="koboSpan" id="kobo.403.1">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">bid_price</span></strong><span class="koboSpan" id="kobo.405.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">ask_price</span></strong><span class="koboSpan" id="kobo.407.1"> variables we computed in the preceding code block a and pass them to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">OrderManager::moveOrders()</span></strong><span class="koboSpan" id="kobo.409.1"> method to move the orders to the </span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">desired prices:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.411.1">
        order_manager_-&gt;moveOrders(ticker_id, bid_price,
          ask_price, clip);
      }
    }</span></pre>
<p><span class="koboSpan" id="kobo.412.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">MarketMaker</span></strong><span class="koboSpan" id="kobo.414.1"> trading algorithm does not do anything when there are trade events and simply logs the trade message it receives, as </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.416.1">
    auto onTradeUpdate(const Exchange::MEMarketUpdate
      *market_update, MarketOrderBook * /* book */)
       noexcept -&gt; void {
      logger_-&gt;log("%:% %() % %\n", __FILE__, __LINE__,
        __FUNCTION__, Common::
         getCurrentTimeStr(&amp;time_str_),
                   market_update-&gt;toString().c_str());
    }</span></pre>
<p><span class="koboSpan" id="kobo.417.1">We have one </span><a id="_idIndexMarker1354"/><span class="koboSpan" id="kobo.418.1">more task to complete </span><a id="_idIndexMarker1355"/><span class="koboSpan" id="kobo.419.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">MarketMaker</span></strong><span class="koboSpan" id="kobo.421.1"> trading </span><a id="_idIndexMarker1356"/><span class="koboSpan" id="kobo.422.1">strategy – handling order updates for its orders, which </span><a id="_idIndexMarker1357"/><span class="koboSpan" id="kobo.423.1">will be addressed in the </span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">next subsection.</span></span></p>
<h2 id="_idParaDest-261"><a id="_idTextAnchor274"/><span class="koboSpan" id="kobo.425.1">Handling order updates in the MarketMaker algorithm</span></h2>
<p><span class="koboSpan" id="kobo.426.1">The handling of </span><a id="_idIndexMarker1358"/><span class="koboSpan" id="kobo.427.1">order updates for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">MarketMaker</span></strong><span class="koboSpan" id="kobo.429.1"> trading </span><a id="_idIndexMarker1359"/><span class="koboSpan" id="kobo.430.1">algorithm’s orders is simple; it simply forwards the </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">MEClientResponse</span></strong><span class="koboSpan" id="kobo.432.1"> messages to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">order_manager_</span></strong><span class="koboSpan" id="kobo.434.1"> member it uses to manage orders. </span><span class="koboSpan" id="kobo.434.2">This is achieved by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">OrderManager::onOrderUpdate()</span></strong><span class="koboSpan" id="kobo.436.1"> method, which we </span><span class="No-Break"><span class="koboSpan" id="kobo.437.1">implemented previously:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.438.1">
    auto onOrderUpdate(const Exchange::MEClientResponse
      *client_response) noexcept -&gt; void {
      logger_-&gt;log("%:% %() % %\n", __FILE__, __LINE__,
        __FUNCTION__, Common::
         getCurrentTimeStr(&amp;time_str_),
                   client_response-&gt;toString().c_str());
      order_manager_-&gt;onOrderUpdate(client_response);
    }</span></pre>
<p><span class="koboSpan" id="kobo.439.1">That concludes our implementation of the MM trading algorithm. </span><span class="koboSpan" id="kobo.439.2">In the next section, we will tackle the other type of trading strategy we will build in this book – a liquidity </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">taking algorithm.</span></span></p>
<h1 id="_idParaDest-262"><a id="_idTextAnchor275"/><span class="koboSpan" id="kobo.441.1">Opening and closing positions aggressively</span></h1>
<p><span class="koboSpan" id="kobo.442.1">In this section, we will build a liquidity taking algorithm, whose behavior we covered in the first section of this chapter. </span><span class="koboSpan" id="kobo.442.2">This trading strategy does not send passive orders as the MM algorithm does; instead, it sends aggressive orders that trade against liquidity resting in the book. </span><span class="koboSpan" id="kobo.442.3">The source code for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">LiquidityTaker</span></strong><span class="koboSpan" id="kobo.444.1"> algorithm is in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">Chapter10/trading/strategy/liquidity_taker.h</span></strong><span class="koboSpan" id="kobo.446.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">Chapter10/trading/strategy/liquidity_taker.cpp</span></strong><span class="koboSpan" id="kobo.448.1"> source files. </span><span class="koboSpan" id="kobo.448.2">First, we will define the data members that make up the </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">LiquidityTaker</span></strong><span class="koboSpan" id="kobo.450.1"> class in the </span><span class="No-Break"><span class="koboSpan" id="kobo.451.1">next subsection.</span></span></p>
<h2 id="_idParaDest-263"><a id="_idTextAnchor276"/><span class="koboSpan" id="kobo.452.1">Defining the data members in the LiquidityTaker algorithm</span></h2>
<p><span class="koboSpan" id="kobo.453.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">LiquidityTaker</span></strong><span class="koboSpan" id="kobo.455.1"> trading strategy has the same data members as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">MarketMaker</span></strong><span class="koboSpan" id="kobo.457.1"> algorithm </span><a id="_idIndexMarker1360"/><span class="koboSpan" id="kobo.458.1">we built in the </span><a id="_idIndexMarker1361"/><span class="koboSpan" id="kobo.459.1">previous section. </span><span class="koboSpan" id="kobo.459.2">Before we describe the data members themselves, we will present the header files we need to include in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">liquidity_taker.h</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.461.1">source file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.462.1">
#pragma once
#include "common/macros.h"
#include "common/logging.h"
#include "order_manager.h"
#include "feature_engine.h"
using namespace Common;</span></pre>
<p><span class="koboSpan" id="kobo.463.1">Now, we can define the data members, which are the same ones that the MM algorithm has. </span><span class="koboSpan" id="kobo.463.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">LiquidityTaker</span></strong><span class="koboSpan" id="kobo.465.1"> class has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">feature_engine_</span></strong><span class="koboSpan" id="kobo.467.1"> member, which is a constant pointer to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">FeatureEngine</span></strong><span class="koboSpan" id="kobo.469.1"> object, an </span><strong class="source-inline"><span class="koboSpan" id="kobo.470.1">order_manager_</span></strong><span class="koboSpan" id="kobo.471.1"> pointer to an </span><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">OrderManager</span></strong><span class="koboSpan" id="kobo.473.1"> object, and a constant </span><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">ticker_cfg_</span></strong><span class="koboSpan" id="kobo.475.1"> member, which is of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">TradeEngineCfgHashMap</span></strong><span class="koboSpan" id="kobo.477.1">. </span><span class="koboSpan" id="kobo.477.2">These members serve the same purpose as they did in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">MarketMaker</span></strong><span class="koboSpan" id="kobo.479.1"> class; </span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">feature_engine_</span></strong><span class="koboSpan" id="kobo.481.1"> is used to extract the ratio of aggressive trade to top-of-book quantity. </span><span class="koboSpan" id="kobo.481.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">order_manager_</span></strong><span class="koboSpan" id="kobo.483.1"> object is used to send and </span><a id="_idIndexMarker1362"/><span class="koboSpan" id="kobo.484.1">manage the orders for this </span><a id="_idIndexMarker1363"/><span class="koboSpan" id="kobo.485.1">trading strategy. </span><span class="koboSpan" id="kobo.485.2">Finally, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">ticker_cfg_</span></strong><span class="koboSpan" id="kobo.487.1"> object holds the trading parameters that will be used by this algorithm to make trading decisions and send orders to </span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">the exchange:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.489.1">
namespace Trading {
  class LiquidityTaker {
  private:
    const FeatureEngine *feature_engine_ = nullptr;
    OrderManager *order_manager_ = nullptr;
    std::string time_str_;
    Common::Logger *logger_ = nullptr;
    const TradeEngineCfgHashMap ticker_cfg_;
  };
}</span></pre>
<p><span class="koboSpan" id="kobo.490.1">In the next section, we will see how to initialize a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">LiquidityTaker</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.492.1"> object.</span></span></p>
<h2 id="_idParaDest-264"><a id="_idTextAnchor277"/><span class="koboSpan" id="kobo.493.1">Initializing the LiquidityTaker trading algorithm</span></h2>
<p><span class="koboSpan" id="kobo.494.1">The initialization for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">LiquidityTaker</span></strong><span class="koboSpan" id="kobo.496.1"> class is identical to the initialization for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">MarketMaker</span></strong><span class="koboSpan" id="kobo.498.1"> class. </span><span class="koboSpan" id="kobo.498.2">The </span><a id="_idIndexMarker1364"/><span class="koboSpan" id="kobo.499.1">constructor expects the following arguments – a </span><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">Logger</span></strong><span class="koboSpan" id="kobo.501.1"> object, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">TradeEngine</span></strong><span class="koboSpan" id="kobo.503.1"> object within which this algorithm runs, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">FeatureEngine</span></strong><span class="koboSpan" id="kobo.505.1"> object to compute the feature, an </span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">OrderManager</span></strong><span class="koboSpan" id="kobo.507.1"> object used to manage orders for this trading strategy, and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">TradeEngineCfgHashMap</span></strong><span class="koboSpan" id="kobo.509.1"> object containing the trading parameters for </span><span class="No-Break"><span class="koboSpan" id="kobo.510.1">this strategy:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.511.1">
#include "liquidity_taker.h"
#include "trade_engine.h"
namespace Trading {
  LiquidityTaker::LiquidityTaker(Common::Logger *logger,
    TradeEngine *trade_engine, FeatureEngine
      *feature_engine,
    OrderManager *order_manager,
    const TradeEngineCfgHashMap &amp;ticker_cfg):
      feature_engine_(feature_engine),
        order_manager_(order_manager), logger_(logger),
        ticker_cfg_(ticker_cfg) {</span></pre>
<p><span class="koboSpan" id="kobo.512.1">This constructor also overrides the callbacks in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">TradeEngine</span></strong><span class="koboSpan" id="kobo.514.1"> object for order book updates, trade </span><a id="_idIndexMarker1365"/><span class="koboSpan" id="kobo.515.1">events, and updates to the algorithm’s orders like the </span><strong class="source-inline"><span class="koboSpan" id="kobo.516.1">MarketMaker</span></strong><span class="koboSpan" id="kobo.517.1"> algorithm. </span><span class="koboSpan" id="kobo.517.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">std::function</span></strong><span class="koboSpan" id="kobo.519.1"> members, </span><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">algoOnOrderBookUpdate_</span></strong><span class="koboSpan" id="kobo.521.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.522.1">algoOnTradeUpdate_</span></strong><span class="koboSpan" id="kobo.523.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">algoOnOrderUpdate_</span></strong><span class="koboSpan" id="kobo.525.1">, in </span><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">TradeEngine</span></strong><span class="koboSpan" id="kobo.527.1"> are bound, respectively, to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.528.1">onOrderBookUpdate</span></strong><span class="koboSpan" id="kobo.529.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">onTradeUpdate</span></strong><span class="koboSpan" id="kobo.531.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">onOrderUpdate</span></strong><span class="koboSpan" id="kobo.533.1"> methods within </span><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">LiquidityTaker</span></strong><span class="koboSpan" id="kobo.535.1"> using lambda methods, as shown here (and as we </span><span class="No-Break"><span class="koboSpan" id="kobo.536.1">saw before):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.537.1">
    trade_engine-&gt;algoOnOrderBookUpdate_ = [this](auto
      ticker_id, auto price, auto side, auto book) {
      onOrderBookUpdate(ticker_id, price, side, book);
    };
    trade_engine-&gt;algoOnTradeUpdate_ = [this](auto
      market_update, auto book) {
       onTradeUpdate(market_update, book); };
    trade_engine-&gt;algoOnOrderUpdate_ = [this](auto
      client_response) { onOrderUpdate(client_response); };
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.538.1">Next, we will </span><a id="_idIndexMarker1366"/><span class="koboSpan" id="kobo.539.1">discuss the code for handling trade events and order book updates due to events in the market data in this </span><span class="No-Break"><span class="koboSpan" id="kobo.540.1">trading strategy.</span></span></p>
<h2 id="_idParaDest-265"><a id="_idTextAnchor278"/><span class="koboSpan" id="kobo.541.1">Handling trade events and order book updates</span></h2>
<p><span class="koboSpan" id="kobo.542.1">For the </span><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">MarketMaker</span></strong><span class="koboSpan" id="kobo.544.1"> trading strategy, we saw that it only makes trading decisions on order book </span><a id="_idIndexMarker1367"/><span class="koboSpan" id="kobo.545.1">updates and does nothing </span><a id="_idIndexMarker1368"/><span class="koboSpan" id="kobo.546.1">on trade updates. </span><span class="koboSpan" id="kobo.546.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.547.1">LiquidityTaker</span></strong><span class="koboSpan" id="kobo.548.1"> strategy </span><a id="_idIndexMarker1369"/><span class="koboSpan" id="kobo.549.1">does the opposite – it takes trading </span><a id="_idIndexMarker1370"/><span class="koboSpan" id="kobo.550.1">decisions in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">onTradeUpdate()</span></strong><span class="koboSpan" id="kobo.552.1"> method and does nothing in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.553.1">onOrderBookUpdate()</span></strong><span class="koboSpan" id="kobo.554.1"> method. </span><span class="koboSpan" id="kobo.554.2">We will start by looking at the implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.555.1">LiquidityTaker::onTradeUpdate()</span></strong><span class="koboSpan" id="kobo.556.1"> method first in the next </span><span class="No-Break"><span class="koboSpan" id="kobo.557.1">code block:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.558.1">
    auto onTradeUpdate(const Exchange::MEMarketUpdate
      *market_update, MarketOrderBook *book) noexcept -&gt; void {
      logger_-&gt;log("%:% %() % %\n", __FILE__, __LINE__,
        __FUNCTION__, Common::
          getCurrentTimeStr(&amp;time_str_),
                   market_update-&gt;toString().c_str());</span></pre>
<p><span class="koboSpan" id="kobo.559.1">We will fetch and save </span><strong class="source-inline"><span class="koboSpan" id="kobo.560.1">BBO</span></strong><span class="koboSpan" id="kobo.561.1"> using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.562.1">getBBO()</span></strong><span class="koboSpan" id="kobo.563.1"> method in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">bbo</span></strong><span class="koboSpan" id="kobo.565.1"> local variable. </span><span class="koboSpan" id="kobo.565.2">For this trading strategy, we will fetch the aggressive trade quantity ratio feature from the feature engine by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">FeatureEngine::getAggTradeQtyRatio()</span></strong><span class="koboSpan" id="kobo.567.1"> method and saving it in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">agg_qty_ratio</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.569.1"> variable:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.570.1">
      const auto bbo = book-&gt;getBBO();
      const auto agg_qty_ratio = feature_engine_-&gt;
        getAggTradeQtyRatio();</span></pre>
<p><span class="koboSpan" id="kobo.571.1">As we saw before, we will check to make sure that </span><strong class="source-inline"><span class="koboSpan" id="kobo.572.1">bid_price_</span></strong><span class="koboSpan" id="kobo.573.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.574.1">ask_price_</span></strong><span class="koboSpan" id="kobo.575.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.576.1">agg_qty_ratio</span></strong><span class="koboSpan" id="kobo.577.1"> are valid values before we decide to take an </span><span class="No-Break"><span class="koboSpan" id="kobo.578.1">order action:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.579.1">
      if (LIKELY(bbo-&gt;bid_price_ != Price_INVALID &amp;&amp; bbo-&gt;
        ask_price_ != Price_INVALID &amp;&amp; agg_qty_ratio !=
          Feature_INVALID)) {
        logger_-&gt;log("%:% %() % % agg-qty-ratio:%\n",
          __FILE__, __LINE__, __FUNCTION__,
                     Common::getCurrentTimeStr(&amp;time_str_),
                     bbo-&gt;toString().c_str(),
                       agg_qty_ratio);</span></pre>
<p><span class="koboSpan" id="kobo.580.1">If the validity check passes, we first need to fetch the </span><strong class="source-inline"><span class="koboSpan" id="kobo.581.1">clip_</span></strong><span class="koboSpan" id="kobo.582.1"> member from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">ticker_cfg_</span></strong><span class="koboSpan" id="kobo.584.1"> object for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">TickerId</span></strong><span class="koboSpan" id="kobo.586.1"> of this trade message, as shown in the following code block, and save it in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.587.1">clip</span></strong><span class="koboSpan" id="kobo.588.1"> local variable. </span><span class="koboSpan" id="kobo.588.2">Similarly, we will fetch and save the </span><strong class="source-inline"><span class="koboSpan" id="kobo.589.1">threshold_</span></strong><span class="koboSpan" id="kobo.590.1"> member from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.591.1">ticker_cfg_</span></strong><span class="koboSpan" id="kobo.592.1"> configuration object for </span><span class="No-Break"><span class="koboSpan" id="kobo.593.1">that </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.594.1">TickerId</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.595.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.596.1">
        const auto clip = ticker_cfg_.at(market_update-&gt;
          ticker_id_).clip_;
        const auto threshold = ticker_cfg_
          .at(market_update-&gt;ticker_id_).threshold_;</span></pre>
<p><span class="koboSpan" id="kobo.597.1">To decide whether we send or adjust active orders for this algorithm, we will check whether the </span><strong class="source-inline"><span class="koboSpan" id="kobo.598.1">agg_qty_ratio</span></strong><span class="koboSpan" id="kobo.599.1"> exceeds the threshold we </span><span class="No-Break"><span class="koboSpan" id="kobo.600.1">previously fetched:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.601.1">
        if (agg_qty_ratio &gt;= threshold) {</span></pre>
<p><span class="koboSpan" id="kobo.602.1">To send orders using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.603.1">OrderManager::moveOrders()</span></strong><span class="koboSpan" id="kobo.604.1"> method, we will check whether the </span><a id="_idIndexMarker1371"/><span class="koboSpan" id="kobo.605.1">aggressive trade was a buy trade </span><a id="_idIndexMarker1372"/><span class="koboSpan" id="kobo.606.1">or a sell trade. </span><span class="koboSpan" id="kobo.606.2">If it was a buy trade, we </span><a id="_idIndexMarker1373"/><span class="koboSpan" id="kobo.607.1">will send an aggressive buy order to take liquidity at the </span><a id="_idIndexMarker1374"/><span class="koboSpan" id="kobo.608.1">best </span><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">BBO</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.610.1">ask_price_</span></strong><span class="koboSpan" id="kobo.611.1"> and no sell order by specifying a sell price of </span><strong class="source-inline"><span class="koboSpan" id="kobo.612.1">Price_INVALID</span></strong><span class="koboSpan" id="kobo.613.1">. </span><span class="koboSpan" id="kobo.613.2">Conversely, if it was a sell trade and we wanted to send an aggressive sell order to take liquidity, we would specify a sell price to be </span><strong class="source-inline"><span class="koboSpan" id="kobo.614.1">bid_price_</span></strong><span class="koboSpan" id="kobo.615.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.616.1">BBO</span></strong><span class="koboSpan" id="kobo.617.1"> object and no buy order by specifying a </span><strong class="source-inline"><span class="koboSpan" id="kobo.618.1">Price_INVALID</span></strong><span class="koboSpan" id="kobo.619.1"> buy price. </span><span class="koboSpan" id="kobo.619.2">Remember that this trading strategy takes a direction in the market by aggressively sending a buy or sell order one at a time, but not both like the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">MarketMaker</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.621.1"> algorithm:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.622.1">
          if (market_update-&gt;side_ == Side::BUY)
            order_manager_-&gt;moveOrders(market_update-&gt;
              ticker_id_, bbo-&gt;ask_price_, Price_INVALID,
                clip);
          else
            order_manager_-&gt;moveOrders(market_update-&gt;
              ticker_id_, Price_INVALID, bbo-&gt;bid_price_,
                clip);
        }
      }
    }</span></pre>
<p><span class="koboSpan" id="kobo.623.1">As mentioned </span><a id="_idIndexMarker1375"/><span class="koboSpan" id="kobo.624.1">before and as shown in the </span><a id="_idIndexMarker1376"/><span class="koboSpan" id="kobo.625.1">following code </span><a id="_idIndexMarker1377"/><span class="koboSpan" id="kobo.626.1">block, this </span><strong class="source-inline"><span class="koboSpan" id="kobo.627.1">LiquidityTaker</span></strong><span class="koboSpan" id="kobo.628.1"> trading strategy does not take any </span><a id="_idIndexMarker1378"/><span class="koboSpan" id="kobo.629.1">action on order updates in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.630.1">onOrderBookUpdate()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.631.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.632.1">
    auto onOrderBookUpdate(TickerId ticker_id, Price price,
      Side side, MarketOrderBook *) noexcept -&gt; void {
      logger_-&gt;log("%:% %() % ticker:% price:% side:%\n",
        __FILE__, __LINE__, __FUNCTION__,
                   Common::getCurrentTimeStr(&amp;time_str_),
                     ticker_id, Common::
                       priceToString(price).c_str(),
                   Common::sideToString(side).c_str());
    }</span></pre>
<p><span class="koboSpan" id="kobo.633.1">The next concluding section related to </span><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">LiquidityTaker</span></strong><span class="koboSpan" id="kobo.635.1"> adds handling to the order updates for the </span><span class="No-Break"><span class="koboSpan" id="kobo.636.1">strategy’s orders.</span></span></p>
<h2 id="_idParaDest-266"><a id="_idTextAnchor279"/><span class="koboSpan" id="kobo.637.1">Handling order updates in the LiquidityTaker algorithm</span></h2>
<p><span class="koboSpan" id="kobo.638.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">LiquidityTaker::onOrderUpdate()</span></strong><span class="koboSpan" id="kobo.640.1"> method, as shown in the following code block, has </span><a id="_idIndexMarker1379"/><span class="koboSpan" id="kobo.641.1">an identical implementation </span><a id="_idIndexMarker1380"/><span class="koboSpan" id="kobo.642.1">to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.643.1">MarketMaker::onOrderUpdate()</span></strong><span class="koboSpan" id="kobo.644.1"> method and simply forwards the order update to the order manager using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.645.1">OrderManager::onOrderUpdate()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.646.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.647.1">
    auto onOrderUpdate(const Exchange::MEClientResponse
      *client_response) noexcept -&gt; void {
      logger_-&gt;log("%:% %() % %\n", __FILE__, __LINE__,
        __FUNCTION__, Common::
          getCurrentTimeStr(&amp;time_str_),
                   client_response-&gt;toString().c_str());
      order_manager_-&gt;onOrderUpdate(client_response);
    }</span></pre>
<p><span class="koboSpan" id="kobo.648.1">That concludes our implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.649.1">LiquidityTaker</span></strong><span class="koboSpan" id="kobo.650.1"> trading strategy. </span><span class="koboSpan" id="kobo.650.2">In the next section, we </span><a id="_idIndexMarker1381"/><span class="koboSpan" id="kobo.651.1">will shift the discussion to </span><a id="_idIndexMarker1382"/><span class="koboSpan" id="kobo.652.1">building the final form of our trading application so that we can build and run these actual trading strategies in our electronic </span><span class="No-Break"><span class="koboSpan" id="kobo.653.1">trading ecosystem.</span></span></p>
<h1 id="_idParaDest-267"><a id="_idTextAnchor280"/><span class="koboSpan" id="kobo.654.1">Building the trade engine framework</span></h1>
<p><span class="koboSpan" id="kobo.655.1">In this section, we </span><a id="_idIndexMarker1383"/><span class="koboSpan" id="kobo.656.1">will build the trade engine framework in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.657.1">TradeEngine</span></strong><span class="koboSpan" id="kobo.658.1"> class. </span><span class="koboSpan" id="kobo.658.2">This framework ties all the different components we built together – the </span><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">OrderGateway</span></strong><span class="koboSpan" id="kobo.660.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.661.1">MarketDataConsumer</span></strong><span class="koboSpan" id="kobo.662.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">MarketOrderBook</span></strong><span class="koboSpan" id="kobo.664.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">FeatureEngine</span></strong><span class="koboSpan" id="kobo.666.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.667.1">PositionKeeper</span></strong><span class="koboSpan" id="kobo.668.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.669.1">OrderManager</span></strong><span class="koboSpan" id="kobo.670.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.671.1">RiskManager</span></strong><span class="koboSpan" id="kobo.672.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.673.1">MarketMaker</span></strong><span class="koboSpan" id="kobo.674.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.675.1">LiquidityTaker</span></strong><span class="koboSpan" id="kobo.676.1"> components. </span><span class="koboSpan" id="kobo.676.2">As a reminder of the trading engine component, we present a diagram of all the sub-components here. </span><span class="koboSpan" id="kobo.676.3">We have built all the sub-components; now, we will just build the trading engine framework in which these </span><span class="No-Break"><span class="koboSpan" id="kobo.677.1">sub-components exist.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer065">
<span class="koboSpan" id="kobo.678.1"><img alt="Figure 10.8 – The components of the trading engine in the client’s trading system" src="image/Figure_9.1_B19434.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.679.1">Figure 10.8 – The components of the trading engine in the client’s trading system</span></p>
<p><span class="koboSpan" id="kobo.680.1">We will start this </span><a id="_idIndexMarker1384"/><span class="koboSpan" id="kobo.681.1">section by defining the data members of our class, as usual. </span><span class="koboSpan" id="kobo.681.2">All the source code for the basic </span><strong class="source-inline"><span class="koboSpan" id="kobo.682.1">TradeEngine</span></strong><span class="koboSpan" id="kobo.683.1"> framework is in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.684.1">Chapter10/trading/strategy/trade_engine.h</span></strong><span class="koboSpan" id="kobo.685.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.686.1">Chapter10/trading/strategy/trade_engine.cpp</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.687.1">source files.</span></span></p>
<h2 id="_idParaDest-268"><a id="_idTextAnchor281"/><span class="koboSpan" id="kobo.688.1">Defining the data members in the trade engine</span></h2>
<p><span class="koboSpan" id="kobo.689.1">Before </span><a id="_idIndexMarker1385"/><span class="koboSpan" id="kobo.690.1">we define the data members in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.691.1">TradeEngine</span></strong><span class="koboSpan" id="kobo.692.1"> class, we present the header files that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">trade_engine.h</span></strong><span class="koboSpan" id="kobo.694.1"> source file needs </span><span class="No-Break"><span class="koboSpan" id="kobo.695.1">to include:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.696.1">
#pragma once
#include &lt;functional&gt;
#include "common/thread_utils.h"
#include "common/time_utils.h"
#include "common/lf_queue.h"
#include "common/macros.h"
#include "common/logging.h"
#include "exchange/order_server/client_request.h"
#include "exchange/order_server/client_response.h"
#include "exchange/market_data/market_update.h"
#include "market_order_book.h"
#include "feature_engine.h"
#include "position_keeper.h"
#include "order_manager.h"
#include "risk_manager.h"
#include "market_maker.h"
#include "liquidity_taker.h"</span></pre>
<p><span class="koboSpan" id="kobo.697.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.698.1">TradeEngine</span></strong><span class="koboSpan" id="kobo.699.1"> class needs the following basic </span><span class="No-Break"><span class="koboSpan" id="kobo.700.1">data members:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.701.1">It has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.702.1">client_id_</span></strong><span class="koboSpan" id="kobo.703.1"> variable of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.704.1">ClientId</span></strong><span class="koboSpan" id="kobo.705.1"> to represent the unique trading </span><span class="No-Break"><span class="koboSpan" id="kobo.706.1">application instance.</span></span></li>
<li><span class="koboSpan" id="kobo.707.1">We create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.708.1">ticker_order_book_</span></strong><span class="koboSpan" id="kobo.709.1"> instance of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.710.1">MarketOrderBookHashMap</span></strong><span class="koboSpan" id="kobo.711.1">, which, as a reminder, is </span><strong class="source-inline"><span class="koboSpan" id="kobo.712.1">std::array</span></strong><span class="koboSpan" id="kobo.713.1"> of </span><strong class="source-inline"><span class="koboSpan" id="kobo.714.1">MarketOrderBook</span></strong><span class="koboSpan" id="kobo.715.1"> objects to represent a hash map from </span><strong class="source-inline"><span class="koboSpan" id="kobo.716.1">TickerId</span></strong><span class="koboSpan" id="kobo.717.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.718.1">MarketOrderBook</span></strong><span class="koboSpan" id="kobo.719.1"> for </span><span class="No-Break"><span class="koboSpan" id="kobo.720.1">that instrument.</span></span></li>
<li><span class="koboSpan" id="kobo.721.1">We have three </span><a id="_idIndexMarker1386"/><span class="koboSpan" id="kobo.722.1">lock-free queues to receive market data updates, send order requests, and receive order responses from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.723.1">MarketDataConsumer</span></strong><span class="koboSpan" id="kobo.724.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.725.1">OrderGateway</span></strong><span class="koboSpan" id="kobo.726.1"> components. </span><span class="koboSpan" id="kobo.726.2">We receive market data updates using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.727.1">incoming_md_updates_</span></strong><span class="koboSpan" id="kobo.728.1"> variable, which is a pointer to type </span><strong class="source-inline"><span class="koboSpan" id="kobo.729.1">MEMarketUpdateLFQueue</span></strong><span class="koboSpan" id="kobo.730.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.731.1">LFQueue</span></strong><span class="koboSpan" id="kobo.732.1"> of </span><strong class="source-inline"><span class="koboSpan" id="kobo.733.1">MEMarketUpdate</span></strong><span class="koboSpan" id="kobo.734.1"> messages). </span><span class="koboSpan" id="kobo.734.2">We send client order requests using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.735.1">outgoing_ogw_requests_</span></strong><span class="koboSpan" id="kobo.736.1"> variable, which is a pointer to type </span><strong class="source-inline"><span class="koboSpan" id="kobo.737.1">ClientRequestLFQueue</span></strong><span class="koboSpan" id="kobo.738.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.739.1">LFQueue</span></strong><span class="koboSpan" id="kobo.740.1"> of </span><strong class="source-inline"><span class="koboSpan" id="kobo.741.1">MEClientRequest</span></strong><span class="koboSpan" id="kobo.742.1"> messages). </span><span class="koboSpan" id="kobo.742.2">We receive client order responses using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.743.1">incoming_ogw_responses_</span></strong><span class="koboSpan" id="kobo.744.1"> variable, which is a pointer to type </span><strong class="source-inline"><span class="koboSpan" id="kobo.745.1">ClientResponseLFQueue</span></strong><span class="koboSpan" id="kobo.746.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.747.1">LFQueue</span></strong><span class="koboSpan" id="kobo.748.1"> of </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.749.1">MEClientResponse</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.750.1"> messages).</span></span></li>
<li><span class="koboSpan" id="kobo.751.1">We have the usual Boolean </span><strong class="source-inline"><span class="koboSpan" id="kobo.752.1">run_</span></strong><span class="koboSpan" id="kobo.753.1"> variable, which will control the execution of the main </span><strong class="source-inline"><span class="koboSpan" id="kobo.754.1">TradeEngine</span></strong><span class="koboSpan" id="kobo.755.1"> thread and is </span><span class="No-Break"><span class="koboSpan" id="kobo.756.1">marked </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.757.1">volatile</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.758.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.759.1">We have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.760.1">last_event_time_</span></strong><span class="koboSpan" id="kobo.761.1"> variable of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.762.1">Nanos</span></strong><span class="koboSpan" id="kobo.763.1"> to keep track of the time when the last message from the exchange </span><span class="No-Break"><span class="koboSpan" id="kobo.764.1">was received.</span></span></li>
<li><span class="koboSpan" id="kobo.765.1">We will </span><a id="_idIndexMarker1387"/><span class="koboSpan" id="kobo.766.1">also have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.767.1">Logger</span></strong><span class="koboSpan" id="kobo.768.1"> variable called </span><strong class="source-inline"><span class="koboSpan" id="kobo.769.1">logger_</span></strong><span class="koboSpan" id="kobo.770.1"> to create a log file for </span><strong class="source-inline"><span class="koboSpan" id="kobo.771.1">TradeEngine</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.772.1">to use:</span></span></li>
</ul>
<pre class="source-code"><span class="koboSpan" id="kobo.773.1">
namespace Trading {
  class TradeEngine {
  private:
    const ClientId client_id_;
    MarketOrderBookHashMap ticker_order_book_;
    Exchange::ClientRequestLFQueue *outgoing_ogw_requests_
      = nullptr;
    Exchange::ClientResponseLFQueue
      *incoming_ogw_responses_ = nullptr;
    Exchange::MEMarketUpdateLFQueue *incoming_md_updates_ =
      nullptr;
    Nanos last_event_time_ = 0;
    volatile bool run_ = false;
    std::string time_str_;
    Logger logger_;</span></pre>
<p><span class="koboSpan" id="kobo.774.1">We also need instances of each of our components from the previous chapter, namely </span><span class="No-Break"><span class="koboSpan" id="kobo.775.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.776.1">A variable of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.777.1">FeatureEngine</span></strong><span class="koboSpan" id="kobo.778.1"> called </span><strong class="source-inline"><span class="koboSpan" id="kobo.779.1">feature_engine_</span></strong><span class="koboSpan" id="kobo.780.1"> to compute complex </span><span class="No-Break"><span class="koboSpan" id="kobo.781.1">feature values</span></span></li>
<li><span class="koboSpan" id="kobo.782.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.783.1">position_keeper_</span></strong><span class="koboSpan" id="kobo.784.1"> variable of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.785.1">PositionKeeper</span></strong><span class="koboSpan" id="kobo.786.1"> to track trading strategy positions and Profits and Losses (</span><strong class="bold"><span class="koboSpan" id="kobo.787.1">PnLs</span></strong><span class="koboSpan" id="kobo.788.1">) money made or lost from </span><span class="No-Break"><span class="koboSpan" id="kobo.789.1">our trading</span></span></li>
<li><span class="koboSpan" id="kobo.790.1">An instance of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.791.1">OrderManager</span></strong><span class="koboSpan" id="kobo.792.1"> called </span><strong class="source-inline"><span class="koboSpan" id="kobo.793.1">order_manager_</span></strong><span class="koboSpan" id="kobo.794.1">, which will be used by the trading strategies to send and manage </span><span class="No-Break"><span class="koboSpan" id="kobo.795.1">live orders</span></span></li>
<li><span class="koboSpan" id="kobo.796.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.797.1">RiskManager</span></strong><span class="koboSpan" id="kobo.798.1"> object named </span><strong class="source-inline"><span class="koboSpan" id="kobo.799.1">risk_manager_</span></strong><span class="koboSpan" id="kobo.800.1"> to manage the trading </span><span class="No-Break"><span class="koboSpan" id="kobo.801.1">strategy’s risk</span></span></li>
<li><span class="koboSpan" id="kobo.802.1">A pointer to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.803.1">MarketMaker</span></strong><span class="koboSpan" id="kobo.804.1"> object called </span><strong class="source-inline"><span class="koboSpan" id="kobo.805.1">mm_algo_</span></strong><span class="koboSpan" id="kobo.806.1">, which will be initialized if we configure </span><strong class="source-inline"><span class="koboSpan" id="kobo.807.1">TradeEngine</span></strong><span class="koboSpan" id="kobo.808.1"> to run a MM </span><span class="No-Break"><span class="koboSpan" id="kobo.809.1">trading algorithm</span></span></li>
<li><span class="koboSpan" id="kobo.810.1">Similarly, a pointer to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.811.1">LiquidityTaker</span></strong><span class="koboSpan" id="kobo.812.1"> object called </span><strong class="source-inline"><span class="koboSpan" id="kobo.813.1">taker_algo_</span></strong><span class="koboSpan" id="kobo.814.1">, which </span><a id="_idIndexMarker1388"/><span class="koboSpan" id="kobo.815.1">will be initialized if we configure </span><strong class="source-inline"><span class="koboSpan" id="kobo.816.1">TradeEngine</span></strong><span class="koboSpan" id="kobo.817.1"> to run a liquidity taking </span><span class="No-Break"><span class="koboSpan" id="kobo.818.1">trading strategy:</span></span></li>
</ul>
<pre class="source-code"><span class="koboSpan" id="kobo.819.1">
    FeatureEngine feature_engine_;
    PositionKeeper position_keeper_;
    OrderManager order_manager_;
    RiskManager risk_manager_;
    MarketMaker *mm_algo_ = nullptr;
    LiquidityTaker *taker_algo_ = nullptr;</span></pre>
<p><span class="koboSpan" id="kobo.820.1">We will also add three </span><strong class="source-inline"><span class="koboSpan" id="kobo.821.1">std::function</span></strong><span class="koboSpan" id="kobo.822.1"> member variables, which </span><strong class="source-inline"><span class="koboSpan" id="kobo.823.1">TradeEngine</span></strong><span class="koboSpan" id="kobo.824.1"> will use to forward market data and order updates to the trading strategy that it instantiates. </span><span class="koboSpan" id="kobo.824.2">These are explained </span><span class="No-Break"><span class="koboSpan" id="kobo.825.1">as follows:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.826.1">algoOnOrderBookUpdate_</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.827.1">std::function</span></strong><span class="koboSpan" id="kobo.828.1"> has the same signature as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.829.1">TradeEngine::onOrderBookUpdate()</span></strong><span class="koboSpan" id="kobo.830.1"> method and is used to forward order book updates to the </span><span class="No-Break"><span class="koboSpan" id="kobo.831.1">trading strategy</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.832.1">algoOnTradeUpdate_</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.833.1">std::function</span></strong><span class="koboSpan" id="kobo.834.1"> has the same signature as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.835.1">TradeEngine::onTradeUpdate()</span></strong><span class="koboSpan" id="kobo.836.1"> method and is used to forward trade events to the </span><span class="No-Break"><span class="koboSpan" id="kobo.837.1">trading strategy</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.838.1">algoOnOrderUpdate_</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.839.1">std::function</span></strong><span class="koboSpan" id="kobo.840.1"> has the same signature as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.841.1">TradeEngine::onOrderUpdate()</span></strong><span class="koboSpan" id="kobo.842.1"> method and is used to forward order updates/responses to the </span><span class="No-Break"><span class="koboSpan" id="kobo.843.1">trading strategy:</span></span></li>
</ul>
<pre class="source-code"><span class="koboSpan" id="kobo.844.1">
    std::function&lt;void(TickerId ticker_id, Price price,
      Side side, MarketOrderBook *book)&gt;
        algoOnOrderBookUpdate_;
    std::function&lt;void(const Exchange::MEMarketUpdate
      *market_update, MarketOrderBook *book)&gt;
        algoOnTradeUpdate_;
    std::function&lt;void(const Exchange::MEClientResponse
      *client_response)&gt; algoOnOrderUpdate_;</span></pre>
<p><span class="koboSpan" id="kobo.845.1">To default-initialize </span><a id="_idIndexMarker1389"/><span class="koboSpan" id="kobo.846.1">these three </span><strong class="source-inline"><span class="koboSpan" id="kobo.847.1">std::function</span></strong><span class="koboSpan" id="kobo.848.1"> data members, we will create three new methods that simply log the parameters they are passed. </span><span class="koboSpan" id="kobo.848.2">They are </span><span class="No-Break"><span class="koboSpan" id="kobo.849.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.850.1">
    auto defaultAlgoOnOrderBookUpdate(TickerId ticker_id,
      Price price, Side side, MarketOrderBook *) noexcept
       -&gt; void {
      logger_.log("%:% %() % ticker:% price:% side:%\n",
        __FILE__, __LINE__, __FUNCTION__,
                  Common::getCurrentTimeStr(&amp;time_str_),
                    ticker_id, Common::
                      priceToString(price).c_str(),
                  Common::sideToString(side).c_str());
    }
    auto defaultAlgoOnTradeUpdate(const
      Exchange::MEMarketUpdate *market_update,
        MarketOrderBook *) noexcept -&gt; void {
      logger_.log("%:% %() % %\n", __FILE__, __LINE__,
        __FUNCTION__, Common::
          getCurrentTimeStr(&amp;time_str_),
                  market_update-&gt;toString().c_str());
    }
    auto defaultAlgoOnOrderUpdate(const
      Exchange::MEClientResponse *client_response) noexcept
        -&gt; void {
      logger_.log("%:% %() % %\n", __FILE__, __LINE__,
        __FUNCTION__, Common::
          getCurrentTimeStr(&amp;time_str_),
                  client_response-&gt;toString().c_str());
    }</span></pre>
<p><span class="koboSpan" id="kobo.851.1">Next, we will discuss the </span><a id="_idIndexMarker1390"/><span class="koboSpan" id="kobo.852.1">code for some methods to initialize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.853.1">TradeEngine</span></strong><span class="koboSpan" id="kobo.854.1"> class and its </span><span class="No-Break"><span class="koboSpan" id="kobo.855.1">member variables.</span></span></p>
<h2 id="_idParaDest-269"><a id="_idTextAnchor282"/><span class="koboSpan" id="kobo.856.1">Initializing the trade engine</span></h2>
<p><span class="koboSpan" id="kobo.857.1">The constructor </span><a id="_idIndexMarker1391"/><span class="koboSpan" id="kobo.858.1">for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.859.1">TradeEngine</span></strong><span class="koboSpan" id="kobo.860.1"> class requires a </span><strong class="source-inline"><span class="koboSpan" id="kobo.861.1">ClientId</span></strong><span class="koboSpan" id="kobo.862.1"> argument to identify the trading application used in the client order requests. </span><span class="koboSpan" id="kobo.862.2">It also needs pointers to the three </span><strong class="source-inline"><span class="koboSpan" id="kobo.863.1">LFQueue</span></strong><span class="koboSpan" id="kobo.864.1"> of types </span><strong class="source-inline"><span class="koboSpan" id="kobo.865.1">ClientRequestLFQueue</span></strong><span class="koboSpan" id="kobo.866.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.867.1">ClientResponseLFQueue</span></strong><span class="koboSpan" id="kobo.868.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.869.1">MEMarketUpdateLFQueue</span></strong><span class="koboSpan" id="kobo.870.1"> to initialize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.871.1">outgoing_ogw_requests_</span></strong><span class="koboSpan" id="kobo.872.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.873.1">incoming_ogw_responses_</span></strong><span class="koboSpan" id="kobo.874.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.875.1">incoming_md_updates_</span></strong><span class="koboSpan" id="kobo.876.1"> data members, respectively. </span><span class="koboSpan" id="kobo.876.2">It also needs an </span><strong class="source-inline"><span class="koboSpan" id="kobo.877.1">algo_type</span></strong><span class="koboSpan" id="kobo.878.1"> argument of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.879.1">AlgoType</span></strong><span class="koboSpan" id="kobo.880.1"> to specify the type of trading strategy and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.881.1">ticker_cfg</span></strong><span class="koboSpan" id="kobo.882.1"> argument of type reference-to </span><strong class="source-inline"><span class="koboSpan" id="kobo.883.1">const TradeEngineCfgHashMap</span></strong><span class="koboSpan" id="kobo.884.1">, which contains the configuration parameters for the risk manager and the </span><span class="No-Break"><span class="koboSpan" id="kobo.885.1">trading strategy.</span></span></p>
<p><span class="koboSpan" id="kobo.886.1">The constructor also initializes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.887.1">Logger logger_</span></strong><span class="koboSpan" id="kobo.888.1"> member variable with a log file and creates a </span><strong class="source-inline"><span class="koboSpan" id="kobo.889.1">MarketOrderBook</span></strong><span class="koboSpan" id="kobo.890.1"> component for each possible </span><strong class="source-inline"><span class="koboSpan" id="kobo.891.1">TickerId</span></strong><span class="koboSpan" id="kobo.892.1"> value, holding them in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.893.1">ticker_order_book_</span></strong><span class="koboSpan" id="kobo.894.1"> container. </span><span class="koboSpan" id="kobo.894.2">It calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.895.1">setTradeEngine()</span></strong><span class="koboSpan" id="kobo.896.1"> method on each </span><strong class="source-inline"><span class="koboSpan" id="kobo.897.1">MarketOrderBook</span></strong><span class="koboSpan" id="kobo.898.1"> component so that callbacks from the book can be received in </span><strong class="source-inline"><span class="koboSpan" id="kobo.899.1">TradeEngine</span></strong><span class="koboSpan" id="kobo.900.1">. </span><span class="koboSpan" id="kobo.900.2">We also initialize the data members corresponding to the trading sub-components – </span><strong class="source-inline"><span class="koboSpan" id="kobo.901.1">feature_engine_</span></strong><span class="koboSpan" id="kobo.902.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.903.1">position_keeper_</span></strong><span class="koboSpan" id="kobo.904.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.905.1">order_manager_</span></strong><span class="koboSpan" id="kobo.906.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.907.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.908.1">risk_manager_</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.909.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.910.1">
  TradeEngine::TradeEngine(Common::ClientId client_id,
    AlgoType algo_type,
const TradeEngineCfgHashMap &amp;ticker_cfg,
Exchange::ClientRequestLFQueue *client_requests,
Exchange::ClientResponseLFQueue *client_responses,
Exchange::MEMarketUpdateLFQueue *market_updates)
      : client_id_(client_id),
        outgoing_ogw_requests_(client_requests),
          incoming_ogw_responses_(client_responses),
        incoming_md_updates_(market_updates),
          logger_("trading_engine_" + std::
            to_string(client_id) + ".log"),
        feature_engine_(&amp;logger_),
        position_keeper_(&amp;logger_),
        order_manager_(&amp;logger_, this, risk_manager_),
        risk_manager_(&amp;logger_, &amp;position_keeper_,
          ticker_cfg) {
    for (size_t i = 0; i &lt; ticker_order_book_.size(); ++i) {
      ticker_order_book_[i] = new MarketOrderBook(i, &amp;logger_);
      ticker_order_book_[i]-&gt;setTradeEngine(this);
    }</span></pre>
<p><span class="koboSpan" id="kobo.911.1">In the body </span><a id="_idIndexMarker1392"/><span class="koboSpan" id="kobo.912.1">of the constructor, in addition to the order books we previously created, we will initialize our new </span><strong class="source-inline"><span class="koboSpan" id="kobo.913.1">std::function</span></strong><span class="koboSpan" id="kobo.914.1"> members – </span><strong class="source-inline"><span class="koboSpan" id="kobo.915.1">algoOnOrderBookUpdate_</span></strong><span class="koboSpan" id="kobo.916.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.917.1">algoOnTradeUpdate_</span></strong><span class="koboSpan" id="kobo.918.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.919.1">algoOnOrderUpdate_</span></strong><span class="koboSpan" id="kobo.920.1"> – with the defaults – the </span><strong class="source-inline"><span class="koboSpan" id="kobo.921.1">defaultAlgoOnOrderBookUpdate()</span></strong><span class="koboSpan" id="kobo.922.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.923.1">defaultAlgoOnTradeUpdate()</span></strong><span class="koboSpan" id="kobo.924.1">, and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.925.1">defaultAlgoOnOrderUpdate()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.926.1"> methods:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.927.1">
    algoOnOrderBookUpdate_ = [this](auto ticker_id, auto
      price, auto side, auto book) {
      defaultAlgoOnOrderBookUpdate(ticker_id, price, side,
        book);
    };
    algoOnTradeUpdate_ = [this](auto market_update, auto
      book) { defaultAlgoOnTradeUpdate(market_update,
        book); };
    algoOnOrderUpdate_ = [this](auto client_response) {
      defaultAlgoOnOrderUpdate(client_response); };</span></pre>
<p><span class="koboSpan" id="kobo.928.1">Finally, we will initialize a trading strategy instance, either </span><strong class="source-inline"><span class="koboSpan" id="kobo.929.1">mm_algo_</span></strong><span class="koboSpan" id="kobo.930.1"> of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.931.1">MarketMaker</span></strong><span class="koboSpan" id="kobo.932.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.933.1">taker_algo_</span></strong><span class="koboSpan" id="kobo.934.1"> of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.935.1">LiquidityTaker</span></strong><span class="koboSpan" id="kobo.936.1"> type trading strategy. </span><span class="koboSpan" id="kobo.936.2">This initialization is </span><a id="_idIndexMarker1393"/><span class="koboSpan" id="kobo.937.1">shown as follows; remember that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.938.1">MarketMaker</span></strong><span class="koboSpan" id="kobo.939.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.940.1">LiquidityTaker</span></strong><span class="koboSpan" id="kobo.941.1"> object will update/override the members – </span><strong class="source-inline"><span class="koboSpan" id="kobo.942.1">algoOnOrderBookUpdate_</span></strong><span class="koboSpan" id="kobo.943.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.944.1">algoOnTradeUpdate_</span></strong><span class="koboSpan" id="kobo.945.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.946.1">algoOnOrderUpdate_</span></strong><span class="koboSpan" id="kobo.947.1"> – to point to their own </span><span class="No-Break"><span class="koboSpan" id="kobo.948.1">method implementations:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.949.1">
    if (algo_type == AlgoType::MAKER) {
      mm_algo_ = new MarketMaker(&amp;logger_, this,
        &amp;feature_engine_, &amp;order_manager_, ticker_cfg);
    } else if (algo_type == AlgoType::TAKER) {
      taker_algo_ = new LiquidityTaker(&amp;logger_, this,
        &amp;feature_engine_, &amp;order_manager_, ticker_cfg);
    }
    for (TickerId i = 0; i &lt; ticker_cfg.size(); ++i) {
      logger_.log("%:% %() % Initialized % Ticker:% %.\n",
        __FILE__, __LINE__, __FUNCTION__,
                  Common::getCurrentTimeStr(&amp;time_str_),
                  algoTypeToString(algo_type), i,
                  ticker_cfg.at(i).toString());
    }
  }</span></pre>
<p><span class="koboSpan" id="kobo.950.1">We have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.951.1">start()</span></strong><span class="koboSpan" id="kobo.952.1"> method, as we saw for other components. </span><span class="koboSpan" id="kobo.952.2">Again, it sets the </span><strong class="source-inline"><span class="koboSpan" id="kobo.953.1">run_</span></strong><span class="koboSpan" id="kobo.954.1"> flag to </span><strong class="source-inline"><span class="koboSpan" id="kobo.955.1">true</span></strong><span class="koboSpan" id="kobo.956.1"> to allow the </span><strong class="source-inline"><span class="koboSpan" id="kobo.957.1">run()</span></strong><span class="koboSpan" id="kobo.958.1"> method to execute and creates and launches a thread to execute the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.959.1">run()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.960.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.961.1">
    auto start() -&gt; void {
      run_ = true;
      ASSERT(Common::createAndStartThread(-1,
        "Trading/TradeEngine", [this] { run(); }) !=
          nullptr, "Failed to start TradeEngine thread.");
    }</span></pre>
<p><span class="koboSpan" id="kobo.962.1">The destructor does some simple de-initialization of the variables. </span><span class="koboSpan" id="kobo.962.2">First, it sets the </span><strong class="source-inline"><span class="koboSpan" id="kobo.963.1">run_</span></strong><span class="koboSpan" id="kobo.964.1"> flag to </span><strong class="source-inline"><span class="koboSpan" id="kobo.965.1">false</span></strong><span class="koboSpan" id="kobo.966.1"> and </span><a id="_idIndexMarker1394"/><span class="koboSpan" id="kobo.967.1">waits a little bit to let the main thread exit, then it proceeds to delete each </span><strong class="source-inline"><span class="koboSpan" id="kobo.968.1">MarketOrderBook</span></strong><span class="koboSpan" id="kobo.969.1"> instance and clear out the </span><strong class="source-inline"><span class="koboSpan" id="kobo.970.1">ticker_order_book_</span></strong><span class="koboSpan" id="kobo.971.1"> container, and finally, it resets the </span><strong class="source-inline"><span class="koboSpan" id="kobo.972.1">LFQueue</span></strong><span class="koboSpan" id="kobo.973.1"> pointers it holds. </span><span class="koboSpan" id="kobo.973.2">It also deletes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.974.1">mm_algo_</span></strong><span class="koboSpan" id="kobo.975.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.976.1">taker_algo_</span></strong><span class="koboSpan" id="kobo.977.1"> members corresponding to the </span><span class="No-Break"><span class="koboSpan" id="kobo.978.1">trading strategies:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.979.1">
  TradeEngine::~TradeEngine() {
    run_ = false;
    using namespace std::literals::chrono_literals;
    std::this_thread::sleep_for(1s);
    delete mm_algo_; mm_algo_ = nullptr;
    delete taker_algo_; taker_algo_ = nullptr;
    for (auto &amp;order_book: ticker_order_book_) {
      delete order_book;
      order_book = nullptr;
    }
    outgoing_ogw_requests_ = nullptr;
    incoming_ogw_responses_ = nullptr;
    incoming_md_updates_ = nullptr;
  }</span></pre>
<p><span class="koboSpan" id="kobo.980.1">The familiar </span><strong class="source-inline"><span class="koboSpan" id="kobo.981.1">stop()</span></strong><span class="koboSpan" id="kobo.982.1"> method for this class first waits until all the incoming </span><strong class="source-inline"><span class="koboSpan" id="kobo.983.1">MEClientResponse</span></strong><span class="koboSpan" id="kobo.984.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.985.1">MEMarketUpdate</span></strong><span class="koboSpan" id="kobo.986.1"> messages are drained from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.987.1">incoming_ogw_responses_</span></strong><span class="koboSpan" id="kobo.988.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.989.1">incoming_md_updates_</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.990.1">LFQueue</span></strong><span class="koboSpan" id="kobo.991.1"> objects. </span><span class="koboSpan" id="kobo.991.2">Then, it resets </span><a id="_idIndexMarker1395"/><span class="koboSpan" id="kobo.992.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.993.1">run_</span></strong><span class="koboSpan" id="kobo.994.1"> flag to stop the main </span><strong class="source-inline"><span class="koboSpan" id="kobo.995.1">run()</span></strong><span class="koboSpan" id="kobo.996.1"> thread and returns from </span><span class="No-Break"><span class="koboSpan" id="kobo.997.1">the function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.998.1">
    auto stop() -&gt; void {
      while(incoming_ogw_responses_-&gt;size() ||
        incoming_md_updates_-&gt;size()) {
        logger_.log("%:% %() % Sleeping till all updates
          are consumed ogw-size:% md-size:%\n", __FILE__,
            __LINE__, __FUNCTION__,
                    Common::getCurrentTimeStr(&amp;time_str_),
                       incoming_ogw_responses_-&gt;size(),
                         incoming_md_updates_-&gt;size());
        using namespace std::literals::chrono_literals;
        std::this_thread::sleep_for(10ms);
      }
      logger_.log("%:% %() % POSITIONS\n%\n", __FILE__,
        __LINE__, __FUNCTION__, Common::
         getCurrentTimeStr(&amp;time_str_),
                  position_keeper_.toString());
      run_ = false;
    }</span></pre>
<p><span class="koboSpan" id="kobo.999.1">The next method we </span><a id="_idIndexMarker1396"/><span class="koboSpan" id="kobo.1000.1">will add to this basic framework is meant to be used to send </span><strong class="source-inline"><span class="koboSpan" id="kobo.1001.1">MEClientRequest</span></strong><span class="koboSpan" id="kobo.1002.1"> messages to </span><span class="No-Break"><span class="koboSpan" id="kobo.1003.1">the exchange.</span></span></p>
<h2 id="_idParaDest-270"><a id="_idTextAnchor283"/><span class="koboSpan" id="kobo.1004.1">Sending client requests</span></h2>
<p><span class="koboSpan" id="kobo.1005.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1006.1">sendClientRequest()</span></strong><span class="koboSpan" id="kobo.1007.1"> method in the trading engine framework is extremely simple. </span><span class="koboSpan" id="kobo.1007.2">It </span><a id="_idIndexMarker1397"/><span class="koboSpan" id="kobo.1008.1">receives a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1009.1">MEClientRequest</span></strong><span class="koboSpan" id="kobo.1010.1"> object and simply writes it to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1011.1">outgoing_ogw_requests_</span></strong><span class="koboSpan" id="kobo.1012.1"> lock-free queue so that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1013.1">OrderGateway</span></strong><span class="koboSpan" id="kobo.1014.1"> component can pick this up and send it out to the </span><span class="No-Break"><span class="koboSpan" id="kobo.1015.1">trading exchange:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1016.1">
  auto TradeEngine::sendClientRequest(const
    Exchange::MEClientRequest *client_request) noexcept -&gt;
    void {
    logger_.log("%:% %() % Sending %\n", __FILE__,
      __LINE__, __FUNCTION__, Common::
        getCurrentTimeStr(&amp;time_str_),
                client_request-&gt;toString().c_str());
    auto next_write = outgoing_ogw_requests_-&gt;
      getNextToWriteTo();
    *next_write = std::move(*client_request);
    outgoing_ogw_requests_-&gt;updateWriteIndex();
  }</span></pre>
<p><span class="koboSpan" id="kobo.1017.1">The next subsection presents the main </span><strong class="source-inline"><span class="koboSpan" id="kobo.1018.1">run()</span></strong><span class="koboSpan" id="kobo.1019.1"> loop and shows how we handle incoming data from </span><span class="No-Break"><span class="koboSpan" id="kobo.1020.1">the exchange.</span></span></p>
<h2 id="_idParaDest-271"><a id="_idTextAnchor284"/><span class="koboSpan" id="kobo.1021.1">Processing market data updates and client responses</span></h2>
<p><span class="koboSpan" id="kobo.1022.1">The main thread </span><a id="_idIndexMarker1398"/><span class="koboSpan" id="kobo.1023.1">for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1024.1">TradeEngine</span></strong><span class="koboSpan" id="kobo.1025.1"> executes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1026.1">run()</span></strong><span class="koboSpan" id="kobo.1027.1"> method, which simply checks the incoming data </span><strong class="source-inline"><span class="koboSpan" id="kobo.1028.1">LFQueue</span></strong><span class="koboSpan" id="kobo.1029.1"> and </span><a id="_idIndexMarker1399"/><span class="koboSpan" id="kobo.1030.1">reads and processes any </span><span class="No-Break"><span class="koboSpan" id="kobo.1031.1">available updates.</span></span></p>
<p><span class="koboSpan" id="kobo.1032.1">First, we check and drain the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1033.1">incoming_ogw_responses_</span></strong><span class="koboSpan" id="kobo.1034.1"> queue. </span><span class="koboSpan" id="kobo.1034.2">For each </span><strong class="source-inline"><span class="koboSpan" id="kobo.1035.1">MEClientResponse</span></strong><span class="koboSpan" id="kobo.1036.1"> message we read here, we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1037.1">TradeEngine::onOrderUpdate()</span></strong><span class="koboSpan" id="kobo.1038.1"> method and pass the response message from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1039.1">OrderGateway</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1040.1">to it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1041.1">
  auto TradeEngine::run() noexcept -&gt; void {
    logger_.log("%:% %() %\n", __FILE__, __LINE__,
      __FUNCTION__, Common::getCurrentTimeStr(&amp;time_str_));
    while (run_) {
      for (auto client_response = incoming_ogw_responses_-&gt;
        getNextToRead(); client_response; client_response =
          incoming_ogw_responses_-&gt;getNextToRead()) {
        logger_.log("%:% %() % Processing %\n", __FILE__,
          __LINE__, __FUNCTION__, Common::
            getCurrentTimeStr(&amp;time_str_),
                    client_response-&gt;toString().c_str());
        onOrderUpdate(client_response);
        incoming_ogw_responses_-&gt;updateReadIndex();
        last_event_time_ = Common::getCurrentNanos();
      }</span></pre>
<p><span class="koboSpan" id="kobo.1042.1">We perform </span><a id="_idIndexMarker1400"/><span class="koboSpan" id="kobo.1043.1">a similar task with </span><a id="_idIndexMarker1401"/><span class="koboSpan" id="kobo.1044.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1045.1">incoming_md_updates_</span></strong><span class="koboSpan" id="kobo.1046.1"> lock-free queue. </span><span class="koboSpan" id="kobo.1046.2">We read any available </span><strong class="source-inline"><span class="koboSpan" id="kobo.1047.1">MEMarketUpdate</span></strong><span class="koboSpan" id="kobo.1048.1"> messages and pass them to the correct </span><strong class="source-inline"><span class="koboSpan" id="kobo.1049.1">MarketOrderBook</span></strong><span class="koboSpan" id="kobo.1050.1"> instance by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1051.1">MarketOrderBook::onMarketUpdate()</span></strong><span class="koboSpan" id="kobo.1052.1"> method and passing the market update </span><span class="No-Break"><span class="koboSpan" id="kobo.1053.1">to it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1054.1">
      for (auto market_update = incoming_md_updates_-&gt;
        getNextToRead(); market_update; market_update =
          incoming_md_updates_-&gt;getNextToRead()) {
        logger_.log("%:% %() % Processing %\n", __FILE__,
         __LINE__, __FUNCTION__, Common::
           getCurrentTimeStr(&amp;time_str_),
                    market_update-&gt;toString().c_str());
        ASSERT(market_update-&gt;ticker_id_ &lt;
         ticker_order_book_.size(),
               "Unknown ticker-id on update:" +
                 market_update-&gt;toString());
        ticker_order_book_[market_update-&gt;ticker_id_]-&gt;
          onMarketUpdate(market_update);
        incoming_md_updates_-&gt;updateReadIndex();
        last_event_time_ = Common::getCurrentNanos();
      }
    }
  }</span></pre>
<p><span class="koboSpan" id="kobo.1055.1">Note that in both </span><a id="_idIndexMarker1402"/><span class="koboSpan" id="kobo.1056.1">of the preceding code </span><a id="_idIndexMarker1403"/><span class="koboSpan" id="kobo.1057.1">blocks, when we successfully read and dispatch a market data update or an order response, we update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1058.1">last_event_time_</span></strong><span class="koboSpan" id="kobo.1059.1"> variable to track the time of the event, as we described earlier in this section. </span><span class="koboSpan" id="kobo.1059.2">We will see some minor miscellaneous placeholder methods in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1060.1">next subsection.</span></span></p>
<h2 id="_idParaDest-272"><a id="_idTextAnchor285"/><span class="koboSpan" id="kobo.1061.1">Handling order book, trade, and order response updates</span></h2>
<p><span class="koboSpan" id="kobo.1062.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1063.1">TradeEngine::onOrderBookUpdate()</span></strong><span class="koboSpan" id="kobo.1064.1"> method performs a couple of tasks. </span><span class="koboSpan" id="kobo.1064.2">First, it </span><a id="_idIndexMarker1404"/><span class="koboSpan" id="kobo.1065.1">fetches </span><strong class="source-inline"><span class="koboSpan" id="kobo.1066.1">BBO</span></strong><span class="koboSpan" id="kobo.1067.1"> from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1068.1">MarketOrderBook</span></strong><span class="koboSpan" id="kobo.1069.1">, which it </span><a id="_idIndexMarker1405"/><span class="koboSpan" id="kobo.1070.1">receives in the method’s </span><a id="_idIndexMarker1406"/><span class="koboSpan" id="kobo.1071.1">arguments by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1072.1">MarketOrderBook::getBBO()</span></strong><span class="koboSpan" id="kobo.1073.1"> method. </span><span class="koboSpan" id="kobo.1073.2">It provides the updated </span><strong class="source-inline"><span class="koboSpan" id="kobo.1074.1">BBO</span></strong><span class="koboSpan" id="kobo.1075.1"> to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1076.1">position_keeper_</span></strong><span class="koboSpan" id="kobo.1077.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1078.1">feature_engine_</span></strong><span class="koboSpan" id="kobo.1079.1"> data members. </span><span class="koboSpan" id="kobo.1079.2">For the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1080.1">FeatureEngine</span></strong><span class="koboSpan" id="kobo.1081.1"> member, it calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1082.1">FeatureEngine::onOrderBookUpdate()</span></strong><span class="koboSpan" id="kobo.1083.1"> method to notify the feature engine to update its feature values. </span><span class="koboSpan" id="kobo.1083.2">The method also needs to call </span><strong class="source-inline"><span class="koboSpan" id="kobo.1084.1">algoOnOrderBookUpdate_()</span></strong><span class="koboSpan" id="kobo.1085.1"> so that the trading strategy can receive the notification about the order </span><span class="No-Break"><span class="koboSpan" id="kobo.1086.1">book update:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1087.1">
  auto TradeEngine::onOrderBookUpdate(TickerId ticker_id,
    Price price, Side side, MarketOrderBook *book) noexcept
      -&gt; void {
    logger_.log("%:% %() % ticker:% price:% side:%\n",
      __FILE__, __LINE__, __FUNCTION__,
                Common::getCurrentTimeStr(&amp;time_str_),
                  ticker_id, Common::priceToString
                     (price).c_str(),
                Common::sideToString(side).c_str());
    const auto bbo = book-&gt;getBBO();
    position_keeper_.updateBBO(ticker_id, bbo);
    feature_engine_.onOrderBookUpdate(ticker_id, price,
       side, book);
    algoOnOrderBookUpdate_(ticker_id, price, side, book);
  }</span></pre>
<p><span class="koboSpan" id="kobo.1088.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1089.1">TradeEngine::onTradeUpdate()</span></strong><span class="koboSpan" id="kobo.1090.1"> method that is called on trade events also performs a </span><a id="_idIndexMarker1407"/><span class="koboSpan" id="kobo.1091.1">couple of tasks, which are like </span><a id="_idIndexMarker1408"/><span class="koboSpan" id="kobo.1092.1">the ones in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1093.1">onOrderBookUpdate()</span></strong><span class="koboSpan" id="kobo.1094.1"> method we just saw. </span><span class="koboSpan" id="kobo.1094.2">It passes the trade event to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1095.1">FeatureEngine</span></strong><span class="koboSpan" id="kobo.1096.1"> by </span><a id="_idIndexMarker1409"/><span class="koboSpan" id="kobo.1097.1">calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1098.1">onTradeUpdate()</span></strong><span class="koboSpan" id="kobo.1099.1"> method so that the feature engine can update the features it computes. </span><span class="koboSpan" id="kobo.1099.2">It also passes the trade event to the trading strategy by invoking the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1100.1">algoOnTradeUpdate_()</span></strong> <span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1101.1">std::function</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1102.1"> member:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1103.1">
  auto TradeEngine::onTradeUpdate(const
    Exchange::MEMarketUpdate *market_update,
      MarketOrderBook *book) noexcept -&gt; void {
    logger_.log("%:% %() % %\n", __FILE__, __LINE__,
      __FUNCTION__, Common::getCurrentTimeStr(&amp;time_str_),
                market_update-&gt;toString().c_str());
    feature_engine_.onTradeUpdate(market_update, book);
    algoOnTradeUpdate_(market_update, book);
  }</span></pre>
<p><span class="koboSpan" id="kobo.1104.1">Finally, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1105.1">TradeEngine::onOrderUpdate()</span></strong><span class="koboSpan" id="kobo.1106.1"> does two things. </span><span class="koboSpan" id="kobo.1106.2">It checks whether </span><strong class="source-inline"><span class="koboSpan" id="kobo.1107.1">MEClientResponse</span></strong><span class="koboSpan" id="kobo.1108.1"> corresponds to </span><a id="_idIndexMarker1410"/><span class="koboSpan" id="kobo.1109.1">an execution (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1110.1">ClientResponseType::FILLED</span></strong><span class="koboSpan" id="kobo.1111.1">) and calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1112.1">PositionKeeper::addFill()</span></strong><span class="koboSpan" id="kobo.1113.1"> method to update the position and PnLs. </span><span class="koboSpan" id="kobo.1113.2">It also invokes </span><a id="_idIndexMarker1411"/><span class="koboSpan" id="kobo.1114.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1115.1">algoOnOrderUpdate_()</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.1116.1">std::function</span></strong><span class="koboSpan" id="kobo.1117.1"> member so that the trading strategy can </span><a id="_idIndexMarker1412"/><span class="koboSpan" id="kobo.1118.1">process </span><span class="No-Break"><span class="koboSpan" id="kobo.1119.1">the </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1120.1">MEClientResponse</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1121.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1122.1">
  auto TradeEngine::onOrderUpdate(const
    Exchange::MEClientResponse *client_response) noexcept
      -&gt; void {
    logger_.log("%:% %() % %\n", __FILE__, __LINE__,
      __FUNCTION__, Common::getCurrentTimeStr(&amp;time_str_),
                client_response-&gt;toString().c_str());
    if (UNLIKELY(client_response-&gt;type_ ==
     Exchange::ClientResponseType::FILLED))
      position_keeper_.addFill(client_response);
    algoOnOrderUpdate_(client_response);
  }</span></pre>
<p><span class="koboSpan" id="kobo.1123.1">Now, we can conclude the design and implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1124.1">TradeEngine</span></strong><span class="koboSpan" id="kobo.1125.1"> framework in the next subsection by defining some miscellaneous methods </span><span class="No-Break"><span class="koboSpan" id="kobo.1126.1">we require.</span></span></p>
<h2 id="_idParaDest-273"><a id="_idTextAnchor286"/><span class="koboSpan" id="kobo.1127.1">Adding some miscellaneous methods</span></h2>
<p><span class="koboSpan" id="kobo.1128.1">This section </span><a id="_idIndexMarker1413"/><span class="koboSpan" id="kobo.1129.1">defines some miscellaneous methods for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1130.1">TradeEngine</span></strong><span class="koboSpan" id="kobo.1131.1"> class. </span><span class="koboSpan" id="kobo.1131.2">The first method, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1132.1">initLastEventTime()</span></strong><span class="koboSpan" id="kobo.1133.1">, simply initializes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1134.1">last_event_time_</span></strong><span class="koboSpan" id="kobo.1135.1"> variable with the current time, which is obtained by calling the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1136.1">getCurrentNanos()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1137.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1138.1">
    auto initLastEventTime() {
      last_event_time_ = Common::getCurrentNanos();
    }</span></pre>
<p><span class="koboSpan" id="kobo.1139.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1140.1">silentSeconds()</span></strong><span class="koboSpan" id="kobo.1141.1"> method returns the time elapsed (in seconds) since the last event </span><span class="No-Break"><span class="koboSpan" id="kobo.1142.1">was received:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1143.1">
    auto silentSeconds() {
      return (Common::getCurrentNanos() - last_event_time_)
        / NANOS_TO_SECS;
    }</span></pre>
<p><span class="koboSpan" id="kobo.1144.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1145.1">clientId()</span></strong><span class="koboSpan" id="kobo.1146.1"> method is a simple getter method that returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.1147.1">client_id_</span></strong><span class="koboSpan" id="kobo.1148.1"> for this </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1149.1">TradeEngine</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1150.1"> instance:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1151.1">
    auto clientId() const {
      return client_id_;
    }</span></pre>
<p><span class="koboSpan" id="kobo.1152.1">That concludes the design and implementation of our trading engine framework. </span><span class="koboSpan" id="kobo.1152.2">In the next section, we will build the main trading </span><span class="No-Break"><span class="koboSpan" id="kobo.1153.1">application binary.</span></span></p>
<h1 id="_idParaDest-274"><a id="_idTextAnchor287"/><span class="koboSpan" id="kobo.1154.1">Building and running the main trading application</span></h1>
<p><span class="koboSpan" id="kobo.1155.1">In the last section </span><a id="_idIndexMarker1414"/><span class="koboSpan" id="kobo.1156.1">of this chapter, we will finally build the main </span><a id="_idIndexMarker1415"/><span class="koboSpan" id="kobo.1157.1">trading application using all the components we built in this chapter, as well as the previous two chapters. </span><span class="koboSpan" id="kobo.1157.2">First, we will discuss the implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1158.1">trading_main</span></strong><span class="koboSpan" id="kobo.1159.1"> binary application, which combines the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1160.1">MarketDataConsumer</span></strong><span class="koboSpan" id="kobo.1161.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1162.1">OrderGateway</span></strong><span class="koboSpan" id="kobo.1163.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1164.1">MarketOrderBook</span></strong><span class="koboSpan" id="kobo.1165.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1166.1">TradeEngine</span></strong><span class="koboSpan" id="kobo.1167.1"> components. </span><span class="koboSpan" id="kobo.1167.2">After that, we will run our complete electronic trading ecosystem – the electronic trading exchange (the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1168.1">exchange_main</span></strong><span class="koboSpan" id="kobo.1169.1"> application) from the </span><em class="italic"><span class="koboSpan" id="kobo.1170.1">Communicating with Market Participants</span></em><span class="koboSpan" id="kobo.1171.1"> chapter and a few instances of the market participants (the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1172.1">trading_main</span></strong><span class="koboSpan" id="kobo.1173.1"> application), which we will </span><span class="No-Break"><span class="koboSpan" id="kobo.1174.1">build next.</span></span></p>
<h2 id="_idParaDest-275"><a id="_idTextAnchor288"/><span class="koboSpan" id="kobo.1175.1">Building the main trading application</span></h2>
<p><span class="koboSpan" id="kobo.1176.1">Now, let us build </span><a id="_idIndexMarker1416"/><span class="koboSpan" id="kobo.1177.1">the executable </span><strong class="source-inline"><span class="koboSpan" id="kobo.1178.1">trading_main</span></strong><span class="koboSpan" id="kobo.1179.1"> binary that will initialize and run all the components on the market participant’s trading system. </span><span class="koboSpan" id="kobo.1179.2">The source code for this application is in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1180.1">Chapter10/trading/trading_main.cpp</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1181.1">source file.</span></span></p>
<p><span class="koboSpan" id="kobo.1182.1">First, we will include the necessary header files and create some basic variables to represent the different components we need. </span><span class="koboSpan" id="kobo.1182.2">Specifically, we will have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1183.1">Logger</span></strong><span class="koboSpan" id="kobo.1184.1"> object pointer to be used for logging purposes, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1185.1">TradeEngine</span></strong><span class="koboSpan" id="kobo.1186.1"> object pointer for the basic trading engine framework, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1187.1">MarketDataConsumer</span></strong><span class="koboSpan" id="kobo.1188.1"> object pointer to consumer market data, and an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1189.1">OrderGateway</span></strong><span class="koboSpan" id="kobo.1190.1"> object pointer to connect to and communicate with the exchange’s </span><span class="No-Break"><span class="koboSpan" id="kobo.1191.1">order server:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1192.1">
#include &lt;csignal&gt;
#include "strategy/trade_engine.h"
#include "order_gw/order_gateway.h"
#include "market_data/market_data_consumer.h"
#include "common/logging.h"
Common::Logger *logger = nullptr;
Trading::TradeEngine *trade_engine = nullptr;
Trading::MarketDataConsumer *market_data_consumer = nullptr;
Trading::OrderGateway *order_gateway = nullptr;</span></pre>
<p><span class="koboSpan" id="kobo.1193.1">Now, we start the entry point – the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1194.1">main()</span></strong><span class="koboSpan" id="kobo.1195.1"> method. </span><span class="koboSpan" id="kobo.1195.2">On the command line, we will accept arguments of the following form – </span><strong class="source-inline"><span class="koboSpan" id="kobo.1196.1">trading_main CLIENT_ID ALGO_TYPE [CLIP_1 THRESH_1 MAX_ORDER_SIZE_1 MAX_POS_1 MAX_LOSS_1] [CLIP_2 THRESH_2 MAX_ORDER_SIZE_2 MAX_POS_2 </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1197.1">MAX_LOSS_2] …</span></strong></span></p>
<p><span class="koboSpan" id="kobo.1198.1">The first argument represents </span><strong class="source-inline"><span class="koboSpan" id="kobo.1199.1">ClientId</span></strong><span class="koboSpan" id="kobo.1200.1"> for this trading application instance. </span><span class="koboSpan" id="kobo.1200.2">We will also accept </span><strong class="source-inline"><span class="koboSpan" id="kobo.1201.1">AlgoType</span></strong><span class="koboSpan" id="kobo.1202.1"> as the second parameter, and configurations for each trading algorithm instance for each </span><strong class="source-inline"><span class="koboSpan" id="kobo.1203.1">TickerId</span></strong><span class="koboSpan" id="kobo.1204.1"> as the remaining parameters. </span><span class="koboSpan" id="kobo.1204.2">We will source the random number generator by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1205.1">srand()</span></strong><span class="koboSpan" id="kobo.1206.1"> method and passing it </span><strong class="source-inline"><span class="koboSpan" id="kobo.1207.1">client_id</span></strong><span class="koboSpan" id="kobo.1208.1"> for this </span><span class="No-Break"><span class="koboSpan" id="kobo.1209.1">specific instance:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1210.1">
int main(int argc, char **argv) {
  const Common::ClientId client_id = atoi(argv[1]);
  srand(client_id);</span></pre>
<p><span class="koboSpan" id="kobo.1211.1">We will extract </span><strong class="source-inline"><span class="koboSpan" id="kobo.1212.1">AlgoType</span></strong><span class="koboSpan" id="kobo.1213.1">, as </span><span class="No-Break"><span class="koboSpan" id="kobo.1214.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1215.1">
  const auto algo_type = stringToAlgoType(argv[2]);</span></pre>
<p><span class="koboSpan" id="kobo.1216.1">We will also </span><a id="_idIndexMarker1417"/><span class="koboSpan" id="kobo.1217.1">initialize an object of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.1218.1">TradeEngineCfgHashMap</span></strong><span class="koboSpan" id="kobo.1219.1"> from the remaining command-line arguments, as shown in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.1220.1">code block:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1221.1">
  TradeEngineCfgHashMap ticker_cfg;
  size_t next_ticker_id = 0;
  for (int i = 3; i &lt; argc; i += 5, ++next_ticker_id) {
    ticker_cfg.at(next_ticker_id) =
      {static_cast&lt;Qty&gt;(std::atoi(argv[i])),
        std::atof(argv[i + 1]),
                                     {static_cast&lt;Qty&gt;(std:
                                     :atoi(argv[i + 2])),
                                      static_cast&lt;Qty&gt;(std:
                                     :atoi(argv[i + 3])),
                                      std::atof(argv[i +
                                       4])}};
  }</span></pre>
<p><span class="koboSpan" id="kobo.1222.1">We will initialize the component variables we declared before – </span><strong class="source-inline"><span class="koboSpan" id="kobo.1223.1">Logger</span></strong><span class="koboSpan" id="kobo.1224.1">, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1225.1">client_requests</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.1226.1">LFQueue</span></strong><span class="koboSpan" id="kobo.1227.1">, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1228.1">client_responses</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.1229.1">LFQueue</span></strong><span class="koboSpan" id="kobo.1230.1">, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1231.1">market_updates</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.1232.1">LFQueue</span></strong><span class="koboSpan" id="kobo.1233.1">. </span><span class="koboSpan" id="kobo.1233.2">We will also define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1234.1">sleep_time</span></strong><span class="koboSpan" id="kobo.1235.1"> variable and set it to 20 microseconds. </span><span class="koboSpan" id="kobo.1235.2">We </span><a id="_idIndexMarker1418"/><span class="koboSpan" id="kobo.1236.1">will use this value to pause between consecutive order requests we send to the trading exchange’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.1237.1">OrderGatewayServer</span></strong><span class="koboSpan" id="kobo.1238.1"> component, only in the random </span><span class="No-Break"><span class="koboSpan" id="kobo.1239.1">trading strategy:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1240.1">
  logger = new Common::Logger("trading_main_" +
    std::to_string(client_id) + ".log");
  const int sleep_time = 20 * 1000;
  Exchange::ClientRequestLFQueue
    client_requests(ME_MAX_CLIENT_UPDATES);
  Exchange::ClientResponseLFQueue
    client_responses(ME_MAX_CLIENT_UPDATES);
  Exchange::MEMarketUpdateLFQueue
    market_updates(ME_MAX_MARKET_UPDATES);
  std::string time_str;</span></pre>
<p><span class="koboSpan" id="kobo.1241.1">The first component we will initialize and start will be </span><strong class="source-inline"><span class="koboSpan" id="kobo.1242.1">TradeEngine</span></strong><span class="koboSpan" id="kobo.1243.1">. </span><span class="koboSpan" id="kobo.1243.2">We will pass </span><strong class="source-inline"><span class="koboSpan" id="kobo.1244.1">client_id</span></strong><span class="koboSpan" id="kobo.1245.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1246.1">algo_type</span></strong><span class="koboSpan" id="kobo.1247.1">, the strategy configurations in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1248.1">ticker_cfg</span></strong><span class="koboSpan" id="kobo.1249.1"> object, and the lock-free queues that </span><strong class="source-inline"><span class="koboSpan" id="kobo.1250.1">TradeEngine</span></strong><span class="koboSpan" id="kobo.1251.1"> needs in the constructor. </span><span class="koboSpan" id="kobo.1251.2">We then call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1252.1">start()</span></strong><span class="koboSpan" id="kobo.1253.1"> method to get the main thread to start executing, as shown in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.1254.1">code block:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1255.1">
  logger-&gt;log("%:% %() % Starting Trade Engine...\n",
    __FILE__, __LINE__, __FUNCTION__,
     Common::getCurrentTimeStr(&amp;time_str));
  trade_engine = new Trading::TradeEngine(client_id,
    algo_type,ticker_cfg,&amp;client_requests,
        &amp;client_responses,&amp;market_updates);
  trade_engine-&gt;start();</span></pre>
<p><span class="koboSpan" id="kobo.1256.1">We perform a similar initialization of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1257.1">OrderGateway</span></strong><span class="koboSpan" id="kobo.1258.1"> component next by passing it the IP and port </span><a id="_idIndexMarker1419"/><span class="koboSpan" id="kobo.1259.1">information of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1260.1">exchange_main</span></strong><span class="koboSpan" id="kobo.1261.1">’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.1262.1">OrderGateway</span></strong><span class="koboSpan" id="kobo.1263.1"> server component. </span><span class="koboSpan" id="kobo.1263.2">We also pass it the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1264.1">client_requests</span></strong><span class="koboSpan" id="kobo.1265.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1266.1">client_responses</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.1267.1">LFQueue</span></strong><span class="koboSpan" id="kobo.1268.1"> variables to consume </span><strong class="source-inline"><span class="koboSpan" id="kobo.1269.1">MEClientRequest</span></strong><span class="koboSpan" id="kobo.1270.1"> messages from and write </span><strong class="source-inline"><span class="koboSpan" id="kobo.1271.1">MEClientResponse</span></strong><span class="koboSpan" id="kobo.1272.1"> messages to, and then we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1273.1">start()</span></strong><span class="koboSpan" id="kobo.1274.1"> on the </span><span class="No-Break"><span class="koboSpan" id="kobo.1275.1">main thread:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1276.1">
  const std::string order_gw_ip = "127.0.0.1";
  const std::string order_gw_iface = "lo";
  const int order_gw_port = 12345;
  logger-&gt;log("%:% %() % Starting Order Gateway...\n",
    __FILE__, __LINE__, __FUNCTION__,
      Common::getCurrentTimeStr(&amp;time_str));
  order_gateway = new Trading::OrderGateway(client_id,
    &amp;client_requests, &amp;client_responses, order_gw_ip,
      order_gw_iface, order_gw_port);
  order_gateway-&gt;start();</span></pre>
<p><span class="koboSpan" id="kobo.1277.1">Finally, we initialize and start the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1278.1">MarketDataConsumer</span></strong><span class="koboSpan" id="kobo.1279.1"> component. </span><span class="koboSpan" id="kobo.1279.2">It needs the IP and port information of the snapshot stream and the incremental stream on which the exchange’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.1280.1">MarketDataPublisher</span></strong><span class="koboSpan" id="kobo.1281.1"> publishes market data. </span><span class="koboSpan" id="kobo.1281.2">It also needs the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1282.1">market_updates</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.1283.1">LFQueue</span></strong><span class="koboSpan" id="kobo.1284.1"> variable, which it will write decoded market data updates to. </span><span class="koboSpan" id="kobo.1284.2">Finally, since all the components are ready, we will start </span><strong class="source-inline"><span class="koboSpan" id="kobo.1285.1">market_data_consumer</span></strong><span class="koboSpan" id="kobo.1286.1"> so that we can process any market data </span><span class="No-Break"><span class="koboSpan" id="kobo.1287.1">updates available:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1288.1">
  const std::string mkt_data_iface = "lo";
  const std::string snapshot_ip = "233.252.14.1";
  const int snapshot_port = 20000;
  const std::string incremental_ip = "233.252.14.3";
  const int incremental_port = 20001;
  logger-&gt;log("%:% %() % Starting Market Data
    Consumer...\n", __FILE__, __LINE__, __FUNCTION__,
      Common::getCurrentTimeStr(&amp;time_str));
  market_data_consumer = new
    Trading::MarketDataConsumer(client_id, &amp;market_updates,
      mkt_data_iface, snapshot_ip, snapshot_port,
        incremental_ip, incremental_port);
  market_data_consumer-&gt;start();</span></pre>
<p><span class="koboSpan" id="kobo.1289.1">Now, we are almost ready to start sending orders to the exchange; we just need to perform a few </span><a id="_idIndexMarker1420"/><span class="koboSpan" id="kobo.1290.1">more minor tasks first. </span><span class="koboSpan" id="kobo.1290.2">First, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1291.1">main()</span></strong><span class="koboSpan" id="kobo.1292.1"> application will sleep briefly so that the threads we just created and started in each of our components can run for a </span><span class="No-Break"><span class="koboSpan" id="kobo.1293.1">few seconds:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1294.1">
  usleep(10 * 1000 * 1000);</span></pre>
<p><span class="koboSpan" id="kobo.1295.1">We will also initialize the first event time in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1296.1">TradeEngine</span></strong><span class="koboSpan" id="kobo.1297.1"> by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1298.1">TradeEngine::initLastEventTime()</span></strong><span class="koboSpan" id="kobo.1299.1"> method. </span><span class="koboSpan" id="kobo.1299.2">We intentionally delayed this member’s initialization until we were ready to </span><span class="No-Break"><span class="koboSpan" id="kobo.1300.1">start trading:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1301.1">
  trade_engine-&gt;initLastEventTime();</span></pre>
<p><span class="koboSpan" id="kobo.1302.1">If </span><strong class="source-inline"><span class="koboSpan" id="kobo.1303.1">AlgoType</span></strong><span class="koboSpan" id="kobo.1304.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.1305.1">AlgoType::RANDOM</span></strong><span class="koboSpan" id="kobo.1306.1">, we will implement the trading logic right here, since it is super simple. </span><span class="koboSpan" id="kobo.1306.2">First, we will check the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1307.1">algo_type</span></strong><span class="koboSpan" id="kobo.1308.1"> variable, and branch if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1309.1">algo_type</span></strong><span class="koboSpan" id="kobo.1310.1"> argument specifies the random </span><span class="No-Break"><span class="koboSpan" id="kobo.1311.1">trading strategy:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1312.1">
  if (algo_type == AlgoType::RANDOM) {</span></pre>
<p><span class="koboSpan" id="kobo.1313.1">For this random trading algorithm, we will create a starting </span><strong class="source-inline"><span class="koboSpan" id="kobo.1314.1">OrderId</span></strong><span class="koboSpan" id="kobo.1315.1"> value unique to this trading application’s instance, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1316.1">client_id</span></strong><span class="koboSpan" id="kobo.1317.1"> we received from the </span><span class="No-Break"><span class="koboSpan" id="kobo.1318.1">command-line argument:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1319.1">
  Common::OrderId order_id = client_id * 1000;</span></pre>
<p><span class="koboSpan" id="kobo.1320.1">Since we send orders with a random price, quantity, and side in our current test setup, we will initialize a random reference price for each instrument, for which we will send orders. </span><span class="koboSpan" id="kobo.1320.2">We will send orders with prices that are randomly distributed around this reference price value shortly. </span><span class="koboSpan" id="kobo.1320.3">We do this purely so that different trading instruments have orders of slightly different and random prices. </span><span class="koboSpan" id="kobo.1320.4">The random reference price for each instrument is held in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1321.1">ticker_base_price</span></strong><span class="koboSpan" id="kobo.1322.1"> variable. </span><span class="koboSpan" id="kobo.1322.2">We will also create </span><strong class="source-inline"><span class="koboSpan" id="kobo.1323.1">std::vector</span></strong><span class="koboSpan" id="kobo.1324.1"> of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1325.1">MEClientRequest</span></strong><span class="koboSpan" id="kobo.1326.1"> messages to store the order requests we send to the exchange. </span><span class="koboSpan" id="kobo.1326.2">We </span><a id="_idIndexMarker1421"/><span class="koboSpan" id="kobo.1327.1">will also send cancellations for some of these orders to exercise that functionality; hence, we will save them for when we try to </span><span class="No-Break"><span class="koboSpan" id="kobo.1328.1">cancel them:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1329.1">
  std::vector&lt;Exchange::MEClientRequest&gt;
    client_requests_vec;
  std::array&lt;Price, ME_MAX_TICKERS&gt; ticker_base_price;
  for(size_t i = 0; i &lt; ME_MAX_TICKERS; ++i)
    ticker_base_price[i] = (rand() % 100) + 100;</span></pre>
<p><span class="koboSpan" id="kobo.1330.1">Now, we can start sending some orders to the exchange, but first, we will initialize </span><strong class="source-inline"><span class="koboSpan" id="kobo.1331.1">TradeEngine</span></strong><span class="koboSpan" id="kobo.1332.1">’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.1333.1">last_event_time_</span></strong><span class="koboSpan" id="kobo.1334.1"> variable before we </span><span class="No-Break"><span class="koboSpan" id="kobo.1335.1">get started:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1336.1">
  trade_engine-&gt;initLastEventTime();</span></pre>
<p><span class="koboSpan" id="kobo.1337.1">In the following loop, which executes 10,000 times, we will perform a few tasks, described </span><span class="No-Break"><span class="koboSpan" id="kobo.1338.1">as follows.</span></span></p>
<p><span class="koboSpan" id="kobo.1339.1">We will pick a random </span><strong class="source-inline"><span class="koboSpan" id="kobo.1340.1">TickerId</span></strong><span class="koboSpan" id="kobo.1341.1">, generate a random </span><strong class="source-inline"><span class="koboSpan" id="kobo.1342.1">Price</span></strong><span class="koboSpan" id="kobo.1343.1"> close to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1344.1">ticker_base_price</span></strong><span class="koboSpan" id="kobo.1345.1"> reference price value for that instrument, generate a random </span><strong class="source-inline"><span class="koboSpan" id="kobo.1346.1">Qty</span></strong><span class="koboSpan" id="kobo.1347.1">, and generate a random </span><strong class="source-inline"><span class="koboSpan" id="kobo.1348.1">Side</span></strong><span class="koboSpan" id="kobo.1349.1"> for the order we </span><span class="No-Break"><span class="koboSpan" id="kobo.1350.1">will send:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1351.1">
  for (size_t i = 0; i &lt; 10000; ++i) {
      const Common::TickerId ticker_id = rand() %
        Common::ME_MAX_TICKERS;
      const Price price = ticker_base_price[ticker_id] +
        (rand() % 10) + 1;
      const Qty qty = 1 + (rand() % 100) + 1;
      const Side side = (rand() % 2 ? </span><span class="koboSpan" id="kobo.1351.2">Common::Side::BUY :
        Common::Side::SELL);</span></pre>
<p><span class="koboSpan" id="kobo.1352.1">We will create an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1353.1">MEClientRequest</span></strong><span class="koboSpan" id="kobo.1354.1"> message of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.1355.1">ClientRequestType::NEW</span></strong><span class="koboSpan" id="kobo.1356.1"> with these attributes and pass it along to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1357.1">TradeEngine</span></strong><span class="koboSpan" id="kobo.1358.1"> using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1359.1">sendClientRequest()</span></strong><span class="koboSpan" id="kobo.1360.1"> method call. </span><span class="koboSpan" id="kobo.1360.2">We will pause for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1361.1">sleep_time</span></strong><span class="koboSpan" id="kobo.1362.1"> (20 microseconds) after we send the order request, and we will also save the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1363.1">MEClientRequest</span></strong><span class="koboSpan" id="kobo.1364.1"> message we just sent out in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1365.1">client_requests_vec</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1366.1"> container:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1367.1">
    Exchange::MEClientRequest
      new_request{Exchange::ClientRequestType::NEW,
        client_id, ticker_id, order_id++, side, price,
          qty};
    trade_engine-&gt;sendClientRequest(&amp;new_request);
    usleep(sleep_time);
    client_requests_vec.push_back(new_request);</span></pre>
<p><span class="koboSpan" id="kobo.1368.1">After the pause, we </span><a id="_idIndexMarker1422"/><span class="koboSpan" id="kobo.1369.1">randomly pick a client request we sent from our container of client requests. </span><span class="koboSpan" id="kobo.1369.2">We change the request type to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1370.1">ClientRequestType::CANCEL</span></strong><span class="koboSpan" id="kobo.1371.1"> and send it through to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1372.1">TradeEngine</span></strong><span class="koboSpan" id="kobo.1373.1">. </span><span class="koboSpan" id="kobo.1373.2">Then, we pause again and continue with the </span><span class="No-Break"><span class="koboSpan" id="kobo.1374.1">loop iteration:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1375.1">
    const auto cxl_index = rand() %
      client_requests_vec.size();
    auto cxl_request = client_requests_vec[cxl_index];
    cxl_request.type_ =
      Exchange::ClientRequestType::CANCEL;
    trade_engine-&gt;sendClientRequest(&amp;cxl_request);
    usleep(sleep_time);
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.1376.1">After we have sent out all of the order flow, we wait until we encounter a 60-second period where no market update and no order response have been received by </span><strong class="source-inline"><span class="koboSpan" id="kobo.1377.1">TradeEngine</span></strong><span class="koboSpan" id="kobo.1378.1">. </span><span class="koboSpan" id="kobo.1378.2">This is a simple method of detecting when there is no market activity due to this client or any other trading client being connected to </span><span class="No-Break"><span class="koboSpan" id="kobo.1379.1">the exchange:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1380.1">
  while (trade_engine-&gt;silentSeconds() &lt; 60) {
    logger-&gt;log("%:% %() % Waiting till no activity, been
      silent for % seconds...\n", __FILE__, __LINE__,
        __FUNCTION__,
                Common::getCurrentTimeStr(&amp;time_str),
                  trade_engine-&gt;silentSeconds());
    using namespace std::literals::chrono_literals;
    std::this_thread::sleep_for(10s);
  }</span></pre>
<p><span class="koboSpan" id="kobo.1381.1">After a period </span><a id="_idIndexMarker1423"/><span class="koboSpan" id="kobo.1382.1">of inactivity, this application exits. </span><span class="koboSpan" id="kobo.1382.2">We first stop each of our components and pause for a brief period, before de-initializing and exiting </span><span class="No-Break"><span class="koboSpan" id="kobo.1383.1">the application:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1384.1">
  trade_engine-&gt;stop();
  market_data_consumer-&gt;stop();
  order_gateway-&gt;stop();
  using namespace std::literals::chrono_literals;
  std::this_thread::sleep_for(10s);
  delete logger;
  logger = nullptr;
  delete trade_engine;
  trade_engine = nullptr;
  delete market_data_consumer;
  market_data_consumer = nullptr;
  delete order_gateway;
  order_gateway = nullptr;
  std::this_thread::sleep_for(10s);
  exit(EXIT_SUCCESS);
}</span></pre>
<p><span class="koboSpan" id="kobo.1385.1">This concludes the implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1386.1">trading_main</span></strong><span class="koboSpan" id="kobo.1387.1"> application. </span><span class="koboSpan" id="kobo.1387.2">We have included a build script in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1388.1">Chapter10/scripts/build.sh</span></strong><span class="koboSpan" id="kobo.1389.1">, which uses CMake and Ninja to build the libraries and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1390.1">trading_main</span></strong><span class="koboSpan" id="kobo.1391.1"> application, in addition to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1392.1">exchange_main</span></strong><span class="koboSpan" id="kobo.1393.1"> application that we built before. </span><span class="koboSpan" id="kobo.1393.2">You will have to edit this script to point to the correct binaries on your system or switch to a different build system if you wish. </span><span class="koboSpan" id="kobo.1393.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1394.1">scripts/build.sh</span></strong><span class="koboSpan" id="kobo.1395.1"> script is expected to be run from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1396.1">Chapter10</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.1397.1">root</span></strong><span class="koboSpan" id="kobo.1398.1"> directory, </span><a id="_idIndexMarker1424"/><span class="koboSpan" id="kobo.1399.1">and it simply configures the build files, which in this case use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1400.1">Ninja</span></strong><span class="koboSpan" id="kobo.1401.1">, and cleans and rebuilds the build for the release and debug versions. </span><span class="koboSpan" id="kobo.1401.2">We want to clarify that the choice of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1402.1">Ninja</span></strong><span class="koboSpan" id="kobo.1403.1"> is completely arbitrary; we do not depend on anything that is </span><strong class="source-inline"><span class="koboSpan" id="kobo.1404.1">Ninja</span></strong><span class="koboSpan" id="kobo.1405.1">-specific for our system to build and run. </span><span class="koboSpan" id="kobo.1405.2">The build process generates binaries in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1406.1">Chapter10/cmake-build-release</span></strong><span class="koboSpan" id="kobo.1407.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1408.1">Chapter10/cmake-build-debug</span></strong><span class="koboSpan" id="kobo.1409.1"> directories. </span><span class="koboSpan" id="kobo.1409.2">The scripts to run the trading binaries use the binaries from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1410.1">Chapter10/cmake-build-release</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1411.1"> directory.</span></span></p>
<h2 id="_idParaDest-276"><a id="_idTextAnchor289"/><span class="koboSpan" id="kobo.1412.1">Running the final trading ecosystem</span></h2>
<p><span class="koboSpan" id="kobo.1413.1">We are finally at the point where we can run our entire electronic trading ecosystem, admittedly with </span><a id="_idIndexMarker1425"/><span class="koboSpan" id="kobo.1414.1">a random trading strategy for now. </span><span class="koboSpan" id="kobo.1414.2">We will present two scripts – one is </span><strong class="source-inline"><span class="koboSpan" id="kobo.1415.1">Chapter10/scripts/run_clients.sh</span></strong><span class="koboSpan" id="kobo.1416.1">, which is configured to launch five instances of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1417.1">trading_main</span></strong><span class="koboSpan" id="kobo.1418.1"> application with client IDs of 1 to 5. </span><span class="koboSpan" id="kobo.1418.2">The second script is </span><strong class="source-inline"><span class="koboSpan" id="kobo.1419.1">Chapter10/scripts/run_exchange_and_clients.sh</span></strong><span class="koboSpan" id="kobo.1420.1">, which first builds the libraries and the binaries using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1421.1">build.sh</span></strong><span class="koboSpan" id="kobo.1422.1"> script. </span><span class="koboSpan" id="kobo.1422.2">Then, it launches the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1423.1">exchange_main</span></strong><span class="koboSpan" id="kobo.1424.1"> application and proceeds to launch the trading client instances using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1425.1">run_clients.sh</span></strong><span class="koboSpan" id="kobo.1426.1"> script. </span><span class="koboSpan" id="kobo.1426.2">Finally, it waits for all the trading client instances to finish execution, then terminates the exchange instance, </span><span class="No-Break"><span class="koboSpan" id="kobo.1427.1">and exits.</span></span></p>
<p><span class="koboSpan" id="kobo.1428.1">We will not look at the full </span><strong class="source-inline"><span class="koboSpan" id="kobo.1429.1">run_clients.sh</span></strong><span class="koboSpan" id="kobo.1430.1"> script, but an example of the first trading client that creates a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1431.1">MarketMaker</span></strong><span class="koboSpan" id="kobo.1432.1"> algorithm is </span><span class="No-Break"><span class="koboSpan" id="kobo.1433.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1434.1">
./cmake-build-release/trading_main  1 MAKER 100 0.6 150 300 -100 60 0.6 150 300 -100 150 0.5 250 600 -100 200 0.4 500 3000 -100 1000 0.9 5000 4000 -100 300 0.8 1500 3000 -100 50 0.7 150 300 -100 100 0.3 250 300 -100 &amp;</span></pre>
<p><span class="koboSpan" id="kobo.1435.1">In this script, the 1 and 2 client IDs are MM trading algorithms, the 3 and 4 client IDs are liquidity taking trading algorithms, and the last client ID, 5, is a random trading algorithm. </span><span class="koboSpan" id="kobo.1435.2">The random trading algorithm instance exists to simulate all trades made by the rest of the market participants for any reason. </span><span class="koboSpan" id="kobo.1435.3">We do this because, in our ecosystem, we only run five trading clients (due to limited resources on our workstation). </span><span class="koboSpan" id="kobo.1435.4">However, we encourage those interested among you with access to a lot more CPU resources </span><a id="_idIndexMarker1426"/><span class="koboSpan" id="kobo.1436.1">to run as many trading clients as the system can handle. </span><span class="koboSpan" id="kobo.1436.2">Remember that, in practice, the market is composed of orders and trades from thousands of market participants (if </span><span class="No-Break"><span class="koboSpan" id="kobo.1437.1">not more).</span></span></p>
<p><span class="koboSpan" id="kobo.1438.1">First, we have the output of the build process, which is generated by running the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1439.1">scripts/run_exchange_and_clients.sh</span></strong><span class="koboSpan" id="kobo.1440.1"> script that internally calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1441.1">scripts/build.sh</span></strong><span class="koboSpan" id="kobo.1442.1"> script to first build everything. </span><span class="koboSpan" id="kobo.1442.2">Note that you need to be in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1443.1">Chapter10</span></strong><span class="koboSpan" id="kobo.1444.1"> root directory, as shown here, for this script to </span><span class="No-Break"><span class="koboSpan" id="kobo.1445.1">work correctly:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1446.1">
sghosh@sghosh-ThinkPad-X1-Carbon-3rd:~/Building-Low-Latency-Applications-with-CPP/Chapter10$ bash scripts/run_exchange_and_clients.sh
...
</span><span class="koboSpan" id="kobo.1446.2">-- Build files have been written to: /home/sghosh/Building-Low-Latency-Applications-with-CPP/Chapter10/cmake-build-release
...
</span><span class="koboSpan" id="kobo.1446.3">[36/37] Linking CXX executable trading_main
[37/37] Linking CXX executable exchange_main</span></pre>
<p><span class="koboSpan" id="kobo.1447.1">Then, we have the output of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1448.1">exchange_main</span></strong><span class="koboSpan" id="kobo.1449.1"> application </span><span class="No-Break"><span class="koboSpan" id="kobo.1450.1">starting up:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1451.1">
-----------------------------------------
Starting Exchange...
</span><span class="koboSpan" id="kobo.1451.2">-----------------------------------------
Set core affinity for Common/Logger exchange_main.log 140716464399936 to -1
Set core affinity for Common/Logger exchange_matching_engine.log 140716293985856 to -1
...</span></pre>
<p><span class="koboSpan" id="kobo.1452.1">Then, the output of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1453.1">trading_main</span></strong><span class="koboSpan" id="kobo.1454.1"> instances launching </span><span class="No-Break"><span class="koboSpan" id="kobo.1455.1">is produced:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1456.1">
-----------------------------------------
Starting TradingClient 1...
</span><span class="koboSpan" id="kobo.1456.2">-----------------------------------------
Set core affinity for Common/Logger trading_main_1.log 139636947019328 to -1
...
</span><span class="koboSpan" id="kobo.1456.3">-----------------------------------------
Starting TradingClient 5...
</span><span class="koboSpan" id="kobo.1456.4">-----------------------------------------
Set core affinity for Common/Logger trading_main_5.log 139837285852736 to -1
...</span></pre>
<p><span class="koboSpan" id="kobo.1457.1">Finally, we have the </span><a id="_idIndexMarker1427"/><span class="koboSpan" id="kobo.1458.1">output from the trading clients that shut down, and then the </span><span class="No-Break"><span class="koboSpan" id="kobo.1459.1">exchange exits:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1460.1">
Set core affinity for Trading/MarketDataConsumer 139836325348928 to –1
...
</span><span class="koboSpan" id="kobo.1460.2">Thu Apr  6 12:37:04 2023 Flushing and closing Logger for trading_main_1.log
...
</span><span class="koboSpan" id="kobo.1460.3">Thu Apr  6 12:37:21 2023 Logger for trading_order_gateway_5.log exiting.
</span><span class="koboSpan" id="kobo.1460.4">-----------------------------------------
Stopping Exchange...
</span><span class="koboSpan" id="kobo.1460.5">-----------------------------------------
...
</span><span class="koboSpan" id="kobo.1460.6">Thu Apr  6 12:38:09 2023 Logger for exchange_order_server.log exiting.</span></pre>
<p><span class="koboSpan" id="kobo.1461.1">Note that this is just the output displayed on screen. </span><span class="koboSpan" id="kobo.1461.2">The interesting details are in the log files, which we will inspect and discuss in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1462.1">next subsection.</span></span></p>
<p><span class="koboSpan" id="kobo.1463.1">One other important note is that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1464.1">exchange_main</span></strong><span class="koboSpan" id="kobo.1465.1"> application has 10 threads, and each </span><strong class="source-inline"><span class="koboSpan" id="kobo.1466.1">trading_main</span></strong><span class="koboSpan" id="kobo.1467.1"> application has 8 threads. </span><span class="koboSpan" id="kobo.1467.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1468.1">Logger</span></strong><span class="koboSpan" id="kobo.1469.1"> threads, which are many of these threads (five for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1470.1">exchange_main</span></strong><span class="koboSpan" id="kobo.1471.1"> and four for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1472.1">trading_main</span></strong><span class="koboSpan" id="kobo.1473.1">), as well as the thread for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1474.1">main()</span></strong><span class="koboSpan" id="kobo.1475.1"> method (one each for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1476.1">exchange_main</span></strong><span class="koboSpan" id="kobo.1477.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1478.1">trading_main</span></strong><span class="koboSpan" id="kobo.1479.1">), are not CPU-intensive and sleep for most of their runtime. </span><span class="koboSpan" id="kobo.1479.2">The optimal setup would </span><a id="_idIndexMarker1428"/><span class="koboSpan" id="kobo.1480.1">need a lot of cores for the entire ecosystem, which is common for production trading servers used for electronic trading. </span><span class="koboSpan" id="kobo.1480.2">On these production-grade trading servers, we would be able to assign a CPU core to each of the remaining critical threads (four for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1481.1">exchange_main</span></strong><span class="koboSpan" id="kobo.1482.1"> and three for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1483.1">trading_main</span></strong><span class="koboSpan" id="kobo.1484.1">). </span><span class="koboSpan" id="kobo.1484.2">Since we are not sure which server we run on, we intentionally avoid setting affinity on those threads. </span><span class="koboSpan" id="kobo.1484.3">If CPU and/or memory resources are limited on your system, our advice would be to reduce the number of trading clients launched in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1485.1">run_clients.sh</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1486.1"> script.</span></span></p>
<h2 id="_idParaDest-277"><a id="_idTextAnchor290"/><span class="koboSpan" id="kobo.1487.1">Inspecting the output of a run</span></h2>
<p><span class="koboSpan" id="kobo.1488.1">In this concluding section, we will look at the log files generated by running the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1489.1">run_exchange_and_clients.sh</span></strong><span class="koboSpan" id="kobo.1490.1"> script. </span><span class="koboSpan" id="kobo.1490.2">We know that the trading strategy we ran in this </span><a id="_idIndexMarker1429"/><span class="koboSpan" id="kobo.1491.1">chapter is not interesting since it sends random orders to the exchange, but there are some important observations in these log files. </span><span class="koboSpan" id="kobo.1491.2">Running the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1492.1">run_exchange_and_clients.sh</span></strong><span class="koboSpan" id="kobo.1493.1"> script should generate log files similar to </span><span class="No-Break"><span class="koboSpan" id="kobo.1494.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1495.1">
exchange_main.log  exchange_market_data_publisher.log  exchange_matching_engine.log  exchange_order_server.log  exchange_snapshot_synthesizer.log
trading_engine_1.log  trading_main_1.log  trading_market_data_consumer_1.log  trading_order_gateway_1.log
… trading_order_gateway_5.log</span></pre>
<p><span class="koboSpan" id="kobo.1496.1">To understand and follow the events, our advice would be to correlate the log lines we generate from our calls to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1497.1">Logger::log()</span></strong><span class="koboSpan" id="kobo.1498.1"> from various components and sub-components and then find them in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1499.1">log files.</span></span></p>
<p><span class="koboSpan" id="kobo.1500.1">As an example, let us follow the path of a client sending an order to the exchange receiving the request, and generating a client response and a market update for that order request. </span><span class="koboSpan" id="kobo.1500.2">Let us say, for this example, that we want to find the path followed by </span><strong class="bold"><span class="koboSpan" id="kobo.1501.1">OrderId=1445</span></strong><span class="koboSpan" id="kobo.1502.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.1503.1">MarketOrderId=53</span></strong><span class="koboSpan" id="kobo.1504.1">; the path which this order follows is laid out as follows from </span><a id="_idIndexMarker1430"/><span class="koboSpan" id="kobo.1505.1">the log files. </span><span class="koboSpan" id="kobo.1505.2">Note that this is just an example that was generated from this specific run and might not be reproducible; the goal here is to understand how to track the events in </span><span class="No-Break"><span class="koboSpan" id="kobo.1506.1">our ecosystem:</span></span></p>
<ol>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1507.1">MEClientRequest</span></strong><span class="koboSpan" id="kobo.1508.1"> for the new order gets sent by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1509.1">TradeEngine</span></strong><span class="koboSpan" id="kobo.1510.1"> component for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1511.1">trading_main</span></strong><span class="koboSpan" id="kobo.1512.1"> instance </span><span class="No-Break"><span class="koboSpan" id="kobo.1513.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1514.1">ClientId=1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1515.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1516.1">
trading_engine_5.log:trade_engine.cpp:33 sendClientRequest() Thu Apr  6 12:26:47 2023 Sending MEClientRequest [type:NEW client:1 ticker:0 oid:1445 side:BUY qty:10 price:184]</span></pre></li>
<li><span class="koboSpan" id="kobo.1517.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1518.1">OrderGateway</span></strong><span class="koboSpan" id="kobo.1519.1"> component picks up that request from the lock-free queue and sends it out on the TCP connection to the exchange, as </span><span class="No-Break"><span class="koboSpan" id="kobo.1520.1">shown here:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1521.1">
trading_order_gateway_5.log:order_gateway.cpp:19 run() Thu Apr  6 12:26:47 2023 Sending cid:1 seq:891 MEClientRequest [type:NEW client:1 ticker:0 oid:1445 side:BUY qty:10 price:184]</span></pre></li>
<li><span class="koboSpan" id="kobo.1522.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1523.1">OrderServer</span></strong><span class="koboSpan" id="kobo.1524.1"> component inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1525.1">exchange_main</span></strong><span class="koboSpan" id="kobo.1526.1"> application receives it from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1527.1">TCPServer</span></strong><span class="koboSpan" id="kobo.1528.1"> socket, as </span><span class="No-Break"><span class="koboSpan" id="kobo.1529.1">shown here:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1530.1">
exchange_order_server.log:order_server.h:55 recvCallback() Thu Apr  6 12:26:47 2023 Received OMClientRequest [seq:891 MEClientRequest [type:NEW client:1 ticker:0 oid:1445 side:BUY qty:10 price:184]]</span></pre></li>
<li><span class="koboSpan" id="kobo.1531.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1532.1">FifoSequencer</span></strong><span class="koboSpan" id="kobo.1533.1"> sub-component inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.1534.1">OrderServer</span></strong><span class="koboSpan" id="kobo.1535.1"> sequences the client order request (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1536.1">MEClientRequest</span></strong><span class="koboSpan" id="kobo.1537.1">) based on the software receive time, and publishes it to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1538.1">MatchingEngine</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1539.1">lock-free queue:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1540.1">
exchange_order_server.log:fifo_sequencer.h:38 sequenceAndPublish() Thu Apr  6 12:26:47 2023 Writing RX:1680802007777361000 Req:MEClientRequest [type:NEW client:1 ticker:0 oid:1445 side:BUY qty:10 price:184] to FIFO.</span></pre></li>
<li><span class="koboSpan" id="kobo.1541.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1542.1">MatchingEngine</span></strong><span class="koboSpan" id="kobo.1543.1"> component finally receives this request from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1544.1">LFQueue</span></strong><span class="koboSpan" id="kobo.1545.1"> and </span><a id="_idIndexMarker1431"/><span class="koboSpan" id="kobo.1546.1">processes it, as displayed in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.1547.1">log file:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1548.1">
exchange_matching_engine.log:matching_engine.h:66 run() Thu Apr  6 12:26:47 2023 Processing MEClientRequest [type:NEW client:1 ticker:0 oid:1445 side:BUY qty:10 price:184]</span></pre></li>
<li><span class="koboSpan" id="kobo.1549.1">In response to the order request it received, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1550.1">MatchingEngine</span></strong><span class="koboSpan" id="kobo.1551.1"> component generates a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1552.1">MEClientResponse</span></strong><span class="koboSpan" id="kobo.1553.1"> message meant for the client to be published by the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1554.1">OrderServer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1555.1"> component:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1556.1">
exchange_matching_engine.log:matching_engine.h:48 sendClientResponse() Thu Apr  6 12:26:47 2023 Sending MEClientResponse [type:ACCEPTED client:1 ticker:0 coid:1445 moid:53 side:BUY exec_qty:0 leaves_qty:10 price:184]</span></pre></li>
<li><span class="koboSpan" id="kobo.1557.1">Corresponding to the new order that is added to the limit order book, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1558.1">MatchingEngine</span></strong><span class="koboSpan" id="kobo.1559.1"> also generates an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1560.1">MEMarketUpdate</span></strong><span class="koboSpan" id="kobo.1561.1"> message, as shown here. </span><span class="koboSpan" id="kobo.1561.2">This is meant for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1562.1">MarketDataPublisher</span></strong><span class="koboSpan" id="kobo.1563.1"> component to publish and update the snapshot </span><span class="No-Break"><span class="koboSpan" id="kobo.1564.1">it maintains:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1565.1">
exchange_matching_engine.log:matching_engine.h:55 sendMarketUpdate() Thu Apr  6 12:26:47 2023 Sending MEMarketUpdate [ type:ADD ticker:0 oid:53 side:BUY qty:10 price:184 priority:2]</span></pre></li>
<li><span class="koboSpan" id="kobo.1566.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1567.1">OrderServer</span></strong><span class="koboSpan" id="kobo.1568.1"> component picks up the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1569.1">MEClientResponse</span></strong><span class="koboSpan" id="kobo.1570.1"> message from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1571.1">LFQueue</span></strong><span class="koboSpan" id="kobo.1572.1">, sending out an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1573.1">OMClientResponse</span></strong><span class="koboSpan" id="kobo.1574.1"> message to the client on the </span><a id="_idIndexMarker1432"/><span class="koboSpan" id="kobo.1575.1">correct TCP connection with the </span><span class="No-Break"><span class="koboSpan" id="kobo.1576.1">trading client:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1577.1">
exchange_order_server.log:order_server.h:32 run() Thu Apr  6 12:26:47 2023 Processing cid:1 seq:1343 MEClientResponse [type:ACCEPTED client:1 ticker:0 coid:1445 moid:53 side:BUY exec_qty:0 leaves_qty:10 price:184]</span></pre></li>
<li><span class="koboSpan" id="kobo.1578.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1579.1">MarketDataPublisher</span></strong><span class="koboSpan" id="kobo.1580.1"> component picks up the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1581.1">MEMarketUpdate</span></strong><span class="koboSpan" id="kobo.1582.1"> message sent by </span><strong class="source-inline"><span class="koboSpan" id="kobo.1583.1">MatchingEngine</span></strong><span class="koboSpan" id="kobo.1584.1">, sending out an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1585.1">MDPMarketUpdate</span></strong><span class="koboSpan" id="kobo.1586.1"> message on the incremental market data </span><span class="No-Break"><span class="koboSpan" id="kobo.1587.1">multicast stream:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1588.1">
exchange_market_data_publisher.log:market_data_publisher.cpp:19 run() Thu Apr  6 12:26:47 2023 Sending seq:902 MEMarketUpdate [ type:ADD ticker:0 oid:53 side:BUY qty:10 price:184 priority:2]</span></pre></li>
<li><span class="koboSpan" id="kobo.1589.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1590.1">SnapshotSynthesizer</span></strong><span class="koboSpan" id="kobo.1591.1"> sub-component inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1592.1">MarketDataPublisher</span></strong><span class="koboSpan" id="kobo.1593.1"> component also receives this incremental </span><strong class="source-inline"><span class="koboSpan" id="kobo.1594.1">MEMarketUpdate</span></strong><span class="koboSpan" id="kobo.1595.1"> message, adding it to the snapshot </span><span class="No-Break"><span class="koboSpan" id="kobo.1596.1">it maintains:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1597.1">
exchange_snapshot_synthesizer.log:snapshot_synthesizer.cpp:107 run() Thu Apr  6 12:26:47 2023 Processing MDPMarketUpdate [ seq:902 MEMarketUpdate [ type:ADD ticker:0 oid:53 side:BUY qty:10 price:184 priority:2]]</span></pre></li>
<li><span class="koboSpan" id="kobo.1598.1">At some </span><a id="_idIndexMarker1433"/><span class="koboSpan" id="kobo.1599.1">point, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1600.1">SnapshotSynthesizer</span></strong><span class="koboSpan" id="kobo.1601.1"> publishes a snapshot of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1602.1">MDPMarketUpdate</span></strong><span class="koboSpan" id="kobo.1603.1"> messages on the snapshot multicast market data stream, including this </span><span class="No-Break"><span class="koboSpan" id="kobo.1604.1">market update:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1605.1">
exchange_snapshot_synthesizer.log:snapshot_synthesizer.cpp:88 publishSnapshot() Thu Apr  6 12:27:40 2023 MDPMarketUpdate [ seq:7 MEMarketUpdate [ type:ADD ticker:0 oid:53 side:BUY qty:10 price:184 priority:2]]</span></pre></li>
<li><span class="koboSpan" id="kobo.1606.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1607.1">OrderGateway</span></strong><span class="koboSpan" id="kobo.1608.1"> component inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1609.1">trading_main</span></strong><span class="koboSpan" id="kobo.1610.1"> application receives the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1611.1">OMClientResponse</span></strong><span class="koboSpan" id="kobo.1612.1"> response for the order request, from the TCPSocket that is connected to </span><span class="No-Break"><span class="koboSpan" id="kobo.1613.1">the exchange:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1614.1">
trading_order_gateway_5.log:order_gateway.cpp:37 recvCallback() Thu Apr  6 12:26:47 2023 Received OMClientResponse [seq:1343 MEClientResponse [type:ACCEPTED client:1 ticker:0 coid:1445 moid:53 side:BUY exec_qty:0 leaves_qty:10 price:184]]</span></pre></li>
<li><span class="koboSpan" id="kobo.1615.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1616.1">MarketDataConsumer</span></strong><span class="koboSpan" id="kobo.1617.1"> component inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1618.1">trading_main</span></strong><span class="koboSpan" id="kobo.1619.1"> application </span><a id="_idIndexMarker1434"/><span class="koboSpan" id="kobo.1620.1">receives the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1621.1">MDPMarketUpdate</span></strong><span class="koboSpan" id="kobo.1622.1"> message on the incremental market </span><span class="No-Break"><span class="koboSpan" id="kobo.1623.1">data stream:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1624.1">
trading_market_data_consumer_5.log:market_data_consumer.cpp:177 recvCallback() Thu Apr  6 12:26:47 2023 Received incremental socket len:42 MDPMarketUpdate [ seq:902 MEMarketUpdate [ type:ADD ticker:0 oid:53 side:BUY qty:10 price:184 priority:2]]</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1625.1">
trading_market_data_consumer_5.log:market_data_consumer.cpp:193 recvCallback() Thu Apr  6 12:26:47 2023 MDPMarketUpdate [ seq:902 MEMarketUpdate [ type:ADD ticker:0 oid:53 side:BUY qty:10 price:184 priority:2]]</span></pre></li>
<li><span class="koboSpan" id="kobo.1626.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1627.1">TradeEngine</span></strong><span class="koboSpan" id="kobo.1628.1"> component finally receives the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1629.1">MEClientResponse</span></strong><span class="koboSpan" id="kobo.1630.1"> message from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1631.1">OrderGateway</span></strong><span class="koboSpan" id="kobo.1632.1"> component over the lock-free queue. </span><span class="koboSpan" id="kobo.1632.2">It also forwards the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1633.1">MEClientResponse</span></strong><span class="koboSpan" id="kobo.1634.1"> message via the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1635.1">onOrderUpdate()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1636.1"> callback:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1637.1">
trading_engine_5.log:trade_engine.cpp:44 run() Thu Apr  6 12:26:47 2023 Processing MEClientResponse [type:ACCEPTED client:1 ticker:0 coid:1445 moid:53 side:BUY exec_qty:0 leaves_qty:10 price:184]</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1638.1">
trading_engine_5.log:trade_engine.cpp:75 onOrderUpdate() Thu Apr  6 12:26:47 2023 MEClientResponse [type:ACCEPTED client:1 ticker:0 coid:1445 moid:53 side:BUY exec_qty:0 leaves_qty:10 price:184]</span></pre></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1639.1">TradeEngine</span></strong><span class="koboSpan" id="kobo.1640.1"> also receives the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1641.1">MEMarketUpdate</span></strong><span class="koboSpan" id="kobo.1642.1"> message, updates </span><strong class="source-inline"><span class="koboSpan" id="kobo.1643.1">MarketOrderBook</span></strong><span class="koboSpan" id="kobo.1644.1">, and, in turn, receives </span><strong class="source-inline"><span class="koboSpan" id="kobo.1645.1">onOrderBookUpdate()</span></strong><span class="koboSpan" id="kobo.1646.1"> from the order book back </span><span class="No-Break"><span class="koboSpan" id="kobo.1647.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1648.1">TradeEngine</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1649.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1650.1">
trading_engine_5.log:trade_engine.cpp:52 run() Thu Apr  6 12:26:47 2023 Processing MEMarketUpdate [ type:ADD ticker:0 oid:53 side:BUY qty:10 price:184 priority:2]</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1651.1">
trading_engine_5.log:trade_engine.cpp:64 onOrderBookUpdate() Thu Apr  6 12:26:47 2023 ticker:0 price:184 side:BUY</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.1652.1">Hopefully, this </span><a id="_idIndexMarker1435"/><span class="koboSpan" id="kobo.1653.1">example provided you with good insight into what the different components in our trading ecosystem do. </span><span class="koboSpan" id="kobo.1653.2">This should also serve as an example of how to investigate different events in the various applications, components, and sub-components of our electronic </span><span class="No-Break"><span class="koboSpan" id="kobo.1654.1">trading universe.</span></span></p>
<p><span class="koboSpan" id="kobo.1655.1">Now, let us focus on the entries generated by our other components – </span><strong class="source-inline"><span class="koboSpan" id="kobo.1656.1">FeatureEngine</span></strong><span class="koboSpan" id="kobo.1657.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1658.1">RiskManager</span></strong><span class="koboSpan" id="kobo.1659.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1660.1">PositionKeeper</span></strong><span class="koboSpan" id="kobo.1661.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1662.1">OrderManager</span></strong><span class="koboSpan" id="kobo.1663.1"> – and the strategies – the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1664.1">MarketMaker</span></strong><span class="koboSpan" id="kobo.1665.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1666.1">LiquidityTaker</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1667.1"> algorithms:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1668.1">The following log lines display the feature values that are updated by </span><strong class="source-inline"><span class="koboSpan" id="kobo.1669.1">FeatureEngine</span></strong><span class="koboSpan" id="kobo.1670.1"> as the order book updates or new trade events occur in </span><span class="No-Break"><span class="koboSpan" id="kobo.1671.1">market data:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1672.1">
trading_engine_1.log:feature_engine.h:23 onOrderBookUpdate() Thu May 11 16:10:45 2023 ticker:7 price:152 side:BUY mkt-price:152.394 agg-trade-ratio:0.0994475</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1673.1">
trading_engine_1.log:feature_engine.h:34 onTradeUpdate() Thu May 11 16:10:45 2023 MEMarketUpdate [ type:TRADE ticker:1 oid:INVALID side:SELL qty:50 price:170 priority:INVALID] mkt-price:170.071 agg-trade-ratio:1</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1674.1">
trading_engine_1.log:feature_engine.h:23 onOrderBookUpdate() Thu May 11 16:10:45 2023 ticker:2 price:119 side:SELL mkt-price:115.299 agg-trade-ratio:0.262712</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1675.1">
trading_engine_1.log:feature_engine.h:34 onTradeUpdate() Thu May 11 16:10:45 2023 MEMarketUpdate [ type:TRADE ticker:3 oid:INVALID side:BUY qty:18 price:180 priority:INVALID] mkt-price:115.299 agg-trade-ratio:0.00628931</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1676.1">
trading_engine_1.log:feature_engine.h:23 onOrderBookUpdate() Thu May 11 16:10:45 2023 ticker:3 price:180 side:SELL mkt-price:178.716 agg-trade-ratio:0.00628931</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1677.1">
trading_engine_1.log:feature_engine.h:34 onTradeUpdate() Thu May 11 16:10:45 2023 MEMarketUpdate [ type:TRADE ticker:3 oid:INVALID side:BUY qty:30 price:180 priority:INVALID] mkt-price:178.716 agg-trade-ratio:0.0105485</span></pre></li>
<li><span class="koboSpan" id="kobo.1678.1">The following </span><a id="_idIndexMarker1436"/><span class="koboSpan" id="kobo.1679.1">log lines correspond to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1680.1">PositionKeeper</span></strong><span class="koboSpan" id="kobo.1681.1"> being updated as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1682.1">BBO</span></strong><span class="koboSpan" id="kobo.1683.1"> changes or additional executions </span><span class="No-Break"><span class="koboSpan" id="kobo.1684.1">are processed:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1685.1">
trading_engine_1.log:position_keeper.h:75 addFill() Thu May 11 16:10:38 2023 Position{pos:476 u-pnl:-120.715 r-pnl:6248.71 t-pnl:6128 vol:8654 vwaps:[114.254X0] BBO{21@115X116@296}} MEClientResponse [type:FILLED client:1 ticker:2 coid:962 moid:1384 side:BUY exec_qty:25 leaves_qty:102 price:114]</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1686.1">
trading_engine_1.log:position_keeper.h:98 updateBBO() Thu May 11 16:10:42 2023 Position{pos:194 u-pnl:15.8965 r-pnl:311.103 t-pnl:327 vol:802 vwaps:[180.918X0] BBO{730@180X182@100}} BBO{730@180X182@100}</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1687.1">
trading_engine_1.log:position_keeper.h:75 addFill() Thu May 11 16:10:42 2023 Position{pos:392 u-pnl:688.98 r-pnl:6435.02 t-pnl:7124 vol:8782 vwaps:[114.242X0] BBO{44@114X116@150}} MEClientResponse [type:FILLED client:1 ticker:2 coid:970 moid:1394 side:SELL exec_qty:83 leaves_qty:44 price:116]</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1688.1">
trading_engine_1.log:position_keeper.h:98 updateBBO() Thu May 11 16:10:44 2023 Position{pos:373 u-pnl:282.585 r-pnl:6468.41 t-pnl:6751 vol:8801 vwaps:[114.242X0] BBO{19@114X116@131}} BBO{19@114X116@131}</span></pre></li>
<li><span class="koboSpan" id="kobo.1689.1">Failures </span><a id="_idIndexMarker1437"/><span class="koboSpan" id="kobo.1690.1">in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1691.1">RiskManager</span></strong><span class="koboSpan" id="kobo.1692.1">, due to several reasons we discussed in the </span><em class="italic"><span class="koboSpan" id="kobo.1693.1">Building the C++ trading algorithm building blocks</span></em><span class="koboSpan" id="kobo.1694.1"> chapter in the </span><em class="italic"><span class="koboSpan" id="kobo.1695.1">Computing and managing risk</span></em><span class="koboSpan" id="kobo.1696.1"> section, show up in the log files as something like </span><span class="No-Break"><span class="koboSpan" id="kobo.1697.1">the following:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1698.1">
trading_engine_1.log:order_manager.h:69 moveOrder() Thu May 11 16:10:41 2023 Ticker:1 Side:BUY Qty:60 RiskCheckResult:POSITION_TOO_LARGE</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1699.1">
trading_engine_1.log:order_manager.h:69 moveOrder() Thu May 11 16:10:41 2023 Ticker:4 Side:SELL Qty:1000 RiskCheckResult:LOSS_TOO_LARGE</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1700.1">
trading_engine_1.log:order_manager.h:69 moveOrder() Thu May 11 16:10:42 2023 Ticker:2 Side:BUY Qty:150 RiskCheckResult:POSITION_TOO_LARGE</span></pre></li>
<li><span class="koboSpan" id="kobo.1701.1">Events in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1702.1">OrderManager</span></strong><span class="koboSpan" id="kobo.1703.1"> appear as follows in the log files, as attempts are made to </span><a id="_idIndexMarker1438"/><span class="koboSpan" id="kobo.1704.1">send order requests and responses </span><span class="No-Break"><span class="koboSpan" id="kobo.1705.1">are processed:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1706.1">
trading_engine_1.log:order_manager.h:26 onOrderUpdate() Thu May 11 16:10:36 2023 OMOrder[tid:6 oid:965 side:SELL price:125 qty:15 state:PENDING_CANCEL]</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1707.1">
trading_engine_1.log:order_manager.cpp:13 newOrder() Thu May 11 16:10:37 2023 Sent new order MEClientRequest [type:NEW client:1 ticker:6 oid:966 side:SELL qty:50 price:126] for OMOrder[tid:6 oid:966 side:SELL price:126 qty:50 state:PENDING_NEW]</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1708.1">
trading_engine_1.log:order_manager.h:23 onOrderUpdate() Thu May 11 16:10:37 2023 MEClientResponse [type:ACCEPTED client:1 ticker:6 coid:966 moid:1806 side:SELL exec_qty:0 leaves_qty:50 price:126]</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1709.1">
trading_engine_1.log:order_manager.h:26 onOrderUpdate() Thu May 11 16:10:37 2023 OMOrder[tid:6 oid:966 side:SELL price:126 qty:50 state:PENDING_NEW]</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1710.1">
trading_engine_1.log:order_manager.cpp:26 cancelOrder() Thu May 11 16:10:37 2023 Sent cancel MEClientRequest [type:CANCEL client:1 ticker:1 oid:927 side:SELL qty:60 price:170] for OMOrder[tid:1 oid:927 side:SELL price:170 qty:60 state:PENDING_CANCEL]</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1711.1">
trading_engine_1.log:order_manager.h:23 onOrderUpdate() Thu May 11 16:10:37 2023 MEClientResponse [type:CANCELED client:1 ticker:1 coid:927 moid:1826 side:SELL exec_qty:INVALID leaves_qty:60 price:170]</span></pre></li>
<li><span class="koboSpan" id="kobo.1712.1">Events in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1713.1">LiquidityTaker</span></strong><span class="koboSpan" id="kobo.1714.1"> trading strategy appear as shown here. </span><span class="koboSpan" id="kobo.1714.2">These correspond </span><a id="_idIndexMarker1439"/><span class="koboSpan" id="kobo.1715.1">to order book updates, trade events, and updates to </span><span class="No-Break"><span class="koboSpan" id="kobo.1716.1">strategy orders:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1717.1">
trading_engine_1.log:liquidity_taker.h:19 onOrderBookUpdate() Thu May 11 16:07:48 2023 ticker:4 price:183 side:SELL</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1718.1">
trading_engine_1.log:liquidity_taker.h:19 onOrderBookUpdate() Thu May 11 16:07:48 2023 ticker:7 price:153 side:BUY</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1719.1">
trading_engine_1.log:liquidity_taker.h:25 onTradeUpdate() Thu May 11 16:07:48 2023 MEMarketUpdate [ type:TRADE ticker:7 oid:INVALID side:SELL qty:90 price:154 priority:INVALID]</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1720.1">
trading_engine_1.log:liquidity_taker.h:32 onTradeUpdate() Thu May 11 16:07:48 2023 BBO{368@154X155@2095} agg-qty-ratio:0.244565</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1721.1">
trading_engine_1.log:liquidity_taker.h:19 onOrderBookUpdate() Thu May 11 16:07:48 2023 ticker:7 price:154 side:BUY</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1722.1">
trading_engine_1.log:liquidity_taker.h:49 onOrderUpdate() Thu May 11 16:07:48 2023 MEClientResponse [type:FILLED client:3 ticker:7 coid:202 moid:792 side:BUY exec_qty:90 leaves_qty:183 price:154]</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1723.1">
trading_engine_1.log:liquidity_taker.h:19 onOrderBookUpdate() Thu May 11 16:07:48 2023 ticker:0 price:180 side:BUY</span></pre></li>
<li><span class="koboSpan" id="kobo.1724.1">Similarly, </span><a id="_idIndexMarker1440"/><span class="koboSpan" id="kobo.1725.1">events in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1726.1">MarketMaker</span></strong><span class="koboSpan" id="kobo.1727.1"> trading algorithm appear in the log files, as </span><span class="No-Break"><span class="koboSpan" id="kobo.1728.1">shown here:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1729.1">
trading_engine_1.log:market_maker.h:47 onOrderUpdate() Thu May 11 16:06:12 2023 MEClientResponse [type:FILLED client:1 ticker:5 coid:418 moid:552 side:BUY exec_qty:62 leaves_qty:160 price:137]</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1730.1">
trading_engine_1.log:market_maker.h:42 onTradeUpdate() Thu May 11 16:06:12 2023 MEMarketUpdate [ type:TRADE ticker:3 oid:INVALID side:BUY qty:47 price:180 priority:INVALID]</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1731.1">
trading_engine_1.log:market_maker.h:19 onOrderBookUpdate() Thu May 11 16:06:12 2023 ticker:3 price:180 side:SELL</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1732.1">
trading_engine_1.log:market_maker.h:27 onOrderBookUpdate() Thu May 11 16:06:12 2023 BBO{2759@178X180@2409} fair-price:179.068</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1733.1">
trading_engine_1.log:market_maker.h:19 onOrderBookUpdate() Thu May 11 16:06:12 2023 ticker:0 price:183 side:SELL</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1734.1">
trading_engine_1.log:market_maker.h:27 onOrderBookUpdate() Thu May 11 16:06:12 2023 BBO{4395@181X182@534} fair-price:181.892</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1735.1">
trading_engine_1.log:market_maker.h:42 onTradeUpdate() Thu May 11 16:06:12 2023 MEMarketUpdate [ type:TRADE ticker:5 oid:INVALID side:SELL qty:62 price:137 priority:INVALID]</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1736.1">
trading_engine_1.log:market_maker.h:19 onOrderBookUpdate() Thu May 11 16:06:12 2023 ticker:5 price:137 side:BUY</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.1737.1">We encourage you </span><a id="_idIndexMarker1441"/><span class="koboSpan" id="kobo.1738.1">to inspect the various log files in more detail to understand the processing that occurs in the different components and how our entire electronic trading </span><span class="No-Break"><span class="koboSpan" id="kobo.1739.1">ecosystem functions.</span></span></p>
<h1 id="_idParaDest-278"><a id="_idTextAnchor291"/><span class="koboSpan" id="kobo.1740.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1741.1">This chapter focused on using all the components we have built over the last two chapters and leveraging them to build our intelligent trading strategies – the MM trading strategy and the liquidity taking trading algorithm. </span><span class="koboSpan" id="kobo.1741.2">We spent some time understanding the theory, motivation, and behavior of these two trading algorithms with </span><span class="No-Break"><span class="koboSpan" id="kobo.1742.1">some examples.</span></span></p>
<p><span class="koboSpan" id="kobo.1743.1">In the next two sections, we implemented the C++ MM trading algorithm, which manages passive orders, and the liquidity taking algorithm, which sends aggressive orders to </span><span class="No-Break"><span class="koboSpan" id="kobo.1744.1">the market.</span></span></p>
<p><span class="koboSpan" id="kobo.1745.1">Then, we built the trading engine framework that ties together the market data consumer, the order gateway, the feature engine, the position keeper, the order manager, and the risk manager together with the two trading algorithms. </span><span class="koboSpan" id="kobo.1745.2">This framework is what we use to join all these components together and facilitate the flow of incoming and outgoing data streams and </span><span class="No-Break"><span class="koboSpan" id="kobo.1746.1">trading intelligence.</span></span></p>
<p><span class="koboSpan" id="kobo.1747.1">Finally, we built the main trading application, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1748.1">trading_main</span></strong><span class="koboSpan" id="kobo.1749.1">, which is the complement of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1750.1">exchange_main</span></strong><span class="koboSpan" id="kobo.1751.1"> application on the market participant’s side. </span><span class="koboSpan" id="kobo.1751.2">We then ran a few different instances of the trading application to run instances of the random trading algorithm, the MM algorithm, and the liquidity taking algorithm in our ecosystem. </span><span class="koboSpan" id="kobo.1751.3">We inspected the log files generated by running our electronic trading ecosystem as the different trading client systems and strategies interacted with each other through the </span><span class="No-Break"><span class="koboSpan" id="kobo.1752.1">electronic exchange.</span></span></p>
<p><span class="koboSpan" id="kobo.1753.1">In the next chapter, we will add an instrumentation system to measure the performance of our entire electronic trading ecosystem. </span><span class="koboSpan" id="kobo.1753.2">We mentioned throughout this book that the first step to optimizing something is measuring the performance of a system and its components individually, and we will start by doing that in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1754.1">next chapter.</span></span></p>
</div>


<div class="Content" id="_idContainer067">
<h1 id="_idParaDest-279"><a id="_idTextAnchor292"/><span class="koboSpan" id="kobo.1.1">Part 4:Analyzing and Improving Performance</span></h1>
<p><span class="koboSpan" id="kobo.2.1">In this part, we will measure the performance of all the different C++ components in our trading ecosystem. </span><span class="koboSpan" id="kobo.2.2">We will analyze the latency profile of the different components individually, as well as measuring the performance of the end-to-end round-trip path. </span><span class="koboSpan" id="kobo.2.3">From there, we will discuss further optimization techniques and see the impact of our C++ optimization efforts. </span><span class="koboSpan" id="kobo.2.4">We will also discuss some future enhancements that can be made to our electronic </span><span class="No-Break"><span class="koboSpan" id="kobo.3.1">trading ecosystem.</span></span></p>
<p><span class="koboSpan" id="kobo.4.1">This part contains the </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">following chapters:</span></span></p>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapter 11, Adding Instrumentation and Measuring Performance</span></em></li>
<li><em class="italic"><span class="koboSpan" id="kobo.7.1">Chapter 12, Analyzing and Optimizing the Performance of Our C++ System</span></em></li>
</ul>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer068">
</div>
</div>
<div>
<div id="_idContainer069">
</div>
</div>
</body></html>