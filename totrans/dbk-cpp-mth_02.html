<html><head></head><body>
  <div id="_idContainer008">
   <h1 class="chapter-number" id="_idParaDest-27">
    <a id="_idTextAnchor026">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     2
    </span>
   </h1>
   <h1 id="_idParaDest-28">
    <a id="_idTextAnchor027">
    </a>
    <span class="koboSpan" id="kobo.2.1">
     Every C++ Program Is Standard-Compliant
    </span>
   </h1>
   <p class="italic-heading">
    <em class="italic">
     <span class="koboSpan" id="kobo.3.1">
      Except when they are not
     </span>
    </em>
   </p>
   <p>
    <span class="koboSpan" id="kobo.4.1">
     In the world of C++ programming, the concept of standard compliance is often held in high regard, with the latest iteration of the C++ standard perceived as the definitive guide for writing correct and efficient code.
    </span>
    <span class="koboSpan" id="kobo.4.2">
     The C++ standard, meticulously crafted and periodically
    </span>
    <a id="_idIndexMarker030">
    </a>
    <span class="koboSpan" id="kobo.5.1">
     updated by the C++ committee and the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.6.1">
      International Organization for Standardization
     </span>
    </strong>
    <span class="koboSpan" id="kobo.7.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.8.1">
      ISO
     </span>
    </strong>
    <span class="koboSpan" id="kobo.9.1">
     ), serves as the ultimate guide for developers, providing a comprehensive set of rules and best practices to ensure code quality and interoperability.
    </span>
    <span class="koboSpan" id="kobo.9.2">
     However, the reality of software development is more nuanced and complex than this
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.10.1">
      ideal suggests.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.11.1">
     In this chapter, we will delve into the myriad challenges faced by developers who, due to various constraints, cannot always adhere to these standards and carefully balance on the sharp, thin edge between ideal standards and the practical demands of their work.
    </span>
    <span class="koboSpan" id="kobo.11.2">
     These constraints can include limitations in their development environment, such as outdated compilers, legacy systems, or specific project requirements that mandate the use of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.12.1">
      non-standard features.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.13.1">
     Complex situations can arise when we are forced to use a framework that uses C++ as a base and provides a set of extensions to satisfy a certain use case.
    </span>
    <span class="koboSpan" id="kobo.13.2">
     As we will present at a later stage, these frameworks build on existing standard C++ and bring in features that are highly specific for a certain scope, but have nothing in common with the C++ standard.
    </span>
    <span class="koboSpan" id="kobo.13.3">
     So, we might ask ourselves: should we use these frameworks or not?
    </span>
    <span class="koboSpan" id="kobo.13.4">
     The answer to this question, as we will see, is not as straightforward as one
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.14.1">
      might assume.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.15.1">
     In this chapter, we will cover the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.16.1">
      major topics:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.17.1">
      Adherence to standards in various compilers, frameworks,
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.18.1">
       and environments
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.19.1">
      Why can’t everyone learn, use, or write
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.20.1">
       standard C++?
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.21.1">
      Compiler extensions drifting away from
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.22.1">
       the standard
      </span>
     </span>
    </li>
   </ul>
   <h1 id="_idParaDest-29">
    <a id="_idTextAnchor028">
    </a>
    <span class="koboSpan" id="kobo.23.1">
     Technical requirements
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.24.1">
     We have to admit that reading this chapter will not be a straightforward process, but we will try to make it as easy as possible.
    </span>
    <span class="koboSpan" id="kobo.24.2">
     Our minds will wander between platforms, compilers, and different dialects of the C++ language.
    </span>
    <span class="koboSpan" id="kobo.24.3">
     However, at some point, we must draw the line and conclude that we should be able to transform all this theoretical transfer of information into the practicalities of life and produce some C++ code out of it.
    </span>
    <span class="koboSpan" id="kobo.24.4">
     So, we kindly ask that at this stage of the book, you have access to the almighty internet, and the go-to place for experimental C++: Matt
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.25.1">
      Godbolt’s site:
     </span>
    </span>
   </p>
   <p>
    <a href="https://gcc.godbolt.org/">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.26.1">
       https://gcc.godbolt.org/
      </span>
     </span>
    </a>
   </p>
   <p>
    <span class="koboSpan" id="kobo.27.1">
     That place should keep you covered since almost all the compilers we will discuss in this chapter are to be
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.28.1">
      found there.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.29.1">
     There is nothing else required for now.
    </span>
    <span class="koboSpan" id="kobo.29.2">
     That’s because at this stage, we have not produced enough valuable code to be able to put anything meaningful into the GitHub repository of the book, and the code that we have produced should not
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.30.1">
      go anywhere.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-30">
    <a id="_idTextAnchor029">
    </a>
    <span class="koboSpan" id="kobo.31.1">
     Somewhere in Ghana, far, far away
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.32.1">
     When Richard Appiah Akoto posted a few images of himself drawing the user interface of Microsoft Word
    </span>
    <a id="_idIndexMarker031">
    </a>
    <span class="koboSpan" id="kobo.33.1">
     on a blackboard at his school in Ghana, he instantly became a social media phenomenon overnight
    </span>
    <span class="superscript">
     <span id="footnote-007-backlink">
      <a class="_idFootnoteLink _idGenColorInherit" href="B22235_02.xhtml#footnote-007">
       <span class="koboSpan" id="kobo.34.1">
        1
       </span>
      </a>
     </span>
    </span>
    <span class="koboSpan" id="kobo.35.1">
     .
    </span>
    <span class="koboSpan" id="kobo.35.2">
     His school was poor and they had no working computers, just a standard blackboard from the turn of the century, but this did not stop him from performing his duties as a teacher.
    </span>
    <span class="koboSpan" id="kobo.35.3">
     In a very creative manner, he did his best to convey life-altering knowledge to his pupils, hoping that one day, it would be useful for them in their quest for a better life.
    </span>
    <span class="koboSpan" id="kobo.35.4">
     The rest is history, but the real question is: was this the standard way of teaching
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.36.1">
      Microsoft Word?
     </span>
    </span>
   </p>
   <div class="_idFootnote" epub:type="footnote" id="footnote-007">
    <p class="Basic-Paragraph">
     <a class="_idFootnoteAnchor _idGenColorInherit" href="B22235_02.xhtml#footnote-007-backlink">
      <span class="koboSpan" id="kobo.37.1">
       1
      </span>
     </a>
     <a href="https://news.microsoft.com/apac/2018/03/17/teacher-who-used-a-chalkboard-in-computer-class-because-he-had-no-computer-stars-at-microsofts-education-exchange/">
      <span lang="en-US" xml:lang="en-US">
       <span class="koboSpan" id="kobo.38.1">
        https://news.microsoft.com/apac/2018/03/17/teacher-who-used-a-chalkboard-in-computer-class-because-he-had-no-computer-stars-at-microsofts-education-exchange/
       </span>
      </span>
     </a>
    </p>
   </div>
   <p>
    <span class="koboSpan" id="kobo.39.1">
     Let’s not diverge too much from our initial objective.
    </span>
    <span class="koboSpan" id="kobo.39.2">
     We want to find out about the standard compliance of C++ programs.
    </span>
    <span class="koboSpan" id="kobo.39.3">
     For zealot C++ programmers, the latest iteration of the standard is perceived as holy scripture, the word, the collection of rules that they should obey, and any deviation from it should be punishable with an erasure and rewrite of the non-standard compliant code.
    </span>
    <span class="koboSpan" id="kobo.39.4">
     Or one week in the detention center labeled
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.40.1">
      the maintainer of
     </span>
    </em>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.41.1">
       legacy code
      </span>
     </em>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.42.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.43.1">
     Facing the harsh reality, things couldn’t be further from an idealistic environment.
    </span>
    <span class="koboSpan" id="kobo.43.2">
     Some developers do not have the possibility to use the latest version of the C++ standard.
    </span>
    <span class="koboSpan" id="kobo.43.3">
     This could be because their livelihood is bound to real-life projects that require a specific compiler, or because the environment they program for does not allow the use of specific features of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.44.1">
      the language.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.45.1">
     Or maybe they are
    </span>
    <a id="_idIndexMarker032">
    </a>
    <span class="koboSpan" id="kobo.46.1">
     paid to work on a platform that simply has not received updates for the last 20 years because the provider declared bankruptcy a decade ago, and there was no one to take up their business.
    </span>
    <span class="koboSpan" id="kobo.46.2">
     However, since everything works and it still generates revenue, it is kept and maintained using tools that were available 20
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.47.1">
      years ago.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.48.1">
     This definitely does not include
    </span>
    <a id="_idIndexMarker033">
    </a>
    <span class="koboSpan" id="kobo.49.1">
     compilers with support for the latest C++ standard.
    </span>
    <span class="koboSpan" id="kobo.49.2">
     So, does this mean the C++ code the developers working on these platforms write is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.50.1">
      not standard-compliant?
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.51.1">
     At the turn of the century, the author of this chapter found himself in a classroom at his university, attending a course called
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.52.1">
      Introduction to C++ Programming
     </span>
    </em>
    <span class="koboSpan" id="kobo.53.1">
     .
    </span>
    <span class="koboSpan" id="kobo.53.2">
     It was the only C++ course offered at that place, and there was one book the teacher used to pass on knowledge to more than
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.54.1">
      30 students.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.55.1">
     The small copy shop owner at the end of the road was very happy when, one day, the teacher decided to loan the book to one of the students.
    </span>
    <span class="koboSpan" id="kobo.55.2">
     The book was a translated and heavily reduced version of Kris Jamsa’s
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.56.1">
      C/C++ programmers’ Bible
     </span>
    </em>
    <span class="koboSpan" id="kobo.57.1">
     , the “book with the spotted dog,” as we
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.58.1">
      called it.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.59.1">
     The local edition of the book contained only the C++ part, but it carried a very important inset: a Turbo C++ Lite IDE and accompanying compiler on a standard 1.44 MB floppy disk.
    </span>
    <span class="koboSpan" id="kobo.59.2">
     For those who are unfamiliar with the name, Turbo C++ Lite was a dumbed-down version of the popular (and very user-friendly) IDE and compiler Turbo C++ by Borland.
    </span>
    <span class="koboSpan" id="kobo.59.3">
     The compiler was the same, however, a lot of features and tools were removed in order to fit the entire environment on a single 1.44 MB (megabytes, that is)
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.60.1">
      floppy disk.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.61.1">
     This was our first introduction to the complex world of compilers, linkers, and syntax.
    </span>
    <span class="koboSpan" id="kobo.61.2">
     Some of us found it so fascinating that even now, some 20 years later, we still use it in our daily work.
    </span>
    <span class="koboSpan" id="kobo.61.3">
     So, as you can imagine, our first C++ program looked like the one in the screenshot
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.62.1">
      that follows.
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer007">
     <span class="koboSpan" id="kobo.63.1">
      <img alt="Figure 2.1 – The infamous blue screen of code, as seen in Life of a Programmer (1997)" src="image/B22235_02_01.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.64.1">
     Figure 2.1 – The infamous screen of code, as seen in Life of a Programmer (1997)
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.65.1">
     Oh, the horror
    </span>
    <a id="_idIndexMarker034">
    </a>
    <span class="koboSpan" id="kobo.66.1">
     on your face!
    </span>
    <span class="koboSpan" id="kobo.66.2">
     I can clearly imagine it, dear C++ acolyte.
    </span>
    <span class="koboSpan" id="kobo.66.3">
     The sheer
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.67.1">
      sight of:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.68.1">
       iostream.h
      </span>
     </strong>
     <span class="koboSpan" id="kobo.69.1">
      : Well, hello, it’s 1999, and the C++98 standard came out last year.
     </span>
     <span class="koboSpan" id="kobo.69.2">
      Why don’t you use it, you heretic?
     </span>
     <span class="koboSpan" id="kobo.69.3">
      Its number is ISO/IEC 14882:1998, go fetch it for a mere 200 Swiss Francs.
     </span>
     <span class="koboSpan" id="kobo.69.4">
      … Oh, that is your salary as a part-time dishwasher for three months while
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.70.1">
       studying here?
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.71.1">
       void main(void)
      </span>
     </strong>
     <span class="koboSpan" id="kobo.72.1">
      : Oh dear, that was never even in any standard, whether C or C++.
     </span>
     <span class="koboSpan" id="kobo.72.2">
      What sort of dark concoction did you just dig out?
     </span>
     <span class="koboSpan" id="kobo.72.3">
      … Or is this the new thing they
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.73.1">
       call… Java?
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.74.1">
       cout
      </span>
     </strong>
     <span class="koboSpan" id="kobo.75.1">
      : Without ever encountering a using directive, how is this
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.76.1">
       even possible?
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.77.1">
     Here, you can easily afford to give up on trying to understand the reasons for this, sighing with relief, but please bear
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.78.1">
      with me.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.79.1">
     Very much akin to the conditions faced by Richard Appiah Akoto, at that stage of our education, we also had access to a classroom with a blackboard, accompanied by one dedicated teacher and the book, as well as several copies of it, as mentioned earlier.
    </span>
    <span class="koboSpan" id="kobo.79.2">
     Even so, we learned C++.
    </span>
    <span class="koboSpan" id="kobo.79.3">
     Maybe, from the point of view of the standard, these were ideal circumstances, because the C++ standard is very relaxed, considering the environment, it requires nothing that you can find in a modern computer – no keyboard, no screen, and not even
    </span>
    <a id="_idIndexMarker035">
    </a>
    <span class="koboSpan" id="kobo.80.1">
     an operating system.
    </span>
    <span class="koboSpan" id="kobo.80.2">
     Indeed, the only very strict environmental requirement is that
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.81.1">
      char
     </span>
    </strong>
    <span class="koboSpan" id="kobo.82.1">
     must be at least 8 bits in size.
    </span>
    <span class="koboSpan" id="kobo.82.2">
     This is to ensure that a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.83.1">
      char
     </span>
    </strong>
    <span class="koboSpan" id="kobo.84.1">
     can hold any member of the basic execution character set (which includes standard ASCII characters).
    </span>
    <span class="koboSpan" id="kobo.84.2">
     And the fact that
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.85.1">
      sizeof(char) == 1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.86.1">
     is also guaranteed by the C++ standard, together with the signed and unsigned versions of it.
    </span>
    <span class="koboSpan" id="kobo.86.2">
     Everything else builds on
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.87.1">
      these foundations.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.88.1">
     So, we might say that until we were granted access to the computer lab, we had ideal circumstances for learning standard C++.
    </span>
    <span class="koboSpan" id="kobo.88.2">
     No annoying system dependencies, no computer crashes, and no hardware to kick in case of frustration when your code does not compile.
    </span>
    <span class="koboSpan" id="kobo.88.3">
     Since we had no compiler running on the blackboard, our teacher soon realized that compiling more complex C++ code on a blackboard is not quite feasible, so we were allocated an early Friday morning time slot at the computer lab.
    </span>
    <span class="koboSpan" id="kobo.88.4">
     All the troubles
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.89.1">
      began afterward.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.90.1">
     The explanation is quite simple: you see, the computer lab that was allocated for teaching C++ at our university back in the day consisted of a bunch of 80286 IBM
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.91.1">
      AT clones.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.92.1">
     You read that correctly.
    </span>
    <span class="koboSpan" id="kobo.92.2">
     30 students were allocated eight computers (each with a glorious 80286 processors, possibly high-tech at the time of their conception, albeit quite outdated more than one and a half decades later), hand-me-downs from some aid organization that likely did an upgrade, and decided to donate their old equipment to the university for the
    </span>
    <span class="strikethrough">
     <span class="koboSpan" id="kobo.93.1">
      tax
     </span>
    </span>
    <span class="koboSpan" id="kobo.94.1">
     benefit of the
    </span>
    <span class="strikethrough">
     <span class="koboSpan" id="kobo.95.1">
      company
     </span>
    </span>
    <span class="koboSpan" id="kobo.96.1">
     students.
    </span>
    <span class="koboSpan" id="kobo.96.2">
     Four and a half people were sitting at one machine, with one book (and several copies) for the class, trying to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.97.1">
      learn C++.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.98.1">
     Although the situation was not as bleak as in Richard Appiah Akoto’s school two decades later, there were simply no better conditions.
    </span>
    <span class="koboSpan" id="kobo.98.2">
     Those machines could never run anything else
    </span>
    <a id="_idIndexMarker036">
    </a>
    <span class="koboSpan" id="kobo.99.1">
     than pure DOS, and there was no better compiler available for them than Turbo C++ Lite, which came out 10 years earlier.
    </span>
    <span class="koboSpan" id="kobo.99.2">
     Does this mean we intentionally learned to write non-standard C++ code?
    </span>
    <span class="koboSpan" id="kobo.99.3">
     No, obviously not.
    </span>
    <span class="koboSpan" id="kobo.99.4">
     We wrote code that we had the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.100.1">
      possibility to.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.101.1">
     However, let’s not jump that far back in time.
    </span>
    <span class="koboSpan" id="kobo.101.2">
     As of 2024, the date of writing of this book, there are
    </span>
    <a id="_idIndexMarker037">
    </a>
    <span class="koboSpan" id="kobo.102.1">
     46 questions on Stack Overflow (
    </span>
    <a href="https://stackoverflow.com/">
     <span class="koboSpan" id="kobo.103.1">
      https://stackoverflow.com/
     </span>
    </a>
    <span class="koboSpan" id="kobo.104.1">
     ), containing the dreaded
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.105.1">
      void main(void)
     </span>
    </strong>
    <span class="koboSpan" id="kobo.106.1">
     phrase.
    </span>
    <span class="koboSpan" id="kobo.106.2">
     The latest one is surprisingly from 2023.
    </span>
    <span class="koboSpan" id="kobo.106.3">
     A bit more with the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.107.1">
      iostream.h
     </span>
    </strong>
    <span class="koboSpan" id="kobo.108.1">
     content but mostly with educational context, and we did not dare count the ones containing
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.109.1">
      cout
     </span>
    </strong>
    <span class="koboSpan" id="kobo.110.1">
     without encountering the using directive or a namespace qualifier because it would have been futile.
    </span>
    <span class="koboSpan" id="kobo.110.2">
     Does this mean that even in 2024, there are programmers still writing code that relies on non-standard C++?
    </span>
    <span class="koboSpan" id="kobo.110.3">
     Or are there students learning C++ in a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.111.1">
      non-standard way?
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.112.1">
     Digging a bit further on Stack Overflow, another interesting piece of an old dialect of C++ pops up:
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.113.1">
      conio.h
     </span>
    </strong>
    <span class="koboSpan" id="kobo.114.1">
     .
    </span>
    <span class="koboSpan" id="kobo.114.2">
     This header was shipped with Turbo C (and C++) several years before the official standardization of the language, but considering that there are young padawans still asking questions about it in 2024, we might say that the answer to the previous question is highly
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.115.1">
      likely
     </span>
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.116.1">
       yes
      </span>
     </em>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.117.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.118.1">
     Depending on their circumstances and possibilities, whether they have to learn using a blackboard, drawing with chalk, or by sharing a keyboard, tapping each other’s hands gently in the process, there are still programmers out there today who involuntarily have the process of learning and writing non-standard C++ imposed
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.119.1">
      on them.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-31">
    <a id="_idTextAnchor030">
    </a>
    <span class="koboSpan" id="kobo.120.1">
     Microsoft’s tiny, squishy C++
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.121.1">
     That’s enough
    </span>
    <a id="_idIndexMarker038">
    </a>
    <span class="koboSpan" id="kobo.122.1">
     staring backward for now.
    </span>
    <span class="koboSpan" id="kobo.122.2">
     Let’s look, for a moment, in a different direction and consider a compiler that once was the king of C++, but with time, its shine faded.
    </span>
    <span class="koboSpan" id="kobo.122.3">
     OpenWatcom is an open source integrated development environment and suite of compilers for C and C++ (and Fortran too, but that language is not in focus in this book), originally developed by Watcom International Corporation and released as open source by Sybase
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.123.1">
      in 2003.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.124.1">
     It supports multiple operating systems, including DOS, Windows, OS/2, and also Linux, and is the de-facto compiler for programmers who have an interest in creating fun, free-time projects for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.125.1">
      retro platforms.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.126.1">
     Not necessarily for the money, but instead for that joyful feeling of sweet nostalgia shivering through one’s spine when they are in front of an 80x25 screen.
    </span>
    <span class="koboSpan" id="kobo.126.2">
     Maybe that’s the reason most senior programmers today use a grid of VI editors running in a terminal tiled to 6x4 windows, on huge WQUXGA (or
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.127.1">
      larger) screens.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.128.1">
     But let’s get back to the
    </span>
    <a id="_idIndexMarker039">
    </a>
    <span class="koboSpan" id="kobo.129.1">
     OpenWatcom compiler.
    </span>
    <span class="koboSpan" id="kobo.129.2">
     While browsing the release notes of the project
    </span>
    <span class="superscript">
     <span id="footnote-006-backlink">
      <a class="_idFootnoteLink _idGenColorInherit" href="B22235_02.xhtml#footnote-006">
       <span class="koboSpan" id="kobo.130.1">
        2
       </span>
      </a>
     </span>
    </span>
    <span class="koboSpan" id="kobo.131.1">
     , we encountered the following, may I say so, quite intriguing phrase (in the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.132.1">
      Major differences from version 10.0
     </span>
    </em>
    <span class="koboSpan" id="kobo.133.1">
     section, at
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.134.1">
      item 29):
     </span>
    </span>
   </p>
   <div class="_idFootnote" epub:type="footnote" id="footnote-006">
    <p class="Footer" lang="en-US" xml:lang="en-US">
     <a class="_idFootnoteAnchor _idGenColorInherit" href="B22235_02.xhtml#footnote-006-backlink">
      <span class="koboSpan" id="kobo.135.1">
       2
      </span>
     </a>
     <a href="https://open-watcom.github.io/open-watcom-v2-wikidocs/c_readme.html">
      <span class="koboSpan" id="kobo.136.1">
       https://open-watcom.github.io/open-watcom-v2-wikidocs/c_readme.html
      </span>
     </a>
    </p>
   </div>
   <p class="author-quote">
    <span class="koboSpan" id="kobo.137.1">
     We have duplicated a Microsoft Visual C++ extension that was required to parse the Windows 95 SDK header files.
    </span>
   </p>
   <p class="author-quote">
    <span class="koboSpan" id="kobo.138.1">
     Example:
    </span>
   </p>
   <p class="author-quote">
    <span class="koboSpan" id="kobo.139.1">
     typedef struct S {
    </span>
   </p>
   <p class="author-quote">
    <span class="koboSpan" id="kobo.140.1">
     } S, const *CSP;
    </span>
   </p>
   <p class="author-quote">
    <span class="koboSpan" id="kobo.141.1">
     ^^^^^- not allowed in ISO C or ISO C++
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.142.1">
     Ehm … what?
    </span>
    <span class="koboSpan" id="kobo.142.2">
     Did I just read correctly that there is an extension for Visual C++ that allows non-standard code to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.143.1">
      be compiled?
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.144.1">
     Yes, we actually read that correctly.
    </span>
    <span class="koboSpan" id="kobo.144.2">
     The following short sequence of demonstrative code should not compile with any major C++ compiler today, except for Visual C++ (and OpenWatcom’s C++ compiler, as per
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.145.1">
      their comments):
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.146.1">
#include &lt;iostream&gt;
typedef struct S {
   int a;
} S, const *CSP;
int main() {
   S s1; s1.a = 1;
   CSP ps1 = &amp;s1;
   std::cout &lt;&lt; ps1-&gt;a;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.147.1">
     ...and due to some mystery, the author was not able to decipher, the code sequence is also accepted by several versions of ICC (Intel’s powerful, but sadly discontinued, C++ compiler).
    </span>
    <span class="koboSpan" id="kobo.147.2">
     So, we can ask the following question again: since one major, and two relatively esoteric compilers accept this kind of code, does this mean that we should use it?
    </span>
    <span class="koboSpan" id="kobo.147.3">
     Is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.148.1">
      it standard?
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.149.1">
     The answer to the second question is a definitive
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.150.1">
      no
     </span>
    </em>
    <span class="koboSpan" id="kobo.151.1">
     .
    </span>
    <span class="koboSpan" id="kobo.151.2">
     However, for the first one, it is a bit more nuanced.
    </span>
    <span class="koboSpan" id="kobo.151.3">
     This is because before answering, we must take the background, requirements, and other relevant factors that might influence the decisions concerning the development into
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.152.1">
      consideration again.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.153.1">
     Do we want to
    </span>
    <a id="_idIndexMarker040">
    </a>
    <span class="koboSpan" id="kobo.154.1">
     stick to the standard C++ as much as we can?
    </span>
    <span class="koboSpan" id="kobo.154.2">
     Is it possible to deliver the required solution without extending ourselves to using vendor-specific extensions?
    </span>
    <span class="koboSpan" id="kobo.154.3">
     Are we bound to a compiler or an operating system, and are we not worried about ever needing to visit
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.155.1">
      foreign lands?
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.156.1">
     Would it save us a lot of trouble to use the managed extensions for C++, offered by adopting the Microsoft platform, or would we rather stick to the good old syntax (and types) that we know and are
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.157.1">
      familiar with?
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.158.1">
     Microsoft is famous for providing platform-specific extensions for the C and C++ languages, to the extent that there is an entire section dedicated to Microsoft-specific C++ keywords
    </span>
    <span class="superscript">
     <span id="footnote-005-backlink">
      <a class="_idFootnoteLink _idGenColorInherit" href="B22235_02.xhtml#footnote-005">
       <span class="koboSpan" id="kobo.159.1">
        3
       </span>
      </a>
     </span>
    </span>
    <span class="koboSpan" id="kobo.160.1">
     .
    </span>
    <span class="koboSpan" id="kobo.160.2">
     This tells us that there is a market for non-standard C++, and with just cause, because some of these extensions are very handy, at the expense of binding ourselves to a platform, compiler,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.161.1">
      and toolchain.
     </span>
    </span>
   </p>
   <div class="_idFootnote" epub:type="footnote" id="footnote-005">
    <p class="Basic-Paragraph">
     <a class="_idFootnoteAnchor _idGenColorInherit" href="B22235_02.xhtml#footnote-005-backlink">
      <span class="koboSpan" id="kobo.162.1">
       3
      </span>
     </a>
     <a href="https://learn.microsoft.com/en-us/cpp/cpp/keywords-cpp?view=msvc-170">
      <span class="koboSpan" id="kobo.163.1">
       https://learn.microsoft.com/en-us/cpp/cpp/keywords-cpp?view=msvc-170
      </span>
     </a>
    </p>
   </div>
   <p>
    <span class="koboSpan" id="kobo.164.1">
     One of the
    </span>
    <a id="_idIndexMarker041">
    </a>
    <span class="koboSpan" id="kobo.165.1">
     Microsoft extensions manifests itself within the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.166.1">
      __declspec
     </span>
    </strong>
    <span class="koboSpan" id="kobo.167.1">
     keyword.
    </span>
    <span class="koboSpan" id="kobo.167.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.168.1">
      __declspec
     </span>
    </strong>
    <span class="koboSpan" id="kobo.169.1">
     keyword in C and C++ is part of Microsoft’s extended C++ syntax, which allows developers to specify Microsoft-specific storage-class attributes for certain
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.170.1">
      C++ constructs.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.171.1">
     This keyword provides additional control over behaviors such as DLL exporting and memory alignment, which are not covered by the standard ANSI keywords such as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.172.1">
      static
     </span>
    </strong>
    <span class="koboSpan" id="kobo.173.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.174.1">
      extern
     </span>
    </strong>
    <span class="koboSpan" id="kobo.175.1">
     .
    </span>
    <span class="koboSpan" id="kobo.175.2">
     By using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.176.1">
      __declspec
     </span>
    </strong>
    <span class="koboSpan" id="kobo.177.1">
     , developers can easily and non-standard compliantly apply these features specific to Microsoft’s own compiler (behold: a surprise follows!) to their code, enhancing the capabilities and performance of their code, such as in the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.178.1">
      code sequence:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.179.1">
struct person {
   void set_age(int page) { m_age = page; }
   int get_age() const { return m_age; }
   __declspec (property(get = get_age, put = set_age)) int age;
   person() = default;
private:
   int m_age;
};
int main() {
   person joe;
   joe.age = 12;
   std::cout &lt;&lt; "Hello " &lt;&lt; joe.age;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.180.1">
     Using Microsoft’s
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.181.1">
      __declspec(property(...))
     </span>
    </strong>
    <span class="koboSpan" id="kobo.182.1">
     syntax, the preceding code sequence creates an
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.183.1">
      age
     </span>
    </strong>
    <span class="koboSpan" id="kobo.184.1">
     property that allows indirect interaction with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.185.1">
      m_
     </span>
    </strong>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.186.1">
      age
     </span>
    </strong>
    <span class="koboSpan" id="kobo.187.1">
     through the methods provided, properly encapsulating the age data while providing a simplified interface for accessing and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.188.1">
      modifying it.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.189.1">
     The list of
    </span>
    <a id="_idIndexMarker042">
    </a>
    <span class="koboSpan" id="kobo.190.1">
     attributes that one can harness with the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.191.1">
      __declspec
     </span>
    </strong>
    <span class="koboSpan" id="kobo.192.1">
     extension is quite long and pragmatic, and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.193.1">
      __declspec
     </span>
    </strong>
    <span class="koboSpan" id="kobo.194.1">
     also seems to be catchy in the compiler development world.
    </span>
    <span class="koboSpan" id="kobo.194.2">
     In fact, it’s so
    </span>
    <a id="_idIndexMarker043">
    </a>
    <span class="koboSpan" id="kobo.195.1">
     catchy that
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.196.1">
      Clang
     </span>
    </strong>
    <span class="koboSpan" id="kobo.197.1">
     provides an argument dedicated to understanding this Microsoft-specific extension.
    </span>
    <span class="koboSpan" id="kobo.197.2">
     This flag,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.198.1">
      -fdeclspec
     </span>
    </strong>
    <span class="koboSpan" id="kobo.199.1">
     , makes it possible to use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.200.1">
      __declspec
     </span>
    </strong>
    <span class="koboSpan" id="kobo.201.1">
     keyword in code compiled by Clang too.
    </span>
    <span class="koboSpan" id="kobo.201.2">
     So, the question naturally arises: is this a Microsoft-specific extension anymore, or are we witnessing the emergence of a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.202.1">
      cross-platform feature?
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.203.1">
     A truth that is still considered to be taboo in hardcore C++ programmer circles is that in real life, rare are the situations, when one needs to write true cross-platform code.
    </span>
    <span class="koboSpan" id="kobo.203.2">
     Most programmers work for a specific company, developing or supporting a particular product.
    </span>
    <span class="koboSpan" id="kobo.203.3">
     They’ll mostly use one operating system, with one compiler toolchain, complying with the restrictions imposed by their employer and happily compiling their code using all the extensions their
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.204.1">
      compiler supports.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.205.1">
     This does not mean they don’t explicitly want to write standard compliant C++ code.
    </span>
    <span class="koboSpan" id="kobo.205.2">
     No, on the contrary, I believe they write the highest quality code they can come up with.
    </span>
    <span class="koboSpan" id="kobo.205.3">
     This just means that they merely use the possibilities provided by a specific compiler: the one they have to work with.
    </span>
    <span class="koboSpan" id="kobo.205.4">
     At their next company, there is a high chance that they will be using a
    </span>
    <a id="_idIndexMarker044">
    </a>
    <span class="koboSpan" id="kobo.206.1">
     different compiler that runs on a different OS, thus forgetting all about the advantages provided by their ex-compiler at their ex-place.
    </span>
    <span class="koboSpan" id="kobo.206.2">
     This is because compiler-specific syntax and extensions are not bound to one
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.207.1">
      compiler exclusively.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.208.1">
     Let’s consider the following code sample,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.209.1">
      for example:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.210.1">
char arr[6] = {'a', 'b', "cde"};</span></pre>
   <p>
    <span class="koboSpan" id="kobo.211.1">
     Other than hurting our eyes, this sequence is obviously as standard and non-conformant as possible.
    </span>
    <span class="koboSpan" id="kobo.211.2">
     Who in their right mind would ever attempt to initialize an array of 6 chars like this?
    </span>
    <span class="koboSpan" id="kobo.211.3">
     However, the Microsoft Visual C++ compiler happily digests it.
    </span>
    <span class="koboSpan" id="kobo.211.4">
     Let’s start with a few normal characters, and when we get bored of typing in all the apostrophes and commas, we’ll just throw everything else in a constant string literal, because why not?
    </span>
    <span class="koboSpan" id="kobo.211.5">
     And it is quite clever about it, detecting the size that was requested for the array and matching it to the accumulated length of the parts, signaling an error if there are
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.212.1">
      any mismatches.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.213.1">
     Microsoft’s C++ compiler is a very innovative one when it comes to adding features not found in the standard, or allowing code that would break a language lawyer’s tongue.
    </span>
    <span class="koboSpan" id="kobo.213.2">
     Let’s look at the following piece of code,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.214.1">
      for example:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.215.1">
class person {
public:
   int age;
   class {
   public:
       std::string name;
   };
};</span></pre>
   <p>
    <span class="koboSpan" id="kobo.216.1">
     This code sequence is anything but standard C++.
    </span>
    <span class="koboSpan" id="kobo.216.2">
     Its sheer existence even allows us to write code that looks like
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.217.1">
      the following:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.218.1">
int main() {
   person joe;
   joe.name = "Joe";
   std::cout &lt;&lt; "Hello " &lt;&lt; joe.name;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.219.1">
     The preceding example compiles and runs without any issues when compiled using Microsoft’s own C++ compiler.
    </span>
    <span class="koboSpan" id="kobo.219.2">
     Please carefully observe the anonymous class, which contains the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.220.1">
      name
     </span>
    </strong>
    <span class="koboSpan" id="kobo.221.1">
     member, is an object that has a constructor..
    </span>
    <span class="koboSpan" id="kobo.221.2">
     This is an object that has a constructor, a destructor, and lots of other interesting features.
    </span>
    <span class="koboSpan" id="kobo.221.3">
     This is another (very handy, if I may say so) Microsoft deviation from the
    </span>
    <a id="_idIndexMarker045">
    </a>
    <span class="koboSpan" id="kobo.222.1">
     standard because anonymous unions are a well-known beast of C++.
    </span>
    <span class="koboSpan" id="kobo.222.2">
     However, anonymous structs only dwell in the C language (starting from C11) and no other compiler accepts the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.223.1">
      preceding code.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.224.1">
     As a side note, if you’re not familiar with the notion of anonymous structs in the C language, they are a useful feature for simplifying nested structure declarations.
    </span>
    <span class="koboSpan" id="kobo.224.2">
     They do not require the naming of inner structs when they are not needed elsewhere, and they make the code more concise and readable.
    </span>
    <span class="koboSpan" id="kobo.224.3">
     While the members are enclosed in a structure, it is still possible to have direct access to them.
    </span>
    <span class="koboSpan" id="kobo.224.4">
     By encapsulating related fields within anonymous structs, and introducing logical blocks within these members, the cluttering of the code with unnecessary type definitions becomes
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.225.1">
      less overwhelming.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-32">
    <a id="_idTextAnchor031">
    </a>
    <span class="koboSpan" id="kobo.226.1">
     The realm of free compilers
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.227.1">
     Two of the three
    </span>
    <a id="_idIndexMarker046">
    </a>
    <span class="koboSpan" id="kobo.228.1">
     major compilers today are developed and maintained in an open-source manner.
    </span>
    <span class="koboSpan" id="kobo.228.2">
     This means that, in theory, anyone can contribute and provide useful new features to their compiler of choice.
    </span>
    <span class="koboSpan" id="kobo.228.3">
     However, in practice, it means that there is a tiny core of professional programmers who have the necessary knowledge and dedication, and also the backing of a large corporation benefiting from the development of the aforementioned compiler working
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.229.1">
      on it.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.230.1">
     In no particular order, GCC and Clang (and MSVC, which we discussed in the previous section) are the most standard-compliant compilers as of 2024.
    </span>
    <span class="koboSpan" id="kobo.230.2">
     This standard compliance, however, does not mean that these compilers don’t come with their own perks that a developer once thought would be a great idea
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.231.1">
      to incorporate.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.232.1">
     Let’s take, for example, the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.233.1">
      computed goto
     </span>
    </strong>
    <span class="koboSpan" id="kobo.234.1">
     feature of GCC (and Clang too, of course; those two tend to go hand in hand).
    </span>
    <span class="koboSpan" id="kobo.234.2">
     We all have learned in school that
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.235.1">
      goto
     </span>
    </strong>
    <span class="koboSpan" id="kobo.236.1">
     is just plain evil, and should
    </span>
    <a id="_idIndexMarker047">
    </a>
    <span class="koboSpan" id="kobo.237.1">
     not be ever used.
    </span>
    <span class="koboSpan" id="kobo.237.2">
     If you did not learn this in school, please do not learn it from this book.
    </span>
    <span class="koboSpan" id="kobo.237.3">
     That’s because it is, again, not true.
    </span>
    <span class="koboSpan" id="kobo.237.4">
     Instead, let’s focus
    </span>
    <a id="_idIndexMarker048">
    </a>
    <span class="koboSpan" id="kobo.238.1">
     on what we can think of the computed
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.239.1">
      goto
     </span>
    </strong>
    <span class="koboSpan" id="kobo.240.1">
     .
    </span>
    <span class="koboSpan" id="kobo.240.2">
     If
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.241.1">
      goto
     </span>
    </strong>
    <span class="koboSpan" id="kobo.242.1">
     is evil, then is computed
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.243.1">
      goto
     </span>
    </strong>
    <span class="koboSpan" id="kobo.244.1">
     calculated evil?
    </span>
    <span class="koboSpan" id="kobo.244.2">
     So is the following code sequence pure evil, or calculated evil?
    </span>
    <span class="koboSpan" id="kobo.244.3">
     Let’s have
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.245.1">
      a look:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.246.1">
int main() {
   std::vector&lt;void*&gt; labels = { &amp;&amp;start, &amp;&amp;state1, &amp;&amp;state2, &amp;&amp;end };
   int state = 0;
   goto *labels[state];
   start:
       std::cout &lt;&lt; "In start state" &lt;&lt; std::endl;
       state = 1;
       goto *labels[state];
   state1:
       std::cout &lt;&lt; "In state 1" &lt;&lt; std::endl;
       state = 2;
       goto *labels[state];
   state2:
       std::cout &lt;&lt; "In state 2" &lt;&lt; std::endl;
       state = 3;
       goto *labels[state];
   end:
       std::cout &lt;&lt; "In end state" &lt;&lt; std::endl;
       return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.247.1">
     There is nothing wrong with the first line.
    </span>
    <span class="koboSpan" id="kobo.247.2">
     The problems start after that.
    </span>
    <span class="koboSpan" id="kobo.247.3">
     This very handy feature can be used for implementing interpreters or state machines efficiently and in a non-standard manner by allowing jumps to labels based on the value of a pointer, initialized from the address of the label itself.
    </span>
    <span class="koboSpan" id="kobo.247.4">
     Since we are dealing with pointers, it is entirely possible to use the dreaded pointer arithmetic and do some calculations on
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.248.1">
      the addresses.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.249.1">
     Also, this can be a dangerous feature if not used properly.
    </span>
    <span class="koboSpan" id="kobo.249.2">
     Unlike in the case of the standard
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.250.1">
      goto
     </span>
    </strong>
    <span class="koboSpan" id="kobo.251.1">
     , the calculated one does not take into calculation the objects whose lifetime ends upon leaving a specific scope.
    </span>
    <span class="koboSpan" id="kobo.251.2">
     So, no destructors are called.
    </span>
    <span class="koboSpan" id="kobo.251.3">
     Consider
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.252.1">
      yourself warned!
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.253.1">
     Another pretty useful
    </span>
    <a id="_idIndexMarker049">
    </a>
    <span class="koboSpan" id="kobo.254.1">
     deviation from the standard C++ syntax comes from GCC (and again, it’s implemented by Clang too, what a surprise), which makes the following code sequence compilable with these
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.255.1">
      two compilers:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.256.1">
int y = ({ int x = 10; x + 5; });</span></pre>
   <p>
    <span class="koboSpan" id="kobo.257.1">
     Neat, ain’t it?
    </span>
    <span class="koboSpan" id="kobo.257.2">
     This feature is called
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.258.1">
      Statements and Declarations in Expressions
     </span>
    </em>
    <span class="koboSpan" id="kobo.259.1">
     and has all the benefits that you can think of: nice encapsulation of the objects declared inside, and somewhat safer macros if used properly.
    </span>
    <span class="koboSpan" id="kobo.259.2">
     It’s too bad it is not
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.260.1">
      standard C++.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.261.1">
     Clang, the new kid on the block (well, if we can call a 15-year-old compiler the “new” kid, although compared to GCC, with a birth date dating back to 1987, Clang is still a very young, albeit skilled, player in the field) takes the feature fight a bit further.
    </span>
    <span class="koboSpan" id="kobo.261.2">
     The following piece of code only compiles with Clang, with the benefit of a very special library and a new command line switch to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.262.1">
      the compiler:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.263.1">
#include &lt;iostream&gt;
int main() {
   int (^square)(int) = ^(int num) { return num * num; };
   int y = square(12);
   std::cout &lt;&lt; y &lt;&lt; std::endl;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.264.1">
     This feature
    </span>
    <a id="_idIndexMarker050">
    </a>
    <span class="koboSpan" id="kobo.265.1">
     is called
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.266.1">
      Blocks
     </span>
    </strong>
    <span class="koboSpan" id="kobo.267.1">
     in Clang.
    </span>
    <span class="koboSpan" id="kobo.267.2">
     In order to get it right, you will need to install the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.268.1">
      BlocksRuntime
     </span>
    </strong>
    <span class="superscript">
     <span id="footnote-004-backlink">
      <a class="_idFootnoteLink _idGenColorInherit" href="B22235_02.xhtml#footnote-004">
       <span class="koboSpan" id="kobo.269.1">
        4
       </span>
      </a>
     </span>
    </span>
    <span class="koboSpan" id="kobo.270.1">
     library, then specify a special
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.271.1">
      -fblocks
     </span>
    </strong>
    <span class="koboSpan" id="kobo.272.1">
     flag to Clang, and, after all this blocking has been done, we can finally compile the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.273.1">
      preceding code.
     </span>
    </span>
   </p>
   <div class="_idFootnote" epub:type="footnote" id="footnote-004">
    <p class="Basic-Paragraph">
     <a class="_idFootnoteAnchor _idGenColorInherit" href="B22235_02.xhtml#footnote-004-backlink">
      <span class="koboSpan" id="kobo.274.1">
       4
      </span>
     </a>
     <a href="https://github.com/mackyle/blocksruntime">
      <span class="koboSpan" id="kobo.275.1">
       https://github.com/mackyle/blocksruntime
      </span>
     </a>
    </p>
   </div>
   <p>
    <span class="koboSpan" id="kobo.276.1">
     This pretty much resembles the behavior of a standard C++11 lambda, but considering that this feature was created and introduced in Clang in 2008, we might call this the father of the
    </span>
    <a id="_idIndexMarker051">
    </a>
    <span class="koboSpan" id="kobo.277.1">
     standard C++ lambda.
    </span>
    <span class="koboSpan" id="kobo.277.2">
     In case you’re curious, the standard C++ lambda providing the same functionality is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.278.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.279.1">
auto square = [](int num) -&gt;int { return num * num; };</span></pre>
   <p>
    <span class="koboSpan" id="kobo.280.1">
     That’s not black magic, unlike the following piece
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.281.1">
      of code:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.282.1">
auto generate(int n) -&gt; std::vector&lt;int&gt;{
   int array[n] = {0};
   for(int i=0; i&lt;n; i++) array[i] = i;
   return std::vector&lt;int&gt;{array, array + n};
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.283.1">
     So, in case you
    </span>
    <a id="_idIndexMarker052">
    </a>
    <span class="koboSpan" id="kobo.284.1">
     are wondering what is happening there, here’s just a small refresher of your C++ freshman memories: under no circumstances is
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.285.1">
      int array[n] = {0};
     </span>
    </strong>
    <span class="koboSpan" id="kobo.286.1">
     standard C++.
    </span>
    <span class="koboSpan" id="kobo.286.2">
     The
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.287.1">
      variable length array
     </span>
    </strong>
    <span class="koboSpan" id="kobo.288.1">
     is a feature present in C, but the C++ standard does not include it due to various safety considerations.
    </span>
    <span class="koboSpan" id="kobo.288.2">
     Regardless, the preceding code is accepted by the GCC compiler, but Clang complains
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.289.1">
      about it:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.290.1">
error: variable-sized object may not be initialized
   5 |     int array[n] = {0};</span></pre>
   <p>
    <span class="koboSpan" id="kobo.291.1">
     According to the error message, the fix
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.292.1">
      is easy:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.293.1">
auto generate(int n) -&gt; std::vector&lt;int&gt;{
   int array[n];
   for(int i=0; i&lt;n; i++) array[i] = i;
   return std::vector&lt;int&gt;{array, array + n};
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.294.1">
     Now, even Clang (and several other compilers, such as ICC) accept it, regardless of the state of
    </span>
    <a id="_idIndexMarker053">
    </a>
    <span class="koboSpan" id="kobo.295.1">
     standardness of the code… or rather, the lack
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.296.1">
      of it.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-33">
    <a id="_idTextAnchor032">
    </a>
    <span class="koboSpan" id="kobo.297.1">
     A tribute to attributes
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.298.1">
     Both GCC and Clang (and also Microsoft Visual C++) can, however, agree on the usefulness of one very specific extension to the C++ language: we need a way to attach metadata
    </span>
    <a id="_idIndexMarker054">
    </a>
    <span class="koboSpan" id="kobo.299.1">
     to some of the language constructs (such as types, functions, variables, etc.).
    </span>
    <span class="koboSpan" id="kobo.299.2">
     This metadata can then be used by the compiler and other tools to generate optimized code, perform checks, or provide
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.300.1">
      other features.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.301.1">
     Before modern C++ (i.e., C++11) introduced the standardized way to specify attributes using the double square bracket syntax
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.302.1">
      [[attribute]]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.303.1">
     , each compiler had their own way of specifying these so
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.304.1">
      required attributes:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.305.1">
      GCC and Clang
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.306.1">
       used
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.307.1">
        __attribute__((attribute-name))
       </span>
      </strong>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.308.1">
      Microsoft Visual C++
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.309.1">
       used
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.310.1">
        __declspec(attribute-name)
       </span>
      </strong>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.311.1">
     With the release of C++11, however, the standardization committee realized the usefulness of these, and lifted the most applicable attributes into the language (such as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.312.1">
      [[noreturn]]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.313.1">
     ) while later improvements to the standard added even more attributes (such as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.314.1">
      [[fallthrough]]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.315.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.316.1">
      [[nodiscard]]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.317.1">
     , etc.).
    </span>
    <span class="koboSpan" id="kobo.317.2">
     However, a lot of these attributes remained confined to the compilers that have introduced them.
    </span>
    <span class="koboSpan" id="kobo.317.3">
     The following code snippet showcases some
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.318.1">
      of these:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.319.1">
void old_function() __attribute__((deprecated));
void fatal_error() __attribute__((noreturn));
int pure_function(int x) __attribute__((pure));
int x __attribute__((aligned(16)));
void old_function() {
   std::cout &lt;&lt; "This function is deprecated.";
}
void fatal_error() {
   std::cerr &lt;&lt; "This function does not return.";
   exit(1);
}
int pure_function(int x) {
   return x * x;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.320.1">
     The code
    </span>
    <a id="_idIndexMarker055">
    </a>
    <span class="koboSpan" id="kobo.321.1">
     sequence above contains a few attributes shared by GCC and Clang, such as
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.322.1">
      the following:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.323.1">
       __attribute__((deprecated))
      </span>
     </strong>
     <span class="koboSpan" id="kobo.324.1">
      marks
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.325.1">
       old_function
      </span>
     </strong>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.326.1">
       as deprecated
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.327.1">
       __attribute__((noreturn))
      </span>
     </strong>
     <span class="koboSpan" id="kobo.328.1">
      is used to indicate that
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.329.1">
       fatal_error
      </span>
     </strong>
     <span class="koboSpan" id="kobo.330.1">
      does
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.331.1">
       not return
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.332.1">
       __attribute__((pure))
      </span>
     </strong>
     <span class="koboSpan" id="kobo.333.1">
      is used to indicate that
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.334.1">
       pure_function
      </span>
     </strong>
     <span class="koboSpan" id="kobo.335.1">
      has no side effects except for its
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.336.1">
       return value
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.337.1">
       __attribute__((aligned(16)))
      </span>
     </strong>
     <span class="koboSpan" id="kobo.338.1">
      is used to align the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.339.1">
       x
      </span>
     </strong>
     <span class="koboSpan" id="kobo.340.1">
      variable to a
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.341.1">
       16-byte boundary
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.342.1">
     The list of attributes these compilers
    </span>
    <span class="superscript">
     <span id="footnote-003-backlink">
      <a class="_idFootnoteLink _idGenColorInherit" href="B22235_02.xhtml#footnote-003">
       <span class="koboSpan" id="kobo.343.1">
        5
       </span>
      </a>
     </span>
    </span>
    <span class="koboSpan" id="kobo.344.1">
     provide is huge
    </span>
    <span class="superscript">
     <span id="footnote-002-backlink">
      <a class="_idFootnoteLink _idGenColorInherit" href="B22235_02.xhtml#footnote-002">
       <span class="koboSpan" id="kobo.345.1">
        6
       </span>
      </a>
     </span>
    </span>
    <span class="koboSpan" id="kobo.346.1">
     , and we can highly recommend that if you are in a situation where you are working with one of these compilers on a very specific platform, and your main concern is not code portability, platform independence, and standard compliance, then you should go and check them out.
    </span>
    <span class="koboSpan" id="kobo.346.2">
     That’s because a lot of power can be harnessed by properly using the tools your compiler provides
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.347.1">
      you with.
     </span>
    </span>
   </p>
   <div class="_idFootnote" epub:type="footnote" id="footnote-003">
    <p class="Basic-Paragraph">
     <a class="_idFootnoteAnchor _idGenColorInherit" href="B22235_02.xhtml#footnote-003-backlink">
      <span class="koboSpan" id="kobo.348.1">
       5
      </span>
     </a>
     <a href="https://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html">
      <span class="koboSpan" id="kobo.349.1">
       https://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html
      </span>
     </a>
    </p>
    <div class="_idFootnote" epub:type="footnote" id="footnote-002">
     <p class="Basic-Paragraph">
      <a class="_idFootnoteAnchor _idGenColorInherit" href="B22235_02.xhtml#footnote-002-backlink">
       <span class="koboSpan" id="kobo.350.1">
        6
       </span>
      </a>
      <a href="https://clang.llvm.org/docs/AttributeReference.html">
       <span class="koboSpan" id="kobo.351.1">
        https://clang.llvm.org/docs/AttributeReference.html
       </span>
      </a>
     </p>
    </div>
   </div>
   <h1 id="_idParaDest-34">
    <a id="_idTextAnchor033">
    </a>
    <span class="koboSpan" id="kobo.352.1">
     When the header is not even C++
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.353.1">
     The long list of standard-non-compliant-but-still-working-and-useful features does not end with the preceding examples.
    </span>
    <span class="koboSpan" id="kobo.353.2">
     However, if we had only focused our attention on those, we could still have filled several books with them.
    </span>
    <span class="koboSpan" id="kobo.353.3">
     Sadly, for the moment, we have only dedicated one chapter to this topic, so let’s move our attention to somewhat more
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.354.1">
      exotic features.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.355.1">
     Qt has been the de-facto cross-platform programming framework for GUI applications (but not only) for quite some time.
    </span>
    <span class="koboSpan" id="kobo.355.2">
     Throughout its fateful history, while exchanging owners several times since its inception in 1994, the Qt framework has evolved significantly, with each release giving a new set of features to the C++ (but not only) programming community.
    </span>
    <span class="koboSpan" id="kobo.355.3">
     However, one feature has remained more or less the same: the signal/slot
    </span>
    <a id="_idIndexMarker056">
    </a>
    <span class="koboSpan" id="kobo.356.1">
     implementation and the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.357.1">
      Meta Object Compiler
     </span>
    </strong>
    <span class="koboSpan" id="kobo.358.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.359.1">
      MOC
     </span>
    </strong>
    <span class="koboSpan" id="kobo.360.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.360.2">
     The pillar of the framework, the MOC makes it possible to connect events from components (i.e., signals) to receivers (i.e., slots) for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.361.1">
      proper handling.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.362.1">
     However, this very
    </span>
    <a id="_idIndexMarker057">
    </a>
    <span class="koboSpan" id="kobo.363.1">
     handy feature comes at the expense of having to support several non-C++ constructs, which makes the connection between seemingly unrelated elements of the application possible.
    </span>
    <span class="koboSpan" id="kobo.363.2">
     For example, the class declaration of objects that must respond to an event is extended by several non-standard “access modifiers”, such as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.364.1">
      signals:
     </span>
    </strong>
    <span class="koboSpan" id="kobo.365.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.366.1">
      private slots:
     </span>
    </strong>
    <span class="koboSpan" id="kobo.367.1">
     , and so on.
    </span>
    <span class="koboSpan" id="kobo.367.2">
     Also, there is a new
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.368.1">
      keyword
     </span>
    </strong>
    <span class="koboSpan" id="kobo.369.1">
     called
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.370.1">
      emit
     </span>
    </strong>
    <span class="koboSpan" id="kobo.371.1">
     , which makes
    </span>
    <a id="_idIndexMarker058">
    </a>
    <span class="koboSpan" id="kobo.372.1">
     it possible to, well,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.373.1">
      emit signals.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.374.1">
     Long story short, the following is an excerpt from a header file, making the compilation of the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.375.1">
      code possible:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.376.1">
#ifndef MYCONTROL_H
#define MYCONTROL_H
#include &lt;QObject&gt;
#include &lt;QPushButton&gt;
#include &lt;QWidget&gt;
class MyControl : public QWidget {
   Q_OBJECT
public:
   MyControl(QWidget *parent = nullptr);
private slots:
   void onButtonClicked();
signals:
   void nameChanged(const QString &amp;name);
private:
   QPushButton *myButton;
};
#endif</span></pre>
   <p>
    <span class="koboSpan" id="kobo.377.1">
     Should we adopt the luxury provided to us by Qt and use the very convenient signal/slot mechanism with the drawback that we have to write non-standard C++ code?
    </span>
    <span class="koboSpan" id="kobo.377.2">
     Or would we rather stick to tradition and create every little button and connection by writing pure C++ code, as we would do
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.378.1">
      in GTK?
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.379.1">
     This chapter cannot
    </span>
    <a id="_idIndexMarker059">
    </a>
    <span class="koboSpan" id="kobo.380.1">
     answer this question because, in the end, it is up to every project’s specific requirements.
    </span>
    <span class="koboSpan" id="kobo.380.2">
     Those include what is imposed by the environment, what the project stakeholders expect from it, and how the development team decides the path forward.
    </span>
    <span class="koboSpan" id="kobo.380.3">
     However, despair not: even if this does not feel like standard C++, it solves a very real-life problem.
    </span>
    <span class="koboSpan" id="kobo.380.4">
     Behind the scenes, there hides a cutting-edge implementation, which has been tested, approved, improved, and used in several small- and large-scale projects.
    </span>
    <span class="koboSpan" id="kobo.380.5">
     It has stood the test
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.381.1">
      of time.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.382.1">
     Microsoft’s own large-scale extension to the C++ language comes from a different approach.
    </span>
    <span class="koboSpan" id="kobo.382.2">
     While not being a specific tool such as Qt’s MOC, C++/CLI extends C++ with .NET-specific
    </span>
    <a id="_idIndexMarker060">
    </a>
    <span class="koboSpan" id="kobo.383.1">
     syntax.
    </span>
    <span class="koboSpan" id="kobo.383.2">
     The Visual Studio compiler for C++/
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.384.1">
      CLI
     </span>
    </strong>
    <span class="koboSpan" id="kobo.385.1">
     (as in,
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.386.1">
      Common Language Infrastructure
     </span>
    </strong>
    <span class="koboSpan" id="kobo.387.1">
     , not Command Line Interface) can parse this extended syntax and generate valid Common Intermediate Language (which is a low-level, platform-independent instruction set used by the .NET framework) and native code.
    </span>
    <span class="koboSpan" id="kobo.387.2">
     The following code sequence is an example of this managed C++.
    </span>
    <span class="koboSpan" id="kobo.387.3">
     It does nothing special; it just concatenates the elements of an array of strings and prints
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.388.1">
      the result:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.389.1">
#include &lt;iostream&gt;
#include &lt;atlstr.h&gt;
#include &lt;stdio.h&gt;
using namespace System;
int main() {
   array&lt;String^&gt;^ args = { "managed", "world" };
   String^ s = "Hello";
   for each (String ^ a in args) s += " " + a ;
   CString cs(s);
   wprintf(cs);
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.390.1">
     I totally agree; it is anything but standard C++.
    </span>
    <span class="koboSpan" id="kobo.390.2">
     It does not look like standard C++, it does not feel like
    </span>
    <a id="_idIndexMarker061">
    </a>
    <span class="koboSpan" id="kobo.391.1">
     standard C++, and it doesn’t even quack like standard C++.
    </span>
    <span class="koboSpan" id="kobo.391.2">
     So, it must not be that.
    </span>
    <span class="koboSpan" id="kobo.391.3">
     The standard-compliant C++ code having the same functionality would look like
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.392.1">
      the following:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.393.1">
#include &lt;array&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
int main() {
   std::array&lt;std::string, 2&gt; args = { "unmanaged", "world" };
   std::string s = "Hello";
   for(const auto&amp; a : args) {
       s += " " + a ;
   }
   std::cout &lt;&lt; s;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.394.1">
     Isn’t it nicer, shorter, and more concise than the previous one?
    </span>
    <span class="koboSpan" id="kobo.394.2">
     Not to mention the fact that it is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.395.1">
      also standard-conformant.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.396.1">
     It will be interesting to observe the evolution of the managed extensions of C++ in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.397.1">
      the future.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.398.1">
     Right now, it serves as a bridge between native and managed code, which is a very niche field for the moment.
    </span>
    <span class="koboSpan" id="kobo.398.2">
     However, in the long term, its survival is heavily dependent on how the
    </span>
    <a id="_idIndexMarker062">
    </a>
    <span class="koboSpan" id="kobo.399.1">
     developer communities will embrace it (or not), whether the ecosystem it has created will be of enough use to keep it alive, or whether other technologies, such as P/Invoke or COM Interop, will take over the specific uses cases that C++/CLI handles
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.400.1">
      right now.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.401.1">
     There are interesting times
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.402.1">
      ahead, indeed.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-35">
    <a id="_idTextAnchor034">
    </a>
    <span class="koboSpan" id="kobo.403.1">
     The curious case of C++ locked in a box
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.404.1">
     Up until now, we have observed cases where the standard compliance was at the developers’ own discretion.
    </span>
    <span class="koboSpan" id="kobo.404.2">
     They had the option to choose their platform, use the extensions provided by their favorite compiler, or go for pure standard C++.
    </span>
    <span class="koboSpan" id="kobo.404.3">
     However, out there in
    </span>
    <a id="_idIndexMarker063">
    </a>
    <span class="koboSpan" id="kobo.405.1">
     the wild wide world, there are certain circumstances wherein we cannot fully comply with the standard due to some restrictions imposed upon us by the environment that disallows the usage of certain features found in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.406.1">
      C++ standard.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.407.1">
     Not considering obscene scenarios, when we must maintain decades-old legacy code written in the golden age of C++ (i.e., before the standardization committee took over and ruined all the fun by demanding standard compliance, in order to avert the uncontrollable spread of C++ dialects as happened with
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.408.1">
      BASIC
     </span>
    </strong>
    <span class="koboSpan" id="kobo.409.1">
     ), there are situations outside of our control that make the usage of the full C++ standard features impossible.
    </span>
    <span class="koboSpan" id="kobo.409.2">
     For example, there might be certain requirements that disallow the usage of exceptions.
    </span>
    <span class="koboSpan" id="kobo.409.3">
     Other environments may lack the proper support for memory allocation, while others still simply force us to write to direct hardware addresses in order for something to happen.
    </span>
    <span class="koboSpan" id="kobo.409.4">
     However, this last one can happen in a standard-compliant
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.410.1">
      way too.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.411.1">
     Some embedded systems, for example, actively encourage the usage of their platform-specific assembly instructions.
    </span>
    <span class="koboSpan" id="kobo.411.2">
     As we know, there is no such thing as a platform-independent assembly language because that is the lowest level one can go to in today’s C++.
    </span>
    <span class="koboSpan" id="kobo.411.3">
     Below that is pure hexadecimal machine code, but long gone are the times when we had to use that in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.412.1">
      C++ code.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.413.1">
     There might also be scenarios wherein the requirements formulated for our code by the hardware require deterministic behavior.
    </span>
    <span class="koboSpan" id="kobo.413.2">
     This, by definition, excludes exceptions (because who would like to be unable to follow the code flow at every nanosecond during its execution?) and memory allocations (because of allocation latency, memory fragmentation, and a myriad of other issues your code is again not behaving in a deterministic manner).
    </span>
    <span class="koboSpan" id="kobo.413.3">
     Thus, a large chunk of the C++ standard falls out of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.414.1">
      our grace.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.415.1">
     There are certain solutions tackling the problem of memory allocation in embedded systems, such as the usage of memory pools, object pools, compile time memory allocation, and various other resources, which may be even platform-specific in turn.
    </span>
    <span class="koboSpan" id="kobo.415.2">
     Then there are the exceptions.
    </span>
    <span class="koboSpan" id="kobo.415.3">
     In his excellent paper
    </span>
    <span class="superscript">
     <span id="footnote-001-backlink">
      <a class="_idFootnoteLink _idGenColorInherit" href="B22235_02.xhtml#footnote-001">
       <span class="koboSpan" id="kobo.416.1">
        7
       </span>
      </a>
     </span>
    </span>
    <span class="koboSpan" id="kobo.417.1">
     , Bjarne Stroustrup discusses the challenges, costs, and risks involved in replacing C++ exceptions with alternatives such as deterministic exceptions.
    </span>
    <span class="koboSpan" id="kobo.417.2">
     However, as the paper concludes, at this moment, there are no clear advantages
    </span>
    <a id="_idIndexMarker064">
    </a>
    <span class="koboSpan" id="kobo.418.1">
     to replacing the current exception-handling mechanisms with something else.
    </span>
    <span class="koboSpan" id="kobo.418.2">
     That would include another fragmentation in the C++ developer community, as if there aren’t enough of those already.
    </span>
    <span class="koboSpan" id="kobo.418.3">
     Instead, the paper argues for the importance of focusing on enhancing the current exception-handling system rather than complicating the language with additional mechanisms, emphasizing that exceptions, despite their imperfections, have effectively served a vast number of developers
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.419.1">
      for decades.
     </span>
    </span>
   </p>
   <div class="_idFootnote" epub:type="footnote" id="footnote-001">
    <p class="Basic-Paragraph">
     <a class="_idFootnoteAnchor _idGenColorInherit" href="B22235_02.xhtml#footnote-001-backlink">
      <span class="koboSpan" id="kobo.420.1">
       7
      </span>
     </a>
     <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1947r0.pdf">
      <span class="koboSpan" id="kobo.421.1">
       https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1947r0.pdf
      </span>
     </a>
    </p>
   </div>
   <h1 id="_idParaDest-36">
    <a id="_idTextAnchor035">
    </a>
    <span class="koboSpan" id="kobo.422.1">
     Past days of future C++
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.423.1">
     The last scenario that we will explore concerning the standard compliance of the code you write
    </span>
    <a id="_idIndexMarker065">
    </a>
    <span class="koboSpan" id="kobo.424.1">
     relates to the most fundamental item in the C++ ecosystem: the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.425.1">
      compiler itself.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.426.1">
     You see, compilers are also programs, consisting of millions and millions of lines of code.
    </span>
    <span class="koboSpan" id="kobo.426.2">
     There are several contributors spread out on the globe working on them, adding new features, fixing bugs, making them more standard compliant, releasing the latest versions, and generally making sure that your compiler
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.427.1">
      just works.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.428.1">
     These compilers also have a development timeline.
    </span>
    <span class="koboSpan" id="kobo.428.2">
     The implementation of features does not happen overnight, and there simply might be situations wherein, at a certain point in time, some compiler does not support some feature of the standard because there was not enough manpower to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.429.1">
      implement it.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.430.1">
     There is a very handy document available at the source of all C++ knowledge
    </span>
    <span class="superscript">
     <span id="footnote-000-backlink">
      <a class="_idFootnoteLink _idGenColorInherit" href="B22235_02.xhtml#footnote-000">
       <span class="koboSpan" id="kobo.431.1">
        8
       </span>
      </a>
     </span>
    </span>
    <span class="koboSpan" id="kobo.432.1">
     , which details the support of various C++ standard features and which compilers have support for a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.433.1">
      specific feature.
     </span>
    </span>
   </p>
   <div class="_idFootnote" epub:type="footnote" id="footnote-000">
    <p class="Footer" lang="en-US" xml:lang="en-US">
     <a class="_idFootnoteAnchor _idGenColorInherit" href="B22235_02.xhtml#footnote-000-backlink">
      <span class="koboSpan" id="kobo.434.1">
       8
      </span>
     </a>
     <a href="https://en.cppreference.com/w/cpp/compiler_support">
      <span class="koboSpan" id="kobo.435.1">
       https://en.cppreference.com/w/cpp/compiler_support
      </span>
     </a>
    </p>
   </div>
   <p>
    <span class="koboSpan" id="kobo.436.1">
     At the turn of standards (or when forced to use outdated compilers that have not implemented some of the features yet), there have been several tricks employed by the C++ developer community to compensate for the lack of features in upcoming versions of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.437.1">
      various compilers.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.438.1">
     When the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.439.1">
      mutable
     </span>
    </strong>
    <span class="koboSpan" id="kobo.440.1">
     keyword was
    </span>
    <a id="_idIndexMarker066">
    </a>
    <span class="koboSpan" id="kobo.441.1">
     introduced in C++98, its implementation in certain compilers took a bit longer than in others.
    </span>
    <span class="koboSpan" id="kobo.441.2">
     For programmers using these compilers, it was challenging
    </span>
    <a id="_idIndexMarker067">
    </a>
    <span class="koboSpan" id="kobo.442.1">
     to modify member variables in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.443.1">
      const
     </span>
    </strong>
    <span class="koboSpan" id="kobo.444.1">
     member
    </span>
    <a id="_idIndexMarker068">
    </a>
    <span class="koboSpan" id="kobo.445.1">
     functions (a feature introduced in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.446.1">
      same standard).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.447.1">
     In situations like this, the following (quite ugly) hack had to be used to counteract the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.448.1">
      missing keyword:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.449.1">
class Counter {
   int viewCount = 0;
public:
   void view() const {
       const_cast&lt;Counter*&gt;(this)-&gt;viewCount++;
   }
   void print() const {
       std::cout &lt;&lt; "Count: " &lt;&lt; viewCount &lt;&lt; std::endl;
   }
};</span></pre>
   <p>
    <span class="koboSpan" id="kobo.450.1">
     Assuming that your computer supports
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.451.1">
      const_cast
     </span>
    </strong>
    <span class="koboSpan" id="kobo.452.1">
     , there is nothing wrong with the preceding code.
    </span>
    <span class="koboSpan" id="kobo.452.2">
     However, if
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.453.1">
      const_cast
     </span>
    </strong>
    <span class="koboSpan" id="kobo.454.1">
     is not in the list of supported keywords, then you are pretty much back to a standard C style cast, such as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.455.1">
      ((Counter*)(this))-&gt;viewCount++;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.456.1">
     .
    </span>
    <span class="koboSpan" id="kobo.456.2">
     This should fix all
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.457.1">
      your problems.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.458.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.459.1">
      mutable
     </span>
    </strong>
    <span class="koboSpan" id="kobo.460.1">
     keyword was not the first one whose lack of support in compilers caused trouble for developers.
    </span>
    <span class="koboSpan" id="kobo.460.2">
     Before C++11 introduced
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.461.1">
      constexpr
     </span>
    </strong>
    <span class="koboSpan" id="kobo.462.1">
     (and a few years after that too, for Microsoft Visual C++ programmers), compile-time constant expressions had to be evaluated
    </span>
    <a id="_idIndexMarker069">
    </a>
    <span class="koboSpan" id="kobo.463.1">
     using various template tricks (or just macros, but as we all know, they are evil, so let’s avoid them for as long as
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.464.1">
      we can).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.465.1">
     For example, the following piece of code calculated the famous factorial of some number, before
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.466.1">
      constexpr
     </span>
    </strong>
    <span class="koboSpan" id="kobo.467.1">
     (but still at
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.468.1">
      compile time):
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.469.1">
template &lt;unsigned int N&gt;
struct Factorial {
   static const unsigned long long value = N * Factorial&lt;N - 1&gt;::value;
};
template &lt;&gt;
struct Factorial&lt;0&gt; {
   static const unsigned long long value = 1;
};
const unsigned long long fac5 =  Factorial&lt;5&gt;::value;</span></pre>
   <p>
    <span class="koboSpan" id="kobo.470.1">
     The current standard implementation using a compiler that supports
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.471.1">
      constexpr
     </span>
    </strong>
    <span class="koboSpan" id="kobo.472.1">
     of the same function is certainly shorter and much easier
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.473.1">
      to understand:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.474.1">
constexpr unsigned long long factorial(unsigned int n) {
   return n &lt;= 1 ? </span><span class="koboSpan" id="kobo.474.2">1 : n * factorial(n - 1);
}
const unsigned long long fac5too =  factorial(5);</span></pre>
   <p>
    <span class="koboSpan" id="kobo.475.1">
     Certainly, a huge jump in the readability of the code, if I may
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.476.1">
      say so.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-37">
    <a id="_idTextAnchor036">
    </a>
    <span class="koboSpan" id="kobo.477.1">
     Summary
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.478.1">
     As this chapter has demonstrated, writing standard C++ ensures code portability, compatibility, and maintainability across different platforms and compilers.
    </span>
    <span class="koboSpan" id="kobo.478.2">
     We learned that by adhering to the ISO/IEC C++ standard, we can create code that behaves predictably and is less prone to bugs and platform-specific issues.
    </span>
    <span class="koboSpan" id="kobo.478.3">
     Standard-compliant C++ code also benefits from generic compiler optimizations and future language enhancements, while ensuring long-term relevance and performance, as we learned in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.479.1">
      this chapter.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.480.1">
     On the other hand, using C++ compiler-specific extensions can provide performance optimizations specific to a platform and compiler, access to advanced features that are not yet standardized, and integration with vendor-specific tools.
    </span>
    <span class="koboSpan" id="kobo.480.2">
     However, the extension may introduce portability issues, dependencies on specific compiler versions, as well as divergence from standard C++ practices, which can impact code maintenance and interoperability across different platforms and compilers.
    </span>
    <span class="koboSpan" id="kobo.480.3">
     We also covered this in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.481.1">
      this chapter.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.482.1">
     Therefore, we learned that adoption should be carefully considered based on project needs, balancing the benefits of enhanced functionality with potential drawbacks related to compatibility and long-term support.
    </span>
    <span class="koboSpan" id="kobo.482.2">
     At this stage, we trust that you can make the right decision that has the best impact on your project and code base while allowing you to deliver the required product.
    </span>
    <span class="koboSpan" id="kobo.482.3">
     Even if it’s your pet project that you coded in your free time on a 30-year-old machine.
    </span>
    <span class="koboSpan" id="kobo.482.4">
     Compiled with a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.483.1">
      30-year-old compiler.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.484.1">
     Our next chapter, courtesy of Alex, will go on a deep exploration and try to uncover the basic truth of whether C++ is indeed just another object-oriented language, or whether there is something more lurking below
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.485.1">
      the surface...
     </span>
    </span>
   </p>
  </div>
 </body></html>