<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-27">
    <a id="_idTextAnchor026">
    </a>
    
     2
    
   </h1>
   <h1 id="_idParaDest-28">
    <a id="_idTextAnchor027">
    </a>
    
     Every C++ Program Is Standard-Compliant
    
   </h1>
   <p class="italic-heading">
    <em class="italic">
     
      Except when they are not
     
    </em>
   </p>
   <p>
    
     In the world of C++ programming, the concept of standard compliance is often held in high regard, with the latest iteration of the C++ standard perceived as the definitive guide for writing correct and efficient code.
    
    
     The C++ standard, meticulously crafted and periodically
    
    <a id="_idIndexMarker030">
    </a>
    
     updated by the C++ committee and the
    
    <strong class="bold">
     
      International Organization for Standardization
     
    </strong>
    
     (
    
    <strong class="bold">
     
      ISO
     
    </strong>
    
     ), serves as the ultimate guide for developers, providing a comprehensive set of rules and best practices to ensure code quality and interoperability.
    
    
     However, the reality of software development is more nuanced and complex than this
    
    
     
      ideal suggests.
     
    
   </p>
   <p>
    
     In this chapter, we will delve into the myriad challenges faced by developers who, due to various constraints, cannot always adhere to these standards and carefully balance on the sharp, thin edge between ideal standards and the practical demands of their work.
    
    
     These constraints can include limitations in their development environment, such as outdated compilers, legacy systems, or specific project requirements that mandate the use of
    
    
     
      non-standard features.
     
    
   </p>
   <p>
    
     Complex situations can arise when we are forced to use a framework that uses C++ as a base and provides a set of extensions to satisfy a certain use case.
    
    
     As we will present at a later stage, these frameworks build on existing standard C++ and bring in features that are highly specific for a certain scope, but have nothing in common with the C++ standard.
    
    
     So, we might ask ourselves: should we use these frameworks or not?
    
    
     The answer to this question, as we will see, is not as straightforward as one
    
    
     
      might assume.
     
    
   </p>
   <p>
    
     In this chapter, we will cover the following
    
    
     
      major topics:
     
    
   </p>
   <ul>
    <li>
     
      Adherence to standards in various compilers, frameworks,
     
     
      
       and environments
      
     
    </li>
    <li>
     
      Why can’t everyone learn, use, or write
     
     
      
       standard C++?
      
     
    </li>
    <li>
     
      Compiler extensions drifting away from
     
     
      
       the standard
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-29">
    <a id="_idTextAnchor028">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     We have to admit that reading this chapter will not be a straightforward process, but we will try to make it as easy as possible.
    
    
     Our minds will wander between platforms, compilers, and different dialects of the C++ language.
    
    
     However, at some point, we must draw the line and conclude that we should be able to transform all this theoretical transfer of information into the practicalities of life and produce some C++ code out of it.
    
    
     So, we kindly ask that at this stage of the book, you have access to the almighty internet, and the go-to place for experimental C++: Matt
    
    
     
      Godbolt’s site:
     
    
   </p>
   <p>
    <a href="https://gcc.godbolt.org/">
     
      
       https://gcc.godbolt.org/
      
     
    </a>
   </p>
   <p>
    
     That place should keep you covered since almost all the compilers we will discuss in this chapter are to be
    
    
     
      found there.
     
    
   </p>
   <p>
    
     There is nothing else required for now.
    
    
     That’s because at this stage, we have not produced enough valuable code to be able to put anything meaningful into the GitHub repository of the book, and the code that we have produced should not
    
    
     
      go anywhere.
     
    
   </p>
   <h1 id="_idParaDest-30">
    <a id="_idTextAnchor029">
    </a>
    
     Somewhere in Ghana, far, far away
    
   </h1>
   <p>
    
     When Richard Appiah Akoto posted a few images of himself drawing the user interface of Microsoft Word
    
    <a id="_idIndexMarker031">
    </a>
    
     on a blackboard at his school in Ghana, he instantly became a social media phenomenon overnight
    
    
     
      <a class="_idFootnoteLink _idGenColorInherit" href="B22235_02.xhtml#footnote-007">
       
        1
       
      </a>
     
    
    
     .
    
    
     His school was poor and they had no working computers, just a standard blackboard from the turn of the century, but this did not stop him from performing his duties as a teacher.
    
    
     In a very creative manner, he did his best to convey life-altering knowledge to his pupils, hoping that one day, it would be useful for them in their quest for a better life.
    
    
     The rest is history, but the real question is: was this the standard way of teaching
    
    
     
      Microsoft Word?
     
    
   </p>
   <div><p class="Basic-Paragraph">
     <a class="_idFootnoteAnchor _idGenColorInherit" href="B22235_02.xhtml#footnote-007-backlink">
      
       1
      
     </a>
     <a href="https://news.microsoft.com/apac/2018/03/17/teacher-who-used-a-chalkboard-in-computer-class-because-he-had-no-computer-stars-at-microsofts-education-exchange/">
      
       
        https://news.microsoft.com/apac/2018/03/17/teacher-who-used-a-chalkboard-in-computer-class-because-he-had-no-computer-stars-at-microsofts-education-exchange/
       
      
     </a>
    </p>
   </div>
   <p>
    
     Let’s not diverge too much from our initial objective.
    
    
     We want to find out about the standard compliance of C++ programs.
    
    
     For zealot C++ programmers, the latest iteration of the standard is perceived as holy scripture, the word, the collection of rules that they should obey, and any deviation from it should be punishable with an erasure and rewrite of the non-standard compliant code.
    
    
     Or one week in the detention center labeled
    
    <em class="italic">
     
      the maintainer of
     
    </em>
    
     <em class="italic">
      
       legacy code
      
     </em>
    
    
     
      .
     
    
   </p>
   <p>
    
     Facing the harsh reality, things couldn’t be further from an idealistic environment.
    
    
     Some developers do not have the possibility to use the latest version of the C++ standard.
    
    
     This could be because their livelihood is bound to real-life projects that require a specific compiler, or because the environment they program for does not allow the use of specific features of
    
    
     
      the language.
     
    
   </p>
   <p>
    
     Or maybe they are
    
    <a id="_idIndexMarker032">
    </a>
    
     paid to work on a platform that simply has not received updates for the last 20 years because the provider declared bankruptcy a decade ago, and there was no one to take up their business.
    
    
     However, since everything works and it still generates revenue, it is kept and maintained using tools that were available 20
    
    
     
      years ago.
     
    
   </p>
   <p>
    
     This definitely does not include
    
    <a id="_idIndexMarker033">
    </a>
    
     compilers with support for the latest C++ standard.
    
    
     So, does this mean the C++ code the developers working on these platforms write is
    
    
     
      not standard-compliant?
     
    
   </p>
   <p>
    
     At the turn of the century, the author of this chapter found himself in a classroom at his university, attending a course called
    
    <em class="italic">
     
      Introduction to C++ Programming
     
    </em>
    
     .
    
    
     It was the only C++ course offered at that place, and there was one book the teacher used to pass on knowledge to more than
    
    
     
      30 students.
     
    
   </p>
   <p>
    
     The small copy shop owner at the end of the road was very happy when, one day, the teacher decided to loan the book to one of the students.
    
    
     The book was a translated and heavily reduced version of Kris Jamsa’s
    
    <em class="italic">
     
      C/C++ programmers’ Bible
     
    </em>
    
     , the “book with the spotted dog,” as we
    
    
     
      called it.
     
    
   </p>
   <p>
    
     The local edition of the book contained only the C++ part, but it carried a very important inset: a Turbo C++ Lite IDE and accompanying compiler on a standard 1.44 MB floppy disk.
    
    
     For those who are unfamiliar with the name, Turbo C++ Lite was a dumbed-down version of the popular (and very user-friendly) IDE and compiler Turbo C++ by Borland.
    
    
     The compiler was the same, however, a lot of features and tools were removed in order to fit the entire environment on a single 1.44 MB (megabytes, that is)
    
    
     
      floppy disk.
     
    
   </p>
   <p>
    
     This was our first introduction to the complex world of compilers, linkers, and syntax.
    
    
     Some of us found it so fascinating that even now, some 20 years later, we still use it in our daily work.
    
    
     So, as you can imagine, our first C++ program looked like the one in the screenshot
    
    
     
      that follows.
     
    
   </p>
   <div><div><img alt="Figure 2.1 – The infamous blue screen of code, as seen in Life of a Programmer (1997)" src="img/B22235_02_01.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.1 – The infamous screen of code, as seen in Life of a Programmer (1997)
    
   </p>
   <p>
    
     Oh, the horror
    
    <a id="_idIndexMarker034">
    </a>
    
     on your face!
    
    
     I can clearly imagine it, dear C++ acolyte.
    
    
     The sheer
    
    
     
      sight of:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       iostream.h
      
     </strong>
     
      : Well, hello, it’s 1999, and the C++98 standard came out last year.
     
     
      Why don’t you use it, you heretic?
     
     
      Its number is ISO/IEC 14882:1998, go fetch it for a mere 200 Swiss Francs.
     
     
      … Oh, that is your salary as a part-time dishwasher for three months while
     
     
      
       studying here?
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       void main(void)
      
     </strong>
     
      : Oh dear, that was never even in any standard, whether C or C++.
     
     
      What sort of dark concoction did you just dig out?
     
     
      … Or is this the new thing they
     
     
      
       call… Java?
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       cout
      
     </strong>
     
      : Without ever encountering a using directive, how is this
     
     
      
       even possible?
      
     
    </li>
   </ul>
   <p>
    
     Here, you can easily afford to give up on trying to understand the reasons for this, sighing with relief, but please bear
    
    
     
      with me.
     
    
   </p>
   <p>
    
     Very much akin to the conditions faced by Richard Appiah Akoto, at that stage of our education, we also had access to a classroom with a blackboard, accompanied by one dedicated teacher and the book, as well as several copies of it, as mentioned earlier.
    
    
     Even so, we learned C++.
    
    
     Maybe, from the point of view of the standard, these were ideal circumstances, because the C++ standard is very relaxed, considering the environment, it requires nothing that you can find in a modern computer – no keyboard, no screen, and not even
    
    <a id="_idIndexMarker035">
    </a>
    
     an operating system.
    
    
     Indeed, the only very strict environmental requirement is that
    
    <strong class="source-inline">
     
      char
     
    </strong>
    
     must be at least 8 bits in size.
    
    
     This is to ensure that a
    
    <strong class="source-inline">
     
      char
     
    </strong>
    
     can hold any member of the basic execution character set (which includes standard ASCII characters).
    
    
     And the fact that
    
    <strong class="source-inline">
     
      sizeof(char) == 1
     
    </strong>
    
     is also guaranteed by the C++ standard, together with the signed and unsigned versions of it.
    
    
     Everything else builds on
    
    
     
      these foundations.
     
    
   </p>
   <p>
    
     So, we might say that until we were granted access to the computer lab, we had ideal circumstances for learning standard C++.
    
    
     No annoying system dependencies, no computer crashes, and no hardware to kick in case of frustration when your code does not compile.
    
    
     Since we had no compiler running on the blackboard, our teacher soon realized that compiling more complex C++ code on a blackboard is not quite feasible, so we were allocated an early Friday morning time slot at the computer lab.
    
    
     All the troubles
    
    
     
      began afterward.
     
    
   </p>
   <p>
    
     The explanation is quite simple: you see, the computer lab that was allocated for teaching C++ at our university back in the day consisted of a bunch of 80286 IBM
    
    
     
      AT clones.
     
    
   </p>
   <p>
    
     You read that correctly.
    
    
     30 students were allocated eight computers (each with a glorious 80286 processors, possibly high-tech at the time of their conception, albeit quite outdated more than one and a half decades later), hand-me-downs from some aid organization that likely did an upgrade, and decided to donate their old equipment to the university for the
    
    
     
      tax
     
    
    
     benefit of the
    
    
     
      company
     
    
    
     students.
    
    
     Four and a half people were sitting at one machine, with one book (and several copies) for the class, trying to
    
    
     
      learn C++.
     
    
   </p>
   <p>
    
     Although the situation was not as bleak as in Richard Appiah Akoto’s school two decades later, there were simply no better conditions.
    
    
     Those machines could never run anything else
    
    <a id="_idIndexMarker036">
    </a>
    
     than pure DOS, and there was no better compiler available for them than Turbo C++ Lite, which came out 10 years earlier.
    
    
     Does this mean we intentionally learned to write non-standard C++ code?
    
    
     No, obviously not.
    
    
     We wrote code that we had the
    
    
     
      possibility to.
     
    
   </p>
   <p>
    
     However, let’s not jump that far back in time.
    
    
     As of 2024, the date of writing of this book, there are
    
    <a id="_idIndexMarker037">
    </a>
    
     46 questions on Stack Overflow (
    
    <a href="https://stackoverflow.com/">
     
      https://stackoverflow.com/
     
    </a>
    
     ), containing the dreaded
    
    <strong class="source-inline">
     
      void main(void)
     
    </strong>
    
     phrase.
    
    
     The latest one is surprisingly from 2023.
    
    
     A bit more with the
    
    <strong class="source-inline">
     
      iostream.h
     
    </strong>
    
     content but mostly with educational context, and we did not dare count the ones containing
    
    <strong class="source-inline">
     
      cout
     
    </strong>
    
     without encountering the using directive or a namespace qualifier because it would have been futile.
    
    
     Does this mean that even in 2024, there are programmers still writing code that relies on non-standard C++?
    
    
     Or are there students learning C++ in a
    
    
     
      non-standard way?
     
    
   </p>
   <p>
    
     Digging a bit further on Stack Overflow, another interesting piece of an old dialect of C++ pops up:
    
    <strong class="source-inline">
     
      conio.h
     
    </strong>
    
     .
    
    
     This header was shipped with Turbo C (and C++) several years before the official standardization of the language, but considering that there are young padawans still asking questions about it in 2024, we might say that the answer to the previous question is highly
    
    
     
      likely
     
    
    
     <em class="italic">
      
       yes
      
     </em>
    
    
     
      .
     
    
   </p>
   <p>
    
     Depending on their circumstances and possibilities, whether they have to learn using a blackboard, drawing with chalk, or by sharing a keyboard, tapping each other’s hands gently in the process, there are still programmers out there today who involuntarily have the process of learning and writing non-standard C++ imposed
    
    
     
      on them.
     
    
   </p>
   <h1 id="_idParaDest-31">
    <a id="_idTextAnchor030">
    </a>
    
     Microsoft’s tiny, squishy C++
    
   </h1>
   <p>
    
     That’s enough
    
    <a id="_idIndexMarker038">
    </a>
    
     staring backward for now.
    
    
     Let’s look, for a moment, in a different direction and consider a compiler that once was the king of C++, but with time, its shine faded.
    
    
     OpenWatcom is an open source integrated development environment and suite of compilers for C and C++ (and Fortran too, but that language is not in focus in this book), originally developed by Watcom International Corporation and released as open source by Sybase
    
    
     
      in 2003.
     
    
   </p>
   <p>
    
     It supports multiple operating systems, including DOS, Windows, OS/2, and also Linux, and is the de-facto compiler for programmers who have an interest in creating fun, free-time projects for
    
    
     
      retro platforms.
     
    
   </p>
   <p>
    
     Not necessarily for the money, but instead for that joyful feeling of sweet nostalgia shivering through one’s spine when they are in front of an 80x25 screen.
    
    
     Maybe that’s the reason most senior programmers today use a grid of VI editors running in a terminal tiled to 6x4 windows, on huge WQUXGA (or
    
    
     
      larger) screens.
     
    
   </p>
   <p>
    
     But let’s get back to the
    
    <a id="_idIndexMarker039">
    </a>
    
     OpenWatcom compiler.
    
    
     While browsing the release notes of the project
    
    
     
      <a class="_idFootnoteLink _idGenColorInherit" href="B22235_02.xhtml#footnote-006">
       
        2
       
      </a>
     
    
    
     , we encountered the following, may I say so, quite intriguing phrase (in the
    
    <em class="italic">
     
      Major differences from version 10.0
     
    </em>
    
     section, at
    
    
     
      item 29):
     
    
   </p>
   <div><p class="Footer" lang="en-US" xml:lang="en-US">
     <a class="_idFootnoteAnchor _idGenColorInherit" href="B22235_02.xhtml#footnote-006-backlink">
      
       2
      
     </a>
     <a href="https://open-watcom.github.io/open-watcom-v2-wikidocs/c_readme.html">
      
       https://open-watcom.github.io/open-watcom-v2-wikidocs/c_readme.html
      
     </a>
    </p>
   </div>
   <p class="author-quote">
    
     We have duplicated a Microsoft Visual C++ extension that was required to parse the Windows 95 SDK header files.
    
   </p>
   <p class="author-quote">
    
     Example:
    
   </p>
   <p class="author-quote">
    
     typedef struct S {
    
   </p>
   <p class="author-quote">
    
     } S, const *CSP;
    
   </p>
   <p class="author-quote">
    
     ^^^^^- not allowed in ISO C or ISO C++
    
   </p>
   <p>
    
     Ehm … what?
    
    
     Did I just read correctly that there is an extension for Visual C++ that allows non-standard code to
    
    
     
      be compiled?
     
    
   </p>
   <p>
    
     Yes, we actually read that correctly.
    
    
     The following short sequence of demonstrative code should not compile with any major C++ compiler today, except for Visual C++ (and OpenWatcom’s C++ compiler, as per
    
    
     
      their comments):
     
    
   </p>
   <pre class="source-code">
#include &lt;iostream&gt;
typedef struct S {
   int a;
} S, const *CSP;
int main() {
   S s1; s1.a = 1;
   CSP ps1 = &amp;s1;
   std::cout &lt;&lt; ps1-&gt;a;
}</pre>
   <p>
    
     ...and due to some mystery, the author was not able to decipher, the code sequence is also accepted by several versions of ICC (Intel’s powerful, but sadly discontinued, C++ compiler).
    
    
     So, we can ask the following question again: since one major, and two relatively esoteric compilers accept this kind of code, does this mean that we should use it?
    
    
     Is
    
    
     
      it standard?
     
    
   </p>
   <p>
    
     The answer to the second question is a definitive
    
    <em class="italic">
     
      no
     
    </em>
    
     .
    
    
     However, for the first one, it is a bit more nuanced.
    
    
     This is because before answering, we must take the background, requirements, and other relevant factors that might influence the decisions concerning the development into
    
    
     
      consideration again.
     
    
   </p>
   <p>
    
     Do we want to
    
    <a id="_idIndexMarker040">
    </a>
    
     stick to the standard C++ as much as we can?
    
    
     Is it possible to deliver the required solution without extending ourselves to using vendor-specific extensions?
    
    
     Are we bound to a compiler or an operating system, and are we not worried about ever needing to visit
    
    
     
      foreign lands?
     
    
   </p>
   <p>
    
     Would it save us a lot of trouble to use the managed extensions for C++, offered by adopting the Microsoft platform, or would we rather stick to the good old syntax (and types) that we know and are
    
    
     
      familiar with?
     
    
   </p>
   <p>
    
     Microsoft is famous for providing platform-specific extensions for the C and C++ languages, to the extent that there is an entire section dedicated to Microsoft-specific C++ keywords
    
    
     
      <a class="_idFootnoteLink _idGenColorInherit" href="B22235_02.xhtml#footnote-005">
       
        3
       
      </a>
     
    
    
     .
    
    
     This tells us that there is a market for non-standard C++, and with just cause, because some of these extensions are very handy, at the expense of binding ourselves to a platform, compiler,
    
    
     
      and toolchain.
     
    
   </p>
   <div><p class="Basic-Paragraph">
     <a class="_idFootnoteAnchor _idGenColorInherit" href="B22235_02.xhtml#footnote-005-backlink">
      
       3
      
     </a>
     <a href="https://learn.microsoft.com/en-us/cpp/cpp/keywords-cpp?view=msvc-170">
      
       https://learn.microsoft.com/en-us/cpp/cpp/keywords-cpp?view=msvc-170
      
     </a>
    </p>
   </div>
   <p>
    
     One of the
    
    <a id="_idIndexMarker041">
    </a>
    
     Microsoft extensions manifests itself within the
    
    <strong class="source-inline">
     
      __declspec
     
    </strong>
    
     keyword.
    
    
     The
    
    <strong class="source-inline">
     
      __declspec
     
    </strong>
    
     keyword in C and C++ is part of Microsoft’s extended C++ syntax, which allows developers to specify Microsoft-specific storage-class attributes for certain
    
    
     
      C++ constructs.
     
    
   </p>
   <p>
    
     This keyword provides additional control over behaviors such as DLL exporting and memory alignment, which are not covered by the standard ANSI keywords such as
    
    <strong class="source-inline">
     
      static
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      extern
     
    </strong>
    
     .
    
    
     By using
    
    <strong class="source-inline">
     
      __declspec
     
    </strong>
    
     , developers can easily and non-standard compliantly apply these features specific to Microsoft’s own compiler (behold: a surprise follows!) to their code, enhancing the capabilities and performance of their code, such as in the following
    
    
     
      code sequence:
     
    
   </p>
   <pre class="source-code">
struct person {
   void set_age(int page) { m_age = page; }
   int get_age() const { return m_age; }
   __declspec (property(get = get_age, put = set_age)) int age;
   person() = default;
private:
   int m_age;
};
int main() {
   person joe;
   joe.age = 12;
   std::cout &lt;&lt; "Hello " &lt;&lt; joe.age;
}</pre>
   <p>
    
     Using Microsoft’s
    
    <strong class="source-inline">
     
      __declspec(property(...))
     
    </strong>
    
     syntax, the preceding code sequence creates an
    
    <strong class="source-inline">
     
      age
     
    </strong>
    
     property that allows indirect interaction with
    
    <strong class="source-inline">
     
      m_
     
    </strong>
    <strong class="source-inline">
     
      age
     
    </strong>
    
     through the methods provided, properly encapsulating the age data while providing a simplified interface for accessing and
    
    
     
      modifying it.
     
    
   </p>
   <p>
    
     The list of
    
    <a id="_idIndexMarker042">
    </a>
    
     attributes that one can harness with the
    
    <strong class="source-inline">
     
      __declspec
     
    </strong>
    
     extension is quite long and pragmatic, and
    
    <strong class="source-inline">
     
      __declspec
     
    </strong>
    
     also seems to be catchy in the compiler development world.
    
    
     In fact, it’s so
    
    <a id="_idIndexMarker043">
    </a>
    
     catchy that
    
    <strong class="bold">
     
      Clang
     
    </strong>
    
     provides an argument dedicated to understanding this Microsoft-specific extension.
    
    
     This flag,
    
    <strong class="source-inline">
     
      -fdeclspec
     
    </strong>
    
     , makes it possible to use the
    
    <strong class="source-inline">
     
      __declspec
     
    </strong>
    
     keyword in code compiled by Clang too.
    
    
     So, the question naturally arises: is this a Microsoft-specific extension anymore, or are we witnessing the emergence of a
    
    
     
      cross-platform feature?
     
    
   </p>
   <p>
    
     A truth that is still considered to be taboo in hardcore C++ programmer circles is that in real life, rare are the situations, when one needs to write true cross-platform code.
    
    
     Most programmers work for a specific company, developing or supporting a particular product.
    
    
     They’ll mostly use one operating system, with one compiler toolchain, complying with the restrictions imposed by their employer and happily compiling their code using all the extensions their
    
    
     
      compiler supports.
     
    
   </p>
   <p>
    
     This does not mean they don’t explicitly want to write standard compliant C++ code.
    
    
     No, on the contrary, I believe they write the highest quality code they can come up with.
    
    
     This just means that they merely use the possibilities provided by a specific compiler: the one they have to work with.
    
    
     At their next company, there is a high chance that they will be using a
    
    <a id="_idIndexMarker044">
    </a>
    
     different compiler that runs on a different OS, thus forgetting all about the advantages provided by their ex-compiler at their ex-place.
    
    
     This is because compiler-specific syntax and extensions are not bound to one
    
    
     
      compiler exclusively.
     
    
   </p>
   <p>
    
     Let’s consider the following code sample,
    
    
     
      for example:
     
    
   </p>
   <pre class="source-code">
char arr[6] = {'a', 'b', "cde"};</pre>
   <p>
    
     Other than hurting our eyes, this sequence is obviously as standard and non-conformant as possible.
    
    
     Who in their right mind would ever attempt to initialize an array of 6 chars like this?
    
    
     However, the Microsoft Visual C++ compiler happily digests it.
    
    
     Let’s start with a few normal characters, and when we get bored of typing in all the apostrophes and commas, we’ll just throw everything else in a constant string literal, because why not?
    
    
     And it is quite clever about it, detecting the size that was requested for the array and matching it to the accumulated length of the parts, signaling an error if there are
    
    
     
      any mismatches.
     
    
   </p>
   <p>
    
     Microsoft’s C++ compiler is a very innovative one when it comes to adding features not found in the standard, or allowing code that would break a language lawyer’s tongue.
    
    
     Let’s look at the following piece of code,
    
    
     
      for example:
     
    
   </p>
   <pre class="source-code">
class person {
public:
   int age;
   class {
   public:
       std::string name;
   };
};</pre>
   <p>
    
     This code sequence is anything but standard C++.
    
    
     Its sheer existence even allows us to write code that looks like
    
    
     
      the following:
     
    
   </p>
   <pre class="source-code">
int main() {
   person joe;
   joe.name = "Joe";
   std::cout &lt;&lt; "Hello " &lt;&lt; joe.name;
}</pre>
   <p>
    
     The preceding example compiles and runs without any issues when compiled using Microsoft’s own C++ compiler.
    
    
     Please carefully observe the anonymous class, which contains the
    
    <strong class="source-inline">
     
      name
     
    </strong>
    
     member, is an object that has a constructor..
    
    
     This is an object that has a constructor, a destructor, and lots of other interesting features.
    
    
     This is another (very handy, if I may say so) Microsoft deviation from the
    
    <a id="_idIndexMarker045">
    </a>
    
     standard because anonymous unions are a well-known beast of C++.
    
    
     However, anonymous structs only dwell in the C language (starting from C11) and no other compiler accepts the
    
    
     
      preceding code.
     
    
   </p>
   <p>
    
     As a side note, if you’re not familiar with the notion of anonymous structs in the C language, they are a useful feature for simplifying nested structure declarations.
    
    
     They do not require the naming of inner structs when they are not needed elsewhere, and they make the code more concise and readable.
    
    
     While the members are enclosed in a structure, it is still possible to have direct access to them.
    
    
     By encapsulating related fields within anonymous structs, and introducing logical blocks within these members, the cluttering of the code with unnecessary type definitions becomes
    
    
     
      less overwhelming.
     
    
   </p>
   <h1 id="_idParaDest-32">
    <a id="_idTextAnchor031">
    </a>
    
     The realm of free compilers
    
   </h1>
   <p>
    
     Two of the three
    
    <a id="_idIndexMarker046">
    </a>
    
     major compilers today are developed and maintained in an open-source manner.
    
    
     This means that, in theory, anyone can contribute and provide useful new features to their compiler of choice.
    
    
     However, in practice, it means that there is a tiny core of professional programmers who have the necessary knowledge and dedication, and also the backing of a large corporation benefiting from the development of the aforementioned compiler working
    
    
     
      on it.
     
    
   </p>
   <p>
    
     In no particular order, GCC and Clang (and MSVC, which we discussed in the previous section) are the most standard-compliant compilers as of 2024.
    
    
     This standard compliance, however, does not mean that these compilers don’t come with their own perks that a developer once thought would be a great idea
    
    
     
      to incorporate.
     
    
   </p>
   <p>
    
     Let’s take, for example, the
    
    <strong class="bold">
     
      computed goto
     
    </strong>
    
     feature of GCC (and Clang too, of course; those two tend to go hand in hand).
    
    
     We all have learned in school that
    
    <strong class="source-inline">
     
      goto
     
    </strong>
    
     is just plain evil, and should
    
    <a id="_idIndexMarker047">
    </a>
    
     not be ever used.
    
    
     If you did not learn this in school, please do not learn it from this book.
    
    
     That’s because it is, again, not true.
    
    
     Instead, let’s focus
    
    <a id="_idIndexMarker048">
    </a>
    
     on what we can think of the computed
    
    <strong class="source-inline">
     
      goto
     
    </strong>
    
     .
    
    
     If
    
    <strong class="source-inline">
     
      goto
     
    </strong>
    
     is evil, then is computed
    
    <strong class="source-inline">
     
      goto
     
    </strong>
    
     calculated evil?
    
    
     So is the following code sequence pure evil, or calculated evil?
    
    
     Let’s have
    
    
     
      a look:
     
    
   </p>
   <pre class="source-code">
int main() {
   std::vector&lt;void*&gt; labels = { &amp;&amp;start, &amp;&amp;state1, &amp;&amp;state2, &amp;&amp;end };
   int state = 0;
   goto *labels[state];
   start:
       std::cout &lt;&lt; "In start state" &lt;&lt; std::endl;
       state = 1;
       goto *labels[state];
   state1:
       std::cout &lt;&lt; "In state 1" &lt;&lt; std::endl;
       state = 2;
       goto *labels[state];
   state2:
       std::cout &lt;&lt; "In state 2" &lt;&lt; std::endl;
       state = 3;
       goto *labels[state];
   end:
       std::cout &lt;&lt; "In end state" &lt;&lt; std::endl;
       return 0;
}</pre>
   <p>
    
     There is nothing wrong with the first line.
    
    
     The problems start after that.
    
    
     This very handy feature can be used for implementing interpreters or state machines efficiently and in a non-standard manner by allowing jumps to labels based on the value of a pointer, initialized from the address of the label itself.
    
    
     Since we are dealing with pointers, it is entirely possible to use the dreaded pointer arithmetic and do some calculations on
    
    
     
      the addresses.
     
    
   </p>
   <p>
    
     Also, this can be a dangerous feature if not used properly.
    
    
     Unlike in the case of the standard
    
    <strong class="source-inline">
     
      goto
     
    </strong>
    
     , the calculated one does not take into calculation the objects whose lifetime ends upon leaving a specific scope.
    
    
     So, no destructors are called.
    
    
     Consider
    
    
     
      yourself warned!
     
    
   </p>
   <p>
    
     Another pretty useful
    
    <a id="_idIndexMarker049">
    </a>
    
     deviation from the standard C++ syntax comes from GCC (and again, it’s implemented by Clang too, what a surprise), which makes the following code sequence compilable with these
    
    
     
      two compilers:
     
    
   </p>
   <pre class="source-code">
int y = ({ int x = 10; x + 5; });</pre>
   <p>
    
     Neat, ain’t it?
    
    
     This feature is called
    
    <em class="italic">
     
      Statements and Declarations in Expressions
     
    </em>
    
     and has all the benefits that you can think of: nice encapsulation of the objects declared inside, and somewhat safer macros if used properly.
    
    
     It’s too bad it is not
    
    
     
      standard C++.
     
    
   </p>
   <p>
    
     Clang, the new kid on the block (well, if we can call a 15-year-old compiler the “new” kid, although compared to GCC, with a birth date dating back to 1987, Clang is still a very young, albeit skilled, player in the field) takes the feature fight a bit further.
    
    
     The following piece of code only compiles with Clang, with the benefit of a very special library and a new command line switch to
    
    
     
      the compiler:
     
    
   </p>
   <pre class="source-code">
#include &lt;iostream&gt;
int main() {
   int (^square)(int) = ^(int num) { return num * num; };
   int y = square(12);
   std::cout &lt;&lt; y &lt;&lt; std::endl;
}</pre>
   <p>
    
     This feature
    
    <a id="_idIndexMarker050">
    </a>
    
     is called
    
    <strong class="bold">
     
      Blocks
     
    </strong>
    
     in Clang.
    
    
     In order to get it right, you will need to install the
    
    <strong class="source-inline">
     
      BlocksRuntime
     
    </strong>
    
     
      <a class="_idFootnoteLink _idGenColorInherit" href="B22235_02.xhtml#footnote-004">
       
        4
       
      </a>
     
    
    
     library, then specify a special
    
    <strong class="source-inline">
     
      -fblocks
     
    </strong>
    
     flag to Clang, and, after all this blocking has been done, we can finally compile the
    
    
     
      preceding code.
     
    
   </p>
   <div><p class="Basic-Paragraph">
     <a class="_idFootnoteAnchor _idGenColorInherit" href="B22235_02.xhtml#footnote-004-backlink">
      
       4
      
     </a>
     <a href="https://github.com/mackyle/blocksruntime">
      
       https://github.com/mackyle/blocksruntime
      
     </a>
    </p>
   </div>
   <p>
    
     This pretty much resembles the behavior of a standard C++11 lambda, but considering that this feature was created and introduced in Clang in 2008, we might call this the father of the
    
    <a id="_idIndexMarker051">
    </a>
    
     standard C++ lambda.
    
    
     In case you’re curious, the standard C++ lambda providing the same functionality is
    
    
     
      as follows:
     
    
   </p>
   <pre class="source-code">
auto square = [](int num) -&gt;int { return num * num; };</pre>
   <p>
    
     That’s not black magic, unlike the following piece
    
    
     
      of code:
     
    
   </p>
   <pre class="source-code">
auto generate(int n) -&gt; std::vector&lt;int&gt;{
   int array[n] = {0};
   for(int i=0; i&lt;n; i++) array[i] = i;
   return std::vector&lt;int&gt;{array, array + n};
}</pre>
   <p>
    
     So, in case you
    
    <a id="_idIndexMarker052">
    </a>
    
     are wondering what is happening there, here’s just a small refresher of your C++ freshman memories: under no circumstances is
    
    <strong class="source-inline">
     
      int array[n] = {0};
     
    </strong>
    
     standard C++.
    
    
     The
    
    <strong class="bold">
     
      variable length array
     
    </strong>
    
     is a feature present in C, but the C++ standard does not include it due to various safety considerations.
    
    
     Regardless, the preceding code is accepted by the GCC compiler, but Clang complains
    
    
     
      about it:
     
    
   </p>
   <pre class="source-code">
error: variable-sized object may not be initialized
   5 |     int array[n] = {0};</pre>
   <p>
    
     According to the error message, the fix
    
    
     
      is easy:
     
    
   </p>
   <pre class="source-code">
auto generate(int n) -&gt; std::vector&lt;int&gt;{
   int array[n];
   for(int i=0; i&lt;n; i++) array[i] = i;
   return std::vector&lt;int&gt;{array, array + n};
}</pre>
   <p>
    
     Now, even Clang (and several other compilers, such as ICC) accept it, regardless of the state of
    
    <a id="_idIndexMarker053">
    </a>
    
     standardness of the code… or rather, the lack
    
    
     
      of it.
     
    
   </p>
   <h2 id="_idParaDest-33">
    <a id="_idTextAnchor032">
    </a>
    
     A tribute to attributes
    
   </h2>
   <p>
    
     Both GCC and Clang (and also Microsoft Visual C++) can, however, agree on the usefulness of one very specific extension to the C++ language: we need a way to attach metadata
    
    <a id="_idIndexMarker054">
    </a>
    
     to some of the language constructs (such as types, functions, variables, etc.).
    
    
     This metadata can then be used by the compiler and other tools to generate optimized code, perform checks, or provide
    
    
     
      other features.
     
    
   </p>
   <p>
    
     Before modern C++ (i.e., C++11) introduced the standardized way to specify attributes using the double square bracket syntax
    
    <strong class="source-inline">
     
      [[attribute]]
     
    </strong>
    
     , each compiler had their own way of specifying these so
    
    
     
      required attributes:
     
    
   </p>
   <ul>
    <li>
     
      GCC and Clang
     
     
      
       used
      
     
     
      <strong class="source-inline">
       
        __attribute__((attribute-name))
       
      </strong>
     
    </li>
    <li>
     
      Microsoft Visual C++
     
     
      
       used
      
     
     
      <strong class="source-inline">
       
        __declspec(attribute-name)
       
      </strong>
     
    </li>
   </ul>
   <p>
    
     With the release of C++11, however, the standardization committee realized the usefulness of these, and lifted the most applicable attributes into the language (such as
    
    <strong class="source-inline">
     
      [[noreturn]]
     
    </strong>
    
     ) while later improvements to the standard added even more attributes (such as
    
    <strong class="source-inline">
     
      [[fallthrough]]
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      [[nodiscard]]
     
    </strong>
    
     , etc.).
    
    
     However, a lot of these attributes remained confined to the compilers that have introduced them.
    
    
     The following code snippet showcases some
    
    
     
      of these:
     
    
   </p>
   <pre class="source-code">
void old_function() __attribute__((deprecated));
void fatal_error() __attribute__((noreturn));
int pure_function(int x) __attribute__((pure));
int x __attribute__((aligned(16)));
void old_function() {
   std::cout &lt;&lt; "This function is deprecated.";
}
void fatal_error() {
   std::cerr &lt;&lt; "This function does not return.";
   exit(1);
}
int pure_function(int x) {
   return x * x;
}</pre>
   <p>
    
     The code
    
    <a id="_idIndexMarker055">
    </a>
    
     sequence above contains a few attributes shared by GCC and Clang, such as
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       __attribute__((deprecated))
      
     </strong>
     
      marks
     
     <strong class="source-inline">
      
       old_function
      
     </strong>
     
      
       as deprecated
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       __attribute__((noreturn))
      
     </strong>
     
      is used to indicate that
     
     <strong class="source-inline">
      
       fatal_error
      
     </strong>
     
      does
     
     
      
       not return
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       __attribute__((pure))
      
     </strong>
     
      is used to indicate that
     
     <strong class="source-inline">
      
       pure_function
      
     </strong>
     
      has no side effects except for its
     
     
      
       return value
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       __attribute__((aligned(16)))
      
     </strong>
     
      is used to align the
     
     <strong class="source-inline">
      
       x
      
     </strong>
     
      variable to a
     
     
      
       16-byte boundary
      
     
    </li>
   </ul>
   <p>
    
     The list of attributes these compilers
    
    
     
      <a class="_idFootnoteLink _idGenColorInherit" href="B22235_02.xhtml#footnote-003">
       
        5
       
      </a>
     
    
    
     provide is huge
    
    
     
      <a class="_idFootnoteLink _idGenColorInherit" href="B22235_02.xhtml#footnote-002">
       
        6
       
      </a>
     
    
    
     , and we can highly recommend that if you are in a situation where you are working with one of these compilers on a very specific platform, and your main concern is not code portability, platform independence, and standard compliance, then you should go and check them out.
    
    
     That’s because a lot of power can be harnessed by properly using the tools your compiler provides
    
    
     
      you with.
     
    
   </p>
   <div><p class="Basic-Paragraph">
     <a class="_idFootnoteAnchor _idGenColorInherit" href="B22235_02.xhtml#footnote-003-backlink">
      
       5
      
     </a>
     <a href="https://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html">
      
       https://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html
      
     </a>
    </p>
    <div><p class="Basic-Paragraph">
      <a class="_idFootnoteAnchor _idGenColorInherit" href="B22235_02.xhtml#footnote-002-backlink">
       
        6
       
      </a>
      <a href="https://clang.llvm.org/docs/AttributeReference.html">
       
        https://clang.llvm.org/docs/AttributeReference.html
       
      </a>
     </p>
    </div>
   </div>
   <h1 id="_idParaDest-34">
    <a id="_idTextAnchor033">
    </a>
    
     When the header is not even C++
    
   </h1>
   <p>
    
     The long list of standard-non-compliant-but-still-working-and-useful features does not end with the preceding examples.
    
    
     However, if we had only focused our attention on those, we could still have filled several books with them.
    
    
     Sadly, for the moment, we have only dedicated one chapter to this topic, so let’s move our attention to somewhat more
    
    
     
      exotic features.
     
    
   </p>
   <p>
    
     Qt has been the de-facto cross-platform programming framework for GUI applications (but not only) for quite some time.
    
    
     Throughout its fateful history, while exchanging owners several times since its inception in 1994, the Qt framework has evolved significantly, with each release giving a new set of features to the C++ (but not only) programming community.
    
    
     However, one feature has remained more or less the same: the signal/slot
    
    <a id="_idIndexMarker056">
    </a>
    
     implementation and the
    
    <strong class="bold">
     
      Meta Object Compiler
     
    </strong>
    
     (
    
    <strong class="bold">
     
      MOC
     
    </strong>
    
     ).
    
    
     The pillar of the framework, the MOC makes it possible to connect events from components (i.e., signals) to receivers (i.e., slots) for
    
    
     
      proper handling.
     
    
   </p>
   <p>
    
     However, this very
    
    <a id="_idIndexMarker057">
    </a>
    
     handy feature comes at the expense of having to support several non-C++ constructs, which makes the connection between seemingly unrelated elements of the application possible.
    
    
     For example, the class declaration of objects that must respond to an event is extended by several non-standard “access modifiers”, such as
    
    <strong class="source-inline">
     
      signals:
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      private slots:
     
    </strong>
    
     , and so on.
    
    
     Also, there is a new
    
    <strong class="bold">
     
      keyword
     
    </strong>
    
     called
    
    <strong class="source-inline">
     
      emit
     
    </strong>
    
     , which makes
    
    <a id="_idIndexMarker058">
    </a>
    
     it possible to, well,
    
    
     
      emit signals.
     
    
   </p>
   <p>
    
     Long story short, the following is an excerpt from a header file, making the compilation of the following
    
    
     
      code possible:
     
    
   </p>
   <pre class="source-code">
#ifndef MYCONTROL_H
#define MYCONTROL_H
#include &lt;QObject&gt;
#include &lt;QPushButton&gt;
#include &lt;QWidget&gt;
class MyControl : public QWidget {
   Q_OBJECT
public:
   MyControl(QWidget *parent = nullptr);
private slots:
   void onButtonClicked();
signals:
   void nameChanged(const QString &amp;name);
private:
   QPushButton *myButton;
};
#endif</pre>
   <p>
    
     Should we adopt the luxury provided to us by Qt and use the very convenient signal/slot mechanism with the drawback that we have to write non-standard C++ code?
    
    
     Or would we rather stick to tradition and create every little button and connection by writing pure C++ code, as we would do
    
    
     
      in GTK?
     
    
   </p>
   <p>
    
     This chapter cannot
    
    <a id="_idIndexMarker059">
    </a>
    
     answer this question because, in the end, it is up to every project’s specific requirements.
    
    
     Those include what is imposed by the environment, what the project stakeholders expect from it, and how the development team decides the path forward.
    
    
     However, despair not: even if this does not feel like standard C++, it solves a very real-life problem.
    
    
     Behind the scenes, there hides a cutting-edge implementation, which has been tested, approved, improved, and used in several small- and large-scale projects.
    
    
     It has stood the test
    
    
     
      of time.
     
    
   </p>
   <p>
    
     Microsoft’s own large-scale extension to the C++ language comes from a different approach.
    
    
     While not being a specific tool such as Qt’s MOC, C++/CLI extends C++ with .NET-specific
    
    <a id="_idIndexMarker060">
    </a>
    
     syntax.
    
    
     The Visual Studio compiler for C++/
    
    <strong class="bold">
     
      CLI
     
    </strong>
    
     (as in,
    
    <strong class="bold">
     
      Common Language Infrastructure
     
    </strong>
    
     , not Command Line Interface) can parse this extended syntax and generate valid Common Intermediate Language (which is a low-level, platform-independent instruction set used by the .NET framework) and native code.
    
    
     The following code sequence is an example of this managed C++.
    
    
     It does nothing special; it just concatenates the elements of an array of strings and prints
    
    
     
      the result:
     
    
   </p>
   <pre class="source-code">
#include &lt;iostream&gt;
#include &lt;atlstr.h&gt;
#include &lt;stdio.h&gt;
using namespace System;
int main() {
   array&lt;String^&gt;^ args = { "managed", "world" };
   String^ s = "Hello";
   for each (String ^ a in args) s += " " + a ;
   CString cs(s);
   wprintf(cs);
}</pre>
   <p>
    
     I totally agree; it is anything but standard C++.
    
    
     It does not look like standard C++, it does not feel like
    
    <a id="_idIndexMarker061">
    </a>
    
     standard C++, and it doesn’t even quack like standard C++.
    
    
     So, it must not be that.
    
    
     The standard-compliant C++ code having the same functionality would look like
    
    
     
      the following:
     
    
   </p>
   <pre class="source-code">
#include &lt;array&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
int main() {
   std::array&lt;std::string, 2&gt; args = { "unmanaged", "world" };
   std::string s = "Hello";
   for(const auto&amp; a : args) {
       s += " " + a ;
   }
   std::cout &lt;&lt; s;
}</pre>
   <p>
    
     Isn’t it nicer, shorter, and more concise than the previous one?
    
    
     Not to mention the fact that it is
    
    
     
      also standard-conformant.
     
    
   </p>
   <p>
    
     It will be interesting to observe the evolution of the managed extensions of C++ in
    
    
     
      the future.
     
    
   </p>
   <p>
    
     Right now, it serves as a bridge between native and managed code, which is a very niche field for the moment.
    
    
     However, in the long term, its survival is heavily dependent on how the
    
    <a id="_idIndexMarker062">
    </a>
    
     developer communities will embrace it (or not), whether the ecosystem it has created will be of enough use to keep it alive, or whether other technologies, such as P/Invoke or COM Interop, will take over the specific uses cases that C++/CLI handles
    
    
     
      right now.
     
    
   </p>
   <p>
    
     There are interesting times
    
    
     
      ahead, indeed.
     
    
   </p>
   <h1 id="_idParaDest-35">
    <a id="_idTextAnchor034">
    </a>
    
     The curious case of C++ locked in a box
    
   </h1>
   <p>
    
     Up until now, we have observed cases where the standard compliance was at the developers’ own discretion.
    
    
     They had the option to choose their platform, use the extensions provided by their favorite compiler, or go for pure standard C++.
    
    
     However, out there in
    
    <a id="_idIndexMarker063">
    </a>
    
     the wild wide world, there are certain circumstances wherein we cannot fully comply with the standard due to some restrictions imposed upon us by the environment that disallows the usage of certain features found in the
    
    
     
      C++ standard.
     
    
   </p>
   <p>
    
     Not considering obscene scenarios, when we must maintain decades-old legacy code written in the golden age of C++ (i.e., before the standardization committee took over and ruined all the fun by demanding standard compliance, in order to avert the uncontrollable spread of C++ dialects as happened with
    
    <strong class="bold">
     
      BASIC
     
    </strong>
    
     ), there are situations outside of our control that make the usage of the full C++ standard features impossible.
    
    
     For example, there might be certain requirements that disallow the usage of exceptions.
    
    
     Other environments may lack the proper support for memory allocation, while others still simply force us to write to direct hardware addresses in order for something to happen.
    
    
     However, this last one can happen in a standard-compliant
    
    
     
      way too.
     
    
   </p>
   <p>
    
     Some embedded systems, for example, actively encourage the usage of their platform-specific assembly instructions.
    
    
     As we know, there is no such thing as a platform-independent assembly language because that is the lowest level one can go to in today’s C++.
    
    
     Below that is pure hexadecimal machine code, but long gone are the times when we had to use that in
    
    
     
      C++ code.
     
    
   </p>
   <p>
    
     There might also be scenarios wherein the requirements formulated for our code by the hardware require deterministic behavior.
    
    
     This, by definition, excludes exceptions (because who would like to be unable to follow the code flow at every nanosecond during its execution?) and memory allocations (because of allocation latency, memory fragmentation, and a myriad of other issues your code is again not behaving in a deterministic manner).
    
    
     Thus, a large chunk of the C++ standard falls out of
    
    
     
      our grace.
     
    
   </p>
   <p>
    
     There are certain solutions tackling the problem of memory allocation in embedded systems, such as the usage of memory pools, object pools, compile time memory allocation, and various other resources, which may be even platform-specific in turn.
    
    
     Then there are the exceptions.
    
    
     In his excellent paper
    
    
     
      <a class="_idFootnoteLink _idGenColorInherit" href="B22235_02.xhtml#footnote-001">
       
        7
       
      </a>
     
    
    
     , Bjarne Stroustrup discusses the challenges, costs, and risks involved in replacing C++ exceptions with alternatives such as deterministic exceptions.
    
    
     However, as the paper concludes, at this moment, there are no clear advantages
    
    <a id="_idIndexMarker064">
    </a>
    
     to replacing the current exception-handling mechanisms with something else.
    
    
     That would include another fragmentation in the C++ developer community, as if there aren’t enough of those already.
    
    
     Instead, the paper argues for the importance of focusing on enhancing the current exception-handling system rather than complicating the language with additional mechanisms, emphasizing that exceptions, despite their imperfections, have effectively served a vast number of developers
    
    
     
      for decades.
     
    
   </p>
   <div><p class="Basic-Paragraph">
     <a class="_idFootnoteAnchor _idGenColorInherit" href="B22235_02.xhtml#footnote-001-backlink">
      
       7
      
     </a>
     <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1947r0.pdf">
      
       https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1947r0.pdf
      
     </a>
    </p>
   </div>
   <h1 id="_idParaDest-36">
    <a id="_idTextAnchor035">
    </a>
    
     Past days of future C++
    
   </h1>
   <p>
    
     The last scenario that we will explore concerning the standard compliance of the code you write
    
    <a id="_idIndexMarker065">
    </a>
    
     relates to the most fundamental item in the C++ ecosystem: the
    
    
     
      compiler itself.
     
    
   </p>
   <p>
    
     You see, compilers are also programs, consisting of millions and millions of lines of code.
    
    
     There are several contributors spread out on the globe working on them, adding new features, fixing bugs, making them more standard compliant, releasing the latest versions, and generally making sure that your compiler
    
    
     
      just works.
     
    
   </p>
   <p>
    
     These compilers also have a development timeline.
    
    
     The implementation of features does not happen overnight, and there simply might be situations wherein, at a certain point in time, some compiler does not support some feature of the standard because there was not enough manpower to
    
    
     
      implement it.
     
    
   </p>
   <p>
    
     There is a very handy document available at the source of all C++ knowledge
    
    
     
      <a class="_idFootnoteLink _idGenColorInherit" href="B22235_02.xhtml#footnote-000">
       
        8
       
      </a>
     
    
    
     , which details the support of various C++ standard features and which compilers have support for a
    
    
     
      specific feature.
     
    
   </p>
   <div><p class="Footer" lang="en-US" xml:lang="en-US">
     <a class="_idFootnoteAnchor _idGenColorInherit" href="B22235_02.xhtml#footnote-000-backlink">
      
       8
      
     </a>
     <a href="https://en.cppreference.com/w/cpp/compiler_support">
      
       https://en.cppreference.com/w/cpp/compiler_support
      
     </a>
    </p>
   </div>
   <p>
    
     At the turn of standards (or when forced to use outdated compilers that have not implemented some of the features yet), there have been several tricks employed by the C++ developer community to compensate for the lack of features in upcoming versions of
    
    
     
      various compilers.
     
    
   </p>
   <p>
    
     When the
    
    <strong class="source-inline">
     
      mutable
     
    </strong>
    
     keyword was
    
    <a id="_idIndexMarker066">
    </a>
    
     introduced in C++98, its implementation in certain compilers took a bit longer than in others.
    
    
     For programmers using these compilers, it was challenging
    
    <a id="_idIndexMarker067">
    </a>
    
     to modify member variables in
    
    <strong class="source-inline">
     
      const
     
    </strong>
    
     member
    
    <a id="_idIndexMarker068">
    </a>
    
     functions (a feature introduced in the
    
    
     
      same standard).
     
    
   </p>
   <p>
    
     In situations like this, the following (quite ugly) hack had to be used to counteract the
    
    
     
      missing keyword:
     
    
   </p>
   <pre class="source-code">
class Counter {
   int viewCount = 0;
public:
   void view() const {
       const_cast&lt;Counter*&gt;(this)-&gt;viewCount++;
   }
   void print() const {
       std::cout &lt;&lt; "Count: " &lt;&lt; viewCount &lt;&lt; std::endl;
   }
};</pre>
   <p>
    
     Assuming that your computer supports
    
    <strong class="source-inline">
     
      const_cast
     
    </strong>
    
     , there is nothing wrong with the preceding code.
    
    
     However, if
    
    <strong class="source-inline">
     
      const_cast
     
    </strong>
    
     is not in the list of supported keywords, then you are pretty much back to a standard C style cast, such as
    
    <strong class="source-inline">
     
      ((Counter*)(this))-&gt;viewCount++;
     
    </strong>
    
     .
    
    
     This should fix all
    
    
     
      your problems.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      mutable
     
    </strong>
    
     keyword was not the first one whose lack of support in compilers caused trouble for developers.
    
    
     Before C++11 introduced
    
    <strong class="source-inline">
     
      constexpr
     
    </strong>
    
     (and a few years after that too, for Microsoft Visual C++ programmers), compile-time constant expressions had to be evaluated
    
    <a id="_idIndexMarker069">
    </a>
    
     using various template tricks (or just macros, but as we all know, they are evil, so let’s avoid them for as long as
    
    
     
      we can).
     
    
   </p>
   <p>
    
     For example, the following piece of code calculated the famous factorial of some number, before
    
    <strong class="source-inline">
     
      constexpr
     
    </strong>
    
     (but still at
    
    
     
      compile time):
     
    
   </p>
   <pre class="source-code">
template &lt;unsigned int N&gt;
struct Factorial {
   static const unsigned long long value = N * Factorial&lt;N - 1&gt;::value;
};
template &lt;&gt;
struct Factorial&lt;0&gt; {
   static const unsigned long long value = 1;
};
const unsigned long long fac5 =  Factorial&lt;5&gt;::value;</pre>
   <p>
    
     The current standard implementation using a compiler that supports
    
    <strong class="source-inline">
     
      constexpr
     
    </strong>
    
     of the same function is certainly shorter and much easier
    
    
     
      to understand:
     
    
   </p>
   <pre class="source-code">
constexpr unsigned long long factorial(unsigned int n) {
   return n &lt;= 1 ? 1 : n * factorial(n - 1);
}
const unsigned long long fac5too =  factorial(5);</pre>
   <p>
    
     Certainly, a huge jump in the readability of the code, if I may
    
    
     
      say so.
     
    
   </p>
   <h1 id="_idParaDest-37">
    <a id="_idTextAnchor036">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     As this chapter has demonstrated, writing standard C++ ensures code portability, compatibility, and maintainability across different platforms and compilers.
    
    
     We learned that by adhering to the ISO/IEC C++ standard, we can create code that behaves predictably and is less prone to bugs and platform-specific issues.
    
    
     Standard-compliant C++ code also benefits from generic compiler optimizations and future language enhancements, while ensuring long-term relevance and performance, as we learned in
    
    
     
      this chapter.
     
    
   </p>
   <p>
    
     On the other hand, using C++ compiler-specific extensions can provide performance optimizations specific to a platform and compiler, access to advanced features that are not yet standardized, and integration with vendor-specific tools.
    
    
     However, the extension may introduce portability issues, dependencies on specific compiler versions, as well as divergence from standard C++ practices, which can impact code maintenance and interoperability across different platforms and compilers.
    
    
     We also covered this in
    
    
     
      this chapter.
     
    
   </p>
   <p>
    
     Therefore, we learned that adoption should be carefully considered based on project needs, balancing the benefits of enhanced functionality with potential drawbacks related to compatibility and long-term support.
    
    
     At this stage, we trust that you can make the right decision that has the best impact on your project and code base while allowing you to deliver the required product.
    
    
     Even if it’s your pet project that you coded in your free time on a 30-year-old machine.
    
    
     Compiled with a
    
    
     
      30-year-old compiler.
     
    
   </p>
   <p>
    
     Our next chapter, courtesy of Alex, will go on a deep exploration and try to uncover the basic truth of whether C++ is indeed just another object-oriented language, or whether there is something more lurking below
    
    
     
      the surface...
     
    
   </p>
  </div>
 </body></html>