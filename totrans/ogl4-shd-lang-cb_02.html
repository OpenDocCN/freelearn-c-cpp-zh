<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Working with GLSL Programs</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li><span>Sending data to a shader using vertex attributes and vertex buffer objects</span></li>
<li><span>Getting a list of active vertex input attributes and locations</span></li>
<li><span>Sending data to a shader using uniform variables</span></li>
<li><span>Getting a list of active uniform variables</span></li>
<li><span>Using uniform blocks and uniform buffer objects</span></li>
<li>Using program pipelines</li>
<li><span>Getting debug messages</span></li>
<li><span>Building a C++ shader program class</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>In <a href="3b817a9a-28a1-4be7-936c-b982b4dfacdf.xhtml">Chapter 1</a>, <em>Getting Started with GLSL</em>, we covered the basics of compiling, linking, and exporting shader programs. In this chapter, we'll cover techniques for communication between shader programs and the host OpenGL program. To be more specific, we'll focus primarily on input. The input to shader programs is generally accomplished via attributes and uniform variables. In this chapter, we'll see several examples of the use of these types of variables. We'll also cover a recipe for mixing and matching shader program stages, and a recipe for creating a C++ shader program object.</p>
<p>We won't cover shader output in this chapter. Obviously, shader programs send their output to the default framebuffer, but there are several other techniques for receiving shader output. For example, the use of custom framebuffer objects allow us to store shader output to a texture or other buffer. A technique called transform feedback allows for the storage of vertex shader output into arbitrary buffers. You'll see many examples of these output techniques later in this book.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Sending data to a shader using vertex attributes and vertex buffer objects</h1>
                </header>
            
            <article>
                
<p>The vertex shader is invoked once per vertex. Its main job is to process the data associated with the vertex, and pass it (and possibly other information) along to the next stage of the pipeline. In order to give our vertex shader something to work with, we must have some way of providing (per-vertex) input to the shader. Typically, this includes the vertex position, normal vector, and texture coordinates (among other things). In earlier versions of OpenGL (prior to 3.0), each piece of vertex information had a specific <em>channel</em> in the pipeline. It was provided to the shaders using functions such as<span> </span><kbd>glVertex</kbd>,<span> </span><kbd>glTexCoord</kbd>, and<span> </span><kbd>glNormal</kbd><span> </span>(or within client vertex arrays using<span> </span><kbd>glVertexPointer</kbd>,<span> </span><kbd>glTexCoordPointer</kbd>, or<span> </span><kbd>glNormalPointer</kbd>). The shader would then access these values via built-in variables such as<span> </span><kbd>gl_Vertex</kbd><span> </span>and<span> </span><kbd>gl_Normal</kbd>. This functionality was deprecated in OpenGL 3.0 and later removed. Instead, vertex information must now be provided using<span> </span><em>generic vertex attributes</em>, usually in conjunction with (vertex)<span> </span><em>buffer objects</em>. The programmer is now free to define an arbitrary set of per-vertex attributes to provide as input to the vertex shader. For example, in order to implement normal mapping, the programmer might decide that the position, normal vector, and tangent vector should be provided along with each vertex. With OpenGL 4, it's easy to define this as the set of input attributes. This gives us a great deal of flexibility to define our vertex information in any way that is appropriate for our application, but may require a bit of getting used to for those of us who are accustomed to the old way of doing things.</p>
<p>In the vertex shader, the per-vertex input attributes are defined by using the <kbd>in</kbd> GLSL qualifier. For example, to define a three-component vector input attribute named<span> </span><kbd>VertexColor</kbd>, we use the following code:</p>
<pre>in vec3 VertexColor; </pre>
<p>Of course, the data for this attribute must be supplied by the OpenGL program. To do so, we make use of vertex buffer objects. The buffer object contains the values for the input attribute. In the main OpenGL program, we make the connection between the buffer and the input attribute and define how to <em>step through</em> the data. Then, when rendering, OpenGL pulls data for the input attribute from the buffer for each invocation of the vertex shader.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>For this recipe, we'll draw a single triangle. Our vertex attributes will be position and color. We'll use a fragment shader to blend the colors of each vertex across the triangle to produce an image similar to the one shown as follows. The vertices of the triangle are red, green, and blue, and the interior of the triangle has those three colors blended together. The colors may not be visible in the printed text, but the variation in the shade should indicate the blending:</p>
<div class="CDPAlignCenter"><img src="assets/1865a799-6e7e-4491-a832-cd10c8898d37.png" style="width:21.92em;height:16.08em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We'll start with an empty OpenGL program, and the following shaders:</p>
<p>The vertex shader (<kbd>basic.vert.glsl</kbd>):</p>
<pre>#version 460 
 
layout (location=0) in vec3 VertexPosition; 
layout (location=1) in vec3 VertexColor; 
 
out vec3 Color; 
 
void main() 
{ 
  Color = VertexColor; 
 
  gl_Position = vec4(VertexPosition,1.0); 
}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Attributes are the input variables to a vertex shader. In the previous code, there are two input attributes:<span> </span><kbd>VertexPosition</kbd><span> </span>and<span> </span><kbd>VertexColor</kbd>. They are specified using the <kbd>in</kbd> GLSL keyword. Don't worry about the<span> </span><kbd>layout</kbd><span> </span>prefix, as we'll discuss that later. Our main OpenGL program needs to supply the data for these two attributes for each vertex. We will do so by mapping our polygon data to these variables.</p>
<p class="mce-root">It also has one output variable, named<span> </span><kbd>Color</kbd>, which is sent to the fragment shader. In this case,<span> </span><kbd>Color</kbd><span> </span>is just an unchanged copy of<span> </span><kbd>VertexColor</kbd>. Also, note that the<span> </span><kbd>VertexPosition</kbd><span> attribute </span>is simply expanded and passed along to the built-in <kbd>gl_Position</kbd><span> output variable </span>for further processing.</p>
<p>The fragment shader (<kbd>basic.frag.glsl</kbd>):</p>
<pre>#version 460 
 
in vec3 Color;
out vec4 FragColor; 
 
void main() {
  FragColor = vec4(Color, 1.0); 
} </pre>
<p>There is just one input variable for this shader,<span> </span><kbd>Color</kbd>. This links to the corresponding output variable in the vertex shader, and will contain a value that has been interpolated across the triangle based on the values at the vertices. We simply expand and copy this color to the <kbd>FragColor</kbd><span> output variable </span>(more about fragment shader output variables in later recipes).</p>
<p>Write code to compile and link these shaders into a shader program (see the<span> </span><em>Compiling a shader</em> and<span> </span><em>Linking a shader program</em> recipes). In the following code, I'll assume that the handle to the shader program is<span> </span><kbd>programHandle</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Use the following steps to set up your buffer objects and render the triangle:</p>
<ol>
<li>Create a global (or private instance) variable to hold our handle to the vertex array object:</li>
</ol>
<pre style="padding-left: 60px">GLuint vaoHandle;</pre>
<ol start="2">
<li>Within the initialization function, we create and populate the vertex buffer objects for each attribute:</li>
</ol>
<pre style="padding-left: 60px">float positionData[] = { 
      -0.8f, -0.8f, 0.0f, 
      0.8f, -0.8f, 0.0f, 
      0.0f,  0.8f, 0.0f }; 
float colorData[] = { 
      1.0f, 0.0f, 0.0f, 
      0.0f, 1.0f, 0.0f, 
      0.0f, 0.0f, 1.0f }; 
 
// Create and populate the buffer objects 
GLuint vboHandles[2]; 
glGenBuffers(2, vboHandles); 
GLuint positionBufferHandle = vboHandles[0]; 
GLuint colorBufferHandle = vboHandles[1]; 
 
// Populate the position buffer 
glBindBuffer(GL_ARRAY_BUFFER, positionBufferHandle); 
glBufferData(GL_ARRAY_BUFFER, 9 * sizeof(float), <br/>       positionData, GL_STATIC_DRAW); 
 
// Populate the color buffer 
glBindBuffer(GL_ARRAY_BUFFER, colorBufferHandle); 
glBufferData(GL_ARRAY_BUFFER, 9 * sizeof(float), colorData, <br/>       GL_STATIC_DRAW);</pre>
<ol start="3">
<li>Create and define a vertex array object, which defines the relationship between the buffers and the input attributes (see <em>There's more...</em> for an alternate way to do this that is valid for OpenGL 4.3 and later):</li>
</ol>
<pre style="padding-left: 60px">// Create and set-up the vertex array object 
glGenVertexArrays( 1, &amp;vaoHandle ); 
glBindVertexArray(vaoHandle); 
 
// Enable the vertex attribute arrays 
glEnableVertexAttribArray(0);  // Vertex position 
glEnableVertexAttribArray(1);  // Vertex color 
 
// Map index 0 to the position buffer 
glBindBuffer(GL_ARRAY_BUFFER, positionBufferHandle); 
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, NULL); 
 
// Map index 1 to the color buffer 
glBindBuffer(GL_ARRAY_BUFFER, colorBufferHandle); 
glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 0, NULL);</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="4">
<li>In the render function, bind to the vertex array object and call<span> </span><kbd>glDrawArrays</kbd><span> </span>to initiate the rendering:</li>
</ol>
<pre style="padding-left: 60px">glBindVertexArray(vaoHandle); 
glDrawArrays(GL_TRIANGLES, 0, 3 ); </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Vertex attributes are the input variables to our vertex shader. In the given vertex shader, our two attributes are<span> </span><kbd>VertexPosition</kbd><span> </span>and<span> </span><kbd>VertexColor</kbd>. The main OpenGL program refers to vertex attributes by associating each (active) input variable with a generic attribute index. These generic indices are simply integers between <kbd>0</kbd> and<span> </span><kbd>GL_MAX_VERTEX_ATTRIBS - 1</kbd>. We can specify the relationship between these indices and the attributes using the<span> </span><kbd>layout</kbd><span> </span>qualifier. For example, in our vertex shader, we use the layout qualifier to assign<span> </span><kbd>VertexPosition</kbd><span> </span>to attribute index <kbd>0</kbd> and<span> </span><kbd>VertexColor</kbd><span> </span>to attribute index <kbd>1</kbd>:</p>
<pre>layout (location = 0) in vec3 VertexPosition; 
layout (location = 1) in vec3 VertexColor; </pre>
<p>We refer to the vertex attributes in our OpenGL code by referring to the corresponding generic vertex attribute index.</p>
<div class="packt_infobox"><span>It is not strictly necessary to explicitly specify the mappings between attribute variables and generic attribute indexes, because OpenGL will automatically map active vertex attributes to generic indexes when the program is linked. We could then query for the mappings and determine the indexes that correspond to the shader's input variables. It may be somewhat clearer, however, to explicitly specify the mapping, as we do in this example.</span></div>
<p>The first step involves setting up a pair of buffer objects to store our position and color data. As with most OpenGL objects, we start by creating the objects and acquiring handles to the two buffers by calling<span> </span><kbd>glGenBuffers</kbd>. We then assign each handle to a separate descriptive variable to make the following code more clear.</p>
<p>For each buffer object, we first bind the buffer to the<span> </span><kbd>GL_ARRAY_BUFFER</kbd><span> </span>binding point by calling<span> </span><kbd>glBindBuffer</kbd>. The first argument to<span> </span><kbd>glBindBuffer</kbd><span> </span>is the target binding point. In this case, since the data is essentially a generic array, we use<span> </span><kbd>GL_ARRAY_BUFFER</kbd>. Examples of other kinds of targets (such as<span> </span><kbd>GL_UNIFORM_BUFFER</kbd> or<span> </span><kbd>GL_ELEMENT_ARRAY_BUFFER</kbd>) will be seen in later examples.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Once our buffer object is bound, we can populate the buffer with our vertex/color data by calling<span> </span><kbd>glBufferData</kbd>. The second and third arguments to this function are the size of the array and a pointer to the array containing the data. Let's focus on the first and last arguments. The first argument indicates the target buffer object. The data provided in the third argument is copied into the buffer that is bound to this binding point. The last argument is one that gives OpenGL a hint about how the data will be used so that it can determine how best to manage the buffer internally. For full details about this argument, take a look into the OpenGL documentation. In our case, the data is specified once, will not be modified, and will be used many times for drawing operations, so this usage pattern best corresponds to the <span> </span><kbd>GL_STATIC_DRAW</kbd> value.</p>
<p>Now that we have set up our buffer objects, we tie them together into a<span> </span><strong>Vertex Array Object</strong> (<strong>VAO</strong>). The VAO contains information about the connections between the data in our buffers and the input vertex attributes. We create a VAO using the <kbd>glGenVertexArrays</kbd> <span>function. </span>This gives us a handle to our new object, which we store in the<span> </span><kbd>vaoHandle</kbd> (global) variable. Then, we enable the generic vertex attribute indexes <kbd>0</kbd> and <kbd>1</kbd> by calling<span> </span><kbd>glEnableVertexAttribArray</kbd>. Doing so indicates that that the values for the attributes will be accessed and used for rendering.</p>
<p>The next step makes the connection between the buffer objects and the generic vertex attribute indexes:</p>
<pre>// Map index 0 to the position buffer 
glBindBuffer(GL_ARRAY_BUFFER, positionBufferHandle); 
glVertexAttribPointer( 0, 3, GL_FLOAT, GL_FALSE, 0, NULL ); </pre>
<p>First, we bind the buffer object to the<span> </span><kbd>GL_ARRAY_BUFFER</kbd><span> </span>binding point, then we call<span> </span><kbd>glVertexAttribPointer</kbd>, which tells OpenGL which generic index the data should be used with, the format of the data stored in the buffer object, and where it is located within the buffer object that is bound to the<span> </span><kbd>GL_ARRAY_BUFFER</kbd><span> </span>binding point.</p>
<p>The first argument is the generic attribute index. The second is the number of components per vertex attribute (1, 2, 3, or 4). In this case, we are providing three-dimensional data, so we want three components per vertex. The third argument is the data type of each component in the buffer. The fourth is a Boolean that specifies whether the data should be automatically normalized (mapped to a range of [-1, 1] for signed integral values or [0, 1] for unsigned integral values). The fifth argument is the stride, which indicates the byte offset between consecutive attributes. Since our data is tightly packed, we can use a value of zero. The last argument is a pointer, which is not treated as a pointer! Instead, its value is interpreted as a byte offset from the beginning of the buffer to the first attribute in the buffer. In this case, there is no additional data in either buffer before the first element, so we use a value of zero.</p>
<div class="packt_infobox"><span>The </span><kbd>glVertexAttribPointer</kbd><span> function stores (in the VAO's state) a pointer to the buffer currently bound to the </span><kbd>GL_ARRAY_BUFFER</kbd><span> binding point. When another buffer is bound to that binding point, it does not change the value of the pointer.</span></div>
<p>The VAO stores all of the OpenGL states related to the relationship between buffer objects and the generic vertex attributes, as well as the information about the format of the data in the buffer objects. This allows us to quickly return all of this state when rendering.</p>
<p>The VAO is an extremely important concept, but can be tricky to understand. It's important to remember that the VAO's state is primarily associated with the enabled attributes and their connection to buffer objects. It doesn't necessarily keep track of buffer bindings. For example, it doesn't remember what is bound to the<span> </span><kbd>GL_ARRAY_BUFFER</kbd><span> </span>binding point. We only bind to this point in order to set up the pointers via<span> </span><kbd>glVertexAttribPointer</kbd>.</p>
<p>Once we have the VAO set up (a one-time operation), we can issue a draw command to render our object. In our render function, we clear the color buffer using<span> </span><kbd>glClear</kbd>, bind to the vertex array object, and call<span> </span><kbd>glDrawArrays</kbd><span> </span>to draw our triangle. The <kbd>glDrawArrays</kbd><span> function </span>initiates rendering of primitives by stepping through the buffers for each enabled attribute array, and passing the data down the pipeline to our vertex shader. The first argument is the render mode (in this case, we are drawing triangles), the second is the starting index in the enabled arrays, and the third argument is the number of indices to be rendered (three vertices for a single triangle).</p>
<p>To summarize, we followed these steps:</p>
<ol>
<li>Make sure to specify the generic vertex attribute indexes for each attribute in the vertex shader using the<span> </span><kbd>layout</kbd><span> </span>qualifier</li>
<li>Create and populate the buffer objects for each attribute</li>
<li>Create and define the vertex array object by calling<span> </span><kbd>glVertexAttribPointer</kbd><span> </span>while the appropriate buffer is bound</li>
<li>When rendering, bind to the vertex array object and call<span> </span><kbd>glDrawArrays</kbd>, or an other appropriate rendering function (for example,<span> </span><kbd>glDrawElements</kbd>)</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>In the following section, we'll discuss some details, extensions, and alternatives to the previous technique.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Separate attribute format</h1>
                </header>
            
            <article>
                
<p>With OpenGL 4.3, we have an alternate (arguably better) way of specifying the vertex array object state (attribute format, enabled attributes, and buffers). In the previous example, the<span> </span><kbd>glVertexAttribPointer</kbd><span> </span>function does two important things. First, it indirectly specifies which buffer contains the data for the attribute which is the buffer currently bound (at the time of the call) to<span> </span><kbd>GL_ARRAY_BUFFER</kbd>. Secondly, it specifies the format of that data (type, offset, stride, and so on).</p>
<p>It is arguably clearer to separate these two concerns into their own functions. This is exactly what has been implemented in OpenGL 4.3. For example, to implement the same functionality as in step 3 of the previous<span> </span><em>How to do it...</em><span> </span>section, we would use the following code:</p>
<pre>glGenVertexArrays(1, &amp;vaoHandle); 
glBindVertexArray(vaoHandle); 
glEnableVertexAttribArray(0); 
glEnableVertexAttribArray(1); 
 
glBindVertexBuffer(0, positionBufferHandle, 0, sizeof(GLfloat)*3); 
glBindVertexBuffer(1, colorBufferHandle, 0, sizeof(GLfloat)*3); 
 
glVertexAttribFormat(0, 3, GL_FLOAT, GL_FALSE, 0); 
glVertexAttribBinding(0, 0); 
glVertexAttribFormat(1, 3, GL_FLOAT, GL_FALSE, 0); 
glVertexAttribBinding(1, 1); </pre>
<p>The first four lines of the previous code are exactly the same as in the first example. We create and bind to the VAO, then enable attributes <kbd>0</kbd> and <kbd>1</kbd>. Next, we bind our two buffers to two different indexes within the vertex buffer binding point using<span> </span><kbd>glBindVertexBuffer</kbd>. Note that we're no longer using the<span> </span><kbd>GL_ARRAY_BUFFER</kbd><span> </span>binding point. Instead, we now have a new binding point specifically for vertex buffers. This binding point has several indexes (usually from 0 - 15), so we can bind multiple buffers to this point. The first argument to<span> </span><kbd>glBindVertexBuffer</kbd><span> </span>specifies the index within the vertex buffer binding point. Here, we bind our position buffer to index <kbd>0</kbd> and our color buffer to index <kbd>1</kbd>.</p>
<div class="packt_infobox"><span>The indexes within the vertex buffer binding point need not be the same as the attribute locations.</span></div>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The other arguments to<span> </span><kbd>glBindVertexBuffer</kbd><span> </span>are as follows. The second argument is the buffer to be bound, the third is the offset from the beginning of the buffer to where the data begins, and the fourth is the stride, which is the distance between successive elements within the buffer. Unlike<span> </span><kbd>glVertexAttribPointer</kbd>, we can't use a <kbd>0</kbd> value here for tightly packed data, because OpenGL can't determine the size of the data without more information, so we need to specify it explicitly here.</p>
<p>Next, we call<span> </span><kbd>glVertexAttribFormat</kbd><span> </span>to specify the format of the data for the attribute. Note that this time, this is decoupled from the buffer that stores the data. Instead, we're just specifying the format to expect for this attribute. The arguments are the same as the first four arguments to<span> </span><kbd>glVertexAttribPointer</kbd>.</p>
<p>The <kbd>glVertexAttribBinding</kbd><span> function </span>specifies the relationship between buffers that are bound to the vertex buffer binding point and attributes. The first argument is the attribute location, and the second is the index within the vertex buffer binding point. In this example, they are the same, but they don't need to be.</p>
<p>Also note that the buffer bindings of the vertex buffer binding point (specified by<span> </span><kbd>glBindVertexBuffer</kbd>)<span> </span>are<span> </span>part of the VAO state, unlike the binding to<span> </span><kbd>GL_ARRAY_BUFFER</kbd>.</p>
<p>This version is arguably clearer and easier to understand. It removes the confusing aspects of the <em>invisible</em> pointers that are managed in the VAO, and makes the relationship between attributes and buffers much clearer with<span> </span><kbd>glVertexAttribBinding</kbd>. Additionally, it separates concerns that really don't need to be combined.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Fragment shader output</h1>
                </header>
            
            <article>
                
<p>You may have noticed that I've neglected to say anything about the <span> </span><kbd>FragColor</kbd><span> output variable </span>in the fragment shader. This variable receives the final output color for each fragment (pixel). Like vertex input variables, this variable needs to be associated with a proper location. Of course, we would typically like this to be linked to the back color buffer, which by default (in double buffered systems) is "color number" zero. (The relationship of the color numbers to render buffers can be changed by using<span> </span><kbd>glDrawBuffers</kbd>). In this program, we are relying on the fact that the linker will automatically link our only fragment output variable to color number zero. To explicitly do so, we could (and probably should) have used a layout qualifier in the fragment shader:</p>
<pre>layout (location = 0) out vec4 FragColor;</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>We are free to define multiple output variables for a fragment shader, thereby enabling us to render to multiple output buffers. This can be quite useful for specialized algorithms such as deferred rendering (see<span> </span><a href="827d2689-d7e7-4188-a7bc-2eb4d813e88d.xhtml"><span class="ChapterrefPACKT">Chapter 6</span></a>,<span> </span><em>Image Processing and Screen Space Techniques</em>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Specifying attribute indexes without using layout qualifiers</h1>
                </header>
            
            <article>
                
<p>If you'd rather not clutter up your vertex shader code with the<span> </span><kbd>layout</kbd><span> </span>qualifiers (or you're using a version of OpenGL that doesn't support them), you can define the attribute indexes within the OpenGL program. We can do so by calling<span> </span><kbd>glBindAttribLocation</kbd><span> </span>just prior to linking the shader program. For example, we'd add the following code to the main OpenGL program just before the link step:</p>
<pre>glBindAttribLocation(programHandle, 0, "VertexPosition"); 
glBindAttribLocation(programHandle, 1, "VertexColor"); </pre>
<p>This would indicate to the linker that<span> </span><kbd>VertexPosition</kbd><span> </span>should correspond to generic attribute index <kbd>0</kbd> and<span> </span><kbd>VertexColor</kbd><span> </span>to index <kbd>1</kbd>.</p>
<p>Similarly, we can specify the color number for the fragment shader output variables without using the layout qualifier. We do so by calling<span> </span><kbd>glBindFragDataLocation</kbd><span> </span>prior to linking the shader program:</p>
<pre>glBindFragDataLocation(programHandle, 0, "FragColor"); </pre>
<p>This would tell the linker to bind the<span> </span><kbd>FragColor</kbd><span> output variable </span>to color number <kbd>0</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using element arrays</h1>
                </header>
            
            <article>
                
<p>It is often the case that we need to step through our vertex arrays in a non-linear fashion. In other words, we may want to <em>jump around</em> the data rather than just move through it from beginning to end. For example, we might want to draw a cube where the vertex data consists of only eight positions (the corners of the cube). In order to draw the cube, we would need to draw 12 triangles (two for each face), each of which consists of three vertices. All of the needed position data is in the original eight positions, but to draw all the triangles, we'll need to jump around and use each position for at least three different triangles.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>To jump around in our vertex arrays, we can make use of element arrays. The element array is another buffer that defines the indices used when stepping through the vertex arrays. For details on using element arrays, take a look at the <kbd>glDrawElements</kbd><span> function </span>in the OpenGL documentation (<a href="http://www.opengl.org/sdk/docs/man"><span class="URLPACKT">http://www.opengl.org/sdk/docs/man</span></a>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Interleaved arrays</h1>
                </header>
            
            <article>
                
<p>In this example, we used two buffers (one for color and one for position). Instead, we could have used just a single buffer and combined all of the data. In general, it is possible to combine the data for multiple attributes into a single buffer. The data for multiple attributes can be interleaved within an array, so that all of the data for a given vertex is grouped together within the buffer. Doing so just requires careful use of the<span> </span>stride<span> </span>argument to<span> </span><kbd>glVertexAttribPointer</kbd><span> </span>or<span> </span><kbd>glBindVertexBuffer</kbd>. Take a look at the documentation for full details (<a href="http://www.opengl.org/sdk/docs/man"><span class="URLPACKT">http://www.opengl.org/sdk/docs/man</span></a>).</p>
<p>The decision about when to use interleaved arrays and when to use separate arrays is highly dependent on the situation. Interleaved arrays may bring better results due to the fact that data is accessed together and resides closer in memory (so-called <strong>locality of reference</strong>), resulting in better caching performance.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>The <kbd>chapter02/scenebasic_attrib.cpp</kbd><span> file </span>in the example code</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting a list of active vertex input attributes and locations</h1>
                </header>
            
            <article>
                
<p>As covered in the previous recipe, the input variables within a vertex shader are linked to generic vertex attribute indices at the time the program is linked. If we need to specify the relationship, we can either use layout qualifiers within the shader, or we could call<span> </span><kbd>glBindAttribLocation</kbd><span> </span>before linking.</p>
<p>However, it may be preferable to let the linker create the mappings automatically and query for them after program linking is complete. In this recipe, we'll see a simple example that prints all the active attributes and their indices.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Start with an OpenGL program that compiles and links a shader pair. You could use the shaders from the previous recipe.</p>
<p>As in previous recipes, we'll assume that the handle to the shader program is stored in a variable named<span> </span><kbd>programHandle</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>After linking and enabling the shader program, use the following code to display the list of active attributes:</p>
<ol>
<li>Start by querying for the number of active attributes:</li>
</ol>
<pre style="padding-left: 60px">GLint numAttribs; 
glGetProgramInterfaceiv(programHandle, GL_PROGRAM_INPUT,<br/>        GL_ACTIVE_RESOURCES, &amp;numAttribs);</pre>
<ol start="2">
<li>Loop through each attribute, query for the length of the name, the type, and the attribute location, and print the results to standard out:</li>
</ol>
<pre style="padding-left: 60px">GLenum properties[] = {GL_NAME_LENGTH, GL_TYPE, GL_LOCATION};
 
std::cout &lt;&lt; "Active attributes" &lt;&lt; std::endl; 
for( int i = 0; i &lt; numAttribs; ++i ) { 
  GLint results[3]; 
  glGetProgramResourceiv(programHhandle, GL_PROGRAM_INPUT,<br/>        i, 3, properties, 3, NULL, results); 
 
  GLint nameBufSize = results[0] + 1; 
  char * name = new char[nameBufSize]; 
  glGetProgramResourceName(programHandle, <br/>       GL_PROGRAM_INPUT, i, nameBufSize, NULL, name);  <br/>  printf("%-5d %s (%s)n", results[2], name, <br/>  getTypeString(results[1])); 
  delete [] name; 
}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In step 1, we query for the number of active attributes by calling<span> </span><kbd>glGetProgramInterfaceiv</kbd>. The first argument is the handle to the program object, and the second (<kbd>GL_PROGRAM_INPUT</kbd>) indicates that we are querying for information about the program input variables (the vertex attributes). The third argument (<kbd>GL_ACTIVE_RESOURCES</kbd>) indicates that we want the number of active resources. The result is stored in the location pointed to by the last argument,<span> </span><kbd>numAttribs</kbd>.</p>
<p>Now that we have the number of attributes, we query for information about each one. The indices of the attributes run from <kbd>0</kbd> to<span> </span><kbd>numAttribs-1</kbd>. We loop over those indices and for each we call<span> </span><kbd>glGetProgramResourceiv</kbd><span> </span>to get the length of the name, the type, and the location. We specify what information we would like to receive by means of an array of<span> </span><kbd>GLenum</kbd><span> </span>values called<span> </span><kbd>properties</kbd>. The first argument is the handle to the program object, the second is the resource that we are querying (<kbd>GL_PROGRAM_INPUT</kbd>). The third is the index of the attribute and the fourth is the number of values in the<span> </span><kbd>properties</kbd><span> </span>array, which is the fifth argument. The<span> </span><kbd>properties</kbd><span> </span>array contains<span> </span><kbd>GLenum</kbd> values, which specify the specific properties we would like to receive. In this example, the array contains <span> </span><kbd>GL_NAME_LENGTH</kbd>,<span> </span><kbd>GL_TYPE</kbd>, and<span> </span><kbd>GL_LOCATION</kbd>, which indicates that we want the length of the attribute's name, the data type of the attribute, and its location. The sixth argument is the size of the buffer that will receive the results; the seventh argument is a pointer to an integer that would receive the number of results that were written. If that argument is<span> </span><kbd>NULL</kbd>, then no information is provided. Finally, the last argument is a pointer to a<span> </span><kbd>GLint</kbd><span> </span>array that will receive the results. Each item in the<span> </span><kbd>properties</kbd><span> </span>array corresponds to the same index in the<span> </span><kbd>results</kbd><span> </span>array.</p>
<p>Next, we retrieve the name of the attribute by allocating a buffer to store the name and calling<span> </span><kbd>glGetProgramResourceName</kbd>. The<span> </span><kbd>results</kbd><span> </span>array contains the length of the name in the first element, so we allocate an array of that size with an extra character just for good measure. The OpenGL documentation says that the size returned from<span> </span><kbd>glGetProgramResourceiv</kbd><span> </span>includes the null terminator, but it doesn't hurt to make sure by making a bit of additional space. In my tests, I've found this to be necessary on the latest NVIDIA drivers.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Finally, we get the name by calling<span> </span><kbd>glGetProgramResourceName</kbd>, and then print the information to the screen. We print the attribute's location, name, and type. The location is available in the third element of the <kbd>results</kbd> array, and the type is in the second. Note the use of the <kbd><span>getTypeString</span></kbd> function. This is a simple custom function that just returns a string representation of the data type. The data type is represented by one of the OpenGL defined constants, such as<span> </span><kbd>GL_FLOAT</kbd>,<span> </span><kbd>GL_FLOAT_VEC2</kbd>, or<span> </span><kbd>GL_FLOAT_VEC3</kbd>. The<span> </span><kbd>getTypeString</kbd><span> </span>function consists of just one big <kbd>switch</kbd> statement returning a human-readable string corresponding to the value of the parameter (see the source code for<span> </span><kbd>glslprogram.cpp</kbd><span> </span>in the example code for this book).</p>
<p>The output of the previous code looks like this when it is run on the shaders from the previous recipes:</p>
<pre>    <strong>Active attributes:</strong>
    <strong>1    VertexColor (vec3)</strong>
    <strong>0    VertexPosition (vec3)</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>It should be noted that in order for a vertex shader input variable to be considered active, it must be used within the vertex shader. In other words, a variable is considered active if it is determined by the GLSL linker that it may be accessed during program execution. If a variable is declared within a shader, but not used, the previous code will not display the variable because it is not considered active and is effectively ignored by OpenGL.</p>
<p>The previous code is only valid for OpenGL 4.3 and later. Alternatively, you can achieve similar results with the <kbd>glGetProgramiv</kbd>,<span> </span><kbd>glGetActiveAttrib</kbd>,<span> </span>and<span> </span><kbd>glGetAttribLocation</kbd> <span>functions.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>The <kbd>chapter02/scenebasic_attrib.cpp</kbd><span> file </span>in the example code</li>
<li>The<span> </span><em>Compiling a shader</em><span> </span>recipe </li>
<li>The<span> </span><em>Linking a shader program</em><span> </span>recipe </li>
<li>The<span> </span><em>Sending data to a shader using vertex attributes and vertex buffer objects</em><span> </span>recipe </li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Sending data to a shader using uniform variables</h1>
                </header>
            
            <article>
                
<p>Vertex attributes offer one avenue for providing input to shaders; a second technique is uniform variables. Uniform variables are intended to be used for data that may change relatively infrequently compared to per-vertex attributes. In fact, it is simply not possible to set per-vertex attributes with uniform variables. For example, uniform variables are well-suited to the matrices used for modeling, viewing, and projective transformations.</p>
<p>Within a shader, uniform variables are read-only. Their values can only be changed from outside the shader, via the OpenGL API. However, they can be initialized within the shader by assigning them to a constant value along with the declaration.</p>
<p>Uniform variables can appear in any shader within a shader program, and are always used as input variables. They can be declared in one or more shaders within a program, but if a variable with a given name is declared in more than one shader, its type must be the same in all shaders. In other words, the uniform variables are held in a shared uniform namespace for the entire shader program.</p>
<p>In this recipe, we'll draw the same triangle as in previous recipes in this chapter; however, this time, we'll rotate the triangle using a uniform matrix variable:</p>
<div class="CDPAlignCenter"><img src="assets/63ba2410-bddf-4413-86b5-636e56c72d83.png" style="width:11.08em;height:10.50em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We'll use the following vertex shader:</p>
<pre>#version 430 
 
layout (location = 0) in vec3 VertexPosition; 
layout (location = 1) in vec3 VertexColor; 
 
out vec3 Color; 
 
uniform mat4 RotationMatrix; 
 
void main() { 
  Color = VertexColor; 
  gl_Position = RotationMatrix * vec4(VertexPosition,1.0); 
} </pre>
<p>Note that the<span> </span><kbd>RotationMatrix</kbd><span> variable </span>is declared using the uniform qualifier. We'll provide the data for this variable via the OpenGL program. The<span> </span><kbd>RotationMatrix</kbd><span> variable </span>is also used to transform<span> </span><kbd>VertexPosition</kbd><span> </span>before assigning it to the default output position variable,<span> </span><kbd>gl_Position</kbd>.</p>
<p>We'll use the same fragment shader as in the previous recipes:</p>
<pre>#version 460 
 
in vec3 Color; 
 
layout (location = 0) out vec4 FragColor; 
 
void main() { 
  FragColor = vec4(Color, 1.0); 
} </pre>
<p>Within the main OpenGL code, we determine the rotation matrix and send it to the shader's uniform variable. To create our rotation matrix, we'll use the GLM library (see the<span> </span><em>Using the GLM for mathematics</em><span> </span>recipe). Within the main OpenGL code, add the following include statements:</p>
<pre>#include &lt;glm/glm.hpp&gt; 
#include &lt;glm/gtc/matrix_transform.hpp&gt; </pre>
<p>We'll also assume that code has been written to compile and link the shaders, and to create the vertex array object for the color triangle. We'll assume that the handle to the vertex array object is<span> </span><kbd>vaoHandle</kbd>, and the handle to the program object is<span> </span><kbd>programHandle</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Within the render method, use the following code:</p>
<pre>glClear(GL_COLOR_BUFFER_BIT); 
 
glm::mat4 rotationMatrix = glm::rotate(glm::mat4(1.0f), angle, <br/>       glm::vec3(0.0f,0.0f,1.0f));<br/>GLuint location = glGetUniformLocation(programHandle,<br/>       "RotationMatrix"); 
 
if( location &gt;= 0 ) { 
  glUniformMatrix4fv(location, 1, GL_FALSE, glm::value_ptr(rotationMatrix)); 
} 
 
glBindVertexArray(vaoHandle); 
glDrawArrays(GL_TRIANGLES, 0, 3 ); </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The steps involved in setting the value of a uniform variable include finding the location of the variable, and assigning a value to that location using one of the<span> </span><kbd>glUniform</kbd><span> </span>functions.</p>
<p>In this example, we start by clearing the color buffer, then creating a rotation matrix using GLM. Next, we query for the location of the uniform variable by calling<span> </span><kbd>glGetUniformLocation</kbd>. This function takes the handle to the shader program object and the name of the uniform variable, and returns its location. If the uniform variable is not an active uniform variable, the function returns <kbd>-1</kbd>.</p>
<div class="packt_tip">It is inefficient to query the location of a uniform variable in each frame. A more efficient approach would be to cache the location during the shader compilation stage, and use it here.</div>
<p>We then assign a value to the uniform variable's location using<span> </span><kbd>glUniformMatrix4fv</kbd>. The first argument is the uniform variable's location. The second is the number of matrices that are being assigned (note that the uniform variable could be an array). The third is a Boolean value indicating whether the matrix should be transposed when loaded into the uniform variable. With GLM matrices, a transpose is not required, so we use<span> </span><kbd>GL_FALSE</kbd><span> </span>here. If you were implementing the matrix using an array, and the data was in row-major order, you might need to use<span> </span><kbd>GL_TRUE</kbd><span> </span>for this argument. The last argument is a pointer to the data for the uniform variable.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Of course, uniform variables can be any valid GLSL type, including complex types such as arrays or structures. OpenGL provides a<span> </span><kbd>glUniform</kbd><span> </span>function with the usual suffixes, appropriate for each type. For example, to assign to a variable of the<span> </span><kbd>vec3</kbd> type, one would use<span> </span><kbd>glUniform3f</kbd><span> </span>or<span> </span><kbd>glUniform3fv</kbd>.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>For arrays, one can use the functions ending in <kbd>v</kbd> to initialize multiple values within the array. Note that if it is desired, one can query for the location of a particular element of the uniform array using the<span> </span><kbd>[]</kbd><span> </span>operator. For example, to query for the location of the second element of<span> </span><kbd>MyArray</kbd>:</p>
<pre>GLuint location = <br/>   glGetUniformLocation( programHandle, "MyArray[1]" );</pre>
<p>For structures, the members of the structure must be initialized individually. As with arrays, one can query for the location of a member of a structure using something like the following:</p>
<pre>GLuint location = <br/>   glGetUniformLocation( programHandle, "MyMatrices.Rotation" );</pre>
<p>Where the structure variable is<span> </span><kbd>MyMatrices</kbd><span> </span>and the member of the structure is<span> </span><kbd>Rotation</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>The <kbd>chapter02/scenebasic_uniform.cpp</kbd><span> file </span>in the example code</li>
<li>The<span> </span><em>Compiling a shader</em><span> </span>recipe </li>
<li>The<span> </span><em>Linking a shader program</em><span> </span>recipe </li>
<li>The<span> </span><em>Sending data to a shader using vertex attributes and vertex buffer objects</em><span> </span>recipe</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting a list of active uniform variables</h1>
                </header>
            
            <article>
                
<p>While it is a simple process to query for the location of an individual uniform variable, there may be instances where it can be useful to generate a list of all active uniform variables. For example, one might choose to create a set of variables to store the location of each uniform and assign their values after the program is linked. This would avoid the need to query for uniform locations when setting the value of the uniform variables, creating slightly more efficient code.</p>
<p>The process for listing uniform variables is very similar to the process for listing attributes (see the<span> </span><em>Getting a list of active vertex input attributes and locations</em><span> </span>recipe), so this recipe will refer the reader back to the previous recipe for a detailed explanation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Start with a basic OpenGL program that compiles and links a shader program. In the following recipes, we'll assume that the handle to the program is in a variable named<span> </span><kbd>programHandle</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>After linking and enabling the shader program, use the following code to display the list of active uniforms:</p>
<ol>
<li>Start by querying for the number of active uniform variables:</li>
</ol>
<pre style="padding-left: 60px">GLint numUniforms = 0; 
glGetProgramInterfaceiv( handle, GL_UNIFORM, <br/>   GL_ACTIVE_RESOURCES, &amp;numUniforms);</pre>
<ol start="2">
<li>Loop through each uniform index and query for the length of the name, the type, the location, and the block index:</li>
</ol>
<pre style="padding-left: 60px">GLenum properties[] = {GL_NAME_LENGTH, GL_TYPE, <br/>   GL_LOCATION, GL_BLOCK_INDEX}; 
 
std::cout &lt;&lt; "Active uniforms" &lt;&lt; std::endl; 
for( int i = 0; i &lt; numUniforms; ++i ) { 
  GLint results[4]; 
  glGetProgramResourceiv(handle, GL_UNIFORM, i, 4, <br/>       properties, 4, NULL, results); 
  if( results[3] != -1 )  
        continue;    // Skip uniforms in blocks  
  GLint nameBufSize = results[0] + 1; 
  char * name = new char[nameBufSize]; 
  glGetProgramResourceName(handle, GL_UNIFORM, i, <br/>       nameBufSize, NULL, name);<br/>  printf("%-5d %s (%s)n", results[2], name, <br/>       getTypeString(results[1])); 
  delete [] name; 
} </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The process is very similar to the process shown in the <em>Getting a list of active vertex input attributes and locations</em> <span>recipe</span>. I will focus on the main differences.</p>
<p class="mce-root"/>
<p>The first and most obvious is that we use<span> </span><kbd>GL_UNIFORM</kbd><span> </span>instead of<span> </span><kbd>GL_PROGRAM_INPUT</kbd> as the interface that we are querying in<span> </span><kbd>glGetProgramResourceiv</kbd><span> </span>and<span> </span><kbd>glGetProgramInterfaceiv</kbd>. Second, we query for the block index (using<span> </span><kbd>GL_BLOCK_INDEX</kbd><span> </span>in the<span> </span><kbd>properties</kbd><span> </span>array). The reason for this is that some uniform variables are contained within a uniform block (see the <em>Using uniform blocks and uniform buffer objects</em> <span>recipe</span>). For this example, we only want information about uniforms that are not within blocks. The block index will be<span> </span><kbd>-1</kbd><span> </span>if the uniform variable is not within a block, so we skip any uniform variables that do not have a block index of<span> </span><kbd><span>-1</span></kbd>.</p>
<p>Again, we use the<span> </span><kbd>getTypeString</kbd><span> </span>function to convert the type value into a human-readable string (see the example code).</p>
<p>When this is run on the shader program from the previous recipe, we see the following output:</p>
<pre>    <strong>Active uniforms:</strong>
    <strong>0    RotationMatrix (mat4)</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>As with vertex attributes, a uniform variable is not considered active unless it is determined by the GLSL linker that it will be used within the shader.</p>
<p>The previous code is only valid for OpenGL 4.3 and later. Alternatively, you can achieve similar results using the <kbd>glGetProgramiv</kbd>,<span> </span><kbd>glGetActiveUniform</kbd>,<span> </span><kbd>glGetUniformLocation</kbd>, and<span> </span><kbd>glGetActiveUniformName</kbd> <span>functions.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>The <kbd>chapter02/scenebasic_uniform.cpp</kbd><span> file </span>in the example code</li>
<li>The<span> </span><em>Sending data to a shader using uniform variables</em><span> </span>recipe</li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using uniform blocks and uniform buffer objects</h1>
                </header>
            
            <article>
                
<p>If your program involves multiple shader programs that use the same uniform variables, one has to manage the variables separately for each program. Uniform locations are generated when a program is linked, so the locations of the uniforms may change from one program to the next. The data for those uniforms may have to be regenerated and applied to the new locations.</p>
<p>Uniform blocks were designed to ease the sharing of uniform data between programs. With uniform blocks, one can create a buffer object for storing the values of all the uniform variables, and bind the buffer to the uniform block. When changing programs, the same buffer object need only be rebound to the corresponding block in the new program.</p>
<p>A uniform block is simply a group of uniform variables defined within a syntactical structure known as a uniform block. For example, in this recipe, we'll use the following uniform block:</p>
<pre>uniform BlobSettings { 
  vec4 InnerColor; 
  vec4 OuterColor; 
  float RadiusInner; 
  float RadiusOuter; 
}; </pre>
<p>This defines a block with the name<span> </span><kbd>BlobSettings</kbd><span> </span>that contains four uniform variables. With this type of block definition, the variables within the block are still part of the global scope and do not need to be qualified with the block name.</p>
<p>The buffer object used to store the data for the uniforms is often referred to as a<span> </span><strong>uniform buffer object</strong>. We'll see that a uniform buffer object is simply a buffer object that is bound to a certain location.</p>
<p>For this recipe, we'll use a simple example to demonstrate the use of uniform buffer objects and uniform blocks. We'll draw a quad (two triangles) with texture coordinates, and use our fragment shader to fill the quad with a fuzzy circle. The circle is a solid color in the center, but at its edge, it gradually fades to the background color, as shown in the following image:</p>
<div class="CDPAlignCenter"><img src="assets/6e480890-1446-4636-90e1-48aeb854b174.png" style="width:14.83em;height:14.17em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Start with an OpenGL program that draws two triangles to form a quad. Provide the position at vertex attribute location <kbd>0</kbd>, and the texture coordinate (0 to 1 in each direction) at vertex attribute location <kbd>1</kbd> (see the<span> </span><em>Sending data to a shader using vertex attributes and vertex buffer objects</em><span> </span>recipe).</p>
<p>We'll use the following vertex shader:</p>
<pre>#version 430 
 
layout (location = 0) in vec3 VertexPosition; 
layout (location = 1) in vec3 VertexTexCoord; 
 
out vec3 TexCoord; 
 
void main() { 
  TexCoord = VertexTexCoord; 
  gl_Position = vec4(VertexPosition,1.0); 
} </pre>
<p>The fragment shader contains the uniform block, and is responsible for drawing our<br/>
fuzzy circle:</p>
<pre>#version 430 
 
in vec3 TexCoord; 
layout (location = 0) out vec4 FragColor; 
 
layout (binding = 0) uniform BlobSettings { 
  vec4 InnerColor; 
  vec4 OuterColor; 
  float RadiusInner; 
  float RadiusOuter; 
}; 
 
void main() { 
  float dx = TexCoord.x - 0.5; 
  float dy = TexCoord.y - 0.5; 
  float dist = sqrt(dx * dx + dy * dy); 
  FragColor =<br/>    mix( InnerColor, OuterColor,<br/>       smoothstep( RadiusInner, RadiusOuter, dist )); 
} </pre>
<p>Note the uniform block named<span> </span><kbd>BlobSettings</kbd>. The variables within this block define the parameters of our fuzzy circle. The <kbd>OuterColor</kbd><span> variable </span>defines the color outside of the circle.<span> </span><kbd>InnerColor</kbd><span> </span>is the color inside of the circle.<span> </span><kbd>RadiusInner</kbd><span> </span>is the radius that defines the part of the circle that is a solid color (inside the fuzzy edge), and the distance from the center of the circle to the inner edge of the fuzzy boundary.<span> </span><kbd>RadiusOuter</kbd><span> </span>is the outer edge of the fuzzy boundary of the circle (when the color is equal to<span> </span><kbd>OuterColor</kbd>).</p>
<p>The code within the main function computes the distance of the texture coordinate to the center of the quad located at (<kbd>0.5</kbd>, <kbd>0.5</kbd>). It then uses that distance to compute the color by using the<span> </span><kbd>smoothstep</kbd><span> </span>function. This function provides a value that smoothly varies between 0.0 and 1.0 when the value of the third argument is between the values of the first two arguments. Otherwise, it returns <kbd>0.0</kbd> or <kbd>1.0</kbd>, depending on whether<span> </span><kbd>dist</kbd><span> </span>is less than the first or greater than the second, respectively. The<span> </span><kbd>mix</kbd><span> </span>function is then used to linearly interpolate between<span> </span><kbd>InnerColor</kbd><span> </span>and<span> </span><kbd>OuterColor</kbd><span> </span>based on the value returned by the<span> </span><kbd>smoothstep</kbd><span> </span>function.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>In the OpenGL program, after linking the shader program, use the following steps to assign data to the uniform block in the fragment shader:</p>
<ol>
<li>Get the index of the uniform block using<span> </span><kbd>glGetUniformBlockIndex</kbd>:</li>
</ol>
<pre style="padding-left: 60px">GLuint blockIndex = glGetUniformBlockIndex(programHandle, <br/>   "BlobSettings");</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="2">
<li>Allocate space for the buffer to contain the data for the uniform block. We get the size using<span> </span><kbd>glGetActiveUniformBlockiv</kbd>:</li>
</ol>
<pre style="padding-left: 60px">GLint blockSize; 
glGetActiveUniformBlockiv(programHandle, blockIndex,<br/>        GL_UNIFORM_BLOCK_DATA_SIZE, &amp;blockSize); 
 
GLubyte * blockBuffer; 
blockBuffer = (GLubyte *) malloc(blockSize); </pre>
<ol start="3">
<li>Query for the offset of each variable within the block. To do so, we first find the index of each variable within the block:</li>
</ol>
<pre style="padding-left: 60px">const GLchar *names[] = { "InnerColor", "OuterColor",<br/>       "RadiusInner", "RadiusOuter" }; 
GLuint indices[4]; 
glGetUniformIndices(programHandle, 4, names, indices); 
 
GLint offset[4]; 
glGetActiveUniformsiv(programHandle, 4, indices, <br/>       GL_UNIFORM_OFFSET, offset);</pre>
<ol start="4">
<li>Place the data into the buffer at the appropriate offsets:</li>
</ol>
<pre style="padding-left: 60px">// Store data within the buffer at the appropriate offsets 
GLfloat outerColor[] = {0.0f, 0.0f, 0.0f, 0.0f}; 
GLfloat innerColor[] = {1.0f, 1.0f, 0.75f, 1.0f}; 
GLfloat innerRadius = 0.25f, outerRadius = 0.45f; 
 
memcpy(blockBuffer + offset[0], innerColor, <br/>       4 * sizeof(GLfloat));<br/>memcpy(blockBuffer + offset[1], outerColor, <br/>       4 * sizeof(GLfloat));<br/>memcpy(blockBuffer + offset[2], &amp;innerRadius, <br/>       sizeof(GLfloat));<br/>memcpy(blockBuffer + offset[3], &amp;outerRadius, <br/>       sizeof(GLfloat));</pre>
<ol start="5">
<li>Create the buffer object and copy the data into it:</li>
</ol>
<pre style="padding-left: 60px">GLuint uboHandle; 
glGenBuffers( 1, &amp;uboHandle ); 
glBindBuffer( GL_UNIFORM_BUFFER, uboHandle ); 
glBufferData( GL_UNIFORM_BUFFER, blockSize, blockBuffer, <br/>       GL_DYNAMIC_DRAW );</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="6">
<li>Bind the buffer object to the uniform buffer-binding point at the index specified by the binding-layout qualifier in the fragment shader (<kbd>0</kbd>):</li>
</ol>
<pre style="padding-left: 60px">glBindBufferBase(GL_UNIFORM_BUFFER, 0, uboHandle); </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Phew! This seems like a lot of work! However, the real advantage comes when using multiple programs where the same buffer object can be used for each program. Let's take a look at each step individually.</p>
<p>First, we get the index of the uniform block by calling<span> </span><kbd>glGetUniformBlockIndex</kbd>, then we query for the size of the block by calling<span> </span><kbd>glGetActiveUniformBlockiv</kbd>. After getting the size, we allocate a temporary buffer named<span> </span><kbd>blockBuffer</kbd><span> </span>to hold the data for our block.</p>
<p>The layout of data within a uniform block is implementation-dependent, and implementations may use different padding and/or byte alignment. So in order to accurately lay out our data, we need to query for the offset of each variable within the block. This is done in two steps. First, we query for the index of each variable within the block by calling<span> </span><kbd>glGetUniformIndices</kbd>. This accepts an array of the <kbd>names</kbd> variable (third argument) and returns the indices of the variables in the <kbd>indices</kbd><span> array </span>(fourth argument). Then, we use the indices to query for the offsets by calling<span> </span><kbd>glGetActiveUniformsiv</kbd>. When the fourth argument is<span> </span><kbd>GL_UNIFORM_OFFSET</kbd>, this returns the offset of each variable in the array pointed to by the fifth argument. This function can also be used to query for the size and type, however, in this case we choose not to do so in order to keep the code simple (albeit less general).</p>
<p>The next step involves filling our temporary buffer,<span> </span><kbd>blockBuffer</kbd><span>, </span>with the data for the uniforms at the appropriate offsets. Here, we use the standard library function,<span> </span><kbd>memcpy</kbd><span>, </span>to accomplish this.</p>
<p>Now that the temporary buffer is populated with the data with the appropriate layout, we can create our buffer object and copy the data into the buffer object. We call<span> </span><kbd>glGenBuffers</kbd><span> </span>to generate a buffer handle, and then bind that buffer to the<span> </span><kbd>GL_UNIFORM_BUFFER</kbd><span> </span>binding point by calling<span> </span><kbd>glBindBuffer</kbd>. The space is allocated within the buffer object and the data is copied when<span> </span><kbd>glBufferData</kbd><span> </span>is called. We use<span> </span><kbd>GL_DYNAMIC_DRAW</kbd><span> </span>as the usage hint here because uniform data may be changed somewhat often during rendering. Of course, this is entirely dependent on the situation.</p>
<p class="mce-root"/>
<p>Finally, we associate the buffer object with the uniform block by calling<span> </span><kbd>glBindBufferBase</kbd>. This function binds to an index within a buffer binding point. Certain binding points are also called <strong>indexed buffer targets</strong>. This means that the target is actually an array of targets, and<span> </span><kbd>glBindBufferBase</kbd><span> </span>allows us to bind to one index within the array. In this case, we bind it to the index that we specified in the layout qualifier in the fragment shader:<span> </span><kbd>layout (binding = 0)</kbd><span> </span>(see <em>Getting ready</em>). These two indices must match.</p>
<div class="packt_infobox"><span>You might be wondering why we use </span><kbd>glBindBuffer</kbd><span> and </span><kbd>glBindBufferBase</kbd><span> with </span><kbd>GL_UNIFORM_BUFFER</kbd><span>. Aren't these the same binding points used in two different contexts? The answer is that the </span><kbd>GL_UNIFORM_BUFFER</kbd><span> point can be used in each function with a slightly different meaning. With </span><kbd>glBindBuffer</kbd><span>, we bind to a point that can be used for filling or modifying a buffer, but can't be used as a source of data for the shader. When we use </span><kbd>glBindBufferBase</kbd><span>, we are binding to an index within a location that can be directly sourced by the shader. Granted, that's a bit confusing.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>If the data for a uniform block needs to be changed at some later time, one can call<span> </span><kbd>glBufferSubData</kbd><span> </span>to replace all or part of the data within the buffer. If you do so, don't forget to first bind the buffer to the generic binding point,<span> </span><kbd>GL_UNIFORM_BUFFER</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using an instance name with a uniform block</h1>
                </header>
            
            <article>
                
<p>A uniform block can have an optional instance name. For example, with our<span> </span><kbd>BlobSettings</kbd><span> </span>block, we could have used the instance name<span> </span><kbd>Blob</kbd>, as shown here:</p>
<pre>uniform BlobSettings { 
  vec4 InnerColor; 
  vec4 OuterColor; 
  float RadiusInner; 
  float RadiusOuter; 
} Blob;</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>In this case, the variables within the block are placed within a namespace qualified by the instance name. Therefore, our shader code needs to refer to them prefixed with the instance name. For example:</p>
<pre>FragColor =<br/>    mix( Blob.InnerColor, Blob.OuterColor,<br/>        smoothstep( Blob.RadiusInner, Blob.RadiusOuter, dist ) 
  ); </pre>
<p>Additionally, we need to qualify the variable names (with the<span> </span><kbd>BlobSettings</kbd> block name) within the OpenGL code when querying for variable indices:</p>
<pre>const GLchar *names[] = { "BlobSettings.InnerColor",  
      "BlobSettings.OuterColor", "BlobSettings. RadiusInner", 
      "BlobSettings.RadiusOuter" }; 
GLuint indices[4]; 
glGetUniformIndices(programHandle, 4, names, indices); </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using layout qualifiers with uniform blocks</h1>
                </header>
            
            <article>
                
<p>Since the layout of the data within a uniform buffer object is implementation-dependent, it required us to query for the variable offsets. However, one can avoid this by asking OpenGL to use the standard layout,<span> </span><kbd>std140</kbd>. This is accomplished by using a layout qualifier when declaring the uniform block. For example:</p>
<pre>layout( std140 ) uniform BlobSettings { 
   
}; </pre>
<p>The<span> </span><kbd>std140</kbd><span> </span>layout is described in detail within the OpenGL specification document (available at<span> </span><a href="http://www.opengl.org"><span class="URLPACKT">http://www.opengl.org</span></a>).</p>
<p>Other options for the layout qualifier that apply to uniform block layouts include<span> </span><kbd>packed</kbd><span> </span>and<span> </span><kbd>shared</kbd>. The<span> </span><kbd>packed</kbd><span> </span>qualifier simply states that the implementation is free to optimize memory in whatever way it finds necessary (based on variable usage or other criteria). With the<span> </span><kbd>packed</kbd><span> </span>qualifier, we still need to query for the offsets of each variable. The<span> </span><kbd>shared</kbd><span> </span>qualifier guarantees that the layout will be consistent between multiple programs and program stages provided that the uniform block declaration does not change. If you are planning to use the same buffer object between multiple programs and/or program stages, it is a good idea to use the<span> </span><kbd>shared</kbd><span> </span>option.</p>
<p>There are two other layout qualifiers that are worth mentioning:<span> </span><kbd>row_major</kbd><span> </span>and <kbd>column_major</kbd>. These define the ordering of data within the matrix type variables within the uniform block.</p>
<p class="mce-root"/>
<p>One can use multiple (non-conflicting) qualifiers for a block. For example, to define a block with both the<span> </span><kbd>row_major</kbd><span> </span>and<span> </span><kbd>shared</kbd><span> </span>qualifiers, we would use the following syntax:</p>
<pre>layout( row_major, shared ) uniform BlobSettings { 
   // ...
}; </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>The <kbd>chapter02/scenebasic_uniformblock.cpp</kbd><span> file </span>in the example code</li>
<li>The<span> </span><em>Sending data to a shader using uniform variables</em><span> </span>recipe</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using program pipelines</h1>
                </header>
            
            <article>
                
<p>Program pipeline objects were introduced as part of the <strong>separable shader objects </strong>extension, and moved into core OpenGL with version 4.1. They allow programmers to mix and match shader stages from multiple<span> </span><strong>separable</strong><span> </span>shader programs. To understand how this works and why it may be useful, let's go through a hypothetical example. </p>
<p>Suppose we have one vertex shader and two fragment shaders. Suppose that the code in the vertex shader will function correctly with both fragment shaders. I could simply create two different shader programs, reusing the OpenGL shader object containing the vertex shader. However, if the vertex shader has a lot of uniform variables, then every time that I switch between the two shader programs, I would (potentially) need to reset some or all of those uniform variables. This is because the uniform variables are part of the<span> </span><em>shader program's</em><span> </span>state, so changes to the uniforms in one program would not carry over to the other program, even when the two share a shader object. The uniform information is stored in the shader program object, not the shader object.</p>
<div class="packt_infobox">Shader program objects include the values of active uniform variables; this information is not stored within a shader object.</div>
<p>With separable shader objects, we can create shader programs that include one or more shader stages. Prior to this extension, we were required to include at least a vertex and fragment shader. Such programs are called separable because they are not necessarily linked to specific other stages. They can be separated and linked to different stages at different times. Separable programs can contain just a single stage (or more if desired). </p>
<p class="mce-root"/>
<p>With<span> </span><strong>program pipelines</strong>, we can create pipelines that mix and match the stages of separable programs. This enables us to avoid losing the state of uniform variables in a given shader stage when switching other stages. For example, in the preceding scenario, where we have one vertex shader (shader A) and two fragment shaders (B and C), we could create three shader programs, each containing a single stage. Then, we could create two pipelines. The first pipeline would use the vertex shader from program A and the fragment shader from program B, and the second would use the vertex shader from program A and the fragment shader from program C. We could switch between the two pipelines without losing any of the uniform variable state in shader stage A, because we haven't actually switched shader programs—we're using the same shader program (containing stage A) in both pipelines. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>For this recipe, we'll follow through with the earlier example. We'll need a single vertex shader and two compatible fragment shaders. Let's assume that the file names are<span> </span><kbd>separable.vert.glsl</kbd>,<span> </span><kbd>separable1.frag.glsl</kbd>, and<span> </span><kbd>separable2.frag.glsl</kbd>.</p>
<p>Separable shaders require you to re-declare the built-in<span> </span><kbd>gl_PerVertex</kbd><span> output block </span>if you use any of its members. Since you will nearly always use one of its members (<kbd>gl_Position</kbd>), you'll very likely need to add the following to your vertex shader:</p>
<pre>out gl_PerVertex {<br/>  vec4 gl_Position;<br/>  float gl_PointSize;<br/>  float gl_ClipDistance[];<br/>};</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Start by loading the shader files into<span> </span><kbd>std::string</kbd>:</p>
<pre>std::string vertCode  = loadShaderCode("separable.vert.glsl");<br/>std::string fragCode1 = loadShaderCode("separable1.frag.glsl");<br/>std::string fragCode2 = loadShaderCode("separable2.frag.glsl");</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Next, we'll create one shader program for each using<span> </span><kbd>glCreateShaderProgramv</kbd>:</p>
<pre>GLuint programs[3];<br/>const GLchar * codePtrs = {vertCode.c_str(), fragCode1.c_str(),  <br/>  fragCode2.c_str()};<br/>programs[0] = glCreateShaderProgramv(GL_VERTEX_SHADER, 1, codePtrs);<br/>programs[1] = glCreateShaderProgramv(GL_FRAGMENT_SHADER, 1, codePtrs + 1);<br/>programs[2] = glCreateShaderProgramv(GL_FRAGMENT_SHADER, 1, codePtrs + 2);<br/><br/>// Check for errors...</pre>
<p>Now, we'll create two program pipelines. The first will use the vertex shader and the first fragment shader, and the second will use the vertex shader and the second fragment shader:</p>
<pre>GLuint pipelines[2];<br/>glCreateProgramPipelines(2, pipelines);<br/>// First pipeline<br/>glUseProgramStages(pipelines[0], GL_VERTEX_SHADER_BIT, programs[0]);<br/>glUseProgramStages(pipelines[0], GL_FRAGMENT_SHADER_BIT, programs[1]);<br/>// Second pipeline<br/>glUseProgramStages(pipelines[1], GL_VERTEX_SHADER_BIT, programs[0]);<br/>glUseProgramStages(pipelines[1], GL_FRAGMENT_SHADER_BIT, programs[2]);</pre>
<p>To set uniform variables in separable shaders, the recommended technique is to use<span> </span><kbd>glProgramUniform</kbd><span> </span>rather than<span> </span><kbd>glUniform</kbd>. With separable shaders and program pipelines, it can be a bit tedious and tricky to determine which shader stage is affected by the<span> </span><kbd>glUniform</kbd><span> </span>functions. The<span> </span><kbd>glProgramUniform</kbd><span> </span>functions allow us to specify the target program directly. For example, here, we'll set a uniform in the vertex shader program (shared by the two pipelines):</p>
<pre>GLint location = glGetUniformLocation(programs[0], uniformName);<br/>glProgramUniform3f(programs[0], location, 0, 1, 0);</pre>
<p>To render, we first need to make sure that no programs are currently bound. If there is a program bound via<span> </span><kbd>glUseProgram</kbd>, it will ignore any program pipelines:</p>
<pre>glUseProgram(0);</pre>
<p>Now, we can use the pipelines that we set up earlier:</p>
<pre>glBindProgramPipeline(pipelines[0]);<br/>// Draw...<br/>glBindProgramPipeline(pipelines[1]);<br/>// Draw...</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The <kbd>glCreateShaderProgramv</kbd><span> function </span>provides a simple way to create a separable shader program consisting of a single stage. We pass the shader stage and the code string to function which creates a shader object, compiles it, creates a separable program, attaches the shader, and links the program, and returns the name of the new shader program. We should check for errors immediately after each call. All errors will be in the program info log. The <em>Linking a shader program</em> recipe details how to check for errors.</p>
<p>Once we have the shader programs, we create the pipelines. We create two pipeline objects using<span> </span><kbd>glCreateProgramPipelines</kbd>. Then, we set the stages for each pipeline using<span> </span><kbd>glUseProgramStages</kbd>. The first argument to<span> </span><kbd>glUseProgramStages</kbd><span> </span>is the pipeline name, the second is a bit string indicating the stages that are to be used from the program, and the last argument is the program name. The bit string for the second argument can be composed of some combination of<span> </span><kbd>GL_VERTEX_SHADER_BIT</kbd>,<span> </span><kbd>GL_FRAGMENT_SHADER_BIT</kbd>, and so on. Use the bitwise OR operator (<kbd>|</kbd>) to combine bits.</p>
<p>As mentioned earlier, when using program pipelines, it is a good idea to use<span> </span><kbd>glProgramUniform</kbd><span> </span>rather than<span> </span><kbd>glUniform</kbd><span> </span>to set uniform variables. It can be difficult to determine the program that is being affected when using<span> </span><kbd>glUniform</kbd><span> </span>due to the fact that a pipeline can and usually does involve multiple programs. There is a function called<span> </span><kbd>glActiveShaderProgram</kbd><span> </span>that can be used to specify the program affected by<span> </span><kbd>glUniform</kbd><span> </span>calls, or you can simply use<span> </span><kbd>glUseProgram</kbd>. However, there's no need to bother with any of that, because<span> </span><kbd>glProgramUniform</kbd><span> </span>makes it clear and simple. With<span> </span><kbd>glProgramUniform</kbd>, we specify the target program directly as the first argument.</p>
<p>Before rendering with pipelines, it is important to make sure that there is no program that is currently bound to the GL context via<span> </span><kbd>glUseProgram</kbd>. If there is, it will be used instead of the pipeline. Therefore, you might want to call<span> </span><kbd>glUseProgram(0)</kbd><span> </span>before rendering, just to be sure.</p>
<p>Finally, we use<span> </span><kbd>glBindProgramPipeline</kbd><span> </span>to enable one of our pipelines before rendering. In this example, the first draw will use the vertex shader and the first fragment shader. The second draw will use the vertex shader and the second fragment shader.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>In the preceding example, we used<span> </span><kbd>glCreateShaderProgramv</kbd><span> </span>to create each single-stage program. However, you can also use the more familiar<span> </span><kbd>glCreateProgram</kbd><span> </span>to do the same thing. In fact, if you want to create a program with more than one stage (say, a vertex shader and a geometry shader), you need to use<span> </span><kbd>glCreateProgram</kbd>. However, since we want to use it with shader pipelines, it is important to use<span> </span><kbd>glProgramParameteri</kbd> to designate it as a separable program. Here's an example of creating a single stage program using<span> </span><kbd>glCreateProgram</kbd>, assuming that<span> </span><kbd>vertShader</kbd><span> </span>is the name of a previously-compiled vertex shader object:</p>
<pre>GLuint program = glCreateProgram();<br/>glProgramParameteri(program, GL_PROGRAM_SEPARABLE, GL_TRUE);<br/><br/>glAttachShader(program, vertShader);<br/><br/>glLinkProgram(program);<br/>// Check for errors...</pre>
<p>You could attach more than one shader before linking.</p>
<p>Program pipelines make it easy to mix and match shader stages, while maintaining uniform state. However, the added complexity may not be worth it for many situations. If your shaders are complex, with lots of uniform states, and you need to switch portions of the pipeline often, it might be a good alternative.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>The <kbd>chapter02/sceneseparable.cpp</kbd><span> file </span>in the example code</li>
<li>The <em>Linking a shader program</em> recipe</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting debug messages</h1>
                </header>
            
            <article>
                
<p>Prior to recent versions of OpenGL, the traditional way to get debug information was to call<span> </span><kbd>glGetError</kbd>. Unfortunately, that is an exceedingly tedious method to debug a program. The<span> </span><kbd>glGetError</kbd><span> </span>function returns an error code if an error has occurred at some point before the function was called.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>This means that if we're chasing down a bug, we essentially need to call<span> </span><kbd>glGetError</kbd><span> </span>after every function call to an OpenGL function, or do a binary search-like process where we call it before and after a block of code, and then move the two calls closer to each other until we determine the source of the error. What a pain!</p>
<p>Thankfully, as of OpenGL 4.3, we now have support for a more modern method for debugging. Now, we can register a debug callback function that will be executed whenever an error occurs, or other informational message is generated. Not only that, but we can send our own custom messages to be handled by the same callback, and we can filter the messages using a variety of criteria.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Create an OpenGL program with a debug context. While it is not strictly necessary to acquire a debug context, we might not get messages that are as informative as when we are using a debug context. To create an OpenGL context using GLFW with debugging enabled, use the following function call prior to creating the window:</p>
<pre>glfwWindowHint(GLFW_OPENGL_DEBUG_CONTEXT, GL_TRUE); </pre>
<p>An OpenGL debug context will have debug messages enabled by default. If, however, you need to enable debug messages explicitly, use the following call:</p>
<pre>glEnable(GL_DEBUG_OUTPUT); </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Use the following steps:</p>
<ol>
<li>Create a callback function to receive the debug messages. The function must conform to a specific prototype described in the OpenGL documentation. For this example, we'll use the following one:</li>
</ol>
<pre style="padding-left: 60px">void debugCallback(GLenum source, GLenum type, GLuint id, <br/>       GLenum severity, GLsizei length, <br/>       const GLchar * message, const void * param) { 
 
    // Convert GLenum parameters to strings <br/>  printf("%s:%s[%s](%d): %sn", sourceStr, typeStr, <br/>       severityStr, id, message); 
}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="2">
<li>Register our callback with OpenGL using<span> </span><kbd>glDebugMessageCallback</kbd>:</li>
</ol>
<pre style="padding-left: 60px">glDebugMessageCallback( debugCallback, nullptr ); </pre>
<ol start="3">
<li>Enable all messages, all sources, all levels, and all IDs:</li>
</ol>
<pre style="padding-left: 60px">glDebugMessageControl(GL_DONT_CARE, GL_DONT_CARE, <br/>       GL_DONT_CARE, 0, NULL, GL_TRUE);</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The<span> </span><kbd>debugCallback</kbd><span> callback function </span>has several parameters, the most important of which is the debug message itself (the sixth parameter,<span> </span><kbd>message</kbd>). For this example, we simply print the message to the standard output, but we could send it to a log file or some other destination.</p>
<p>The first four parameters to<span> </span><kbd>debugCallback</kbd><span> </span>describe the source, type, ID number, and severity of the message. The ID number is an unsigned integer specific to the message. The possible values for the source, type, and severity parameters are described in the following tables.</p>
<p> </p>
<p>The source parameter can have any of the following values:</p>
<table border="1" class="table" style="border-collapse: collapse;border: 2px solid black">
<tbody>
<tr>
<td><strong>Source</strong></td>
<td><strong>Generated by</strong></td>
</tr>
<tr>
<td><kbd>GL_DEBUG_SOURCE_API</kbd></td>
<td>Calls to the OpenGL API</td>
</tr>
<tr>
<td><kbd>GL_DEBUG_SOURCE_WINDOW_SYSTEM</kbd></td>
<td>Calls to a Windows system API</td>
</tr>
<tr>
<td><kbd>GL_DEBUG_SOURCE_THIRD_PARTY</kbd></td>
<td>An application associated with OpenGL</td>
</tr>
<tr>
<td><kbd>GL_DEBUG_SOURCE_APPLICATION</kbd></td>
<td>The application itself</td>
</tr>
<tr>
<td><kbd>GL_DEBUG_SOURCE_OTHER</kbd></td>
<td>Some other source</td>
</tr>
</tbody>
</table>
<div class="packt_figure"/>
<p> </p>
<p>The type parameter can have any of the following values:</p>
<table border="1" class="table" style="border-collapse: collapse;border: 2px solid black">
<tbody>
<tr>
<td><strong>Type</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td><kbd>GL_DEBUG_TYPE_ERROR</kbd></td>
<td>An error from the OpenGL API</td>
</tr>
<tr>
<td><kbd>GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR</kbd></td>
<td>Behavior that has been deprecated</td>
</tr>
<tr>
<td><kbd>GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR</kbd></td>
<td>Undefined behavior</td>
</tr>
<tr>
<td><kbd>GL_DEBUG_TYPE_PORTABILITY</kbd></td>
<td>Some functionality is not portable</td>
</tr>
<tr>
<td><kbd>GL_DEBUG_TYPE_PERFORMANCE</kbd></td>
<td>Possible performance issues</td>
</tr>
<tr>
<td><kbd>GL_DEBUG_TYPE_MARKER</kbd></td>
<td>An annotation</td>
</tr>
<tr>
<td><kbd>GL_DEBUG_TYPE_PUSH_GROUP</kbd></td>
<td>Messages related to debug group push</td>
</tr>
<tr>
<td><kbd>GL_DEBUG_TYPE_POP_GROUP</kbd></td>
<td>Messages related to debug group pop</td>
</tr>
<tr>
<td><kbd>GL_DEBUG_TYPE_OTHER</kbd></td>
<td>Other messages</td>
</tr>
</tbody>
</table>
<div class="packt_figure"/>
<p> </p>
<p>The severity parameter can have the following values:</p>
<table border="1" class="table" style="border-collapse: collapse;border: 2px solid black">
<tbody>
<tr>
<td><strong>Severity</strong></td>
<td><strong>Meaning</strong></td>
</tr>
<tr>
<td><kbd>GL_DEBUG_SEVERITY_HIGH</kbd></td>
<td>Errors or dangerous behavior</td>
</tr>
<tr>
<td><kbd>GL_DEBUG_SEVERITY_MEDIUM</kbd></td>
<td>Major performance warnings, other warnings, or use of deprecated functionality</td>
</tr>
<tr>
<td><kbd>GL_DEBUG_SEVERITY_LOW</kbd></td>
<td>Redundant state changes, unimportant undefined behavior</td>
</tr>
<tr>
<td><kbd>GL_DEBUG_SEVERITY_NOTIFICATION</kbd></td>
<td>A notification, not an error, or performance issue</td>
</tr>
</tbody>
</table>
<div class="packt_figure"/>
<p> </p>
<p>The<span> </span><kbd>length</kbd><span> </span>parameter is the length of the message string, excluding the null terminator. The last parameter,<span> </span><kbd>param</kbd><span>, </span>is a user-defined pointer. We can use this to point to some custom objects that might be helpful to the callback function. This parameter can be set using the second parameter to<span> </span><kbd>glDebugMessageCallback</kbd>.</p>
<p>Within<span> </span><kbd>debugCallback</kbd><span>, </span>we convert each<span> </span><kbd>GLenum</kbd><span> </span>parameter into a string. Due to space constraints, I don't show all of that code here, but it can be found in the example code for this book. We then print all of the information to the standard output.</p>
<p>The call to<span> </span><kbd>glDebugMessageCallback</kbd><span> </span>registers our callback function with the OpenGL debug system. The first parameter is a pointer to our callback function, and the second parameter (<kbd>nullptr</kbd>,<span> </span>in this example) can be a pointer to any object that we would like to pass into the callback. This pointer is passed as the last parameter with every call to<span> </span><kbd>debugCallback</kbd>.</p>
<p>Finally, the call to<span> </span><kbd>glDebugMessageControl</kbd><span> </span>determines our message filters. This function can be used to selectively turn on or off any combination of message source, type, ID, or severity. In this example, we turn everything on.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>OpenGL also provides support for stacks of named debug groups. This means that we can remember all of our debug message filter settings on a stack and return to them after some changes have been made. This might be useful, for example, if there are sections of code where we need to filter some kinds of messages and other sections where we want a different set of messages.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The functions involved are<span> </span><kbd>glPushDebugGroup</kbd><span> </span>and<span> </span><kbd>glPopDebugGroup</kbd>. A call to<span> </span><kbd>glPushDebugGroup</kbd><span> </span>generates a debug message with the<span> </span><kbd>GL_DEBUG_TYPE_PUSH_GROUP</kbd> type, and retains the current state of our debug filters on a stack. We can then change our filters using<span> </span><kbd>glDebugMessageControl</kbd>, and later return to the original state using<span> </span><kbd>glPopDebugGroup</kbd>. Similarly, the<span> </span><kbd>glPopDebugGroup</kbd><span> function </span>generates a debug message with the<span> </span><kbd>GL_DEBUG_TYPE_POP_GROUP</kbd> type.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building a C++ shader program class</h1>
                </header>
            
            <article>
                
<p>If you are using C++, it can be very convenient to create classes to encapsulate some of the OpenGL objects. A prime example is the shader program object. In this recipe, we'll look at a design for a C++ class that can be used to manage a shader program.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>There's not much to prepare for with this one; you just need a build environment that supports C++. Also, I'll assume that you are using GLM for matrix and vector support; if not, just leave out the functions involving the GLM classes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>First, we'll use a custom exception class for errors that might occur during compilation or linking:</p>
<pre>class GLSLProgramException : public std::runtime_error { 
public: 
  GLSLProgramException( const string &amp; msg ) : <br/>       std::runtime_error(msg) { } 
};</pre>
<p>We'll use <kbd>enum</kbd><span> </span>for the various shader types:</p>
<pre>namespace GLSLShader { 
  enum GLSLShaderType { 
        VERTEX = GL_VERTEX_SHADER,  
        FRAGMENT = GL_FRAGMENT_SHADER,  
        GEOMETRY = GL_GEOMETRY_SHADER,  
        TESS_CONTROL = GL_TESS_CONTROL_SHADER,<br/>        TESS_EVALUATION = GL_TESS_EVALUATION_SHADER,  
        COMPUTE = GL_COMPUTE_SHADER 
  }; 
}; </pre>
<p>The program class itself has the following interface:</p>
<pre>class GLSLProgram  { 
private: 
  int  handle; 
  bool linked; 
  std::map&lt;string, int&gt; uniformLocations;<br/>  GLint getUniformLocation(const char *);
 
  // A few other helper functions 
 
public: 
  GLSLProgram();
  ~GLSLProgram();<br/><br/>  // Make it non-copyable<br/>  GLSLProgram(const GLSLProgram &amp;) = delete;<br/>  GLSLProgram &amp; operator=(const GLSLProgram &amp;) = delete; 
 
  void compileShader( const char * filename );  <br/>  void compileShader( const char * filename, <br/>  GLSLShader::GLSLShaderType type );<br/>  void compileShader( const string &amp; source, <br/>       GLSLShader::GLSLShaderType type,<br/>       const char * filename = nullptr );
  void link();
  void use();
  void validate();
 
  int    getHandle(); 
  bool   isLinked(); 
 
  void   bindAttribLocation( GLuint location, const char * name);  <br/>  void   bindFragDataLocation( GLuint location, const char * name );  <br/>  void   setUniform(const char *name, float x, float y, float z); 
  void   setUniform(const char *name, const glm::vec3 &amp; v); 
  void   setUniform(const char *name, const glm::vec4 &amp; v); 
  void   setUniform(const char *name, const glm::mat4 &amp; m); 
  void   setUniform(const char *name, const glm::mat3 &amp; m); 
  void   setUniform(const char *name, float val ); 
  void   setUniform(const char *name, int val ); 
  void   setUniform(const char *name, bool val );<br/><br/><span>  void </span><span>findUniformLocations</span>()<span>;<br/>  // ... <br/></span>};</pre>
<div class="packt_tip"><span class="packt_screen">Code download tip</span><span class="packt_screen"><br/>
<br/></span> <span>The full source code for all of the recipes in this text is available </span><span>on GitHub at <a href="https://github.com/PacktPublishing/OpenGL-4-Shading-Language-Cookbook-Third-Edition">https://github.com/PacktPublishing/OpenGL-4-Shading-Language-Cookbook-Third-Edition</a></span><span>.</span><br/>
<br/>
<span>You can also download the example code files for all Packt books you have purchased from your account at </span><a href="http://www.packtpub.com"><span class="URLPACKT">http://www.packtpub.com</span></a><span>. If you purchased this book elsewhere, you can visit </span><a href="http://www.packtpub.com/support"><span class="URLPACKT">http://www.packtpub.com/support</span></a><span> and register to </span><span>have the files emailed directly to you.</span></div>
<p>The techniques involved in the implementation of these functions are covered in previous recipes in this chapter. Due to space limitations, I won't include the code here (it's available from this book's GitHub repository), but we'll discuss some of the design decisions in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The state stored within a<span> </span><kbd>GLSLProgram</kbd><span> </span>object includes the handle to the OpenGL shader program object (<kbd>handle</kbd>), a<span> </span><kbd>bool</kbd><span> </span>variable indicating whether or not the program has been successfully linked (<kbd>linked</kbd>), and <kbd>map</kbd>,<span> which is </span>used to store<span> </span><kbd>uniform</kbd><span> </span>locations as they are discovered (<kbd>uniformLocations</kbd>).</p>
<p>The<span> </span><kbd>compileShader</kbd><span> </span>overloads will throw <kbd>GLSLProgramException</kbd><span> </span>if the compilation fails. The first version determines the type of shader based on the filename extension. In the second version, the caller provides the shader type, and the third version is used to compile a shader, taking the shader's source code from a<span> </span>string. The filename can be provided as a third argument if the<span> </span>string<span> </span>was taken from a file, which is helpful for providing better error messages.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The <kbd>GLSLProgramException</kbd> error message will contain the contents of the shader log or program log when an error occurs.</p>
<p>The <kbd>getUniformLocation</kbd><span> private function </span>is used by the<span> </span><kbd>setUniform</kbd><span> </span>functions to find the location of a uniform variable. It checks the <kbd>uniformLocations</kbd><span> map </span>first, and if the location is not found, queries OpenGL for the location, and stores the result in the map before returning. The<span> </span><kbd>fileExists</kbd><span> </span>function is used by<span> </span><kbd>compileShaderFromFile</kbd><span> </span>to check for file existence.</p>
<p>The constructor simply initializes<span> </span><kbd>linked</kbd><span> </span>to <kbd>false</kbd> and<span> </span><kbd>handle</kbd><span> </span>to <kbd>0</kbd>. The <kbd>handle</kbd><span> variable </span>will be initialized by calling<span> </span><kbd>glCreateProgram</kbd><span> </span>when the first shader is compiled.</p>
<p>The<span> </span><kbd>link</kbd><span> </span>function simply attempts to link the program by calling<span> </span><kbd>glLinkProgram</kbd>. It then checks the link status, and if successful, sets the<span> </span><kbd>linked</kbd><span> variable </span>to<span> </span><kbd>true</kbd><span> </span>and returns<span> </span><kbd>true</kbd>. Otherwise, it gets the program log (by calling<span> </span><kbd>glGetProgramInfoLog</kbd>), stores the result in <kbd>GLSLProgramException</kbd><span>, </span>and throws it. If the link is successful, it calls <kbd>findUniformLocations</kbd><span>, which gets a list of all active uniform variables and stores their locations in the map named</span><span> </span><kbd>uniformLocations</kbd><span>, </span><span>keyed by their names. Regardless of whether the link is successful, it detaches and deletes all shader objects before returning or throwing an exception.  After all of this, it detaches and deletes the shader objects, because they are no longer needed.  </span></p>
<p>The<span> </span><kbd>use</kbd><span> </span>function simply calls<span> </span><kbd>glUseProgram</kbd><span> </span>if the program has already been successfully linked, otherwise it does nothing.</p>
<p>The<span> </span><kbd>getHandle</kbd><span> </span>and<span> </span><kbd>isLinked</kbd><span> functions </span>are simply <em>getter</em> functions that return <kbd>handle</kbd> to the OpenGL program object and the value of the<span> </span><kbd>linked</kbd><span> </span>variable.</p>
<p>The<span> </span><kbd>bindAttribLocation</kbd><span> </span>and<span> </span><kbd>bindFragDataLocation</kbd><span> functions </span>are wrappers around<span> </span><kbd>glBindAttribLocation</kbd><span> </span>and<span> </span><kbd>glBindFragDataLocation</kbd>. Note that these functions should only be called prior to linking the program.</p>
<p>The<span> </span><kbd>setUniform</kbd><span> </span>overloaded functions are straightforward wrappers around the appropriate<span> </span><kbd>glUniform</kbd><span> </span>functions. As mentioned previously, the uniform locations are queried and stored when the program is linked, so each <kbd>setUniform</kbd> function checks the map to get the cached uniform location.</p>
<p>The destructor takes care of deleting the program object.</p>
<p class="mce-root"/>
<p>Finally, the<span> </span><kbd>printActiveUniforms</kbd>,<span> </span><kbd>printActiveUniformBlocks</kbd>, and<span> </span><kbd>printActiveAttribs</kbd><span> </span>functions are useful for debugging purposes. They simply display a list of the active<span> </span><kbd>uniforms/attributes</kbd><span> </span>to the standard output.</p>
<p>The following is a simple example of the use of the<span> </span><kbd>GLSLProgram</kbd><span> </span>class:</p>
<pre>GLSLProgram prog; 
 
try { 
  prog.compileShader("myshader.vert.glsl"); 
  prog.compileShader("myshader.frag.glsl"); 
  prog.link(); 
  prog.validate(); 
  prog.use(); 
} catch( GLSLProgramException &amp;e ) { 
  cerr &lt;&lt; e.what() &lt;&lt; endl; 
  exit(EXIT_FAILURE); 
} 
 
prog.setUniform("ModelViewMatrix", matrix); 
prog.setUniform("LightPosition", 1.0f, 1.0f, 1.0f); </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>The <kbd>ingredients/glslprogram.cpp</kbd><span> file </span>in the example code</li>
<li>For the full source code, check out the GitHub site for this book at <a href="https://github.com/PacktPublishing/OpenGL-4-Shading-Language-Cookbook-Third-Edition">https://github.com/PacktPublishing/OpenGL-4-Shading-Language-Cookbook-Third-Edition</a></li>
<li>All of the recipes in this chapter</li>
</ul>


            </article>

            
        </section>
    </body></html>