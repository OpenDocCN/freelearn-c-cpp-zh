- en: In-scene Video and Visual Effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'UE4 has some amazing in-game visual effects. Media Framework is a very cool
    tool and is used to add in-scene video to a game. Unreal also has some significantly-developed,
    but not entirely ready-to-go, tools for capturing realtime video. In this chapter,
    we''ll capture a section of video from gameplay, then project it onto a surface
    as in-scene video playback. Unreal also offers a huge variety of visual FX, and
    to spice up our weapon impacts, we''ll add some impact particles with physics to
    have a basis for these kinds of options as well. This chapter will focus on:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an in-game video player with Media Framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create assets and a material to add this to any actor in the map
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Triggering and repeating our video
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding physics-based particles to the game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an emitter for our projectiles and spawning it on hit-events
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Orienting and modifying particles to have a cool motion/feel
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will implement its components in the `Chapter 12` branch of our
    project on GitHub: [https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-12](https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-12).
  prefs: []
  type: TYPE_NORMAL
- en: We used Engine version 4.19.2.
  prefs: []
  type: TYPE_NORMAL
- en: Playing in-scene video with Media Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Media Framework adds several helpful key systems to play videos in-engine. However,
    the one we will focus on here is playing an in-scene video with audio playback
    on a "screen" triggered by our player. This is a very common and popular feature
    in many games, and using Unreal's render target materials, you can put realtime
    renders of other areas of your map anywhere. The classic example being security
    cameras showing you other areas. But to reiterate, we're just focusing on how
    to get a movie into the game to prove what can be done and learn what's involved
    in adding it to a game. First, however, we'll need a few new items.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our assets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several components needed to make a nice in-scene video player, let''s
    quickly enumerate them here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The source video, of course! In Epic''s documentation, they list supported
    files, but a nice short version is: when in doubt, use MP4s, as they work across
    every platform (more on the specific one here in a moment).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A File Media Source object that references, well, this source media (in our
    case, our video).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Media Player object that does the work at runtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An associated Media Texture asset.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Material that uses this texture.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, the great news about UE4 is that lot of this is automated for you, so don't
    get intimidated by that list, this will go surprisingly quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a quick aside, I''ll describe generally where this specific video came from,
    as the actual video file is key to this whole concept. There are, of course, a
    number of ways to capture video. While this book is not meant to be an endorsement
    of any specific outside products (other than recognizing what development tools
    and versions were used), doing an internet search on "Windows screen capture,"
    is an easy solution. Also, using some of the game-streaming tools and apps on
    mobile devices can do this too: many have a "game mode" that captures the video
    and saves it.'
  prefs: []
  type: TYPE_NORMAL
- en: Check out the Sequence Recorder in the editor (Windows | Sequence Recorder),
    as this may be just what you need. I found a few issues with using it in the past;
    but there is constant work being done with systems like that, and if you can get
    comfortable with a supported system built in to UE4, it's the best way to go.
  prefs: []
  type: TYPE_NORMAL
- en: 'The checked-in asset you can see is literally just me walking over to our Countess
    introduction in-game scene and capturing it out to an MP4 video that will be uploaded
    with the branch to GitHub. So with this video file added to our content folder,
    we can get back to the editor, and making items in our content browser:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing needed, as noted, is a File Media Source:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/94bba451-c2a6-47b3-8078-fe72ea895525.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And as you''ll see, there''s really not much to this particular object, just
    point it to the source media and note there are options for platform player overrides:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fc4142d4-1e5e-4446-a745-f7d5b5406dc9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The last thing we''ll add here is our Media Player. Note that when making a
    new media player, you''ll get this popup and definitely want to check the box
    (as it is what automates making the media texture and wiring it up for us):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/04f11ba2-7f72-4ec5-9583-dfea740d1370.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After clicking ok, we can continue:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0efda684-9634-489c-950b-d6b3e6281ca9.png)'
  prefs: []
  type: TYPE_IMG
- en: And in here, simply drag and drop the CountessVid asset we just made into its
    list in the bottom left and the player is ready with its default settings. Our
    texture asset is now automatically created and associated (again, a great streamlining
    feature of modern UE4!). Now all we need is a material that we can generate by
    dragging the texture onto an actor, so let's progress to that.
  prefs: []
  type: TYPE_NORMAL
- en: Building and playing the video in-scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Theoretically, you can now play a video on any static mesh actor or a number
    of surfaces. Typically, though, it is just a plane, which can be dragged from
    the modes window right into the level. We''ll generate a material by dragging
    the media texture directly on to the actor we want to use (our plane in this case),
    and then you can see a dead-simple material is added and is set on the surface.
    So after doing all of that, as seen here, there''s one tricky part left: the audio
    that will fail to play if we don''t right-click the +Add Component for our in-scene
    screen (plane), add a Media Sound component, and hook its media to our player:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6deb5680-765e-4133-b22e-7dd11ada8c2c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Manually hooking up the audio this way is one of the only complaints I have
    about the process these days, so now that we''re pretty close to having everything
    we need, it''s just a matter of triggering the video and checking it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0bf9c68e-d2bc-4909-b874-88269bf738e7.png)'
  prefs: []
  type: TYPE_IMG
- en: Here a simple trigger volume is added in front of our screen, a blueprint-level
    variable (of Media Player type) is added on the left in the level blueprint, and
    with the volume selected, right-clicking in the blueprint event area lets you
    directly drop its on-actor-overlap event in and trigger an Open Source node, which
    is also set to point to our new asset. So note, this logic will trigger any and
    all instances of this material, which uses our media player, which can be great,
    but also may not be exactly what you want. There are a number of solutions there –
    the most obvious, but not nicest for asset cleanliness, is just to duplicate the
    player for each individual thing you want to play separately. Anyway, there you
    have it, we can now walk over to the screen to see and hear the Countess' intro
    sequence as many times as we like, as we trigger our MP4 video thereof!
  prefs: []
  type: TYPE_NORMAL
- en: 'One last point: when playing, this video comes across pretty dark in the scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/89c0251d-3826-4711-a1ec-75fcb723d52e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To correct that, I just did a very simple multiply on the color output in the
    material. Once again, there are a number of ways you could approach this; I always
    start with the simplest and if that does the job, move on! You can check that
    change out here, modify the constant value in the material, see the effect it
    has on our output in the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/45abc86b-83f2-462d-bbb4-59b3d86eeb2f.png)'
  prefs: []
  type: TYPE_IMG
- en: Now let's check out a couple more great visual FX that can be made with UE4
    as we haven't used their particle system much yet.
  prefs: []
  type: TYPE_NORMAL
- en: Adding physics particles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our goal here will have two parts: first, to add some sparks off of our projectile
    hits when they impact, but then to get those sparks bouncing around in the physics
    universe without utterly killing our framerate. One great piece of news is that
    UE4 supports GPU particles across all kinds of platforms for you, and in general
    this is where you want to be doing that kind of work. Should you find yourself
    in a game that is GPU-bound because of its complex visuals (or low-bar for platform
    hardware specifications), these kinds of things are often the first to go; but
    let''s not worry about that now, let''s make some pretty sparks first.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating our initial emitter on projectile hit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So some of you may remember way back at the beginning of the book that we added
    the starter content pack. Well, now we can finally put a bit more of that to use.
    Scrolling down near the bottom of the folders is StarterContent/Particles (or
    just do a wildcard search for P_Sparks in the search box). This is not exactly
    what we want, but it''s close, which is always saves time. Notice that it is already
    using some spark and smoke GPU Sprite emitters (the other being a flash/burst).
    It seems pretty close, so why not start here? Similarly for C++ classes and all
    other aspects of game development, if you can begin with something that is at
    least partially already doing the job you want, always put that to use and begin
    modifying from there for efficiency. Now, let''s take a look at these sparks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/638b0e7e-a827-445d-abd9-83eb5fcabb05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we''ll be modifying them to behave a bit differently, I simply copy and
    paste the emitter (P_Sparks asset) up to FirstPersonCPP/FX. I also renamed it
    to P_ImpactSparks so as to avoid confusion when browsing for it. Now we have our
    own fresh copy and can begin modifying it. First, though, let''s take a step back
    and just get them to spawn upon projectile impacts. We''ll need to add a new variable
    to our MasteringProjectile class and spawn them around where we spawn impact sounds:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First in our projectile''s header file we add:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then in `OnHit` down at the bottom in the `.cpp` file we add:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'And just like that, we have particles spawning at the hit locations. Simply
    go to each projectile in the `FirstPersonCPP/Blueprints/Weapons` folder and set
    all of their ImpactParticle variables to use the newly copied P_ImpactSparks asset.
    For those going through this step by step, you''ll notice some problems at this
    point:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eaf700c3-cdef-4030-ae77-29ef1aba06e8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'First, our particle systems (emitters) live forever, and second, they always
    spawn straight up and down with no imparted sense of velocity and simply flow
    to the ground as a stationary fountain would. The first is trivial to fix: open
    P_ImpactSparks in Cascade (double click the asset) and you''ll see three emitters
    in its main window. Click on the Required bar on each and scroll down on the Details
    menu, and you''ll see all three have a looping count set to 0 (loop forever) –
    set it to 1 as that fixes our infinite systems here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/92dd359d-834f-4032-a7b0-642ae60d36ee.png)'
  prefs: []
  type: TYPE_IMG
- en: I'm not a huge fan of the user interface in Cascade, but with practice I have
    seen FX artists that work in it masterfully and can find and modify systems very
    quickly. In this case, we'll likely want to increase the sparks' velocity and
    reduce that emitter's lifetime, but these are all more or less cosmetic things.
    Our last issues are to get them orienting properly for the way the projectiles
    hit the surfaces and make sure we can tune the spark behavior coming off of them
    if needed for performance reasons.
  prefs: []
  type: TYPE_NORMAL
- en: So why not use Niagara, the newer editor for the particles? Honestly, in this
    instance, it was my own familiarity with Cascade; but of course anyone is welcome
    to use Niagara and I will add a link to it (which starts with a link to the differences
    and similarities to Cascade) in Further Reading. Similar to Matinee vs. Sequencer
    earlier, both will remain and be supported, but long-term, it probably *is* a
    good idea to move to Niagara.
  prefs: []
  type: TYPE_NORMAL
- en: Orienting and adjusting physics of the particles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having particle systems just rain down boring-looking sparks is not going to
    cut it with this type of effect, we need the sparks to align in a way that makes
    sense from the projectile impact. This will take just a little bit more code work
    and a little bit more Cascade work; but should come out looking good.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:** If you use blueprints to spawn various effects, it makes it much
    easier to hook up outside factors to these emitters and systems. Technical artists
    often find this invaluable to allow for a quick iteration of systems until they
    get things looking right. Just be aware that a well-meaning content creator can
    make one small node that ends up testing a huge amount of physics collisions accidentally,
    so this kind of experimentation can be dangerous for performance!'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the quick code change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a *lot* of options here, you can use Hit.Normal/Hit.ImpactNormal instead
    of the velocity to build your rotation, and not attach the particles if desired,
    for example. I found here that attaching the system made the particles feel like
    they were being "pulled with" the projectile and made for a bit of a chaotic look,
    which I liked, setting the rotation along the velocity as well. In Cascade, only
    the smoke system was currently set to inherit the parent''s velocity; I made the
    sparks do so as well (right-click in the emitter''s column area, add that field,
    and select it). Note the reduced Emitter Duration tuned value on the left:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1e14d42b-b119-4799-a233-168754f44efb.png)'
  prefs: []
  type: TYPE_IMG
- en: The end result is not quite ready for professional quality, knowing your limits
    is an important trait in growing with a team as well. Still, hopefully the journey
    here helped to boost your confidence in Unreal's awesome visual effects. There's
    so much more to explore, but having the fundamentals to take a project forward
    is what this book is all about.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve touched on just about all of the major systems traditional UE4 has to
    offer. While there are a few more specialized systems, at this point, you should
    be comfortable making a traditional game on whatever platform is desired in UE4\.
    The Unreal community has a huge amount of visual FX that can be downloaded for
    free, knowing the above you should have the confidence to go explore its deep
    options! There''s only one area we haven''t really explored yet; it''s one of
    the newest to UE4 and what we''ll cover in the next chapter: AR and VR, Unreal''s
    Augmented Reality and Virtual Reality API and projects. This is also the end of
    the updates for our main GitHub project: from its humble origins as the FirstPersonCPP
    template, to FrozenCove, its fog and lighting, to the Countess and her AI, to
    loading and saving, and effects and optimizations. I hope you have found it an
    inspiring and meaningful journey. Now on to the new worlds of AR and VR!'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Why is MP4 typically the best choice for videos in UE4? (Hint: see the *Further
    reading* section for some details)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a single Media Player is referenced on multiple actors, what happens when
    opening that media?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's the quick simple way to get your video texture and video material?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why was the constant multiplier added to color output of the material here?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's a good strategy to save time in both C++ and asset creation that we used
    with the particle emitter?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should we attach the emitter to our projectile rather than have it stay
    still in space, as first implemented?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How did we get the emitters aligned with the projectile direction?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When is it disadvantageous to have particles simulate on the GPU (which can
    easily be changed in Cascade)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Supported video types in Media Framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.unrealengine.com/en-US/Engine/MediaFramework/TechReference](https://docs.unrealengine.com/en-US/Engine/MediaFramework/TechReference)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Niagara particle editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.unrealengine.com/en-us/Engine/Niagara](https://docs.unrealengine.com/en-us/Engine/Niagara)'
  prefs: []
  type: TYPE_NORMAL
