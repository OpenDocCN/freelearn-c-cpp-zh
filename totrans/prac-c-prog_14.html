<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">General-Purpose Utilities</h1>
                </header>
            
            <article>
                
<p>In this chapter, we are going to learn about the different functions that are used when performing different tasks. We will learn how to register functions that execute automatically when a program terminates. We will learn about functions that measure the clock ticks and CPU seconds required for the execution of certain tasks. We will also learn how to allocate memory at runtime, and then free it up when its task is over. Finally, we will learn how to handle different signals. </p>
<p>In this chapter, we will dive into the following recipes:</p>
<ul>
<li>Registering a function that is called when a program exits</li>
<li>Measuring the clock ticks and CPU seconds required in the execution of a function</li>
<li>Performing dynamic memory allocation</li>
<li>Handling signals</li>
</ul>
<p>However, before we proceed, a small introduction to dynamic memory allocation and some related functions is in order.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dynamic memory allocation</h1>
                </header>
            
            <article>
                
<p>As the name suggests, <strong>dynamic memory allocation</strong> is the concept of allocating memory at runtime. Unlike static memory allocation, where the memory is prebooked, dynamic memory allocation can be booked as and when required. The size of memory that is statically allocated cannot be increased or decreased, whereas the size of dynamically allocated memory blocks can be increased and decreased as per your requirements. Additionally, when processing is over, the dynamically allocated memory can be freed so that it can be used by other applications. The following subsections describe several functions that are required in dynamic memory allocation.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">malloc()</h1>
                </header>
            
            <article>
                
<p>This function allocates memory dynamically, that is, during runtime. A block of memory of a given size in bytes is allocated and a pointer pointing to that block is returned. Here is its syntax:</p>
<pre>pointer = (data_type*) malloc(size_in_bytes)</pre>
<p class="mce-root"><span>This function doesn't initialize the allocated memory, as that memory block initially contains some garbage values.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">calloc()</h1>
                </header>
            
            <article>
                
<p>This function allocates multiple blocks of memory and returns a pointer pointing to that memory block.<span> </span><span>Here is its s</span>yntax:</p>
<pre>pointer=(data_type*) calloc( size_t num_of_blocks, size_t size_of_block )</pre>
<p class="mce-root"><span>This function initializes the allocated memory blocks to zero.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">realloc()</h1>
                </header>
            
            <article>
                
<p>As the name suggests, this function is used to reallocate or resize the allocated memory. The reallocation of memory will not result in the loss of the existing data.<span> </span><span>Here is its s</span>yntax:</p>
<pre>pointer= realloc(void *pointer, size_t new_blocksize);</pre>
<p>Here,<span> </span><kbd>pointer</kbd><span> </span>is a pointer to the existing allocated memory block. <kbd>new_blocksize</kbd> represents the new size of the block in bytes and can be smaller or larger than the existing allocated block size.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">free()</h1>
                </header>
            
            <article>
                
<p>When the job or task assigned to the allocated block of memory is over, that memory block needs to be freed up so that it can be used by another application. To free up the dynamically allocated memory, the<span> </span><kbd>free</kbd><span> </span>function is used.<span> </span><span>Here is its s</span>yntax:</p>
<pre>free(pointer);</pre>
<p class="mce-root"/>
<p>Here,<span> </span><kbd>pointer</kbd><span> </span>represents the pointer to the allocated memory.</p>
<p>Let's now begin with our first recipe!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Registering a function that is called when a program exits</h1>
                </header>
            
            <article>
                
<p><span>Our first recipe will be to register a function that executes automatically when a program terminates normally. For this recipe, we will be using the <kbd>atexit()</kbd> function. </span></p>
<p>The <kbd>atexit</kbd> function is set to point to a function; this function is automatically called without arguments when the program terminates. If more than one <kbd>atexit</kbd> function is defined in a program, then these functions will be called in the <strong>Last In, First Out</strong> (<strong>LIFO</strong>) order, that is, the function pointed to last by the <kbd>atexit</kbd> function will be executed first, followed by the second to last one, and so on.</p>
<p>The <kbd>atexit</kbd> function accepts a single mandatory parameter: the pointer to the function to be called on program termination. Additionally, the function returns <kbd>0</kbd> if the function is registered successfully, that is, the function to be invoked is successfully pointed. The function returns a nonzero value if it is not registered.</p>
<p>In this recipe, we will dynamically allocate some memory for accepting a string from the user. The string entered is displayed on the screen, and, when the program terminates, the registered function is automatically executed, which frees up the dynamically allocated memory.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it…</h1>
                </header>
            
            <article>
                
<p>Follow these steps to create a recipe that registers a function that executes automatically when a program terminates normally:</p>
<ol>
<li>Register a function using the <kbd>atexit</kbd> function.</li>
<li>Allocate some memory dynamically and allow that memory to be pointed to by a pointer.</li>
<li>Ask the user to enter a string and assign the string to the dynamically allocated memory block.</li>
<li>Display the entered string on the screen.</li>
</ol>
<ol start="5">
<li>When the program terminates, the function registered via the <kbd>atexit</kbd> function is invoked automatically.</li>
<li>The registered function simply frees up the dynamically allocated memory so that it can be used by other applications.</li>
</ol>
<p>The program for registering a function that automatically executes when a program terminates is as follows (<kbd>atexistprog1.c</kbd>):</p>
<pre>#include &lt;stdio.h&gt; <br/>#include &lt;stdlib.h&gt; <br/><br/>char *str; <br/>void freeup() <br/>{ <br/>    free(str); <br/>    printf( "Allocated memory is freed  \n"); <br/>} <br/><br/>int main() <br/>{ <br/>    int retvalue; <br/>    retvalue = atexit(freeup); <br/>    if (retvalue != 0) { <br/>        printf("Registration of function for atexit () function <br/>          failed\n"); <br/>        exit(1); <br/>    } <br/>    str = malloc( 20 * sizeof(char) ); <br/>    if( str== NULL ) <br/>    { <br/>        printf("Some error occurred in allocating memory\n"); <br/>        exit(1); <br/>    } <br/>    printf("Enter a string "); <br/>    scanf("%s", str); <br/>    printf("The string entered is %s\n", str); <br/>}</pre>
<p class="mce-root">Now, let's go behind the scenes to understand the code better.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Using the <kbd>atexit</kbd> function, register a function called <kbd>freeup</kbd>, ensuring that the <kbd>freeup</kbd> function will be invoked if the program terminates normally. The value returned by the <kbd>atexit</kbd> function is checked to see that it is zero only. If the value returned by the <kbd>atexit</kbd> function is a nonzero value, then that means the function is not registered successfully and the program will terminate after displaying an error message.</p>
<p>If the function is registered successfully, 20 bytes are dynamically allocated and the allocated memory block is assigned to a character pointer, <kbd>str</kbd>. If the <kbd>str</kbd> pointer is <kbd>NULL</kbd>, then this means an error has occurred in the allocation of the memory block. If it is confirmed that the <kbd>str</kbd> pointer is not <kbd>NULL</kbd> and is pointing to a memory block, the user will be asked to enter a string. The string entered by the user is assigned to the memory block pointed to by the <kbd>str</kbd> pointer. The string entered by the user is then displayed on the screen, and, finally, the program terminates. However, before the program terminates, the function that is registered using the <kbd>atexit</kbd> function, <kbd>freeup</kbd>, is invoked. The <kbd>freeup</kbd> function frees the memory allocated to the <kbd>str</kbd> <span>pointer </span>and displays a message:<span class="packt_screen"> </span><kbd>Allocated memory is freed</kbd>. </p>
<p>The program is compiled using GCC, as shown in the following screenshot. Because no error appears during compilation, the <kbd>atexistprog1.c</kbd> <span>program </span>has successfully compiled into a <kbd>.exe</kbd> file: <kbd>atexistprog1.exe</kbd>. Upon executing this file, the user is prompted to enter a string that is assigned to the dynamically allocated memory. On program termination, the function registered with <kbd>atexit</kbd> is executed, which frees up the dynamically allocated memory, as is confirmed by the text message in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7d8abe93-f66d-4ca9-9e7c-e38eed4ae180.png" style="width:27.83em;height:9.00em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 14.1</div>
<p>Voilà! We have successfully registered a function that is called when the program exits.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>If there is more than one function that is registered via the <kbd>atexit</kbd> function, then these functions will be executed in LIFO order. To understand this, let's modify the preceding <kbd>atexistprog1.c</kbd> program to register two functions via the <kbd>atexit</kbd> function. We will save the modified program as <kbd>atexistprog2.c</kbd> as follows (<kbd>atexistprog2.c</kbd>):</p>
<pre>#include &lt;stdio.h&gt; <br/>#include &lt;stdlib.h&gt; <br/><br/>char *str; <br/>void freeup1() <br/>{<br/>    free(str); <br/>    printf( "Allocated memory is freed  \n"); <br/>} <br/><br/>void freeup2()<br/>{ <br/>    printf( "The size of dynamic memory can be increased and decreased  \n"); <br/>} <br/><br/>int main() <br/>{<br/>    int retvalue; <br/>    retvalue = atexit(freeup1); <br/>    if (retvalue != 0) { <br/>        printf("Registration of function freeup1() for atexit () <br/>          function failed\n"); <br/>        exit(1); <br/>    }<br/>    retvalue = atexit(freeup2); <br/>    if (retvalue != 0) { <br/>        printf("Registration of function freeup2() for atexit () <br/>          function failed\n");<br/>        exit(1); <br/>    }<br/>    str = malloc( 20 * sizeof(char));<br/>    if( str== NULL ) <br/>    { <br/>        printf("Some error occurred in allocating memory\n"); <br/>        exit(1); <br/>    } <br/>    printf("Enter a string "); <br/>    scanf("%s", str); <br/>    printf("The string entered is %s\n", str); <br/>}</pre>
<p>On compiling and executing the program, we get the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4379bed0-b65e-4b7c-b4b6-639f3db57ab8.png" style="width:33.67em;height:9.67em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 14.2</div>
<p>This output confirms that the last registered function, <kbd>freeup2</kbd>, is executed first, followed by the first registered function, <kbd>freeup1</kbd>.</p>
<p>Now, let's move on to the next recipe!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Measuring the clock ticks and CPU seconds required in the execution of a function</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will learn how to find out the clock ticks and CPU seconds that are required in the execution of a function. We will create a program that contains a function. This function will simply run a nested loop and we will find out the time required to run it<span>. To do so, we will make use of the </span><kbd>clock()</kbd><span> function. </span></p>
<p><span>The </span><kbd>clock()</kbd><span> function</span> returns the processor time that is consumed by the program. Essentially, this time is dependent on the technique that the operating system uses in allocating the resources to the process. More precisely, the function returns the number of clock ticks elapsed from the time the program is invoked. The function does not require any parameters and returns either the processor time that is required in running certain statements or returns <kbd>-1</kbd> if there is any failure.</p>
<div class="packt_infobox">The time returned by the function is measured in <kbd>CLOCKS_PER_SECs</kbd> of a second, where <kbd>CLOCKS_PER_SEC</kbd> varies as per the operating system and its value is around 1,000,000. So, in order to find the number of seconds used by the CPU, the number of clock ticks returned by the function is divided by <kbd>CLOCKS_PER_SEC</kbd>.<br/>
<br/>
The value returned by the <kbd>clock()</kbd> function is of the <kbd>clock_t</kbd> data type. The <kbd>clock_t</kbd> data type is used to represent the processor time.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Follow these steps to find out the number of clock ticks and CPU seconds required to run a function:</p>
<ol>
<li>Define two variables of the <kbd>clock_t</kbd> data type for saving processor time.</li>
<li>Invoke the <kbd>clock()</kbd> function to discern the number of clock ticks elapsed from the time the program is invoked. The clock ticks are saved in one of the variables.</li>
<li>Invoke a function whose processing time has to be established.</li>
<li>Again, invoke the <kbd>clock()</kbd> function and then save the returned number of clock ticks to another variable.</li>
<li>Subtract the number of clock ticks in the two variables to discern the number of clock ticks required to execute the function.</li>
<li>Divide the number of clock ticks returned in the preceding steps by <kbd>CLOCKS_PER_SEC</kbd> to identify the number of seconds used by the function.
<ol>
<li>Both the number of clock ticks and the CPU seconds required to execute the function are displayed on the screen.</li>
</ol>
</li>
</ol>
<p>The program for knowing the number of clock ticks and CPU seconds required in executing a function is as follows (<kbd>timecalc.c</kbd>):</p>
<pre>#include &lt;time.h&gt; <br/>#include &lt;stdio.h&gt; <br/><br/>void somefunction() <br/>{ <br/>    for (int i=0; i&lt;32000; i++) <br/>    { <br/>        for (int j=0; j&lt;32000; j++) ; <br/>    } <br/>} <br/><br/>int main() <br/>{ <br/>    clock_t clocktickstart, clocktickend; <br/>    double timeconsumed; <br/>    clocktickstart = clock();  <br/>    somefunction(); <br/>    clocktickend = clock(); <br/>    timeconsumed = (double)(clocktickend - clocktickstart) / <br/>      CLOCKS_PER_SEC; <br/>    printf("Number of clocks ticks required in running the function is <br/>      : %.3f\n",  (double)(clocktickend - clocktickstart)); <br/>    printf("Time taken by program is : %.2f sec\n", timeconsumed); <br/>    return 0; <br/>}</pre>
<p class="mce-root">Now, let's go behind the scenes to understand the code better.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Define two variables, <kbd>clocktickstart</kbd> and <kbd>clocktickend</kbd>, of the <kbd>clock_t</kbd> data type, as they will be used to represent the processor time. The main idea of this program is to ascertain the time consumed during the execution of a function.</p>
<p>The <kbd>clock</kbd> function is invoked to know the number of clock ticks elapsed from the time the program is invoked. Assign the number of clock ticks returned to a <kbd>clocktickstart</kbd> variable. Then, invoke a <kbd>somefunction()</kbd> <span>function,</span> which includes a nested <kbd>for</kbd> loop. The idea of using nested loops is just to make the CPU invest some time in executing these loops. After the <kbd>somefunction</kbd> function is over, invoke the <kbd>clock()</kbd> function, and assign the number of clock ticks elapsed from the time the program is invoked to the <kbd>clocktickend</kbd> <span>variable. </span>The difference between the <kbd>clocktickend</kbd> and <kbd>clocktickstart</kbd> variables will give us the number of clock ticks used in executing the <kbd>somefunction</kbd> function. The number of clock ticks is then divided by <kbd>CLOCKS_PER_SEC</kbd> to distinguish the number of CPU seconds used to execute the function. Finally, the number of clock ticks used in executing the <kbd>somefunction</kbd> function and the CPU seconds used by it are displayed on the screen.</p>
<p class="mce-root"/>
<p>The program is compiled using GCC, as shown in the following screenshot. Because no error appears during compilation, the <kbd>timecalc.c</kbd> <span>program </span>is successfully compiled into a <kbd>.exe</kbd> file: <kbd>timecalc.exe</kbd>. Upon executing this file, the number of clock ticks and the number of CPU seconds required in the execution of the specific function in the program are displayed on the screen as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f3e91a19-d7c9-4959-8ddf-b82e83f5363c.png" style="width:41.42em;height:7.33em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 14.3</div>
<p>Now, let's move on to the next recipe!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Performing dynamic memory allocation</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will learn how to dynamically allocate some memory. We will also learn how to increase the number of memory blocks, how to decrease the number of allocated memory blocks, and how to free up memory. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>We will ask the user how many memory blocks need to be allocated, and we will <span>dynamically allocate</span> that number of memory blocks. The user will then be asked to assign integer values to those memory blocks. After that, the user will be asked how many more additional blocks need to be allocated. Similarly, the user will be asked how many memory blocks need to be reduced too. The following are the steps to be performed in order to dynamically allocate memory, by increasing and decreasing memory blocks:</p>
<ol>
<li>The user is asked to enter an integer value, and that number of memory blocks will be dynamically allocated by invoking the <kbd>calloc</kbd> function. Each allocated memory block will be capable of storing a numerical of the integer data type.</li>
<li>The user is then asked to enter values in the dynamically allocated memory blocks.</li>
</ol>
<ol start="3">
<li>Display the integer values on the screen that are assigned to the memory blocks.</li>
<li>Ask the user how many more memory blocks need to be added.</li>
<li>Invoke the <kbd>realloc</kbd> function to increase the number of allocated memory blocks.</li>
<li>Ask the user to enter the integer values in the newly added memory blocks.</li>
<li>Display all the integer values assigned to the memory blocks.</li>
<li>Ask the user how many of the available memory blocks are required.</li>
<li>Again, invoke the <kbd>realloc</kbd> function to reduce the number of allocated memory blocks.</li>
<li>Display the integer values available in the existing memory blocks.</li>
<li>Free up all of the memory blocks so that they can be used by other applications.</li>
</ol>
<p>The program for showing the benefits of dynamic memory allocation, that is, how the memory can be allocated at runtime, and how its size can be increased or decreased and is freed, is as follows (<kbd>dynamicmem.c</kbd>):</p>
<pre>#include &lt;stdio.h&gt; <br/>#include &lt;stdlib.h&gt; <br/><br/>int main() <br/>{ <br/>    int* ptr; <br/>    int m,n, i; <br/><br/>    printf("How many elements are there? "); <br/>    scanf("%d", &amp;n); <br/>    ptr = (int*)calloc(n, sizeof(int));<br/>    if (ptr == NULL) { <br/>        printf("Memory could not be allocated.\n"); <br/>        exit(0); <br/>    } <br/>    printf("Enter %d elements \n", n); <br/>    for (i = 0; i &lt; n; ++i) <br/>        scanf("%d",&amp;ptr[i]); <br/>    printf("\nThe elements entered are: \n"); <br/>    for (i = 0; i &lt; n; ++i) <br/>        printf("%d\n", ptr[i]); <br/>    printf("\nHow many elements you want to add more? "); <br/>    scanf("%d",&amp;m); <br/>    ptr = realloc(ptr, (m+n) * sizeof(int)); <br/>    printf("Enter values for %d elements\n",m); <br/>    for (i = n; i &lt; (m+n); ++i) <br/>        scanf("%d",&amp;ptr[i]); <br/>    printf("\nThe complete set of elements now are: \n"); <br/>    for (i = 0; i &lt; (m+n); ++i) <br/>        printf("%d\n", ptr[i]); <br/>    printf("\nHow many elements you want to keep ? "); <br/>    scanf("%d", &amp;m); <br/>    ptr = realloc(ptr, (m) * sizeof(int)); <br/>    printf("\nThe new set of elements now are: \n"); <br/>    for (i = 0; i &lt; m; ++i) <br/>        printf("%d\n", ptr[i]); <br/>    free(ptr);   <br/>    return 0; <br/>}</pre>
<p class="mce-root">Now, let's go behind the scenes to understand the code better.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The user will be asked to specify the number of elements. The value entered by the user will be assigned to the variable <kbd>n</kbd><span>.</span> Let's assume the value entered by the user is <kbd>4</kbd>, which is then assigned to the <span>variable </span><kbd>n</kbd><span>.</span> Using the <kbd>calloc</kbd> function, <kbd>4</kbd> memory blocks are dynamically allocated, where the size of each memory block is equal to the size consumed by an <kbd>int</kbd> data type. In other words, a memory block that can store four integer values is dynamically allocated and a pointer, <kbd>ptr</kbd>, is set to point to it. If the <kbd>ptr</kbd> pointer is <kbd>NULL</kbd>, then this means that the memory could not be allocated and the program will terminate after displaying an error message.</p>
<p>If the memory is successfully allocated, the user will be asked to enter four integer values. The values entered will be assigned to individual memory blocks pointed to by the pointer, <kbd>ptr</kbd>. The integer values entered by the user are then displayed on the screen. The user will then be asked if they want to add more elements. Assuming that the user wants to add two more memory blocks to the existing allocated ones, the value of <kbd>2</kbd> entered by the user will be assigned to the variable <kbd>m</kbd>.</p>
<p>Using the <kbd>realloc</kbd> function, the quantity of the memory blocks increases from four to six, where each memory block is able to store an integer number. The user will be asked to enter the integer values for two newly added memory blocks. To indicate that the size of memory blocks has increased from four to six, all of the six integers assigned to the memory blocks are displayed on the screen. Thereafter, the user will be asked <span>how many blocks they want to keep </span>out of the six memory blocks. Let's assume the value entered by the user is <kbd>3</kbd>; that is, the user wants to keep the integers in the first three memory blocks and discard the rest.</p>
<p>The value of <kbd>3</kbd> entered by the user will be assigned to the variable <kbd>m</kbd>. Again, the <kbd>realloc</kbd> function is invoked to reduce the number of memory blocks from six to three. Finally, the integers in the three memory blocks are displayed on the screen.</p>
<p>The program is compiled using GCC, as shown in the following screenshot. Because no error appears during compilation, the <kbd>dynamicmem.c</kbd> <span>program </span>has successfully compiled into a <kbd>.exe</kbd> file: <kbd>dynamicmem.exe</kbd>. Upon executing this file, the user is prompted to define how many memory blocks they want to dynamically allocate. After that, the user is asked how many additional memory blocks they want. The user is also asked whether they want to keep some memory blocks active from the total, thereby reducing the number of allocated memory blocks, and, finally, all the memory blocks are freed. All of the actions appear as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2835e744-847e-410d-b0ac-d25c63e6bc80.png" style="width:19.92em;height:34.75em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 14.4</div>
<p>Now, let's move on to the next recipe!</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling signals</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will learn signal handling. We will learn how to automatically raise a signal, how signals are raised by user actions, and how signals are directed to specific signal-handling functions. Signal handling is required to take necessary action when the signal occurs. The actions may include ignoring the signal, terminating the process, blocking or suspending a process, resuming a process, and many more.</p>
<p>Let's start with a quick overview of signals before we dive into the recipe.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Signals</h1>
                </header>
            
            <article>
                
<p>A signal is an indicator that is generated through software and is used to stop the usual execution of the program, and through a branch of CPU to perform some specific tasks. The signal can be generated either by a process or when the user presses <em>Ctrl </em>+ <em>C</em>. When something goes wrong or some error occurs while executing an operation, the signal acts as a medium of communication between the process and the operating system. The signal is raised by the operating system and is forwarded to the process to take necessary actions. Essentially, a corresponding signal handler is executed as a corrective measure.</p>
<p>The following are some of the important signals that you should be aware of:</p>
<ul>
<li><strong>SIGABRT</strong> (<strong>Signal Abort</strong>): This signal reports the abnormal termination of the program. The signal is raised in the case of critical errors; for example, if an assertion fails or memory could not be allocated, or any similar memory heap errors.</li>
<li><strong>SIGFPE</strong> (<strong>Signal Floating-Point Exception</strong>)<span>:</span> This signal reports an arithmetic error. Any arithmetic error, including overflow or divide by zero, is covered by this signal.</li>
<li><strong>SIGILL</strong> (<strong>Signal Illegal Instruction</strong>)<span>:</span> This signal reports illegal instructions. Such a signal is raised when the program tries to execute data or an executable file is corrupted. In other words, the signal is raised when the program is trying to execute a nonexecutable instruction.</li>
<li><strong>SIGINT</strong> (<strong>Signal Interrupt</strong>)<span>:</span> This is a program interrupt signal that is generated by the user by pressing <em>Ctrl</em> + <em>C</em>.</li>
<li><strong>SIGSEGV</strong> (<strong>Signal Segmentation Violation</strong>)<span>:</span> This signal is raised when the program tries to write into read-only memory or into a block that does not have write permissions. The signal is also raised when a program tries to read or write into memory that is outside the range that is allocated to it.</li>
<li><strong>SIGTERM</strong> (<strong>Signal Terminate</strong>): This is a termination signal that is sent to a process in order to terminate it.</li>
</ul>
<p><span>To handle signals in a program, the <kbd>signal()</kbd> function is used. Let's look at a quick introduction to the signal function.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">signal()</h1>
                </header>
            
            <article>
                
<p>The signal function directs the occurrence of the signal to any of the following signal handlers:</p>
<ul>
<li><kbd>SIG_IGN</kbd><span>:</span> This will result in the signal being ignored.</li>
<li><kbd>SIG_DFL</kbd><span>:</span> This will result in invoking the default action that is associated with the raised signal.</li>
<li><kbd>user_defined_function</kbd><span>:</span> This will result in the invoking of the user-defined function when the signal is raised.</li>
</ul>
<p>Now, let's begin with the recipe.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>The following are the steps for associating signals to signal-handling functions, automatically raise the signals, and get the desired actions performed when signals are raised by user actions:</p>
<ol>
<li>Associate a signal interrupt, <kbd>(SIGINT)</kbd>, to a function. This function will act as a signal handler.</li>
<li>Write some code in the signal handler function.</li>
<li>In the <kbd>main</kbd> function, make a <kbd>while</kbd> loop that executes 5 times. You can make the <kbd>while</kbd> loop run for as many times as you want. The <kbd>while</kbd> loop is set to display a text message after a delay of 1 second.</li>
<li>The idea is to automatically raise the signal after 5 seconds. So, after its 5 iterations, the <kbd>while</kbd> loop ends and the interrupt signal is automatically raised.</li>
</ol>
<ol start="5">
<li>The associated signal handler function is executed.</li>
<li>After executing the code in the signal handler, in the <kbd>main</kbd> function, again, associate a signal interrupt, <kbd>(SIGINT)</kbd>, with another signal handler function.</li>
<li>Set an infinite <kbd>while</kbd> loop to execute, which displays a text message after each delay of 1 second.</li>
<li>If the user presses <em>Ctrl</em> + <em>C</em> , the signal interrupt is raised and the associated signal handler is raised.</li>
<li>In the signal handler, we associate the signal interrupt with its default action.</li>
<li>Consequently, if the user presses <em>Ctrl</em> + <em>C</em> again, that is, if the signal interrupt is raised again, the default action will take place: the program will terminate.</li>
</ol>
<p>The program for showing how the signals are automatically raised, how signals are raised by the user, and how they are handled, is as follows (<kbd>signalhandling.c</kbd>):</p>
<pre>#include &lt;stdio.h&gt;<br/>#include &lt;unistd.h&gt;<br/>#include &lt;stdlib.h&gt;<br/>#include &lt;signal.h&gt;<br/><br/>void sighandler1(int signum) {<br/>    printf("Ctrl + C is auto pressed \n"); <br/>} <br/><br/>void sighandler2(int signum) { <br/>    printf("You have pressed Ctrl+c\n"); <br/>    printf("Press Ctrl+c again to exit\n"); <br/>    (void) signal(SIGINT, SIG_DFL); <br/>} <br/><br/>int main () { <br/>    int x=1; <br/>    signal(SIGINT, sighandler1); <br/>    while(x&lt;=5) { <br/>        printf("Signal will be raised automatically after 5 <br/>          seconds\n");<br/>        x++; <br/>        sleep(1); <br/>    }<br/>    raise(SIGINT); <br/>    signal(SIGINT, sighandler2);<br/>    while(1) {<br/>        printf("Infinite loop, press Ctrl+C to raise signal\n"); <br/>        sleep(1); <br/>    } <br/>    return(0); <br/>}</pre>
<p class="mce-root">Now, let's go behind the scenes to understand the code better.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Using the <kbd>signal</kbd> function, a signal interrupt, <kbd>(SIGINT)</kbd>, is associated with a function called <kbd>signalhandler1</kbd>. That is, if the interrupt is autogenerated or is generated by the user, the <kbd>sighandler1</kbd> <span>function </span>will be invoked. A counter, <kbd>x</kbd>, is initialized to <kbd>1</kbd> and a <kbd>while</kbd> loop is set to execute until the value of counter <kbd>x</kbd> becomes larger than <kbd>5</kbd>. Within the <kbd>while</kbd> loop, the following text is displayed: <kbd>Signal will be raised automatically after 5 seconds</kbd>. In addition to this, the value of counter <kbd>x</kbd> is incremented by <kbd>1</kbd> within the <kbd>while</kbd> loop. A delay of 1 second is inserted in the <kbd>while</kbd> loop. In short, the <kbd>while</kbd> loop will display a text message after a gap of 1 second each. After displaying the text message 5 times, the <kbd>raise</kbd> function is invoked to raise the <kbd>SIGINT</kbd> signal.</p>
<p>On raising the <kbd>SIGINT</kbd> signal, the <kbd>signalhandler1</kbd> function will be invoked. The <kbd>signalhandler1</kbd> function does nothing other than display a text message: <kbd>Ctrl+C is auto pressed</kbd>. After executing the <kbd>signalhandler1</kbd> function, the control resumes executing the statements in the <kbd>main</kbd> function. Again, the <kbd>signal</kbd> function is invoked and the <kbd>SIGINT</kbd> signal is associated with the <kbd>sighandler2</kbd> <span>function.</span> Once more, a <kbd>while</kbd> loop is set to execute; however, this time, the loop will run indefinitely. Within the <kbd>while</kbd> loop, a text message, <kbd>Infinite loop, press Ctrl+C to raise signal</kbd>, is displayed. After displaying the text message, a delay of 1 second is inserted; that is, the text message will keep on displaying indefinitely after a gap of 1 second. If the user presses <em>Ctrl</em> + <em>C</em>, the signal interrupt will be raised and the <kbd>sighandler2</kbd> <span>function </span>will be invoked.</p>
<p>In the <kbd>sighandler2</kbd> function, a text message, <kbd>You have pressed Ctrl+C</kbd>, is displayed on one line and, on the next line, <kbd>Press Ctrl+C again to exit</kbd> is displayed. Thereafter, the <kbd>signal</kbd> function is invoked to set the <kbd>SIGINT</kbd> signal to take the default action. The default action of the <kbd>SIGINT</kbd> interrupt is to terminate and exit from the program. This means that if the user again presses <em>Ctrl</em> + <em>C</em>, the program will terminate.</p>
<p>The program is compiled using GCC, as shown in the following screenshot. Because no error appears during compilation, the <kbd>signalhandling.c</kbd> program has successfully compiled into a <kbd>.exe</kbd> file: <kbd>signalhandling.exe</kbd>. Upon executing this file, five text messages are displayed <span>on the screen </span>through the first <kbd>while</kbd> loop. After that, the signal is automatically raised and the text message from the first signal handler appears on the screen. Thereafter, a text message from the infinite <kbd>while</kbd> loop appears. Finally, the output from the second signal handler appears, which is executed when the signal interrupt is generated by the user.  All of the actions appear as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/18d32e1f-2fb8-4b38-a22e-daf2e0eacff0.png" style="width:27.58em;height:20.92em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 14.5</div>
<p>Voilà! We have successfully handled signals.</p>


            </article>

            
        </section>
    </body></html>