["```cpp\n\ndef ADD {\n  string Mnemonic = \"add\";\n  int Opcode = 0xA0;\n}\n```", "```cpp\n\n$ llvm-tblgen --print-records inst.td\n------------- Classes -----------------\n------------- Defs -----------------\ndef ADD {\n  string Mnemonic = \"add\";\n  int Opcode = 160;\n}\n```", "```cpp\n\nclass Inst<string mnemonic, int opcode> {\n  string Mnemonic = mnemonic;\n  int Opcode = opcode;\n}\ndef ADD : Inst<\"add\", 0xA0>;\ndef SUB : Inst<\"sub\", 0xB0>;\n```", "```cpp\n\n$ llvm-tblgen --print-records inst.td\n------------- Classes -----------------\nclass Inst<string Inst:mnemonic = ?, int Inst:opcode = ?> {\n  string Mnemonic = Inst:mnemonic;\n  int Opcode = Inst:opcode;\n}\n------------- Defs -----------------\ndef ADD {       // Inst\n  string Mnemonic = \"add\";\n  int Opcode = 160;\n}\ndef SUB {       // Inst\n  string Mnemonic = \"sub\";\n  int Opcode = 176;\n}\n```", "```cpp\n\nclass Inst<string mnemonic, int opcode, bit commutable = 0> {\n  string Mnemonic = mnemonic;\n  int Opcode = opcode;\n  bit Commutable = commutable;\n}\ndef ADD : Inst<\"add\", 0xA0, 1>;\ndef SUB : Inst<\"sub\", 0xB0>;\n```", "```cpp\n\nclass Inst<string mnemonic, int opcode> {\n  string Mnemonic = mnemonic;\n  int Opcode = opcode;\n  bit Commutable = 0;\n}\ndef SUB : Inst<\"sub\", 0xB0>;\n```", "```cpp\n\nlet Commutable = 1 in\n  def ADD : Inst<\"add\", 0xA0>;\n```", "```cpp\n\ndef ADD : Inst<\"add\", 0xA0> {\n  let Commutable = 1;\n}\n```", "```cpp\n\nclass Inst<string mnemonic, int opcode> {\n  string Mnemonic = mnemonic;\n  int Opcode = opcode;\n  bit Commutable = 0;\n}\nclass CommutableInst<string mnemonic, int opcode>\n  : Inst<mnemonic, opcode> {\n  let Commutable = 1;\n}\ndef SUB : Inst<\"sub\", 0xB0>;\ndef ADD : CommutableInst<\"add\", 0xA0>;\n```", "```cpp\n\n!add(opcode, 1)\n```", "```cpp\n\n!strconcat(mnemonic,\"i\")\n```", "```cpp\n\nclass Inst<string mnemonic, int opcode> {\n  string Mnemonic = mnemonic;\n  int Opcode = opcode;\n}\n```", "```cpp\n\n    multiclass InstWithImm<string mnemonic, int opcode> {\n    ```", "```cpp\n\n      def \"\": Inst<mnemonic, opcode>;\n    ```", "```cpp\n\n      def I: Inst<!strconcat(mnemonic,\"i\"), !add(opcode, 1)>;\n    ```", "```cpp\n\n    }\n    ```", "```cpp\n\ndefm ADD : InstWithImm<\"add\", 0xA0>;\n```", "```cpp\n\n$ llvm-tblgen –print-records inst.td\n------------- Classes -----------------\nclass Inst<string Inst:mnemonic = ?, int Inst:opcode = ?> {\n  string Mnemonic = Inst:mnemonic;\n  int Opcode = Inst:opcode;\n}\n------------- Defs -----------------\ndef ADD {       // Inst\n  string Mnemonic = \"add\";\n  int Opcode = 160;\n}\ndef ADDI {      // Inst\n  string Mnemonic = \"addi\";\n  int Opcode = 161;\n}\n```", "```cpp\n\nmulticlass InstWithOps<string mnemonic, int opcode> {\n  def \"\": Inst<mnemonic, opcode>;\n  def \"I\": Inst<!strconcat(mnemonic,\"i\"), !add(opcode, 1)>;\n  def \"M\": Inst<!strconcat(mnemonic,\"m\"), !add(opcode, 2)>;\n}\n```", "```cpp\n\n    class InstDesc<string name, string suffix, int delta> {\n      string Name = name;\n      string Suffix = suffix;\n      int Delta = delta;\n    }\n    ```", "```cpp\n\n    def RegOp : InstDesc<\"\", \"\", 0>;\n    def ImmOp : InstDesc<\"I\", \"\"\", 1>;\n    def MemOp : InstDesc\"\"\"\",\"\"\"\", 2>;\n    ```", "```cpp\n\n    class getDesc<int n> {\n      InstDesc ret = !cond(!eq(n, 0) : RegOp,\n                           !eq(n, 1) : ImmOp,\n                           !eq(n, 2) : MemOp);\n    }\n    ```", "```cpp\n\n    multiclass InstWithOps<string mnemonic, int opcode> {\n      foreach I = 0-2 in {\n        defvar Name = getDesc<I>.ret.Name;\n        defvar Suffix = getDesc<I>.ret.Suffix;\n        defvar Delta = getDesc<I>.ret.Delta;\n        def Name: Inst<mnemonic # Suffix,\n                       !add(opcode, Delta)>;\n      }\n    }\n    ```", "```cpp\n\n    defm ADD : InstWithOps<\"add\", 0xA0>;\n    ```", "```cpp\n\nmulticlass InstWithOps<string mnemonic, int opcode> {\n  foreach I = [RegOp, ImmOp, MemOp] in {\n    defvar Name = I.Name;\n    defvar Suffix = I.Suffix;\n    defvar Delta = I.Delta;\n    def Name: Inst<mnemonic # Suffix, !add(opcode, Delta)>;\n  }\n}\n```", "```cpp\n\n    class Flag<string name, int val> {\n        string Name = name;\n        int Val = val;\n    }\n    ```", "```cpp\n\n    class Token {\n        string Name;\n    }\n    ```", "```cpp\n\n    class Tok<string name> : Token {\n        let Name = name;\n    }\n    ```", "```cpp\n\n    class Punctuator<string name, string spelling> : Token {\n        let Name = name;\n        string Spelling = spelling;\n    }\n    ```", "```cpp\n\n    class Keyword<string name, list<Flag> flags> : Token {\n        let Name = name;\n        list<Flag> Flags = flags;\n    }\n    ```", "```cpp\n\n    class TokenFilter<list<Token> tokens> {\n        string FunctionName;\n        list<Token> Tokens = tokens;\n    }\n    ```", "```cpp\n\n    Include \"Keyword.td\"\n    ```", "```cpp\n\n    def KEYC99  : Flag<\"KEYC99\", 0x1>;\n    def KEYCXX  : Flag<\"KEYCXX\", 0x2>;\n    def KEYCXX11: Flag<\"KEYCXX11\", 0x4>;\n    def KEYGNU  : Flag<\"KEYGNU\", 0x8>;\n    def KEYALL  : Flag<\"KEYALL\",\n                       !or(KEYC99.Val, KEYCXX.Val,\n                           KEYCXX11.Val , KEYGNU.Val)>;\n    ```", "```cpp\n\n    def : Tok<\"comment\">;\n    ```", "```cpp\n\n    def : Punctuator<\"plus\", \"+\">;\n    def : Punctuator<\"minus\", \"-\">;\n    ```", "```cpp\n\n    def kw_auto: Keyword<\"auto\", [KEYALL]>;\n    def kw_inline: Keyword<\"inline\", [KEYC99,KEYCXX,KEYGNU]>;\n    def kw_restrict: Keyword<\"restrict\", [KEYC99]>;\n    ```", "```cpp\n\n    def : TokenFilter<[kw_auto, kw_inline, kw_restrict]>;\n    ```", "```cpp\n\n    enum Flags : unsigned {\n    #define GET_TOKEN_FLAGS\n    #include \"TokenKinds.inc\"\n    }\n    ```", "```cpp\n\n    #include \"TableGenBackends.h\"\n    #include \"llvm/Support/Format.h\"\n    #include \"llvm/TableGen/Record.h\"\n    #include \"llvm/TableGen/TableGenBackend.h\"\n    #include <algorithm>\n    ```", "```cpp\n\n    using namespace llvm;\n    ```", "```cpp\n\n    namespace {\n    class TokenAndKeywordFilterEmitter {\n      RecordKeeper &Records;\n    public:\n      explicit TokenAndKeywordFilterEmitter(RecordKeeper &R)\n          : Records(R) {}\n      void run(raw_ostream &OS);\n    private:\n      void emitFlagsFragment(raw_ostream &OS);\n      void emitTokenKind(raw_ostream &OS);\n      void emitKeywordFilter(raw_ostream &OS);\n    };\n    } // End anonymous namespace\n    ```", "```cpp\n\n    void TokenAndKeywordFilterEmitter::run(raw_ostream &OS) {\n      // Emit Flag fragments.\n      Records.startTimer(\"Emit flags\");\n      emitFlagsFragment(OS);\n      // Emit token kind enum and functions.\n      Records.startTimer(\"Emit token kind\");\n      emitTokenKind(OS);\n      // Emit keyword filter code.\n      Records.startTimer(\"Emit keyword filter\");\n      emitKeywordFilter(OS);\n      Records.stopTimer();\n    }\n    ```", "```cpp\n\n    void TokenAndKeywordFilterEmitter::emitFlagsFragment(\n        raw_ostream &OS) {\n      OS << \"#ifdef GET_TOKEN_FLAGS\\n\";\n      OS << \"#undef GET_TOKEN_FLAGS\\n\";\n      for (Record *CC :\n           Records.getAllDerivedDefinitions(\"Flag\")) {\n        StringRef Name = CC->getValueAsString(\"Name\");\n        int64_t Val = CC->getValueAsInt(\"Val\");\n        OS << Name << \" = \" << format_hex(Val, 2) << \",\\n\";\n      }\n      OS << \"#endif\\n\";\n    }\n    ```", "```cpp\n\n      OS << \"#ifdef GET_TOKEN_KIND_DECLARATION\\n\"\n         << \"#undef GET_TOKEN_KIND_DECLARATION\\n\"\n         << \"namespace tok {\\n\"\n         << \"  enum TokenKind : unsigned short {\\n\";\n      for (Record *CC :\n           Records.getAllDerivedDefinitions(\"Token\")) {\n        StringRef Name = CC->getValueAsString(\"Name\");\n        OS << \"    \";\n        if (CC->isSubClassOf(\"Keyword\"))\n          OS << \"kw_\";\n        OS << Name << \",\\n\";\n      }\n      OS << „    NUM_TOKENS\\n\"\n         << „  };\\n\";\n    ```", "```cpp\n\n      OS << \"  const char *getTokenName(TokenKind Kind) \"\n            \"LLVM_READNONE;\\n\"\n         << \"  const char *getPunctuatorSpelling(TokenKind \"\n            \"Kind) LLVM_READNONE;\\n\"\n         << \"  const char *getKeywordSpelling(TokenKind \"\n            \"Kind) \"\n            \"LLVM_READNONE;\\n\"\n         << \"}\\n\"\n         << \"#endif\\n\";\n    ```", "```cpp\n\n      OS << \"#ifdef GET_TOKEN_KIND_DEFINITION\\n\";\n      OS << \"#undef GET_TOKEN_KIND_DEFINITION\\n\";\n      OS << \"static const char * const TokNames[] = {\\n\";\n      for (Record *CC :\n           Records.getAllDerivedDefinitions(\"Token\")) {\n        OS << \"  \\\"\" << CC->getValueAsString(\"Name\")\n           << \"\\\",\\n\";\n      }\n      OS << \"};\\n\\n\";\n      OS << \"const char *tok::getTokenName(TokenKind Kind) \"\n            \"{\\n\"\n         << \"  if (Kind <= tok::NUM_TOKENS)\\n\"\n         << \"    return TokNames[Kind];\\n\"\n         << \"  llvm_unreachable(\\\"unknown TokenKind\\\");\\n\"\n         << \"  return nullptr;\\n\"\n         << \"};\\n\\n\";\n    ```", "```cpp\n\n      OS << \"const char \"\n            \"*tok::getPunctuatorSpelling(TokenKind \"\n            \"Kind) {\\n\"\n         << \"  switch (Kind) {\\n\";\n      for (Record *CC :\n           Records.getAllDerivedDefinitions(\"Punctuator\")) {\n        OS << \"    \" << CC->getValueAsString(\"Name\")\n           << \": return \\\"\"\n           << CC->getValueAsString(\"Spelling\") << \"\\\";\\n\";\n      }\n      OS << \"    default: break;\\n\"\n         << \"  }\\n\"\n         << \"  return nullptr;\\n\"\n         << \"};\\n\\n\";\n    ```", "```cpp\n\n      OS << \"const char *tok::getKeywordSpelling(TokenKind \"\n            \"Kind) {\\n\"\n         << \"  switch (Kind) {\\n\";\n      for (Record *CC :\n           Records.getAllDerivedDefinitions(\"Keyword\")) {\n        OS << \"    kw_\" << CC->getValueAsString(\"Name\")\n           << \": return \\\"\" << CC->getValueAsString(\"Name\")\n           << \"\\\";\\n\";\n      }\n      OS << \"    default: break;\\n\"\n         << \"  }\\n\"\n         << \"  return nullptr;\\n\"\n         << «};\\n\\n»;\n      OS << «#endif\\n»;\n    }\n    ```", "```cpp\n\n      std::vector<Record *> AllTokenFilter =\n          Records.getAllDerivedDefinitionsIfDefined(\n              \"TokenFilter\");\n      if (AllTokenFilter.empty())\n        return;\n    ```", "```cpp\n\n      ListInit *TokenFilter = dyn_cast_or_null<ListInit>(\n          AllTokenFilter[0]\n              ->getValue(\"Tokens\")\n              ->getValue());\n      if (!TokenFilter)\n        return;\n    ```", "```cpp\n\n      using KeyFlag = std::pair<StringRef, uint64_t>;\n      std::vector<KeyFlag> Table;\n      for (size_t I = 0, E = TokenFilter->size(); I < E;\n           ++I) {\n       Record *CC = TokenFilter->getElementAsRecord(I);\n       StringRef Name = CC->getValueAsString(\"Name\");\n       uint64_t Val = 0;\n       ListInit *Flags = nullptr;\n       if (RecordVal *F = CC->getValue(\"Flags\"))\n          Flags = dyn_cast_or_null<ListInit>(F->getValue());\n       if (Flags) {\n          for (size_t I = 0, E = Flags->size(); I < E; ++I) {\n            Val |=\n                Flags->getElementAsRecord(I)->getValueAsInt(\n                    \"Val\");\n          }\n       }\n       Table.emplace_back(Name, Val);\n      }\n    ```", "```cpp\n\n      llvm::sort(Table.begin(), Table.end(),\n                 [](const KeyFlag A, const KeyFlag B) {\n                   return A.first < B.first;\n                 });\n    ```", "```cpp\n\n      OS << \"#ifdef GET_KEYWORD_FILTER\\n\"\n         << \"#undef GET_KEYWORD_FILTER\\n\";\n      OS << \"bool lookupKeyword(llvm::StringRef Keyword, \"\n            \"unsigned &Value) {\\n\";\n      OS << \"  struct Entry {\\n\"\n         << \"    unsigned Value;\\n\"\n         << \"    llvm::StringRef Keyword;\\n\"\n         << \"  };\\n\"\n         << \"static const Entry Table[\" << Table.size()\n         << \"] = {\\n\";\n      for (const auto &[Keyword, Value] : Table) {\n       OS << \"    { \" << Value << \", llvm::StringRef(\\\"\"\n          << Keyword << \"\\\", \" << Keyword.size()\n          << \") },\\n\";\n      }\n      OS << \"  };\\n\\n\";\n    ```", "```cpp\n\n      OS << \"  const Entry *E = \"\n            \"std::lower_bound(&Table[0], \"\n            \"&Table[\"\n         << Table.size()\n         << \"], Keyword, [](const Entry &A, const \"\n            \"StringRef \"\n            \"&B) {\\n\";\n      OS << \"    return A.Keyword < B;\\n\";\n      OS << \"  });\\n\";\n      OS << \"  if (E != &Table[\" << Table.size()\n         << \"]) {\\n\";\n      OS << \"    Value = E->Value;\\n\";\n      OS << \"    return true;\\n\";\n      OS << \"  }\\n\";\n      OS << \"  return false;\\n\";\n      OS << \"}\\n\";\n      OS << \"#endif\\n\";\n    }\n    ```", "```cpp\n\n    void EmitTokensAndKeywordFilter(RecordKeeper &RK,\n                                    raw_ostream &OS) {\n      emitSourceFileHeader(\"Token Kind and Keyword Filter \"\n                           \"Implementation Fragment\",\n                           OS);\n      TokenAndKeywordFilterEmitter(RK).run(OS);\n    }\n    ```", "```cpp\n\n#ifndef TABLEGENBACKENDS_H\n#define TABLEGENBACKENDS_H\nnamespace llvm {\nclass raw_ostream;\nclass RecordKeeper;\n} // namespace llvm\nvoid EmitTokensAndKeywordFilter(llvm::RecordKeeper &RK,\n                                llvm::raw_ostream &OS);\n#endif\n```", "```cpp\n\n    #include \"TableGenBackends.h\"\n    #include \"llvm/Support/CommandLine.h\"\n    #include \"llvm/Support/PrettyStackTrace.h\"\n    #include \"llvm/Support/Signals.h\"\n    #include \"llvm/TableGen/Main.h\"\n    #include \"llvm/TableGen/Record.h\"\n    ```", "```cpp\n\n    using namespace llvm;\n    ```", "```cpp\n\n    enum ActionType {\n      PrintRecords,\n      DumpJSON,\n      GenTokens,\n    };\n    ```", "```cpp\n\n    namespace {\n    cl::opt<ActionType> Action(\n        cl::desc(\"Action to perform:\"),\n        cl::values(\n            clEnumValN(\n                PrintRecords, \"print-records\",\n                \"Print all records to stdout (default)\"),\n            clEnumValN(DumpJSON, \"dump-json\",\n                       \"Dump all records as \"\n                       \"machine-readable JSON\"),\n            clEnumValN(GenTokens, \"gen-tokens\",\n                       \"Generate token kinds and keyword \"\n                       \"filter\")));\n    ```", "```cpp\n\n    bool Main(raw_ostream &OS, RecordKeeper &Records) {\n      switch (Action) {\n      case PrintRecords:\n        OS << Records; // No argument, dump all contents\n        break;\n      case DumpJSON:\n        EmitJSON(Records, OS);\n        break;\n      case GenTokens:\n        EmitTokensAndKeywordFilter(Records, OS);\n        break;\n      }\n      return false;\n    }\n    } // namespace\n    ```", "```cpp\n\n    int main(int argc, char **argv) {\n      sys::PrintStackTraceOnErrorSignal(argv[0]);\n      PrettyStackTraceProgram X(argc, argv);\n      cl::ParseCommandLineOptions(argc, argv);\n      llvm_shutdown_obj Y;\n      return TableGenMain(argv[0], &Main);\n    }\n    ```", "```cpp\n\n$ tinylang-tblgen --gen-tokens –o TokenFilter.inc KeywordC.td\n```"]