- en: Testing OS-Based Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, an embedded system uses a more or less regular **Operating System** (**OS**),
    which means that, often much, is the same as on our desktop OS in terms of runtime
    environment and tools, especially when targeting embedded Linux. Yet, differences
    in terms of performance and access offered by the embedded hardware versus our
    PC makes it essential to consider where to perform which parts of developing and
    testing, as well as how to integrate this into our development workflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Developing cross-platform code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging and testing cross-platform code under Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Effectively using cross-compilers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a build system that supports multiple targets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding real hardware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the biggest advantages of OS-based development on platforms such as embedded
    Linux is that it's so similar to a regular desktop Linux installation. Especially
    when running an OS such as a Debian-based Linux distribution (Armbian, Raspbian,
    and others) on SoCs, we have practically the same tools available, with the entire
    package manager, compiler collections, and libraries available with a few keystrokes.
  prefs: []
  type: TYPE_NORMAL
- en: This is, however, also its biggest pitfall.
  prefs: []
  type: TYPE_NORMAL
- en: We can write code, copy it over to the SBC, compile it there, run the test,
    and make changes to the code before repeating the process. Or, we can even write
    the code on the SBC itself, essentially using it as our sole development platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main reasons why we should never do this are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A modern PC is much faster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing on real hardware should never be done until the final stages of development.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automated integration testing is made much harder.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, the first point seems fairly obvious. What takes a single or dual-core
    ARM SoC a good minute to compile will quickly go from start of compilation to
    linking the objects in ten seconds or less with a relatively modern multi-core,
    multithreaded processor at 3+ GHz, and a toolchain that supports multi-core compilation.
  prefs: []
  type: TYPE_NORMAL
- en: This means that, instead of waiting half a minute or longer before we can run
    a new test or start a debugging session, we can do so almost instantly.
  prefs: []
  type: TYPE_NORMAL
- en: The next two points are related. While it may seem advantageous to test on the
    real hardware, it comes with its own complications. One thing is that this hardware
    relies on a number of external factors to work properly, including its power supply,
    any wiring between power sources, peripherals, and signal interfaces. Things such
    as electromagnetic interference may also cause issues, in terms of signal degradation,
    as well as interrupts being triggered due to electromagnetic coupling.
  prefs: []
  type: TYPE_NORMAL
- en: An example of electromagnetic coupling became apparent while developing the
    club status service project of [Chapter 3](47e0b6fb-cb68-43c3-9453-2dc7575b1a46.xhtml),
    *Developing for Embedded Linux and Similar Systems*. Here, one of the signal wires
    for the switches ran alongside 230V AC wiring. Changes in the current on this
    mains wiring induced pulses in the signal wire, causing false interrupt trigger
    events.
  prefs: []
  type: TYPE_NORMAL
- en: All of these potential hardware-related issues show that such tests aren't nearly
    as deterministic as we would wish them to be. The potential result of this is
    that project development takes much longer than planned, with debugging being
    complicated due to conflicting and non-deterministic test results.
  prefs: []
  type: TYPE_NORMAL
- en: Another effect of a focus on developing on and for real hardware is that it
    makes automated testing much harder. The reason for this is that we cannot use
    any generic build cluster and, for example, Linux VM-based testing environment,
    as is common with mainstream **Continuous** **Integration** (**CI**) services.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of this, we would have to somehow integrate something such as an SBC
    into the CI system, having it either cross-compile and copy the binary to the
    SBC for running the test, or compile it on the SBC itself, which gets us back
    to the first point.
  prefs: []
  type: TYPE_NORMAL
- en: In the next few sections, we'll look at a of approaches to make embedded Linux-based
    development as painless as possible, starting with cross-compilation.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-compiling for SBCs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The compile process takes the source files, turning them into an intermediate
    format, after which this format can be used to target a specific CPU architecture.
    For us, this means that we aren't limited to compiling applications for an SBC
    on that SBC itself, but we can do so on our development PC.
  prefs: []
  type: TYPE_NORMAL
- en: To do so for an SBC such as the Raspberry Pi (Broadcom Cortex-A-based ARM SoCs),
    we need to install the `arm-linux-gnueabihf` toolchain, which targets the ARM
    architecture with hard float (hardware floating point) support, outputting Linux-compatible
    binaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'On a Debian-based Linux system, we can install the entire toolchain with the
    following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first command installs the native GCC-based toolchain for the system (if
    it wasn't already installed), along with any common related tools and utilities,
    including `make`, `libtool`, `flex`, and others. The second command installs the
    actual cross-compiler. Finally, the third package is the version of the GDB debugger
    that supports multiple architectures, which we'll need later on for doing remote
    debugging on the real hardware, as well as for analyzing core dumps produced when
    our application crashes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now use the g++ compiler for the target SBC using its full name on the
    command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To test whether the toolchain was properly installed, we can execute the following
    command, which should tell us the compiler details including the version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to this, we may need to link with some shared libraries that exist
    on the target system. For this, we can copy the entire contents of the `/lib`
    and `/usr` folders and include them as part of the system root for the compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `Pi-system` is the IP address or network name of the Raspberry Pi or
    similar system. After this, we can tell GCC to use these folders instead of the
    standard paths using the `sysroot` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here `dir` would be the folder where we copied these folders to, in this example
    that would be `~/raspberry/sysroot`.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, we can just copy the header and library files we require and
    add them as part of the source tree. Whichever approach is the easiest mostly
    depends on the dependencies of the project in question.
  prefs: []
  type: TYPE_NORMAL
- en: For the club status service project, we require at the very least the headers
    and libraries for WiringPi, as well as those for the POCO project and its dependencies.
    We could determine the dependencies we need and copy the required includes and
    library files that are missing from the toolchain we installed earlier. Unless
    there's a pressing need to do so, it's far easier to just copy the entire folders
    from the SBC's OS.
  prefs: []
  type: TYPE_NORMAL
- en: As an alternative to using the `sysroot` method, we can also explicitly define
    the paths to the shared libraries that we wish to use while linking our code.
    This of course comes with its own set of advantages and disadvantages.
  prefs: []
  type: TYPE_NORMAL
- en: Integration test for club status service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to test the club status service on a regular desktop Linux (or macOS
    or Windows) system before we embark on cross-compiling and testing on real hardware,
    a simple integration test was written, which uses mocks for the GPIO and I2C peripherals.
  prefs: []
  type: TYPE_NORMAL
- en: In the source code for the project covered in [Chapter 3](47e0b6fb-cb68-43c3-9453-2dc7575b1a46.xhtml),
    *Developing for Embedded Linux and Similar Systems*, the files for these peripherals are
    found in the `wiring` folder of that project.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with the `wiringPi.h` header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We include a header from the POCO framework to allow us to easily create a
    timer instance later on. Then, we define all possible pin modes, just as the actual
    WiringPi header defines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'These defines define further pin modes, including the digital input levels,
    the possible states of the pull-ups and pull-downs on the pins, and finally the
    possible types of interrupts, defining the trigger or triggers for an interrupt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This `typedef` defines the format for an interrupt callback function pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now look at the `WiringTimer` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This class is the integral part of the GPIO-side of our mock implementation.
    Its main purpose is to keep track of which of the two interrupts we''re interested
    in have been registered, and to trigger them at regular intervals using the timer,
    as we''ll see in a moment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we define the standard WiringPi functions before moving on the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the class constructor, we set the default values before creating the timer
    instance, configuring it to call our callback function every ten seconds, after
    an initial 10-second delay:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the destructor, we delete the timer callback instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In this function, we actually start the timer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This last function in the class is the callback for the timer. The way it functions
    is that it keeps track of how many times it has been triggered, with it setting
    the appropriate pin level in the form of a value in a file that we write to disk.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the initial delay, the first trigger will set the lock switch to `false`,
    the second the status switch to `true`, the third the status switch back to `false`,
    and finally the fourth trigger sets the lock switch back to `true`, before resetting
    the counter and starting over again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We add a global namespace in which we have a `unique_ptr` instance for a `WiringTimer`
    class instance, along with an initialization status indicator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The setup function is used to write the default values for the mocked GPIO
    pin inputs value to disk. We also create the pointer to a `WiringTimer` instance
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Because our mocked implementation determines the behavior of the pins, we can
    ignore any input on these functions. For testing purposes, we could add an assert
    to validate that these functions have been called at the right times with the
    appropriate settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'When reading the value for one of the two mocked pins, we open its respective
    file and read out its content, which is either the 1 or 0 set by the setup function
    or by the callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This function is used to register an interrupt and its associated callback function.
    After an initial check that the mock has been initialized by the setup function,
    we then continue to register the interrupt for one of the two specified pins.
  prefs: []
  type: TYPE_NORMAL
- en: Once both pins have had an interrupt set for them, we start the timer, which
    will in turn start generating events for the interrupt callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next is the I2C bus mock:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We just need two functions here: the setup function and the simple one-byte
    register write function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the setup function, we log the requested device ID (I2C bus address) and
    return a standard device handle. Here, we use the `log()` function from the `Club`
    class to make the mock integrate into the rest of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Since the code that would call this function wouldn't be expecting a response,
    beyond a simple acknowledgment that the data has been received, we can just log
    the received data and further details here. The `NumberFormatter` class from POCO
    is used here as well for formatting the integer data as hexadecimal values like
    in the application, for consistency.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now compile the project and use the following command-line command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the application (under GDB, to see when new threads are created/destroyed)
    now gets us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, the system has been configured with all interrupts set and the
    I2C device configured by the application. The timer has started its initial countdown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The initial status of the GPIO pins has been read out and both switches are
    found to be in the `off` position, so we activate the red light on the traffic
    light indicator by writing its position in the register:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Next, the timer starts triggering the callback function repeatedly, causing
    it to go through its different stages. This allows us to ascertain that the basic
    functioning of the code is correct.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we can start implementing more complex test cases, conceivably
    even implementing scriptable test cases using an embedded Lua, Python runtime
    or similar.
  prefs: []
  type: TYPE_NORMAL
- en: Mock versus hardware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An obvious question to ask when mocking away large sections of code and hardware
    peripherals is how realistic the resulting mock is. We obviously want to be able
    to cover as many real-life scenarios as possible with our integration test before
    we move to testing on the target system.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to know which test cases we wish to cover in our mock, we have to
    look both at our project requirements (what it should be able to handle), and
    which situations and inputs can occur in a real-life scenario.
  prefs: []
  type: TYPE_NORMAL
- en: For this, we would analyze the underlying code to see what conditions can occur,
    and decide on which ones are relevant for us.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of the WiringPi mocks we looked at earlier, a quick glance at the
    source code for the library's implementation makes it clear just how much we simplified
    our code compared to the version we would be using on our target system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the basic WiringPi setup function, we see that it does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Determines the exact board model and SoC to get the GPIO layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Opens the Linux device for the memory-mapped GPIO pins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets the memory offsets into the GPIO device and uses `mmap()` to map specific
    peripherals such as PWM, timer, and GPIO into memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Instead of ignoring calls to `pinMode()`, the implementation does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Appropriately sets the hardware GPIO direction register in the SoC (for input/output
    mode)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starts PWM, soft PWM, or Tone mode on a pin (as requested); sub-functions set
    the appropriate registers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This continues with the I2C side, where the setup function implementation looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Compared to our mock implementation, the main difference is in that an I2C peripheral
    is expected to be present on the in-memory filesystem of the OS, and the board
    revision determines which one we pick.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last function that gets called tries to open the device, as in Linux and
    similar OSes every device is simply a file that we can open and get a file handle
    to, if successful. This file handle is the ID that gets returned when the function
    returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: After opening the I2C device, the Linux system function, `ioctl()`, is used
    to send data to the I2C peripheral, in this case, the address of the I2C slave
    device that we wish to use. If successful, we get a non-negative response and
    return the integer that's our file handle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Writing and reading the I2C bus is also handled using `ioctl()`, as we can
    see in the same source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This same inline function is called for every single I2C bus access. With the
    I2C device that we wish to use already selected, we can simply target the I2C
    peripheral and have it transmit the payload to the device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the `i2c_smbus_data` type is a simple union to support various sizes
    for the return value (when performing a read operation):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Here, we mostly see the benefit of using an abstract API. Without it, we would
    have peppered our code with low-level calls that would have been much harder to
    mock away. What we also see is that there are a number of conditions that we should
    likely be testing as well, such as a missing I2C slave device, read and write
    errors on the I2C bus that may result in unexpected behavior, as well as unexpected
    input on GPIO pins, including for interrupt pins as was noted at the beginning
    of this chapter already.
  prefs: []
  type: TYPE_NORMAL
- en: Although obviously not all scenarios can be planned for, efforts should be made
    to document all realistic scenarios and incorporate them into the mocked-up implementation,
    so that they can be enabled at will during integration and regression testing
    and while debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Testing with Valgrind
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Valgrind is the most commonly used collection of open source tools for analyzing
    and profiling everything from the cache and heap behavior of an application to
    memory leaks and potential multithreading issues. It works in tandem with the
    underlying operating system as, depending on the tool used, it has to intercept
    everything from memory allocations to instructions related to multithreading and
    related. This is the reason why it is only fully supported under Linux on 64-bit
    x86_64 architectures.
  prefs: []
  type: TYPE_NORMAL
- en: Using Valgrind on other supported platforms (Linux on x86, PowerPC, ARM, S390,
    MIPS, and ARM, also Solaris and macOS) is definitely also an option, but the primary
    development target of the Valgrind project is x86_64/Linux, making it the best
    platform to do profiling and debugging on, even if other platforms will be targeted
    later on.
  prefs: []
  type: TYPE_NORMAL
- en: On the Valgrind website at [http://valgrind.org/info/platforms.html](http://valgrind.org/info/platforms.html),
    we can see a full overview of the currently supported platforms.
  prefs: []
  type: TYPE_NORMAL
- en: One very attractive property of Valgrind is that none of its tools require us
    to alter the source code or resulting binary in any fashion. This makes it very
    easy to integrate into an existing workflow, including automated testing and integration
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: On Windows-based system, tools such as Dr. Memory ([http://drmemory.org/](http://drmemory.org/))
    are available as well, which can handle at least the profiling of memory-related
    behavior. This particular tool also comes with Dr. Fuzz, a tool that can repeatedly
    call functions with varying inputs, potentially useful for integration testing.
  prefs: []
  type: TYPE_NORMAL
- en: By using an integration test such as what we looked at in the previous section,
    we're free to fully analyze the behavior of our code from the comfort of our PC.
    Since all of Valgrind's tools significantly slow down the execution of our code
    (10-100 times), being able to do most of the debugging and profiling on a fast
    system means that we can save a significant amount of time before embarking on
    testing on the target hardware.
  prefs: []
  type: TYPE_NORMAL
- en: Of the tools we'll likely use the most often, **Memcheck**, **Helgrind**, and
    **DRD** are useful for detecting memory allocation and multithreading issues.
    Once our code passes through these three tools, while using an extensive integration
    test that provides wide coverage of the code, we can move on to profiling and
    optimizing.
  prefs: []
  type: TYPE_NORMAL
- en: To profile our code, we then use **Callgrind** to see where our code spends
    the most of the time executing, followed by **Massif** to do profiling of heap
    allocations. With the information we can glean from this data, we can make changes
    to the code to streamline common allocation and de-allocation cases. It might
    also show us where it might make sense to use a cache to reuse resources instead
    of discarding them from memory.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we would run another cycle of MemCheck, Helgrind, and DRD to ensure
    that our changes didn't cause any regressions. Once we're satisfied, we move on
    to deploying the code on the target system and see how it performs there.
  prefs: []
  type: TYPE_NORMAL
- en: If the target system also runs Linux or other supported OSes, we can use Valgrind
    on there as well, to check that we didn't miss anything. Depending on the exact
    platform (OS and CPU architecture), we may run into limitations of the Valgrind
    port for that platform. These can include errors such as *unhandled instruction*,
    where the tool hasn't had a CPU instruction implemented and hence Valgrind cannot
    continue.
  prefs: []
  type: TYPE_NORMAL
- en: By extending the integration test to use the SBC instead of a local process,
    we can set up a continuous integration system whereby, in addition to the tests
    on a local process, we also run them on real hardware, taking into account the
    limitations of the real hardware platform relative to the x86_64-based Linux system
    used for most of the testing.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-target build system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cross-compilation and multi-target build systems are among the words that tend
    to frighten a lot of people, mostly because they evoke images of hugely complicated
    build scripts that require arcane incantations to perform the desired operation.
    In this chapter, we'll be looking at a simple Makefile-based build system, based
    on a build system that has seen use in commercial projects across a range of hardware
    targets.
  prefs: []
  type: TYPE_NORMAL
- en: The one thing that makes a build system pleasant to use is to be able to get
    everything set up for compilation with minimal fuss and have a central location
    from which we can control all relevant aspects of building the project, or parts
    of it, along with building and running tests.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, we have a single Makefile at the top of the project, which
    handles all of the basics, including the determining of which platform we run
    on. The only simplification we're making here is that we assume a Unix-like environment,
    with MSYS2 or Cygwin on Windows, and Linux, BSD, and OS X/macOS and others using
    their native shell environments. We could, however, also adapt it to allow for
    Microsoft Visual Studio, **Intel Compiler Collection** (**ICC**), and other compilers,
    so long as they provide the basic tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'Key to the build system are simple Makefiles, in which we define the specific
    details of the target platform, for example, for a standard Linux system running
    on x86_x64 hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can set the names of the command-line tools that we'll be using for
    compiling, creating archives, stripping debug symbols from binaries, and so on.
    The build system will use the target OS and architecture to keep the created binaries
    separate so that we can use the same source tree to create binaries for all target
    platforms in one run.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see how we separate the flags that we''ll be passing to the compiler
    and linker into different categories: platform-specific ones, common (standard)
    flags, and finally flags specific for the C and C++ compiler. The former is useful
    when integrating external dependencies that have been integrated into the source
    tree, yet are written in C. These dependencies we''ll find in the `extern` folder,
    as we''ll see in more detail in a moment.'
  prefs: []
  type: TYPE_NORMAL
- en: This kind of file will be heavily customized to fit a specific project, adding
    the required includes, libraries, and compile flags. For this example file, we
    can see a project that uses the POCO and Boost libraries, along with OpenSSL,
    tweaking the POCO library for the target platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s look at the top of the configuration file for macOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Although the rest of the file is almost the same, here we can see a good example
    of generalizing what a tool is called. Although Clang supports the same flags
    as GCC, its tools are called differently. With this approach, we just write the
    different names once in this file and everything will just work.
  prefs: []
  type: TYPE_NORMAL
- en: 'This continues with the Linux on ARM target, which is set up as a cross-compilation
    target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here, we see the reappearance of the cross-compilation toolchain for ARM Linux
    platforms, which we looked at earlier in this chapter. To save ourselves typing,
    we define the basic name once so that it is easy to redefine. This also shows
    how flexible Makefiles are. With some more creativity, we could create a set of
    templates that would generalize entire toolchains into a simple Makefile to be
    included by the main Makefile depending on hints in the platform's Makefile (or
    other configuration file), making this highly flexible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on, we''ll look at the main Makefile as found in the root of the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we cannot guess what platform the user wants us to target, we require
    that the target is specified, with the platform name as the value, for example, `linux-x86_x64`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Later on in the system, we''ll need to know which folder we''re in on the local
    filesystem so that we can specify absolute paths. We use the standard Make variable
    for this and export it as our own environment variable, along with the build target
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Using the (command-line) `uname` command, we can check which OS we're running
    on, with each OS that supports the command in its shell returning its name, such
    as `Linux` for Linux and `Darwin` for macOS. On pure Windows (no MSYS2 or Cygwin),
    the command doesn't exist, which would get us the second part of this `if/else`
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'This statement could be expanded to support more OSes, depending on what the
    build system requires. In this case, it is only used to determine whether executables
    we create should have a file extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In this `if/else` statement, we can set the appropriate command-line commands
    for common file operations. Since we're taking the easy way out, we're assuming
    the use of MSYS2 or similar Bash shell on Windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could take the concept of generalizing further at this point as well, splitting
    off the OS file CLI tools as its own set of Makefiles, which we can then include
    as part of OS-specific settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we use the target parameter provided to the Makefile to include
    the appropriate configuration file. After exporting some details from it, we now
    have a configured build system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: From this single Makefile, we can choose to compile the entire project or just
    the dependencies or the core project. We can also compile a specific external
    dependency and nothing else.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can clean the core project, the dependencies, or both.
  prefs: []
  type: TYPE_NORMAL
- en: 'This top Makefile is primarily for controlling the underlying Makefiles. The
    next two Makefiles are found in the `Core` and `extern` folders. Of these, the
    `Core` Makefile simply directly compiles the project''s core:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As the first step, we include the Makefile configuration for the target platform
    so that we have access to all of its definitions. These could also have been exported
    in the main Makefile, but this way we're free to customize the build system even
    more.
  prefs: []
  type: TYPE_NORMAL
- en: 'We specify the name of the output binary that we''re building, before some
    small tasks, including opening the `version` file (with Makefile syntax) in the
    root of the project, which contains the version number of the source we''re building
    from. This is prepared to be passed as a preprocessor definition into the compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This is another section where we rely on having a Bash shell or something compatible
    around, as we use the date command in order to create a timestamp for the build.
    The format depends on what parameter was passed to the main Makefile. If we're
    building a release, we take the timestamp from the Git repository, with the Git
    commit tag name used to retrieve the commit timestamp for that tag before formatting
    it.
  prefs: []
  type: TYPE_NORMAL
- en: If `GITTIME` is passed as parameter, the timestamp of the most recent Git commit
    is used. Otherwise, the current time and date is used (UTC).
  prefs: []
  type: TYPE_NORMAL
- en: 'This bit of code is intended to solve one of the issues that comes with having
    lots of test and integration builds: keeping track of which ones were built when
    and with which revision of the source code. It could be adapted to other file
    revision systems, as long as it supports similar functionality with the retrieving
    of specific timestamps.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Of note is the second timestamp we''re creating. This is a slightly different
    formatted version of the timestamp that is affixed to the produced binary, except
    when we''re building in release mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set the flags we wish to pass to the compiler, including the version
    and timestamp, both being passed as preprocessor definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the sources in the current project folder are collected and the output
    folder for the object files is set. As we can see here, we''ll be writing the
    object files to a folder underneath the project root, with further separation
    by the compile target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This part is fairly generic for a Makefile. We have the `all` target, along
    with one to make the folders on the filesystem, if they don''t exist yet. Finally,
    we take in the array of source files in the next target, compiling them as configured
    and outputting the object file in the appropriate folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'After we have created all of the object files from our source files, we want
    to link them together, which happens in this step. We can also see where the binary
    will end up: in a `bin` sub-folder of the project''s build folder.'
  prefs: []
  type: TYPE_NORMAL
- en: The linker is called, and we create a copy of the resulting binary, which we
    post-fix with `.debug` to indicate that it is the version with all of the debug
    information. The original binary is then stripped of its debug symbols and other
    unneeded information, leaving us with a small binary to copy to the remote test
    system and a larger version with all of the debug information for when we need
    to analyze core dumps or do remote debugging.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we also see here is a small hack that got added due to an unsupported
    command-line flag by Clang''s linker, requiring the implementation of a special
    case. While working on cross-platform compiling and similar tasks, one is likely
    to run into many of such small details, all of which complicate the writing of
    a universal build system that simply works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: As a final step, we allow for the generated object files to be deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second sub-Makefile in `extern` is also of note, as it controls all of
    the underlying dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'An interesting feature here is the dependency selector based on the target
    platform. If we have dependencies that shouldn''t be compiled for a specific platform,
    we can skip them here. This feature also allows us to directly instruct this Makefile
    to compile all dependencies for a specific platform. Here, we allow for the targeting
    of QNX, Linux, OS X/macOS, and Windows, while ignoring the architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The actual targets merely call another Makefile at the top of the dependency
    project, which in turn compiles that dependency and adds it to the build folder,
    where it can be used by the `Core`'s Makefile.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, we can also directly compile the project from this Makefile using
    an existing build system, such as here for OpenSSL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This code works through all of the usual steps of building OpenSSL by hand,
    before copying the resulting binaries to their target folders.
  prefs: []
  type: TYPE_NORMAL
- en: One issue with cross-platform build systems one may notice is that a common
    GNU tool such as Autoconf is extremely slow on OSes such as Windows, due to it
    launching many processes as it runs hundreds of tests. Even on Linux, this process
    can take a long time, which is very annoying and time consuming when running through
    the same build process multiple times a day.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ideal case is having a simple Makefile in which everything is predefined
    and in a known state so that no library discovery and such are needed. This was
    one of the motivations behind adding the POCO library source code to one project
    and having a simple Makefile compile it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This Makefile then calls the individual Makefile for each module, as in this
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This Makefile compiles the entire `Net` module of the library. It's similar
    in structure to the one for compiling the project core source files. In addition
    to compiling the object files, it puts them into an archive so that we can link
    against it later, and copies this archive as well as the header files to their
    place in the build folder.
  prefs: []
  type: TYPE_NORMAL
- en: The main reason for compiling the library for the project was to allow for specific
    optimizations and tweaks that wouldn't be available with a precompiled library.
    By having everything but the basics stripped out of the library's original build
    system, trying out different settings was made very easy and even worked on Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Remote testing on real hardware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After we have done all of the local testing of our code and are reasonably certain
    that it should work on the real hardware, we can use the cross-compile build system
    to create a binary that we can then run on the target system.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we can simply copy the resulting binary and associated files
    to the target system and see whether it works. The more scientific way to do this
    is to use GDB. With the GDB server service installed on the target Linux system,
    we can connect to it with GDB from our PC, either via the network or a serial
    connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'For SBCs running a Debian-based Linux installation, the GDB server can be easily
    installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Although it is called `gdbserver`, its essential function is that of a remote
    stub implementation for the debugger, which runs on the host system. This makes
    `gdbserver` very lightweight and simple to implement for new targets.
  prefs: []
  type: TYPE_NORMAL
- en: 'After this, we want to make sure that `gdbserver` is running by logging in
    to the system and starting it in one of a variety of ways. We can do so for TPC
    connections over the network like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Or we can attach it to a running process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The `host` part of the first argument refers to the name (or IP address) of
    the host system that will be connecting. This parameter is currently ignored,
    meaning that it can also be left empty. The port section has to be a port that
    is not currently in use on the target system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Or we can use some kind of serial connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The moment we launch `gdbserver`, it pauses the execution of the target application
    if it was already running, allowing us to connect with the debugger from the host
    system. While on the target system, we can run a binary that has been stripped
    of its debug symbols; these are required to be present in the binary that we use
    on the host side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, debug symbols would be loaded from the binary, along with those
    from any dependencies (if available). Connecting over a serial connection would
    look similar, just with the address and port replaced with the serial interface
    path or name. The `baud` rate of the serial connection (if not the default 9,600
    baud) is specified as a parameter to GDB when we''re starting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Once we have told GDB the details of the remote target, we should see the usual
    GDB command-line interface appear, allowing us to step through, analyze, and debug
    the program as if it was running locally on our system.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier in this chapter, we're using `gdb-multiarch` as this version
    of the GDB debugger supports different architectures, which is useful since we'll
    likely be running the debugger on an x86_64 system, whereas the SBC is very likely
    ARM-based, but could also be MIPS or x86 (i686).
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to running the application directly with `gdbserver`, we can also
    start `gdbserver` to just wait for a debugger to connect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Or we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We would then connect to this remote target like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we should find ourselves at the GDB command-line interface again,
    with the program binary loaded on both target and host.
  prefs: []
  type: TYPE_NORMAL
- en: A big advantage of this method is that `gdbserver` does not exit when the application
    that's being debugged exits. In addition, this mode allows us to debug different
    applications simultaneously on the same target, assuming that the target supports
    this.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at how to develop and test embedded, OS-based applications.
    We learned how to install and use a cross-compilation toolchain, how to do remote
    debugging using GDB, and how to write a build system that allows us to compile
    for a wide variety of target systems with minimal effort required to add a new
    target.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you are expected to be able to develop and debug an embedded
    application for a Linux-based SBC or similar, while being able to work in an efficient
    way.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll be looking at how to develop for and test applications
    for more constrained, MCU-based platforms.
  prefs: []
  type: TYPE_NORMAL
