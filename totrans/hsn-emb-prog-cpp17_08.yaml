- en: Testing OS-Based Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试基于操作系统的应用程序
- en: Often, an embedded system uses a more or less regular **Operating System** (**OS**),
    which means that, often much, is the same as on our desktop OS in terms of runtime
    environment and tools, especially when targeting embedded Linux. Yet, differences
    in terms of performance and access offered by the embedded hardware versus our
    PC makes it essential to consider where to perform which parts of developing and
    testing, as well as how to integrate this into our development workflow.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，嵌入式系统使用的是一个或多或少常规的**操作系统**（**OS**），这意味着在运行时环境和工具方面，与我们的桌面OS有很多相同之处，尤其是在针对嵌入式Linux时。然而，嵌入式硬件与我们的PC在性能和提供的访问方面存在的差异，使得考虑在哪里执行开发和测试的哪些部分，以及如何将其集成到我们的开发工作流程中变得至关重要。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Developing cross-platform code
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发跨平台代码
- en: Debugging and testing cross-platform code under Linux
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Linux下调试和测试跨平台代码
- en: Effectively using cross-compilers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效使用交叉编译器
- en: Creating a build system that supports multiple targets
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建支持多个目标的构建系统
- en: Avoiding real hardware
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免使用真实硬件
- en: One of the biggest advantages of OS-based development on platforms such as embedded
    Linux is that it's so similar to a regular desktop Linux installation. Especially
    when running an OS such as a Debian-based Linux distribution (Armbian, Raspbian,
    and others) on SoCs, we have practically the same tools available, with the entire
    package manager, compiler collections, and libraries available with a few keystrokes.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于操作系统的平台上进行开发（如嵌入式Linux）的最大优势之一是它与常规桌面Linux安装非常相似。特别是当在SoC上运行基于Debian的Linux发行版（Armbian、Raspbian等）时，我们实际上拥有相同的工具，包括整个包管理器、编译器集合和库，只需几个按键即可使用。
- en: This is, however, also its biggest pitfall.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这同时也是其最大的陷阱。
- en: We can write code, copy it over to the SBC, compile it there, run the test,
    and make changes to the code before repeating the process. Or, we can even write
    the code on the SBC itself, essentially using it as our sole development platform.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写代码，将其复制到SBC上，在那里编译，运行测试，并在重复此过程之前对代码进行修改。或者，我们甚至可以直接在SBC上编写代码，实际上将其作为我们的唯一开发平台。
- en: 'The main reasons why we should never do this are as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们永远不应该这样做的主要原因如下：
- en: A modern PC is much faster.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代PC要快得多。
- en: Testing on real hardware should never be done until the final stages of development.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发后期阶段之前，不应在真实硬件上进行测试。
- en: Automated integration testing is made much harder.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动集成测试变得更加困难。
- en: Here, the first point seems fairly obvious. What takes a single or dual-core
    ARM SoC a good minute to compile will quickly go from start of compilation to
    linking the objects in ten seconds or less with a relatively modern multi-core,
    multithreaded processor at 3+ GHz, and a toolchain that supports multi-core compilation.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，第一个观点似乎相当明显。单个或双核ARM SoC需要一分钟才能编译的任务，在具有3+ GHz的相对现代多核多线程处理器和能够支持多核编译的工具链的情况下，将从编译开始到链接对象只需十秒或更少。
- en: This means that, instead of waiting half a minute or longer before we can run
    a new test or start a debugging session, we can do so almost instantly.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，我们不必等待半分钟或更长时间才能运行新的测试或开始调试会话，我们几乎可以立即这样做。
- en: The next two points are related. While it may seem advantageous to test on the
    real hardware, it comes with its own complications. One thing is that this hardware
    relies on a number of external factors to work properly, including its power supply,
    any wiring between power sources, peripherals, and signal interfaces. Things such
    as electromagnetic interference may also cause issues, in terms of signal degradation,
    as well as interrupts being triggered due to electromagnetic coupling.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的两点是相关的。虽然在实际硬件上进行测试可能看起来有利，但它也伴随着自己的复杂性。一方面，这种硬件依赖于许多外部因素才能正常工作，包括电源供应、电源之间的任何布线、外围设备和信号接口。电磁干扰等问题也可能导致信号退化，以及由于电磁耦合而触发的中断。
- en: An example of electromagnetic coupling became apparent while developing the
    club status service project of [Chapter 3](47e0b6fb-cb68-43c3-9453-2dc7575b1a46.xhtml),
    *Developing for Embedded Linux and Similar Systems*. Here, one of the signal wires
    for the switches ran alongside 230V AC wiring. Changes in the current on this
    mains wiring induced pulses in the signal wire, causing false interrupt trigger
    events.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发第3章[第3章](47e0b6fb-cb68-43c3-9453-2dc7575b1a46.xhtml)“为嵌入式Linux和类似系统开发”的俱乐部状态服务项目时，一个电磁耦合的例子变得明显。在这里，开关的一个信号线与230V交流电线并行。主电线上的电流变化在信号线上引起脉冲，导致错误的中断触发事件。
- en: All of these potential hardware-related issues show that such tests aren't nearly
    as deterministic as we would wish them to be. The potential result of this is
    that project development takes much longer than planned, with debugging being
    complicated due to conflicting and non-deterministic test results.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些潜在的硬件相关问题表明，这样的测试远不如我们希望的那样确定。这种潜在的结果是项目开发时间比计划的长得多，由于冲突和非确定性的测试结果，调试变得复杂。
- en: Another effect of a focus on developing on and for real hardware is that it
    makes automated testing much harder. The reason for this is that we cannot use
    any generic build cluster and, for example, Linux VM-based testing environment,
    as is common with mainstream **Continuous** **Integration** (**CI**) services.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 专注于在真实硬件上开发和为真实硬件开发的效果之一是，它使得自动化测试变得更加困难。原因是我们不能使用任何通用的构建集群，例如，像主流**持续****集成**（**CI**）服务中常见的基于Linux虚拟机（VM）的测试环境。
- en: Instead of this, we would have to somehow integrate something such as an SBC
    into the CI system, having it either cross-compile and copy the binary to the
    SBC for running the test, or compile it on the SBC itself, which gets us back
    to the first point.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相反，我们可能需要以某种方式将类似SBC（单板计算机）这样的组件集成到CI（持续集成）系统中，使其能够交叉编译并将二进制文件复制到SBC上以运行测试，或者直接在SBC上编译，这又回到了第一个问题。
- en: In the next few sections, we'll look at a of approaches to make embedded Linux-based
    development as painless as possible, starting with cross-compilation.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将探讨一些方法，使基于嵌入式Linux的开发尽可能无痛苦，从交叉编译开始。
- en: Cross-compiling for SBCs
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为SBC进行交叉编译
- en: The compile process takes the source files, turning them into an intermediate
    format, after which this format can be used to target a specific CPU architecture.
    For us, this means that we aren't limited to compiling applications for an SBC
    on that SBC itself, but we can do so on our development PC.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 编译过程将源文件转换为中间格式，然后可以使用这种格式针对特定的CPU架构进行编译。对我们来说，这意味着我们不仅限于在SBC上编译该SBC上的应用程序，我们还可以在我们的开发PC上这样做。
- en: To do so for an SBC such as the Raspberry Pi (Broadcom Cortex-A-based ARM SoCs),
    we need to install the `arm-linux-gnueabihf` toolchain, which targets the ARM
    architecture with hard float (hardware floating point) support, outputting Linux-compatible
    binaries.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要为像树莓派（基于Broadcom Cortex-A的ARM SoC）这样的SBC进行交叉编译，我们需要安装`arm-linux-gnueabihf`工具链，它针对具有硬件浮点（硬件浮点）支持的ARM架构，输出兼容Linux的二进制文件。
- en: 'On a Debian-based Linux system, we can install the entire toolchain with the
    following commands:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于Debian的Linux系统上，我们可以使用以下命令安装整个工具链：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first command installs the native GCC-based toolchain for the system (if
    it wasn't already installed), along with any common related tools and utilities,
    including `make`, `libtool`, `flex`, and others. The second command installs the
    actual cross-compiler. Finally, the third package is the version of the GDB debugger
    that supports multiple architectures, which we'll need later on for doing remote
    debugging on the real hardware, as well as for analyzing core dumps produced when
    our application crashes.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令安装了系统本地的基于GCC的工具链（如果尚未安装），以及任何相关的常用工具和实用程序，包括`make`、`libtool`、`flex`等。第二个命令安装实际的交叉编译器。最后，第三个包是支持多个架构的GDB调试器版本，我们稍后需要它来进行真实硬件上的远程调试，以及分析应用程序崩溃时产生的核心转储。
- en: 'We can now use the g++ compiler for the target SBC using its full name on the
    command line:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用命令行上的完整名称来使用目标SBC的g++编译器：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To test whether the toolchain was properly installed, we can execute the following
    command, which should tell us the compiler details including the version:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试工具链是否正确安装，我们可以执行以下命令，它应该会告诉我们编译器的详细信息，包括版本：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In addition to this, we may need to link with some shared libraries that exist
    on the target system. For this, we can copy the entire contents of the `/lib`
    and `/usr` folders and include them as part of the system root for the compiler:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可能还需要与目标系统上存在的某些共享库链接。为此，我们可以复制 `/lib` 和 `/usr` 文件夹的全部内容，并将它们作为编译器的系统根的一部分包含进来：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here, `Pi-system` is the IP address or network name of the Raspberry Pi or
    similar system. After this, we can tell GCC to use these folders instead of the
    standard paths using the `sysroot` flag:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`Pi-system` 是 Raspberry Pi 或类似系统的 IP 地址或网络名称。在此之后，我们可以告诉 GCC 使用 `sysroot`
    标志来使用这些文件夹而不是标准路径：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here `dir` would be the folder where we copied these folders to, in this example
    that would be `~/raspberry/sysroot`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 `dir` 是我们复制这些文件夹的文件夹，在这个例子中，那将是 `~/raspberry/sysroot`。
- en: Alternatively, we can just copy the header and library files we require and
    add them as part of the source tree. Whichever approach is the easiest mostly
    depends on the dependencies of the project in question.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们只需复制所需的头文件和库文件，并将它们作为源树的一部分添加。哪种方法更容易，主要取决于相关项目的依赖项。
- en: For the club status service project, we require at the very least the headers
    and libraries for WiringPi, as well as those for the POCO project and its dependencies.
    We could determine the dependencies we need and copy the required includes and
    library files that are missing from the toolchain we installed earlier. Unless
    there's a pressing need to do so, it's far easier to just copy the entire folders
    from the SBC's OS.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于俱乐部状态服务项目，我们至少需要 WiringPi 的头文件和库，以及 POCO 项目及其依赖项的头文件和库。我们可以确定所需的依赖项，并复制之前安装的工具链中缺少的所需包含文件和库文件。除非有迫切需要这样做，否则直接复制
    SBC 操作系统中的整个文件夹要容易得多。
- en: As an alternative to using the `sysroot` method, we can also explicitly define
    the paths to the shared libraries that we wish to use while linking our code.
    This of course comes with its own set of advantages and disadvantages.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 作为使用 `sysroot` 方法的替代方案，我们也可以在链接代码时显式定义我们希望使用的共享库的路径。这当然有其自身的优缺点。
- en: Integration test for club status service
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 俱乐部状态服务集成测试
- en: In order to test the club status service on a regular desktop Linux (or macOS
    or Windows) system before we embark on cross-compiling and testing on real hardware,
    a simple integration test was written, which uses mocks for the GPIO and I2C peripherals.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始交叉编译和在实际硬件上进行测试之前，为了在常规桌面 Linux（或 macOS 或 Windows）系统上测试俱乐部状态服务，我们编写了一个简单的集成测试，该测试使用
    GPIO 和 I2C 外围设备的模拟。
- en: In the source code for the project covered in [Chapter 3](47e0b6fb-cb68-43c3-9453-2dc7575b1a46.xhtml),
    *Developing for Embedded Linux and Similar Systems*, the files for these peripherals are
    found in the `wiring` folder of that project.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 3 章](47e0b6fb-cb68-43c3-9453-2dc7575b1a46.xhtml) 的项目源代码中，*为嵌入式 Linux 和类似系统开发*，这些外围设备的文件位于该项目的
    `wiring` 文件夹中。
- en: 'We start with the `wiringPi.h` header:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 `wiringPi.h` 头文件开始：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We include a header from the POCO framework to allow us to easily create a
    timer instance later on. Then, we define all possible pin modes, just as the actual
    WiringPi header defines:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包含来自 POCO 框架的头文件，以便我们稍后可以轻松创建定时器实例。然后，我们定义所有可能的引脚模式，就像实际的 WiringPi 头文件定义的那样：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'These defines define further pin modes, including the digital input levels,
    the possible states of the pull-ups and pull-downs on the pins, and finally the
    possible types of interrupts, defining the trigger or triggers for an interrupt:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这些定义进一步定义了引脚模式，包括数字输入电平、引脚上上拉和下拉的可能状态，以及最后可能的中断类型，定义了中断的触发器或触发器：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This `typedef` defines the format for an interrupt callback function pointer.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `typedef` 定义了中断回调函数指针的格式。
- en: 'Let''s now look at the `WiringTimer` class:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看 `WiringTimer` 类：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This class is the integral part of the GPIO-side of our mock implementation.
    Its main purpose is to keep track of which of the two interrupts we''re interested
    in have been registered, and to trigger them at regular intervals using the timer,
    as we''ll see in a moment:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类是我们模拟实现 GPIO 侧的组成部分。其主要目的是跟踪我们感兴趣的哪一个中断已被注册，并使用定时器定期触发它们，正如我们稍后将要看到的：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, we define the standard WiringPi functions before moving on the implementation:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在继续实现之前定义了标准的 WiringPi 函数：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the class constructor, we set the default values before creating the timer
    instance, configuring it to call our callback function every ten seconds, after
    an initial 10-second delay:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在类构造函数中，我们在创建计时器实例之前设置默认值，将其配置为每10秒调用我们的回调函数，初始延迟为10秒：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the destructor, we delete the timer callback instance:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在析构函数中，我们删除计时器回调实例：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this function, we actually start the timer:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们实际上启动了计时器：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This last function in the class is the callback for the timer. The way it functions
    is that it keeps track of how many times it has been triggered, with it setting
    the appropriate pin level in the form of a value in a file that we write to disk.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 类中的最后一个函数是定时器的回调函数。其工作方式是跟踪它被触发的次数，并以文件中的值形式设置适当的引脚电平，这些文件是我们写入磁盘的。
- en: 'After the initial delay, the first trigger will set the lock switch to `false`,
    the second the status switch to `true`, the third the status switch back to `false`,
    and finally the fourth trigger sets the lock switch back to `true`, before resetting
    the counter and starting over again:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始延迟之后，第一次触发将锁定开关设置为`false`，第二次将状态开关设置为`true`，第三次将状态开关再次设置为`false`，最后第四次触发将锁定开关再次设置为`true`，然后重置计数器并重新开始：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We add a global namespace in which we have a `unique_ptr` instance for a `WiringTimer`
    class instance, along with an initialization status indicator.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在全局命名空间中添加了一个`unique_ptr`实例，用于`WiringTimer`类实例，以及一个初始化状态指示器。
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The setup function is used to write the default values for the mocked GPIO
    pin inputs value to disk. We also create the pointer to a `WiringTimer` instance
    here:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 设置函数用于将模拟GPIO引脚输入值的默认值写入磁盘。我们在这里也创建了`WiringTimer`实例的指针：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Because our mocked implementation determines the behavior of the pins, we can
    ignore any input on these functions. For testing purposes, we could add an assert
    to validate that these functions have been called at the right times with the
    appropriate settings:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的模拟实现决定了引脚的行为，我们可以忽略这些函数上的任何输入。为了测试目的，我们可以在这些函数被正确时间以适当设置调用时添加一个断言来验证：
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When reading the value for one of the two mocked pins, we open its respective
    file and read out its content, which is either the 1 or 0 set by the setup function
    or by the callback:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当读取两个模拟引脚之一的值时，我们打开其相应的文件并读取其内容，该内容是设置函数或回调设置的1或0：
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This function is used to register an interrupt and its associated callback function.
    After an initial check that the mock has been initialized by the setup function,
    we then continue to register the interrupt for one of the two specified pins.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数用于注册中断及其关联的回调函数。在初始检查模拟已被设置函数初始化之后，我们继续为两个指定引脚之一注册中断。
- en: Once both pins have had an interrupt set for them, we start the timer, which
    will in turn start generating events for the interrupt callbacks.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦为两个引脚都设置了中断，我们就开始计时器，这将反过来开始为中断回调生成事件。
- en: 'Next is the I2C bus mock:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是I2C总线模拟：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We just need two functions here: the setup function and the simple one-byte
    register write function.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要在这里添加两个函数：设置函数和简单的单字节寄存器写入函数。
- en: 'The implementation is as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 实现如下：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the setup function, we log the requested device ID (I2C bus address) and
    return a standard device handle. Here, we use the `log()` function from the `Club`
    class to make the mock integrate into the rest of the code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置函数中，我们记录请求的设备ID（I2C总线地址）并返回一个标准设备句柄。在这里，我们使用`Club`类的`log()`函数使模拟集成到代码的其余部分：
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Since the code that would call this function wouldn't be expecting a response,
    beyond a simple acknowledgment that the data has been received, we can just log
    the received data and further details here. The `NumberFormatter` class from POCO
    is used here as well for formatting the integer data as hexadecimal values like
    in the application, for consistency.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 由于调用此函数的代码不会期望任何响应，除了简单确认数据已被接收之外，我们只需在这里记录接收到的数据和更多详细信息。这里也使用了POCO的`NumberFormatter`类，用于将整数数据格式化为十六进制值，以保持与应用程序的一致性。
- en: 'We now compile the project and use the following command-line command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们编译项目并使用以下命令行命令：
- en: '[PRE22]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Running the application (under GDB, to see when new threads are created/destroyed)
    now gets us the following output:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在GDB下运行应用程序（以查看何时创建/销毁新线程）现在得到以下输出：
- en: '[PRE23]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'At this point, the system has been configured with all interrupts set and the
    I2C device configured by the application. The timer has started its initial countdown:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，系统已经配置完毕，所有中断都已设置，应用程序已配置I2C设备。定时器已经开始初始倒计时：
- en: '[PRE24]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The initial status of the GPIO pins has been read out and both switches are
    found to be in the `off` position, so we activate the red light on the traffic
    light indicator by writing its position in the register:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 已读取GPIO引脚的初始状态，并且两个开关都发现处于`关闭`位置，因此我们通过在寄存器中写入其位置来激活交通灯指示器的红灯：
- en: '[PRE25]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Next, the timer starts triggering the callback function repeatedly, causing
    it to go through its different stages. This allows us to ascertain that the basic
    functioning of the code is correct.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定时器开始重复触发回调函数，使其通过不同的阶段。这使我们能够确定代码的基本功能是正确的。
- en: At this point, we can start implementing more complex test cases, conceivably
    even implementing scriptable test cases using an embedded Lua, Python runtime
    or similar.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以开始实现更复杂的测试用例，甚至可能使用嵌入式Lua、Python运行时或类似的脚本化测试用例。
- en: Mock versus hardware
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟与硬件
- en: An obvious question to ask when mocking away large sections of code and hardware
    peripherals is how realistic the resulting mock is. We obviously want to be able
    to cover as many real-life scenarios as possible with our integration test before
    we move to testing on the target system.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当模拟大量代码和硬件外设时，一个明显的问题是要问模拟结果的真实性如何。显然，在我们将测试转移到目标系统之前，我们希望我们的集成测试能够尽可能覆盖更多的真实场景。
- en: If we want to know which test cases we wish to cover in our mock, we have to
    look both at our project requirements (what it should be able to handle), and
    which situations and inputs can occur in a real-life scenario.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想知道在模拟中要覆盖哪些测试用例，我们必须查看我们的项目需求（它应该能够处理什么），以及在实际场景中可能发生的情况和输入。
- en: For this, we would analyze the underlying code to see what conditions can occur,
    and decide on which ones are relevant for us.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这一点，我们会分析底层代码以查看可能发生的条件，并决定哪些对我们来说是相关的。
- en: In the case of the WiringPi mocks we looked at earlier, a quick glance at the
    source code for the library's implementation makes it clear just how much we simplified
    our code compared to the version we would be using on our target system.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前查看的WiringPi模拟中，快速查看库实现的源代码清楚地表明，与我们在目标系统上使用的版本相比，我们简化了代码。
- en: 'Looking at the basic WiringPi setup function, we see that it does the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 查看基本的WiringPi设置函数，我们看到它执行以下操作：
- en: Determines the exact board model and SoC to get the GPIO layout
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定确切的板型和SoC以获取GPIO布局
- en: Opens the Linux device for the memory-mapped GPIO pins
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开Linux设备以访问内存映射的GPIO引脚
- en: Sets the memory offsets into the GPIO device and uses `mmap()` to map specific
    peripherals such as PWM, timer, and GPIO into memory
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置GPIO设备的内存偏移量，并使用`mmap()`将PWM、定时器和GPIO等特定外设映射到内存中
- en: 'Instead of ignoring calls to `pinMode()`, the implementation does the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与忽略`pinMode()`调用不同，实现执行以下操作：
- en: Appropriately sets the hardware GPIO direction register in the SoC (for input/output
    mode)
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在SoC中适当地设置硬件GPIO方向寄存器（用于输入/输出模式）
- en: Starts PWM, soft PWM, or Tone mode on a pin (as requested); sub-functions set
    the appropriate registers
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在引脚上启动PWM、软PWM或Tone模式（如请求所示）；子功能设置适当的寄存器
- en: 'This continues with the I2C side, where the setup function implementation looks
    like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这继续到I2C方面，其中设置函数的实现如下：
- en: '[PRE26]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Compared to our mock implementation, the main difference is in that an I2C peripheral
    is expected to be present on the in-memory filesystem of the OS, and the board
    revision determines which one we pick.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的模拟实现相比，主要区别在于预期的I2C外设在操作系统的内存文件系统中，而板型版本决定了我们选择哪一个。
- en: 'The last function that gets called tries to open the device, as in Linux and
    similar OSes every device is simply a file that we can open and get a file handle
    to, if successful. This file handle is the ID that gets returned when the function
    returns:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后被调用的函数尝试打开设备，就像在Linux和类似的操作系统中，每个设备都是一个我们可以打开并获取文件句柄的文件，如果成功的话。这个文件句柄是函数返回时返回的ID：
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: After opening the I2C device, the Linux system function, `ioctl()`, is used
    to send data to the I2C peripheral, in this case, the address of the I2C slave
    device that we wish to use. If successful, we get a non-negative response and
    return the integer that's our file handle.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在打开 I2C 设备后，Linux 系统函数 `ioctl()` 用于向 I2C 外设发送数据，在这种情况下，是我们希望使用的 I2C 从设备地址。如果成功，我们将获得一个非负响应，并返回我们的文件句柄整数。
- en: 'Writing and reading the I2C bus is also handled using `ioctl()`, as we can
    see in the same source file:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ioctl()` 函数来读写 I2C 总线也是通过该函数实现的，正如我们在同一源文件中看到的：
- en: '[PRE28]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This same inline function is called for every single I2C bus access. With the
    I2C device that we wish to use already selected, we can simply target the I2C
    peripheral and have it transmit the payload to the device.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每次 I2C 总线访问，都会调用相同的内联函数。在我们希望使用的 I2C 设备已经选定的情况下，我们可以简单地针对 I2C 外设，并让它将有效载荷传输到设备。
- en: 'Here, the `i2c_smbus_data` type is a simple union to support various sizes
    for the return value (when performing a read operation):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`i2c_smbus_data` 类型是一个简单的联合体，用于支持返回值的多种大小（在执行读取操作时）：
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, we mostly see the benefit of using an abstract API. Without it, we would
    have peppered our code with low-level calls that would have been much harder to
    mock away. What we also see is that there are a number of conditions that we should
    likely be testing as well, such as a missing I2C slave device, read and write
    errors on the I2C bus that may result in unexpected behavior, as well as unexpected
    input on GPIO pins, including for interrupt pins as was noted at the beginning
    of this chapter already.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们主要看到了使用抽象 API 的好处。没有它，我们的代码中会充斥着低级调用，这将使模拟变得非常困难。我们还看到，有一些条件我们可能也需要测试，例如缺失的
    I2C 从设备、I2C 总线上的读写错误，这些错误可能导致意外的行为，以及 GPIO 引脚上的意外输入，包括中断引脚，正如在本章开头已经提到的。
- en: Although obviously not all scenarios can be planned for, efforts should be made
    to document all realistic scenarios and incorporate them into the mocked-up implementation,
    so that they can be enabled at will during integration and regression testing
    and while debugging.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然显然不可能为所有场景都做出计划，但应该努力记录所有现实场景并将它们纳入模拟实现中，以便在集成和回归测试以及调试期间可以随意启用。
- en: Testing with Valgrind
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Valgrind 进行测试
- en: Valgrind is the most commonly used collection of open source tools for analyzing
    and profiling everything from the cache and heap behavior of an application to
    memory leaks and potential multithreading issues. It works in tandem with the
    underlying operating system as, depending on the tool used, it has to intercept
    everything from memory allocations to instructions related to multithreading and
    related. This is the reason why it is only fully supported under Linux on 64-bit
    x86_64 architectures.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Valgrind 是最常用的开源工具集合，用于分析和应用性能，从应用程序的缓存和堆行为到内存泄漏和潜在的线程问题。它与底层操作系统协同工作，因为根据使用的工具，它必须拦截从内存分配到与多线程相关的指令等所有内容。这也是为什么它仅在
    64 位 x86_64 架构的 Linux 上完全支持的原因。
- en: Using Valgrind on other supported platforms (Linux on x86, PowerPC, ARM, S390,
    MIPS, and ARM, also Solaris and macOS) is definitely also an option, but the primary
    development target of the Valgrind project is x86_64/Linux, making it the best
    platform to do profiling and debugging on, even if other platforms will be targeted
    later on.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他支持的平台上使用 Valgrind（例如 x86、PowerPC、ARM、S390、MIPS 和 ARM，以及 Solaris 和 macOS）当然也是一个选项，但
    Valgrind 项目的首要开发目标是 x86_64/Linux，这使得它成为进行性能分析和调试的最佳平台，即使以后会针对其他平台。
- en: On the Valgrind website at [http://valgrind.org/info/platforms.html](http://valgrind.org/info/platforms.html),
    we can see a full overview of the currently supported platforms.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Valgrind 网站上 [http://valgrind.org/info/platforms.html](http://valgrind.org/info/platforms.html)，我们可以看到目前支持的所有平台的全面概述。
- en: One very attractive property of Valgrind is that none of its tools require us
    to alter the source code or resulting binary in any fashion. This makes it very
    easy to integrate into an existing workflow, including automated testing and integration
    systems.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Valgrind 非常吸引人的一个特性是，它的所有工具都不需要我们以任何方式修改源代码或生成的二进制文件。这使得它很容易集成到现有的工作流程中，包括自动化测试和集成系统。
- en: On Windows-based system, tools such as Dr. Memory ([http://drmemory.org/](http://drmemory.org/))
    are available as well, which can handle at least the profiling of memory-related
    behavior. This particular tool also comes with Dr. Fuzz, a tool that can repeatedly
    call functions with varying inputs, potentially useful for integration testing.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于Windows的系统上，也提供了诸如Dr. Memory ([http://drmemory.org/](http://drmemory.org/))之类的工具，这些工具可以处理至少与内存相关行为的分析。这个特定的工具还附带了一个名为Dr.
    Fuzz的工具，该工具可以重复调用具有不同输入的函数，这对于集成测试可能很有用。
- en: By using an integration test such as what we looked at in the previous section,
    we're free to fully analyze the behavior of our code from the comfort of our PC.
    Since all of Valgrind's tools significantly slow down the execution of our code
    (10-100 times), being able to do most of the debugging and profiling on a fast
    system means that we can save a significant amount of time before embarking on
    testing on the target hardware.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用类似于我们在上一节中查看的集成测试，我们可以从我们PC的舒适环境中完全分析我们代码的行为。由于Valgrind的所有工具都会显著减慢我们代码的执行速度（10-100倍），能够在快速系统上进行大部分调试和性能分析意味着我们可以在开始测试目标硬件之前节省大量时间。
- en: Of the tools we'll likely use the most often, **Memcheck**, **Helgrind**, and
    **DRD** are useful for detecting memory allocation and multithreading issues.
    Once our code passes through these three tools, while using an extensive integration
    test that provides wide coverage of the code, we can move on to profiling and
    optimizing.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可能会最频繁使用的工具中，**Memcheck**、**Helgrind**和**DRD**对于检测内存分配和多线程问题很有用。一旦我们的代码通过了这三个工具，同时使用一个提供广泛代码覆盖的广泛集成测试，我们就可以继续进行性能分析和优化。
- en: To profile our code, we then use **Callgrind** to see where our code spends
    the most of the time executing, followed by **Massif** to do profiling of heap
    allocations. With the information we can glean from this data, we can make changes
    to the code to streamline common allocation and de-allocation cases. It might
    also show us where it might make sense to use a cache to reuse resources instead
    of discarding them from memory.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分析我们的代码，我们随后使用**Callgrind**来查看我们的代码在执行时花费了最多的时间在哪里，然后使用**Massif**来进行堆分配的分析。从这些数据中我们可以获取的信息，我们可以对代码进行修改，以简化常见的分配和释放情况。它也可能显示在哪里使用缓存来重用资源而不是从内存中丢弃它们是有意义的。
- en: Finally, we would run another cycle of MemCheck, Helgrind, and DRD to ensure
    that our changes didn't cause any regressions. Once we're satisfied, we move on
    to deploying the code on the target system and see how it performs there.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还会运行一轮MemCheck、Helgrind和DRD，以确保我们的更改没有引起任何回归。一旦我们满意，我们就可以继续在目标系统上部署代码，并查看其在那里的表现。
- en: If the target system also runs Linux or other supported OSes, we can use Valgrind
    on there as well, to check that we didn't miss anything. Depending on the exact
    platform (OS and CPU architecture), we may run into limitations of the Valgrind
    port for that platform. These can include errors such as *unhandled instruction*,
    where the tool hasn't had a CPU instruction implemented and hence Valgrind cannot
    continue.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标系统也运行Linux或其他支持的操作系统，我们也可以在那里使用Valgrind，以检查我们是否遗漏了任何内容。根据确切的平台（操作系统和CPU架构），我们可能会遇到该平台Valgrind端口的限制。这可以包括诸如*未处理的指令*之类的错误，其中工具尚未实现CPU指令，因此Valgrind无法继续。
- en: By extending the integration test to use the SBC instead of a local process,
    we can set up a continuous integration system whereby, in addition to the tests
    on a local process, we also run them on real hardware, taking into account the
    limitations of the real hardware platform relative to the x86_64-based Linux system
    used for most of the testing.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将集成测试扩展到使用SBC而不是本地进程，我们可以设置一个持续集成系统，在该系统中，除了对本地进程的测试之外，我们还会在真实硬件上运行它们，考虑到与用于大多数测试的基于x86_64的Linux系统相比，真实硬件平台存在的限制。
- en: Multi-target build system
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多目标构建系统
- en: Cross-compilation and multi-target build systems are among the words that tend
    to frighten a lot of people, mostly because they evoke images of hugely complicated
    build scripts that require arcane incantations to perform the desired operation.
    In this chapter, we'll be looking at a simple Makefile-based build system, based
    on a build system that has seen use in commercial projects across a range of hardware
    targets.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 交叉编译和多目标构建系统是那些往往会让很多人感到害怕的词汇之一，主要是因为它们会唤起大量复杂的构建脚本的图像，这些脚本需要使用晦涩的咒语才能执行所需的操作。在本章中，我们将探讨一个基于简单Makefile的构建系统，该系统已在各种硬件目标上的商业项目中得到应用。
- en: The one thing that makes a build system pleasant to use is to be able to get
    everything set up for compilation with minimal fuss and have a central location
    from which we can control all relevant aspects of building the project, or parts
    of it, along with building and running tests.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使构建系统易于使用的一点是能够以最小的麻烦设置好编译环境，并有一个中心位置，我们可以从中控制构建项目或其部分的所有相关方面，包括构建和运行测试。
- en: For this reason, we have a single Makefile at the top of the project, which
    handles all of the basics, including the determining of which platform we run
    on. The only simplification we're making here is that we assume a Unix-like environment,
    with MSYS2 or Cygwin on Windows, and Linux, BSD, and OS X/macOS and others using
    their native shell environments. We could, however, also adapt it to allow for
    Microsoft Visual Studio, **Intel Compiler Collection** (**ICC**), and other compilers,
    so long as they provide the basic tools.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在项目的顶部有一个单独的 Makefile，它处理所有基本任务，包括确定我们运行的平台。我们在这里所做的唯一简化是假设一个类 Unix 环境，在
    Windows 上使用 MSYS2 或 Cygwin，Linux、BSD 和 OS X/macOS 以及其他使用它们的本地 shell 环境。然而，我们也可以将其修改为允许使用
    Microsoft Visual Studio、**Intel 编译器集合**（**ICC**）和其他编译器，只要它们提供基本工具。
- en: 'Key to the build system are simple Makefiles, in which we define the specific
    details of the target platform, for example, for a standard Linux system running
    on x86_x64 hardware:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 构建系统的关键在于简单的 Makefiles，在其中我们定义了目标平台的具体细节，例如，对于在 x86_x64 硬件上运行的标准 Linux 系统：
- en: '[PRE30]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, we can set the names of the command-line tools that we'll be using for
    compiling, creating archives, stripping debug symbols from binaries, and so on.
    The build system will use the target OS and architecture to keep the created binaries
    separate so that we can use the same source tree to create binaries for all target
    platforms in one run.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以设置我们将用于编译、创建存档、从二进制文件中剥离调试符号等命令行工具的名称。构建系统将使用目标操作系统和架构来保持创建的二进制文件分开，这样我们就可以使用相同的源树在一次运行中为所有目标平台创建二进制文件。
- en: 'We can see how we separate the flags that we''ll be passing to the compiler
    and linker into different categories: platform-specific ones, common (standard)
    flags, and finally flags specific for the C and C++ compiler. The former is useful
    when integrating external dependencies that have been integrated into the source
    tree, yet are written in C. These dependencies we''ll find in the `extern` folder,
    as we''ll see in more detail in a moment.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到如何将传递给编译器和链接器的标志分为不同的类别：平台特定的标志、通用（标准）标志，以及针对 C 和 C++ 编译器的特定标志。当集成已集成到源树中的外部依赖项，而这些依赖项是用
    C 编写的时，这种做法很有用。这些依赖项我们将在稍后更详细地看到，它们位于 `extern` 文件夹中。
- en: This kind of file will be heavily customized to fit a specific project, adding
    the required includes, libraries, and compile flags. For this example file, we
    can see a project that uses the POCO and Boost libraries, along with OpenSSL,
    tweaking the POCO library for the target platform.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的文件将被高度定制以适应特定的项目，添加所需的包含文件、库和编译标志。对于这个示例文件，我们可以看到一个使用 POCO 和 Boost 库，以及
    OpenSSL 的项目，并对 POCO 库针对目标平台进行了调整。
- en: 'First, let''s look at the top of the configuration file for macOS:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看 macOS 配置文件的开头：
- en: '[PRE31]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Although the rest of the file is almost the same, here we can see a good example
    of generalizing what a tool is called. Although Clang supports the same flags
    as GCC, its tools are called differently. With this approach, we just write the
    different names once in this file and everything will just work.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管文件的其他部分几乎相同，但在这里我们可以看到一个很好的例子，说明如何泛化工具的名称。尽管 Clang 支持与 GCC 相同的标志，但其工具的名称不同。采用这种方法，我们只需在这个文件中写一次不同的名称，一切就会正常工作。
- en: 'This continues with the Linux on ARM target, which is set up as a cross-compilation
    target:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这继续到 Linux on ARM 目标，它被设置为交叉编译目标：
- en: '[PRE32]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, we see the reappearance of the cross-compilation toolchain for ARM Linux
    platforms, which we looked at earlier in this chapter. To save ourselves typing,
    we define the basic name once so that it is easy to redefine. This also shows
    how flexible Makefiles are. With some more creativity, we could create a set of
    templates that would generalize entire toolchains into a simple Makefile to be
    included by the main Makefile depending on hints in the platform's Makefile (or
    other configuration file), making this highly flexible.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到了之前在本章中提到的ARM Linux平台的交叉编译工具链的再次出现。为了节省我们输入，我们定义了一个基本名称，这样就可以轻松地重新定义。这也显示了Makefile的灵活性。通过一些更多的创意，我们可以创建一组模板，将整个工具链概括成一个简单的Makefile，根据平台Makefile（或其他配置文件）中的提示将其包含在主Makefile中，从而使其非常灵活。
- en: 'Moving on, we''ll look at the main Makefile as found in the root of the project:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看项目根目录下的主要Makefile：
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Since we cannot guess what platform the user wants us to target, we require
    that the target is specified, with the platform name as the value, for example, `linux-x86_x64`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们无法猜测用户希望我们针对哪个平台，因此我们需要指定目标，平台名称作为值，例如，`linux-x86_x64`：
- en: '[PRE34]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Later on in the system, we''ll need to know which folder we''re in on the local
    filesystem so that we can specify absolute paths. We use the standard Make variable
    for this and export it as our own environment variable, along with the build target
    name:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统的后续部分，我们需要知道我们在本地文件系统中的哪个文件夹，以便我们可以指定绝对路径。我们使用标准的Make变量来完成此操作，并将其作为我们自己的环境变量导出，同时导出构建目标名称：
- en: '[PRE35]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Using the (command-line) `uname` command, we can check which OS we're running
    on, with each OS that supports the command in its shell returning its name, such
    as `Linux` for Linux and `Darwin` for macOS. On pure Windows (no MSYS2 or Cygwin),
    the command doesn't exist, which would get us the second part of this `if/else`
    statement.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用（命令行）`uname`命令，我们可以检查我们正在运行的操作系统，每个在shell中支持该命令的操作系统都会返回其名称，例如，Linux的`Linux`和macOS的`Darwin`。在纯Windows（没有MSYS2或Cygwin）上，该命令不存在，这将得到这个`if/else`语句的第二部分。
- en: 'This statement could be expanded to support more OSes, depending on what the
    build system requires. In this case, it is only used to determine whether executables
    we create should have a file extension:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这条语句可以根据构建系统的需求扩展以支持更多的操作系统。在这种情况下，它仅用于确定我们创建的可执行文件是否应该有文件扩展名：
- en: '[PRE36]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In this `if/else` statement, we can set the appropriate command-line commands
    for common file operations. Since we're taking the easy way out, we're assuming
    the use of MSYS2 or similar Bash shell on Windows.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`if/else`语句中，我们可以设置常见文件操作的正确命令行命令。由于我们选择了简单的方法，我们假设在Windows上使用MSYS2或类似的Bash
    shell。
- en: 'We could take the concept of generalizing further at this point as well, splitting
    off the OS file CLI tools as its own set of Makefiles, which we can then include
    as part of OS-specific settings:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们也可以进一步推广概念，将操作系统文件CLI工具作为一组独立的Makefile分离出来，然后我们可以将其作为操作系统特定设置的组成部分包含进来：
- en: '[PRE37]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'At this point, we use the target parameter provided to the Makefile to include
    the appropriate configuration file. After exporting some details from it, we now
    have a configured build system:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们使用Makefile提供的目标参数来包含适当的配置文件。在从中导出一些详细信息后，我们现在有一个配置好的构建系统：
- en: '[PRE38]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: From this single Makefile, we can choose to compile the entire project or just
    the dependencies or the core project. We can also compile a specific external
    dependency and nothing else.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个单一的Makefile中，我们可以选择编译整个项目或仅编译依赖项或核心项目。我们还可以编译特定的外部依赖项，而不编译其他任何内容。
- en: Finally, we can clean the core project, the dependencies, or both.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以清理核心项目、依赖项或两者。
- en: 'This top Makefile is primarily for controlling the underlying Makefiles. The
    next two Makefiles are found in the `Core` and `extern` folders. Of these, the
    `Core` Makefile simply directly compiles the project''s core:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个顶级Makefile主要用于控制底层的Makefile。接下来的两个Makefile位于`Core`和`extern`文件夹中。在这些文件夹中，`Core`
    Makefile直接编译项目的核心：
- en: '[PRE39]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As the first step, we include the Makefile configuration for the target platform
    so that we have access to all of its definitions. These could also have been exported
    in the main Makefile, but this way we're free to customize the build system even
    more.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，我们包含目标平台的Makefile配置，以便我们可以访问其所有定义。这些也可以在主Makefile中导出，但这样我们可以更自由地自定义构建系统。
- en: 'We specify the name of the output binary that we''re building, before some
    small tasks, including opening the `version` file (with Makefile syntax) in the
    root of the project, which contains the version number of the source we''re building
    from. This is prepared to be passed as a preprocessor definition into the compiler:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行一些小任务之前，我们指定要构建的输出二进制文件名，包括在项目根目录下打开`version`文件（使用Makefile语法），其中包含我们从源代码构建的版本号。这是准备传递给编译器的预处理器定义：
- en: '[PRE40]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This is another section where we rely on having a Bash shell or something compatible
    around, as we use the date command in order to create a timestamp for the build.
    The format depends on what parameter was passed to the main Makefile. If we're
    building a release, we take the timestamp from the Git repository, with the Git
    commit tag name used to retrieve the commit timestamp for that tag before formatting
    it.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个我们需要有一个Bash shell或兼容工具的章节，因为我们使用日期命令来为构建创建时间戳。格式取决于传递给主Makefile的参数。如果我们正在构建一个发布版本，我们从Git仓库中获取时间戳，使用Git提交标签名称来检索该标签的提交时间戳，然后再进行格式化。
- en: If `GITTIME` is passed as parameter, the timestamp of the most recent Git commit
    is used. Otherwise, the current time and date is used (UTC).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传递了`GITTIME`参数，则使用最近的Git提交的时间戳。否则，使用当前时间和日期（UTC）。
- en: 'This bit of code is intended to solve one of the issues that comes with having
    lots of test and integration builds: keeping track of which ones were built when
    and with which revision of the source code. It could be adapted to other file
    revision systems, as long as it supports similar functionality with the retrieving
    of specific timestamps.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码旨在解决与大量测试和集成构建相关的问题之一：跟踪哪些构建了何时以及使用源代码的哪个版本。它可以适应其他文件版本控制系统，只要它支持类似的功能，包括检索特定的时间戳。
- en: 'Of note is the second timestamp we''re creating. This is a slightly different
    formatted version of the timestamp that is affixed to the produced binary, except
    when we''re building in release mode:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，我们创建的第二个时间戳。这是一个与附加到生成的二进制文件的时间戳略有不同格式的版本，除非我们在发布模式下构建：
- en: '[PRE41]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here, we set the flags we wish to pass to the compiler, including the version
    and timestamp, both being passed as preprocessor definitions.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们设置希望传递给编译器的标志，包括版本和时间戳，这两者都作为预处理器定义传递。
- en: 'Finally, the sources in the current project folder are collected and the output
    folder for the object files is set. As we can see here, we''ll be writing the
    object files to a folder underneath the project root, with further separation
    by the compile target:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当前项目文件夹中的源代码被收集，对象文件的输出文件夹被设置。正如我们所看到的，我们将对象文件写入项目根目录下的一个文件夹中，并通过编译目标进行进一步分离：
- en: '[PRE42]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This part is fairly generic for a Makefile. We have the `all` target, along
    with one to make the folders on the filesystem, if they don''t exist yet. Finally,
    we take in the array of source files in the next target, compiling them as configured
    and outputting the object file in the appropriate folder:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分对于Makefile来说相当通用。我们有`all`目标，以及一个用于在文件系统中创建文件夹（如果尚不存在）的目标。最后，我们在下一个目标中接收源文件数组，按照配置编译它们，并将对象文件输出到适当的文件夹：
- en: '[PRE43]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'After we have created all of the object files from our source files, we want
    to link them together, which happens in this step. We can also see where the binary
    will end up: in a `bin` sub-folder of the project''s build folder.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们从源文件创建所有对象文件之后，我们希望将它们链接在一起，这一步骤就是为此而设。我们还可以看到二进制文件最终将放在哪里：在项目构建文件夹的`bin`子文件夹中。
- en: The linker is called, and we create a copy of the resulting binary, which we
    post-fix with `.debug` to indicate that it is the version with all of the debug
    information. The original binary is then stripped of its debug symbols and other
    unneeded information, leaving us with a small binary to copy to the remote test
    system and a larger version with all of the debug information for when we need
    to analyze core dumps or do remote debugging.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 调用链接器，并创建结果的二进制文件的副本，我们将其后缀为`.debug`以指示它是包含所有调试信息的版本。然后，原始二进制文件被剥离其调试符号和其他不需要的信息，留下一个较小的二进制文件，可以复制到远程测试系统，以及一个包含所有调试信息的大版本，以便我们在需要分析核心转储或进行远程调试时使用。
- en: 'What we also see here is a small hack that got added due to an unsupported
    command-line flag by Clang''s linker, requiring the implementation of a special
    case. While working on cross-platform compiling and similar tasks, one is likely
    to run into many of such small details, all of which complicate the writing of
    a universal build system that simply works:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们还看到了由于 Clang 链接器不支持命令行标志而添加的一个小技巧，需要实现一个特殊案例。在处理跨平台编译和类似任务时，很可能会遇到许多这样的小细节，所有这些都使得编写一个简单有效的通用构建系统变得复杂：
- en: '[PRE44]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As a final step, we allow for the generated object files to be deleted.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，我们允许删除生成的目标文件。
- en: 'The second sub-Makefile in `extern` is also of note, as it controls all of
    the underlying dependencies:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`extern` 中的第二个子 Makefile 也值得关注，因为它控制了所有底层依赖：'
- en: '[PRE45]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'An interesting feature here is the dependency selector based on the target
    platform. If we have dependencies that shouldn''t be compiled for a specific platform,
    we can skip them here. This feature also allows us to directly instruct this Makefile
    to compile all dependencies for a specific platform. Here, we allow for the targeting
    of QNX, Linux, OS X/macOS, and Windows, while ignoring the architecture:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个有趣的功能，即基于目标平台的依赖选择器。如果我们有不应为特定平台编译的依赖项，我们可以在这里跳过它们。此功能还允许我们直接指示此 Makefile
    编译特定平台的全部依赖项。在这里，我们允许针对 QNX、Linux、OS X/macOS 和 Windows 进行目标定位，同时忽略架构：
- en: '[PRE46]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The actual targets merely call another Makefile at the top of the dependency
    project, which in turn compiles that dependency and adds it to the build folder,
    where it can be used by the `Core`'s Makefile.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的目标仅仅是调用依赖项目顶部的另一个 Makefile，该 Makefile 依次编译该依赖并将其添加到构建文件夹中，以便 `Core` 的 Makefile
    可以使用。
- en: 'Of course, we can also directly compile the project from this Makefile using
    an existing build system, such as here for OpenSSL:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也可以直接使用现有的构建系统，如这里用于 OpenSSL 的构建系统：
- en: '[PRE47]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This code works through all of the usual steps of building OpenSSL by hand,
    before copying the resulting binaries to their target folders.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码通过手动构建 OpenSSL 的所有常规步骤工作，然后将生成的二进制文件复制到目标文件夹中。
- en: One issue with cross-platform build systems one may notice is that a common
    GNU tool such as Autoconf is extremely slow on OSes such as Windows, due to it
    launching many processes as it runs hundreds of tests. Even on Linux, this process
    can take a long time, which is very annoying and time consuming when running through
    the same build process multiple times a day.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会注意到的一个跨平台构建系统的问题是，像 Autoconf 这样的常见 GNU 工具在 Windows 等操作系统上非常慢，因为它在运行时启动了数百个进程进行测试。即使在
    Linux 上，这个过程也可能需要很长时间，这在每天多次运行相同的构建过程中非常令人烦恼且耗时。
- en: 'The ideal case is having a simple Makefile in which everything is predefined
    and in a known state so that no library discovery and such are needed. This was
    one of the motivations behind adding the POCO library source code to one project
    and having a simple Makefile compile it:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 理想的情况是拥有一个简单的 Makefile，其中所有内容都预先定义且处于已知状态，因此无需进行库发现等操作。这是将 POCO 库源代码添加到项目中并使用简单的
    Makefile 编译它的动机之一：
- en: '[PRE48]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This Makefile then calls the individual Makefile for each module, as in this
    example:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 此 Makefile 然后调用每个模块的单独 Makefile，例如在这个示例中：
- en: '[PRE49]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This Makefile compiles the entire `Net` module of the library. It's similar
    in structure to the one for compiling the project core source files. In addition
    to compiling the object files, it puts them into an archive so that we can link
    against it later, and copies this archive as well as the header files to their
    place in the build folder.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 此 Makefile 编译了库的整个 `Net` 模块。其结构与编译项目核心源文件的 Makefile 类似。除了编译目标文件外，它还将它们放入存档中，以便我们可以在以后链接到它，并将此存档以及头文件复制到构建文件夹中的相应位置。
- en: The main reason for compiling the library for the project was to allow for specific
    optimizations and tweaks that wouldn't be available with a precompiled library.
    By having everything but the basics stripped out of the library's original build
    system, trying out different settings was made very easy and even worked on Windows.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 编译库到项目中的主要原因是允许进行特定的优化和调整，这些优化和调整在预编译库中是不可用的。通过从库的原始构建系统中移除所有非基本内容，尝试不同的设置变得非常容易，甚至在
    Windows 上也能工作。
- en: Remote testing on real hardware
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在真实硬件上进行远程测试
- en: After we have done all of the local testing of our code and are reasonably certain
    that it should work on the real hardware, we can use the cross-compile build system
    to create a binary that we can then run on the target system.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对代码进行所有本地测试并且合理确信它应该在真实硬件上工作之后，我们可以使用交叉编译构建系统创建一个二进制文件，然后我们可以在目标系统上运行它。
- en: At this point, we can simply copy the resulting binary and associated files
    to the target system and see whether it works. The more scientific way to do this
    is to use GDB. With the GDB server service installed on the target Linux system,
    we can connect to it with GDB from our PC, either via the network or a serial
    connection.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以简单地复制生成的二进制文件和相关文件到目标系统，看看它是否工作。更科学的方法是使用 GDB。在目标 Linux 系统上安装了 GDB
    服务器服务后，我们可以通过我们的 PC 连接到它，无论是通过网络还是串行连接。
- en: 'For SBCs running a Debian-based Linux installation, the GDB server can be easily
    installed:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 对于运行基于 Debian 的 Linux 安装的 SBC，GDB 服务器可以很容易地安装：
- en: '[PRE50]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Although it is called `gdbserver`, its essential function is that of a remote
    stub implementation for the debugger, which runs on the host system. This makes
    `gdbserver` very lightweight and simple to implement for new targets.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它被称为 `gdbserver`，但其基本功能是作为调试器的远程存根实现，它在主机系统上运行。这使得 `gdbserver` 对于新目标来说非常轻量级且易于实现。
- en: 'After this, we want to make sure that `gdbserver` is running by logging in
    to the system and starting it in one of a variety of ways. We can do so for TPC
    connections over the network like this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们想要确保 `gdbserver` 正在运行，可以通过登录系统并以多种方式之一启动它。我们可以这样在网络上的 TPC 连接上做到这一点：
- en: '[PRE51]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Or we can attach it to a running process:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以将其附加到正在运行的进程上：
- en: '[PRE52]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `host` part of the first argument refers to the name (or IP address) of
    the host system that will be connecting. This parameter is currently ignored,
    meaning that it can also be left empty. The port section has to be a port that
    is not currently in use on the target system.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数的 `host` 部分指的是将要连接的主机系统的名称（或 IP 地址）。这个参数目前被忽略，这意味着它也可以留空。端口部分必须是一个目标系统上当前未使用的端口。
- en: 'Or we can use some kind of serial connection:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以使用某种串行连接：
- en: '[PRE53]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The moment we launch `gdbserver`, it pauses the execution of the target application
    if it was already running, allowing us to connect with the debugger from the host
    system. While on the target system, we can run a binary that has been stripped
    of its debug symbols; these are required to be present in the binary that we use
    on the host side:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启动 `gdbserver` 时，如果目标应用已经在运行，它会暂停其执行，使我们能够从主机系统连接到调试器。在目标系统上，我们可以运行一个去除了调试符号的二进制文件；这些符号必须存在于我们在主机端使用的二进制文件中：
- en: '[PRE54]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'At this point, debug symbols would be loaded from the binary, along with those
    from any dependencies (if available). Connecting over a serial connection would
    look similar, just with the address and port replaced with the serial interface
    path or name. The `baud` rate of the serial connection (if not the default 9,600
    baud) is specified as a parameter to GDB when we''re starting:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，调试符号将从二进制文件中加载，以及从任何依赖项（如果可用）中加载。通过串行连接连接看起来类似，只是将地址和端口替换为串行接口路径或名称。串行连接的
    `baud` 率（如果不是默认的 9,600 波特）在启动时作为参数指定给 GDB：
- en: '[PRE55]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Once we have told GDB the details of the remote target, we should see the usual
    GDB command-line interface appear, allowing us to step through, analyze, and debug
    the program as if it was running locally on our system.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们告诉 GDB 远程目标的详细信息，我们应该看到通常的 GDB 命令行界面出现，允许我们逐步执行、分析和调试程序，就像它在我们的系统上本地运行一样。
- en: As mentioned earlier in this chapter, we're using `gdb-multiarch` as this version
    of the GDB debugger supports different architectures, which is useful since we'll
    likely be running the debugger on an x86_64 system, whereas the SBC is very likely
    ARM-based, but could also be MIPS or x86 (i686).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所述，我们使用 `gdb-multiarch`，因为这个版本的 GDB 调试器支持不同的架构，这在我们将很可能在 x86_64 系统上运行调试器时很有用，而单板计算机（SBC）很可能基于
    ARM，但也可能是 MIPS 或 x86（i686）。
- en: 'In addition to running the application directly with `gdbserver`, we can also
    start `gdbserver` to just wait for a debugger to connect:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 除了直接使用 `gdbserver` 运行应用程序外，我们还可以启动 `gdbserver` 以等待调试器连接：
- en: '[PRE56]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Or we can do this:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以这样做：
- en: '[PRE57]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We would then connect to this remote target like this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以此方式连接到这个远程目标：
- en: '[PRE58]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: At this point, we should find ourselves at the GDB command-line interface again,
    with the program binary loaded on both target and host.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们应该再次回到GDB命令行界面，程序二进制文件已加载在目标和主机上。
- en: A big advantage of this method is that `gdbserver` does not exit when the application
    that's being debugged exits. In addition, this mode allows us to debug different
    applications simultaneously on the same target, assuming that the target supports
    this.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点之一是，当被调试的应用程序退出时，`gdbserver`不会退出。此外，这种模式允许我们在同一目标上同时调试不同的应用程序，前提是目标支持这种模式。
- en: Summary
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at how to develop and test embedded, OS-based applications.
    We learned how to install and use a cross-compilation toolchain, how to do remote
    debugging using GDB, and how to write a build system that allows us to compile
    for a wide variety of target systems with minimal effort required to add a new
    target.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何开发和测试基于操作系统的嵌入式应用程序。我们学习了如何安装和使用交叉编译工具链，如何使用GDB进行远程调试，以及如何编写一个构建系统，使我们能够以最小的努力为各种目标系统编译。
- en: At this point, you are expected to be able to develop and debug an embedded
    application for a Linux-based SBC or similar, while being able to work in an efficient
    way.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应能够开发并调试基于Linux的SBC或类似设备的嵌入式应用程序，同时能够以高效的方式工作。
- en: In the next chapter, we'll be looking at how to develop for and test applications
    for more constrained, MCU-based platforms.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何为更受限制的基于MCU的平台开发和测试应用程序。
