["```cpp\n#pragma once\n#include <SFML/Graphics.hpp>\nusing namespace sf;\nclass Particle\n{\nprivate:\n    Vector2f m_Position;\n    Vector2f m_Velocity;\npublic:\n    Particle(Vector2f direction);\n    void update(float dt);\n    void setPosition(Vector2f position);\n    Vector2f getPosition();\n};\n```", "```cpp\n#include \"Particle.h\"\nParticle::Particle(Vector2f direction)\n{\n    // Determine the direction\n\n    m_Velocity.x = direction.x;\n    m_Velocity.y = direction.y;\n}\nvoid Particle::update(float dtAsSeconds)\n{\n    // Move the particle\n    m_Position += m_Velocity * dtAsSeconds;\n}\nvoid Particle::setPosition(Vector2f position)\n{\n    m_Position = position;\n}\nVector2f Particle::getPosition()\n{\n    return m_Position;\n}\n```", "```cpp\nclass SpaceShip : public Drawable\n{\nprivate:\n    Sprite m_Sprite;\n    // More private members\npublic:\n    virtual void draw(RenderTarget& target, \n        RenderStates states) const;\n    // More public members\n};\n```", "```cpp\nvoid SpaceShip::SpaceShip\n{\n    // Set up the spaceship\n}\nvoid SpaceShip::draw(RenderTarget& target, RenderStates states) const\n{\n    target.draw(m_Sprite, states);\n}\n// Any other functions\n```", "```cpp\nSpaceShip m_SpaceShip;\n// create other objects here\n// ...\n// In the draw function\n// Rub out the last frame\nm_Window.clear(Color::Black);\n// Draw the spaceship\nm_Window.draw(m_SpaceShip);\n// More drawing here\n// ...\n// Show everything we have just drawn\nm_Window.display();\n```", "```cpp\nvoid drawThisObject(RenderWindow window)\n{\n    window.draw(m_Sprite)\n}\n```", "```cpp\n playerHero.draw(m_Window);\n```", "```cpp\n#pragma once\n#include <SFML/Graphics.hpp>\n#include \"Particle.h\"\nusing namespace sf;\nusing namespace std;\nclass ParticleSystem : public Drawable\n{\nprivate:\n    vector<Particle> m_Particles;\n    VertexArray m_Vertices;\n    float m_Duration;\n    bool m_IsRunning = false;\npublic:\n    virtual void draw(RenderTarget& target, \n      RenderStates states) const;\n\n    void init(int count);\n    void emitParticles(Vector2f position);\n    void update(float elapsed);\n    bool running();\n};\n```", "```cpp\nm_Window.draw(m_PS);\n```", "```cpp\n#include <SFML/Graphics.hpp>\n#include \"ParticleSystem.h\"\nusing namespace sf;\nusing namespace std;\nvoid ParticleSystem::init(int numParticles)\n{\n    m_Vertices.setPrimitiveType(Points);\n    m_Vertices.resize(numParticles);\n    // Create the particles\n    for (int i = 0; i < numParticles; i++)\n    {\n        srand(time(0) + i);\n        float angle = (rand() % 360) * 3.14f / 180.f;\n        float speed = (rand() % 600) + 600.f;\n        Vector2f direction;\n        direction = Vector2f(cos(angle) * speed,\n            sin(angle) * speed);\n        m_Particles.push_back(Particle(direction));\n    }\n}\n```", "```cpp\nvoid ParticleSystem::update(float dt)\n{\n    m_Duration -= dt;\n    vector<Particle>::iterator i;\n    int currentVertex = 0;\n    for (i = m_Particles.begin(); i != m_Particles.end(); i++)\n    {\n        // Move the particle\n        (*i).update(dt);\n        // Update the vertex array\n        m_Vertices[currentVertex++].position = i->getPosition();\n    }\n    if (m_Duration < 0)\n    {\n        m_IsRunning = false;\n    }\n}\n```", "```cpp\nvoid ParticleSystem::emitParticles(Vector2f startPosition)\n{\n    m_IsRunning = true;\n    m_Duration = 2;\n\n    int currentVertex = 0;\n    for (auto it = m_Particles.begin(); \n         it != m_Particles.end();\n         it++)\n    {\n        m_Vertices[currentVertex++].color = Color::Yellow;\n        it->setPosition(startPosition);\n    }\n}\n```", "```cpp\nvoid ParticleSystem::\n       draw(RenderTarget& target, \n       RenderStates states) const\n{\n    target.draw(m_Vertices, states);\n}\n```", "```cpp\nbool ParticleSystem::running()\n{\n    return m_IsRunning;\n}\n```", "```cpp\n#pragma once\n#include <SFML/Graphics.hpp>\n#include \"TextureHolder.h\"\n#include \"Thomas.h\"\n#include \"Bob.h\"\n#include \"LevelManager.h\"\n#include \"SoundManager.h\"\n#include \"HUD.h\"\n#include \"ParticleSystem.h\"\nusing namespace sf;\nclass Engine\n{\nprivate:\n    // The texture holder\n    TextureHolder th;\n    // create a particle system\n    ParticleSystem m_PS;\n    // Thomas and his friend, Bob\n    Thomas m_Thomas;\n    Bob m_Bob;\n```", "```cpp\nEngine::Engine()\n{\n    // Get the screen resolution and create an SFML window and View\n    Vector2f resolution;\n    resolution.x = VideoMode::getDesktopMode().width;\n    resolution.y = VideoMode::getDesktopMode().height;\n    m_Window.create(VideoMode(resolution.x, resolution.y),\n        \"Thomas was late\",\n        Style::Fullscreen);\n    // Initialize the full screen view\n    m_MainView.setSize(resolution);\n    m_HudView.reset(\n        FloatRect(0, 0, resolution.x, resolution.y));\n    // Initialize the split-screen Views\n    m_LeftView.setViewport(\n        FloatRect(0.001f, 0.001f, 0.498f, 0.998f));\n    m_RightView.setViewport(\n        FloatRect(0.5f, 0.001f, 0.499f, 0.998f));\n    m_BGLeftView.setViewport(\n        FloatRect(0.001f, 0.001f, 0.498f, 0.998f));\n    m_BGRightView.setViewport(\n        FloatRect(0.5f, 0.001f, 0.499f, 0.998f));\n    // Can this graphics card use shaders?\n    if (!sf::Shader::isAvailable())\n    {\n        // Time to get a new PC\n        m_Window.close();\n    }\n    m_BackgroundTexture = TextureHolder::GetTexture(\n        \"graphics/background.png\");\n    // Associate the sprite with the texture\n    m_BackgroundSprite.setTexture(m_BackgroundTexture);\n    // Load the texture for the background vertex array\n    m_TextureTiles = TextureHolder::GetTexture(\n        \"graphics/tiles_sheet.png\");\n    // Initialize the particle system\n    m_PS.init(1000);\n}// End Engine constructor\n```", "```cpp\n    // Update the HUD every m_TargetFramesPerHUDUpdate frames\n    if (m_FramesSinceLastHUDUpdate > m_TargetFramesPerHUDUpdate)\n    {\n        // Update game HUD text\n        stringstream ssTime;\n        stringstream ssLevel;\n        // Update the time text\n        ssTime << (int)m_TimeRemaining;\n        m_Hud.setTime(ssTime.str());\n        // Update the level text\n        ssLevel << \"Level:\" << m_LM.getCurrentLevel();\n        m_Hud.setLevel(ssLevel.str());\n        m_FramesSinceLastHUDUpdate = 0;\n    }\n    // Update the particles\n    if (m_PS.running())\n    {\n        m_PS.update(dtAsSeconds);\n    }\n}// End of update function\n```", "```cpp\n// Is character colliding with a regular block\nif (m_ArrayLevel[y][x] == 1)\n{\n    if (character.getRight().intersects(block))\n    {\n        character.stopRight(block.left);\n    }\n    else if (character.getLeft().intersects(block))\n    {\n        character.stopLeft(block.left);\n    }\n    if (character.getFeet().intersects(block))\n    {\n        character.stopFalling(block.top);\n    }\n    else if (character.getHead().intersects(block))\n    {\n        character.stopJump();\n    }\n}\n// More collision detection here once \n// we have learned about particle effects\n// Have the characters' feet touched fire or water?\n// If so, start a particle effect\n// Make sure this is the first time we have detected this\n// by seeing if an effect is already running            \nif (!m_PS.running()) {\n    if (m_ArrayLevel[y][x] == 2 || m_ArrayLevel[y][x] == 3)\n    {\n        if (character.getFeet().intersects(block))\n        {\n            // position and start the particle system\n            m_PS.emitParticles(character.getCenter());\n        }\n    }\n}\n// Has the character reached the goal?\nif (m_ArrayLevel[y][x] == 4)\n{\n    // Character has reached the goal\n    reachedGoal = true;\n}\n```", "```cpp\nvoid Engine::draw()\n{\n    // Rub out the last frame\n    m_Window.clear(Color::White);\n    if (!m_SplitScreen)\n    {\n        // Switch to background view\n        m_Window.setView(m_BGMainView);\n        // Draw the background\n        m_Window.draw(m_BackgroundSprite);\n        // Switch to m_MainView\n        m_Window.setView(m_MainView);        \n        // Draw the Level\n        m_Window.draw(m_VALevel, &m_TextureTiles);\n        // Draw thomas\n        m_Window.draw(m_Thomas.getSprite());\n        // Draw bob\n        m_Window.draw(m_Bob.getSprite());\n        // Draw the particle system\n        if (m_PS.running())\n        {\n            m_Window.draw(m_PS);\n        }\n    }\n    else\n    {\n        // Split-screen view is active\n        // First draw Thomas' side of the screen\n        // Switch to background view\n        m_Window.setView(m_BGLeftView);\n        // Draw the background\n        m_Window.draw(m_BackgroundSprite);\n        // Switch to m_LeftView\n        m_Window.setView(m_LeftView);\n        // Draw the Level\n        m_Window.draw(m_VALevel, &m_TextureTiles);\n\n        // Draw bob\n        m_Window.draw(m_Bob.getSprite());\n        // Draw thomas\n        m_Window.draw(m_Thomas.getSprite());\n        // Draw the particle system\n        if (m_PS.running())\n        {\n            m_Window.draw(m_PS);\n        }\n\n        // Now draw Bob's side of the screen\n        // Switch to background view\n        m_Window.setView(m_BGRightView);\n        // Draw the background\n        m_Window.draw(m_BackgroundSprite);\n        // Switch to m_RightView\n        m_Window.setView(m_RightView);\n        // Draw the Level\n        m_Window.draw(m_VALevel, &m_TextureTiles);\n        // Draw thomas\n        m_Window.draw(m_Thomas.getSprite());\n        // Draw bob\n        m_Window.draw(m_Bob.getSprite());\n        // Draw the particle system\n        if (m_PS.running())\n        {\n            m_Window.draw(m_PS);\n        }\n\n    }\n\n    // Draw the HUD\n    // Switch to m_HudView\n    m_Window.setView(m_HudView);\n    m_Window.draw(m_Hud.getLevel());\n    m_Window.draw(m_Hud.getTime());\n    if (!m_Playing)\n    {\n        m_Window.draw(m_Hud.getMessage());\n    }\n\n    // Show everything we have just drawn\n    m_Window.display();\n}\n```", "```cpp\n// attributes from vertShader.vert\nvarying vec4 vColor;\nvarying vec2 vTexCoord;\n// uniforms\nuniform sampler2D uTexture;\nuniform float uTime;\nvoid main() {\n    float coef = sin(gl_FragCoord.y * 0.1 + 1 * uTime);\n    vTexCoord.y +=  coef * 0.03;\n    gl_FragColor = vColor * texture2D(uTexture, vTexCoord);\n}\n```", "```cpp\n//varying \"out\" variables to be used in the fragment shader\nvarying vec4 vColor;\nvarying vec2 vTexCoord;\n\nvoid main() {\n    vColor = gl_Color;\n    vTexCoord = (gl_TextureMatrix[0] * gl_MultiTexCoord0).xy;\n    gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\n}\n```", "```cpp\n// Three views for the background\nView m_BGMainView;\nView m_BGLeftView;\nView m_BGRightView;\nView m_HudView;\n// Declare a sprite and a Texture for the background\nSprite m_BackgroundSprite;\nTexture m_BackgroundTexture;\n// Declare a shader for the background\nShader m_RippleShader;\n// Is the game currently playing?\nbool m_Playing = false;\n// Is character 1 or 2 the current focus?\nbool m_Character1 = true;\n```", "```cpp\n// Can this graphics card use shaders?\nif (!sf::Shader::isAvailable())\n{\n    // Time to get a new PC\n    // Or remove all the shader related code L\n    m_Window.close();\n}\nelse\n{\n    // Load two shaders (1 vertex, 1 fragment)\n    m_RippleShader.loadFromFile(\"shaders/vertShader.vert\",\n        \"shaders/rippleShader.frag\");\n}\nm_BackgroundTexture = TextureHolder::GetTexture(\n    \"graphics/background.png\");\n```", "```cpp\nvoid Engine::draw()\n{\n    // Rub out the last frame\n    m_Window.clear(Color::White);\n    // Update the shader parameters\nm_RippleShader.setUniform(\"uTime\", \n      m_GameTimeTotal.asSeconds());\n    if (!m_SplitScreen)\n    {\n        // Switch to background view\n        m_Window.setView(m_BGMainView);\n        // Draw the background\n        //m_Window.draw(m_BackgroundSprite);\n        // Draw the background, complete with shader effect\n        m_Window.draw(m_BackgroundSprite, &m_RippleShader);\n        // Switch to m_MainView\n        m_Window.setView(m_MainView);\n        // Draw the Level\n        m_Window.draw(m_VALevel, &m_TextureTiles);\n        // Draw thomas\n        m_Window.draw(m_Thomas.getSprite());\n        // Draw thomas\n        m_Window.draw(m_Bob.getSprite());\n        // Draw the particle system\n        if (m_PS.running())\n        {\n            m_Window.draw(m_PS);\n        }\n    }\n    else\n    {\n        // Split-screen view is active\n        // First draw Thomas' side of the screen\n        // Switch to background view\n        m_Window.setView(m_BGLeftView);\n        // Draw the background\n        //m_Window.draw(m_BackgroundSprite);\n        // Draw the background, complete with shader effect\n        m_Window.draw(m_BackgroundSprite, &m_RippleShader);\n        // Switch to m_LeftView\n        m_Window.setView(m_LeftView);\n        // Draw the Level\n        m_Window.draw(m_VALevel, &m_TextureTiles);\n\n        // Draw thomas\n        m_Window.draw(m_Bob.getSprite());\n        // Draw thomas\n        m_Window.draw(m_Thomas.getSprite());\n        // Draw the particle system\n        if (m_PS.running())\n        {\n            m_Window.draw(m_PS);\n        }\n\n        // Now draw Bob's side of the screen\n        // Switch to background view\n        m_Window.setView(m_BGRightView);\n        // Draw the background\n        //m_Window.draw(m_BackgroundSprite);\n        // Draw the background, complete with shader effect\n        m_Window.draw(m_BackgroundSprite, &m_RippleShader);\n        // Switch to m_RightView\n        m_Window.setView(m_RightView);\n        // Draw the Level\n        m_Window.draw(m_VALevel, &m_TextureTiles);\n        // Draw thomas\n        m_Window.draw(m_Thomas.getSprite());\n        // Draw bob\n        m_Window.draw(m_Bob.getSprite());\n        // Draw the particle system\n        if (m_PS.running())\n        {\n            m_Window.draw(m_PS);\n        }                \n    }\n\n    // Draw the HUD\n    // Switch to m_HudView\n    m_Window.setView(m_HudView);\n    m_Window.draw(m_Hud.getLevel());\n    m_Window.draw(m_Hud.getTime());\n    if (!m_Playing)\n    {\n        m_Window.draw(m_Hud.getMessage());\n    }    \n\n    // Show everything we have just drawn\n    m_Window.display();\n}\n```"]