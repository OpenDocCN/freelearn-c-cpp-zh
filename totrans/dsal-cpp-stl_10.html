<html><head></head><body>
		<div><h1 id="_idParaDest-465" class="chapter-number"><a id="_idTextAnchor465"/>10</h1>
			<h1 id="_idParaDest-466"><a id="_idTextAnchor466"/>Advanced Container  View Usage</h1>
			<p>At their core, views are non-owning ranges, meaning they provide a view (hence the name) of other data structures without taking ownership of the underlying data. This makes them incredibly lightweight and versatile. With views, you can perform various operations on data without copying it, ensuring efficient code that maximizes performance and minimizes overhead.</p>
			<p>This chapter focuses on the following containers:</p>
			<ul>
				<li><code>std::span</code></li>
				<li><code>std::mdspan</code></li>
			</ul>
			<h1 id="_idParaDest-467"><a id="_idTextAnchor467"/>Technical requirements</h1>
			<p>The code in this chapter can be found on GitHub:</p>
			<p><a href="https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL">https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL</a></p>
			<h1 id="_idParaDest-468"><a id="_idTextAnchor468"/>std::span</h1>
			<p><code>std::span</code> is a<a id="_idIndexMarker702"/> template class introduced in C++20 that provides a view of a contiguous sequence of elements, similar to a lightweight, non-owning reference. It represents a range over some contiguous storage, such as an array or a portion of a vector, without owning the underlying data.</p>
			<p>The primary purpose of <code>std::span</code> is to safely and efficiently pass arrays of data to functions without needing to pass the size explicitly, as the size information is encapsulated within the <code>std::span</code> object. It can be considered a safer, more flexible alternative to raw pointer-and-size or pointer-and-length parameter passing.</p>
			<h2 id="_idParaDest-469"><a id="_idTextAnchor469"/>Purpose and suitability</h2>
			<p><code>std::span</code> is a non-owning view of a contiguous sequence, often an array or a segment of another container. It is a lightweight, flexible, and safe way to refer to such sequences, ensuring no extraneous copies.</p>
			<p><code>std::span</code> is best suited in the <a id="_idIndexMarker703"/>following scenarios:</p>
			<ul>
				<li>When a temporary view of data is needed</li>
				<li>When the underlying data’s ownership is managed elsewhere</li>
				<li>When you want to avoid unnecessary data copying but still need random access</li>
			</ul>
			<p>Consider using <code>std::span</code> to provide functions with access to parts of data without granting ownership.</p>
			<h2 id="_idParaDest-470"><a id="_idTextAnchor470"/>Ideal use cases</h2>
			<p>The following are some of <a id="_idIndexMarker704"/>the ideal use cases of <code>std::span</code>:</p>
			<ul>
				<li><strong class="bold">Processing data segments</strong>: Parsing a subsegment of a large data block, such as processing headers in a networking buffer</li>
				<li><strong class="bold">Function interfaces</strong>: Granting functions a view of data without transferring ownership or risking resource leaks</li>
				<li><strong class="bold">Data views</strong>: Quickly and safely offering multiple views on a data source without duplicating the source</li>
			</ul>
			<h2 id="_idParaDest-471"><a id="_idTextAnchor471"/>Performance</h2>
			<p>The<a id="_idIndexMarker705"/> algorithmic performance of <code>std::span</code> is characterized as follows:</p>
			<ul>
				<li><code>std::span</code> doesn’t own its data</li>
				<li><strong class="bold">Deletion</strong>: Not applicable</li>
				<li><strong class="bold">Access</strong>: <em class="italic">O(1)</em>, just like direct array access</li>
				<li><strong class="bold">Memory overhead</strong>: Minimal, as it essentially holds a pointer and a size</li>
			</ul>
			<p>Remember, the <a id="_idIndexMarker706"/>performance of <code>std::span</code> mainly derives from its non-owning characteristic.</p>
			<h2 id="_idParaDest-472"><a id="_idTextAnchor472"/>Memory management</h2>
			<p>No allocations <a id="_idIndexMarker707"/>are done by <code>std::span</code>. It simply references memory owned elsewhere. Thus, concerns about memory behavior primarily relate to the underlying data, not the span itself.</p>
			<h2 id="_idParaDest-473"><a id="_idTextAnchor473"/>Thread safety</h2>
			<p>Multiple concurrent<a id="_idIndexMarker708"/> reads through a span are safe. However, as with any data structure, concurrent writes or write-read combinations require synchronization.</p>
			<h2 id="_idParaDest-474"><a id="_idTextAnchor474"/>Extensions and variants</h2>
			<p><code>std::span</code> is<a id="_idIndexMarker709"/> unique in the <code>std::string_view</code> offer a similar view concept, they cater to specific data types.</p>
			<h2 id="_idParaDest-475"><a id="_idTextAnchor475"/>Sorting and searching complexity</h2>
			<p>Sorting <a id="_idIndexMarker710"/>isn’t directly applicable to <code>std::span</code>, since it doesn’t own its data. Searching, however, is <em class="italic">O(n)</em> for an unsorted sequence and <em class="italic">O(log n)</em> for sorted data using appropriate STL algorithms.</p>
			<h2 id="_idParaDest-476"><a id="_idTextAnchor476"/>Interface and member functions</h2>
			<p>Key<a id="_idIndexMarker711"/> functions in <a id="_idIndexMarker712"/>this category include the following:</p>
			<ul>
				<li><code>size()</code>: Returns the number of elements</li>
				<li><code>data()</code>: Provides access to the underlying data</li>
				<li><code>subspan()</code>: Generates another span from the current one</li>
			</ul>
			<h2 id="_idParaDest-477"><a id="_idTextAnchor477"/>Comparisons</h2>
			<p>Compared<a id="_idIndexMarker713"/> to <code>std::vector</code> or <code>std::array</code>, <code>std::span</code> doesn’t manage or own data. It offers a way to safely view sections of these containers (or others) without copying.</p>
			<h2 id="_idParaDest-478"><a id="_idTextAnchor478"/>Interactions with algorithms</h2>
			<p>STL algorithms<a id="_idIndexMarker714"/> requiring access (and not structure modification) can interact with <code>std::span</code> seamlessly. Those requiring insertions or deletions should be avoided.</p>
			<h2 id="_idParaDest-479"><a id="_idTextAnchor479"/>Exceptions</h2>
			<p>Operating <a id="_idIndexMarker715"/>beyond the bounds of the span can trigger exceptions. Always ensure the underlying data’s validity during the span’s entire lifetime.</p>
			<h2 id="_idParaDest-480"><a id="_idTextAnchor480"/>Customization</h2>
			<p><code>std::span</code> isn’t <a id="_idIndexMarker716"/>typically customized with allocators, comparators, or hash functions due to its non-owning nature.</p>
			<h2 id="_idParaDest-481"><a id="_idTextAnchor481"/>Example</h2>
			<p>Let’s look<a id="_idIndexMarker717"/> at an example demonstrating the use of <code>std::span</code> to process<a id="_idIndexMarker718"/> the headers of a <strong class="bold">User Datagram Protocol</strong> (<strong class="bold">UDP</strong>) packet.</p>
			<p>UDP headers typically consist of the following:</p>
			<ul>
				<li><strong class="bold">Source port</strong>: 2 bytes</li>
				<li><strong class="bold">Destination port</strong>: 2 bytes</li>
				<li><strong class="bold">Length</strong>: 2 bytes</li>
				<li><strong class="bold">Checksum</strong>: 2 bytes</li>
			</ul>
			<p>We’ll create a simple structure representing the header, and then we’ll use <code>std::span</code> to handle a buffer containing the header and data of a UDP packet. Let’s explore the<a id="_idIndexMarker719"/> following code:</p>
			<pre class="source-code">
#include &lt;cstdint&gt;
#include &lt;iostream&gt;
#include &lt;span&gt;
struct UDPHeader {
  uint16_t srcPort{0};
  uint16_t destPort{0};
  uint16_t length{0};
  uint16_t checksum{0};
  void display() const {
    std::cout &lt;&lt; "Source Port: " &lt;&lt; srcPort &lt;&lt; "\n"
              &lt;&lt; "Destination Port: " &lt;&lt; destPort &lt;&lt; "\n"
              &lt;&lt; "Length: " &lt;&lt; length &lt;&lt; "\n"
              &lt;&lt; "Checksum: " &lt;&lt; checksum &lt;&lt; "\n";
  }
};
void processUDPPacket(std::span&lt;const uint8_t&gt; packet) {
  if (packet.size() &lt; sizeof(UDPHeader)) {
    std::cerr &lt;&lt; "Invalid packet size!\n";
    return;
  }
  auto headerSpan = packet.subspan(0, sizeof(UDPHeader));
  const UDPHeader &amp;header =
      *reinterpret_cast&lt;const UDPHeader *&gt;(
          headerSpan.data());
  header.display();
  auto dataSpan = packet.subspan(sizeof(UDPHeader));
  std::cout &lt;&lt; "Data size: " &lt;&lt; dataSpan.size()
            &lt;&lt; " bytes\n";
}
int main() {
  uint8_t udpPacket[] = {0x08, 0x15, // Source port
                         0x09, 0x16, // Destination port
                         0x00, 0x10, // Length
                         0x12, 0x34, // Checksum
                         // Some data
                         0x01, 0x02, 0x03, 0x04, 0x05,
                         0x06};
  processUDPPacket(udpPacket);
  return 0;
}</pre>			<p>Here is the example output:</p>
			<pre class="console">
Source Port: 5384
Destination Port: 5641
Length: 4096
Checksum: 13330
Data size: 6 bytes</pre>			<p>The key <a id="_idIndexMarker720"/>points from the preceding code are as follows:</p>
			<ul>
				<li>We define a <code>UDPHeader</code> structure to represent the header fields.</li>
				<li>In the <code>processUDPPacket</code> function, we use <code>std::span</code> to handle the buffer.</li>
				<li>We then create a <code>subspan</code> for the header and reinterpret it as the <code>UDPHeader</code> structure.</li>
				<li>The remaining part of the buffer is the data, which we handle using another <code>subspan</code>.</li>
			</ul>
			<p><code>std::span</code> offers a view of a contiguous sequence of objects, making it suitable for safely accessing memory regions, such as networking buffers, without owning the underlying data.</p>
			<h2 id="_idParaDest-482"><a id="_idTextAnchor482"/>Best practices</h2>
			<p>Let us<a id="_idIndexMarker721"/> explore the best practices of using <code>std::span</code>:</p>
			<ul>
				<li><code>std::span</code> outlives the span itself. This is critical to avoid dangling references.</li>
				<li><code>std::span</code> is not a data-owning container. It only provides a view of the data, unlike containers such as <code>std::vector</code> that manage their data.</li>
				<li><code>std::span</code> view. This joint reflection means data integrity must be maintained throughout the span’s life cycle.</li>
				<li><code>std::span</code> judiciously. Always ensure the span’s duration is shorter than or equal to the lifetime of the underlying data.</li>
				<li><code>std::span</code> in function interfaces to prevent unnecessary<a id="_idIndexMarker722"/> data copying. This can optimize performance, especially when working with large data blocks.</li>
				<li><code>std::span</code>. Utilize functions such as <code>size()</code> for bounds verification.</li>
				<li><code>std::span</code> over raw pointer and length pairs. It offers a type-safe, more readable alternative, reducing the risk of common pointer errors.</li>
				<li><code>std::span</code> for abstracting data segments. It’s especially beneficial when different components or functions of a program need access to varying data sections without full ownership.</li>
				<li><code>std::span</code> offers random access iterators, it’s compatible with most STL algorithms. However, be cautious when using algorithms that might expect data ownership or mutation capabilities beyond the scope of <code>std::span</code>.</li>
				<li><code>std::span</code>, given its direct reflection properties.</li>
			</ul>
			<h1 id="_idParaDest-483"><a id="_idTextAnchor483"/>std::mdspan</h1>
			<p><code>std::mdspan</code>, introduced<a id="_idIndexMarker723"/> in the C++23 standard, is a multidimensional span template class that extends the concept of <code>std::span</code> to multiple dimensions. It provides a view of a multidimensional contiguous sequence of elements without owning the underlying data. This class is handy for numerical computations and <a id="_idIndexMarker724"/>algorithms that operate on multidimensional data structures, such as matrices and tensors.</p>
			<h2 id="_idParaDest-484"><a id="_idTextAnchor484"/>Purpose and suitability</h2>
			<p><code>std::mdspan</code> is a <a id="_idIndexMarker725"/>multidimensional span in the C++ STL. It is a non-owning view of a multidimensional array, offering efficient access and manipulation.</p>
			<p>Its strengths are as follows:</p>
			<ul>
				<li>Representing and accessing multidimensional data without owning it</li>
				<li>Facilitating interoperability with other languages and libraries that work with multidimensional arrays</li>
			</ul>
			<p><code>std::mdspan</code> is particularly<a id="_idIndexMarker726"/> suitable in the following scenarios:</p>
			<ul>
				<li>When you must work with multidimensional data from other libraries or APIs without copying</li>
				<li>When you require flexibility in indexing and slicing through multidimensional datasets.</li>
			</ul>
			<h2 id="_idParaDest-485"><a id="_idTextAnchor485"/>Ideal use cases</h2>
			<p>The following are<a id="_idIndexMarker727"/> some of the ideal use cases of <code>std::mdspan</code>:</p>
			<ul>
				<li><strong class="bold">Image processing</strong>: Accessing pixels in a 2D image or frames in a 3D video stream</li>
				<li><strong class="bold">Scientific computing</strong>: Manipulating data in matrix formats for mathematical computations</li>
				<li><strong class="bold">Data wrangling</strong>: Efficiently re-indexing, slicing, or reshaping multidimensional datasets</li>
				<li><strong class="bold">Interoperability</strong>: Interfacing with other languages or libraries that manage multidimensional data structures</li>
			</ul>
			<h2 id="_idParaDest-486"><a id="_idTextAnchor486"/>Performance</h2>
			<p>The <a id="_idIndexMarker728"/>algorithmic performance of <code>std::mdspan</code> is characterized as follows:</p>
			<ul>
				<li><strong class="bold">Access</strong>: Typically <em class="italic">O(1)</em> for any position.</li>
				<li><code>std::mdspan</code> only provides a view of existing data.</li>
				<li><code>std::mdspan</code> itself.</li>
			</ul>
			<h2 id="_idParaDest-487"><a id="_idTextAnchor487"/>Memory management</h2>
			<p>Since <code>std::mdspan</code> doesn’t <a id="_idIndexMarker729"/>own its data, it does not control memory allocation or deallocation. Ensure the underlying data remains valid during the <code>mdspan</code> lifespan.</p>
			<h2 id="_idParaDest-488"><a id="_idTextAnchor488"/>Thread safety</h2>
			<p>Like <code>std::span</code>, multiple<a id="_idIndexMarker730"/> concurrent reads are safe, but writes or mixed reads and writes necessitate external synchronization.</p>
			<h2 id="_idParaDest-489"><a id="_idTextAnchor489"/>Extensions and variants</h2>
			<p><code>std::span</code> can be<a id="_idIndexMarker731"/> seen as a 1D variant. While <code>std::span</code> provides a view of linear data, <code>std::mdspan</code> extends this concept to multidimensional data.</p>
			<h2 id="_idParaDest-490"><a id="_idTextAnchor490"/>Sorting and searching complexity</h2>
			<p>Sorting and searching <a id="_idIndexMarker732"/>are not inherently properties of <code>std::mdspan</code>, given its nature. External algorithms would need to be adapted to their multidimensional characteristics.</p>
			<h2 id="_idParaDest-491"><a id="_idTextAnchor491"/>Special interface and member functions</h2>
			<p><code>std::mdspan</code> offers <a id="_idIndexMarker733"/>the following special interface and member<a id="_idIndexMarker734"/> functions:</p>
			<ul>
				<li><code>extent</code>: Returns the size in a given dimension</li>
				<li><code>strides</code>: Provides the number of elements between successive items in each dimension</li>
				<li><code>rank</code>: Gives the number of dimensions</li>
			</ul>
			<h2 id="_idParaDest-492"><a id="_idTextAnchor492"/>Comparisons</h2>
			<p>Against raw <a id="_idIndexMarker735"/>multidimensional arrays or pointers, <code>std::mdspan</code> offers a safer and more flexible interface, albeit without data ownership.</p>
			<h2 id="_idParaDest-493"><a id="_idTextAnchor493"/>Interactions with algorithms</h2>
			<p>While many STL algorithms <a id="_idIndexMarker736"/>are designed for linear data structures, specific algorithms, especially custom ones for multidimensional data, can be adapted to work with <code>std::mdspan</code>.</p>
			<h2 id="_idParaDest-494"><a id="_idTextAnchor494"/>Exceptions</h2>
			<p>Given its <a id="_idIndexMarker737"/>non-owning nature, accessing data through an invalidated <code>std::mdspan</code> (if the underlying data is destroyed) is an undefined behavior and won’t throw standard exceptions. Always ensure data validity.</p>
			<h2 id="_idParaDest-495"><a id="_idTextAnchor495"/>Customization</h2>
			<p><code>std::mdspan</code> can <a id="_idIndexMarker738"/>be customized using layout policies to define data storage patterns.</p>
			<h2 id="_idParaDest-496"><a id="_idTextAnchor496"/>Best practices</h2>
			<p>Let us explore <a id="_idIndexMarker739"/>the best practices of using <code>std::mdspan</code>:</p>
			<ul>
				<li><code>std::mdspan</code> is a non-owning view. Ensure that you never mistakenly treat it as a data-owning container. This oversight can introduce dangling references and undefined behavior.</li>
				<li><code>std::mdspan</code>. Understanding and adjusting these aspects can optimize your data access patterns, making them more cache-friendly.</li>
				<li><code>std::mdspan</code>’s layout with the expected convention can prevent subtle bugs and inefficiencies.</li>
				<li><code>std::mdspan</code> points remain valid for the span’s entire lifetime. Avoid situations where the underlying data could be destroyed or go out of scope while an active <code>std::mdspan</code> references it.</li>
				<li><strong class="bold">Explicit layout specification</strong>: When working alongside different libraries, especially those external to the C++ STL, be overt about the expected data layouts. Such clarity prevents ambiguities and ensures consistent data interpretation.</li>
				<li><code>std::mdspan</code> as a parameter. This choice offers safety from dangling references (compared to raw pointers) and greater expressiveness regarding multidimensional data operations.</li>
				<li><code>std::mdspan</code>. While <code>std::mdspan</code> offers some level of type safety, out-of-bounds access still leads to undefined behavior. Consider using functions such as <code>extents</code> to ascertain dimensions.</li>
				<li><code>std::mdspan</code> interprets the underlying data using layout policies for advanced use cases. This flexibility can be particularly valuable when needing non-standard data arrangements or optimizing for specific hardware architectures.</li>
				<li><code>std::span</code>, <code>std::mdspan</code> itself doesn’t guarantee <a id="_idIndexMarker741"/>thread safety for the underlying data. If multithreaded access is anticipated, ensure the underlying data structure or its operations are thread-safe.</li>
				<li><code>std::mdspan</code> doesn’t naturally fit all STL algorithms due to its multidimensional nature, you can still use many algorithms on a flattened view or individual slices of the data. Being familiar with STL algorithms can help you avoid reinventing the wheel.</li>
			</ul>
		</div>
	

		<div><h1 id="_idParaDest-497" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor497"/>Part 3: Mastering STL Algorithms</h1>
		</div>
		<div><p>In this Part, you will acquire a robust understanding of the algorithmic backbone of the C++ STL. We establish a foundation with fundamental algorithms, emphasizing sorting, searching, and element comparison, essential to efficient data manipulation. We then dive into the transformative power of STL through copying, moving, filling, and generating operations, revealing techniques for optimal data manipulation while underpinning the importance of modern idioms like <strong class="bold">Return Value </strong><strong class="bold">Optimization (RVO)</strong>.</p>
			<p>Continuing, we explore numeric operations, from simple summations to complex inner products, and extend our focus to range-based operations, underscoring their significance in modern C++. The subsequent chapter transitions to the structured manipulation of data sets through partitioning, heap operations, and permutations, illustrating their pivotal roles in data organization and analysis.</p>
			<p>Finally, we conclude by introducing the concept of ranges, an evolution in STL that brings a more expressive and efficient approach to algorithmic operations. We dissect the advantages and best practices of range-based algorithms for sorting and searching, advocating for their adoption in contemporary C++ development. Best practices are highlighted throughout, providing you with a clear pathway to writing clean, efficient, and maintainable code with STL algorithms.</p>
			<p>This part has the following chapters:</p>
			<ul>
				<li><a href="B21945_11.xhtml#_idTextAnchor498"><em class="italic">Chapter 11</em></a><em class="italic">: Fundamental Algorithms and Searching</em></li>
				<li><a href="B21945_12.xhtml#_idTextAnchor507"><em class="italic">Chapter 12</em></a><em class="italic">: Manipulation and Transformation</em></li>
				<li><a href="B21945_13.xhtml#_idTextAnchor530"><em class="italic">Chapter 13</em></a><em class="italic">: Numeric and Range-Based Operations</em></li>
				<li><a href="B21945_14.xhtml#_idTextAnchor542"><em class="italic">Chapter 14</em></a><em class="italic">: Permutations, Partitions, and Heaps</em></li>
				<li><a href="B21945_15.xhtml#_idTextAnchor563"><em class="italic">Chapter 15</em></a><em class="italic">: Modern STL with Ranges</em></li>
			</ul>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
	</body></html>