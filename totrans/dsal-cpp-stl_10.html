<html><head></head><body>
		<div id="_idContainer024">
			<h1 id="_idParaDest-465" class="chapter-number"><a id="_idTextAnchor465"/>10</h1>
			<h1 id="_idParaDest-466"><a id="_idTextAnchor466"/>Advanced Container  View Usage</h1>
			<p>At their core, views are non-owning ranges, meaning they provide a view (hence the name) of other data structures without taking ownership of the underlying data. This makes them incredibly lightweight and versatile. With views, you can perform various operations on data without copying it, ensuring efficient code that maximizes performance and <span class="No-Break">minimizes overhead.</span></p>
			<p>This chapter focuses on the <span class="No-Break">following containers:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">std::span</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">std::mdspan</strong></span></li>
			</ul>
			<h1 id="_idParaDest-467"><a id="_idTextAnchor467"/>Technical requirements</h1>
			<p>The code in this chapter can be found <span class="No-Break">on GitHub:</span></p>
			<p><a href="https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL"><span class="No-Break">https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL</span></a></p>
			<h1 id="_idParaDest-468"><a id="_idTextAnchor468"/>std::span</h1>
			<p><strong class="source-inline">std::span</strong> is a<a id="_idIndexMarker702"/> template class introduced in C++20 that provides a view of a contiguous sequence of elements, similar to a lightweight, non-owning reference. It represents a range over some contiguous storage, such as an array or a portion of a vector, without owning the <span class="No-Break">underlying data.</span></p>
			<p>The primary purpose of <strong class="source-inline">std::span</strong> is to safely and efficiently pass arrays of data to functions without needing to pass the size explicitly, as the size information is encapsulated within the <strong class="source-inline">std::span</strong> object. It can be considered a safer, more flexible alternative to raw pointer-and-size or pointer-and-length <span class="No-Break">parameter passing.</span></p>
			<h2 id="_idParaDest-469"><a id="_idTextAnchor469"/>Purpose and suitability</h2>
			<p><strong class="source-inline">std::span</strong> is a non-owning view of a contiguous sequence, often an array or a segment of another container. It is a lightweight, flexible, and safe way to refer to such sequences, ensuring no <span class="No-Break">extraneous copies.</span></p>
			<p><strong class="source-inline">std::span</strong> is best suited in the <a id="_idIndexMarker703"/><span class="No-Break">following scenarios:</span></p>
			<ul>
				<li>When a temporary view of data <span class="No-Break">is needed</span></li>
				<li>When the underlying data’s ownership is <span class="No-Break">managed elsewhere</span></li>
				<li>When you want to avoid unnecessary data copying but still need <span class="No-Break">random access</span></li>
			</ul>
			<p>Consider using <strong class="source-inline">std::span</strong> to provide functions with access to parts of data without <span class="No-Break">granting ownership.</span></p>
			<h2 id="_idParaDest-470"><a id="_idTextAnchor470"/>Ideal use cases</h2>
			<p>The following are some of <a id="_idIndexMarker704"/>the ideal use cases <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">std::span</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="bold">Processing data segments</strong>: Parsing a subsegment of a large data block, such as processing headers in a <span class="No-Break">networking buffer</span></li>
				<li><strong class="bold">Function interfaces</strong>: Granting functions a view of data without transferring ownership or risking <span class="No-Break">resource leaks</span></li>
				<li><strong class="bold">Data views</strong>: Quickly and safely offering multiple views on a data source without duplicating <span class="No-Break">the source</span></li>
			</ul>
			<h2 id="_idParaDest-471"><a id="_idTextAnchor471"/>Performance</h2>
			<p>The<a id="_idIndexMarker705"/> algorithmic performance of <strong class="source-inline">std::span</strong> is characterized <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Insertion</strong>: Not applicable, as <strong class="source-inline">std::span</strong> doesn’t own <span class="No-Break">its data</span></li>
				<li><strong class="bold">Deletion</strong>: <span class="No-Break">Not applicable</span></li>
				<li><strong class="bold">Access</strong>: <em class="italic">O(1)</em>, just like direct <span class="No-Break">array access</span></li>
				<li><strong class="bold">Memory overhead</strong>: Minimal, as it essentially holds a pointer and <span class="No-Break">a size</span></li>
			</ul>
			<p>Remember, the <a id="_idIndexMarker706"/>performance of <strong class="source-inline">std::span</strong> mainly derives from its <span class="No-Break">non-owning characteristic.</span></p>
			<h2 id="_idParaDest-472"><a id="_idTextAnchor472"/>Memory management</h2>
			<p>No allocations <a id="_idIndexMarker707"/>are done by <strong class="source-inline">std::span</strong>. It simply references memory owned elsewhere. Thus, concerns about memory behavior primarily relate to the underlying data, not the <span class="No-Break">span itself.</span></p>
			<h2 id="_idParaDest-473"><a id="_idTextAnchor473"/>Thread safety</h2>
			<p>Multiple concurrent<a id="_idIndexMarker708"/> reads through a span are safe. However, as with any data structure, concurrent writes or write-read combinations <span class="No-Break">require synchronization.</span></p>
			<h2 id="_idParaDest-474"><a id="_idTextAnchor474"/>Extensions and variants</h2>
			<p><strong class="source-inline">std::span</strong> is<a id="_idIndexMarker709"/> unique in the <strong class="bold">Standard Template Library</strong> (<strong class="bold">STL</strong>) and designed for its purpose. While containers such as <strong class="source-inline">std::string_view</strong> offer a similar view concept, they cater to specific <span class="No-Break">data types.</span></p>
			<h2 id="_idParaDest-475"><a id="_idTextAnchor475"/>Sorting and searching complexity</h2>
			<p>Sorting <a id="_idIndexMarker710"/>isn’t directly applicable to <strong class="source-inline">std::span</strong>, since it doesn’t own its data. Searching, however, is <em class="italic">O(n)</em> for an unsorted sequence and <em class="italic">O(log n)</em> for sorted data using appropriate <span class="No-Break">STL algorithms.</span></p>
			<h2 id="_idParaDest-476"><a id="_idTextAnchor476"/>Interface and member functions</h2>
			<p>Key<a id="_idIndexMarker711"/> functions in <a id="_idIndexMarker712"/>this category include <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="source-inline">size()</strong>: Returns the number <span class="No-Break">of elements</span></li>
				<li><strong class="source-inline">data()</strong>: Provides access to the <span class="No-Break">underlying data</span></li>
				<li><strong class="source-inline">subspan()</strong>: Generates another span from the <span class="No-Break">current one</span></li>
			</ul>
			<h2 id="_idParaDest-477"><a id="_idTextAnchor477"/>Comparisons</h2>
			<p>Compared<a id="_idIndexMarker713"/> to <strong class="source-inline">std::vector</strong> or <strong class="source-inline">std::array</strong>, <strong class="source-inline">std::span</strong> doesn’t manage or own data. It offers a way to safely view sections of these containers (or others) <span class="No-Break">without copying.</span></p>
			<h2 id="_idParaDest-478"><a id="_idTextAnchor478"/>Interactions with algorithms</h2>
			<p>STL algorithms<a id="_idIndexMarker714"/> requiring access (and not structure modification) can interact with <strong class="source-inline">std::span</strong> seamlessly. Those requiring insertions or deletions should <span class="No-Break">be avoided.</span></p>
			<h2 id="_idParaDest-479"><a id="_idTextAnchor479"/>Exceptions</h2>
			<p>Operating <a id="_idIndexMarker715"/>beyond the bounds of the span can trigger exceptions. Always ensure the underlying data’s validity during the span’s <span class="No-Break">entire lifetime.</span></p>
			<h2 id="_idParaDest-480"><a id="_idTextAnchor480"/>Customization</h2>
			<p><strong class="source-inline">std::span</strong> isn’t <a id="_idIndexMarker716"/>typically customized with allocators, comparators, or hash functions due to its <span class="No-Break">non-owning nature.</span></p>
			<h2 id="_idParaDest-481"><a id="_idTextAnchor481"/>Example</h2>
			<p>Let’s look<a id="_idIndexMarker717"/> at an example demonstrating the use of <strong class="source-inline">std::span</strong> to process<a id="_idIndexMarker718"/> the headers of a <strong class="bold">User Datagram Protocol</strong> (<span class="No-Break"><strong class="bold">UDP</strong></span><span class="No-Break">) packet.</span></p>
			<p>UDP headers typically consist of <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Source port</strong>: <span class="No-Break">2 bytes</span></li>
				<li><strong class="bold">Destination port</strong>: <span class="No-Break">2 bytes</span></li>
				<li><strong class="bold">Length</strong>: <span class="No-Break">2 bytes</span></li>
				<li><strong class="bold">Checksum</strong>: <span class="No-Break">2 bytes</span></li>
			</ul>
			<p>We’ll create a simple structure representing the header, and then we’ll use <strong class="source-inline">std::span</strong> to handle a buffer containing the header and data of a UDP packet. Let’s explore the<a id="_idIndexMarker719"/> <span class="No-Break">following code:</span></p>
			<pre class="source-code">
#include &lt;cstdint&gt;
#include &lt;iostream&gt;
#include &lt;span&gt;
struct UDPHeader {
  uint16_t srcPort{0};
  uint16_t destPort{0};
  uint16_t length{0};
  uint16_t checksum{0};
  void display() const {
    std::cout &lt;&lt; "Source Port: " &lt;&lt; srcPort &lt;&lt; "\n"
              &lt;&lt; "Destination Port: " &lt;&lt; destPort &lt;&lt; "\n"
              &lt;&lt; "Length: " &lt;&lt; length &lt;&lt; "\n"
              &lt;&lt; "Checksum: " &lt;&lt; checksum &lt;&lt; "\n";
  }
};
void processUDPPacket(std::span&lt;const uint8_t&gt; packet) {
  if (packet.size() &lt; sizeof(UDPHeader)) {
    std::cerr &lt;&lt; "Invalid packet size!\n";
    return;
  }
  auto headerSpan = packet.subspan(0, sizeof(UDPHeader));
  const UDPHeader &amp;header =
      *reinterpret_cast&lt;const UDPHeader *&gt;(
          headerSpan.data());
  header.display();
  auto dataSpan = packet.subspan(sizeof(UDPHeader));
  std::cout &lt;&lt; "Data size: " &lt;&lt; dataSpan.size()
            &lt;&lt; " bytes\n";
}
int main() {
  uint8_t udpPacket[] = {0x08, 0x15, // Source port
                         0x09, 0x16, // Destination port
                         0x00, 0x10, // Length
                         0x12, 0x34, // Checksum
                         // Some data
                         0x01, 0x02, 0x03, 0x04, 0x05,
                         0x06};
  processUDPPacket(udpPacket);
  return 0;
}</pre>			<p>Here is the <span class="No-Break">example output:</span></p>
			<pre class="console">
Source Port: 5384
Destination Port: 5641
Length: 4096
Checksum: 13330
Data size: 6 bytes</pre>			<p>The key <a id="_idIndexMarker720"/>points from the preceding code are <span class="No-Break">as follows:</span></p>
			<ul>
				<li>We define a <strong class="source-inline">UDPHeader</strong> structure to represent the <span class="No-Break">header fields.</span></li>
				<li>In the <strong class="source-inline">processUDPPacket</strong> function, we use <strong class="source-inline">std::span</strong> to handle <span class="No-Break">the buffer.</span></li>
				<li>We then create a <strong class="source-inline">subspan</strong> for the header and reinterpret it as the <span class="No-Break"><strong class="source-inline">UDPHeader</strong></span><span class="No-Break"> structure.</span></li>
				<li>The remaining part of the buffer is the data, which we handle using <span class="No-Break">another </span><span class="No-Break"><strong class="source-inline">subspan</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p><strong class="source-inline">std::span</strong> offers a view of a contiguous sequence of objects, making it suitable for safely accessing memory regions, such as networking buffers, without owning the <span class="No-Break">underlying data.</span></p>
			<h2 id="_idParaDest-482"><a id="_idTextAnchor482"/>Best practices</h2>
			<p>Let us<a id="_idIndexMarker721"/> explore the best practices of <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">std::span</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="bold">Dangling references</strong>: Ensure that the underlying data of <strong class="source-inline">std::span</strong> outlives the span itself. This is critical to avoid <span class="No-Break">dangling references.</span></li>
				<li><strong class="bold">Non-owning nature</strong>: Understand that <strong class="source-inline">std::span</strong> is not a data-owning container. It only provides a view of the data, unlike containers such as <strong class="source-inline">std::vector</strong> that manage <span class="No-Break">their data.</span></li>
				<li><strong class="bold">Mutual reflection</strong>: Be aware that any modifications to the underlying data will immediately reflect in the <strong class="source-inline">std::span</strong> view. This joint reflection means data integrity must be maintained throughout the span’s <span class="No-Break">life cycle.</span></li>
				<li><strong class="bold">Data lifetime</strong>: Use <strong class="source-inline">std::span</strong> judiciously. Always ensure the span’s duration is shorter than or equal to the lifetime of the <span class="No-Break">underlying data.</span></li>
				<li><strong class="bold">Copy management</strong>: Favor <strong class="source-inline">std::span</strong> in function interfaces to prevent unnecessary<a id="_idIndexMarker722"/> data copying. This can optimize performance, especially when working with large <span class="No-Break">data blocks.</span></li>
				<li><strong class="bold">Bounds checking</strong>: As with any data access, always validate bounds before accessing elements through <strong class="source-inline">std::span</strong>. Utilize functions such as <strong class="source-inline">size()</strong> for <span class="No-Break">bounds verification.</span></li>
				<li><strong class="bold">Safety over raw pointers</strong>: Opt for <strong class="source-inline">std::span</strong> over raw pointer and length pairs. It offers a type-safe, more readable alternative, reducing the risk of common <span class="No-Break">pointer errors.</span></li>
				<li><strong class="bold">Data abstraction</strong>: Leverage <strong class="source-inline">std::span</strong> for abstracting data segments. It’s especially beneficial when different components or functions of a program need access to varying data sections without <span class="No-Break">full ownership.</span></li>
				<li><strong class="bold">Interactions with STL algorithms</strong>: Since <strong class="source-inline">std::span</strong> offers random access iterators, it’s compatible with most STL algorithms. However, be cautious when using algorithms that might expect data ownership or mutation capabilities beyond the scope <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">std::span</strong></span><span class="No-Break">.</span></li>
				<li><strong class="bold">Data synchronization</strong>: In multithreaded scenarios, ensure proper synchronization when accessing or modifying the underlying data through <strong class="source-inline">std::span</strong>, given its direct <span class="No-Break">reflection properties.</span></li>
			</ul>
			<h1 id="_idParaDest-483"><a id="_idTextAnchor483"/>std::mdspan</h1>
			<p><strong class="source-inline">std::mdspan</strong>, introduced<a id="_idIndexMarker723"/> in the C++23 standard, is a multidimensional span template class that extends the concept of <strong class="source-inline">std::span</strong> to multiple dimensions. It provides a view of a multidimensional contiguous sequence of elements without owning the underlying data. This class is handy for numerical computations and <a id="_idIndexMarker724"/>algorithms that operate on multidimensional data structures, such as matrices <span class="No-Break">and tensors.</span></p>
			<h2 id="_idParaDest-484"><a id="_idTextAnchor484"/>Purpose and suitability</h2>
			<p><strong class="source-inline">std::mdspan</strong> is a <a id="_idIndexMarker725"/>multidimensional span in the C++ STL. It is a non-owning view of a multidimensional array, offering efficient access <span class="No-Break">and manipulation.</span></p>
			<p>Its strengths are <span class="No-Break">as follows:</span></p>
			<ul>
				<li>Representing and accessing multidimensional data without <span class="No-Break">owning it</span></li>
				<li>Facilitating interoperability with other languages and libraries that work with <span class="No-Break">multidimensional arrays</span></li>
			</ul>
			<p><strong class="source-inline">std::mdspan</strong> is particularly<a id="_idIndexMarker726"/> suitable in the <span class="No-Break">following scenarios:</span></p>
			<ul>
				<li>When you must work with multidimensional data from other libraries or APIs <span class="No-Break">without copying</span></li>
				<li>When you require flexibility in indexing and slicing through <span class="No-Break">multidimensional datasets.</span></li>
			</ul>
			<h2 id="_idParaDest-485"><a id="_idTextAnchor485"/>Ideal use cases</h2>
			<p>The following are<a id="_idIndexMarker727"/> some of the ideal use cases <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">std::mdspan</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="bold">Image processing</strong>: Accessing pixels in a 2D image or frames in a 3D <span class="No-Break">video stream</span></li>
				<li><strong class="bold">Scientific computing</strong>: Manipulating data in matrix formats for <span class="No-Break">mathematical computations</span></li>
				<li><strong class="bold">Data wrangling</strong>: Efficiently re-indexing, slicing, or reshaping <span class="No-Break">multidimensional datasets</span></li>
				<li><strong class="bold">Interoperability</strong>: Interfacing with other languages or libraries that manage multidimensional <span class="No-Break">data structures</span></li>
			</ul>
			<h2 id="_idParaDest-486"><a id="_idTextAnchor486"/>Performance</h2>
			<p>The <a id="_idIndexMarker728"/>algorithmic performance of <strong class="source-inline">std::mdspan</strong> is characterized <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Access</strong>: Typically <em class="italic">O(1)</em> for <span class="No-Break">any position.</span></li>
				<li><strong class="bold">Memory overhead</strong>: Minimal, as <strong class="source-inline">std::mdspan</strong> only provides a view of <span class="No-Break">existing data.</span></li>
				<li><strong class="bold">Trade-offs</strong>: The primary trade-off is the lack of ownership. Ensure underlying data outlives the <span class="No-Break"><strong class="source-inline">std::mdspan</strong></span><span class="No-Break"> itself.</span></li>
			</ul>
			<h2 id="_idParaDest-487"><a id="_idTextAnchor487"/>Memory management</h2>
			<p>Since <strong class="source-inline">std::mdspan</strong> doesn’t <a id="_idIndexMarker729"/>own its data, it does not control memory allocation or deallocation. Ensure the underlying data remains valid during the <span class="No-Break"><strong class="source-inline">mdspan</strong></span><span class="No-Break"> lifespan.</span></p>
			<h2 id="_idParaDest-488"><a id="_idTextAnchor488"/>Thread safety</h2>
			<p>Like <strong class="source-inline">std::span</strong>, multiple<a id="_idIndexMarker730"/> concurrent reads are safe, but writes or mixed reads and writes necessitate <span class="No-Break">external synchronization.</span></p>
			<h2 id="_idParaDest-489"><a id="_idTextAnchor489"/>Extensions and variants</h2>
			<p><strong class="source-inline">std::span</strong> can be<a id="_idIndexMarker731"/> seen as a 1D variant. While <strong class="source-inline">std::span</strong> provides a view of linear data, <strong class="source-inline">std::mdspan</strong> extends this concept to <span class="No-Break">multidimensional data.</span></p>
			<h2 id="_idParaDest-490"><a id="_idTextAnchor490"/>Sorting and searching complexity</h2>
			<p>Sorting and searching <a id="_idIndexMarker732"/>are not inherently properties of <strong class="source-inline">std::mdspan</strong>, given its nature. External algorithms would need to be adapted to their <span class="No-Break">multidimensional characteristics.</span></p>
			<h2 id="_idParaDest-491"><a id="_idTextAnchor491"/>Special interface and member functions</h2>
			<p><strong class="source-inline">std::mdspan</strong> offers <a id="_idIndexMarker733"/>the following special interface and <span class="No-Break">member</span><span class="No-Break"><a id="_idIndexMarker734"/></span><span class="No-Break"> functions:</span></p>
			<ul>
				<li><strong class="source-inline">extent</strong>: Returns the size in a <span class="No-Break">given dimension</span></li>
				<li><strong class="source-inline">strides</strong>: Provides the number of elements between successive items in <span class="No-Break">each dimension</span></li>
				<li><strong class="source-inline">rank</strong>: Gives the number <span class="No-Break">of dimensions</span></li>
			</ul>
			<h2 id="_idParaDest-492"><a id="_idTextAnchor492"/>Comparisons</h2>
			<p>Against raw <a id="_idIndexMarker735"/>multidimensional arrays or pointers, <strong class="source-inline">std::mdspan</strong> offers a safer and more flexible interface, albeit without <span class="No-Break">data ownership.</span></p>
			<h2 id="_idParaDest-493"><a id="_idTextAnchor493"/>Interactions with algorithms</h2>
			<p>While many STL algorithms <a id="_idIndexMarker736"/>are designed for linear data structures, specific algorithms, especially custom ones for multidimensional data, can be adapted to work <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">std::mdspan</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-494"><a id="_idTextAnchor494"/>Exceptions</h2>
			<p>Given its <a id="_idIndexMarker737"/>non-owning nature, accessing data through an invalidated <strong class="source-inline">std::mdspan</strong> (if the underlying data is destroyed) is an undefined behavior and won’t throw standard exceptions. Always ensure <span class="No-Break">data validity.</span></p>
			<h2 id="_idParaDest-495"><a id="_idTextAnchor495"/>Customization</h2>
			<p><strong class="source-inline">std::mdspan</strong> can <a id="_idIndexMarker738"/>be customized using layout policies to define data <span class="No-Break">storage patterns.</span></p>
			<h2 id="_idParaDest-496"><a id="_idTextAnchor496"/>Best practices</h2>
			<p>Let us explore <a id="_idIndexMarker739"/>the best practices of <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">std::mdspan</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="bold">Ownership awareness</strong>: <strong class="source-inline">std::mdspan</strong> is a non-owning view. Ensure that you never mistakenly treat it as a data-owning container. This oversight can introduce dangling references and <span class="No-Break">undefined behavior.</span></li>
				<li><strong class="bold">Efficient data access</strong>: Pay attention to the layout and stride when using <strong class="source-inline">std::mdspan</strong>. Understanding and adjusting these aspects can optimize your data access patterns, making them <span class="No-Break">more cache-friendly.</span></li>
				<li><strong class="bold">Inter-language interoperability</strong>: If you’re interfacing with libraries from other<a id="_idIndexMarker740"/> programming languages, be particularly vigilant about data layouts. Languages have their conventions, such as row-major or column-major storage. Aligning <strong class="source-inline">std::mdspan</strong>’s layout with the expected convention can prevent subtle bugs <span class="No-Break">and inefficiencies.</span></li>
				<li><strong class="bold">Lifetime management</strong>: It’s paramount that the data to which <strong class="source-inline">std::mdspan</strong> points remain valid for the span’s entire lifetime. Avoid situations where the underlying data could be destroyed or go out of scope while an active <strong class="source-inline">std::mdspan</strong> <span class="No-Break">references it.</span></li>
				<li><strong class="bold">Explicit layout specification</strong>: When working alongside different libraries, especially those external to the C++ STL, be overt about the expected data layouts. Such clarity prevents ambiguities and ensures consistent <span class="No-Break">data interpretation.</span></li>
				<li><strong class="bold">API design</strong>: When designing APIs that manipulate multidimensional data, prefer using <strong class="source-inline">std::mdspan</strong> as a parameter. This choice offers safety from dangling references (compared to raw pointers) and greater expressiveness regarding multidimensional <span class="No-Break">data operations.</span></li>
				<li><strong class="bold">Bound checks</strong>: Test the dimensions and bounds before accessing data through <strong class="source-inline">std::mdspan</strong>. While <strong class="source-inline">std::mdspan</strong> offers some level of type safety, out-of-bounds access still leads to undefined behavior. Consider using functions such as <strong class="source-inline">extents</strong> to <span class="No-Break">ascertain dimensions.</span></li>
				<li><strong class="bold">Custom layouts</strong>: You can customize how <strong class="source-inline">std::mdspan</strong> interprets the underlying data using layout policies for advanced use cases. This flexibility can be particularly valuable when needing non-standard data arrangements or optimizing for specific <span class="No-Break">hardware architectures.</span></li>
				<li><strong class="bold">Thread safety</strong>: Like its sibling <strong class="source-inline">std::span</strong>, <strong class="source-inline">std::mdspan</strong> itself doesn’t guarantee <a id="_idIndexMarker741"/>thread safety for the underlying data. If multithreaded access is anticipated, ensure the underlying data structure or its operations <span class="No-Break">are thread-safe.</span></li>
				<li><strong class="bold">Leverage STL algorithms</strong>: While <strong class="source-inline">std::mdspan</strong> doesn’t naturally fit all STL algorithms due to its multidimensional nature, you can still use many algorithms on a flattened view or individual slices of the data. Being familiar with STL algorithms can help you avoid reinventing <span class="No-Break">the wheel.</span></li>
			</ul>
		</div>
	

		<div id="_idContainer025" class="Content">
			<h1 id="_idParaDest-497" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor497"/>Part 3: Mastering STL Algorithms</h1>
		</div>
		<div id="_idContainer026">
			<p>In this Part, you will acquire a robust understanding of the algorithmic backbone of the C++ STL. We establish a foundation with fundamental algorithms, emphasizing sorting, searching, and element comparison, essential to efficient data manipulation. We then dive into the transformative power of STL through copying, moving, filling, and generating operations, revealing techniques for optimal data manipulation while underpinning the importance of modern idioms like <strong class="bold">Return Value </strong><span class="No-Break"><strong class="bold">Optimization (RVO)</strong></span><span class="No-Break">.</span></p>
			<p>Continuing, we explore numeric operations, from simple summations to complex inner products, and extend our focus to range-based operations, underscoring their significance in modern C++. The subsequent chapter transitions to the structured manipulation of data sets through partitioning, heap operations, and permutations, illustrating their pivotal roles in data organization <span class="No-Break">and analysis.</span></p>
			<p>Finally, we conclude by introducing the concept of ranges, an evolution in STL that brings a more expressive and efficient approach to algorithmic operations. We dissect the advantages and best practices of range-based algorithms for sorting and searching, advocating for their adoption in contemporary C++ development. Best practices are highlighted throughout, providing you with a clear pathway to writing clean, efficient, and maintainable code with <span class="No-Break">STL algorithms.</span></p>
			<p>This part has the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B21945_11.xhtml#_idTextAnchor498"><em class="italic">Chapter 11</em></a><em class="italic">: Fundamental Algorithms and Searching</em></li>
				<li><a href="B21945_12.xhtml#_idTextAnchor507"><em class="italic">Chapter 12</em></a><em class="italic">: Manipulation and Transformation</em></li>
				<li><a href="B21945_13.xhtml#_idTextAnchor530"><em class="italic">Chapter 13</em></a><em class="italic">: Numeric and Range-Based Operations</em></li>
				<li><a href="B21945_14.xhtml#_idTextAnchor542"><em class="italic">Chapter 14</em></a><em class="italic">: Permutations, Partitions, and Heaps</em></li>
				<li><a href="B21945_15.xhtml#_idTextAnchor563"><em class="italic">Chapter 15</em></a><em class="italic">: Modern STL with Ranges</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer027">
			</div>
		</div>
		<div>
			<div id="_idContainer028" class="Basic-Graphics-Frame">
			</div>
		</div>
	</body></html>