- en: Example - Building Monitoring and Control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The monitoring of conditions within a building, including the temperature,
    humidity, and CO[2] levels is becoming increasingly more common, with the goal
    being to adjust heating, cooling, and ventilation systems to keep the occupants
    of the building as comfortable as possible. In this chapter, such a system is
    explored and implemented. The following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating complex firmware for the ESP8266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating an MCU into an IP-based network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding CO[2] and I2C-based sensors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using GPIO and PWM to control relays and DC voltage-controlled fans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting networked nodes using a central controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plants, rooms, and beyond
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 5](886aecf2-8926-4aec-8045-a07ae2cdde84.xhtml), *Example - Soil
    Humidity Monitor with Wi-Fi*, we looked at developing firmware for the ESP8266
    MCU to complement a soil humidity sensor and pump, to ensure that a connected
    plant would be provided with sufficient water from the water tank.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we noted in that chapter, the firmware used is highly modular and has the
    highly flexible MQTT-based interface so that it can be used for a wide variety
    of modules. This chapter covers the system in which the firmware originated: **Building
    Management and Control** (**BMaC**), originally developed just to monitor rooms
    for their temperature, humidity, and CO² levels, but later expanded to keep tabs
    on coffee machines and meeting room occupancy, and ultimately to control the air-conditioning
    throughout the building.'
  prefs: []
  type: TYPE_NORMAL
- en: The BMaC project's current development status can be found at the author's GitHub
    account at [https://github.com/MayaPosch/BMaC](https://github.com/MayaPosch/BMaC).
    The version we are covering here is as it exists at this point, with us covering
    how this system came to be and what it looks like today, and why.
  prefs: []
  type: TYPE_NORMAL
- en: Developmental history
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The BMaC project started when sensors were to be added around an office building
    in order to measure temperature and other parameters, such as relative humidity.
    After deciding to use ESP8266 MCUs along with DHT22 temperature and humidity sensors,
    a simple prototype was put together, using a basic firmware written using the
    Sming framework.
  prefs: []
  type: TYPE_NORMAL
- en: It was found that DHT22 sensors were generally rather bulky and not very precise.
    The breakout boards used also had an improper resistor mounted on them, leading
    to the wrong temperature being reported. This sensor type also had the disadvantage
    of using its own one-wire protocol, instead of a standard interface method.
  prefs: []
  type: TYPE_NORMAL
- en: The DHT22 sensors got swapped out with BME280 MEMS sensors, which measure temperature,
    humidity, and also air pressure. A CO[2] sensor was added as well, in the form
    of the MH-Z19\. This required the firmware to support these additional sensors
    too. The sensor readings would be sent as MQTT messages, with a backend service
    subscribing to these topics, and writing them to a time series database (InfluxDB),
    for viewing and analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Decisions had to be made when the possibility of reading out the counters for
    products from the fully automatic Jura coffee machines was considered, and with
    it whether separate firmware would have to be developed.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of separate firmware, the decision was made to use the same firmware
    for all ESP8266 nodes. This meant that they needed to have the functionality to
    somehow enable individual features and to support specific sensors and other features.
    This led to the development of new firmware, which allowed remote commands, sent
    over MQTT, to toggle feature modules on or off, along with other management features.
  prefs: []
  type: TYPE_NORMAL
- en: Along with the new firmware, a **command and control** (**C&C**) server was
    added, used by the individual nodes to retrieve their configuration, along with
    an administration application to be used to add new nodes and add or edit the
    node configuration.
  prefs: []
  type: TYPE_NORMAL
- en: With this framework in place, it became possible to add new features quickly.
    These included the addition of motion sensors, for detecting the presence of people
    in a room, to ultimately the controlling of air-conditioning units, as the existing
    centralized control in the office building was found to be inadequate.
  prefs: []
  type: TYPE_NORMAL
- en: 'The system as a whole can be visualized like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d784b62d-39db-497b-91d4-8914218b0cde.png)'
  prefs: []
  type: TYPE_IMG
- en: In the upcoming sections, we will be taking a detailed look at each of these
    aspects.
  prefs: []
  type: TYPE_NORMAL
- en: Functional modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is a list of modules in this firmware:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Feature** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| THP | Temperature, Humidity, Pressure | Central class for THP sensors. Enables
    BME280 functionality by default. |'
  prefs: []
  type: TYPE_TB
- en: '| CO[2] | CO[2] value | Measures CO[2] <indexentry content="functional modules,
    Building Management and Control (BMaC):CO[2]">values using an MH-Z19 or compatible
    sensor. |'
  prefs: []
  type: TYPE_TB
- en: '| Jura | TopTronics EEPROM counters | Reads out the counters for various products
    from the EEPROM. |'
  prefs: []
  type: TYPE_TB
- en: '| JuraTerm | TopTronics remote control | Allows a remote service to send TopTronics
    (classic, v5-style) commands to a supported coffee machine. |'
  prefs: []
  type: TYPE_TB
- en: '| Motion | Motion detection | Uses an HC-SR501 PIR motion sensor or compatible
    to detect motion. |'
  prefs: []
  type: TYPE_TB
- en: '| PWM | PWM output | Sets a pulse-width modulation output on one or more pins.
    |'
  prefs: []
  type: TYPE_TB
- en: '| I/O | I/O expansion | Supports the MCP23008 eight-channel I/O expander module
    via I2C. |'
  prefs: []
  type: TYPE_TB
- en: '| Switch | Persistent switch | Controls a switch that uses a latching relay
    or equivalent for switching. |'
  prefs: []
  type: TYPE_TB
- en: '| Plant | Watering plants | Reads out an analog soil sensor to determine soil
    humidity, activating a pump when needed. |'
  prefs: []
  type: TYPE_TB
- en: Firmware source
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we look at the source code for the ESP8266 firmware as used
    with the BMaC system.
  prefs: []
  type: TYPE_NORMAL
- en: Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The core of the firmware we already looked at in [Chapter 5](886aecf2-8926-4aec-8045-a07ae2cdde84.xhtml), *Example - Soil
    Humidity Monitor with Wi-Fi*, including the entry point, the `OtaCore` class,
    and the `BaseModule` class, which provide all of the functionality needed to make
    individual modules initialize and to allow them to be enabled and disabled using
    the MQTT interface.
  prefs: []
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Of the firmware modules, we already looked at the plant module in [Chapter
    5](886aecf2-8926-4aec-8045-a07ae2cdde84.xhtml), *Example - Soil Humidity Monitor
    with Wi-Fi*. Here we will look at the remaining modules, starting with the THP
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This module has the provisions to act as a generic interface to a wide variety
    of temperature, humidity, and air-pressure sensors. As this was not a requirement
    at the time, it merely acted as a pass-through for the BME280 module. It registers
    itself with the base module when called and calls the respective functions on
    the BME280 module when its own are called.
  prefs: []
  type: TYPE_NORMAL
- en: To make it more versatile, the class would be extended to allow for commands
    to be received—possibly over MQTT as well on its own topic—which would then enable
    a specific sensor module, or even a collection of them, when using separate temperature
    and air pressure sensors, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of whether it is being used or not in this firmware, let's take a
    look at the DHT module so that we can compare it with the BME280 module later.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Of note is that while the class is static, any variables that would take up
    considerable memory—such as library class instances—are defined as pointers. This
    forms a compromise between having the module available for easy use and going
    for a more complicated, fully dynamic solution. As most MCUs tend to keep as much
    of the program code as possible in the ROM until it is used, this should keep
    both SRAM and ROM usage to a minimum.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: To initialize the module, we ensure that we can safely use the **general-purpose
    input/output** (**GPIO**) pins we intend to use, create a new instance of the
    sensor class from the library, and set it up before creating the 2-second timer
    that will perform the scheduled sensor read-out.
  prefs: []
  type: TYPE_NORMAL
- en: Since we create a new instance of the  sensor class upon initializing there
    should never be an existing instance of this class, but we check in case the init()
    function gets called again a second time for some reason. Calling the initialization
    function on the timer a second time could also be included in this block, but
    isn't strictly required as there is no harmful effect from initializing the timer
    again.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: To shut down the module, we stop the timer and release the GPIO pin we were
    using, before cleaning up all resources we used. As we have claimed the pin we're
    using previously when we initialized the module we should have no issues releasing
    it again, but we check to make sure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is an example of how one could later change the GPIO pin used by a module,
    here using the old text-based command format that early versions of the BMaC firmware
    used to use. We could also receive this information via an MQTT topic, or by actively
    querying the command and control server.
  prefs: []
  type: TYPE_NORMAL
- en: Note that to change the pin used by the sensor one would have to restart the
    sensor by deleting the class instance and creating a new instance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, for the `BME280` sensor module, its code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, it''s familiar-looking implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, this module was basically copied from the DHT one, and then modified
    to fit the BME280 sensor. The similarities between those two modules was one of
    the motivations behind developing the THP module, in order to exploit these similarities.
  prefs: []
  type: TYPE_NORMAL
- en: As with the DHT module, we can see that we rely on an external library to do
    the heavy lifting for us, with us merely having to call the functions on the library
    class to set up the sensor and get the data from it.
  prefs: []
  type: TYPE_NORMAL
- en: CO2 module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the CO[2] module, no attempt has been made yet to make it work with multiple
    types of CO[2] sensors. The first CO[2] sensor used was the MH-Z14, before it
    <indexentry content="modules, Building Management and Control (BMaC):CO[2] module">switched
    to the more compact MH-Z19 sensor. Both of these use the same protocol on their
    **universal asynchronous receiver/transmitter** (**UART**) interface, however.
  prefs: []
  type: TYPE_NORMAL
- en: On the ESP8266 there are two UARTs, though only one is complete, with a receive
    (RX) and send (TX) line. The second UART only has a TX line. This essentially
    limits this MCU to a single UART and thus single UART-based sensor.
  prefs: []
  type: TYPE_NORMAL
- en: These sensors also have a single-wire interface in addition to the UART-based
    interface, where the sensor outputs the current sensor reading using a specific
    encoding that has to be received and decoded using the specific distance between
    pulses on that signal wire. This is similar to the DHT-22's single-wire protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the UART is obviously significantly easier, and it''s what we ended up
    using with this module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see here the callback function that will be used with the UART when
    we receive data. We also have a few other variables whose meaning will <indexentry
    content="modules, Building Management and Control (BMaC):CO[2] module">become
    clear in a moment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the static initializations, we define the command that we will be sending
    to the CO[2] sensor, which will tell it to send us its currently measured value.
    We define a number of counters and the related timer instance, which we will be
    using to analyze the CO[2] levels we receive.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Starting this module triggers the registering of the pins, which we need for
    the UART, with the UART started at a baud rate of 9,600\. Our receive callback
    is also registered. The pin registration routine in the core class is meant for
    housekeeping and therefore cannot really fail. In case of an overlapping pin mapping
    with another module, we might want to release the first pin registration if the
    second registration fails.
  prefs: []
  type: TYPE_NORMAL
- en: The GPIO pins used by the serial interface are set in the same core class and
    would have to be modified there. The main reason behind this lack of configurability
    is that the GPIO pins on the ESP8266 are fairly limited in what features they
    support, which is why the hardware UART is basically always found on these two
    pins, leaving the other pins for other functionality.
  prefs: []
  type: TYPE_NORMAL
- en: The timer we start will read out the sensor every 30 seconds, keeping in mind
    that the first 3 minutes of sensor readings are useless as the sensor takes <indexentry
    content="modules, Building Management and Control (BMaC):CO[2] module">about that
    long to warm up.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Reading out the sensor is as easy as writing the series of bytes we defined
    during the static initialization phase to the sensor, and waiting for the sensor
    to respond by sending data back to us into our RX buffer, which will trigger our
    callback function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The configuration method was also left unimplemented here, but could be used
    to disable events (explained in the next part) and make various adjustments dynamically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the callback, we get the characters as they come in on the RX line. We wait
    until we have nine characters waiting for us in the RX buffer, which is the <indexentry
    content="modules, Building Management and Control (BMaC):CO[2] module">number
    of bytes we are expecting to receive from the CO[2] sensor. We could also validate
    the checksum for the received data, for which the MH-Z19 datasheet gives the following
    C code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This routine calculates the checksum for the received data as a single byte,
    which we can then compare with the value contained in the 9th byte of the received
    data to see whether the values match.
  prefs: []
  type: TYPE_NORMAL
- en: Returning to our own code, we process the bytes to calculate the **parts per
    million** (**PPM**) of the CO[2] molecules the sensor detected. This value is
    immediately published to its respective MQTT topic.
  prefs: []
  type: TYPE_NORMAL
- en: After this, we compare the new PPM value to see whether we have crossed any
    of the three preset trigger levels, the first one of which indicates a safe CO[2 ]level,
    the second an elevated CO[2 ]level, and the third a very high CO[2] level that
    requires attention. When we exceed or return to a lower trigger level, an event
    is published for this on the MQTT topic.
  prefs: []
  type: TYPE_NORMAL
- en: Jura
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is another module which uses the UART. It was used with a number of Jura
    coffee machines, which used the common TopTronics electronics used by other coffee
    machine manufacturers as well. To enable reading out these coffee machines, an
    ESP8266 module was integrated into a small, plastic enclosure which just had a
    serial connector on one side. This connected with a standard nine-pin serial cable
    to the so-called service port on the back of the machine.
  prefs: []
  type: TYPE_NORMAL
- en: The serial port on the machine provided 5V when it was powered on, which thus
    also turned on the ESP8266 node when the coffee machine was on. The plastic enclosure
    could then be hidden away behind the machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'The module for this feature looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The only really noticeable thing about this class declaration is the method
    name involving a coffee maker. We''ll see in a second what it does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As is common, the coffee machine''s UART runs at 9,600 baud. We set the serial
    callback method, and start a timer for reading out the EEPROM''s product counters.
    Since we are talking about a coffee machine, reading out the counters more than
    once a minute is somewhat silly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To read out the EEPROM''s counters, we need to send the command for this to
    the machine''s UART. This command will tell it to send us the contents of the
    first row in the EEPROM. Unfortunately, the machine''s protocol doesn''t use plain
    text, but requires a bit of special encoding, which we do in the next method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes in a string, appending the required EOL characters and encoding
    each byte into four bytes, putting the data bits into each new byte''s second
    and fifth bit, the rest of the bits all being a 1\. These four bytes are then
    sent to the machine''s UART with a small delay between each write to ensure correct
    reception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the serial receive callback, we decode each byte we receive using the same
    process we used to encode the data we sent to the machine, buffering the decoded
    bytes until we detect the end of the response (linefeed, LF) character. We then
    read out the 16-bit counters, which we then publish on the MQTT topic for them.
  prefs: []
  type: TYPE_NORMAL
- en: JuraTerm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The JuraTerm module is similar to the Jura one, but it accepts remote commands,
    encodes them in the same way as the Jura module, and returns the decoded response.
    In the project it used to be the Jura class until it got superseded by the new
    Jura class and this one was delegated to just a terminal class. In a future revision
    this module's functionality will therefore be merged into the main Jura class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: When we start this module, we register an MQTT topic to receive commands. This
    allows us to receive the coffee machine commands. We basically act as a straight
    pass-through for these commands, except for this one particular command. This
    command that we filter out would erase the machine's EEPROM, which is something
    which we are unlikely to want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, we use the same method to encode the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Instead of interpreting the data in any way, we merely return the response on
    its respective MQTT topic.
  prefs: []
  type: TYPE_NORMAL
- en: Motion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The motion module is intended to work with **passive infrared** (**PIR**) sensors.
    These have onboard logic that determine when a trigger point has been reached,
    at which point they change an interrupt pin into a high signal. We can use this
    to determine whether a person is in a room, or is walking through a hallway.
  prefs: []
  type: TYPE_NORMAL
- en: 'Its code looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Of note here is that we explicitly move the interrupt handler method into the
    MCU's SRAM with the IRAM_ATTR keyword, to prevent any delay when the interrupt
    gets called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Its implementation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: A PIR sensor requires warm-up time to stabilize its readings. We give it a minute
    using the warm-up timer. We also set the mode for the GPIO pin we're using.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'After the sensor has finished warming up, we stop its timer and attach the
    interrupt to handle any signals from the sensor. We''ll check up on the shared
    variable with the interrupt routine, to see whether the value has changed, publishing
    the current value every 5 seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'When checking the current sensor value, we make it a point to ignore the first
    time that the sensor reports `LOW`. This in order to ensure that we ignore moments
    when people do not move a lot in the room. The resulting value is then published
    on the MQTT topic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The interrupt handler merely updates the local Boolean value. Because of the
    relatively long transition times for most processing circuits for PIR sensor there
    is quite a bit of time (seconds) before the sensor will detect motion again, creating
    dead zones. Here we keep track of the last registered value.
  prefs: []
  type: TYPE_NORMAL
- en: PWM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The reason why the PWM module was developed was to have a way to generate an
    analog output voltage using an external RC filter circuit. This was in order to
    control the fan of the ceiling-mounted air-conditioning units, whose fan controller
    accepts a voltage of between 0 and 10 volts.
  prefs: []
  type: TYPE_NORMAL
- en: 'An interesting feature of this module is that it has its own binary protocol
    to allow for remote control, which is how the air-conditioning service can directly
    control the fan speeds via the ceiling-mounted nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We define the commands that will be available with the PWM module here as an
    enumeration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: When we start this module, we register the MQTT topic on which the module will
    be able to receive commands. When shutting down, we deregister this topic again.
    We use the `HardwarePWM` class from Sming to enable PWM on individual pins.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of the module is simply the command processor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The protocol implemented by the preceding method is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Command** | **Meaning** | **Payload** | **Return value** |'
  prefs: []
  type: TYPE_TB
- en: '| 0x01 | Start the module | uint8 (number of pins)uint8* (one byte per pin
    number) | 0x00/0x01 |'
  prefs: []
  type: TYPE_TB
- en: '| 0x02 | Stop the module | - | 0x00/0x01 |'
  prefs: []
  type: TYPE_TB
- en: '| 0x04 | Set the PWM duty level | uint8 (pin number)uint8 (duty cycle, 0 -
    100) | 0x00/0x01 |'
  prefs: []
  type: TYPE_TB
- en: '| 0x08 | Get the PWM duty level | uint8 (pin number). | uint8 (duty level)
    |'
  prefs: []
  type: TYPE_TB
- en: '| 0x10 | Returns the active pins | - | uint8* (one pin number per byte) |'
  prefs: []
  type: TYPE_TB
- en: For each command, we parse the string of bytes we receive, checking the number
    of bytes to see whether we get the expected number, and then interpreting them
    as commands and their payload. We either return a 0 (failure) or a 1 (success),
    or a payload with the desired information.
  prefs: []
  type: TYPE_NORMAL
- en: One obvious addition that could be made here would be to add some kind of checksum
    to the received command, along with sanity checks on the received data. While
    code like this will work great in a secure environment with encrypted MQTT links
    and a reliable network connection, other environments may be less forgiving, with
    corrupted data and false data being injected.
  prefs: []
  type: TYPE_NORMAL
- en: I/O
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes all we need is just a lot of GPIO pins that connect to things like
    relays, so that we can turn heating valves on or off. This was the reason behind
    this module. The nodes that were being installed on the ceiling had not just an
    I2C bus being used for the environmental sensors, but also the UART for CO[2]
    measurements and four pins for PWM output.
  prefs: []
  type: TYPE_NORMAL
- en: As more GPIO was needed to turn the relays that controlled the valves on the
    water lines to the air-conditioning units on or off, a dedicated GPIO expander
    chip was added to the I2C bus to provide eight more GPIO pins.
  prefs: []
  type: TYPE_NORMAL
- en: 'This module allows for an external service like the air-conditioning service
    to directly set these new GPIO pins as high or low:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This class wraps the MCP23008 I/O expander device, keeping a local copy of
    its direction, pull-up, and GPIO state registers for easy updating and control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We keep a local copy of three registers on the I2C GPIO expander device—the
    I/O direction (`iodir`), pull-up register (`gppu`), and the pin I/O level (`gpio`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We again define a number of commands in the form of an enumeration, along with
    one for the pin direction of the GPIO expander:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Initializing and starting the module is similar to the PWM module, with us registering
    an MQTT topic to receive commands on. The difference here is that since we are
    using an I2C device, we have to make sure that the I2C functionality has been
    started already.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we address the command-processing method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Its protocol looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Command** | **Meaning** | **Payload** | **Return value** |'
  prefs: []
  type: TYPE_TB
- en: '| 0x01 | Start the module | uint8 I2C address offset (0-7, optional) | 0x010x00/0x01
    |'
  prefs: []
  type: TYPE_TB
- en: '| 0x02 | Stop the module | - | 0x020x00/0x01 |'
  prefs: []
  type: TYPE_TB
- en: '| 0x04 | Returns I/O mode, pull-up, and level state | - | 0x040x00/0x01 (result)uint8
    (iodir register)uint8 (gppu register)uint8 (gpio register) |'
  prefs: []
  type: TYPE_TB
- en: '| 0x08 | Set a pin to a specific mode (In/Out) | uint8 (pin number, 0 - 7)uint8
    (0: output, 1: input) | 0x080x00/0x01 |'
  prefs: []
  type: TYPE_TB
- en: '| 0x10 | Set a pin''s pull-up resistor (Low/High) | uint8 (pin number, 0 -
    7)uint8 (pin pull-up state, 0/1) | 0x100x00/0x01 |'
  prefs: []
  type: TYPE_TB
- en: '| 0x20 | Set a pin to either Low or High | uint8 (pin number, 0-7)uint8 (pin
    state, 0/1) | 0x20 0x00/0x01 |'
  prefs: []
  type: TYPE_TB
- en: '| 0x40 | Read the current pin value (Low, High) | uint8 (pin number) | 0x40
    0x00/0x01 uint8 (pin number) uint8 (pin value) |'
  prefs: []
  type: TYPE_TB
- en: '| 0x80 | Return whether this module has been initialized | - | 0x80 0x00/0x01
    uint8 (module state, 0/1). |'
  prefs: []
  type: TYPE_TB
- en: Similar to the protocol for the PWM module, either a Boolean value is returned
    to indicate success, or the requested payload is returned. We also return the
    command that was called in the response.
  prefs: []
  type: TYPE_NORMAL
- en: The command is a single byte, allowing for a maximum of eight commands since
    we are using bit flags. This could be extended to 256 commands if we wanted to.
  prefs: []
  type: TYPE_NORMAL
- en: Possible improvements to this module's code include consolidating duplicated
    code into (inline) function calls and conceivably the use of a sub-class that
    would manage the setting and toggling of individual bits with a more higher-level
    API.
  prefs: []
  type: TYPE_NORMAL
- en: Switch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since each section of the office had its own central switch that would switch
    the water in the pipes that flowed to the FCUs, this had to be controllable from
    the backend server as well. Using a latching relay configuration, it was possible
    to both switch between heating and cooling configurations, as well as have a memory
    element that could be read out by the node:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This system was assembled on a single board that was used to replace the original
    manual switch, using the following module to control it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Its implementation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This module is very similar to the PWM and I/O modules, with the registering
    of an MQTT topic to allow communication using its own binary protocol. Here, the
    device that is being controlled is fairly simple. It is a latching relay with
    two sides, one of which is connected to the connections that are being switched
    between, while the other side is used as a one-bit memory cell.
  prefs: []
  type: TYPE_NORMAL
- en: As both sides of this type of relay will switch simultaneously, we can count
    on the side connected to the MCU to match the position of that on the side connected
    to the rest of the system. Even after a power failure or reset of the MCU, we
    can simply read out the values of the pins connected to the relay to find out
    the state of the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting protocol looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Command** | **Meaning** | **Payload** | **Return value** |'
  prefs: []
  type: TYPE_TB
- en: '| 0x01 | Switch to Position 1 | - | 0x010x00/0x01 |'
  prefs: []
  type: TYPE_TB
- en: '| 0x02 | Switch to Position 2 | - | 0x020x00/0x01 |'
  prefs: []
  type: TYPE_TB
- en: '| 0x04 | Return the current state | - | 0x040x00/0x01 (result)uint8 (active
    pin 0x00, 0x01) |'
  prefs: []
  type: TYPE_TB
- en: Command and control server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As alluded to earlier in this chapter, a so-called **command and control** (**C&C**)
    server is essentially a database containing information on individual nodes and
    their configuration, for use by the nodes themselves and administration tools
    like the one in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'It also includes an HTTP server, for use with HTTP-based **over-the-air** (**OTA**)
    updates. Since the BMaC system is MQTT-based, this server is also written as an
    MQTT client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We're using the Mosquitto C++ MQTT client along with the POCO framework to provide
    us with the required functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Listener` class is next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We include the headers from POCO for the SQLite database functionality, which
    forms the database backend for this application. The class itself derives from
    the Mosquitto C++ class, providing us with all the basic MQTT functionalities
    along with a few function stubs, which we still have to implement in a moment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We define a structure for a single node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In the constructor, we attempt to connect to the MQTT broker, using the provided
    host and port. We also set up a connection with the SQLite database, and ensure
    that it has valid nodes and a firmware table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We reimplement the callback for when a connection has been established with
    the MQTT broker. In this method, we subscribe to all the MQTT topics in which
    we are interested.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next method is called whenever we receive an MQTT message on one of the
    topics which we subscribed to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We validate the payload we receive for each topic. For this first topic, we
    expect its payload to contain the MAC address of the node which wants to receive
    its configuration. We make sure that this seems to be the case, then continue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We attempt to find the MAC address in the database, reading out the node's configuration
    if found and making it the payload for the return message.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next topics are used with the administration tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In the case of this payload string, we return the binary data for a map image
    that should exist in the local folder. This map contains the layout of the building
    we are administrating, for displaying in the tool.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The preceding section reads out every single node in the database and returns
    it in a binary, serialized format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create a new node and add it to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Updating a node''s configuration is also possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we look at the topic handler for deleting a node''s configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'When we looked at the CO[2] module of the firmware earlier, we saw that it
    generated CO[2] events. These also end up here in this example, in order to generate
    events in JSON format, which we send to some HTTP-based API. We then use the HTTPS
    client in POCO to send this JSON to the remote server (here set to localhost):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Finally, for managing the stored firmware images, we can use the following topic.
    Which node uses which firmware version can be set in each node's configuration,
    though as we saw earlier, the default is to use the latest firmware.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this topic, we can list the available firmware images or upload a new
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: On each successful MQTT topic subscription, this method is called, allowing
    us to do something else if needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we look at the HTTP server component, starting with the HTTP request
    handler factory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This handler will always return an instance of the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This class looks fairly impressive, yet mostly does just an SQLite database
    lookup for the node ID (MAC address) and returns the appropriate firmware image
    if found.
  prefs: []
  type: TYPE_NORMAL
- en: Administration tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the APIs implemented by the C&C server, a GUI-based administration tool
    was created using the Qt5 framework and the Mosquitto MQTT client library was
    developed, allowing for the basic management of nodes. They were overlaid on top
    of a layout graphic of buildings.
  prefs: []
  type: TYPE_NORMAL
- en: While basically usable, it was found that a graphical tool was fairly complicated
    to develop. It was also limited to a single floor of a building, unless one were
    to have a really large map containing all of the floors with the nodes mapped
    onto this. This would have been quite clumsy, obviously.
  prefs: []
  type: TYPE_NORMAL
- en: In the source code provided with this chapter, the administration tool can be
    found as well, to serve as an example of how one could implement it. For the sake
    of brevity, the code for it has been omitted here.
  prefs: []
  type: TYPE_NORMAL
- en: Air-conditioning service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To control air-conditioning units, a service much like the C&C one was developed,
    using the same basic template. The interesting parts of its source are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The definition for this class in the AC service gives a good overview of the
    functionality of this class. It's essentially a wrapper around an SQLite database,
    containing information on nodes, valves, and cooling/heating switches. It also
    contains the timers that will keep triggering the application to check the status
    of the system, to compare it to the target state, and to make adjustments if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'This class is used extensively by the `Listener` class of this application
    for keeping track of the status of nodes and the connected AC units, along with
    those switches and valves controlling the water flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The way that this application works is that the `Nodes` class timers will cause
    the `Listener` class to publish on the topics for the PWM, IO, and Switch modules,
    inquiring about the state of the devices that are supposed to be active.
  prefs: []
  type: TYPE_NORMAL
- en: This kind of active loop system is common in industrial applications, as it
    provides constant validation of the system to detect quickly if something isn't
    working as intended.
  prefs: []
  type: TYPE_NORMAL
- en: InfluxDB for recording sensor readings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recording the sensor readings and later the statistics read from the coffee
    machines was a priority from the beginning. The ideal database for this kind of
    data is a time series database, of which Influx is a common one. The biggest problem
    with this database is that it does not support MQTT, only offering its HTTP and
    native interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this, a simple MQTT-to-Influx HTTP line protocol bridge was written,
    again using the Mosquitto client library as well as the POCO framework''s HTTP
    functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'In the constructor, we connect to the MQTT broker, and create either an HTTP
    or HTTPS client, depending on which protocol has been set in the configuration
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Instead of fixed MQTT topics to subscribe to, we use the topics that are defined
    in the configuration file, here provided to us as a single string with each topic
    separated by a comma.
  prefs: []
  type: TYPE_NORMAL
- en: We also create an STL map containing the name of the time series to record for
    the topic, taking the final part of the MQTT topic after the last slash. One could
    make this further configurable, but for the topics used in the BMaC system this
    limitation was no consideration as it not necessary to have more complex topics.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: When we get a new MQTT message in, we find the name of the Influx time series
    for it, then create a string to send to the InfluxDB server. The assumption here
    is that the payload consists of the MAC address of the node which sent the message
    followed by a semi-colon.
  prefs: []
  type: TYPE_NORMAL
- en: We simply get the part after the semi-colon to set it as the value, and use
    the MAC as the location. This we then send to the database server.
  prefs: []
  type: TYPE_NORMAL
- en: Security aspects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During the development of this system it became soon obvious that security would
    be a paramount aspect of the system. For that reason we looked at adding transport
    layer security (TLS) encryption. This would use the integrated axTLS encryption
    library in the Sming framework together with AES certificates (host and client)
    to provide both verification that the host (servers) and clients (nodes) are who
    they say they are, but also provide a secure encrypted link.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](886aecf2-8926-4aec-8045-a07ae2cdde84.xhtml), *Example - Soil
    Humidity Monitor with Wi-Fi*, we already looked at the handling of these client
    certificates and setting up of an encrypted MQTT connection. One detail which
    is not obvious from that were the troubles which we encountered while setting
    up this certificate system. As mentioned in [Chapter 5](886aecf2-8926-4aec-8045-a07ae2cdde84.xhtml), *Example - Soil
    Humidity Monitor with Wi-Fi*, the ESP8266 does not have enough memory to allocate
    the default TLS handshake buffers and requires the use of the SSL fragment size
    extension on the side of the server (host).
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately we found that the commonly used MQTT broker we were using (Mosquitto)
    did not support this SSL extension and would therefore require that clients used
    the default double 16 kB buffer. The first solution to this would be to recompile
    the Mosquitto broker after making a few changes to its source code to change this
    setting.
  prefs: []
  type: TYPE_NORMAL
- en: The better solution and the one which we ultimately implemented was to install
    a proxy software (HAProxy) which functioned as the TLS endpoint, handling the
    certificates and redirecting the decrypted traffic to the MQTT broker via the
    local loopback (localhost) interface.
  prefs: []
  type: TYPE_NORMAL
- en: With the SSL fragment size option set to 1-2 kB everything worked as intended
    and we had a building-wide, wireless monitoring and control system that allowed
    for secure communications of sensitive information and delicate control commands.
  prefs: []
  type: TYPE_NORMAL
- en: Future developments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are still many additions that can be made to this system. From the number
    of sensors that could be supported, further GPIO expander chips, air-conditioning
    system configurations, room occupancy detection linked into a calendar backend,
    to clearing out scheduled meetings at an office where nobody showed up, and so
    on.
  prefs: []
  type: TYPE_NORMAL
- en: There is also the option of switching from ESP8266 as the MCU to a different
    one, such as ARM-based MCUs, to get wired Ethernet options, along with better
    debug and development tools. As convenient as it is to have an MCU with Wi-Fi,
    which one can just stick anywhere and theoretically have it work, the development
    tools for the ESP8266 aren't that great, and the lack of wired communication options
    (without using external chips) means that everything either works or doesn't depending
    on the quality of the Wi-Fi network.
  prefs: []
  type: TYPE_NORMAL
- en: As BMaC involves the automation of a building, it is desirable to have a certain
    level of reliability, which is hard to guarantee with a Wi-Fi network, though
    for less crucial components (coffee machine statistics, sensor readings, and so
    on) this is unlikely to be an issue. Conceivably a hybrid network with both wired
    and wireless options could be the future.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at how a building-wide monitoring and management
    system was developed, what its components looked like, and what lessons were learned
    during its development.
  prefs: []
  type: TYPE_NORMAL
- en: The reader is expected to understand now how such a large-scale embedded system
    is constructed and functions, and should be able either to use the BMaC system
    themselves or implement a similar system.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we will look at developing embedded projects using the Qt
    framework.
  prefs: []
  type: TYPE_NORMAL
