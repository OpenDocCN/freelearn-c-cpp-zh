- en: Example - Building Monitoring and Control
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 - 建筑监控与控制
- en: 'The monitoring of conditions within a building, including the temperature,
    humidity, and CO[2] levels is becoming increasingly more common, with the goal
    being to adjust heating, cooling, and ventilation systems to keep the occupants
    of the building as comfortable as possible. In this chapter, such a system is
    explored and implemented. The following topics will be covered:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 建筑内部条件的监控，包括温度、湿度和CO[2]水平，正变得越来越普遍，目标是调整供暖、冷却和通风系统，以使建筑内的居住者尽可能舒适。在本章中，将探讨并实现这样一个系统。以下将涵盖以下主题：
- en: Creating complex firmware for the ESP8266
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为ESP8266创建复杂的固件
- en: Integrating an MCU into an IP-based network
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将MCU集成到基于IP的网络中
- en: Adding CO[2] and I2C-based sensors
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加CO[2]和基于I2C的传感器
- en: Using GPIO and PWM to control relays and DC voltage-controlled fans
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GPIO和PWM控制继电器和直流电压控制的风扇
- en: Connecting networked nodes using a central controller
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用中央控制器连接网络节点
- en: Plants, rooms, and beyond
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 植物、房间以及其他
- en: In [Chapter 5](886aecf2-8926-4aec-8045-a07ae2cdde84.xhtml), *Example - Soil
    Humidity Monitor with Wi-Fi*, we looked at developing firmware for the ESP8266
    MCU to complement a soil humidity sensor and pump, to ensure that a connected
    plant would be provided with sufficient water from the water tank.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](886aecf2-8926-4aec-8045-a07ae2cdde84.xhtml)“示例 - 基于Wi-Fi的土壤湿度监测器”中，我们探讨了为ESP8266微控制器开发固件，以补充土壤湿度传感器和泵，确保连接的植物能够从水箱中获得足够的水。
- en: 'As we noted in that chapter, the firmware used is highly modular and has the
    highly flexible MQTT-based interface so that it can be used for a wide variety
    of modules. This chapter covers the system in which the firmware originated: **Building
    Management and Control** (**BMaC**), originally developed just to monitor rooms
    for their temperature, humidity, and CO² levels, but later expanded to keep tabs
    on coffee machines and meeting room occupancy, and ultimately to control the air-conditioning
    throughout the building.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在那一章中提到的，所使用的固件高度模块化，具有高度灵活的基于MQTT的接口，因此可以用于广泛的模块。本章涵盖了固件起源的系统：**建筑管理与控制**（**BMaC**），最初仅用于监控房间的温度、湿度和CO²水平，但后来扩展到监控咖啡机和会议室的占用情况，最终控制整个建筑物的空调系统。
- en: The BMaC project's current development status can be found at the author's GitHub
    account at [https://github.com/MayaPosch/BMaC](https://github.com/MayaPosch/BMaC).
    The version we are covering here is as it exists at this point, with us covering
    how this system came to be and what it looks like today, and why.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: BMaC项目的当前开发状态可以在作者的GitHub账户[https://github.com/MayaPosch/BMaC](https://github.com/MayaPosch/BMaC)中找到。我们在这里介绍的是当前版本，我们将介绍这个系统是如何形成的，以及它现在的样子，以及原因。
- en: Developmental history
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发展历史
- en: The BMaC project started when sensors were to be added around an office building
    in order to measure temperature and other parameters, such as relative humidity.
    After deciding to use ESP8266 MCUs along with DHT22 temperature and humidity sensors,
    a simple prototype was put together, using a basic firmware written using the
    Sming framework.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: BMaC项目始于需要在办公大楼周围添加传感器以测量温度和其他参数，如相对湿度。在决定使用ESP8266微控制器以及DHT22温度和湿度传感器后，使用Sming框架编写的简单固件构建了一个原型。
- en: It was found that DHT22 sensors were generally rather bulky and not very precise.
    The breakout boards used also had an improper resistor mounted on them, leading
    to the wrong temperature being reported. This sensor type also had the disadvantage
    of using its own one-wire protocol, instead of a standard interface method.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 发现DHT22传感器通常相当庞大且不太精确。使用的扩展板上也安装了不适当的电阻，导致报告了错误的温度。这种传感器类型还有使用自己的单线协议而不是标准接口方法的缺点。
- en: The DHT22 sensors got swapped out with BME280 MEMS sensors, which measure temperature,
    humidity, and also air pressure. A CO[2] sensor was added as well, in the form
    of the MH-Z19\. This required the firmware to support these additional sensors
    too. The sensor readings would be sent as MQTT messages, with a backend service
    subscribing to these topics, and writing them to a time series database (InfluxDB),
    for viewing and analysis.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: DHT22传感器被替换成了BME280 MEMS传感器，这些传感器可以测量温度、湿度和空气压力。还增加了一个CO[2]传感器，形式为MH-Z19。这要求固件也支持这些额外的传感器。传感器读数将以MQTT消息的形式发送，后端服务订阅这些主题，并将它们写入时间序列数据库（InfluxDB），以便查看和分析。
- en: Decisions had to be made when the possibility of reading out the counters for
    products from the fully automatic Jura coffee machines was considered, and with
    it whether separate firmware would have to be developed.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当考虑从全自动Jura咖啡机读取产品计数器的可能性时，必须做出决定，以及是否需要开发单独的固件。
- en: Instead of separate firmware, the decision was made to use the same firmware
    for all ESP8266 nodes. This meant that they needed to have the functionality to
    somehow enable individual features and to support specific sensors and other features.
    This led to the development of new firmware, which allowed remote commands, sent
    over MQTT, to toggle feature modules on or off, along with other management features.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用单独的固件，决定使用相同的固件为所有ESP8266节点。这意味着它们需要具备某种方式启用单个功能和支持特定传感器以及其他功能。这导致了新固件的开发，该固件允许通过MQTT发送远程命令，来切换功能模块的开启或关闭，以及其他管理功能。
- en: Along with the new firmware, a **command and control** (**C&C**) server was
    added, used by the individual nodes to retrieve their configuration, along with
    an administration application to be used to add new nodes and add or edit the
    node configuration.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 除了新的固件，还增加了一个**命令和控制**（**C&C**）服务器，由各个节点使用以检索它们的配置，以及一个用于添加新节点和添加或编辑节点配置的管理应用程序。
- en: With this framework in place, it became possible to add new features quickly.
    These included the addition of motion sensors, for detecting the presence of people
    in a room, to ultimately the controlling of air-conditioning units, as the existing
    centralized control in the office building was found to be inadequate.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个框架下，快速添加新功能成为可能。这包括添加运动传感器，用于检测房间内的人，最终到控制空调单元，因为发现办公楼现有的集中式控制不足。
- en: 'The system as a whole can be visualized like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 整个系统可以像这样可视化：
- en: '![](img/d784b62d-39db-497b-91d4-8914218b0cde.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d784b62d-39db-497b-91d4-8914218b0cde.png)'
- en: In the upcoming sections, we will be taking a detailed look at each of these
    aspects.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将详细探讨这些方面的每一个。
- en: Functional modules
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能模块
- en: 'Here is a list of modules in this firmware:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是这个固件中模块的列表：
- en: '| **Name** | **Feature** | **Description** |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **功能** | **描述** |'
- en: '| THP | Temperature, Humidity, Pressure | Central class for THP sensors. Enables
    BME280 functionality by default. |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| THP | 温度、湿度、压力 | THP传感器的核心类。默认启用BME280功能。|'
- en: '| CO[2] | CO[2] value | Measures CO[2] <indexentry content="functional modules,
    Building Management and Control (BMaC):CO[2]">values using an MH-Z19 or compatible
    sensor. |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| CO[2] | CO[2]值 | 使用MH-Z19或兼容传感器测量CO[2]值。|'
- en: '| Jura | TopTronics EEPROM counters | Reads out the counters for various products
    from the EEPROM. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| Jura | TopTronics EEPROM计数器 | 从EEPROM读取各种产品的计数器。|'
- en: '| JuraTerm | TopTronics remote control | Allows a remote service to send TopTronics
    (classic, v5-style) commands to a supported coffee machine. |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| JuraTerm | TopTronics远程控制 | 允许远程服务向支持的咖啡机发送TopTronics（经典，v5风格）命令。|'
- en: '| Motion | Motion detection | Uses an HC-SR501 PIR motion sensor or compatible
    to detect motion. |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 运动 | 运动检测 | 使用HC-SR501 PIR运动传感器或兼容传感器来检测运动。|'
- en: '| PWM | PWM output | Sets a pulse-width modulation output on one or more pins.
    |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| PWM | PWM输出 | 在一个或多个引脚上设置脉冲宽度调制输出。|'
- en: '| I/O | I/O expansion | Supports the MCP23008 eight-channel I/O expander module
    via I2C. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| I/O | I/O扩展 | 通过I2C支持MCP23008八通道I/O扩展模块。|'
- en: '| Switch | Persistent switch | Controls a switch that uses a latching relay
    or equivalent for switching. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 开关 | 持久开关 | 控制使用继电器或等效器件进行切换的开关。|'
- en: '| Plant | Watering plants | Reads out an analog soil sensor to determine soil
    humidity, activating a pump when needed. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| Plant | 浇水植物 | 读取模拟土壤传感器以确定土壤湿度，在需要时激活水泵。|'
- en: Firmware source
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 固件源代码
- en: In this section, we look at the source code for the ESP8266 firmware as used
    with the BMaC system.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看与BMaC系统一起使用的ESP8266固件的源代码。
- en: Core
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 核心模块
- en: The core of the firmware we already looked at in [Chapter 5](886aecf2-8926-4aec-8045-a07ae2cdde84.xhtml), *Example - Soil
    Humidity Monitor with Wi-Fi*, including the entry point, the `OtaCore` class,
    and the `BaseModule` class, which provide all of the functionality needed to make
    individual modules initialize and to allow them to be enabled and disabled using
    the MQTT interface.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第5章](886aecf2-8926-4aec-8045-a07ae2cdde84.xhtml)中查看过的固件的核心，*示例 - 带Wi-Fi的土壤湿度监测器*，包括入口点、`OtaCore`类和`BaseModule`类，它们提供了使各个模块初始化以及通过MQTT接口启用和禁用模块所需的所有功能。
- en: Modules
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块
- en: 'Of the firmware modules, we already looked at the plant module in [Chapter
    5](886aecf2-8926-4aec-8045-a07ae2cdde84.xhtml), *Example - Soil Humidity Monitor
    with Wi-Fi*. Here we will look at the remaining modules, starting with the THP
    module:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在固件模块中，我们已经在[第5章](886aecf2-8926-4aec-8045-a07ae2cdde84.xhtml)中查看过了植物模块，*示例 -
    带Wi-Fi的土壤湿度监测器*。在这里，我们将查看剩余的模块，从THP模块开始：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This module has the provisions to act as a generic interface to a wide variety
    of temperature, humidity, and air-pressure sensors. As this was not a requirement
    at the time, it merely acted as a pass-through for the BME280 module. It registers
    itself with the base module when called and calls the respective functions on
    the BME280 module when its own are called.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块具备充当各种温度、湿度和气压传感器通用接口的条款。由于当时这不是一个要求，它仅仅作为BME280模块的透传。当被调用时，它会向基础模块注册自己，并在调用自己的函数时在BME280模块上调用相应的函数。
- en: To make it more versatile, the class would be extended to allow for commands
    to be received—possibly over MQTT as well on its own topic—which would then enable
    a specific sensor module, or even a collection of them, when using separate temperature
    and air pressure sensors, for example.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其更加通用，我们将扩展该类以允许接收命令——可能通过MQTT以及它自己的主题接收——这样就可以在单独的温度和气压传感器使用时启用特定的传感器模块，甚至是一组模块。
- en: Regardless of whether it is being used or not in this firmware, let's take a
    look at the DHT module so that we can compare it with the BME280 module later.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 无论在这个固件中是否使用，让我们看一下DHT模块，以便我们可以在稍后与BME280模块进行比较。
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Of note is that while the class is static, any variables that would take up
    considerable memory—such as library class instances—are defined as pointers. This
    forms a compromise between having the module available for easy use and going
    for a more complicated, fully dynamic solution. As most MCUs tend to keep as much
    of the program code as possible in the ROM until it is used, this should keep
    both SRAM and ROM usage to a minimum.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，尽管类是静态的，但任何可能占用大量内存的变量——例如库类实例——都被定义为指针。这在我们希望模块易于使用和追求更复杂、完全动态的解决方案之间形成了一种折衷。由于大多数MCU倾向于尽可能将程序代码保持在ROM中直到使用，这应该将SRAM和ROM的使用量保持在最低。
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To initialize the module, we ensure that we can safely use the **general-purpose
    input/output** (**GPIO**) pins we intend to use, create a new instance of the
    sensor class from the library, and set it up before creating the 2-second timer
    that will perform the scheduled sensor read-out.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要初始化模块，我们确保我们可以安全地使用我们打算使用的**通用输入/输出**（**GPIO**）引脚，从库中创建一个新的传感器类实例，并在创建执行计划中的传感器读出的2秒定时器之前设置它。
- en: Since we create a new instance of the  sensor class upon initializing there
    should never be an existing instance of this class, but we check in case the init()
    function gets called again a second time for some reason. Calling the initialization
    function on the timer a second time could also be included in this block, but
    isn't strictly required as there is no harmful effect from initializing the timer
    again.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在初始化时创建了一个新的传感器类实例，因此不应该存在该类的现有实例，但我们仍然会进行检查，以防init()函数由于某种原因被再次调用。在定时器上再次调用初始化函数也可以包含在这个块中，但这不是严格必要的，因为再次初始化定时器没有有害的影响。
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To shut down the module, we stop the timer and release the GPIO pin we were
    using, before cleaning up all resources we used. As we have claimed the pin we're
    using previously when we initialized the module we should have no issues releasing
    it again, but we check to make sure.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要关闭模块，我们首先停止定时器并释放我们之前使用的GPIO引脚，然后清理我们使用的所有资源。因为我们初始化模块时已经声明了我们要使用的引脚，所以我们再次释放它应该没有问题，但我们仍然会进行检查。
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is an example of how one could later change the GPIO pin used by a module,
    here using the old text-based command format that early versions of the BMaC firmware
    used to use. We could also receive this information via an MQTT topic, or by actively
    querying the command and control server.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例，说明如何稍后更改模块使用的GPIO引脚，这里使用的是早期版本BMaC固件曾经使用的旧文本命令格式。我们也可以通过MQTT主题或通过主动查询命令和控制服务器来接收此信息。
- en: Note that to change the pin used by the sensor one would have to restart the
    sensor by deleting the class instance and creating a new instance.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，要更改传感器使用的引脚，必须通过删除类实例并创建一个新的实例来重新启动传感器。
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, for the `BME280` sensor module, its code looks like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，对于`BME280`传感器模块，其代码如下：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, it''s familiar-looking implementation:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它的实现看起来很熟悉：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As we can see, this module was basically copied from the DHT one, and then modified
    to fit the BME280 sensor. The similarities between those two modules was one of
    the motivations behind developing the THP module, in order to exploit these similarities.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这个模块基本上是从DHT模块复制过来的，然后修改以适应BME280传感器。这两个模块之间的相似性是开发THP模块的动机之一，以便利用这些相似性。
- en: As with the DHT module, we can see that we rely on an external library to do
    the heavy lifting for us, with us merely having to call the functions on the library
    class to set up the sensor and get the data from it.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 就像DHT模块一样，我们可以看到我们依赖于外部库来为我们做繁重的工作，我们只需调用库类上的函数来设置传感器并从中获取数据。
- en: CO2 module
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CO2模块
- en: For the CO[2] module, no attempt has been made yet to make it work with multiple
    types of CO[2] sensors. The first CO[2] sensor used was the MH-Z14, before it
    <indexentry content="modules, Building Management and Control (BMaC):CO[2] module">switched
    to the more compact MH-Z19 sensor. Both of these use the same protocol on their
    **universal asynchronous receiver/transmitter** (**UART**) interface, however.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于CO[2]模块，尚未尝试使其与多种类型的CO[2]传感器一起工作。最初使用的CO[2]传感器是MH-Z14，在它切换到更紧凑的MH-Z19传感器之前。这两个传感器在其**通用异步接收/发送器**（**UART**）接口上使用相同的协议。
- en: On the ESP8266 there are two UARTs, though only one is complete, with a receive
    (RX) and send (TX) line. The second UART only has a TX line. This essentially
    limits this MCU to a single UART and thus single UART-based sensor.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在ESP8266上，有两个UART，尽管只有一个完整，有一个接收（RX）和发送（TX）线。第二个UART只有一个TX线。这实际上将这个MCU限制为单个UART和基于UART的单个传感器。
- en: These sensors also have a single-wire interface in addition to the UART-based
    interface, where the sensor outputs the current sensor reading using a specific
    encoding that has to be received and decoded using the specific distance between
    pulses on that signal wire. This is similar to the DHT-22's single-wire protocol.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这些传感器除了基于UART的接口外，还有一个单线接口，传感器使用特定的编码输出当前的传感器读数，该编码必须通过在该信号线上脉冲之间的特定距离接收和解码。这与DHT-22的单线协议类似。
- en: 'Using the UART is obviously significantly easier, and it''s what we ended up
    using with this module:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用UART显然要容易得多，这也是我们最终在这个模块上使用的：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can see here the callback function that will be used with the UART when
    we receive data. We also have a few other variables whose meaning will <indexentry
    content="modules, Building Management and Control (BMaC):CO[2] module">become
    clear in a moment:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里可以看到，当我们接收到数据时将用于UART的回调函数。还有一些其他变量，其含义将在稍后变得清晰：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the static initializations, we define the command that we will be sending
    to the CO[2] sensor, which will tell it to send us its currently measured value.
    We define a number of counters and the related timer instance, which we will be
    using to analyze the CO[2] levels we receive.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在静态初始化中，我们定义了将发送给CO[2]传感器的命令，这将告诉它发送给我们当前测量的值。我们定义了多个计数器和相关的定时器实例，我们将使用它们来分析接收到的CO[2]水平。
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Starting this module triggers the registering of the pins, which we need for
    the UART, with the UART started at a baud rate of 9,600\. Our receive callback
    is also registered. The pin registration routine in the core class is meant for
    housekeeping and therefore cannot really fail. In case of an overlapping pin mapping
    with another module, we might want to release the first pin registration if the
    second registration fails.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 启动此模块会触发注册用于UART的引脚，UART以9600波特率启动。我们的接收回调也被注册。核心类中的引脚注册例程是为了维护而设计的，因此实际上不会失败。如果与其他模块的引脚映射重叠，我们可能希望在第二个注册失败时释放第一个引脚注册。
- en: The GPIO pins used by the serial interface are set in the same core class and
    would have to be modified there. The main reason behind this lack of configurability
    is that the GPIO pins on the ESP8266 are fairly limited in what features they
    support, which is why the hardware UART is basically always found on these two
    pins, leaving the other pins for other functionality.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 串行接口使用的GPIO引脚设置在同一个核心类中，并且必须在那里进行修改。这种不可配置性的主要原因在于ESP8266上的GPIO引脚在支持的功能方面相当有限，这也是为什么硬件UART基本上总是出现在这两个引脚上，而将其他引脚留给其他功能。
- en: The timer we start will read out the sensor every 30 seconds, keeping in mind
    that the first 3 minutes of sensor readings are useless as the sensor takes <indexentry
    content="modules, Building Management and Control (BMaC):CO[2] module">about that
    long to warm up.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们启动的定时器将每30秒读取一次传感器，考虑到传感器需要大约3分钟的时间来预热，所以前3分钟的传感器读数是无用的。
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Reading out the sensor is as easy as writing the series of bytes we defined
    during the static initialization phase to the sensor, and waiting for the sensor
    to respond by sending data back to us into our RX buffer, which will trigger our
    callback function.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 读取传感器就像在静态初始化阶段定义的字节序列写入传感器，并等待传感器通过将数据发送回我们的RX缓冲区来响应我们，这将触发我们的回调函数。
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The configuration method was also left unimplemented here, but could be used
    to disable events (explained in the next part) and make various adjustments dynamically:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的配置方法也未实现，但可以用来禁用事件（在下一部分中解释）并动态地进行各种调整：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the callback, we get the characters as they come in on the RX line. We wait
    until we have nine characters waiting for us in the RX buffer, which is the <indexentry
    content="modules, Building Management and Control (BMaC):CO[2] module">number
    of bytes we are expecting to receive from the CO[2] sensor. We could also validate
    the checksum for the received data, for which the MH-Z19 datasheet gives the following
    C code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在回调函数中，我们从RX线上接收到的字符。我们等待直到RX缓冲区中有九个字符等待，这是我们从CO[2]传感器期望接收的字节数。我们还可以验证接收到的数据的校验和，MH-Z19数据表提供了以下C代码：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This routine calculates the checksum for the received data as a single byte,
    which we can then compare with the value contained in the 9th byte of the received
    data to see whether the values match.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 此例程计算接收数据的校验和作为一个字节，然后我们可以将其与接收数据第9个字节中包含的值进行比较，看看是否匹配。
- en: Returning to our own code, we process the bytes to calculate the **parts per
    million** (**PPM**) of the CO[2] molecules the sensor detected. This value is
    immediately published to its respective MQTT topic.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的代码，我们处理字节以计算传感器检测到的CO[2]分子的**百万分之一**（**PPM**）。这个值立即发布到相应的MQTT主题。
- en: After this, we compare the new PPM value to see whether we have crossed any
    of the three preset trigger levels, the first one of which indicates a safe CO[2 ]level,
    the second an elevated CO[2 ]level, and the third a very high CO[2] level that
    requires attention. When we exceed or return to a lower trigger level, an event
    is published for this on the MQTT topic.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们比较新的PPM值，看看是否超过了三个预设的触发水平中的任何一个，第一个表示安全的CO[2]水平，第二个表示升高的CO[2]水平，第三个是要求注意的非常高的CO[2]水平。当我们超过或返回到较低的触发水平时，会在MQTT主题上发布一个事件。
- en: Jura
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jura
- en: This is another module which uses the UART. It was used with a number of Jura
    coffee machines, which used the common TopTronics electronics used by other coffee
    machine manufacturers as well. To enable reading out these coffee machines, an
    ESP8266 module was integrated into a small, plastic enclosure which just had a
    serial connector on one side. This connected with a standard nine-pin serial cable
    to the so-called service port on the back of the machine.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这又是一个使用UART的模块。它曾与多台Jura咖啡机一起使用，这些咖啡机使用了其他咖啡机制造商常用的常见TopTronics电子设备。为了能够读取这些咖啡机，一个ESP8266模块被集成到一个小型塑料外壳中，这个外壳一侧只有一个串行连接器。它通过一个标准的九针串行电缆连接到机器背面的所谓服务端口。
- en: The serial port on the machine provided 5V when it was powered on, which thus
    also turned on the ESP8266 node when the coffee machine was on. The plastic enclosure
    could then be hidden away behind the machine.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当机器开启时，其串行端口提供5V，因此当咖啡机开启时，ESP8266节点也会开启。塑料外壳可以随后被隐藏在机器后面。
- en: 'The module for this feature looks like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能的模块看起来是这样的：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The only really noticeable thing about this class declaration is the method
    name involving a coffee maker. We''ll see in a second what it does:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类声明唯一真正引人注目的是涉及咖啡机的命名方法。我们将在下一秒看到它做了什么：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As is common, the coffee machine''s UART runs at 9,600 baud. We set the serial
    callback method, and start a timer for reading out the EEPROM''s product counters.
    Since we are talking about a coffee machine, reading out the counters more than
    once a minute is somewhat silly:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如同常见的那样，咖啡机的UART运行在9,600波特率。我们设置了串行回调方法，并启动了一个定时器来读取EEPROM的产品计数器。由于我们谈论的是咖啡机，每分钟读取计数器超过一次似乎有些荒谬：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To read out the EEPROM''s counters, we need to send the command for this to
    the machine''s UART. This command will tell it to send us the contents of the
    first row in the EEPROM. Unfortunately, the machine''s protocol doesn''t use plain
    text, but requires a bit of special encoding, which we do in the next method:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取EEPROM的计数器，我们需要向机器的UART发送这个命令。这个命令会告诉它发送EEPROM中第一行的内容。不幸的是，机器的协议不使用纯文本，而是需要一些特殊的编码，我们将在下一个方法中完成：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This method takes in a string, appending the required EOL characters and encoding
    each byte into four bytes, putting the data bits into each new byte''s second
    and fifth bit, the rest of the bits all being a 1\. These four bytes are then
    sent to the machine''s UART with a small delay between each write to ensure correct
    reception:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法接受一个字符串，附加所需的EOL字符，并将每个字节编码成四个字节，将数据位放入每个新字节的第二和第五位，其余位都是1。然后这四个字节以每个写入之间有少量延迟的方式发送到机器的UART，以确保正确接收：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the serial receive callback, we decode each byte we receive using the same
    process we used to encode the data we sent to the machine, buffering the decoded
    bytes until we detect the end of the response (linefeed, LF) character. We then
    read out the 16-bit counters, which we then publish on the MQTT topic for them.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在串行接收回调中，我们使用与编码发送给机器的数据相同的过程解码我们接收到的每个字节，缓冲解码的字节，直到我们检测到响应结束（换行符，LF）字符。然后我们读取16位计数器，然后将它们发布在MQTT主题上。
- en: JuraTerm
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JuraTerm
- en: The JuraTerm module is similar to the Jura one, but it accepts remote commands,
    encodes them in the same way as the Jura module, and returns the decoded response.
    In the project it used to be the Jura class until it got superseded by the new
    Jura class and this one was delegated to just a terminal class. In a future revision
    this module's functionality will therefore be merged into the main Jura class.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: JuraTerm模块与Jura模块类似，但它接受远程命令，以与Jura模块相同的方式编码它们，并返回解码后的响应。在项目中，它曾经是Jura类，直到被新的Jura类取代，这个模块因此被委托为仅终端类。在未来的修订中，这个模块的功能将因此合并到主Jura类中。
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When we start this module, we register an MQTT topic to receive commands. This
    allows us to receive the coffee machine commands. We basically act as a straight
    pass-through for these commands, except for this one particular command. This
    command that we filter out would erase the machine's EEPROM, which is something
    which we are unlikely to want.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启动这个模块时，我们注册了一个MQTT主题来接收命令。这允许我们接收咖啡机的命令。我们基本上是这些命令的直接传递，除了这个特定的命令。我们过滤掉的这个命令会擦除机器的EEPROM，这是我们不太可能想要做的事情。
- en: 'Again, we use the same method to encode the command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们使用相同的方法来编码命令：
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Instead of interpreting the data in any way, we merely return the response on
    its respective MQTT topic.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不解释数据，只是在其各自的MQTT主题上返回响应。
- en: Motion
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运动
- en: The motion module is intended to work with **passive infrared** (**PIR**) sensors.
    These have onboard logic that determine when a trigger point has been reached,
    at which point they change an interrupt pin into a high signal. We can use this
    to determine whether a person is in a room, or is walking through a hallway.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 运动模块旨在与**被动红外**（**PIR**）传感器一起工作。这些传感器内部有逻辑电路，用于确定何时达到触发点，此时它们将中断引脚变为高信号。我们可以利用这一点来判断是否有人员在房间里，或者是否正在走廊里行走。
- en: 'Its code looks as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 其代码如下所示：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Of note here is that we explicitly move the interrupt handler method into the
    MCU's SRAM with the IRAM_ATTR keyword, to prevent any delay when the interrupt
    gets called.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，我们使用IRAM_ATTR关键字将中断处理方法显式地移动到MCU的SRAM中，以防止在调用中断时出现任何延迟。
- en: 'Its implementation is as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 其实现方式如下：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: A PIR sensor requires warm-up time to stabilize its readings. We give it a minute
    using the warm-up timer. We also set the mode for the GPIO pin we're using.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: PIR传感器需要预热时间以稳定其读数。我们使用预热定时器给它一分钟。我们还设置了我们所使用的GPIO引脚的模式。
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After the sensor has finished warming up, we stop its timer and attach the
    interrupt to handle any signals from the sensor. We''ll check up on the shared
    variable with the interrupt routine, to see whether the value has changed, publishing
    the current value every 5 seconds:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 传感器完成预热后，我们停止其定时器并将中断附加到处理来自传感器的任何信号的程序。我们将通过中断例程检查共享变量，以查看值是否已更改，每5秒发布当前值：
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When checking the current sensor value, we make it a point to ignore the first
    time that the sensor reports `LOW`. This in order to ensure that we ignore moments
    when people do not move a lot in the room. The resulting value is then published
    on the MQTT topic:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查当前传感器值时，我们特别注意忽略传感器第一次报告`LOW`的情况。这是为了确保我们忽略人们不在房间里移动很多的时刻。然后，将结果值发布在MQTT主题上：
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The interrupt handler merely updates the local Boolean value. Because of the
    relatively long transition times for most processing circuits for PIR sensor there
    is quite a bit of time (seconds) before the sensor will detect motion again, creating
    dead zones. Here we keep track of the last registered value.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 中断处理程序仅更新局部布尔值。由于PIR传感器的处理电路的过渡时间相对较长，因此在传感器再次检测到运动之前有一段时间（秒数），这会形成死区。在这里，我们记录最后注册的值。
- en: PWM
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PWM
- en: The reason why the PWM module was developed was to have a way to generate an
    analog output voltage using an external RC filter circuit. This was in order to
    control the fan of the ceiling-mounted air-conditioning units, whose fan controller
    accepts a voltage of between 0 and 10 volts.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 开发PWM模块的原因是提供一个使用外部RC滤波电路生成模拟输出电压的方法。这是为了控制安装在天花板上的空调单元的风扇，其风扇控制器接受0到10伏的电压。
- en: 'An interesting feature of this module is that it has its own binary protocol
    to allow for remote control, which is how the air-conditioning service can directly
    control the fan speeds via the ceiling-mounted nodes:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块的一个有趣特性是它有自己的二进制协议，允许远程控制，这就是空调服务可以直接通过天花板上的节点控制风扇速度的原因：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The implementation is as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 实现方式如下：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We define the commands that will be available with the PWM module here as an
    enumeration:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里定义PWM模块将提供的命令作为枚举：
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: When we start this module, we register the MQTT topic on which the module will
    be able to receive commands. When shutting down, we deregister this topic again.
    We use the `HardwarePWM` class from Sming to enable PWM on individual pins.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启动此模块时，我们注册模块将能够接收命令的MQTT主题。当关闭时，我们再次注销此主题。我们使用Sming中的`HardwarePWM`类来在单个引脚上启用PWM。
- en: 'The rest of the module is simply the command processor:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的其他部分仅仅是命令处理器：
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The protocol implemented by the preceding method is the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 前述方法实现的协议如下：
- en: '| **Command** | **Meaning** | **Payload** | **Return value** |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **含义** | **有效载荷** | **返回值** |'
- en: '| 0x01 | Start the module | uint8 (number of pins)uint8* (one byte per pin
    number) | 0x00/0x01 |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 0x01 | 启动模块 | uint8 (引脚数量)uint8* (每个引脚号一个字节) | 0x00/0x01 |'
- en: '| 0x02 | Stop the module | - | 0x00/0x01 |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 0x02 | 停止模块 | - | 0x00/0x01 |'
- en: '| 0x04 | Set the PWM duty level | uint8 (pin number)uint8 (duty cycle, 0 -
    100) | 0x00/0x01 |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 0x04 | 设置PWM占空比 | uint8 (引脚号)uint8 (占空比，0 - 100) | 0x00/0x01 |'
- en: '| 0x08 | Get the PWM duty level | uint8 (pin number). | uint8 (duty level)
    |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 0x08 | 获取PWM占空比 | uint8 (引脚编号)。 | uint8 (占空比) |'
- en: '| 0x10 | Returns the active pins | - | uint8* (one pin number per byte) |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 0x10 | 返回活动引脚 | - | uint8* (每字节一个引脚编号) |'
- en: For each command, we parse the string of bytes we receive, checking the number
    of bytes to see whether we get the expected number, and then interpreting them
    as commands and their payload. We either return a 0 (failure) or a 1 (success),
    or a payload with the desired information.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个命令，我们解析我们接收的字节字符串，检查字节数以查看我们是否获得了预期的数量，然后将它们解释为命令及其有效负载。我们返回0（失败）或1（成功），或者带有所需信息的有效负载。
- en: One obvious addition that could be made here would be to add some kind of checksum
    to the received command, along with sanity checks on the received data. While
    code like this will work great in a secure environment with encrypted MQTT links
    and a reliable network connection, other environments may be less forgiving, with
    corrupted data and false data being injected.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这里可以明显添加的一个改进是，在接收到的命令中添加某种校验和，并对接收到的数据进行合理性检查。虽然这样的代码在具有加密MQTT链接和可靠网络连接的安全环境中运行得很好，但其他环境可能不太宽容，可能会注入损坏的数据和错误数据。
- en: I/O
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: I/O
- en: Sometimes all we need is just a lot of GPIO pins that connect to things like
    relays, so that we can turn heating valves on or off. This was the reason behind
    this module. The nodes that were being installed on the ceiling had not just an
    I2C bus being used for the environmental sensors, but also the UART for CO[2]
    measurements and four pins for PWM output.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们需要的只是大量的GPIO引脚，这些引脚连接到诸如继电器之类的设备，这样我们就可以打开或关闭加热阀门。这就是这个模块背后的原因。安装在天花板上的节点不仅使用了I2C总线用于环境传感器，还使用了UART进行CO[2]测量和四个用于PWM输出的引脚。
- en: As more GPIO was needed to turn the relays that controlled the valves on the
    water lines to the air-conditioning units on or off, a dedicated GPIO expander
    chip was added to the I2C bus to provide eight more GPIO pins.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 由于需要更多的GPIO来控制水线中阀门的开闭，以控制空调单元的开关，因此在I2C总线上添加了一个专门的GPIO扩展器芯片，以提供另外八个GPIO引脚。
- en: 'This module allows for an external service like the air-conditioning service
    to directly set these new GPIO pins as high or low:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块允许外部服务（如空调服务）直接将这些新的GPIO引脚设置为高或低：
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This class wraps the MCP23008 I/O expander device, keeping a local copy of
    its direction, pull-up, and GPIO state registers for easy updating and control:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类封装了MCP23008 I/O扩展器设备，保留其方向、上拉和GPIO状态寄存器的本地副本，以便于更新和控制：
- en: '[PRE32]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We keep a local copy of three registers on the I2C GPIO expander device—the
    I/O direction (`iodir`), pull-up register (`gppu`), and the pin I/O level (`gpio`):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在I2C GPIO扩展器设备上保留三个寄存器的本地副本——I/O方向（`iodir`）、上拉寄存器（`gppu`）和引脚I/O电平（`gpio`）：
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We again define a number of commands in the form of an enumeration, along with
    one for the pin direction of the GPIO expander:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次以枚举的形式定义了一系列命令，包括用于GPIO扩展器引脚方向的命令：
- en: '[PRE34]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Initializing and starting the module is similar to the PWM module, with us registering
    an MQTT topic to receive commands on. The difference here is that since we are
    using an I2C device, we have to make sure that the I2C functionality has been
    started already.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化和启动模块类似于PWM模块，我们注册一个MQTT主题以接收命令。这里的区别在于，由于我们使用I2C设备，我们必须确保I2C功能已经启动。
- en: 'Next, we address the command-processing method:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们处理命令处理方法：
- en: '[PRE35]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Its protocol looks as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 其协议如下所示：
- en: '| **Command** | **Meaning** | **Payload** | **Return value** |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **含义** | **有效负载** | **返回值** |'
- en: '| 0x01 | Start the module | uint8 I2C address offset (0-7, optional) | 0x010x00/0x01
    |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| 0x01 | 启动模块 | uint8 I2C地址偏移（0-7，可选） | 0x010x00/0x01 |'
- en: '| 0x02 | Stop the module | - | 0x020x00/0x01 |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| 0x02 | 停止模块 | - | 0x020x00/0x01 |'
- en: '| 0x04 | Returns I/O mode, pull-up, and level state | - | 0x040x00/0x01 (result)uint8
    (iodir register)uint8 (gppu register)uint8 (gpio register) |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 0x04 | 返回I/O模式、上拉和电平状态 | - | 0x040x00/0x01 (结果)uint8 (iodir 寄存器)uint8 (gppu
    寄存器)uint8 (gpio 寄存器) |'
- en: '| 0x08 | Set a pin to a specific mode (In/Out) | uint8 (pin number, 0 - 7)uint8
    (0: output, 1: input) | 0x080x00/0x01 |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 0x08 | 将引脚设置为特定模式（输入/输出） | uint8 (引脚编号，0 - 7)uint8 (0：输出，1：输入) | 0x080x00/0x01
    |'
- en: '| 0x10 | Set a pin''s pull-up resistor (Low/High) | uint8 (pin number, 0 -
    7)uint8 (pin pull-up state, 0/1) | 0x100x00/0x01 |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 0x10 | 设置引脚的上拉电阻（低/高） | uint8 (引脚编号，0 - 7)uint8 (引脚上拉状态，0/1) | 0x100x00/0x01
    |'
- en: '| 0x20 | Set a pin to either Low or High | uint8 (pin number, 0-7)uint8 (pin
    state, 0/1) | 0x20 0x00/0x01 |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 0x20 | 将引脚设置为低或高 | uint8 (引脚编号，0-7)uint8 (引脚状态，0/1) | 0x20 0x00/0x01 |'
- en: '| 0x40 | Read the current pin value (Low, High) | uint8 (pin number) | 0x40
    0x00/0x01 uint8 (pin number) uint8 (pin value) |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 0x40 | 读取当前引脚值（低，高） | uint8（引脚号） | 0x40 0x00/0x01 uint8（引脚号） uint8（引脚值） |'
- en: '| 0x80 | Return whether this module has been initialized | - | 0x80 0x00/0x01
    uint8 (module state, 0/1). |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 0x80 | 返回此模块是否已初始化 | - | 0x80 0x00/0x01 uint8（模块状态，0/1）。 |'
- en: Similar to the protocol for the PWM module, either a Boolean value is returned
    to indicate success, or the requested payload is returned. We also return the
    command that was called in the response.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 与PWM模块的协议类似，要么返回布尔值以指示成功，要么返回请求的有效负载。我们还在响应中返回所调用的命令。
- en: The command is a single byte, allowing for a maximum of eight commands since
    we are using bit flags. This could be extended to 256 commands if we wanted to.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 命令是一个单字节，由于我们使用位标志，因此最多可以有八个命令。如果我们想的话，这可以扩展到256个命令。
- en: Possible improvements to this module's code include consolidating duplicated
    code into (inline) function calls and conceivably the use of a sub-class that
    would manage the setting and toggling of individual bits with a more higher-level
    API.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块代码的潜在改进包括将重复的代码合并到（内联）函数调用中，以及可能使用一个子类来管理使用更高级API设置和切换单个位。
- en: Switch
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开关
- en: 'Since each section of the office had its own central switch that would switch
    the water in the pipes that flowed to the FCUs, this had to be controllable from
    the backend server as well. Using a latching relay configuration, it was possible
    to both switch between heating and cooling configurations, as well as have a memory
    element that could be read out by the node:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 由于办公室的每个部分都有自己的中央开关，该开关可以切换流向FCU的管道中的水流，因此这也必须从后端服务器进行控制。使用继电器保持接通配置，可以切换加热和冷却配置，并且还有一个可以被节点读取的存储元件：
- en: 'This system was assembled on a single board that was used to replace the original
    manual switch, using the following module to control it:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 该系统是在一个单板上组装的，用于替换原始的手动开关，使用以下模块来控制它：
- en: '[PRE36]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Its implementation is as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 其实现方式如下：
- en: '[PRE37]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This module is very similar to the PWM and I/O modules, with the registering
    of an MQTT topic to allow communication using its own binary protocol. Here, the
    device that is being controlled is fairly simple. It is a latching relay with
    two sides, one of which is connected to the connections that are being switched
    between, while the other side is used as a one-bit memory cell.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块与PWM和I/O模块非常相似，通过注册MQTT主题来允许使用其自己的二进制协议进行通信。在这里，被控制的设备相当简单。它是一个具有两端的继电器，其中一端连接到正在切换的连接，而另一端用作一个位存储单元。
- en: As both sides of this type of relay will switch simultaneously, we can count
    on the side connected to the MCU to match the position of that on the side connected
    to the rest of the system. Even after a power failure or reset of the MCU, we
    can simply read out the values of the pins connected to the relay to find out
    the state of the system.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此类继电器的两侧将同时切换，我们可以确信连接到MCU的侧将与连接到系统其余部分的侧的位置相匹配。即使在电源故障或MCU重置之后，我们也可以简单地读取连接到继电器的引脚值，以找出系统的状态。
- en: 'The resulting protocol looks like this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的协议看起来如下：
- en: '| **Command** | **Meaning** | **Payload** | **Return value** |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **含义** | **有效负载** | **返回值** |'
- en: '| 0x01 | Switch to Position 1 | - | 0x010x00/0x01 |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| 0x01 | 切换到位置 1 | - | 0x010x00/0x01 |'
- en: '| 0x02 | Switch to Position 2 | - | 0x020x00/0x01 |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| 0x02 | 切换到位置 2 | - | 0x020x00/0x01 |'
- en: '| 0x04 | Return the current state | - | 0x040x00/0x01 (result)uint8 (active
    pin 0x00, 0x01) |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 0x04 | 返回当前状态 | - | 0x040x00/0x01（结果）uint8（活动引脚0x00，0x01） |'
- en: Command and control server
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令与控制服务器
- en: As alluded to earlier in this chapter, a so-called **command and control** (**C&C**)
    server is essentially a database containing information on individual nodes and
    their configuration, for use by the nodes themselves and administration tools
    like the one in the next section.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所述，所谓的**命令与控制**（**C&C**）服务器本质上是一个数据库，包含有关各个节点及其配置的信息，供节点本身和下一节中提到的类似管理工具使用。
- en: 'It also includes an HTTP server, for use with HTTP-based **over-the-air** (**OTA**)
    updates. Since the BMaC system is MQTT-based, this server is also written as an
    MQTT client:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 它还包括一个HTTP服务器，用于基于HTTP的**空中**（**OTA**）更新。由于BMaC系统基于MQTT，因此该服务器也作为MQTT客户端编写：
- en: '[PRE38]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We're using the Mosquitto C++ MQTT client along with the POCO framework to provide
    us with the required functionality.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Mosquitto C++ MQTT客户端和POCO框架来提供所需的功能。
- en: 'The `Listener` class is next:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个类是 `Listener` 类：
- en: '[PRE39]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We include the headers from POCO for the SQLite database functionality, which
    forms the database backend for this application. The class itself derives from
    the Mosquitto C++ class, providing us with all the basic MQTT functionalities
    along with a few function stubs, which we still have to implement in a moment:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包含了来自 POCO 的头文件以支持 SQLite 数据库功能，这构成了本应用程序的数据库后端。该类本身继承自 Mosquitto C++ 类，为我们提供了所有基本
    MQTT 功能以及一些函数占位符，我们稍后还需要实现这些函数：
- en: '[PRE40]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We define a structure for a single node:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个单个节点的结构：
- en: '[PRE41]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the constructor, we attempt to connect to the MQTT broker, using the provided
    host and port. We also set up a connection with the SQLite database, and ensure
    that it has valid nodes and a firmware table:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们尝试使用提供的主机和端口连接到 MQTT 代理。我们还设置了一个与 SQLite 数据库的连接，并确保它具有有效的节点和固件表：
- en: '[PRE42]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We reimplement the callback for when a connection has been established with
    the MQTT broker. In this method, we subscribe to all the MQTT topics in which
    we are interested.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重新实现了与 MQTT 代理建立连接时的回调。在这个方法中，我们订阅了我们感兴趣的所有 MQTT 主题。
- en: 'The next method is called whenever we receive an MQTT message on one of the
    topics which we subscribed to:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们收到订阅主题之一的 MQTT 消息时，将调用下一个方法：
- en: '[PRE43]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We validate the payload we receive for each topic. For this first topic, we
    expect its payload to contain the MAC address of the node which wants to receive
    its configuration. We make sure that this seems to be the case, then continue:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们验证接收到的每个主题的有效载荷。对于这个第一个主题，我们期望其有效载荷包含想要接收其配置的节点的 MAC 地址。我们确保这似乎是正确的，然后继续：
- en: '[PRE44]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We attempt to find the MAC address in the database, reading out the node's configuration
    if found and making it the payload for the return message.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试在数据库中找到 MAC 地址，如果找到则读取节点的配置并将其作为返回消息的有效载荷。
- en: 'The next topics are used with the administration tool:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个主题与行政工具一起使用：
- en: '[PRE45]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In the case of this payload string, we return the binary data for a map image
    that should exist in the local folder. This map contains the layout of the building
    we are administrating, for displaying in the tool.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此有效载荷字符串，我们返回本地文件夹中应存在的地图图像的二进制数据。此地图包含我们管理的建筑布局，用于在工具中显示。
- en: '[PRE46]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The preceding section reads out every single node in the database and returns
    it in a binary, serialized format.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节读取数据库中的每个节点，并以二进制序列化的格式返回它。
- en: 'Next, we create a new node and add it to the database:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个新的节点并将其添加到数据库中：
- en: '[PRE47]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Updating a node''s configuration is also possible:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 更新节点配置也是可能的：
- en: '[PRE48]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Next, we look at the topic handler for deleting a node''s configuration:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看删除节点配置的主题处理器：
- en: '[PRE49]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'When we looked at the CO[2] module of the firmware earlier, we saw that it
    generated CO[2] events. These also end up here in this example, in order to generate
    events in JSON format, which we send to some HTTP-based API. We then use the HTTPS
    client in POCO to send this JSON to the remote server (here set to localhost):'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前查看固件中的 CO[2] 模块时，我们看到它生成了 CO[2] 事件。这些事件也出现在这个示例中，以便生成 JSON 格式的事件，我们将这些事件发送到某个基于
    HTTP 的 API。然后我们使用 POCO 中的 HTTPS 客户端将此 JSON 发送到远程服务器（此处设置为 localhost）：
- en: '[PRE50]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Finally, for managing the stored firmware images, we can use the following topic.
    Which node uses which firmware version can be set in each node's configuration,
    though as we saw earlier, the default is to use the latest firmware.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了管理存储的固件映像，我们可以使用以下主题。每个节点使用哪个固件版本可以在每个节点的配置中设置，尽管如我们之前所见，默认是使用最新固件。
- en: 'Using this topic, we can list the available firmware images or upload a new
    one:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此主题，我们可以列出可用的固件映像或上传一个新的：
- en: '[PRE51]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: On each successful MQTT topic subscription, this method is called, allowing
    us to do something else if needed.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个成功的 MQTT 主题订阅后，此方法会被调用，允许我们在需要时执行其他操作。
- en: 'Next, we look at the HTTP server component, starting with the HTTP request
    handler factory:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看 HTTP 服务器组件，从 HTTP 请求处理器工厂开始：
- en: '[PRE52]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This handler will always return an instance of the following class:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 此处理器将始终返回以下类的实例：
- en: '[PRE53]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This class looks fairly impressive, yet mostly does just an SQLite database
    lookup for the node ID (MAC address) and returns the appropriate firmware image
    if found.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类看起来相当令人印象深刻，但它主要只是对节点 ID（MAC 地址）进行 SQLite 数据库查找，如果找到则返回相应的固件映像。
- en: Administration tool
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理工具
- en: Using the APIs implemented by the C&C server, a GUI-based administration tool
    was created using the Qt5 framework and the Mosquitto MQTT client library was
    developed, allowing for the basic management of nodes. They were overlaid on top
    of a layout graphic of buildings.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 使用C&C服务器实现的API，使用Qt5框架创建了一个基于GUI的管理工具，并开发了Mosquitto MQTT客户端库，允许对节点进行基本管理。它们叠加在建筑布局图形之上。
- en: While basically usable, it was found that a graphical tool was fairly complicated
    to develop. It was also limited to a single floor of a building, unless one were
    to have a really large map containing all of the floors with the nodes mapped
    onto this. This would have been quite clumsy, obviously.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然基本可用，但发现开发一个图形工具相当复杂。它也仅限于建筑物的单层，除非有一个包含所有楼层并且节点映射到该图上的非常大的地图。这显然会很笨拙。
- en: In the source code provided with this chapter, the administration tool can be
    found as well, to serve as an example of how one could implement it. For the sake
    of brevity, the code for it has been omitted here.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章提供的源代码中，可以找到管理工具，作为如何实现它的示例。为了简洁起见，这里省略了它的代码。
- en: Air-conditioning service
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空调服务
- en: 'To control air-conditioning units, a service much like the C&C one was developed,
    using the same basic template. The interesting parts of its source are the following:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制空调单元，开发了一个类似于C&C的服务，使用相同的模板。其源代码中有趣的部分如下：
- en: '[PRE54]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The definition for this class in the AC service gives a good overview of the
    functionality of this class. It's essentially a wrapper around an SQLite database,
    containing information on nodes, valves, and cooling/heating switches. It also
    contains the timers that will keep triggering the application to check the status
    of the system, to compare it to the target state, and to make adjustments if necessary.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在AC服务中对这个类的定义提供了一个关于该类功能性的良好概述。它本质上是一个SQLite数据库的包装器，包含有关节点、阀门和冷却/加热开关的信息。它还包含定时器，这些定时器将不断触发应用程序检查系统的状态，将其与目标状态进行比较，并在必要时进行调整。
- en: 'This class is used extensively by the `Listener` class of this application
    for keeping track of the status of nodes and the connected AC units, along with
    those switches and valves controlling the water flow:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类被应用程序的`Listener`类广泛使用，用于跟踪节点和连接的AC单元的状态，以及控制水流的开/关阀门：
- en: '[PRE55]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The way that this application works is that the `Nodes` class timers will cause
    the `Listener` class to publish on the topics for the PWM, IO, and Switch modules,
    inquiring about the state of the devices that are supposed to be active.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序的工作方式是，`Nodes`类的定时器将导致`Listener`类在PWM、IO和开关模块的主题上发布，询问应处于活动状态的设备的状态。
- en: This kind of active loop system is common in industrial applications, as it
    provides constant validation of the system to detect quickly if something isn't
    working as intended.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这种主动循环系统在工业应用中很常见，因为它提供了对系统的持续验证，可以快速检测是否有东西没有按预期工作。
- en: InfluxDB for recording sensor readings
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: InfluxDB用于记录传感器读数
- en: Recording the sensor readings and later the statistics read from the coffee
    machines was a priority from the beginning. The ideal database for this kind of
    data is a time series database, of which Influx is a common one. The biggest problem
    with this database is that it does not support MQTT, only offering its HTTP and
    native interface.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 从一开始，记录传感器的读数以及后来从咖啡机读取的统计数据就是一项优先任务。对于这类数据，理想的数据库是时间序列数据库，其中Influx就是一个常见的例子。这个数据库最大的问题是不支持MQTT，只提供HTTP和本地接口。
- en: 'To fix this, a simple MQTT-to-Influx HTTP line protocol bridge was written,
    again using the Mosquitto client library as well as the POCO framework''s HTTP
    functionality:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，编写了一个简单的MQTT到Influx HTTP行协议网桥，再次使用了Mosquitto客户端库以及POCO框架的HTTP功能：
- en: '[PRE56]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In the constructor, we connect to the MQTT broker, and create either an HTTP
    or HTTPS client, depending on which protocol has been set in the configuration
    file:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们连接到MQTT代理，并创建HTTP或HTTPS客户端，具体取决于配置文件中设置的协议：
- en: '[PRE57]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Instead of fixed MQTT topics to subscribe to, we use the topics that are defined
    in the configuration file, here provided to us as a single string with each topic
    separated by a comma.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不使用固定的MQTT主题进行订阅，而是使用配置文件中定义的主题，这里提供给我们的是一个由逗号分隔的单个字符串。
- en: We also create an STL map containing the name of the time series to record for
    the topic, taking the final part of the MQTT topic after the last slash. One could
    make this further configurable, but for the topics used in the BMaC system this
    limitation was no consideration as it not necessary to have more complex topics.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一个STL映射，包含要记录的时间序列名称，取MQTT主题中最后一个斜杠之后的部分。虽然可以进一步配置，但对于BMaC系统中使用的主题，这个限制并不重要，因为不需要更复杂的话题。
- en: '[PRE58]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: When we get a new MQTT message in, we find the name of the Influx time series
    for it, then create a string to send to the InfluxDB server. The assumption here
    is that the payload consists of the MAC address of the node which sent the message
    followed by a semi-colon.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们收到新的MQTT消息时，我们会找到对应Influx时间序列的名称，然后创建一个字符串发送到InfluxDB服务器。这里的假设是有效载荷由发送消息的节点的MAC地址组成，后面跟着一个分号。
- en: We simply get the part after the semi-colon to set it as the value, and use
    the MAC as the location. This we then send to the database server.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需获取分号后面的部分，将其设置为值，并使用MAC地址作为位置。然后我们将这个信息发送到数据库服务器。
- en: Security aspects
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全方面
- en: During the development of this system it became soon obvious that security would
    be a paramount aspect of the system. For that reason we looked at adding transport
    layer security (TLS) encryption. This would use the integrated axTLS encryption
    library in the Sming framework together with AES certificates (host and client)
    to provide both verification that the host (servers) and clients (nodes) are who
    they say they are, but also provide a secure encrypted link.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发这个系统的过程中，很快就很明显，安全性将是系统的关键方面。因此，我们考虑添加传输层安全性（TLS）加密。这将使用Sming框架中集成的axTLS加密库以及AES证书（主机和客户端）来提供主机（服务器）和客户端（节点）身份验证，同时提供一个安全的加密链接。
- en: In [Chapter 5](886aecf2-8926-4aec-8045-a07ae2cdde84.xhtml), *Example - Soil
    Humidity Monitor with Wi-Fi*, we already looked at the handling of these client
    certificates and setting up of an encrypted MQTT connection. One detail which
    is not obvious from that were the troubles which we encountered while setting
    up this certificate system. As mentioned in [Chapter 5](886aecf2-8926-4aec-8045-a07ae2cdde84.xhtml), *Example - Soil
    Humidity Monitor with Wi-Fi*, the ESP8266 does not have enough memory to allocate
    the default TLS handshake buffers and requires the use of the SSL fragment size
    extension on the side of the server (host).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](886aecf2-8926-4aec-8045-a07ae2cdde84.xhtml)，*示例 - 带Wi-Fi的土壤湿度监测器*中，我们已经讨论了这些客户端证书的处理和设置加密MQTT连接的过程。其中不太明显的一个细节是我们设置此证书系统时遇到的麻烦。正如[第5章](886aecf2-8926-4aec-8045-a07ae2cdde84.xhtml)，*示例
    - 带Wi-Fi的土壤湿度监测器*中提到的，ESP8266没有足够的内存来分配默认的TLS握手缓冲区，因此需要在服务器（主机）端使用SSL片段大小扩展。
- en: Unfortunately we found that the commonly used MQTT broker we were using (Mosquitto)
    did not support this SSL extension and would therefore require that clients used
    the default double 16 kB buffer. The first solution to this would be to recompile
    the Mosquitto broker after making a few changes to its source code to change this
    setting.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们发现我们常用的MQTT代理（Mosquitto）不支持这个SSL扩展，因此需要客户端使用默认的双16 kB缓冲区。对此的第一个解决方案是在对其源代码进行一些修改后重新编译Mosquitto代理，以更改此设置。
- en: The better solution and the one which we ultimately implemented was to install
    a proxy software (HAProxy) which functioned as the TLS endpoint, handling the
    certificates and redirecting the decrypted traffic to the MQTT broker via the
    local loopback (localhost) interface.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的解决方案，也是我们最终实施的方案，是安装一个代理软件（HAProxy），它作为TLS端点，处理证书并将解密后的流量通过本地回环（localhost）接口重定向到MQTT代理。
- en: With the SSL fragment size option set to 1-2 kB everything worked as intended
    and we had a building-wide, wireless monitoring and control system that allowed
    for secure communications of sensitive information and delicate control commands.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 将SSL片段大小选项设置为1-2 kB后，一切按预期工作，我们拥有一个覆盖整个建筑物的无线监控和控制系统，它允许安全地传输敏感信息和微妙的控制命令。
- en: Future developments
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未来发展
- en: There are still many additions that can be made to this system. From the number
    of sensors that could be supported, further GPIO expander chips, air-conditioning
    system configurations, room occupancy detection linked into a calendar backend,
    to clearing out scheduled meetings at an office where nobody showed up, and so
    on.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统还有很多可以添加的功能。从可以支持传感器的数量，到进一步的GPIO扩展芯片，空调系统配置，将房间占用检测链接到日历后端，以及清理办公室中无人出席的预定会议等等。
- en: There is also the option of switching from ESP8266 as the MCU to a different
    one, such as ARM-based MCUs, to get wired Ethernet options, along with better
    debug and development tools. As convenient as it is to have an MCU with Wi-Fi,
    which one can just stick anywhere and theoretically have it work, the development
    tools for the ESP8266 aren't that great, and the lack of wired communication options
    (without using external chips) means that everything either works or doesn't depending
    on the quality of the Wi-Fi network.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将ESP8266作为MCU切换到其他类型，例如基于ARM的MCU，以获得有线以太网选项，以及更好的调试和开发工具外，还有其他选择。虽然拥有Wi-Fi的MCU非常方便，可以随意放置并理论上工作，但ESP8266的开发工具并不出色，而且缺乏有线通信选项（不使用外部芯片），这意味着一切要么工作要么不工作，这取决于Wi-Fi网络的质量。
- en: As BMaC involves the automation of a building, it is desirable to have a certain
    level of reliability, which is hard to guarantee with a Wi-Fi network, though
    for less crucial components (coffee machine statistics, sensor readings, and so
    on) this is unlikely to be an issue. Conceivably a hybrid network with both wired
    and wireless options could be the future.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 由于BMaC涉及到建筑的自动化，因此希望有一个一定程度的可靠性，而使用Wi-Fi网络很难保证这一点，尽管对于不那么关键的部分（如咖啡机统计，传感器读数等）这不太可能成为问题。可能一个既有有线又有无线选项的混合网络将是未来的发展方向。
- en: Summary
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at how a building-wide monitoring and management
    system was developed, what its components looked like, and what lessons were learned
    during its development.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何开发一个建筑级的监控和管理系统，它的组件是什么样的，以及在其开发过程中学到了什么经验教训。
- en: The reader is expected to understand now how such a large-scale embedded system
    is constructed and functions, and should be able either to use the BMaC system
    themselves or implement a similar system.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 预期读者现在应该理解这样一个大规模嵌入式系统的构建和功能，并且能够自己使用BMaC系统或实现一个类似的系统。
- en: In the next chapter we will look at developing embedded projects using the Qt
    framework.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨使用Qt框架开发嵌入式项目。
