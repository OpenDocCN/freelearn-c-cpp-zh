<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-213">
    <a id="_idTextAnchor212">
    </a>
    
     10
    
   </h1>
   <h1 id="_idParaDest-214">
    <a id="_idTextAnchor213">
    </a>
    
     Coroutines with Boost.Cobalt
    
   </h1>
   <p>
    
     The previous chapters introduced C++20 coroutines and the Boost.Asio library, which is the foundation for
    
    <a id="_idIndexMarker760">
    </a>
    
     writing asynchronous
    
    <strong class="bold">
     
      input/output
     
    </strong>
    
     (
    
    <strong class="bold">
     
      I/O
     
    </strong>
    
     ) operations using Boost.
    
    
     In this chapter, we will explore Boost.Cobalt, a high-level abstraction based on Boost.Asio that simplifies asynchronous programming
    
    
     
      with coroutines.
     
    
   </p>
   <p>
    
     Boost.Cobalt allows you to write clear, maintainable asynchronous code while avoiding the complexities of manually implementing coroutines in C++ (as covered in
    
    <a href="B22219_08.xhtml#_idTextAnchor164">
     
      <em class="italic">
       
        Chapter 8
       
      </em>
     
    </a>
    
     ).
    
    
     Boost.Cobalt is fully compatible with Boost.Asio, allowing you to seamlessly combine both libraries in your projects.
    
    
     By using Boost.Cobalt, you can focus on building your application without worrying about the low-level details
    
    
     
      of coroutines.
     
    
   </p>
   <p>
    
     In this chapter, we will cover the following
    
    
     
      Boost.Cobalt topics:
     
    
   </p>
   <ul>
    <li>
     
      Introducing the
     
     
      
       Boost.Cobalt library
      
     
    </li>
    <li>
     
      
       Boost.Cobalt generators
      
     
    </li>
    <li>
     
      Boost.Cobalt tasks
     
     
      
       and promises
      
     
    </li>
    <li>
     
      
       Boost.Cobalt channels
      
     
    </li>
    <li>
     
      Boost.Cobalt
     
     
      
       synchronization functions
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-215">
    <a id="_idTextAnchor214">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     To build and execute the code examples from this chapter, a compiler that supports C++20 is required.
    
    
     We have used both Clang
    
    <strong class="source-inline">
     
      18
     
    </strong>
    
     and
    
    
     
      GCC
     
    
    
     <strong class="source-inline">
      
       14.2
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Make sure you use Boost version 1.84 or newer and that your Boost library was compiled with C++20 support.
    
    
     At the time of writing this book, Cobalt support is rather fresh in Boost and not all precompiled distributions may provide this component.
    
    
     The situation will generally improve by the time of reading this book.
    
    
     If, for any reason, the Boost library in your system does not meet these requirements, you have to build it from its source.
    
    
     Compiling with an earlier version, such as C++17, won’t include Boost.Cobalt since it relies heavily on
    
    
     
      C++20 coroutines.
     
    
   </p>
   <p>
    
     You can find the complete code in the following
    
    
     
      GitHub repository:
     
    
   </p>
   <p>
    <a href="https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP">
     
      
       https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP
      
     
    </a>
   </p>
   <p>
    
     The examples for this chapter are located under the
    
    
     <strong class="source-inline">
      
       Chapter_10
      
     </strong>
    
    
     
      folder.
     
    
   </p>
   <h1 id="_idParaDest-216">
    <a id="_idTextAnchor215">
    </a>
    
     Introducing the Boost.Cobalt library
    
   </h1>
   <p>
    
     We introduced how C++20 supports coroutines in
    
    <a href="B22219_08.xhtml#_idTextAnchor164">
     
      <em class="italic">
       
        Chapter 8
       
      </em>
     
    </a>
    
     .
    
    
     It was made obvious that writing
    
    <a id="_idIndexMarker761">
    </a>
    
     coroutines is not an easy task due to two
    
    
     
      main reasons:
     
    
   </p>
   <ul>
    <li>
     
      Writing coroutines in C++ requires a certain amount of code to make the coroutine work but is not related to the functionality we want to implement.
     
     
      For example, the coroutine we wrote to generate the Fibonacci sequence was quite simple, but we had to implement the wrapper type, the promise, and all the functions required for it to
     
     
      
       be usable.
      
     
    </li>
    <li>
     
      The development of plain C++20 coroutines requires a good knowledge of the low-level aspects of how coroutines are implemented in C++, how the compiler transforms our code to implement all the mechanisms necessary to keep the coroutine state, and details about how the functions we must implement are called
     
     
      
       and when.
      
     
    </li>
   </ul>
   <p>
    
     Asynchronous programming is difficult enough without all those many details.
    
    
     It would be much better if we could focus on our program and be isolated from the lower-level concepts and code.
    
    
     We saw how C++23 introduced
    
    <strong class="source-inline">
     
      std::generator
     
    </strong>
    
     precisely to achieve this.
    
    
     Let us write just the generator code, and let the C++ Standard Library and compiler take care of the rest.
    
    
     It is expected that this coroutine support will improve in the next
    
    
     
      C++ version.
     
    
   </p>
   <p>
    
     Boost.Cobalt, one of the libraries included in the Boost C++ libraries, allows us to do just that – avoid the coroutines details.
    
    
     Boost.Cobalt was introduced in Boost 1.84 and requires C++20 because it relies on the language coroutines features.
    
    
     It is based on Boost.Asio, and we can use both libraries in
    
    
     
      our programs.
     
    
   </p>
   <p>
    
     The goal of Boost.Cobalt is to allow us to write simple single-threaded asynchronous code using coroutines – applications that can do multiple things simultaneously in a single thread.
    
    
     Of course, by simultaneously, we mean concurrently, not in parallel, because there
    
    <a id="_idIndexMarker762">
    </a>
    
     is only one thread.
    
    
     By using Boost.Asio multithreading features, we can execute coroutines in different threads, but in this chapter, we will focus on
    
    
     
      single-threaded applications.
     
    
   </p>
   <h2 id="_idParaDest-217">
    <a id="_idTextAnchor216">
    </a>
    
     Eager and lazy coroutines
    
   </h2>
   <p>
    
     Before we
    
    <a id="_idIndexMarker763">
    </a>
    
     introduce the coroutine types implemented by Boost.Cobalt, we need to define the two kinds
    
    
     
      of coroutines:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Eager coroutines
      
     </strong>
     
      : An eager coroutine begins execution as soon as it is called.
     
     
      This means
     
     <a id="_idIndexMarker764">
     </a>
     
      that the coroutine logic starts running immediately, and it progresses through its sequence until it hits a suspension point (such as
     
     <strong class="source-inline">
      
       co_await
      
     </strong>
     
      or
     
     <strong class="source-inline">
      
       co_yield
      
     </strong>
     
      ).
     
     
      The creation of the coroutine effectively starts its processing, and any side effects in its body will execute
     
     
      
       right away.
      
     
     <p class="list-inset">
      
       Eager coroutines are beneficial when you want the coroutine to initiate its work immediately upon being created, such as starting asynchronous network operations or
      
      
       
        preparing data.
       
      
     </p>
    </li>
    <li>
     <strong class="bold">
      
       Lazy coroutines
      
     </strong>
     
      : A lazy
     
     <a id="_idIndexMarker765">
     </a>
     
      coroutine defers its execution until is
     
     <a id="_idIndexMarker766">
     </a>
     
      explicitly awaited or used.
     
     
      The coroutine object can be created without any of its body running until the caller decides to interact with it (usually by awaiting it
     
     
      
       with
      
     
     
      <strong class="source-inline">
       
        co_await
       
      </strong>
     
     
      
       ).
      
     
     <p class="list-inset">
      
       Lazy coroutines are useful when you want to set up a coroutine but delay its execution until a certain condition is met or when you need to coordinate its execution with
      
      
       
        other tasks.
       
      
     </p>
    </li>
   </ul>
   <p>
    
     After defining eager and lazy coroutines we will describe the different types of coroutines implemented
    
    
     
      in Boost.Cobalt.
     
    
   </p>
   <h2 id="_idParaDest-218">
    <a id="_idTextAnchor217">
    </a>
    
     Boost.Cobalt coroutine types
    
   </h2>
   <p>
    
     Boost.Cobalt
    
    <a id="_idIndexMarker767">
    </a>
    
     implements four types of coroutines.
    
    
     We will introduce them in this section, and then see some examples later in
    
    
     
      the chapter:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Promise
      
     </strong>
     
      : This is the main coroutine type in Boost.Cobalt.
     
     
      It is used to implement asynchronous operations that return a single value (calling
     
     <strong class="source-inline">
      
       co_return
      
     </strong>
     
      ).
     
     
      It is an eager coroutine.
     
     
      It supports
     
     <strong class="source-inline">
      
       co_await
      
     </strong>
     
      , allowing asynchronous suspension and continuation.
     
     
      For example, a promise can be used to execute a network call that, when complete, will return its result without blocking
     
     
      
       other operations.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Task
      
     </strong>
     
      : Task is the lazy version of the promise.
     
     
      It will not begin execution until is explicitly awaited.
     
     
      It provides more flexibility in controlling when and how a coroutine runs.
     
     
      When awaited, the task starts execution, allowing for delayed processing of
     
     
      
       asynchronous operations.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Generator
      
     </strong>
     
      : In Boost.Cobalt, a generator is the only type of coroutine that can yield values.
     
     
      Each value is yielded individually using
     
     <strong class="source-inline">
      
       co_yield.
      
     </strong>
     
      Its functionality is like
     
     <strong class="source-inline">
      
       std::generator
      
     </strong>
     
      in C++23 but it allows waiting with
     
     <strong class="source-inline">
      
       co_await
      
     </strong>
     
      (
     
     
      <strong class="source-inline">
       
        std::generator
       
      </strong>
     
     
      
       doesn’t).
      
     
    </li>
    <li>
     <strong class="bold">
      
       Detached
      
     </strong>
     
      : This is an eager coroutine that can use
     
     <strong class="source-inline">
      
       co_await
      
     </strong>
     
      but not
     
     <strong class="source-inline">
      
       co_return
      
     </strong>
     
      values.
     
     
      It cannot be resumed and usually is
     
     
      
       not awaited.
      
     
    </li>
   </ul>
   <p>
    
     So far, we introduced Boost.Cobalt.
    
    
     We defined what eager and lazy coroutines are and then we defined the four main types of coroutines in
    
    
     
      the library.
     
    
   </p>
   <p>
    
     In the next section, we will dive into one of the most important topics related to Boost.Cobalt – generators.
    
    
     We will also implement a few simple examples
    
    
     
      of generators.
     
    
   </p>
   <h1 id="_idParaDest-219">
    <a id="_idTextAnchor218">
    </a>
    
     Boost.Cobalt generators
    
   </h1>
   <p>
    
     As discussed in
    
    <a href="B22219_08.xhtml#_idTextAnchor164">
     
      <em class="italic">
       
        Chapter 8
       
      </em>
     
    </a>
    
     ,
    
    <strong class="bold">
     
      generator coroutines
     
    </strong>
    
     are specialized coroutines designed to yield
    
    <a id="_idIndexMarker768">
    </a>
    
     values incrementally.
    
    
     After each value is yielded, the coroutine suspends itself until the caller requests the next value.
    
    
     In Boost.Cobalt, generators work in the same way.
    
    
     They are the only coroutine type that can yield values.
    
    
     This makes generators essential when you need a coroutine to produce multiple values
    
    
     
      over time.
     
    
   </p>
   <p>
    
     One key characteristic of Boost.Cobalt generators is that they are eager by default, meaning they start execution immediately after being called.
    
    
     Additionally, these generators
    
    <a id="_idIndexMarker769">
    </a>
    
     are asynchronous, allowing them to use
    
    <strong class="source-inline">
     
      co_await
     
    </strong>
    
     , an important difference from
    
    <strong class="source-inline">
     
      std::generator
     
    </strong>
    
     introduced in C++23, which is lazy and doesn’t
    
    
     
      support
     
    
    
     <strong class="source-inline">
      
       co_await
      
     </strong>
    
    
     
      .
     
    
   </p>
   <h2 id="_idParaDest-220">
    <a id="_idTextAnchor219">
    </a>
    
     Looking at a basic example
    
   </h2>
   <p>
    
     Let’s begin
    
    <a id="_idIndexMarker770">
    </a>
    
     with the simplest Boost.Cobalt program.
    
    
     This example is not that of a generator, but we will explain some important details with
    
    
     
      its help:
     
    
   </p>
   <pre class="source-code">
#include &lt;iostream&gt;
#include &lt;boost/cobalt.hpp&gt;
boost::cobalt::main co_main(int argc, char* argv[]) {
    std::cout &lt;&lt; "Hello Boost.Cobalt\n";
    co_return 0;
}</pre>
   <p>
    
     In the preceding code, we observe
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      To use Boost.Cobalt, the
     
     <strong class="source-inline">
      
       &lt;boost/cobalt.hpp&gt;
      
     </strong>
     
      header file must
     
     
      
       be included.
      
     
    </li>
    <li>
     
      You also must link the Boost.Cobalt library to your application.
     
     
      We supply a
     
     <strong class="source-inline">
      
       CMakeLists.txt
      
     </strong>
     
      file to do just that, not only for Boost.Cobalt but for all the required Boost libraries.
     
     
      To link Boost.Cobalt explicitly (that is, not all the required Boost libraries), just add the following line to your
     
     
      <strong class="source-inline">
       
        CMakeLists.txt
       
      </strong>
     
     
      
       file:
      
     
     <pre class="source-code">
target_link_libraries(${EXEC_NAME} Boost::cobalt)</pre>
    </li>
    <li>
     
      Use of the
     
     <strong class="source-inline">
      
       co_main
      
     </strong>
     
      function.
     
     
      Instead of the usual
     
     <strong class="source-inline">
      
       main
      
     </strong>
     
      function, Boost.Cobalt introduces a coroutine-based entry point called
     
     <strong class="source-inline">
      
       co_main
      
     </strong>
     
      .
     
     
      This function can use coroutine-specific keywords such as
     
     <strong class="source-inline">
      
       co_return
      
     </strong>
     
      .
     
     
      Boost.Cobalt implements the required
     
     <strong class="source-inline">
      
       main
      
     </strong>
     
      
       function internally.
      
     
     <p class="list-inset">
      
       Using
      
      <strong class="source-inline">
       
        co_main
       
      </strong>
      
       will let you implement the
      
      <strong class="source-inline">
       
        main
       
      </strong>
      
       function (entry point) of your program as a coroutine, thus being able to call
      
      <strong class="source-inline">
       
        co_await
       
      </strong>
      
       and
      
      <strong class="source-inline">
       
        co_return
       
      </strong>
      
       .
      
      
       Remember from
      
      <a href="B22219_08.xhtml#_idTextAnchor164">
       
        <em class="italic">
         
          Chapter 8
         
        </em>
       
      </a>
      
       that the
      
      <strong class="source-inline">
       
        main
       
      </strong>
      
       function cannot be
      
      
       
        a coroutine.
       
      
     </p>
     <p class="list-inset">
      
       If you cannot change your current
      
      <strong class="source-inline">
       
        main
       
      </strong>
      
       function, it is possible to use Boost.Cobalt.
      
      
       You just need to call a function, which will be the top-level function
      
      <a id="_idIndexMarker771">
      </a>
      
       of your asynchronous code using Boost.Cobalt, from
      
      <strong class="source-inline">
       
        main
       
      </strong>
      
       .
      
      
       In fact, this is what Boost.Cobalt is doing: it implements a
      
      <strong class="source-inline">
       
        main
       
      </strong>
      
       function, which is the entry point of the program, and that (hidden to you)
      
      <strong class="source-inline">
       
        main
       
      </strong>
      
       function
      
      
       
        calls
       
      
      
       <strong class="source-inline">
        
         co_main
        
       </strong>
      
      
       
        .
       
      
     </p>
     <p class="list-inset">
      
       The easiest way to use your own
      
      <strong class="source-inline">
       
        main
       
      </strong>
      
       function would be something
      
      
       
        like this:
       
      
     </p>
     <pre class="source-code">
cobalt::task&lt;int&gt; async_task() {
    // your code here
    // …
    return 0;
}
int main() {
    // main function code
    // …
    return cobalt::run(async_code();
}</pre>
    </li>
   </ul>
   <p>
    
     The example simply prints a greeting message and then returns 0 calling
    
    <strong class="source-inline">
     
      co_await
     
    </strong>
    
     .
    
    
     In all future examples, we will follow this pattern: including the
    
    <strong class="source-inline">
     
      &lt;boost/cobalt.hpp&gt;
     
    </strong>
    
     header file and using
    
    <strong class="source-inline">
     
      co_main
     
    </strong>
    
     instead
    
    
     
      of
     
    
    
     <strong class="source-inline">
      
       main
      
     </strong>
    
    
     
      .
     
    
   </p>
   <h2 id="_idParaDest-221">
    <a id="_idTextAnchor220">
    </a>
    
     Boost.Cobalt simple generators
    
   </h2>
   <p>
    
     Armed
    
    <a id="_idIndexMarker772">
    </a>
    
     with the knowledge from our previous basic example, we will implement a very simple
    
    
     
      generator coroutine:
     
    
   </p>
   <pre class="source-code">
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;boost/cobalt.hpp&gt;
using namespace std::chrono_literals;
using namespace boost;
cobalt::generator&lt;int&gt; basic_generator()
{
    std::this_thread::sleep_for(1s);
    co_yield 1;
    std::this_thread::sleep_for(1s);
    co_return 0;
}
cobalt::main co_main(int argc, char* argv[]) {
    auto g = basic_generator();
    std::cout &lt;&lt; co_await g &lt;&lt; std::endl;
    std::cout &lt;&lt; co_await g &lt;&lt; std::endl;
    co_return 0;
}</pre>
   <p>
    
     The preceding code shows a simple generator that yields an integer value (using
    
    <strong class="source-inline">
     
      co_yield
     
    </strong>
    
     ) and returns another one (
    
    
     
      using
     
    
    
     <strong class="source-inline">
      
       co_return
      
     </strong>
    
    
     
      ).
     
    
   </p>
   <p>
    <strong class="source-inline">
     
      cobalt::generator
     
    </strong>
    
     is a
    
    
     <strong class="source-inline">
      
       struct
      
     </strong>
    
    
     
      template:
     
    
   </p>
   <pre class="source-code">
template&lt;typename Yield, typename Push = void&gt;
struct generator</pre>
   <p>
    
     The two
    
    <a id="_idIndexMarker773">
    </a>
    
     parameter types are
    
    
     
      as follows:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       Yield
      
     </strong>
     
      : The generated
     
     
      
       object type
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       Push
      
     </strong>
     
      : The input parameter type (defaults
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        void
       
      </strong>
     
     
      
       )
      
     
    </li>
   </ul>
   <p>
    
     The
    
    <strong class="source-inline">
     
      co_main
     
    </strong>
    
     function prints both numbers after getting them using
    
    <strong class="source-inline">
     
      co_await
     
    </strong>
    
     (the caller waits for the values to be available).
    
    
     We have introduced some delays to simulate the processing a generator must do to generate
    
    
     
      the numbers.
     
    
   </p>
   <p>
    
     Our second generator will yield the square of
    
    
     
      an integer:
     
    
   </p>
   <pre class="source-code">
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;boost/cobalt.hpp&gt;
using namespace std::chrono_literals;
using namespace boost;
cobalt::generator&lt;int, int&gt; square_generator(int x){
    while (x != 0) {
        x = co_yield x * x;
    }
    co_return 0;
}
cobalt::main co_main(int argc, char* argv[]){
    auto g = square_generator(10);
    std::cout &lt;&lt; co_await g(4) &lt;&lt; std::endl;
    std::cout &lt;&lt; co_await g(12) &lt;&lt; std::endl;
    std::cout &lt;&lt; co_await g(0) &lt;&lt; std::endl;
    co_return 0;
}</pre>
   <p>
    
     In this example,
    
    <strong class="source-inline">
     
      square_generator
     
    </strong>
    
     yields the square of the
    
    <strong class="source-inline">
     
      x
     
    </strong>
    
     parameter.
    
    
     This shows
    
    <a id="_idIndexMarker774">
    </a>
    
     how we can
    
    <em class="italic">
     
      push
     
    </em>
    
     values to a Boost.Cobalt generator.
    
    
     In Boost.Cobalt, pushing values to a generator means passing parameters (in the preceding example, the passed parameters
    
    
     
      are integers).
     
    
   </p>
   <p>
    
     The generator in this example, though correct, can be confusing.
    
    
     Take a look at the following line
    
    
     
      of code:
     
    
   </p>
   <pre class="source-code">
auto g = square_generator(10);</pre>
   <p>
    
     This creates the generator object with
    
    <strong class="source-inline">
     
      10
     
    </strong>
    
     as the initial value.
    
    
     Then, look at the following line
    
    
     
      of code:
     
    
   </p>
   <pre class="source-code">
std::cout &lt;&lt; co_await g(4) &lt;&lt; std::endl;</pre>
   <p>
    
     This will print the square of
    
    <strong class="source-inline">
     
      10
     
    </strong>
    
     and will push
    
    <strong class="source-inline">
     
      4
     
    </strong>
    
     to the generator.
    
    
     As you can see, the printed values are not the squares of the values passed to the generator.
    
    
     This is because the generator is initialized with one value (in this example,
    
    <strong class="source-inline">
     
      10
     
    </strong>
    
     ), and it generates the squared value when the caller calls
    
    <strong class="source-inline">
     
      co_await
     
    </strong>
    
     to pass another value.
    
    
     The generator will yield
    
    <strong class="source-inline">
     
      100
     
    </strong>
    
     when receiving the new value,
    
    <strong class="source-inline">
     
      4
     
    </strong>
    
     , then it will yield
    
    <strong class="source-inline">
     
      16
     
    </strong>
    
     when receiving the value of
    
    <strong class="source-inline">
     
      12
     
    </strong>
    
     , and
    
    
     
      so on.
     
    
   </p>
   <p>
    
     We said
    
    <a id="_idIndexMarker775">
    </a>
    
     that Boost.Cobalt generators are eager, but it is possible to make them wait (
    
    <strong class="source-inline">
     
      co_await
     
    </strong>
    
     ) as soon as they start executing.
    
    
     The following example shows how to
    
    
     
      do it:
     
    
   </p>
   <pre class="source-code">
#include &lt;iostream&gt;
#include &lt;boost/cobalt.hpp&gt;
boost::cobalt::generator&lt;int, int&gt; square_generator() {
    auto x = co_await boost::cobalt::this_coro::initial;
    while (x != 0) {
        x = co_yield x * x;
    }
    co_return 0;
}
boost::cobalt::main co_main(int, char*[]) {
    auto g = square_generator();
    std::cout &lt;&lt; co_await g(4) &lt;&lt; std::endl;
    std::cout &lt;&lt; co_await g(10) &lt;&lt; std::endl;
    std::cout &lt;&lt; co_await g(12) &lt;&lt; std::endl;
    std::cout &lt;&lt; co_await g(0) &lt;&lt; std::endl;
    co_return 0;
}</pre>
   <p>
    
     The code
    
    <a id="_idIndexMarker776">
    </a>
    
     is very similar to the previous example, but there are
    
    
     
      some differences:
     
    
   </p>
   <ul>
    <li>
     
      We create the generator without any parameter being passed
     
     
      
       to it:
      
     
     <pre class="source-code">
auto g = square_generator();</pre>
    </li>
    <li>
     
      Take a look at the first line of the
     
     
      
       generator’s code:
      
     
     <pre class="source-code">
auto x = co_await boost::cobalt::this_coro::initial;</pre>
     <p class="list-inset">
      
       This makes the generator wait for the first pushed integer.
      
      
       This behaves as a lazy generator (in fact, it starts executing immediately because the generator is eager, but the first thing it does is wait for
      
      
       
        an integer).
       
      
     </p>
    </li>
    <li>
     
      The yielded values are what we would expect from
     
     
      
       the code:
      
     
     <pre class="source-code">
std::cout &lt;&lt; co_await g(10) &lt;&lt; std::endl;</pre>
     <p class="list-inset">
      
       This will print
      
      <strong class="source-inline">
       
        100
       
      </strong>
      
       instead of the square of the previously
      
      
       
        pushed integer.
       
      
     </p>
    </li>
   </ul>
   <p>
    
     Let’s summarize here what the example does: the
    
    <strong class="source-inline">
     
      co_main
     
    </strong>
    
     function calls the
    
    <strong class="source-inline">
     
      square_generator
     
    </strong>
    
     coroutine to generate the square of an integer value.
    
    
     The generator coroutine suspends itself at the beginning waiting for the first integer and it suspends itself after yielding each square.
    
    
     The example is easy on purpose, just to illustrate how to write a generator
    
    
     
      using Boost.Cobalt.
     
    
   </p>
   <p>
    
     An important feature of the preceding program is that it runs in a single thread.
    
    
     This means that
    
    <strong class="source-inline">
     
      co_main
     
    </strong>
    
     and the generator coroutine run one
    
    
     
      after another.
     
    
   </p>
   <h2 id="_idParaDest-222">
    <a id="_idTextAnchor221">
    </a>
    
     A Fibonacci sequence generator
    
   </h2>
   <p>
    
     In this section, we will implement a Fibonacci sequence generator like the one we implemented in
    
    <a href="B22219_08.xhtml#_idTextAnchor164">
     
      <em class="italic">
       
        Chapter 8
       
      </em>
     
    </a>
    
     .
    
    
     This will let us see how much easier is writing generator coroutines with Boost.Cobalt than with pure C++20 without using any
    
    
     
      coroutines library.
     
    
   </p>
   <p>
    
     We
    
    <a id="_idIndexMarker777">
    </a>
    
     have written two versions of the generator.
    
    
     The first one calculates an arbitrary term of the Fibonacci sequence.
    
    
     We push the term we want to generate, and we get it.
    
    
     This generator uses a lambda as a
    
    
     
      Fibonacci calculator:
     
    
   </p>
   <pre class="source-code">
boost::cobalt::generator&lt;int, int&gt; fibonacci_term() {
    auto fibonacci = [](int n) {
        if (n &lt; 2) {
            return n;
        }
        int f0 = 0;
        int f1 = 1;
        int f;
        for (int i = 2; i &lt;= n; ++i) {
            f = f0 + f1;
            f0 = f1;
            f1 = f;
        }
        return f;
    };
    auto x = co_await boost::cobalt::this_coro::initial;
    while (x != -1) {
        x = co_yield fibonacci(x);
    }
    co_return 0;
 }</pre>
   <p>
    
     In the preceding code, we see that this generator is very similar to the one we implemented in the previous section to calculate the square of a number.
    
    
     At the beginning of the coroutine, we have
    
    
     
      the following:
     
    
   </p>
   <pre class="source-code">
auto x = co_await boost::cobalt::this_coro::initial;</pre>
   <p>
    
     This
    
    <a id="_idIndexMarker778">
    </a>
    
     line of code suspends the coroutine to wait for the first
    
    
     
      input value.
     
    
   </p>
   <p>
    
     And then we have
    
    
     
      the following:
     
    
   </p>
   <pre class="source-code">
while (x != -1) {
        x = co_yield fibonacci(x);
    }</pre>
   <p>
    
     This generates the requested Fibonacci sequence term and suspends itself until the next term is requested.
    
    
     While the requested term is not equal to
    
    <strong class="source-inline">
     
      -1
     
    </strong>
    
     , we can go on requesting more values until pushing
    
    <strong class="source-inline">
     
      -1
     
    </strong>
    
     terminates
    
    
     
      the coroutine.
     
    
   </p>
   <p>
    
     The next version of the Fibonacci generator will yield an infinite number of terms as they are requested.
    
    
     By
    
    <em class="italic">
     
      infinite
     
    </em>
    
     we mean
    
    <em class="italic">
     
      potentially infinite
     
    </em>
    
     .
    
    
     Think about this generator as always ready to yield one more Fibonacci
    
    
     
      sequence number:
     
    
   </p>
   <pre class="source-code">
boost::cobalt::generator&lt;int&gt; fibonacci_sequence() {
    int f0 = 0;
    int f1 = 1;
    int f = 0;
    while (true) {
        co_yield f0;
        f = f0 + f1;
        f0 = f1;
        f1 = f;
    }
}</pre>
   <p>
    
     The preceding code is easy to understand: the coroutine yields a value and suspends itself
    
    <a id="_idIndexMarker779">
    </a>
    
     until another one is requested and the coroutine calculates the new value and yields it and suspends itself again in an
    
    
     
      infinite loop.
     
    
   </p>
   <p>
    
     In this case, we can see the advantage of a coroutine: we can generate the terms of the Fibonacci sequence, one after another, whenever we need them.
    
    
     We don’t need to keep any state to generate the next term because the state is kept in
    
    
     
      the coroutine.
     
    
   </p>
   <p>
    
     Also note that even if the function executes an infinite loop, because it is a coroutine, it suspends and resumes again and again, avoiding blocking the
    
    
     
      current thread.
     
    
   </p>
   <h1 id="_idParaDest-223">
    <a id="_idTextAnchor222">
    </a>
    
     Boost.Cobalt tasks and promises
    
   </h1>
   <p>
    
     As we have already seen in this chapter, Boost.Cobalt promises are eager coroutines that return one value and Boost.Cobalt tasks are the lazy version
    
    
     
      of promises.
     
    
   </p>
   <p>
    
     We can
    
    <a id="_idIndexMarker780">
    </a>
    
     see them as just functions that don’t yield multiple values like generators do.
    
    
     We can call a promise repeatedly to get more than one value, but the state won’t be kept between calls (as in generators).
    
    
     Basically, a promise is a coroutine that can use
    
    <strong class="source-inline">
     
      co_await
     
    </strong>
    
     (it can use
    
    
     <strong class="source-inline">
      
       co_return
      
     </strong>
    
    
     
      too).
     
    
   </p>
   <p>
    
     Different use cases of promises would be a socket listener to receive network packets, process them, make queries to a database, and then generate some results from the data.
    
    
     In general, their functionality requires asynchronously waiting for some result and then performing some processing on that result (or maybe just returning it to
    
    
     
      the caller).
     
    
   </p>
   <p>
    
     Our first
    
    <a id="_idIndexMarker781">
    </a>
    
     example is a simple promise that generates one random number (this can be done with a
    
    
     
      generator too):
     
    
   </p>
   <pre class="source-code">
#include &lt;iostream&gt;
#include &lt;random&gt;
#include &lt;boost/cobalt.hpp&gt;
boost::cobalt::promise&lt;int&gt; random_number(int min, int max) {
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution&lt;&gt; dist(min, max);
    co_return dist(gen);
}
boost::cobalt::promise&lt;int&gt; random(int min, int max) {
    int res = co_await random_number(min, max);
    co_return res;
}
boost::cobalt::main co_main(int, char*[]) {
    for (int i = 0; i &lt; 10; ++i) {
        auto r = random(1, 100);
        std::cout &lt;&lt; "random number between 1 and 100: "
                  &lt;&lt; co_await r &lt;&lt; std::endl;
    }
    co_return 0;
}</pre>
   <p>
    
     In the
    
    <a id="_idIndexMarker782">
    </a>
    
     preceding code, we have written
    
    
     
      three coroutines:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       co_main
      
     </strong>
     
      : Remember that in Boost.Cobalt,
     
     <strong class="source-inline">
      
       co_main
      
     </strong>
     
      is a coroutine and it calls
     
     <strong class="source-inline">
      
       co_return
      
     </strong>
     
      to return
     
     
      
       a value.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       random()
      
     </strong>
     
      : This coroutine returns a random number to the caller.
     
     
      It calls
     
     <strong class="source-inline">
      
       random()
      
     </strong>
     
      with
     
     <strong class="source-inline">
      
       co_await
      
     </strong>
     
      to generate the random number.
     
     
      It asynchronously waits for the random number to
     
     
      
       be generated.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       random_number()
      
     </strong>
     
      : This coroutine generates a uniformly distributed random number between two values,
     
     <strong class="source-inline">
      
       min
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       max
      
     </strong>
     
      , and returns it to the caller.
     
     <strong class="source-inline">
      
       random_number()
      
     </strong>
     
      is also
     
     
      
       a promise.
      
     
    </li>
   </ul>
   <p>
    
     The following coroutine returns a
    
    <strong class="source-inline">
     
      std::vector&lt;int&gt;
     
    </strong>
    
     of random numbers.
    
    <strong class="source-inline">
     
      co_await random_number()
     
    </strong>
    
     is called in a loop to generate a vector of
    
    <strong class="source-inline">
     
      n
     
    </strong>
    
     
      random numbers:
     
    
   </p>
   <pre class="source-code">
boost::cobalt::promise&lt;std::vector&lt;int&gt;&gt; random_vector(int min, int max, int n) {
    std::vector&lt;int&gt; rv(n);
    for (int i = 0; i &lt; n; ++i) {
        rv[i] = co_await random_number(min, max);
    }
    co_return rv;
}</pre>
   <p>
    
     The preceding function returns a promise of
    
    <strong class="source-inline">
     
      std::vector&lt;int&gt;
     
    </strong>
    
     .
    
    
     To access the vector, we need to
    
    
     
      call
     
    
    
     <strong class="source-inline">
      
       get()
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
auto v = random_vector(1, 100, 20);
for (int n : v.get()) {
    std::cout &lt;&lt; n &lt;&lt; " ";
}
std::cout &lt;&lt; std::endl;</pre>
   <p>
    
     The previous code prints the elements of the
    
    <strong class="source-inline">
     
      v
     
    </strong>
    
     vector.
    
    
     To access the vector, we need to
    
    
     
      call
     
    
    
     <strong class="source-inline">
      
       v.get()
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     We are
    
    <a id="_idIndexMarker783">
    </a>
    
     going to implement a second example to illustrate how the execution of promises and
    
    
     
      tasks differ:
     
    
   </p>
   <pre class="source-code">
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;boost/cobalt.hpp&gt;
void sleep(){
    std::this_thread::sleep_for(std::chrono::seconds(2));
}
boost::cobalt::promise&lt;int&gt; eager_promise(){
    std::cout &lt;&lt; "Eager promise started\n";
    sleep();
    std::cout &lt;&lt; "Eager promise done\n";
    co_return 1;
}
boost::cobalt::task&lt;int&gt; lazy_task(){
    std::cout &lt;&lt; "Lazy task started\n";
    sleep();
    std::cout &lt;&lt; "Lazy task done\n";
    co_return 2;
}
boost::cobalt::main co_main(int, char*[]){
    std::cout &lt;&lt; "Calling eager_promise...\n";
    auto promise_result = eager_promise();
    std::cout &lt;&lt; "Promise called, but not yet awaited.\n";
    std::cout &lt;&lt; "Calling lazy_task...\n";
    auto task_result = lazy_task();
    std::cout &lt;&lt; "Task called, but not yet awaited.\n";
    std::cout &lt;&lt; "Awaiting both results...\n";
    int promise_value = co_await promise_result;
    std::cout &lt;&lt; "Promise value: " &lt;&lt; promise_value
              &lt;&lt; std::endl;
    int task_value = co_await task_result;
    std::cout &lt;&lt; "Task value: " &lt;&lt; task_value
              &lt;&lt; std::endl;
    co_return 0;
}</pre>
   <p>
    
     In this example, we have implemented two coroutines: a promise and a task.
    
    
     As we have already said, the promise is eager and it starts executing as soon as it’s called.
    
    
     The task is lazy and it’s suspended after
    
    
     
      being called.
     
    
   </p>
   <p>
    
     When we run the program, it prints all the messages, which let us know exactly how the
    
    
     
      coroutines execute.
     
    
   </p>
   <p>
    
     After the
    
    <a id="_idIndexMarker784">
    </a>
    
     first three lines of
    
    <strong class="source-inline">
     
      co_main()
     
    </strong>
    
     are executed, the printed output is
    
    
     
      the following:
     
    
   </p>
   <pre class="console">
Calling eager_promise...
Eager promise started
Eager promise done
Promise called, but not yet awaited.</pre>
   <p>
    
     From these messages, we know that the promise has been executed until the call
    
    
     
      to
     
    
    
     <strong class="source-inline">
      
       co_return
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     After the next three lines of
    
    <strong class="source-inline">
     
      co_main()
     
    </strong>
    
     are executed, the printed output has these
    
    
     
      new messages:
     
    
   </p>
   <pre class="console">
Calling lazy_task...
Task called, but not yet awaited.</pre>
   <p>
    
     Here, we see that the task has not been executed.
    
    
     It is a lazy coroutine and, for this reason, it just suspends immediately after being called and no messages are printed by this coroutine
    
    
     
      just yet.
     
    
   </p>
   <p>
    
     Three more lines of
    
    <strong class="source-inline">
     
      co_main()
     
    </strong>
    
     are executed, and these are the new messages in the
    
    
     
      program’s output:
     
    
   </p>
   <pre class="console">
Awaiting both results...
Promise value: 1</pre>
   <p>
    
     The call to
    
    <strong class="source-inline">
     
      co_await
     
    </strong>
    
     on the promise gives us its result (in this case, set to
    
    <strong class="source-inline">
     
      1
     
    </strong>
    
     ) and its
    
    
     
      execution ends.
     
    
   </p>
   <p>
    
     Finally, we call
    
    <strong class="source-inline">
     
      co_await
     
    </strong>
    
     on the task, and it then executes and returns its value (which, in this case, is set to
    
    <strong class="source-inline">
     
      2
     
    </strong>
    
     ).
    
    
     The output is
    
    
     
      the following:
     
    
   </p>
   <pre class="console">
Lazy task started
Lazy task done
Task value: 2</pre>
   <p>
    
     This example shows how tasks are lazy and start suspended and only resume executing when the caller calls
    
    <strong class="source-inline">
     
      co_await
     
    </strong>
    
     
      on them.
     
    
   </p>
   <p>
    
     In this section, we have seen that, as in the case of generators, it is much easier to write promise
    
    <a id="_idIndexMarker785">
    </a>
    
     and task coroutines using Boost.Cobalt than just using plain C++.
    
    
     We don’t need to write all the support code that C++ requires to implement coroutines.
    
    
     We have also seen the main difference between tasks
    
    
     
      and promises.
     
    
   </p>
   <p>
    
     In the next section, we will study an example of a channel, a communication mechanism between two coroutines in a
    
    
     
      producer/consumer model.
     
    
   </p>
   <h1 id="_idParaDest-224">
    <a id="_idTextAnchor223">
    </a>
    
     Boost.Cobalt channels
    
   </h1>
   <p>
    
     In Boost.Cobalt, channels provide a way for coroutines to communicate asynchronously, allowing
    
    <a id="_idIndexMarker786">
    </a>
    
     data transfer between a producer and a consumer coroutine in a safe and efficient manner.
    
    
     They are inspired by Golang channels and allow communication through message passing, promoting a
    
    
     <em class="italic">
      
       share-memory-by-communicating
      
     </em>
    
    
     
      paradigm.
     
    
   </p>
   <p>
    
     A
    
    <strong class="bold">
     
      channel
     
    </strong>
    
     is a mechanism
    
    <a id="_idIndexMarker787">
    </a>
    
     through which values are asynchronously passed from one coroutine (the producer) to another (the consumer).
    
    
     This communication is non-blocking, which means that coroutines can suspend their execution when they wait for data to be available on the channel or when they write data to a channel that has limited capacity.
    
    
     Let’s clarify this: both reading and writing operations may be blocking, depending on the buffer size if, by
    
    <em class="italic">
     
      blocking
     
    </em>
    
     , we mean coroutines are suspended, but on the other hand, from the point of view of threads, these operations don’t block
    
    
     
      the thread.
     
    
   </p>
   <p>
    
     If the buffer size is zero, a read and a write will need to occur at the same time and act as a rendezvous (synchronous communication).
    
    
     If the channel size is bigger than zero and the buffer is not full, the write operation will not suspend the coroutine.
    
    
     Likewise, if the buffer is not empty, the read operation will
    
    
     
      not suspend.
     
    
   </p>
   <p>
    
     Similar to Golang channels, Boost.Cobalt channels are strongly typed.
    
    
     A channel is defined for a specific type, and only that type can be sent through it.
    
    
     For example, a channel of the
    
    <strong class="source-inline">
     
      int
     
    </strong>
    
     type (
    
    <strong class="source-inline">
     
      boost::cobalt::channel&lt;int&gt;
     
    </strong>
    
     ) can only
    
    
     
      transmit integers.
     
    
   </p>
   <p>
    
     Let’s
    
    <a id="_idIndexMarker788">
    </a>
    
     now see an example of
    
    
     
      a channel:
     
    
   </p>
   <pre class="source-code">
#include &lt;iostream&gt;
#include &lt;boost/cobalt.hpp&gt;
#include &lt;boost/asio.hpp&gt;
boost::cobalt::promise&lt;void&gt; producer(boost::cobalt::channel&lt;int&gt;&amp; ch) {
    for (int i = 1; i &lt;= 10; ++i) {
        std::cout &lt;&lt; "Producer waiting for request\n";
        co_await ch.write(i);
        std::cout &lt;&lt; "Producing value " &lt;&lt; i &lt;&lt; std::endl;
    }
    std::cout &lt;&lt; "Producer end\n";
    ch.close();
    co_return;
}
boost::cobalt::main co_main(int, char*[]) {
    boost::cobalt::channel&lt;int&gt; ch;
    auto p = producer(ch);
    while (ch.is_open()) {
        std::cout &lt;&lt; "Consumer waiting for next number \n";
        std::this_thread::sleep_for(std::chrono::seconds(5));
        auto n = co_await ch.read();
        std::cout &lt;&lt; "Consuming value " &lt;&lt; n &lt;&lt; std::endl;
        std::cout &lt;&lt; n * n &lt;&lt; std::endl;
    }
    co_await p;
    co_return 0;
}</pre>
   <p>
    
     In this example, we create a size
    
    <strong class="source-inline">
     
      0
     
    </strong>
    
     channel and two coroutines: the
    
    <strong class="source-inline">
     
      producer
     
    </strong>
    
     promise and
    
    <strong class="source-inline">
     
      co_main()
     
    </strong>
    
     , which acts as the consumer.
    
    
     The producer writes integers to the channel and the consumer reads them back and prints
    
    
     
      them squared.
     
    
   </p>
   <p>
    
     We added
    
    <strong class="source-inline">
     
      std::this_thread::sleep
     
    </strong>
    
     to delay the program execution and, hence, be able
    
    <a id="_idIndexMarker789">
    </a>
    
     to see what happens as the program runs.
    
    
     Let’s see an excerpt of the example’s output to see how
    
    
     
      it works:
     
    
   </p>
   <pre class="console">
Producer waiting for request
Consumer waiting for next number
Producing value 1
Producer waiting for request
Consuming value 1
1
Consumer waiting for next number
Producing value 2
Producer waiting for request
Consuming value 2
4
Consumer waiting for next number
Producing value 3
Producer waiting for request
Consuming value 3
9
Consumer waiting for next number</pre>
   <p>
    
     Both the consumer and the producer wait for the next action to happen.
    
    
     The producer will always wait for the consumer to request the next item.
    
    
     This is basically how generators work, and it is a very common pattern in asynchronous code
    
    
     
      using coroutines.
     
    
   </p>
   <p>
    
     The consumer executes the following line
    
    
     
      of code:
     
    
   </p>
   <pre class="source-code">
auto n = co_await ch.read();</pre>
   <p>
    
     Then, the producer
    
    <a id="_idIndexMarker790">
    </a>
    
     writes the next number to the channel and waits for the next request.
    
    
     This is done in the following line
    
    
     
      of code:
     
    
   </p>
   <pre class="source-code">
co_await ch.write(i);</pre>
   <p>
    
     You can see in the fourth line of the previous output excerpt how the producer goes back to waiting for the
    
    
     
      next request.
     
    
   </p>
   <p>
    
     Boost.Cobalt channels make writing this kind of asynchronous code very clean and easy
    
    
     
      to understand.
     
    
   </p>
   <p>
    
     The example shows both coroutines communicating through
    
    
     
      a channel.
     
    
   </p>
   <p>
    
     That wraps up this section.
    
    
     The next one will introduce synchronization functions – mechanisms to wait for more than
    
    
     
      one coroutine.
     
    
   </p>
   <h1 id="_idParaDest-225">
    <a id="_idTextAnchor224">
    </a>
    
     Boost.Cobalt synchronization functions
    
   </h1>
   <p>
    
     Previously, we implemented coroutines, and, in every case in which we called
    
    <strong class="source-inline">
     
      co_await
     
    </strong>
    
     , we did it for just one coroutine.
    
    
     This means we waited for the result of only one
    
    <a id="_idIndexMarker791">
    </a>
    
     coroutine.
    
    
     Boost.Cobalt has mechanisms that allow us to wait on more than one coroutine.
    
    
     These mechanisms are called
    
    
     <strong class="bold">
      
       synchronization functions
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     There are
    
    <a id="_idIndexMarker792">
    </a>
    
     four synchronization functions implemented
    
    
     
      in Boost.Cobalt:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       race
      
     </strong>
     
      : The
     
     <strong class="source-inline">
      
       race
      
     </strong>
     
      function
     
     <a id="_idIndexMarker793">
     </a>
     
      waits for one
     
     <a id="_idIndexMarker794">
     </a>
     
      coroutine out of a set to complete, but it does so in a pseudo-random manner.
     
     
      This mechanism helps avoid starvation of coroutines, ensuring that one coroutine doesn’t dominate the execution flow over others.
     
     
      When you have multiple asynchronous operations and you want the first to finish to determine the flow,
     
     <strong class="source-inline">
      
       race
      
     </strong>
     
      will allow any coroutine that becomes ready to proceed in a
     
     
      
       non-deterministic order.
      
     
     <p class="list-inset">
      
       When you
      
      <a id="_idIndexMarker795">
      </a>
      
       have multiple tasks (tasks in the generic sense, not Boost.Cobalt tasks) and are interested in completing one first, without preference
      
      <a id="_idIndexMarker796">
      </a>
      
       as to which one, but want to prevent one coroutine from always winning in situations where readiness is simultaneous, you will
      
      
       
        use
       
      
      
       <strong class="source-inline">
        
         race
        
       </strong>
      
      
       
        .
       
      
     </p>
    </li>
    <li>
     <strong class="bold">
      
       join
      
     </strong>
     
      : The
     
     <strong class="source-inline">
      
       join
      
     </strong>
     
      function waits for all the coroutines in a given set to complete and return
     
     <a id="_idIndexMarker797">
     </a>
     
      their results as values.
     
     
      If any
     
     <a id="_idIndexMarker798">
     </a>
     
      of the coroutines throws an exception,
     
     <strong class="source-inline">
      
       join
      
     </strong>
     
      will propagate the exception to the caller.
     
     
      It’s a way to gather results from multiple asynchronous operations that must all finish
     
     
      
       before proceeding.
      
     
     <p class="list-inset">
      
       You will use
      
      <strong class="source-inline">
       
        join
       
      </strong>
      
       when you need the result of multiple asynchronous operations together and want to throw an error if any of
      
      
       
        them fail.
       
      
     </p>
    </li>
    <li>
     <strong class="bold">
      
       gather
      
     </strong>
     
      : The
     
     <strong class="source-inline">
      
       gather
      
     </strong>
     
      function, like
     
     <strong class="source-inline">
      
       join
      
     </strong>
     
      , waits for a set of coroutines to complete, but it
     
     <a id="_idIndexMarker799">
     </a>
     
      handles exceptions differently.
     
     
      Instead of throwing
     
     <a id="_idIndexMarker800">
     </a>
     
      an exception immediately when one of the coroutines fails,
     
     <strong class="source-inline">
      
       gather
      
     </strong>
     
      captures each coroutine’s result individually.
     
     
      This means that you can inspect the outcome (success or failure) of each
     
     
      
       coroutine independently.
      
     
     <p class="list-inset">
      
       When you need all asynchronous operations to complete but you want to capture all results and exceptions individually to handle them separately, you will
      
      
       
        use
       
      
      
       <strong class="source-inline">
        
         gather
        
       </strong>
      
      
       
        .
       
      
     </p>
    </li>
    <li>
     <strong class="bold">
      
       left_race
      
     </strong>
     
      : The
     
     <strong class="source-inline">
      
       left_race
      
     </strong>
     
      function is like
     
     <strong class="source-inline">
      
       race
      
     </strong>
     
      but with deterministic behavior.
     
     
      It
     
     <a id="_idIndexMarker801">
     </a>
     
      evaluates the
     
     <a id="_idIndexMarker802">
     </a>
     
      coroutines from left to right and waits for the first coroutine to become ready.
     
     
      This can be useful when the order of coroutine completion matters, and you want to ensure a predictable outcome based on the order in which they
     
     
      
       were provided.
      
     
     <p class="list-inset">
      
       When you have multiple potential results and need to favor the first available coroutine in the order provided, making the behavior more predictable than
      
      <strong class="source-inline">
       
        race
       
      </strong>
      
       , you will
      
      
       
        use
       
      
      
       <strong class="source-inline">
        
         left_race
        
       </strong>
      
      
       
        .
       
      
     </p>
    </li>
   </ul>
   <p>
    
     In this section, we will explore examples of both
    
    <strong class="source-inline">
     
      join
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      gather
     
    </strong>
    
     functions.
    
    
     As we have seen, both functions wait for a set of coroutines to finish.
    
    
     The difference between them is that
    
    <strong class="source-inline">
     
      join
     
    </strong>
    
     throws an exception if any of the coroutines throw an exception, and
    
    <strong class="source-inline">
     
      gather
     
    </strong>
    
     always returns the results for all the awaited coroutines.
    
    
     In the case of the
    
    <strong class="source-inline">
     
      gather
     
    </strong>
    
     function, the result for each coroutine will either be an error (absent value) or a value.
    
    <strong class="source-inline">
     
      join
     
    </strong>
    
     returns a tuple of values or throws an exception;
    
    <strong class="source-inline">
     
      gather
     
    </strong>
    
     returns a tuple of optional values that have no value in the event of an exception (the optional variables are
    
    
     
      not initialized).
     
    
   </p>
   <p>
    
     The full code
    
    <a id="_idIndexMarker803">
    </a>
    
     for the following example is in the GitHub repo.
    
    
     We will focus here on the
    
    
     
      main sections.
     
    
   </p>
   <p>
    
     We have defined a simple function to simulate data processing, which is just a delay.
    
    
     The function throws an exception if we pass a delay bigger than
    
    
     
      5,000 milliseconds:
     
    
   </p>
   <pre class="source-code">
boost::cobalt::promise&lt;std::chrono::milliseconds::rep&gt; process(std::chrono::milliseconds ms) {
    if (ms &gt; std::chrono::milliseconds(5000)) {
        throw std::runtime_error("delay throw");
    }
    boost::asio::steady_timer tmr{ co_await boost::cobalt::this_coro::executor, ms };
    co_await tmr.async_wait(boost::cobalt::use_op);
    co_return ms.count();
}</pre>
   <p>
    
     The function is a
    
    
     
      Boost.Cobalt promise.
     
    
   </p>
   <p>
    
     Now, in the next section of the code, we will wait for three instances of this promise
    
    
     
      to run:
     
    
   </p>
   <pre class="source-code">
auto result = co_await boost::cobalt::join(process(100ms),
                                           process(200ms),
                                           process(300ms));
std::cout &lt;&lt; "First coroutine finished in: "
          &lt;&lt;  std::get&lt;0&gt;(result) &lt;&lt; "ms\n";
std::cout &lt;&lt; "Second coroutine took finished in: "
          &lt;&lt;  std::get&lt;1&gt;(result) &lt;&lt; "ms\n";
std::cout &lt;&lt; "Third coroutine took finished in: "
         &lt;&lt;  std::get&lt;2&gt;(result) &lt;&lt; "ms\n";</pre>
   <p>
    
     The preceding code calls
    
    <strong class="source-inline">
     
      join
     
    </strong>
    
     to wait for the completion of three coroutines and then prints the
    
    <a id="_idIndexMarker804">
    </a>
    
     time they took.
    
    
     As you can see, the result is a tuple, and to make the code as simple as possible, we just call
    
    <strong class="source-inline">
     
      std::get&lt;i&gt;(result)
     
    </strong>
    
     for each element.
    
    
     In this case, all the processing times are inside the valid range and no exception is thrown, so we can get the result for all the
    
    
     
      executed coroutines.
     
    
   </p>
   <p>
    
     If an exception is thrown, then we won’t get
    
    
     
      any value:
     
    
   </p>
   <pre class="source-code">
try {
    auto result throw = co_await
    boost::cobalt::join(process(100ms),
                        process(20000ms),
                        process(300ms));
}
catch (...) {
    std::cout &lt;&lt; "An exception was thrown\n";
}</pre>
   <p>
    
     The preceding code will throw an exception because the second coroutine receives a processing time outside of the valid range.
    
    
     It will print an
    
    
     
      error message.
     
    
   </p>
   <p>
    
     When calling the
    
    <strong class="source-inline">
     
      join
     
    </strong>
    
     function, we want all the coroutines to be considered as part of processing and, in the event of an exception, the full
    
    
     
      processing fails.
     
    
   </p>
   <p>
    
     If we need
    
    <a id="_idIndexMarker805">
    </a>
    
     to get all the results for each coroutine, we will use the
    
    
     <strong class="source-inline">
      
       gather
      
     </strong>
    
    
     
      function:
     
    
   </p>
   <pre class="source-code">
try
    auto result throw =
    boost::cobalt::co_await lt::gather(process(100ms),
                                       process(20000ms),
                                       process(300ms));
    if (std::get&lt;0&gt;(result throw).has value()) {
        std::cout &lt;&lt; "First coroutine took: "
                  &lt;&lt;  *std::get&lt;0&gt;(result throw)
                  &lt;&lt; "msec\n";
    }
    else {
        std::cout &lt;&lt; "First coroutine threw an exception\n";
    }
    if (std::get&lt;1&gt;(result throw).has value()) {
        std::cout &lt;&lt; "Second coroutine took: "
                  &lt;&lt;  *std::get&lt;1&gt;(result throw)
                  &lt;&lt; "msec\n";
    }
    else {
        std::cout &lt;&lt; "Second coroutine threw an exception\n";
    }
    if (std::get&lt;2&gt;(result throw).has value()) {
        std::cout &lt;&lt; "Third coroutine took: "
                  &lt;&lt;  *std::get&lt;2&gt;(result throw)
                  &lt;&lt; "msec\n";
    }
    else {
        std::cout &lt;&lt; "Third coroutine threw an exception\n";
    }
}
catch (...) {
    // this is never reached because gather doesn't throw exceptions
    std::cout &lt;&lt; "An exception was thrown\n";
}</pre>
   <p>
    
     We have
    
    <a id="_idIndexMarker806">
    </a>
    
     put the code inside a
    
    <strong class="source-inline">
     
      try-catch
     
    </strong>
    
     block but no exception is thrown.
    
    
     The
    
    <strong class="source-inline">
     
      gather
     
    </strong>
    
     function returns a tuple of optional values, and we need to check whether each coroutine returned a value or not (the optional has a value
    
    
     
      or not).
     
    
   </p>
   <p>
    
     We use
    
    <strong class="source-inline">
     
      gather
     
    </strong>
    
     when we want the coroutines to return a value if they are
    
    
     
      executed successfully.
     
    
   </p>
   <p>
    
     These examples of
    
    <strong class="source-inline">
     
      join
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      gather
     
    </strong>
    
     functions conclude our introduction to the Boost.Cobalt
    
    
     
      synchronization functions.
     
    
   </p>
   <h1 id="_idParaDest-226">
    <a id="_idTextAnchor225">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     In this chapter, we saw how to implement coroutines using the Boost.Cobalt library.
    
    
     It was added to Boost only recently, and there is not much information about it.
    
    
     It simplifies the development of asynchronous code with coroutines, avoiding writing the low-level code necessary for
    
    
     
      C++20 coroutines.
     
    
   </p>
   <p>
    
     We studied the main library concepts and developed some simple examples to
    
    
     
      understand them.
     
    
   </p>
   <p>
    
     With Boost.Cobalt, writing asynchronous code using coroutines is simplified.
    
    
     All the low-level details of writing coroutines in C++ are implemented by the library and we can focus just on the functionality we want to implement in
    
    
     
      our programs.
     
    
   </p>
   <p>
    
     In the next chapter, we will see how to debug
    
    
     
      asynchronous code.
     
    
   </p>
   <h1 id="_idParaDest-227">
    <a id="_idTextAnchor226">
    </a>
    
     Further reading
    
   </h1>
   <ul>
    <li>
     
      Boost.Cobalt reference:
     
     <em class="italic">
      
       Boost.Cobalt reference
      
     </em>
     
      <em class="italic">
       
        guide
       
      </em>
     
     
      
       (
      
     
     <a href="https://www.boost.org/doc/libs/1_86_0/libs/cobalt/doc/html/index.html#overview">
      
       
        https://www.boost.org/doc/libs/1_86_0/libs/cobalt/doc/html/index.html#overview
       
      
     </a>
     
      
       )
      
     
    </li>
    <li>
     
      A YouTube video on Boost.Cobalt:
     
     <em class="italic">
      
       Using coroutines with
      
     </em>
     
      <em class="italic">
       
        Boost.Cobalt
       
      </em>
     
     
      
       (
      
     
     <a href="https://www.youtube.com/watch?v=yElSdUqEvME">
      
       
        https://www.youtube.com/watch?v=yElSdUqEvME
       
      
     </a>
     
      
       )
      
     
    </li>
   </ul>
  </div>
 

  <div><h1 id="_idParaDest-228" lang="en-US" xml:lang="en-US">
    <a id="_idTextAnchor227">
    </a>
    
     Part 5: Debugging, Testing, and Performance Optimization in Asynchronous Programming
    
   </h1>
  </div>
  <div><p>
    
     In this final part, we focus on the essential practices of debugging, testing, and optimizing the performance of multithreaded and asynchronous programs.
    
    
     We will begin by using logging and advanced debugging tools and techniques, including reverse debugging and code sanitizers, to identify and resolve subtle bugs in asynchronous applications, such as crashes, deadlocks, race conditions, memory leaks, and thread safety issues, followed by testing strategies tailored for asynchronous code using the GoogleTest framework.
    
    
     Finally, we will dive into performance optimization, understanding key concepts such as cache sharing, false sharing, and how to mitigate performance bottlenecks.
    
    
     Mastering these techniques will provide us with a comprehensive toolkit for identifying, diagnosing, and improving the quality and performance of
    
    
     
      asynchronous applications.
     
    
   </p>
   <p>
    
     This part has the
    
    
     
      following chapters:
     
    
   </p>
   <ul>
    <li>
     <a href="B22219_11.xhtml#_idTextAnchor228">
      <em class="italic">
       
        Chapter 11
       
      </em>
     </a>
     
      ,
     
     <em class="italic">
      
       Logging and Debugging Asynchronous Software
      
     </em>
    </li>
    <li>
     <a href="B22219_12.xhtml#_idTextAnchor243">
      <em class="italic">
       
        Chapter 12
       
      </em>
     </a>
     
      ,
     
     <em class="italic">
      
       Sanitizing and Testing Asynchronous Software
      
     </em>
    </li>
    <li>
     <a href="B22219_13.xhtml#_idTextAnchor267">
      <em class="italic">
       
        Chapter 13
       
      </em>
     </a>
     
      ,
     
     <em class="italic">
      
       Improving Asynchronous Software Performance
      
     </em>
    </li>
   </ul>
  </div>
  <div><div></div>
  </div>
  <div><div></div>
  </div>
 </body></html>