<html><head></head><body>
  <div id="_idContainer060">
   <h1 class="chapter-number" id="_idParaDest-213">
    <a id="_idTextAnchor212">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     10
    </span>
   </h1>
   <h1 id="_idParaDest-214">
    <a id="_idTextAnchor213">
    </a>
    <span class="koboSpan" id="kobo.2.1">
     Coroutines with Boost.Cobalt
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.3.1">
     The previous chapters introduced C++20 coroutines and the Boost.Asio library, which is the foundation for
    </span>
    <a id="_idIndexMarker760">
    </a>
    <span class="koboSpan" id="kobo.4.1">
     writing asynchronous
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.5.1">
      input/output
     </span>
    </strong>
    <span class="koboSpan" id="kobo.6.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.7.1">
      I/O
     </span>
    </strong>
    <span class="koboSpan" id="kobo.8.1">
     ) operations using Boost.
    </span>
    <span class="koboSpan" id="kobo.8.2">
     In this chapter, we will explore Boost.Cobalt, a high-level abstraction based on Boost.Asio that simplifies asynchronous programming
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.9.1">
      with coroutines.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.10.1">
     Boost.Cobalt allows you to write clear, maintainable asynchronous code while avoiding the complexities of manually implementing coroutines in C++ (as covered in
    </span>
    <a href="B22219_08.xhtml#_idTextAnchor164">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.11.1">
        Chapter 8
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.12.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.12.2">
     Boost.Cobalt is fully compatible with Boost.Asio, allowing you to seamlessly combine both libraries in your projects.
    </span>
    <span class="koboSpan" id="kobo.12.3">
     By using Boost.Cobalt, you can focus on building your application without worrying about the low-level details
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.13.1">
      of coroutines.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.14.1">
     In this chapter, we will cover the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.15.1">
      Boost.Cobalt topics:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.16.1">
      Introducing the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.17.1">
       Boost.Cobalt library
      </span>
     </span>
    </li>
    <li>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.18.1">
       Boost.Cobalt generators
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.19.1">
      Boost.Cobalt tasks
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.20.1">
       and promises
      </span>
     </span>
    </li>
    <li>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.21.1">
       Boost.Cobalt channels
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.22.1">
      Boost.Cobalt
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.23.1">
       synchronization functions
      </span>
     </span>
    </li>
   </ul>
   <h1 id="_idParaDest-215">
    <a id="_idTextAnchor214">
    </a>
    <span class="koboSpan" id="kobo.24.1">
     Technical requirements
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.25.1">
     To build and execute the code examples from this chapter, a compiler that supports C++20 is required.
    </span>
    <span class="koboSpan" id="kobo.25.2">
     We have used both Clang
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.26.1">
      18
     </span>
    </strong>
    <span class="koboSpan" id="kobo.27.1">
     and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.28.1">
      GCC
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.29.1">
       14.2
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.30.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.31.1">
     Make sure you use Boost version 1.84 or newer and that your Boost library was compiled with C++20 support.
    </span>
    <span class="koboSpan" id="kobo.31.2">
     At the time of writing this book, Cobalt support is rather fresh in Boost and not all precompiled distributions may provide this component.
    </span>
    <span class="koboSpan" id="kobo.31.3">
     The situation will generally improve by the time of reading this book.
    </span>
    <span class="koboSpan" id="kobo.31.4">
     If, for any reason, the Boost library in your system does not meet these requirements, you have to build it from its source.
    </span>
    <span class="koboSpan" id="kobo.31.5">
     Compiling with an earlier version, such as C++17, won’t include Boost.Cobalt since it relies heavily on
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.32.1">
      C++20 coroutines.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.33.1">
     You can find the complete code in the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.34.1">
      GitHub repository:
     </span>
    </span>
   </p>
   <p>
    <a href="https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.35.1">
       https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP
      </span>
     </span>
    </a>
   </p>
   <p>
    <span class="koboSpan" id="kobo.36.1">
     The examples for this chapter are located under the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.37.1">
       Chapter_10
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.38.1">
      folder.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-216">
    <a id="_idTextAnchor215">
    </a>
    <span class="koboSpan" id="kobo.39.1">
     Introducing the Boost.Cobalt library
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.40.1">
     We introduced how C++20 supports coroutines in
    </span>
    <a href="B22219_08.xhtml#_idTextAnchor164">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.41.1">
        Chapter 8
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.42.1">
     .
    </span>
    <span class="koboSpan" id="kobo.42.2">
     It was made obvious that writing
    </span>
    <a id="_idIndexMarker761">
    </a>
    <span class="koboSpan" id="kobo.43.1">
     coroutines is not an easy task due to two
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.44.1">
      main reasons:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.45.1">
      Writing coroutines in C++ requires a certain amount of code to make the coroutine work but is not related to the functionality we want to implement.
     </span>
     <span class="koboSpan" id="kobo.45.2">
      For example, the coroutine we wrote to generate the Fibonacci sequence was quite simple, but we had to implement the wrapper type, the promise, and all the functions required for it to
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.46.1">
       be usable.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.47.1">
      The development of plain C++20 coroutines requires a good knowledge of the low-level aspects of how coroutines are implemented in C++, how the compiler transforms our code to implement all the mechanisms necessary to keep the coroutine state, and details about how the functions we must implement are called
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.48.1">
       and when.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.49.1">
     Asynchronous programming is difficult enough without all those many details.
    </span>
    <span class="koboSpan" id="kobo.49.2">
     It would be much better if we could focus on our program and be isolated from the lower-level concepts and code.
    </span>
    <span class="koboSpan" id="kobo.49.3">
     We saw how C++23 introduced
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.50.1">
      std::generator
     </span>
    </strong>
    <span class="koboSpan" id="kobo.51.1">
     precisely to achieve this.
    </span>
    <span class="koboSpan" id="kobo.51.2">
     Let us write just the generator code, and let the C++ Standard Library and compiler take care of the rest.
    </span>
    <span class="koboSpan" id="kobo.51.3">
     It is expected that this coroutine support will improve in the next
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.52.1">
      C++ version.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.53.1">
     Boost.Cobalt, one of the libraries included in the Boost C++ libraries, allows us to do just that – avoid the coroutines details.
    </span>
    <span class="koboSpan" id="kobo.53.2">
     Boost.Cobalt was introduced in Boost 1.84 and requires C++20 because it relies on the language coroutines features.
    </span>
    <span class="koboSpan" id="kobo.53.3">
     It is based on Boost.Asio, and we can use both libraries in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.54.1">
      our programs.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.55.1">
     The goal of Boost.Cobalt is to allow us to write simple single-threaded asynchronous code using coroutines – applications that can do multiple things simultaneously in a single thread.
    </span>
    <span class="koboSpan" id="kobo.55.2">
     Of course, by simultaneously, we mean concurrently, not in parallel, because there
    </span>
    <a id="_idIndexMarker762">
    </a>
    <span class="koboSpan" id="kobo.56.1">
     is only one thread.
    </span>
    <span class="koboSpan" id="kobo.56.2">
     By using Boost.Asio multithreading features, we can execute coroutines in different threads, but in this chapter, we will focus on
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.57.1">
      single-threaded applications.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-217">
    <a id="_idTextAnchor216">
    </a>
    <span class="koboSpan" id="kobo.58.1">
     Eager and lazy coroutines
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.59.1">
     Before we
    </span>
    <a id="_idIndexMarker763">
    </a>
    <span class="koboSpan" id="kobo.60.1">
     introduce the coroutine types implemented by Boost.Cobalt, we need to define the two kinds
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.61.1">
      of coroutines:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.62.1">
       Eager coroutines
      </span>
     </strong>
     <span class="koboSpan" id="kobo.63.1">
      : An eager coroutine begins execution as soon as it is called.
     </span>
     <span class="koboSpan" id="kobo.63.2">
      This means
     </span>
     <a id="_idIndexMarker764">
     </a>
     <span class="koboSpan" id="kobo.64.1">
      that the coroutine logic starts running immediately, and it progresses through its sequence until it hits a suspension point (such as
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.65.1">
       co_await
      </span>
     </strong>
     <span class="koboSpan" id="kobo.66.1">
      or
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.67.1">
       co_yield
      </span>
     </strong>
     <span class="koboSpan" id="kobo.68.1">
      ).
     </span>
     <span class="koboSpan" id="kobo.68.2">
      The creation of the coroutine effectively starts its processing, and any side effects in its body will execute
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.69.1">
       right away.
      </span>
     </span>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.70.1">
       Eager coroutines are beneficial when you want the coroutine to initiate its work immediately upon being created, such as starting asynchronous network operations or
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.71.1">
        preparing data.
       </span>
      </span>
     </p>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.72.1">
       Lazy coroutines
      </span>
     </strong>
     <span class="koboSpan" id="kobo.73.1">
      : A lazy
     </span>
     <a id="_idIndexMarker765">
     </a>
     <span class="koboSpan" id="kobo.74.1">
      coroutine defers its execution until is
     </span>
     <a id="_idIndexMarker766">
     </a>
     <span class="koboSpan" id="kobo.75.1">
      explicitly awaited or used.
     </span>
     <span class="koboSpan" id="kobo.75.2">
      The coroutine object can be created without any of its body running until the caller decides to interact with it (usually by awaiting it
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.76.1">
       with
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.77.1">
        co_await
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.78.1">
       ).
      </span>
     </span>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.79.1">
       Lazy coroutines are useful when you want to set up a coroutine but delay its execution until a certain condition is met or when you need to coordinate its execution with
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.80.1">
        other tasks.
       </span>
      </span>
     </p>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.81.1">
     After defining eager and lazy coroutines we will describe the different types of coroutines implemented
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.82.1">
      in Boost.Cobalt.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-218">
    <a id="_idTextAnchor217">
    </a>
    <span class="koboSpan" id="kobo.83.1">
     Boost.Cobalt coroutine types
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.84.1">
     Boost.Cobalt
    </span>
    <a id="_idIndexMarker767">
    </a>
    <span class="koboSpan" id="kobo.85.1">
     implements four types of coroutines.
    </span>
    <span class="koboSpan" id="kobo.85.2">
     We will introduce them in this section, and then see some examples later in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.86.1">
      the chapter:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.87.1">
       Promise
      </span>
     </strong>
     <span class="koboSpan" id="kobo.88.1">
      : This is the main coroutine type in Boost.Cobalt.
     </span>
     <span class="koboSpan" id="kobo.88.2">
      It is used to implement asynchronous operations that return a single value (calling
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.89.1">
       co_return
      </span>
     </strong>
     <span class="koboSpan" id="kobo.90.1">
      ).
     </span>
     <span class="koboSpan" id="kobo.90.2">
      It is an eager coroutine.
     </span>
     <span class="koboSpan" id="kobo.90.3">
      It supports
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.91.1">
       co_await
      </span>
     </strong>
     <span class="koboSpan" id="kobo.92.1">
      , allowing asynchronous suspension and continuation.
     </span>
     <span class="koboSpan" id="kobo.92.2">
      For example, a promise can be used to execute a network call that, when complete, will return its result without blocking
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.93.1">
       other operations.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.94.1">
       Task
      </span>
     </strong>
     <span class="koboSpan" id="kobo.95.1">
      : Task is the lazy version of the promise.
     </span>
     <span class="koboSpan" id="kobo.95.2">
      It will not begin execution until is explicitly awaited.
     </span>
     <span class="koboSpan" id="kobo.95.3">
      It provides more flexibility in controlling when and how a coroutine runs.
     </span>
     <span class="koboSpan" id="kobo.95.4">
      When awaited, the task starts execution, allowing for delayed processing of
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.96.1">
       asynchronous operations.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.97.1">
       Generator
      </span>
     </strong>
     <span class="koboSpan" id="kobo.98.1">
      : In Boost.Cobalt, a generator is the only type of coroutine that can yield values.
     </span>
     <span class="koboSpan" id="kobo.98.2">
      Each value is yielded individually using
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.99.1">
       co_yield.
      </span>
     </strong>
     <span class="koboSpan" id="kobo.100.1">
      Its functionality is like
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.101.1">
       std::generator
      </span>
     </strong>
     <span class="koboSpan" id="kobo.102.1">
      in C++23 but it allows waiting with
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.103.1">
       co_await
      </span>
     </strong>
     <span class="koboSpan" id="kobo.104.1">
      (
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.105.1">
        std::generator
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.106.1">
       doesn’t).
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.107.1">
       Detached
      </span>
     </strong>
     <span class="koboSpan" id="kobo.108.1">
      : This is an eager coroutine that can use
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.109.1">
       co_await
      </span>
     </strong>
     <span class="koboSpan" id="kobo.110.1">
      but not
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.111.1">
       co_return
      </span>
     </strong>
     <span class="koboSpan" id="kobo.112.1">
      values.
     </span>
     <span class="koboSpan" id="kobo.112.2">
      It cannot be resumed and usually is
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.113.1">
       not awaited.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.114.1">
     So far, we introduced Boost.Cobalt.
    </span>
    <span class="koboSpan" id="kobo.114.2">
     We defined what eager and lazy coroutines are and then we defined the four main types of coroutines in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.115.1">
      the library.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.116.1">
     In the next section, we will dive into one of the most important topics related to Boost.Cobalt – generators.
    </span>
    <span class="koboSpan" id="kobo.116.2">
     We will also implement a few simple examples
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.117.1">
      of generators.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-219">
    <a id="_idTextAnchor218">
    </a>
    <span class="koboSpan" id="kobo.118.1">
     Boost.Cobalt generators
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.119.1">
     As discussed in
    </span>
    <a href="B22219_08.xhtml#_idTextAnchor164">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.120.1">
        Chapter 8
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.121.1">
     ,
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.122.1">
      generator coroutines
     </span>
    </strong>
    <span class="koboSpan" id="kobo.123.1">
     are specialized coroutines designed to yield
    </span>
    <a id="_idIndexMarker768">
    </a>
    <span class="koboSpan" id="kobo.124.1">
     values incrementally.
    </span>
    <span class="koboSpan" id="kobo.124.2">
     After each value is yielded, the coroutine suspends itself until the caller requests the next value.
    </span>
    <span class="koboSpan" id="kobo.124.3">
     In Boost.Cobalt, generators work in the same way.
    </span>
    <span class="koboSpan" id="kobo.124.4">
     They are the only coroutine type that can yield values.
    </span>
    <span class="koboSpan" id="kobo.124.5">
     This makes generators essential when you need a coroutine to produce multiple values
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.125.1">
      over time.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.126.1">
     One key characteristic of Boost.Cobalt generators is that they are eager by default, meaning they start execution immediately after being called.
    </span>
    <span class="koboSpan" id="kobo.126.2">
     Additionally, these generators
    </span>
    <a id="_idIndexMarker769">
    </a>
    <span class="koboSpan" id="kobo.127.1">
     are asynchronous, allowing them to use
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.128.1">
      co_await
     </span>
    </strong>
    <span class="koboSpan" id="kobo.129.1">
     , an important difference from
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.130.1">
      std::generator
     </span>
    </strong>
    <span class="koboSpan" id="kobo.131.1">
     introduced in C++23, which is lazy and doesn’t
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.132.1">
      support
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.133.1">
       co_await
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.134.1">
      .
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-220">
    <a id="_idTextAnchor219">
    </a>
    <span class="koboSpan" id="kobo.135.1">
     Looking at a basic example
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.136.1">
     Let’s begin
    </span>
    <a id="_idIndexMarker770">
    </a>
    <span class="koboSpan" id="kobo.137.1">
     with the simplest Boost.Cobalt program.
    </span>
    <span class="koboSpan" id="kobo.137.2">
     This example is not that of a generator, but we will explain some important details with
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.138.1">
      its help:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.139.1">
#include &lt;iostream&gt;
#include &lt;boost/cobalt.hpp&gt;
boost::cobalt::main co_main(int argc, char* argv[]) {
    std::cout &lt;&lt; "Hello Boost.Cobalt\n";
    co_return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.140.1">
     In the preceding code, we observe
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.141.1">
      the following:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.142.1">
      To use Boost.Cobalt, the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.143.1">
       &lt;boost/cobalt.hpp&gt;
      </span>
     </strong>
     <span class="koboSpan" id="kobo.144.1">
      header file must
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.145.1">
       be included.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.146.1">
      You also must link the Boost.Cobalt library to your application.
     </span>
     <span class="koboSpan" id="kobo.146.2">
      We supply a
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.147.1">
       CMakeLists.txt
      </span>
     </strong>
     <span class="koboSpan" id="kobo.148.1">
      file to do just that, not only for Boost.Cobalt but for all the required Boost libraries.
     </span>
     <span class="koboSpan" id="kobo.148.2">
      To link Boost.Cobalt explicitly (that is, not all the required Boost libraries), just add the following line to your
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.149.1">
        CMakeLists.txt
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.150.1">
       file:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.151.1">
target_link_libraries(${EXEC_NAME} Boost::cobalt)</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.152.1">
      Use of the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.153.1">
       co_main
      </span>
     </strong>
     <span class="koboSpan" id="kobo.154.1">
      function.
     </span>
     <span class="koboSpan" id="kobo.154.2">
      Instead of the usual
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.155.1">
       main
      </span>
     </strong>
     <span class="koboSpan" id="kobo.156.1">
      function, Boost.Cobalt introduces a coroutine-based entry point called
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.157.1">
       co_main
      </span>
     </strong>
     <span class="koboSpan" id="kobo.158.1">
      .
     </span>
     <span class="koboSpan" id="kobo.158.2">
      This function can use coroutine-specific keywords such as
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.159.1">
       co_return
      </span>
     </strong>
     <span class="koboSpan" id="kobo.160.1">
      .
     </span>
     <span class="koboSpan" id="kobo.160.2">
      Boost.Cobalt implements the required
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.161.1">
       main
      </span>
     </strong>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.162.1">
       function internally.
      </span>
     </span>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.163.1">
       Using
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.164.1">
        co_main
       </span>
      </strong>
      <span class="koboSpan" id="kobo.165.1">
       will let you implement the
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.166.1">
        main
       </span>
      </strong>
      <span class="koboSpan" id="kobo.167.1">
       function (entry point) of your program as a coroutine, thus being able to call
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.168.1">
        co_await
       </span>
      </strong>
      <span class="koboSpan" id="kobo.169.1">
       and
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.170.1">
        co_return
       </span>
      </strong>
      <span class="koboSpan" id="kobo.171.1">
       .
      </span>
      <span class="koboSpan" id="kobo.171.2">
       Remember from
      </span>
      <a href="B22219_08.xhtml#_idTextAnchor164">
       <span class="No-Break">
        <em class="italic">
         <span class="koboSpan" id="kobo.172.1">
          Chapter 8
         </span>
        </em>
       </span>
      </a>
      <span class="koboSpan" id="kobo.173.1">
       that the
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.174.1">
        main
       </span>
      </strong>
      <span class="koboSpan" id="kobo.175.1">
       function cannot be
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.176.1">
        a coroutine.
       </span>
      </span>
     </p>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.177.1">
       If you cannot change your current
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.178.1">
        main
       </span>
      </strong>
      <span class="koboSpan" id="kobo.179.1">
       function, it is possible to use Boost.Cobalt.
      </span>
      <span class="koboSpan" id="kobo.179.2">
       You just need to call a function, which will be the top-level function
      </span>
      <a id="_idIndexMarker771">
      </a>
      <span class="koboSpan" id="kobo.180.1">
       of your asynchronous code using Boost.Cobalt, from
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.181.1">
        main
       </span>
      </strong>
      <span class="koboSpan" id="kobo.182.1">
       .
      </span>
      <span class="koboSpan" id="kobo.182.2">
       In fact, this is what Boost.Cobalt is doing: it implements a
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.183.1">
        main
       </span>
      </strong>
      <span class="koboSpan" id="kobo.184.1">
       function, which is the entry point of the program, and that (hidden to you)
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.185.1">
        main
       </span>
      </strong>
      <span class="koboSpan" id="kobo.186.1">
       function
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.187.1">
        calls
       </span>
      </span>
      <span class="No-Break">
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.188.1">
         co_main
        </span>
       </strong>
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.189.1">
        .
       </span>
      </span>
     </p>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.190.1">
       The easiest way to use your own
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.191.1">
        main
       </span>
      </strong>
      <span class="koboSpan" id="kobo.192.1">
       function would be something
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.193.1">
        like this:
       </span>
      </span>
     </p>
     <pre class="source-code"><span class="koboSpan" id="kobo.194.1">
cobalt::task&lt;int&gt; async_task() {
    // your code here
    // …
    return 0;
}
int main() {
    // main function code
    // …
    return cobalt::run(async_code();
}</span></pre>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.195.1">
     The example simply prints a greeting message and then returns 0 calling
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.196.1">
      co_await
     </span>
    </strong>
    <span class="koboSpan" id="kobo.197.1">
     .
    </span>
    <span class="koboSpan" id="kobo.197.2">
     In all future examples, we will follow this pattern: including the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.198.1">
      &lt;boost/cobalt.hpp&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.199.1">
     header file and using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.200.1">
      co_main
     </span>
    </strong>
    <span class="koboSpan" id="kobo.201.1">
     instead
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.202.1">
      of
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.203.1">
       main
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.204.1">
      .
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-221">
    <a id="_idTextAnchor220">
    </a>
    <span class="koboSpan" id="kobo.205.1">
     Boost.Cobalt simple generators
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.206.1">
     Armed
    </span>
    <a id="_idIndexMarker772">
    </a>
    <span class="koboSpan" id="kobo.207.1">
     with the knowledge from our previous basic example, we will implement a very simple
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.208.1">
      generator coroutine:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.209.1">
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;boost/cobalt.hpp&gt;
using namespace std::chrono_literals;
using namespace boost;
cobalt::generator&lt;int&gt; basic_generator()
{
    std::this_thread::sleep_for(1s);
    co_yield 1;
    std::this_thread::sleep_for(1s);
    co_return 0;
}
cobalt::main co_main(int argc, char* argv[]) {
    auto g = basic_generator();
    std::cout &lt;&lt; co_await g &lt;&lt; std::endl;
    std::cout &lt;&lt; co_await g &lt;&lt; std::endl;
    co_return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.210.1">
     The preceding code shows a simple generator that yields an integer value (using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.211.1">
      co_yield
     </span>
    </strong>
    <span class="koboSpan" id="kobo.212.1">
     ) and returns another one (
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.213.1">
      using
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.214.1">
       co_return
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.215.1">
      ).
     </span>
    </span>
   </p>
   <p>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.216.1">
      cobalt::generator
     </span>
    </strong>
    <span class="koboSpan" id="kobo.217.1">
     is a
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.218.1">
       struct
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.219.1">
      template:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.220.1">
template&lt;typename Yield, typename Push = void&gt;
struct generator</span></pre>
   <p>
    <span class="koboSpan" id="kobo.221.1">
     The two
    </span>
    <a id="_idIndexMarker773">
    </a>
    <span class="koboSpan" id="kobo.222.1">
     parameter types are
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.223.1">
      as follows:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.224.1">
       Yield
      </span>
     </strong>
     <span class="koboSpan" id="kobo.225.1">
      : The generated
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.226.1">
       object type
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.227.1">
       Push
      </span>
     </strong>
     <span class="koboSpan" id="kobo.228.1">
      : The input parameter type (defaults
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.229.1">
       to
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.230.1">
        void
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.231.1">
       )
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.232.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.233.1">
      co_main
     </span>
    </strong>
    <span class="koboSpan" id="kobo.234.1">
     function prints both numbers after getting them using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.235.1">
      co_await
     </span>
    </strong>
    <span class="koboSpan" id="kobo.236.1">
     (the caller waits for the values to be available).
    </span>
    <span class="koboSpan" id="kobo.236.2">
     We have introduced some delays to simulate the processing a generator must do to generate
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.237.1">
      the numbers.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.238.1">
     Our second generator will yield the square of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.239.1">
      an integer:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.240.1">
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;boost/cobalt.hpp&gt;
using namespace std::chrono_literals;
using namespace boost;
cobalt::generator&lt;int, int&gt; square_generator(int x){
    while (x != 0) {
        x = co_yield x * x;
    }
    co_return 0;
}
cobalt::main co_main(int argc, char* argv[]){
    auto g = square_generator(10);
    std::cout &lt;&lt; co_await g(4) &lt;&lt; std::endl;
    std::cout &lt;&lt; co_await g(12) &lt;&lt; std::endl;
    std::cout &lt;&lt; co_await g(0) &lt;&lt; std::endl;
    co_return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.241.1">
     In this example,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.242.1">
      square_generator
     </span>
    </strong>
    <span class="koboSpan" id="kobo.243.1">
     yields the square of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.244.1">
      x
     </span>
    </strong>
    <span class="koboSpan" id="kobo.245.1">
     parameter.
    </span>
    <span class="koboSpan" id="kobo.245.2">
     This shows
    </span>
    <a id="_idIndexMarker774">
    </a>
    <span class="koboSpan" id="kobo.246.1">
     how we can
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.247.1">
      push
     </span>
    </em>
    <span class="koboSpan" id="kobo.248.1">
     values to a Boost.Cobalt generator.
    </span>
    <span class="koboSpan" id="kobo.248.2">
     In Boost.Cobalt, pushing values to a generator means passing parameters (in the preceding example, the passed parameters
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.249.1">
      are integers).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.250.1">
     The generator in this example, though correct, can be confusing.
    </span>
    <span class="koboSpan" id="kobo.250.2">
     Take a look at the following line
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.251.1">
      of code:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.252.1">
auto g = square_generator(10);</span></pre>
   <p>
    <span class="koboSpan" id="kobo.253.1">
     This creates the generator object with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.254.1">
      10
     </span>
    </strong>
    <span class="koboSpan" id="kobo.255.1">
     as the initial value.
    </span>
    <span class="koboSpan" id="kobo.255.2">
     Then, look at the following line
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.256.1">
      of code:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.257.1">
std::cout &lt;&lt; co_await g(4) &lt;&lt; std::endl;</span></pre>
   <p>
    <span class="koboSpan" id="kobo.258.1">
     This will print the square of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.259.1">
      10
     </span>
    </strong>
    <span class="koboSpan" id="kobo.260.1">
     and will push
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.261.1">
      4
     </span>
    </strong>
    <span class="koboSpan" id="kobo.262.1">
     to the generator.
    </span>
    <span class="koboSpan" id="kobo.262.2">
     As you can see, the printed values are not the squares of the values passed to the generator.
    </span>
    <span class="koboSpan" id="kobo.262.3">
     This is because the generator is initialized with one value (in this example,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.263.1">
      10
     </span>
    </strong>
    <span class="koboSpan" id="kobo.264.1">
     ), and it generates the squared value when the caller calls
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.265.1">
      co_await
     </span>
    </strong>
    <span class="koboSpan" id="kobo.266.1">
     to pass another value.
    </span>
    <span class="koboSpan" id="kobo.266.2">
     The generator will yield
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.267.1">
      100
     </span>
    </strong>
    <span class="koboSpan" id="kobo.268.1">
     when receiving the new value,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.269.1">
      4
     </span>
    </strong>
    <span class="koboSpan" id="kobo.270.1">
     , then it will yield
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.271.1">
      16
     </span>
    </strong>
    <span class="koboSpan" id="kobo.272.1">
     when receiving the value of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.273.1">
      12
     </span>
    </strong>
    <span class="koboSpan" id="kobo.274.1">
     , and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.275.1">
      so on.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.276.1">
     We said
    </span>
    <a id="_idIndexMarker775">
    </a>
    <span class="koboSpan" id="kobo.277.1">
     that Boost.Cobalt generators are eager, but it is possible to make them wait (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.278.1">
      co_await
     </span>
    </strong>
    <span class="koboSpan" id="kobo.279.1">
     ) as soon as they start executing.
    </span>
    <span class="koboSpan" id="kobo.279.2">
     The following example shows how to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.280.1">
      do it:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.281.1">
#include &lt;iostream&gt;
#include &lt;boost/cobalt.hpp&gt;
boost::cobalt::generator&lt;int, int&gt; square_generator() {
    auto x = co_await boost::cobalt::this_coro::initial;
    while (x != 0) {
        x = co_yield x * x;
    }
    co_return 0;
}
boost::cobalt::main co_main(int, char*[]) {
    auto g = square_generator();
    std::cout &lt;&lt; co_await g(4) &lt;&lt; std::endl;
    std::cout &lt;&lt; co_await g(10) &lt;&lt; std::endl;
    std::cout &lt;&lt; co_await g(12) &lt;&lt; std::endl;
    std::cout &lt;&lt; co_await g(0) &lt;&lt; std::endl;
    co_return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.282.1">
     The code
    </span>
    <a id="_idIndexMarker776">
    </a>
    <span class="koboSpan" id="kobo.283.1">
     is very similar to the previous example, but there are
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.284.1">
      some differences:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.285.1">
      We create the generator without any parameter being passed
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.286.1">
       to it:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.287.1">
auto g = square_generator();</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.288.1">
      Take a look at the first line of the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.289.1">
       generator’s code:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.290.1">
auto x = co_await boost::cobalt::this_coro::initial;</span></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.291.1">
       This makes the generator wait for the first pushed integer.
      </span>
      <span class="koboSpan" id="kobo.291.2">
       This behaves as a lazy generator (in fact, it starts executing immediately because the generator is eager, but the first thing it does is wait for
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.292.1">
        an integer).
       </span>
      </span>
     </p>
    </li>
    <li>
     <span class="koboSpan" id="kobo.293.1">
      The yielded values are what we would expect from
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.294.1">
       the code:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.295.1">
std::cout &lt;&lt; co_await g(10) &lt;&lt; std::endl;</span></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.296.1">
       This will print
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.297.1">
        100
       </span>
      </strong>
      <span class="koboSpan" id="kobo.298.1">
       instead of the square of the previously
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.299.1">
        pushed integer.
       </span>
      </span>
     </p>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.300.1">
     Let’s summarize here what the example does: the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.301.1">
      co_main
     </span>
    </strong>
    <span class="koboSpan" id="kobo.302.1">
     function calls the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.303.1">
      square_generator
     </span>
    </strong>
    <span class="koboSpan" id="kobo.304.1">
     coroutine to generate the square of an integer value.
    </span>
    <span class="koboSpan" id="kobo.304.2">
     The generator coroutine suspends itself at the beginning waiting for the first integer and it suspends itself after yielding each square.
    </span>
    <span class="koboSpan" id="kobo.304.3">
     The example is easy on purpose, just to illustrate how to write a generator
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.305.1">
      using Boost.Cobalt.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.306.1">
     An important feature of the preceding program is that it runs in a single thread.
    </span>
    <span class="koboSpan" id="kobo.306.2">
     This means that
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.307.1">
      co_main
     </span>
    </strong>
    <span class="koboSpan" id="kobo.308.1">
     and the generator coroutine run one
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.309.1">
      after another.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-222">
    <a id="_idTextAnchor221">
    </a>
    <span class="koboSpan" id="kobo.310.1">
     A Fibonacci sequence generator
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.311.1">
     In this section, we will implement a Fibonacci sequence generator like the one we implemented in
    </span>
    <a href="B22219_08.xhtml#_idTextAnchor164">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.312.1">
        Chapter 8
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.313.1">
     .
    </span>
    <span class="koboSpan" id="kobo.313.2">
     This will let us see how much easier is writing generator coroutines with Boost.Cobalt than with pure C++20 without using any
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.314.1">
      coroutines library.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.315.1">
     We
    </span>
    <a id="_idIndexMarker777">
    </a>
    <span class="koboSpan" id="kobo.316.1">
     have written two versions of the generator.
    </span>
    <span class="koboSpan" id="kobo.316.2">
     The first one calculates an arbitrary term of the Fibonacci sequence.
    </span>
    <span class="koboSpan" id="kobo.316.3">
     We push the term we want to generate, and we get it.
    </span>
    <span class="koboSpan" id="kobo.316.4">
     This generator uses a lambda as a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.317.1">
      Fibonacci calculator:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.318.1">
boost::cobalt::generator&lt;int, int&gt; fibonacci_term() {
    auto fibonacci = [](int n) {
        if (n &lt; 2) {
            return n;
        }
        int f0 = 0;
        int f1 = 1;
        int f;
        for (int i = 2; i &lt;= n; ++i) {
            f = f0 + f1;
            f0 = f1;
            f1 = f;
        }
        return f;
    };
    auto x = co_await boost::cobalt::this_coro::initial;
    while (x != -1) {
        x = co_yield fibonacci(x);
    }
    co_return 0;
 }</span></pre>
   <p>
    <span class="koboSpan" id="kobo.319.1">
     In the preceding code, we see that this generator is very similar to the one we implemented in the previous section to calculate the square of a number.
    </span>
    <span class="koboSpan" id="kobo.319.2">
     At the beginning of the coroutine, we have
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.320.1">
      the following:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.321.1">
auto x = co_await boost::cobalt::this_coro::initial;</span></pre>
   <p>
    <span class="koboSpan" id="kobo.322.1">
     This
    </span>
    <a id="_idIndexMarker778">
    </a>
    <span class="koboSpan" id="kobo.323.1">
     line of code suspends the coroutine to wait for the first
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.324.1">
      input value.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.325.1">
     And then we have
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.326.1">
      the following:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.327.1">
while (x != -1) {
        x = co_yield fibonacci(x);
    }</span></pre>
   <p>
    <span class="koboSpan" id="kobo.328.1">
     This generates the requested Fibonacci sequence term and suspends itself until the next term is requested.
    </span>
    <span class="koboSpan" id="kobo.328.2">
     While the requested term is not equal to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.329.1">
      -1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.330.1">
     , we can go on requesting more values until pushing
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.331.1">
      -1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.332.1">
     terminates
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.333.1">
      the coroutine.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.334.1">
     The next version of the Fibonacci generator will yield an infinite number of terms as they are requested.
    </span>
    <span class="koboSpan" id="kobo.334.2">
     By
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.335.1">
      infinite
     </span>
    </em>
    <span class="koboSpan" id="kobo.336.1">
     we mean
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.337.1">
      potentially infinite
     </span>
    </em>
    <span class="koboSpan" id="kobo.338.1">
     .
    </span>
    <span class="koboSpan" id="kobo.338.2">
     Think about this generator as always ready to yield one more Fibonacci
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.339.1">
      sequence number:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.340.1">
boost::cobalt::generator&lt;int&gt; fibonacci_sequence() {
    int f0 = 0;
    int f1 = 1;
    int f = 0;
    while (true) {
        co_yield f0;
        f = f0 + f1;
        f0 = f1;
        f1 = f;
    }
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.341.1">
     The preceding code is easy to understand: the coroutine yields a value and suspends itself
    </span>
    <a id="_idIndexMarker779">
    </a>
    <span class="koboSpan" id="kobo.342.1">
     until another one is requested and the coroutine calculates the new value and yields it and suspends itself again in an
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.343.1">
      infinite loop.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.344.1">
     In this case, we can see the advantage of a coroutine: we can generate the terms of the Fibonacci sequence, one after another, whenever we need them.
    </span>
    <span class="koboSpan" id="kobo.344.2">
     We don’t need to keep any state to generate the next term because the state is kept in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.345.1">
      the coroutine.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.346.1">
     Also note that even if the function executes an infinite loop, because it is a coroutine, it suspends and resumes again and again, avoiding blocking the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.347.1">
      current thread.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-223">
    <a id="_idTextAnchor222">
    </a>
    <span class="koboSpan" id="kobo.348.1">
     Boost.Cobalt tasks and promises
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.349.1">
     As we have already seen in this chapter, Boost.Cobalt promises are eager coroutines that return one value and Boost.Cobalt tasks are the lazy version
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.350.1">
      of promises.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.351.1">
     We can
    </span>
    <a id="_idIndexMarker780">
    </a>
    <span class="koboSpan" id="kobo.352.1">
     see them as just functions that don’t yield multiple values like generators do.
    </span>
    <span class="koboSpan" id="kobo.352.2">
     We can call a promise repeatedly to get more than one value, but the state won’t be kept between calls (as in generators).
    </span>
    <span class="koboSpan" id="kobo.352.3">
     Basically, a promise is a coroutine that can use
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.353.1">
      co_await
     </span>
    </strong>
    <span class="koboSpan" id="kobo.354.1">
     (it can use
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.355.1">
       co_return
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.356.1">
      too).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.357.1">
     Different use cases of promises would be a socket listener to receive network packets, process them, make queries to a database, and then generate some results from the data.
    </span>
    <span class="koboSpan" id="kobo.357.2">
     In general, their functionality requires asynchronously waiting for some result and then performing some processing on that result (or maybe just returning it to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.358.1">
      the caller).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.359.1">
     Our first
    </span>
    <a id="_idIndexMarker781">
    </a>
    <span class="koboSpan" id="kobo.360.1">
     example is a simple promise that generates one random number (this can be done with a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.361.1">
      generator too):
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.362.1">
#include &lt;iostream&gt;
#include &lt;random&gt;
#include &lt;boost/cobalt.hpp&gt;
boost::cobalt::promise&lt;int&gt; random_number(int min, int max) {
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution&lt;&gt; dist(min, max);
    co_return dist(gen);
}
boost::cobalt::promise&lt;int&gt; random(int min, int max) {
    int res = co_await random_number(min, max);
    co_return res;
}
boost::cobalt::main co_main(int, char*[]) {
    for (int i = 0; i &lt; 10; ++i) {
        auto r = random(1, 100);
        std::cout &lt;&lt; "random number between 1 and 100: "
                  &lt;&lt; co_await r &lt;&lt; std::endl;
    }
    co_return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.363.1">
     In the
    </span>
    <a id="_idIndexMarker782">
    </a>
    <span class="koboSpan" id="kobo.364.1">
     preceding code, we have written
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.365.1">
      three coroutines:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.366.1">
       co_main
      </span>
     </strong>
     <span class="koboSpan" id="kobo.367.1">
      : Remember that in Boost.Cobalt,
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.368.1">
       co_main
      </span>
     </strong>
     <span class="koboSpan" id="kobo.369.1">
      is a coroutine and it calls
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.370.1">
       co_return
      </span>
     </strong>
     <span class="koboSpan" id="kobo.371.1">
      to return
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.372.1">
       a value.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.373.1">
       random()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.374.1">
      : This coroutine returns a random number to the caller.
     </span>
     <span class="koboSpan" id="kobo.374.2">
      It calls
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.375.1">
       random()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.376.1">
      with
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.377.1">
       co_await
      </span>
     </strong>
     <span class="koboSpan" id="kobo.378.1">
      to generate the random number.
     </span>
     <span class="koboSpan" id="kobo.378.2">
      It asynchronously waits for the random number to
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.379.1">
       be generated.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.380.1">
       random_number()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.381.1">
      : This coroutine generates a uniformly distributed random number between two values,
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.382.1">
       min
      </span>
     </strong>
     <span class="koboSpan" id="kobo.383.1">
      and
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.384.1">
       max
      </span>
     </strong>
     <span class="koboSpan" id="kobo.385.1">
      , and returns it to the caller.
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.386.1">
       random_number()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.387.1">
      is also
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.388.1">
       a promise.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.389.1">
     The following coroutine returns a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.390.1">
      std::vector&lt;int&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.391.1">
     of random numbers.
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.392.1">
      co_await random_number()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.393.1">
     is called in a loop to generate a vector of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.394.1">
      n
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.395.1">
      random numbers:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.396.1">
boost::cobalt::promise&lt;std::vector&lt;int&gt;&gt; random_vector(int min, int max, int n) {
    std::vector&lt;int&gt; rv(n);
    for (int i = 0; i &lt; n; ++i) {
        rv[i] = co_await random_number(min, max);
    }
    co_return rv;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.397.1">
     The preceding function returns a promise of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.398.1">
      std::vector&lt;int&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.399.1">
     .
    </span>
    <span class="koboSpan" id="kobo.399.2">
     To access the vector, we need to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.400.1">
      call
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.401.1">
       get()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.402.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.403.1">
auto v = random_vector(1, 100, 20);
for (int n : v.get()) {
    std::cout &lt;&lt; n &lt;&lt; " ";
}
std::cout &lt;&lt; std::endl;</span></pre>
   <p>
    <span class="koboSpan" id="kobo.404.1">
     The previous code prints the elements of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.405.1">
      v
     </span>
    </strong>
    <span class="koboSpan" id="kobo.406.1">
     vector.
    </span>
    <span class="koboSpan" id="kobo.406.2">
     To access the vector, we need to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.407.1">
      call
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.408.1">
       v.get()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.409.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.410.1">
     We are
    </span>
    <a id="_idIndexMarker783">
    </a>
    <span class="koboSpan" id="kobo.411.1">
     going to implement a second example to illustrate how the execution of promises and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.412.1">
      tasks differ:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.413.1">
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;boost/cobalt.hpp&gt;
void sleep(){
    std::this_thread::sleep_for(std::chrono::seconds(2));
}
boost::cobalt::promise&lt;int&gt; eager_promise(){
    std::cout &lt;&lt; "Eager promise started\n";
    sleep();
    std::cout &lt;&lt; "Eager promise done\n";
    co_return 1;
}
boost::cobalt::task&lt;int&gt; lazy_task(){
    std::cout &lt;&lt; "Lazy task started\n";
    sleep();
    std::cout &lt;&lt; "Lazy task done\n";
    co_return 2;
}
boost::cobalt::main co_main(int, char*[]){
    std::cout &lt;&lt; "Calling eager_promise...\n";
    auto promise_result = eager_promise();
    std::cout &lt;&lt; "Promise called, but not yet awaited.\n";
    std::cout &lt;&lt; "Calling lazy_task...\n";
    auto task_result = lazy_task();
    std::cout &lt;&lt; "Task called, but not yet awaited.\n";
    std::cout &lt;&lt; "Awaiting both results...\n";
    int promise_value = co_await promise_result;
    std::cout &lt;&lt; "Promise value: " &lt;&lt; promise_value
              &lt;&lt; std::endl;
    int task_value = co_await task_result;
    std::cout &lt;&lt; "Task value: " &lt;&lt; task_value
              &lt;&lt; std::endl;
    co_return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.414.1">
     In this example, we have implemented two coroutines: a promise and a task.
    </span>
    <span class="koboSpan" id="kobo.414.2">
     As we have already said, the promise is eager and it starts executing as soon as it’s called.
    </span>
    <span class="koboSpan" id="kobo.414.3">
     The task is lazy and it’s suspended after
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.415.1">
      being called.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.416.1">
     When we run the program, it prints all the messages, which let us know exactly how the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.417.1">
      coroutines execute.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.418.1">
     After the
    </span>
    <a id="_idIndexMarker784">
    </a>
    <span class="koboSpan" id="kobo.419.1">
     first three lines of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.420.1">
      co_main()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.421.1">
     are executed, the printed output is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.422.1">
      the following:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.423.1">
Calling eager_promise...
</span><span class="koboSpan" id="kobo.423.2">Eager promise started
Eager promise done
Promise called, but not yet awaited.</span></pre>
   <p>
    <span class="koboSpan" id="kobo.424.1">
     From these messages, we know that the promise has been executed until the call
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.425.1">
      to
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.426.1">
       co_return
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.427.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.428.1">
     After the next three lines of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.429.1">
      co_main()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.430.1">
     are executed, the printed output has these
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.431.1">
      new messages:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.432.1">
Calling lazy_task...
</span><span class="koboSpan" id="kobo.432.2">Task called, but not yet awaited.</span></pre>
   <p>
    <span class="koboSpan" id="kobo.433.1">
     Here, we see that the task has not been executed.
    </span>
    <span class="koboSpan" id="kobo.433.2">
     It is a lazy coroutine and, for this reason, it just suspends immediately after being called and no messages are printed by this coroutine
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.434.1">
      just yet.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.435.1">
     Three more lines of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.436.1">
      co_main()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.437.1">
     are executed, and these are the new messages in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.438.1">
      program’s output:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.439.1">
Awaiting both results...
</span><span class="koboSpan" id="kobo.439.2">Promise value: 1</span></pre>
   <p>
    <span class="koboSpan" id="kobo.440.1">
     The call to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.441.1">
      co_await
     </span>
    </strong>
    <span class="koboSpan" id="kobo.442.1">
     on the promise gives us its result (in this case, set to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.443.1">
      1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.444.1">
     ) and its
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.445.1">
      execution ends.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.446.1">
     Finally, we call
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.447.1">
      co_await
     </span>
    </strong>
    <span class="koboSpan" id="kobo.448.1">
     on the task, and it then executes and returns its value (which, in this case, is set to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.449.1">
      2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.450.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.450.2">
     The output is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.451.1">
      the following:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.452.1">
Lazy task started
Lazy task done
Task value: 2</span></pre>
   <p>
    <span class="koboSpan" id="kobo.453.1">
     This example shows how tasks are lazy and start suspended and only resume executing when the caller calls
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.454.1">
      co_await
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.455.1">
      on them.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.456.1">
     In this section, we have seen that, as in the case of generators, it is much easier to write promise
    </span>
    <a id="_idIndexMarker785">
    </a>
    <span class="koboSpan" id="kobo.457.1">
     and task coroutines using Boost.Cobalt than just using plain C++.
    </span>
    <span class="koboSpan" id="kobo.457.2">
     We don’t need to write all the support code that C++ requires to implement coroutines.
    </span>
    <span class="koboSpan" id="kobo.457.3">
     We have also seen the main difference between tasks
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.458.1">
      and promises.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.459.1">
     In the next section, we will study an example of a channel, a communication mechanism between two coroutines in a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.460.1">
      producer/consumer model.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-224">
    <a id="_idTextAnchor223">
    </a>
    <span class="koboSpan" id="kobo.461.1">
     Boost.Cobalt channels
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.462.1">
     In Boost.Cobalt, channels provide a way for coroutines to communicate asynchronously, allowing
    </span>
    <a id="_idIndexMarker786">
    </a>
    <span class="koboSpan" id="kobo.463.1">
     data transfer between a producer and a consumer coroutine in a safe and efficient manner.
    </span>
    <span class="koboSpan" id="kobo.463.2">
     They are inspired by Golang channels and allow communication through message passing, promoting a
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.464.1">
       share-memory-by-communicating
      </span>
     </em>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.465.1">
      paradigm.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.466.1">
     A
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.467.1">
      channel
     </span>
    </strong>
    <span class="koboSpan" id="kobo.468.1">
     is a mechanism
    </span>
    <a id="_idIndexMarker787">
    </a>
    <span class="koboSpan" id="kobo.469.1">
     through which values are asynchronously passed from one coroutine (the producer) to another (the consumer).
    </span>
    <span class="koboSpan" id="kobo.469.2">
     This communication is non-blocking, which means that coroutines can suspend their execution when they wait for data to be available on the channel or when they write data to a channel that has limited capacity.
    </span>
    <span class="koboSpan" id="kobo.469.3">
     Let’s clarify this: both reading and writing operations may be blocking, depending on the buffer size if, by
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.470.1">
      blocking
     </span>
    </em>
    <span class="koboSpan" id="kobo.471.1">
     , we mean coroutines are suspended, but on the other hand, from the point of view of threads, these operations don’t block
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.472.1">
      the thread.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.473.1">
     If the buffer size is zero, a read and a write will need to occur at the same time and act as a rendezvous (synchronous communication).
    </span>
    <span class="koboSpan" id="kobo.473.2">
     If the channel size is bigger than zero and the buffer is not full, the write operation will not suspend the coroutine.
    </span>
    <span class="koboSpan" id="kobo.473.3">
     Likewise, if the buffer is not empty, the read operation will
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.474.1">
      not suspend.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.475.1">
     Similar to Golang channels, Boost.Cobalt channels are strongly typed.
    </span>
    <span class="koboSpan" id="kobo.475.2">
     A channel is defined for a specific type, and only that type can be sent through it.
    </span>
    <span class="koboSpan" id="kobo.475.3">
     For example, a channel of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.476.1">
      int
     </span>
    </strong>
    <span class="koboSpan" id="kobo.477.1">
     type (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.478.1">
      boost::cobalt::channel&lt;int&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.479.1">
     ) can only
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.480.1">
      transmit integers.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.481.1">
     Let’s
    </span>
    <a id="_idIndexMarker788">
    </a>
    <span class="koboSpan" id="kobo.482.1">
     now see an example of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.483.1">
      a channel:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.484.1">
#include &lt;iostream&gt;
#include &lt;boost/cobalt.hpp&gt;
#include &lt;boost/asio.hpp&gt;
boost::cobalt::promise&lt;void&gt; producer(boost::cobalt::channel&lt;int&gt;&amp; ch) {
    for (int i = 1; i &lt;= 10; ++i) {
        std::cout &lt;&lt; "Producer waiting for request\n";
        co_await ch.write(i);
        std::cout &lt;&lt; "Producing value " &lt;&lt; i &lt;&lt; std::endl;
    }
    std::cout &lt;&lt; "Producer end\n";
    ch.close();
    co_return;
}
boost::cobalt::main co_main(int, char*[]) {
    boost::cobalt::channel&lt;int&gt; ch;
    auto p = producer(ch);
    while (ch.is_open()) {
        std::cout &lt;&lt; "Consumer waiting for next number \n";
        std::this_thread::sleep_for(std::chrono::seconds(5));
        auto n = co_await ch.read();
        std::cout &lt;&lt; "Consuming value " &lt;&lt; n &lt;&lt; std::endl;
        std::cout &lt;&lt; n * n &lt;&lt; std::endl;
    }
    co_await p;
    co_return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.485.1">
     In this example, we create a size
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.486.1">
      0
     </span>
    </strong>
    <span class="koboSpan" id="kobo.487.1">
     channel and two coroutines: the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.488.1">
      producer
     </span>
    </strong>
    <span class="koboSpan" id="kobo.489.1">
     promise and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.490.1">
      co_main()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.491.1">
     , which acts as the consumer.
    </span>
    <span class="koboSpan" id="kobo.491.2">
     The producer writes integers to the channel and the consumer reads them back and prints
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.492.1">
      them squared.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.493.1">
     We added
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.494.1">
      std::this_thread::sleep
     </span>
    </strong>
    <span class="koboSpan" id="kobo.495.1">
     to delay the program execution and, hence, be able
    </span>
    <a id="_idIndexMarker789">
    </a>
    <span class="koboSpan" id="kobo.496.1">
     to see what happens as the program runs.
    </span>
    <span class="koboSpan" id="kobo.496.2">
     Let’s see an excerpt of the example’s output to see how
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.497.1">
      it works:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.498.1">
Producer waiting for request
Consumer waiting for next number
Producing value 1
Producer waiting for request
Consuming value 1
1
Consumer waiting for next number
Producing value 2
Producer waiting for request
Consuming value 2
4
Consumer waiting for next number
Producing value 3
Producer waiting for request
Consuming value 3
9
Consumer waiting for next number</span></pre>
   <p>
    <span class="koboSpan" id="kobo.499.1">
     Both the consumer and the producer wait for the next action to happen.
    </span>
    <span class="koboSpan" id="kobo.499.2">
     The producer will always wait for the consumer to request the next item.
    </span>
    <span class="koboSpan" id="kobo.499.3">
     This is basically how generators work, and it is a very common pattern in asynchronous code
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.500.1">
      using coroutines.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.501.1">
     The consumer executes the following line
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.502.1">
      of code:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.503.1">
auto n = co_await ch.read();</span></pre>
   <p>
    <span class="koboSpan" id="kobo.504.1">
     Then, the producer
    </span>
    <a id="_idIndexMarker790">
    </a>
    <span class="koboSpan" id="kobo.505.1">
     writes the next number to the channel and waits for the next request.
    </span>
    <span class="koboSpan" id="kobo.505.2">
     This is done in the following line
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.506.1">
      of code:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.507.1">
co_await ch.write(i);</span></pre>
   <p>
    <span class="koboSpan" id="kobo.508.1">
     You can see in the fourth line of the previous output excerpt how the producer goes back to waiting for the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.509.1">
      next request.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.510.1">
     Boost.Cobalt channels make writing this kind of asynchronous code very clean and easy
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.511.1">
      to understand.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.512.1">
     The example shows both coroutines communicating through
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.513.1">
      a channel.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.514.1">
     That wraps up this section.
    </span>
    <span class="koboSpan" id="kobo.514.2">
     The next one will introduce synchronization functions – mechanisms to wait for more than
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.515.1">
      one coroutine.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-225">
    <a id="_idTextAnchor224">
    </a>
    <span class="koboSpan" id="kobo.516.1">
     Boost.Cobalt synchronization functions
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.517.1">
     Previously, we implemented coroutines, and, in every case in which we called
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.518.1">
      co_await
     </span>
    </strong>
    <span class="koboSpan" id="kobo.519.1">
     , we did it for just one coroutine.
    </span>
    <span class="koboSpan" id="kobo.519.2">
     This means we waited for the result of only one
    </span>
    <a id="_idIndexMarker791">
    </a>
    <span class="koboSpan" id="kobo.520.1">
     coroutine.
    </span>
    <span class="koboSpan" id="kobo.520.2">
     Boost.Cobalt has mechanisms that allow us to wait on more than one coroutine.
    </span>
    <span class="koboSpan" id="kobo.520.3">
     These mechanisms are called
    </span>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.521.1">
       synchronization functions
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.522.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.523.1">
     There are
    </span>
    <a id="_idIndexMarker792">
    </a>
    <span class="koboSpan" id="kobo.524.1">
     four synchronization functions implemented
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.525.1">
      in Boost.Cobalt:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.526.1">
       race
      </span>
     </strong>
     <span class="koboSpan" id="kobo.527.1">
      : The
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.528.1">
       race
      </span>
     </strong>
     <span class="koboSpan" id="kobo.529.1">
      function
     </span>
     <a id="_idIndexMarker793">
     </a>
     <span class="koboSpan" id="kobo.530.1">
      waits for one
     </span>
     <a id="_idIndexMarker794">
     </a>
     <span class="koboSpan" id="kobo.531.1">
      coroutine out of a set to complete, but it does so in a pseudo-random manner.
     </span>
     <span class="koboSpan" id="kobo.531.2">
      This mechanism helps avoid starvation of coroutines, ensuring that one coroutine doesn’t dominate the execution flow over others.
     </span>
     <span class="koboSpan" id="kobo.531.3">
      When you have multiple asynchronous operations and you want the first to finish to determine the flow,
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.532.1">
       race
      </span>
     </strong>
     <span class="koboSpan" id="kobo.533.1">
      will allow any coroutine that becomes ready to proceed in a
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.534.1">
       non-deterministic order.
      </span>
     </span>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.535.1">
       When you
      </span>
      <a id="_idIndexMarker795">
      </a>
      <span class="koboSpan" id="kobo.536.1">
       have multiple tasks (tasks in the generic sense, not Boost.Cobalt tasks) and are interested in completing one first, without preference
      </span>
      <a id="_idIndexMarker796">
      </a>
      <span class="koboSpan" id="kobo.537.1">
       as to which one, but want to prevent one coroutine from always winning in situations where readiness is simultaneous, you will
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.538.1">
        use
       </span>
      </span>
      <span class="No-Break">
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.539.1">
         race
        </span>
       </strong>
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.540.1">
        .
       </span>
      </span>
     </p>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.541.1">
       join
      </span>
     </strong>
     <span class="koboSpan" id="kobo.542.1">
      : The
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.543.1">
       join
      </span>
     </strong>
     <span class="koboSpan" id="kobo.544.1">
      function waits for all the coroutines in a given set to complete and return
     </span>
     <a id="_idIndexMarker797">
     </a>
     <span class="koboSpan" id="kobo.545.1">
      their results as values.
     </span>
     <span class="koboSpan" id="kobo.545.2">
      If any
     </span>
     <a id="_idIndexMarker798">
     </a>
     <span class="koboSpan" id="kobo.546.1">
      of the coroutines throws an exception,
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.547.1">
       join
      </span>
     </strong>
     <span class="koboSpan" id="kobo.548.1">
      will propagate the exception to the caller.
     </span>
     <span class="koboSpan" id="kobo.548.2">
      It’s a way to gather results from multiple asynchronous operations that must all finish
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.549.1">
       before proceeding.
      </span>
     </span>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.550.1">
       You will use
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.551.1">
        join
       </span>
      </strong>
      <span class="koboSpan" id="kobo.552.1">
       when you need the result of multiple asynchronous operations together and want to throw an error if any of
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.553.1">
        them fail.
       </span>
      </span>
     </p>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.554.1">
       gather
      </span>
     </strong>
     <span class="koboSpan" id="kobo.555.1">
      : The
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.556.1">
       gather
      </span>
     </strong>
     <span class="koboSpan" id="kobo.557.1">
      function, like
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.558.1">
       join
      </span>
     </strong>
     <span class="koboSpan" id="kobo.559.1">
      , waits for a set of coroutines to complete, but it
     </span>
     <a id="_idIndexMarker799">
     </a>
     <span class="koboSpan" id="kobo.560.1">
      handles exceptions differently.
     </span>
     <span class="koboSpan" id="kobo.560.2">
      Instead of throwing
     </span>
     <a id="_idIndexMarker800">
     </a>
     <span class="koboSpan" id="kobo.561.1">
      an exception immediately when one of the coroutines fails,
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.562.1">
       gather
      </span>
     </strong>
     <span class="koboSpan" id="kobo.563.1">
      captures each coroutine’s result individually.
     </span>
     <span class="koboSpan" id="kobo.563.2">
      This means that you can inspect the outcome (success or failure) of each
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.564.1">
       coroutine independently.
      </span>
     </span>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.565.1">
       When you need all asynchronous operations to complete but you want to capture all results and exceptions individually to handle them separately, you will
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.566.1">
        use
       </span>
      </span>
      <span class="No-Break">
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.567.1">
         gather
        </span>
       </strong>
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.568.1">
        .
       </span>
      </span>
     </p>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.569.1">
       left_race
      </span>
     </strong>
     <span class="koboSpan" id="kobo.570.1">
      : The
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.571.1">
       left_race
      </span>
     </strong>
     <span class="koboSpan" id="kobo.572.1">
      function is like
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.573.1">
       race
      </span>
     </strong>
     <span class="koboSpan" id="kobo.574.1">
      but with deterministic behavior.
     </span>
     <span class="koboSpan" id="kobo.574.2">
      It
     </span>
     <a id="_idIndexMarker801">
     </a>
     <span class="koboSpan" id="kobo.575.1">
      evaluates the
     </span>
     <a id="_idIndexMarker802">
     </a>
     <span class="koboSpan" id="kobo.576.1">
      coroutines from left to right and waits for the first coroutine to become ready.
     </span>
     <span class="koboSpan" id="kobo.576.2">
      This can be useful when the order of coroutine completion matters, and you want to ensure a predictable outcome based on the order in which they
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.577.1">
       were provided.
      </span>
     </span>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.578.1">
       When you have multiple potential results and need to favor the first available coroutine in the order provided, making the behavior more predictable than
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.579.1">
        race
       </span>
      </strong>
      <span class="koboSpan" id="kobo.580.1">
       , you will
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.581.1">
        use
       </span>
      </span>
      <span class="No-Break">
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.582.1">
         left_race
        </span>
       </strong>
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.583.1">
        .
       </span>
      </span>
     </p>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.584.1">
     In this section, we will explore examples of both
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.585.1">
      join
     </span>
    </strong>
    <span class="koboSpan" id="kobo.586.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.587.1">
      gather
     </span>
    </strong>
    <span class="koboSpan" id="kobo.588.1">
     functions.
    </span>
    <span class="koboSpan" id="kobo.588.2">
     As we have seen, both functions wait for a set of coroutines to finish.
    </span>
    <span class="koboSpan" id="kobo.588.3">
     The difference between them is that
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.589.1">
      join
     </span>
    </strong>
    <span class="koboSpan" id="kobo.590.1">
     throws an exception if any of the coroutines throw an exception, and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.591.1">
      gather
     </span>
    </strong>
    <span class="koboSpan" id="kobo.592.1">
     always returns the results for all the awaited coroutines.
    </span>
    <span class="koboSpan" id="kobo.592.2">
     In the case of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.593.1">
      gather
     </span>
    </strong>
    <span class="koboSpan" id="kobo.594.1">
     function, the result for each coroutine will either be an error (absent value) or a value.
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.595.1">
      join
     </span>
    </strong>
    <span class="koboSpan" id="kobo.596.1">
     returns a tuple of values or throws an exception;
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.597.1">
      gather
     </span>
    </strong>
    <span class="koboSpan" id="kobo.598.1">
     returns a tuple of optional values that have no value in the event of an exception (the optional variables are
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.599.1">
      not initialized).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.600.1">
     The full code
    </span>
    <a id="_idIndexMarker803">
    </a>
    <span class="koboSpan" id="kobo.601.1">
     for the following example is in the GitHub repo.
    </span>
    <span class="koboSpan" id="kobo.601.2">
     We will focus here on the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.602.1">
      main sections.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.603.1">
     We have defined a simple function to simulate data processing, which is just a delay.
    </span>
    <span class="koboSpan" id="kobo.603.2">
     The function throws an exception if we pass a delay bigger than
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.604.1">
      5,000 milliseconds:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.605.1">
boost::cobalt::promise&lt;std::chrono::milliseconds::rep&gt; process(std::chrono::milliseconds ms) {
    if (ms &gt; std::chrono::milliseconds(5000)) {
        throw std::runtime_error("delay throw");
    }
    boost::asio::steady_timer tmr{ co_await boost::cobalt::this_coro::executor, ms };
    co_await tmr.async_wait(boost::cobalt::use_op);
    co_return ms.count();
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.606.1">
     The function is a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.607.1">
      Boost.Cobalt promise.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.608.1">
     Now, in the next section of the code, we will wait for three instances of this promise
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.609.1">
      to run:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.610.1">
auto result = co_await boost::cobalt::join(process(100ms),
                                           process(200ms),
                                           process(300ms));
std::cout &lt;&lt; "First coroutine finished in: "
          &lt;&lt;  std::get&lt;0&gt;(result) &lt;&lt; "ms\n";
std::cout &lt;&lt; "Second coroutine took finished in: "
          &lt;&lt;  std::get&lt;1&gt;(result) &lt;&lt; "ms\n";
std::cout &lt;&lt; "Third coroutine took finished in: "
         &lt;&lt;  std::get&lt;2&gt;(result) &lt;&lt; "ms\n";</span></pre>
   <p>
    <span class="koboSpan" id="kobo.611.1">
     The preceding code calls
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.612.1">
      join
     </span>
    </strong>
    <span class="koboSpan" id="kobo.613.1">
     to wait for the completion of three coroutines and then prints the
    </span>
    <a id="_idIndexMarker804">
    </a>
    <span class="koboSpan" id="kobo.614.1">
     time they took.
    </span>
    <span class="koboSpan" id="kobo.614.2">
     As you can see, the result is a tuple, and to make the code as simple as possible, we just call
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.615.1">
      std::get&lt;i&gt;(result)
     </span>
    </strong>
    <span class="koboSpan" id="kobo.616.1">
     for each element.
    </span>
    <span class="koboSpan" id="kobo.616.2">
     In this case, all the processing times are inside the valid range and no exception is thrown, so we can get the result for all the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.617.1">
      executed coroutines.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.618.1">
     If an exception is thrown, then we won’t get
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.619.1">
      any value:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.620.1">
try {
    auto result throw = co_await
    boost::cobalt::join(process(100ms),
                        process(20000ms),
                        process(300ms));
}
catch (...) {
    std::cout &lt;&lt; "An exception was thrown\n";
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.621.1">
     The preceding code will throw an exception because the second coroutine receives a processing time outside of the valid range.
    </span>
    <span class="koboSpan" id="kobo.621.2">
     It will print an
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.622.1">
      error message.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.623.1">
     When calling the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.624.1">
      join
     </span>
    </strong>
    <span class="koboSpan" id="kobo.625.1">
     function, we want all the coroutines to be considered as part of processing and, in the event of an exception, the full
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.626.1">
      processing fails.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.627.1">
     If we need
    </span>
    <a id="_idIndexMarker805">
    </a>
    <span class="koboSpan" id="kobo.628.1">
     to get all the results for each coroutine, we will use the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.629.1">
       gather
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.630.1">
      function:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.631.1">
try
    auto result throw =
    boost::cobalt::co_await lt::gather(process(100ms),
                                       process(20000ms),
                                       process(300ms));
    if (std::get&lt;0&gt;(result throw).has value()) {
        std::cout &lt;&lt; "First coroutine took: "
                  &lt;&lt;  *std::get&lt;0&gt;(result throw)
                  &lt;&lt; "msec\n";
    }
    else {
        std::cout &lt;&lt; "First coroutine threw an exception\n";
    }
    if (std::get&lt;1&gt;(result throw).has value()) {
        std::cout &lt;&lt; "Second coroutine took: "
                  &lt;&lt;  *std::get&lt;1&gt;(result throw)
                  &lt;&lt; "msec\n";
    }
    else {
        std::cout &lt;&lt; "Second coroutine threw an exception\n";
    }
    if (std::get&lt;2&gt;(result throw).has value()) {
        std::cout &lt;&lt; "Third coroutine took: "
                  &lt;&lt;  *std::get&lt;2&gt;(result throw)
                  &lt;&lt; "msec\n";
    }
    else {
        std::cout &lt;&lt; "Third coroutine threw an exception\n";
    }
}
catch (...) {
    // this is never reached because gather doesn't throw exceptions
    std::cout &lt;&lt; "An exception was thrown\n";
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.632.1">
     We have
    </span>
    <a id="_idIndexMarker806">
    </a>
    <span class="koboSpan" id="kobo.633.1">
     put the code inside a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.634.1">
      try-catch
     </span>
    </strong>
    <span class="koboSpan" id="kobo.635.1">
     block but no exception is thrown.
    </span>
    <span class="koboSpan" id="kobo.635.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.636.1">
      gather
     </span>
    </strong>
    <span class="koboSpan" id="kobo.637.1">
     function returns a tuple of optional values, and we need to check whether each coroutine returned a value or not (the optional has a value
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.638.1">
      or not).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.639.1">
     We use
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.640.1">
      gather
     </span>
    </strong>
    <span class="koboSpan" id="kobo.641.1">
     when we want the coroutines to return a value if they are
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.642.1">
      executed successfully.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.643.1">
     These examples of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.644.1">
      join
     </span>
    </strong>
    <span class="koboSpan" id="kobo.645.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.646.1">
      gather
     </span>
    </strong>
    <span class="koboSpan" id="kobo.647.1">
     functions conclude our introduction to the Boost.Cobalt
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.648.1">
      synchronization functions.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-226">
    <a id="_idTextAnchor225">
    </a>
    <span class="koboSpan" id="kobo.649.1">
     Summary
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.650.1">
     In this chapter, we saw how to implement coroutines using the Boost.Cobalt library.
    </span>
    <span class="koboSpan" id="kobo.650.2">
     It was added to Boost only recently, and there is not much information about it.
    </span>
    <span class="koboSpan" id="kobo.650.3">
     It simplifies the development of asynchronous code with coroutines, avoiding writing the low-level code necessary for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.651.1">
      C++20 coroutines.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.652.1">
     We studied the main library concepts and developed some simple examples to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.653.1">
      understand them.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.654.1">
     With Boost.Cobalt, writing asynchronous code using coroutines is simplified.
    </span>
    <span class="koboSpan" id="kobo.654.2">
     All the low-level details of writing coroutines in C++ are implemented by the library and we can focus just on the functionality we want to implement in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.655.1">
      our programs.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.656.1">
     In the next chapter, we will see how to debug
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.657.1">
      asynchronous code.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-227">
    <a id="_idTextAnchor226">
    </a>
    <span class="koboSpan" id="kobo.658.1">
     Further reading
    </span>
   </h1>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.659.1">
      Boost.Cobalt reference:
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.660.1">
       Boost.Cobalt reference
      </span>
     </em>
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.661.1">
        guide
       </span>
      </em>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.662.1">
       (
      </span>
     </span>
     <a href="https://www.boost.org/doc/libs/1_86_0/libs/cobalt/doc/html/index.html#overview">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.663.1">
        https://www.boost.org/doc/libs/1_86_0/libs/cobalt/doc/html/index.html#overview
       </span>
      </span>
     </a>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.664.1">
       )
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.665.1">
      A YouTube video on Boost.Cobalt:
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.666.1">
       Using coroutines with
      </span>
     </em>
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.667.1">
        Boost.Cobalt
       </span>
      </em>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.668.1">
       (
      </span>
     </span>
     <a href="https://www.youtube.com/watch?v=yElSdUqEvME">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.669.1">
        https://www.youtube.com/watch?v=yElSdUqEvME
       </span>
      </span>
     </a>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.670.1">
       )
      </span>
     </span>
    </li>
   </ul>
  </div>
 

  <div class="Content" id="_idContainer061">
   <h1 id="_idParaDest-228" lang="en-US" xml:lang="en-US">
    <a id="_idTextAnchor227">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     Part 5: Debugging, Testing, and Performance Optimization in Asynchronous Programming
    </span>
   </h1>
  </div>
  <div id="_idContainer062">
   <p>
    <span class="koboSpan" id="kobo.2.1">
     In this final part, we focus on the essential practices of debugging, testing, and optimizing the performance of multithreaded and asynchronous programs.
    </span>
    <span class="koboSpan" id="kobo.2.2">
     We will begin by using logging and advanced debugging tools and techniques, including reverse debugging and code sanitizers, to identify and resolve subtle bugs in asynchronous applications, such as crashes, deadlocks, race conditions, memory leaks, and thread safety issues, followed by testing strategies tailored for asynchronous code using the GoogleTest framework.
    </span>
    <span class="koboSpan" id="kobo.2.3">
     Finally, we will dive into performance optimization, understanding key concepts such as cache sharing, false sharing, and how to mitigate performance bottlenecks.
    </span>
    <span class="koboSpan" id="kobo.2.4">
     Mastering these techniques will provide us with a comprehensive toolkit for identifying, diagnosing, and improving the quality and performance of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.3.1">
      asynchronous applications.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.4.1">
     This part has the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.5.1">
      following chapters:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <a href="B22219_11.xhtml#_idTextAnchor228">
      <em class="italic">
       <span class="koboSpan" id="kobo.6.1">
        Chapter 11
       </span>
      </em>
     </a>
     <span class="koboSpan" id="kobo.7.1">
      ,
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.8.1">
       Logging and Debugging Asynchronous Software
      </span>
     </em>
    </li>
    <li>
     <a href="B22219_12.xhtml#_idTextAnchor243">
      <em class="italic">
       <span class="koboSpan" id="kobo.9.1">
        Chapter 12
       </span>
      </em>
     </a>
     <span class="koboSpan" id="kobo.10.1">
      ,
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.11.1">
       Sanitizing and Testing Asynchronous Software
      </span>
     </em>
    </li>
    <li>
     <a href="B22219_13.xhtml#_idTextAnchor267">
      <em class="italic">
       <span class="koboSpan" id="kobo.12.1">
        Chapter 13
       </span>
      </em>
     </a>
     <span class="koboSpan" id="kobo.13.1">
      ,
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.14.1">
       Improving Asynchronous Software Performance
      </span>
     </em>
    </li>
   </ul>
  </div>
  <div>
   <div id="_idContainer063">
   </div>
  </div>
  <div>
   <div class="Basic-Graphics-Frame" id="_idContainer064">
   </div>
  </div>
 </body></html>