- en: Remote Databases with Qt SQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt SQL is not dependent on any particular database driver. The same API can
    be used with various popular database backends. Databases can get huge storage,
    whereas mobile and embedded devices have limited amounts of storage, more so with
    embedded devices than mobile phones. You will learn about using Qt to access databases
    remotely over the network.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Drivers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding to a database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can grab this chapter's source code in the `cp10` branch at `git clone -b
    cp10 https://github.com/PacktPublishing/Hands-On-Mobile-and-Embedded-Development-with-Qt-5`.
  prefs: []
  type: TYPE_NORMAL
- en: You should also have installed the `sqlite` or `mysql` package for your system.
  prefs: []
  type: TYPE_NORMAL
- en: Drivers are database backends
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Qt supports a variety of database drivers or backends to the databases. The
    backends wrap the various system databases and allow Qt to have a unified API
    frontend. Qt supports the following database types:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Database types | Software |'
  prefs: []
  type: TYPE_TB
- en: '| QDB2 | IBM Db2 |'
  prefs: []
  type: TYPE_TB
- en: '| QIBASE | Borland InterBase |'
  prefs: []
  type: TYPE_TB
- en: '| QMYSQL | MySQL |'
  prefs: []
  type: TYPE_TB
- en: '| QOCI | Oracle Call Interface |'
  prefs: []
  type: TYPE_TB
- en: '| QODBC | ODBC |'
  prefs: []
  type: TYPE_TB
- en: '| QPSQL | PostgreSQL |'
  prefs: []
  type: TYPE_TB
- en: '| QSQLITE | SQLite version 3 or above |'
  prefs: []
  type: TYPE_TB
- en: '| QSQLITE2 | SQLite version 2 |'
  prefs: []
  type: TYPE_TB
- en: '| QTDS | Sybase Adaptive Server |'
  prefs: []
  type: TYPE_TB
- en: We will be looking into QMYSQL type, since it supports remote access. MySQL
    can be installed on Raspberry Pi. QSQLITE3 can be shared on a network resource
    and made to support remote access, and iOS and Android have support for SQLite.
  prefs: []
  type: TYPE_NORMAL
- en: Setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The MySQL database will need to be configured to let you have remote access
    to it. Let''s look at how we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: You will need to have the server and/or client installed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we'll create the database and make it accessible from the network, if
    needed. This will be done using the command line and a Terminal application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The MySQL server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I am using Ubuntu, so these commands will be mostly specific to a Debian-based
    Linux. If you are using a different Linux distribution, only the installation
    command would be different. You should install the MySQL server and client according
    to your distribution. The commands to create the database would be the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how we will set up the server:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need the MySQL server and client installed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`sudo apt-get install mysql-server mysql-client`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run `sudo mysql_secure_installation`, which will allow you to set up the root
    account. Then, log in to the `mysql` root account:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`sudo mysql -u root -p`'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new database `username` and `password`: `GRANT ALL PRIVILEGES ON *.*
    TO 'username'@'localhost' IDENTIFIED BY 'password';`. Change `username` to your
    database user, and `password` to a password you want to use to access this database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To make the server accessible from a host other than localhost, edit `/etc/mysql/mysql.conf.d/mysqld.cnf`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the `bind-address = localhost to bind-address = <your ip>` line, `<your
    ip>` being the IP address of the machine that the database is on. Then, restart
    the `mysql` server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`sudo  service mysql restart`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in your MySQL console, let a remote user access the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GRANT ALL ON *.* TO ''username''@''<your ip>'' IDENTIFIED BY ''password'';`'
  prefs: []
  type: TYPE_NORMAL
- en: Change `<your ip>` to the IP address or hostname of the client device, `username`
    to the username you used on the MySQL server, and `password` to the password they
    will use.
  prefs: []
  type: TYPE_NORMAL
- en: SQLite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SQLite is a file-based database and, as such, there is no such thing as a server.
    We can still connect to it remotely via a network filesystem, such as Windows
    file sharing/Samba, **Network File System** (NFS), or the **Secure Shell File
    System** (**SSHFS**) on Linux. SSHFS allows you to mount and access a remote filesystem
    like it is a local filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: There's no need to create a database manually using arcane commands unless you
    need to, as we will create it using Qt!
  prefs: []
  type: TYPE_NORMAL
- en: On Android, there are Samba clients, which will mount a Windows network share
    so we can use that. If you are using a Raspberry Pi or some other development
    board, you might be able to use SSHFS to mount a remote directory over SSH.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to a local or remote database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we have the database configured and running, we can now connect to it using
    the same functions regardless of whether it is local or a remote database. Now,
    let's take a look at writing code to connect to a database, whether local or remote.
  prefs: []
  type: TYPE_NORMAL
- en: Databases are either locally available, which usually means on the same machine,
    or accessed remotely over a network. Connecting to these different databases using
    Qt is essentially the same. Not all databases support remote access.
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin by using a local database.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the `sql` module, we need to add `sql` to the profile:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QT += sql`'
  prefs: []
  type: TYPE_NORMAL
- en: To connect to a database in Qt, we need to use the `QSqlDatabase` class.
  prefs: []
  type: TYPE_NORMAL
- en: QSqlDatabase
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Despite the name, `QSqlDatabase` represents a connection to a database, not
    the database itself.
  prefs: []
  type: TYPE_NORMAL
- en: To create a connection to a database, you first need to specify which database
    type you are using. It is referenced as a string representation of the supported
    database. Let's first choose the MySQL `QMYSQL` database.
  prefs: []
  type: TYPE_NORMAL
- en: The source code can be found on the Git repository under the `Chapter10-1` directory,
    in the `cp10` branch.
  prefs: []
  type: TYPE_NORMAL
- en: To use `QSqlDatabase`, we first need to add the database to create its instance.
  prefs: []
  type: TYPE_NORMAL
- en: The static `QSqlDatbase::addDatabase` function takes one parameter, that of
    a database type, and adds the instance of the database to the list of database
    connections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we add a MySQL database, so use the `QMYSQL` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are connecting to a SQLite database, use the `MSQLITE` database type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Most databases require a username and password. To set the `username` and `password`,
    use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we are connecting to a remote MySQL database, we need to specify the
    hostname as well. It can also be an IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To start the connection, call the `open()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`open` returns a `bool`, which is `true` if it was successful, or `false` if
    it failed, in which case we can check the error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If this opens successfully, we are connected to the database.
  prefs: []
  type: TYPE_NORMAL
- en: Let's actually create the remote database, since we have the needed permissions.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and opening a database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the SQLite database, once we open it, it creates the database on the filesystem.
    For MySQL, we have to send MySQL commands to create the database. We construct
    the SQL query using `QSqlQuery` do this in MySQL. `QSqlQuery` takes the database
    object as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To send a query, we call the `exec()` function on the `QSqlQuery` object. It
    takes a `String` as a typical `query` syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`dbname` here is any `String` we want the database name to be; I am using `MAEPQT
    db`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If this command fails, we issue a warning message. If it succeeds, then we
    go on and issue the command to `USE` it, so we call another `query` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: From here, we need to create some tables. I will keep it simple and fill it
    with some data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start another query, but with an empty command, and the `db` object as the
    second argument, which will create the `QSqlQuery` object on the specified database,
    but does not execute any commands until we are ready:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The database is prepared, so now we can add some data.
  prefs: []
  type: TYPE_NORMAL
- en: Adding data to the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Qt documents state that it is not a best practice to keep the `QSqlDatabase`
    object around.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few different ways we could go about this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We could use `QSqlDatabase::database` to grab an instance of the opened database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We can also use another function of `QSqlQuery` , named `prepare()`, which prepares
    the query string for execution using a proxy variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we can use `bindValue` to bind the value to its identifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As an alternative, you can call `bindValue` with the first argument being the
    index of the position of the identifier, starting at the number 0 and working
    upward through the values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use `bindValue` in the order of values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's look at retrieving data from the database.
  prefs: []
  type: TYPE_NORMAL
- en: Executing queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been running queries, but not getting any data in return. One
    of the points of a database is to query for data, not just to enter it. What fun
    would it be if we could only input data? The Qt API has a way to accommodate the
    different syntax and millions of ways a query can be made. Most of the time, it
    is specific to the type of data you need to be returned, but also specific to
    the database data itself. Luckily, `QSqlQuery` is general enough that the query
    parameter is a string.
  prefs: []
  type: TYPE_NORMAL
- en: QSqlQuery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To retrieve data, execute a query using `QsqlQuery` and then operate on the
    records using the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`first()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`last()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`next()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`previous()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`seek(int)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `first()` and `last()` functions will retrieve the first and last records
    respectively. To iterate backward through the records, use `previous()`. The `seek
    (int)` function takes on integer as an argument to determine which record to retrieve.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use `next()`, which will iterate forward through the records found
    in the query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We also use `value` to retrieve each field's data, which takes an `int` that
    indicates the position of the record starting at 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use `QSqlRecord` and `QSqlField` to do the same thing, but with
    more clarity as to what is actually going on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: To get the record data, use `value()`, which will return a `QVariant` that represents
    the data for that record field.
  prefs: []
  type: TYPE_NORMAL
- en: We could have used a model-based widget and then used `QsqlQueryModel` to execute
    the query.
  prefs: []
  type: TYPE_NORMAL
- en: QSqlQueryModel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`QSqlQueryModel` inherits from `QSqlQuery`, and returns a model object that
    can be used with model-based widgets and other classes. If we change our `QTableWidget`
    to `QTableView`, we can use `QSqlQueryModel` to be its data model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is my Raspberry Pi (with a Lego stand!) running the database example using
    the MySQL plugin remotely:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0e6010a7-476f-4740-bd4c-a405253bbfda.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned that `QSqlDatabase` represents a connection to any
    supported database. You can use this to log in to remote MySQL databases or a
    SQLite database on a network share. To perform data retrieval, use `QSqlQuery`.
    You use the same class to set data and tables and other database commands. You
    can use `QSqlDatabaseModel` if you are using a model-view application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore in-app purchasing using the Qt Purchasing
    module.
  prefs: []
  type: TYPE_NORMAL
