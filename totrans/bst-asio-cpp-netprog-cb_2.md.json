["```cpp\n#include <boost/asio.hpp>\n#include <iostream>\n\nusing namespace boost;\n\nint main()\n{\n  std::string buf; // 'buf' is the raw buffer. \n  buf = \"Hello\";   // Step 1 and 2 in single line.\n\n  // Step 3\\. Creating buffer representation that satisfies \n  // ConstBufferSequence concept requirements.\n  asio::const_buffers_1 output_buf = asio::buffer(buf);\n\n  // Step 4\\. 'output_buf' is the representation of the\n  // buffer 'buf' that can be used in Boost.Asio output\n  // operations.\n\n  return 0;\n}\n```", "```cpp\n#include <boost/asio.hpp>\n#include <iostream>\n#include <memory> // For std::unique_ptr<>\n\nusing namespace boost;\n\nint main()\n{\n  // We expect to receive a block of data no more than 20 bytes \n  // long. \n  const size_t BUF_SIZE_BYTES = 20;\n\n  // Step 1\\. Allocating the buffer. \n  std::unique_ptr<char[]> buf(new char[BUF_SIZE_BYTES]);\n\n  // Step 2\\. Creating buffer representation that satisfies \n  // MutableBufferSequence concept requirements.\n  asio::mutable_buffers_1 input_buf =\n    asio::buffer(static_cast<void*>(buf.get()),\n     BUF_SIZE_BYTES);\n\n  // Step 3\\. 'input_buf' is the representation of the buffer\n  // 'buf' that can be used in Boost.Asio input operations.\n\n  return 0;\n}\n```", "```cpp\ntemplate<typename ConstBufferSequence>\nstd::size_t send(const ConstBufferSequence & buffers);\n```", "```cpp\nasio::const_buffer asio_buf(buf.c_str(), buf.length());\nstd::vector<asio::const_buffer> buffers_sequence;\nbuffers_sequence.push_back(asio_buf);\n```", "```cpp\nasio::const_buffers_1 output_buf = asio::buffer(buf);\n```", "```cpp\ntypedef basic_streambuf<> streambuf;\n```", "```cpp\n#include <boost/asio.hpp>\n#include <iostream>\n\nusing namespace boost;\n\nint main()\n{\n  asio::streambuf buf;\n\n  std::ostream output(&buf);\n\n  // Writing the message to the stream-based buffer.\n  output << \"Message1\\nMessage2\";\n\n  // Now we want to read all data from a streambuf\n  // until '\\n' delimiter.\n  // Instantiate an input stream which uses our \n  // stream buffer.\n  std::istream input(&buf);\n\n  // We'll read data into this string.\n  std::string message1;\n\n  std::getline(input, message1);\n\n  // Now message1 string contains 'Message1'.\n\n  return 0;\n} \n```", "```cpp\ntemplate<\ntypename ConstBufferSequence>\nstd::size_t write_some(\nconst ConstBufferSequence & buffers);\n```", "```cpp\n#include <boost/asio.hpp>\n#include <iostream>\n\nusing namespace boost;\n\nvoid writeToSocket(asio::ip::tcp::socket& sock) {\n  // Step 2\\. Allocating and filling the buffer.\n  std::string buf = \"Hello\";\n\n  std::size_t total_bytes_written = 0;\n\n  // Step 3\\. Run the loop until all data is written\n  // to the socket.\n  while (total_bytes_written != buf.length()) {\n    total_bytes_written += sock.write_some(\n      asio::buffer(buf.c_str() +\n      total_bytes_written,\n      buf.length() - total_bytes_written));\n  }\n}\n\nint main()\n{\n  std::string raw_ip_address = \"127.0.0.1\";\n  unsigned short port_num = 3333;\n\n  try {\n    asio::ip::tcp::endpoint\n      ep(asio::ip::address::from_string(raw_ip_address),\n      port_num);\n\n    asio::io_service ios;\n\n// Step 1\\. Allocating and opening the socket.\n    asio::ip::tcp::socket sock(ios, ep.protocol());\n\n    sock.connect(ep);\n\n    writeToSocket(sock);\n  }\n  catch (system::system_error &e) {\n    std::cout << \"Error occured! Error code = \" << e.code()\n      << \". Message: \" << e.what();\n\n    return e.code().value();\n  }\n\n  return 0;\n}\n```", "```cpp\n  while (total_bytes_written != buf.length()) {\n    total_bytes_written += sock.write_some(\n      asio::buffer(buf.c_str() +\n      total_bytes_written,\n      buf.length() - total_bytes_written));\n  }\n```", "```cpp\ntemplate<\ntypename ConstBufferSequence>\nstd::size_t send(\n    const ConstBufferSequence & buffers,\n    socket_base::message_flags flags);\n```", "```cpp\ntemplate<\n    typename SyncWriteStream,\n    typename ConstBufferSequence>\nstd::size_t write(\n    SyncWriteStream & s,\n    const ConstBufferSequence & buffers);\n```", "```cpp\nvoid writeToSocketEnhanced(asio::ip::tcp::socket& sock) {\n  // Allocating and filling the buffer.\n  std::string buf = \"Hello\";\n\n  // Write whole buffer to the socket.\n  asio::write(sock, asio::buffer(buf));\n}\n```", "```cpp\ntemplate<\ntypename MutableBufferSequence>\nstd::size_t read_some(\n    const MutableBufferSequence & buffers);\n```", "```cpp\n#include <boost/asio.hpp>\n#include <iostream>\n\nusing namespace boost;\n\nstd::string readFromSocket(asio::ip::tcp::socket& sock) {\n  const unsigned char MESSAGE_SIZE = 7;\n  char buf[MESSAGE_SIZE];\n  std::size_t total_bytes_read = 0;\n\n  while (total_bytes_read != MESSAGE_SIZE) {\n    total_bytes_read += sock.read_some(\n      asio::buffer(buf + total_bytes_read,\n      MESSAGE_SIZE - total_bytes_read));\n  }\n\n  return std::string(buf, total_bytes_read);\n}\n\nint main()\n{\n  std::string raw_ip_address = \"127.0.0.1\";\n  unsigned short port_num = 3333;\n\n  try {\n    asio::ip::tcp::endpoint\n      ep(asio::ip::address::from_string(raw_ip_address),\n      port_num);\n\n    asio::io_service ios;\n\n    asio::ip::tcp::socket sock(ios, ep.protocol());\n\n    sock.connect(ep);\n\n    readFromSocket(sock);\n  }\n  catch (system::system_error &e) {\n    std::cout << \"Error occured! Error code = \" << e.code()\n      << \". Message: \" << e.what();\n\n    return e.code().value();\n  }\n\n  return 0;\n}\n```", "```cpp\n  while (total_bytes_read != MESSAGE_SIZE) {\n    total_bytes_read += sock.read_some(\n      asio::buffer(buf + total_bytes_read,\n      MESSAGE_SIZE - total_bytes_read));\n  }\n```", "```cpp\ntemplate<\n    typename MutableBufferSequence>\nstd::size_t receive(\n    const MutableBufferSequence & buffers,\n    socket_base::message_flags flags);\n```", "```cpp\ntemplate<\n    typename SyncReadStream,\n    typename MutableBufferSequence>\nstd::size_t read(\n    SyncReadStream & s,\n    const MutableBufferSequence & buffers);\n```", "```cpp\nstd::string readFromSocketEnhanced(asio::ip::tcp::socket& sock) {\n  const unsigned char MESSAGE_SIZE = 7;\n  char buf[MESSAGE_SIZE];\n\n  asio::read(sock, asio::buffer(buf, MESSAGE_SIZE));\n\n  return std::string(buf, MESSAGE_SIZE);\n}\n```", "```cpp\ntemplate<\n    typename SyncReadStream,\n    typename Allocator>\nstd::size_t read_until(\n    SyncReadStream & s,\n    boost::asio::basic_streambuf< Allocator > & b,\n    char delim);\n```", "```cpp\nstd::string readFromSocketDelim(asio::ip::tcp::socket& sock) {\n  asio::streambuf buf;\n\n  // Synchronously read data from the socket until\n  // '\\n' symbol is encountered.  \n  asio::read_until(sock, buf, '\\n');\n\n  std::string message;\n\n  // Because buffer 'buf' may contain some other data\n  // after '\\n' symbol, we have to parse the buffer and\n  // extract only symbols before the delimiter. \n\n  std::istream input_stream(&buf);\n  std::getline(input_stream, message);\n  return message;\n}\n```", "```cpp\ntemplate<\n    typename ConstBufferSequence,\n    typename WriteHandler>\nvoid async_write_some(\n    const ConstBufferSequence & buffers,\n    WriteHandler handler);\n```", "```cpp\nvoid write_handler(\n    const boost::system::error_code& ec,\n    std::size_t bytes_transferred);\n```", "```cpp\n#include <boost/asio.hpp>\n#include <iostream>\n\nusing namespace boost;\n```", "```cpp\n// Keeps objects we need in a callback to\n// identify whether all data has been written\n// to the socket and to initiate next async\n// writing operation if needed.\nstruct Session {\n  std::shared_ptr<asio::ip::tcp::socket> sock;\n  std::string buf;\n  std::size_t total_bytes_written;\n};\n```", "```cpp\n// Function used as a callback for \n// asynchronous writing operation.\n// Checks if all data from the buffer has\n// been written to the socket and initiates\n// new asynchronous writing operation if needed.\nvoid callback(const boost::system::error_code& ec,\n        std::size_t bytes_transferred,\n        std::shared_ptr<Session> s) \n{\n  if (ec != 0) {\n    std::cout << \"Error occured! Error code = \" \n    << ec.value()\n    << \". Message: \" << ec.message();\n\n    return;\n  }\n\n  s->total_bytes_written += bytes_transferred;\n\n  if (s->total_bytes_written == s->buf.length()) {\n    return;\n  }\n\n  s->sock->async_write_some(\n  asio::buffer(\n  s->buf.c_str() + \n  s->total_bytes_written, \n  s->buf.length() - \n  s->total_bytes_written),\n  std::bind(callback, std::placeholders::_1,\n  std::placeholders::_2, s));\n}\n```", "```cpp\nvoid writeToSocket(std::shared_ptr<asio::ip::tcp::socket> sock) {\n\n  std::shared_ptr<Session> s(new Session);\n\n  // Step 4\\. Allocating and filling the buffer.\n  s->buf = std::string(\"Hello\");\n  s->total_bytes_written = 0;\n  s->sock = sock;\n\n  // Step 5\\. Initiating asynchronous write operation.\n  s->sock->async_write_some(\n  asio::buffer(s->buf),\n  std::bind(callback, \n  std::placeholders::_1,\n  std::placeholders::_2, \n  s));\n}\n```", "```cpp\nint main()\n{\n  std::string raw_ip_address = \"127.0.0.1\";\n  unsigned short port_num = 3333;\n\n  try {\n    asio::ip::tcp::endpoint\n      ep(asio::ip::address::from_string(raw_ip_address),\n      port_num);\n\n    asio::io_service ios;\n\n    // Step 3\\. Allocating, opening and connecting a socket.\n    std::shared_ptr<asio::ip::tcp::socket> sock(\n    new asio::ip::tcp::socket(ios, ep.protocol()));\n\n    sock->connect(ep);\n\n    writeToSocket(sock);\n\n    // Step 6.\n    ios.run();\n  }\n  catch (system::system_error &e) {\n    std::cout << \"Error occured! Error code = \" << e.code()\n      << \". Message: \" << e.what();\n\n    return e.code().value();\n  }\n\n  return 0;\n}\n```", "```cpp\ns->sock->async_write_some(\n  asio::buffer(s->buf),\n  std::bind(callback,\n     std::placeholders::_1,\nstd::placeholders::_2, \ns));\n```", "```cpp\ns->sock->async_write_some(\nasio::buffer(\ns->buf.c_str() + \ns->total_bytes_written, \ns->buf.length() â€“ \ns->total_bytes_written),\nstd::bind(callback, std::placeholders::_1,\nstd::placeholders::_2, s));\n```", "```cpp\ntemplate<\n    typename AsyncWriteStream,\n    typename ConstBufferSequence,\n    typename WriteHandler>\nvoid async_write(\n    AsyncWriteStream & s,\n    const ConstBufferSequence & buffers,\n    WriteHandler handler);\n```", "```cpp\nstruct Session {\n  std::shared_ptr<asio::ip::tcp::socket> sock;\n  std::string buf;\n}; \n```", "```cpp\nvoid callback(const boost::system::error_code& ec,\n  std::size_t bytes_transferred,\n  std::shared_ptr<Session> s)\n{\n  if (ec != 0) {\n    std::cout << \"Error occured! Error code = \"\n      << ec.value()\n      << \". Message: \" << ec.message();\n\n    return;\n  }\n\n  // Here we know that all the data has\n  // been written to the socket.\n}\n```", "```cpp\ntemplate<\n    typename MutableBufferSequence,\n    typename ReadHandler>\nvoid async_read_some(\n    const MutableBufferSequence & buffers,\n    ReadHandler handler);\n```", "```cpp\nvoid read_handler(\n    const boost::system::error_code& ec,\n    std::size_t bytes_transferred);\n```", "```cpp\n#include <boost/asio.hpp>\n#include <iostream>\n\nusing namespace boost;\n```", "```cpp\n// Keeps objects we need in a callback to\n// identify whether all data has been read\n// from the socket and to initiate next async\n// reading operation if needed.\nstruct Session {\n  std::shared_ptr<asio::ip::tcp::socket> sock;\n  std::unique_ptr<char[]> buf;\n  std::size_t total_bytes_read;\n  unsigned int buf_size;\n};\n```", "```cpp\n// Function used as a callback for \n// asynchronous reading operation.\n// Checks if all data has been read\n// from the socket and initiates\n// new reading operation if needed.\nvoid callback(const boost::system::error_code& ec,\n  std::size_t bytes_transferred,\n  std::shared_ptr<Session> s)\n{\n  if (ec != 0) {\n    std::cout << \"Error occured! Error code = \"\n      << ec.value()\n      << \". Message: \" << ec.message();\n\n    return;\n  }\n\n  s->total_bytes_read += bytes_transferred;\n\n  if (s->total_bytes_read == s->buf_size) {\n    return;\n  }\n\n  s->sock->async_read_some(\n    asio::buffer(\n    s->buf.get() +\n      s->total_bytes_read,\n    s->buf_size -\n      s->total_bytes_read),\n    std::bind(callback, std::placeholders::_1,\n    std::placeholders::_2, s));\n} \n```", "```cpp\nvoid readFromSocket(std::shared_ptr<asio::ip::tcp::socket> sock) {  \n  std::shared_ptr<Session> s(new Session);\n\n  // Step 4\\. Allocating the buffer.\n  const unsigned int MESSAGE_SIZE = 7;\n\n  s->buf.reset(new char[MESSAGE_SIZE]);\n  s->total_bytes_read = 0;\n  s->sock = sock;\n  s->buf_size = MESSAGE_SIZE;\n\n  // Step 5\\. Initiating asynchronous reading operation.\n  s->sock->async_read_some(\n    asio::buffer(s->buf.get(), s->buf_size),\n    std::bind(callback,\n      std::placeholders::_1,\n      std::placeholders::_2,\n      s));\n}\n```", "```cpp\nint main()\n{\n  std::string raw_ip_address = \"127.0.0.1\";\n  unsigned short port_num = 3333;\n\n  try {\n    asio::ip::tcp::endpoint\n      ep(asio::ip::address::from_string(raw_ip_address),\n      port_num);\n\n    asio::io_service ios;\n\n    // Step 3\\. Allocating, opening and connecting a socket.\n    std::shared_ptr<asio::ip::tcp::socket> sock(\n      new asio::ip::tcp::socket(ios, ep.protocol()));\n\n    sock->connect(ep);\n\n    readFromSocket(sock);\n\n    // Step 6.\n    ios.run();\n  }\n  catch (system::system_error &e) {\n    std::cout << \"Error occured! Error code = \" << e.code()\n      << \". Message: \" << e.what();\n\n    return e.code().value();\n  }\n\n  return 0;\n} \n```", "```cpp\ns->sock->async_read_some(\n  asio::buffer(s->buf.get(), s->buf_size),\n  std::bind(callback,\n    std::placeholders::_1,\n    std::placeholders::_2,\n    s));\n```", "```cpp\ns->sock->async_read_some(\n    asio::buffer(s->buf.get(), s->buf_size),\n    std::bind(callback,\n      std::placeholders::_1,\n      std::placeholders::_2,\n      s));\n```", "```cpp\ntemplate<\n    typename AsyncReadStream,\n    typename MutableBufferSequence,\n    typename ReadHandler>\nvoid async_read(\n    AsyncReadStream & s,\n    const MutableBufferSequence & buffers,\n    ReadHandler handler);\n```", "```cpp\nstruct Session {\n  std::shared_ptr<asio::ip::tcp::socket> sock;\n  std::unique_ptr<char[]> buf;\n  unsigned int buf_size;\n}; \n```", "```cpp\nvoid callback(const boost::system::error_code& ec,\n  std::size_t bytes_transferred,\n  std::shared_ptr<Session> s)\n{\n  if (ec != 0) {\n    std::cout << \"Error occured! Error code = \"\n      << ec.value()\n      << \". Message: \" << ec.message();\n\n    return;\n  }\n\n  // Here we know that the reading has completed\n  // successfully and the buffer is full with\n  // data read from the socket.\n}\n```", "```cpp\n#include <boost/predef.h> // Tools to identify the OS.\n```", "```cpp\n#ifdef BOOST_OS_WINDOWS\n#define _WIN32_WINNT 0x0501\n\n#if _WIN32_WINNT <= 0x0502 // Windows Server 2003 or earlier.\n#define BOOST_ASIO_DISABLE_IOCP\n#define BOOST_ASIO_ENABLE_CANCELIO  \n#endif\n#endif\n```", "```cpp\n#include <boost/asio.hpp>\n#include <iostream>\n#include <thread>\n\nusing namespace boost;\n```", "```cpp\nint main()\n{\n  std::string raw_ip_address = \"127.0.0.1\";\n  unsigned short port_num = 3333;\n\n  try {\n    asio::ip::tcp::endpoint\n      ep(asio::ip::address::from_string(raw_ip_address),\n      port_num);\n\n    asio::io_service ios;\n\n    std::shared_ptr<asio::ip::tcp::socket> sock(\n      new asio::ip::tcp::socket(ios, ep.protocol()));\n\n    sock->async_connect(ep,\n      [sock](const boost::system::error_code& ec)\n    {\n      // If asynchronous operation has been\n      // cancelled or an error occured during\n      // execution, ec contains corresponding\n      // error code.\n      if (ec != 0) {\n        if (ec == asio::error::operation_aborted) {\n          std::cout << \"Operation cancelled!\";\n        }\n        else {\n          std::cout << \"Error occured!\"\n            << \" Error code = \"\n            << ec.value()\n            << \". Message: \"\n            << ec.message();\n        }\n\n        return;\n      }\n      // At this point the socket is connected and\n      // can be used for communication with \n      // remote application.\n    });\n\n    // Starting a thread, which will be used\n    // to call the callback when asynchronous \n    // operation completes.\n    std::thread worker_thread([&ios](){\n      try {\n        ios.run();\n      }\n      catch (system::system_error &e) {\n        std::cout << \"Error occured!\"\n        << \" Error code = \" << e.code()\n        << \". Message: \" << e.what();\n      }\n    });\n\n    // Emulating delay.\n    std::this_thread::sleep_for(std::chrono::seconds(2));\n\n    // Cancelling the initiated operation.\n    sock->cancel();\n\n    // Waiting for the worker thread to complete.\n    worker_thread.join();\n  }\n  catch (system::system_error &e) {\n    std::cout << \"Error occured! Error code = \" << e.code()\n      << \". Message: \" << e.what();\n\n    return e.code().value();\n  }\n\n  return 0;\n}\n```", "```cpp\n#include <boost/asio.hpp>\n#include <iostream>\n\nusing namespace boost;\n```", "```cpp\nvoid communicate(asio::ip::tcp::socket& sock) {\n  // Allocating and filling the buffer with\n  // binary data.\n  const char request_buf[] = {0x48, 0x65, 0x0, 0x6c, 0x6c,\n 0x6f};\n\n  // Sending the request data.\n  asio::write(sock, asio::buffer(request_buf));\n\n  // Shutting down the socket to let the\n  // server know that we've sent the whole\n  // request.\n  sock.shutdown(asio::socket_base::shutdown_send);\n\n  // We use extensible buffer for response\n  // because we don't know the size of the\n  // response message.\n  asio::streambuf response_buf;\n\n  system::error_code ec;\n  asio::read(sock, response_buf, ec);\n\n  if (ec == asio::error::eof) {\n    // Whole response message has been received.\n    // Here we can handle it.\n  }\n  else {\n    throw system::system_error(ec);\n  }\n}\n```", "```cpp\nint main()\n{\n  std::string raw_ip_address = \"127.0.0.1\";\n  unsigned short port_num = 3333;\n\n  try {\n    asio::ip::tcp::endpoint\n      ep(asio::ip::address::from_string(raw_ip_address),\n      port_num);\n\n    asio::io_service ios;\n\n    asio::ip::tcp::socket sock(ios, ep.protocol());\n\n    sock.connect(ep);\n\n    communicate(sock);\n  }\n  catch (system::system_error &e) {\n    std::cout << \"Error occured! Error code = \" << e.code()\n      << \". Message: \" << e.what();\n\n    return e.code().value();\n  }\n\n  return 0;\n}\n```", "```cpp\n#include <boost/asio.hpp>\n#include <iostream>\n\nusing namespace boost;\n```", "```cpp\nvoid processRequest(asio::ip::tcp::socket& sock) {\n  // We use extensible buffer because we don't\n  // know the size of the request message.\n  asio::streambuf request_buf;\n\n  system::error_code ec;\n\n  // Receiving the request.\n  asio::read(sock, request_buf, ec);\n\n  if (ec != asio::error::eof)\n    throw system::system_error(ec);\n\n  // Request received. Sending response.\n  // Allocating and filling the buffer with\n  // binary data.\n  const char response_buf[] = { 0x48, 0x69, 0x21 };\n\n  // Sending the request data.\n  asio::write(sock, asio::buffer(response_buf));\n\n  // Shutting down the socket to let the\n  // client know that we've sent the whole\n  // response.\n  sock.shutdown(asio::socket_base::shutdown_send);\n}\n```", "```cpp\nint main()\n{\n  unsigned short port_num = 3333;\n\n  try {\n    asio::ip::tcp::endpoint ep(asio::ip::address_v4::any(),\n      port_num);\n\n    asio::io_service ios;\n\n    asio::ip::tcp::acceptor acceptor(ios, ep);\n\n    asio::ip::tcp::socket sock(ios);\n\n    acceptor.accept(sock);\n\n    processRequest(sock);\n  }\n  catch (system::system_error &e) {\n    std::cout << \"Error occured! Error code = \" << e.code()\n      << \". Message: \" << e.what();\n\n    return e.code().value();\n  }\n\n  return 0;\n}\n```", "```cpp\nsock.shutdown(asio::socket_base::shutdown_send);\n```", "```cpp\nsystem::error_code ec;\nasio::read(sock, response_buf, ec);\n\nif (ec == asio::error::eof) {\n  // Whole response message has been received.\n  // Here we can handle it.\n}\n```"]