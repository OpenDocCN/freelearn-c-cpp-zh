["```cpp\nvoid clock_pll_on(int powersave)\n{\n  uint32_t reg32, plln, pllm, pllq,\n      pllp, pllr, hpre, ppre1, ppre2,\n      flash_waitstates;\n  if (powersave) {\n    cpu_freq = 48000000;\n    pllm = 8;\n    plln = 96;\n    pllp = 2;\n    pllq = 2;\n    pllr = 0;\n    hpre = RCC_PRESCALER_DIV_NONE;\n    ppre1 = RCC_PRESCALER_DIV_4;\n    ppre2 = RCC_PRESCALER_DIV_2;\n    flash_waitstates = 5;\n  } else {\n    cpu_freq = 168000000;\n    pllm = 8;\n    plln = 336;\n    pllp = 2;\n    pllq = 7;\n    pllr = 0;\n    hpre = RCC_PRESCALER_DIV_NONE;\n    ppre1 = RCC_PRESCALER_DIV_4;\n    ppre2 = RCC_PRESCALER_DIV_2;\n    flash_waitstates = 3;\n  }\n```", "```cpp\n flash_set_waitstates(flash_waitstates);\n```", "```cpp\n RCC_CR |= RCC_CR_HSION;\n DMB();\n while ((RCC_CR & RCC_CR_HSIRDY) == 0) {};\n reg32 = RCC_CFGR;\n reg32 &= ~((1 << 1) | (1 << 0));\n RCC_CFGR = (reg32 | RCC_CFGR_SW_HSI);\n DMB();\n RCC_CR |= RCC_CR_HSEON;\n DMB();\n while ((RCC_CR & RCC_CR_HSERDY) == 0)\n    ;\n```", "```cpp\n reg32 = RCC_CFGR;\n reg32 &= ~(0xF0);\n RCC_CFGR = (reg32 | (hpre << 4));\n DMB();\n reg32 = RCC_CFGR;\n reg32 &= ~(0x1C00);\n RCC_CFGR = (reg32 | (ppre1 << 10));\n DMB();\n reg32 = RCC_CFGR;\n reg32 &= ~(0x07 << 13);\n RCC_CFGR = (reg32 | (ppre2 << 13));\n DMB();\n reg32 = RCC_PLLCFGR;\n reg32 &= ~(PLL_FULL_MASK);\n RCC_PLLCFGR = reg32 | RCC_PLLCFGR_PLLSRC | pllm |\n (plln << 6) | (((pllp >> 1) - 1) << 16) | (pllq << 24);\n}\n```", "```cpp\n#define SCB_SCR (*(volatile uint32_t *)(0xE000ED10))\n#define SCB_SCR_SEVONPEND (1 << 4)\n#define SCB_SCR_SLEEPDEEP (1 << 2)\n#define SCB_SCR_SLEEPONEXIT (1 << 1)\n#define POW_BASE (0x40007000)\n#define POW_CR (*(volatile uint32_t *)(POW_BASE + 0x00))\n#define POW_SCR (*(volatile uint32_t *)(POW_BASE + 0x04))\n#define POW_CR_VOS (1 << 14)\n#define POW_CR_FPDS (1 << 9)\n#define POW_CR_CWUF (1 << 2)\n#define POW_CR_PDDS (1 << 1)\n#define POW_CR_LPDS (1 << 0)\n#define POW_SCR_WUF (1 << 0)\n#define POW_SCR_EWUP (1 << 4)\n```", "```cpp\n#define WFI() asm volatile (\"wfi\")\n#define WFE() asm volatile (\"wfe\")\n```", "```cpp\nvoid main(void) {\n  int sleep = 0;\n  pll_on(0);\n  button_setup();\n  led_setup();\n  timer_init(CPU_FREQ, 1, 1000);\n  while(1) {\n    if (timer_elapsed) {\n      WFE(); /* consume timer event */\n      led_toggle();\n      timer_elapsed = 0;\n    }\n    if (tim2_ticks > 10) {\n      sleep = 1;\n      tim2_ticks = 0;\n    }\n    if (sleep) {\n      enter_lowpower_mode();\n      WFE();\n      sleep = 0;\n      exit_lowpower_mode();\n    } else\n      WFI();\n  }\n}\n```", "```cpp\nvoid isr_tim2(void) {\n  nvic_irq_clear(NVIC_TIM2_IRQN);\n  TIM2_SR &= ~TIM_SR_UIF;\n  tim2_ticks++;\n  timer_elapsed++;\n}\n```", "```cpp\nvoid enter_lowpower_mode(void)\n{\n  uint32_t scr = 0;\n  led_off();\n  scr = SCB_SCR;\n  scr &= ~SCB_SCR_SEVONPEND;\n  scr |= SCB_SCR_SLEEPDEEP;\n  scr &= ~SCB_SCR_SLEEPONEXIT;\n  SCB_SCR = scr;\n  POW_CR |= POW_CR_CWUF | POW_CR_FPDS | POW_CR_LPDS;\n}\n```", "```cpp\nvoid button_setup(void)\n{\n  uint32_t reg;\n  AHB1_CLOCK_ER |= GPIOA_AHB1_CLOCK_ER;\n  APB2_CLOCK_ER |= SYSCFG_APB2_CLOCK_ER;\n  GPIOA_MODE &= ~ (0x03 << (BUTTON_PIN * 2));\n  EXTI_CR0 &= ~EXTI_CR_EXTI0_MASK;\n  EXTI_IMR &= ~0x7FFFFF;\n  reg = EXTI_EMR & ~0x7FFFFF;\n  EXTI_EMR = reg | (1 << BUTTON_PIN);\n  reg = EXTI_RTSR & ~0x7FFFFF;\n  EXTI_RTSR = reg | (1 << BUTTON_PIN);\n  EXTI_FTSR &= ~0x7FFFFF;\n}\n```", "```cpp\n    void exit_lowpower_mode(void)\n    ```", "```cpp\n    {\n    ```", "```cpp\n      SCB_SCR &= ~SCB_SCR_SLEEPDEEP;\n    ```", "```cpp\n      POW_CR |= POW_CR_CWUF | POW_CR_CSBF;\n    ```", "```cpp\n      clock_pll_on(0);\n    ```", "```cpp\n      timer_init(cpu_freq, 1, 1000);\n    ```", "```cpp\n      led_on();\n    ```", "```cpp\n    }\n    ```", "```cpp\nvoid enter_lowpower_mode(void)\n{\n  uint32_t scr = 0;\n  led_off();\n  scr = SCB_SCR;\n  scr &= ~SCB_SCR_SEVONPEND;\n  scr |= SCB_SCR_SLEEPDEEP;\n  scr &= ~SCB_SCR_SLEEPONEXIT;\n  SCB_SCR = scr;\n  POW_CR |= POW_CR_CWUF | POW_CR_FPDS | POW_CR_PDDS;\n  POW_SCR |= POW_CR_CSBF;\n}\n```", "```cpp\n#define RTC_BASE (0x40002800)\n#define RTC_CR (*(volatile uint32_t *)(RTC_BASE + 0x08))\n#define RTC_ISR (*(volatile uint32_t *)(RTC_BASE + 0x0c))\n#define RTC_WUTR (*(volatile uint32_t *)(RTC_BASE + 0x14))\n#define RTC_WPR (*(volatile uint32_t *)(RTC_BASE + 0x24))\n#define RTC_CR_WUP (0x03 << 21)\n#define RTC_CR_WUTIE (1 << 14)\n#define RTC_CR_WUTE (1 << 10)\n#define RTC_ISR_WUTF (1 << 10)\n#define RTC_ISR_WUTWF (1 << 2)\n```", "```cpp\n    void rtc_init(void) {\n    ```", "```cpp\n       APB1_CLOCK_ER |= PWR_APB1_CLOCK_ER_VAL;\n    ```", "```cpp\n       POW_CR |= POW_CR_DPB;\n    ```", "```cpp\n       RCC_BACKUP |= RCC_BACKUP_RTCEN;\n    ```", "```cpp\n       RCC_CSR |= RCC_CSR_LSION;\n    ```", "```cpp\n       while (!(RCC_CSR & RCC_CSR_LSIRDY))\n    ```", "```cpp\n         ;\n    ```", "```cpp\n      RCC_BACKUP |= (RCC_BACKUP_RTCSEL_LSI << \n    ```", "```cpp\n          RCC_BACKUP_RTCSEL_SHIFT);\n    ```", "```cpp\n      EXTI_IMR |= (1 << 22);\n    ```", "```cpp\n      EXTI_EMR |= (1 << 22);\n    ```", "```cpp\n      EXTI_RTSR |= (1 << 22);\n    ```", "```cpp\n      RTC_WPR = 0xCA;\n    ```", "```cpp\n      RTC_WPR = 0x53;\n    ```", "```cpp\n       RTC_CR &= ~RTC_CR_WUTE;\n    ```", "```cpp\n       DMB();\n    ```", "```cpp\n       while (!(RTC_ISR & RTC_ISR_WUTWF))\n    ```", "```cpp\n         ;\n    ```", "```cpp\n      RTC_WUTR = (2048 * 5) – 1;\n    ```", "```cpp\n      RTC_CR |= RTC_CR_WUP;\n    ```", "```cpp\n      RTC_ISR &= ~RTC_ISR_WUTF;\n    ```", "```cpp\n       RTC_WPR = 0xb0;\n    ```", "```cpp\n    }\n    ```", "```cpp\n    void rtc_start(void)\n    ```", "```cpp\n    {\n    ```", "```cpp\n       RTC_WPR = 0xCA;\n    ```", "```cpp\n       RTC_WPR = 0x53;\n    ```", "```cpp\n       RTC_CR |= RTC_CR_WUTIE |RTC_CR_WUTE;\n    ```", "```cpp\n       while (((RTC_ISR) & (RTC_ISR_WUTWF)))\n    ```", "```cpp\n         ;\n    ```", "```cpp\n       RTC_WPR = 0xb0;\n    ```", "```cpp\n    }\n    ```", "```cpp\nvoid main(void) {\n  int sleep = 0;\n  clock_pll_on(0);\n  led_setup();\n  rtc_init();\n  timer_init(cpu_freq, 1, 1000);\n  while(1) {\n    if (timer_elapsed) {\n      WFE(); /* Consume timer event */\n      led_toggle();\n      timer_elapsed = 0;\n    }\n    if (tim2_ticks > 10) {\n      sleep = 1;\n      tim2_ticks = 0;\n    }\n    if (sleep) {\n      enter_lowpower_mode();\n      rtc_start();\n      WFE(); /* Never returns */\n    }\n    else\n      WFI();\n  }\n}\n```", "```cpp\nwhile((GPIOX_IDR & (1 << INPUT_PINX)) != 0)\n  ;\n```", "```cpp\nRCC_CSR |= RCC_CSR_LSION;\nwhile (!(RCC_CSR & RCC_CSR_LSIRDY))\n   ;\n```"]