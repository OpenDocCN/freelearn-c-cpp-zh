["```cpp\nvar inventory = [\"Amulet\", \"Bananas\", \"Candles\"]\nprint(inventory.find(\"Bananas\"))\n```", "```cpp\nfunc lower_player_health(amount):\n   player_health -= amount\n```", "```cpp\nfunc <function_name>(<parameter1>, <parameter2>):\n   <code_block>\n```", "```cpp\nfunc say_hello():\n   print(\"Hello, World\")\n```", "```cpp\ncalculate_player_health()\napply_velocity()\nprepare_race()\n```", "```cpp\ndo_the_thing()\ncalculate()\na()\n```", "```cpp\nfunc a_cool_function():\n   print(\"This piece of code will be executed\")\n   return\n   print(\"This piece of code will NEVER EVER be executed\")\n```", "```cpp\nfunc minimum(number1, number2):\n   if number1 < number2:\n      return number1\n   else:\n      minimum() function to get the smallest of the two values:\n\n```", "```cpp\n\n\t\t\tRunning this snippet of code will print the number `2` and will populate the `lowest_number` variable with the number `1`.\n\t\t\tIn this section, we implemented our own `minimum()` function, but this function actually already exists in the engine, called `min()`. So, from now on, you can use the one that the engine provides to find the smallest number.\n\t\t\tThe pass keyword\n\t\t\tWhen creating a new script, we’ve already seen the `_ready()` function structured like this:\n\n```", "```cpp\nextends Node\nvar player_health = 2\nfunc lower_player_health(amount = 1):\n   player_health -= amount\n```", "```cpp\nlower_player_health(5) # Will subtract 5 from the player's health\nlower_player_health(2) # Will subtract 2 from the player's health\nlower_player_health() # Will subtract 1 from the player's health\n```", "```cpp\nfunc move_player(angle, is_running, speed = 20, can_collide = true):\n   # function body\n```", "```cpp\nmove_player(.5, true) # Fill none of the optional parameters\nmove_player(.5, true, 100) # Fill one of the optional parameters\nmove_player(.5, true, 1, false) # Fill two of the optional parameters\n```", "```cpp\nclass Enemy:\n   var damage = 5\n   var health = 10\n   func take_damage(amount):\n      health -= amount\n      if health <= 0:\n         die()\n   func die():\n      print(\"Aaargh I died!\")\n```", "```cpp\nvar enemy = Enemy.new()\n```", "```cpp\nprint(enemy.damage)\nenemy.take_damage(20)\n```", "```cpp\nvar list_of_enemies = [\n   Enemy.new(),\n   Enemy.new(),\n]\nvar dict_of_enemies = {\n   \"Enemy1\": Enemy.new(),\n}\n\nvar enemy = Enemy.new()\nany_function(enemy)\n```", "```cpp\nEnemy\nHealthTracker\nInventoryItem\n```", "```cpp\nclass BuffEnemy extends Enemy:\n   func _init():\n      health = 100\n   func die():\n      print(\"How did you defeat me?!?\")\n```", "```cpp\nvar buff_enemy = BuffEnemy.new()\nprint(buff_enemy.damage)\nbuff_enemy.take_damage(20)\nprint(buff_enemy.health)\nbuff_enemy.take_damage(80)\n```", "```cpp\nclass_name MyCustomNode\nextends Node\n# Rest of the class\n```", "```cpp\nfunc _ready():\n   var player_health = 5\n   if player_health > 2:\n      var damage = 2\n   player_health -= damage\n```", "```cpp\n    var player_health = 2\n    print(player_health)\n    ```", "```cpp\n    var player_health = 2\n    if player_health > 1:\n       print(player_health)\n    ```", "```cpp\n    extends Node\n    var player_health = 2\n    func _ready():\n       print(player_health)\n    ```", "```cpp\nPI # Carries the constant of pi, about 3.1415\nTime\nOS\n```", "```cpp\nextends Node\nvar damage = 3\nfunc a_function():\n   var damage = 100\n   print(damage)\n```", "```cpp\nprint(\"Hey\")\nmax(5, 3) # Returns the highest of the two numbers\nsin(PI) # Returns the sinus value for an angle\n```", "```cpp\nvar number_of_lives = 5\nnumber_of_lives += 1\nnumber_of_lives = {\n   player_lives = 5,\n   enemie_lives = 1,\n}\n1 to the value 5, another number, while in the second instance, we try to add 1 to a whole dictionary. This operation is not supported and thus crashes the game.\n\t\t\tLuckily, there is a way we can leverage our knowledge of what data type we expect for certain operations or functions. This is what we will learn over the course of this section.\n\t\t\tWhat is type hinting?\n\t\t\tOther popular languages such as C++, C#, Java, Golang, and Rust solve the problem of not knowing what data type a variable is by implicitly specifying what type it will carry from the moment it is defined. There is (almost) no way of defining a variable without locking it to a certain type. Also, the type of a variable, unlike in GDScript, cannot be changed over the course of a program in those other languages.\n\t\t\tIn GDScript, there is a system to do something such as this too, but less restrictive. This system is called **type hinting** because we give a hint of what type we would like a variable to be in. This helps GDScript to determine beforehand if an operation will work or is going to crash the game.\n\t\t\tLet’s have a look at different ways to type hint in GDScript.\n\t\t\tType hinting variables\n\t\t\tFor example, if we want to specify that the player’s number of lives will always be a whole number, aka an *integer*, we can give a hint of this variable’s type, like so:\n\n```", "```cpp\n\n\t\t\tWe can do the same for different data types as well:\n\n```", "```cpp\n\n\t\t\tIf we try to assign a value of a different type to a type-hinted variable, as in the following example, the code editor will give us a warning before we run the game and an error while running it:\n\n```", "```cpp\n\n\t\t\tNote that we can only type hint a variable while defining it. After the definition, we can freely use the variable, and the engine needs to know if it is a specific type. That is why we cannot just add a type or change it later on.\n\t\t\tType hinting helps us to catch bugs before they happen!\n\t\t\tType hinting arrays\n\t\t\tOn top of specifying that a certain variable is an `Array` type, we can also specify the type of values we can find within this array. This is very useful and makes it easy for us to know what kind of data to expect within an array.\n\t\t\tTo specify what data types can be found within an array, just mention this type within square brackets after the `Array` type, like so:\n\n```", "```cpp\nvar inventory: Array[String] = [\"Cool glasses\", \"Drinks\", 100]\n```", "```cpp\nfunc take_damage(amount: int):\n   player_health -= amount\n```", "```cpp\ntake_damage(\"Two\")\n```", "```cpp\nfunc take_damage(amount: int = 1):\n   player_health -= amount\n```", "```cpp\nfunc minimum(number_1: float, number_2: float) -> float:\n   if number_1 < number_2:\n      return number_1\n   else:\n      return number_2\n```", "```cpp\nvar player_health: int = 5\nfunc subtract_amount_from_health(amount: int) -> void:\n   player_health -= amount\n```", "```cpp\nvar number_of_lives := 5\n```", "```cpp\nvar number_of_lives\nnumber_of_lives := 5 # This will error\n```", "```cpp\nvar inventory: Array[String] = [\"Bananas\", \"Cinder\", \"Drake\"]\ninventory = null # This is legal\ninventory.find(\"Drake\") # This will crash the game\n```", "```cpp\nclass_name Player\nextends Node\nvar player_health = 2\nfunc _ready():\n   print(player_health)\n```", "```cpp\nvar player: Player = Player.new()\nplayer.player_health += 1\n```", "```cpp\nextends Node\nvar health: int = 2 # Public variable\nvar _weapon: String = \"Sword\" # Private variable\nfunc take_damage(amount: float): # Public function\n   # Take damage in some way\nfunc _calculate_damage() -> float: # Private function\n   # Calculate damage in some way\n```", "```cpp\nclass Enemy:\n   var damage: float\n   var health: float\nclass BuffEnemy extends Enemy:\n   var attack_distance: float = 50\n   func _ready():\n      damage = 2\n      health = 10\nclass StrongEnemy extends Enemy:\n   func _ready():\n      damage = 10\n      health = 1\n```", "```cpp\nvar buff_enemy: BuffEnemy = BuffEnemy.new()\nprint(buff_enemy.damage)\nvar enemy: Enemy = buff_enemy\nprint(enemy.damage)\n```", "```cpp\nvar buff_enemy: BuffEnemy = Enemy.new()\n```", "```cpp\nvar buff_enemy: BuffEnemy = StrongEnemy.new()\n```", "```cpp\nclass Enemy:\n   func die():\n      print(\"Aaargh!\")\nclass BuffEnemy extends Enemy:\n   func die():\n      print(\"How did you defeat me?!?\")\n```", "```cpp\nvar enemy: Enemy = Enemy.new()\nenemy.die()\n```", "```cpp\nvar buff_enemy: BuffEnemy = BuffEnemy.new()\nbuff_enemy.die()\n```", "```cpp\nvar enemy: Enemy = BuffEnemy.new()\nenemy.die()\n```", "```cpp\n    var inventory: Array = [\"Boots\", \"Sword\", \"Grapes\", \"Cuffs\", \"Potion\"]\n    var limited_inventory: Array = limit_inventory(inventory, 2)\n    print(limited_inventory)\n    ```", "```cpp\n    var inventory: Array = [\"Boots\", \"Sword\", \"Grapes\", \"Cuffs\", \"Potion\"]\n    var limited_inventory: Array = limit_inventory(inventory)\n    print(limited_inventory)\n    ```", "```cpp\n    func _ready():\n       var player_health = 5\n       if player_health > 2:\n          var damage = 2\n       player_health -= damage\n    ```", "```cpp\n    var player: Player = Player.new()\n    var enemy: Enemy = Enemy.new()\n    while player.health > 0 and enemy.health > 0:\n       enemy.take_damage(player.damage)\n       player.take_damage(enemy.damage)\n    ```", "```cpp\n    class Enemy:\n       var damage: int = 5\n       # Rest of the class\n    var new_enemy: Enemy = ...\n    ```", "```cpp\n\n```", "```cpp\n\n```"]