<html><head></head><body>
		<div id="_idContainer061">
			<h1 class="chapter-number" id="_idParaDest-84"><a id="_idTextAnchor131"/>6</h1>
			<h1 id="_idParaDest-85"><a id="_idTextAnchor132"/>Building an Online Checkers Game</h1>
			<p>In this chapter, we will delve into the captivating realm of creating an online multiplayer checkers game. We will apply the knowledge and skills we have acquired throughout this book to develop an engaging and interactive <span class="No-Break">gaming experience.</span></p>
			<p>Checkers, a classic <a id="_idIndexMarker181"/>board game enjoyed by players of all ages, provides the perfect canvas to explore the complexity of online multiplayer game development. We will learn how to leverage the power of the Godot Engine and its versatile features to create a seamless multiplayer experience that will have players strategizing, competing, and enjoying the <span class="No-Break">game together.</span></p>
			<p>To facilitate the synchronization of the game state across multiple players, we will introduce a powerful tool called the <strong class="source-inline">MultiplayerSynchronizer</strong> node. This node will play a crucial role in updating the positions of the checkers pieces across the boards of all connected players. By using this node, we can ensure that each player’s game view remains consistent and up to date, enhancing the overall <span class="No-Break">multiplayer experience.</span></p>
			<p>Throughout this chapter, we will cover essential concepts, such as client-server architecture, game synchronization, and player interactions, which are fundamental to the development of any multiplayer game. By understanding these concepts and applying them to our checkers game, we will create a robust and engaging multiplayer experience that will captivate players from around the world. The following diagram showcases the final project, where players are playing against each <span class="No-Break">other online!</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer051">
					<img alt="Figure 6.1 – Player 1’s game instance view and Player 2’s game instance view during the Black Team’s turn" src="image/Figure_06.01_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – Player 1’s game instance view and Player 2’s game instance view during the Black Team’s turn</p>
			<p>In addition to the technical aspects, we will also focus on creating an intuitive user experience that allows players to seamlessly navigate the game and interact with the checkers pieces. A well-designed interface is crucial in enhancing the player experience and ensuring a smooth and enjoyable gameplay session. Using some visual cues, we will ensure that players know the current game <span class="No-Break">state intuitively.</span></p>
			<p>As we progress, we will explore strategies to manage player interactions, such as handling player turns and validating moves. These features are vital in maintaining fairness and ensuring that the game follows the established rules of checkers. By incorporating these elements, we will create an authentic and immersive checkers experience that will engage players for hours <span class="No-Break">on end.</span></p>
			<p>By the end of this chapter, you will have gained valuable insights into the intricacies of online multiplayer game development. You will have the knowledge and skills necessary to create your own multiplayer games, with the ability to synchronize game states, handle player interactions, and deliver an immersive <span class="No-Break">multiplayer experience.</span></p>
			<p>So, get ready to embark on this exciting journey as we delve into the world of online multiplayer checkers game development. To do so, we will learn about the <strong class="source-inline">MultiplayerSynchronizer</strong> node and RPC functions, as they will be our key allies in synchronizing the players’ boards. Let’s begin this chapter and unlock the immense potential of multiplayer game <span class="No-Break">development together.</span></p>
			<p>We will cover the following topics in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>Introducing the <span class="No-Break">Checkers project</span></li>
				<li>Serializing <span class="No-Break">players’ turns</span></li>
				<li>Deserializing the <span class="No-Break">opponent’s turn</span></li>
				<li>Managing win and <span class="No-Break">lose conditions</span></li>
			</ul>
			<h1 id="_idParaDest-86"><a id="_idTextAnchor133"/>Technical requirements</h1>
			<p>In this chapter, we’ll be working with the fourth folder of our Godot Engine project repository, which you can access through the following <span class="No-Break">link: </span><a href="https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0"><span class="No-Break">https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0</span></a><span class="No-Break">.</span></p>
			<p>Another requirement you will need to accomplish before following with our project import is to download Godot Engine version 4.0, as this is the version we will use throughout the <span class="No-Break">whole book.</span></p>
			<p>After opening your Godot Engine 4.0, open the project using the project manager. Then, navigate to the <strong class="source-inline">06.building-online-checkers</strong> folder. Here, you’ll find all the files we used to build this chapter’s project. You can test the game opening and playing the <span class="No-Break"><strong class="source-inline">res://06.building-online-checkers/CheckersGame.tscn</strong></span><span class="No-Break"> scene.</span></p>
			<p>This scene showcases most of the features of our game. In this chapter, we are also going to implement the lobby system we have worked with throughout the book. On top of that, we will turn some local features into online multiplayer features <span class="No-Break">as well.</span></p>
			<p>So, <span class="No-Break">stay tuned.</span></p>
			<h1 id="_idParaDest-87"><a id="_idTextAnchor134"/>Introducing the Checkers project</h1>
			<p>Welcome, respected <a id="_idIndexMarker182"/>network engineer of our esteemed fictional indie development studio! As we embark on this chapter, let us take a moment to familiarize ourselves with the existing Checkers project. Currently, the project is designed for local multiplayers, allowing players to engage in thrilling matches offline. This understanding will serve as a solid foundation as we explore the path toward transforming our Checkers game into a captivating online <span class="No-Break">multiplayer experience.</span></p>
			<p>In this endeavor, our goal is to seamlessly transition the existing local multiplayer functionality into an online environment, without encountering significant obstacles along the way. By leveraging our existing knowledge and skills, we can effectively adapt the game to support online multiplayer, thus expanding its reach and providing players with the opportunity to compete with opponents from around <span class="No-Break">the globe.</span></p>
			<p>Throughout this section, we will unravel our Checkers project’s inner workings, gaining valuable insights into its structure and mechanics. Armed with this understanding, we will be better equipped to navigate the porting process with confidence <span class="No-Break">and efficiency.</span></p>
			<p>As the designated network engineer, you play a pivotal role in this endeavor. Your expertise and problem-solving abilities will be put to the test. With careful consideration and strategic implementation, we can minimize any potential challenges and ensure a seamless transition to the online <span class="No-Break">multiplayer realm.</span></p>
			<p>Together, we will examine the project’s architecture, dissect its components, and identify the necessary modifications required to facilitate online multiplayer functionality. By applying our knowledge of networking concepts and programming techniques, we will construct a robust foundation upon which the online multiplayer features <span class="No-Break">will thrive.</span></p>
			<p>Remember, you are an integral part of this process; as a network engineer, it is your job to implement all online multiplayer code, so you play a fundamental role here. Your skills will contribute to the realization of our vision – a thrilling online multiplayer Checkers game that captivates players across the digital landscape. So, let us embark on this journey. In the upcoming <a id="_idIndexMarker183"/>sections, we will understand the ins and outs of our local <span class="No-Break">Checkers game.</span></p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor135"/>Understanding the Checkers Piece scene</h2>
			<p>The <strong class="bold">Piece</strong> implements the<a id="_idIndexMarker184"/> functionality of a checkers game piece in our checkers’ game. It allows players to interact with the Piece by selecting or deselecting it, keeping track of its selected state. In the following screenshot, we can see the SceneTree <span class="No-Break">structure</span><span class="No-Break">’</span><span class="No-Break">s Piece.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer052">
					<img alt="Figure 6.2 – The Piece scene node hierarchy" src="image/Figure_06.02_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – The Piece scene node hierarchy</p>
			<p>To enhance the player experience and decision-making during their turns, we utilize visual cues provided by the <strong class="source-inline">EnabledColorRect</strong> and <strong class="source-inline">SelectedColorRect</strong> nodes. <strong class="source-inline">EnabledColorRect</strong> becomes visible when the Piece is capable of making a valid move within a player’s turn. Conversely, <strong class="source-inline">SelectedColorRect</strong> becomes visible when a player chooses this specific Piece over others, allowing for clear differentiation <span class="No-Break">between them.</span></p>
			<p>The <strong class="source-inline">Sprite2D</strong> node is responsible for displaying the current texture of the Piece. Depending on the player’s team and whether the Piece has been promoted to a king piece, the texture can represent either a white piece, a black piece, or their respective <span class="No-Break">king versions.</span></p>
			<p>The <strong class="source-inline">SelectionArea2D</strong> node plays a crucial role in detecting player input. By using the <strong class="source-inline">input_event</strong> signal, we establish communication between the player’s clicks and the Piece. This enables us to toggle the Piece’s selection state, determining whether it is currently selected <span class="No-Break">or deselected.</span></p>
			<p>Let’s take a look at its code to understand how each of these nodes plays a role in this <span class="No-Break">whole logic.</span></p>
			<p>Overall, this code forms a <a id="_idIndexMarker185"/>crucial component of the online multiplayer checkers game, providing the necessary functionality to interact with and manage the behavior of individual checkers pieces within <span class="No-Break">the game:</span></p>
			<pre class="source-code">
extends Node2D
signal selected
signal deselected
enum Teams{BLACK, WHITE}
@export var team: Teams = Teams.BLACK
@export var is_king = false: set = _set_is_king
@export var king_texture = preload("res://
    06.building-online-checkers/WhiteKing.svg")
@onready var area = $SelectionArea2D
@onready var selected_color_rect = $SelectedColorRect
@onready var enabled_color_rect = $EnabledColorRect
@onready var sprite = $Sprite2D
var is_selected = false</pre>			<p>We start by defining some variables to store information about the Piece’s team – whether it’s a king, and its texture. It also has references to some child nodes in the scene and a variable to track whether the Piece is currently selected. Signals are defined to indicate when the Piece is selected or deselected. Next, we will declare the setter function we stated in the <span class="No-Break"><strong class="source-inline">_is_king</strong></span><span class="No-Break"> variable:</span></p>
			<pre class="source-code">
func _set_is_king(new_value):
  is_king = new_value
  if not is_inside_tree():
    await(ready)
  if is_king:
    sprite.texture = king_texture</pre>			<p>When this variable is<a id="_idIndexMarker186"/> set to a new value, the code checks whether the node is part of the scene tree. If not, it waits until the node is ready, this prevents any errors when changing the variable’s value through the inspector. If the variable is set to <strong class="source-inline">true</strong>, it updates the visual appearance of the game piece to represent a king, using a specific texture. This allows for dynamic visual changes in the game piece when it becomes a king. After that, we have a signal callback from the <strong class="source-inline">Area2D</strong> node’s <span class="No-Break"><strong class="source-inline">input_event</strong></span><span class="No-Break"> signal:</span></p>
			<pre class="source-code">
func _on_area_2d_input_event(viewport, event, shape_idx):
  if event is InputEventMouseButton:
    if event.button_index == 1 and event.pressed:
      select()</pre>			<p>It listens for left mouse button clicks and, when detected, calls the <strong class="source-inline">select()</strong> method, which, as we will see next, performs the procedures related to selecting the Piece. This code enables interaction within the game when the player clicks the left mouse button while hovering over the Piece’s <strong class="source-inline">Area2D</strong>. Here, we have the code for the <span class="No-Break"><strong class="source-inline">select()</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
func select():
  get_tree().call_group("selected", "deselect")
  add_to_group("selected")
  selected_color_rect.show()
  is_selected = true
  selected.emit()</pre>			<p>In this function, we define what happens when the Piece is selected. It ensures that any previously selected objects are deselected, marks the current object as selected, shows a visual indicator, updates a variable to reflect the selection status, and emits the <strong class="source-inline">selected</strong> signal to notify other parts of the game about the selection event. This code is fundamental for managing and conveying the selected state of Pieces in the game. Then, we also have the opposite <span class="No-Break">function, </span><span class="No-Break"><strong class="source-inline">deselect()</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
func deselect():
  remove_from_group("selected")
  selected_color_rect.hide()
  is_selected = false
  deselected.emit()</pre>			<p>Here, we define what happens when an object is deselected. The code removes the object from the <strong class="source-inline">"selected"</strong> group, hides the visual indicator of selection, updates the <strong class="source-inline">is_selected</strong> variable to reflect the deselection status, and emits the <strong class="source-inline">deselected</strong> signal to notify other parts of the game about the deselection event. Now, it’s time to enable the change in selection states; without that, the Piece shouldn’t be selectable. This helps to prevent players <a id="_idIndexMarker187"/>from selecting Pieces from the <span class="No-Break">opponent’s team:</span></p>
			<pre class="source-code">
func enable():
  area.input_pickable = true
  enabled_color_rect.visible = true</pre>			<p>In this part, we make the <strong class="source-inline">Area2D</strong> responsive to input events, and we also make a visual indicator visible on the screen. This is important to allow players to interact with and manipulate Pieces in the game when they are in an enabled state. Now, let’s see its counterpart, the <span class="No-Break"><strong class="source-inline">disable()</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
func disable():
  area.input_pickable = false
  enabled_color_rect.visible = false</pre>			<p>It’s essentially the<a id="_idIndexMarker188"/> opposite of the previous method. We make the <strong class="source-inline">Area2D</strong> non-responsive to input events, effectively making it non-interactive. On top of that, we hide the visual indicator on the screen that represents the Piece’s availability, visually representing the Piece’s disabled state. This is useful for controlling when and how players can interact with Pieces in <span class="No-Break">the game.</span></p>
			<p>In the upcoming section, we are going to see how the FreeCell scene works. It’s a scene we use to highlight the available free cells that a selected Piece can <span class="No-Break">move to.</span></p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor136"/>Comprehending the FreeCell scene</h2>
			<p>In our game project, we have a<a id="_idIndexMarker189"/> concept called <strong class="bold">FreeCell</strong>, which represents a valid cell that a Piece can move to. Think of it as a designated area where the Piece is allowed to go. Each time the player selects a Piece with valid movement, we visually indicate the available cells by showing them in green. These cells are actually instances of the FreeCell scene, which we dynamically create and display on the <span class="No-Break">game board.</span></p>
			<p>To provide a clear example, imagine a scenario where a king Piece is selected. In the following diagram, you can see that all the cells where this king Piece can move to are highlighted in green. Each of these highlighted cells is an instance of the FreeCell scene, which allows the player to quickly identify the possible movement options for the <span class="No-Break">selected Piece.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer053">
					<img alt="Figure 6.3 – Free cells available to the selected king piece" src="image/Figure_06.03_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 – Free cells available to the selected king piece</p>
			<p>By using the FreeCell concept, we enhance the player’s experience by visually communicating the valid movement possibilities. This empowers them to make informed decisions and strategize their next move effectively. It’s a powerful tool that adds clarity and depth to the <span class="No-Break">gameplay mechanics.</span></p>
			<p>The FreeCell scene is an essential component of our game, composed of three distinct nodes. The main node is an <strong class="source-inline">Area2D</strong>, which serves as the foundation for the FreeCell. It encompasses two child nodes – a <strong class="source-inline">CollisionShape2D</strong> and <span class="No-Break">a </span><span class="No-Break"><strong class="source-inline">ColorRect</strong></span><span class="No-Break">.</span></p>
			<p>The <strong class="source-inline">CollisionShape2D</strong> node is responsible for defining the shape and boundaries of the FreeCell. It ensures that the cell can properly interact with other game objects, such as Pieces or other elements within the game world. As we are about to see, <strong class="source-inline">CollisionShape2D</strong> also defines the boundaries in which the <strong class="source-inline">Area2D</strong> detects mouse inputs, which is fundamental for the <span class="No-Break">FreeCell’s behavior.</span></p>
			<p>The <strong class="source-inline">ColorRect</strong> node, conversely, controls the<a id="_idIndexMarker190"/> visual representation of the FreeCell. It determines the color and appearance of the cell, providing a visual indicator to distinguish it from other elements on the <span class="No-Break">game board.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer054">
					<img alt="Figure 6.4 – The FreeCell scene node hierarchy&#13;&#10;" src="image/Figure_06.04_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4 – The FreeCell scene node hierarchy</p>
			<p>To better understand the functionality and behavior of the FreeCell, let’s explore its accompanying script. By examining the script code, we will gain insights into how the FreeCell operates and interacts with other game elements, ultimately contributing to the overall game logic <span class="No-Break">and mechanics:</span></p>
			<pre class="source-code">
extends Area2D
signal selected(cell_position)
func _input_event(viewport, event, shape_idx):
     if event is InputEventMouseButton:
          if event.button_index == 1 and event.pressed:
               select()
func select():
     selected.emit(self.position)</pre>			<p>This code allows the cell, represented by <strong class="source-inline">Area2D</strong>, to respond to right mouse button events within its area. When a cell is selected, it emits a signal with the position of the cell. This signal can be used to inform other objects or scripts about the selection and provide them with the cell’s position for further processing. We’ll use this in the <strong class="source-inline">CheckerBoard</strong> script to map the <a id="_idIndexMarker191"/>FreeCell’s position into the <span class="No-Break">board’s cell.</span></p>
			<p>In the upcoming section, we will introduce the game board, an essential component of our game. We will then shift our focus to the core of this chapter, which involves implementing methods that we will turn into RPCs. These RPCs will enable the game to work seamlessly in an online environment, allowing players to interact with each other and synchronize their actions over <span class="No-Break">the network.</span></p>
			<p>By leveraging the power of RPCs, we will create a dynamic and engaging multiplayer experience for our players. Let’s dive into the details and explore how these methods will bring our game to life in an <span class="No-Break">online setting.</span></p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor137"/>Introducing the CheckerBoard scene</h2>
			<p>In this section, let’s delve into the <a id="_idIndexMarker192"/>primary role of the game board, as this will serve as a foundation for our upcoming sections. By understanding the key responsibilities of the board, we can naturally identify the specific areas we will be focusing on in the subsequent sections. This understanding will pave the way for a clear and structured approach as we continue exploring our checker’s <span class="No-Break">development process.</span></p>
			<p>The primary role of our game board is to manage the relationship between the black and white pieces in the game. To achieve this, the board utilizes the built-in <strong class="source-inline">TileMap</strong> functions to map the pieces onto cartesian coordinates. Additionally, it employs a hash map to associate the content of each cell on <span class="No-Break">the board.</span></p>
			<p>This means that we can access the content of a specific cell by providing its corresponding <strong class="source-inline">Vector2i</strong> coordinate. For example, by using the <strong class="source-inline">meta_board[Vector2i(0,3)]</strong> expression, we can retrieve the contents of the cell located in the first column and fourth row of the board. The result of this access will either be <strong class="source-inline">null</strong>, indicating that the cell is free, or it will return the Piece that is currently mapped to that particular cell. This mechanism allows for efficient retrieval and manipulation of the contents on the board, enabling seamless gameplay and interaction with <span class="No-Break">the pieces.</span></p>
			<p>The CheckerBoard plays a vital role in our game by overseeing various aspects of gameplay. Firstly, it manages the available movements for each cell on the board, taking into account the current team in play and whether a Piece has been promoted to a king. This ensures that players can only make valid moves based on the rules of <span class="No-Break">the game.</span></p>
			<p>The CheckerBoard is also responsible for controlling the turns in the game. It enables and disables the Pieces according to the active team, allowing only the team in play to make moves during their turn. This mechanism ensures fair gameplay and maintains the flow of <span class="No-Break">the game.</span></p>
			<p>Furthermore, the<a id="_idIndexMarker193"/> CheckerBoard keeps track of the number of Pieces each team possesses at the end of each turn. This count is crucial, as it determines the win-lose condition of the game. If a team has no remaining Pieces on the board, the CheckerBoard triggers the appropriate <strong class="source-inline">win</strong> condition, declaring the opposing team as <span class="No-Break">the winner.</span></p>
			<p>By managing the cell movements, regulating turns, and monitoring the Piece count, the CheckerBoard maintains the game’s rules and progression. Its role is fundamental to providing clear conditions for victory or defeat. Let’s take a look at the CheckerBoard <span class="No-Break">scene structure:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer055">
					<img alt="Figure 6.5 – The CheckerBoard scene node hierarchy" src="image/Figure_06.05_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.5 – The CheckerBoard scene node hierarchy</p>
			<p>It’s important to <a id="_idIndexMarker194"/>note that the CheckerBoard is implemented as <strong class="source-inline">TileMap</strong>, a useful class in our game. We use specific methods provided by the <strong class="source-inline">TileMap</strong> class, such as <strong class="source-inline">map_to_local()</strong>, <strong class="source-inline">local_to_map()</strong>, and <strong class="source-inline">get_used_cells()</strong>, to establish our cell-mapping functionality. The <strong class="source-inline">map_to_local()</strong> method will help us map the game to cell positions in <strong class="source-inline">TileMap</strong>, while <strong class="source-inline">local_to_map()</strong> will help us convert the Pieces’ positions to cells in the map. This will help us abstract the game in terms of rows and columns instead of floating-point numbers. As for the <strong class="source-inline">get_used_cells()</strong> method, it will help us access only the cells that have a tile set to them and avoid dealing with blank cells in <strong class="source-inline">TileMap</strong>. This will be useful when we create a matrix of the <span class="No-Break">cells’ contents.</span></p>
			<p>In the <strong class="source-inline">CheckerBoard</strong> class, we’ll focus on understanding the significance of the <strong class="source-inline">meta_board</strong> <strong class="bold">Dictionary</strong>, which serves as a fundamental component in subsequent sections. The core features we need to understand in order to turn this project into an online multiplayer checkers game are the <strong class="source-inline">create_meta_board()</strong> and <strong class="source-inline">map_pieces()</strong> methods within the <span class="No-Break"><strong class="source-inline">CheckerBoard</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
func create_meta_board():
     for cell in get_used_cells(0):
          meta_board[cell] = null
func map_pieces(team):
     for piece in team.get_children():
          var piece_position = local_to_map(piece.position)
          meta_board[piece_position] = piece
          piece.selected.connect(_on_piece_selected.bind
              (piece))</pre>			<p>The <strong class="source-inline">create_meta_board()</strong> method is responsible for setting up the <strong class="source-inline">meta_board</strong> Dictionary. This Dictionary acts as a data structure that maps cell coordinates to their corresponding contents. By leveraging the <strong class="source-inline">TileMap</strong> methods mentioned earlier, the <strong class="source-inline">create_meta_board()</strong> method populates <strong class="source-inline">meta_board</strong> with the appropriate cell coordinates and initializes them with null values, indicating <span class="No-Break">empty cells.</span></p>
			<p>Conversely, the <strong class="source-inline">map_pieces()</strong> method performs an essential role in updating the <strong class="source-inline">meta_board</strong> to reflect the current state of the game. This method iterates over all the Pieces on the provided team, which is passed as a reference to either the <strong class="source-inline">BlackTeam</strong> node or the <strong class="source-inline">WhiteTeam</strong> node. Then, it converts the Pieces’ positions using the <strong class="source-inline">TileMap.local_to_map()</strong> method and maps each Piece to its respective cell coordinate in <strong class="source-inline">meta_board</strong>. This ensures that <strong class="source-inline">meta_board</strong> accurately represents the placement of Pieces on the <span class="No-Break">visual board.</span></p>
			<p>Lastly, the code establishes a <a id="_idIndexMarker195"/>connection between the <strong class="source-inline">Piece.selected</strong> signal and the <strong class="source-inline">_on_piece_selected()</strong> callback function. By connecting this signal, we bind the current Piece to the callback function as its argument. This enables us to conveniently access the <strong class="source-inline">Piece</strong> node whenever the player <span class="No-Break">selects it.</span></p>
			<p>This connection ensures that when the Piece emits the selected signal, the associated callback function, <strong class="source-inline">_on_piece_selected()</strong>, will be invoked and provided with the <strong class="source-inline">Piece</strong> node as its argument. This mechanism allows us to perform specific actions or access properties of the <strong class="source-inline">Piece</strong> node, in response to the <span class="No-Break">player’s selection.</span></p>
			<p>By establishing this connection, we create a seamless interaction between the <strong class="source-inline">Piece</strong> node and the corresponding callback function, enhancing the flexibility and responsiveness of <span class="No-Break">our game.</span></p>
			<p>There are some auxiliary functions that help us calculate available cells and coordinate the Piece’s movement; feel free to check them out and understand how we check for available cells, how we capture cells, and other gameplay features. In the next section, we will explore a different aspect of our checkers <span class="No-Break">development journey.</span></p>
			<p>We will focus on how we can package and transmit all the pertinent information about a player’s turn across the network, ensuring that other players are promptly updated with the current state of the <span class="No-Break">game</span><span class="No-Break"><a id="_idIndexMarker196"/></span><span class="No-Break"> board.</span></p>
			<p>By understanding this process, we will be able to establish efficient communication between players, facilitating a seamless multiplayer experience. This functionality is essential for maintaining synchronization and enabling real-time gameplay in our online multiplayer game. Stay tuned as we dive into the intricacies of transmitting and updating the game state across <span class="No-Break">the network.</span></p>
			<h1 id="_idParaDest-91"><a id="_idTextAnchor138"/>Serializing players’ turns</h1>
			<p>In <a href="B18527_02.xhtml#_idTextAnchor037"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Sending and Receiving Data</em>, we explored an essential technique to recreate the game<a id="_idIndexMarker197"/> state across multiple players in a network. By serializing the relevant data and transmitting it in small portions, we ensure efficient utilization of network bandwidth while maintaining synchronization <span class="No-Break">among peers.</span></p>
			<p>Developing an understanding of what information is crucial to replicate the game state among players involves mastering the concept of abstraction in game development. In our case, this primarily revolves around <strong class="source-inline">meta_board</strong>, which is an abstraction of the relevant metadata of our game, such as the positional data and king state of the Pieces and the empty cells in <span class="No-Break">the board.</span></p>
			<p>Additionally, we need to consider the availability of Pieces, depending on the players’ turn. Fortunately, most other elements of the game can be managed locally without requiring <span class="No-Break">network synchronization.</span></p>
			<p>To simplify the process of synchronizing node properties across networked peers, I would like to introduce you to <strong class="source-inline">MultiplayerSynchronizer</strong>. This powerful node takes on the responsibility of automatically synchronizing properties across peers, relieving us from the tedious task of <span class="No-Break">manual synchronization.</span></p>
			<p>With <strong class="source-inline">MultiplayerSynchronizer</strong> in place, we can focus on developing the game’s logic and let the node handle the efficient transmission of data <span class="No-Break">among players.</span></p>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor139"/>Working with MultiplayerSynchronizer</h2>
			<p><strong class="source-inline">MultiplayerSynchronizer</strong> plays a vital role by allowing us to effortlessly sync and share the state of<a id="_idIndexMarker198"/> nodes across multiple players, without writing any additional code. To begin utilizing this functionality, we will add a <strong class="source-inline">MultiplayerSynchronizer</strong> node to the Piece’s scene. This will ensure consistency in the game state of each player. Let’s dive into the process of integrating the <strong class="source-inline">MultiplayerSynchronizer</strong> and harnessing <span class="No-Break">its capabilities.</span></p>
			<h3>Setting up MultiplayerSynchronizer in the Piece scene</h3>
			<p>Open<a id="_idIndexMarker199"/> the <strong class="source-inline">res://06.building-online-checkers/Piece.tscn</strong> scene and add a <strong class="source-inline">MultiplayerSynchronizer</strong> as a child of the <strong class="source-inline">Piece</strong> node. Then, we’ll set up the properties we want <span class="No-Break">to synchronize:</span></p>
			<ol>
				<li>With the <strong class="source-inline">MultiplayerSychronizer</strong> node selected, in the bottom panel on the <strong class="bold">Replication</strong> tab, click the <strong class="bold">Add property to </strong><span class="No-Break"><strong class="bold">sync</strong></span><span class="No-Break"> button.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer056">
					<img alt="Figure 6.6 – The Replication menu from the MultiplayerSynchronizer node" src="image/Figure_06.06_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.6 – The Replication menu from the MultiplayerSynchronizer node</p>
			<ol>
				<li value="2">From the pop-up menu, select the <span class="No-Break"><strong class="bold">Piece</strong></span><span class="No-Break"> node.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer057">
					<img alt="Figure 6.7 – Selecting the Piece node from the Pick a ﻿node to ﻿synchronize pop-up menu" src="image/Figure_06.07_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.7 – Selecting the Piece node from the Pick a node to synchronize pop-up menu</p>
			<ol>
				<li value="3">After<a id="_idIndexMarker200"/> selecting the <strong class="bold">Piece</strong> node, another pop-up menu will appear, asking you to select the property you want to sync. From there, select the <span class="No-Break"><strong class="bold">position</strong></span><span class="No-Break"> property.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer058">
					<img alt="Figure 6.8 – Choosing the position property from the Select Property pop-up menu" src="image/Figure_06.08_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.8 – Choosing the position property from the Select Property pop-up menu</p>
			<p>And that’s it. With<a id="_idIndexMarker201"/> that, as soon as the players are connected to the same network, they will automatically sync their Pieces’ positions on the board. However, we still have an issue as this only updates the visual representation of the Piece, and we still need to update its data in <strong class="source-inline">meta_board</strong>. Now comes the <span class="No-Break">fun part.</span></p>
			<p>In the next section, we will start to understand the methods in the CheckerBoard that we need to turn into RPCs, keeping players on the <span class="No-Break">same page.</span></p>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor140"/>Updating and syncing the CheckerBoard</h2>
			<p>A core issue when<a id="_idIndexMarker202"/> developing any application is that we have limited resources. In the case of transmitting data over a network, we are talking about bandwidth. Games are a special case because everything should happen in real time, so we can’t risk heavy data transmission that hurts <span class="No-Break">network performance.</span></p>
			<p>To turn this in our favor, we need to pass data in the most abstract and lightweight way we can. In our case, we have our <strong class="source-inline">meta_board</strong> as a means to represent the game’s current state. By using <strong class="source-inline">Vector2i</strong> coordinates, we can access and change the game states. And that’s how we are going to keep players updated. In the next section, we are going to work with the <strong class="source-inline">CheckerBoard.update_cells()</strong> method, which is the core of our <span class="No-Break">update system.</span></p>
			<h3>Using coordinates to update the board</h3>
			<p>Since <strong class="source-inline">meta_board</strong> is a <a id="_idIndexMarker203"/>Dictionary, we can access and set the values of its keys using Godot Engine’s built-in types. For instance, if we want to change the content of the cell in the third row second column to <strong class="source-inline">null</strong>, we can write <strong class="source-inline">meta_board[Vectori(1, 2)] = </strong><span class="No-Break"><strong class="source-inline">null</strong></span><span class="No-Break">.</span></p>
			<p>When Pieces perform a move, we just need to know the content of the previous and new cell of this movement, so that we can update it. And that’s exactly what the <strong class="source-inline">update_cells()</strong> method does. Let’s take a look <span class="No-Break">at it:</span></p>
			<pre class="source-code">
func update_cells(previous_cell, target_cell):
     meta_board[target_cell] = meta_board[previous_cell]
     meta_board[previous_cell] = null</pre>			<p>Since this is the very core of our update system, we need to turn it into an RPC function and call it <span class="No-Break">as such.</span></p>
			<p>For that, let’s make the appropriate changes in <span class="No-Break">our script:</span></p>
			<ol>
				<li>Add the <strong class="source-inline">@rpc</strong> annotation to this method, using the <strong class="source-inline">any_peer</strong> and <strong class="source-inline">call_local</strong> options. We use these because we want every player to update others about changes in their board, and we also want their own board to update itself, hence the <span class="No-Break"><strong class="source-inline">call_local</strong></span><span class="No-Break"> option:</span><pre class="source-code">
@rpc("any_peer", "call_local")
func update_cells(previous_cell, target_cell):</pre></li>				<li>In the <strong class="source-inline">move_selected_piece()</strong> method, change the <strong class="source-inline">update_cells(current_cell, target_cell)</strong> line to an RPC call instead. This will make the call of this method both local and remote on other peers <span class="No-Break">as well:</span><pre class="source-code">
func move_selected_piece(target_cell):
     var current_cell = local_to_map
         (selected_piece.position)
     Selected_piece.position = map_to_local
         (target_cell)
     rpc("update_cells", current_cell, target_cell)
     if not is_free_cell(target_cell):
          crown(target_cell)</pre></li>			</ol>
			<p>With that, every time the CheckerBoard moves a Piece, it updates its <strong class="source-inline">meta_board</strong> data on all peers on <span class="No-Break">the network.</span></p>
			<p>Note that there’s another method that we can turn into an RPC as well. Every player should update <strong class="source-inline">Piece.is_king</strong> of a Piece that reached their opponent’s king row. For that, we have the <strong class="source-inline">crown()</strong>method that <strong class="source-inline">move_selected_piece()</strong> calls at the bottom of <span class="No-Break">its logic.</span></p>
			<p>Let’s do the<a id="_idIndexMarker204"/> same thing we did with <strong class="source-inline">update_cells()</strong> with the <span class="No-Break"><strong class="source-inline">crown()</strong></span><span class="No-Break"> method:</span></p>
			<ol>
				<li>First, we add the <strong class="source-inline">@rpc</strong> annotation to it with the <strong class="source-inline">any_peer</strong> and <span class="No-Break"><strong class="source-inline">call_local</strong></span><span class="No-Break"> options:</span><pre class="source-code">
@rpc("any_peer", "call_local")
func crown(cell):</pre></li>				<li>Then, we change the <strong class="source-inline">crown(target_cell)</strong> call to its <span class="No-Break"><strong class="source-inline">rpc()</strong></span><span class="No-Break"> version:</span><pre class="source-code">
func move_selected_piece(target_cell):
     var current_cell = local_to_map
         (selected_piece.position)
     selected_piece.position = map_to_local
         (target_cell)
     rpc("update_cells", current_cell, target_cell)
     if not is_free_cell(target_cell):
          rpc("crown", target_cell)</pre></li>			</ol>
			<p>With that, when a Piece reaches the king row, all players’ CheckerBoards update their king state, be it an opponent Piece or an <span class="No-Break">ally Piece.</span></p>
			<p>Our work isn’t <a id="_idIndexMarker205"/>done yet. In the next section, we will see how we update the <strong class="source-inline">meta_board</strong> content when players perform a capturing movement, meaning we need to remove a Piece from <span class="No-Break">the board.</span></p>
			<h3>Removing a Piece from the board</h3>
			<p>When a player <a id="_idIndexMarker206"/>makes a move that ends up capturing an opponent Piece, we should update the game board accordingly. This means that on top of updating the cells involved in the movement, we should also update the cell where the captured Piece was, setting its content to null – in other words, turning it into a free cell. That’s what the <strong class="source-inline">remove_piece()</strong> <span class="No-Break">method does.</span></p>
			<p>Let’s take a look at <span class="No-Break">its code:</span></p>
			<pre class="source-code">
func remove_piece(piece_cell):
     if not is_on_board(piece_cell):
          return
     if is_free_cell(piece_cell):
          return
     var piece = meta_board[piece_cell]
     piece.get_parent().remove_child(piece)
     piece.free()
     meta_board[piece_cell] = null</pre>			<p>Since this behavior impacts both players, we need to turn this method into an RPC as well so that every time a player captures a Piece, they update their opponent with this <span class="No-Break">sad fact.</span></p>
			<p>Let’s make the appropriate changes so that this feature is compliant with our online <span class="No-Break">multiplayer demands:</span></p>
			<ol>
				<li>Add the <strong class="source-inline">@rpc</strong> annotation to the <strong class="source-inline">remove_piece()</strong> method with the <strong class="source-inline">any_peer</strong> and <span class="No-Break"><strong class="source-inline">call_local</strong></span><span class="No-Break"> options:</span><pre class="source-code">
@rpc("any_peer", "call_local")
func remove_piece(piece_cell):</pre></li>				<li>In <a id="_idIndexMarker207"/>the <strong class="source-inline">capture_piece()</strong> method, update the <strong class="source-inline">remove_piece(cell)</strong> line to its <span class="No-Break"><strong class="source-inline">rpc()</strong></span><span class="No-Break"> version:</span><pre class="source-code">
func capture_pieces(target_cell):
     var origin_cell = local_to_map(selected_piece.
         position)
     var direction = Vector2(target_cell -origin_cell)
         .normalized()
     direction = Vector2i(direction.round())
     var cell = target_cell - direction
     if not is_on_board(cell):
          return
     if not is_free_cell(cell):
          rpc("remove_piece", cell)
          move_selected_piece(target_cell)</pre></li>			</ol>
			<p>Now, every time a player<a id="_idIndexMarker208"/> captures a cell, it calls the <strong class="source-inline">remove_piece()</strong> method both locally and remotely on all <span class="No-Break">connected peers!</span></p>
			<p>With that, we have our players turn properly serialized and ready to be passed through the network to other peers, with good performance and little data usage, leaving a good bandwidth for us if we so desire. For instance, we can add a chat feature using a new RPC channel if we want to in <span class="No-Break">the future.</span></p>
			<p>In this section, we learned about the importance of abstracting relevant data for our network communication and how to turn local functionalities into remote functionalities, while maintaining all their logic and overall structure. Here, we saw the relevance of the <strong class="source-inline">call_local</strong> RPC option as well as the simplicity of turning a method call into an RPC call with the <span class="No-Break"><strong class="source-inline">rpc()</strong></span><span class="No-Break"> method.</span></p>
			<p>In the next section, we will see how we manage the turn logic. This is an important feature to handle because there we will need to actively add a layer of network verification to properly handle the turns. The logic of a local turn shift and a remote turn shift is <span class="No-Break">very distinct.</span></p>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor141"/>Handling remote turn shifts</h1>
			<p>One of the most important <a id="_idIndexMarker209"/>aspects of playing a game online is to maintain players’ autonomy and authority over their resources – in this case, their team’s Pieces. Godot Engine offers an interesting system where a SceneTree can structure its nodes’ hierarchies with distinct <span class="No-Break">Multiplayer Authorities.</span></p>
			<p>To set up a node and its children’s Multiplayer Authority, recursively, we can use <strong class="source-inline">set_multiplayer_authority()</strong> and pass the respective peer’s ID as an argument. In our case, we are going to change the <strong class="source-inline">BlackTeam</strong> and <strong class="source-inline">WhiteTeam</strong> nodes’ Multiplayer Authority to match their respective players’ <span class="No-Break">peer IDs.</span></p>
			<p>This will be done by the server, so to keep the application simple, we are going to allow clients and server to share the same script, and we will check which one is running the server instance by using <strong class="source-inline">is_multiplayer_authority()</strong> on the CheckerBoard. We should only run this logic if the game is running in a network and there are peers connected. For that, we can check whether <strong class="source-inline">multiplayer.get_peers().size()</strong> is greater than <strong class="source-inline">0</strong>, meaning there are peers connected. Let’s see this in practice, <span class="No-Break">shall we?</span></p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor142"/>Setting up players’ teams</h2>
			<p>The first thing we need to understand<a id="_idIndexMarker210"/> to handle players’ turn shifts is that each one of the nodes that represent the team – in other words, the <strong class="source-inline">BlackTeam</strong> and the <strong class="source-inline">WhiteTeam</strong> nodes – should have its respective players’ peer IDs set as their <span class="No-Break">Multiplayer Authorities.</span></p>
			<p>In that sense, we need to create a method in the <strong class="source-inline">CheckerBoard</strong> class that receives the team and the peer ID as arguments. Remember, we can’t pass objects as arguments in this method because it needs to work in the network. So, we need to abstract teams as an <strong class="source-inline">enum</strong> that we can pass around through RPCs, and then all peers will be able to understand the message and access the correct team node at their end. Let’s dive into the action and create a method <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">setup_team()</strong></span><span class="No-Break">:</span></p>
			<ol>
				<li>Add the <strong class="source-inline">@rpc("authority", "call_local")</strong> decorator before the <strong class="source-inline">setup_team()</strong> function definition. The <strong class="source-inline">authority</strong> option indicates that this RPC can only be called by the Multiplayer Authority; remember that the authority of the CheckerBoard will still be the server. The <strong class="source-inline">call_local</strong> argument specifies that the function should also be executed locally on the <span class="No-Break">calling peers:</span><pre class="source-code">
@rpc("authority", "call_local")
func setup_team(team, peer_id):</pre></li>				<li>Inside the<a id="_idIndexMarker211"/> function, check whether the value of <strong class="source-inline">team</strong> is equal to <strong class="source-inline">Teams.BLACK</strong>; if this is the case, call the <strong class="source-inline">set_multiplayer_authority()</strong> method on the <strong class="source-inline">black_team</strong> object and pass <strong class="source-inline">peer_id</strong> as an argument. This effectively designates the specified peer as the authority for <strong class="source-inline">BlackTeam</strong> and all its children – in other words, the <span class="No-Break">black Pieces:</span><pre class="source-code">
@rpc("authority", "call_local")
func setup_team(team, peer_id):
     if team == Teams.BLACK:
          black_team.set_multiplayer_authority
              (peer_id)</pre></li>				<li>Otherwise, call the <strong class="source-inline">set_multiplayer_authority()</strong> method on the <strong class="source-inline">white_team</strong> object and pass <strong class="source-inline">peer_id</strong> as <span class="No-Break">an argument:</span><pre class="source-code">
@rpc("authority", "call_local")
func setup_team(team, peer_id):
     if team == Teams.BLACK:
          black_team.set_multiplayer_authority
              (peer_id)
     else:
          white_team.set_multiplayer_authority
              (peer_id)</pre></li>			</ol>
			<p>This method sets up the<a id="_idIndexMarker212"/> Multiplayer Authority of a team node based on the received team, <strong class="source-inline">black_team</strong> or <strong class="source-inline">white_team</strong>, using the provided <strong class="source-inline">peer_id</strong>. This ensures that the Multiplayer Authority for each team is correctly established, allowing the game logic to be synchronized across networked peers. Since the server calls this method on all peers, both players and the server will sync their team <span class="No-Break">nodes accordingly.</span></p>
			<p>Now, to ensure that this mechanism will be established among all peers, we are going to add the following lines of code right inside the <span class="No-Break"><strong class="source-inline">_ready()</strong></span><span class="No-Break"> callback:</span></p>
			<ol>
				<li>Inside the <strong class="source-inline">_ready()</strong> callback, check whether there are peers connected in the multiplayer session by checking whether the size of <strong class="source-inline">multiplayer.get_peers()</strong> array is greater <span class="No-Break">than </span><span class="No-Break"><strong class="source-inline">0</strong></span><span class="No-Break">:</span><pre class="source-code">
func _ready():
     if multiplayer.get_peers().size() &gt; 0:</pre></li>				<li>If this is the case, check whether the current node is the Multiplayer Authority by using the <strong class="source-inline">is_multiplayer_authority()</strong> function. This ensures that we will only call the following logic in the <span class="No-Break">server peer:</span><pre class="source-code">
func _ready():
     if multiplayer.get_peers().size() &gt; 0:
          if is_multiplayer_authority():</pre></li>				<li>Then, make an RPC using the <strong class="source-inline">rpc()</strong> method, with the <strong class="source-inline">"setup_team "</strong> , <strong class="source-inline">Teams.BLACK</strong>, and <strong class="source-inline">multiplayer.get_peers()[0]</strong> arguments. This will call the <strong class="source-inline">setup_team()</strong> method on all connected peers, telling them to set the BlackTeam’s Multiplayer Authority using the first peer ID in the list of connected peers. So, the first player connected in the session will be responsible for the <span class="No-Break">black Pieces:</span><pre class="source-code">
func _ready():
     if multiplayer.get_peers().size() &gt; 0:
          if is_multiplayer_authority():
               rpc("setup_team", Teams.BLACK,
                   multiplayer.get_peers()[0])</pre></li>				<li>Right below the<a id="_idIndexMarker213"/> previous line, we are going to do the same thing but use <strong class="source-inline">Teams.WHITE</strong> and the connected peers’ list second index, meaning the second player that connected to <span class="No-Break">the session:</span><pre class="source-code">
func _ready():
     if multiplayer.get_peers().size() &gt; 0:
          if is_multiplayer_authority():
               rpc("setup_team", Teams.BLACK,
                   multiplayer.get_peers()[0])
               rpc("setup_team", Teams.WHITE,
                   multiplayer.get_peers()[1])</pre></li>			</ol>
			<p>With that, we have our<a id="_idIndexMarker214"/> team setup in place. Note that, since the server has both team nodes’ Multiplayer Authorities assigned to each of the players in the match, the server itself can’t perform any movement in the <span class="No-Break">board’s Pieces.</span></p>
			<p>Talking about that prevention mechanism, how does it work? How does the CheckerBoard prevent players from interacting with Pieces, especially with their opponent Pieces? In the next section, we are going to see how we can detect which player is assigned to which team and only re-enable their appropriate <span class="No-Break">team Pieces.</span></p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor143"/>Enabling and disabling team pieces</h2>
			<p>In our game, when players end a turn, we<a id="_idIndexMarker215"/> disable all their pieces using the <strong class="source-inline">disable_pieces()</strong> method. In turn shifts, we make sure to disable both teams’ Pieces, and we also check whether there’s a winner from the past turn; if not, we start the procedure to re-enable players’ Pieces based on the <span class="No-Break">turn’s team.</span></p>
			<p>All of that happens in the <strong class="source-inline">toggle_turn()</strong> method, but as it is, it won’t work in an online multiplayer scenario because, currently, the method performs only local logic. So, let’s turn it into a method that will work for our improved online multiplayer <span class="No-Break">checkers game.</span></p>
			<p>However, before that, let’s see how the code is right now so we can already pick where we will need to <span class="No-Break">make adjustments:</span></p>
			<pre class="source-code">
func toggle_turn():
     clear_free_cells()
     disable_pieces(white_team)
     disable_pieces(black_team)
     var winner = get_winner()
     if winner:
          player_won.emit(winner)
          return
     if current_turn == Teams.BLACK:
          current_turn = Teams.WHITE
          enable_pieces(white_team)
     else:
          current_turn = Teams.BLACK
          enable_pieces(black_team)</pre>			<p>This function is<a id="_idIndexMarker216"/> responsible for managing the turn-based logic of a game. It first clears the available cells for movements and then disables the pieces of both teams. Then, it checks whether there is a winner and, if so, emits a signal to the <strong class="source-inline">CheckersGame</strong> script’s <strong class="source-inline">_on_checker_board_player_won()</strong> method, indicating the winning team. If there is no winner, it switches the turn to the other team and enables the pieces of the <span class="No-Break">corresponding team.</span></p>
			<p>Can you point out where we need to make the necessary changes in order to make it work in our online version of the game? Remember that the game should work both locally and remotely, so we need to maintain the overall outcome of this method. Let’s begin <span class="No-Break">the process:</span></p>
			<ol>
				<li>Decorate the <strong class="source-inline">toggle_turn()</strong> method with the <strong class="source-inline">@rpc</strong> annotation, using the <strong class="source-inline">any_peer</strong> and the <strong class="source-inline">call_local</strong> options. This indicates that any peer can call this method remotely in the multiplayer session, but they should also call it locally. This ensures that even if we are playing the game without joining a multiplayer session, we can call this method locally, using the <strong class="source-inline">rpc()</strong> method, and everything will <span class="No-Break">still work:</span><pre class="source-code">
@rpc("any_peer", "call_local")
func toggle_turn():</pre></li>				<li>Inside that, check <a id="_idIndexMarker217"/>whether the <strong class="source-inline">current_turn</strong> is <strong class="source-inline">Teams.BLACK</strong>; we are going to move <strong class="source-inline">enable_pieces(white_team)</strong> inside yet another check. This time, we are going to check whether we don’t have any peers connected, meaning we are playing the game alone <span class="No-Break">or locally:</span><pre class="source-code">
if current_turn == Teams.BLACK:
          current_turn = Teams.WHITE
          if not multiplayer.get_peers().size() &gt; 0:
               enable_pieces(white_team)</pre></li>				<li>If we are not playing the game locally, we need to check whether the current player is the WhiteTeam’s Multiplayer Authority, using the <strong class="source-inline">multiplayer.get_unique_id()</strong> method; if so, we can enable the <strong class="bold">WhiteTeam</strong> Pieces. And that’s how we ensure that only the correct player will have their <span class="No-Break">Pieces re-enabled:</span><pre class="source-code">
if current_turn == Teams.BLACK:
          current_turn = Teams.WHITE
          if not multiplayer.get_peers().size() &gt; 0:
               enable_pieces(white_team)
          elif white_team.get_multiplayer_authority()
              == multiplayer.get_unique_id():
               enable_pieces(white_team)</pre></li>				<li>We are <a id="_idIndexMarker218"/>going to do the same thing, but inside the <strong class="source-inline">else</strong> statement, which handles whether the <strong class="source-inline">current_turn</strong> was <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">Teams.WHITE</strong></span><span class="No-Break">:</span><pre class="source-code">
else:
          current_turn = Teams.BLACK
          if not multiplayer.get_peers().size() &gt; 0:
               enable_pieces(black_team)
          elif black_team.get_multiplayer_authority()
              == multiplayer.get_unique_id():
               enable_pieces(black_team)</pre></li>			</ol>
			<p>With that, every time we call the <strong class="source-inline">toggle_turn()</strong> method, we are going to check whether the peer has authority over the current Pieces in play, and we only allow them to select the Pieces from their team. Now, we still need to make a small change in order for this to be compliant with our network requirements. In the <strong class="source-inline">_free_cell_selected()</strong> callback, let’s change the line that makes a direct call to the <strong class="source-inline">toggle_turn()</strong> method, making it a remote call using the <span class="No-Break"><strong class="source-inline">rpc()</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
func _on_free_cell_selected(free_cell_position):
     var free_cell = local_to_map(free_cell_position)
     if can_capture(selected_piece):
          capture_pieces(free_cell)
     else:
          move_selected_piece(free_cell)
     rpc("toggle_turn")
     selected_piece.deselect()</pre>			<p>Note<a id="_idIndexMarker219"/> that the <strong class="source-inline">can_capture()</strong> method is responsible for checking whether there’s any enemy Piece around <strong class="source-inline">selected_piece</strong>, which can lead to a capture move. If this is the case, we call the <strong class="source-inline">capture_pieces()</strong> method, which will perform the capture movement on all possible enemy Pieces in the selected direction. Otherwise, if there’s no capture movement available, we perform a simple movement calling the <strong class="source-inline">move_selected_piece()</strong> method, passing around <strong class="source-inline">free_cell</strong> as <span class="No-Break">an argument.</span></p>
			<p>Now, every time a player selectes an available free cell to perform a move with a Piece, they will make a remote procedure call to <strong class="source-inline">toggle_turn()</strong>, telling all the connected peers to properly disable and re-enable their respective Pieces. Awesome, <span class="No-Break">isn’t it?</span></p>
			<p>At this point, we have all the core mechanisms of our game in place, and we can play an online match with other players connected to our network. There’s only one thing missing. We still need to communicate over the network when a player wins a match and allow players to <span class="No-Break">play again.</span></p>
			<p>In the next section, we are going to create a simple mechanism to allow players to rematch after one of them won the match <span class="No-Break">for good.</span></p>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor144"/>Managing win and lose conditions</h1>
			<p>Excellent! We have successfully <a id="_idIndexMarker220"/>completed the development of the CheckerBoard scene, and our game’s core functionalities are now in place. The next step is to transition the logic of the CheckersGame scene from local to <span class="No-Break">remote gameplay.</span></p>
			<p>To begin, let’s open the <strong class="source-inline">res://06.building-online-checkers/CheckersGame.tscn</strong> file and familiarize ourselves with <span class="No-Break">its structure.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer059">
					<img alt="Figure 6.9 – The CheckersGame’s scene node hierarchy" src="image/Figure_06.09_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.9 – The CheckersGame’s scene node hierarchy</p>
			<p>Take note that the <a id="_idIndexMarker221"/>CheckerBoard’s <strong class="source-inline">player_won</strong> signal is connected to the <strong class="source-inline">CheckersGame._on_checker_board_player_won()</strong> callback. This callback is responsible for handling situations when a player’s team has no remaining pieces on the board. Now, let’s proceed by opening the script <span class="No-Break">for CheckersGame.</span></p>
			<p>We will be working on all the methods within the script, ensuring they are properly adjusted for online <span class="No-Break">multiplayer functionality:</span></p>
			<ol>
				<li>First of all, let’s add the <strong class="source-inline">@rpc</strong> annotation to the <strong class="source-inline">update_winner()</strong> method with the <strong class="source-inline">any_peer</strong> and <span class="No-Break"><strong class="source-inline">call_local</strong></span><span class="No-Break"> options.</span><pre class="source-code">
@rpc("any_peer", "call_local")
func update_winner(winner):</pre></li>				<li>Then, we are going to do the same thing with the <strong class="source-inline">rematch()</strong> method. This one is called by RematchButton’s <span class="No-Break"><strong class="source-inline">pressed</strong></span><span class="No-Break"> method:</span><pre class="source-code">
@rpc("any_peer", "call_local")
func rematch():</pre></li>				<li>Now, we need to call these methods remotely, using the <strong class="source-inline">rpc()</strong> method instead of directly calling them in <strong class="source-inline">CheckersGame</strong>. Let’s do that in <strong class="source-inline">_on_checker_board_player_won()</strong>, turning the <strong class="source-inline">update_winner(winner)</strong> into <strong class="source-inline">rpc("update_winner", winner)</strong> instead. This is the method that the CheckerBoard’s <strong class="source-inline">player_won signals</strong> is <span class="No-Break">connected to:</span><pre class="source-code">
func _on_checker_board_player_won(winner):
     rpc("update_winner", winner)</pre></li>				<li>Lastly, we <a id="_idIndexMarker222"/>do the same thing with <strong class="source-inline">_on_rematch_button_pressed()</strong>, turning the <strong class="source-inline">rematch()</strong> call into <strong class="source-inline">rpc("rematch")</strong>. This is the method that<strong class="bold"> </strong>the <strong class="source-inline">pressed</strong> signal of <strong class="bold">RematchButton</strong> connects to, so when players press the button, this is what <span class="No-Break">should happen:</span><pre class="source-code">
func _on_rematch_button_pressed():
     rpc("rematch")</pre></li>			</ol>
			<p>With the adjustments we’ve <a id="_idIndexMarker223"/>made, our game is now fully equipped to run smoothly, whether it’s played locally or remotely. When a player successfully captures their opponent’s pieces, the game will transition all peers into a rematch state, where any peer can initiate a new match and start a fresh game. This ensures that players have the option to engage in continuous gameplay sessions without the need to exit and restart the <span class="No-Break">game manually.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer060">
					<img alt="Figure 6.10 – The CheckersGame rematch screen" src="image/Figure_06.10_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.10 – The CheckersGame rematch screen</p>
			<p>Our game is finally working! We have a fully functional checkers game that players can play online and challenge each other playing <span class="No-Break">multiple matches.</span></p>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor145"/>Summary</h1>
			<p>To recap, in this chapter, we introduced the <strong class="source-inline">MultiplayerSynchronizer</strong> node to synchronize properties across a network, established the concept of abstraction for effective data transmission, utilized the <strong class="source-inline">@rpc</strong> annotations to enable multiplayer functionality, and learned how to assign and manage Multiplayer Authority to ensure player autonomy and <span class="No-Break">resource protection.</span></p>
			<p>In the upcoming chapter, we will see how to develop an online Pong game. There, we will cover the modifications necessary to turn the local game into an online multiplayer one, setting up online multiplayer paddles, syncing remote objects in real time, and coordinating the paddle’s position. For that, will use the <strong class="source-inline">MultiplayerSynchronizer</strong> node with a bit more depth than we did in this chapter. Also, we will talk about the importance of maintaining a shared game world for players in action-based games, which is very different from <span class="No-Break">turn-based games.</span></p>
		</div>
	</body></html>