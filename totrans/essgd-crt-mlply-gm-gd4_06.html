<html><head></head><body>
		<div><h1 class="chapter-number" id="_idParaDest-84"><a id="_idTextAnchor131"/>6</h1>
			<h1 id="_idParaDest-85"><a id="_idTextAnchor132"/>Building an Online Checkers Game</h1>
			<p>In this chapter, we will delve into the captivating realm of creating an online multiplayer checkers game. We will apply the knowledge and skills we have acquired throughout this book to develop an engaging and interactive gaming experience.</p>
			<p>Checkers, a classic <a id="_idIndexMarker181"/>board game enjoyed by players of all ages, provides the perfect canvas to explore the complexity of online multiplayer game development. We will learn how to leverage the power of the Godot Engine and its versatile features to create a seamless multiplayer experience that will have players strategizing, competing, and enjoying the game together.</p>
			<p>To facilitate the synchronization of the game state across multiple players, we will introduce a powerful tool called the <code>MultiplayerSynchronizer</code> node. This node will play a crucial role in updating the positions of the checkers pieces across the boards of all connected players. By using this node, we can ensure that each player’s game view remains consistent and up to date, enhancing the overall multiplayer experience.</p>
			<p>Throughout this chapter, we will cover essential concepts, such as client-server architecture, game synchronization, and player interactions, which are fundamental to the development of any multiplayer game. By understanding these concepts and applying them to our checkers game, we will create a robust and engaging multiplayer experience that will captivate players from around the world. The following diagram showcases the final project, where players are playing against each other online!</p>
			<div><div><img alt="Figure 6.1 – Player 1’s game instance view and Player 2’s game instance view during the Black Team’s turn" src="img/Figure_06.01_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – Player 1’s game instance view and Player 2’s game instance view during the Black Team’s turn</p>
			<p>In addition to the technical aspects, we will also focus on creating an intuitive user experience that allows players to seamlessly navigate the game and interact with the checkers pieces. A well-designed interface is crucial in enhancing the player experience and ensuring a smooth and enjoyable gameplay session. Using some visual cues, we will ensure that players know the current game state intuitively.</p>
			<p>As we progress, we will explore strategies to manage player interactions, such as handling player turns and validating moves. These features are vital in maintaining fairness and ensuring that the game follows the established rules of checkers. By incorporating these elements, we will create an authentic and immersive checkers experience that will engage players for hours on end.</p>
			<p>By the end of this chapter, you will have gained valuable insights into the intricacies of online multiplayer game development. You will have the knowledge and skills necessary to create your own multiplayer games, with the ability to synchronize game states, handle player interactions, and deliver an immersive multiplayer experience.</p>
			<p>So, get ready to embark on this exciting journey as we delve into the world of online multiplayer checkers game development. To do so, we will learn about the <code>MultiplayerSynchronizer</code> node and RPC functions, as they will be our key allies in synchronizing the players’ boards. Let’s begin this chapter and unlock the immense potential of multiplayer game development together.</p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li>Introducing the Checkers project</li>
				<li>Serializing players’ turns</li>
				<li>Deserializing the opponent’s turn</li>
				<li>Managing win and lose conditions</li>
			</ul>
			<h1 id="_idParaDest-86"><a id="_idTextAnchor133"/>Technical requirements</h1>
			<p>In this chapter, we’ll be working with the fourth folder of our Godot Engine project repository, which you can access through the following link: <a href="https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0">https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0</a>.</p>
			<p>Another requirement you will need to accomplish before following with our project import is to download Godot Engine version 4.0, as this is the version we will use throughout the whole book.</p>
			<p>After opening your Godot Engine 4.0, open the project using the project manager. Then, navigate to the <code>06.building-online-checkers</code> folder. Here, you’ll find all the files we used to build this chapter’s project. You can test the game opening and playing the <code>res://06.building-online-checkers/CheckersGame.tscn</code> scene.</p>
			<p>This scene showcases most of the features of our game. In this chapter, we are also going to implement the lobby system we have worked with throughout the book. On top of that, we will turn some local features into online multiplayer features as well.</p>
			<p>So, stay tuned.</p>
			<h1 id="_idParaDest-87"><a id="_idTextAnchor134"/>Introducing the Checkers project</h1>
			<p>Welcome, respected <a id="_idIndexMarker182"/>network engineer of our esteemed fictional indie development studio! As we embark on this chapter, let us take a moment to familiarize ourselves with the existing Checkers project. Currently, the project is designed for local multiplayers, allowing players to engage in thrilling matches offline. This understanding will serve as a solid foundation as we explore the path toward transforming our Checkers game into a captivating online multiplayer experience.</p>
			<p>In this endeavor, our goal is to seamlessly transition the existing local multiplayer functionality into an online environment, without encountering significant obstacles along the way. By leveraging our existing knowledge and skills, we can effectively adapt the game to support online multiplayer, thus expanding its reach and providing players with the opportunity to compete with opponents from around the globe.</p>
			<p>Throughout this section, we will unravel our Checkers project’s inner workings, gaining valuable insights into its structure and mechanics. Armed with this understanding, we will be better equipped to navigate the porting process with confidence and efficiency.</p>
			<p>As the designated network engineer, you play a pivotal role in this endeavor. Your expertise and problem-solving abilities will be put to the test. With careful consideration and strategic implementation, we can minimize any potential challenges and ensure a seamless transition to the online multiplayer realm.</p>
			<p>Together, we will examine the project’s architecture, dissect its components, and identify the necessary modifications required to facilitate online multiplayer functionality. By applying our knowledge of networking concepts and programming techniques, we will construct a robust foundation upon which the online multiplayer features will thrive.</p>
			<p>Remember, you are an integral part of this process; as a network engineer, it is your job to implement all online multiplayer code, so you play a fundamental role here. Your skills will contribute to the realization of our vision – a thrilling online multiplayer Checkers game that captivates players across the digital landscape. So, let us embark on this journey. In the upcoming <a id="_idIndexMarker183"/>sections, we will understand the ins and outs of our local Checkers game.</p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor135"/>Understanding the Checkers Piece scene</h2>
			<p>The <strong class="bold">Piece</strong> implements the<a id="_idIndexMarker184"/> functionality of a checkers game piece in our checkers’ game. It allows players to interact with the Piece by selecting or deselecting it, keeping track of its selected state. In the following screenshot, we can see the SceneTree structure’s Piece.</p>
			<div><div><img alt="Figure 6.2 – The Piece scene node hierarchy" src="img/Figure_06.02_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – The Piece scene node hierarchy</p>
			<p>To enhance the player experience and decision-making during their turns, we utilize visual cues provided by the <code>EnabledColorRect</code> and <code>SelectedColorRect</code> nodes. <code>EnabledColorRect</code> becomes visible when the Piece is capable of making a valid move within a player’s turn. Conversely, <code>SelectedColorRect</code> becomes visible when a player chooses this specific Piece over others, allowing for clear differentiation between them.</p>
			<p>The <code>Sprite2D</code> node is responsible for displaying the current texture of the Piece. Depending on the player’s team and whether the Piece has been promoted to a king piece, the texture can represent either a white piece, a black piece, or their respective king versions.</p>
			<p>The <code>SelectionArea2D</code> node plays a crucial role in detecting player input. By using the <code>input_event</code> signal, we establish communication between the player’s clicks and the Piece. This enables us to toggle the Piece’s selection state, determining whether it is currently selected or deselected.</p>
			<p>Let’s take a look at its code to understand how each of these nodes plays a role in this whole logic.</p>
			<p>Overall, this code forms a <a id="_idIndexMarker185"/>crucial component of the online multiplayer checkers game, providing the necessary functionality to interact with and manage the behavior of individual checkers pieces within the game:</p>
			<pre class="source-code">
extends Node2D
signal selected
signal deselected
enum Teams{BLACK, WHITE}
@export var team: Teams = Teams.BLACK
@export var is_king = false: set = _set_is_king
@export var king_texture = preload("res://
    06.building-online-checkers/WhiteKing.svg")
@onready var area = $SelectionArea2D
@onready var selected_color_rect = $SelectedColorRect
@onready var enabled_color_rect = $EnabledColorRect
@onready var sprite = $Sprite2D
var is_selected = false</pre>			<p>We start by defining some variables to store information about the Piece’s team – whether it’s a king, and its texture. It also has references to some child nodes in the scene and a variable to track whether the Piece is currently selected. Signals are defined to indicate when the Piece is selected or deselected. Next, we will declare the setter function we stated in the <code>_is_king</code> variable:</p>
			<pre class="source-code">
func _set_is_king(new_value):
  is_king = new_value
  if not is_inside_tree():
    await(ready)
  if is_king:
    sprite.texture = king_texture</pre>			<p>When this variable is<a id="_idIndexMarker186"/> set to a new value, the code checks whether the node is part of the scene tree. If not, it waits until the node is ready, this prevents any errors when changing the variable’s value through the inspector. If the variable is set to <code>true</code>, it updates the visual appearance of the game piece to represent a king, using a specific texture. This allows for dynamic visual changes in the game piece when it becomes a king. After that, we have a signal callback from the <code>Area2D</code> node’s <code>input_event</code> signal:</p>
			<pre class="source-code">
func _on_area_2d_input_event(viewport, event, shape_idx):
  if event is InputEventMouseButton:
    if event.button_index == 1 and event.pressed:
      select()</pre>			<p>It listens for left mouse button clicks and, when detected, calls the <code>select()</code> method, which, as we will see next, performs the procedures related to selecting the Piece. This code enables interaction within the game when the player clicks the left mouse button while hovering over the Piece’s <code>Area2D</code>. Here, we have the code for the <code>select()</code> method:</p>
			<pre class="source-code">
func select():
  get_tree().call_group("selected", "deselect")
  add_to_group("selected")
  selected_color_rect.show()
  is_selected = true
  selected.emit()</pre>			<p>In this function, we define what happens when the Piece is selected. It ensures that any previously selected objects are deselected, marks the current object as selected, shows a visual indicator, updates a variable to reflect the selection status, and emits the <code>selected</code> signal to notify other parts of the game about the selection event. This code is fundamental for managing and conveying the selected state of Pieces in the game. Then, we also have the opposite function, <code>deselect()</code>:</p>
			<pre class="source-code">
func deselect():
  remove_from_group("selected")
  selected_color_rect.hide()
  is_selected = false
  deselected.emit()</pre>			<p>Here, we define what happens when an object is deselected. The code removes the object from the <code>"selected"</code> group, hides the visual indicator of selection, updates the <code>is_selected</code> variable to reflect the deselection status, and emits the <code>deselected</code> signal to notify other parts of the game about the deselection event. Now, it’s time to enable the change in selection states; without that, the Piece shouldn’t be selectable. This helps to prevent players <a id="_idIndexMarker187"/>from selecting Pieces from the opponent’s team:</p>
			<pre class="source-code">
func enable():
  area.input_pickable = true
  enabled_color_rect.visible = true</pre>			<p>In this part, we make the <code>Area2D</code> responsive to input events, and we also make a visual indicator visible on the screen. This is important to allow players to interact with and manipulate Pieces in the game when they are in an enabled state. Now, let’s see its counterpart, the <code>disable()</code> method:</p>
			<pre class="source-code">
func disable():
  area.input_pickable = false
  enabled_color_rect.visible = false</pre>			<p>It’s essentially the<a id="_idIndexMarker188"/> opposite of the previous method. We make the <code>Area2D</code> non-responsive to input events, effectively making it non-interactive. On top of that, we hide the visual indicator on the screen that represents the Piece’s availability, visually representing the Piece’s disabled state. This is useful for controlling when and how players can interact with Pieces in the game.</p>
			<p>In the upcoming section, we are going to see how the FreeCell scene works. It’s a scene we use to highlight the available free cells that a selected Piece can move to.</p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor136"/>Comprehending the FreeCell scene</h2>
			<p>In our game project, we have a<a id="_idIndexMarker189"/> concept called <strong class="bold">FreeCell</strong>, which represents a valid cell that a Piece can move to. Think of it as a designated area where the Piece is allowed to go. Each time the player selects a Piece with valid movement, we visually indicate the available cells by showing them in green. These cells are actually instances of the FreeCell scene, which we dynamically create and display on the game board.</p>
			<p>To provide a clear example, imagine a scenario where a king Piece is selected. In the following diagram, you can see that all the cells where this king Piece can move to are highlighted in green. Each of these highlighted cells is an instance of the FreeCell scene, which allows the player to quickly identify the possible movement options for the selected Piece.</p>
			<div><div><img alt="Figure 6.3 – Free cells available to the selected king piece" src="img/Figure_06.03_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 – Free cells available to the selected king piece</p>
			<p>By using the FreeCell concept, we enhance the player’s experience by visually communicating the valid movement possibilities. This empowers them to make informed decisions and strategize their next move effectively. It’s a powerful tool that adds clarity and depth to the gameplay mechanics.</p>
			<p>The FreeCell scene is an essential component of our game, composed of three distinct nodes. The main node is an <code>Area2D</code>, which serves as the foundation for the FreeCell. It encompasses two child nodes – a <code>CollisionShape2D</code> and a <code>ColorRect</code>.</p>
			<p>The <code>CollisionShape2D</code> node is responsible for defining the shape and boundaries of the FreeCell. It ensures that the cell can properly interact with other game objects, such as Pieces or other elements within the game world. As we are about to see, <code>CollisionShape2D</code> also defines the boundaries in which the <code>Area2D</code> detects mouse inputs, which is fundamental for the FreeCell’s behavior.</p>
			<p>The <code>ColorRect</code> node, conversely, controls the<a id="_idIndexMarker190"/> visual representation of the FreeCell. It determines the color and appearance of the cell, providing a visual indicator to distinguish it from other elements on the game board.</p>
			<div><div><img alt="Figure 6.4 – The FreeCell scene node hierarchy&#13;&#10;" src="img/Figure_06.04_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4 – The FreeCell scene node hierarchy</p>
			<p>To better understand the functionality and behavior of the FreeCell, let’s explore its accompanying script. By examining the script code, we will gain insights into how the FreeCell operates and interacts with other game elements, ultimately contributing to the overall game logic and mechanics:</p>
			<pre class="source-code">
extends Area2D
signal selected(cell_position)
func _input_event(viewport, event, shape_idx):
     if event is InputEventMouseButton:
          if event.button_index == 1 and event.pressed:
               select()
func select():
     selected.emit(self.position)</pre>			<p>This code allows the cell, represented by <code>Area2D</code>, to respond to right mouse button events within its area. When a cell is selected, it emits a signal with the position of the cell. This signal can be used to inform other objects or scripts about the selection and provide them with the cell’s position for further processing. We’ll use this in the <code>CheckerBoard</code> script to map the <a id="_idIndexMarker191"/>FreeCell’s position into the board’s cell.</p>
			<p>In the upcoming section, we will introduce the game board, an essential component of our game. We will then shift our focus to the core of this chapter, which involves implementing methods that we will turn into RPCs. These RPCs will enable the game to work seamlessly in an online environment, allowing players to interact with each other and synchronize their actions over the network.</p>
			<p>By leveraging the power of RPCs, we will create a dynamic and engaging multiplayer experience for our players. Let’s dive into the details and explore how these methods will bring our game to life in an online setting.</p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor137"/>Introducing the CheckerBoard scene</h2>
			<p>In this section, let’s delve into the <a id="_idIndexMarker192"/>primary role of the game board, as this will serve as a foundation for our upcoming sections. By understanding the key responsibilities of the board, we can naturally identify the specific areas we will be focusing on in the subsequent sections. This understanding will pave the way for a clear and structured approach as we continue exploring our checker’s development process.</p>
			<p>The primary role of our game board is to manage the relationship between the black and white pieces in the game. To achieve this, the board utilizes the built-in <code>TileMap</code> functions to map the pieces onto cartesian coordinates. Additionally, it employs a hash map to associate the content of each cell on the board.</p>
			<p>This means that we can access the content of a specific cell by providing its corresponding <code>Vector2i</code> coordinate. For example, by using the <code>meta_board[Vector2i(0,3)]</code> expression, we can retrieve the contents of the cell located in the first column and fourth row of the board. The result of this access will either be <code>null</code>, indicating that the cell is free, or it will return the Piece that is currently mapped to that particular cell. This mechanism allows for efficient retrieval and manipulation of the contents on the board, enabling seamless gameplay and interaction with the pieces.</p>
			<p>The CheckerBoard plays a vital role in our game by overseeing various aspects of gameplay. Firstly, it manages the available movements for each cell on the board, taking into account the current team in play and whether a Piece has been promoted to a king. This ensures that players can only make valid moves based on the rules of the game.</p>
			<p>The CheckerBoard is also responsible for controlling the turns in the game. It enables and disables the Pieces according to the active team, allowing only the team in play to make moves during their turn. This mechanism ensures fair gameplay and maintains the flow of the game.</p>
			<p>Furthermore, the<a id="_idIndexMarker193"/> CheckerBoard keeps track of the number of Pieces each team possesses at the end of each turn. This count is crucial, as it determines the win-lose condition of the game. If a team has no remaining Pieces on the board, the CheckerBoard triggers the appropriate <code>win</code> condition, declaring the opposing team as the winner.</p>
			<p>By managing the cell movements, regulating turns, and monitoring the Piece count, the CheckerBoard maintains the game’s rules and progression. Its role is fundamental to providing clear conditions for victory or defeat. Let’s take a look at the CheckerBoard scene structure:</p>
			<div><div><img alt="Figure 6.5 – The CheckerBoard scene node hierarchy" src="img/Figure_06.05_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.5 – The CheckerBoard scene node hierarchy</p>
			<p>It’s important to <a id="_idIndexMarker194"/>note that the CheckerBoard is implemented as <code>TileMap</code>, a useful class in our game. We use specific methods provided by the <code>TileMap</code> class, such as <code>map_to_local()</code>, <code>local_to_map()</code>, and <code>get_used_cells()</code>, to establish our cell-mapping functionality. The <code>map_to_local()</code> method will help us map the game to cell positions in <code>TileMap</code>, while <code>local_to_map()</code> will help us convert the Pieces’ positions to cells in the map. This will help us abstract the game in terms of rows and columns instead of floating-point numbers. As for the <code>get_used_cells()</code> method, it will help us access only the cells that have a tile set to them and avoid dealing with blank cells in <code>TileMap</code>. This will be useful when we create a matrix of the cells’ contents.</p>
			<p>In the <code>CheckerBoard</code> class, we’ll focus on understanding the significance of the <code>meta_board</code> <code>create_meta_board()</code> and <code>map_pieces()</code> methods within the <code>CheckerBoard</code> class:</p>
			<pre class="source-code">
func create_meta_board():
     for cell in get_used_cells(0):
          meta_board[cell] = null
func map_pieces(team):
     for piece in team.get_children():
          var piece_position = local_to_map(piece.position)
          meta_board[piece_position] = piece
          piece.selected.connect(_on_piece_selected.bind
              (piece))</pre>			<p>The <code>create_meta_board()</code> method is responsible for setting up the <code>meta_board</code> Dictionary. This Dictionary acts as a data structure that maps cell coordinates to their corresponding contents. By leveraging the <code>TileMap</code> methods mentioned earlier, the <code>create_meta_board()</code> method populates <code>meta_board</code> with the appropriate cell coordinates and initializes them with null values, indicating empty cells.</p>
			<p>Conversely, the <code>map_pieces()</code> method performs an essential role in updating the <code>meta_board</code> to reflect the current state of the game. This method iterates over all the Pieces on the provided team, which is passed as a reference to either the <code>BlackTeam</code> node or the <code>WhiteTeam</code> node. Then, it converts the Pieces’ positions using the <code>TileMap.local_to_map()</code> method and maps each Piece to its respective cell coordinate in <code>meta_board</code>. This ensures that <code>meta_board</code> accurately represents the placement of Pieces on the visual board.</p>
			<p>Lastly, the code establishes a <a id="_idIndexMarker195"/>connection between the <code>Piece.selected</code> signal and the <code>_on_piece_selected()</code> callback function. By connecting this signal, we bind the current Piece to the callback function as its argument. This enables us to conveniently access the <code>Piece</code> node whenever the player selects it.</p>
			<p>This connection ensures that when the Piece emits the selected signal, the associated callback function, <code>_on_piece_selected()</code>, will be invoked and provided with the <code>Piece</code> node as its argument. This mechanism allows us to perform specific actions or access properties of the <code>Piece</code> node, in response to the player’s selection.</p>
			<p>By establishing this connection, we create a seamless interaction between the <code>Piece</code> node and the corresponding callback function, enhancing the flexibility and responsiveness of our game.</p>
			<p>There are some auxiliary functions that help us calculate available cells and coordinate the Piece’s movement; feel free to check them out and understand how we check for available cells, how we capture cells, and other gameplay features. In the next section, we will explore a different aspect of our checkers development journey.</p>
			<p>We will focus on how we can package and transmit all the pertinent information about a player’s turn across the network, ensuring that other players are promptly updated with the current state of the game<a id="_idIndexMarker196"/> board.</p>
			<p>By understanding this process, we will be able to establish efficient communication between players, facilitating a seamless multiplayer experience. This functionality is essential for maintaining synchronization and enabling real-time gameplay in our online multiplayer game. Stay tuned as we dive into the intricacies of transmitting and updating the game state across the network.</p>
			<h1 id="_idParaDest-91"><a id="_idTextAnchor138"/>Serializing players’ turns</h1>
			<p>In <a href="B18527_02.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Sending and Receiving Data</em>, we explored an essential technique to recreate the game<a id="_idIndexMarker197"/> state across multiple players in a network. By serializing the relevant data and transmitting it in small portions, we ensure efficient utilization of network bandwidth while maintaining synchronization among peers.</p>
			<p>Developing an understanding of what information is crucial to replicate the game state among players involves mastering the concept of abstraction in game development. In our case, this primarily revolves around <code>meta_board</code>, which is an abstraction of the relevant metadata of our game, such as the positional data and king state of the Pieces and the empty cells in the board.</p>
			<p>Additionally, we need to consider the availability of Pieces, depending on the players’ turn. Fortunately, most other elements of the game can be managed locally without requiring network synchronization.</p>
			<p>To simplify the process of synchronizing node properties across networked peers, I would like to introduce you to <code>MultiplayerSynchronizer</code>. This powerful node takes on the responsibility of automatically synchronizing properties across peers, relieving us from the tedious task of manual synchronization.</p>
			<p>With <code>MultiplayerSynchronizer</code> in place, we can focus on developing the game’s logic and let the node handle the efficient transmission of data among players.</p>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor139"/>Working with MultiplayerSynchronizer</h2>
			<p><code>MultiplayerSynchronizer</code> plays a vital role by allowing us to effortlessly sync and share the state of<a id="_idIndexMarker198"/> nodes across multiple players, without writing any additional code. To begin utilizing this functionality, we will add a <code>MultiplayerSynchronizer</code> node to the Piece’s scene. This will ensure consistency in the game state of each player. Let’s dive into the process of integrating the <code>MultiplayerSynchronizer</code> and harnessing its capabilities.</p>
			<h3>Setting up MultiplayerSynchronizer in the Piece scene</h3>
			<p>Open<a id="_idIndexMarker199"/> the <code>res://06.building-online-checkers/Piece.tscn</code> scene and add a <code>MultiplayerSynchronizer</code> as a child of the <code>Piece</code> node. Then, we’ll set up the properties we want to synchronize:</p>
			<ol>
				<li>With the <code>MultiplayerSychronizer</code> node selected, in the bottom panel on the <strong class="bold">Replication</strong> tab, click the <strong class="bold">Add property to </strong><strong class="bold">sync</strong> button.</li>
			</ol>
			<div><div><img alt="Figure 6.6 – The Replication menu from the MultiplayerSynchronizer node" src="img/Figure_06.06_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.6 – The Replication menu from the MultiplayerSynchronizer node</p>
			<ol>
				<li value="2">From the pop-up menu, select the <strong class="bold">Piece</strong> node.</li>
			</ol>
			<div><div><img alt="Figure 6.7 – Selecting the Piece node from the Pick a ﻿node to ﻿synchronize pop-up menu" src="img/Figure_06.07_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.7 – Selecting the Piece node from the Pick a node to synchronize pop-up menu</p>
			<ol>
				<li value="3">After<a id="_idIndexMarker200"/> selecting the <strong class="bold">Piece</strong> node, another pop-up menu will appear, asking you to select the property you want to sync. From there, select the <strong class="bold">position</strong> property.</li>
			</ol>
			<div><div><img alt="Figure 6.8 – Choosing the position property from the Select Property pop-up menu" src="img/Figure_06.08_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.8 – Choosing the position property from the Select Property pop-up menu</p>
			<p>And that’s it. With<a id="_idIndexMarker201"/> that, as soon as the players are connected to the same network, they will automatically sync their Pieces’ positions on the board. However, we still have an issue as this only updates the visual representation of the Piece, and we still need to update its data in <code>meta_board</code>. Now comes the fun part.</p>
			<p>In the next section, we will start to understand the methods in the CheckerBoard that we need to turn into RPCs, keeping players on the same page.</p>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor140"/>Updating and syncing the CheckerBoard</h2>
			<p>A core issue when<a id="_idIndexMarker202"/> developing any application is that we have limited resources. In the case of transmitting data over a network, we are talking about bandwidth. Games are a special case because everything should happen in real time, so we can’t risk heavy data transmission that hurts network performance.</p>
			<p>To turn this in our favor, we need to pass data in the most abstract and lightweight way we can. In our case, we have our <code>meta_board</code> as a means to represent the game’s current state. By using <code>Vector2i</code> coordinates, we can access and change the game states. And that’s how we are going to keep players updated. In the next section, we are going to work with the <code>CheckerBoard.update_cells()</code> method, which is the core of our update system.</p>
			<h3>Using coordinates to update the board</h3>
			<p>Since <code>meta_board</code> is a <a id="_idIndexMarker203"/>Dictionary, we can access and set the values of its keys using Godot Engine’s built-in types. For instance, if we want to change the content of the cell in the third row second column to <code>null</code>, we can write <code>meta_board[Vectori(1, 2)] = </code><code>null</code>.</p>
			<p>When Pieces perform a move, we just need to know the content of the previous and new cell of this movement, so that we can update it. And that’s exactly what the <code>update_cells()</code> method does. Let’s take a look at it:</p>
			<pre class="source-code">
func update_cells(previous_cell, target_cell):
     meta_board[target_cell] = meta_board[previous_cell]
     meta_board[previous_cell] = null</pre>			<p>Since this is the very core of our update system, we need to turn it into an RPC function and call it as such.</p>
			<p>For that, let’s make the appropriate changes in our script:</p>
			<ol>
				<li>Add the <code>@rpc</code> annotation to this method, using the <code>any_peer</code> and <code>call_local</code> options. We use these because we want every player to update others about changes in their board, and we also want their own board to update itself, hence the <code>call_local</code> option:<pre class="source-code">
@rpc("any_peer", "call_local")
func update_cells(previous_cell, target_cell):</pre></li>				<li>In the <code>move_selected_piece()</code> method, change the <code>update_cells(current_cell, target_cell)</code> line to an RPC call instead. This will make the call of this method both local and remote on other peers as well:<pre class="source-code">
func move_selected_piece(target_cell):
     var current_cell = local_to_map
         (selected_piece.position)
     Selected_piece.position = map_to_local
         (target_cell)
     rpc("update_cells", current_cell, target_cell)
     if not is_free_cell(target_cell):
          crown(target_cell)</pre></li>			</ol>
			<p>With that, every time the CheckerBoard moves a Piece, it updates its <code>meta_board</code> data on all peers on the network.</p>
			<p>Note that there’s another method that we can turn into an RPC as well. Every player should update <code>Piece.is_king</code> of a Piece that reached their opponent’s king row. For that, we have the <code>crown()</code>method that <code>move_selected_piece()</code> calls at the bottom of its logic.</p>
			<p>Let’s do the<a id="_idIndexMarker204"/> same thing we did with <code>update_cells()</code> with the <code>crown()</code> method:</p>
			<ol>
				<li>First, we add the <code>@rpc</code> annotation to it with the <code>any_peer</code> and <code>call_local</code> options:<pre class="source-code">
@rpc("any_peer", "call_local")
func crown(cell):</pre></li>				<li>Then, we change the <code>crown(target_cell)</code> call to its <code>rpc()</code> version:<pre class="source-code">
func move_selected_piece(target_cell):
     var current_cell = local_to_map
         (selected_piece.position)
     selected_piece.position = map_to_local
         (target_cell)
     rpc("update_cells", current_cell, target_cell)
     if not is_free_cell(target_cell):
          rpc("crown", target_cell)</pre></li>			</ol>
			<p>With that, when a Piece reaches the king row, all players’ CheckerBoards update their king state, be it an opponent Piece or an ally Piece.</p>
			<p>Our work isn’t <a id="_idIndexMarker205"/>done yet. In the next section, we will see how we update the <code>meta_board</code> content when players perform a capturing movement, meaning we need to remove a Piece from the board.</p>
			<h3>Removing a Piece from the board</h3>
			<p>When a player <a id="_idIndexMarker206"/>makes a move that ends up capturing an opponent Piece, we should update the game board accordingly. This means that on top of updating the cells involved in the movement, we should also update the cell where the captured Piece was, setting its content to null – in other words, turning it into a free cell. That’s what the <code>remove_piece()</code> method does.</p>
			<p>Let’s take a look at its code:</p>
			<pre class="source-code">
func remove_piece(piece_cell):
     if not is_on_board(piece_cell):
          return
     if is_free_cell(piece_cell):
          return
     var piece = meta_board[piece_cell]
     piece.get_parent().remove_child(piece)
     piece.free()
     meta_board[piece_cell] = null</pre>			<p>Since this behavior impacts both players, we need to turn this method into an RPC as well so that every time a player captures a Piece, they update their opponent with this sad fact.</p>
			<p>Let’s make the appropriate changes so that this feature is compliant with our online multiplayer demands:</p>
			<ol>
				<li>Add the <code>@rpc</code> annotation to the <code>remove_piece()</code> method with the <code>any_peer</code> and <code>call_local</code> options:<pre class="source-code">
@rpc("any_peer", "call_local")
func remove_piece(piece_cell):</pre></li>				<li>In <a id="_idIndexMarker207"/>the <code>capture_piece()</code> method, update the <code>remove_piece(cell)</code> line to its <code>rpc()</code> version:<pre class="source-code">
func capture_pieces(target_cell):
     var origin_cell = local_to_map(selected_piece.
         position)
     var direction = Vector2(target_cell -origin_cell)
         .normalized()
     direction = Vector2i(direction.round())
     var cell = target_cell - direction
     if not is_on_board(cell):
          return
     if not is_free_cell(cell):
          rpc("remove_piece", cell)
          move_selected_piece(target_cell)</pre></li>			</ol>
			<p>Now, every time a player<a id="_idIndexMarker208"/> captures a cell, it calls the <code>remove_piece()</code> method both locally and remotely on all connected peers!</p>
			<p>With that, we have our players turn properly serialized and ready to be passed through the network to other peers, with good performance and little data usage, leaving a good bandwidth for us if we so desire. For instance, we can add a chat feature using a new RPC channel if we want to in the future.</p>
			<p>In this section, we learned about the importance of abstracting relevant data for our network communication and how to turn local functionalities into remote functionalities, while maintaining all their logic and overall structure. Here, we saw the relevance of the <code>call_local</code> RPC option as well as the simplicity of turning a method call into an RPC call with the <code>rpc()</code> method.</p>
			<p>In the next section, we will see how we manage the turn logic. This is an important feature to handle because there we will need to actively add a layer of network verification to properly handle the turns. The logic of a local turn shift and a remote turn shift is very distinct.</p>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor141"/>Handling remote turn shifts</h1>
			<p>One of the most important <a id="_idIndexMarker209"/>aspects of playing a game online is to maintain players’ autonomy and authority over their resources – in this case, their team’s Pieces. Godot Engine offers an interesting system where a SceneTree can structure its nodes’ hierarchies with distinct Multiplayer Authorities.</p>
			<p>To set up a node and its children’s Multiplayer Authority, recursively, we can use <code>set_multiplayer_authority()</code> and pass the respective peer’s ID as an argument. In our case, we are going to change the <code>BlackTeam</code> and <code>WhiteTeam</code> nodes’ Multiplayer Authority to match their respective players’ peer IDs.</p>
			<p>This will be done by the server, so to keep the application simple, we are going to allow clients and server to share the same script, and we will check which one is running the server instance by using <code>is_multiplayer_authority()</code> on the CheckerBoard. We should only run this logic if the game is running in a network and there are peers connected. For that, we can check whether <code>multiplayer.get_peers().size()</code> is greater than <code>0</code>, meaning there are peers connected. Let’s see this in practice, shall we?</p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor142"/>Setting up players’ teams</h2>
			<p>The first thing we need to understand<a id="_idIndexMarker210"/> to handle players’ turn shifts is that each one of the nodes that represent the team – in other words, the <code>BlackTeam</code> and the <code>WhiteTeam</code> nodes – should have its respective players’ peer IDs set as their Multiplayer Authorities.</p>
			<p>In that sense, we need to create a method in the <code>CheckerBoard</code> class that receives the team and the peer ID as arguments. Remember, we can’t pass objects as arguments in this method because it needs to work in the network. So, we need to abstract teams as an <code>enum</code> that we can pass around through RPCs, and then all peers will be able to understand the message and access the correct team node at their end. Let’s dive into the action and create a method called <code>setup_team()</code>:</p>
			<ol>
				<li>Add the <code>@rpc("authority", "call_local")</code> decorator before the <code>setup_team()</code> function definition. The <code>authority</code> option indicates that this RPC can only be called by the Multiplayer Authority; remember that the authority of the CheckerBoard will still be the server. The <code>call_local</code> argument specifies that the function should also be executed locally on the calling peers:<pre class="source-code">
@rpc("authority", "call_local")
func setup_team(team, peer_id):</pre></li>				<li>Inside the<a id="_idIndexMarker211"/> function, check whether the value of <code>team</code> is equal to <code>Teams.BLACK</code>; if this is the case, call the <code>set_multiplayer_authority()</code> method on the <code>black_team</code> object and pass <code>peer_id</code> as an argument. This effectively designates the specified peer as the authority for <code>BlackTeam</code> and all its children – in other words, the black Pieces:<pre class="source-code">
@rpc("authority", "call_local")
func setup_team(team, peer_id):
     if team == Teams.BLACK:
          black_team.set_multiplayer_authority
              (peer_id)</pre></li>				<li>Otherwise, call the <code>set_multiplayer_authority()</code> method on the <code>white_team</code> object and pass <code>peer_id</code> as an argument:<pre class="source-code">
@rpc("authority", "call_local")
func setup_team(team, peer_id):
     if team == Teams.BLACK:
          black_team.set_multiplayer_authority
              (peer_id)
     else:
          white_team.set_multiplayer_authority
              (peer_id)</pre></li>			</ol>
			<p>This method sets up the<a id="_idIndexMarker212"/> Multiplayer Authority of a team node based on the received team, <code>black_team</code> or <code>white_team</code>, using the provided <code>peer_id</code>. This ensures that the Multiplayer Authority for each team is correctly established, allowing the game logic to be synchronized across networked peers. Since the server calls this method on all peers, both players and the server will sync their team nodes accordingly.</p>
			<p>Now, to ensure that this mechanism will be established among all peers, we are going to add the following lines of code right inside the <code>_ready()</code> callback:</p>
			<ol>
				<li>Inside the <code>_ready()</code> callback, check whether there are peers connected in the multiplayer session by checking whether the size of <code>multiplayer.get_peers()</code> array is greater than <code>0</code>:<pre class="source-code">
func _ready():
     if multiplayer.get_peers().size() &gt; 0:</pre></li>				<li>If this is the case, check whether the current node is the Multiplayer Authority by using the <code>is_multiplayer_authority()</code> function. This ensures that we will only call the following logic in the server peer:<pre class="source-code">
func _ready():
     if multiplayer.get_peers().size() &gt; 0:
          if is_multiplayer_authority():</pre></li>				<li>Then, make an RPC using the <code>rpc()</code> method, with the <code>"setup_team "</code> , <code>Teams.BLACK</code>, and <code>multiplayer.get_peers()[0]</code> arguments. This will call the <code>setup_team()</code> method on all connected peers, telling them to set the BlackTeam’s Multiplayer Authority using the first peer ID in the list of connected peers. So, the first player connected in the session will be responsible for the black Pieces:<pre class="source-code">
func _ready():
     if multiplayer.get_peers().size() &gt; 0:
          if is_multiplayer_authority():
               rpc("setup_team", Teams.BLACK,
                   multiplayer.get_peers()[0])</pre></li>				<li>Right below the<a id="_idIndexMarker213"/> previous line, we are going to do the same thing but use <code>Teams.WHITE</code> and the connected peers’ list second index, meaning the second player that connected to the session:<pre class="source-code">
func _ready():
     if multiplayer.get_peers().size() &gt; 0:
          if is_multiplayer_authority():
               rpc("setup_team", Teams.BLACK,
                   multiplayer.get_peers()[0])
               rpc("setup_team", Teams.WHITE,
                   multiplayer.get_peers()[1])</pre></li>			</ol>
			<p>With that, we have our<a id="_idIndexMarker214"/> team setup in place. Note that, since the server has both team nodes’ Multiplayer Authorities assigned to each of the players in the match, the server itself can’t perform any movement in the board’s Pieces.</p>
			<p>Talking about that prevention mechanism, how does it work? How does the CheckerBoard prevent players from interacting with Pieces, especially with their opponent Pieces? In the next section, we are going to see how we can detect which player is assigned to which team and only re-enable their appropriate team Pieces.</p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor143"/>Enabling and disabling team pieces</h2>
			<p>In our game, when players end a turn, we<a id="_idIndexMarker215"/> disable all their pieces using the <code>disable_pieces()</code> method. In turn shifts, we make sure to disable both teams’ Pieces, and we also check whether there’s a winner from the past turn; if not, we start the procedure to re-enable players’ Pieces based on the turn’s team.</p>
			<p>All of that happens in the <code>toggle_turn()</code> method, but as it is, it won’t work in an online multiplayer scenario because, currently, the method performs only local logic. So, let’s turn it into a method that will work for our improved online multiplayer checkers game.</p>
			<p>However, before that, let’s see how the code is right now so we can already pick where we will need to make adjustments:</p>
			<pre class="source-code">
func toggle_turn():
     clear_free_cells()
     disable_pieces(white_team)
     disable_pieces(black_team)
     var winner = get_winner()
     if winner:
          player_won.emit(winner)
          return
     if current_turn == Teams.BLACK:
          current_turn = Teams.WHITE
          enable_pieces(white_team)
     else:
          current_turn = Teams.BLACK
          enable_pieces(black_team)</pre>			<p>This function is<a id="_idIndexMarker216"/> responsible for managing the turn-based logic of a game. It first clears the available cells for movements and then disables the pieces of both teams. Then, it checks whether there is a winner and, if so, emits a signal to the <code>CheckersGame</code> script’s <code>_on_checker_board_player_won()</code> method, indicating the winning team. If there is no winner, it switches the turn to the other team and enables the pieces of the corresponding team.</p>
			<p>Can you point out where we need to make the necessary changes in order to make it work in our online version of the game? Remember that the game should work both locally and remotely, so we need to maintain the overall outcome of this method. Let’s begin the process:</p>
			<ol>
				<li>Decorate the <code>toggle_turn()</code> method with the <code>@rpc</code> annotation, using the <code>any_peer</code> and the <code>call_local</code> options. This indicates that any peer can call this method remotely in the multiplayer session, but they should also call it locally. This ensures that even if we are playing the game without joining a multiplayer session, we can call this method locally, using the <code>rpc()</code> method, and everything will still work:<pre class="source-code">
@rpc("any_peer", "call_local")
func toggle_turn():</pre></li>				<li>Inside that, check <a id="_idIndexMarker217"/>whether the <code>current_turn</code> is <code>Teams.BLACK</code>; we are going to move <code>enable_pieces(white_team)</code> inside yet another check. This time, we are going to check whether we don’t have any peers connected, meaning we are playing the game alone or locally:<pre class="source-code">
if current_turn == Teams.BLACK:
          current_turn = Teams.WHITE
          if not multiplayer.get_peers().size() &gt; 0:
               enable_pieces(white_team)</pre></li>				<li>If we are not playing the game locally, we need to check whether the current player is the WhiteTeam’s Multiplayer Authority, using the <code>multiplayer.get_unique_id()</code> method; if so, we can enable the <strong class="bold">WhiteTeam</strong> Pieces. And that’s how we ensure that only the correct player will have their Pieces re-enabled:<pre class="source-code">
if current_turn == Teams.BLACK:
          current_turn = Teams.WHITE
          if not multiplayer.get_peers().size() &gt; 0:
               enable_pieces(white_team)
          elif white_team.get_multiplayer_authority()
              == multiplayer.get_unique_id():
               enable_pieces(white_team)</pre></li>				<li>We are <a id="_idIndexMarker218"/>going to do the same thing, but inside the <code>else</code> statement, which handles whether the <code>current_turn</code> was from <code>Teams.WHITE</code>:<pre class="source-code">
else:
          current_turn = Teams.BLACK
          if not multiplayer.get_peers().size() &gt; 0:
               enable_pieces(black_team)
          elif black_team.get_multiplayer_authority()
              == multiplayer.get_unique_id():
               enable_pieces(black_team)</pre></li>			</ol>
			<p>With that, every time we call the <code>toggle_turn()</code> method, we are going to check whether the peer has authority over the current Pieces in play, and we only allow them to select the Pieces from their team. Now, we still need to make a small change in order for this to be compliant with our network requirements. In the <code>_free_cell_selected()</code> callback, let’s change the line that makes a direct call to the <code>toggle_turn()</code> method, making it a remote call using the <code>rpc()</code> method:</p>
			<pre class="source-code">
func _on_free_cell_selected(free_cell_position):
     var free_cell = local_to_map(free_cell_position)
     if can_capture(selected_piece):
          capture_pieces(free_cell)
     else:
          move_selected_piece(free_cell)
     rpc("toggle_turn")
     selected_piece.deselect()</pre>			<p>Note<a id="_idIndexMarker219"/> that the <code>can_capture()</code> method is responsible for checking whether there’s any enemy Piece around <code>selected_piece</code>, which can lead to a capture move. If this is the case, we call the <code>capture_pieces()</code> method, which will perform the capture movement on all possible enemy Pieces in the selected direction. Otherwise, if there’s no capture movement available, we perform a simple movement calling the <code>move_selected_piece()</code> method, passing around <code>free_cell</code> as an argument.</p>
			<p>Now, every time a player selectes an available free cell to perform a move with a Piece, they will make a remote procedure call to <code>toggle_turn()</code>, telling all the connected peers to properly disable and re-enable their respective Pieces. Awesome, isn’t it?</p>
			<p>At this point, we have all the core mechanisms of our game in place, and we can play an online match with other players connected to our network. There’s only one thing missing. We still need to communicate over the network when a player wins a match and allow players to play again.</p>
			<p>In the next section, we are going to create a simple mechanism to allow players to rematch after one of them won the match for good.</p>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor144"/>Managing win and lose conditions</h1>
			<p>Excellent! We have successfully <a id="_idIndexMarker220"/>completed the development of the CheckerBoard scene, and our game’s core functionalities are now in place. The next step is to transition the logic of the CheckersGame scene from local to remote gameplay.</p>
			<p>To begin, let’s open the <code>res://06.building-online-checkers/CheckersGame.tscn</code> file and familiarize ourselves with its structure.</p>
			<div><div><img alt="Figure 6.9 – The CheckersGame’s scene node hierarchy" src="img/Figure_06.09_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.9 – The CheckersGame’s scene node hierarchy</p>
			<p>Take note that the <a id="_idIndexMarker221"/>CheckerBoard’s <code>player_won</code> signal is connected to the <code>CheckersGame._on_checker_board_player_won()</code> callback. This callback is responsible for handling situations when a player’s team has no remaining pieces on the board. Now, let’s proceed by opening the script for CheckersGame.</p>
			<p>We will be working on all the methods within the script, ensuring they are properly adjusted for online multiplayer functionality:</p>
			<ol>
				<li>First of all, let’s add the <code>@rpc</code> annotation to the <code>update_winner()</code> method with the <code>any_peer</code> and <code>call_local</code> options.<pre class="source-code">
@rpc("any_peer", "call_local")
func update_winner(winner):</pre></li>				<li>Then, we are going to do the same thing with the <code>rematch()</code> method. This one is called by RematchButton’s <code>pressed</code> method:<pre class="source-code">
@rpc("any_peer", "call_local")
func rematch():</pre></li>				<li>Now, we need to call these methods remotely, using the <code>rpc()</code> method instead of directly calling them in <code>CheckersGame</code>. Let’s do that in <code>_on_checker_board_player_won()</code>, turning the <code>update_winner(winner)</code> into <code>rpc("update_winner", winner)</code> instead. This is the method that the CheckerBoard’s <code>player_won signals</code> is connected to:<pre class="source-code">
func _on_checker_board_player_won(winner):
     rpc("update_winner", winner)</pre></li>				<li>Lastly, we <a id="_idIndexMarker222"/>do the same thing with <code>_on_rematch_button_pressed()</code>, turning the <code>rematch()</code> call into <code>rpc("rematch")</code>. This is the method that<code>pressed</code> signal of <strong class="bold">RematchButton</strong> connects to, so when players press the button, this is what should happen:<pre class="source-code">
func _on_rematch_button_pressed():
     rpc("rematch")</pre></li>			</ol>
			<p>With the adjustments we’ve <a id="_idIndexMarker223"/>made, our game is now fully equipped to run smoothly, whether it’s played locally or remotely. When a player successfully captures their opponent’s pieces, the game will transition all peers into a rematch state, where any peer can initiate a new match and start a fresh game. This ensures that players have the option to engage in continuous gameplay sessions without the need to exit and restart the game manually.</p>
			<div><div><img alt="Figure 6.10 – The CheckersGame rematch screen" src="img/Figure_06.10_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.10 – The CheckersGame rematch screen</p>
			<p>Our game is finally working! We have a fully functional checkers game that players can play online and challenge each other playing multiple matches.</p>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor145"/>Summary</h1>
			<p>To recap, in this chapter, we introduced the <code>MultiplayerSynchronizer</code> node to synchronize properties across a network, established the concept of abstraction for effective data transmission, utilized the <code>@rpc</code> annotations to enable multiplayer functionality, and learned how to assign and manage Multiplayer Authority to ensure player autonomy and resource protection.</p>
			<p>In the upcoming chapter, we will see how to develop an online Pong game. There, we will cover the modifications necessary to turn the local game into an online multiplayer one, setting up online multiplayer paddles, syncing remote objects in real time, and coordinating the paddle’s position. For that, will use the <code>MultiplayerSynchronizer</code> node with a bit more depth than we did in this chapter. Also, we will talk about the importance of maintaining a shared game world for players in action-based games, which is very different from turn-based games.</p>
		</div>
	</body></html>