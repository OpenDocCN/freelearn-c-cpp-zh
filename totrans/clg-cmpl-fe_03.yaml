- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Clang Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will examine the internal architecture of Clang and its
    relationship with other LLVM components. We will begin with an overview of the
    overall compiler architecture, with a specific focus on the clang driver. As the
    backbone of the compiler, the driver runs all compilation phases and controls
    their execution. Finally, we will concentrate on the frontend portion of the Clang
    compiler, which includes lexical and semantic analysis, and produces an **Abstract
    Syntax Tree (AST** ) as its primary output. The AST forms the foundation for most
    Clang tools, and we will examine it more closely in the next chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Compiler overview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clang driver overview, including an explanation of the compilation phases and
    their execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clang frontend overview covering the preprocessing step, parsing, and semantic
    analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.1 Technical requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The source code for this chapter is located in the `chapter2` folder of the
    book’s GitHub repository: [https://github.com/PacktPublishing/Clang-Compiler-Frontend-Packt/tree/main/chapter2](https://github.com/PacktPublishing/Clang-Compiler-Frontend-Packt/tree/main/chapter2).'
  prefs: []
  type: TYPE_NORMAL
- en: 2.2 Getting started with compilers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Despite the fact that compilers are used to translate programs from one form
    to another, they can also be considered large software systems that use various
    algorithms and data structures. The knowledge obtained by studying compilers can
    be used to design other scalable software systems as well. On the other hand,
    compilers are also a subject of active scientific research, and there are many
    unexplored areas and topics to investigate.
  prefs: []
  type: TYPE_NORMAL
- en: You can find some basic information about the internal structure of a compiler
    here. We will keep it as basic as possible so the information applies to any compiler,
    not just Clang. We will briefly cover all phases of compilation, which will help
    to understand Clang’s position in the overall compiler architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 2.2.1 Exploring the compiler workflow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The primary function of a compiler is to convert a program written in a specific
    programming language (such as C/C++ or FORTRAN) into a format that can be executed
    on a target platform. This process involves the use of a compiler, which takes
    the source file and any compilation flags, and produces a build artifact, such
    as an executable or object file, as shown in [Figure 2.1](#Figure2.1).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1: Compiler workflow ](img/Figure2.1_B19722.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 2.1**: Compiler workflow'
  prefs: []
  type: TYPE_NORMAL
- en: The term ”target platform” can have a broad meaning. It can refer to machine
    code that is executed on the same host, as is typically the case. But it can also
    refer to cross-compilation, where the compiler generates code for a different
    computer architecture than the host. For example, code for a mobile application
    or embedded application running on ARM can be generated using an Intel machine
    as the host. Additionally, the target platform is not limited to machine code
    only. For example, some early C++ compilers (such as ”cc”) would produce pure
    C code as output. This was done because, at the time, C was the most widely used
    and well-established programming language, and the C compiler was the most reliable
    way to generate machine code. This approach allowed early C++ programs to be run
    on a wide range of platforms since most systems already had a C compiler available.
    The produced C code could then be compiled into machine code using any popular
    C Compiler such as GCC or LCC.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2: Typical compiler workflow: source program is passed via different
    stages: frontend, middle-end, and backend ](img/Figure2.2_B19722.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 2.2**: Typical compiler workflow: source program is passed via different
    stages: frontend, middle-end, and backend'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to focus on compilers that produce binary code, and a typical
    compiler workflow for such a compiler is shown in [Figure 2.2](#Figure2.2). The
    stages of compilation can be described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Frontend: The frontend does lexical analysis and parsing, which includes both
    syntax analysis and semantic analysis. The syntax analysis assumes that your program
    is well-organized according to the language grammar rules. The semantic analysis
    performs checks on the program’s meaning and rejects invalid programs, such as
    those that use wrong types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Middle-end: The middle-end performs various optimizations on the intermediate
    representation (IR) code (LLVM-IR for Clang).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Backend: The Backend of a compiler takes the optimized or transformed IR and
    generates machine code or assembly code that can be executed by the target platform.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The source program is transformed into different forms as it passes through
    the various stages. For example, the frontend produces IR code, which is then
    optimized by the middle-end, and finally converted into native code by the backend
    (see [Figure 2.3](#Figure2.3)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3: Source code transformation by compiler ](img/Figure2.3_B19722.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 2.3**: Source code transformation by compiler'
  prefs: []
  type: TYPE_NORMAL
- en: Input data consists of **Source code** and **Compile options**. The source code
    is transformed by the **Frontend** into **IR**. The **Middle-end** does different
    optimizations on **IR** and passes the final (optimized) result to the **Backend**.
    The **Backend** generates the **Target code**. The **Frontend**, **Middle-end**,
    and **Backend** use **Compile options** as settings for the code transformations.
    Let’s look into the compiler frontend as the first component of the compiler’s
    workflow.
  prefs: []
  type: TYPE_NORMAL
- en: 2.2.2 Frontend
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The primary goal for the frontend is to convert a given source code to intermediate
    form. It’s worth mentioning that the frontend also transforms the source code
    into various forms before it produces the IR. The frontend will be our primary
    focus in the book, so we will examine its components. The first component of the
    frontend is the Lexer (see [Figure 2.4](#Figure2.4)). It converts the source code
    into a set of tokens, which are used to create a special data structure called
    the abstract syntax tree (AST ). The final component, the code generator (Codegen),
    traverses the AST and generates the IR from it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4: Compiler frontend ](img/Figure2.4_B19722.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 2.4**: Compiler frontend'
  prefs: []
  type: TYPE_NORMAL
- en: The source code is transformed into a set of tokens (**Toks**) by the **Lexer**
    . The **Parser** takes the tokens and creates an **Abstract Syntax Tree** (**AST**
    ) that we will explore in details later in [*Chapter** 3*](B19722_03.xhtml#x1-530003)*,
    Clang AST*. The **Codegen** generates **IR** from the **AST** .
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use a simple C/C++ program that calculates the maximum of two numbers
    to demonstrate the workings of the frontend. The code for the program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 2.5**: Test program for compiler frontend investigations'
  prefs: []
  type: TYPE_NORMAL
- en: The first component of the frontend is the lexer. Let’s examine it.
  prefs: []
  type: TYPE_NORMAL
- en: Lexer
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The frontend process starts with the Lexer , which converts the input source
    into a stream of tokens. In our example program (see [Figure 2.5](#x1-37021r5)),
    the first token is the keyword `int` , which represents the integer type. This
    is followed by the identifier `max` for the function name. The next token is the
    left parenthesis `(` , and so on (see [Figure 2.6](#Figure2.6)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6: Lexer : the program source is converted into a stream of tokens
    ](img/Figure2.6_B19722.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 2.6**: Lexer : the program source is converted into a stream of tokens'
  prefs: []
  type: TYPE_NORMAL
- en: Parser
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Parser is the next component following the Lexer . The primary output produced
    by the Parser is called an **abstract syntax tree (AST)**. This tree represents
    the abstract syntactic structure of the source code written in a programming language.
    The Parser generates the AST by taking the stream of tokens produced by the Lexer
    as input and organizing them into a tree-like structure. Each node in the tree
    represents a construct in the source code, such as a statement or expression,
    and the edges between nodes represent the relationships between these constructs.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7: The AST for our example program, which calculates a maximum of
    two numbers ](img/Figure2.7_B19722.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 2.7**: The AST for our example program, which calculates a maximum
    of two numbers'
  prefs: []
  type: TYPE_NORMAL
- en: The AST for our example program is shown in [Figure 2.7](#Figure2.7). As you
    can see, our function (`max` ) has two parameters (`a` and `b` ) and a body. The
    body is marked as a compound statement in [Figure 2.7](#Figure2.7), see also [Figure 2.40](#x1-50023r38),
    where we provide a definition for a compound statement from the C++ standard.
    The compound statement consists of other statements, such as `return` and `if`
    . The `a` and `b` variables are used in the bodies of these statements. You may
    also be interested in the real AST generated by Clang for the compound statement,
    the result of which is shown in [Figure 2.8](#Figure2.8).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8: The AST for the compound statement generated by Clang . The tree
    generated by the clang -cc1 -ast-view <...> command ](img/file3.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 2.8**: The AST for the compound statement generated by Clang . The
    tree generated by the `clang -cc1 -ast-view <...>` command'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Parser performs two activities:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Syntax analysis: the Parser constructs the AST by analyzing the syntax of the
    program.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Semantic analysis: the Parser analyzes the program semantically.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One of the jobs of the parser is to produce an error message if the parsing
    fails in either of the syntax or semantic analysis phases. If no error occurs,
    then we get a parse tree (or an AST) for the syntax analysis and a semantically
    verified parse tree in the case of semantic analysis. We can get a sense of this
    by considering what types of errors are detected by syntax analysis and which
    ones are detected by semantic analysis.
  prefs: []
  type: TYPE_NORMAL
- en: 'Syntax analysis assumes that the program should be correct in terms of the
    grammar specified for the language. For example, the following program is invalid
    in terms of syntax because a semicolon is missing from the last return statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 2.9**: Listing of program code with a syntax error'
  prefs: []
  type: TYPE_NORMAL
- en: 'Clang produces the following output for the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 2.10**: Compiler output for a program with a syntax error'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, a program can be syntactically correct but make no sense.
    The Parser should detect a semantic error in such cases. For instance, the following
    program has a semantic error related to the wrongly used type for the return value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 2.11**: Listing of program code with a semantic error'
  prefs: []
  type: TYPE_NORMAL
- en: 'Clang generates the following output for the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 2.12**: Compiler output for a program with a semantic error'
  prefs: []
  type: TYPE_NORMAL
- en: AST is mainly constructed as a result of syntax analysis, but for certain languages,
    such as C++, semantic analysis is also crucial for constructing the AST, particularly
    for C++ template instantiation.
  prefs: []
  type: TYPE_NORMAL
- en: During syntax analysis, the compiler verifies that the template declaration
    adheres to the language’s grammar and syntax rules, including the proper use of
    keywords such as ”template” and ”typename,” as well as the formation of the template
    parameters and body.
  prefs: []
  type: TYPE_NORMAL
- en: Semantic analysis, on the other hand, involves the compiler performing template
    instantiation, which generates the AST for specific instances of the template.
    It’s worth noting that the semantic analysis of templates can be quite complex,
    as the compiler must perform tasks such as type checking, name resolution, and
    more for each template instantiation. Additionally, the instantiation process
    can be recursive and lead to a significant amount of code duplication, known as
    code bloat. To combat this, C++ compilers employ techniques such as template instantiation
    caching to minimize the amount of redundant code generated.
  prefs: []
  type: TYPE_NORMAL
- en: The codegen
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The codegen (it’s worth mentioning that we also have another Codegen component
    as a part of Backend that generate the target code) or code generator, which is
    the final component of the compiler’s frontend, has the primary goal of generating
    the **Intermediate Representation (IR)**. For this purpose, the compiler traverses
    the AST generated by the parser and converts it into other source code that is
    called the Intermediate Representation or IR. The IR is a language-independent
    representation, allowing the same middle-end component to be used for different
    frontends (FORTRAN vs C++). Another reason for using an Intermediate Representation
    (IR) is that if we have a new architecture available tomorrow, we can generate
    the target code specific to that architecture. Since the source language remains
    unchanged, all the steps leading up to the IR will remain the same. The IR provides
    this flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: The use of IRs in compilers is a concept that has been around for several decades.
    The idea of using an intermediate representation to represent the source code
    of a program during compilation has evolved over time, and the exact date when
    IR was first introduced in compilers is not clear.
  prefs: []
  type: TYPE_NORMAL
- en: However, it is known that the first compilers in the 1950s and 1960s did not
    use IRs and instead translated source code directly into machine code. By the
    1960s and 1970s, researchers had begun experimenting with using IRs in compilers
    to improve the efficiency and flexibility of the compilation process.
  prefs: []
  type: TYPE_NORMAL
- en: One of the first widely used IRs was three-address code, which was used in the
    mid-1960s in IBM/360’s FORTRAN compiler. Other early examples of IRs include the
    **register transfer language (RTL)** and the **static single** **assignment (SSA)**
    form, which were introduced in the 1970s and 1980s respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Today, the use of IRs in compilers is a standard practice, and many compilers
    use multiple IRs throughout the compilation process. This allows for more powerful
    optimization and code generation techniques to be applied.
  prefs: []
  type: TYPE_NORMAL
- en: 2.3 Clang driver overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When discussing compilers, we typically refer to a command-line utility that
    initiates and manages the compilation process. For example, to use the GNU Compiler
    Collection, one must call `gcc` to start the compilation process. Similarly, to
    compile a C++ program using Clang, one must call `clang` as the compiler. The
    program that controls the compilation process is known as the driver. The driver
    coordinates different stages of compilation and connects them together. In the
    book, we will be focusing on LLVM and using Clang as the driver for the compilation
    process.
  prefs: []
  type: TYPE_NORMAL
- en: It may be confusing for readers that the same word, ”Clang,” is used to refer
    to both the compiler frontend and the compilation driver. In contrast, with other
    compilers, where the driver and C++ compiler can be separate executables, ”Clang”
    is a single executable that functions as both the driver and the compiler frontend.
    To use Clang as the compiler frontend only, the special option `-cc1` must be
    passed to it.
  prefs: []
  type: TYPE_NORMAL
- en: 2.3.1 Example program
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will use the simple “Hello world!” example program for our experiments with
    the Clang driver. The main source file is called `hello.cpp` . The file implements
    a trivial C++ program that prints “Hello world!” to the standard output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 2.13**: Example program: hello.cpp'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can compile the source with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 2.14**: Compilation for `hello.cpp`'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we used the `clang` executable as the compiler and specified
    the `-lstdc++` library option because we used the `<``iostream``>` header from
    the standard C++ library. We also specified the output for the executable (`/tmp/hello`
    ) with the `-o` option.
  prefs: []
  type: TYPE_NORMAL
- en: 2.3.2 Compilation phases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We used two inputs for our example program. The first one is our source code
    and the second one is a shared library for the standard C++ library. The Clang
    driver should combine the inputs together, pass them via different phases of the
    compilation process, and finally, provide the executable file on the target platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clang uses the same typical compiler workflow as shown in [Figure 2.2](#Figure2.2).
    You can ask Clang to show the phases using the `-ccc-print-phases` additional
    argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 2.15**: Command to print compilation phases for hello.cpp'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output for the command is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 2.16**: Compilation phases for hello.cpp'
  prefs: []
  type: TYPE_NORMAL
- en: We can visualize the output as shown in [Figure 2.17](#Figure2.17).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.17: Clang driver phases](img/Figure2.17_B19722.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 2.17**: Clang driver phases'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in [Figure 2.17](#Figure2.17), the driver receives an input file,
    `hello.cpp` , which is a C++ file. The file is processed by the preprocessor and
    we obtain the preprocessor output (marked as `c++-cpp-output` ). The result is
    compiled into IR form by the compiler, and then the backend converts it into assembly
    form. This form is later transformed into an object file. The final object file
    is combined with another object (`libstdc++` ) to produce the final binary (`image`
    ).
  prefs: []
  type: TYPE_NORMAL
- en: 2.3.3 Tool execution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The phases are combined into several tool executions. The Clang driver invokes
    different programs to produce the final executable. Specifically, for our example,
    it calls the `clang` compiler and the `ld` linker. Both programs require additional
    arguments that are set up by the driver.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, our example program (`hello.cpp` ) includes the following header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 2.18**: iostream header at hello.cpp'
  prefs: []
  type: TYPE_NORMAL
- en: We did not specify any additional arguments (such as search paths, for example,
    `-I` ) when we invoked the compilation. However, different architectures and operating
    systems might have different paths for locating headers.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Fedora 39, the header is located in the `/usr/include/c++/13/iostream` folder.
    We can examine a detailed description of the process executed by the driver and
    the arguments used with the `-###` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 2.19**: Command to print tools execution for hello.cpp'
  prefs: []
  type: TYPE_NORMAL
- en: The output for this command is quite extensive, and certain parts have been
    omitted here. Please refer to [Figure 2.20](#x1-44025r19).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 2.20**: Clang driver tool execution. The host system is Fedora 39\.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see in [Figure 2.20](#x1-44025r19), the driver initiates two processes:
    `clang-18` with the `-cc1` flag (see *Lines 2-12*) and the linker `ld` (see *Lines
    13-16*). The Clang compiler implicitly receives several search paths, as seen
    in *Lines 5, 7, 9, and 11*. These paths are necessary for the inclusion of the
    `iostream` header in the test program.'
  prefs: []
  type: TYPE_NORMAL
- en: The output of the first executable (`/tmp/hello-XXX.o` ) serves as input for
    the second one (see *Lines 12 and 15*). The arguments `-lstdc++` and `-o /tmp/hello`
    are set for the linker, while the first argument (hello.cpp) is provided for the
    compiler invocation (first executable).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.21: Clang driver tool execution. The Clang driver runs two executables:
    the clang executable with the -cc1 flag and the linker - ld executable ](img/Figure2.21_B19722.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 2.21**: Clang driver tool execution. The Clang driver runs two executables:
    the clang executable with the -cc1 flag and the linker - ld executable'
  prefs: []
  type: TYPE_NORMAL
- en: 'The process can be visualized as shown in [Figure 2.21](#Figure2.21), where
    we can see that two executables are executed as part of the compilation process.
    The first one is `clang-18` with a special flag (`-cc1` ). The second one is the
    linker: `ld` .'
  prefs: []
  type: TYPE_NORMAL
- en: 2.3.4 Combining it all together
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can summarize the knowledge we have acquired so far using [Figure 2.22](#Figure2.22).
    The figure illustrates two different processes started by the Clang driver. The
    first one is `clang -cc1` (compiler), and the second one is `ld` (linker). The
    compiler process is the same executable as the Clang driver (`clang` ), but it
    is run with a special argument: `-cc1` . The compiler produces an object file
    that is then processed by the linker (`ld` ) to generate the final binary.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.22: Clang driver: The driver got the input file hello.cpp, which
    is a C++ file. It starts two processes: clang and ld. The first one does real
    compilation and starts the integrated assembler. The last one is the linker (ld)
    that produces the final binary (image) from the result received from the compiler
    and the external library (libstdc++)](img/Figure2.22_B19722.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 2.22**: Clang driver: The driver got the input file hello.cpp, which
    is a C++ file. It starts two processes: clang and ld. The first one does real
    compilation and starts the integrated assembler. The last one is the linker (ld)
    that produces the final binary (image) from the result received from the compiler
    and the external library (libstdc++)'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 2.22](#Figure2.22), we can observe similar components of the compiler
    mentioned earlier (see [*Section** 2.2*](#x1-350002)*, Getting started with compilers*).
    However, the main difference is that the **preprocessor** (part of the lexer)
    is shown separately, while the frontend and middle-end are combined into the **compiler**.
    Additionally, the figure depicts an **assembler** that is executed by the driver
    to generate the object code. It is important to note that the assembler can be
    integrated, as shown in [Figure 2.22](#Figure2.22), or it may require a separate
    process to be executed.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of specifying an external assembler using the `-c` (compile
    only) and `-o` (output file) options, along with the appropriate flags for your
    platform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 2.3.5 Debugging Clang
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to step through a debugging session for our compilation process,
    illustrated in [Figure 2.14](#x1-42011r14).
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: We will use the LLDB build created previously in [*Section** 1.3.3*](B19722_01.xhtml#x1-290003)*,*
    *The LLVM debugger, its build, and usage* for this and other debug sessions throughout
    the book. You can also use the LLDB that comes as part of your host system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our chosen point of interest, or breakpoint, is the `clang::ParseAST` function.
    In a typical debug session, which resembles the one outlined in [Figure 1.11](B19722_01.xhtml#listing-7),
    you would feed command-line arguments following the `"- -"` symbol. The command
    should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 2.23**: Running debugger for hello.cpp file compilation'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, `<...>` represents the directory path used to clone the LLVM project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, this approach doesn’t work with the Clang compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 2.24**: Debugger session with failed interruption'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see from *Line 7*, the breakpoint was set but the process finished
    successfully (*Line 11*) without any interruptions. In other words, our breakpoint
    didn’t trigger in this instance.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the internals of the Clang driver can help us identify the problem
    at hand. As mentioned earlier, the `clang` executable acts as a driver in this
    context, running two separate processes (refer to [Figure 2.21](#Figure2.21)).
    Therefore, if we wish to debug the compiler, we need to run it using the `-cc1`
    option.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s worth mentioning a certain optimization implemented in Clang in 2019 [[22](B19722_Bib.xhtml#Xllvm_D69825)].
    When using the `-c` option, the Clang driver doesn’t spawn a new process for the
    compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As shown above, the Clang driver does not spawn a new process and instead calls
    the ”cc1” tool within the same process. This feature not only improves the compiler’s
    performance but can also be leveraged for Clang debugging.
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon using the `-cc1` option and excluding the `-lstdc++` option (which is
    specific to the second process, the ld linker), the debugger will generate the
    following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 2.25**: Debugger session with missing search paths'
  prefs: []
  type: TYPE_NORMAL
- en: Thus, we can see that we were able to successfully set the breakpoint, but the
    process ended with an error (see *Lines 20-24*). This error arose because we omitted
    certain search paths, which are typically appended implicitly by the Clang driver,
    necessary to find all the includes required for successful compilation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can successfully execute the process if we explicitly include all necessary
    arguments in the compiler invocation. Here’s how to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 2.26**: Running the debugger with specified search paths. Host system
    is Fedora 39'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we can set the breakpoint for `clang``::``ParseAST` and run the debugger.
    The execution will complete without errors, as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 2.27**: Successful debugger session for compiler'
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, we have successfully demonstrated the debugging of a Clang compiler
    invocation. The techniques presented can be effectively employed for exploring
    the internals of a compiler and addressing compiler-related bugs.
  prefs: []
  type: TYPE_NORMAL
- en: 2.4 Clang frontend overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s evident that the Clang compiler toolchain conforms to the pattern widely
    described in various compiler books [[1](B19722_Bib.xhtml#XAho2006Compilers), [18](B19722_Bib.xhtml#Xbook_engineering_a_compiler)].
    However, Clang’s frontend part diverges significantly from a typical compiler
    frontend. The primary reason for this distinction is the complexity of the C++
    language. Some features, such as macros, can modify the source code itself, while
    others, such as typedef, can influence the kind of token. Clang can also generate
    output in a variety of formats. For instance, the following command generates
    an aesthetically pleasing HTML view of the program shown in [*Figure 2.5*](#x1-37021r5):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Take note that we pass the argument to emit the HTML form of the source program
    to the Clang frontend, specified with the `-cc1` option. Alternatively, you can
    pass an option to the frontend via the `-Xclang` option, which requires an additional
    argument representing the option itself, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You may notice that, in the preceding command, we utilized the `-fsyntax-only`
    option, instructing Clang to only execute the preprocessor, parser, and semantic
    analysis stages.
  prefs: []
  type: TYPE_NORMAL
- en: Accordingly, we can instruct the Clang frontend to perform different actions
    and produce varying types of output based on the provided compilation options.
    The base class for these actions is termed `FrontendAction` .
  prefs: []
  type: TYPE_NORMAL
- en: 2.4.1 Frontend action
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Clang frontend is capable of executing only one frontend action at a time.
    A frontend action is a specific task or process that the frontend performs based
    on the provided compiler option. The following is a list of some possible frontend
    actions (the table only includes a subset of the available frontend actions):'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| FrontendAction | Compiler option | Description |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| EmitObjAction | `-emit-obj` (default) | Compile to an object file |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| EmitBCAction | `-emit-llvm-bc` | Compile to LLVM bytecode |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| EmitLLVMAction | `-emit-llvm` | Compile to LLVM readable form |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| ASTPrintAction | `-ast-print` | Build ASTs and then pretty-print them. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| HTMLPrintAction | `-emit-html` | Prints the program source in HTML form |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| DumpTokensAction | `-dump-tokens` | Prints preprocessor tokens |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '**Table 2.1:** Frontend actions'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.28: Clang frontend components ](img/Figure2.28_B19722.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 2.28**: Clang frontend components'
  prefs: []
  type: TYPE_NORMAL
- en: The diagram shown in [Figure 2.28](#Figure2.28) illustrates the basic frontend
    architecture, which is similar to the architecture shown in [Figure 2.4](#Figure2.4).
    However, there are notable differences specific to Clang.
  prefs: []
  type: TYPE_NORMAL
- en: One significant change is the naming of the lexer. In Clang, the lexer is referred
    to as the preprocessor. This naming convention reflects the fact that the lexer
    implementation is encapsulated within the `Preprocessor` class. This alteration
    was inspired by the unique aspects of the C/C++ language, which includes special
    types of tokens (macros) that require specialized preprocessing.
  prefs: []
  type: TYPE_NORMAL
- en: Another noteworthy deviation is found in the parser component. While conventional
    compilers typically perform both syntax and semantic analysis within the parser,
    Clang distributes these tasks across different components. The `Parser` component
    focuses solely on syntax analysis, while the `Sema` component handles semantic
    analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, Clang offers the ability to produce output in different forms or
    formats. For example, the `CodeGenAction` class serves as the base class for various
    code generation actions, such as `EmitObjAction` or `EmitLLVMAction`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the code for the `max` function from [Figure 2.5](#x1-37021r5)
    for our future exploration of the Clang frontend’s internals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 2.29**: Source code for max function: max.cpp'
  prefs: []
  type: TYPE_NORMAL
- en: By utilizing the `-cc1` option, we can directly invoke the Clang frontend, bypassing
    the driver. This approach allows us to examine and analyze the inner workings
    of the Clang frontend in greater detail.
  prefs: []
  type: TYPE_NORMAL
- en: 2.4.2 Preprocessor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first part is the Lexer , which is called the preprocessor in Clang. Its
    primary goal is to convert the input program into a stream of tokens. You can
    print the token stream using the `-dump-tokens` options as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the command is as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 2.30**: Clang dump token output'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, there are different types of tokens, such as language keywords
    (e.g., `int`, `return`), identifiers (e.g., `max`, `a`, `b`, etc.), and special
    symbols (e.g., semicolon, comma, etc.). The tokens for our small program are called
    **normal** **tokens**, which are returned by the lexer.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to normal tokens, Clang has an additional type of token called **annotation
    tokens**. The primary difference is that these tokens also store additional semantic
  prefs: []
  type: TYPE_NORMAL
- en: information. For instance, a sequence of normal tokens can be replaced by the
    parser with a single annotation token that contains information about the type
    or C++ scope. The primary reason for using such tokens is performance, as it allows
    for the prevention of reparsing when the parser needs to backtrack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since annotation tokens are used in the internal implementation of the parser,
    it would be good to consider an example of their usage with LLDB. Suppose we have
    the following C++ code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 2.31**: Source code that uses annotation tokens, annotation.cpp'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last line of the code declares the variable `a` with the following type:'
  prefs: []
  type: TYPE_NORMAL
- en: '`clangbook``::``A``<``int``>`. The type is represented as an annotation token,
    as shown in the following LLDB session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 2.32**: LLDB session for annotation.cpp'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, Clang consumes an annotation token from *Line 4* of the program
    shown in [Figure 2.31](#x1-49014r29). The token is located between columns 1 and
    7\. See [Figure 2.32](#x1-49032r30). This corresponds to the following text used
    as the token: `clangbook``::``A``<``int``>`. The token consists of other tokens,
    such as ’clangbook’, ’::’, and so on. Combining all the tokens into one will significantly
    simplify the parsing and boost the overall parsing performance.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.33: Preprocessor (clang lexer) class internals ](img/Figure2.33_B19722.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 2.33**: Preprocessor (clang lexer) class internals'
  prefs: []
  type: TYPE_NORMAL
- en: 'C/C++ language has some specifics that influence the internal implementation
    of the `Preprocessor` class. The first one is about macros. The `Preprocessor`
    class has two different helper classes to retrieve tokens:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Lexer` class is used to convert a text buffer into a stream of tokens.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `TokenLexer` class is used to retrieve tokens from macro expansions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should be noted that only one of these helpers can be active at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Another specific aspect of C/C++ is the `#``include` directive (which is also
    applicable to the import directive). In this case, we need to maintain a stack
    of includes, where each include can have its own `TokenLexer` or `Lexer`, depending
    on whether there is a macro expansion within it. As a result, the `Preprocessor`
    class keeps a stack of lexers (`IncludeMacroStack` class) for each `#``include`
    directive, as shown in [Figure 2.33](#Figure2.33).
  prefs: []
  type: TYPE_NORMAL
- en: 2.4.3 Parser and sema
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The parser and sema are crucial components of the Clang compiler frontend.
    They handle the syntax and semantic analysis of the source code, producing an
    AST as output. This tree can be visualized for our test program using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this command is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 2.34**: Clang AST dump output'
  prefs: []
  type: TYPE_NORMAL
- en: Clang utilizes a hand-written recursive-descent parser [[10](B19722_Bib.xhtml#Xllvm_clangfeatures)].
    This parser can be considered simple, and this simplicity was one key reason for
    its selection. Additionally, the complex rules specified for the C/C++ languages
    necessitated an ad hoc parser with easily adaptable rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore how this works with our example. Parsing begins with a top-level
    declaration known as a `TranslationUnitDecl`, representing a single translation
    unit. The C++ standard defines a translation unit as follows [[21](B19722_Bib.xhtml#Xstandard_cpp20),
    lex.separate]:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A source file together with all the headers (16.5.1.2) and source files included
    (15.3) via the preprocessing directive #include, less any source lines skipped
    by any of the conditional inclusion (15.2) preprocessing directives, is called
    a translation unit.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The parser first recognizes that the initial tokens from the source code correspond
    to a function definition, as defined in the C++ standard [[21](B19722_Bib.xhtml#Xstandard_cpp20),
    dcl.fct.def.general]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 2.35**: Function definition for C++ standard'
  prefs: []
  type: TYPE_NORMAL
- en: 'The corresponding code follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 2.36**: Part of the example code corresponding to function definition
    from C++ standard'
  prefs: []
  type: TYPE_NORMAL
- en: 'The function definition necessitates a declarator and function body. We’ll
    start with the declarator, defined in the C++ standard as [[21](B19722_Bib.xhtml#Xstandard_cpp20),
    dcl.decl.general]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 2.37**: Declarator definition for C++ standard'
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, the declarator specifies a list of parameter declarations within
    brackets. The corresponding piece of code from the source is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 2.38**: Part of the example code corresponding to declarator from
    C++ standard'
  prefs: []
  type: TYPE_NORMAL
- en: 'The function definition, as stated above, also requires a function body. The
    C++ standard specifies the function body as follows: [[21](B19722_Bib.xhtml#Xstandard_cpp20),
    dcl.fct.def.general]'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 2.39**: Function body definition for C++ standard'
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus the function body consists of a compound statement, which is defined as
    follows in the C++ standard [[21](B19722_Bib.xhtml#Xstandard_cpp20), stmt.block]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 2.40**: Compound statement definition for C++ standard'
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, it describes a sequence of statements enclosed within `{...` brackets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our program has two types of statements: the conditional (`if` ) statement
    and the `return` statement. These are represented in the C++ grammar definition
    as follows [[21](B19722_Bib.xhtml#Xstandard_cpp20), stmt.pre]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 2.41**: Statement definition for C++ standard'
  prefs: []
  type: TYPE_NORMAL
- en: In this context, the `selection` statement corresponds to the `if` condition
    in our program, while the `jump` statement corresponds to the `return` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine the `jum` statement in more detail [[21](B19722_Bib.xhtml#Xstandard_cpp20),
    stmt.jump.general]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 2.42**: jump statement definition for C++ standard'
  prefs: []
  type: TYPE_NORMAL
- en: 'where `expr-or-braced-init-list` is defined as [[21](B19722_Bib.xhtml#Xstandard_cpp20),
    dcl.init.general]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 2.43**: Return expression definition for C++ standard'
  prefs: []
  type: TYPE_NORMAL
- en: In this context, the `return` keyword is followed by an expression and a semicolon.
    In our case, there’s an implicit cast expression that automatically converts the
    variable into the required type (`int` ).
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be enlightening to examine the parser’s operation through the LLDB debugger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The debugger session output is shown in [Figure 2.44](#x1-50054r42). As you
    can see, on *Line 1*, we’ve set a breakpoint for the parsing of return statements.
    Our program has two return statements. We bypass the first call (line 4) and halt
    at the second method invocation (*Line 9*). The backtrace (from the ’bt’ command
    at *Line 13*) displays the call stack for the parsing process. This stack mirrors
    the parsing blocks we described earlier, adhering to the C++ grammar detailed
    in [[21](B19722_Bib.xhtml#Xstandard_cpp20), lex.separate].
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 2.44**: Second return statement parsing at max.cpp example program'
  prefs: []
  type: TYPE_NORMAL
- en: 'The parsing results in the generation of AST. We can also inspect the process
    of AST creation using the debugger. To do this, we need to set a corresponding
    breakpoint at the `clang``::``ReturnStmt``::``Create` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 2.45**: Breakpoint at clang::ReturnStmt::Create'
  prefs: []
  type: TYPE_NORMAL
- en: As can be seen, the AST node for the return statement is created by the Sema
    component.
  prefs: []
  type: TYPE_NORMAL
- en: 'The beginning of the return statement parser can be located in frame 4:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 2.46**: Return statement parsing at debugger'
  prefs: []
  type: TYPE_NORMAL
- en: As we can observe, there is a reference to the C99 standard [[25](B19722_Bib.xhtml#Xstandard_c99)]
    for the corresponding statement. The standard [[25](B19722_Bib.xhtml#Xstandard_c99)]
    provides a detailed description of the statement and the process for handling
    it.
  prefs: []
  type: TYPE_NORMAL
- en: The code assumes that the current token is of type `tok``::``kw_return`, and
    in this case, the parser invokes the relevant `clang``::``Parser``::``ParseReturnStatement`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: While the process of AST node creation can vary across different C++ constructs,
    it generally follows the pattern displayed in [Figure 2.47](#Figure2.47).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.47: C++ parsing in Clang frontend ](img/Figure2.47_B19722.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 2.47**: C++ parsing in Clang frontend'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 2.47](#Figure2.47), the square boxes represent the corresponding
    classes, and the function calls are represented as edges with the called function
    shown as the edge label. As can be seen, the `Parser` invokes the `Preprocessor``::``Lex`
    method to retrieve a token from the lexer. It then calls a method corresponding
    to the token, for example, `Parser``:``ParseXXX` for the token `XXX`. This method
    then calls `Sema``::``ActOnXXX`, which creates the corresponding object using
    `XXX``::``Create`. The process is then repeated with a new token.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this, we have now fully explored how the typical compiler frontend flow
    is implemented in Clang. We can see how the lexer component (the preprocessor)
    works in tandem with the parser (which comprises the parser and sema components)
    to produce the primary data structure for future code generation: the Abstract
    Syntax Tree (AST). The AST is not only essential for code generation but also
    for code analysis and modification. Clang provides easy access to the AST, thereby
    enabling the development of a diverse range of compiler tools.'
  prefs: []
  type: TYPE_NORMAL
- en: 2.5 Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we have acquired a basic understanding of compiler architecture
    and delved into the various stages of the compilation process, with a focus on
    the Clang driver. We have explored the internals of the Clang frontend, studying
    the Preprocessor that transforms a program into a set of tokens, and the Parser,
    which interacts with a component called ’Sema’. Together, these elements perform
    syntax and semantic analysis.
  prefs: []
  type: TYPE_NORMAL
- en: The upcoming chapter will center on the Clang Abstract Syntax Tree (AST)—the
    primary data structure employed in various Clang tools. We will discuss its construction
    and the methods for traversing it.
  prefs: []
  type: TYPE_NORMAL
- en: 2.6 Further reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Working Draft, Standard for Programming Language C++: [https://eel.is/c++draft/](https://eel.is/c++draft/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '“Clang” CFE Internals Manual: [https://clang.llvm.org/docs/InternalsManual.html](https://clang.llvm.org/docs/InternalsManual.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Keith Cooper and Linda Torczon: Engineering A Compiler, 2012 [[18](B19722_Bib.xhtml#Xbook_engineering_a_compiler)]'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
