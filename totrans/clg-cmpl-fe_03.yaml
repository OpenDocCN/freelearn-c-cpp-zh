- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Clang Architecture
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Clang架构
- en: In this chapter, we will examine the internal architecture of Clang and its
    relationship with other LLVM components. We will begin with an overview of the
    overall compiler architecture, with a specific focus on the clang driver. As the
    backbone of the compiler, the driver runs all compilation phases and controls
    their execution. Finally, we will concentrate on the frontend portion of the Clang
    compiler, which includes lexical and semantic analysis, and produces an **Abstract
    Syntax Tree (AST** ) as its primary output. The AST forms the foundation for most
    Clang tools, and we will examine it more closely in the next chapters.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将检查Clang的内部架构及其与其他LLVM组件的关系。我们将从整体编译器架构的概述开始，特别关注clang驱动程序。作为编译器的骨架，驱动程序运行所有编译阶段并控制它们的执行。最后，我们将专注于Clang编译器的前端部分，这包括词法分析和语义分析，并生成**抽象语法树（AST**）作为其主要输出。AST是大多数Clang工具的基础，我们将在下一章中更详细地研究它。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Compiler overview
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器概述
- en: Clang driver overview, including an explanation of the compilation phases and
    their execution
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clang驱动程序概述，包括编译阶段及其执行的说明
- en: Clang frontend overview covering the preprocessing step, parsing, and semantic
    analysis
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clang前端概述，包括预处理步骤、解析和语义分析
- en: 2.1 Technical requirements
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 技术要求
- en: 'The source code for this chapter is located in the `chapter2` folder of the
    book’s GitHub repository: [https://github.com/PacktPublishing/Clang-Compiler-Frontend-Packt/tree/main/chapter2](https://github.com/PacktPublishing/Clang-Compiler-Frontend-Packt/tree/main/chapter2).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码位于本书GitHub仓库的`chapter2`文件夹中：[https://github.com/PacktPublishing/Clang-Compiler-Frontend-Packt/tree/main/chapter2](https://github.com/PacktPublishing/Clang-Compiler-Frontend-Packt/tree/main/chapter2)。
- en: 2.2 Getting started with compilers
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 编译器入门
- en: Despite the fact that compilers are used to translate programs from one form
    to another, they can also be considered large software systems that use various
    algorithms and data structures. The knowledge obtained by studying compilers can
    be used to design other scalable software systems as well. On the other hand,
    compilers are also a subject of active scientific research, and there are many
    unexplored areas and topics to investigate.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管编译器用于将程序从一种形式转换为另一种形式，但它们也可以被视为使用各种算法和数据结构的大型软件系统。通过研究编译器获得的知识可以用来设计其他可扩展的软件系统。另一方面，编译器也是活跃的科学研究的主题，有许多未探索的领域和主题需要研究。
- en: You can find some basic information about the internal structure of a compiler
    here. We will keep it as basic as possible so the information applies to any compiler,
    not just Clang. We will briefly cover all phases of compilation, which will help
    to understand Clang’s position in the overall compiler architecture.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处找到有关编译器内部结构的一些基本信息。我们将尽可能保持其基础性，以便信息适用于任何编译器，而不仅仅是Clang。我们将简要介绍编译的所有阶段，这将有助于理解Clang在整体编译器架构中的位置。
- en: 2.2.1 Exploring the compiler workflow
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.1 探索编译器工作流程
- en: The primary function of a compiler is to convert a program written in a specific
    programming language (such as C/C++ or FORTRAN) into a format that can be executed
    on a target platform. This process involves the use of a compiler, which takes
    the source file and any compilation flags, and produces a build artifact, such
    as an executable or object file, as shown in [Figure 2.1](#Figure2.1).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器的主要功能是将用特定编程语言（如C/C++或FORTRAN）编写的程序转换为可以在目标平台上执行的形式。这个过程涉及到编译器的使用，它接收源文件和任何编译标志，并生成构建工件，例如可执行文件或对象文件，如[图2.1](#Figure2.1)所示。
- en: '![Figure 2.1: Compiler workflow ](img/Figure2.1_B19722.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1：编译器工作流程](img/Figure2.1_B19722.png)'
- en: '**Figure 2.1**: Compiler workflow'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**图2.1**：编译器工作流程'
- en: The term ”target platform” can have a broad meaning. It can refer to machine
    code that is executed on the same host, as is typically the case. But it can also
    refer to cross-compilation, where the compiler generates code for a different
    computer architecture than the host. For example, code for a mobile application
    or embedded application running on ARM can be generated using an Intel machine
    as the host. Additionally, the target platform is not limited to machine code
    only. For example, some early C++ compilers (such as ”cc”) would produce pure
    C code as output. This was done because, at the time, C was the most widely used
    and well-established programming language, and the C compiler was the most reliable
    way to generate machine code. This approach allowed early C++ programs to be run
    on a wide range of platforms since most systems already had a C compiler available.
    The produced C code could then be compiled into machine code using any popular
    C Compiler such as GCC or LCC.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: “目标平台”这个术语可以具有广泛的意义。它可以指在同一主机上执行的目标机器代码，这是典型情况。但它也可以指交叉编译，在这种情况下，编译器为不同于主机的不同计算机架构生成代码。例如，使用英特尔机器作为主机可以生成在ARM上运行的移动应用程序或嵌入式应用程序的代码。此外，目标平台不仅限于机器代码。例如，一些早期的C++编译器（如“cc”）会生成纯C代码作为输出。这是因为在当时，C是最广泛使用且最成熟的编程语言，C编译器是生成机器代码最可靠的方式。这种方法允许早期的C++程序在广泛的平台上运行，因为大多数系统已经提供了C编译器。然后，生成的C代码可以使用任何流行的C编译器（如GCC或LCC）编译成机器代码。
- en: '![Figure 2.2: Typical compiler workflow: source program is passed via different
    stages: frontend, middle-end, and backend ](img/Figure2.2_B19722.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2：典型的编译器工作流程：源程序通过不同的阶段：前端、中间端和后端](img/Figure2.2_B19722.png)'
- en: '**Figure 2.2**: Typical compiler workflow: source program is passed via different
    stages: frontend, middle-end, and backend'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**图2.2**：典型的编译器工作流程：源程序通过不同的阶段：前端、中间端和后端'
- en: 'We are going to focus on compilers that produce binary code, and a typical
    compiler workflow for such a compiler is shown in [Figure 2.2](#Figure2.2). The
    stages of compilation can be described as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将关注生成二进制代码的编译器，并展示这样一个编译器的典型编译器工作流程[图2.2](#Figure2.2)。编译的阶段可以描述如下：
- en: 'Frontend: The frontend does lexical analysis and parsing, which includes both
    syntax analysis and semantic analysis. The syntax analysis assumes that your program
    is well-organized according to the language grammar rules. The semantic analysis
    performs checks on the program’s meaning and rejects invalid programs, such as
    those that use wrong types.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前端：前端执行词法分析和解析，包括语法分析和语义分析。语法分析假设你的程序根据语言语法规则组织得很好。语义分析对程序的意义进行检查，并拒绝无效的程序，例如使用错误类型的程序。
- en: 'Middle-end: The middle-end performs various optimizations on the intermediate
    representation (IR) code (LLVM-IR for Clang).'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间端：中间端对中间表示（IR）代码（Clang的LLVM-IR）执行各种优化。
- en: 'Backend: The Backend of a compiler takes the optimized or transformed IR and
    generates machine code or assembly code that can be executed by the target platform.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后端：编译器后端接收优化或转换后的IR，并生成目标平台可执行的目标机器代码或汇编代码。
- en: The source program is transformed into different forms as it passes through
    the various stages. For example, the frontend produces IR code, which is then
    optimized by the middle-end, and finally converted into native code by the backend
    (see [Figure 2.3](#Figure2.3)).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 源程序在通过各个阶段时被转换成不同的形式。例如，前端生成IR代码，然后由中间端进行优化，最后由后端转换为本地代码（见[图2.3](#Figure2.3)）。
- en: '![Figure 2.3: Source code transformation by compiler ](img/Figure2.3_B19722.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图2.3：编译器对源代码的转换](img/Figure2.3_B19722.png)'
- en: '**Figure 2.3**: Source code transformation by compiler'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**图2.3**：编译器对源代码的转换'
- en: Input data consists of **Source code** and **Compile options**. The source code
    is transformed by the **Frontend** into **IR**. The **Middle-end** does different
    optimizations on **IR** and passes the final (optimized) result to the **Backend**.
    The **Backend** generates the **Target code**. The **Frontend**, **Middle-end**,
    and **Backend** use **Compile options** as settings for the code transformations.
    Let’s look into the compiler frontend as the first component of the compiler’s
    workflow.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 输入数据包括**源代码**和**编译选项**。源代码通过**前端**转换成**IR**。**中间端**对**IR**进行不同的优化，并将最终（优化后的）结果传递给**后端**。**后端**生成**目标代码**。**前端**、**中间端**和**后端**使用**编译选项**作为代码转换的设置。让我们首先研究编译器的前端，它是编译器工作流程的第一个组件。
- en: 2.2.2 Frontend
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.2 前端
- en: The primary goal for the frontend is to convert a given source code to intermediate
    form. It’s worth mentioning that the frontend also transforms the source code
    into various forms before it produces the IR. The frontend will be our primary
    focus in the book, so we will examine its components. The first component of the
    frontend is the Lexer (see [Figure 2.4](#Figure2.4)). It converts the source code
    into a set of tokens, which are used to create a special data structure called
    the abstract syntax tree (AST ). The final component, the code generator (Codegen),
    traverses the AST and generates the IR from it.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 前端的主要目标是将给定的源代码转换成中间形式。值得注意的是，在生成IR之前，前端还将源代码转换成各种形式。前端将是本书的主要焦点，因此我们将检查其组件。前端的第一组件是Lexer（见[图2.4](#Figure2.4)）。它将源代码转换成一组标记，这些标记用于创建一个特殊的数据结构，即抽象语法树（AST）。最后一个组件是代码生成器（Codegen），它遍历AST并从中生成IR。
- en: '![Figure 2.4: Compiler frontend ](img/Figure2.4_B19722.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图2.4：编译器前端](img/Figure2.4_B19722.png)'
- en: '**Figure 2.4**: Compiler frontend'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**图2.4**：编译器前端'
- en: The source code is transformed into a set of tokens (**Toks**) by the **Lexer**
    . The **Parser** takes the tokens and creates an **Abstract Syntax Tree** (**AST**
    ) that we will explore in details later in [*Chapter** 3*](B19722_03.xhtml#x1-530003)*,
    Clang AST*. The **Codegen** generates **IR** from the **AST** .
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码通过Lexer转换成一组标记（**Toks**）。解析器（Parser）接收这些标记并创建一个**抽象语法树**（**AST**），我们将在[第3章](B19722_03.xhtml#x1-530003)*，Clang
    AST*中详细探讨。代码生成器（Codegen）从AST生成**中间表示**（**IR**）。
- en: 'We will use a simple C/C++ program that calculates the maximum of two numbers
    to demonstrate the workings of the frontend. The code for the program is as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个简单的C/C++程序来计算两个数的最大值，以演示前端的工作原理。该程序的代码如下：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Figure 2.5**: Test program for compiler frontend investigations'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**图2.5**：编译器前端测试程序'
- en: The first component of the frontend is the lexer. Let’s examine it.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 前端的第一组件是lexer。让我们来考察它。
- en: Lexer
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Lexer
- en: The frontend process starts with the Lexer , which converts the input source
    into a stream of tokens. In our example program (see [Figure 2.5](#x1-37021r5)),
    the first token is the keyword `int` , which represents the integer type. This
    is followed by the identifier `max` for the function name. The next token is the
    left parenthesis `(` , and so on (see [Figure 2.6](#Figure2.6)).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 前端处理过程从Lexer开始，它将输入源代码转换成一系列的标记。在我们的示例程序中（见[图2.5](#x1-37021r5)），第一个标记是关键字`int`，它代表整数类型。接下来是函数名`max`的标识符。下一个标记是左括号`(`，以此类推（见[图2.6](#Figure2.6)）。
- en: '![Figure 2.6: Lexer : the program source is converted into a stream of tokens
    ](img/Figure2.6_B19722.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图2.6：Lexer：程序源代码被转换成一系列的标记](img/Figure2.6_B19722.png)'
- en: '**Figure 2.6**: Lexer : the program source is converted into a stream of tokens'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**图2.6**：Lexer：程序源代码被转换成一系列的标记'
- en: Parser
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解析器
- en: The Parser is the next component following the Lexer . The primary output produced
    by the Parser is called an **abstract syntax tree (AST)**. This tree represents
    the abstract syntactic structure of the source code written in a programming language.
    The Parser generates the AST by taking the stream of tokens produced by the Lexer
    as input and organizing them into a tree-like structure. Each node in the tree
    represents a construct in the source code, such as a statement or expression,
    and the edges between nodes represent the relationships between these constructs.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 解析器是紧随Lexer之后的下一个组件。解析器的主要输出称为**抽象语法树（AST**）。这棵树代表了用编程语言编写的源代码的抽象句法结构。解析器通过将Lexer产生的标记流作为输入并组织成树状结构来生成AST。树中的每个节点代表源代码中的一个结构，如语句或表达式，节点之间的边代表这些结构之间的关系。
- en: '![Figure 2.7: The AST for our example program, which calculates a maximum of
    two numbers ](img/Figure2.7_B19722.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图2.7：计算两个数最大值的示例程序的AST](img/Figure2.7_B19722.png)'
- en: '**Figure 2.7**: The AST for our example program, which calculates a maximum
    of two numbers'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**图2.7**：计算两个数最大值的示例程序的AST'
- en: The AST for our example program is shown in [Figure 2.7](#Figure2.7). As you
    can see, our function (`max` ) has two parameters (`a` and `b` ) and a body. The
    body is marked as a compound statement in [Figure 2.7](#Figure2.7), see also [Figure 2.40](#x1-50023r38),
    where we provide a definition for a compound statement from the C++ standard.
    The compound statement consists of other statements, such as `return` and `if`
    . The `a` and `b` variables are used in the bodies of these statements. You may
    also be interested in the real AST generated by Clang for the compound statement,
    the result of which is shown in [Figure 2.8](#Figure2.8).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们示例程序的AST显示在[图2.7](#Figure2.7)。如图所示，我们的函数（`max`）有两个参数（`a`和`b`）和一个主体。主体在[图2.7](#Figure2.7)中被标记为复合语句，参见[图2.40](#x1-50023r38)，在那里我们从C++标准中提供了一个复合语句的定义。复合语句由其他语句组成，例如`return`和`if`。变量`a`和`b`在这些语句的主体中使用。您可能还对Clang为复合语句生成的真实AST感兴趣，其结果显示在[图2.8](#Figure2.8)中。
- en: '![Figure 2.8: The AST for the compound statement generated by Clang . The tree
    generated by the clang -cc1 -ast-view <...> command ](img/file3.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图2.8：Clang生成的复合语句的AST。由clang -cc1 -ast-view <...>命令生成的树](img/file3.png)'
- en: '**Figure 2.8**: The AST for the compound statement generated by Clang . The
    tree generated by the `clang -cc1 -ast-view <...>` command'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**图2.8**：Clang生成的复合语句的AST。由`clang -cc1 -ast-view <...>`命令生成的树'
- en: 'The Parser performs two activities:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 解析器执行两个活动：
- en: 'Syntax analysis: the Parser constructs the AST by analyzing the syntax of the
    program.'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 语法分析：解析器通过分析程序的语法来构建抽象语法树（AST）。
- en: 'Semantic analysis: the Parser analyzes the program semantically.'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 语义分析：解析器从语义上分析程序。
- en: One of the jobs of the parser is to produce an error message if the parsing
    fails in either of the syntax or semantic analysis phases. If no error occurs,
    then we get a parse tree (or an AST) for the syntax analysis and a semantically
    verified parse tree in the case of semantic analysis. We can get a sense of this
    by considering what types of errors are detected by syntax analysis and which
    ones are detected by semantic analysis.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 解析器的一项工作是，如果在语法或语义分析阶段解析失败，则生成错误消息。如果没有发生错误，那么我们得到语法分析的解析树（或AST），在语义分析的情况下，我们得到语义验证的解析树。我们可以通过考虑语法分析检测到的错误类型以及语义分析检测到的错误类型来获得这种感觉。
- en: 'Syntax analysis assumes that the program should be correct in terms of the
    grammar specified for the language. For example, the following program is invalid
    in terms of syntax because a semicolon is missing from the last return statement:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 语法分析假设程序在语言的指定语法方面应该是正确的。例如，以下程序在语法上无效，因为最后一个返回语句缺少分号：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Figure 2.9**: Listing of program code with a syntax error'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**图2.9**：具有语法错误的程序代码列表'
- en: 'Clang produces the following output for the program:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Clang为该程序生成了以下输出：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Figure 2.10**: Compiler output for a program with a syntax error'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**图2.10**：具有语法错误的程序的编译器输出'
- en: 'On the other hand, a program can be syntactically correct but make no sense.
    The Parser should detect a semantic error in such cases. For instance, the following
    program has a semantic error related to the wrongly used type for the return value:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，一个程序可能在语法上是正确的，但没有任何意义。在这种情况下，解析器应该检测到语义错误。例如，以下程序有关返回值类型使用错误的语义错误：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Figure 2.11**: Listing of program code with a semantic error'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**图2.11**：包含语义错误的程序代码列表'
- en: 'Clang generates the following output for the program:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Clang为该程序生成了以下输出：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Figure 2.12**: Compiler output for a program with a semantic error'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**图2.12**：具有语义错误的程序的编译器输出'
- en: AST is mainly constructed as a result of syntax analysis, but for certain languages,
    such as C++, semantic analysis is also crucial for constructing the AST, particularly
    for C++ template instantiation.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: AST主要是语法分析的结果，但对于某些语言，如C++，语义分析对于构建AST也是至关重要的，尤其是对于C++模板实例化。
- en: During syntax analysis, the compiler verifies that the template declaration
    adheres to the language’s grammar and syntax rules, including the proper use of
    keywords such as ”template” and ”typename,” as well as the formation of the template
    parameters and body.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在语法分析期间，编译器验证模板声明是否遵循语言的语法和语法规则，包括正确使用“template”和“typename”等关键字，以及模板参数和主体的形成。
- en: Semantic analysis, on the other hand, involves the compiler performing template
    instantiation, which generates the AST for specific instances of the template.
    It’s worth noting that the semantic analysis of templates can be quite complex,
    as the compiler must perform tasks such as type checking, name resolution, and
    more for each template instantiation. Additionally, the instantiation process
    can be recursive and lead to a significant amount of code duplication, known as
    code bloat. To combat this, C++ compilers employ techniques such as template instantiation
    caching to minimize the amount of redundant code generated.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，语义分析涉及编译器执行模板实例化，这为模板的特定实例生成抽象语法树（AST）。值得注意的是，模板的语义分析可能相当复杂，因为编译器必须为每个模板实例化执行类型检查、名称解析等任务。此外，实例化过程可能是递归的，并可能导致大量代码重复，称为代码膨胀。为了解决这个问题，C++编译器采用模板实例化缓存等技术来最小化生成的冗余代码量。
- en: The codegen
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代码生成
- en: The codegen (it’s worth mentioning that we also have another Codegen component
    as a part of Backend that generate the target code) or code generator, which is
    the final component of the compiler’s frontend, has the primary goal of generating
    the **Intermediate Representation (IR)**. For this purpose, the compiler traverses
    the AST generated by the parser and converts it into other source code that is
    called the Intermediate Representation or IR. The IR is a language-independent
    representation, allowing the same middle-end component to be used for different
    frontends (FORTRAN vs C++). Another reason for using an Intermediate Representation
    (IR) is that if we have a new architecture available tomorrow, we can generate
    the target code specific to that architecture. Since the source language remains
    unchanged, all the steps leading up to the IR will remain the same. The IR provides
    this flexibility.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 代码生成（值得一提的是，我们还有一个作为后端一部分的另一个Codegen组件，它生成目标代码）或代码生成器，是编译器前端的最后一个组件，其主要目标是生成**中间表示（IR）**。为此，编译器遍历由解析器生成的AST，并将其转换为称为中间表示或IR的其他源代码。IR是一种与语言无关的表示，允许相同的中间端组件用于不同的前端（FORTRAN与C++）。使用中间表示（IR）的另一个原因是，如果我们明天有新的架构可用，我们可以生成特定于该架构的目标代码。由于源语言保持不变，所有导致IR的步骤都将保持不变。IR提供了这种灵活性。
- en: The use of IRs in compilers is a concept that has been around for several decades.
    The idea of using an intermediate representation to represent the source code
    of a program during compilation has evolved over time, and the exact date when
    IR was first introduced in compilers is not clear.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器中使用IR的概念已经存在了几十年。在编译过程中使用中间表示来表示程序源代码的想法随着时间的推移而发展，IR首次在编译器中引入的确切日期尚不清楚。
- en: However, it is known that the first compilers in the 1950s and 1960s did not
    use IRs and instead translated source code directly into machine code. By the
    1960s and 1970s, researchers had begun experimenting with using IRs in compilers
    to improve the efficiency and flexibility of the compilation process.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，众所周知，20世纪50年代和60年代的第一批编译器没有使用IR，而是直接将源代码翻译成机器代码。到20世纪60年代和70年代，研究人员开始尝试在编译器中使用IR来提高编译过程的效率和灵活性。
- en: One of the first widely used IRs was three-address code, which was used in the
    mid-1960s in IBM/360’s FORTRAN compiler. Other early examples of IRs include the
    **register transfer language (RTL)** and the **static single** **assignment (SSA)**
    form, which were introduced in the 1970s and 1980s respectively.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最早广泛使用的IR之一是三地址代码，它在20世纪60年代中期用于IBM/360的FORTRAN编译器。其他早期的IR示例包括20世纪70年代和80年代分别引入的**寄存器传输语言（RTL）**和**静态单赋值（SSA）**形式。
- en: Today, the use of IRs in compilers is a standard practice, and many compilers
    use multiple IRs throughout the compilation process. This allows for more powerful
    optimization and code generation techniques to be applied.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，编译器中使用IR已成为标准做法，许多编译器在整个编译过程中使用多个IR。这允许应用更强大的优化和代码生成技术。
- en: 2.3 Clang driver overview
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 Clang 驱动概述
- en: When discussing compilers, we typically refer to a command-line utility that
    initiates and manages the compilation process. For example, to use the GNU Compiler
    Collection, one must call `gcc` to start the compilation process. Similarly, to
    compile a C++ program using Clang, one must call `clang` as the compiler. The
    program that controls the compilation process is known as the driver. The driver
    coordinates different stages of compilation and connects them together. In the
    book, we will be focusing on LLVM and using Clang as the driver for the compilation
    process.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论编译器时，我们通常指的是一个命令行工具，用于启动和管理编译过程。例如，要使用GNU编译器集合，必须调用`gcc`来启动编译过程。同样，要使用Clang编译C++程序，必须将`clang`作为编译器调用。控制编译过程的程序被称为驱动程序。驱动程序协调编译的不同阶段并将它们连接在一起。在本书中，我们将重点关注LLVM，并使用Clang作为编译过程的驱动程序。
- en: It may be confusing for readers that the same word, ”Clang,” is used to refer
    to both the compiler frontend and the compilation driver. In contrast, with other
    compilers, where the driver and C++ compiler can be separate executables, ”Clang”
    is a single executable that functions as both the driver and the compiler frontend.
    To use Clang as the compiler frontend only, the special option `-cc1` must be
    passed to it.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于读者来说，可能会感到困惑的是，同一个词“Clang”被用来指代编译器前端和编译驱动程序。相比之下，在其他编译器中，驱动程序和C++编译器可以是独立的可执行文件，而“Clang”是一个单一的可执行文件，它既作为驱动程序也作为编译器前端。要仅将Clang用作编译器前端，必须传递特殊选项`-cc1`。
- en: 2.3.1 Example program
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.1 示例程序
- en: 'We will use the simple “Hello world!” example program for our experiments with
    the Clang driver. The main source file is called `hello.cpp` . The file implements
    a trivial C++ program that prints “Hello world!” to the standard output:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用简单的“Hello world!”示例程序进行Clang驱动程序的实验。主要源文件名为`hello.cpp`。该文件实现了一个简单的C++程序，将“Hello
    world!”打印到标准输出。
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Figure 2.13**: Example program: hello.cpp'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**图2.13**：示例程序：hello.cpp'
- en: 'You can compile the source with the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令编译源代码：
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Figure 2.14**: Compilation for `hello.cpp`'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**图2.14**：`hello.cpp`的编译'
- en: As you can see, we used the `clang` executable as the compiler and specified
    the `-lstdc++` library option because we used the `<``iostream``>` header from
    the standard C++ library. We also specified the output for the executable (`/tmp/hello`
    ) with the `-o` option.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们使用了`clang`可执行文件作为编译器，并指定了`-lstdc++`库选项，因为我们使用了标准C++库中的`<iostream>`头文件。我们还使用`-o`选项指定了可执行文件的输出（`/tmp/hello`）。
- en: 2.3.2 Compilation phases
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.2 编译阶段
- en: We used two inputs for our example program. The first one is our source code
    and the second one is a shared library for the standard C++ library. The Clang
    driver should combine the inputs together, pass them via different phases of the
    compilation process, and finally, provide the executable file on the target platform.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为示例程序使用了两个输入。第一个是我们的源代码，第二个是标准C++库的共享库。Clang驱动程序应将这些输入组合在一起，通过编译过程的各个阶段传递它们，并最终在目标平台上提供可执行文件。
- en: 'Clang uses the same typical compiler workflow as shown in [Figure 2.2](#Figure2.2).
    You can ask Clang to show the phases using the `-ccc-print-phases` additional
    argument:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Clang使用与[图2.2](#Figure2.2)中所示相同的典型编译器工作流程。您可以使用`-ccc-print-phases`附加参数要求Clang显示阶段。
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Figure 2.15**: Command to print compilation phases for hello.cpp'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**图2.15**：打印hello.cpp编译阶段的命令'
- en: 'The output for the command is the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的输出如下：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**Figure 2.16**: Compilation phases for hello.cpp'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**图2.16**：hello.cpp的编译阶段'
- en: We can visualize the output as shown in [Figure 2.17](#Figure2.17).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将输出可视化，如[图2.17](#Figure2.17)所示。
- en: '![Figure 2.17: Clang driver phases](img/Figure2.17_B19722.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图2.17：Clang驱动程序阶段](img/Figure2.17_B19722.png)'
- en: '**Figure 2.17**: Clang driver phases'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**图2.17**：Clang驱动程序阶段'
- en: As we can see in [Figure 2.17](#Figure2.17), the driver receives an input file,
    `hello.cpp` , which is a C++ file. The file is processed by the preprocessor and
    we obtain the preprocessor output (marked as `c++-cpp-output` ). The result is
    compiled into IR form by the compiler, and then the backend converts it into assembly
    form. This form is later transformed into an object file. The final object file
    is combined with another object (`libstdc++` ) to produce the final binary (`image`
    ).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图2.17](#Figure2.17)所示，驱动程序接收一个输入文件`hello.cpp`，这是一个C++文件。该文件由预处理器处理，我们获得预处理器输出（标记为`c++-cpp-output`）。结果由编译器编译成IR形式，然后后端将其转换为汇编形式。这种形式随后被转换成目标文件。最终的目标文件与另一个目标文件（`libstdc++`）结合，生成最终的二进制文件（`image`）。
- en: 2.3.3 Tool execution
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.3 工具执行
- en: The phases are combined into several tool executions. The Clang driver invokes
    different programs to produce the final executable. Specifically, for our example,
    it calls the `clang` compiler and the `ld` linker. Both programs require additional
    arguments that are set up by the driver.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 阶段被组合为几个工具执行。Clang驱动程序调用不同的程序以生成最终的可执行文件。具体来说，对于我们的示例，它调用`clang`编译器和`ld`链接器。这两个程序都需要由驱动程序设置的额外参数。
- en: 'For instance, our example program (`hello.cpp` ) includes the following header:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们的示例程序（`hello.cpp`）包含以下头文件：
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**Figure 2.18**: iostream header at hello.cpp'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**图2.18**：iostream头文件在hello.cpp中'
- en: We did not specify any additional arguments (such as search paths, for example,
    `-I` ) when we invoked the compilation. However, different architectures and operating
    systems might have different paths for locating headers.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用编译时，我们没有指定任何额外的参数（例如，搜索路径，例如，`-I`）。然而，不同的架构和操作系统可能具有不同的路径来定位头文件。
- en: 'On Fedora 39, the header is located in the `/usr/include/c++/13/iostream` folder.
    We can examine a detailed description of the process executed by the driver and
    the arguments used with the `-###` option:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在Fedora 39上，头文件位于`/usr/include/c++/13/iostream`文件夹中。我们可以使用`-###`选项检查驱动程序执行的过程和使用的参数的详细描述：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**Figure 2.19**: Command to print tools execution for hello.cpp'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**图2.19**：打印hello.cpp工具执行的命令'
- en: The output for this command is quite extensive, and certain parts have been
    omitted here. Please refer to [Figure 2.20](#x1-44025r19).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令的输出相当广泛，此处省略了某些部分。请参阅图2.20。
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**Figure 2.20**: Clang driver tool execution. The host system is Fedora 39\.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**图2.20**：Clang驱动程序工具执行。主机系统是Fedora 39。'
- en: 'As we can see in [Figure 2.20](#x1-44025r19), the driver initiates two processes:
    `clang-18` with the `-cc1` flag (see *Lines 2-12*) and the linker `ld` (see *Lines
    13-16*). The Clang compiler implicitly receives several search paths, as seen
    in *Lines 5, 7, 9, and 11*. These paths are necessary for the inclusion of the
    `iostream` header in the test program.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图2.20](#x1-44025r19)所示，驱动程序启动了两个过程：带有`-cc1`标志的`clang-18`（见*行2-12*）和链接器`ld`（见*行13-16*）。Clang编译器隐式接收几个搜索路径，如*行5、7、9和11*所示。这些路径对于在测试程序中包含`iostream`头文件是必要的。
- en: The output of the first executable (`/tmp/hello-XXX.o` ) serves as input for
    the second one (see *Lines 12 and 15*). The arguments `-lstdc++` and `-o /tmp/hello`
    are set for the linker, while the first argument (hello.cpp) is provided for the
    compiler invocation (first executable).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个可执行文件（`/tmp/hello-XXX.o`）的输出作为第二个可执行文件的输入（见*行12和15*）。对于链接器，设置了`-lstdc++`和`-o
    /tmp/hello`参数，而第一个参数（hello.cpp）为编译器调用（第一个可执行文件）提供。
- en: '![Figure 2.21: Clang driver tool execution. The Clang driver runs two executables:
    the clang executable with the -cc1 flag and the linker - ld executable ](img/Figure2.21_B19722.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图2.21：Clang驱动程序工具执行。Clang驱动程序运行两个可执行文件：带有-cc1标志的clang可执行文件和链接器-ld可执行文件](img/Figure2.21_B19722.png)'
- en: '**Figure 2.21**: Clang driver tool execution. The Clang driver runs two executables:
    the clang executable with the -cc1 flag and the linker - ld executable'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**图2.21**：Clang驱动程序工具执行。Clang驱动程序运行两个可执行文件：带有-cc1标志的clang可执行文件和链接器-ld可执行文件'
- en: 'The process can be visualized as shown in [Figure 2.21](#Figure2.21), where
    we can see that two executables are executed as part of the compilation process.
    The first one is `clang-18` with a special flag (`-cc1` ). The second one is the
    linker: `ld` .'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程可以如图2.21所示进行可视化，其中我们可以看到两个可执行文件作为编译过程的一部分被执行。第一个是带有特殊标志（`-cc1`）的`clang-18`。第二个是链接器：`ld`。
- en: 2.3.4 Combining it all together
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.4 将所有内容组合在一起
- en: 'We can summarize the knowledge we have acquired so far using [Figure 2.22](#Figure2.22).
    The figure illustrates two different processes started by the Clang driver. The
    first one is `clang -cc1` (compiler), and the second one is `ld` (linker). The
    compiler process is the same executable as the Clang driver (`clang` ), but it
    is run with a special argument: `-cc1` . The compiler produces an object file
    that is then processed by the linker (`ld` ) to generate the final binary.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用图2.22总结到目前为止所获得的知识。该图说明了Clang驱动程序启动的两个不同过程。第一个是`clang -cc1`（编译器），第二个是`ld`（链接器）。编译器过程与Clang驱动程序（`clang`）相同的可执行文件，但它使用特殊参数：`-cc1`。编译器生成一个对象文件，然后由链接器（`ld`）处理以生成最终的二进制文件。
- en: '![Figure 2.22: Clang driver: The driver got the input file hello.cpp, which
    is a C++ file. It starts two processes: clang and ld. The first one does real
    compilation and starts the integrated assembler. The last one is the linker (ld)
    that produces the final binary (image) from the result received from the compiler
    and the external library (libstdc++)](img/Figure2.22_B19722.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图2.22：Clang驱动器：驱动器获取了输入文件hello.cpp，这是一个C++文件。它启动了两个进程：clang和ld。第一个进程执行真正的编译并启动集成汇编器。最后一个进程是链接器（ld），它从编译器接收到的结果和外部库（libstdc++）生成最终的二进制（镜像）](img/Figure2.22_B19722.png)'
- en: '**Figure 2.22**: Clang driver: The driver got the input file hello.cpp, which
    is a C++ file. It starts two processes: clang and ld. The first one does real
    compilation and starts the integrated assembler. The last one is the linker (ld)
    that produces the final binary (image) from the result received from the compiler
    and the external library (libstdc++)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**图2.22**：Clang驱动器：驱动器获取了输入文件hello.cpp，这是一个C++文件。它启动了两个进程：clang和ld。第一个进程执行真正的编译并启动集成汇编器。最后一个进程是链接器（ld），它从编译器接收到的结果和外部库（libstdc++）生成最终的二进制（镜像）'
- en: In [Figure 2.22](#Figure2.22), we can observe similar components of the compiler
    mentioned earlier (see [*Section** 2.2*](#x1-350002)*, Getting started with compilers*).
    However, the main difference is that the **preprocessor** (part of the lexer)
    is shown separately, while the frontend and middle-end are combined into the **compiler**.
    Additionally, the figure depicts an **assembler** that is executed by the driver
    to generate the object code. It is important to note that the assembler can be
    integrated, as shown in [Figure 2.22](#Figure2.22), or it may require a separate
    process to be executed.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图2.22](#Figure2.22)中，我们可以观察到之前提到的编译器中的类似组件（参见[*第2.2节*](#x1-350002)*，开始使用编译器*）。然而，主要区别在于**预处理器**（词法分析器的一部分）被单独显示，而前端和中端被组合到**编译器**中。此外，该图描述了一个由驱动器执行的**汇编器**，用于生成目标代码。需要注意的是，汇编器可以是集成的，如图[图2.22](#Figure2.22)所示，或者可能需要单独的进程来执行。
- en: Important note
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Here is an example of specifying an external assembler using the `-c` (compile
    only) and `-o` (output file) options, along with the appropriate flags for your
    platform:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用`-c`（仅编译）和`-o`（输出文件）选项以及适用于您平台的适当标志指定外部汇编器的示例：
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 2.3.5 Debugging Clang
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.5 调试Clang
- en: We’re going to step through a debugging session for our compilation process,
    illustrated in [Figure 2.14](#x1-42011r14).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐步通过我们的编译过程调试会话，如图[图2.14](#x1-42011r14)所示。
- en: Important note
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: We will use the LLDB build created previously in [*Section** 1.3.3*](B19722_01.xhtml#x1-290003)*,*
    *The LLVM debugger, its build, and usage* for this and other debug sessions throughout
    the book. You can also use the LLDB that comes as part of your host system.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用之前在[*第1.3.3节*](B19722_01.xhtml#x1-290003)*，* *LLVM调试器、其构建和使用*中创建的LLDB构建，以及本书中其他调试会话进行此调试会话。您也可以使用主机系统提供的LLDB。
- en: 'Our chosen point of interest, or breakpoint, is the `clang::ParseAST` function.
    In a typical debug session, which resembles the one outlined in [Figure 1.11](B19722_01.xhtml#listing-7),
    you would feed command-line arguments following the `"- -"` symbol. The command
    should look like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择的感兴趣点，或断点，是`clang::ParseAST`函数。在一个典型的调试会话中，它类似于[图1.11](B19722_01.xhtml#listing-7)中概述的，你会在`"-
    -"`符号之后输入命令行参数。命令应该看起来像这样：
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**Figure 2.23**: Running debugger for hello.cpp file compilation'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**图2.23**：编译hello.cpp文件时的调试器运行'
- en: In this case, `<...>` represents the directory path used to clone the LLVM project.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`<...>`代表用于克隆LLVM项目的目录路径。
- en: 'Unfortunately, this approach doesn’t work with the Clang compiler:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这种方法与Clang编译器不兼容：
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**Figure 2.24**: Debugger session with failed interruption'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**图2.24**：失败的干扰调试会话'
- en: As we can see from *Line 7*, the breakpoint was set but the process finished
    successfully (*Line 11*) without any interruptions. In other words, our breakpoint
    didn’t trigger in this instance.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从*第7行*可以看到，断点已设置，但进程成功完成（*第11行*）而没有任何中断。换句话说，在这个实例中，我们的断点没有触发。
- en: Understanding the internals of the Clang driver can help us identify the problem
    at hand. As mentioned earlier, the `clang` executable acts as a driver in this
    context, running two separate processes (refer to [Figure 2.21](#Figure2.21)).
    Therefore, if we wish to debug the compiler, we need to run it using the `-cc1`
    option.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 Clang 驱动程序的内部结构可以帮助我们识别当前的问题。如前所述，`clang` 可执行文件在此上下文中充当驱动程序，运行两个独立的进程（参见图
    2.21）。因此，如果我们想调试编译器，我们需要使用 `-cc1` 选项来运行它。
- en: Important note
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'It’s worth mentioning a certain optimization implemented in Clang in 2019 [[22](B19722_Bib.xhtml#Xllvm_D69825)].
    When using the `-c` option, the Clang driver doesn’t spawn a new process for the
    compiler:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，Clang 在 2019 年实现了一种特定的优化 [[22](B19722_Bib.xhtml#Xllvm_D69825)]。当使用 `-c`
    选项时，Clang 驱动程序不会为编译器启动一个新的进程：
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As shown above, the Clang driver does not spawn a new process and instead calls
    the ”cc1” tool within the same process. This feature not only improves the compiler’s
    performance but can also be leveraged for Clang debugging.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如上图所示，Clang 驱动程序不会启动一个新的进程，而是在同一个进程中调用“cc1”工具。这个特性不仅提高了编译器的性能，还可以用于 Clang 调试。
- en: 'Upon using the `-cc1` option and excluding the `-lstdc++` option (which is
    specific to the second process, the ld linker), the debugger will generate the
    following output:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `-cc1` 选项并排除 `-lstdc++` 选项（这是针对第二个进程，即 ld 链接器的特定选项）后，调试器将生成以下输出：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '**Figure 2.25**: Debugger session with missing search paths'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 2.25**：缺少搜索路径的调试会话'
- en: Thus, we can see that we were able to successfully set the breakpoint, but the
    process ended with an error (see *Lines 20-24*). This error arose because we omitted
    certain search paths, which are typically appended implicitly by the Clang driver,
    necessary to find all the includes required for successful compilation.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以看到我们成功地设置了断点，但进程以错误结束（见 *行 20-24*）。这个错误是由于我们省略了某些搜索路径，这些路径通常是 Clang 驱动程序隐式附加的，对于成功编译所需的所有包含文件是必要的。
- en: 'We can successfully execute the process if we explicitly include all necessary
    arguments in the compiler invocation. Here’s how to do that:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在编译器调用中明确包含所有必要的参数，我们可以成功执行该过程。以下是这样做的方法：
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**Figure 2.26**: Running the debugger with specified search paths. Host system
    is Fedora 39'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 2.26**：使用指定搜索路径运行调试器。主机系统是 Fedora 39'
- en: 'Then we can set the breakpoint for `clang``::``ParseAST` and run the debugger.
    The execution will complete without errors, as shown below:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以设置 `clang::ParseAST` 的断点并运行调试器。执行将无错误完成，如下所示：
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**Figure 2.27**: Successful debugger session for compiler'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 2.27**：编译器的成功调试会话'
- en: In conclusion, we have successfully demonstrated the debugging of a Clang compiler
    invocation. The techniques presented can be effectively employed for exploring
    the internals of a compiler and addressing compiler-related bugs.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们已经成功地演示了 Clang 编译器调用的调试。所介绍的技术可以有效地用于探索编译器的内部结构和解决与编译器相关的错误。
- en: 2.4 Clang frontend overview
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4 Clang 前端概述
- en: 'It’s evident that the Clang compiler toolchain conforms to the pattern widely
    described in various compiler books [[1](B19722_Bib.xhtml#XAho2006Compilers), [18](B19722_Bib.xhtml#Xbook_engineering_a_compiler)].
    However, Clang’s frontend part diverges significantly from a typical compiler
    frontend. The primary reason for this distinction is the complexity of the C++
    language. Some features, such as macros, can modify the source code itself, while
    others, such as typedef, can influence the kind of token. Clang can also generate
    output in a variety of formats. For instance, the following command generates
    an aesthetically pleasing HTML view of the program shown in [*Figure 2.5*](#x1-37021r5):'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，Clang 编译器工具链符合各种编译器书籍中广泛描述的模式 [[1](B19722_Bib.xhtml#XAho2006Compilers), [18](B19722_Bib.xhtml#Xbook_engineering_a_compiler)]。然而，Clang
    的前端部分与典型的编译器前端有显著差异。这种差异的主要原因是 C++ 语言的复杂性。一些特性，如宏，可以修改源代码本身，而其他特性，如 typedef，可以影响标记的类型。Clang
    还可以生成多种格式的输出。例如，以下命令生成了[*图 2.5*](#x1-37021r5)中显示的程序的美观 HTML 视图：
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Take note that we pass the argument to emit the HTML form of the source program
    to the Clang frontend, specified with the `-cc1` option. Alternatively, you can
    pass an option to the frontend via the `-Xclang` option, which requires an additional
    argument representing the option itself, for example:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们将输出源程序HTML形式的参数传递给Clang前端，使用`-cc1`选项指定。或者，您也可以通过`-Xclang`选项将选项传递给前端，这需要一个额外的参数来表示选项本身，例如：
- en: '[PRE20]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You may notice that, in the preceding command, we utilized the `-fsyntax-only`
    option, instructing Clang to only execute the preprocessor, parser, and semantic
    analysis stages.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，在前面的命令中，我们使用了`-fsyntax-only`选项，指示Clang只执行预处理器、解析器和语义分析阶段。
- en: Accordingly, we can instruct the Clang frontend to perform different actions
    and produce varying types of output based on the provided compilation options.
    The base class for these actions is termed `FrontendAction` .
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以指示Clang前端执行不同的操作，并根据提供的编译选项生成不同类型的输出。这些操作的基类被称为`FrontendAction`。
- en: 2.4.1 Frontend action
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.1 前端操作
- en: 'The Clang frontend is capable of executing only one frontend action at a time.
    A frontend action is a specific task or process that the frontend performs based
    on the provided compiler option. The following is a list of some possible frontend
    actions (the table only includes a subset of the available frontend actions):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Clang前端一次只能执行一个前端操作。前端操作是基于提供的编译器选项，前端执行的具体任务或过程。以下是一些可能的前端操作列表（表格仅包含可用前端操作的一个子集）：
- en: '|'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| FrontendAction | Compiler option | Description |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| FrontendAction | 编译器选项 | 描述 |'
- en: '|'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| EmitObjAction | `-emit-obj` (default) | Compile to an object file |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| EmitObjAction | `-emit-obj`（默认）| 编译为对象文件 |'
- en: '|'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| EmitBCAction | `-emit-llvm-bc` | Compile to LLVM bytecode |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| EmitBCAction | `-emit-llvm-bc` | 编译为LLVM字节码 |'
- en: '|'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| EmitLLVMAction | `-emit-llvm` | Compile to LLVM readable form |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| EmitLLVMAction | `-emit-llvm` | 编译为LLVM可读形式 |'
- en: '|'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| ASTPrintAction | `-ast-print` | Build ASTs and then pretty-print them. |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| ASTPrintAction | `-ast-print` | 构建抽象语法树（AST）并格式化输出。 |'
- en: '|'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| HTMLPrintAction | `-emit-html` | Prints the program source in HTML form |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| HTMLPrintAction | `-emit-html` | 以HTML形式打印程序源代码 |'
- en: '|'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| DumpTokensAction | `-dump-tokens` | Prints preprocessor tokens |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| DumpTokensAction | `-dump-tokens` | 打印预处理器标记 |'
- en: '|'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|  |  |  |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  |'
- en: '**Table 2.1:** Frontend actions'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**表2.1**: 前端操作'
- en: '![Figure 2.28: Clang frontend components ](img/Figure2.28_B19722.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图2.28: Clang前端组件](img/Figure2.28_B19722.png)'
- en: '**Figure 2.28**: Clang frontend components'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**图2.28**: Clang前端组件'
- en: The diagram shown in [Figure 2.28](#Figure2.28) illustrates the basic frontend
    architecture, which is similar to the architecture shown in [Figure 2.4](#Figure2.4).
    However, there are notable differences specific to Clang.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.28所示为基本前端架构，该架构与图2.4所示的架构类似。然而，Clang有一些特定的显著差异。
- en: One significant change is the naming of the lexer. In Clang, the lexer is referred
    to as the preprocessor. This naming convention reflects the fact that the lexer
    implementation is encapsulated within the `Preprocessor` class. This alteration
    was inspired by the unique aspects of the C/C++ language, which includes special
    types of tokens (macros) that require specialized preprocessing.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 一个显著的变化是词法分析器的命名。在Clang中，词法分析器被称为预处理器。这种命名约定反映了词法分析器实现被封装在`Preprocessor`类中的事实。这种变更受到了C/C++语言独特方面的启发，包括需要特殊预处理的特殊类型的标记（宏）。
- en: Another noteworthy deviation is found in the parser component. While conventional
    compilers typically perform both syntax and semantic analysis within the parser,
    Clang distributes these tasks across different components. The `Parser` component
    focuses solely on syntax analysis, while the `Sema` component handles semantic
    analysis.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得注意的差异出现在解析器组件中。虽然传统的编译器通常在解析器中同时执行语法和语义分析，但Clang将这些任务分配到不同的组件中。`Parser`组件专注于语法分析，而`Sema`组件处理语义分析。
- en: Furthermore, Clang offers the ability to produce output in different forms or
    formats. For example, the `CodeGenAction` class serves as the base class for various
    code generation actions, such as `EmitObjAction` or `EmitLLVMAction`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Clang 还提供以不同形式或格式生成输出的能力。例如，`CodeGenAction` 类是各种代码生成操作的基类，如 `EmitObjAction`
    或 `EmitLLVMAction`。
- en: 'We will use the code for the `max` function from [Figure 2.5](#x1-37021r5)
    for our future exploration of the Clang frontend’s internals:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 [图 2.5](#x1-37021r5) 中的 `max` 函数代码进行我们未来对 Clang 前端内部结构的探索：
- en: '[PRE21]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**Figure 2.29**: Source code for max function: max.cpp'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 2.29**：`max` 函数的源代码：max.cpp'
- en: By utilizing the `-cc1` option, we can directly invoke the Clang frontend, bypassing
    the driver. This approach allows us to examine and analyze the inner workings
    of the Clang frontend in greater detail.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `-cc1` 选项，我们可以直接调用 Clang 前端，绕过驱动程序。这种方法允许我们更详细地检查和分析 Clang 前端的内部工作原理。
- en: 2.4.2 Preprocessor
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.2 预处理器
- en: 'The first part is the Lexer , which is called the preprocessor in Clang. Its
    primary goal is to convert the input program into a stream of tokens. You can
    print the token stream using the `-dump-tokens` options as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分是 Lexer，在 Clang 中被称为预处理器。其主要目标是把输入程序转换成令牌流。您可以使用以下 `-dump-tokens` 选项打印令牌流：
- en: '[PRE22]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output of the command is as shown:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的输出如下所示：
- en: '[PRE23]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '**Figure 2.30**: Clang dump token output'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 2.30**：Clang 输出令牌'
- en: As we can see, there are different types of tokens, such as language keywords
    (e.g., `int`, `return`), identifiers (e.g., `max`, `a`, `b`, etc.), and special
    symbols (e.g., semicolon, comma, etc.). The tokens for our small program are called
    **normal** **tokens**, which are returned by the lexer.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，存在不同类型的令牌，例如语言关键字（例如 `int`、`return`）、标识符（例如 `max`、`a`、`b` 等）和特殊符号（例如分号、逗号等）。我们小程序的令牌被称为
    **普通** **令牌**，由令牌化器返回。
- en: In addition to normal tokens, Clang has an additional type of token called **annotation
    tokens**. The primary difference is that these tokens also store additional semantic
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 除了普通令牌外，Clang 还有一种称为 **注解令牌** 的额外令牌类型。主要区别是这些令牌还存储了额外的语义
- en: information. For instance, a sequence of normal tokens can be replaced by the
    parser with a single annotation token that contains information about the type
    or C++ scope. The primary reason for using such tokens is performance, as it allows
    for the prevention of reparsing when the parser needs to backtrack.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 信息。例如，一系列普通令牌可以被解析器替换为包含类型或 C++ 范围信息的单个注解令牌。使用此类令牌的主要原因是为了性能，因为它允许在解析器需要回溯时防止重新解析。
- en: 'Since annotation tokens are used in the internal implementation of the parser,
    it would be good to consider an example of their usage with LLDB. Suppose we have
    the following C++ code:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 由于注解令牌用于解析器的内部实现，因此考虑一个使用 LLDB 的示例可能会有所帮助。假设我们有以下 C++ 代码：
- en: '[PRE25]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**Figure 2.31**: Source code that uses annotation tokens, annotation.cpp'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 2.31**：使用注解标记的源代码：annotation.cpp'
- en: 'The last line of the code declares the variable `a` with the following type:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的最后一行声明了变量 `a`，其类型如下：
- en: '`clangbook``::``A``<``int``>`. The type is represented as an annotation token,
    as shown in the following LLDB session:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`clangbook``::``A``<``int``>`. 该类型表示为一个注解标记，如下面的 LLDB 会话所示：'
- en: '[PRE26]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '**Figure 2.32**: LLDB session for annotation.cpp'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 2.32**：annotation.cpp 的 LLDB 会话'
- en: 'As we can see, Clang consumes an annotation token from *Line 4* of the program
    shown in [Figure 2.31](#x1-49014r29). The token is located between columns 1 and
    7\. See [Figure 2.32](#x1-49032r30). This corresponds to the following text used
    as the token: `clangbook``::``A``<``int``>`. The token consists of other tokens,
    such as ’clangbook’, ’::’, and so on. Combining all the tokens into one will significantly
    simplify the parsing and boost the overall parsing performance.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，Clang 从 [图 2.31](#x1-49014r29) 中显示的程序的第 4 行消耗了一个注解标记。该标记位于第 1 列和第 7 列之间。参见
    [图 2.32](#x1-49032r30)。这对应于以下用作标记的文本：`clangbook``::``A``<``int``>`. 该标记由其他标记组成，例如
    'clangbook'、'::' 等。将所有标记组合在一起将显著简化解析并提高整体解析性能。
- en: '![Figure 2.33: Preprocessor (clang lexer) class internals ](img/Figure2.33_B19722.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.33：预处理器（Clang 令牌化器）类内部结构](img/Figure2.33_B19722.png)'
- en: '**Figure 2.33**: Preprocessor (clang lexer) class internals'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 2.33**：预处理器（Clang 令牌化器）类内部结构'
- en: 'C/C++ language has some specifics that influence the internal implementation
    of the `Preprocessor` class. The first one is about macros. The `Preprocessor`
    class has two different helper classes to retrieve tokens:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++语言有一些特定的方面影响了`Preprocessor`类的内部实现。第一个是关于宏的。`Preprocessor`类有两个不同的辅助类来检索令牌：
- en: The `Lexer` class is used to convert a text buffer into a stream of tokens.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Lexer`类用于将文本缓冲区转换为令牌流。'
- en: The `TokenLexer` class is used to retrieve tokens from macro expansions.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TokenLexer`类用于从宏展开中检索令牌。'
- en: It should be noted that only one of these helpers can be active at a time.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，一次只能激活这些辅助类中的一个。
- en: Another specific aspect of C/C++ is the `#``include` directive (which is also
    applicable to the import directive). In this case, we need to maintain a stack
    of includes, where each include can have its own `TokenLexer` or `Lexer`, depending
    on whether there is a macro expansion within it. As a result, the `Preprocessor`
    class keeps a stack of lexers (`IncludeMacroStack` class) for each `#``include`
    directive, as shown in [Figure 2.33](#Figure2.33).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++的另一个特定方面是`#include`指令（这也适用于导入指令）。在这种情况下，我们需要维护一个包含栈，其中每个包含可以有自己的`TokenLexer`或`Lexer`，这取决于其中是否包含宏展开。因此，`Preprocessor`类为每个`#include`指令保留了一个令牌化器栈（`IncludeMacroStack`类），如图2.33所示。
- en: 2.4.3 Parser and sema
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.3 解析器和语义分析
- en: 'The parser and sema are crucial components of the Clang compiler frontend.
    They handle the syntax and semantic analysis of the source code, producing an
    AST as output. This tree can be visualized for our test program using the following
    command:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 解析器和语义分析是Clang编译器前端的关键组件。它们处理源代码的语法和语义分析，输出AST（抽象语法树）。可以使用以下命令可视化我们的测试程序：
- en: '[PRE27]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output of this command is shown here:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令的输出如下：
- en: '[PRE28]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '**Figure 2.34**: Clang AST dump output'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '**图2.34**：Clang AST转储输出'
- en: Clang utilizes a hand-written recursive-descent parser [[10](B19722_Bib.xhtml#Xllvm_clangfeatures)].
    This parser can be considered simple, and this simplicity was one key reason for
    its selection. Additionally, the complex rules specified for the C/C++ languages
    necessitated an ad hoc parser with easily adaptable rules.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: Clang使用手写的递归下降解析器 [[10](B19722_Bib.xhtml#Xllvm_clangfeatures)]。这个解析器可以被认为是简单的，这种简单性是其选择的关键原因之一。此外，为C/C++语言指定的复杂规则需要一个具有易于适应规则的临时解析器。
- en: 'Let’s explore how this works with our example. Parsing begins with a top-level
    declaration known as a `TranslationUnitDecl`, representing a single translation
    unit. The C++ standard defines a translation unit as follows [[21](B19722_Bib.xhtml#Xstandard_cpp20),
    lex.separate]:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过我们的示例来探索它是如何工作的。解析从顶级声明开始，称为`TranslationUnitDecl`，代表一个单独的翻译单元。C++标准将翻译单元定义为如下
    [[21](B19722_Bib.xhtml#Xstandard_cpp20), lex.separate]：
- en: 'A source file together with all the headers (16.5.1.2) and source files included
    (15.3) via the preprocessing directive #include, less any source lines skipped
    by any of the conditional inclusion (15.2) preprocessing directives, is called
    a translation unit.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 一个源文件，包括所有头文件（16.5.1.2）和通过预处理指令#include包含的源文件（15.3），但不包括任何由条件包含（15.2）预处理指令跳过的源代码行，被称为翻译单元。
- en: 'The parser first recognizes that the initial tokens from the source code correspond
    to a function definition, as defined in the C++ standard [[21](B19722_Bib.xhtml#Xstandard_cpp20),
    dcl.fct.def.general]:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 解析器首先识别出源代码的初始令牌对应于C++标准中定义的函数定义 [[21](B19722_Bib.xhtml#Xstandard_cpp20), dcl.fct.def.general]：
- en: '[PRE30]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '**Figure 2.35**: Function definition for C++ standard'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '**图2.35**：C++标准中的函数定义'
- en: 'The corresponding code follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的代码如下：
- en: '[PRE31]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '**Figure 2.36**: Part of the example code corresponding to function definition
    from C++ standard'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '**图2.36**：与C++标准中函数定义相对应的示例代码的一部分'
- en: 'The function definition necessitates a declarator and function body. We’ll
    start with the declarator, defined in the C++ standard as [[21](B19722_Bib.xhtml#Xstandard_cpp20),
    dcl.decl.general]:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 函数定义需要声明符和函数体。我们将从声明符开始，它在C++标准中定义为 [[21](B19722_Bib.xhtml#Xstandard_cpp20),
    dcl.decl.general]：
- en: '[PRE32]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '**Figure 2.37**: Declarator definition for C++ standard'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '**图2.37**：C++标准中的声明符定义'
- en: 'In other words, the declarator specifies a list of parameter declarations within
    brackets. The corresponding piece of code from the source is as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，声明符在括号内指定了一系列参数声明。相应的源代码片段如下：
- en: '[PRE33]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '**Figure 2.38**: Part of the example code corresponding to declarator from
    C++ standard'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '**图2.38**：与C++标准中声明符相对应的示例代码的一部分'
- en: 'The function definition, as stated above, also requires a function body. The
    C++ standard specifies the function body as follows: [[21](B19722_Bib.xhtml#Xstandard_cpp20),
    dcl.fct.def.general]'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，函数定义还需要一个函数体。C++标准如下指定了函数体：[[21](B19722_Bib.xhtml#Xstandard_cpp20), dcl.fct.def.general]
- en: '[PRE34]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '**Figure 2.39**: Function body definition for C++ standard'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '**图2.39**: C++标准的函数体定义'
- en: 'Thus the function body consists of a compound statement, which is defined as
    follows in the C++ standard [[21](B19722_Bib.xhtml#Xstandard_cpp20), stmt.block]:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，函数体由一个复合语句组成，这在C++标准中如下定义 [[21](B19722_Bib.xhtml#Xstandard_cpp20), stmt.block]：
- en: '[PRE35]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '**Figure 2.40**: Compound statement definition for C++ standard'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '**图2.40**: C++标准的复合语句定义'
- en: Therefore, it describes a sequence of statements enclosed within `{...` brackets.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，它描述了一个被`{...`括号包围的语句序列。
- en: 'Our program has two types of statements: the conditional (`if` ) statement
    and the `return` statement. These are represented in the C++ grammar definition
    as follows [[21](B19722_Bib.xhtml#Xstandard_cpp20), stmt.pre]:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们程序有两种类型的语句：条件语句（`if`）和返回语句。这些在C++语法定义中如下表示 [[21](B19722_Bib.xhtml#Xstandard_cpp20),
    stmt.pre]：
- en: '[PRE36]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '**Figure 2.41**: Statement definition for C++ standard'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '**图2.41**: C++标准的语句定义'
- en: In this context, the `selection` statement corresponds to the `if` condition
    in our program, while the `jump` statement corresponds to the `return` operator.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在此上下文中，`selection`语句对应于我们程序中的`if`条件，而`jump`语句对应于`return`运算符。
- en: 'Let’s examine the `jum` statement in more detail [[21](B19722_Bib.xhtml#Xstandard_cpp20),
    stmt.jump.general]:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地检查`jum`语句 [[21](B19722_Bib.xhtml#Xstandard_cpp20), stmt.jump.general]：
- en: '[PRE37]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '**Figure 2.42**: jump statement definition for C++ standard'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '**图2.42**: C++标准的跳转语句定义'
- en: 'where `expr-or-braced-init-list` is defined as [[21](B19722_Bib.xhtml#Xstandard_cpp20),
    dcl.init.general]:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`expr-or-braced-init-list`定义为 [[21](B19722_Bib.xhtml#Xstandard_cpp20), dcl.init.general]：
- en: '[PRE38]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '**Figure 2.43**: Return expression definition for C++ standard'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '**图2.43**: C++标准的返回表达式定义'
- en: In this context, the `return` keyword is followed by an expression and a semicolon.
    In our case, there’s an implicit cast expression that automatically converts the
    variable into the required type (`int` ).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在此上下文中，`return`关键字后面跟着一个表达式和一个分号。在我们的情况下，有一个隐式转换表达式，它自动将变量转换为所需类型（`int`）。
- en: 'It can be enlightening to examine the parser’s operation through the LLDB debugger:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 通过LLDB调试器检查解析器的操作可能会有所启发：
- en: '[PRE39]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The debugger session output is shown in [Figure 2.44](#x1-50054r42). As you
    can see, on *Line 1*, we’ve set a breakpoint for the parsing of return statements.
    Our program has two return statements. We bypass the first call (line 4) and halt
    at the second method invocation (*Line 9*). The backtrace (from the ’bt’ command
    at *Line 13*) displays the call stack for the parsing process. This stack mirrors
    the parsing blocks we described earlier, adhering to the C++ grammar detailed
    in [[21](B19722_Bib.xhtml#Xstandard_cpp20), lex.separate].
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 调试会话输出显示在[图2.44](#x1-50054r42)。如您所见，在*行1*，我们已为返回语句的解析设置了断点。我们的程序有两个返回语句。我们跳过了第一个调用（行4）并在第二个方法调用处停止（*行9*）。从*行13*的`bt`命令的回溯显示了解析过程的调用栈。这个栈反映了我们之前描述的解析块，遵循[[21](B19722_Bib.xhtml#Xstandard_cpp20),
    lex.separate]中详细描述的C++语法。
- en: '[PRE40]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '**Figure 2.44**: Second return statement parsing at max.cpp example program'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '**图2.44**: 在max.cpp示例程序中解析第二个返回语句'
- en: 'The parsing results in the generation of AST. We can also inspect the process
    of AST creation using the debugger. To do this, we need to set a corresponding
    breakpoint at the `clang``::``ReturnStmt``::``Create` method:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 解析结果生成AST。我们还可以使用调试器检查AST的创建过程。为此，我们需要在`clang::ReturnStmt::Create`方法设置相应的断点：
- en: '[PRE41]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '**Figure 2.45**: Breakpoint at clang::ReturnStmt::Create'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '**图2.45**: 在`clang::ReturnStmt::Create`处的断点'
- en: As can be seen, the AST node for the return statement is created by the Sema
    component.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如所见，返回语句的AST节点是由Sema组件创建的。
- en: 'The beginning of the return statement parser can be located in frame 4:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 返回语句解析器的开始可以定位在帧4：
- en: '[PRE42]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '**Figure 2.46**: Return statement parsing at debugger'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '**图2.46**: 在调试器中解析返回语句'
- en: As we can observe, there is a reference to the C99 standard [[25](B19722_Bib.xhtml#Xstandard_c99)]
    for the corresponding statement. The standard [[25](B19722_Bib.xhtml#Xstandard_c99)]
    provides a detailed description of the statement and the process for handling
    it.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，有一个对相应语句的C99标准的引用 [[25](B19722_Bib.xhtml#Xstandard_c99)]。该标准 [[25](B19722_Bib.xhtml#Xstandard_c99)]
    提供了关于该语句及其处理过程的详细描述。
- en: The code assumes that the current token is of type `tok``::``kw_return`, and
    in this case, the parser invokes the relevant `clang``::``Parser``::``ParseReturnStatement`
    method.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 代码假设当前标记的类型为`tok::kw_return`，在这种情况下，解析器调用相关的`clang::Parser::ParseReturnStatement`方法。
- en: While the process of AST node creation can vary across different C++ constructs,
    it generally follows the pattern displayed in [Figure 2.47](#Figure2.47).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然AST节点创建的过程在不同C++结构中可能有所不同，但它通常遵循[图2.47](#Figure2.47)中显示的模式。
- en: '![Figure 2.47: C++ parsing in Clang frontend ](img/Figure2.47_B19722.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![图2.47: Clang前端C++解析](img/Figure2.47_B19722.png)'
- en: '**Figure 2.47**: C++ parsing in Clang frontend'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '**图2.47**: Clang前端C++解析'
- en: In [Figure 2.47](#Figure2.47), the square boxes represent the corresponding
    classes, and the function calls are represented as edges with the called function
    shown as the edge label. As can be seen, the `Parser` invokes the `Preprocessor``::``Lex`
    method to retrieve a token from the lexer. It then calls a method corresponding
    to the token, for example, `Parser``:``ParseXXX` for the token `XXX`. This method
    then calls `Sema``::``ActOnXXX`, which creates the corresponding object using
    `XXX``::``Create`. The process is then repeated with a new token.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图2.47](#Figure2.47)中，方框表示相应的类，函数调用表示为带有调用函数作为边标签的边。可以看出，`Parser`调用`Preprocessor::Lex`方法从词法分析器检索一个标记。然后它调用与标记相对应的方法，例如，对于标记`XXX`，调用`Parser::ParseXXX`。然后该方法调用`Sema::ActOnXXX`，使用`XXX::Create`创建相应的对象。然后使用新的标记重复此过程。
- en: 'With this, we have now fully explored how the typical compiler frontend flow
    is implemented in Clang. We can see how the lexer component (the preprocessor)
    works in tandem with the parser (which comprises the parser and sema components)
    to produce the primary data structure for future code generation: the Abstract
    Syntax Tree (AST). The AST is not only essential for code generation but also
    for code analysis and modification. Clang provides easy access to the AST, thereby
    enabling the development of a diverse range of compiler tools.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们现在已经完全探索了Clang中典型编译器前端流程的实现。我们可以看到词法分析器组件（预处理程序）如何与解析器（包括解析器和语义组件）协同工作，以生成未来代码生成的初级数据结构：抽象语法树（AST）。AST不仅对代码生成至关重要，也对代码分析和修改至关重要。Clang提供了对AST的便捷访问，从而使得开发各种编译器工具成为可能。
- en: 2.5 Summary
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.5 概述
- en: In this chapter, we have acquired a basic understanding of compiler architecture
    and delved into the various stages of the compilation process, with a focus on
    the Clang driver. We have explored the internals of the Clang frontend, studying
    the Preprocessor that transforms a program into a set of tokens, and the Parser,
    which interacts with a component called ’Sema’. Together, these elements perform
    syntax and semantic analysis.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们获得了对编译器架构的基本理解，并深入探讨了编译过程的各个阶段，重点关注Clang驱动程序。我们探索了Clang前端内部，研究了将程序转换为一系列标记的预处理程序，以及与称为“Sema”的组件交互的解析器。这些元素共同执行语法和语义分析。
- en: The upcoming chapter will center on the Clang Abstract Syntax Tree (AST)—the
    primary data structure employed in various Clang tools. We will discuss its construction
    and the methods for traversing it.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将专注于Clang抽象语法树（AST）——Clang工具中使用的首要数据结构。我们将讨论其构建和遍历它的方法。
- en: 2.6 Further reading
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.6 进一步阅读
- en: 'Working Draft, Standard for Programming Language C++: [https://eel.is/c++draft/](https://eel.is/c++draft/)'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++编程语言标准草案：[https://eel.is/c++draft/](https://eel.is/c++draft/)
- en: '“Clang” CFE Internals Manual: [https://clang.llvm.org/docs/InternalsManual.html](https://clang.llvm.org/docs/InternalsManual.html)'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “Clang” CFE 内部手册：[https://clang.llvm.org/docs/InternalsManual.html](https://clang.llvm.org/docs/InternalsManual.html)
- en: 'Keith Cooper and Linda Torczon: Engineering A Compiler, 2012 [[18](B19722_Bib.xhtml#Xbook_engineering_a_compiler)]'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Keith Cooper和Linda Torczon：《编译器工程》，2012 [[18](B19722_Bib.xhtml#Xbook_engineering_a_compiler)] '
