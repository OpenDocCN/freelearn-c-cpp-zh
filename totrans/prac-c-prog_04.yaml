- en: Preprocessing and Compilation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several preprocessor statements that can help you determine which
    source code needs to be compiled and which needs to be excluded from being compiled.
    That is, a condition can be applied and the desired statements will be compiled
    only if the specified condition is true. These directives can be nested for more
    precise branching. There are numerous preprocessor statements, such as `#if`,
    `#ifdef`, `#ifndef`, `#else`, `#elif`, and `#endif`, that can be used to collect
    statements into blocks that we want to be compiled when the specified condition
    is true.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the advantages of using macros are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The execution speed of the program increases as the value or code of the macro
    is substituted by the name of the macro. So, the time involved in invoking or
    calling the functions by the compiler is saved.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Macros reduce the length of the program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main disadvantage of using a macro is that the size of the program increases
    prior to the compilation of the program, as all the macros are substituted by
    their code. In this chapter, we will learn how to apply conditional compilation
    using preprocessor directives.
  prefs: []
  type: TYPE_NORMAL
- en: We will also learn how to implement validation in the program by making use
    of assertions. Assertions are a sort of validation check for different critical
    statements of the program. If those assertions or expressions don't validate or
    return false, then an error is displayed and the program is aborted. The main
    difference between this and usual error handling is that assertions can be disabled
    at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: If the `#define NDEBUG` macro is defined near the `#include <assert.h>` directive,
    it will disable the assert function.
  prefs: []
  type: TYPE_NORMAL
- en: Besides the normal asserts, there are also asserts that are referred to as static
    or compile-time asserts, which are used to catch errors at the time of compilation.
    Such asserts can be used to do compile-time validations.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to this, we will learn how to use stringize and token-pasting operators
    using the example of a pizza parlor.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn how to make the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Performing conditional compilation with directives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying assertions for validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using assertions to ensure a pointer is not pointing to `NULL`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Catching errors early with compile-time assertions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying stringize and token-pasting operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start with the first recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Performing conditional compilation with directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to apply conditional compilation. We will
    define certain macros, and then, by applying the `#if`, `#ifdef`, `#ifndef`, `#else`,
    `#elif`, `#endif`, and `#undef` preprocessor directives, we will direct the compiler
    to compile the desired code. Considering the example of a bookstore, let's assume
    that a user is asked to enter the price of the book. The program will apply different
    discounts, festival offers, a discount coupon, and Kindle options on the basis
    of the `Qty` macro, which represents the quantity or number of books purchased
    by the user. The program also defines other macros that determine different offers
    that are applicable.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to perform conditional compilation with preprocessor directives:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a `Qty` macro and assign it an initial value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The user will be prompted to enter the price of a book:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The total number of books is computed using the `Qty*price` formula:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: On the basis of the `Qty` macro, the `#if`, `#elif`, `#else`, and `#endif` directives
    are used to determine the discount on the total number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the discount percentage is determined, the amount after deducting the
    discount is computed and is assigned to the `afterDisc` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The festival discount is also computed on the basis of the `FestivalOffer`
    macro. That is, the `#ifdef`, `#else`, and `#endif` directives are used to confirm
    whether the `FestivalOffer` macro is defined and, accordingly, the amount that
    the customer has to pay after deducting the festival discount is computed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `#if defined` directive is used to confirm whether the `DiscountCoupon`
    macro is defined in the program or not. And, accordingly, the user is informed
    whether they are eligible for the discount coupon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The preprocessor directives, `#ifndef` and `#endif`, are used to determine
    whether the `Kindle` macro is defined or not. If the `Kindle` macro is not yet
    defined, it is defined and its value is set. Accordingly, the user is informed
    of how many months they will be eligible for the `Kindle` version of the book:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The program for performing conditional compilation with preprocessor directives
    is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Four macros, called `Qty`, `FestivalOffer`, `DiscountCoupon`, and `Kindle`,
    are defined with the values of `10`, `2`, `5`, and `2`, respectively. The user
    is prompted to enter the price of a book. The value entered by the user is assigned
    to the variable price. The `#if`, `#elif`, `#else`, and `#endif` conditional directives are
    then used to determine the amount of discount to be applied to the books depending
    on the value of the `Qty` macro. Because, the current value of the `Qty` macro
    is `10`, the value of the discount variable will be set to `15` through the preprocessor
    directives. The value of the `discount` variable can be changed at any time simply
    by changing the value of the `Qty` macro. The total number of the books is computed
    by multiplying the values of `Qty` by the price, and the resultant value is assigned
    to the `totalAmount` variable. Because the user is given some kind of discount
    on the basis of the `Qty` value, the amount that the user has to pay after deducting
    the discount is computed and the resulting amount is assigned to the `afterDisc`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: Again, because the `FestivalOffer` macro is defined, the `#ifdef`, `#else`,
    and `#endif` preprocessor directives are used to compute the amount that the customer
    has to pay after deducting a festival discount of 2%. We can always comment out
    the `#define FestivalOffer` statement to undefine the macro; in this case, no
    festival discount will be given to the customer.
  prefs: []
  type: TYPE_NORMAL
- en: The total amount is displayed on the screen as well as the amount after deducting
    the discount. And if the festival offer is applied, the amount after deducting
    the festival offer is also displayed on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The `#if defined` directive is used to confirm whether the `DiscountCoupon`
    macro is defined or not. Because currently in the program the `DiscountCoupon`
    macro is defined and is assigned the value of `5`, a message is displayed informing
    that they are eligible for an additional discount coupon of $5 too. You can always
    comment out the `DiscountCoupon` macro if you want to avoid giving any discount
    coupons. The Kindle version of the book has to be given to the customer for at
    least a month. Because the `Kindle` macro is defined in the program and is assigned
    the value of `2`, a message is displayed on the screen informing the user that
    they are allowed to use the Kindle version of the book for 2 months. However,
    if you comment out the `Kindle` macro, the `#ifndef` and `#endif` preprocessor
    directives are used to set the value of the `Kindle` macro to `1` if the `Kindle`
    macro is not defined in the program. Therefore, if the `Kindle` macro is not defined
    in the program, a message will be displayed informing the user that they are allowed
    to use the Kindle version of the book for 1 month.
  prefs: []
  type: TYPE_NORMAL
- en: 'The program is compiled using GCC, as shown in the following screenshot. Because
    no error appears during compilation, this means that the `condcompile.c` program is
    successfully compiled into a `.exe` file: `condcompile.exe`. On executing the
    file, the user will be prompted to enter the price of the book and, according
    to the defined macros, the total amount and the discounted amount will be displayed,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/28aac8ff-2af0-4b37-a5e7-c5d4819acca5.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, keeping the value of the `Qty` macro to `10` and try commenting out the
    following two macros:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding program will show the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/834f3be7-668d-4eed-a126-08433a8f22dd.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2
  prefs: []
  type: TYPE_NORMAL
- en: You can see in the output that because the value of the `Qty` macro is still 
     `10`, the customer will continue to get a discount of 15% as shown in the preceding
    screenshot. Additionally, the festival discount is not given to the customer at
    all. Because `DiscountCoupon` macro is still defined, the customer will continue
    to get discount coupon of $5  and the Kindle version is reduced to 1 month.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we mentioned earlier, the `#undef` directive removes the current definition
    of the macro. The following code snippet uses the defined macro and then undefines
    it after using it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the `qty` macro is used and then undefined after usage. Now,
    let's move on to the next recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Applying assertions for validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to implement validation using assertion. The
    program will ask the user to enter the information of the passengers that are
    flying from one place to another. Using assertions, we can ensure that the number
    of passengers entered is a positive number. If the number of passengers entered
    is zero or a negative value, the program will abort.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to create a validation check using assertion. The recipe
    will not allow the program to run if the value of the number of passengers is
    zero or negative:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The user is prompted to enter how many passengers are flying:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'An `assert` instance is defined to ensure that the value of the number of passengers
    should not be `0` or negative. If the user enters a value of `0` or negative for
    the number of passengers, an error message will be displayed showing the line
    number, and the program will abort:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If the value for the number of passengers entered is a positive value, the
    user is asked to supply other information such as where the flight is going from,
    where the flight is going to, and the date of the journey:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The entered information of the passengers is then displayed on the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The program for implementing a validation check using assertions is shown in
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The program prompts the user to enter the information of the passengers that
    are flying from one place to another on a specific date. In order to ensure that
    the value of the number of passengers is not zero or negative, an assertion is
    used. The `assert` expression validates the value assigned to the `noOfPassengers`
    variable. It checks whether the value of the `noOfPassengers` variable is greater
    than `0` or not. If it is, the program will continue to execute the rest of the
    statements; otherwise, the filename and the line number are sent to the standard
    error and the program is aborted.
  prefs: []
  type: TYPE_NORMAL
- en: If the assert statement is validated, that is, if the value assigned to `noOfPassengers`
    is more than 0, then the user is asked to enter the other details of the passengers
    such as where the flight is going from, where the flight is going to, and the
    date of the journey. The entered information is then displayed on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The program is compiled using GCC, as shown in the following screenshot. Because
    no error appears during compilation, this means the `assertdemoprog.c` program is
    successfully compiled into a `.exe` file: `assertdemoprog.exe`. On executing the
    file, the user is prompted to enter the number of passengers flying. If the number
    of passengers entered is a positive value, the program will run perfectly, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a8ed6c5c-aec4-48ea-ad7a-2ad23728242f.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3
  prefs: []
  type: TYPE_NORMAL
- en: 'While executing the program for the second time, if the value entered is negative
    or zero for the `noOfPassengers` variable, an error will be displayed showing
    the program name and line number, and the program is aborted. The specified error
    message, `"Number of passengers should be a positive integer"`, will be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2564dea6-39f1-4278-907f-968da70c2525.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4
  prefs: []
  type: TYPE_NORMAL
- en: Voilà! We have successfully applied assertions to validate our data.
  prefs: []
  type: TYPE_NORMAL
- en: Using assertions to ensure a pointer is not pointing to NULL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's perform one more recipe on assertions. Let's apply assertions to ensure
    that a pointer is not pointing to `NULL` and is instead pointing to a memory address
    that is to be accessed. Essentially, in this recipe, we will learn to compute
    the average of a few numbers, where the numbers are stored in an array, and the
    array elements are accessed through a pointer.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to ensure that the pointer is not `NULL` and is pointing
    to a memory address by making use of assertions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define an array containing a number of integers whose average is to be computed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Set a pointer to point to the array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a function for calculating the average of the array elements. A pointer
    to an array and the count of the number of values in the array are both passed
    to this function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the function, define an `assert` expression that ensures that the pointer
    is not `NULL`. If the pointer is `NULL`, the program will display an error and
    will be aborted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If the pointer is not `NULL`, the array elements will be accessed through the
    pointer and their average will be computed and displayed on the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The program for implementing a validation that ensures the pointer is not `NULL`
    and is pointing to a memory address is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this program, the average of several integers is computed via an array. That
    is, a number of integers whose average is supposed to be computed are assigned
    to an array and an integer pointer is used to access the array elements. A function
    named `findaverage` is defined, to which the integer pointer and the count of
    the numbers are passed. In the function, an assert is used that ensures that the
    pointer is not `NULL`. If the pointer is not `NULL`, the array elements are accessed
    through the pointer and their addition is done. After the addition of the numbers,
    their average is computed. The computed average is then returned to the `main`
    function where the average is displayed on the screen. If the pointer is not pointing
    to the array and is instead pointing to `NULL`, the program will display an error
    and will be aborted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The program is compiled using GCC, as shown in the following screenshot. Because
    no error appears during compilation, this means the `assertprog.c` program is
    successfully compiled into a `.exe` file: `assertprog.exe`. Because the pointer
    is pointing to the array while executing the file, we get the average of the numerical
    values specified in the array, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eff14225-a107-4587-b190-6064448afbc4.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, comment out the following line in which the pointer is pointing to the
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ptr` pointer now is pointing to `NULL`. Hence, on running the program,
    it will display an error, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/624d22ac-a2ce-443c-b887-c8c630b8c7cf.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6
  prefs: []
  type: TYPE_NORMAL
- en: Voilà! We have successfully used assertions to ensure that our pointer is not
    pointing to `NULL`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move on to the next recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Catching errors early with compile-time assertions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will make use of assertions to detect errors at the time
    of compilation. Essentially, we will create a structure and will make a compile-time
    assertion that ensures the size of the structure is of some specific bytes. The
    program will abort if the size of the structure is not equal to the specified
    value. This constraint will help in determining the capacity of storage and also
    in the easy maintenance of records, that is, for deletes and updates.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to create a compile-time `assert` expression that ensures
    that the user-defined structure is a specified number of bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a structure with a few members:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a compile-time assert that puts a constraint on the size of the structure.
    The program will compile only when the assert is validated, that is, the size
    of the structure is exactly equal to the bytes mentioned in the `assert` expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the main body of the program, you can write any executable code. This code
    will compile and execute only when the `assert` expression is validated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The program for implementing compile-time validation to ensure that the size
    of a structure is exactly equal to a specific number of bytes is shown in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A structure is defined by the name `customers`, which consists of a few members.
    The members of the structure are of different data types. A compile-time assert
    is defined that places a constraint on the size of the `customers` structure to
    be of 28 bytes exactly. That means the program will not be compiled if the size
    of the structure is less than or greater than 28 bytes. The `main` function simply
    displays the size of different data types such as `int`, `float`, and `char`.
    The program also displays the size of the complete `customers` structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The program is compiled using GCC, as shown in the following screenshot. Because
    the size of the `customers` structure is exactly the same as that specified in
    the compile-time assert, the program compiles perfectly and the `compileassert.c`
    program is successfully compiled into a `.exe` file: `compileassert.exe`. On executing
    the file, we get the output showing the size of different data types and that
    of the `customers` structure, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7cbaed44-eb2f-4a71-b992-a6a0f7873255.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7
  prefs: []
  type: TYPE_NORMAL
- en: 'After changing the value in the `assert` function, that is, if the size of
    the structure does not match the value mentioned in the compile-time assert, we
    get a compilation error as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/52d6a4b4-f1df-48bb-abe4-2f2b92be8de6.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8
  prefs: []
  type: TYPE_NORMAL
- en: Voilà! We have successfully implemented compile-time assertions to be able to
    catch errors early in the system. Now, let's move on to the next recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Applying stringize and token-pasting operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The stringize or hash symbol (`#`) can be used in a macro definition to convert
    the macro parameter into a string constant. You can imagine that the parameter
    is enclosed in double quotes and returned. It is also known as a token-concatenation
    operator.
  prefs: []
  type: TYPE_NORMAL
- en: The token-pasting operator (`##`) combines two parameters when used in a macro
    definition. That is, the two parameters on either side of each `##` operator are
    joined into a single string. More precisely, it performs string concatenation
    on the two parameters to form a new string.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to apply stringize and token-pasting operators
    in computing. The user is asked to specify a certain pizza size and their desired
    toppings and, accordingly, the price of the pizza is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Following these steps to create a recipe that uses stringize and token-pasting
    operators:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a macro with the name `pizzaprice` using a token-pasting operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Define one more macro with the name `convertIntoStr` using a stringize operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a few variables such as `smallnormal`, `mediumnormal`, `largenormal`,
    and `smallextra` that represent the price for a pizza of different pizza sizes
    and toppings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The user is asked to enter the pizza size desired by the customer and the size
    entered is assigned to the `pizzasize` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the user is asked to specify whether the pizza is desired with normal
    cheese or extra cheese, and the choice entered by the user is assigned to the
    `topping` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, branching is done on the basis of the value of the `topping` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, the size entered in the `pizzasize` variable is compared to check
    whether the pizza size is small, medium, or large and, accordingly, the arguments
    are passed to the `pizzaprice` macro:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The `pizzaprice` macro joins the `pizzasize` and `topping` arguments together
    and expands them into a concatenated variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Here, `small` can be replaced by `medium` or `large` depending on the size chosen
    by the user. Additionally, `extra` can be replaced by `normal` if the user wants
    a pizza with normal cheese.
  prefs: []
  type: TYPE_NORMAL
- en: 'The value of the concatenated variable is displayed as the price of the specified
    pizza with the desired toppings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The program for applying stringize and token-pasting operators is shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A token-pasting operator is used to define a macro with the name `pizzaprice`.
    This macro concatenates the two `a` and `b` parameters into a single string. In
    addition to this, a stringize operator is used to define a macro with the name
    `convertIntoStr`, which converts the `str` parameter into a string. A number of
    variables are defined, such as `smallnormal`, `mediumnormal`, `largenormal`, and `smallextra`.
    These variables represent the price of a small-sized normal pizza, a medium-sized
    normal pizza, a large-sized normal pizza, and a small-sized pizza with extra cheese,
    respectively. The `normal` suffix declares that this is the price of a pizza with
    a regular amount of cheese. The `extra` suffix indicates that this variable represents
    the price of a pizza with extra cheese.
  prefs: []
  type: TYPE_NORMAL
- en: The user is prompted to enter what pizza size the customer is ordering. The
    size entered is assigned to the `pizzasize` variable. After that, the user is
    asked whether the pizza is desired with normal cheese or extra cheese and the
    choice that is entered is assigned to the `topping` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Next, branching is done on the basis of the value in the `topping` variable.
    If the topping is normal, the string in `pizzasize` is compared to check whether
    the pizza size is small, medium, or large and, accordingly, the arguments are
    passed to the `pizzaprice` macro. For example, if the user has entered small as
    the pizza size and the topping as extra, the `pizzaprice` macro is invoked with
    two parameters (small and extra). The `pizzaprice` macro, being a token-pasting
    operator, will concatenate the small and extra strings into `smallextra`, and
    hence the value of the `smallextra` variable will be displayed as the price of
    the small-sized pizza with extra cheese as a topping.
  prefs: []
  type: TYPE_NORMAL
- en: The `pizzasize` and `topping` variables are combined into a concatenated string,
    and hence will access the value in the respective variable. Finally, the `convertIntoStr`
    macro is invoked, which includes a stringize operator to display a `Thanks for
    visiting us` string at the end of the bill.
  prefs: []
  type: TYPE_NORMAL
- en: 'The program is compiled using GCC, as shown in the following screenshot. Because
    no error appears during compilation, the `preconcat.c` program is successfully
    compiled into a `.exe` file: `preconcat.exe`. On executing the file, the user
    will be asked to enter the desired pizza size and toppings and, accordingly, the
    program will display the price of the pizza, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/823df427-5c4a-4fd6-b4fa-9e6fb64c8007.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.9
  prefs: []
  type: TYPE_NORMAL
- en: Voilà! We have successfully applied the stringize and token-pasting operators
    and created custom pizza orders.
  prefs: []
  type: TYPE_NORMAL
