<html><head></head><body>
  <div id="_idContainer037">
   <h1 class="chapter-number" id="_idParaDest-113">
    <a id="_idTextAnchor112">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     11
    </span>
   </h1>
   <h1 id="_idParaDest-114">
    <a id="_idTextAnchor113">
    </a>
    <span class="koboSpan" id="kobo.2.1">
     C++ Is Backward Compatible ...Even with C
    </span>
   </h1>
   <p class="italic-heading">
    <em class="italic">
     <span class="koboSpan" id="kobo.3.1">
      And of course, with C, and B ...
     </span>
     <span class="koboSpan" id="kobo.3.2">
      and even A ...
     </span>
     <span class="koboSpan" id="kobo.3.3">
      and @
     </span>
    </em>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.4.1">
       maybe?
      </span>
     </em>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.5.1">
     In the beginning, there was the word, and the word was used in BCPL.
    </span>
    <span class="koboSpan" id="kobo.5.2">
     Pronounced like Basic Combined Programming Language, not Baltimore County Public Library.
    </span>
    <span class="koboSpan" id="kobo.5.3">
     It was the first of its kind that ruled the land of compilers with an iron syntax for several iterations.
    </span>
    <span class="koboSpan" id="kobo.5.4">
     However, the trials of time were not kind to it.
    </span>
    <span class="koboSpan" id="kobo.5.5">
     New features, doctrines, and syntax passed through and soon a new heir to the throne rose from the bits:
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.6.1">
      B
     </span>
    </em>
    <span class="koboSpan" id="kobo.7.1">
     .
    </span>
    <span class="koboSpan" id="kobo.7.2">
     Not too many considered
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.8.1">
      B
     </span>
    </em>
    <span class="koboSpan" id="kobo.9.1">
     ’s typeless nature and advantage and
    </span>
    <a id="_idIndexMarker382">
    </a>
    <span class="koboSpan" id="kobo.10.1">
     soon
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.11.1">
      B
     </span>
    </em>
    <span class="koboSpan" id="kobo.12.1">
     ceased to be, as a new contender to the throne of programming languages replaced
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.13.1">
       B
      </span>
     </em>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.14.1">
      :
     </span>
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.15.1">
       C
      </span>
     </em>
    </span>
    <span class="No-Break">
     <span class="superscript">
      <span id="footnote-029-backlink">
       <a class="_idFootnoteLink _idGenColorInherit" href="B22235_11.xhtml#footnote-029">
        <span class="koboSpan" id="kobo.16.1">
         1
        </span>
       </a>
      </span>
     </span>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.17.1">
      .
     </span>
    </span>
   </p>
   <div class="_idFootnote" epub:type="footnote" id="footnote-029">
    <p class="Footnote-text">
     <a class="_idFootnoteAnchor _idGenColorInherit" href="B22235_11.xhtml#footnote-029-backlink">
      <span class="koboSpan" id="kobo.18.1">
       1
      </span>
     </a>
     <a href="https://www.bell-labs.com/usr/dmr/www/chist.html">
      <span class="koboSpan" id="kobo.19.1">
       https://www.bell-labs.com/usr/dmr/www/chist.html
      </span>
     </a>
    </p>
   </div>
   <p>
    <span class="koboSpan" id="kobo.20.1">
     The rest is history.
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.21.1">
      C
     </span>
    </em>
    <span class="koboSpan" id="kobo.22.1">
     became the de-facto language of low-level system programming, and its syntax crept into all popular programming languages of the last and this century (hello, curly braces).
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.23.1">
      C
     </span>
    </em>
    <span class="koboSpan" id="kobo.24.1">
     is like glue, binding together various programming languages to perform sacred rites
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.25.1">
      in Computerlandia.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.26.1">
     And the programmers looked and saw that it
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.27.1">
      was good.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.28.1">
     Except for one Prometheus
    </span>
    <span class="superscript">
     <span id="footnote-028-backlink">
      <a class="_idFootnoteLink _idGenColorInherit" href="B22235_11.xhtml#footnote-028">
       <span class="koboSpan" id="kobo.29.1">
        2
       </span>
      </a>
     </span>
    </span>
    <span class="koboSpan" id="kobo.30.1">
     , a bringer of classes into
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.31.1">
      C
     </span>
    </em>
    <span class="koboSpan" id="kobo.32.1">
     , soon to give people,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.33.1">
      C with classes
     </span>
    </em>
    <span class="koboSpan" id="kobo.34.1">
     , and
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.35.1">
      Cfront
     </span>
    </em>
    <span class="koboSpan" id="kobo.36.1">
     , the first ever compiler that digested C++ code and spat out C code which sadly is long gone from our realm, but its legacy remains.
    </span>
    <span class="koboSpan" id="kobo.36.2">
     The language, the dozens of C++ standard-compliant compilers (each, in their time was standard conformant...
    </span>
    <span class="koboSpan" id="kobo.36.3">
     more or less), several hundreds of undefined behavior cases, and various iterations of the standard over the last three decades (the last working one being C++23, while the committee is laboring the latest and greatest C++26) are all here and constitute the programming language we all
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.37.1">
      love: C++.
     </span>
    </span>
   </p>
   <div class="_idFootnote" epub:type="footnote" id="footnote-028">
    <p class="Footnote-text">
     <a class="_idFootnoteAnchor _idGenColorInherit" href="B22235_11.xhtml#footnote-028-backlink">
      <span class="koboSpan" id="kobo.38.1">
       2
      </span>
     </a>
     <span class="koboSpan" id="kobo.39.1">
      Yes, Bjarne, we are talking about you
     </span>
    </p>
   </div>
   <p>
    <span class="koboSpan" id="kobo.40.1">
     This chapter will have you glued to your seat – like traffic at rush hour – with the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.41.1">
      following topics:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.42.1">
      Is C++ really backward-compatible
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.43.1">
       with C
      </span>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.44.1">
       ?
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.45.1">
      Is C++ really backward-compatible
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.46.1">
       with C++?
      </span>
     </span>
    </li>
   </ul>
   <h1 id="_idParaDest-115">
    <a id="_idTextAnchor114">
    </a>
    <span class="koboSpan" id="kobo.47.1">
     Is C really forward-compatible with C++?
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.48.1">
     This chapter will be a bit of exploration, covering most of the banally boring bothersome beliefs concerning whether C++ is really backward compatible with C.
    </span>
    <span class="koboSpan" id="kobo.48.2">
     As we were
    </span>
    <a id="_idIndexMarker383">
    </a>
    <span class="koboSpan" id="kobo.49.1">
     indoctrinated through the decades by our tutors, teachers, and trainers, C++ is mostly backward compatible with C.
    </span>
    <span class="koboSpan" id="kobo.49.2">
     This means that much of C code can be compiled and run in C++ with little modification, as they share similar syntax and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.50.1">
      standard libraries.
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.51.1">
&lt;banalities reason="these were discussed somewhere else"&gt;</span></pre>
   <p>
    <span class="koboSpan" id="kobo.52.1">
     C and C++ may be closely related, like two siblings in a dysfunctional family, but still have many differences, leading to a love-hate relationship when it comes to compatibility.
    </span>
    <span class="koboSpan" id="kobo.52.2">
     However, over time, the two languages have diverged significantly.
    </span>
    <span class="koboSpan" id="kobo.52.3">
     According to the core rules, C is more permissive with looser typing rules, especially around pointers, and allows constructs like implicit pointer conversions, which C++ strictly forbids.
    </span>
    <span class="koboSpan" id="kobo.52.4">
     For instance, in C, you can assign a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.53.1">
      void*
     </span>
    </strong>
    <span class="koboSpan" id="kobo.54.1">
     to any other pointer type without a cast, while C++ will demand an explicit cast to maintain
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.55.1">
      type safety.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.56.1">
     Similarly, C++ (especially the newer iterations of the language) has stricter rules regarding enumerations, making them distinct types, whereas in C, enums are simply treated as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.57.1">
      int
     </span>
    </strong>
    <span class="koboSpan" id="kobo.58.1">
     .
    </span>
    <span class="koboSpan" id="kobo.58.2">
     This difference extends to many other areas: variable initialization, type qualifiers, and even memory allocation (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.59.1">
      *alloc()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.60.1">
     ) work differently between the two.
    </span>
    <span class="koboSpan" id="kobo.60.2">
     This is especially true of functions such as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.61.1">
      malloc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.62.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.63.1">
      calloc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.64.1">
     , and so on.
    </span>
    <span class="koboSpan" id="kobo.64.2">
     While in C they’re just your run-of-the-mill functions, as mundane as your morning cup of coffee, if they occur in any kind of C++ code, suddenly it’s like opening a portal to the seven circles of developer hell.
    </span>
    <span class="koboSpan" id="kobo.64.3">
     This is particularly true during code reviews where acolyte C++ programmers are clutching their keyboards in terror, pointing out how you should not use C functions in C++ code when you have perfectly valid
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.65.1">
      new
     </span>
    </strong>
    <span class="koboSpan" id="kobo.66.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.67.1">
      delete
     </span>
    </strong>
    <span class="koboSpan" id="kobo.68.1">
     .
    </span>
    <span class="koboSpan" id="kobo.68.2">
     They might also ask why you even need to allocate memory.
    </span>
    <span class="koboSpan" id="kobo.68.3">
     It’s 2024.
    </span>
    <span class="koboSpan" id="kobo.68.4">
     We have smart pointers.
    </span>
    <span class="koboSpan" id="kobo.68.5">
     Or at least, if you can restrain yourself, we beg you not to use C-style casting.
    </span>
    <span class="koboSpan" id="kobo.68.6">
     That’s because there are perfectly functioning cast operators introduced in the C++ standard more than a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.69.1">
      decade ago.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.70.1">
     According to what was just discussed (but not exclusively), while young C++ emphasizes stricter type rules and more predictable, safe programming practices, granddaddy C remains the pragmatic and flexible, albeit
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.71.1">
      riskier, option.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.72.1">
     To the
    </span>
    <a id="_idIndexMarker384">
    </a>
    <span class="koboSpan" id="kobo.73.1">
     horror of C++ acolytes, the two languages are often used together, especially in C++ projects that need to use libraries written in C, but ensure code compatibility between the two languages.
    </span>
    <span class="koboSpan" id="kobo.73.2">
     Oh, the nightmares of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.74.1">
      software development.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.75.1">
     To aid the preceding scenario, developers often have to use
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.76.1">
      extern "C"
     </span>
    </strong>
    <span class="koboSpan" id="kobo.77.1">
     declarations, which prevent C++’s name mangling and allow smooth function linking across libraries written in various dialects.
    </span>
    <span class="koboSpan" id="kobo.77.2">
     This is because, despite their similarities, the object files generated by C and C++ compilers are handled differently (yes, name mangling, we’re talking
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.78.1">
      about you).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.79.1">
     To top the previous flat facts, in addition, there are a plethora of C99-specific keywords, such as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.80.1">
      _Alignas
     </span>
    </strong>
    <span class="koboSpan" id="kobo.81.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.82.1">
      _Alignof
     </span>
    </strong>
    <span class="koboSpan" id="kobo.83.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.84.1">
      _Atomic
     </span>
    </strong>
    <span class="koboSpan" id="kobo.85.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.86.1">
      _Bool
     </span>
    </strong>
    <span class="koboSpan" id="kobo.87.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.88.1">
      _Complex
     </span>
    </strong>
    <span class="koboSpan" id="kobo.89.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.90.1">
      _Generic
     </span>
    </strong>
    <span class="koboSpan" id="kobo.91.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.92.1">
      _Imaginary
     </span>
    </strong>
    <span class="koboSpan" id="kobo.93.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.94.1">
      _Noreturn
     </span>
    </strong>
    <span class="koboSpan" id="kobo.95.1">
     , and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.96.1">
      _Static_assert
     </span>
    </strong>
    <span class="koboSpan" id="kobo.97.1">
     , that are not part of standard C++, though some may have C++ equivalents or be available through compiler extensions.
    </span>
    <span class="koboSpan" id="kobo.97.2">
     To make life more interesting, these were actually retired starting from C23, due to some efforts to bring C closer
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.98.1">
      to C++.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.99.1">
     And we didn’t even mention designated initializers.
    </span>
    <span class="koboSpan" id="kobo.99.2">
     Too late
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.100.1">
      for them.
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.101.1">
&lt;/banalities&gt;</span></pre>
   <p>
    <span class="koboSpan" id="kobo.102.1">
     However, C was certainly not thought up with the idea that someday, there would be a future programming language called C++.
    </span>
    <span class="koboSpan" id="kobo.102.2">
     That’s why the following C code is perfectly valid while all law-abiding C++ compilers (and pure C++ developers too) will choke on
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.103.1">
      it heavily:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.104.1">
int template(int this) {
    int class = 0, using = 1, delete;
    if (this == 0) return class;
    if (this == 1) return using;
    for (int friend = 2; friend &lt;= this; friend++) {
        delete = class + using;
        class = using;
        using = delete;
    }
    return delete;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.105.1">
     While
    </span>
    <a id="_idIndexMarker385">
    </a>
    <span class="koboSpan" id="kobo.106.1">
     looking like the nightmare out of the C pits, regardless of it, this piece of pure C code is perfectly valid, and what a surprise, it even calculates the Fibonacci numbers.
    </span>
    <span class="koboSpan" id="kobo.106.2">
     But let’s not be overly fiendish towards you, dear reader (although considering what other mythical code snippets you had to suffer through this book till you reached this chapter, I hardly doubt this piece of code may come as a shock to you ...
    </span>
    <span class="koboSpan" id="kobo.106.3">
     no worries, this is the penultimate chapter, so the suffering is almost over ...
    </span>
    <span class="koboSpan" id="kobo.106.4">
     till then, however: do you remember in
    </span>
    <a href="B22235_09.xhtml#_idTextAnchor096">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.107.1">
        Chapter 9
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.108.1">
     where we defined main to be return and return to be main?), and let us present another interesting feature of C, that was not ported over to C++.
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.109.1">
     No, we are not talking about variable length arrays, regardless of the fact that just due to the peculiar syntax of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.110.1">
      void funny_fun(int n, int array[][*])
     </span>
    </strong>
    <span class="koboSpan" id="kobo.111.1">
     , they also deserve a litany of their own (the syntax is an exemplification of how to pass in a 2D variable length array to a function in the declaration of its prototype).
    </span>
    <span class="koboSpan" id="kobo.111.2">
     Variable length arrays have been discussed
    </span>
    <span class="superscript">
     <span id="footnote-027-backlink">
      <a class="_idFootnoteLink _idGenColorInherit" href="B22235_11.xhtml#footnote-027">
       <span class="koboSpan" id="kobo.112.1">
        3
       </span>
      </a>
     </span>
    </span>
    <span class="koboSpan" id="kobo.113.1">
     in detail
    </span>
    <span class="superscript">
     <span id="footnote-026-backlink">
      <a class="_idFootnoteLink _idGenColorInherit" href="B22235_11.xhtml#footnote-026">
       <span class="koboSpan" id="kobo.114.1">
        4
       </span>
      </a>
     </span>
    </span>
    <span class="koboSpan" id="kobo.115.1">
     throughout the last decade by authorities who are much more qualified to discuss this than our humble person.
    </span>
    <span class="koboSpan" id="kobo.115.2">
     Regardless of those discussions, they (the VLAs) still did not make it into the C++ standard, so there must be a valid reason behind this decision (not just the potential stack-related issues, of assuming a theoretically unlimited stack, and the type mayhem the non-compile time type deduction might induce with VLAs, but also that in C++ there are much better mechanisms to handle this specific
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.116.1">
      use case).
     </span>
    </span>
   </p>
   <div class="_idFootnote" epub:type="footnote" id="footnote-027">
    <p class="Footnote-text">
     <a class="_idFootnoteAnchor _idGenColorInherit" href="B22235_11.xhtml#footnote-027-backlink">
      <span class="koboSpan" id="kobo.117.1">
       3
      </span>
     </a>
     <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3810.pdf">
      <span class="koboSpan" id="kobo.118.1">
       https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3810.pdf
      </span>
     </a>
    </p>
    <div class="_idFootnote" epub:type="footnote" id="footnote-026">
     <p class="Footnote-text">
      <a class="_idFootnoteAnchor _idGenColorInherit" href="B22235_11.xhtml#footnote-026-backlink">
       <span class="koboSpan" id="kobo.119.1">
        4
       </span>
      </a>
      <a href="https://nullprogram.com/blog/2019/10/27/">
       <span class="koboSpan" id="kobo.120.1">
        https://nullprogram.com/blog/2019/10/27/
       </span>
      </a>
     </p>
    </div>
   </div>
   <p>
    <span class="koboSpan" id="kobo.121.1">
     For this chapter of the book, we will discuss some C-specific features that the author finds highly useful, but that sadly still did not make it into the C++ standard in their
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.122.1">
      original form.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-116">
    <a id="_idTextAnchor115">
    </a>
    <span class="koboSpan" id="kobo.123.1">
     The magic of the parameter list
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.124.1">
     Let’s start
    </span>
    <a id="_idIndexMarker386">
    </a>
    <span class="koboSpan" id="kobo.125.1">
     with a simple function, the simplest of all, which is
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.126.1">
      int foo()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.127.1">
     .
    </span>
    <span class="koboSpan" id="kobo.127.2">
     It’s not a very sophisticated function, but it does its job as expected, whatever that
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.128.1">
      might be.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.129.1">
     When compiled as C, a function with an empty parameter list means the function can take an unspecified number of arguments, which can lead to ambiguity and potential errors if arguments are passed to the function.
    </span>
    <span class="koboSpan" id="kobo.129.2">
     That’s because the compiler will not enforce
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.130.1">
      parameter constraints.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.131.1">
     To explicitly specify that a function takes no arguments in C, we must use
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.132.1">
      void
     </span>
    </strong>
    <span class="koboSpan" id="kobo.133.1">
     in the parameter list, as in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.134.1">
      int foo(void)
     </span>
    </strong>
    <span class="koboSpan" id="kobo.135.1">
     , which clearly indicates that the function accepts no arguments and passing any would result in a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.136.1">
      compile-time error.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.137.1">
     In contrast, C++ simplifies this by treating an empty parameter list as equivalent to specifying
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.138.1">
      void
     </span>
    </strong>
    <span class="koboSpan" id="kobo.139.1">
     , meaning that
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.140.1">
      int foo()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.141.1">
     in C++ denotes a function that takes no arguments, just like
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.142.1">
      int foo(void)
     </span>
    </strong>
    <span class="koboSpan" id="kobo.143.1">
     , making the use of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.144.1">
      void
     </span>
    </strong>
    <span class="koboSpan" id="kobo.145.1">
     optional
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.146.1">
      in C++.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.147.1">
     This makes the syntax cleaner in C++, where functions with no parameters can simply be declared with empty parentheses.
    </span>
    <span class="koboSpan" id="kobo.147.2">
     While C still requires
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.148.1">
      void
     </span>
    </strong>
    <span class="koboSpan" id="kobo.149.1">
     for clarity and correctness, C++ allows both forms, though the typical practice is to omit
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.150.1">
      void
     </span>
    </strong>
    <span class="koboSpan" id="kobo.151.1">
     and use the simpler
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.152.1">
      int foo()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.153.1">
     .
    </span>
    <span class="koboSpan" id="kobo.153.2">
     Neat,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.154.1">
      isn’t it?
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.155.1">
     However, what if we want to add some parameters to our function?
    </span>
    <span class="koboSpan" id="kobo.155.2">
     Let’s modify it in the form of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.156.1">
      int foo(int
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.157.1">
       array[static 10])
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.158.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.159.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.160.1">
      int foo(int array[static 10])
     </span>
    </strong>
    <span class="koboSpan" id="kobo.161.1">
     declaration is a feature introduced in
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.162.1">
      C99
     </span>
    </em>
    <span class="koboSpan" id="kobo.163.1">
     that provides additional information to the compiler about the parameters passed to a function, specifically when dealing
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.164.1">
      with arrays.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.165.1">
     In this case, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.166.1">
      static
     </span>
    </strong>
    <span class="koboSpan" id="kobo.167.1">
     keyword within the array parameter indicates to the compiler that the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.168.1">
      fun
     </span>
    </strong>
    <span class="koboSpan" id="kobo.169.1">
     function is expected to be called with an array that has at least 10 elements.
    </span>
    <span class="koboSpan" id="kobo.169.2">
     The number 10 specifies the minimum size of the array that will be passed to the function, which can help the compiler make certain assumptions, such as enabling optimizations based on the guaranteed size of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.170.1">
      the array.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.171.1">
     Additionally, when using static in the array parameter like this, the compiler assumes that the array pointer cannot be
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.172.1">
      NULL
     </span>
    </strong>
    <span class="koboSpan" id="kobo.173.1">
     .
    </span>
    <span class="koboSpan" id="kobo.173.2">
     That’s because a null pointer would imply that there are no valid elements, which violates the condition that the array must have at least 10 elements.
    </span>
    <span class="koboSpan" id="kobo.173.3">
     This provides an extra layer of safety and clarity, as it eliminates the need for the function to check whether the array is
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.174.1">
      NULL
     </span>
    </strong>
    <span class="koboSpan" id="kobo.175.1">
     before proceeding, which can reduce
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.176.1">
      runtime overhead.
     </span>
    </span>
   </p>
   <p>
    <span class="strikethrough">
     <span class="koboSpan" id="kobo.177.1">
      Decent
     </span>
    </span>
    <span class="koboSpan" id="kobo.178.1">
     Recent versions
    </span>
    <a id="_idIndexMarker387">
    </a>
    <span class="koboSpan" id="kobo.179.1">
     of
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.180.1">
      clang
     </span>
    </strong>
    <span class="koboSpan" id="kobo.181.1">
     (well, basically all above 3.1.0) even emit a warning if you call a function having this very specific declaration, with the infamous
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.182.1">
       NULL
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.183.1">
      pointer:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.184.1">
warning: null passed to a callee which requires a non-null argument</span></pre>
   <p>
    <span class="koboSpan" id="kobo.185.1">
     Sadly, this very
    </span>
    <a id="_idIndexMarker388">
    </a>
    <span class="koboSpan" id="kobo.186.1">
     handy feature did not make it into any of the C++ standards, nor can all today’s C compilers digest it (we could not convince MSVC to successfully compile this piece of code, regardless of the requested C standard).
    </span>
    <span class="koboSpan" id="kobo.186.2">
     Regardless, for programmers not targeting these platforms, this might indeed come in as a great help in times
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.187.1">
      of need.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.188.1">
     Another handy feature restricted to the circles of C programmers is the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.189.1">
      restrict
     </span>
    </strong>
    <span class="koboSpan" id="kobo.190.1">
     keyword, introduced in C99, which is a type qualifier that provides hints to the compiler for optimizing memory access involving pointers.
    </span>
    <span class="koboSpan" id="kobo.190.2">
     It tells the compiler that the pointer to which
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.191.1">
      restrict
     </span>
    </strong>
    <span class="koboSpan" id="kobo.192.1">
     is applied is the only means by which the referenced object (memory) will be accessed in the current scope.
    </span>
    <span class="koboSpan" id="kobo.192.2">
     This allows the compiler to make aggressive optimizations because it can assume that no other pointer will alias or reference the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.193.1">
      same memory.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.194.1">
     When you use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.195.1">
      restrict
     </span>
    </strong>
    <span class="koboSpan" id="kobo.196.1">
     qualifier on a pointer, you are promising the compiler that, for the lifetime of that pointer, the object it points to will not be accessed by any other pointer.
    </span>
    <span class="koboSpan" id="kobo.196.2">
     This enables the compiler to generate more efficient code by avoiding unnecessary memory reloads or re-fetches, which might otherwise be required due to potential aliasing (multiple pointers pointing to the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.197.1">
      same memory).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.198.1">
     Without
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.199.1">
      restrict
     </span>
    </strong>
    <span class="koboSpan" id="kobo.200.1">
     , the compiler must assume that any two pointers may reference the same memory, limiting its ability to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.201.1">
      optimize code.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.202.1">
     For example, let’s consider the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.203.1">
      following code:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.204.1">
void update1(int *a, int *b) {
    *a = *a + *b;
    *b = *b + *a;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.205.1">
     In this case, the compiler must assume that
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.206.1">
      *a
     </span>
    </strong>
    <span class="koboSpan" id="kobo.207.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.208.1">
      *b
     </span>
    </strong>
    <span class="koboSpan" id="kobo.209.1">
     could alias each other, so it may reload
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.210.1">
      *a
     </span>
    </strong>
    <span class="koboSpan" id="kobo.211.1">
     or
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.212.1">
      *b
     </span>
    </strong>
    <span class="koboSpan" id="kobo.213.1">
     from memory just
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.214.1">
      in case.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.215.1">
     Here is its counterpart
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.216.1">
      with
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.217.1">
       restrict
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.218.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.219.1">
void update2(int *restrict a, int *restrict b) {
    *a = *a + *b;
    *b = *b + *a;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.220.1">
     In this case, we
    </span>
    <a id="_idIndexMarker389">
    </a>
    <span class="koboSpan" id="kobo.221.1">
     have told the compiler that
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.222.1">
      *a
     </span>
    </strong>
    <span class="koboSpan" id="kobo.223.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.224.1">
      *b
     </span>
    </strong>
    <span class="koboSpan" id="kobo.225.1">
     do not alias, so it can optimize without worrying about
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.226.1">
      memory aliasing.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.227.1">
     The following listings (generated by
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.228.1">
      GCC
     </span>
    </strong>
    <span class="koboSpan" id="kobo.229.1">
     14.2, using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.230.1">
      –O3
     </span>
    </strong>
    <span class="koboSpan" id="kobo.231.1">
     optimization) are the assembly code generated for the two different functions, with
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.232.1">
      some explanation:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.233.1">
update1:
  mov eax, DWORD PTR [rsi]; Load </span><strong class="bold"><span class="koboSpan" id="kobo.234.1">b</span></strong><span class="koboSpan" id="kobo.235.1"> from [rsi] into eax
  add eax, DWORD PTR [rdi]; Add </span><strong class="bold"><span class="koboSpan" id="kobo.236.1">a</span></strong><span class="koboSpan" id="kobo.237.1"> from [rdi] to eax
  mov DWORD PTR [rdi], eax; Store eax into [rdi] (</span><strong class="bold"><span class="koboSpan" id="kobo.238.1">a</span></strong><span class="koboSpan" id="kobo.239.1">)
  add DWORD PTR [rsi], eax; Add eax to [rsi] (</span><strong class="bold"><span class="koboSpan" id="kobo.240.1">b</span></strong><span class="koboSpan" id="kobo.241.1">)
  ret                     ; Return</span></pre>
   <p>
    <span class="koboSpan" id="kobo.242.1">
     Here’s the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.243.1">
      other one:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.244.1">
update2:
  mov eax, DWORD PTR [rsi]; Load </span><strong class="bold"><span class="koboSpan" id="kobo.245.1">b</span></strong><span class="koboSpan" id="kobo.246.1"> from [rsi] into eax
  mov edx, DWORD PTR [rdi]; Load </span><strong class="bold"><span class="koboSpan" id="kobo.247.1">a</span></strong><span class="koboSpan" id="kobo.248.1"> from [rdi] into edx
  add edx, eax            ; eax + edx (result in edx) - </span><strong class="bold"><span class="koboSpan" id="kobo.249.1">a</span></strong><span class="koboSpan" id="kobo.250.1">
  add eax, edx            ; edx + eax (result in eax) - </span><strong class="bold"><span class="koboSpan" id="kobo.251.1">b</span></strong><span class="koboSpan" id="kobo.252.1">
  mov DWORD PTR [rdi], edx; Store edx into [rdi] - </span><strong class="bold"><span class="koboSpan" id="kobo.253.1">a</span></strong><span class="koboSpan" id="kobo.254.1">
  mov DWORD PTR [rsi], eax; Store eax into [rsi] - </span><strong class="bold"><span class="koboSpan" id="kobo.255.1">b</span></strong><span class="koboSpan" id="kobo.256.1">
  ret                     ; Return</span></pre>
   <p>
    <span class="koboSpan" id="kobo.257.1">
     Surprisingly, the one with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.258.1">
      restrict
     </span>
    </strong>
    <span class="koboSpan" id="kobo.259.1">
     has a few more instructions, but once we go through the generated code, we can easily spot the effect of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.260.1">
      restrict
     </span>
    </strong>
    <span class="koboSpan" id="kobo.261.1">
     keyword.
    </span>
    <span class="koboSpan" id="kobo.261.2">
     Supposedly, the parameters to the function are at the memory locations pointed at by
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.262.1">
      [rsi]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.263.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.264.1">
      [rdi]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.265.1">
     .
    </span>
    <span class="koboSpan" id="kobo.265.2">
     The first one (without
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.266.1">
      restrict
     </span>
    </strong>
    <span class="koboSpan" id="kobo.267.1">
     ) has to do all the addition work in memory, thus leading to slightly slower code, while the second one can delegate these costly operations to two ultra-fast
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.268.1">
      register-based additions.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.269.1">
     Also, a big
    </span>
    <a id="_idIndexMarker390">
    </a>
    <span class="koboSpan" id="kobo.270.1">
     difference between these two is that the second one (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.271.1">
      update2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.272.1">
     , with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.273.1">
      restrict
     </span>
    </strong>
    <span class="koboSpan" id="kobo.274.1">
     ) can assume that the value of the second parameter will not change after the first operation, so the carefully crafted register initializations and additions can play a vital part.
    </span>
    <span class="koboSpan" id="kobo.274.2">
     The first one needs to consider that the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.275.1">
      *a = *a + *b;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.276.1">
     operation might change the value of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.277.1">
      b
     </span>
    </strong>
    <span class="koboSpan" id="kobo.278.1">
     too (found at
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.279.1">
      [rsi]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.280.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.280.2">
     Hence, it needs to perform the operations in memory, always making the current value available to the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.281.1">
      upcoming operations.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.282.1">
     While for a simple operation like these simple additions, the effects, and the outcoming result might not be as spectacular as for a larger example which would not have had enough space in this book, we still have enough evidence that the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.283.1">
      restrict
     </span>
    </strong>
    <span class="koboSpan" id="kobo.284.1">
     keyword has factual effects on the generated code.
    </span>
    <span class="koboSpan" id="kobo.284.2">
     Too bad this didn’t make it into
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.285.1">
      C++ either.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.286.1">
     However, that’s enough bashing of C++ and its lack of compatibility with C.
    </span>
    <span class="koboSpan" id="kobo.286.2">
     They were never meant to compete, but rather, they complement each other.
    </span>
    <span class="koboSpan" id="kobo.286.3">
     Let’s move on to more interesting fields.
    </span>
    <span class="koboSpan" id="kobo.286.4">
     Is C++ really compatible
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.287.1">
      with itself?
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-117">
    <a id="_idTextAnchor116">
    </a>
    <span class="koboSpan" id="kobo.288.1">
     Whitespace matters – until it doesn’t
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.289.1">
     The following
    </span>
    <a id="_idIndexMarker391">
    </a>
    <span class="koboSpan" id="kobo.290.1">
     piece of code is not an extraordinarily
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.291.1">
      complicated snippet:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.292.1">
#include &lt;cstdio&gt;
#define STR_I(x) #x
#define STR(x) STR_I(x)
#define JOIN(x,y) (x y)
#define Hello(x) HELLO
int main(void){
    printf("%s\n", STR(JOIN(Hello, World)));
    printf("%s\n", STR(JOIN(Hello,World )));
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.293.1">
     The not-so-complex code defines a series of macros to manipulate strings and concatenate tokens.
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.294.1">
      STR_I(x)
     </span>
    </strong>
    <span class="koboSpan" id="kobo.295.1">
     stringifies its argument,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.296.1">
      STR(x)
     </span>
    </strong>
    <span class="koboSpan" id="kobo.297.1">
     ensures full macro expansion before stringification,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.298.1">
      JOIN(x,y)
     </span>
    </strong>
    <span class="koboSpan" id="kobo.299.1">
     concatenates two arguments with a space, and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.300.1">
      Hello(x)
     </span>
    </strong>
    <span class="koboSpan" id="kobo.301.1">
     is defined but,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.302.1">
      strangely, unused.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.303.1">
     What comes up are two most important
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.304.1">
      printf
     </span>
    </strong>
    <span class="koboSpan" id="kobo.305.1">
     calls in the lifetime of this short program.
    </span>
    <span class="koboSpan" id="kobo.305.2">
     In the first
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.306.1">
      printf
     </span>
    </strong>
    <span class="koboSpan" id="kobo.307.1">
     call,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.308.1">
      JOIN(Hello, World)
     </span>
    </strong>
    <span class="koboSpan" id="kobo.309.1">
     expands to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.310.1">
      (Hello World)
     </span>
    </strong>
    <span class="koboSpan" id="kobo.311.1">
     , which is then stringified to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.312.1">
      "(Hello World)"
     </span>
    </strong>
    <span class="koboSpan" id="kobo.313.1">
     .
    </span>
    <span class="koboSpan" id="kobo.313.2">
     That’s nothing
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.314.1">
      overly complicated.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.315.1">
     However, the
    </span>
    <a id="_idIndexMarker392">
    </a>
    <span class="koboSpan" id="kobo.316.1">
     fun part comes now: in the second
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.317.1">
      printf
     </span>
    </strong>
    <span class="koboSpan" id="kobo.318.1">
     call,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.319.1">
      JOIN(Hello,World)
     </span>
    </strong>
    <span class="koboSpan" id="kobo.320.1">
     (without the space between the comma and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.321.1">
      World
     </span>
    </strong>
    <span class="koboSpan" id="kobo.322.1">
     ) behaves differently depending on the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.323.1">
      GCC version.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.324.1">
     In GCC 9.4 (and below), this results in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.325.1">
      (HelloWorld)
     </span>
    </strong>
    <span class="koboSpan" id="kobo.326.1">
     without a space, while in GCC 9.5 (and above), the preprocessor adds a space between the tokens, making both
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.327.1">
      printf
     </span>
    </strong>
    <span class="koboSpan" id="kobo.328.1">
     calls produce
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.329.1">
      "(
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.330.1">
       Hello World)"
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.331.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.332.1">
     This difference between GCC 9.4 and 9.5 stems from how each version handles token concatenation and whitespace between macro arguments, with GCC 9.4 not inserting spaces where none are explicitly given, and GCC 9.5 handling them more consistently by adding a space even when omitted in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.333.1">
      macro invocation.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.334.1">
     While the C and C++ standards do not explicitly say “whitespace is ignored between macro arguments and commas,” it is implied by the way the preprocessor handles tokenization and macro expansion.
    </span>
    <span class="koboSpan" id="kobo.334.2">
     Regardless, the rules state that arguments are separated by commas, and whitespace does not affect this separation.
    </span>
    <span class="koboSpan" id="kobo.334.3">
     It seems that GCC (before 9.4) had a somewhat liberal interpretation of the lack of specification, which was re-interpreted in GCC 9.5
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.335.1">
      and after.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.336.1">
     The whole misunderstanding is caused by the presence of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.337.1">
      Hello
     </span>
    </strong>
    <span class="koboSpan" id="kobo.338.1">
     macro, defined as a function-like macro, but used as a plain old replacement macro.
    </span>
    <span class="koboSpan" id="kobo.338.2">
     It’s highly possible that the main issue is (or rather, was) a bug in older GCC, which certainly we do not use anymore, because we all know, that newer compilers are more standard compliant, and certainly, we all write standard compliant code,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.339.1">
      don’t we?
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.340.1">
     That’s an interesting piece of historical
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.341.1">
      forward compatibility.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-118">
    <a id="_idTextAnchor117">
    </a>
    <span class="koboSpan" id="kobo.342.1">
     The 11th guest
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.343.1">
     C++11 brought a range of new features while maintaining backward compatibility with C++98, ensuring that developers could adopt the modern capabilities incrementally without breaking existing code.
    </span>
    <span class="koboSpan" id="kobo.343.2">
     One
    </span>
    <a id="_idIndexMarker393">
    </a>
    <span class="koboSpan" id="kobo.344.1">
     of the most transformative additions was
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.345.1">
      move semantics
     </span>
    </strong>
    <span class="koboSpan" id="kobo.346.1">
     , which introduced some new syntax that C++98 compilers could not digest.
    </span>
    <span class="koboSpan" id="kobo.346.2">
     This was facilitated by rvalue references, a syntax again not supported by
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.347.1">
      older compilers.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.348.1">
     Similarly, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.349.1">
      auto
     </span>
    </strong>
    <span class="koboSpan" id="kobo.350.1">
     keyword simplified type declarations by automatically inferring types, yet developers could continue using it to explicitly specify that the variable has automatic storage, like they never did in C++98.
    </span>
    <span class="koboSpan" id="kobo.350.2">
     This choice was made because let’s admit it, no one ever used auto as it was intended for in the C language (from where it was inherited, but even there it was still useless, unless in the B language, where it originated, as correctly denoting the storage for a variable:
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.351.1">
      the stack).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.352.1">
     New syntax
    </span>
    <a id="_idIndexMarker394">
    </a>
    <span class="koboSpan" id="kobo.353.1">
     such as
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.354.1">
      range-based for loops
     </span>
    </strong>
    <span class="koboSpan" id="kobo.355.1">
     allowed for cleaner iteration over containers, but the classic
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.356.1">
      for
     </span>
    </strong>
    <span class="koboSpan" id="kobo.357.1">
     loops from C++98 remained fully functional, thankfully, because lots of people still use them.
    </span>
    <span class="koboSpan" id="kobo.357.2">
     The introduction of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.358.1">
      nullptr
     </span>
    </strong>
    <span class="koboSpan" id="kobo.359.1">
     replaced the old
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.360.1">
      NULL
     </span>
    </strong>
    <span class="koboSpan" id="kobo.361.1">
     macro with a type-safe alternative, though
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.362.1">
      NULL
     </span>
    </strong>
    <span class="koboSpan" id="kobo.363.1">
     was still supported for backward compatibility, regardless of the fact that it was not that different
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.364.1">
      from 0.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.365.1">
     In addition to these core language improvements, C++11 introduced
    </span>
    <a id="_idIndexMarker395">
    </a>
    <span class="koboSpan" id="kobo.366.1">
     modern functional programming features
    </span>
    <a id="_idIndexMarker396">
    </a>
    <span class="koboSpan" id="kobo.367.1">
     such as
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.368.1">
      lambda expressions
     </span>
    </strong>
    <span class="koboSpan" id="kobo.369.1">
     , which allowed anonymous functions to be written inline, facilitating cleaner and more
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.370.1">
      concise code.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.371.1">
     The new
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.372.1">
      constexpr
     </span>
    </strong>
    <span class="koboSpan" id="kobo.373.1">
     feature
    </span>
    <a id="_idIndexMarker397">
    </a>
    <span class="koboSpan" id="kobo.374.1">
     allowed certain functions to be evaluated at compile time, offering performance improvements, but developers could still rely on the C++98 approach of runtime function evaluation if needed with the use of overly complicated templated recursions because, well,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.375.1">
      constexpr
     </span>
    </strong>
    <span class="koboSpan" id="kobo.376.1">
     is not supported by old
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.377.1">
      compilers either.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.378.1">
     However, none of those groundbreaking changes can be more confusing to older users of C++ than the change of parsing for the C++ templates double right-angle brackets.
    </span>
    <span class="koboSpan" id="kobo.378.2">
     In C++98, when using nested template arguments, the parser required spaces between consecutive right-angle brackets (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.379.1">
      &gt; &gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.380.1">
     ) to distinguish them from the shift operator (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.381.1">
      &gt;&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.382.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.382.2">
     This was necessary because, in C++98, the parser would interpret two consecutive
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.383.1">
      &gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.384.1">
     symbols as the bitwise right-shift operator rather than as the closing of two
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.385.1">
      nested templates.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.386.1">
     In C++11 and later, the compiler is smart enough to recognize that in this context,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.387.1">
      &gt;&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.388.1">
     refers to closing
    </span>
    <a id="_idIndexMarker398">
    </a>
    <span class="koboSpan" id="kobo.389.1">
     two nested template brackets, not performing a right-shift operation.
    </span>
    <span class="koboSpan" id="kobo.389.2">
     This makes the syntax cleaner and less error-prone, as developers no longer need to manually add spaces between right-angle brackets in nested template expressions.
    </span>
    <span class="koboSpan" id="kobo.389.3">
     However, this also unfortunately means that the following program will display two different values depending on whether it was compiled with a compiler supporting C++11 standard, or with a compiler that only
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.390.1">
      supports C++98:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.391.1">
#include &lt;iostream&gt;
const int value = 1;
template &lt;class T&gt;
struct D {
    operator bool() {return true;}
    static const int value = 2;
};
template&lt;int t&gt; struct C {
    typedef int value ;
};
int main() {
    const int x = 1;
    if(D&lt;C&lt; ::value&gt;&gt;::value&gt;::value&gt;::value) {
        std::cout &lt;&lt; "C++98 compiler";
    } else {
        std::cout &lt;&lt; "C++11 compiler";
    }
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.392.1">
     When we dig deeper into the intricacies of the program, it is perfectly clear why it has this strange behavior.
    </span>
    <span class="koboSpan" id="kobo.392.2">
     If it is still not clear yet, let’s break
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.393.1">
      it down.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.394.1">
     OK, let’s not break down the entire program.
    </span>
    <span class="koboSpan" id="kobo.394.2">
     That would be too long.
    </span>
    <span class="koboSpan" id="kobo.394.3">
     Instead, we’ll focus on just
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.395.1">
      D&lt;C&lt; ::value&gt;&gt;::value&gt;::value&gt;::value
     </span>
    </strong>
    <span class="koboSpan" id="kobo.396.1">
     , which is the key to all the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.397.1">
      feature identification.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.398.1">
     Using C++98 syntax, this
    </span>
    <a id="_idIndexMarker399">
    </a>
    <span class="koboSpan" id="kobo.399.1">
     will be parsed
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.400.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.401.1">
if(static_cast&lt;bool&gt;(D&lt;int&gt;::value)) { ... </span><span class="koboSpan" id="kobo.401.2">}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.402.1">
     So, it all boils down to the value of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.403.1">
      D&lt;int&gt;::value
     </span>
    </strong>
    <span class="koboSpan" id="kobo.404.1">
     due to the fact that
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.405.1">
      ::value&gt;&gt;::value
     </span>
    </strong>
    <span class="koboSpan" id="kobo.406.1">
     will be parsed as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.407.1">
      1 &gt;&gt; 1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.408.1">
     , resulting in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.409.1">
      0
     </span>
    </strong>
    <span class="koboSpan" id="kobo.410.1">
     .
    </span>
    <span class="koboSpan" id="kobo.410.2">
     This goes into
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.411.1">
      C&lt;0&gt;::value
     </span>
    </strong>
    <span class="koboSpan" id="kobo.412.1">
     , which is a plain
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.413.1">
      typedef
     </span>
    </strong>
    <span class="koboSpan" id="kobo.414.1">
     to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.415.1">
      int
     </span>
    </strong>
    <span class="koboSpan" id="kobo.416.1">
     .
    </span>
    <span class="koboSpan" id="kobo.416.2">
     From there, we
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.417.1">
      reach
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.418.1">
       D&lt;int&gt;::value
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.419.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.420.1">
     Since we have defined it to be
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.421.1">
      2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.422.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.423.1">
      if
     </span>
    </strong>
    <span class="koboSpan" id="kobo.424.1">
     certainly will be
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.425.1">
      true
     </span>
    </strong>
    <span class="koboSpan" id="kobo.426.1">
     , and we have executed the C++98
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.427.1">
      identification branch.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.428.1">
     However, when
    </span>
    <a id="_idIndexMarker400">
    </a>
    <span class="koboSpan" id="kobo.429.1">
     parsing the code with a C++11-compliant compiler, the expression will be parsed as the following, slightly more
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.430.1">
      complex expression:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.431.1">
if((static_cast&lt;int&gt;(D&lt;C&lt;1&gt; &gt;::value &gt; ::value)) &gt; ::value) { ... </span><span class="koboSpan" id="kobo.431.2">}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.432.1">
     As may not be obvious from the long and complex set of right-angle brackets, in the end, this will be parsed like two comparisons.
    </span>
    <span class="koboSpan" id="kobo.432.2">
     That’s because the following
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.433.1">
      D&lt;C&lt;1&gt;&gt;::value
     </span>
    </strong>
    <span class="koboSpan" id="kobo.434.1">
     turns out to be
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.435.1">
      2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.436.1">
     (because
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.437.1">
      C&lt;1&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.438.1">
     is also a type by itself, so we end up in a specialization of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.439.1">
      D
     </span>
    </strong>
    <span class="koboSpan" id="kobo.440.1">
     class with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.441.1">
      C&lt;1&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.442.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.442.2">
     Then, this is compared to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.443.1">
      ::value
     </span>
    </strong>
    <span class="koboSpan" id="kobo.444.1">
     , which will turn out to be true
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.445.1">
      (2&gt;1)
     </span>
    </strong>
    <span class="koboSpan" id="kobo.446.1">
     .
    </span>
    <span class="koboSpan" id="kobo.446.2">
     From this, in the end, after a series of interesting conversions, the end result will look like
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.447.1">
      1&gt;1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.448.1">
     .
    </span>
    <span class="koboSpan" id="kobo.448.2">
     This turns out to be
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.449.1">
      false
     </span>
    </strong>
    <span class="koboSpan" id="kobo.450.1">
     ; hence, we enter the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.451.1">
      C++11 branch.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.452.1">
     With this in place, we have a nice and short, albeit overly complicated and useless, way to identify whether our code was compiled with a C++11 conforming compiler.
    </span>
    <span class="koboSpan" id="kobo.452.2">
     However, checking for the value of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.453.1">
      __cplusplus
     </span>
    </strong>
    <span class="koboSpan" id="kobo.454.1">
     is much easier than this and should be used in any
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.455.1">
      production-ready code.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-119">
    <a id="_idTextAnchor118">
    </a>
    <span class="koboSpan" id="kobo.456.1">
     The auto surprise
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.457.1">
     If you, dear reader, do
    </span>
    <a id="_idIndexMarker401">
    </a>
    <span class="koboSpan" id="kobo.458.1">
     remember that in
    </span>
    <a href="B22235_09.xhtml#_idTextAnchor096">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.459.1">
        Chapter 9
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.460.1">
     , we had an interesting section called
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.461.1">
      The definition of zero
     </span>
    </em>
    <span class="koboSpan" id="kobo.462.1">
     , then all is good.
    </span>
    <span class="koboSpan" id="kobo.462.2">
     That’s because our next pitch will be about this highly influential number again.
    </span>
    <span class="koboSpan" id="kobo.462.3">
     If you don’t remember that chapter, then life is still good, because hopefully, you have purchased a full book with all the chapters inside, and you can turn the pages back to read
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.463.1">
      it (again).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.464.1">
     Let’s consider the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.465.1">
      following program:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.466.1">
#include &lt;iostream&gt;
#include &lt;typeinfo&gt;
#include &lt;string&gt;
template&lt;typename T&gt; std::string typeof(T t) {
    std::string res = typeid(t).name();
    return res;
}
int main() {
    auto a1 = 0;
    auto a2(0);
    auto a3 {0};
    auto a4 = {0};
    std::cout &lt;&lt; typeof(a1) &lt;&lt; std::endl
            &lt;&lt; typeof(a2) &lt;&lt; std::endl
            &lt;&lt; typeof(a3) &lt;&lt; std::endl
            &lt;&lt; typeof(a4) &lt;&lt; std::endl;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.467.1">
     The
    </span>
    <a id="_idIndexMarker402">
    </a>
    <span class="koboSpan" id="kobo.468.1">
     program is not an overly complicated one again.
    </span>
    <span class="koboSpan" id="kobo.468.2">
     It just uses the fancy
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.469.1">
      auto
     </span>
    </strong>
    <span class="koboSpan" id="kobo.470.1">
     keyword and initializes variables to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.471.1">
      0
     </span>
    </strong>
    <span class="koboSpan" id="kobo.472.1">
     using all kinds of mechanisms, mostly presented in the chapter mentioned earlier.
    </span>
    <span class="koboSpan" id="kobo.472.2">
     If you do not know what the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.473.1">
      auto
     </span>
    </strong>
    <span class="koboSpan" id="kobo.474.1">
     keyword does, then here is a short recap: the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.475.1">
      auto
     </span>
    </strong>
    <span class="koboSpan" id="kobo.476.1">
     keyword in C++11 was hijacked from C, and its new role is to allow automatic type inference, enabling the compiler to deduce the type of a variable based on its initializer.
    </span>
    <span class="koboSpan" id="kobo.476.2">
     This simplifies code by removing the need for explicit type declarations, and shortens the handling of complex or verbose types, such as iterators or
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.477.1">
      templated types.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.478.1">
     Anyway, back to our code.
    </span>
    <span class="koboSpan" id="kobo.478.2">
     After careful consideration, we can conclude
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.479.1">
      the following:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.480.1">
       auto a1 = 0;
      </span>
     </strong>
     <span class="koboSpan" id="kobo.481.1">
      : For this simple case,
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.482.1">
       a1
      </span>
     </strong>
     <span class="koboSpan" id="kobo.483.1">
      is deduced to be
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.484.1">
       int
      </span>
     </strong>
     <span class="koboSpan" id="kobo.485.1">
      since 0 is an integer literal.
     </span>
     <span class="koboSpan" id="kobo.485.2">
      This is a straightforward
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.486.1">
       copy initialization.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.487.1">
       auto a2(0);
      </span>
     </strong>
     <span class="koboSpan" id="kobo.488.1">
      : Again, a simple one,
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.489.1">
       a2
      </span>
     </strong>
     <span class="koboSpan" id="kobo.490.1">
      is also deduced to be
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.491.1">
       int
      </span>
     </strong>
     <span class="koboSpan" id="kobo.492.1">
      because 0 is directly initialized as an
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.493.1">
       integer literal.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.494.1">
       auto a3 {0};
      </span>
     </strong>
     <span class="koboSpan" id="kobo.495.1">
      : Then,
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.496.1">
       a3
      </span>
     </strong>
     <span class="koboSpan" id="kobo.497.1">
      is deduced to be
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.498.1">
       int
      </span>
     </strong>
     <span class="koboSpan" id="kobo.499.1">
      , as the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.500.1">
       {0}
      </span>
     </strong>
     <span class="koboSpan" id="kobo.501.1">
      list initialization initializes it to
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.502.1">
       an integer.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.503.1">
       auto a4 = {0};
      </span>
     </strong>
     <span class="koboSpan" id="kobo.504.1">
      : This is a bit tricky, however.
     </span>
     <span class="koboSpan" id="kobo.504.2">
      For this case,
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.505.1">
       a4
      </span>
     </strong>
     <span class="koboSpan" id="kobo.506.1">
      is deduced to be
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.507.1">
       std::initializer_list&lt;int&gt;
      </span>
     </strong>
     <span class="koboSpan" id="kobo.508.1">
      because
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.509.1">
       auto
      </span>
     </strong>
     <span class="koboSpan" id="kobo.510.1">
      with brace initialization deduces an
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.511.1">
       initializer_list
      </span>
     </strong>
     <span class="koboSpan" id="kobo.512.1">
      .
     </span>
     <span class="koboSpan" id="kobo.512.2">
      This is a special rule for
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.513.1">
       auto
      </span>
     </strong>
     <span class="koboSpan" id="kobo.514.1">
      when used with
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.515.1">
       brace-enclosed initializers.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.516.1">
     The output of the
    </span>
    <a id="_idIndexMarker403">
    </a>
    <span class="koboSpan" id="kobo.517.1">
     program using MSVC is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.518.1">
      the following:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.519.1">
int
int
int
class std::initializer_list&lt;int&gt;</span></pre>
   <p>
    <span class="koboSpan" id="kobo.520.1">
     Using GCC (recent/decent versions), the output will be a bit less verbose, but you get
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.521.1">
      the idea:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.522.1">
i
i
i
St16initializer_listIiE</span></pre>
   <p>
    <span class="koboSpan" id="kobo.523.1">
     However, there is a catch.
    </span>
    <span class="koboSpan" id="kobo.523.2">
     If we compile this piece of code with GCC versions older than version 5.0 we get an ugly surprise.
    </span>
    <span class="koboSpan" id="kobo.523.3">
     The output is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.524.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.525.1">
i
i
St16initializer_listIiE
St16initializer_listIiE</span></pre>
   <p>
    <span class="koboSpan" id="kobo.526.1">
     What an unexpected surprise of backward compatibility.
    </span>
    <span class="koboSpan" id="kobo.526.2">
     The real help comes from clang (3.7), however.
    </span>
    <span class="koboSpan" id="kobo.526.3">
     If we compile the program with it, we get the following rather
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.527.1">
      helpful message:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.528.1">
&lt;source&gt;:19:13: warning: direct list initialization of a variable with a deduced type will change meaning in a future version of Clang; insert an '=' to avoid a change in behavior [-Wfuture-compat]
    auto a3 {0};</span></pre>
   <p>
    <span class="koboSpan" id="kobo.529.1">
     So, it seems that at some
    </span>
    <a id="_idIndexMarker404">
    </a>
    <span class="koboSpan" id="kobo.530.1">
     stage during its evolution, the meaning of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.531.1">
      {x}
     </span>
    </strong>
    <span class="koboSpan" id="kobo.532.1">
     combined with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.533.1">
      auto
     </span>
    </strong>
    <span class="koboSpan" id="kobo.534.1">
     but not
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.535.1">
      =
     </span>
    </strong>
    <span class="koboSpan" id="kobo.536.1">
     , in this very specific scenario, has changed (around the birth date of C++17).
    </span>
    <span class="koboSpan" id="kobo.536.2">
     However, thankfully, early compilers had thought of this peculiar scenario, with this very specific and direct warning.
    </span>
    <span class="koboSpan" id="kobo.536.3">
     Very backward compatible,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.537.1">
      isn’t it?
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.538.1">
     So, with all this in mind, it should not come as a huge surprise that the following code does not even compile (considering that we are still in the confines of our previous
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.539.1">
      short program):
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.540.1">
std::cout &lt;&lt; typeof( {0} );</span></pre>
   <p>
    <span class="koboSpan" id="kobo.541.1">
     Why should it?
    </span>
    <span class="koboSpan" id="kobo.541.2">
     Which type would
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.542.1">
      {0}
     </span>
    </strong>
    <span class="koboSpan" id="kobo.543.1">
     be deduced to, considering all the chaos and mayhem with the preceding syntax?
    </span>
    <span class="koboSpan" id="kobo.543.2">
     Would it be deduced to an
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.544.1">
      int
     </span>
    </strong>
    <span class="koboSpan" id="kobo.545.1">
     type?
    </span>
    <span class="koboSpan" id="kobo.545.2">
     Or maybe to an
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.546.1">
      initializer_list
     </span>
    </strong>
    <span class="koboSpan" id="kobo.547.1">
     type?
    </span>
    <span class="koboSpan" id="kobo.547.2">
     Would it be a null pointer (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.548.1">
      nullptr
     </span>
    </strong>
    <span class="koboSpan" id="kobo.549.1">
     )?
    </span>
    <span class="koboSpan" id="kobo.549.2">
     Or an object that can be built from a number, like
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.550.1">
      the following:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.551.1">
struct D { D(int i) {} };
void fun(D d) { }
fun({0});</span></pre>
   <p>
    <span class="koboSpan" id="kobo.552.1">
     Or is this not so
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.553.1">
      fun anymore?
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-120">
    <a id="_idTextAnchor119">
    </a>
    <span class="koboSpan" id="kobo.554.1">
     Summary
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.555.1">
     In this chapter, we learned that C++ has evolved and diverged significantly from its humble C (as well as B and BCPL) origins.
    </span>
    <span class="koboSpan" id="kobo.555.2">
     We learned that C++ has introduced modern features and stricter rules to enhance safety and efficiency, and to support modern programming paradigms.
    </span>
    <span class="koboSpan" id="kobo.555.3">
     While it maintains much of C’s syntax, the two languages have heavily branched off over time, leading to compatibility challenges, especially when mixing older C code with features requiring newer C++ standards.
    </span>
    <span class="koboSpan" id="kobo.555.4">
     We discussed this extensively in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.556.1">
      this chapter.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.557.1">
     Within modern C++ itself, the introduction of features such as move semantics, stricter template parsing, and changes in the behavior of keywords such as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.558.1">
      auto
     </span>
    </strong>
    <span class="koboSpan" id="kobo.559.1">
     have added layers of complexity (not that there were not enough).
    </span>
    <span class="koboSpan" id="kobo.559.2">
     We also learned this in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.560.1">
      this chapter.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.561.1">
     Despite these challenges, we explored the fact that C++ continues to build on its rich legacy, offering powerful tools for developers while requiring careful attention to evolving standards and backward compatibility without incurring too much contradiction with its previous self.
    </span>
    <span class="koboSpan" id="kobo.561.2">
     It remains a language where tradition and innovation meet, often in unexpected and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.562.1">
      fascinating ways.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.563.1">
     But for how long?
    </span>
    <span class="koboSpan" id="kobo.563.2">
     Will it survive the surfacing threat of the new kid on the block?
    </span>
    <span class="koboSpan" id="kobo.563.3">
     Will Rust replace C++?
    </span>
    <span class="koboSpan" id="kobo.563.4">
     That’s up to you, dear reader, and it will be detailedly debated by Alex in our
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.564.1">
      next chapter.
     </span>
    </span>
   </p>
  </div>
 </body></html>