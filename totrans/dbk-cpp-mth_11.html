<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-113">
    <a id="_idTextAnchor112">
    </a>
    
     11
    
   </h1>
   <h1 id="_idParaDest-114">
    <a id="_idTextAnchor113">
    </a>
    
     C++ Is Backward Compatible ...Even with C
    
   </h1>
   <p class="italic-heading">
    <em class="italic">
     
      And of course, with C, and B ...
     
     
      and even A ...
     
     
      and @
     
    </em>
    
     <em class="italic">
      
       maybe?
      
     </em>
    
   </p>
   <p>
    
     In the beginning, there was the word, and the word was used in BCPL.
    
    
     Pronounced like Basic Combined Programming Language, not Baltimore County Public Library.
    
    
     It was the first of its kind that ruled the land of compilers with an iron syntax for several iterations.
    
    
     However, the trials of time were not kind to it.
    
    
     New features, doctrines, and syntax passed through and soon a new heir to the throne rose from the bits:
    
    <em class="italic">
     
      B
     
    </em>
    
     .
    
    
     Not too many considered
    
    <em class="italic">
     
      B
     
    </em>
    
     ’s typeless nature and advantage and
    
    <a id="_idIndexMarker382">
    </a>
    
     soon
    
    <em class="italic">
     
      B
     
    </em>
    
     ceased to be, as a new contender to the throne of programming languages replaced
    
    
     <em class="italic">
      
       B
      
     </em>
    
    
     
      :
     
    
    
     <em class="italic">
      
       C
      
     </em>
    
    
     
      
       <a class="_idFootnoteLink _idGenColorInherit" href="B22235_11.xhtml#footnote-029">
        
         1
        
       </a>
      
     
    
    
     
      .
     
    
   </p>
   <div><p class="Footnote-text">
     <a class="_idFootnoteAnchor _idGenColorInherit" href="B22235_11.xhtml#footnote-029-backlink">
      
       1
      
     </a>
     <a href="https://www.bell-labs.com/usr/dmr/www/chist.html">
      
       https://www.bell-labs.com/usr/dmr/www/chist.html
      
     </a>
    </p>
   </div>
   <p>
    
     The rest is history.
    
    <em class="italic">
     
      C
     
    </em>
    
     became the de-facto language of low-level system programming, and its syntax crept into all popular programming languages of the last and this century (hello, curly braces).
    
    <em class="italic">
     
      C
     
    </em>
    
     is like glue, binding together various programming languages to perform sacred rites
    
    
     
      in Computerlandia.
     
    
   </p>
   <p>
    
     And the programmers looked and saw that it
    
    
     
      was good.
     
    
   </p>
   <p>
    
     Except for one Prometheus
    
    
     
      <a class="_idFootnoteLink _idGenColorInherit" href="B22235_11.xhtml#footnote-028">
       
        2
       
      </a>
     
    
    
     , a bringer of classes into
    
    <em class="italic">
     
      C
     
    </em>
    
     , soon to give people,
    
    <em class="italic">
     
      C with classes
     
    </em>
    
     , and
    
    <em class="italic">
     
      Cfront
     
    </em>
    
     , the first ever compiler that digested C++ code and spat out C code which sadly is long gone from our realm, but its legacy remains.
    
    
     The language, the dozens of C++ standard-compliant compilers (each, in their time was standard conformant...
    
    
     more or less), several hundreds of undefined behavior cases, and various iterations of the standard over the last three decades (the last working one being C++23, while the committee is laboring the latest and greatest C++26) are all here and constitute the programming language we all
    
    
     
      love: C++.
     
    
   </p>
   <div><p class="Footnote-text">
     <a class="_idFootnoteAnchor _idGenColorInherit" href="B22235_11.xhtml#footnote-028-backlink">
      
       2
      
     </a>
     
      Yes, Bjarne, we are talking about you
     
    </p>
   </div>
   <p>
    
     This chapter will have you glued to your seat – like traffic at rush hour – with the
    
    
     
      following topics:
     
    
   </p>
   <ul>
    <li>
     
      Is C++ really backward-compatible
     
     
      
       with C
      
     
     
      
       ?
      
     
    </li>
    <li>
     
      Is C++ really backward-compatible
     
     
      
       with C++?
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-115">
    <a id="_idTextAnchor114">
    </a>
    
     Is C really forward-compatible with C++?
    
   </h1>
   <p>
    
     This chapter will be a bit of exploration, covering most of the banally boring bothersome beliefs concerning whether C++ is really backward compatible with C.
    
    
     As we were
    
    <a id="_idIndexMarker383">
    </a>
    
     indoctrinated through the decades by our tutors, teachers, and trainers, C++ is mostly backward compatible with C.
    
    
     This means that much of C code can be compiled and run in C++ with little modification, as they share similar syntax and
    
    
     
      standard libraries.
     
    
   </p>
   <pre class="source-code">
&lt;banalities reason="these were discussed somewhere else"&gt;</pre>
   <p>
    
     C and C++ may be closely related, like two siblings in a dysfunctional family, but still have many differences, leading to a love-hate relationship when it comes to compatibility.
    
    
     However, over time, the two languages have diverged significantly.
    
    
     According to the core rules, C is more permissive with looser typing rules, especially around pointers, and allows constructs like implicit pointer conversions, which C++ strictly forbids.
    
    
     For instance, in C, you can assign a
    
    <strong class="source-inline">
     
      void*
     
    </strong>
    
     to any other pointer type without a cast, while C++ will demand an explicit cast to maintain
    
    
     
      type safety.
     
    
   </p>
   <p>
    
     Similarly, C++ (especially the newer iterations of the language) has stricter rules regarding enumerations, making them distinct types, whereas in C, enums are simply treated as
    
    <strong class="source-inline">
     
      int
     
    </strong>
    
     .
    
    
     This difference extends to many other areas: variable initialization, type qualifiers, and even memory allocation (
    
    <strong class="source-inline">
     
      *alloc()
     
    </strong>
    
     ) work differently between the two.
    
    
     This is especially true of functions such as
    
    <strong class="source-inline">
     
      malloc
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      calloc
     
    </strong>
    
     , and so on.
    
    
     While in C they’re just your run-of-the-mill functions, as mundane as your morning cup of coffee, if they occur in any kind of C++ code, suddenly it’s like opening a portal to the seven circles of developer hell.
    
    
     This is particularly true during code reviews where acolyte C++ programmers are clutching their keyboards in terror, pointing out how you should not use C functions in C++ code when you have perfectly valid
    
    <strong class="source-inline">
     
      new
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      delete
     
    </strong>
    
     .
    
    
     They might also ask why you even need to allocate memory.
    
    
     It’s 2024.
    
    
     We have smart pointers.
    
    
     Or at least, if you can restrain yourself, we beg you not to use C-style casting.
    
    
     That’s because there are perfectly functioning cast operators introduced in the C++ standard more than a
    
    
     
      decade ago.
     
    
   </p>
   <p>
    
     According to what was just discussed (but not exclusively), while young C++ emphasizes stricter type rules and more predictable, safe programming practices, granddaddy C remains the pragmatic and flexible, albeit
    
    
     
      riskier, option.
     
    
   </p>
   <p>
    
     To the
    
    <a id="_idIndexMarker384">
    </a>
    
     horror of C++ acolytes, the two languages are often used together, especially in C++ projects that need to use libraries written in C, but ensure code compatibility between the two languages.
    
    
     Oh, the nightmares of
    
    
     
      software development.
     
    
   </p>
   <p>
    
     To aid the preceding scenario, developers often have to use
    
    <strong class="source-inline">
     
      extern "C"
     
    </strong>
    
     declarations, which prevent C++’s name mangling and allow smooth function linking across libraries written in various dialects.
    
    
     This is because, despite their similarities, the object files generated by C and C++ compilers are handled differently (yes, name mangling, we’re talking
    
    
     
      about you).
     
    
   </p>
   <p>
    
     To top the previous flat facts, in addition, there are a plethora of C99-specific keywords, such as
    
    <strong class="source-inline">
     
      _Alignas
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      _Alignof
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      _Atomic
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      _Bool
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      _Complex
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      _Generic
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      _Imaginary
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      _Noreturn
     
    </strong>
    
     , and
    
    <strong class="source-inline">
     
      _Static_assert
     
    </strong>
    
     , that are not part of standard C++, though some may have C++ equivalents or be available through compiler extensions.
    
    
     To make life more interesting, these were actually retired starting from C23, due to some efforts to bring C closer
    
    
     
      to C++.
     
    
   </p>
   <p>
    
     And we didn’t even mention designated initializers.
    
    
     Too late
    
    
     
      for them.
     
    
   </p>
   <pre class="source-code">
&lt;/banalities&gt;</pre>
   <p>
    
     However, C was certainly not thought up with the idea that someday, there would be a future programming language called C++.
    
    
     That’s why the following C code is perfectly valid while all law-abiding C++ compilers (and pure C++ developers too) will choke on
    
    
     
      it heavily:
     
    
   </p>
   <pre class="source-code">
int template(int this) {
    int class = 0, using = 1, delete;
    if (this == 0) return class;
    if (this == 1) return using;
    for (int friend = 2; friend &lt;= this; friend++) {
        delete = class + using;
        class = using;
        using = delete;
    }
    return delete;
}</pre>
   <p>
    
     While
    
    <a id="_idIndexMarker385">
    </a>
    
     looking like the nightmare out of the C pits, regardless of it, this piece of pure C code is perfectly valid, and what a surprise, it even calculates the Fibonacci numbers.
    
    
     But let’s not be overly fiendish towards you, dear reader (although considering what other mythical code snippets you had to suffer through this book till you reached this chapter, I hardly doubt this piece of code may come as a shock to you ...
    
    
     no worries, this is the penultimate chapter, so the suffering is almost over ...
    
    
     till then, however: do you remember in
    
    <a href="B22235_09.xhtml#_idTextAnchor096">
     
      <em class="italic">
       
        Chapter 9
       
      </em>
     
    </a>
    
     where we defined main to be return and return to be main?), and let us present another interesting feature of C, that was not ported over to C++.
    
   </p>
   <p>
    
     No, we are not talking about variable length arrays, regardless of the fact that just due to the peculiar syntax of
    
    <strong class="source-inline">
     
      void funny_fun(int n, int array[][*])
     
    </strong>
    
     , they also deserve a litany of their own (the syntax is an exemplification of how to pass in a 2D variable length array to a function in the declaration of its prototype).
    
    
     Variable length arrays have been discussed
    
    
     
      <a class="_idFootnoteLink _idGenColorInherit" href="B22235_11.xhtml#footnote-027">
       
        3
       
      </a>
     
    
    
     in detail
    
    
     
      <a class="_idFootnoteLink _idGenColorInherit" href="B22235_11.xhtml#footnote-026">
       
        4
       
      </a>
     
    
    
     throughout the last decade by authorities who are much more qualified to discuss this than our humble person.
    
    
     Regardless of those discussions, they (the VLAs) still did not make it into the C++ standard, so there must be a valid reason behind this decision (not just the potential stack-related issues, of assuming a theoretically unlimited stack, and the type mayhem the non-compile time type deduction might induce with VLAs, but also that in C++ there are much better mechanisms to handle this specific
    
    
     
      use case).
     
    
   </p>
   <div><p class="Footnote-text">
     <a class="_idFootnoteAnchor _idGenColorInherit" href="B22235_11.xhtml#footnote-027-backlink">
      
       3
      
     </a>
     <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3810.pdf">
      
       https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3810.pdf
      
     </a>
    </p>
    <div><p class="Footnote-text">
      <a class="_idFootnoteAnchor _idGenColorInherit" href="B22235_11.xhtml#footnote-026-backlink">
       
        4
       
      </a>
      <a href="https://nullprogram.com/blog/2019/10/27/">
       
        https://nullprogram.com/blog/2019/10/27/
       
      </a>
     </p>
    </div>
   </div>
   <p>
    
     For this chapter of the book, we will discuss some C-specific features that the author finds highly useful, but that sadly still did not make it into the C++ standard in their
    
    
     
      original form.
     
    
   </p>
   <h2 id="_idParaDest-116">
    <a id="_idTextAnchor115">
    </a>
    
     The magic of the parameter list
    
   </h2>
   <p>
    
     Let’s start
    
    <a id="_idIndexMarker386">
    </a>
    
     with a simple function, the simplest of all, which is
    
    <strong class="source-inline">
     
      int foo()
     
    </strong>
    
     .
    
    
     It’s not a very sophisticated function, but it does its job as expected, whatever that
    
    
     
      might be.
     
    
   </p>
   <p>
    
     When compiled as C, a function with an empty parameter list means the function can take an unspecified number of arguments, which can lead to ambiguity and potential errors if arguments are passed to the function.
    
    
     That’s because the compiler will not enforce
    
    
     
      parameter constraints.
     
    
   </p>
   <p>
    
     To explicitly specify that a function takes no arguments in C, we must use
    
    <strong class="source-inline">
     
      void
     
    </strong>
    
     in the parameter list, as in
    
    <strong class="source-inline">
     
      int foo(void)
     
    </strong>
    
     , which clearly indicates that the function accepts no arguments and passing any would result in a
    
    
     
      compile-time error.
     
    
   </p>
   <p>
    
     In contrast, C++ simplifies this by treating an empty parameter list as equivalent to specifying
    
    <strong class="source-inline">
     
      void
     
    </strong>
    
     , meaning that
    
    <strong class="source-inline">
     
      int foo()
     
    </strong>
    
     in C++ denotes a function that takes no arguments, just like
    
    <strong class="source-inline">
     
      int foo(void)
     
    </strong>
    
     , making the use of the
    
    <strong class="source-inline">
     
      void
     
    </strong>
    
     optional
    
    
     
      in C++.
     
    
   </p>
   <p>
    
     This makes the syntax cleaner in C++, where functions with no parameters can simply be declared with empty parentheses.
    
    
     While C still requires
    
    <strong class="source-inline">
     
      void
     
    </strong>
    
     for clarity and correctness, C++ allows both forms, though the typical practice is to omit
    
    <strong class="source-inline">
     
      void
     
    </strong>
    
     and use the simpler
    
    <strong class="source-inline">
     
      int foo()
     
    </strong>
    
     .
    
    
     Neat,
    
    
     
      isn’t it?
     
    
   </p>
   <p>
    
     However, what if we want to add some parameters to our function?
    
    
     Let’s modify it in the form of
    
    <strong class="source-inline">
     
      int foo(int
     
    </strong>
    
     <strong class="source-inline">
      
       array[static 10])
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      int foo(int array[static 10])
     
    </strong>
    
     declaration is a feature introduced in
    
    <em class="italic">
     
      C99
     
    </em>
    
     that provides additional information to the compiler about the parameters passed to a function, specifically when dealing
    
    
     
      with arrays.
     
    
   </p>
   <p>
    
     In this case, the
    
    <strong class="source-inline">
     
      static
     
    </strong>
    
     keyword within the array parameter indicates to the compiler that the
    
    <strong class="source-inline">
     
      fun
     
    </strong>
    
     function is expected to be called with an array that has at least 10 elements.
    
    
     The number 10 specifies the minimum size of the array that will be passed to the function, which can help the compiler make certain assumptions, such as enabling optimizations based on the guaranteed size of
    
    
     
      the array.
     
    
   </p>
   <p>
    
     Additionally, when using static in the array parameter like this, the compiler assumes that the array pointer cannot be
    
    <strong class="source-inline">
     
      NULL
     
    </strong>
    
     .
    
    
     That’s because a null pointer would imply that there are no valid elements, which violates the condition that the array must have at least 10 elements.
    
    
     This provides an extra layer of safety and clarity, as it eliminates the need for the function to check whether the array is
    
    <strong class="source-inline">
     
      NULL
     
    </strong>
    
     before proceeding, which can reduce
    
    
     
      runtime overhead.
     
    
   </p>
   <p>
    
     
      Decent
     
    
    
     Recent versions
    
    <a id="_idIndexMarker387">
    </a>
    
     of
    
    <strong class="bold">
     
      clang
     
    </strong>
    
     (well, basically all above 3.1.0) even emit a warning if you call a function having this very specific declaration, with the infamous
    
    
     <strong class="source-inline">
      
       NULL
      
     </strong>
    
    
     
      pointer:
     
    
   </p>
   <pre class="source-code">
warning: null passed to a callee which requires a non-null argument</pre>
   <p>
    
     Sadly, this very
    
    <a id="_idIndexMarker388">
    </a>
    
     handy feature did not make it into any of the C++ standards, nor can all today’s C compilers digest it (we could not convince MSVC to successfully compile this piece of code, regardless of the requested C standard).
    
    
     Regardless, for programmers not targeting these platforms, this might indeed come in as a great help in times
    
    
     
      of need.
     
    
   </p>
   <p>
    
     Another handy feature restricted to the circles of C programmers is the
    
    <strong class="source-inline">
     
      restrict
     
    </strong>
    
     keyword, introduced in C99, which is a type qualifier that provides hints to the compiler for optimizing memory access involving pointers.
    
    
     It tells the compiler that the pointer to which
    
    <strong class="source-inline">
     
      restrict
     
    </strong>
    
     is applied is the only means by which the referenced object (memory) will be accessed in the current scope.
    
    
     This allows the compiler to make aggressive optimizations because it can assume that no other pointer will alias or reference the
    
    
     
      same memory.
     
    
   </p>
   <p>
    
     When you use the
    
    <strong class="source-inline">
     
      restrict
     
    </strong>
    
     qualifier on a pointer, you are promising the compiler that, for the lifetime of that pointer, the object it points to will not be accessed by any other pointer.
    
    
     This enables the compiler to generate more efficient code by avoiding unnecessary memory reloads or re-fetches, which might otherwise be required due to potential aliasing (multiple pointers pointing to the
    
    
     
      same memory).
     
    
   </p>
   <p>
    
     Without
    
    <strong class="source-inline">
     
      restrict
     
    </strong>
    
     , the compiler must assume that any two pointers may reference the same memory, limiting its ability to
    
    
     
      optimize code.
     
    
   </p>
   <p>
    
     For example, let’s consider the
    
    
     
      following code:
     
    
   </p>
   <pre class="source-code">
void update1(int *a, int *b) {
    *a = *a + *b;
    *b = *b + *a;
}</pre>
   <p>
    
     In this case, the compiler must assume that
    
    <strong class="source-inline">
     
      *a
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      *b
     
    </strong>
    
     could alias each other, so it may reload
    
    <strong class="source-inline">
     
      *a
     
    </strong>
    
     or
    
    <strong class="source-inline">
     
      *b
     
    </strong>
    
     from memory just
    
    
     
      in case.
     
    
   </p>
   <p>
    
     Here is its counterpart
    
    
     
      with
     
    
    
     <strong class="source-inline">
      
       restrict
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
void update2(int *restrict a, int *restrict b) {
    *a = *a + *b;
    *b = *b + *a;
}</pre>
   <p>
    
     In this case, we
    
    <a id="_idIndexMarker389">
    </a>
    
     have told the compiler that
    
    <strong class="source-inline">
     
      *a
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      *b
     
    </strong>
    
     do not alias, so it can optimize without worrying about
    
    
     
      memory aliasing.
     
    
   </p>
   <p>
    
     The following listings (generated by
    
    <strong class="bold">
     
      GCC
     
    </strong>
    
     14.2, using
    
    <strong class="source-inline">
     
      –O3
     
    </strong>
    
     optimization) are the assembly code generated for the two different functions, with
    
    
     
      some explanation:
     
    
   </p>
   <pre class="source-code">
update1:
  mov eax, DWORD PTR [rsi]; Load <strong class="bold">b</strong> from [rsi] into eax
  add eax, DWORD PTR [rdi]; Add <strong class="bold">a</strong> from [rdi] to eax
  mov DWORD PTR [rdi], eax; Store eax into [rdi] (<strong class="bold">a</strong>)
  add DWORD PTR [rsi], eax; Add eax to [rsi] (<strong class="bold">b</strong>)
  ret                     ; Return</pre>
   <p>
    
     Here’s the
    
    
     
      other one:
     
    
   </p>
   <pre class="source-code">
update2:
  mov eax, DWORD PTR [rsi]; Load <strong class="bold">b</strong> from [rsi] into eax
  mov edx, DWORD PTR [rdi]; Load <strong class="bold">a</strong> from [rdi] into edx
  add edx, eax            ; eax + edx (result in edx) - <strong class="bold">a</strong>
  add eax, edx            ; edx + eax (result in eax) - <strong class="bold">b</strong>
  mov DWORD PTR [rdi], edx; Store edx into [rdi] - <strong class="bold">a</strong>
  mov DWORD PTR [rsi], eax; Store eax into [rsi] - <strong class="bold">b</strong>
  ret                     ; Return</pre>
   <p>
    
     Surprisingly, the one with
    
    <strong class="source-inline">
     
      restrict
     
    </strong>
    
     has a few more instructions, but once we go through the generated code, we can easily spot the effect of the
    
    <strong class="source-inline">
     
      restrict
     
    </strong>
    
     keyword.
    
    
     Supposedly, the parameters to the function are at the memory locations pointed at by
    
    <strong class="source-inline">
     
      [rsi]
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      [rdi]
     
    </strong>
    
     .
    
    
     The first one (without
    
    <strong class="source-inline">
     
      restrict
     
    </strong>
    
     ) has to do all the addition work in memory, thus leading to slightly slower code, while the second one can delegate these costly operations to two ultra-fast
    
    
     
      register-based additions.
     
    
   </p>
   <p>
    
     Also, a big
    
    <a id="_idIndexMarker390">
    </a>
    
     difference between these two is that the second one (
    
    <strong class="source-inline">
     
      update2
     
    </strong>
    
     , with
    
    <strong class="source-inline">
     
      restrict
     
    </strong>
    
     ) can assume that the value of the second parameter will not change after the first operation, so the carefully crafted register initializations and additions can play a vital part.
    
    
     The first one needs to consider that the
    
    <strong class="source-inline">
     
      *a = *a + *b;
     
    </strong>
    
     operation might change the value of
    
    <strong class="source-inline">
     
      b
     
    </strong>
    
     too (found at
    
    <strong class="source-inline">
     
      [rsi]
     
    </strong>
    
     ).
    
    
     Hence, it needs to perform the operations in memory, always making the current value available to the
    
    
     
      upcoming operations.
     
    
   </p>
   <p>
    
     While for a simple operation like these simple additions, the effects, and the outcoming result might not be as spectacular as for a larger example which would not have had enough space in this book, we still have enough evidence that the
    
    <strong class="source-inline">
     
      restrict
     
    </strong>
    
     keyword has factual effects on the generated code.
    
    
     Too bad this didn’t make it into
    
    
     
      C++ either.
     
    
   </p>
   <p>
    
     However, that’s enough bashing of C++ and its lack of compatibility with C.
    
    
     They were never meant to compete, but rather, they complement each other.
    
    
     Let’s move on to more interesting fields.
    
    
     Is C++ really compatible
    
    
     
      with itself?
     
    
   </p>
   <h1 id="_idParaDest-117">
    <a id="_idTextAnchor116">
    </a>
    
     Whitespace matters – until it doesn’t
    
   </h1>
   <p>
    
     The following
    
    <a id="_idIndexMarker391">
    </a>
    
     piece of code is not an extraordinarily
    
    
     
      complicated snippet:
     
    
   </p>
   <pre class="source-code">
#include &lt;cstdio&gt;
#define STR_I(x) #x
#define STR(x) STR_I(x)
#define JOIN(x,y) (x y)
#define Hello(x) HELLO
int main(void){
    printf("%s\n", STR(JOIN(Hello, World)));
    printf("%s\n", STR(JOIN(Hello,World )));
}</pre>
   <p>
    
     The not-so-complex code defines a series of macros to manipulate strings and concatenate tokens.
    
    <strong class="source-inline">
     
      STR_I(x)
     
    </strong>
    
     stringifies its argument,
    
    <strong class="source-inline">
     
      STR(x)
     
    </strong>
    
     ensures full macro expansion before stringification,
    
    <strong class="source-inline">
     
      JOIN(x,y)
     
    </strong>
    
     concatenates two arguments with a space, and
    
    <strong class="source-inline">
     
      Hello(x)
     
    </strong>
    
     is defined but,
    
    
     
      strangely, unused.
     
    
   </p>
   <p>
    
     What comes up are two most important
    
    <strong class="source-inline">
     
      printf
     
    </strong>
    
     calls in the lifetime of this short program.
    
    
     In the first
    
    <strong class="source-inline">
     
      printf
     
    </strong>
    
     call,
    
    <strong class="source-inline">
     
      JOIN(Hello, World)
     
    </strong>
    
     expands to
    
    <strong class="source-inline">
     
      (Hello World)
     
    </strong>
    
     , which is then stringified to
    
    <strong class="source-inline">
     
      "(Hello World)"
     
    </strong>
    
     .
    
    
     That’s nothing
    
    
     
      overly complicated.
     
    
   </p>
   <p>
    
     However, the
    
    <a id="_idIndexMarker392">
    </a>
    
     fun part comes now: in the second
    
    <strong class="source-inline">
     
      printf
     
    </strong>
    
     call,
    
    <strong class="source-inline">
     
      JOIN(Hello,World)
     
    </strong>
    
     (without the space between the comma and
    
    <strong class="source-inline">
     
      World
     
    </strong>
    
     ) behaves differently depending on the
    
    
     
      GCC version.
     
    
   </p>
   <p>
    
     In GCC 9.4 (and below), this results in
    
    <strong class="source-inline">
     
      (HelloWorld)
     
    </strong>
    
     without a space, while in GCC 9.5 (and above), the preprocessor adds a space between the tokens, making both
    
    <strong class="source-inline">
     
      printf
     
    </strong>
    
     calls produce
    
    <strong class="source-inline">
     
      "(
     
    </strong>
    
     <strong class="source-inline">
      
       Hello World)"
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     This difference between GCC 9.4 and 9.5 stems from how each version handles token concatenation and whitespace between macro arguments, with GCC 9.4 not inserting spaces where none are explicitly given, and GCC 9.5 handling them more consistently by adding a space even when omitted in the
    
    
     
      macro invocation.
     
    
   </p>
   <p>
    
     While the C and C++ standards do not explicitly say “whitespace is ignored between macro arguments and commas,” it is implied by the way the preprocessor handles tokenization and macro expansion.
    
    
     Regardless, the rules state that arguments are separated by commas, and whitespace does not affect this separation.
    
    
     It seems that GCC (before 9.4) had a somewhat liberal interpretation of the lack of specification, which was re-interpreted in GCC 9.5
    
    
     
      and after.
     
    
   </p>
   <p>
    
     The whole misunderstanding is caused by the presence of the
    
    <strong class="source-inline">
     
      Hello
     
    </strong>
    
     macro, defined as a function-like macro, but used as a plain old replacement macro.
    
    
     It’s highly possible that the main issue is (or rather, was) a bug in older GCC, which certainly we do not use anymore, because we all know, that newer compilers are more standard compliant, and certainly, we all write standard compliant code,
    
    
     
      don’t we?
     
    
   </p>
   <p>
    
     That’s an interesting piece of historical
    
    
     
      forward compatibility.
     
    
   </p>
   <h2 id="_idParaDest-118">
    <a id="_idTextAnchor117">
    </a>
    
     The 11th guest
    
   </h2>
   <p>
    
     C++11 brought a range of new features while maintaining backward compatibility with C++98, ensuring that developers could adopt the modern capabilities incrementally without breaking existing code.
    
    
     One
    
    <a id="_idIndexMarker393">
    </a>
    
     of the most transformative additions was
    
    <strong class="bold">
     
      move semantics
     
    </strong>
    
     , which introduced some new syntax that C++98 compilers could not digest.
    
    
     This was facilitated by rvalue references, a syntax again not supported by
    
    
     
      older compilers.
     
    
   </p>
   <p>
    
     Similarly, the
    
    <strong class="source-inline">
     
      auto
     
    </strong>
    
     keyword simplified type declarations by automatically inferring types, yet developers could continue using it to explicitly specify that the variable has automatic storage, like they never did in C++98.
    
    
     This choice was made because let’s admit it, no one ever used auto as it was intended for in the C language (from where it was inherited, but even there it was still useless, unless in the B language, where it originated, as correctly denoting the storage for a variable:
    
    
     
      the stack).
     
    
   </p>
   <p>
    
     New syntax
    
    <a id="_idIndexMarker394">
    </a>
    
     such as
    
    <strong class="bold">
     
      range-based for loops
     
    </strong>
    
     allowed for cleaner iteration over containers, but the classic
    
    <strong class="source-inline">
     
      for
     
    </strong>
    
     loops from C++98 remained fully functional, thankfully, because lots of people still use them.
    
    
     The introduction of
    
    <strong class="source-inline">
     
      nullptr
     
    </strong>
    
     replaced the old
    
    <strong class="source-inline">
     
      NULL
     
    </strong>
    
     macro with a type-safe alternative, though
    
    <strong class="source-inline">
     
      NULL
     
    </strong>
    
     was still supported for backward compatibility, regardless of the fact that it was not that different
    
    
     
      from 0.
     
    
   </p>
   <p>
    
     In addition to these core language improvements, C++11 introduced
    
    <a id="_idIndexMarker395">
    </a>
    
     modern functional programming features
    
    <a id="_idIndexMarker396">
    </a>
    
     such as
    
    <strong class="bold">
     
      lambda expressions
     
    </strong>
    
     , which allowed anonymous functions to be written inline, facilitating cleaner and more
    
    
     
      concise code.
     
    
   </p>
   <p>
    
     The new
    
    <strong class="source-inline">
     
      constexpr
     
    </strong>
    
     feature
    
    <a id="_idIndexMarker397">
    </a>
    
     allowed certain functions to be evaluated at compile time, offering performance improvements, but developers could still rely on the C++98 approach of runtime function evaluation if needed with the use of overly complicated templated recursions because, well,
    
    <strong class="source-inline">
     
      constexpr
     
    </strong>
    
     is not supported by old
    
    
     
      compilers either.
     
    
   </p>
   <p>
    
     However, none of those groundbreaking changes can be more confusing to older users of C++ than the change of parsing for the C++ templates double right-angle brackets.
    
    
     In C++98, when using nested template arguments, the parser required spaces between consecutive right-angle brackets (
    
    <strong class="source-inline">
     
      &gt; &gt;
     
    </strong>
    
     ) to distinguish them from the shift operator (
    
    <strong class="source-inline">
     
      &gt;&gt;
     
    </strong>
    
     ).
    
    
     This was necessary because, in C++98, the parser would interpret two consecutive
    
    <strong class="source-inline">
     
      &gt;
     
    </strong>
    
     symbols as the bitwise right-shift operator rather than as the closing of two
    
    
     
      nested templates.
     
    
   </p>
   <p>
    
     In C++11 and later, the compiler is smart enough to recognize that in this context,
    
    <strong class="source-inline">
     
      &gt;&gt;
     
    </strong>
    
     refers to closing
    
    <a id="_idIndexMarker398">
    </a>
    
     two nested template brackets, not performing a right-shift operation.
    
    
     This makes the syntax cleaner and less error-prone, as developers no longer need to manually add spaces between right-angle brackets in nested template expressions.
    
    
     However, this also unfortunately means that the following program will display two different values depending on whether it was compiled with a compiler supporting C++11 standard, or with a compiler that only
    
    
     
      supports C++98:
     
    
   </p>
   <pre class="source-code">
#include &lt;iostream&gt;
const int value = 1;
template &lt;class T&gt;
struct D {
    operator bool() {return true;}
    static const int value = 2;
};
template&lt;int t&gt; struct C {
    typedef int value ;
};
int main() {
    const int x = 1;
    if(D&lt;C&lt; ::value&gt;&gt;::value&gt;::value&gt;::value) {
        std::cout &lt;&lt; "C++98 compiler";
    } else {
        std::cout &lt;&lt; "C++11 compiler";
    }
}</pre>
   <p>
    
     When we dig deeper into the intricacies of the program, it is perfectly clear why it has this strange behavior.
    
    
     If it is still not clear yet, let’s break
    
    
     
      it down.
     
    
   </p>
   <p>
    
     OK, let’s not break down the entire program.
    
    
     That would be too long.
    
    
     Instead, we’ll focus on just
    
    <strong class="source-inline">
     
      D&lt;C&lt; ::value&gt;&gt;::value&gt;::value&gt;::value
     
    </strong>
    
     , which is the key to all the
    
    
     
      feature identification.
     
    
   </p>
   <p>
    
     Using C++98 syntax, this
    
    <a id="_idIndexMarker399">
    </a>
    
     will be parsed
    
    
     
      as follows:
     
    
   </p>
   <pre class="source-code">
if(static_cast&lt;bool&gt;(D&lt;int&gt;::value)) { ... }</pre>
   <p>
    
     So, it all boils down to the value of
    
    <strong class="source-inline">
     
      D&lt;int&gt;::value
     
    </strong>
    
     due to the fact that
    
    <strong class="source-inline">
     
      ::value&gt;&gt;::value
     
    </strong>
    
     will be parsed as
    
    <strong class="source-inline">
     
      1 &gt;&gt; 1
     
    </strong>
    
     , resulting in
    
    <strong class="source-inline">
     
      0
     
    </strong>
    
     .
    
    
     This goes into
    
    <strong class="source-inline">
     
      C&lt;0&gt;::value
     
    </strong>
    
     , which is a plain
    
    <strong class="source-inline">
     
      typedef
     
    </strong>
    
     to
    
    <strong class="source-inline">
     
      int
     
    </strong>
    
     .
    
    
     From there, we
    
    
     
      reach
     
    
    
     <strong class="source-inline">
      
       D&lt;int&gt;::value
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Since we have defined it to be
    
    <strong class="source-inline">
     
      2
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      if
     
    </strong>
    
     certainly will be
    
    <strong class="source-inline">
     
      true
     
    </strong>
    
     , and we have executed the C++98
    
    
     
      identification branch.
     
    
   </p>
   <p>
    
     However, when
    
    <a id="_idIndexMarker400">
    </a>
    
     parsing the code with a C++11-compliant compiler, the expression will be parsed as the following, slightly more
    
    
     
      complex expression:
     
    
   </p>
   <pre class="source-code">
if((static_cast&lt;int&gt;(D&lt;C&lt;1&gt; &gt;::value &gt; ::value)) &gt; ::value) { ... }</pre>
   <p>
    
     As may not be obvious from the long and complex set of right-angle brackets, in the end, this will be parsed like two comparisons.
    
    
     That’s because the following
    
    <strong class="source-inline">
     
      D&lt;C&lt;1&gt;&gt;::value
     
    </strong>
    
     turns out to be
    
    <strong class="source-inline">
     
      2
     
    </strong>
    
     (because
    
    <strong class="source-inline">
     
      C&lt;1&gt;
     
    </strong>
    
     is also a type by itself, so we end up in a specialization of the
    
    <strong class="source-inline">
     
      D
     
    </strong>
    
     class with
    
    <strong class="source-inline">
     
      C&lt;1&gt;
     
    </strong>
    
     ).
    
    
     Then, this is compared to
    
    <strong class="source-inline">
     
      ::value
     
    </strong>
    
     , which will turn out to be true
    
    <strong class="source-inline">
     
      (2&gt;1)
     
    </strong>
    
     .
    
    
     From this, in the end, after a series of interesting conversions, the end result will look like
    
    <strong class="source-inline">
     
      1&gt;1
     
    </strong>
    
     .
    
    
     This turns out to be
    
    <strong class="source-inline">
     
      false
     
    </strong>
    
     ; hence, we enter the
    
    
     
      C++11 branch.
     
    
   </p>
   <p>
    
     With this in place, we have a nice and short, albeit overly complicated and useless, way to identify whether our code was compiled with a C++11 conforming compiler.
    
    
     However, checking for the value of
    
    <strong class="source-inline">
     
      __cplusplus
     
    </strong>
    
     is much easier than this and should be used in any
    
    
     
      production-ready code.
     
    
   </p>
   <h1 id="_idParaDest-119">
    <a id="_idTextAnchor118">
    </a>
    
     The auto surprise
    
   </h1>
   <p>
    
     If you, dear reader, do
    
    <a id="_idIndexMarker401">
    </a>
    
     remember that in
    
    <a href="B22235_09.xhtml#_idTextAnchor096">
     
      <em class="italic">
       
        Chapter 9
       
      </em>
     
    </a>
    
     , we had an interesting section called
    
    <em class="italic">
     
      The definition of zero
     
    </em>
    
     , then all is good.
    
    
     That’s because our next pitch will be about this highly influential number again.
    
    
     If you don’t remember that chapter, then life is still good, because hopefully, you have purchased a full book with all the chapters inside, and you can turn the pages back to read
    
    
     
      it (again).
     
    
   </p>
   <p>
    
     Let’s consider the
    
    
     
      following program:
     
    
   </p>
   <pre class="source-code">
#include &lt;iostream&gt;
#include &lt;typeinfo&gt;
#include &lt;string&gt;
template&lt;typename T&gt; std::string typeof(T t) {
    std::string res = typeid(t).name();
    return res;
}
int main() {
    auto a1 = 0;
    auto a2(0);
    auto a3 {0};
    auto a4 = {0};
    std::cout &lt;&lt; typeof(a1) &lt;&lt; std::endl
            &lt;&lt; typeof(a2) &lt;&lt; std::endl
            &lt;&lt; typeof(a3) &lt;&lt; std::endl
            &lt;&lt; typeof(a4) &lt;&lt; std::endl;
}</pre>
   <p>
    
     The
    
    <a id="_idIndexMarker402">
    </a>
    
     program is not an overly complicated one again.
    
    
     It just uses the fancy
    
    <strong class="source-inline">
     
      auto
     
    </strong>
    
     keyword and initializes variables to
    
    <strong class="source-inline">
     
      0
     
    </strong>
    
     using all kinds of mechanisms, mostly presented in the chapter mentioned earlier.
    
    
     If you do not know what the
    
    <strong class="source-inline">
     
      auto
     
    </strong>
    
     keyword does, then here is a short recap: the
    
    <strong class="source-inline">
     
      auto
     
    </strong>
    
     keyword in C++11 was hijacked from C, and its new role is to allow automatic type inference, enabling the compiler to deduce the type of a variable based on its initializer.
    
    
     This simplifies code by removing the need for explicit type declarations, and shortens the handling of complex or verbose types, such as iterators or
    
    
     
      templated types.
     
    
   </p>
   <p>
    
     Anyway, back to our code.
    
    
     After careful consideration, we can conclude
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       auto a1 = 0;
      
     </strong>
     
      : For this simple case,
     
     <strong class="source-inline">
      
       a1
      
     </strong>
     
      is deduced to be
     
     <strong class="source-inline">
      
       int
      
     </strong>
     
      since 0 is an integer literal.
     
     
      This is a straightforward
     
     
      
       copy initialization.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       auto a2(0);
      
     </strong>
     
      : Again, a simple one,
     
     <strong class="source-inline">
      
       a2
      
     </strong>
     
      is also deduced to be
     
     <strong class="source-inline">
      
       int
      
     </strong>
     
      because 0 is directly initialized as an
     
     
      
       integer literal.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       auto a3 {0};
      
     </strong>
     
      : Then,
     
     <strong class="source-inline">
      
       a3
      
     </strong>
     
      is deduced to be
     
     <strong class="source-inline">
      
       int
      
     </strong>
     
      , as the
     
     <strong class="source-inline">
      
       {0}
      
     </strong>
     
      list initialization initializes it to
     
     
      
       an integer.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       auto a4 = {0};
      
     </strong>
     
      : This is a bit tricky, however.
     
     
      For this case,
     
     <strong class="source-inline">
      
       a4
      
     </strong>
     
      is deduced to be
     
     <strong class="source-inline">
      
       std::initializer_list&lt;int&gt;
      
     </strong>
     
      because
     
     <strong class="source-inline">
      
       auto
      
     </strong>
     
      with brace initialization deduces an
     
     <strong class="source-inline">
      
       initializer_list
      
     </strong>
     
      .
     
     
      This is a special rule for
     
     <strong class="source-inline">
      
       auto
      
     </strong>
     
      when used with
     
     
      
       brace-enclosed initializers.
      
     
    </li>
   </ul>
   <p>
    
     The output of the
    
    <a id="_idIndexMarker403">
    </a>
    
     program using MSVC is
    
    
     
      the following:
     
    
   </p>
   <pre class="source-code">
int
int
int
class std::initializer_list&lt;int&gt;</pre>
   <p>
    
     Using GCC (recent/decent versions), the output will be a bit less verbose, but you get
    
    
     
      the idea:
     
    
   </p>
   <pre class="source-code">
i
i
i
St16initializer_listIiE</pre>
   <p>
    
     However, there is a catch.
    
    
     If we compile this piece of code with GCC versions older than version 5.0 we get an ugly surprise.
    
    
     The output is
    
    
     
      as follows:
     
    
   </p>
   <pre class="source-code">
i
i
St16initializer_listIiE
St16initializer_listIiE</pre>
   <p>
    
     What an unexpected surprise of backward compatibility.
    
    
     The real help comes from clang (3.7), however.
    
    
     If we compile the program with it, we get the following rather
    
    
     
      helpful message:
     
    
   </p>
   <pre class="source-code">
&lt;source&gt;:19:13: warning: direct list initialization of a variable with a deduced type will change meaning in a future version of Clang; insert an '=' to avoid a change in behavior [-Wfuture-compat]
    auto a3 {0};</pre>
   <p>
    
     So, it seems that at some
    
    <a id="_idIndexMarker404">
    </a>
    
     stage during its evolution, the meaning of
    
    <strong class="source-inline">
     
      {x}
     
    </strong>
    
     combined with
    
    <strong class="source-inline">
     
      auto
     
    </strong>
    
     but not
    
    <strong class="source-inline">
     
      =
     
    </strong>
    
     , in this very specific scenario, has changed (around the birth date of C++17).
    
    
     However, thankfully, early compilers had thought of this peculiar scenario, with this very specific and direct warning.
    
    
     Very backward compatible,
    
    
     
      isn’t it?
     
    
   </p>
   <p>
    
     So, with all this in mind, it should not come as a huge surprise that the following code does not even compile (considering that we are still in the confines of our previous
    
    
     
      short program):
     
    
   </p>
   <pre class="source-code">
std::cout &lt;&lt; typeof( {0} );</pre>
   <p>
    
     Why should it?
    
    
     Which type would
    
    <strong class="source-inline">
     
      {0}
     
    </strong>
    
     be deduced to, considering all the chaos and mayhem with the preceding syntax?
    
    
     Would it be deduced to an
    
    <strong class="source-inline">
     
      int
     
    </strong>
    
     type?
    
    
     Or maybe to an
    
    <strong class="source-inline">
     
      initializer_list
     
    </strong>
    
     type?
    
    
     Would it be a null pointer (
    
    <strong class="source-inline">
     
      nullptr
     
    </strong>
    
     )?
    
    
     Or an object that can be built from a number, like
    
    
     
      the following:
     
    
   </p>
   <pre class="source-code">
struct D { D(int i) {} };
void fun(D d) { }
fun({0});</pre>
   <p>
    
     Or is this not so
    
    
     
      fun anymore?
     
    
   </p>
   <h1 id="_idParaDest-120">
    <a id="_idTextAnchor119">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     In this chapter, we learned that C++ has evolved and diverged significantly from its humble C (as well as B and BCPL) origins.
    
    
     We learned that C++ has introduced modern features and stricter rules to enhance safety and efficiency, and to support modern programming paradigms.
    
    
     While it maintains much of C’s syntax, the two languages have heavily branched off over time, leading to compatibility challenges, especially when mixing older C code with features requiring newer C++ standards.
    
    
     We discussed this extensively in
    
    
     
      this chapter.
     
    
   </p>
   <p>
    
     Within modern C++ itself, the introduction of features such as move semantics, stricter template parsing, and changes in the behavior of keywords such as
    
    <strong class="source-inline">
     
      auto
     
    </strong>
    
     have added layers of complexity (not that there were not enough).
    
    
     We also learned this in
    
    
     
      this chapter.
     
    
   </p>
   <p>
    
     Despite these challenges, we explored the fact that C++ continues to build on its rich legacy, offering powerful tools for developers while requiring careful attention to evolving standards and backward compatibility without incurring too much contradiction with its previous self.
    
    
     It remains a language where tradition and innovation meet, often in unexpected and
    
    
     
      fascinating ways.
     
    
   </p>
   <p>
    
     But for how long?
    
    
     Will it survive the surfacing threat of the new kid on the block?
    
    
     Will Rust replace C++?
    
    
     That’s up to you, dear reader, and it will be detailedly debated by Alex in our
    
    
     
      next chapter.
     
    
   </p>
  </div>
 </body></html>