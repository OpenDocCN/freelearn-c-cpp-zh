- en: 3D Graphics with Qt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many modern games take place in 3D worlds. Graphics processing units are constantly
    evolving, allowing developers to create more and more visually appealing and detailed
    worlds. While you can use OpenGL or Vulkan directly to render 3D objects, this
    can prove to be quite challenging. Luckily, the Qt 3D module provides an implementation
    of 3D rendering with a high-level API. In this chapter, we'll learn to use its
    capabilities and see how we can create a 3D game with Qt.
  prefs: []
  type: TYPE_NORMAL
- en: Qt 3D is not limited to rendering. You'll also learn to handle user input and
    implement game logic in a 3D game. Qt 3D was designed to be highly efficient and
    fully extensible, so it allows you to implement your own additions to all Qt 3D
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: Qt 3D offers both C++ and QML API with mostly equivalent functionality. While
    the C++ API allows you to modify and extend the implementation, we will use the
    QML approach, that will allow us to write clean and declarative code and use the
    techniques we've learned in the previous chapters. By combining Qt 3D with the
    powers of QML, you will be able to make amazing games in no time!
  prefs: []
  type: TYPE_NORMAL
- en: 'The main topics covered in this chapter are:'
  prefs: []
  type: TYPE_NORMAL
- en: Rendering 3D objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling user input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing animations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration with 3D editors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Qt 3D using C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration with Qt Widgets and Qt Quick
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Qt 3D overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we see Qt 3D in action, let's go through the important parts of its architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Entities and components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt 3D is not just a 3D rendering tool. When sufficiently evolved, it can become
    a full-featured game engine. This is supported by its original architecture. Qt
    3D introduces a new set of abstractions that are particularly useful for its task.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that most of the Qt API heavily uses inheritance. For example,
    each widget type is derived from `QWidget`, which in turn is derived from `QObject`.
    Qt forms large family trees of classes to provide common and specialized behavior.
    In contrast, elements of a Qt 3D scene are constructed using **composition** instead
    of inheritance. A single part of a Qt 3D scene is called an **entity** and represented
    by the `Entity` type. However, an `Entity` object by itself doesn't have any particular
    effect or behavior. You can add pieces of behavior to an entity in the form of
    **components**.
  prefs: []
  type: TYPE_NORMAL
- en: Each component controls some part of the entity's behavior. For example, the
    `Transform` component controls the entity's position within the scene, the `Mesh`
    component defines its shape, and the `Material` component controls the properties
    of the surface. This approach allows you to assemble entities from only the components
    that you need. For example, if you need to add a light source to the scene, you
    can create an entity with the `PointLight` component. You still want to choose
    a location of the light source, so you'll need the `Transform` component as well.
    However, `Mesh` and `Material` components do not make sense for a light source,
    so you don't need to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Entities are arranged in a classic parent–child relationship, like any other
    QML objects or QObjects. A tree of entities form a Qt 3D scene. The topmost entity
    is usually responsible for defining scene-wide configuration. These settings are
    specified by attaching special components (such as `RenderSettings` and `InputSettings`)
    to the top level `Entity`.
  prefs: []
  type: TYPE_NORMAL
- en: Qt 3D modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt 3D is split into a number of modules that you can choose to use in your project. It
    may be hard to see which of them you need, so let's see what each module is made
    for.
  prefs: []
  type: TYPE_NORMAL
- en: Stable modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Qt3DCore` module implements the base structure of Qt 3D. It provides `Entity`
    and `Component` types, as well as base classes for other Qt 3D systems. `Qt3DCore`
    itself does not implement any behavior, providing only the framework that's used
    by other modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Qt3DRender` module implements 3D rendering, so it''s one of the most feature-rich
    modules. Let''s list some important pieces of its functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GeometryRenderer` is the base component type that defines the visible shape
    of an entity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Mesh` component allows you to import the entity's geometry from a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Material` component is the base component type that defines visible properties
    of the entity's surface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `SceneLoader` component allows you to import a hierarchy of entities with
    meshes and materials from a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Light components (`DirectionalLight`, `EnvironmentLight`, `PointLight`, and `SpotLight`)
    allow you to control the scene's lighting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `FrameGraph` API provides a way of defining how exactly your scene should
    be rendered. It allows you to set up the camera, implement multiple viewports,
    shadow mapping, custom shaders, and much more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ObjectPicker` component allows you to find out which entities are positioned
    at a particular window point.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, `Qt3DLogic` is a very small module that provides the `FrameAction` component.
    This component allows you to execute an arbitrary action for each frame of your
    entity.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `Qt3DInput` module is focused on user input. It provides a few
    components that allow you to handle keyboard and mouse events in your game. `Qt3DInput`
    also contains types that can be used to configure the input devices.
  prefs: []
  type: TYPE_NORMAL
- en: Experimental modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the time of writing, all the other Qt 3D modules are still in **tech preview**,
    so their API may be incomplete. Future Qt versions may introduce incompatible
    changes in these modules, so don't be surprised if you need to make a few changes
    in the provided code to make it work (our code was tested on Qt 5.10). These modules
    should eventually be stabilized in the future, so you should check the Qt documentation
    to find out their current status.
  prefs: []
  type: TYPE_NORMAL
- en: The `Qt3DAnimation` module, as the name implies, is responsible for animations
    in the Qt 3D scene. It's able to handle keyframe animations on the entity's `Transform`
    component, as well as blend-shape and vertex-blend animations. However, we won't
    be using this module in this chapter, as the already familiar animation framework
    of Qt Quick is more than enough for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Qt3DExtras` module provides components that are not strictly necessary
    for working with Qt 3D, but are very useful for building first simple projects.
    They are:'
  prefs: []
  type: TYPE_NORMAL
- en: Mesh generators for basic geometric shapes (cubes, spheres, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ExtrudedTextMesh` component that allows you to show 3D text in the scene
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many standard material components, such as `DiffuseSpecularMaterial` and `GoochMaterial`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additionally, `Qt3DExtras` provides two convenience classes that allow the
    user to control the position of the camera using mouse and keyboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OrbitCameraController` moves the camera along an orbital path'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FirstPersonCameraController` moves the camera as in a first-person game'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Qt3DQuickExtras` module provides the `Qt3DExtras::Quick::Qt3DQuickWindow`
    C++ class. This is a window that displays a QML-based Qt 3D scene.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `Qt3DQuickScene2D` module provides the ability to embed Qt Quick
    items into the Qt 3D scene, and the `QtQuick.Scene3D` QML module allows you to
    embed a Qt 3D scene into a Qt Quick application.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the capabilities of Qt 3D are not limited by rendering. You
    can also use it to handle user input and implement the game logic for your entities.
    Qt 3D is fully extensible, so you can use its C++ API to implement your own components,
    or modify existing ones. However, we will mainly use the QML-based API in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note that Qt 3D objects are not Qt Quick items, so not all Qt Quick capabilities
    are open for you when you work with Qt 3D. For example, you can't use `Repeater`
    to instantiate multiple Qt 3D entities. However, you can still use Qt Quick animations
    because they can handle any QML objects. It's also possible to embed a Qt 3D scene
    into a Qt Quick interface using the `Scene3D` QML type.
  prefs: []
  type: TYPE_NORMAL
- en: Using modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before using each of the Qt 3D modules, you have to enable the module separately
    in the project file. For example, the following line will enable all currently
    documented modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When using QML, each module must also be separately imported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can see that different Qt 3D modules have different QML module versions.
    Some modules were updated in Qt 5.10 and have new features that we'd like to use
    in our code, so you have to specify the last version (2.10) to make new QML types
    available. On the other hand, some modules weren't updated, so 2.0 is the only
    available version. The up-to-date versions will change in the future as new Qt
    releases come out. The Qt documentation should hopefully contain the correct import
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: All C++ types of a Qt 3D module are placed in a namespace. In other regards,
    Qt naming conventions apply. For example, the `Entity` QML type corresponds to
    the `QEntity` C++ class in the `Qt3DCore` namespace. The corresponding include
    directive is `#include <QEntity>`.
  prefs: []
  type: TYPE_NORMAL
- en: Qt 3D also introduces a concept of **aspects**. An aspect is simply a piece
    of behavior that can be added to the Qt 3D engine. The `Qt3DQuickWindow` class
    contains a built-in aspect engine that automatically enables `QRenderAspect`, `QInputAspect`,
    and `QLogicAspect` aspects, allowing Qt 3D to render the scene, process user input,
    and execute frame actions. If you decide to use the `Qt3DAnimation` module, you
    should also enable `QAnimationAspect`. You can do that using the `Qt3DWindow::registerAspect()`
    method. Other Qt 3D modules don't require a separate aspect. It's also possible
    to create a new aspect, but it's usually not necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering 3D objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each item of the Qt 3D scene is represented by the `Entity` type. However, not
    all entities are visible 3D objects. In order for an entity to be visible, it
    has to have a **mesh** component and a **material** component.
  prefs: []
  type: TYPE_NORMAL
- en: Mesh, material, and transform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The mesh defines the geometrical shape of the entity. It contains information
    about vertices, edges, and faces required to render the object. The base type
    of all mesh components is `GeometryRenderer`. However, you''ll usually use one
    of its descendants:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Mesh` imports geometry data from a file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConeMesh`, `CuboidMesh`, `CylinderMesh`, `PlaneMesh`, `SphereMesh`, and `TorusMesh` provide
    access to primitive geometric shapes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ExtrudedTextMesh` defines the entity''s shape based on a specified text and
    font'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While the mesh defines where the object''s surface will be drawn, the material
    defines how exactly it will be drawn. The most obvious property of a surface is
    its color, but depending on the reflection model, there can be all sorts of properties,
    such as coefficients of diffuse and specular reflection. Qt 3D provides a lot
    of different material types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PerVertexColorMaterial` allows you to set color properties for each vertex
    and renders ambient and diffuse reflections'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TextureMaterial` renders a texture and ignores lighting'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DiffuseSpecularMaterial` implements the Phong reflection model and allows
    you to set ambient, diffuse, and specular components of the reflection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GoochMaterial` implements the Gooch shading model'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MetalRoughMaterial` renders a metal-like surface using PBR (physically based
    rendering)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MorphPhongMaterial` also follows the Phong reflection model but also supports
    morph animations of the `Qt3DAnimation` module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third common component of a visible 3D object is `Transform`. While not
    strictly required, it's usually necessary for setting the position of the object
    in the scene. You can set the position using the `translation` property. It's
    also possible to scale the object using the `scale3D` property that allows you
    to set different scale coefficients for each `axis`, or the `scale` property that
    accepts a single coefficient that applies to all axes. Similarly, you can either
    set the rotation quaternion using the `rotation` property or set individual Euler
    angles using `rotationX`, `rotationY`, and `rotationZ` properties. Finally, you
    can set the `matrix` property to apply an arbitrary transformation matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Note that transformations apply not only to the current entity, but to all its
    children as well.
  prefs: []
  type: TYPE_NORMAL
- en: Lighting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some of the available materials will take the lighting into account. Qt 3D allows
    you to add different types of lights to the scene and configure them. You can
    do that by adding a new `Entity` to the scene and attaching a `DirectionalLight`, `PointLight`,
    or `SpotLight` component to it. Each of these components has the `color` property
    that allows you to configure the color of the light and the `intensity` property
    that allows you to choose how bright the light is. The rest of the properties
    are specific to the light type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Directional light** (also called "distant light" or "sunlight") casts parallel
    rays in the direction defined by the `worldDirection` property of the `DirectionalLight`
    type. Position and rotation of the entity have no influence on the lighting effect
    of a directional light, so there is no need for a `Transform` component.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Point light** emits light from its position in all directions. The position
    of the light can be changed via the `Transform` component attached to the same
    entity. The `PointLight` component allows you to configure how bright the light
    will be at a distance by setting the `constantAttenuation`, `linearAttenuation`,
    and `quadraticAttenuation` properties.'
  prefs: []
  type: TYPE_NORMAL
- en: While point light can be interpreted as a sphere of light, **spotlight** is
    a cone of light. It emits light from its position, but the directions are limited
    by the `localDirection` property that defines where the spotlight is facing and
    the `cutOffAngle` property that configures how wide the light cone is. The position
    and direction of the spotlight can be influenced by the translation and rotation
    of the `Transform` component attached to the same entity. `SpotLight` also has
    the same attenuation properties as `PointLight`.
  prefs: []
  type: TYPE_NORMAL
- en: If no lights are present in the scene, Qt will automatically add an implicit
    point light so that the scene is somewhat visible.
  prefs: []
  type: TYPE_NORMAL
- en: The fourth type of light is different from the others. It's called **environment
    light** and can be configured by adding the `EnvironmentLight` component to an
    entity. It defines the surrounding lighting of the scene using two textures assigned
    to its `irradiance` and `specular` properties. Unlike other light types, this
    component does not have `color` or `intensity` properties. There can only be one
    environment light in a scene.
  prefs: []
  type: TYPE_NORMAL
- en: Note that light sources themselves are invisible. Their only purpose is to influence
    the appearance of 3D objects that use certain material types.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating a 3D scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will create an implementation of the famous Tower of Hanoi
    game. This puzzle game contains three rods and multiple disks of different sizes.
    The disks can slide onto the rods, but a disk cannot be placed on top of a smaller
    disk. At the starting position, all the rods are placed on one of the disks. The
    goal is to move them all to another rod. The player can only move one disk at
    a time.
  prefs: []
  type: TYPE_NORMAL
- en: As usual, you will find the complete project in the resources that come with
    the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Qt Quick Application - Empty project and call it `hanoi`. While
    we will use some Qt Quick utilities, our project will not really be based on Qt
    Quick. Qt 3D will do most of the work. Nevertheless, the Qt Quick Application
    - Empty is the most suitable of currently present templates, so we choose to use
    it. Edit the `hanoi.pro` file to enable the Qt modules that we''ll need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use the `Qt3DQuickWindow` class to instantiate our QML objects instead
    of the `QQmlApplicationEngine` class we usually use with Qt Quick. To do that,
    replace the `main.cpp` file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, replace the `main.qml` file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This code declares a single `Entity` object that contains two components. The 
    `RenderSettings` component defines how Qt 3D should render the scene. The `activeFrameGraph`
    property of `RenderSettings` can hold a tree of render operations, but the simplest
    possible frame graph is a single `ForwardRenderer` object that takes care of all
    the rendering. `ForwardRenderer` renders objects one by one directly to the OpenGL
    framebuffer. We use the `clearColor` property to set the background color of our
    scene to black. The `camera` property of the `ForwardRenderer` holds the `Camera`
    object it will use for calculating the transformation matrix. Let''s go through
    the properties of the `Camera` object we''ve used in our code:'
  prefs: []
  type: TYPE_NORMAL
- en: The `projectionType` property defines the type of the projection. Besides the `PerspectiveProjection`,
    you can use `OrthographicProjection`,  `FrustumProjection`, or  `CustomProjection`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `fieldOfView` property contains the field of view parameter of the perspective
    projection. You can change it to achieve a zoom in/out effect.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `nearPlane` and `farPlane` properties define the positions of the nearest
    and the furthest planes that will be visible in the camera (they correspond to
    the visible *z* axis values in the viewport coordinates).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `position` vector defines the position of the camera in the world coordinates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `upVector` vector in the world coordinates is the vector that would appear
    pointing up when viewing it through the camera.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `viewCenter` vector in the world coordinates is the point that will appear
    in the center of the viewport.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When using the perspective projection, you usually need to set the aspect ratio
    according to the window size. The `Camera` object has the `aspectRatio` property
    for that, but we don't need to set it, since the `Qt3DQuickWindow` object will
    update this property automatically.
  prefs: []
  type: TYPE_NORMAL
- en: You can disable this feature by adding  `window.setCameraAspectRatioMode(Qt3DExtras::Quick::Qt3DQuickWindow::UserAspectRatio)`
    to the `main.cpp` file.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to use an orthographic projection instead of a perspective one,
    you can use the `top`, `left`, `bottom`, and `right` properties of the `Camera`
    object to set the visible area.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the second component of our `Entity` is the `InputSettings` component.
    Its `eventSource` property should point to the object that provides the input
    events. As with `aspectRatio`, we don't need to set this property manually. The `Qt3DQuickWindow`
    will find the `InputSettings` object and set itself as the `eventSource`.
  prefs: []
  type: TYPE_NORMAL
- en: You can run the project to verify that it compiles successfully and doesn't
    produce any runtime errors. You should receive an empty black window as a result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s add something visible to our scene. Edit the `main.qml` file to
    add a few child objects to the root `Entity`, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result, you should see a cube at the center of the window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c4641a69-bed6-448d-8a8e-5091b7237f54.png)'
  prefs: []
  type: TYPE_IMG
- en: More than that, you can use the arrow keys, the **Page Up** and **Page Down**
    keys, and the left mouse button to move the camera around.
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We added a few objects to our scene graph. First, the `FirstPersonCameraController`
    object allows the user to freely control the camera. This is quite useful for
    testing the game while you don't have your own camera controlling code yet. Next,
    an entity with a single `DirectionalLight` component works as a light source in
    the scene. We use the properties of this component to set the color, intensity,
    and direction of the light.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we added an entity that represents a regular 3D object. Its shape is
    provided by the `CuboidMesh` component that generates a unit cube. The appearance
    of its surface is defined by the `DiffuseSpecularMaterial` component that conforms
    to the widely used Phong reflection model. You can use `ambient`, `diffuse`, and `specular` color
    properties to control different components of the reflected light. The `shininess`
    property defines how smooth the surface is. We use the `Transform` component to
    scale the cube to a larger size.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – constructing the Tower of Hanoi scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our next task will be to create a foundation and three rods for our puzzle.
    We will take advantage of QML''s modular system and split our code into multiple
    components. First, let''s leave camera and lighting settings in the `main.qml`
    and put our actual scene content to a new `Scene` component. In order to do that,
    put the text cursor onto the Entity declaration of the cube, press *Alt* + *Enter*
    and select Move Component into Separate File. Input `Scene` as the component name
    and confirm the operation. Qt Creator will create a new `Scene.qml` file and add
    it to the project''s resources. The `main.qml` now contains just an instantiation
    of our scene component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The actual properties of the entity are moved to the `Scene.qml` file. Let''s
    adjust it to the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Our scene will contain multiple items, so we introduced a new `Entity` object
    and called it `sceneRoot`. This entity doesn't have any components, so it will
    not have any visible effect on the scene. This is similar to how an object of `Item` type
    usually serves as a container for Qt Quick items without providing any visual
    content.
  prefs: []
  type: TYPE_NORMAL
- en: The cube entity is now a child of `sceneRoot`. We use the `scale3D` property
    of the `Transform` component to change the dimensions of our cube. Now it looks
    like a tabletop that will serve as a foundation for the rest of the objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s work on the rods. Naturally, we want to have a `Rod` component because
    it is a repeating part of our scene. Invoke the context menu of `qml.qrc` in the
    project tree and choose Add New. From the Qt category, choose QML File (Qt Quick
    2) and input `Rod` as the filename. Let''s see how we can implement this component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the cube entity, our rod consists of a mesh, a material, and a `Transform`
    component. Instead of the `CubeMesh`, we use the `CylinderMesh` component that
    will create a cylinder for us. The `radius` and `length` properties define the
    dimensions of the object, and the `slices` property impacts the number of generated
    triangles. We chose to increase the number of slices to make the cylinders look
    better, but be aware that it has a performance impact that may become noticeable
    if you have many objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `Rod` component has the index property that contains the positional number
    of the rod. We use this property to calculate the *x* and *z* coordinates of the
    rod so that all three rods are placed on a circle with an eight radius. The *y*
    coordinate is set to ensure that the rod is positioned on top of the foundation.
    We assign the calculated position vector to the `translation` property of the
    `Transform` component. Finally, add three `Rod` objects to the `Scene.qml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the project, you should see the foundation and the rods:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d5089464-00d9-4aff-a550-47bd14caa50d.png)'
  prefs: []
  type: TYPE_IMG
- en: Time for action – repeating 3D objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our code works, but the way we create the rods is not ideal. First, enumerating
    rods and their indices in `Scene.qml` is inconvenient and error-prone. Second,
    we'll need to have a way to access a `Rod` object by its index, and the current
    approach doesn't allow that. In the previous chapters, we dealt with repeating
    Qt Quick objects using the `Repeater` QML type. However, `Repeater` doesn't work
    for `Entity` objects. It's only able to handle types that inherit from Qt Quick
    `Item`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to our problem is already familiar to you since [Chapter 12](4fdfe294-c35c-476d-9656-0aefd533e491.xhtml)*,
    Customization in Qt Quick*. We can create QML objects using imperative JavaScript
    code. Remove `Rod` objects from the `Scene.qml` file and make the following additions
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: What just happened?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we created a property called `rods` that will hold an array of created
    `Rod` objects. Next, we used the `Component.onCompleted` attached property to
    run some JavaScript code after the QML engine instantiates our root object. Our
    first action was to load the `Rod` component and check whether it was loaded successfully.
    After obtaining a functioning component object, we used its `createObject()` method
    to create three new rods. We used the arguments of this function to pass the root
    object and value of the `index` property. Finally, we pushed the `Rod` object
    into the array.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating disks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our next task is to create eight disks that will slide onto rods. We''ll do
    it in a similar way to how we handled rods. First, create a new file called `Disk.qml`
    for our new component. Put the following content into the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Like rods, disks are identified by their index. In this case, index influences
    the color and size of the disk. We calculate the disk's color using the `Qt.hsla()`
    function that takes hue, saturation, and lightness values and returns a `color`
    value that can be assigned to the `ambient` property of the material. This formula
    will give us eight colorful disks of different hues.
  prefs: []
  type: TYPE_NORMAL
- en: The position of the disk is defined by the `translation` property of the `Transform`
    component. We want to be able to read and change the position of the disk from
    the outside, so we set up a property alias called `pos` that exposes the `transform.translation`
    property value.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use the `TorusMesh` component to define the shape of our disks. A torus
    shape is not really suitable for playing the Tower of Hanoi game in reality, but
    it will have to do for now. Later in this chapter, we'll replace it with a more
    suitable shape. The properties of the `TorusMesh` component allow us to adjust
    some of its measurements, but we also have to apply rotation and scale to the
    object to achieve the desired size and position.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of putting all the disk objects into a single array, let''s create
    an array for each rod. When we move a disk from one rod to another one, we''ll
    remove the disk from the first rod''s array and add it to the second rod''s array.
    We can do that by adding a property to the `Rod` component. While we''re at it,
    we should also expose the rod''s position to the outside. We''ll need it to position
    the disks on the rods. Declare the following properties in the top level `Entity`
    in `Rod.qml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `pos` property will follow the value of the `translation` property of the
    `Transform` component. Since this value is calculated based on the `index` property,
    we declare the `pos` property as `readonly`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to adjust the `Component.onCompleted` handler of the `Scene`
    component. Initialize the `diskComponent` variable, just like we did with `rodComponent`.
    Then you can create disks using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: After creating each disk, we set its position based on its index and the position
    of the chosen rod. We accumulate all disks in the `disks` property of the rod.
    We choose the order of disks in the array so that the bottom disk is at the beginning
    and the top disk is at the end. The `unshift()` function adds the item to the
    array at the beginning, giving the desired order.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the project, you should see all eight tori on one of the rods:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/140c44d4-992a-40ee-ae7d-dc71c062cd55.png)'
  prefs: []
  type: TYPE_IMG
- en: The next piece of functionality we'll need is the ability to move disks from
    one rod to another. However, it's the player who makes the decision, so we'll
    also need some way to receive input from the user. Let's see what options we have
    for handling user input.
  prefs: []
  type: TYPE_NORMAL
- en: Handling user input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first way of receiving events in Qt 3D is to use Qt GUI capabilities. The `Qt3DQuickWindow`
    class we use inherits from `QWindow`. That allows you to subclass `Qt3DQuickWindow`
    and reimplement some of its virtual functions, such as `keyPressEvent()` or `mouseMoveEvent()`. You
    are already familiar with this part of Qt API because it's roughly the same as
    provided by Qt Widgets and Graphics View. Qt 3D doesn't introduce anything special
    here, so we won't give this approach much attention.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to Qt Quick, Qt 3D introduces a higher-level API for receiving input
    events. Let's see how we can use it.
  prefs: []
  type: TYPE_NORMAL
- en: Devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Qt 3D is focused on providing a good abstraction for every aspect it handles.
    This applies to input as well. In terms of Qt 3D, an application may have access
    to an arbitrary number of **physical devices**. They are represented by the `AbstractPhysicalDevice`
    type. At the time of writing, there are two built-in types of physical devices:
    keyboard and mouse. You can access them by declaring an object of `KeyboardDevice`
    or `MouseDevice` type in your QML file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use properties of the device object to configure its behavior. There
    is currently only one such property: the `MouseDevice` type has a `sensitivity`
    property that affects how mouse movement is converted to axis inputs.'
  prefs: []
  type: TYPE_NORMAL
- en: It's allowed to create multiple objects of the same device type in a single
    application. All devices will handle all received inputs, but you can set different
    values of properties for different device objects.
  prefs: []
  type: TYPE_NORMAL
- en: You typically don't want to handle events directly from the physical devices.
    Instead, you should set up a **logical device** that receives events from the
    physical devices and converts them to actions and inputs that make sense for your
    application. You can specify a set of **actions** and **axes** for your device
    using the `actions` and `axes` properties of the `LogicalDevice` type, and Qt
    3D will recognize the described inputs and notify your objects about them.
  prefs: []
  type: TYPE_NORMAL
- en: We will provide a few code examples to demonstrate how to handle various kinds
    of input in Qt 3D. You can test the code by putting it into the `main.qml` file
    of the `hanoi` project or create a separate project for that.
  prefs: []
  type: TYPE_NORMAL
- en: Keyboard and mouse buttons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An action is represented by the `Action` type. An action can be triggered by
    pressing a single key, a key combination, or a key sequence. This is defined by
    the `inputs` property of the `Action` type. The most simple kind of input is `ActionInput`
    which reacts to a single key.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the action is triggered, its `active` property will change from `false`
    to `true`. When the corresponding key or key combination is released, `active`
    changes back to `false`. You can use the usual QML features to track changes of
    the property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, keyboard and mouse button events are handled in the same way.
    However, they come from different physical devices, so make sure you specify the
    correct device in the `sourceDevice` property of `ActionInput`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can specify multiple buttons for `ActionInput`. In this case, the action
    will trigger if any of the specified buttons are pressed. For example, use the
    following code to handle both the main *Enter* key and the *Enter* key on the
    keypad:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note that it's not required to put the input handling code into the root object
    of the scene. You can put it into any `Entity`. It's also possible to have multiple
    entities handling input events at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Input chords
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `InputChord` type allows you to trigger an action when multiple keys are
    pressed at the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `onActiveChanged` handler will be called when *Q*, *W*, and *E* keys are
    pressed within 500 milliseconds and held together.
  prefs: []
  type: TYPE_NORMAL
- en: Analog (axis) input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Axis** in Qt 3D is an abstraction of analog one-dimensional input. A typical
    source of axis input is an analog stick of a gamepad. As the name implies, `Axis`
    only represents movement along a single axis, so a stick can be represented by
    two axes—one for vertical movement and one for horizontal movement. A pressure-sensitive
    button can be represented by a single axis. An axis input produces a `float` value
    ranging from −1 to 1, with zero corresponding to the neutral position.'
  prefs: []
  type: TYPE_NORMAL
- en: That being said, there is no gamepad support in Qt 3D at the time of writing.
    It's possible that it will be added in future versions. You can also use the extensible C++
    API of Qt 3D to implement the gamepad device using Qt Gamepad. However, the simplest
    solution is to use Qt Gamepad directly. Nothing prevents you from using QML or
    C++ API of Qt Gamepad in an application that uses Qt 3D.
  prefs: []
  type: TYPE_NORMAL
- en: The `inputs` property of the `Axis` type allows you to specify which input events
    should be redirected to this axis. You can use the `AnalogAxisInput` type to access
    the axis data provided by a physical device. The `MouseDevice` provides four virtual
    axes that are emulated based on the mouse input. Two of them are based on the
    vertical and horizontal scroll. Two others are based on vertical and horizontal
    pointer movement, but they only work while any mouse button is pressed.
  prefs: []
  type: TYPE_NORMAL
- en: The `ButtonAxisInput` type allows you to emulate an axis based on the button
    pressed. You can use the `scale` property to set the axis value corresponding
    to each button. When multiple buttons are pressed together, the mean of their
    axis values is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both mouse-based and button-based axes are demonstrated in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Object picker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Object picker is a component that allows an entity to interact with the mouse
    pointer. This component does not interact with the previously described input
    API directly. For example, you don''t need to provide a mouse device for it. All
    you need to do is to attach the `ObjectPicker` component to an entity that also
    contains a mesh. The signals from `ObjectPicker` will notify you about input events
    related to this entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Signal** | **Explanation** |'
  prefs: []
  type: TYPE_TB
- en: '| `clicked(pick)` | The object was clicked. |'
  prefs: []
  type: TYPE_TB
- en: '| `pressed(pick)` | The mouse button was pressed over the object. |'
  prefs: []
  type: TYPE_TB
- en: '| `released(pick)` | The mouse button was released after `pressed(pick)` was
    triggered. |'
  prefs: []
  type: TYPE_TB
- en: '| `moved(pick)` | The mouse pointer was moved. |'
  prefs: []
  type: TYPE_TB
- en: '| `entered()` | The mouse pointer entered the object''s area. |'
  prefs: []
  type: TYPE_TB
- en: '| `exited()` | The mouse pointer exited the object''s area. |'
  prefs: []
  type: TYPE_TB
- en: 'Additionally, the `pressed` property will be set to `true` while a mouse button
    is pressed over the object, and the `containsMouse` property will be set to `true`
    while the mouse pointer is over the object''s area. You can attach change handlers
    to these properties or use them in a property binding, as with any other property
    in QML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Depending on your scene, picking can be a heavy computational task. By default,
    the most simple and efficient options are used. The default object picker will
    only handle mouse press and release events. You can set its `dragEnabled` property
    to `true` to handle mouse movements after `pressed(pick)` was triggered. You can
    also set the `hoverEnabled` property to `true` to handle all mouse movements,
    even when mouse buttons aren't pressed. There properties belong to the `ObjectPicker`
    component, so you can set them separately for each entity.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also global picking settings that affect the whole window. They are
    stored in the `pickingSettings` property of the `RenderSettings` component that
    is normally attached to the root entity. The settings can be changed like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Let's go through the possible settings. The `pickResultMode` property defines
    the behavior of overlapping pickers. If it's set to `PickingSettings.NearestPick`,
    only the object nearest to the camera will receive the event. If `PickingSettings.AllPicks`
    is specified, all objects will receive the event.
  prefs: []
  type: TYPE_NORMAL
- en: The `pickMethod` property allows you to choose how pickers decide whether the
    mouse pointer overlaps with the object. The default value is `PickingSettings.BoundingVolumePicking`,
    meaning that only the bounding box of the object is taken into account. This is
    a fast but inaccurate method. To achieve higher accuracy, you can set the `PickingSettings.TrianglePicking`
    method, which takes all mesh triangles into account.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `faceOrientationPickingMode` property allows you to choose if the
    front face, back face, or both faces will be used for the triangle picking.
  prefs: []
  type: TYPE_NORMAL
- en: Frame-based input handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In all the previous examples, we used property change signal handlers to execute
    code when the state of the logical device or object picker changes. This allows
    you, for example, to execute a function at the moment a button is pressed or released.
    However, sometimes you want to execute a continuous action (for example, accelerate
    an object) while a button is pressed. This is easy to do with just a few changes
    to the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to attach an `id` to the object with interesting properties
    (for example `Action`, `Axis`, or `ObjectPicker`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This will allow you to refer to its properties. Next, you need to use the `FrameAction`
    component provided by the `Qt3DLogic` module. This component will simply emit
    the `triggered()` signal each frame. You can attach it to any entity and use the
    input data as you want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You can use the `FrameAction` component to run any code that should be executed
    once per frame. However, don't forget that QML allows you to use property bindings,
    so you can set property values based on user input without having to write imperative
    code at all.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – receiving mouse input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our game is pretty simple, so the only action the player has to do is pick two
    rods for a move. Let's use `ObjectPicker` to detect when the player clicks on
    a rod.
  prefs: []
  type: TYPE_NORMAL
- en: First, set the `pickingSettings.pickMethod` property of the `RenderSettings`
    object to `PickingSettings.TrianglePicking` in the `main.qml` file (you can use
    the code example from the previous section). Our scene is very simple, and triangle
    picking shouldn't be too slow. This setting will greatly increase the picker's
    accuracy.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next set of changes will go to the `Rod.qml` file. First, add an ID to
    the root entity and declare a signal that will notify the outside world that the
    rod was clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add an `ObjectPicker` to the `components` array and emit the public `clicked()`
    signal when the picker reports that it was clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s give the player a hint that the rod is clickable by highlighting
    it when it intersects with the mouse pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'When the player puts the mouse pointer over a rod, the `picker.containsMouse`
    property will become `true`, and QML will update the material''s color automatically.
    You should see this behavior when running the project. The next task is to access
    the rod''s `clicked()` signal from the `Scene` component. To do that, you''ll
    need to make the following changes to the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As a result of these changes, the game should print a message to the application
    output, whenever a rod is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we added a `setupRod()` helper function that creates a new rod and connects
    its signal to the new `rodClicked()` function. Then we simply called `setupRod()`
    for each index and accumulated the rod object into the `rods` array. The `rodClicked()`
    function will contain the rest of our game logic, but for now it only prints the
    index of the clicked rod to the application output.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the content of the `setupRod()` function cannot be placed directly
    into the body of the `for` loop over `i`. The `clicked()` signal is connected
    to a closure that captures the `rod` variable. Within the function, each rod will
    connect to a closure that captures the corresponding `Rod`
  prefs: []
  type: TYPE_NORMAL
- en: object. Within the `for` loop, all closures would capture the common
  prefs: []
  type: TYPE_NORMAL
- en: '`rod` variable that will hold the last `Rod` object for all the closures.'
  prefs: []
  type: TYPE_NORMAL
- en: Performing animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Animations are essential for making a good game. Qt 3D provides a separate module
    for performing animations, but at the time of writing it's still experimental.
    Luckily, Qt already provides multiple ways to play animations. When using C++
    API, you can use the Animation Framework (we learned about it in [Chapter 5](bf16fe2f-f507-4980-96cd-9b53b200522e.xhtml),
    *Animations in Graphics View*). When using QML, you can use the powerful and convenient
    animation system provided by Qt Quick. We already worked with it a lot in previous
    chapters, so here we'll see how we can apply our knowledge to Qt 3D.
  prefs: []
  type: TYPE_NORMAL
- en: Qt Quick animations can be applied to almost any property of any QML object
    (strictly speaking, there are property types it can't handle, but we won't deal
    with those types here). If you look at the QML files of our project, you'll see
    that basically everything in our scene is defined by properties. That means that
    you can animate positions, colors, dimensions of objects and almost everything
    else.
  prefs: []
  type: TYPE_NORMAL
- en: Our current task will be to create an animation of the disk sliding up from
    the rod, moving across the table to the other rod, and sliding down that rod.
    The property we'll animate is `pos` which is the property alias for `transform.translation`.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – animating disk movements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our animation will consist of three parts, so it will require a fair amount
    of code. Instead of putting all that code directly into the `Scene` component,
    let''s put the animation into a separate component. Create a new file called `DiskAnimation.qml` and
    fill it with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: What just happened?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our animation has a lot of properties because it should be flexible enough to
    handle all the cases we need. First, it should be able to animate any disk, so
    we added the `target` property that will contain the disk we currently move. Next,
    the rods that participate in the movement influence the intermediate and final
    coordinates of the disk (more specifically, its *x* and *z* coordinates). The
    `rod1Pos` and `rod2Pos` properties will hold the coordinates of the rods in play.
    The `startY` and `finalY` properties define the starting and final coordinates
    of the disk. These coordinates will depend on the current number of disks stored
    on each rod. Finally, the `maxY` property simply defines the maximum height the
    disk will raise at while moving.
  prefs: []
  type: TYPE_NORMAL
- en: The property we animated is of the `vector3d` type, so we needed to use the 
    `Vector3dAnimation` type that is able to correctly interpolate all three components
    of the vector. We set the same `target` and `property` for all three parts of
    the animation. Then, we carefully calculated the final position of the disk after
    each stage and assigned it to the `to` property. There is no need to set the `from`
    property, as the animation will automatically use the current position of the
    disk as the starting point. Finally, we calculated the `duration` of each step
    to ensure steady movement of the disk.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, we want to test the new animation right away. Add a `DiskAnimation`
    object to the `Scene` component and initialize the animation at the end of the 
    `Component.onCompleted` handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: When you run the application, you should see the top disk moving from one rod
    to another.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – implementing game logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the required preparations are done, and now it's time to make our game
    functional. The player should be able to make a move by clicking on a rod and
    then clicking on another rod. After the first rod is selected, the game should
    remember it and show it in a different color.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s prepare the `Rod` component. We need it to have a new property
    that indicates that this rod was selected as the first rod for the next move:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s easy to make the rod change color depending on the `isSourceRod` value
    using a property binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s turn our attention to the `Scene` component. We''ll need a property
    that contains the currently selected first rod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'All that remains is the implementation of the `rodClicked()` function. Let''s
    go through it in two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: First, we check whether the move animation is already running, and ignore the
    event if it is. Next, we check whether the clicked rod was already selected. In
    this case, we simply deselect the rod. This allows the player to cancel the move
    if they accidentally selected an incorrect rod.
  prefs: []
  type: TYPE_NORMAL
- en: If `sourceRod` is unset, that means that we're in the first phase of the move.
    We check that the clicked rod has some disks on it, otherwise a move would not
    be possible. If everything is all right, we set the `sourceRod` property and the
    rod's `isSourceRod` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of the function handles the second phase of the move:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In this branch, we already know that we have the first rod object stored in
    the `sourceRod` property. We store the clicked rod object in the `targetRod` variable.
    Next, we check whether the player tries to put a larger disk on top of the smaller
    one. If that's the case, we refuse to make the invalid move.
  prefs: []
  type: TYPE_NORMAL
- en: If everything is correct, we finally perform the move. We use the `pop()` function
    to remove the disk from the end of the `sourceRod.disks` array. This is the disk
    that will be moved to the other rod. We immediately push the disk object to the
    `disks` array of the other rod. Next, we carefully set up all properties of the
    animation and start it. At the end of the function, we clear the rod's `isSourceRod`
    property and the scene's `sourceRod` property to allow the player to make the
    next move.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – improving the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Try to make your own modifications to the game. For example, you can notify
    the player about an invalid move by flashing the background color or the color
    of the foundation object. You can even add a 3D text to the scene using the `ExtrudedTextMesh`
    component. Try to play with different easing modes to make the animations look
    better.
  prefs: []
  type: TYPE_NORMAL
- en: The properties and functions of the `Scene` object are visible to the outside
    world, but they really are implementation details. You can fix that by putting
    them into an internal `QtObject`, as we described in [Chapter 12](4fdfe294-c35c-476d-9656-0aefd533e491.xhtml),
    *Customization in Qt Quick*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Qt 3D is very flexible when it comes to rendering. While it''s straightforward
    to use with the simple `ForwardRenderer`, you can create a much more complex render
    graph if you want. It''s possible to render to multiple viewports, use off-screen
    textures, apply custom shaders, and create your own graphics effects and materials.
    We can''t discuss all these possibilities in this book, but you can look at Qt
    examples to see how this can be done. Some of the relevant examples are Qt3D:
    Multi Viewport QML, Qt3D: Shadow Map QML, and Qt3D: Advanced custom material QML.'
  prefs: []
  type: TYPE_NORMAL
- en: Integration with 3D modeling software
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Geometric shapes provided by the `Qt3DExtras` module are great for prototyping.
    As we saw, these mesh generators come in handy when you want to create and test
    a new game quickly. However, a real game usually contains more complex figures
    than spheres and cubes. The meshes are usually prepared using specialized 3D modelling
    software. Qt 3D provides wide capabilities for importing 3D data from external
    files.
  prefs: []
  type: TYPE_NORMAL
- en: The first way of importing such data is the `Mesh` component. You only need
    to attach this component to an entity and specify the path to the file using the
    `source` property. As of Qt 5.10, `Mesh` supports OBJ, PLY, STL, and Autodesk
    FBX file formats.
  prefs: []
  type: TYPE_NORMAL
- en: As always, you can use a real filename or a Qt resource path. However, note
    that the source property expects an URL, not a path. A correct absolute resource
    path should start with `qrc:/`, and an absolute file path should start with `file://`.
    You can also use relative paths that will be resolved relatively to the current
    QML file.
  prefs: []
  type: TYPE_NORMAL
- en: If you're using OBJ files, `Mesh` provides you with an additional option to
    only load a sub-mesh from the `source` file. You can do it by specifying the name
    of the sub-mesh in the `meshName` property of the `Mesh` component. Instead of
    the exact name, you can also specify a regular expression to load all sub-meshes
    matching that expression.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – using OBJ files for the disks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt 3D doesn't provide a suitable mesh for the disks, but we can use a 3D modelling
    software to make any shape we want and then use it in our project. You will find
    the required OBJ files in the resources that come with the book. The files are
    named from `disk0.obj` to `disk7.obj`. If you want to practice with a 3D modelling
    software, you can prepare the files yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a subdirectory named `obj` in your project directory and put the OBJ
    files there. Invoke the context menu of `qml.qrc` in the Qt Creator''s project
    tree and select Add Existing Files. Add all OBJ files to the project. To put these
    files to work, we need to edit the `Disk.qml` file. Remove scale and rotation
    from the `Transform` component. Replace `TorusMesh` with `Mesh` and specify the
    resource path to the OBJ file as the `source` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Qt 3D will now use our new models for the disks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9ac45d17-62bc-4229-bb96-e6204b89cfdb.png)'
  prefs: []
  type: TYPE_IMG
- en: Loading a 3D scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Mesh` component is useful when you want to import a single object's shape
    from an external file. However, sometimes you want to import multiple objects
    from a single file. For example, you could prepare some decorations surrounding
    your game action and then import them all at once. This is where the `SceneLoader`
    component becomes useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be used similar to the `Mesh` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: However, instead of providing shape for its entity, `SceneLoader` creates a
    whole tree of `Entity` objects that become children of the `SceneLoader`'s entity.
    Each new entity will be provided with a mesh, a material, and a transform according
    to the file data. `SceneLoader` uses Assimp (Open Asset Import Library) to parse
    the source files, so it supports many common 3D formats.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Qt 3D using C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While QML is a powerful and convenient way of using Qt 3D, sometimes you may
    have reasons to prefer C++ over QML. For example, if your project has a large
    C++ codebase or your team is not familiar with JavaScript, sticking with C++ might
    be the right solution. If you want to extend a Qt 3D class with your custom implementation,
    you'll have to use the C++ approach. Additionally, if you deal with large amounts
    of objects, processing them in C++ may be noticeably faster than doing that in
    QML. Qt allows you to choose between C++ and QML freely.
  prefs: []
  type: TYPE_NORMAL
- en: The QML API of Qt 3D for the most part consists of C++ classes exposed without
    many changes. That means that most of the code you've seen in this chapter so
    far can be transparently translated to the equivalent C++ code with minimal effort.
    When you elect not to use QML, you lose its property bindings, syntax sugar, and
    the ability to declare trees of objects that are automatically instantiated. However,
    as long as you're familiar with the core of Qt C++ API, you shouldn't have any
    issues. You'll have to create objects manually and assign parents to them. In
    place of property bindings, you'll have to connect to property change signals
    and perform the required updates manually. If you studied the earlier chapters
    of this book, you should have no problems with doing that.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating a 3D scene using C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see how we can recreate our first Qt 3D scene using only C++ code. Our
    scene will contain a light source, a cube, and a first person camera controller.
    You can use the Qt Console Application template to create the project. Don''t
    forget to enable the Qt 3D modules you want to use in the project file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The first change compared to the QML approach is that you need to use the `Qt3DWindow`
    class instead of `Qt3DQuickWindow`. The `Qt3DWindow` class performs a few actions
    that are typically needed in a Qt 3D application. It sets up a `QForwardRenderer`,
    a camera, and initializes the `QInputSettings` object needed for processing events.
    You can access the default frame graph using the `defaultFrameGraph()` method.
    The default camera is available using the `camera()` method. The aspect ratio
    of the default camera is updated automatically according to the window size. If
    you want to set up a custom frame graph, use the `setActiveFrameGraph()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the code from our small example will be put into the `main()` function.
    Let''s go through it piece by piece. First, we initialize the usual `QGuiApplication`
    object, create a `Qt3DWindow` object, and apply our preferred settings to its
    frame graph and camera:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create a root entity object that will hold all our other entities
    and create a camera controller attached to the camera:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we set up a light entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s important that we pass the root entity to the `QEntity` constructor to
    ensure that the new entity will be a part of our scene. To add a component to
    the entity, we use the `addComponent()` function. The next step is to set up the
    cube 3D object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this code simply creates a few objects and sets their properties
    to the same values we used in our QML example. The final lines of code complete
    our setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We pass the root entity to the window and show it on screen. That's all! Qt
    3D will render the constructed scene in the same way it worked in our QML project.
  prefs: []
  type: TYPE_NORMAL
- en: All properties of Qt 3D classes are equipped with change notification signals,
    so you can use connect statements to react to external changes properties. For
    example, if you use the `Qt3DInput::QAction` component to receive keyboard or
    mouse events, you can use its `activeChanged(bool isActive)` signal to get notifications
    about the event. You can also perform animations in the 3D scene using C++ animation
    classes such as `QPropertyAnimation`.
  prefs: []
  type: TYPE_NORMAL
- en: Integration with Qt Widgets and Qt Quick
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While Qt 3D is a very powerful module, sometimes it's not enough to make a complete
    game or application. Other Qt modules such as Qt Quick or Qt Widgets can be very
    helpful, for example, when working on the user interface of your game. Luckily,
    Qt provides a few ways to use different modules together.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to Qt Widgets, your best bet is the `QWidget::createWindowContainer()`
    function. It allows you to surround your 3D view with widgets and display them
    all in a single window. This approach was already discussed in [Chapter 9](15aa8ec3-9e80-4f68-8e0e-f365e860f5c5.xhtml),
    *OpenGL and Vulkan in Qt Applications*, and can be applied to Qt 3D without any
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: However, the capabilities of Qt Widgets are still limited in the world of hardware-accelerated
    graphics. Qt Quick is much more promising in this area, and the synergy between
    QML APIs of Qt Quick and Qt 3D can prove to be very strong. Qt provides two ways
    to combine Qt Quick and Qt 3D in a single application without significant performance
    costs. Let's take a closer look at them.
  prefs: []
  type: TYPE_NORMAL
- en: Embedding Qt Quick UI into a 3D scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt 3D allows you to embed an arbitrary Qt Quick item into your 3D scene using
    the `Scene2D` type. How does that work? First, you need to put your Qt Quick content
    into a new `Scene2D` object. Next, you need to declare a texture that will be
    used as a render target for the form. Whenever Qt Quick decides to update its
    virtual view, the `Scene2D` object will render it directly to the specified texture.
    You only need to display this texture as you want. The most simple way of doing
    that is to pass it to a `TextureMaterial` component attached to one of your 3D
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this is only one part of the job. It''s nice to allow users to see
    your form, but they should also be able to interact with it. This is also supported
    by `Scene2D`! To make it work, you need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Set `pickMethod` to `TrianglePicking` in the `RenderSettings`. This will allow
    object pickers to retrieve more accurate information about mouse events.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attach an `ObjectPicker` component to all entities that use the texture created
    by `Scene2D`. It's a good idea to set the `hoverEnabled` and `dragEnabled` properties
    of the object picker to `true` to make mouse events work as expected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify all these entities in the `entities` property of the `Scene2D` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will allow `Scene2D` to forward mouse events to the Qt Quick content. Unfortunately,
    forwarding keyboard events is not available yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example of this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This code sets up a Qt 3D scene that contains a `Scene2D` object. `Scene2D`
    itself is not visible in the 3D scene. We declare a texture that will receive
    the rendered Qt Quick content. You can choose `width` and `height` of the texture
    depending on the size of the displayed content.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we declare that we'll render this texture in two entities (we'll create
    them in the next piece of code). Finally, we place a Qt Quick item directly into
    the `Scene2D` object. Make sure you set this size for your Qt Quick item according
    to the size of the texture. In our example, we created a form containing three
    checkboxes in a layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next part of code creates two items for displaying the Qt Quick-based texture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The first item is a cube, and the second item is a plane. Most of the properties
    are just arbitrary values that make the scene look good. The important part is
    that each item has a `TextureMaterial` component, and we passed the `texture`
    object into it. Each item also has an `ObjectPicker` component that allows the
    user to interact with the item. Note that we used the `mirrored` property of `PlaneMesh`
    to display the texture in its original (not mirrored) orientation.
  prefs: []
  type: TYPE_NORMAL
- en: One plane object is usually enough to display your form. We used two objects
    purely for demonstration purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'While Qt Quick items and Qt 3D entities live in different worlds and don''t
    seem to interact with each other, they are still declared in a single QML file,
    so you can use property bindings and other QML techniques to make all these items
    work together. In our example, not only is the background color of the root Qt
    Quick item controlled by the checkbox, but the 3D objects are also influenced
    by checkboxes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/46724776-f305-4da1-8269-01df5ad34e00.png)'
  prefs: []
  type: TYPE_IMG
- en: Embedding a Qt 3D scene into a Qt Quick form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's see how we can perform the opposite task. This approach is useful
    if your application is built mainly around Qt Quick. This means that you use the `QQmlApplicationEngine`
    class in the `main()` function, and the root object of your `main.qml` file is
    usually the `Window` object. It's very easy to extend your Qt Quick application
    with a bit of 3D action.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could place all the code into the `main.qml` file, but it''s more convenient
    to split it because setting up a 3D scene requires quite a bit of code. Let''s
    say you have a file named `My3DScene.qml` that contains the usual content of a
    3D scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'To add this 3D scene into the `main.qml` file (or any other Qt Quick-based
    QML file), you should use the `Scene3D` QML type that can be imported from the `QtQuick.Scene3D`
    module. For example, this is how you can create a form with a button and a 3D
    view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the code is the usual content of a Qt Quick form. The `Scene3D` item
    does all the magic. The root 3D entity should be added to this item directly or,
    as in our case, in the form of a custom component. The `Scene3D` item sets up
    a Qt 3D engine and renders the passed scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/403e934d-6ae3-423a-8e4c-aa4a8257b994.png)'
  prefs: []
  type: TYPE_IMG
- en: If you want to use `Qt3DInput` or `Qt3DLogic` modules, you need to enable the
    corresponding 3D aspects using the `aspects` property of `Scene3D`, as shown in
    the screenshot. Additionally, the `multisample` Boolean property can be used to
    enable multisampling. The `hoverEnabled` property can be used to enable handling
    of mouse events when mouse buttons are not pressed.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to `Qt3DQuickWindow`, `Scene3D` sets the camera's aspect ratio automatically
    by default. You can disable it by setting its `cameraAspectRatioMode` property
    to `Scene3D.UserAspectRatio`.
  prefs: []
  type: TYPE_NORMAL
- en: This approach can also be used to display some UI controls on top of the 3D
    view. This will allow you to use the full power of Qt Quick to make the UI of
    your game amazing.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Q1\. Which component can be used to rotate a 3D object?
  prefs: []
  type: TYPE_NORMAL
- en: '`CuboidMesh`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`RotationAnimation`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Transform`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q2\. Which component is the most suitable for emulating the light of the sun?
  prefs: []
  type: TYPE_NORMAL
- en: '`DirectionalLight`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PointLight`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SpotLight`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q3\. What is a Qt 3D material?
  prefs: []
  type: TYPE_NORMAL
- en: An object that allows you to load a texture from a file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A component that defines the physical properties of the object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A component that defines the visible properties of the object's surface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned to create 3D games with Qt. We saw how to create
    and position 3D objects in the scene and configure the camera for rendering. Next,
    we examined how we can handle user input using Qt 3D. More than that, you learned
    to apply your existing animation skills to Qt 3D objects. Finally, we found out
    how to use Qt 3D together with other Qt modules.
  prefs: []
  type: TYPE_NORMAL
- en: Like Qt Quick, Qt 3D is rapidly evolving. At the time of writing, some of the
    modules are still experimental. You should expect the API of Qt 3D to be improved
    and extended, so make sure you check the Qt documentation for newer releases.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our book on game programming using Qt. We have taught you the
    general basics of Qt, described its widget realm to you, and introduced you to
    the fascinating world of Qt Quick and Qt 3D. Widgets (including Graphics View),
    Qt Quick, and Qt 3D are the main paths you can take when creating games using
    the Qt framework. We have also shown you ways of merging the two approaches by
    making use of any OpenGL or Vulkan skills you might have, going beyond what Qt
    already offers today. At this point, you should start playing around and experimenting,
    and if at any point you feel lost or simply lack the information on how to do
    something, the very helpful Qt reference manual should be the first resource you
    direct yourself to.
  prefs: []
  type: TYPE_NORMAL
- en: Good luck and have lots of fun!
  prefs: []
  type: TYPE_NORMAL
