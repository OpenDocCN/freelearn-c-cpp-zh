- en: 3D Graphics with Qt
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Qt 进行 3D 图形
- en: Many modern games take place in 3D worlds. Graphics processing units are constantly
    evolving, allowing developers to create more and more visually appealing and detailed
    worlds. While you can use OpenGL or Vulkan directly to render 3D objects, this
    can prove to be quite challenging. Luckily, the Qt 3D module provides an implementation
    of 3D rendering with a high-level API. In this chapter, we'll learn to use its
    capabilities and see how we can create a 3D game with Qt.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现代游戏都在 3D 世界中进行。图形处理单元不断进化，允许开发者创建越来越视觉上吸引人且细节丰富的世界。虽然你可以直接使用 OpenGL 或 Vulkan
    来渲染 3D 对象，但这可能相当具有挑战性。幸运的是，Qt 3D 模块提供了一个使用高级 API 进行 3D 渲染的实现。在本章中，我们将学习如何使用其功能，并了解我们如何使用
    Qt 创建一个 3D 游戏。
- en: Qt 3D is not limited to rendering. You'll also learn to handle user input and
    implement game logic in a 3D game. Qt 3D was designed to be highly efficient and
    fully extensible, so it allows you to implement your own additions to all Qt 3D
    systems.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 3D 不仅限于渲染。你还将学习如何处理用户输入并在 3D 游戏中实现游戏逻辑。Qt 3D 被设计成高度高效和完全可扩展的，因此它允许你向所有 Qt
    3D 系统添加自己的扩展。
- en: Qt 3D offers both C++ and QML API with mostly equivalent functionality. While
    the C++ API allows you to modify and extend the implementation, we will use the
    QML approach, that will allow us to write clean and declarative code and use the
    techniques we've learned in the previous chapters. By combining Qt 3D with the
    powers of QML, you will be able to make amazing games in no time!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 3D 提供了 C++ 和 QML API，功能基本相同。虽然 C++ API 允许你修改和扩展实现，但我们将使用 QML 方法，这将允许我们编写干净且声明性的代码，并使用我们在前几章中学到的技术。通过将
    Qt 3D 与 QML 的力量结合起来，你将能够迅速制作出令人惊叹的游戏！
- en: 'The main topics covered in this chapter are:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要涵盖以下主题：
- en: Rendering 3D objects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染 3D 对象
- en: Handling user input
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理用户输入
- en: Performing animations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行动画
- en: Integration with 3D editors
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 3D 编辑器的集成
- en: Working with Qt 3D using C++
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 C++ 与 Qt 3D 一起工作
- en: Integration with Qt Widgets and Qt Quick
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 Qt Widgets 和 Qt Quick 的集成
- en: Qt 3D overview
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt 3D 概述
- en: Before we see Qt 3D in action, let's go through the important parts of its architecture.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们看到 Qt 3D 的实际应用之前，让我们先了解其架构的重要部分。
- en: Entities and components
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体和组件
- en: Qt 3D is not just a 3D rendering tool. When sufficiently evolved, it can become
    a full-featured game engine. This is supported by its original architecture. Qt
    3D introduces a new set of abstractions that are particularly useful for its task.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 3D 不仅仅是一个 3D 渲染工具。当它充分发展时，它可以成为一个功能齐全的游戏引擎。这得益于其原始架构。Qt 3D 引入了一套新的抽象概念，这些概念对于其任务特别有用。
- en: You may have noticed that most of the Qt API heavily uses inheritance. For example,
    each widget type is derived from `QWidget`, which in turn is derived from `QObject`.
    Qt forms large family trees of classes to provide common and specialized behavior.
    In contrast, elements of a Qt 3D scene are constructed using **composition** instead
    of inheritance. A single part of a Qt 3D scene is called an **entity** and represented
    by the `Entity` type. However, an `Entity` object by itself doesn't have any particular
    effect or behavior. You can add pieces of behavior to an entity in the form of
    **components**.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，大多数 Qt API 都大量使用了继承。例如，每个小部件类型都从 `QWidget` 派生而来，而 `QWidget` 又从 `QObject`
    派生。Qt 形成了庞大的类家族树，以提供通用和特殊的行为。相比之下，Qt 3D 场景的元素是使用 **组合** 而不是继承来构建的。Qt 3D 场景的一个部分称为
    **实体**，并由 `Entity` 类型表示。然而，一个 `Entity` 对象本身并没有任何特定的效果或行为。你可以通过添加 **组件** 的形式向实体添加行为片段。
- en: Each component controls some part of the entity's behavior. For example, the
    `Transform` component controls the entity's position within the scene, the `Mesh`
    component defines its shape, and the `Material` component controls the properties
    of the surface. This approach allows you to assemble entities from only the components
    that you need. For example, if you need to add a light source to the scene, you
    can create an entity with the `PointLight` component. You still want to choose
    a location of the light source, so you'll need the `Transform` component as well.
    However, `Mesh` and `Material` components do not make sense for a light source,
    so you don't need to use them.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 每个组件控制实体行为的一部分。例如，`Transform` 组件控制实体在场景中的位置，`Mesh` 组件定义其形状，而 `Material` 组件控制表面的属性。这种方法允许你仅从所需的组件中组装实体。例如，如果你需要向场景中添加光源，你可以创建一个带有
    `PointLight` 组件的实体。你仍然需要选择光源的位置，因此你还需要 `Transform` 组件。然而，对于光源来说，`Mesh` 和 `Material`
    组件没有意义，所以你不需要使用它们。
- en: Entities are arranged in a classic parent–child relationship, like any other
    QML objects or QObjects. A tree of entities form a Qt 3D scene. The topmost entity
    is usually responsible for defining scene-wide configuration. These settings are
    specified by attaching special components (such as `RenderSettings` and `InputSettings`)
    to the top level `Entity`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 实体按照经典的父子关系排列，就像任何其他 QML 对象或 QObjects 一样。实体树形成了一个 Qt 3D 场景。最顶层的实体通常负责定义场景级别的配置。这些设置通过将特殊组件（如
    `RenderSettings` 和 `InputSettings`）附加到顶级 `Entity` 来指定。
- en: Qt 3D modules
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt 3D 模块
- en: Qt 3D is split into a number of modules that you can choose to use in your project. It
    may be hard to see which of them you need, so let's see what each module is made
    for.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 3D 被分割成多个模块，你可以选择在项目中使用它们。可能很难看出你需要哪些模块，所以让我们看看每个模块的用途。
- en: Stable modules
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 稳定模块
- en: The `Qt3DCore` module implements the base structure of Qt 3D. It provides `Entity`
    and `Component` types, as well as base classes for other Qt 3D systems. `Qt3DCore`
    itself does not implement any behavior, providing only the framework that's used
    by other modules.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`Qt3DCore` 模块实现了 Qt 3D 的基本结构。它提供了 `Entity` 和 `Component` 类型，以及其他 Qt 3D 系统的基类。`Qt3DCore`
    本身不实现任何行为，仅提供其他模块使用的框架。'
- en: 'The `Qt3DRender` module implements 3D rendering, so it''s one of the most feature-rich
    modules. Let''s list some important pieces of its functionality:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`Qt3DRender` 模块实现了 3D 渲染，因此它是功能最丰富的模块之一。以下是它功能的一些重要部分：'
- en: '`GeometryRenderer` is the base component type that defines the visible shape
    of an entity'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GeometryRenderer` 是定义实体可见形状的基本组件类型。'
- en: The `Mesh` component allows you to import the entity's geometry from a file
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mesh` 组件允许你从文件中导入实体的几何形状。'
- en: The `Material` component is the base component type that defines visible properties
    of the entity's surface
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Material` 组件是定义实体表面可见属性的基本组件类型。'
- en: The `SceneLoader` component allows you to import a hierarchy of entities with
    meshes and materials from a file
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SceneLoader` 组件允许你从文件中导入具有网格和材料的实体层次结构。'
- en: Light components (`DirectionalLight`, `EnvironmentLight`, `PointLight`, and `SpotLight`)
    allow you to control the scene's lighting
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 光照组件（`DirectionalLight`、`EnvironmentLight`、`PointLight` 和 `SpotLight`）允许你控制场景的照明。
- en: The `FrameGraph` API provides a way of defining how exactly your scene should
    be rendered. It allows you to set up the camera, implement multiple viewports,
    shadow mapping, custom shaders, and much more
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FrameGraph` API 提供了一种定义场景应该如何精确渲染的方法。它允许你设置相机、实现多个视口、阴影映射、自定义着色器等等。'
- en: The `ObjectPicker` component allows you to find out which entities are positioned
    at a particular window point.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ObjectPicker` 组件允许你找出在特定窗口点位置上的哪些实体。'
- en: Next, `Qt3DLogic` is a very small module that provides the `FrameAction` component.
    This component allows you to execute an arbitrary action for each frame of your
    entity.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`Qt3DLogic` 是一个非常小的模块，它提供了 `FrameAction` 组件。这个组件允许你为实体的每一帧执行任意操作。
- en: Finally, the `Qt3DInput` module is focused on user input. It provides a few
    components that allow you to handle keyboard and mouse events in your game. `Qt3DInput`
    also contains types that can be used to configure the input devices.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Qt3DInput` 模块专注于用户输入。它提供了一些组件，允许你在游戏中处理键盘和鼠标事件。`Qt3DInput` 还包含可以用于配置输入设备的类型。
- en: Experimental modules
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验模块
- en: At the time of writing, all the other Qt 3D modules are still in **tech preview**,
    so their API may be incomplete. Future Qt versions may introduce incompatible
    changes in these modules, so don't be surprised if you need to make a few changes
    in the provided code to make it work (our code was tested on Qt 5.10). These modules
    should eventually be stabilized in the future, so you should check the Qt documentation
    to find out their current status.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，所有其他 Qt 3D 模块仍在 **技术预览** 中，因此它们的 API 可能不完整。未来的 Qt 版本可能会在这些模块中引入不兼容的更改，所以如果你需要修改提供的代码以使其工作，请不要感到惊讶（我们的代码已在
    Qt 5.10 上进行测试）。这些模块最终将在未来稳定下来，因此你应该检查 Qt 文档以了解它们当前的状态。
- en: The `Qt3DAnimation` module, as the name implies, is responsible for animations
    in the Qt 3D scene. It's able to handle keyframe animations on the entity's `Transform`
    component, as well as blend-shape and vertex-blend animations. However, we won't
    be using this module in this chapter, as the already familiar animation framework
    of Qt Quick is more than enough for us.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如同其名，`Qt3DAnimation` 模块负责 Qt 3D 场景中的动画。它能够处理实体的 `Transform` 组件上的关键帧动画，以及混合形状和顶点混合动画。然而，在本章中，我们不会使用此模块，因为已经熟悉的
    Qt Quick 动画框架对我们来说已经足够。
- en: 'The `Qt3DExtras` module provides components that are not strictly necessary
    for working with Qt 3D, but are very useful for building first simple projects.
    They are:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`Qt3DExtras` 模块提供了不是严格必要的 Qt 3D 工作组件，但对于构建简单的第一个项目非常有用。它们包括：'
- en: Mesh generators for basic geometric shapes (cubes, spheres, and so on)
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本几何形状（如立方体、球体等）的网格生成器
- en: The `ExtrudedTextMesh` component that allows you to show 3D text in the scene
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExtrudedTextMesh` 组件允许你在场景中显示 3D 文本'
- en: Many standard material components, such as `DiffuseSpecularMaterial` and `GoochMaterial`
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多标准材质组件，例如 `DiffuseSpecularMaterial` 和 `GoochMaterial`
- en: 'Additionally, `Qt3DExtras` provides two convenience classes that allow the
    user to control the position of the camera using mouse and keyboard:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`Qt3DExtras` 提供了两个便利类，允许用户使用鼠标和键盘控制相机的位置：
- en: '`OrbitCameraController` moves the camera along an orbital path'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OrbitCameraController` 沿着轨道路径移动相机'
- en: '`FirstPersonCameraController` moves the camera as in a first-person game'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FirstPersonCameraController` 以第一人称游戏的方式移动相机'
- en: The `Qt3DQuickExtras` module provides the `Qt3DExtras::Quick::Qt3DQuickWindow`
    C++ class. This is a window that displays a QML-based Qt 3D scene.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`Qt3DQuickExtras` 模块提供了 `Qt3DExtras::Quick::Qt3DQuickWindow` C++ 类。这是一个显示基于
    QML 的 Qt 3D 场景的窗口。'
- en: Finally, the `Qt3DQuickScene2D` module provides the ability to embed Qt Quick
    items into the Qt 3D scene, and the `QtQuick.Scene3D` QML module allows you to
    embed a Qt 3D scene into a Qt Quick application.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Qt3DQuickScene2D` 模块提供了将 Qt Quick 项目嵌入到 Qt 3D 场景的能力，而 `QtQuick.Scene3D`
    QML 模块允许你将 Qt 3D 场景嵌入到 Qt Quick 应用程序中。
- en: As you can see, the capabilities of Qt 3D are not limited by rendering. You
    can also use it to handle user input and implement the game logic for your entities.
    Qt 3D is fully extensible, so you can use its C++ API to implement your own components,
    or modify existing ones. However, we will mainly use the QML-based API in this
    chapter.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Qt 3D 的功能并不仅限于渲染。你还可以用它来处理用户输入并实现实体的游戏逻辑。Qt 3D 是完全可扩展的，因此你可以使用其 C++ API
    来实现自己的组件，或者修改现有的组件。然而，在本章中，我们将主要使用基于 QML 的 API。
- en: Note that Qt 3D objects are not Qt Quick items, so not all Qt Quick capabilities
    are open for you when you work with Qt 3D. For example, you can't use `Repeater`
    to instantiate multiple Qt 3D entities. However, you can still use Qt Quick animations
    because they can handle any QML objects. It's also possible to embed a Qt 3D scene
    into a Qt Quick interface using the `Scene3D` QML type.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Qt 3D 对象不是 Qt Quick 项目，因此当你使用 Qt 3D 时，并非所有 Qt Quick 功能都对你开放。例如，你不能使用 `Repeater`
    来实例化多个 Qt 3D 实体。然而，你仍然可以使用 Qt Quick 动画，因为它们可以处理任何 QML 对象。你也可以使用 `Scene3D` QML
    类型将 Qt 3D 场景嵌入到 Qt Quick 界面中。
- en: Using modules
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模块
- en: 'Before using each of the Qt 3D modules, you have to enable the module separately
    in the project file. For example, the following line will enable all currently
    documented modules:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用每个 Qt 3D 模块之前，你必须单独在项目文件中启用该模块。例如，以下行将启用所有当前记录的模块：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When using QML, each module must also be separately imported:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 QML 时，每个模块也必须单独导入：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can see that different Qt 3D modules have different QML module versions.
    Some modules were updated in Qt 5.10 and have new features that we'd like to use
    in our code, so you have to specify the last version (2.10) to make new QML types
    available. On the other hand, some modules weren't updated, so 2.0 is the only
    available version. The up-to-date versions will change in the future as new Qt
    releases come out. The Qt documentation should hopefully contain the correct import
    statements.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到不同的 Qt 3D 模块有不同的 QML 模块版本。一些模块在 Qt 5.10 中进行了更新，并具有我们希望在代码中使用的新功能，因此你必须指定最后一个版本（2.10），以便使新的
    QML 类型可用。另一方面，一些模块没有更新，所以 2.0 是唯一可用的版本。随着新 Qt 版本的发布，最新的版本将在未来发生变化。希望 Qt 文档将包含正确的导入语句。
- en: All C++ types of a Qt 3D module are placed in a namespace. In other regards,
    Qt naming conventions apply. For example, the `Entity` QML type corresponds to
    the `QEntity` C++ class in the `Qt3DCore` namespace. The corresponding include
    directive is `#include <QEntity>`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 Qt 3D 模块的 C++ 类型都放置在一个命名空间中。在其他方面，Qt 命名约定适用。例如，`Entity` QML 类型对应于 `Qt3DCore`
    命名空间中的 `QEntity` C++ 类。相应的包含指令是 `#include <QEntity>`。
- en: Qt 3D also introduces a concept of **aspects**. An aspect is simply a piece
    of behavior that can be added to the Qt 3D engine. The `Qt3DQuickWindow` class
    contains a built-in aspect engine that automatically enables `QRenderAspect`, `QInputAspect`,
    and `QLogicAspect` aspects, allowing Qt 3D to render the scene, process user input,
    and execute frame actions. If you decide to use the `Qt3DAnimation` module, you
    should also enable `QAnimationAspect`. You can do that using the `Qt3DWindow::registerAspect()`
    method. Other Qt 3D modules don't require a separate aspect. It's also possible
    to create a new aspect, but it's usually not necessary.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 3D 还引入了 **方面** 的概念。方面简单地说是一段可以添加到 Qt 3D 引擎中的行为。`Qt3DQuickWindow` 类包含一个内置的方面引擎，它自动启用
    `QRenderAspect`、`QInputAspect` 和 `QLogicAspect` 方面，允许 Qt 3D 渲染场景、处理用户输入和执行帧动作。如果您决定使用
    `Qt3DAnimation` 模块，您也应该启用 `QAnimationAspect`。您可以使用 `Qt3DWindow::registerAspect()`
    方法做到这一点。其他 Qt 3D 模块不需要单独的方面。也有可能创建一个新的方面，但通常不是必要的。
- en: Rendering 3D objects
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染 3D 对象
- en: Each item of the Qt 3D scene is represented by the `Entity` type. However, not
    all entities are visible 3D objects. In order for an entity to be visible, it
    has to have a **mesh** component and a **material** component.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 3D 场景中的每个项目都由 `Entity` 类型表示。然而，并非所有实体都是可见的 3D 对象。为了使实体可见，它必须具有 **网格** 组件和
    **材质** 组件。
- en: Mesh, material, and transform
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网格、材质和变换
- en: 'The mesh defines the geometrical shape of the entity. It contains information
    about vertices, edges, and faces required to render the object. The base type
    of all mesh components is `GeometryRenderer`. However, you''ll usually use one
    of its descendants:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 网格定义了实体的几何形状。它包含有关顶点、边和面的信息，这些信息是渲染对象所需的。所有网格组件的基类型是 `GeometryRenderer`。然而，您通常会使用其子类之一。
- en: '`Mesh` imports geometry data from a file'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mesh` 从文件中导入几何数据。'
- en: '`ConeMesh`, `CuboidMesh`, `CylinderMesh`, `PlaneMesh`, `SphereMesh`, and `TorusMesh` provide
    access to primitive geometric shapes'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConeMesh`、`CuboidMesh`、`CylinderMesh`、`PlaneMesh`、`SphereMesh` 和 `TorusMesh`
    提供了对原始几何形状的访问。'
- en: '`ExtrudedTextMesh` defines the entity''s shape based on a specified text and
    font'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExtrudedTextMesh` 根据指定的文本和字体定义实体的形状。'
- en: 'While the mesh defines where the object''s surface will be drawn, the material
    defines how exactly it will be drawn. The most obvious property of a surface is
    its color, but depending on the reflection model, there can be all sorts of properties,
    such as coefficients of diffuse and specular reflection. Qt 3D provides a lot
    of different material types:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然网格定义了对象表面将被绘制的位置，但材质定义了它将如何精确地被绘制。表面最明显的属性是其颜色，但根据反射模型，可能会有各种属性，例如漫反射和镜面反射的系数。Qt
    3D 提供了大量的不同材质类型：
- en: '`PerVertexColorMaterial` allows you to set color properties for each vertex
    and renders ambient and diffuse reflections'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PerVertexColorMaterial` 允许您为每个顶点设置颜色属性，并渲染周围和漫反射反射。'
- en: '`TextureMaterial` renders a texture and ignores lighting'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TextureMaterial` 渲染纹理并忽略光照。'
- en: '`DiffuseSpecularMaterial` implements the Phong reflection model and allows
    you to set ambient, diffuse, and specular components of the reflection'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DiffuseSpecularMaterial` 实现了 Phong 反射模型，并允许您设置反射的周围、漫反射和镜面反射组件。'
- en: '`GoochMaterial` implements the Gooch shading model'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GoochMaterial` 实现了 Gooch 着色模型。'
- en: '`MetalRoughMaterial` renders a metal-like surface using PBR (physically based
    rendering)'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MetalRoughMaterial` 使用 PBR（基于物理的渲染）渲染类似金属的表面。'
- en: '`MorphPhongMaterial` also follows the Phong reflection model but also supports
    morph animations of the `Qt3DAnimation` module'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MorphPhongMaterial` 也遵循 Phong 反射模型，但同时也支持 `Qt3DAnimation` 模块的形态动画。'
- en: The third common component of a visible 3D object is `Transform`. While not
    strictly required, it's usually necessary for setting the position of the object
    in the scene. You can set the position using the `translation` property. It's
    also possible to scale the object using the `scale3D` property that allows you
    to set different scale coefficients for each `axis`, or the `scale` property that
    accepts a single coefficient that applies to all axes. Similarly, you can either
    set the rotation quaternion using the `rotation` property or set individual Euler
    angles using `rotationX`, `rotationY`, and `rotationZ` properties. Finally, you
    can set the `matrix` property to apply an arbitrary transformation matrix.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 可见 3D 对象的第三个常见组件是 `Transform`。虽然不是严格必需的，但通常需要设置对象在场景中的位置。你可以使用 `translation`
    属性来设置位置。也可以使用 `scale3D` 属性来缩放对象，该属性允许你为每个 `axis` 设置不同的缩放系数，或者使用接受单个系数并应用于所有轴的
    `scale` 属性。同样，你可以使用 `rotation` 属性设置旋转四元数，或者使用 `rotationX`、`rotationY` 和 `rotationZ`
    属性设置单个欧拉角。最后，你可以设置 `matrix` 属性来应用任意变换矩阵。
- en: Note that transformations apply not only to the current entity, but to all its
    children as well.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，变换不仅应用于当前实体，还应用于其所有子实体。
- en: Lighting
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 光照
- en: Some of the available materials will take the lighting into account. Qt 3D allows
    you to add different types of lights to the scene and configure them. You can
    do that by adding a new `Entity` to the scene and attaching a `DirectionalLight`, `PointLight`,
    or `SpotLight` component to it. Each of these components has the `color` property
    that allows you to configure the color of the light and the `intensity` property
    that allows you to choose how bright the light is. The rest of the properties
    are specific to the light type.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一些可用的材料会考虑光照。Qt 3D 允许你向场景添加不同类型的灯光并对其进行配置。你可以通过向场景添加一个新的 `Entity` 并将其与一个 `DirectionalLight`、`PointLight`
    或 `SpotLight` 组件相关联来实现这一点。这些组件中的每一个都有一个 `color` 属性，允许你配置灯光的颜色，以及一个 `intensity`
    属性，允许你选择灯光的亮度。其余的属性都是特定于灯光类型的。
- en: '**Directional light** (also called "distant light" or "sunlight") casts parallel
    rays in the direction defined by the `worldDirection` property of the `DirectionalLight`
    type. Position and rotation of the entity have no influence on the lighting effect
    of a directional light, so there is no need for a `Transform` component.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**方向光**（也称为“远光”或“日光”）从由 `DirectionalLight` 类型的 `worldDirection` 属性定义的方向发射平行光线。实体的位置和旋转对方向光的光照效果没有影响，因此不需要
    `Transform` 组件。'
- en: '**Point light** emits light from its position in all directions. The position
    of the light can be changed via the `Transform` component attached to the same
    entity. The `PointLight` component allows you to configure how bright the light
    will be at a distance by setting the `constantAttenuation`, `linearAttenuation`,
    and `quadraticAttenuation` properties.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**点光**从其位置向所有方向发射光线。可以通过附加到同一实体的 `Transform` 组件来更改光源的位置。`PointLight` 组件允许你通过设置
    `constantAttenuation`、`linearAttenuation` 和 `quadraticAttenuation` 属性来配置在距离处灯光的亮度。'
- en: While point light can be interpreted as a sphere of light, **spotlight** is
    a cone of light. It emits light from its position, but the directions are limited
    by the `localDirection` property that defines where the spotlight is facing and
    the `cutOffAngle` property that configures how wide the light cone is. The position
    and direction of the spotlight can be influenced by the translation and rotation
    of the `Transform` component attached to the same entity. `SpotLight` also has
    the same attenuation properties as `PointLight`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当点光可以解释为一个光源的球体时，**聚光灯**是一个光锥。它从其位置发射光线，但方向受到 `localDirection` 属性的限制，该属性定义了聚光灯面向的方向，以及
    `cutOffAngle` 属性配置了光锥的宽度。聚光灯的位置和方向可以通过附加到同一实体的 `Transform` 组件的平移和旋转来影响。`SpotLight`
    也具有与 `PointLight` 相同的衰减属性。
- en: If no lights are present in the scene, Qt will automatically add an implicit
    point light so that the scene is somewhat visible.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果场景中没有灯光，Qt 将自动添加一个隐含的点光源，以便场景在一定程度上可见。
- en: The fourth type of light is different from the others. It's called **environment
    light** and can be configured by adding the `EnvironmentLight` component to an
    entity. It defines the surrounding lighting of the scene using two textures assigned
    to its `irradiance` and `specular` properties. Unlike other light types, this
    component does not have `color` or `intensity` properties. There can only be one
    environment light in a scene.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 第四种光与其他不同。它被称为**环境光**，可以通过向实体添加`EnvironmentLight`组件来配置。它使用分配给其`irradiance`和`specular`属性的两种纹理来定义场景的周围照明。与其他光类型不同，此组件没有`color`或`intensity`属性。场景中只能有一个环境光。
- en: Note that light sources themselves are invisible. Their only purpose is to influence
    the appearance of 3D objects that use certain material types.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，光源本身是不可见的。它们唯一的作用是影响使用特定材质类型的3D对象的外观。
- en: Time for action – creating a 3D scene
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 创建3D场景
- en: In this chapter, we will create an implementation of the famous Tower of Hanoi
    game. This puzzle game contains three rods and multiple disks of different sizes.
    The disks can slide onto the rods, but a disk cannot be placed on top of a smaller
    disk. At the starting position, all the rods are placed on one of the disks. The
    goal is to move them all to another rod. The player can only move one disk at
    a time.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建著名汉诺塔游戏的实现。这个谜题游戏包含三个杆和多个不同大小的盘子。盘子可以滑到杆上，但盘子不能放在比它小的盘子上面。在起始位置，所有杆都放在一个盘子上。目标是将它们全部移动到另一个杆上。玩家一次只能移动一个盘子。
- en: As usual, you will find the complete project in the resources that come with
    the book.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，你将在书中附带资源中找到完整的项目。
- en: 'Create a new Qt Quick Application - Empty project and call it `hanoi`. While
    we will use some Qt Quick utilities, our project will not really be based on Qt
    Quick. Qt 3D will do most of the work. Nevertheless, the Qt Quick Application
    - Empty is the most suitable of currently present templates, so we choose to use
    it. Edit the `hanoi.pro` file to enable the Qt modules that we''ll need:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的Qt Quick应用程序 - 空项目，并将其命名为`hanoi`。虽然我们将使用一些Qt Quick工具，但我们的项目实际上不会基于Qt Quick。Qt
    3D将做大部分工作。尽管如此，`Qt Quick Application - Empty`是目前最合适的模板，所以我们选择使用它。编辑`hanoi.pro`文件以启用我们将需要的Qt模块：
- en: '[PRE2]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We will use the `Qt3DQuickWindow` class to instantiate our QML objects instead
    of the `QQmlApplicationEngine` class we usually use with Qt Quick. To do that,
    replace the `main.cpp` file with the following code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`Qt3DQuickWindow`类来实例化我们的QML对象，而不是我们通常与Qt Quick一起使用的`QQmlApplicationEngine`类。为此，将`main.cpp`文件替换为以下代码：
- en: '[PRE3]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, replace the `main.qml` file with the following code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将`main.qml`文件替换为以下代码：
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This code declares a single `Entity` object that contains two components. The 
    `RenderSettings` component defines how Qt 3D should render the scene. The `activeFrameGraph`
    property of `RenderSettings` can hold a tree of render operations, but the simplest
    possible frame graph is a single `ForwardRenderer` object that takes care of all
    the rendering. `ForwardRenderer` renders objects one by one directly to the OpenGL
    framebuffer. We use the `clearColor` property to set the background color of our
    scene to black. The `camera` property of the `ForwardRenderer` holds the `Camera`
    object it will use for calculating the transformation matrix. Let''s go through
    the properties of the `Camera` object we''ve used in our code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码声明了一个包含两个组件的单个`Entity`对象。`RenderSettings`组件定义了Qt 3D应该如何渲染场景。`RenderSettings`的`activeFrameGraph`属性可以包含一个渲染操作的树，但最简单的帧图是一个单独的`ForwardRenderer`对象，它负责所有渲染。`ForwardRenderer`逐个将对象直接渲染到OpenGL帧缓冲区。我们使用`clearColor`属性将场景的背景色设置为黑色。`ForwardRenderer`的`camera`属性包含它将用于计算变换矩阵的`Camera`对象。让我们来看看我们代码中使用的`Camera`对象的属性：
- en: The `projectionType` property defines the type of the projection. Besides the `PerspectiveProjection`,
    you can use `OrthographicProjection`,  `FrustumProjection`, or  `CustomProjection`.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`projectionType`属性定义了投影的类型。除了`PerspectiveProjection`之外，你还可以使用`OrthographicProjection`、`FrustumProjection`或`CustomProjection`。'
- en: The `fieldOfView` property contains the field of view parameter of the perspective
    projection. You can change it to achieve a zoom in/out effect.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fieldOfView`属性包含透视投影的视野参数。你可以更改它以实现缩放效果。'
- en: The `nearPlane` and `farPlane` properties define the positions of the nearest
    and the furthest planes that will be visible in the camera (they correspond to
    the visible *z* axis values in the viewport coordinates).
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nearPlane`和`farPlane`属性定义了在相机中可见的最近和最远平面的位置（它们对应于视口坐标中可见的*z*轴值）。'
- en: The `position` vector defines the position of the camera in the world coordinates.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`position`向量定义了相机在世界坐标中的位置。'
- en: The `upVector` vector in the world coordinates is the vector that would appear
    pointing up when viewing it through the camera.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 世界坐标中的`upVector`向量是当通过相机观察时指向向上的向量。
- en: The `viewCenter` vector in the world coordinates is the point that will appear
    in the center of the viewport.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 世界坐标中的`viewCenter`向量是将在视口中心出现的点。
- en: When using the perspective projection, you usually need to set the aspect ratio
    according to the window size. The `Camera` object has the `aspectRatio` property
    for that, but we don't need to set it, since the `Qt3DQuickWindow` object will
    update this property automatically.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用透视投影时，通常需要根据窗口大小设置纵横比。`Camera`对象有`aspectRatio`属性用于此目的，但我们不需要设置它，因为`Qt3DQuickWindow`对象将自动更新此属性。
- en: You can disable this feature by adding  `window.setCameraAspectRatioMode(Qt3DExtras::Quick::Qt3DQuickWindow::UserAspectRatio)`
    to the `main.cpp` file.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在`main.cpp`文件中添加`window.setCameraAspectRatioMode(Qt3DExtras::Quick::Qt3DQuickWindow::UserAspectRatio)`来禁用此功能。
- en: If you want to use an orthographic projection instead of a perspective one,
    you can use the `top`, `left`, `bottom`, and `right` properties of the `Camera`
    object to set the visible area.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用正交投影而不是透视投影，你可以使用`Camera`对象的`top`、`left`、`bottom`和`right`属性来设置可见区域。
- en: Finally, the second component of our `Entity` is the `InputSettings` component.
    Its `eventSource` property should point to the object that provides the input
    events. As with `aspectRatio`, we don't need to set this property manually. The `Qt3DQuickWindow`
    will find the `InputSettings` object and set itself as the `eventSource`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的`Entity`的第二个组件是`InputSettings`组件。它的`eventSource`属性应指向提供输入事件的对象。与`aspectRatio`一样，我们不需要手动设置此属性。`Qt3DQuickWindow`将找到`InputSettings`对象并将其自身设置为`eventSource`。
- en: You can run the project to verify that it compiles successfully and doesn't
    produce any runtime errors. You should receive an empty black window as a result.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以运行项目以验证它是否成功编译并且没有产生任何运行时错误。你应该得到一个空的黑窗口作为结果。
- en: 'Now let''s add something visible to our scene. Edit the `main.qml` file to
    add a few child objects to the root `Entity`, as shown:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在我们的场景中添加一些可见的内容。编辑`main.qml`文件，向根`Entity`添加几个子对象，如下所示：
- en: '[PRE5]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As a result, you should see a cube at the center of the window:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你应该在窗口中心看到一个立方体：
- en: '![](img/c4641a69-bed6-448d-8a8e-5091b7237f54.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c4641a69-bed6-448d-8a8e-5091b7237f54.png)'
- en: More than that, you can use the arrow keys, the **Page Up** and **Page Down**
    keys, and the left mouse button to move the camera around.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，你可以使用箭头键、**Page Up**和**Page Down**键以及左鼠标按钮来移动相机。
- en: What just happened?
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We added a few objects to our scene graph. First, the `FirstPersonCameraController`
    object allows the user to freely control the camera. This is quite useful for
    testing the game while you don't have your own camera controlling code yet. Next,
    an entity with a single `DirectionalLight` component works as a light source in
    the scene. We use the properties of this component to set the color, intensity,
    and direction of the light.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的场景图中添加了一些对象。首先，`FirstPersonCameraController`对象允许用户自由控制相机。这在还没有自己的相机控制代码时测试游戏非常有用。接下来，一个带有单个`DirectionalLight`组件的实体在场景中充当光源。我们使用该组件的属性来设置光的颜色、强度和方向。
- en: Finally, we added an entity that represents a regular 3D object. Its shape is
    provided by the `CuboidMesh` component that generates a unit cube. The appearance
    of its surface is defined by the `DiffuseSpecularMaterial` component that conforms
    to the widely used Phong reflection model. You can use `ambient`, `diffuse`, and `specular` color
    properties to control different components of the reflected light. The `shininess`
    property defines how smooth the surface is. We use the `Transform` component to
    scale the cube to a larger size.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加了一个代表常规3D对象的实体。其形状由`CuboidMesh`组件提供，该组件生成一个单位立方体。其表面的外观由符合广泛使用的Phong反射模型的`DiffuseSpecularMaterial`组件定义。您可以使用`ambient`、`diffuse`和`specular`颜色属性来控制反射光的不同组成部分。`shininess`属性定义了表面有多光滑。我们使用`Transform`组件将立方体缩放到更大的尺寸。
- en: Time for action – constructing the Tower of Hanoi scene
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候构建汉诺塔场景了。
- en: 'Our next task will be to create a foundation and three rods for our puzzle.
    We will take advantage of QML''s modular system and split our code into multiple
    components. First, let''s leave camera and lighting settings in the `main.qml`
    and put our actual scene content to a new `Scene` component. In order to do that,
    put the text cursor onto the Entity declaration of the cube, press *Alt* + *Enter*
    and select Move Component into Separate File. Input `Scene` as the component name
    and confirm the operation. Qt Creator will create a new `Scene.qml` file and add
    it to the project''s resources. The `main.qml` now contains just an instantiation
    of our scene component:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的任务是为我们的谜题创建一个基础和三个杆。我们将利用QML的模块化系统，将我们的代码拆分成多个组件。首先，让我们将相机和光照设置保留在`main.qml`中，并将我们的实际场景内容放入一个新的`Scene`组件中。为了做到这一点，将文本光标置于立方体的实体声明上，按*Alt*
    + *Enter*并选择将组件移动到单独的文件中。输入`Scene`作为组件名称并确认操作。Qt Creator将创建一个新的`Scene.qml`文件并将其添加到项目的资源中。现在`main.qml`中只包含我们场景组件的一个实例化：
- en: '[PRE6]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The actual properties of the entity are moved to the `Scene.qml` file. Let''s
    adjust it to the following form:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的实体属性被移动到了`Scene.qml`文件中。让我们调整成以下形式：
- en: '[PRE7]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Our scene will contain multiple items, so we introduced a new `Entity` object
    and called it `sceneRoot`. This entity doesn't have any components, so it will
    not have any visible effect on the scene. This is similar to how an object of `Item` type
    usually serves as a container for Qt Quick items without providing any visual
    content.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的场景将包含多个项目，因此我们引入了一个新的`Entity`对象，并将其命名为`sceneRoot`。这个实体没有任何组件，因此它不会对场景产生任何可见的影响。这类似于`Item`类型的对象通常作为Qt
    Quick项的容器，而不提供任何视觉内容。
- en: The cube entity is now a child of `sceneRoot`. We use the `scale3D` property
    of the `Transform` component to change the dimensions of our cube. Now it looks
    like a tabletop that will serve as a foundation for the rest of the objects.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在立方体实体是`sceneRoot`的子实体。我们使用`Transform`组件的`scale3D`属性来改变立方体的尺寸。现在它看起来像一张桌面，将作为其余物体的基础。
- en: 'Now let''s work on the rods. Naturally, we want to have a `Rod` component because
    it is a repeating part of our scene. Invoke the context menu of `qml.qrc` in the
    project tree and choose Add New. From the Qt category, choose QML File (Qt Quick
    2) and input `Rod` as the filename. Let''s see how we can implement this component:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来处理杆。自然地，我们想要有一个`Rod`组件，因为它是场景的一个重复部分。在项目树中调用`qml.qrc`的上下文菜单，并选择添加新项。从Qt类别中选择QML文件（Qt
    Quick 2），并将文件名输入为`Rod`。让我们看看我们如何实现这个组件：
- en: '[PRE8]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Similar to the cube entity, our rod consists of a mesh, a material, and a `Transform`
    component. Instead of the `CubeMesh`, we use the `CylinderMesh` component that
    will create a cylinder for us. The `radius` and `length` properties define the
    dimensions of the object, and the `slices` property impacts the number of generated
    triangles. We chose to increase the number of slices to make the cylinders look
    better, but be aware that it has a performance impact that may become noticeable
    if you have many objects.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 与立方体实体类似，我们的杆由一个网格、一个材质和一个`Transform`组件组成。我们使用`CylinderMesh`组件来创建一个圆柱体，而不是`CubeMesh`。`radius`和`length`属性定义了对象的尺寸，而`slices`属性影响生成的三角形的数量。我们选择增加切片的数量以使圆柱体看起来更好，但请注意，这可能会对性能产生影响，如果有很多对象，这种影响可能会变得明显。
- en: 'Our `Rod` component has the index property that contains the positional number
    of the rod. We use this property to calculate the *x* and *z* coordinates of the
    rod so that all three rods are placed on a circle with an eight radius. The *y*
    coordinate is set to ensure that the rod is positioned on top of the foundation.
    We assign the calculated position vector to the `translation` property of the
    `Transform` component. Finally, add three `Rod` objects to the `Scene.qml` file:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Rod`组件有一个索引属性，其中包含杆的位置编号。我们使用这个属性来计算杆的*x*和*z*坐标，以便所有三根杆都放置在一个半径为八的圆上。*y*坐标被设置为确保杆位于基础之上。我们将计算出的位置向量分配给`Transform`组件的`translation`属性。最后，将三个`Rod`对象添加到`Scene.qml`文件中：
- en: '[PRE9]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When you run the project, you should see the foundation and the rods:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行项目时，你应该看到基础和杆：
- en: '![](img/d5089464-00d9-4aff-a550-47bd14caa50d.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d5089464-00d9-4aff-a550-47bd14caa50d.png)'
- en: Time for action – repeating 3D objects
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现在是时候重复3D对象了
- en: Our code works, but the way we create the rods is not ideal. First, enumerating
    rods and their indices in `Scene.qml` is inconvenient and error-prone. Second,
    we'll need to have a way to access a `Rod` object by its index, and the current
    approach doesn't allow that. In the previous chapters, we dealt with repeating
    Qt Quick objects using the `Repeater` QML type. However, `Repeater` doesn't work
    for `Entity` objects. It's only able to handle types that inherit from Qt Quick
    `Item`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码是可行的，但我们创建杆的方式并不理想。首先，在`Scene.qml`中枚举杆及其索引是不方便且容易出错的。其次，我们需要有一种方法可以通过索引访问`Rod`对象，而当前的方法不允许这样做。在前几章中，我们使用`Repeater`
    QML类型处理重复的Qt Quick对象。然而，`Repeater`不适用于`Entity`对象。它只能处理继承自Qt Quick `Item`的类型。
- en: 'The solution to our problem is already familiar to you since [Chapter 12](4fdfe294-c35c-476d-9656-0aefd533e491.xhtml)*,
    Customization in Qt Quick*. We can create QML objects using imperative JavaScript
    code. Remove `Rod` objects from the `Scene.qml` file and make the following additions
    instead:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们问题的解决方案对你来说已经很熟悉了，因为[第12章](4fdfe294-c35c-476d-9656-0aefd533e491.xhtml)*，Qt
    Quick中的自定义*。我们可以使用命令式JavaScript代码创建QML对象。从`Scene.qml`文件中删除`Rod`对象，并添加以下内容：
- en: '[PRE10]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: What just happened?
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: First, we created a property called `rods` that will hold an array of created
    `Rod` objects. Next, we used the `Component.onCompleted` attached property to
    run some JavaScript code after the QML engine instantiates our root object. Our
    first action was to load the `Rod` component and check whether it was loaded successfully.
    After obtaining a functioning component object, we used its `createObject()` method
    to create three new rods. We used the arguments of this function to pass the root
    object and value of the `index` property. Finally, we pushed the `Rod` object
    into the array.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个名为`rods`的属性，它将保存创建的`Rod`对象数组。接下来，我们使用`Component.onCompleted`附加属性在QML引擎实例化我们的根对象后运行一些JavaScript代码。我们的第一个动作是加载`Rod`组件并检查它是否成功加载。在获得一个功能组件对象后，我们使用其`createObject()`方法创建了三根新杆。我们使用该函数的参数传递根对象和`index`属性的值。最后，我们将`Rod`对象推入数组中。
- en: Time for action – creating disks
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现在是创建磁盘的时候了
- en: 'Our next task is to create eight disks that will slide onto rods. We''ll do
    it in a similar way to how we handled rods. First, create a new file called `Disk.qml`
    for our new component. Put the following content into the file:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的任务是创建八个将滑入杆中的磁盘。我们将以处理杆类似的方式来做这件事。首先，为我们的新组件创建一个名为`Disk.qml`的新文件。将以下内容放入该文件中：
- en: '[PRE11]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Like rods, disks are identified by their index. In this case, index influences
    the color and size of the disk. We calculate the disk's color using the `Qt.hsla()`
    function that takes hue, saturation, and lightness values and returns a `color`
    value that can be assigned to the `ambient` property of the material. This formula
    will give us eight colorful disks of different hues.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 与杆一样，磁盘通过其索引来识别。在这种情况下，索引影响磁盘的颜色和大小。我们使用`Qt.hsla()`函数来计算磁盘的颜色，该函数接受色调、饱和度和亮度值，并返回一个可以分配给材料的`ambient`属性的`color`值。这个公式将给我们八个不同色调的有色磁盘。
- en: The position of the disk is defined by the `translation` property of the `Transform`
    component. We want to be able to read and change the position of the disk from
    the outside, so we set up a property alias called `pos` that exposes the `transform.translation`
    property value.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 磁盘的位置由`Transform`组件的`translation`属性定义。我们希望能够从外部读取和更改磁盘的位置，因此我们设置了一个名为`pos`的属性别名，以暴露`transform.translation`属性值。
- en: Next, we use the `TorusMesh` component to define the shape of our disks. A torus
    shape is not really suitable for playing the Tower of Hanoi game in reality, but
    it will have to do for now. Later in this chapter, we'll replace it with a more
    suitable shape. The properties of the `TorusMesh` component allow us to adjust
    some of its measurements, but we also have to apply rotation and scale to the
    object to achieve the desired size and position.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`TorusMesh`组件来定义我们磁盘的形状。在现实中，环形状并不适合玩汉诺塔游戏，但暂时只能这样。在本章的后面部分，我们将用更合适的形状来替换它。`TorusMesh`组件的属性允许我们调整其一些测量值，但我们也必须对该对象应用旋转和缩放，以实现所需的大小和位置。
- en: 'Instead of putting all the disk objects into a single array, let''s create
    an array for each rod. When we move a disk from one rod to another one, we''ll
    remove the disk from the first rod''s array and add it to the second rod''s array.
    We can do that by adding a property to the `Rod` component. While we''re at it,
    we should also expose the rod''s position to the outside. We''ll need it to position
    the disks on the rods. Declare the following properties in the top level `Entity`
    in `Rod.qml`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 与将所有磁盘对象放入单个数组不同，让我们为每根杆创建一个数组。当我们把一个磁盘从一个杆移动到另一个杆时，我们将从第一个杆的数组中移除该磁盘，并将其添加到第二个杆的数组中。我们可以通过向`Rod`组件添加一个属性来实现这一点。在此过程中，我们还应该将杆的位置暴露给外部。我们需要它来定位杆上的磁盘。在`Rod.qml`中的顶级`Entity`中声明以下属性：
- en: '[PRE12]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `pos` property will follow the value of the `translation` property of the
    `Transform` component. Since this value is calculated based on the `index` property,
    we declare the `pos` property as `readonly`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`pos`属性将遵循`Transform`组件的`translation`属性的值。由于这个值是基于`index`属性计算的，我们将`pos`属性声明为`readonly`。'
- en: 'Next, we need to adjust the `Component.onCompleted` handler of the `Scene`
    component. Initialize the `diskComponent` variable, just like we did with `rodComponent`.
    Then you can create disks using the following code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要调整`Scene`组件的`Component.onCompleted`处理程序。初始化`diskComponent`变量，就像我们处理`rodComponent`一样。然后你可以使用以下代码创建磁盘：
- en: '[PRE13]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: After creating each disk, we set its position based on its index and the position
    of the chosen rod. We accumulate all disks in the `disks` property of the rod.
    We choose the order of disks in the array so that the bottom disk is at the beginning
    and the top disk is at the end. The `unshift()` function adds the item to the
    array at the beginning, giving the desired order.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建每个磁盘后，我们根据其索引和所选杆的位置设置其位置。我们将所有磁盘累积在杆的`disks`属性中。我们选择数组中磁盘的顺序，使得最底部的磁盘在开始处，顶部的磁盘在末尾。`unshift()`函数将项目添加到数组的开始处，从而得到所需的顺序。
- en: 'If you run the project, you should see all eight tori on one of the rods:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行项目，你应该在杆上看到所有的八个环：
- en: '![](img/140c44d4-992a-40ee-ae7d-dc71c062cd55.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/140c44d4-992a-40ee-ae7d-dc71c062cd55.png)'
- en: The next piece of functionality we'll need is the ability to move disks from
    one rod to another. However, it's the player who makes the decision, so we'll
    also need some way to receive input from the user. Let's see what options we have
    for handling user input.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来需要的下一个功能是将磁盘从一个杆移动到另一个杆的能力。然而，这是玩家做出的决定，因此我们还需要一种方式来接收用户的输入。让我们看看我们有哪些处理用户输入的选项。
- en: Handling user input
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理用户输入
- en: The first way of receiving events in Qt 3D is to use Qt GUI capabilities. The `Qt3DQuickWindow`
    class we use inherits from `QWindow`. That allows you to subclass `Qt3DQuickWindow`
    and reimplement some of its virtual functions, such as `keyPressEvent()` or `mouseMoveEvent()`. You
    are already familiar with this part of Qt API because it's roughly the same as
    provided by Qt Widgets and Graphics View. Qt 3D doesn't introduce anything special
    here, so we won't give this approach much attention.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在Qt 3D中接收事件的第一种方式是使用Qt GUI功能。我们使用的`Qt3DQuickWindow`类从`QWindow`继承。这允许你子类化`Qt3DQuickWindow`并重新实现其一些虚拟函数，例如`keyPressEvent()`或`mouseMoveEvent()`。你已经在Qt
    API的这一部分中很熟悉了，因为它大致与Qt Widgets和Graphics View提供的相同。Qt 3D在这里没有引入任何特别的东西，所以我们不会过多关注这种方法。
- en: Similar to Qt Quick, Qt 3D introduces a higher-level API for receiving input
    events. Let's see how we can use it.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 与Qt Quick类似，Qt 3D引入了一个用于接收输入事件的更高级API。让我们看看我们如何使用它。
- en: Devices
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设备
- en: 'Qt 3D is focused on providing a good abstraction for every aspect it handles.
    This applies to input as well. In terms of Qt 3D, an application may have access
    to an arbitrary number of **physical devices**. They are represented by the `AbstractPhysicalDevice`
    type. At the time of writing, there are two built-in types of physical devices:
    keyboard and mouse. You can access them by declaring an object of `KeyboardDevice`
    or `MouseDevice` type in your QML file.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 3D专注于为它处理的每个方面提供良好的抽象。这也适用于输入。在Qt 3D的术语中，一个应用程序可能可以访问任意数量的**物理设备**。它们由`AbstractPhysicalDevice`类型表示。在撰写本文时，有两种内置的物理设备类型：键盘和鼠标。你可以在你的QML文件中通过声明`KeyboardDevice`或`MouseDevice`类型的对象来访问它们。
- en: 'You can use properties of the device object to configure its behavior. There
    is currently only one such property: the `MouseDevice` type has a `sensitivity`
    property that affects how mouse movement is converted to axis inputs.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用设备对象的属性来配置其行为。目前只有一个这样的属性：`MouseDevice`类型有一个` sensitivity`属性，它影响鼠标移动如何转换为轴输入。
- en: It's allowed to create multiple objects of the same device type in a single
    application. All devices will handle all received inputs, but you can set different
    values of properties for different device objects.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在单个应用程序中创建同一设备类型的多个对象是允许的。所有设备将处理所有接收到的输入，但你可以为不同的设备对象设置不同的属性值。
- en: You typically don't want to handle events directly from the physical devices.
    Instead, you should set up a **logical device** that receives events from the
    physical devices and converts them to actions and inputs that make sense for your
    application. You can specify a set of **actions** and **axes** for your device
    using the `actions` and `axes` properties of the `LogicalDevice` type, and Qt
    3D will recognize the described inputs and notify your objects about them.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常不希望直接从物理设备处理事件。相反，你应该设置一个**逻辑设备**，它从物理设备接收事件并将它们转换为对应用程序有意义的动作和输入。你可以使用`LogicalDevice`类型的`actions`和`axes`属性为你的设备指定一组**动作**和**轴**，Qt
    3D将识别所描述的输入并通知你的对象。
- en: We will provide a few code examples to demonstrate how to handle various kinds
    of input in Qt 3D. You can test the code by putting it into the `main.qml` file
    of the `hanoi` project or create a separate project for that.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将提供一些代码示例来展示如何在Qt 3D中处理各种类型的输入。你可以通过将其放入`hanoi`项目的`main.qml`文件中或为该目的创建一个单独的项目来测试代码。
- en: Keyboard and mouse buttons
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 键盘和鼠标按钮
- en: An action is represented by the `Action` type. An action can be triggered by
    pressing a single key, a key combination, or a key sequence. This is defined by
    the `inputs` property of the `Action` type. The most simple kind of input is `ActionInput`
    which reacts to a single key.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 动作由`Action`类型表示。一个动作可以通过按下单个键、键组合或键序列来触发。这是由`Action`类型的`inputs`属性定义的。最简单类型的输入是`ActionInput`，它对单个键做出反应。
- en: 'When the action is triggered, its `active` property will change from `false`
    to `true`. When the corresponding key or key combination is released, `active`
    changes back to `false`. You can use the usual QML features to track changes of
    the property:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当动作被触发时，其`active`属性将从`false`变为`true`。当相应的键或键组合被释放时，`active`将变回`false`。你可以使用通常的QML功能来跟踪属性的变化：
- en: '[PRE14]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, keyboard and mouse button events are handled in the same way.
    However, they come from different physical devices, so make sure you specify the
    correct device in the `sourceDevice` property of `ActionInput`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，键盘和鼠标按钮事件的处理方式相同。然而，它们来自不同的物理设备，所以请确保你在`ActionInput`的`sourceDevice`属性中指定了正确的设备。
- en: 'You can specify multiple buttons for `ActionInput`. In this case, the action
    will trigger if any of the specified buttons are pressed. For example, use the
    following code to handle both the main *Enter* key and the *Enter* key on the
    keypad:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为`ActionInput`指定多个按钮。在这种情况下，如果指定的任何按钮被按下，动作将被触发。例如，使用以下代码来处理主*Enter*键和数字键盘上的*Enter*键：
- en: '[PRE15]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that it's not required to put the input handling code into the root object
    of the scene. You can put it into any `Entity`. It's also possible to have multiple
    entities handling input events at the same time.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，将输入处理代码放入场景的根对象中不是必需的。你可以将其放入任何`Entity`中。同时，也可以有多个实体同时处理输入事件。
- en: Input chords
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入和弦
- en: 'The `InputChord` type allows you to trigger an action when multiple keys are
    pressed at the same time:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`InputChord`类型允许你在同时按下多个键时触发一个动作：'
- en: '[PRE16]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `onActiveChanged` handler will be called when *Q*, *W*, and *E* keys are
    pressed within 500 milliseconds and held together.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 500 毫秒内按下并保持 *Q*、*W* 和 *E* 键时，将调用 `onActiveChanged` 处理器。
- en: Analog (axis) input
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟（轴）输入
- en: '**Axis** in Qt 3D is an abstraction of analog one-dimensional input. A typical
    source of axis input is an analog stick of a gamepad. As the name implies, `Axis`
    only represents movement along a single axis, so a stick can be represented by
    two axes—one for vertical movement and one for horizontal movement. A pressure-sensitive
    button can be represented by a single axis. An axis input produces a `float` value
    ranging from −1 to 1, with zero corresponding to the neutral position.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**轴**在 Qt 3D 中是对模拟一维输入的抽象。轴输入的一个典型来源是游戏手柄的模拟摇杆。正如其名所示，`Axis` 只表示沿单轴的运动，因此摇杆可以表示为两个轴——一个用于垂直运动，一个用于水平运动。一个压力敏感的按钮可以表示为一个轴。轴输入产生一个范围从
    -1 到 1 的 `float` 值，其中零对应于中性位置。'
- en: That being said, there is no gamepad support in Qt 3D at the time of writing.
    It's possible that it will be added in future versions. You can also use the extensible C++
    API of Qt 3D to implement the gamepad device using Qt Gamepad. However, the simplest
    solution is to use Qt Gamepad directly. Nothing prevents you from using QML or
    C++ API of Qt Gamepad in an application that uses Qt 3D.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，在撰写本文时，Qt 3D 中没有游戏手柄支持。有可能在未来版本中添加此功能。您还可以使用 Qt 3D 的可扩展 C++ API 来实现使用 Qt
    Gamepad 的游戏手柄设备。然而，最简单的解决方案是直接使用 Qt Gamepad。没有任何东西阻止您在使用 Qt 3D 的应用程序中使用 QML 或
    Qt Gamepad 的 C++ API。
- en: The `inputs` property of the `Axis` type allows you to specify which input events
    should be redirected to this axis. You can use the `AnalogAxisInput` type to access
    the axis data provided by a physical device. The `MouseDevice` provides four virtual
    axes that are emulated based on the mouse input. Two of them are based on the
    vertical and horizontal scroll. Two others are based on vertical and horizontal
    pointer movement, but they only work while any mouse button is pressed.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`Axis` 类型的 `inputs` 属性允许您指定哪些输入事件应被重定向到该轴。您可以使用 `AnalogAxisInput` 类型来访问由物理设备提供的轴数据。`MouseDevice`
    提供了四个基于鼠标输入的虚拟轴。其中两个基于垂直和水平滚动。另外两个基于垂直和水平指针移动，但它们仅在按下任何鼠标按钮时才工作。'
- en: The `ButtonAxisInput` type allows you to emulate an axis based on the button
    pressed. You can use the `scale` property to set the axis value corresponding
    to each button. When multiple buttons are pressed together, the mean of their
    axis values is used.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`ButtonAxisInput` 类型允许您根据按下的按钮模拟一个轴。您可以使用 `scale` 属性设置每个按钮对应的轴值。当同时按下多个按钮时，使用它们的轴值的平均值。'
- en: 'Both mouse-based and button-based axes are demonstrated in the following example:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例展示了基于鼠标和按钮的轴：
- en: '[PRE17]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Object picker
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象选择器
- en: 'Object picker is a component that allows an entity to interact with the mouse
    pointer. This component does not interact with the previously described input
    API directly. For example, you don''t need to provide a mouse device for it. All
    you need to do is to attach the `ObjectPicker` component to an entity that also
    contains a mesh. The signals from `ObjectPicker` will notify you about input events
    related to this entity:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 对象选择器是一个允许实体与鼠标指针交互的组件。此组件不会直接与之前描述的输入 API 交互。例如，您不需要为此提供鼠标设备。您需要做的只是将 `ObjectPicker`
    组件附加到一个也包含网格的实体上。`ObjectPicker` 的信号将通知您与该实体相关的输入事件：
- en: '| **Signal** | **Explanation** |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| **信号** | **说明** |'
- en: '| `clicked(pick)` | The object was clicked. |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `clicked(pick)` | 对象被点击。 |'
- en: '| `pressed(pick)` | The mouse button was pressed over the object. |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `pressed(pick)` | 在对象上按下鼠标按钮。 |'
- en: '| `released(pick)` | The mouse button was released after `pressed(pick)` was
    triggered. |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `released(pick)` | 在 `pressed(pick)` 触发后，鼠标按钮被释放。 |'
- en: '| `moved(pick)` | The mouse pointer was moved. |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `moved(pick)` | 鼠标指针被移动。 |'
- en: '| `entered()` | The mouse pointer entered the object''s area. |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `entered()` | 鼠标指针进入了对象的区域。 |'
- en: '| `exited()` | The mouse pointer exited the object''s area. |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `exited()` | 鼠标指针离开了对象的区域。 |'
- en: 'Additionally, the `pressed` property will be set to `true` while a mouse button
    is pressed over the object, and the `containsMouse` property will be set to `true`
    while the mouse pointer is over the object''s area. You can attach change handlers
    to these properties or use them in a property binding, as with any other property
    in QML:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当鼠标按钮在对象上按下时，`pressed`属性将被设置为`true`，而当鼠标指针在对象区域上方时，`containsMouse`属性将被设置为`true`。您可以将更改处理程序附加到这些属性或像使用QML中的任何其他属性一样使用它们：
- en: '[PRE18]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Depending on your scene, picking can be a heavy computational task. By default,
    the most simple and efficient options are used. The default object picker will
    only handle mouse press and release events. You can set its `dragEnabled` property
    to `true` to handle mouse movements after `pressed(pick)` was triggered. You can
    also set the `hoverEnabled` property to `true` to handle all mouse movements,
    even when mouse buttons aren't pressed. There properties belong to the `ObjectPicker`
    component, so you can set them separately for each entity.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的场景，拾取可能是一个计算密集型任务。默认情况下，使用最简单和最有效率的选项。默认对象拾取器将仅处理鼠标按下和释放事件。您可以将`dragEnabled`属性设置为`true`以处理在`pressed(pick)`触发后的鼠标移动。您还可以将`hoverEnabled`属性设置为`true`以处理所有鼠标移动，即使鼠标按钮未按下。这些属性属于`ObjectPicker`组件，因此您可以分别为每个实体单独设置它们。
- en: 'There are also global picking settings that affect the whole window. They are
    stored in the `pickingSettings` property of the `RenderSettings` component that
    is normally attached to the root entity. The settings can be changed like this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 也有一些全局拾取设置，它们会影响整个窗口。这些设置存储在`RenderSettings`组件的`pickingSettings`属性中，该组件通常附加到根实体上。设置可以像这样更改：
- en: '[PRE19]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Let's go through the possible settings. The `pickResultMode` property defines
    the behavior of overlapping pickers. If it's set to `PickingSettings.NearestPick`,
    only the object nearest to the camera will receive the event. If `PickingSettings.AllPicks`
    is specified, all objects will receive the event.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看可能的设置。`pickResultMode`属性定义了重叠拾取器的行为。如果设置为`PickingSettings.NearestPick`，则只有离相机最近的对象将接收到事件。如果指定为`PickingSettings.AllPicks`，则所有对象都将接收到事件。
- en: The `pickMethod` property allows you to choose how pickers decide whether the
    mouse pointer overlaps with the object. The default value is `PickingSettings.BoundingVolumePicking`,
    meaning that only the bounding box of the object is taken into account. This is
    a fast but inaccurate method. To achieve higher accuracy, you can set the `PickingSettings.TrianglePicking`
    method, which takes all mesh triangles into account.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`pickMethod`属性允许您选择拾取器如何决定鼠标指针是否与对象重叠。默认值是`PickingSettings.BoundingVolumePicking`，这意味着只考虑对象的边界框。这是一个快速但不太准确的方法。为了获得更高的精度，您可以设置`PickingSettings.TrianglePicking`方法，它考虑所有网格三角形。'
- en: Finally, the `faceOrientationPickingMode` property allows you to choose if the
    front face, back face, or both faces will be used for the triangle picking.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`faceOrientationPickingMode`属性允许您选择是否使用三角形拾取的前面、背面或两个面。
- en: Frame-based input handling
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于帧的输入处理
- en: In all the previous examples, we used property change signal handlers to execute
    code when the state of the logical device or object picker changes. This allows
    you, for example, to execute a function at the moment a button is pressed or released.
    However, sometimes you want to execute a continuous action (for example, accelerate
    an object) while a button is pressed. This is easy to do with just a few changes
    to the code.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有之前的示例中，我们使用了属性更改信号处理程序来在逻辑设备或对象拾取器的状态发生变化时执行代码。这允许您在按钮按下或释放时执行函数。然而，有时您希望在按钮按下时执行连续动作（例如，加速对象）。通过仅对代码进行少量更改，这很容易做到。
- en: 'First, you need to attach an `id` to the object with interesting properties
    (for example `Action`, `Axis`, or `ObjectPicker`):'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要给具有有趣属性的对象附加一个`id`（例如`Action`、`Axis`或`ObjectPicker`）：
- en: '[PRE20]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This will allow you to refer to its properties. Next, you need to use the `FrameAction`
    component provided by the `Qt3DLogic` module. This component will simply emit
    the `triggered()` signal each frame. You can attach it to any entity and use the
    input data as you want:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许您引用其属性。接下来，您需要使用`Qt3DLogic`模块提供的`FrameAction`组件。此组件将简单地每帧发出`triggered()`信号。您可以将它附加到任何实体并按需使用输入数据：
- en: '[PRE21]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You can use the `FrameAction` component to run any code that should be executed
    once per frame. However, don't forget that QML allows you to use property bindings,
    so you can set property values based on user input without having to write imperative
    code at all.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `FrameAction` 组件来运行任何应该每帧执行一次的代码。然而，不要忘记 QML 允许你使用属性绑定，因此你可以根据用户输入设置属性值，而无需编写任何命令式代码。
- en: Time for action – receiving mouse input
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 接收鼠标输入
- en: Our game is pretty simple, so the only action the player has to do is pick two
    rods for a move. Let's use `ObjectPicker` to detect when the player clicks on
    a rod.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏相当简单，所以玩家唯一需要做的动作是选择两根杆进行移动。让我们使用 `ObjectPicker` 来检测玩家何时点击杆。
- en: First, set the `pickingSettings.pickMethod` property of the `RenderSettings`
    object to `PickingSettings.TrianglePicking` in the `main.qml` file (you can use
    the code example from the previous section). Our scene is very simple, and triangle
    picking shouldn't be too slow. This setting will greatly increase the picker's
    accuracy.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将 `RenderSettings` 对象的 `pickingSettings.pickMethod` 属性在 `main.qml` 文件中设置为
    `PickingSettings.TrianglePicking`（你可以使用上一节中的代码示例）。我们的场景非常简单，三角形选择不应该太慢。此设置将大大提高选择器的准确性。
- en: 'The next set of changes will go to the `Rod.qml` file. First, add an ID to
    the root entity and declare a signal that will notify the outside world that the
    rod was clicked:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个更改集将针对 `Rod.qml` 文件。首先，给根实体添加一个 ID 并声明一个信号，该信号将通知外界杆已被点击：
- en: '[PRE22]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, add an `ObjectPicker` to the `components` array and emit the public `clicked()`
    signal when the picker reports that it was clicked:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将 `ObjectPicker` 添加到 `components` 数组中，并在选择器报告被点击时发出公共的 `clicked()` 信号：
- en: '[PRE23]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, let''s give the player a hint that the rod is clickable by highlighting
    it when it intersects with the mouse pointer:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们给玩家一个提示，当杆与鼠标指针相交时，通过高亮显示来表明杆是可点击的：
- en: '[PRE24]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When the player puts the mouse pointer over a rod, the `picker.containsMouse`
    property will become `true`, and QML will update the material''s color automatically.
    You should see this behavior when running the project. The next task is to access
    the rod''s `clicked()` signal from the `Scene` component. To do that, you''ll
    need to make the following changes to the code:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家将鼠标指针放在杆上时，`picker.containsMouse` 属性将变为 `true`，QML 将自动更新材质的颜色。当你运行项目时，你应该看到这种行为。下一个任务是访问
    `Scene` 组件的杆的 `clicked()` 信号。为此，你需要在代码中进行以下更改：
- en: '[PRE25]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As a result of these changes, the game should print a message to the application
    output, whenever a rod is clicked.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些更改，每当点击杆时，游戏应该将一条消息打印到应用程序输出。
- en: What just happened?
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: First, we added a `setupRod()` helper function that creates a new rod and connects
    its signal to the new `rodClicked()` function. Then we simply called `setupRod()`
    for each index and accumulated the rod object into the `rods` array. The `rodClicked()`
    function will contain the rest of our game logic, but for now it only prints the
    index of the clicked rod to the application output.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们添加了一个 `setupRod()` 辅助函数，用于创建一个新的杆并将其信号连接到新的 `rodClicked()` 函数。然后我们简单地为每个索引调用
    `setupRod()` 并将杆对象累积到 `rods` 数组中。`rodClicked()` 函数将包含我们游戏逻辑的其余部分，但现在它只打印被点击杆的索引到应用程序输出。
- en: Note that the content of the `setupRod()` function cannot be placed directly
    into the body of the `for` loop over `i`. The `clicked()` signal is connected
    to a closure that captures the `rod` variable. Within the function, each rod will
    connect to a closure that captures the corresponding `Rod`
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`setupRod()` 函数的内容不能直接放置在 `for` 循环的 `i` 身体中。`clicked()` 信号连接到一个捕获 `rod` 变量的闭包。在函数内部，每根杆都会连接到一个捕获相应
    `Rod` 的闭包
- en: object. Within the `for` loop, all closures would capture the common
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 对象。在 `for` 循环中，所有闭包都会捕获公共
- en: '`rod` variable that will hold the last `Rod` object for all the closures.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`rod` 变量将保存所有闭包的最后一个 `Rod` 对象。'
- en: Performing animations
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行动画
- en: Animations are essential for making a good game. Qt 3D provides a separate module
    for performing animations, but at the time of writing it's still experimental.
    Luckily, Qt already provides multiple ways to play animations. When using C++
    API, you can use the Animation Framework (we learned about it in [Chapter 5](bf16fe2f-f507-4980-96cd-9b53b200522e.xhtml),
    *Animations in Graphics View*). When using QML, you can use the powerful and convenient
    animation system provided by Qt Quick. We already worked with it a lot in previous
    chapters, so here we'll see how we can apply our knowledge to Qt 3D.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 动画对于制作一款优秀的游戏至关重要。Qt 3D提供了一个独立的模块来执行动画，但在撰写本文时，它仍然处于实验阶段。幸运的是，Qt已经提供了多种播放动画的方法。当使用C++
    API时，你可以使用动画框架（我们曾在[第五章](bf16fe2f-f507-4980-96cd-9b53b200522e.xhtml)，*图形视图中的动画*）中了解过）。当使用QML时，你可以使用Qt
    Quick提供的强大且便捷的动画系统。我们在前面的章节中已经大量使用过它，所以在这里我们将看看如何将我们的知识应用到Qt 3D中。
- en: Qt Quick animations can be applied to almost any property of any QML object
    (strictly speaking, there are property types it can't handle, but we won't deal
    with those types here). If you look at the QML files of our project, you'll see
    that basically everything in our scene is defined by properties. That means that
    you can animate positions, colors, dimensions of objects and almost everything
    else.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick动画可以应用于任何QML对象的几乎任何属性（严格来说，有一些属性类型它无法处理，但在这里我们不会处理这些类型）。如果你查看我们项目的QML文件，你会发现我们场景中的几乎所有内容都是由属性定义的。这意味着你可以动画化位置、颜色、对象的尺寸以及几乎所有其他内容。
- en: Our current task will be to create an animation of the disk sliding up from
    the rod, moving across the table to the other rod, and sliding down that rod.
    The property we'll animate is `pos` which is the property alias for `transform.translation`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前的任务将是创建一个动画，该动画显示磁盘从杆上滑起，移动到桌子的另一端，然后沿该杆滑下。我们将动画化的属性是`pos`，它是`transform.translation`属性别名。
- en: Time for action – animating disk movements
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手实践 - 动画磁盘移动
- en: 'Our animation will consist of three parts, so it will require a fair amount
    of code. Instead of putting all that code directly into the `Scene` component,
    let''s put the animation into a separate component. Create a new file called `DiskAnimation.qml` and
    fill it with the following code:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的动画将包含三个部分，因此需要相当多的代码。我们不是直接将所有这些代码放入`Scene`组件中，而是将其放入一个单独的组件中。创建一个名为`DiskAnimation.qml`的新文件，并填充以下代码：
- en: '[PRE26]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: What just happened?
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: Our animation has a lot of properties because it should be flexible enough to
    handle all the cases we need. First, it should be able to animate any disk, so
    we added the `target` property that will contain the disk we currently move. Next,
    the rods that participate in the movement influence the intermediate and final
    coordinates of the disk (more specifically, its *x* and *z* coordinates). The
    `rod1Pos` and `rod2Pos` properties will hold the coordinates of the rods in play.
    The `startY` and `finalY` properties define the starting and final coordinates
    of the disk. These coordinates will depend on the current number of disks stored
    on each rod. Finally, the `maxY` property simply defines the maximum height the
    disk will raise at while moving.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的动画有很多属性，因为它应该足够灵活，以处理我们需要的所有情况。首先，它应该能够动画化任何磁盘，因此我们添加了`target`属性，它将包含我们当前移动的磁盘。接下来，参与移动的杆会影响磁盘的中间和最终坐标（更具体地说，是其*x*和*z*坐标）。`rod1Pos`和`rod2Pos`属性将保存杆的坐标。`startY`和`finalY`属性定义了磁盘的起始和最终坐标。这些坐标将取决于每个杆上存储的磁盘数量。最后，`maxY`属性简单地定义了磁盘在移动过程中可以达到的最大高度。
- en: The property we animated is of the `vector3d` type, so we needed to use the 
    `Vector3dAnimation` type that is able to correctly interpolate all three components
    of the vector. We set the same `target` and `property` for all three parts of
    the animation. Then, we carefully calculated the final position of the disk after
    each stage and assigned it to the `to` property. There is no need to set the `from`
    property, as the animation will automatically use the current position of the
    disk as the starting point. Finally, we calculated the `duration` of each step
    to ensure steady movement of the disk.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所动画的属性是`vector3d`类型，因此我们需要使用能够正确插值向量所有三个分量的`Vector3dAnimation`类型。我们为动画的三个部分设置了相同的`target`和`property`。然后，我们仔细计算了每个阶段后磁盘的最终位置，并将其分配给`to`属性。不需要设置`from`属性，因为动画将自动使用磁盘的当前位置作为起始点。最后，我们计算了每一步的`duration`以确保磁盘的平稳移动。
- en: 'Of course, we want to test the new animation right away. Add a `DiskAnimation`
    object to the `Scene` component and initialize the animation at the end of the 
    `Component.onCompleted` handler:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们想立即测试新的动画。将`DiskAnimation`对象添加到`Scene`组件中，并在`Component.onCompleted`处理器的末尾初始化动画：
- en: '[PRE27]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When you run the application, you should see the top disk moving from one rod
    to another.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行应用程序时，你应该看到顶部圆盘从一个杆子移动到另一个杆子。
- en: Time for action – implementing game logic
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 实现游戏逻辑
- en: Most of the required preparations are done, and now it's time to make our game
    functional. The player should be able to make a move by clicking on a rod and
    then clicking on another rod. After the first rod is selected, the game should
    remember it and show it in a different color.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的大部分准备工作都已完成，现在是时候使我们的游戏功能化了。玩家应该能够通过点击一个杆子然后点击另一个杆子来进行移动。在选择了第一杆后，游戏应该记住它并以不同的颜色显示它。
- en: 'First, let''s prepare the `Rod` component. We need it to have a new property
    that indicates that this rod was selected as the first rod for the next move:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们准备`Rod`组件。我们需要它有一个新的属性，表示该杆被选为下一次移动的第一杆：
- en: '[PRE28]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'It''s easy to make the rod change color depending on the `isSourceRod` value
    using a property binding:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 使用属性绑定很容易根据`isSourceRod`值使杆子改变颜色：
- en: '[PRE29]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now let''s turn our attention to the `Scene` component. We''ll need a property
    that contains the currently selected first rod:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将注意力转向`Scene`组件。我们需要一个包含当前所选第一杆的属性：
- en: '[PRE30]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'All that remains is the implementation of the `rodClicked()` function. Let''s
    go through it in two steps:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是实现`rodClicked()`函数。让我们分两步进行：
- en: '[PRE31]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: First, we check whether the move animation is already running, and ignore the
    event if it is. Next, we check whether the clicked rod was already selected. In
    this case, we simply deselect the rod. This allows the player to cancel the move
    if they accidentally selected an incorrect rod.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查移动动画是否已经在运行，如果是，则忽略事件。接下来，我们检查点击的杆子是否已经被选中。在这种情况下，我们简单地取消选中杆子。这允许玩家在意外选中错误的杆子时取消移动。
- en: If `sourceRod` is unset, that means that we're in the first phase of the move.
    We check that the clicked rod has some disks on it, otherwise a move would not
    be possible. If everything is all right, we set the `sourceRod` property and the
    rod's `isSourceRod` property.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`sourceRod`未设置，这意味着我们处于移动的第一阶段。我们检查点击的杆子上是否有圆盘，否则移动将不可能。如果一切正常，我们设置`sourceRod`属性和杆子的`isSourceRod`属性。
- en: 'The rest of the function handles the second phase of the move:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的其余部分处理移动的第二阶段：
- en: '[PRE32]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this branch, we already know that we have the first rod object stored in
    the `sourceRod` property. We store the clicked rod object in the `targetRod` variable.
    Next, we check whether the player tries to put a larger disk on top of the smaller
    one. If that's the case, we refuse to make the invalid move.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个分支中，我们已经知道我们已经在`sourceRod`属性中存储了第一杆对象。我们将点击的杆子对象存储在`targetRod`变量中。接下来，我们检查玩家是否试图将较大的圆盘放在较小的圆盘上面。如果是这样，我们拒绝执行无效的移动。
- en: If everything is correct, we finally perform the move. We use the `pop()` function
    to remove the disk from the end of the `sourceRod.disks` array. This is the disk
    that will be moved to the other rod. We immediately push the disk object to the
    `disks` array of the other rod. Next, we carefully set up all properties of the
    animation and start it. At the end of the function, we clear the rod's `isSourceRod`
    property and the scene's `sourceRod` property to allow the player to make the
    next move.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，我们最终执行移动。我们使用`pop()`函数从`sourceRod.disks`数组的末尾移除圆盘。这是将被移动到另一个杆子的圆盘。我们立即将圆盘对象推入另一个杆子的`disks`数组。接下来，我们仔细设置动画的所有属性并启动它。在函数的末尾，我们清除杆子的`isSourceRod`属性和场景的`sourceRod`属性，以便玩家可以进行下一次移动。
- en: Have a go hero – improving the game
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试英雄之旅 - 提升游戏
- en: Try to make your own modifications to the game. For example, you can notify
    the player about an invalid move by flashing the background color or the color
    of the foundation object. You can even add a 3D text to the scene using the `ExtrudedTextMesh`
    component. Try to play with different easing modes to make the animations look
    better.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试对游戏进行自己的修改。例如，你可以通过闪烁背景颜色或基础对象的颜色来通知玩家一个无效的移动。你甚至可以使用`ExtrudedTextMesh`组件在场景中添加3D文本。尝试使用不同的缓动模式来使动画看起来更好。
- en: The properties and functions of the `Scene` object are visible to the outside
    world, but they really are implementation details. You can fix that by putting
    them into an internal `QtObject`, as we described in [Chapter 12](4fdfe294-c35c-476d-9656-0aefd533e491.xhtml),
    *Customization in Qt Quick*.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`Scene`对象的属性和函数对外部世界是可见的，但它们实际上是实现细节。您可以通过将它们放入一个内部的`QtObject`中来解决这个问题，正如我们在[第12章](4fdfe294-c35c-476d-9656-0aefd533e491.xhtml)，“Qt
    Quick的自定义”中描述的那样。'
- en: 'Qt 3D is very flexible when it comes to rendering. While it''s straightforward
    to use with the simple `ForwardRenderer`, you can create a much more complex render
    graph if you want. It''s possible to render to multiple viewports, use off-screen
    textures, apply custom shaders, and create your own graphics effects and materials.
    We can''t discuss all these possibilities in this book, but you can look at Qt
    examples to see how this can be done. Some of the relevant examples are Qt3D:
    Multi Viewport QML, Qt3D: Shadow Map QML, and Qt3D: Advanced custom material QML.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染方面，Qt 3D非常灵活。虽然它与简单的`ForwardRenderer`使用起来很直接，但如果您想要创建一个更复杂的渲染图，您也可以做到。您可以将渲染输出到多个视口，使用离屏纹理，应用自定义着色器，并创建自己的图形效果和材质。我们无法在本书中讨论所有这些可能性，但您可以通过查看Qt示例来了解如何实现。一些相关的示例包括Qt3D：多视口QML、Qt3D：阴影映射QML和Qt3D：高级自定义材质QML。
- en: Integration with 3D modeling software
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与3D建模软件的集成
- en: Geometric shapes provided by the `Qt3DExtras` module are great for prototyping.
    As we saw, these mesh generators come in handy when you want to create and test
    a new game quickly. However, a real game usually contains more complex figures
    than spheres and cubes. The meshes are usually prepared using specialized 3D modelling
    software. Qt 3D provides wide capabilities for importing 3D data from external
    files.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`Qt3DExtras`模块提供的几何形状非常适合原型设计。正如我们所见，当您想要快速创建和测试新游戏时，这些网格生成器非常有用。然而，一个真正的游戏通常包含比球体和立方体更复杂的图形。网格通常使用专门的3D建模软件准备。Qt
    3D提供了从外部文件导入3D数据的广泛功能。'
- en: The first way of importing such data is the `Mesh` component. You only need
    to attach this component to an entity and specify the path to the file using the
    `source` property. As of Qt 5.10, `Mesh` supports OBJ, PLY, STL, and Autodesk
    FBX file formats.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 导入此类数据的第一种方式是`Mesh`组件。您只需将此组件附加到实体上，并使用`source`属性指定文件路径。从Qt 5.10版本开始，`Mesh`支持OBJ、PLY、STL和Autodesk
    FBX文件格式。
- en: As always, you can use a real filename or a Qt resource path. However, note
    that the source property expects an URL, not a path. A correct absolute resource
    path should start with `qrc:/`, and an absolute file path should start with `file://`.
    You can also use relative paths that will be resolved relatively to the current
    QML file.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 与往常一样，您可以使用真实的文件名或Qt资源路径。但是请注意，源属性期望一个URL，而不是路径。正确的绝对资源路径应以`qrc:/`开头，而绝对文件路径应以`file://`开头。您还可以使用相对路径，这些路径将相对于当前QML文件进行解析。
- en: If you're using OBJ files, `Mesh` provides you with an additional option to
    only load a sub-mesh from the `source` file. You can do it by specifying the name
    of the sub-mesh in the `meshName` property of the `Mesh` component. Instead of
    the exact name, you can also specify a regular expression to load all sub-meshes
    matching that expression.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用OBJ文件，`Mesh`为您提供了从`source`文件中仅加载子网格的附加选项。您可以通过在`Mesh`组件的`meshName`属性中指定子网格的名称来实现。除了确切名称外，您还可以指定一个正则表达式来加载所有匹配该表达式的子网格。
- en: Time for action – using OBJ files for the disks
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 使用OBJ文件处理磁盘
- en: Qt 3D doesn't provide a suitable mesh for the disks, but we can use a 3D modelling
    software to make any shape we want and then use it in our project. You will find
    the required OBJ files in the resources that come with the book. The files are
    named from `disk0.obj` to `disk7.obj`. If you want to practice with a 3D modelling
    software, you can prepare the files yourself.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 3D不提供适合磁盘的合适网格，但我们可以使用3D建模软件制作我们想要的任何形状，然后将其用于我们的项目中。您将在本书附带资源中找到所需的OBJ文件。文件命名从`disk0.obj`到`disk7.obj`。如果您想使用3D建模软件进行练习，您可以自己准备这些文件。
- en: 'Create a subdirectory named `obj` in your project directory and put the OBJ
    files there. Invoke the context menu of `qml.qrc` in the Qt Creator''s project
    tree and select Add Existing Files. Add all OBJ files to the project. To put these
    files to work, we need to edit the `Disk.qml` file. Remove scale and rotation
    from the `Transform` component. Replace `TorusMesh` with `Mesh` and specify the
    resource path to the OBJ file as the `source` property:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的项目目录中创建一个名为 `obj` 的子目录，并将 OBJ 文件放在那里。在 Qt Creator 的项目树中调用 `qml.qrc` 的上下文菜单，并选择“添加现有文件”。将所有
    OBJ 文件添加到项目中。为了使这些文件发挥作用，我们需要编辑 `Disk.qml` 文件。从 `Transform` 组件中移除缩放和旋转。将 `TorusMesh`
    替换为 `Mesh` 并将资源路径指定为 `source` 属性：
- en: '[PRE33]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Qt 3D will now use our new models for the disks:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 3D 将现在使用我们新的磁盘模型：
- en: '![](img/9ac45d17-62bc-4229-bb96-e6204b89cfdb.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9ac45d17-62bc-4229-bb96-e6204b89cfdb.png)'
- en: Loading a 3D scene
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载 3D 场景
- en: The `Mesh` component is useful when you want to import a single object's shape
    from an external file. However, sometimes you want to import multiple objects
    from a single file. For example, you could prepare some decorations surrounding
    your game action and then import them all at once. This is where the `SceneLoader`
    component becomes useful.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要从外部文件导入单个对象的形状时，`Mesh` 组件非常有用。然而，有时你希望从单个文件中导入多个对象。例如，你可以准备一些围绕你的游戏动作的装饰，然后一次性导入它们。这就是
    `SceneLoader` 组件变得有用的地方。
- en: 'It can be used similar to the `Mesh` component:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以像 `Mesh` 组件一样使用：
- en: '[PRE34]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: However, instead of providing shape for its entity, `SceneLoader` creates a
    whole tree of `Entity` objects that become children of the `SceneLoader`'s entity.
    Each new entity will be provided with a mesh, a material, and a transform according
    to the file data. `SceneLoader` uses Assimp (Open Asset Import Library) to parse
    the source files, so it supports many common 3D formats.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`SceneLoader` 不是提供其实体的形状，而是创建一个整个的 `Entity` 对象树，这些对象成为 `SceneLoader` 实体的子对象。每个新的实体都将根据文件数据提供网格、材质和变换。`SceneLoader`
    使用 Assimp（Open Asset Import Library）来解析源文件，因此它支持许多常见的 3D 格式。
- en: Working with Qt 3D using C++
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 C++ 与 Qt 3D 一起工作
- en: While QML is a powerful and convenient way of using Qt 3D, sometimes you may
    have reasons to prefer C++ over QML. For example, if your project has a large
    C++ codebase or your team is not familiar with JavaScript, sticking with C++ might
    be the right solution. If you want to extend a Qt 3D class with your custom implementation,
    you'll have to use the C++ approach. Additionally, if you deal with large amounts
    of objects, processing them in C++ may be noticeably faster than doing that in
    QML. Qt allows you to choose between C++ and QML freely.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 QML 是使用 Qt 3D 的强大且便捷的方式，但有时你可能出于某些原因更愿意使用 C++ 而不是 QML。例如，如果你的项目有一个庞大的 C++
    代码库或者你的团队不熟悉 JavaScript，坚持使用 C++ 可能是正确的解决方案。如果你想用你的自定义实现扩展 Qt 3D 类，你必须使用 C++ 方法。此外，如果你处理大量对象，在
    C++ 中处理它们可能比在 QML 中处理要快得多。Qt 允许你自由选择 C++ 和 QML。
- en: The QML API of Qt 3D for the most part consists of C++ classes exposed without
    many changes. That means that most of the code you've seen in this chapter so
    far can be transparently translated to the equivalent C++ code with minimal effort.
    When you elect not to use QML, you lose its property bindings, syntax sugar, and
    the ability to declare trees of objects that are automatically instantiated. However,
    as long as you're familiar with the core of Qt C++ API, you shouldn't have any
    issues. You'll have to create objects manually and assign parents to them. In
    place of property bindings, you'll have to connect to property change signals
    and perform the required updates manually. If you studied the earlier chapters
    of this book, you should have no problems with doing that.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 3D 的 QML API 主要由没有太多变化的 C++ 类组成。这意味着到目前为止你在这个章节中看到的绝大部分代码都可以通过最小努力透明地转换为等效的
    C++ 代码。当你选择不使用 QML 时，你会失去其属性绑定、语法糖以及声明自动实例化的对象树的能力。然而，只要你熟悉 Qt C++ API 的核心，你就应该不会有任何问题。你将不得不手动创建对象并将它们分配给父对象。作为属性绑定的替代，你将不得不连接到属性更改信号并手动执行所需的更新。如果你已经学习了这本书的前几章，你应该不会有任何问题。
- en: Time for action – creating a 3D scene using C++
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 使用 C++ 创建 3D 场景
- en: 'Let''s see how we can recreate our first Qt 3D scene using only C++ code. Our
    scene will contain a light source, a cube, and a first person camera controller.
    You can use the Qt Console Application template to create the project. Don''t
    forget to enable the Qt 3D modules you want to use in the project file:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何仅使用 C++ 代码重新创建我们的第一个 Qt 3D 场景。我们的场景将包含一个光源、一个立方体和一个第一人称相机控制器。你可以使用
    Qt 控制台应用程序模板来创建项目。不要忘记在项目文件中启用你想要在项目中使用的 Qt 3D 模块：
- en: '[PRE35]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The first change compared to the QML approach is that you need to use the `Qt3DWindow`
    class instead of `Qt3DQuickWindow`. The `Qt3DWindow` class performs a few actions
    that are typically needed in a Qt 3D application. It sets up a `QForwardRenderer`,
    a camera, and initializes the `QInputSettings` object needed for processing events.
    You can access the default frame graph using the `defaultFrameGraph()` method.
    The default camera is available using the `camera()` method. The aspect ratio
    of the default camera is updated automatically according to the window size. If
    you want to set up a custom frame graph, use the `setActiveFrameGraph()` method.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 与 QML 方法相比，第一个变化是你需要使用 `Qt3DWindow` 类而不是 `Qt3DQuickWindow`。`Qt3DWindow` 类执行了在
    Qt 3D 应用程序中通常需要的几个操作。它设置了一个 `QForwardRenderer`、一个相机，并初始化了处理事件所需的 `QInputSettings`
    对象。你可以使用 `defaultFrameGraph()` 方法访问默认帧图。默认相机可以通过 `camera()` 方法获得。默认相机的纵横比会自动根据窗口大小更新。如果你想要设置自定义帧图，请使用
    `setActiveFrameGraph()` 方法。
- en: 'All the code from our small example will be put into the `main()` function.
    Let''s go through it piece by piece. First, we initialize the usual `QGuiApplication`
    object, create a `Qt3DWindow` object, and apply our preferred settings to its
    frame graph and camera:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们小型示例中的所有代码都将放入 `main()` 函数中。让我们逐个分析它。首先，我们初始化通常的 `QGuiApplication` 对象，创建一个
    `Qt3DWindow` 对象，并将其帧图和相机的首选设置应用于它：
- en: '[PRE36]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Next, we create a root entity object that will hold all our other entities
    and create a camera controller attached to the camera:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个根实体对象，它将包含我们所有的其他实体，并为相机创建一个相机控制器：
- en: '[PRE37]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Next, we set up a light entity:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置一个灯光实体：
- en: '[PRE38]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'It''s important that we pass the root entity to the `QEntity` constructor to
    ensure that the new entity will be a part of our scene. To add a component to
    the entity, we use the `addComponent()` function. The next step is to set up the
    cube 3D object:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，我们需要将根实体传递给 `QEntity` 构造函数，以确保新实体将成为我们场景的一部分。要向实体添加组件，我们使用 `addComponent()`
    函数。下一步是设置立方体 3D 对象：
- en: '[PRE39]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'As you can see, this code simply creates a few objects and sets their properties
    to the same values we used in our QML example. The final lines of code complete
    our setup:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，此代码只是创建了一些对象，并将它们的属性设置为我们在 QML 示例中使用的相同值。代码的最后几行完成了我们的设置：
- en: '[PRE40]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We pass the root entity to the window and show it on screen. That's all! Qt
    3D will render the constructed scene in the same way it worked in our QML project.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将根实体传递给窗口并在屏幕上显示它。这就完成了！Qt 3D 将以与我们的 QML 项目相同的方式渲染构建的场景。
- en: All properties of Qt 3D classes are equipped with change notification signals,
    so you can use connect statements to react to external changes properties. For
    example, if you use the `Qt3DInput::QAction` component to receive keyboard or
    mouse events, you can use its `activeChanged(bool isActive)` signal to get notifications
    about the event. You can also perform animations in the 3D scene using C++ animation
    classes such as `QPropertyAnimation`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 3D 类的所有属性都配备了变更通知信号，因此你可以使用连接语句来对外部属性变更做出反应。例如，如果你使用 `Qt3DInput::QAction`
    组件来接收键盘或鼠标事件，你可以使用它的 `activeChanged(bool isActive)` 信号来获取关于事件的通知。你还可以使用 C++ 动画类，如
    `QPropertyAnimation`，在 3D 场景中执行动画。
- en: Integration with Qt Widgets and Qt Quick
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 Qt Widgets 和 Qt Quick 的集成
- en: While Qt 3D is a very powerful module, sometimes it's not enough to make a complete
    game or application. Other Qt modules such as Qt Quick or Qt Widgets can be very
    helpful, for example, when working on the user interface of your game. Luckily,
    Qt provides a few ways to use different modules together.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Qt 3D 是一个非常强大的模块，但有时它不足以制作一个完整的游戏或应用程序。其他 Qt 模块，如 Qt Quick 或 Qt Widgets，可能非常有帮助，例如，当你在游戏的用户界面工作时。幸运的是，Qt
    提供了一些方法来共同使用不同的模块。
- en: When it comes to Qt Widgets, your best bet is the `QWidget::createWindowContainer()`
    function. It allows you to surround your 3D view with widgets and display them
    all in a single window. This approach was already discussed in [Chapter 9](15aa8ec3-9e80-4f68-8e0e-f365e860f5c5.xhtml),
    *OpenGL and Vulkan in Qt Applications*, and can be applied to Qt 3D without any
    changes.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到 Qt Widgets 时，您最好的选择是 `QWidget::createWindowContainer()` 函数。它允许您将小部件包围在
    3D 视图中，并在单个窗口中显示它们。这种方法已经在 [第 9 章](15aa8ec3-9e80-4f68-8e0e-f365e860f5c5.xhtml)
    中讨论过，即 *Qt 应用程序中的 OpenGL 和 Vulkan*，并且可以应用于 Qt 3D 而无需任何更改。
- en: However, the capabilities of Qt Widgets are still limited in the world of hardware-accelerated
    graphics. Qt Quick is much more promising in this area, and the synergy between
    QML APIs of Qt Quick and Qt 3D can prove to be very strong. Qt provides two ways
    to combine Qt Quick and Qt 3D in a single application without significant performance
    costs. Let's take a closer look at them.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在硬件加速图形的世界中，Qt Widgets 的功能仍然有限。Qt Quick 在这个领域具有更大的潜力，Qt Quick 的 QML API 与
    Qt 3D 之间的协同作用可能非常强大。Qt 提供了两种方法，可以在单个应用程序中将 Qt Quick 和 Qt 3D 结合起来，而不会产生显著的性能成本。让我们更详细地看看它们。
- en: Embedding Qt Quick UI into a 3D scene
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Qt Quick UI 嵌入 3D 场景
- en: Qt 3D allows you to embed an arbitrary Qt Quick item into your 3D scene using
    the `Scene2D` type. How does that work? First, you need to put your Qt Quick content
    into a new `Scene2D` object. Next, you need to declare a texture that will be
    used as a render target for the form. Whenever Qt Quick decides to update its
    virtual view, the `Scene2D` object will render it directly to the specified texture.
    You only need to display this texture as you want. The most simple way of doing
    that is to pass it to a `TextureMaterial` component attached to one of your 3D
    objects.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 3D 允许您使用 `Scene2D` 类型将任意 Qt Quick 项目嵌入到您的 3D 场景中。这是如何工作的？首先，您需要将您的 Qt Quick
    内容放入一个新的 `Scene2D` 对象中。接下来，您需要声明一个将用作表单渲染目标的纹理。每当 Qt Quick 决定更新其虚拟视图时，`Scene2D`
    对象将直接将其渲染到指定的纹理中。您只需要按您想要的方式显示此纹理。最简单的方法是将它传递给附加到您的 3D 对象之一的 `TextureMaterial`
    组件。
- en: 'However, this is only one part of the job. It''s nice to allow users to see
    your form, but they should also be able to interact with it. This is also supported
    by `Scene2D`! To make it work, you need to do the following:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这仅仅是工作的一部分。允许用户看到您的表单是件好事，但他们也应该能够与之交互。这也由 `Scene2D` 支持！为了使其工作，您需要执行以下操作：
- en: Set `pickMethod` to `TrianglePicking` in the `RenderSettings`. This will allow
    object pickers to retrieve more accurate information about mouse events.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `RenderSettings` 中将 `pickMethod` 设置为 `TrianglePicking`。这将允许对象选择器检索关于鼠标事件的更准确信息。
- en: Attach an `ObjectPicker` component to all entities that use the texture created
    by `Scene2D`. It's a good idea to set the `hoverEnabled` and `dragEnabled` properties
    of the object picker to `true` to make mouse events work as expected.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `ObjectPicker` 组件附加到所有使用由 `Scene2D` 创建的纹理的实体。将对象选择器的 `hoverEnabled` 和 `dragEnabled`
    属性设置为 `true` 是一个好主意，以便使鼠标事件按预期工作。
- en: Specify all these entities in the `entities` property of the `Scene2D` object.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Scene2D` 对象的 `entities` 属性中指定所有这些实体。
- en: This will allow `Scene2D` to forward mouse events to the Qt Quick content. Unfortunately,
    forwarding keyboard events is not available yet.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许 `Scene2D` 将鼠标事件转发到 Qt Quick 内容。不幸的是，转发键盘事件目前尚不可用。
- en: 'Let''s see an example of this approach:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个方法的示例：
- en: '[PRE41]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This code sets up a Qt 3D scene that contains a `Scene2D` object. `Scene2D`
    itself is not visible in the 3D scene. We declare a texture that will receive
    the rendered Qt Quick content. You can choose `width` and `height` of the texture
    depending on the size of the displayed content.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码设置了一个包含 `Scene2D` 对象的 Qt 3D 场景。`Scene2D` 本身在该 3D 场景中是不可见的。我们声明了一个将接收渲染的 Qt
    Quick 内容的纹理。您可以根据显示内容的尺寸选择纹理的 `width` 和 `height`。
- en: Next, we declare that we'll render this texture in two entities (we'll create
    them in the next piece of code). Finally, we place a Qt Quick item directly into
    the `Scene2D` object. Make sure you set this size for your Qt Quick item according
    to the size of the texture. In our example, we created a form containing three
    checkboxes in a layout.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明我们将在这个纹理中渲染两个实体（我们将在下一部分代码中创建它们）。最后，我们将一个 Qt Quick 项目直接放置到 `Scene2D`
    对象中。确保您根据纹理的尺寸设置此 Qt Quick 项目的尺寸。在我们的示例中，我们创建了一个包含三个复选框的表单。
- en: 'The next part of code creates two items for displaying the Qt Quick-based texture:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 下一部分代码创建了两个用于显示基于 Qt Quick 的纹理的项目：
- en: '[PRE42]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The first item is a cube, and the second item is a plane. Most of the properties
    are just arbitrary values that make the scene look good. The important part is
    that each item has a `TextureMaterial` component, and we passed the `texture`
    object into it. Each item also has an `ObjectPicker` component that allows the
    user to interact with the item. Note that we used the `mirrored` property of `PlaneMesh`
    to display the texture in its original (not mirrored) orientation.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个项是一个立方体，第二个项是一个平面。大部分属性只是使场景看起来好的任意值。重要的是每个项都有一个`TextureMaterial`组件，并且我们将`texture`对象传递给它。每个项还有一个允许用户与之交互的`ObjectPicker`组件。请注意，我们使用了`PlaneMesh`的`mirrored`属性来以原始（非镜像）方向显示纹理。
- en: One plane object is usually enough to display your form. We used two objects
    purely for demonstration purposes.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 通常一个平面物体就足以展示你的形状。我们使用两个物体纯粹是为了演示目的。
- en: 'While Qt Quick items and Qt 3D entities live in different worlds and don''t
    seem to interact with each other, they are still declared in a single QML file,
    so you can use property bindings and other QML techniques to make all these items
    work together. In our example, not only is the background color of the root Qt
    Quick item controlled by the checkbox, but the 3D objects are also influenced
    by checkboxes:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Qt Quick项和Qt 3D实体存在于不同的世界中，看起来它们不会相互交互，但它们仍然在单个QML文件中声明，因此你可以使用属性绑定和其他QML技术使所有这些项协同工作。在我们的例子中，不仅根Qt
    Quick项的背景颜色由复选框控制，3D对象也受到复选框的影响：
- en: '![](img/46724776-f305-4da1-8269-01df5ad34e00.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/46724776-f305-4da1-8269-01df5ad34e00.png)'
- en: Embedding a Qt 3D scene into a Qt Quick form
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Qt 3D场景嵌入到Qt Quick表单中
- en: Now let's see how we can perform the opposite task. This approach is useful
    if your application is built mainly around Qt Quick. This means that you use the `QQmlApplicationEngine`
    class in the `main()` function, and the root object of your `main.qml` file is
    usually the `Window` object. It's very easy to extend your Qt Quick application
    with a bit of 3D action.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何执行相反的任务。如果你的应用程序主要是围绕Qt Quick构建的，这种方法很有用。这意味着你在`main()`函数中使用`QQmlApplicationEngine`类，并且你的`main.qml`文件的根对象通常是`Window`对象。用一点3D动作扩展你的Qt
    Quick应用程序非常简单。
- en: 'We could place all the code into the `main.qml` file, but it''s more convenient
    to split it because setting up a 3D scene requires quite a bit of code. Let''s
    say you have a file named `My3DScene.qml` that contains the usual content of a
    3D scene:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将所有代码放入`main.qml`文件中，但将其拆分更方便，因为设置3D场景需要相当多的代码。假设你有一个名为`My3DScene.qml`的文件，它包含3D场景的常规内容：
- en: '[PRE43]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To add this 3D scene into the `main.qml` file (or any other Qt Quick-based
    QML file), you should use the `Scene3D` QML type that can be imported from the `QtQuick.Scene3D`
    module. For example, this is how you can create a form with a button and a 3D
    view:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此3D场景添加到`main.qml`文件（或任何其他基于Qt Quick的QML文件），你应该使用可以从`QtQuick.Scene3D`模块导入的`Scene3D`
    QML类型。例如，这是如何创建一个带有按钮和3D视图的表单的方法：
- en: '[PRE44]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Most of the code is the usual content of a Qt Quick form. The `Scene3D` item
    does all the magic. The root 3D entity should be added to this item directly or,
    as in our case, in the form of a custom component. The `Scene3D` item sets up
    a Qt 3D engine and renders the passed scene:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分代码是Qt Quick表单的常规内容。`Scene3D`项执行所有魔法。根3D实体应直接添加到该项，或者，如我们的案例所示，以自定义组件的形式添加。`Scene3D`项设置Qt
    3D引擎并渲染传递的场景：
- en: '![](img/403e934d-6ae3-423a-8e4c-aa4a8257b994.png)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/403e934d-6ae3-423a-8e4c-aa4a8257b994.png)'
- en: If you want to use `Qt3DInput` or `Qt3DLogic` modules, you need to enable the
    corresponding 3D aspects using the `aspects` property of `Scene3D`, as shown in
    the screenshot. Additionally, the `multisample` Boolean property can be used to
    enable multisampling. The `hoverEnabled` property can be used to enable handling
    of mouse events when mouse buttons are not pressed.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要使用`Qt3DInput`或`Qt3DLogic`模块，你需要使用`Scene3D`的`aspects`属性启用相应的3D方面，如图所示。此外，可以使用`multisample`布尔属性启用多采样。可以使用`hoverEnabled`属性在鼠标按钮未按下时处理鼠标事件。
- en: Similar to `Qt3DQuickWindow`, `Scene3D` sets the camera's aspect ratio automatically
    by default. You can disable it by setting its `cameraAspectRatioMode` property
    to `Scene3D.UserAspectRatio`.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Qt3DQuickWindow`类似，`Scene3D`默认自动设置摄像机的宽高比。你可以通过将其`cameraAspectRatioMode`属性设置为`Scene3D.UserAspectRatio`来禁用它。
- en: This approach can also be used to display some UI controls on top of the 3D
    view. This will allow you to use the full power of Qt Quick to make the UI of
    your game amazing.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法也可以用来在 3D 视图上显示一些 UI 控件。这将允许您利用 Qt Quick 的全部功能，使您的游戏 UI 精彩绝伦。
- en: Pop quiz
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速问答
- en: Q1\. Which component can be used to rotate a 3D object?
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. 哪个组件可以用来旋转 3D 对象？
- en: '`CuboidMesh`'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CuboidMesh`'
- en: '`RotationAnimation`'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RotationAnimation`'
- en: '`Transform`'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Transform`'
- en: Q2\. Which component is the most suitable for emulating the light of the sun?
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: Q2. 哪个组件最适合模拟太阳光？
- en: '`DirectionalLight`'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DirectionalLight`'
- en: '`PointLight`'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PointLight`'
- en: '`SpotLight`'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SpotLight`'
- en: Q3\. What is a Qt 3D material?
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: Q3. Qt 3D 材料是什么？
- en: An object that allows you to load a texture from a file.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个允许您从文件中加载纹理的对象。
- en: A component that defines the physical properties of the object.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义对象物理属性的组件。
- en: A component that defines the visible properties of the object's surface.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义对象表面可见属性的组件。
- en: Summary
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we learned to create 3D games with Qt. We saw how to create
    and position 3D objects in the scene and configure the camera for rendering. Next,
    we examined how we can handle user input using Qt 3D. More than that, you learned
    to apply your existing animation skills to Qt 3D objects. Finally, we found out
    how to use Qt 3D together with other Qt modules.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用 Qt 创建 3D 游戏。我们看到了如何在场景中创建和定位 3D 对象，并配置相机进行渲染。接下来，我们探讨了如何使用 Qt
    3D 处理用户输入。不仅如此，您还学会了将现有的动画技能应用到 Qt 3D 对象上。最后，我们发现了如何将 Qt 3D 与其他 Qt 模块一起使用。
- en: Like Qt Quick, Qt 3D is rapidly evolving. At the time of writing, some of the
    modules are still experimental. You should expect the API of Qt 3D to be improved
    and extended, so make sure you check the Qt documentation for newer releases.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Qt Quick 一样，Qt 3D 正在快速发展。在撰写本文时，一些模块仍然是实验性的。您应该期待 Qt 3D 的 API 将得到改进和扩展，因此请确保您检查
    Qt 文档以获取新版本。
- en: This concludes our book on game programming using Qt. We have taught you the
    general basics of Qt, described its widget realm to you, and introduced you to
    the fascinating world of Qt Quick and Qt 3D. Widgets (including Graphics View),
    Qt Quick, and Qt 3D are the main paths you can take when creating games using
    the Qt framework. We have also shown you ways of merging the two approaches by
    making use of any OpenGL or Vulkan skills you might have, going beyond what Qt
    already offers today. At this point, you should start playing around and experimenting,
    and if at any point you feel lost or simply lack the information on how to do
    something, the very helpful Qt reference manual should be the first resource you
    direct yourself to.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书关于使用 Qt 进行游戏编程的内容到此结束。我们向您介绍了 Qt 的一般基础知识，描述了其小部件领域，并带您进入了 Qt Quick 和 Qt 3D
    的迷人世界。Widgets（包括 Graphics View）、Qt Quick 和 Qt 3D 是您在用 Qt 框架创建游戏时可以采取的主要路径。我们还向您展示了如何利用您可能拥有的任何
    OpenGL 或 Vulkan 技能，通过合并这两种方法来超越 Qt 当前的功能。此时，您应该开始尝试和实验，如果您在任何时候感到迷茫或缺乏如何做某事的信息，非常有帮助的
    Qt 参考手册应该是您首先指向的资源。
- en: Good luck and have lots of fun!
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 祝您好运，玩得开心！
