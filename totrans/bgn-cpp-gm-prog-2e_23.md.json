["```cpp\n#include <SFML/Graphics.hpp>\nclass BulletSpawner\n{\npublic:\n    virtual void spawnBullet(\n        sf::Vector2f spawnLocation, bool forPlayer) = 0;\n};\n```", "```cpp\n/*********************************\n******THIS IS AN INTERFACE********\n*********************************/\n```", "```cpp\n#pragma once\n#include \"Screen.h\"\n#include \"GameInputHandler.h\"\n#include \"GameOverInputHandler.h\"\n#include \"BulletSpawner.h\"\nclass GameScreen : public Screen, public BulletSpawner\n{\n   …\n   …\n```", "```cpp\nprivate:\n    ScreenManagerRemoteControl* m_ScreenManagerRemoteControl;\n    shared_ptr<GameInputHandler> m_GIH;\n    int m_NumberInvadersInWorldFile = 0;\n    vector<int> m_BulletObjectLocations;\n    int m_NextBullet = 0;\n    bool m_WaitingToSpawnBulletForPlayer = false;\n    bool m_WaitingToSpawnBulletForInvader = false;\n    Vector2f m_PlayerBulletSpawnLocation;\n    Vector2f m_InvaderBulletSpawnLocation;\n    Clock m_BulletClock;\n    Texture m_BackgroundTexture;\n    Sprite m_BackgroundSprite;\npublic:\n    static bool m_GameOver;\n    GameScreen(ScreenManagerRemoteControl* smrc, Vector2i res);\n    void initialise() override;\n    void virtual update(float fps);\n    void virtual draw(RenderWindow& window);\n    BulletSpawner* getBulletSpawner();\n```", "```cpp\n/****************************************************\n*****************************************************\nFrom BulletSpawner interface\n*****************************************************\n*****************************************************/\nvoid BulletSpawner::spawnBullet(Vector2f spawnLocation, \n    bool forPlayer)\n{\n    if (forPlayer)\n    {\n        Time elapsedTime = m_BulletClock.getElapsedTime();\n        if (elapsedTime.asMilliseconds() > 500) {\n            m_PlayerBulletSpawnLocation.x = spawnLocation.x;\n            m_PlayerBulletSpawnLocation.y = spawnLocation.y;\n            m_WaitingToSpawnBulletForPlayer = true;\n            m_BulletClock.restart();\n        }\n    }\n    else\n    {\n        m_InvaderBulletSpawnLocation.x = spawnLocation.x;\n        m_InvaderBulletSpawnLocation.y = spawnLocation.y;\n        m_WaitingToSpawnBulletForInvader = true;\n    }\n}\n```", "```cpp\nBulletSpawner* GameScreen::getBulletSpawner()\n{\n    return this;\n}\n```", "```cpp\n#pragma once\n#include \"InputHandler.h\"\n#include \"PlayerUpdateComponent.h\"\n#include \"TransformComponent.h\"\nclass GameScreen;\nclass GameInputHandler : public InputHandler\n{\nprivate:\n    shared_ptr<PlayerUpdateComponent> m_PUC;\n    shared_ptr<TransformComponent> m_PTC;\n    bool mBButtonPressed = false;\npublic:\n    void initialize();\n    void handleGamepad() override;\n    void handleKeyPressed(Event& event, \n        RenderWindow& window) override;\n    void handleKeyReleased(Event& event, \n        RenderWindow& window) override;    \n};\n```", "```cpp\n#include \"GameInputHandler.h\"\n#include \"SoundEngine.h\"\n#include \"GameScreen.h\"\nclass BulletSpawner;\nvoid GameInputHandler::initialize() {\n…\n```", "```cpp\nvoid GameInputHandler::handleKeyPressed(\n    Event& event, RenderWindow& window)\n{\n    // Handle key presses\n    if (event.key.code == Keyboard::Escape)\n    {\n        SoundEngine::playClick();\n        getPointerToScreenManagerRemoteControl()->\n            SwitchScreens(\"Select\");\n    }\n\nif (event.key.code == Keyboard::Left)\n    {\n        m_PUC->moveLeft();\n    }\n    if (event.key.code == Keyboard::Right)\n    {\n        m_PUC->moveRight();\n    }\n    if (event.key.code == Keyboard::Up)\n    {\n        m_PUC->moveUp();\n    }\n    if (event.key.code == Keyboard::Down)\n    {\n        m_PUC->moveDown();\n    }\n}\n```", "```cpp\nvoid GameInputHandler::handleKeyReleased(\n    Event& event, RenderWindow& window)\n{\n    if (event.key.code == Keyboard::Left)\n    {\n        m_PUC->stopLeft();\n    }\n    else if (event.key.code == Keyboard::Right)\n    {\n        m_PUC->stopRight();\n    }\n    else if (event.key.code == Keyboard::Up)\n    {\n        m_PUC->stopUp();\n    }\n    else if (event.key.code == Keyboard::Down)\n    {\n        m_PUC->stopDown();\n    }\n    else if (event.key.code == Keyboard::Space)\n    {\n        // Shoot a bullet\n        SoundEngine::playShoot();\n        Vector2f spawnLocation;\nspawnLocation.x = m_PTC->getLocation().x + \n            m_PTC->getSize().x / 2;\n        spawnLocation.y = m_PTC->getLocation().y;\n        static_cast<GameScreen*>(getmParentScreen())->\n            spawnBullet(spawnLocation, true);\n    }\n}\n```", "```cpp\nfloat x  = Joystick::getAxisPosition(0, sf::Joystick::X);\nfloat y = Joystick::getAxisPosition(0, sf::Joystick::Y);\n```", "```cpp\nif (Joystick::isButtonPressed(0, 1))\n{\n    // Take action here\n}\n```", "```cpp\nvoid GameInputHandler::handleGamepad()\n{\n    float deadZone = 10.0f;\n    float x  = Joystick::getAxisPosition(0, sf::Joystick::X);\n    float y = Joystick::getAxisPosition(0, sf::Joystick::Y);    \n\n    if (x < deadZone && x > -deadZone)\n    {\n        x = 0;\n    }\n    if (y < deadZone && y > -deadZone)\n    {\n        y = 0;\n    }\n    m_PUC->updateShipTravelWithController(x, y);    \n    // Has the player pressed the B button?\n    if (Joystick::isButtonPressed(0, 1))\n    {\n        mBButtonPressed = true;\n    }\n    // Has player just released the B button?\n    if (!Joystick::isButtonPressed(0, 1) && mBButtonPressed)\n    {\n        mBButtonPressed = false;\n        // Shoot a bullet\n        SoundEngine::playShoot();\n        Vector2f spawnLocation;\nspawnLocation.x = m_PTC->getLocation().x + \n            m_PTC->getSize().x / 2;\n        spawnLocation.y = m_PTC->getLocation().y;\n\n        static_cast<GameScreen*>(getmParentScreen())->\n            getBulletSpawner()->spawnBullet(\n               spawnLocation, true);\n    }\n}\n```", "```cpp\n#pragma once\n#include \"GameObjectSharer.h\"\n#include \"PlayerUpdateComponent.h\"\nclass PhysicsEnginePlayMode\n{\nprivate:\n    shared_ptr<PlayerUpdateComponent> m_PUC;\n    GameObject* m_Player;\n    bool m_InvaderHitWallThisFrame = false;\n    bool m_InvaderHitWallPreviousFrame = false;\n    bool m_NeedToDropDownAndReverse = false;\n    bool m_CompletedDropDownAndReverse = false;\n    void detectInvaderCollisions(\n        vector<GameObject>& objects,\n        const vector<int>& bulletPositions);\n    void detectPlayerCollisionsAndInvaderDirection(\n        vector<GameObject>& objects,\n        const vector<int>& bulletPositions);\n    void handleInvaderDirection();\npublic:\n    void initilize(GameObjectSharer& gos);\n    void detectCollisions(\n        vector<GameObject>& objects,\n        const vector<int>& bulletPositions);\n};\n```", "```cpp\n#include \"DevelopState.h\"\n#include \"PhysicsEnginePlayMode.h\"\n#include <iostream>\n#include \"SoundEngine.h\"\n#include \"WorldState.h\"\n#include \"InvaderUpdateComponent.h\"\n#include \"BulletUpdateComponent.h\"\nvoid PhysicsEnginePlayMode::\ndetectInvaderCollisions(\n    vector<GameObject>& objects, \n    const vector<int>& bulletPositions)\n{\nVector2f offScreen(-1, -1);\nauto invaderIt = objects.begin();\nauto invaderEnd = objects.end();\nfor (invaderIt;\n    invaderIt != invaderEnd;\n    ++invaderIt)\n{\n    if ((*invaderIt).isActive()\n        && (*invaderIt).getTag() == \"invader\")\n    {\n        auto bulletIt = objects.begin();\n        // Jump to the first bullet\n        advance(bulletIt, bulletPositions[0]);\n        auto bulletEnd = objects.end();\n        for (bulletIt;\n            bulletIt != bulletEnd;\n            ++bulletIt)\n        {\n            if ((*invaderIt).getEncompassingRectCollider()\n                .intersects((*bulletIt)\n                    .getEncompassingRectCollider())\n                && (*bulletIt).getTag() == \"bullet\"\n                && static_pointer_cast<\n                      BulletUpdateComponent>(\n                (*bulletIt).getFirstUpdateComponent())\n                ->m_BelongsToPlayer)\n            {\n                SoundEngine::playInvaderExplode();\n                (*invaderIt).getTransformComponent()\n                    ->getLocation() = offScreen;\n                (*bulletIt).getTransformComponent()\n                    ->getLocation() = offScreen;\n                WorldState::SCORE++;\n                WorldState::NUM_INVADERS--;\n                (*invaderIt).setInactive();\n            }\n        }\n    }\n}\n}\n```", "```cpp\nif ((*invaderIt).isActive()\n        && (*invaderIt).getTag() == \"invader\")\n```", "```cpp\nauto bulletIt = objects.begin();\n// Jump to the first bullet\nadvance(bulletIt, bulletPositions[0]);\nauto bulletEnd = objects.end();\nfor (bulletIt;\n    bulletIt != bulletEnd;\n    ++bulletIt)\n```", "```cpp\nif ((*invaderIt).getEncompassingRectCollider()\n        .intersects((*bulletIt)\n        .getEncompassingRectCollider())\n        && (*bulletIt).getTag() == \"bullet\"\n        && static_pointer_cast<BulletUpdateComponent>(\n        (*bulletIt).getFirstUpdateComponent())\n        ->m_BelongsToPlayer)\n```", "```cpp\nvoid PhysicsEnginePlayMode::\ndetectPlayerCollisionsAndInvaderDirection(\n    vector<GameObject>& objects, \n    const vector<int>& bulletPositions)\n{\nVector2f offScreen(-1, -1);\nFloatRect playerCollider = \n    m_Player->getEncompassingRectCollider();\nshared_ptr<TransformComponent> playerTransform = \n    m_Player->getTransformComponent();\nVector2f playerLocation = \n    playerTransform->getLocation();\nauto it3 = objects.begin();\nauto end3 = objects.end();\nfor (it3;\n    it3 != end3;\n    ++it3)\n{\n    if ((*it3).isActive() &&\n        (*it3).hasCollider() &&\n        (*it3).getTag() != \"Player\")\n    {\n        // Get a reference to all the parts of \n        // the current game object we might need\n        FloatRect currentCollider = (*it3)\n            .getEncompassingRectCollider();\n        // Detect collisions between objects \n        // with the player\n        if (currentCollider.intersects(playerCollider))\n        {\n            if ((*it3).getTag() == \"bullet\")\n            {\n                SoundEngine::playPlayerExplode();\n                WorldState::LIVES--;\n                (*it3).getTransformComponent()->\n                    getLocation() = offScreen;\n            }\n            if ((*it3).getTag() == \"invader\")\n            {\n                SoundEngine::playPlayerExplode();\n                SoundEngine::playInvaderExplode();\n                WorldState::LIVES--;\n                (*it3).getTransformComponent()->\n                    getLocation() = offScreen;\n                WorldState::SCORE++;\n                (*it3).setInactive();\n            }\n        }\n        shared_ptr<TransformComponent> \n            currentTransform =\n            (*it3).getTransformComponent();\n        Vector2f currentLocation = \n            currentTransform->getLocation();\n        string currentTag = (*it3).getTag();\n        Vector2f currentSize = \n            currentTransform->getSize();\n        // Handle the direction and descent \n        // of the invaders\n        if (currentTag == \"invader\")\n        {\n            // This is an invader\n            if (!m_NeedToDropDownAndReverse && \n                !m_InvaderHitWallThisFrame)\n            {\n                // Currently no need to dropdown \n                // and reverse from previous frame \n                // or any hits this frame\n                if (currentLocation.x >= \n                    WorldState::WORLD_WIDTH – \n                            currentSize.x)\n                {\n                    // The invader is passed its \n                    // furthest right position\n                    if (static_pointer_cast\n                        <InvaderUpdateComponent>((*it3)\n                        .getFirstUpdateComponent())->\n                        isMovingRight())\n                    {\n                        // The invader is travelling \n                        // right so set a flag that\n                        // an invader has collided\n\n                        m_InvaderHitWallThisFrame \n                                         = true;\n                    }\n                }\n                else if (currentLocation.x < 0)\n                {\n                    // The invader is past its furthest \n                    // left position\n                    if (!static_pointer_cast\n                        <InvaderUpdateComponent>(        \n                            (*it3).getFirstUpdateComponent())\n                        ->isMovingRight())\n                    {\n                        // The invader is travelling \n                        // left so set a flag that an\n                        // invader has collided \n                        m_InvaderHitWallThisFrame \n                                         = true;\n                    }\n                }\n            }\n            else if (m_NeedToDropDownAndReverse \n                && !m_InvaderHitWallPreviousFrame)\n            {\n                // Drop down and reverse has been set\n                if ((*it3).hasUpdateComponent())\n                {\n                    // Drop down and reverse\n                    static_pointer_cast<\n                            InvaderUpdateComponent>(            \n                            (*it3).getFirstUpdateComponent())\n                    ->dropDownAndReverse();\n                }\n            }\n        }\n    }\n}\n}\n```", "```cpp\nFloatRect playerCollider = \n    m_Player->getEncompassingRectCollider();\nshared_ptr<TransformComponent> playerTransform = \n    m_Player->getTransformComponent();\nVector2f playerLocation = \n    playerTransform->getLocation();\n```", "```cpp\nif ((*it3).isActive() &&\n    (*it3).hasCollider() &&\n    (*it3).getTag() != \"Player\")\n```", "```cpp\nif (currentCollider.intersects(playerCollider))\n```", "```cpp\nvoid PhysicsEnginePlayMode::handleInvaderDirection()\n{\n    if (m_InvaderHitWallThisFrame) {\n        m_NeedToDropDownAndReverse = true;\n        m_InvaderHitWallThisFrame = false;\n    }\n    else {\n        m_NeedToDropDownAndReverse = false;\n    }\n}\n```", "```cpp\nvoid PhysicsEnginePlayMode::initilize(GameObjectSharer& gos) {\n    m_PUC = static_pointer_cast<PlayerUpdateComponent>(\n        gos.findFirstObjectWithTag(\"Player\")\n        .getComponentByTypeAndSpecificType(\"update\", \"player\"));\n    m_Player = &gos.findFirstObjectWithTag(\"Player\");\n}\n```", "```cpp\nvoid PhysicsEnginePlayMode::detectCollisions(\n    vector<GameObject>& objects,\n    const vector<int>& bulletPositions)\n{\n    detectInvaderCollisions(objects, bulletPositions);\n    detectPlayerCollisionsAndInvaderDirection(\n        objects, bulletPositions);\n    handleInvaderDirection();    \n}\n```", "```cpp\n#include \"PhysicsEnginePlayMode.h\"\n```", "```cpp\nprivate:\n    ScreenManagerRemoteControl* m_ScreenManagerRemoteControl;\n    shared_ptr<GameInputHandler> m_GIH;\n    PhysicsEnginePlayMode m_PhysicsEnginePlayMode;\n…\n…\n```", "```cpp\n#include \"GameScreen.h\"\n#include \"GameUIPanel.h\"\n#include \"GameInputHandler.h\"\n#include \"GameOverUIPanel.h\"\n#include \"GameObject.h\"\n#include \"WorldState.h\"\n#include \"BulletUpdateComponent.h\"\n#include \"InvaderUpdateComponent.h\"\nclass BulletSpawner;\nint WorldState::WORLD_HEIGHT;\nint WorldState::NUM_INVADERS;\nint WorldState::NUM_INVADERS_AT_START;\n```", "```cpp\nvoid GameScreen::initialise()\n{\n    m_GIH->initialize();\n    m_PhysicsEnginePlayMode.initilize(\n        m_ScreenManagerRemoteControl->\n        shareGameObjectSharer());\n    WorldState::NUM_INVADERS = 0;\n    // Store all the bullet locations and\n    // Initialize all the BulletSpawners in the invaders\n    // Count the number of invaders\n    int i = 0;\n    auto it = m_ScreenManagerRemoteControl->\n        getGameObjects().begin();\n    auto end = m_ScreenManagerRemoteControl->\n        getGameObjects().end();\n    for (it;\n        it != end;\n        ++it)\n    {\n        if ((*it).getTag() == \"bullet\")\n        {\n            m_BulletObjectLocations.push_back(i);\n        }\n        if ((*it).getTag() == \"invader\")\n        {\n            static_pointer_cast<InvaderUpdateComponent>(\n                (*it).getFirstUpdateComponent())->\n                initializeBulletSpawner(\n                    getBulletSpawner(), i);\n            WorldState::NUM_INVADERS++;\n        }\n        ++i;\n    }\n    m_GameOver = false;\n    if (WorldState::WAVE_NUMBER == 0)\n    {\n        WorldState::NUM_INVADERS_AT_START = \n            WorldState::NUM_INVADERS;\n\n        WorldState::WAVE_NUMBER = 1;\n        WorldState::LIVES = 3;\n        WorldState::SCORE = 0;\n    }\n}\n```", "```cpp\nvoid GameScreen::update(float fps)\n{\n    Screen::update(fps);\n    if (!m_GameOver)\n    {\n        if (m_WaitingToSpawnBulletForPlayer)\n        {\n            static_pointer_cast<BulletUpdateComponent>(\n                m_ScreenManagerRemoteControl->\n                getGameObjects()\n                [m_BulletObjectLocations[m_NextBullet]].\n                getFirstUpdateComponent())->\n                spawnForPlayer(\n                      m_PlayerBulletSpawnLocation);\n\n            m_WaitingToSpawnBulletForPlayer = false;\n            m_NextBullet++;\n            if (m_NextBullet == m_BulletObjectLocations\n                      .size())\n            {\n                m_NextBullet = 0;\n            }\n        }\n        if (m_WaitingToSpawnBulletForInvader)\n        {\n            static_pointer_cast<BulletUpdateComponent>(\n                m_ScreenManagerRemoteControl->\n                getGameObjects()\n                [m_BulletObjectLocations[m_NextBullet]].\n                getFirstUpdateComponent())->\n                spawnForInvader(\n                      m_InvaderBulletSpawnLocation);\n\n            m_WaitingToSpawnBulletForInvader = false;\n            m_NextBullet++;\nif (m_NextBullet == \n                      m_BulletObjectLocations.size())\n            {\n                m_NextBullet = 0;\n            }\n        }\n        auto it = m_ScreenManagerRemoteControl->\n            getGameObjects().begin();\n        auto end = m_ScreenManagerRemoteControl->\n            getGameObjects().end();\n        for (it;\n            it != end;\n            ++it)\n        {\n            (*it).update(fps);\n        }\n\n        m_PhysicsEnginePlayMode.detectCollisions(\nm_ScreenManagerRemoteControl->getGameObjects(), \n            m_BulletObjectLocations);\n        if (WorldState::NUM_INVADERS <= 0)\n        {\n            WorldState::WAVE_NUMBER++;\n            m_ScreenManagerRemoteControl->\n                loadLevelInPlayMode(\"level1\");\n        }\n\n        if (WorldState::LIVES <= 0)\n        {\n            m_GameOver = true;            \n        }\n    }\n}\n```", "```cpp\nvoid GameScreen::draw(RenderWindow & window)\n{    \n    // Change to this screen's view to draw\n    window.setView(m_View);\n    window.draw(m_BackgroundSprite);\n    // Draw the GameObject instances\n    auto it = m_ScreenManagerRemoteControl->\n        getGameObjects().begin();\n    auto end = m_ScreenManagerRemoteControl->\n        getGameObjects().end();\n    for (it;\n        it != end;\n        ++it)\n    {\n        (*it).draw(window);\n    }\n    // Draw the UIPanel view(s)\n    Screen::draw(window);\n}\n```", "```cpp\nGameEngine m_GameEngine;\n```", "```cpp\n    for (int i = m_FirstUpdateComponentLocation; i < \n        m_FirstUpdateComponentLocation + \n        m_NumberUpdateComponents; i++) \n    {\n   …\n}\n```", "```cpp\n[NAME]magazine of bullets[-NAME]\n```", "```cpp\n[NAME]fleet of invaders[-NAME]\n```"]