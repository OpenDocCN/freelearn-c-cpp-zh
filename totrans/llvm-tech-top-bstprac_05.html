<html><head></head><body>
		<div id="_idContainer011">
			<h1 id="_idParaDest-52"><a id="_idTextAnchor052"/><em class="italic">Chapter 4</em>: TableGen Development </h1>
			<p><strong class="bold">TableGen</strong> is a <strong class="bold">domain-specific language</strong> (<strong class="bold">DSL</strong>) that was originally developed in <strong class="bold">Low-Level Virtual Machine</strong> (<strong class="bold">LLVM</strong>) to express processors' <strong class="bold">instruction set architecture</strong> (<strong class="bold">ISA</strong>) and other hardware-specific details, similar to the <strong class="bold">GNU Compiler Collection's</strong> (<strong class="bold">GCC's</strong>) <strong class="bold">Machine Description</strong> (<strong class="bold">MD</strong>). Thus, many people learn TableGen when they're dealing with LLVM's backend development. However, TableGen is not just for describing hardware specifications: it is a <em class="italic">general DSL</em> useful for any tasks that involve non-trivial <em class="italic">static and structural data</em>. LLVM has also been using TableGen on parts outside the backend. For example, Clang has been using TableGen for its command-line options management. People in the community are also exploring the possibility to implement <strong class="bold">InstCombine</strong> rules (LLVM's <strong class="bold">peephole optimizations</strong>) in TableGen syntax.</p>
			<p>Despite TableGen's universality, the language's core syntax has never been widely understood by many new developers in this field, creating lots of copy-and-pasted boilerplate TableGen code in LLVM's code base since they're not familiar with the language <em class="italic">itself</em>. This chapter tries to shed a little bit of light on this situation and show the way to apply this amazing technique to a wide range of applications.</p>
			<p>The chapter starts with an introduction to common and important TableGen syntax, which prepares you for writing a delicious donut recipe in TableGen as a practice, culminating in a demonstration of TableGen's universality in the second part. Finally, the chapter will end with a tutorial to develop a custom <em class="italic">emitter</em>, or a <strong class="bold">TableGen backend</strong>, to convert those nerdy sentences in the TableGen recipe into normal plaintext descriptions that can be put in the kitchen.</p>
			<p>Here is the list of the sections we will be covering:</p>
			<ul>
				<li>Introduction to TableGen syntax</li>
				<li>Writing a donut recipe in TableGen</li>
				<li>Printing a recipe via the TableGen backend</li>
			</ul>
			<h1 id="_idParaDest-53"><a id="_idTextAnchor053"/>Technical requirements</h1>
			<p>This chapter focuses on one tool in the <strong class="source-inline">utils</strong> folder: <strong class="source-inline">llvm-tblgen</strong>. To build it, launch the following command:</p>
			<p class="source-code">$ ninja llvm-tblgen</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you chose to build <strong class="source-inline">llvm-tblgen</strong> in <strong class="bold">Release</strong> mode regardless of the global build type, using the <strong class="source-inline">LLVM_OPTIMIZED_TABLEGEN</strong> CMake variable introduced in the first chapter, you might want to change that setting since it's always better to have a debug version of <strong class="source-inline">llvm-tblgen</strong> in this chapter.</p>
			<p>All of the source code in this chapter can be found in this GitHub repository: <a href="https://github.com/PacktPublishing/LLVM-Techniques-Tips-and-Best-Practices-Clang-and-Middle-End-Libraries/tree/main/Chapter04">https://github.com/PacktPublishing/LLVM-Techniques-Tips-and-Best-Practices-Clang-and-Middle-End-Libraries/tree/main/Chapter04</a>.</p>
			<h1 id="_idParaDest-54"><a id="_idTextAnchor054"/>Introduction to TableGen syntax</h1>
			<p>This section serves as a quick tour of all the important and common TableGen syntax, providing all the <a id="_idIndexMarker101"/>essential knowledge to get hands-on, writing a donut recipe in TableGen in the next section.</p>
			<p>TableGen is a <a id="_idIndexMarker102"/>domain-specific programming language used for modeling custom data layouts. Despite being a programming language, it does something <a id="_idIndexMarker103"/>quite different from conventional languages. <strong class="bold">Conventional programming languages</strong> usually describe <em class="italic">actions</em> performed on the (input) data, how they interact with the environment, and how they generate results, regardless of the programming paradigms (imperative, functional, event-driven…) you adopt. TableGen, in contrast, barely describes any actions.</p>
			<p>TableGen is designed <a id="_idIndexMarker104"/>only to describe structural <strong class="bold">static data</strong>. First, developers define the layout—which is essentially just a table with many fields—of their desired data structure. They then need to fill data into those layouts <em class="italic">right away</em> as most of the fields are populated/initialized. The latter part is probably what makes TableGen unique: many programming languages or frameworks provide ways to design your domain-specific data structures (for example, Google's <strong class="bold">Protocol Buffers</strong>), but in those scenarios, data <a id="_idIndexMarker105"/>is usually filled in <strong class="bold">dynamically</strong>, mostly in the code that consumes the DSL part.</p>
			<p><strong class="bold">Structured Query Language</strong> (<strong class="bold">SQL</strong>) shares many aspects with TableGen: both SQL and TableGen (only) handle <a id="_idIndexMarker106"/>structural data and have a way to define the layout. In SQL, it's <strong class="source-inline">TABLE</strong>; and in TableGen, it's <strong class="source-inline">class</strong>, which will be introduced later on in this section. However, SQL provides much more functions other than crafting the layout. It can also query (actually, that's where its name came from: <strong class="bold">Structured Query Language</strong>) and update data dynamically, which are absent in TableGen. However, later in this chapter, you will see that TableGen provides a nice framework to flexibly process and <em class="italic">interpret</em> this TableGen-defined data.</p>
			<p>We'll now introduce four important TableGen constructions, as follows:</p>
			<ul>
				<li>Layout and records</li>
				<li>Bang operators</li>
				<li>Multiclass</li>
				<li>The <strong class="bold">Directed-Acyclic Graph</strong> (<strong class="bold">DAG</strong>) data type</li>
			</ul>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor055"/>Layout and records</h2>
			<p>Given the fact that TableGen is just a more fancy and expressive way to describe structural data, it's pretty straightforward to think that there is a primitive representation <a id="_idIndexMarker107"/>for the data's <strong class="bold">layout</strong>, and representation for the <em class="italic">instantiated</em> data. The layout is realized by the <strong class="source-inline">class</strong> syntax, as shown in the following code snippet:</p>
			<p class="source-code"><strong class="bold">class</strong> Person {</p>
			<p class="source-code">  string Name = "John Smith";</p>
			<p class="source-code">  int Age;</p>
			<p class="source-code">}</p>
			<p>As shown here, a class is similar to a struct in C and many other programming languages, which only contains a group of data fields. Each field has a type, which can be any of the primitive types (<strong class="source-inline">int</strong>, <strong class="source-inline">string</strong>, <strong class="source-inline">bit</strong>, and so on) or another user-defined <strong class="source-inline">class</strong> type. A field can also assign a default value such as <strong class="source-inline">John Smith</strong>.</p>
			<p>After looking a layout, it's time to create an instance (or a <strong class="bold">record</strong>, in TableGen's terms), out of it, as follows:</p>
			<p class="source-code"><strong class="bold">def john_smith</strong> : Person;</p>
			<p>Here, <strong class="source-inline">john_smith</strong> is a record using <strong class="source-inline">Person</strong> as a template so that it also has two fields—<strong class="source-inline">Name</strong> and <strong class="source-inline">Age</strong>—with the <strong class="source-inline">Name</strong> field filled with the value <strong class="source-inline">John Smith</strong>. This looks pretty straightforward, but recall that TableGen should define static data and that <em class="italic">most</em> fields should <a id="_idIndexMarker108"/>be filled with values. Also, in this case, the <strong class="source-inline">Age</strong> field is still left uninitialized. You can populate its value by <em class="italic">overriding</em> with a bracket closure and statements within, as follows:</p>
			<p class="source-code">def john_smith : Person {</p>
			<p class="source-code">  <strong class="bold">let Age = 87;</strong></p>
			<p class="source-code">}</p>
			<p>You can even define new fields specifically for the <strong class="source-inline">john_smith</strong> record, as follows:</p>
			<p class="source-code">def john_smith : Person {</p>
			<p class="source-code">  let Age = 87;</p>
			<p class="source-code">  <strong class="bold">string Job = "Teacher";</strong></p>
			<p class="source-code">}</p>
			<p>Just be aware that you can only override fields (using the <strong class="source-inline">let</strong> keyword) that have been declared, just as with many other programming languages.</p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor056"/>Bang operators</h2>
			<p>Bang operators <a id="_idIndexMarker109"/>are a group of functions performing <a id="_idIndexMarker110"/>simple tasks such as basic arithmetic or casting on values in TableGen. Here is a simple example of converting kilograms to grams:</p>
			<p class="source-code">class Weight&lt;int kilogram&gt; {</p>
			<p class="source-code">  int Gram = <strong class="bold">!mul(kilogram, 1000)</strong>;</p>
			<p class="source-code">}</p>
			<p>Common operators include arithmetic and bitwise operators (to name but a few), and some <a id="_idIndexMarker111"/>of these <a id="_idIndexMarker112"/>are outlined here:</p>
			<ul>
				<li><strong class="source-inline">!add(a, b)</strong>: For arithmetic addition</li>
				<li><strong class="source-inline">!sub(a, b)</strong>: For arithmetic subtraction</li>
				<li><strong class="source-inline">!mul(a, b)</strong>: For arithmetic multiplication</li>
				<li><strong class="source-inline">!and(a, b)</strong>: For logical <strong class="source-inline">AND</strong> operations</li>
				<li><strong class="source-inline">!or(a, b)</strong>: For logical <strong class="source-inline">OR</strong> operations</li>
				<li><strong class="source-inline">!xor(a, b)</strong>: For logical <strong class="source-inline">XOR</strong> operations</li>
			</ul>
			<p>We also <a id="_idIndexMarker113"/>use conditional operators, and a few are outlined here:</p>
			<ul>
				<li><strong class="source-inline">!ge(a, b)</strong>: Returns 1 if <strong class="source-inline">a &gt;= b</strong>, and 0 otherwise</li>
				<li><strong class="source-inline">!gt(a, b)</strong>: Returns 1 if <strong class="source-inline">a &gt; b</strong>, and 0 otherwise</li>
				<li><strong class="source-inline">!le(a, b)</strong>: Returns 1 if <strong class="source-inline">a &lt;= b</strong>, and 0 otherwise</li>
				<li><strong class="source-inline">!lt(a, b)</strong>: Returns 1 if <strong class="source-inline">a &lt; b</strong>, and 0 otherwise</li>
				<li><strong class="source-inline">!eq(a, b)</strong>: Returns 1 if <strong class="source-inline">a == b</strong>, and 0 otherwise</li>
			</ul>
			<p>Other <a id="_idIndexMarker114"/>interesting operators include the following:</p>
			<ul>
				<li><strong class="source-inline">!cast&lt;type&gt;(x)</strong>: This operator performs type casting on the <strong class="source-inline">x</strong> operand, according to the <strong class="source-inline">type</strong> parameter. In cases where the type is a numerical type, such as with <strong class="source-inline">int</strong> or <strong class="source-inline">bits</strong>, this performs normal arithmetic type casting. In some special cases, we have the following scenarios:<p>If <strong class="source-inline">type</strong> is string and <strong class="source-inline">x</strong> is a record, this returns the record's name.</p><p>If <strong class="source-inline">x</strong> is a string, it is treated as the name of a record. TableGen will look up all the record definitions so far and cast the one with the name of <strong class="source-inline">x</strong> and return it with a type that matches the <strong class="source-inline">type</strong> parameter.</p></li>
				<li><strong class="source-inline">!if(pred, then, else)</strong>: This operator returns the <strong class="source-inline">then</strong> expression if <strong class="source-inline">pred</strong> is 1, and returns the <strong class="source-inline">else</strong> expression otherwise.</li>
				<li><strong class="source-inline">!cond(cond1 : val1, cond2 : val2, …, condN : valN)</strong>: This operator <a id="_idIndexMarker115"/>is an enhanced version of the <strong class="source-inline">!if</strong> operator. It will continuously evaluate <strong class="source-inline">cond1…condN</strong> until one of the expressions returns 1, before returning its associated <strong class="source-inline">val</strong> expression.<p class="callout-heading">Note</p><p class="callout">Unlike functions, which are evaluated during runtime, bang operators are more like <em class="italic">macros</em>, which are evaluated during build time—or in TableGen's terminology, when those syntaxes are processed by TableGen backends.</p></li>
			</ul>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor057"/>Multiclass</h2>
			<p>There are <a id="_idIndexMarker116"/>many cases where we want to define multiple records at once. For example, the following snippet tries to create <em class="italic">auto part</em> records for multiple cars:</p>
			<p class="source-code">class AutoPart&lt;int quantity&gt; {…}</p>
			<p class="source-code">def car1_fuel_tank : AutoPart&lt;1&gt;;</p>
			<p class="source-code">def car1_engine : AutoPart&lt;1&gt;;</p>
			<p class="source-code">def car1_wheels : AutoPart&lt;4&gt;;</p>
			<p class="source-code">…</p>
			<p class="source-code">def car2_fuel_tank : AutoPart&lt;1&gt;;</p>
			<p class="source-code">def car2_engine : AutoPart&lt;1&gt;;</p>
			<p class="source-code">def car2_wheels : AutoPart&lt;4&gt;;</p>
			<p class="source-code">…</p>
			<p>We can further simplify these by using the <strong class="source-inline">multiclass</strong> syntax, as follows:</p>
			<p class="source-code">class AutoPart&lt;int quantity&gt; {…}</p>
			<p class="source-code"><strong class="bold">multiclass</strong> Car&lt;int quantity&gt; {</p>
			<p class="source-code">  def _fuel_tank : AutoPart&lt;quantity&gt;;</p>
			<p class="source-code">  def _engine : AutoPart&lt;quantity&gt;;</p>
			<p class="source-code">  def _wheels : AutoPart&lt;!mul(quantity, 4)&gt;;</p>
			<p class="source-code">  …</p>
			<p class="source-code">}</p>
			<p>When <a id="_idIndexMarker117"/>creating record instances, use the <strong class="source-inline">defm</strong> syntax instead of <strong class="source-inline">def</strong>, as follows:</p>
			<p class="source-code"><strong class="bold">defm</strong> car1 : Car&lt;1&gt;;</p>
			<p class="source-code"><strong class="bold">defm</strong> car2 : Car&lt;1&gt;;</p>
			<p>Thus, at the end, it will still generate records with names such as <strong class="source-inline">car1_fuel_tank</strong>, <strong class="source-inline">car1_engine</strong>,<strong class="source-inline"> car2_fuel_tank</strong>, and so on.</p>
			<p>Despite having <strong class="source-inline">class</strong> in its name, <strong class="source-inline">multiclass</strong> has nothing to do with a class. Instead of describing the layout of a record, <strong class="source-inline">multiclass</strong> acts as a template to <em class="italic">generate</em> records. Inside a <strong class="source-inline">multiclass</strong> template are the prospective records to be created and the records' name <em class="italic">suffix</em> after the template is expanded. For example, the <strong class="source-inline">defm car1 : Car&lt;1&gt;</strong> directive in the preceding snippet will eventually be expanded into three <strong class="source-inline">def</strong> directives, as follows:</p>
			<ul>
				<li><strong class="source-inline">def car1_fuel_tank : AutoPart&lt;1&gt;;</strong></li>
				<li><strong class="source-inline">def car1_engine : AutoPart&lt;1&gt;;</strong></li>
				<li><strong class="source-inline">def car1_wheels : AutoPart&lt;!mul(1, 4)&gt;;</strong></li>
			</ul>
			<p>As you can see in the preceding list, the name suffixes we found inside <strong class="source-inline">multiclass</strong> (for instance, <strong class="source-inline">_fuel_tank</strong>) was concatenated with the name appearing after <strong class="source-inline">defm</strong>—c<strong class="source-inline">ar1</strong> in this case. Also, the <strong class="source-inline">quantity</strong> template argument from <strong class="source-inline">multiclass</strong>, was also instantiated into every expanded record.</p>
			<p>In short, <strong class="source-inline">multiclass</strong> tries to extract common parameters from multiple record instances and make it possible to create them at once. </p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor058"/>The DAG data type</h2>
			<p>In addition to conventional data types, TableGen has a pretty unique first-class type: the <strong class="source-inline">dag</strong> type <a id="_idIndexMarker118"/>that is used for expressing DAG instances. To create <a id="_idIndexMarker119"/>a DAG instance, you can use the following syntax:</p>
			<p class="source-code">(operator operand1, operand2,…, operandN)</p>
			<p>While the <strong class="source-inline">operator</strong> can only be a record instance, operands (<strong class="source-inline">operand1</strong>…<strong class="source-inline">operandN</strong>) can have arbitrary types. Here is an example of trying to model an arithmetic expression, <strong class="source-inline">x * 2 + y + 8 * z</strong>:</p>
			<p class="source-code">class Variable {…}</p>
			<p class="source-code">class Operator {…}</p>
			<p class="source-code">class Expression&lt;<strong class="bold">dag expr</strong>&gt; {…}</p>
			<p class="source-code">// define variables</p>
			<p class="source-code">def x : Variable;</p>
			<p class="source-code">def y : Variable;</p>
			<p class="source-code">def z : Variable;</p>
			<p class="source-code">// define operators</p>
			<p class="source-code">def mul : Operator;</p>
			<p class="source-code">def plus : Operator;</p>
			<p class="source-code">// define expression</p>
			<p class="source-code">def tmp1 : Expression&lt;<strong class="bold">(mul x, 2)</strong>&gt;;</p>
			<p class="source-code">def tmp2 : Expression&lt;<strong class="bold">(mul 8, z)</strong>&gt;;</p>
			<p class="source-code">def result : Expression&lt;<strong class="bold">(plus tmp1, tmp2, y)</strong>&gt;;</p>
			<p>Optionally, you can associate <strong class="source-inline">operator</strong> and/or each operand with a <em class="italic">tag</em>, as follows:</p>
			<p class="source-code">…</p>
			<p class="source-code">def tmp1 : Expression&lt;<strong class="bold">(mul:$op x, 2)</strong>&gt;;</p>
			<p class="source-code">def tmp2 : Expression&lt;<strong class="bold">(mul:$op 8, z)</strong>&gt;;</p>
			<p class="source-code">def result : Expression&lt;<strong class="bold">(plus tmp1:$term1, tmp2:$term2, y:$term3)</strong>&gt;;</p>
			<p>A tag always starts with a dollar sign, <strong class="source-inline">$</strong>, followed by a user-defined tag name. These tags provide a <em class="italic">logical</em> description of each <strong class="source-inline">dag</strong> component and can be useful when processing DAGs in the TableGen backend.</p>
			<p>In this <a id="_idIndexMarker120"/>section, we have gone through the principal <a id="_idIndexMarker121"/>components of the TableGen language and introduced some essential syntax. In the next section, we are going to get hands-on, writing a delicious donut recipe using TableGen.</p>
			<h1 id="_idParaDest-59"><a id="_idTextAnchor059"/>Writing a donut recipe in TableGen</h1>
			<p>With the <a id="_idIndexMarker122"/>knowledge from previous sections, it's time to write our own donut recipe! We'll proceed as follows:</p>
			<ol>
				<li>The first file to create is <strong class="source-inline">Kitchen.td</strong>. It defines the environment for cooking, including measuring units, equipment, and procedures, to name but a few aspects. We are going to start with the measuring units, as follows:<p class="source-code">class Unit {</p><p class="source-code">  string Text;</p><p class="source-code">  bit Imperial;</p><p class="source-code">}</p><p>Here, the <strong class="source-inline">Text</strong> field is the textual format showing on the recipe, and <strong class="source-inline">Imperial</strong> is just a Boolean flag marking whether this unit is imperial or metric. Each weight or volume unit will be a record inheriting from this class—have a look at the following code snippet for an example of this:</p><p class="source-code">def gram_unit : Unit {</p><p class="source-code">  let Imperial = false;</p><p class="source-code">  let Text = "g";</p><p class="source-code">}</p><p class="source-code">def tbsp_unit : Unit {</p><p class="source-code">  let Imperial = true;</p><p class="source-code">  let Text = "tbsp";</p><p class="source-code">}</p><p>There are plenty of measuring units we want to create, but the code is already pretty <a id="_idIndexMarker123"/>lengthy. A way to simplify and make it more readable is by using <strong class="source-inline">class</strong> template arguments, as follows:</p><p class="source-code">class Unit<strong class="bold">&lt;bit imperial, string text&gt;</strong> {</p><p class="source-code">  string Text = <strong class="bold">text</strong>;</p><p class="source-code">  bit Imperial = <strong class="bold">imperial</strong>;</p><p class="source-code">}</p><p class="source-code">def gram_unit : <strong class="bold">Unit&lt;false, "g"&gt;</strong>;</p><p class="source-code">def tbsp_unit : <strong class="bold">Unit&lt;true, "tbsp"&gt;</strong>;</p><p>In contrast to C++'s template arguments, the template arguments in TableGen only accept concrete values. They're just an alternative way to assign values to fields.</p></li>
				<li>Since TableGen doesn't support floating-point numbers, we need to define some way to express numberings, such as <strong class="bold">1 and ¼ cups</strong> or <strong class="bold">94.87g of flour</strong>. One solution is to use a <em class="italic">fixed point</em>, as follows:<p class="source-code">class FixedPoint&lt;int integral, int decimal = 0&gt; {</p><p class="source-code">  int <strong class="bold">Integral</strong> = integral;</p><p class="source-code">  int <strong class="bold">DecimalPoint</strong> = decimal;</p><p class="source-code">}</p><p class="source-code">def one_plus_one_quarter : FixedPoint&lt;<strong class="bold">125, 2</strong>&gt;; <strong class="bold">// Shown as 1.25</strong></p><p>With the <strong class="source-inline">Integral</strong> and <strong class="source-inline">DecimalPoint</strong> fields mentioned, the value represented by this <strong class="source-inline">FixedPoint</strong> class is equal to the following formula:</p><p><em class="italic">Integral * 10^(-DecimalPoint)</em></p><p>Since ¼, ½, and ¾ are apparently commonly used in measuring (especially for imperial units such as a US cup), it's probably a good idea to use a helper class to create them, as follows:</p><p class="source-code">class NplusQuarter&lt;<strong class="bold">int n, bits&lt;2&gt; num_quarter</strong>&gt; : FixedPoint&lt;<strong class="bold">?</strong>, 2&gt; {…}</p><p class="source-code">def one_plus_one_quarter : <strong class="bold">NplusQuarter&lt;1,1&gt;; // Shown as 1.25</strong></p><p>This will make expressing quantities such as N and ¼ cups or N and ½ cups a lot easier.</p><p>TableGen classes also have inheritance—a class can inherit one or more classes. Since TableGen doesn't have the concept of member functions/methods, inheriting <strong class="source-inline">class</strong> is simply just integrating its fields.</p></li>
				<li>To implement <strong class="source-inline">NplusQuarter</strong>, especially the conversion from the <strong class="source-inline">NplusQuarter</strong> class <a id="_idIndexMarker124"/>template parameters to that of <strong class="source-inline">FixedPoint</strong>, we need some simple arithmetic calculations, which is where TableGen's bang operators come into place, as follows:<p class="source-code">class NplusQuarter&lt;<strong class="bold">int n, bits&lt;2&gt; num_quarter</strong>&gt; : FixedPoint&lt;<strong class="bold">?</strong>, 2&gt; {</p><p class="source-code">  int Part1 = <strong class="bold">!mul</strong>(n, 100);</p><p class="source-code">  int Part2 = <strong class="bold">!mul</strong>(25, <strong class="bold">!cast&lt;int&gt;</strong>(num_quarter<strong class="bold">{1...0}</strong>));</p><p class="source-code">  let Integral = <strong class="bold">!add</strong>(Part1, Part2);</p><p class="source-code">}</p><p>Another interesting syntax that appeared is the <em class="italic">bit extraction (or slicing)</em> on the <strong class="source-inline">num_quarter</strong> variable. By writing <strong class="source-inline">num_quarter{1…0}</strong>, this gives you a <strong class="source-inline">bits</strong> value that is equal to the 0th and first bit of <strong class="source-inline">num_quarter</strong>. There are some other variants of this technique. For example, it can slice a non-continuous range of bits, as follows:</p><p class="source-code">num_quarter{8…6,4,2…0}</p><p>Or, it can extract bits in reversed ordering, as follows:</p><p class="source-code">num_quarter{1…7}</p><p class="callout-heading">Note</p><p class="callout">You might wonder why the code needs to extract the smallest 2 bits <em class="italic">explicitly</em> even it has declared that <strong class="source-inline">num_quarter</strong> has a width of 2 bits (the <strong class="source-inline">bits&lt;2&gt;</strong> type). It turned out that for some reason, TableGen will not stop anyone from assigning values greater than <strong class="source-inline">3</strong> into <strong class="source-inline">num_quarter</strong>, like this: <strong class="source-inline">def x : NplusQuarter&lt;1,999&gt;</strong>.</p></li>
				<li>With the measuring units and number format, we can finally deal with the ingredients <a id="_idIndexMarker125"/>needed for this recipe. First, let's use a separated file, <strong class="source-inline">Ingredients.td</strong>, to store all the ingredient records. To use all the things mentioned earlier, we can import <strong class="source-inline">Kitchen.td</strong> by using the <strong class="source-inline">include</strong> syntax, as follows:<p class="source-code">// In Ingredients.td…</p><p class="source-code">include "Kitchen.td"</p><p>Then, a base class of all ingredients is created to carry some common fields, as follows:</p><p class="source-code">class IngredientBase&lt;Unit unit&gt; {</p><p class="source-code">  <strong class="bold">Unit</strong> TheUnit = unit;</p><p class="source-code">  <strong class="bold">FixedPoint</strong> Quantity = FixedPoint&lt;0&gt;;</p><p class="source-code">}</p><p>Each kind of ingredient is represented by a class derived from <strong class="source-inline">IngredientBase</strong>, with parameters to specify the quantity needed by a recipe, and the unit used to measure this ingredient. Take milk, for example, as shown in the following code snippet:</p><p class="source-code">class Milk&lt;<strong class="bold">int integral, int num_quarter</strong>&gt; : IngredientBase&lt;<strong class="bold">cup_unit</strong>&gt; {</p><p class="source-code">  let <strong class="bold">Quantity</strong> = NplusQuarter&lt;<strong class="bold">integral</strong>, <strong class="bold">num_quarter</strong>&gt;;</p><p class="source-code">}</p><p>The <strong class="source-inline">cup_unit</strong> put at the template argument for <strong class="source-inline">IngredientBase</strong> tells us that milk is measured by a US cup unit, and its quantity is to be determined later by the <strong class="source-inline">Milk</strong> class template arguments. </p><p>When writing a recipe, each required ingredient is represented by a record created from one of these ingredient <strong class="source-inline">class</strong> types:</p><p class="source-code">def ingredient_milk : <strong class="bold">Milk&lt;1,2&gt;</strong>; // Need 1.5 cup of milk</p></li>
				<li>Some ingredients, however, always come together—for example, lemon peel and lemon juice, egg yolk, and egg white. That is, if you have two egg yolks, then there must <a id="_idIndexMarker126"/>be two servings of egg white. However, if we need to create a record and assign a quantity for each of the ingredients one by one, there will be a lot of duplicate code. A more elegant way to solve this problem is by using TableGen's <strong class="source-inline">multiclass</strong> syntax.<p>Taking the following egg example, assume we want to create <strong class="source-inline">WholeEgg</strong>, <strong class="source-inline">EggWhite</strong>, and <strong class="source-inline">EggYolk</strong> records at once with the same quantity, and define the <strong class="source-inline">multiclass</strong> first:</p><p class="source-code"><strong class="bold">multiclass</strong> Egg&lt;int num&gt; {</p><p class="source-code">  def <strong class="bold">_whole</strong> : <strong class="bold">WholeEgg</strong> {</p><p class="source-code">    let Quantity = FixedPoint&lt;num&gt;;</p><p class="source-code">  }</p><p class="source-code">  def <strong class="bold">_yolk</strong> : <strong class="bold">EggYolk</strong> {</p><p class="source-code">    let Quantity = FixedPoint&lt;num&gt;;</p><p class="source-code">  }</p><p class="source-code">  def <strong class="bold">_white</strong> : <strong class="bold">EggWhite</strong> {</p><p class="source-code">    let Quantity = FixedPoint&lt;num&gt;;</p><p class="source-code">  }</p><p class="source-code">}</p><p>When writing the recipe, use the <strong class="source-inline">defm</strong> syntax to create <strong class="source-inline">multiclass</strong> records, as follows:</p><p class="source-code">defm egg_ingredient : Egg&lt;3&gt;;</p><p>After using <strong class="source-inline">defm</strong>, three records will actually be created: <strong class="source-inline">egg_ingredient_whole</strong>, <strong class="source-inline">egg_ingredient_yolk</strong>, and <strong class="source-inline">egg_ingredient_white</strong>, inheriting from <strong class="source-inline">WholeEgg</strong>, <strong class="source-inline">EggYolk</strong>, and <strong class="source-inline">EggWhite</strong>, respectively. </p></li>
				<li>Finally, we need a way to describe the steps to make a donut. Many recipes have some preparation steps that don't need to be done in a specific order. Take the <a id="_idIndexMarker127"/>donut recipe here, for example: preheating the oil can be done at any time before the donuts are ready to be fried. Thus, it might be a good idea to express baking steps in a <strong class="source-inline">dag</strong> type.<p>Let's first create the <strong class="source-inline">class</strong> to represent a baking step, as follows:</p><p class="source-code">class Step&lt;<strong class="bold">dag action</strong>, Duration duration, string custom_format&gt; {</p><p class="source-code">  <strong class="bold">dag Action = action;</strong></p><p class="source-code">  Duration TheDuration = duration;</p><p class="source-code">  string CustomFormat = custom_format;</p><p class="source-code">  string Note;</p><p class="source-code">}</p><p>The <strong class="source-inline">Action</strong> field carries the baking instructions and information about the ingredients used. Here is an example:</p><p class="source-code">def <strong class="bold">mix</strong> : Action&lt;"mix",…&gt;;</p><p class="source-code">def <strong class="bold">milk</strong> : Milk&lt;…&gt;;</p><p class="source-code">def <strong class="bold">flour</strong> : Flour&lt;…&gt;;</p><p class="source-code">def step_mixing : Step&lt;<strong class="bold">(mix milk, flour)</strong>, …&gt;;</p><p><strong class="source-inline">Action</strong> is just a class used for describing movements. The following snippet represents the fact that <strong class="source-inline">step_mixing2</strong> is using the outcome from <strong class="source-inline">step_mixing</strong> (maybe a raw dough) and mixing it with butter:</p><p class="source-code">…</p><p class="source-code">def step_mixing : Step&lt;(mix milk, flour), …&gt;;</p><p class="source-code">def step_mixing2 : Step&lt;<strong class="bold">(mix step_mixing, butter)</strong>, …&gt;;</p><p>Eventually, all of the <strong class="source-inline">Step</strong> records will form a DAG, in which a vertex will either be a <strong class="source-inline">step</strong> or an ingredient record.</p><p>We're also <a id="_idIndexMarker128"/>annotating our <strong class="source-inline">dag</strong> operator and operand with tags, as follows:</p><p class="source-code">def step_mixing2 : Step&lt;(mix:<strong class="bold">$action</strong> step_mixing:<strong class="bold">$dough</strong>, butter)&gt;</p><p>In the previous section, <em class="italic">Introduction to TableGen syntax</em>, we said that these <strong class="source-inline">dag</strong> tags have no immediate effect in TableGen code, except affecting how TableGen backends handle the current record—for example, if we have a <strong class="source-inline">string</strong> type field, <strong class="source-inline">CustomFormat</strong>, in the <strong class="source-inline">Step</strong> class, as follows:</p><p class="source-code">def step_prep : Step&lt;(heat:<strong class="bold">$action</strong> fry_oil:<strong class="bold">$oil</strong>, oil_temp:<strong class="bold">$temp</strong>)&gt; {</p><p class="source-code">  let CustomFormat = <strong class="bold">"$action the $oil until $temp"</strong>;</p><p class="source-code">}</p><p>With the field content shown, we can replace <strong class="source-inline">$action</strong>, <strong class="source-inline">$oil</strong>, and <strong class="source-inline">$temp</strong> in the string with the textual representation of those records, generating a string such as <em class="italic">heat the peanut oil until it reaches 300 F</em>.</p></li>
			</ol>
			<p>And that wraps up this section of this chapter. In the next section, the goal is to develop a custom TableGen backend to take the TableGen version recipe here as input and print out a normal plaintext recipe.</p>
			<h1 id="_idParaDest-60"><a id="_idTextAnchor060"/>Printing a recipe via the TableGen backend</h1>
			<p>Following up <a id="_idIndexMarker129"/>on the last part of the previous <a id="_idIndexMarker130"/>section, after composing the donut recipe in TableGen's syntax, it's time to print out a <em class="italic">normal</em> recipe from that via a custom-built TableGen backend. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">Please <a id="_idIndexMarker131"/>don't confuse a <strong class="bold">TableGen backend</strong> with a <strong class="bold">LLVM backend</strong>: the <a id="_idIndexMarker132"/>former converts (or transpiles) TableGen files into an <em class="italic">arbitrary textual content</em>, C/C++ header files being the most common form. An LLVM <a id="_idIndexMarker133"/>backend, on the other hand, lowers LLVM <strong class="bold">intermediate representations</strong> (<strong class="bold">IR</strong>) into low-level assembly code. </p>
			<p>In this section, we're developing the TableGen backend to print the donut we composed in the previous section into content, like this:</p>
			<p class="source-code">=======Ingredients=======</p>
			<p class="source-code">1. oil 500 ml</p>
			<p class="source-code">2. flour 300 g</p>
			<p class="source-code">3. milk 1.25 cup</p>
			<p class="source-code">4. whole egg 1</p>
			<p class="source-code">5. yeast 1.50 tsp</p>
			<p class="source-code">6. butter 3.50 tbsp</p>
			<p class="source-code">7. sugar 2.0 tbsp</p>
			<p class="source-code">8. salt 0.50 tsp</p>
			<p class="source-code">9. vanilla extract 1.0 tsp</p>
			<p class="source-code">=======Instructions=======</p>
			<p class="source-code">1. use deep fryer to heat oil until 160 C</p>
			<p class="source-code">2. use mixer to mix flour, milk, whole egg, yeast, butter, sugar, salt, and vanilla extract. stir in low speed.</p>
			<p class="source-code">3. use mixer to mix outcome from (step 2). stir in medium speed.</p>
			<p class="source-code">4. use bowl to ferment outcome from (step 3).</p>
			<p class="source-code">5. use rolling pin to flatten outcome from (step 4).</p>
			<p class="source-code">6. use cutter to cut outcome from (step 5).</p>
			<p class="source-code">7. use deep fryer to fry outcome from (step 1) and outcome from (step 6).</p>
			<p>First, we <a id="_idIndexMarker134"/>will give an overview of <strong class="source-inline">llvm-tblgen</strong>, the program for driving the TableGen translation process. Then, we will show you <a id="_idIndexMarker135"/>how to develop our recipe-printing TableGen backend. Finally, we'll show you how to integrate our backend into the <strong class="source-inline">llvm-tblgen</strong> executable.</p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor061"/>TableGen's high-level workflow</h2>
			<p>The TableGen backend takes in-memory representation (in the form of C++ objects) of the TableGen <a id="_idIndexMarker136"/>code we just learned and transforms it into <a id="_idIndexMarker137"/>arbitrary <strong class="bold">textual content</strong>. The whole process is driven by the <strong class="source-inline">llvm-tblgen</strong> executable, whose workflow can be illustrated by this diagram:</p>
			<div>
				<div id="_idContainer010" class="IMG---Figure">
					<img src="image/Figure_4.1_B14590.jpg" alt="Figure 4.1 – Workflow of llvm-tblgen &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.1 – Workflow of llvm-tblgen </p>
			<p>TableGen code's in-memory representation (which consists of C++ types and APIs) plays an important role in the TableGen backend development. Similar to LLVM IR, it is organized <em class="italic">hierarchically</em>. Starting from the top level, here is a list of its hierarchy, where each of the items is a C++ class:</p>
			<ol>
				<li value="1"><strong class="source-inline">RecordKeeper</strong>: A collection (and owner) of all <strong class="source-inline">Record</strong> objects in the current translation unit.</li>
				<li><strong class="source-inline">Record</strong>: Represents a record or a <strong class="source-inline">class</strong>. The enclosing fields are represented by <strong class="source-inline">RecordVal</strong>. If it's a <strong class="source-inline">class</strong>, you can also access its template arguments.</li>
				<li><strong class="source-inline">RecordVal</strong>: Represents a <em class="italic">pair</em> of record fields and their initialized value, along with supplementary information such as the field's type and source location.</li>
				<li><strong class="source-inline">Init</strong>: Represents the initialized value of a field. It is a parent class of <strong class="source-inline">many</strong>, which represents different types of initialized values—For example, <strong class="source-inline">IntInit</strong> for integer values and <strong class="source-inline">DagInit</strong> for DAG values.</li>
			</ol>
			<p>To give <a id="_idIndexMarker138"/>you a little task on the practical aspect of a TableGen backend, here is the skeleton of it:</p>
			<p class="source-code">class SampleEmitter {</p>
			<p class="source-code">  RecordKeeper &amp;Records;</p>
			<p class="source-code">public:</p>
			<p class="source-code">  SampleEmitter(RecordKeeper &amp;RK) : Records(RK) {}</p>
			<p class="source-code">  void run(raw_ostream &amp;OS);</p>
			<p class="source-code">};</p>
			<p>This emitter basically takes a <strong class="source-inline">RecordKeeper</strong> object (passed in by the constructor) as the input and prints the output into the <strong class="source-inline">raw_ostream</strong> stream—the function argument of <strong class="source-inline">SampleEmitter::run</strong>. </p>
			<p>In the next section, we're going to show you how to set up the development environment and get hands- on, writing a TableGen backend.</p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor062"/>Writing the TableGen backend</h2>
			<p>In this <a id="_idIndexMarker139"/>section, we're showing you the steps of writing a backend to print out recipes written in TableGen. Let's start with the setup.</p>
			<h3>Project setup</h3>
			<p>To get started, LLVM has already provided a skeleton for writing a TableGen backend. So, please <a id="_idIndexMarker140"/>copy the <strong class="source-inline">llvm/lib/TableGen/TableGenBackendSkeleton.cpp</strong> file from the LLVM Project's source tree into the <strong class="source-inline">llvm/utils/TableGen</strong> folder, as follows:</p>
			<p class="source-code">$ cd llvm</p>
			<p class="source-code">$ cp lib/TableGen/TableGenBackendSkeleton.cpp \</p>
			<p class="source-code">     utils/TableGen/RecipePrinter.cpp</p>
			<p>Then, refactor the c<strong class="source-inline">SkeletonEmitter</strong> class into <strong class="source-inline">RecipePrinter</strong>.</p>
			<p><strong class="source-inline">RecipePrinter</strong> has the following workflow:</p>
			<ol>
				<li value="1">Collect all baking steps and ingredient records.</li>
				<li>Print individual ingredients in textual formats using individual functions to print measuring units, temperature, equipment, and so on in textual formats.</li>
				<li>Linearize the DAG of all baking steps.</li>
				<li>Print each linearized baking step using a function to print custom formatting.</li>
			</ol>
			<p>We're not going to cover all the implementation details since lots of backend codes are actually not directly related to TableGen (text formatting and string processing, for example). Therefore, the following subsections only focus on how to retrieve information from TableGen's in-memory objects.</p>
			<h3>Getting all the baking steps</h3>
			<p>In the TableGen backend, a TableGen record is represented by the <strong class="source-inline">Record</strong> C++ class. When we <a id="_idIndexMarker141"/>want to retrieve all the records derived from a specific TableGen <strong class="source-inline">class</strong>, we can use one of the functions of <strong class="source-inline">RecordKeeper</strong>: <strong class="source-inline">getAllDerivedDefinitions</strong>. For instance, let's say we want to fetch all the baking steps records that derived from the <strong class="source-inline">Step</strong> TableGen class in this case. Here is how we do with <strong class="source-inline">getAllDerivedDefinitions</strong>:</p>
			<p class="source-code">// In RecipePrinter::run method…</p>
			<p class="source-code"><strong class="bold">std::vector&lt;Record*&gt; Steps</strong> = Records.<strong class="bold">getAllDerivedDefinitions</strong>("Step");</p>
			<p>This gives <a id="_idIndexMarker142"/>us a list of <strong class="source-inline">Record</strong> pointers that represent all of the <strong class="source-inline">Step</strong> records.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">For the rest of this section, we will use <strong class="source-inline">Record</strong> in this format (with Courier font face) to refer to the C++ counterpart of a TableGen record. </p>
			<h3>Retrieving field values</h3>
			<p>Retrieving field <a id="_idIndexMarker143"/>values from <strong class="source-inline">Record</strong> is probably the most basic operation. Let's say we're working on a method for printing <strong class="source-inline">Unit</strong> record objects introduced earlier, as follows:</p>
			<p class="source-code">void RecipePrinter::printUnit(raw_ostream&amp; OS, Record* UnitRecord) {</p>
			<p class="source-code">  OS &lt;&lt; UnitRecord-&gt;<strong class="bold">getValueAsString("Text")</strong>;</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">Record</strong> class provides some handy functions, such as <strong class="source-inline">getValueAsString</strong>, to retrieve the value of a field and try to convert it into a specific type so that you don't need to retrieve the <strong class="source-inline">RecordVal</strong> value of a specific field (in this case, the <strong class="source-inline">Text</strong> field) before getting the real value. Similar functions include the following:</p>
			<ul>
				<li><strong class="source-inline">Record* getValueAsDef(StringRef FieldName)</strong></li>
				<li><strong class="source-inline">bool getValueAsBit(StringRef FieldName)</strong></li>
				<li><strong class="source-inline">int64_t getValueAsInt(StringRef FieldName)</strong></li>
				<li><strong class="source-inline">DagInit* getValueAsDag(StringRef FieldName)</strong></li>
			</ul>
			<p>In addition to these utility functions, we sometimes just want to check if a specific field exists in a record. In such cases, call <strong class="source-inline">Record::getValue(StringRef FieldName)</strong> and check if the returned value is null. But just be aware that not every field <em class="italic">needs</em> to be initialized; you may still need to check if a field exists, but is uninitialized. When that happens, let <strong class="source-inline">Record::isValueUnset</strong> help you.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">TableGen actually uses a special <strong class="source-inline">Init</strong> class, <strong class="source-inline">UnsetInit</strong>, to represent an uninitialized value.</p>
			<h3>Type conversion</h3>
			<p><strong class="source-inline">Init</strong> represents <a id="_idIndexMarker144"/>initialization values, but most of the time we're not directly working with it but with one of its children's classes. </p>
			<p>For example, <strong class="source-inline">StepOrIngredient</strong> is an <strong class="source-inline">Init</strong> type object that represents either a <strong class="source-inline">Step</strong> record or an ingredient record. It would be easier for us to convert it to its underlying <strong class="source-inline">DefInit</strong> object since <strong class="source-inline">DefInit</strong> provides richer functionalities. We can use the following code to typecast the <strong class="source-inline">Init</strong> type <strong class="source-inline">StepOrIngredient</strong> into a <strong class="source-inline">DefInit</strong> type object: </p>
			<p class="source-code">const auto* SIDef = <strong class="bold">cast&lt;const DefInit&gt;(StepOrIngredient)</strong>;</p>
			<p>You can also use <strong class="source-inline">isa&lt;…&gt;(…)</strong> to check its underlying type first, or <strong class="source-inline">dyn_cast&lt;…&gt;(…)</strong> if you don't want to receive an exception when the conversion fails.</p>
			<p><strong class="source-inline">Record</strong> represents a TableGen record, but it would be better if we can find out its parent class, which further tells us the field's information.</p>
			<p>For example, after getting the underlying <strong class="source-inline">Record</strong> object for <strong class="source-inline">SIDef</strong>, we can use the <strong class="source-inline">isSubClassOf</strong> function to tell if that <strong class="source-inline">Record</strong> is a baking step or ingredient, as follows:</p>
			<p class="source-code">Record* SIRecord = SIDef-&gt;getDef();</p>
			<p class="source-code">if (SIRecord-&gt;<strong class="bold">isSubClassOf("Step")</strong>) {</p>
			<p class="source-code">  // This Record is a baking step!</p>
			<p class="source-code">} else if (SIRecord-&gt;<strong class="bold">isSubClassOf("IngredientBase")</strong>){</p>
			<p class="source-code">  // This Record is an ingredient!</p>
			<p class="source-code">} </p>
			<p>Knowing what the underlying TableGen class actually is can help us to print that record in its own way.</p>
			<h3>Handling DAG values</h3>
			<p>Now, we are going to print out the <strong class="source-inline">Step</strong> records. Recall that we used the <strong class="source-inline">dag</strong> type to represent <a id="_idIndexMarker145"/>the action and the ingredients required for a baking step. Have a look at the following code example:</p>
			<p class="source-code">def step_prep : Step&lt;<strong class="bold">(heat:$action fry_oil:$oil, oil_temp:$temp)</strong>&gt; {</p>
			<p class="source-code">  let CustomFormat = "$action $oil until $temp";</p>
			<p class="source-code">}</p>
			<p>Here, the highlighted <strong class="source-inline">dag</strong> is stored in the <strong class="source-inline">Action</strong> field of the <strong class="source-inline">Step</strong> TableGen class. So, we use <strong class="source-inline">getValueAsDag</strong> to retrieve that field as a <strong class="source-inline">DagInit</strong> object, as follows:</p>
			<p class="source-code">DagInit* DAG = StepRecord-&gt;<strong class="bold">getValueAsDag("Action");</strong></p>
			<p><strong class="source-inline">DagInit</strong> is just another class derived from <strong class="source-inline">Init</strong>, which wasintroduced earlier. It contains some DAG-specific APIs. For example, we can iterate through all of its operands and get their associated <strong class="source-inline">Init</strong> object using the <strong class="source-inline">getArg</strong> function, as follows:</p>
			<p class="source-code">for(i = 0; i &lt; DAG-&gt;arg_size; ++i) {</p>
			<p class="source-code">  Init* Arg = DAG-&gt;<strong class="bold">getArg</strong>(i);</p>
			<p class="source-code">}</p>
			<p>Furthermore, we can use the <strong class="source-inline">getArgNameStr</strong> function to retrieve the token (if there is any), which is always represented in string type in the TableGen backend, associated with a specific operand, as illustrated in the following code snippet:</p>
			<p class="source-code">for(i = 0; i &lt; DAG-&gt;arg_size; ++i) {</p>
			<p class="source-code">  StringRef ArgTok = DAG-&gt;<strong class="bold">getArgNameStr</strong>(i);</p>
			<p class="source-code">}</p>
			<p>If <strong class="source-inline">ArgTok</strong> is empty, this means there is no token associated with that operand. To get the token associated with the operator, we can use the <strong class="source-inline">getNameStr</strong> API.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Both <strong class="source-inline">DagInit::getArgNameStr</strong> and <strong class="source-inline">DagInit::getNameStr</strong> return the token string <em class="italic">without</em> the leading dollar sign.</p>
			<p>This section has shown you some of the most important aspects of working with TableGen <a id="_idIndexMarker146"/>directives' in-memory C++ representation, which is the building block of writing a TableGen backend. In the next section, we will show you the final step to put everything together and run our custom TableGen backend.</p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor063"/>Integrating the RecipePrinter TableGen backend</h2>
			<p>After finishing the <strong class="source-inline">utils/TableGen/RecipePrinter.cpp</strong> file, it's time to put everything together.</p>
			<p>As mentioned before, a TableGen backend is always associated with the <strong class="source-inline">llvm-tblgen</strong> tool, which <a id="_idIndexMarker147"/>is also the only interface to use the backend. <strong class="source-inline">llvm-tblgen</strong> uses simple command-line options to choose a backend to use. </p>
			<p>Here is an example of choosing one of the backends, <strong class="source-inline">IntrInfoEmitter</strong>, to generate a C/C++ header file from a <strong class="source-inline">TableGen</strong> file that carries instruction set information of <strong class="source-inline">X86</strong>:</p>
			<p class="source-code">$ llvm-tblgen -gen-instr-info /path/to/X86.td -o GenX86InstrInfo.inc</p>
			<p>Let's now see how to integrate <strong class="source-inline">RecipePrinter</strong> source file to <strong class="source-inline">TableGen</strong> backend:</p>
			<ol>
				<li value="1">To link the <strong class="source-inline">RecipePrinter</strong> source file into <strong class="source-inline">llvm-tblgen</strong> and add a command-line option to select it, we're going to use <strong class="source-inline">utils/TableGen/TableGenBackends.h</strong> first. This file only contains a list of TableGen backend entry functions, which are functions that take a <strong class="source-inline">raw_ostream</strong> output stream and the <strong class="source-inline">RecordKeeper</strong> object as arguments. We're also putting our <strong class="source-inline">EmitRecipe</strong> function into the list, as follows:<p class="source-code">…</p><p class="source-code">void EmitX86FoldTables(RecordKeeper &amp;RK, raw_ostream &amp;OS);</p><p class="source-code"><strong class="bold">void EmitRecipe(RecordKeeper &amp;RK, raw_ostream &amp;OS);</strong></p><p class="source-code">void EmitRegisterBank(RecordKeeper &amp;RK, raw_ostream &amp;OS);</p><p class="source-code">…</p></li>
				<li>Next, inside <strong class="source-inline">llvm/utils/TableGen/TableGen.cpp</strong>, we're first adding a new <strong class="source-inline">ActionType</strong> enum element and the selected command-line option, as follows:<p class="source-code">enum Action Type {</p><p class="source-code">…</p><p class="source-code">  <strong class="bold">GenRecipe</strong>,</p><p class="source-code">…</p><p class="source-code">}</p><p class="source-code">…</p><p class="source-code">cl::opt&lt;ActionType&gt; Action(</p><p class="source-code">    cl::desc("Action to perform:"),</p><p class="source-code">    cl::values(</p><p class="source-code">        …</p><p class="source-code">        <strong class="bold">clEnumValN(GenRecipe, "gen-recipe",</strong></p><p class="source-code"><strong class="bold">                   "Print delicious recipes")</strong>,</p><p class="source-code">        …</p><p class="source-code">    ));</p></li>
				<li>After <a id="_idIndexMarker148"/>that, go to the <strong class="source-inline">LLVMTableGenMain</strong> function and insert the function call to <strong class="source-inline">EmitRecipe</strong>, as follows:<p class="source-code">bool LLVMTableGenMain(raw_ostream &amp;OS, RecordKeeper &amp;Records) {</p><p class="source-code">  switch (Action) {</p><p class="source-code">  …</p><p class="source-code">  case <strong class="bold">GenRecipe</strong>:</p><p class="source-code">    <strong class="bold">EmitRecipe(Records, OS)</strong>;</p><p class="source-code">    break;</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>Finally, don't forget to update <strong class="source-inline">utils/TableGen/CMakeLists.txt</strong>, as follows:<p class="source-code">add_tablegen(llvm-tblgen LLVM</p><p class="source-code">  …</p><p class="source-code">  <strong class="bold">RecipePrinter.cpp</strong></p><p class="source-code">  …)</p></li>
				<li>That's all there is to it! You can now run the following command:<p class="source-code"><strong class="bold">$ llvm-tblgen -gen-recipe DonutRecipe.td</strong></p><p>(You can optionally redirect the output to a file using the <strong class="source-inline">-o</strong> option.)</p><p>The <a id="_idIndexMarker149"/>preceding command will print out a (mostly) normal donut recipe, just like this:</p><p class="source-code"><strong class="bold">=======Ingredients=======</strong></p><p class="source-code"><strong class="bold">1. oil 500 ml</strong></p><p class="source-code"><strong class="bold">2. flour 300 g</strong></p><p class="source-code"><strong class="bold">3. milk 1.25 cup</strong></p><p class="source-code"><strong class="bold">4. whole egg 1</strong></p><p class="source-code"><strong class="bold">5. yeast 1.50 tsp</strong></p><p class="source-code"><strong class="bold">6. butter 3.50 tbsp</strong></p><p class="source-code"><strong class="bold">7. sugar 2.0 tbsp</strong></p><p class="source-code"><strong class="bold">8. salt 0.50 tsp</strong></p><p class="source-code"><strong class="bold">9. vanilla extract 1.0 tsp</strong></p><p class="source-code"><strong class="bold">=======Instructions=======</strong></p><p class="source-code"><strong class="bold">1. use deep fryer to heat oil until 160 C</strong></p><p class="source-code"><strong class="bold">2. use mixer to mix flour, milk, whole egg, yeast, butter, sugar, salt, and vanilla extract. stir in low speed.</strong></p><p class="source-code"><strong class="bold">3. use mixer to mix outcome from (step 2). stir in medium speed.</strong></p><p class="source-code"><strong class="bold">4. use bowl to ferment outcome from (step 3).</strong></p><p class="source-code"><strong class="bold">5. use rolling pin to flatten outcome from (step 4).</strong></p><p class="source-code"><strong class="bold">6. use cutter to cut outcome from (step 5).</strong></p><p class="source-code"><strong class="bold">7. use deep fryer to fry outcome from (step 1) and outcome from (step 6).</strong></p></li>
			</ol>
			<p>In this section, we have learned how to build a custom TableGen backend to transform a recipe written in TableGen into normal plaintext format. Things we learned here include how <strong class="source-inline">llvm-tblgen</strong>, the driver of translating TableGen code, works; how to use the TableGen backend's C++ APIs to operate TableGen directive's in-memory representation; and how <a id="_idIndexMarker150"/>to integrate our custom backend into <strong class="source-inline">llvm-tblgen</strong> in order to run it. Combining the skills you learned in this chapter and in the previous one, you can create a complete and standalone toolchain that implements your custom logic, using TableGen as a solution.</p>
			<h1 id="_idParaDest-64"><a id="_idTextAnchor064"/>Summary</h1>
			<p>In this chapter, we introduced TableGen, a powerful DSL for expressing structural data. We have shown you its universality in solving a variety of tasks, albeit it originally being created for compiler development. Through the lens of writing a donut recipe in TableGen, we have learned its core syntax. The following section on developing a custom TableGen backend taught you how to use C++ APIs to interact with in-memory TableGen directives parsed from the source input, giving you the power to create a complete and standalone TableGen toolchain to implement your own custom logic. Learning how to master TableGen can not only help your development in LLVM-related projects but also gives you more options to solve structural data problems in arbitrary projects.</p>
			<p>This section marks the end of the first part—an introduction to all kinds of useful supporting components in the LLVM project. Starting from the next chapter, we will move into the core compilation pipeline of LLVM. The first important topic we will cover is Clang, LLVM's official frontend for C-family programming languages.</p>
			<h1 id="_idParaDest-65"><a id="_idTextAnchor065"/>Further reading</h1>
			<ul>
				<li>This LLVM page provides a good reference on the TableGen syntax: <a href="https://llvm.org/docs/TableGen/ProgRef.html">https://llvm.org/docs/TableGen/ProgRef.html</a></li>
				<li>This LLVM page provides a good reference on developing a TableGen backend: <a href="https://llvm.org/docs/TableGen/BackGuide.html">https://llvm.org/docs/TableGen/BackGuide.html</a> </li>
			</ul>
		</div>
	</body></html>