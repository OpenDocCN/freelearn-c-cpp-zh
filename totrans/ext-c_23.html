<html><head></head><body>
		<div id="_idContainer166">
			<h1 class="chapterNumber">Chapter 23<a id="_idTextAnchor650"/></h1>
			<h1 id="_idParaDest-336" class="chapterTitle" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor651"/>Build Systems</h1>
			<p class="normal">For us programmers, building a project and running its various components is the first step in developing a new feature or fixing a reported bug in a project. In fact, this is not limited to C or C++; almost any project with a component written in a compiled programming language, such as C, C++, Java, or Go, needs to be built first.</p>
			<p class="normal">Therefore, being able to build a software project quickly and easily is a fundamental demand required by almost any party working in the software production pipeline, whether they be developers, testers, integrators, DevOps engineers, or even customer support.</p>
			<p class="normal">More than that, when you join a team as a newbie, the first thing you do is to build the code base that you are going to work on. Considering all this, then, it's clear that addressing the ability to build a software project is justified, given its importance within the software development process.</p>
			<p class="normal">Programmers need to build code bases frequently in order to see the results of their changes. Building a project with only a few source files seems to be easy and fast, but when the number of source files grows (and believe me, it happens), building a code base frequently becomes a real obstacle to development tasks. Therefore, a proper mechanism for building a software project is crucial.</p>
			<p class="normal">People used to write shell scripts to build a huge number of source files. Even though it worked, it took a lot of effort and maintenance to keep the scripts general enough to be used in various software projects. Following that, around 1976 at Bell Labs, the first (or, at least, one of the earliest ones) <em class="italics">build system</em>, named <em class="italics">Make</em>, was<a id="_idIndexMarker1703"/> developed and it was used in internal projects.</p>
			<p class="normal">After that, Make was used on a massive scale in all C and C++ projects, and even in other projects in which C/C++ were n-ot the main languages.</p>
			<p class="normal">In this chapter, we are going to talk about widely used <em class="italics">build systems</em> and <em class="italics">build script generators</em> for C and C++ projects. As part of this chapter, we will talk about the following topics:</p>
			<ul>
				<li class="list">First, we will look at what build systems are and what they are good for.</li>
				<li class="list">Then, we will cover what Make is and how Makefiles should be used.</li>
				<li class="list">CMake is the next topic. You will read about build script generators and you will learn how to write simple <code class="Code-In-Text--PACKT-">CMakeLists.txt</code> files.</li>
				<li class="list">We'll see what Ninja is and how it is different from Make.</li>
				<li class="list">The chapter will also explore how CMake should be used to generate Ninja build scripts.</li>
				<li class="list">We'll delve into what Bazel is and how it should be used. You will learn about <code class="Code-In-Text--PACKT-">WORKSPACE</code> and <code class="Code-In-Text--PACKT-">BUILD</code> files and how they should be written in a simple use case.</li>
				<li class="list">Finally, you will be given links to some already-published comparisons of various build systems.<a id="_idTextAnchor652"/></li>
			</ul>
			<p class="normal">Note that the build tools used in this chapter all need to be installed on your system beforehand. Proper resources and documentation should be available on the internet, since these build tools are being used on a massive scale.</p>
			<p class="normal">In the first section, we are going to explore what a build system actually is.</p>
			<h1 id="_idParaDest-337" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor653"/>What is a build system?</h1>
			<p class="normal">Put simply, a build system is <a id="_idIndexMarker1704"/>a set of programs and companion text files that collectively build a software code base. Nowadays, every programming language has its own set of build systems. For instance, in Java, you have <em class="italics">Ant</em>, <em class="italics">Maven</em>, <em class="italics">Gradle</em>, and so on. But what does "building a code base" mean?</p>
			<p class="normal">Building a code base means producing final products from source files. For example, for a C code base, the final products can be executable files, shared object files, or static libraries, and the goal of a C build system is to produce these products out of the C source files found in the code base. The details of the operations needed for this purpose depend heavily on the programming language or the languages involved in the code base.</p>
			<p class="normal">Many modern build systems, especially in projects written in a <em class="italics">JVM language</em> such as Java or Scala, provide an extra service. </p>
			<p class="normal">They <a id="_idIndexMarker1705"/>do <em class="italics">dependency management</em> as well. This means that the build system detects the dependencies of the target code base, and it downloads all of them and uses the downloaded artifacts during the <em class="italics">build process</em>. This is very handy, especially if there are a great many dependencies in a project, which is usually the case in big code bases.</p>
			<p class="normal">For instance, <em class="italics">Maven</em> is one of the <a id="_idIndexMarker1706"/>most famous building systems for Java projects; it uses XML files and supports dependency<a id="_idIndexMarker1707"/> management. Unfortunately, we don't have great tools for dependency management in C/C++ projects. Why we haven't got Maven-like build systems for C/C++ projects yet is a matter for debate, but the fact that they have not been developed yet could be a sign that we don't need them.</p>
			<p class="normal">Another aspect of a build system is the ability to build a huge project with multiple modules inside. Of course, this is possible using shell scripts and writing recursive <em class="italics">Makefiles</em> that go through any level of modules, but we are talking about the intrinsic support of such a demand. Unfortunately, Make does not offer this intrinsically. Another famous build tool, CMake, does offer that, however. We will talk more about this in the section dedicated to CMake.</p>
			<p class="normal">As of today, many projects still use Make as their default build system, however, through using CMake. Indeed, this is one of the points that makes CMake very important, and you need to learn it before joining a C/C++ project. Note that CMake is not limited to C and C++ and can be used in projects using various programming langua<a id="_idTextAnchor654"/>ges.</p>
			<p class="normal">In the following section, we are going to discuss the Make build system and how it builds a project. We will give an example of a multi-module C project and use it throughout this chapter to demonstrate how various build systems can be used to build this project.</p>
			<h1 id="_idParaDest-338" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor655"/>Make</h1>
			<p class="normal">The Make build <a id="_idIndexMarker1708"/>system uses Makefiles. A Makefile is<a id="_idIndexMarker1709"/> a text file with the name "Makefile" (exactly this and without any extension) in a source directory, and it <a id="_idIndexMarker1710"/>contains <em class="italics">build targets</em> and commands that tell Make how to build the current code base.</p>
			<p class="normal">Let's start with a simple multi-module C project and equip it with Make. The following shell box shows the files and directories found in the project. As you can see, it has one module named <code class="Code-In-Text--PACKT-">calc</code>, and another module named <code class="Code-In-Text--PACKT-">exec</code> is using it. </p>
			<p class="normal">The output of the <code class="Code-In-Text--PACKT-">calc</code> module would be a static object library, and the output of the <code class="Code-In-Text--PACKT-">exec</code> module is an executable file:</p>
			<p class="snippet shell"><strong class="highlight">$ tree ex23_1</strong></p>
			<p class="snippet shell">ex23_1/</p>
			<p class="snippet shell">├── calc</p>
			<p class="snippet shell">│   ├── add.c</p>
			<p class="snippet shell">│   ├── calc.h</p>
			<p class="snippet shell">│   ├── multiply.c</p>
			<p class="snippet shell">│   └── subtract.c</p>
			<p class="snippet shell">└── exec</p>
			<p class="snippet shell">    └── main.c</p>
			<p class="snippet shell">2 directories, 5 files </p>
			<p class="snippet shell"><strong class="highlight">$</strong></p>
			<p class="packt_figref">Shell Box 23-1: The files and directories found in the target project</p>
			<p class="normal">If we want to build the<a id="_idIndexMarker1711"/> above project without using a build system, we must run the following commands in order to build its products. Note that we have used Linux as the target platform for this project:</p>
			<p class="snippet shell"><strong class="highlight">$ mkdir -p out</strong></p>
			<p class="snippet shell"><strong class="highlight">$ gcc -c calc/add.c -o out/add.o</strong></p>
			<p class="snippet shell"><strong class="highlight">$ gcc -c calc/multiply.c -o out/multiply.o</strong></p>
			<p class="snippet shell"><strong class="highlight">$ gcc -c calc/subtract.c -o out/subtract.o</strong></p>
			<p class="snippet shell"><strong class="highlight">$ ar rcs out/libcalc.a out/add.o out/multiply.o out/subtract.o</strong></p>
			<p class="snippet shell"><strong class="highlight">$ gcc -c -Icalc exec/main.c -o out/main.o</strong></p>
			<p class="snippet shell"><strong class="highlight">$ gcc -Lout out/main.o -lcalc -o out/ex23_1.out</strong></p>
			<p class="snippet shell"><strong class="highlight">$</strong></p>
			<p class="packt_figref">Shell Box 23-2: Building the target project</p>
			<p class="normal">As you can see, the project has two artifacts: a static library, <code class="Code-In-Text--PACKT-">libcalc.a</code>, and an executable file, <code class="Code-In-Text--PACKT-">ex23_1.out</code>. If you don't know how to compile a C project, or the preceding commands are strange to you, please read <em class="italics">Chapter 2</em>, <em class="italics">Compilation and Linking</em>, and <em class="italics">Chapter 3</em>, <em class="italics">Object Files</em>.</p>
			<p class="normal">The first command in <em class="italics">Shell Box 23-2</em> creates a directory named <span class="Plain-Text-Char">out</span>. This directory is supposed to contain all the relocatable object files and the final products. </p>
			<p class="normal">Following that, the next three commands use <code class="Code-In-Text--PACKT-">gcc</code> to compile the source files in the <code class="Code-In-Text--PACKT-">calc</code> directory and produce their corresponding relocatable object files. Then, these object files are used in the fifth command to produce the static library <code class="Code-In-Text--PACKT-">libcalc.a</code>.</p>
			<p class="normal">Finally, the last two commands compile the file <code class="Code-In-Text--PACKT-">main.c</code> from the <span class="Plain-Text-Char">exec</span> directory and finally link it together with <code class="Code-In-Text--PACKT-">libcalc.a</code> to produce the final executable file, <code class="Code-In-Text--PACKT-">ex23_1.out</code>. Note that all these files are put inside the <span class="Plain-Text-Char">out</span> directory.</p>
			<p class="normal">The preceding commands can grow as the number of source files grows. We could maintain the preceding<a id="_idIndexMarker1712"/> commands in a shell script file called a <em class="italics">build script</em>, but there are some aspects that we should think about beforehand:</p>
			<ul>
				<li class="list">Are we going to run the same<a id="_idIndexMarker1713"/> commands on all platforms? There are some details that differ in various compilers and environments; therefore, the commands might vary from one system to another. In the simplest scenario, we should maintain different shell scripts for different platforms. Then, it effectively means that our script is not <em class="italics">portable</em>.</li>
				<li class="list">What happens when a new directory or a new module is added to the project? Do we need to change the build script?</li>
				<li class="list">What happens to the build script if we add new source files?</li>
				<li class="list">What happens if we need a new product, like a new library or a new executable file?</li>
			</ul>
			<p class="normal">A good build system <a id="_idIndexMarker1714"/>should handle all or most of the situations covered above. Let's present our first Makefile. This file is going to build the above project and generate its products. All the files written for build systems, in this section and the following sections, can be used to build this particular project and nothing more than that.</p>
			<p class="normal">The following code box shows the content of the simplest Makefile that we can write for the above project:</p>
			<p class="snippet code">build:</p>
			<p class="snippet code">    mkdir -p out</p>
			<p class="snippet code">    gcc -c calc/add.c -o out/add.o</p>
			<p class="snippet code">    gcc -c calc/multiply.c -o out/multiply.o</p>
			<p class="snippet code">    gcc -c calc/subtract.c -o out/subtract.o</p>
			<p class="snippet code">    ar rcs out/libcalc.a out/add.o out/multiply.o out/subtract.o</p>
			<p class="snippet code">    gcc -c -Icalc exec/main.c -o out/main.o</p>
			<p class="snippet code">    gcc -Lout -lcalc out/main.o -o out/ex23_1.out</p>
			<p class="snippet code">clean:</p>
			<p class="snippet code">    rm -rfv out</p>
			<p class="packt_figref">Code Box 23-1 [Makefile-very-simple]: A very simple Makefile written for the target project</p>
			<p class="normal">The preceding Makefile contains two targets: <code class="Code-In-Text--PACKT-">build</code> and <code class="Code-In-Text--PACKT-">clean</code>. Targets have a set of commands, which should be executed when the target is summoned. This set of commands is called the <em class="italics">recipe</em> of the target.</p>
			<p class="normal">In order to run the commands in a Makefile, we need to use the <code class="Code-In-Text--PACKT-">make</code> command. You need to tell the <code class="Code-In-Text--PACKT-">make</code> command<a id="_idIndexMarker1715"/> which target to run, but if you leave it empty, <span class="Plain-Text-Char">make</span> always executes the first target.</p>
			<p class="normal">To build the preceding project using the Makefile, it is enough to copy the lines from <em class="italics">Code Box 23-1</em> to a file named <code class="Code-In-Text--PACKT-">Makefile</code> and put it in the root of the project. The content of the project's directory should be similar to what we see in the following shell box:</p>
			<p class="snippet shell"><strong class="highlight">$ tree ex23_1</strong></p>
			<p class="snippet shell">ex23_1/</p>
			<p class="snippet shell">├── <strong class="highlight">Makefile</strong></p>
			<p class="snippet shell">├── calc</p>
			<p class="snippet shell">│   ├── add.c</p>
			<p class="snippet shell">│   ├── calc.h</p>
			<p class="snippet shell">│   ├── multiply.c</p>
			<p class="snippet shell">│   └── subtract.c</p>
			<p class="snippet shell">└── exec</p>
			<p class="snippet shell">    └── main.c</p>
			<p class="snippet shell">2 directories, 6 files </p>
			<p class="snippet shell"><strong class="highlight">$</strong></p>
			<p class="packt_figref">Shell Box 23-3: The files and directories found in the target project after adding the Makefile</p>
			<p class="normal">Following that, you can just run the <span class="Plain-Text-Char">make</span> command. The <code class="Code-In-Text--PACKT-">make</code> program automatically looks for the <code class="Code-In-Text--PACKT-">Makefile</code> file in the current directory and executes its first target. If we wanted to run the <code class="Code-In-Text--PACKT-">clean</code> target, we would have to use the <code class="Code-In-Text--PACKT-">make clean</code> command. The <code class="Code-In-Text--PACKT-">clean</code> target can be used to remove the files produced as part of the build process, and this way, we can start a fresh build from scratch.</p>
			<p class="normal">The following shell box shows the result of running the <code class="Code-In-Text--PACKT-">make</code> command:</p>
			<p class="snippet shell"><strong class="highlight">$ cd ex23_1</strong></p>
			<p class="snippet shell"><strong class="highlight">$ make</strong></p>
			<p class="snippet shell">mkdir -p out</p>
			<p class="snippet shell">gcc -c -Icalc exec/main.c -o out/main.o</p>
			<p class="snippet shell">gcc -c calc/add.c -o out/add.o</p>
			<p class="snippet shell">gcc -c calc/multiply.c -o out/multiply.o</p>
			<p class="snippet shell">gcc -c calc/subtract.c -o out/subtract.o</p>
			<p class="snippet shell">ar rcs out/libcalc.a out/add.o out/multiply.o out/subtract.o</p>
			<p class="snippet shell">gcc -Lout -lcalc out/main.o -o out/ex23_1.out</p>
			<p class="snippet shell"><strong class="highlight">$</strong></p>
			<p class="packt_figref">Shell Box 23-4: Building the target project using the very simple Makefile</p>
			<p class="normal">You might ask, "What is the difference between a build script (written in a shell script), and the above Makefile?" You'd be right to ask this! The preceding Makefile does not represent the way we<a id="_idIndexMarker1716"/> usually use Make to build our projects. </p>
			<p class="normal">In fact, the preceding Makefile is a naive usage of the Make build system, and it doesn't benefit from the features we know that Make has to offer.</p>
			<p class="normal">In other words, so far, a Makefile has been remarkably similar to a shell script, and we could still just use shell scripting (though, of course, that would involve more effort). Now we get to the point where Makefiles become interesting and really different.</p>
			<p class="normal">The following Makefile is still simple, but it introduces more of the aspects of the Make build system that we are interested in:</p>
			<p class="snippet code">CC = gcc</p>
			<p class="snippet code">build: prereq out/main.o out/libcalc.a</p>
			<p class="snippet code">    ${CC} -Lout -lcalc out/main.o -o out/ex23_1.out</p>
			<p class="snippet code">prereq:</p>
			<p class="snippet code">    mkdir -p out</p>
			<p class="snippet code">out/libcalc.a: out/add.o out/multiply.o out/subtract.o</p>
			<p class="snippet code">    ar rcs out/libcalc.a out/add.o out/multiply.o out/subtract.o</p>
			<p class="snippet code">out/main.o: exec/main.c calc/calc.h</p>
			<p class="snippet code">    ${CC} -c -Icalc exec/main.c -o out/main.o</p>
			<p class="snippet code">out/add.o: calc/add.c calc/calc.h</p>
			<p class="snippet code">    ${CC} -c calc/add.c -o out/add.o</p>
			<p class="snippet code">out/subtract.o: calc/subtract.c calc/calc.h</p>
			<p class="snippet code">    ${CC} -c calc/subtract.c -o out/subtract.o</p>
			<p class="snippet code">out/multiply.o: calc/multiply.c calc/calc.h</p>
			<p class="snippet code">    ${CC} -c calc/multiply.c -o out/multiply.o</p>
			<p class="snippet code">clean: out</p>
			<p class="snippet code">    rm -rf out</p>
			<p class="packt_figref">Code Box 23-2 [Makefile-simple]: A new, but still simple, Makefile written for the target project</p>
			<p class="normal">As you can see, we can declare a variable in a Makefile and use it in various places, just as we have declared <span class="Plain-Text-Char">CC</span> in the preceding code box. Variables, together with conditions in a Makefile, allow us to write flexible build instructions with less effort than it takes to write a shell script that would achieve the same flexibility.</p>
			<p class="normal">Another cool feature of Makefiles is the ability to include other Makefiles. This way, you can benefit from existing Makefiles that you have written in your previous projects.</p>
			<p class="normal">As you can see in the <a id="_idIndexMarker1717"/>preceding Makefile, each Makefile can have several targets. Targets start at the beginning of a line and end with a colon, ":". One tab character <em class="italics">must</em> be used to indent all the instructions within a target (the recipe) in order to make them recognizable by the <code class="Code-In-Text--PACKT-">make</code> program. Here is the cool thing about targets: they can be dependent on the other targets.</p>
			<p class="normal">For example, in the preceding Makefile, the <code class="Code-In-Text--PACKT-">build</code> target depends on the <code class="Code-In-Text--PACKT-">prereq</code>, <code class="Code-In-Text--PACKT-">out /main.o</code>, and <code class="Code-In-Text--PACKT-">out/libcalc.a</code> targets. Then, whenever the <code class="Code-In-Text--PACKT-">build</code> target is invoked, first, its depending targets will be checked, and if they are not yet produced, then those targets will be invoked first. Now, if you pay more attention to the targets in the preceding Makefile, you should be able to see the flow of execution between targets.</p>
			<p class="normal">This is definitely something that we miss in a shell script; a lot of control flow mechanisms (loops, conditions, and so on) would be needed to make a shell script work like this. Makefiles are less verbose and more declarative, and that is why we use them. We want to only declare what needs to be built, and we do not need to know about the path it takes to get built. While this is not totally achieved by using Make, it is a start to having a fully featured build system.</p>
			<p class="normal">Another feature of the targets in a Makefile is that if they are referring to a file or a directory on the disk, such as <code class="Code-In-Text--PACKT-">out/multiply.o</code>, the <code class="Code-In-Text--PACKT-">make</code> program checks for recent modifications to that file or directory, and if there is no modification since the last build, it skips that target. This is also true for the dependency of <code class="Code-In-Text--PACKT-">out/multiply.o</code>, which is <code class="Code-In-Text--PACKT-">calc/multiply.c</code>. If the source file, <code class="Code-In-Text--PACKT-">calc/multiply.c</code>, has not been changed recently and it has been compiled before, it doesn't make sense to compile it again. This is again a feature that you cannot simply obtain by writing shell scripts.</p>
			<p class="normal">By having this feature, you only compile the source files that have been modified from the last build, and this reduces a huge amount of compilation for sources that have not been changed since the last build. Of course, this feature will work after having the whole project compiled at least once. After that, only modified sources will trigger a compilation or linkage.</p>
			<p class="normal">Another crucial point in the preceding Makefile is the <code class="Code-In-Text--PACKT-">calc/calc.h</code> target. As you can see, there are multiple<a id="_idIndexMarker1718"/> targets, mostly source files, that are dependent on the header file, <code class="Code-In-Text--PACKT-">calc/calc.h</code>. Therefore, based on the functionality we explained before, a simple modification to the header file can trigger multiple compilations for the source files depending on that header file.</p>
			<p class="normal">This is exactly why we try to include only the required header files in a source file, and use forward declarations wherever possible instead of inclusion. Forward declarations are not usually made in source files because there, we often demand access to the actual definition of a structure or a function, but it can be easily done in header files.</p>
			<p class="normal">Having a lot of dependencies between header files usually leads to build disasters. Even a small modification to a header file included by many other header files, and eventually included by many source files, can trigger building the whole project or something on that scale. This will effectively reduce the quality of development as well as lead to a developer having to wait for minutes between builds.</p>
			<p class="normal">The preceding Makefile is still too verbose. We have to change the targets whenever we add a new source file. We expect to change the Makefile upon adding a new source file, but not by adding a new target and changing the overall structure of a Makefile. This effectively prevents us from reusing the same Makefile in another project similar to the current one.</p>
			<p class="normal">More than that, many targets follow the same pattern, and we can benefit from the <em class="italics">pattern matching</em> feature available in <a id="_idIndexMarker1719"/>Make to reduce the number of targets and write less code in a Makefile. This is another super feature of Make whose effect you cannot easily achieve by writing shell scripts.</p>
			<p class="normal">The following Makefile will be our last one for this project, but still is not the best Makefile that a Make professional can write:</p>
			<p class="snippet code">BUILD_DIR = out</p>
			<p class="snippet code">OBJ = ${BUILD_DIR}/calc/add.o \</p>
			<p class="snippet code">                ${BUILD_DIR}/calc/subtract.o \</p>
			<p class="snippet code">                ${BUILD_DIR}/calc/multiply.o \</p>
			<p class="snippet code">                ${BUILD_DIR}/exec/main.o</p>
			<p class="snippet code">CC = gcc</p>
			<p class="snippet code">HEADER_DIRS = -Icalc</p>
			<p class="snippet code">LIBCALCNAME = calc</p>
			<p class="snippet code">LIBCALC = ${BUILD_DIR}/lib${LIBCALCNAME}.a</p>
			<p class="snippet code">EXEC = ${BUILD_DIR}/ex23_1.out</p>
			<p class="snippet code">build: prereq ${BUILD_DIR}/exec/main.o ${LIBCALC}</p>
			<p class="snippet code">    ${CC} -L${BUILD_DIR} -l${LIBCALCNAME} ${BUILD_DIR}/exec/main.o -o ${EXEC}</p>
			<p class="snippet code">prereq:</p>
			<p class="snippet code">    mkdir -p ${BUILD_DIR}</p>
			<p class="snippet code">    mkdir -p ${BUILD_DIR}/calc</p>
			<p class="snippet code">    mkdir -p ${BUILD_DIR}/exec</p>
			<p class="snippet code">${LIBCALC}: ${OBJ}</p>
			<p class="snippet code">    ar rcs ${LIBCALC} ${OBJ}</p>
			<p class="snippet code">${BUILD_DIR}/calc/%.o: calc/%.c</p>
			<p class="snippet code">    ${CC} -c ${HEADER_DIRS} $&lt; -o $@</p>
			<p class="snippet code">${BUILD_DIR}/exec/%.o: exec/%.c</p>
			<p class="snippet code">    ${CC} -c ${HEADER_DIRS} $&lt; -o $@</p>
			<p class="snippet code">clean: ${BUILD_DIR}</p>
			<p class="snippet code">    rm -rf ${BUILD_DIR}</p>
			<p class="packt_figref">Code Box 23-3 [Makefile-by-pattern]: A new Makefile written for the target project that uses pattern matching</p>
			<p class="normal">The preceding<a id="_idIndexMarker1720"/> Makefile uses pattern matching in its targets. The variable <code class="Code-In-Text--PACKT-">OBJ</code> keeps a list of the expected relocatable object files, and it is used in all other places when a list of object files is needed.</p>
			<p class="normal">This is not a book on how Make's pattern matching works, but you can see that there are a bunch of wildcard characters, such as <code class="Code-In-Text--PACKT-">%</code>, <code class="Code-In-Text--PACKT-">$&lt;</code>, and <code class="Code-In-Text--PACKT-">$@</code>, that are used in the patterns. </p>
			<p class="normal">Running the preceding Makefile will produce the same results as the other Makefiles, but we can benefit from the various nice features that Make offers, and eventually have a reusable and maintainable Make script.</p>
			<p class="normal">The following shell box shows how to run the preceding Makefile and what the output is:</p>
			<p class="snippet shell"><strong class="highlight">$ make</strong></p>
			<p class="snippet shell">mkdir -p out</p>
			<p class="snippet shell">mkdir -p out/calc</p>
			<p class="snippet shell">mkdir -p out/exec</p>
			<p class="snippet shell">gcc -c -Icalc exec/main.c -o out/exec/main.o</p>
			<p class="snippet shell">gcc -c -Icalc calc/add.c -o out/calc/add.o</p>
			<p class="snippet shell">gcc -c -Icalc calc/subtract.c -o out/calc/subtract.o</p>
			<p class="snippet shell">gcc -c -Icalc calc/multiply.c -o out/calc/multiply.o</p>
			<p class="snippet shell">ar rcs out/libcalc.a out/calc/add.o out/calc/subtract.o out/calc/multiply.o out/exec/main.o</p>
			<p class="snippet shell">gcc -Lout -lcalc out/exec/main.o -o out/ex23_1.out</p>
			<p class="snippet shell"><strong class="highlight">$</strong></p>
			<p class="packt_figref">Shell Box 23-5: Building the target project using the final Makefile</p>
			<p class="normal">In the following<a id="_idIndexMarker1721"/> sections, we will be talking about CMake, a great tool for generating true Makefiles. In fact, a while after Make became popular, a new generation of build tools emerged, <em class="italics">buil<a id="_idTextAnchor656"/>d script generators</em>, which <a id="_idIndexMarker1722"/>could generate Makefiles or scripts from other build systems based on a given description. CMake is one of them, and it is probably the most popular one.</p>
			<div>
				<div id="_idContainer160" class="note">
					<p class="Information-Box--PACKT-"><strong class="screen-text">Note</strong>:</p>
					<p class="Information-Box--PACKT-">Here is the main link to<a id="_idIndexMarker1723"/> read more about GNU Make, which is the implementation of Make made <a href="https://www.gnu.org/software/make/manual/html_node/index.html">for the GNU project: <span class="url">https://www.gnu.org/software/make/manual</span></a><span class="url">/html_node/index.html</span>.</p>
				</div>
			</div>
			<h1 id="_idParaDest-339" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor657"/>CMake – not a build system!</h1>
			<p class="normal">CMake is a build script <a id="_idIndexMarker1724"/>generator and acts as a generator for other build systems such as Make and Ninja. It is a tedious and complex job to write effective and cross-platform Makefiles. CMake or similar<a id="_idIndexMarker1725"/> tools, like <em class="italics">Autotools</em>, are developed to deliver finely tuned cross-platform build scripts such as Makefiles or Ninja build files. Note that Ninja is another build system and will be introduced in the next section.</p>
			<div>
				<div id="_idContainer161" class="note">
					<p class="Information-Box--PACKT-"><strong class="screen-text">Note</strong>:</p>
					<p class="Information-Box--PACKT-">You can read more<a href="https://www.gnu.org/software/automake/manual/html_node/Autotools-Introduction.html"> <span id="_idIndexMarker1726"/>about Autotools here: <span class="url">https://www.gnu.org/software/automake/manual/html_node/Aut</span></a><span class="url">otools-Introduction.html</span>.</p>
				</div>
			</div>
			<p class="normal">Dependency <a id="_idIndexMarker1727"/>management is also important, which is not delivered through Makefiles. These generator tools can also check for installed dependencies and won't generate the build scripts if a required dependency is missing from the system. Checking the compilers and their versions, and finding their locations, their supported features, and so on is all part of what these tools do before generating a build script.</p>
			<p class="normal">Like Make, which looks for a file named <code class="Code-In-Text--PACKT-">Makefile</code>, CMake looks for a file named <code class="Code-In-Text--PACKT-">CMakeLists.txt</code>. Wherever you find this file in a project, it means that CMake can be used to generate proper Makefiles. Fortunately, and unlike Make, CMake supports nested modules. In other words, you can have multiple <code class="Code-In-Text--PACKT-">CMakeLists.txt</code><span class="Plain-Text-Char"> </span>in other directories as part of your project <a id="_idIndexMarker1728"/>and all of them can be found and proper Makefiles would be generated for all of them, just by running CMake in the root of your project.</p>
			<p class="normal">Let's continue this section by adding CMake support to our example project. For this purpose, we add three <code class="Code-In-Text--PACKT-">CMakeLists.txt</code> files. Next, you can see the hierarchy of the project after adding these files:</p>
			<p class="snippet shell"><strong class="highlight">$ tree ex23_1</strong></p>
			<p class="snippet shell">ex23_1/</p>
			<p class="snippet shell">├── <strong class="highlight">CMakeLists.txt</strong></p>
			<p class="snippet shell">├── calc</p>
			<p class="snippet shell">│   ├── <strong class="highlight">CMakeLists.txt</strong></p>
			<p class="snippet shell">│   ├── add.c</p>
			<p class="snippet shell">│   ├── calc.h</p>
			<p class="snippet shell">│   ├── multiply.c</p>
			<p class="snippet shell">│   └── subtract.c</p>
			<p class="snippet shell">└── exec</p>
			<p class="snippet shell">    ├── <strong class="highlight">CMakeLists.txt</strong></p>
			<p class="snippet shell">    └── main.c</p>
			<p class="snippet shell">2 directories, 8 files</p>
			<p class="snippet shell"><strong class="highlight">$</strong></p>
			<p class="packt_figref">Shell Box 23-6: The project hierarchy after introducing three CMakeLists.txt files</p>
			<p class="normal">As you can see, we have three <code class="Code-In-Text--PACKT-">CMakeLists.txt</code> files: one in the root directory, one in the <code class="Code-In-Text--PACKT-">calc</code> directory, and the other one in the <code class="Code-In-Text--PACKT-">exec</code> directory. The following code box shows the content of the <code class="Code-In-Text--PACKT-">CMakeLists.txt</code> file found in the root directory. As you can see, it adds subdirectories of <code class="Code-In-Text--PACKT-">calc</code> and <code class="Code-In-Text--PACKT-">exec</code>. </p>
			<p class="normal">These subdirectories must have a <code class="Code-In-Text--PACKT-">CMakeLists.txt</code> file inside and, in fact, they do, according to our setup:</p>
			<p class="snippet code">cmake_minimum_required(VERSION 3.8)</p>
			<p class="snippet code">include_directories(calc)</p>
			<p class="snippet code">add_subdirectory(calc)</p>
			<p class="snippet code">add_subdirectory(exec)</p>
			<p class="packt_figref">Code Box 23-4 [CMakeLists.txt]: The CMakeLists.txt file found in the root directory of the project</p>
			<p class="normal">The preceding CMake file adds the <code class="Code-In-Text--PACKT-">calc</code> directory to the <code class="Code-In-Text--PACKT-">include</code> directories that will be used by the C compiler <a id="_idIndexMarker1729"/>when compiling the source files. Like we said before, it also adds two subdirectories: <code class="Code-In-Text--PACKT-">calc</code> and <code class="Code-In-Text--PACKT-">exec</code>. These directories have their own <code class="Code-In-Text--PACKT-">CMakeLists.txt</code> files that explain how to compile their content. The following is the <code class="Code-In-Text--PACKT-">CMakeLists.txt</code> file found in the <code class="Code-In-Text--PACKT-">calc</code> directory:</p>
			<p class="snippet code">add_library(calc STATIC</p>
			<p class="snippet code">  add.c</p>
			<p class="snippet code">  subtract.c</p>
			<p class="snippet code">  multiply.c</p>
			<p class="snippet code">)</p>
			<p class="packt_figref">Code Box 23-5 [calc/CMakeLists.txt]: The CMakeLists.txt file found in the calc directory</p>
			<p class="normal">As you can see, it is just a simple <em class="italics">target declaration</em> for the <code class="Code-In-Text--PACKT-">calc</code> target, meaning that we need to have a static library named <code class="Code-In-Text--PACKT-">calc</code> (actually <code class="Code-In-Text--PACKT-">libcalc.a</code> after build) that should contain the corresponding relocatable object files for the source files, <code class="Code-In-Text--PACKT-">add.c</code>, <code class="Code-In-Text--PACKT-">subtract.c</code>, and <code class="Code-In-Text--PACKT-">multiply.c</code>. Note that CMake targets usually represent the final products of a code base. Therefore, specifically for the <code class="Code-In-Text--PACKT-">calc</code> module, we have only one product, which is a static library.</p>
			<p class="normal">As you can see, nothing else is specified for the <code class="Code-In-Text--PACKT-">calc</code> target. For instance, we didn't specify the extension of the static library or the filename of the library (even though we could). All other configurations required to build this module are either inherited from the parent <code class="Code-In-Text--PACKT-">CMakeLists.txt</code> file or have been obtained from the default configuration of CMake itself.</p>
			<p class="normal">For example, we know that the extension for shared object files is different on Linux and macOS. Therefore, if the target is a shared library, there is no need to specify the extension as part of the target declaration. CMake is able to handle this very platform-specific difference, and the final shared object file will have the correct extension based on the platform that it is being built on.</p>
			<p class="normal">The following <code class="Code-In-Text--PACKT-">CMakeLists.txt</code> file is the one found in the <code class="Code-In-Text--PACKT-">exec</code> directory:</p>
			<p class="snippet code">add_executable(ex23_1.out</p>
			<p class="snippet code">  main.c</p>
			<p class="snippet code">)</p>
			<p class="snippet code">target_link_libraries(ex23_1.out</p>
			<p class="snippet code">  calc</p>
			<p class="snippet code">)</p>
			<p class="packt_figref">Code Box 23-6 [exec/CMakeLists.txt]: The CMakeLists.txt file found in the exec directory</p>
			<p class="normal">As you can see, the target declared in the preceding <code class="Code-In-Text--PACKT-">CMakeLists.txt</code> is an executable, and it should be linked to the <code class="Code-In-Text--PACKT-">calc</code> target that is already declared in another <code class="Code-In-Text--PACKT-">CMakeLists.txt</code> file. </p>
			<p class="normal">This really gives you the power to create libraries in one corner of your project and use them in another corner just by writing some directives.</p>
			<p class="normal">Now it's time to show<a id="_idIndexMarker1730"/> you how to generate a Makefile based on the <code class="Code-In-Text--PACKT-">CMakeLists.txt</code> file found in the root directory. Note that we do this in a separate directory named <code class="Code-In-Text--PACKT-">build</code> in order to have the resulting relocatable and final object files kept separated from the actual sources.</p>
			<p class="normal">If you're <a id="_idIndexMarker1731"/>using a <strong class="bold">source control management</strong> (<strong class="bold">SCM</strong>) system like <em class="italics">git</em>, you can ignore the <code class="Code-In-Text--PACKT-">build</code> directory because it should be generated on each platform separately. The only files that matter are the <code class="Code-In-Text--PACKT-">CMakeLists.txt</code> files, which are always kept in a source control repository.</p>
			<p class="normal">The following shell box demonstrates how to generate build scripts (in this case, a Makefile) for the <code class="Code-In-Text--PACKT-">CMakeLists.txt</code> file found in the root directory:</p>
			<p class="snippet shell"><strong class="highlight">$ cd ex23_1</strong></p>
			<p class="snippet shell"><strong class="highlight">$ mkdir -p build</strong></p>
			<p class="snippet shell"><strong class="highlight">$ cd build</strong></p>
			<p class="snippet shell"><strong class="highlight">$ rm -rfv *</strong></p>
			<p class="snippet shell"><strong class="highlight">...</strong></p>
			<p class="snippet shell"><strong class="highlight">$ cmake ..</strong></p>
			<p class="snippet shell">-- The C compiler identification is GNU 7.4.0</p>
			<p class="snippet shell">-- The CXX compiler identification is GNU 7.4.0</p>
			<p class="snippet shell">-- Check for working C compiler: /usr/bin/cc</p>
			<p class="snippet shell">-- Check for working C compiler: /usr/bin/cc -- works</p>
			<p class="snippet shell">-- Detecting C compiler ABI info</p>
			<p class="snippet shell">-- Detecting C compiler ABI info - done</p>
			<p class="snippet shell">-- Detecting C compile features</p>
			<p class="snippet shell">-- Detecting C compile features - done</p>
			<p class="snippet shell">-- Check for working CXX compiler: /usr/bin/c++</p>
			<p class="snippet shell">-- Check for working CXX compiler: /usr/bin/c++ -- works</p>
			<p class="snippet shell">-- Detecting CXX compiler ABI info</p>
			<p class="snippet shell">-- Detecting CXX compiler ABI info - done</p>
			<p class="snippet shell">-- Detecting CXX compile features</p>
			<p class="snippet shell">-- Detecting CXX compile features - done</p>
			<p class="snippet shell">-- Configuring done</p>
			<p class="snippet shell">-- Generating done</p>
			<p class="snippet shell">-- Build files have been written to: .../extreme_c/ch23/ex23_1/build</p>
			<p class="snippet shell"><strong class="highlight">$</strong></p>
			<p class="packt_figref">Shell Box 23-7: Generating a Makefile based on the CMakeLists.txt file found in the root directory</p>
			<p class="normal">As you can see from<a id="_idIndexMarker1732"/> the output, the CMake command has been able to detect the working compilers, their ABI info (for more on ABI, refer to <em class="italics">Chapter 3</em>, <em class="italics">Object Files</em>), their features, and so on, and finally it has generated a Makefile in the <code class="Code-In-Text--PACKT-">build</code> directory.</p>
			<div>
				<div id="_idContainer162" class="note">
					<p class="Information-Box--PACKT-"><strong class="screen-text">Note</strong>:</p>
					<p class="Information-Box--PACKT-">In <em class="italics">Shell Box 23-7</em>, we assumed that we could have had the <code class="Code-In-Text--PACKT-">build</code> directory in place; therefore, we removed all of its content first.</p>
				</div>
			</div>
			<p class="normal">You can see the content of the <code class="Code-In-Text--PACKT-">build</code> directory and the generated Makefile:</p>
			<p class="snippet shell"><strong class="highlight">$ ls</strong></p>
			<p class="snippet shell">CMakeCache.txt  CMakeFiles  <strong class="highlight">Makefile</strong>  calc  cmake_install.cmake  exec</p>
			<p class="snippet shell"><strong class="highlight">$</strong></p>
			<p class="packt_figref">Shell Box 23-8: Generated Makefile in the build directory</p>
			<p class="normal">Now that you've got a Makefile in your <code class="Code-In-Text--PACKT-">build</code> directory, you're free to run the <span class="Plain-Text-Char">make</span> command. It will take care of the compilation and display its progress nicely for you. </p>
			<p class="normal">Note that you should be in the <code class="Code-In-Text--PACKT-">build</code> directory before running the <code class="Code-In-Text--PACKT-">make</code> command:</p>
			<p class="snippet shell"><strong class="highlight">$ make</strong></p>
			<p class="snippet shell">Scanning dependencies of target calc</p>
			<p class="snippet shell">[ 16%] Building C object calc/CMakeFiles/calc.dir/add.c.o</p>
			<p class="snippet shell">[ 33%] Building C object calc/CMakeFiles/calc.dir/subtract.c.o</p>
			<p class="snippet shell">[ 50%] Building C object calc/CMakeFiles/calc.dir/multiply.c.o</p>
			<p class="snippet shell">[ 66%] Linking C static library libcalc.a</p>
			<p class="snippet shell">[ 66%] Built target calc</p>
			<p class="snippet shell">Scanning dependencies of target ex23_1.out</p>
			<p class="snippet shell">[ 83%] Building C object exec/CMakeFiles/ex23_1.out.dir/main.c.o</p>
			<p class="snippet shell">[100%] Linking C executable ex23_1.out</p>
			<p class="snippet shell">[100%] Built target ex23_1.out</p>
			<p class="snippet shell"><strong class="highlight">$</strong></p>
			<p class="packt_figref">Shell Box 23-9: Executing the generated Makefile</p>
			<p class="normal">Currently, many big projects use CMake, and you can build their sources by using more or less the same <a id="_idIndexMarker1733"/>commands that we've shown in the previous shell boxes. <em class="italics">Vim</em> is one such project. Even CMake itself is built using CMake after having a minimum CMake system built by Autotools! CMake now has lots of versions and features and it would take a whole book to discuss them in extensive detail.</p>
			<div>
				<div id="_idContainer163" class="note">
					<p class="Information-Box--PACKT-"><strong class="screen-text">Note</strong>:</p>
					<p class="Information-Box--PACKT-">The following link is the official <a id="_idIndexMarker1734"/>documentation of the latest version of CMake and it can help you to get an idea of how it <a href="https://cmake.org/cmake/help/latest/index.html">works and what features it has: <span class="url">https://cmake.</span></a><span class="url">org/cmake/help/latest/index.html</span>.</p>
				</div>
			</div>
			<p class="normal">As a final note in this section, CMake can create build script files for Microsoft Visual Studio, Apple's Xcode, and other development environments.</p>
			<p class="normal">In the following section, we will be discussing the Ninja build system, a fast alternative to Make that has been gaining momentum recently. We also explain how CMake can be used to generate Ninja bu<a id="_idTextAnchor658"/>ild script files instead of Makefiles.</p>
			<h1 id="_idParaDest-340" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor659"/>Ninja</h1>
			<p class="normal">Ninja is an alternative<a id="_idIndexMarker1735"/> to Make. I hesitate to call it a replacement, but it is a faster alternative. It achieves its high performance by removing some of the features that Make offers, such as string manipulation, loops, and pattern matching. </p>
			<p class="normal">Ninja has less overhead by removing these features, and because of that, it is not wise to write Ninja build scripts from scratch.</p>
			<p class="normal">Writing Ninja scripts can be compared to writing shell scripts, the downsides of which we explained in the previous section. That's why it is recommended to use it together with a build script generator tool like CMake.</p>
			<p class="normal">In this section, we show how Ninja can be used when Ninja build scripts are generated by CMake. Therefore, in this section, we won't go through the syntax of Ninja, as we did for Makefiles. That's <a id="_idIndexMarker1736"/>because we are not going to write them ourselves; instead, we are going to ask CMake to generate them for us.</p>
			<div>
				<div id="_idContainer164" class="note">
					<p class="Information-Box--PACKT-"><strong class="screen-text">Note</strong>:</p>
					<p class="Information-Box--PACKT-">For more information on Ninja syntax, please follow this link: <span class="url">https://ninja-build.org/manual.html#_writing_your_own_ninja_files</span>.</p>
				</div>
			</div>
			<p class="normal">As we explained before, it is best to use a build script generator to produce Ninja build script files. In the following shell box, you can see how to use CMake to generate a Ninja build script, <code class="Code-In-Text--PACKT-">build.ninja</code>, instead of a Makefile for our target project:</p>
			<p class="snippet shell"><strong class="highlight">$ cd ex23_1</strong></p>
			<p class="snippet shell"><strong class="highlight">$ mkdir -p build</strong></p>
			<p class="snippet shell"><strong class="highlight">$ cd build</strong></p>
			<p class="snippet shell"><strong class="highlight">$ rm -rfv *</strong></p>
			<p class="snippet shell"><strong class="highlight">...</strong></p>
			<p class="snippet shell"><strong class="highlight">$ cmake -GNinja ..</strong></p>
			<p class="snippet shell">-- The C compiler identification is GNU 7.4.0</p>
			<p class="snippet shell">-- The CXX compiler identification is GNU 7.4.0</p>
			<p class="snippet shell">-- Check for working C compiler: /usr/bin/cc</p>
			<p class="snippet shell">-- Check for working C compiler: /usr/bin/cc -- works</p>
			<p class="snippet shell">-- Detecting C compiler ABI info</p>
			<p class="snippet shell">-- Detecting C compiler ABI info - done</p>
			<p class="snippet shell">-- Detecting C compile features</p>
			<p class="snippet shell">-- Detecting C compile features - done</p>
			<p class="snippet shell">-- Check for working CXX compiler: /usr/bin/c++</p>
			<p class="snippet shell">-- Check for working CXX compiler: /usr/bin/c++ -- works</p>
			<p class="snippet shell">-- Detecting CXX compiler ABI info</p>
			<p class="snippet shell">-- Detecting CXX compiler ABI info - done</p>
			<p class="snippet shell">-- Detecting CXX compile features</p>
			<p class="snippet shell">-- Detecting CXX compile features - done</p>
			<p class="snippet shell">-- Configuring done</p>
			<p class="snippet shell">-- Generating done</p>
			<p class="snippet shell">-- Build files have been written to: .../extreme_c/ch23/ex23_1/build</p>
			<p class="snippet shell"><strong class="highlight">$</strong></p>
			<p class="packt_figref">Shell Box 23-10: Generating build.ninja based on CMakeLists.txt found in the root directory </p>
			<p class="normal">As you can see, we have passed the option <code class="Code-In-Text--PACKT-">-GNinja</code> to let CMake know that we are demanding Ninja build<a id="_idIndexMarker1737"/> script files instead of Makefiles. CMake generates the <code class="Code-In-Text--PACKT-">build.ninja</code> file and you can find it in the <code class="Code-In-Text--PACKT-">build</code> directory as follows:</p>
			<p class="snippet shell"><strong class="highlight">$ ls</strong></p>
			<p class="snippet shell">CMakeCache.txt  CMakeFiles  <strong class="highlight">build.ninja</strong>  calc  cmake_install.cmake  exec  rules.ninja</p>
			<p class="snippet shell"><strong class="highlight">$</strong></p>
			<p class="packt_figref">Shell Box 23-11: Generated build.ninja in the build directory</p>
			<p class="normal">To compile the project, it is enough to run the <code class="Code-In-Text--PACKT-">ninja</code> command as follows. Note that just as the <code class="Code-In-Text--PACKT-">make</code> program looks for the <code class="Code-In-Text--PACKT-">Makefile</code> in the current directory, the <code class="Code-In-Text--PACKT-">ninja</code> program looks for <code class="Code-In-Text--PACKT-">build.ninja</code> in the current directory:</p>
			<p class="snippet shell"><strong class="highlight">$ ninja</strong></p>
			<p class="snippet shell">[6/6] Linking C executable exec/ex23_1.out</p>
			<p class="snippet shell"><strong class="highlight">$</strong></p>
			<p class="packt_figref">Shell Box 23-1<a id="_idTextAnchor660"/>2: Executing generated build.ninja</p>
			<p class="normal">In the following section, we are going to talk about <em class="italics">Bazel</em>, another build system that can be used for building C and C++ projects.</p>
			<h1 id="_idParaDest-341" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor661"/>Bazel</h1>
			<p class="normal">Bazel is a build system <a id="_idIndexMarker1738"/>developed at Google to address the internal need to have a fast and scalable build system that can build any project no matter what the programming language is. Bazel supports building C, C++, Java, Go, and Objective-C projects. More than that, it can be used to build Android and iOS projects.</p>
			<p class="normal">Bazel became open source around 2015. It is a build system, so it can be compared with Make and Ninja, but not CMake. Almost all of Google's open source projects use Bazel for their builds. For example, we can name <em class="italics">Bazel</em> itself, <em class="italics">gRPC</em>, <em class="italics">Angular</em>, <em class="italics">Kubernetes</em>, and <em class="italics">TensorFlow</em>.</p>
			<p class="normal">Bazel is written in Java. It is famous for parallel and scalable builds, and it really makes a difference in big projects. Parallel builds are also available in Make and Ninja, both by passing the <code class="Code-In-Text--PACKT-">-j</code> option (Ninja is parallel by default, however).</p>
			<div>
				<div id="_idContainer165" class="note">
					<p class="Information-Box--PACKT-"><strong class="screen-text">Note</strong>:</p>
					<p class="Information-Box--PACKT-">The official docume<a href="https://docs.bazel.build/versions/master/bazel-overview.html">ntation <span id="_idIndexMarker1739"/>of Bazel can be found here: <span class="url">https://docs.bazel.buil</span></a><span class="url">d/versions/master/bazel-overview.html</span>.</p>
				</div>
			</div>
			<p class="normal">The way to use Bazel is similar to what we did for Make and Ninja. Bazel requires two kinds of files to be present in a project: <code class="Code-In-Text--PACKT-">WORKSPACE</code> and <code class="Code-In-Text--PACKT-">BUILD</code> files. The <code class="Code-In-Text--PACKT-">WORKSPACE</code> file should be in the root <a id="_idIndexMarker1740"/>directory, and the <code class="Code-In-Text--PACKT-">BUILD</code> files should be put into the modules that should be built as part of the same workspace (or project). This is more or less similar to the case with CMake, where we had three <code class="Code-In-Text--PACKT-">CMakeLists.txt</code> files distributed in the project, but note that, here, Bazel itself is the build system and we are not going to generate any build script for another build system.</p>
			<p class="normal">If we want to add the Bazel support to our project, we should obtain the following hierarchy in the project:</p>
			<p class="snippet shell"><strong class="highlight">$ tree ex23_1</strong></p>
			<p class="snippet shell">ex23_1/</p>
			<p class="snippet shell">├── <strong class="highlight">WORKSPACE</strong></p>
			<p class="snippet shell">├── calc</p>
			<p class="snippet shell">│   ├── <strong class="highlight">BUILD</strong></p>
			<p class="snippet shell">│   ├── add.c</p>
			<p class="snippet shell">│   ├── calc.h</p>
			<p class="snippet shell">│   ├── multiply.c</p>
			<p class="snippet shell">│   └── subtract.c</p>
			<p class="snippet shell">└── exec</p>
			<p class="snippet shell">    ├── <strong class="highlight">BUILD</strong></p>
			<p class="snippet shell">    └── main.c</p>
			<p class="snippet shell">2 directories, 8 files</p>
			<p class="snippet shell"><strong class="highlight">$</strong></p>
			<p class="packt_figref">Shell Box 23-13: The project hierarchy after introducing Bazel files</p>
			<p class="normal">The content of the <code class="Code-In-Text--PACKT-">WORKSPACE</code> file would be empty in our example. It is usually used to indicate the root of the code base. Note that you need to refer to the documentation to see how these files, <code class="Code-In-Text--PACKT-">WORKSPACE</code> and <code class="Code-In-Text--PACKT-">BUILD</code>, should be propagated throughout the code base if you have even more nested and deeper modules.</p>
			<p class="normal">The content of the <code class="Code-In-Text--PACKT-">BUILD</code> file indicates the targets that should be built in that directory (or module). The following code box shows the <code class="Code-In-Text--PACKT-">BUILD</code> file for the <code class="Code-In-Text--PACKT-">calc</code> module:</p>
			<p class="snippet code">c_library(</p>
			<p class="snippet code">  name = "calc",</p>
			<p class="snippet code">  srcs = ["add.c", "subtract.c", "multiply.c"],</p>
			<p class="snippet code">  hdrs = ["calc.h"],</p>
			<p class="snippet code">  linkstatic = True,</p>
			<p class="snippet code">  visibility = ["//exec:__pkg__"]</p>
			<p class="snippet code">)</p>
			<p class="packt_figref">Code Box 23-7 [calc/BUILD]: The BUILD file found in the calc directory</p>
			<p class="normal">As you see, a new target, <code class="Code-In-Text--PACKT-">calc</code>, is declared. It is a static library and contains the three source files found in the <a id="_idIndexMarker1741"/>directory. The library is also visible to the targets residing in the <code class="Code-In-Text--PACKT-">exec</code> directory.</p>
			<p class="normal">Let's look at the <code class="Code-In-Text--PACKT-">BUILD</code> file in the exec directory:</p>
			<p class="snippet code">cc_binary(</p>
			<p class="snippet code">  name = "ex23_1.out",</p>
			<p class="snippet code">  srcs = ["main.c"],</p>
			<p class="snippet code">  deps = [</p>
			<p class="snippet code">    "//calc:calc"</p>
			<p class="snippet code">  ],</p>
			<p class="snippet code">  copts = ["-Icalc"]</p>
			<p class="snippet code">)</p>
			<p class="packt_figref">Code Box 23-8 [exec/BUILD]: The BUILD file found in the exec directory</p>
			<p class="normal">With the preceding files in their places, we can now run Bazel and build the project. You need to go to the project's root directory. Note that there is no need to have a build directory as we did for CMake:</p>
			<p class="snippet shell"><strong class="highlight">$ cd ex23_1</strong></p>
			<p class="snippet shell"><strong class="highlight">$ bazel build //...</strong></p>
			<p class="snippet shell">INFO: Analyzed 2 targets (14 packages loaded, 71 targets configured).</p>
			<p class="snippet shell">INFO: Found 2 targets...</p>
			<p class="snippet shell">INFO: Elapsed time: 1.067s, Critical Path: 0.15s</p>
			<p class="snippet shell">INFO: 6 processes: 6 linux-sandbox.</p>
			<p class="snippet shell">INFO: Build completed successfully, 11 total actions</p>
			<p class="snippet shell"><strong class="highlight">$</strong></p>
			<p class="packt_figref">Shell Box 23-14: Building the example project using Bazel</p>
			<p class="normal">Now, if you look at the <code class="Code-In-Text--PACKT-">bazel-bin</code> directory found in the root directory, you should be able to find the products:</p>
			<p class="snippet shell"><strong class="highlight">$ tree bazel-bin</strong></p>
			<p class="snippet shell">bazel-bin</p>
			<p class="snippet shell">├── calc</p>
			<p class="snippet shell">│   ├── _objs</p>
			<p class="snippet shell">│   │   └── calc</p>
			<p class="snippet shell">│   │       ├── add.pic.d</p>
			<p class="snippet shell">│   │       ├── add.pic.o</p>
			<p class="snippet shell">│   │       ├── multiply.pic.d</p>
			<p class="snippet shell">│   │       ├── multiply.pic.o</p>
			<p class="snippet shell">│   │       ├── subtract.pic.d</p>
			<p class="snippet shell">│   │       └── subtract.pic.o</p>
			<p class="snippet shell">│   ├── <strong class="highlight">libcalc.a</strong></p>
			<p class="snippet shell">│   └── libcalc.a-2.params</p>
			<p class="snippet shell">└── exec</p>
			<p class="snippet shell">    ├── _objs</p>
			<p class="snippet shell">    │   └── ex23_1.out</p>
			<p class="snippet shell">    │       ├── main.pic.d</p>
			<p class="snippet shell">    │       └── main.pic.o</p>
			<p class="snippet shell">    ├── <strong class="highlight">ex23_1.out</strong></p>
			<p class="snippet shell">    ├── ex23_1.out-2.params</p>
			<p class="snippet shell">    ├── ex23_1.out.runfiles</p>
			<p class="snippet shell">    │   ├── MANIFEST</p>
			<p class="snippet shell">    │   └── __main__</p>
			<p class="snippet shell">    │       └── exec</p>
			<p class="snippet shell">    │           └── ex23_1.out -&gt; .../bin/exec/ex23_1.ou<a id="_idTextAnchor662"/>t</p>
			<p class="snippet shell">    └── ex23_1.out.runfiles_manifest</p>
			<p class="snippet shell">9 directories, 15 files</p>
			<p class="snippet shell"><strong class="highlight">$</strong></p>
			<p class="packt_figref">Shell Box 23-15: The content of bazel-bin after running the build</p>
			<p class="normal">As you can see in the <a id="_idIndexMarker1742"/>preceding list, the project is built successfully, and the products have been located.</p>
			<p class="normal">In the next section, we are going to close our discussion in this chapter and compare various build systems that exist for C and C++ projects.</p>
			<h1 id="_idParaDest-342" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor663"/>Comparing build systems</h1>
			<p class="normal">In this chapter, we tried to<a id="_idIndexMarker1743"/> introduce three of the most well-known and widely used build systems. We also introduced CMake as a build script generator. You should know that there are other build systems that can be used to build C and C++ projects. </p>
			<p class="normal">Note that your choice of build system should be considered as a long-term commitment; if you start a project with a specific build system, it would take significant effort to change it to another one.</p>
			<p class="normal">Build systems can be compared based on various properties. Dependency management, being able to handle a complex hierarchy of nested projects, build speed, scalability, integration with existing services, flexibility to add a new logic, and so on can all be used to make a fair comparison. I'm not going to finish this book with a comparison of build systems because it is a tedious job to do, and, more than that, there are already some great online articles covering the topic.</p>
			<p class="normal">A nice Wiki page on <a id="_idIndexMarker1744"/>Bitbucket that does a pros/cons comparison on available build systems, together with build script<a href="https://bitbucket.org/scons/scons/wiki/SconsVsOtherBuildTools"> generator systems can be found here: <span class="url">https://bitbucket.o</span></a><span class="url">rg/scons/scons/wiki/SconsVsOtherBuildTools</span>.</p>
			<p class="normal">Note that the result of a comparison can be different for anyone. You should choose a build system based on <a id="_idIndexMarker1745"/>your project's requirements and the resources available to you. The following links lead to supplementary resources that can<a href="https://www.reddit.com/r/cpp/comments/8zm66h/an_overview_of_build_systems_mostly_for_c_projects/"> be used for further study and comparison:</a></p>
			<p class="normal"><a href="https://www.reddit.com/r/cpp/comments/8zm66h/an_overview_of_build_systems_mostly_for_c_projects/"><span class="url">https://www.reddit.com/r/cpp/comments/8zm66h/an_overv</span></a><span class="url">i</span><a href="https://github.com/LoopPerfect/buckaroo/wiki/Build-Systems-Comparison"><span class="url">ew_of_build_systems_mostly_for_c_projects/</span></a></p>
			<p class="normal"><a href="https://github.com/LoopPerfect/buckaroo/wiki/Build-Systems-Comparison"><span class="url">https://github.com/LoopPer</span></a><span class="url">f</span><a href="https://medium.com/@julienjorge/an-overview-of-build-systems-mostly-for-c-projects-ac9931494444"><span class="url">ect/buckaroo/wiki/Build-Systems-Comparison</span></a></p>
			<p class="normal"><a href="https://medium.com/@julienjorge/an-overview-of-build-systems-mostly-for-c-projects-ac9931494444"><span class="url">https://medium.com/@julienjorge/an-overview-of-build</span></a><span class="url">-<a id="_idTextAnchor664"/><a id="_idTextAnchor665"/><a id="_idTextAnchor666"/><a id="_idTextAnchor667"/><a id="_idTextAnchor668"/><a id="_idTextAnchor669"/><a id="_idTextAnchor670"/>systems-mostly-for-c-projects-ac9931494444</span></p>
			<h1 id="_idParaDest-343" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor671"/>Summary</h1>
			<p class="normal">In this chapter, we discussed the common build tools available for building a C or C++ project. As part of this chapter:</p>
			<ul>
				<li class="list">We discussed the need for a build system.</li>
				<li class="list">We introduced Make, one of the oldest build systems available for C and C++ projects.</li>
				<li class="list">We introduced Autotools and CMake, two famous build script generators.</li>
				<li class="list">We showed how CMake can be used to generate the required Makefiles.</li>
				<li class="list">We discussed Ninja and we showed how CMake can be used to generate Ninja build scripts.</li>
				<li class="list">We demonstrated how Bazel can be used to build a C project.</li>
				<li class="list">Finally, we provided some links to a number of online discussions regarding the comparison of various build systems.</li>
			</ul>
			<h1 id="_idParaDest-344" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor672"/>Epilogue</h1>
			<p class="normal">And the final words ... </p>
			<p class="normal">If you are reading this, it means that our journey has come to an end!  We went through several topics and concepts as part of this book, and I hope that the journey has made you a better C programmer. Of course, it cannot give you the experience; you must obtain that by working on various projects. The methods and tips we discussed in this book will ramp up your level of expertise, and this will enable you to work on more serious projects. Now you know more about software systems, from a broader point of view, and possess a top-notch knowledge about the internal workings. </p>
			<p class="normal">Though this book was heavier and lengthier than your usual read, it still could not cover all the topics found within C, C++, and system programming. Therefore, a weight remains on my shoulders; the journey is not yet done! I would like to continue to work on more Extreme topics, maybe more specific areas, such as Asynchronous I/O, Advanced Data Structures, Socket Programming, Distributed Systems, Kernel Development, and Functional Programming, in time. </p>
			<p class="normal">Hope to see you again on the next journey! </p>
			<p class="normal">Kamran</p>
		</div>
</body></html>