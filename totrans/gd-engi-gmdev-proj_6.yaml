- en: 3D Minigolf
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3D迷你高尔夫
- en: The previous projects in this book have been designed in 2D space. This is intentional,
    in order to introduce the various features and concepts of Godot while keeping
    the projects' scopes limited. In this chapter, you'll venture into the 3D side
    of game development. For some, 3D development feels significantly more difficult
    to manage; for others, it is more straightforward. In either case, there is certainly
    an additional layer of complexity for you to understand.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书中之前的 projekty 都是设计在2D空间中的。这是故意的，为了在保持项目范围有限的同时介绍Godot的各种功能和概念。在本章中，你将进入游戏开发的3D方面。对于一些人来说，3D开发感觉管理起来要困难得多；对于其他人来说，它更直接。无论如何，你确实需要理解一个额外的复杂层。
- en: If you've never worked with any kind of 3D software before, you may find yourself
    encountering many new concepts. This chapter will explain them as much as possible,
    but remember to refer to the Godot documentation whenever you need a more in-depth
    understanding of a particular topic.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以前从未使用过任何类型的3D软件，你可能会发现自己遇到了许多新概念。本章将尽可能多地解释它们，但请记住，当你需要更深入理解特定主题时，要参考Godot文档。
- en: The game you'll make in this chapter is called **Minigolf**. This will consist
    of a small customizable course, a ball, and an interface for aiming and shooting
    the ball towards the hole.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中你要制作的游戏被称为**迷你高尔夫**。它将包括一个小型可定制的球场、一个球和一个瞄准并射击球入洞的界面。
- en: 'This is what you''ll learn in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是本章你要学习的内容：
- en: Navigating Godot's 3D editor
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航Godot的3D编辑器
- en: The Spatial node and its properties
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空间节点及其属性
- en: Importing 3D meshes and using 3D collision shapes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入3D网格和使用3D碰撞形状
- en: How to use 3D cameras, both stationary and moving
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用3D相机，包括静止和移动的
- en: Using GridMap to place the tiles of your golf course
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GridMap放置你的高尔夫球场瓷砖
- en: Setting up lighting and the environment
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置灯光和环境
- en: An introduction to PBR rendering and materials
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PBR渲染和材质的介绍
- en: But first, here's a brief introduction to 3D in Godot.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，这里是对Godot中3D的简要介绍。
- en: Introduction to 3D
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3D 简介
- en: One of the strengths of Godot is its ability to handle both 2D and 3D games.
    While much of what you've learned earlier in this book applies equally well in
    3D (nodes, scenes, signals, and so on), changing from 2D to 3D brings with it
    a whole new layer of complexity and capabilities. First, you'll find that there
    are some additional features available in the 3D editor window, and it's a good
    idea to familiarize yourself with how to navigate in the 3D editor window.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Godot的一个优势是它能够处理2D和3D游戏。虽然你在这本书中早期学到的许多内容在3D中同样适用（节点、场景、信号等），但从2D转换为3D会带来一个全新的复杂性和功能层。首先，你会发现3D编辑器窗口中有一些额外的功能可用，熟悉如何在3D编辑器窗口中导航是个好主意。
- en: Orienting in 3D space
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在3D空间中定位
- en: 'When you click on the 3D button at the top of the editor window, you will see
    the 3D project view:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在编辑器窗口顶部的3D按钮上点击时，你会看到3D项目视图：
- en: '![](img/3cc33fd0-c7e4-46fb-840a-168374ee6f9d.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3cc33fd0-c7e4-46fb-840a-168374ee6f9d.png)'
- en: The first thing you should notice is the three colored lines in the center.
    These are the *x* (red), *y* (green), and *z* (blue) axes. The point where they
    meet is the origin, with coordinates of `(0, 0, 0)`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先应该注意到的中心的三条彩色线条。这些是*x*（红色）、*y*（绿色）和*z*（蓝色）轴。它们相交的点就是原点，其坐标为`(0, 0, 0)`。
- en: Just as you used `Vector2(x, y)` to indicate a position in two-dimensional space,
    `Vector3(x, y, z)` describes a position in three dimensions along these three
    axes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你使用`Vector2(x, y)`来表示二维空间中的位置一样，`Vector3(x, y, z)`描述了沿着这三个轴的三维空间中的位置。
- en: One issue that arises when working in 3D is that different applications use
    different conventions for orientation. Godot uses Y-Up orientation, so when looking
    at the axes, if *x* is pointing to the left/right, then *y* is up/down, and *z*
    is forward/back. You may find when using other popular 3D software that they use
    Z-Up. It's good to be aware of this, as it can lead to confusion when moving between
    different programs.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在3D工作中出现的一个问题是，不同的应用程序使用不同的惯例来表示方向。Godot使用Y-Up方向，所以当你观察轴时，如果*x*指向左/右，那么*y*就是上/下，而*z*是前/后。你可能会发现当使用其他流行的3D软件时，它们使用Z-Up。了解这一点是好的，因为它可以在不同程序之间移动时导致混淆。
- en: 'Another major aspect to be aware of is the unit of measure. In 2D, everything
    is measured in pixels, which makes sense as a natural basis for measurement when
    drawing on the screen. However, when working in 3D space, pixels aren''t really
    useful. Two objects of exactly the same size will occupy different areas on the
    screen depending on how far away they are from the camera (more about cameras
    soon). For this reason, in 3D space all objects in Godot are measured in generic
    units. You''re free to call these units whatever you like: meters, inches, or
    even light years, depending on the scale of your game world.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Godot's 3D editor
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before getting started with 3D, it will be useful to briefly review how to
    navigate in Godot''s 3D space. The camera is controlled with the mouse and keyboard:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'Mousewheel up/down: Zoom in/out'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Middle button + drag: Orbit the camera around the current target'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Shift* + middle button + drag: Pan camera up/down/left/right'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Right-click + drag: Rotate camera in place'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you're familiar with popular 3D games such as *Minecraft*, you can press *Shift*
    + *F* to switch to Freelook mode. In this mode, you can use the WASD keys to *fly*
    around the scene while aiming with the mouse. Press *Shift* + *F* again to exit
    Freelook mode.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also alter the camera''s view by clicking on the [ Perspective ] label
    in the upper-left corner. Here, you can snap the camera to a particular orientation
    such as Top View or Front View:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ed351884-c48f-48ac-aae1-f6ca5873f778.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
- en: This can be especially useful on large displays when combined with the use of
    multiple Viewports. Click the View menu and you can split the screen into multiple
    views of the space, allowing you to see an object from all sides simultaneously.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Note that each of these menu options has a keyboard shortcut associated with
    it. You can click on Editor *|* Editor Settings *|* 3D to adjust the 3D navigation
    and shortcuts to your liking.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7744c74b-511b-4a3b-9d16-532a62701bbc.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
- en: 'When using multiple viewports, each can be set to a different perspective so
    you can see the effect of your actions from multiple directions at the same time:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6f0a2741-d6d6-4fda-9881-de32f4495678.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
- en: Adding 3D objects
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s time to add your first 3D node. Just as all 2D nodes inherit from `Node2D`,
    which provides properties such as `position` and `rotation`, 3D nodes inherit
    from the `Spatial` node. Add one to the scene and you''ll see the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dd3ead8a-ce47-49dd-8f74-b434e0249f12.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
- en: That colorful object you see is not the node, but rather a 3D *gizmo*. Gizmos
    are tools that allow you to move and rotate objects in space. The three rings
    control rotation, while the three arrows move (translate) the object along the
    three axes. Notice that the rings and arrows are color-coded to match the axis
    colors. The arrows move the object *along* the respective axis, while the rings
    rotate the object *around* a particular axis. There are also three small squares
    that lock one axis and allow you to move the object in a single plane.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到的那个五彩斑斓的对象不是节点，而是一个3D *工具*。工具是允许你在空间中移动和旋转对象的工具。三个环控制旋转，而三个箭头沿着三个轴移动（平移）对象。注意，环和箭头是按照轴的颜色进行编码的。箭头沿着相应的轴移动对象，而环则围绕特定的轴旋转对象。还有三个小方块可以锁定一个轴，并允许你在单个平面上移动对象。
- en: Take a few minutes to experiment and get familiar with the gizmo. Use Undo if
    you find yourself getting lost.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 花几分钟时间实验并熟悉工具。如果你发现自己迷路了，请使用撤销。
- en: 'Sometimes, gizmos get in the way. You can click on the mode icons to restrict
    yourself to only one type of transformation: move, rotate, or scale:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，工具会碍事。你可以点击模式图标来限制自己只进行一种变换：移动、旋转或缩放：
- en: '![](img/352310f8-b426-416f-8a3d-fbb189188c0c.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/352310f8-b426-416f-8a3d-fbb189188c0c.png)'
- en: The *Q*, *W*, *E*, and *R* keys are shortcuts for these buttons, allowing for
    quickly changing between modes.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*Q*、*W*、*E*和*R*键是这些按钮的快捷键，允许快速在模式之间切换。'
- en: Global versus Local Space
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局空间与本地空间
- en: 'By default, the gizmo controls operate in global space. Try rotating the object.
    No matter how you turn it, the gizmo''s movement arrows still point along the
    axes. Now try this: put the `Spatial` node back to its original position and orientation
    (or delete it and add a new one). Rotate the object around one axis, then click
    the Local Space Mode (T) button:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，工具控制操作在全局空间中。尝试旋转对象。无论你怎么转，工具的移动箭头仍然沿着轴指向。现在尝试这样做：将`Spatial`节点放回其原始位置和方向（或者删除它并添加一个新的）。围绕一个轴旋转对象，然后点击本地空间模式（T）按钮：
- en: '![](img/f9ccf729-ad6f-4e1b-a7b6-05fb0cfc27af.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f9ccf729-ad6f-4e1b-a7b6-05fb0cfc27af.png)'
- en: Observe what happened to the gizmo arrows. They now point along the *object's*
    local *x*/*y*/*z* axes and not the world's. When you click and drag them, they
    will move the object relative to its axes. Switching back and forth between these
    two modes can make it much easier to place an object exactly where you want it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 观察一下工具箭头的位置。现在它们指向的是*对象*的本地*x*、*y*、*z*轴，而不是世界轴。当你点击并拖动它们时，它们会相对于轴移动对象。在这两种模式之间切换可以使你更容易将对象放置到你想要的位置。
- en: Transforms
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变换
- en: 'Look at the Inspector for your `Spatial` node. Instead of a Position property,
    you now have Translation, as well as Rotation Degrees and Scale. As you move the
    object around, observe how these values change. Note that the Translation represents
    the object''s coordinates relative to the origin:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 查看你的`Spatial`节点的检查器。现在你有了平移、旋转度数以及缩放，而不是位置属性。当你移动对象时，观察这些值是如何变化的。请注意，平移表示对象相对于原点的坐标：
- en: '![](img/b773736e-a608-4ef9-90fb-1c48fcbe993c.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b773736e-a608-4ef9-90fb-1c48fcbe993c.png)'
- en: You'll also notice a Transform property, which also changes as you move and
    rotate the object. When you change translation or rotation, you'll notice that
    the 12 transform quantities will change as well.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会注意到一个*变换*属性，当你移动和旋转对象时，它也会改变。当你改变平移或旋转时，你会注意到12个变换量也会随之改变。
- en: A full explanation of the math behind transforms is beyond the scope of this
    book, but in a nutshell, a transform is a *matrix* that describes an object's
    translation, rotation, and scale all at once. You briefly used the 2D equivalent
    in the Space Rocks game earlier in this book, but the concept is more widely applied
    in 3D.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 变换背后的数学解释超出了本书的范围，但简而言之，变换是一个*矩阵*，它同时描述了一个对象的平移、旋转和缩放。你之前在这本书的“太空岩石”游戏中简要使用过二维等价物，但这个概念在三维中应用得更广泛。
- en: Transforms in code
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码中的变换
- en: 'When positioning a 3D node via code, you have access to its `transform` and
    `global_transform` properties, which are `Transform` objects. A `Transform` has
    two sub-properties: `origin` and `basis`. The `origin` represents the body''s
    offset from its parent''s origin or the global origin, respectively. The `basis`
    property contains three vectors that define a local coordinate system traveling
    with the object. Think of the three axis arrows in the gizmo when you are in Local
    Space mode.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: You'll see more about how to use 3D transforms later in this section.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Meshes
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like `Node2D`, a `Spatial` node has no size or appearance of its own.
    In 2D, you added a Sprite to assign a texture to the node. In 3D, you need to
    add a *mesh*. A mesh is a mathematical description of a shape. It consists of
    a collection of points, called *vertices*. These vertices are connected by lines,
    called *edges,* and multiple edges (at least three) together make a *face*:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7336961e-d3d3-4a62-b20d-63b848ba37ea.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
- en: A cube, for example, is composed of eight vertices, twelve edges, and six faces.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: If you've ever used 3D design software, this will be very familiar to you. If
    you haven't, and you're interested in learning about 3D modeling, Blender is a
    very popular open source tool for designing 3D objects. You can find many tutorials
    and lessons on the internet to help you get started with Blender.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Importing meshes
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whatever modeling software you may use, you will need to export your models
    in a format that is readable by Godot. Wavefront (`.obj`) and Collada (`.dae`)
    are the most popular. Unfortunately, if you're using Blender, its Collada exporter
    has some flaws that make it unusable with Godot. To fix this, Godot's developers
    have created a Blender plugin called **Better Collada Exporter** that you can
    download from [https://godotengine.org/download](https://godotengine.org/download).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: If your objects are in another format, such as FBX, you'll need to use a converter
    tool to save them as OBJ or DAE in order to use them with Godot.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: A new format called GLTF is gaining in popularity and has some significant advantages
    over Collada. Godot already supports it, so feel free to experiment with any models
    you may find in this format.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Primitives
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you don''t have any models handy, or if you just need a simple model quickly,
    Godot has the ability to create certain 3D meshes directly. Add a `MeshInstance`
    node as a child of Spatial, and in the Inspector, click the Mesh property:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: .![](img/952db26a-7939-4067-a644-408dbec5eda0.png)
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: These predefined shapes are called *primitives* and they represent a handy collection
    of common useful shapes. You can use these shapes for a variety of purposes, as
    you'll see later in this chapter. Select New CubeMesh and you'll see a plain cube
    appear on the screen. The cube itself is white, but it may appear bluish on your
    screen due to the default ambient light in the 3D editor window. You'll learn
    how to work with lighting later in this chapter.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Multiple meshes
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, you'll find yourself with an object composed of many different meshes.
    A character might have separate meshes for its head, torso, and limbs. If you
    have a great many of these types of objects, it can lead to performance issues
    as the engine tries to render so many meshes. As a result, `MultiMeshInstance`
    is designed to provide a high-performance method of grouping many meshes together
    into a single object. You probably don't need it yet, because it won't be necessary
    for this project, but keep it in mind as a tool that may come in handy later.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Cameras
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Try running the scene with your cube mesh. Where is it? In 3D, you won''t see
    anything in the game viewport without using a `Camera`. Add one, and use the camera''s
    gizmo to position and point it towards the cube, as in the following screenshot:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9e5a6587-8a37-4f85-8374-184e1e7b1307.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
- en: The pinkish-purple, pyramid-shaped object is called the camera's *fustrum*.
    It represents the camera's view, and can be made narrow or wide to affect the
    camera's *field of view*. The triangular arrow at the top of the fustrum is the
    camera's up direction.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: As you're moving the camera around, you can use the Preview button in the upper-right
    to check your aim. Preview will always show you what the selected camera can see.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'As with the `Camera2D` you used earlier, a `Camera` must be set as Current
    for it to be active. Its other properties affect how it *sees*: field of view,
    projection, and near/far. The default values of these properties are good for
    this project, but go ahead and experiment with them to see how they affect the
    view of the cube. Use Undo to return everything to the default values when you''re
    done.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Project setup
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you've learned how to navigate in Godot's 3D editor, you're ready to
    start on the Minigolf project. As with the other projects, download the game assets
    from the following link and unzip them in your project folder. The unzipped `assets`
    folder contains images, 3D models, and the other assets you need to complete the
    project. You can download a Zip file of the art and sounds (collectively known
    as *assets*) for the game here, [https://github.com/PacktPublishing/Godot-Game-Engine-Projects/releases](https://github.com/PacktPublishing/Godot-Game-Engine-Projects/releases).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'This game will use the left mouse button as an input. The Input Map does not
    have any default actions defined for this, so you need to add one. Open Project
    | Project Settings and go to the Input Map tab. Add a new action called click,
    then click the plus to add a Mouse Button event to it. Choose Left Button:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7dc5e9bd-2341-45ef-80fb-6056ce0cde98.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
- en: Creating the course
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the first scene, add a node called `Main` to serve as your scene's root.
    This scene will contain the major parts of the game, starting with the course
    itself. Start by adding a `GridMap` node to lay out the course.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: GridMaps
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`GridMap` is the 3D equivalent of the `TileMap` node you used in earlier projects.
    It allows you to use a collection of meshes (contained in a `MeshLibrary`) and
    lay them out in a grid to more quickly design an environment. Because it is 3D,
    you can stack the meshes in any direction, although for this project, you''ll
    stick to the same plane.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Making a MeshLibrary
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `res://assets` folder contains a pre-generated `MeshLibrary` for the project,
    containing all the necessary course parts along with collision shapes. However,
    if you need to change it or make your own, you'll find the procedure is very similar
    to how `TileSet` is created in 2D.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: The scene used to create the pre-generated `MeshLibrary` can also be found in
    the `res://assets` folder. Its name is `course_tiles_edit1.tscn`. Feel free to
    open it and look at how it is set up.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Start by making a new scene, with a `Spatial` as its root. To this node, add
    any number of `MeshInstance`. You can find the original course meshes, exported
    from Blender, in the `res://assets/dae` folder.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: The names you give to these nodes will be their names in the `MeshLibrary`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Once you have added the meshes, they need static collision bodies added to them.
    Creating collision shapes that match a given mesh can be complicated, but Godot
    has a method of automatically generating them.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'Select a mesh and you''ll see a `Mesh` menu appear at the top of the editor
    window:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1bd9dccb-57f8-4e68-88b4-b23c7e31e76e.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
- en: 'Select Create Trimesh Static Body and Godot will create a `StaticBody` and
    add a `CollisionShape` using the mesh''s data:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f09ad4f0-97eb-4e95-9d6f-197aa13a457b.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
- en: Do this with each of your mesh objects, and then select Scene | Convert To |
    MeshLibrary to save the resource.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the course
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Drag the `MeshLibrary` (`res://assets/course_tiles.tres` or the one you created)
    into the Theme property of `GridMap` in the Inspector. Also, check that the Cell/Size
    property is set to `(2, 2, 2)`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dd63475f-7f2f-47f9-b81b-7f2ade347670.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
- en: Try drawing by selecting the tile piece from the list on the right and placing
    it by left-clicking in the editor window. You can rotate a piece around the y
    axis by pressing *S*. To remove a tile, use *Shift* + right-click.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: For now, stick to a simple course; you can get fancy later when everything is
    working. Don't forget the hole!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/380ed00a-aa05-40e3-9a2b-3d494debc718.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
- en: Now, it's time to see what this is going to look like when the game is run.
    Add a `Camera` to the scene. Move it up and angle it so it looks down on the course.
    Remember, you can use the Preview button to check what the camera sees.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Run the scene. You'll see that everything seems very dark. By default, there
    is minimal environmental light in the scene. To see more clearly, you need to
    add more light.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: WorldEnvironment
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lighting is a complex subject all on its own. Deciding where to place lights
    and how to set their color and intensity can dramatically affect how a scene looks.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'Godot provides three lighting nodes in 3D:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '`OmniLight`: For light that is emitted in all directions, like from a light
    bulb or candle'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DirectionalLight`: Infinite light from a distant source, such as sunlight'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SpotLight`: Directional light from a single source, such as a flashlight'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to using individual lights, you can also set an *ambient* light
    using `WorldEnvironment`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `WorldEnvironment` node to the scene. In the Inspector, select New Environment
    in the Environment property. Everything will turn black, but don''t worry, you''ll
    fix that soon:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/49ac8ea4-a0d0-4a5c-9aff-4934b98b34f6.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
- en: Click on New Environment and you'll see a large list of properties. The one
    you want is Ambient Light. Set Color to white and you'll see your scene become
    more brightly lit.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that ambient light comes from all directions equally. If your scene
    needs shadows or other light effects, you'll want to use one of the `Light` nodes.
    You'll see how light nodes work later in the chapter.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Finishing the scene
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you have the course laid out, two more items remain: the *tee,* or
    location where the ball will start, and a way to detect when the ball has entered
    the hole.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Add a `Position3D` node named `Tee`. Just like `Position2D`, this node is used
    to mark a location in space. Place this node where you want the ball to start.
    Make sure you put it just above the surface so that the ball doesn't spawn inside
    the ground.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'To detect the ball entering the hole, you can use an `Area` node. This node
    is directly analogous to the 2D version: it can signal when a body enters its
    assigned shape. Add an `Area` and give it a `CollisionShape` child.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'In the child''s Shape property of the `CollisionShape`, add a `SphereShape`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/08d8a699-79b7-4d9d-98be-8e81cd24e3ed.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
- en: 'To size the collision sphere, use the single radius adjustment handle:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b05ff677-f689-4699-b666-7d06a68195cf.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
- en: Place the `Area` just below the hole and size the collision shape so that it
    overlaps the bottom of the hole. Don't let it project above the top of the hole,
    or the ball will count as *in* when it hasn't dropped in yet.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/16daab45-a042-4120-9a8a-45daa6a8394d.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
- en: You may find it easier to position the node if you use the Perspective button
    to view the hole from one direction at at time. When you've finished positioning
    it, change the name of the `Area` to `Hole`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Ball
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, you're ready to make the ball. Since the ball needs physics—gravity, friction,
    collision with walls, and other physics properties—`RigidBody` will be the best
    choice of node. Create a new scene with a `RigidBody` named `Ball`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: RigidBody is the 3D equivalent of the `RigidBody2D` node you used in [Chapter
    3](f24a8958-bb32-413a-97ae-12c9e7001c2c.xhtml), *Escape the Maze*. Its behavior
    and properties are very similar, and you use many of the same methods to interact
    with it, such as `apply_impulse()` and `_integrate_forces()`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'The shape of the ball needs to be a sphere. The basic 3D shapes such as sphere,
    cube, cylinder, and so on are called *primitives*. Godot can automatically make
    primitives using the `MeshInstance` node, so add one as a child of the body. In
    the Inspector, choose New SphereMesh in the Mesh property:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 球的形状需要是一个球体。基本3D形状，如球体、立方体、圆柱体等，被称为*原语*。Godot可以使用`MeshInstance`节点自动创建原语，所以添加一个作为身体的子节点。在检查器中，在网格属性中选择新建球体网格：
- en: '![](img/b343cce5-673b-4fbd-b471-4bc0d6ef65dd.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b343cce5-673b-4fbd-b471-4bc0d6ef65dd.png)'
- en: 'The default size is much too large, so click on the new sphere mesh and set
    its size properties, Radius to `0.15` and Height to `0.3`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 默认大小太大，所以点击新的球体网格，并设置其大小属性，半径为`0.15`，高度为`0.3`：
- en: '![](img/3b43a974-10a4-4565-b5ce-42dd235c396d.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3b43a974-10a4-4565-b5ce-42dd235c396d.png)'
- en: 'Next, add a `CollisionShape` node to the `Ball` and give it a `SphereShape`.
    Size it to fit the mesh using the size handle (orange dot):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将一个`CollisionShape`节点添加到`Ball`上，并给它一个`SphereShape`。使用大小手柄（橙色点）调整大小以适应网格：
- en: '![](img/65232fee-96d9-43af-89b4-695324bd259b.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/65232fee-96d9-43af-89b4-695324bd259b.png)'
- en: Testing the ball
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试球
- en: To test the ball, add it to the `Main` scene with the instance button. Position
    it somewhere above the course and hit Play. You should see the ball fall and land
    on the ground. You may find it helpful to add another `Camera` node positioned
    on the side of the course for a different view. Set the Current property on whichever
    camera you want to use.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试球，使用实例按钮将其添加到`Main`场景中。将其放置在赛道上方，然后播放。你应该看到球落下并落在地面上。你可能发现添加另一个位于赛道一侧的`Camera`节点以获得不同的视角很有帮助。设置你想要使用的相机的当前属性。
- en: You can also temporarily give the ball some motion by setting its Linear/Velocity
    property. Try setting it to different values and playing the scene. Remember that
    the *y* axis is up and that using too large a value may cause the ball to go right
    through the wall. Set it back to `(0, 0, 0)` when you're done.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过设置其线性/速度属性临时给球一些运动。尝试设置不同的值并播放场景。记住，*y*轴是向上的，使用太大的值可能会导致球直接穿过墙壁。完成后将其设置回`(0,
    0, 0)`。
- en: Improving collisions
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进碰撞
- en: You may have noticed when adjusting the velocity that the ball sometimes goes
    straight through the wall and/or bounces oddly, especially if you choose a high
    value. There are a few adjustments you can make to the `RigidBody` properties
    to improve the collision behavior at high speeds.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在调整速度时，球有时会直接穿过墙壁，或者弹跳异常，尤其是如果你选择了一个高值。你可以对`RigidBody`属性进行一些调整，以改善高速下的碰撞行为。
- en: First, turn on **Continuous Collision Detection** (**CCD**). You'll find it
    listed as Continuous Cd in the Inspector. Using CCD alters the way the physics
    engine calculates collisions. Normally, the engine operates by first moving the
    object and then testing for and resolving collisions. This is fast, and works
    in most common situations. When using CCD, however, the engine projects the object's
    movement along its path and attempts to predict where the collision may occur.
    This is slower than the default behavior, and so not as efficient, especially
    when simulating many objects, but it is much more accurate. Since you only have
    one ball in the game, CCD is a good option because it won't introduce any noticeable
    performance penalty, but will greatly improve collision detection.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开**连续碰撞检测**（**CCD**）。你会在检查器中找到它列出的连续Cd。使用CCD会改变物理引擎计算碰撞的方式。通常，引擎通过首先移动对象，然后测试和解决碰撞来运行。这很快，并且在大多数常见情况下都有效。当使用CCD时，引擎会沿着对象的路径预测其移动，并尝试预测碰撞可能发生的位置。这比默认行为慢，因此效率不高，尤其是在模拟许多对象时，但它要准确得多。由于你游戏中只有一个球，所以CCD是一个好选项，因为它不会引入任何明显的性能损失，但会大大提高碰撞检测。
- en: The ball also needs a little more action, so set the Bounce to `0.2` and the Gravity
    Scale to `2`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 球也需要一点额外的动作，所以将弹跳设置为`0.2`，并将重力比例设置为`2`。
- en: Finally, you may also have noticed that the ball takes a long time to come to
    a stop. Set the Linear/Damp property to `0.5` and Angular/Damp to `0.1` so that
    you won't have to wait as long for the ball to stop moving.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可能也注意到球停止需要很长时间。将线性/阻尼属性设置为`0.5`，并将角/阻尼设置为`0.1`，这样你就不必等待球停止移动那么长时间。
- en: UI
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UI
- en: 'Now that the ball is on the course, you need a way to aim and hit the ball.
    There are a number of possible control schemes for a game of this type. For this
    project, you''ll use a two-step process:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'Aim: An arrow will appear swinging back and forth. Clicking the mouse button
    will set the aim direction to the arrow''s.'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Shoot: A power bar will move up and down on the screen. Clicking the mouse
    will set the power and launch the ball.'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Aiming arrow
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Drawing an object in 3D is not as easy as it is in 2D. In many cases, you''ll
    have to switch to a 3D modeling program such as Blender to create your game''s
    objects. However, in this case Godot''s primitives have you covered; to make an
    arrow, you just need two meshes: a long, thin rectangle and a triangular prism.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'Start a new scene by adding a `Spatial` node with a `MeshInstance` child. Add
    a new `CubeMesh`. Click on the Mesh property and set the Size property to `(0.5,
    0.2, 2)`. This is the body of the arrow, but it still has one problem. If you
    rotate the parent, the mesh rotates around its center. Instead, you need the arrow
    to rotate around its end, so change the Transform/Translation of MeshInstance
    to `(0, 0, -1)`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3333f4fc-fafd-4edc-87d9-9b6924fa8e75.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
- en: Try rotating the `Arrow` (root) node with the gizmo to confirm that the shape
    is now offset correctly.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: To create the point of the arrow, add another `MeshInstance`, and this time
    choose New PrismMesh. Set its size to `(1.5, 2, 0.5)`. You now have a flat triangle
    shape. To place it properly at the end of the rectangle, change the mesh's Transform/Translation
    to `(0, 0, -3)` and its Rotation Degrees to `(-90, 0, 0)`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Using primitives is a quick way to create placeholder objects directly in Godot
    without having to open up your 3D modeling software.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, scale the whole arrow down by setting the root node''s Transform/Scale
    to `(0.5, 0.5, 0.5)`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/90f7f3be-d00b-466b-ac39-4368867eac39.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
- en: You now have a completed arrow shape. Save it, then instance it in the `Main`
    scene.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: UI display
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new scene with a CanvasLayer called `UI`. In this scene, you''ll show
    the power bar as well as the shot count for the player''s score. Add a `MarginContainer`,
    `VBoxContainer`, two `Label` properties, and a `TextureProgress`. Name them as
    shown:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d7849604-8fff-4299-b3da-b8bd8a4db401.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
- en: 'Set the Custom Constants of `MarginContainer` all to `20`. Add the `Xolonium-Regular.ttf`
    font to both of the `Label` nodes and set their font sizes to `30`. Set the `Shots` label''s
    Text to Shots: 0 and the `Label` Text to Power. Drag one of the colored bar textures
    from `res://assets` into the Texture/Progress of `PowerBar`. By default, `TextureProgress`
    bars grow from left to right, so for a vertical orientation, change the Fill Mode
    to Bottom to Top.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'The completed UI layout should look like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b862af3c-62fe-4f31-944b-0c2319b10aef.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
- en: Instance this scene in the `Main` scene. Because it's a CanvasLayer, it will
    be drawn on top of the 3D camera view.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Scripts
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本
- en: 'In this section, you''ll create the scripts needed to make everything work
    together. The flow of the game will be as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将创建使一切协同工作的脚本。游戏流程如下：
- en: Place the ball at the start (`Tee`)
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将球放置在起始位置（`Tee`）
- en: 'Angle mode: Aim the ball'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 角度模式：瞄准球
- en: 'Power mode: Set the hit power'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 功率模式：设置击球功率
- en: Launch the ball
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发射球
- en: Repeat from step 2 until the ball is in the hole
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤 2，直到球进入洞中
- en: UI
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UI
- en: 'Add the following script to the `UI` to update the UI elements:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下脚本添加到 `UI` 中以更新 UI 元素：
- en: '[PRE0]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The two functions provide a way to update the UI elements when they need to
    display a new value. As you did in the Space Rocks game, changing the progress
    bar's texture based on its size gives a nice high/medium/low feel to the power
    level.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数提供了一种在需要显示新值时更新 UI 元素的方法。正如你在 Space Rocks 游戏中所做的那样，根据进度条的大小更改其纹理，为功率级别提供了很好的高/中/低感觉。
- en: Main
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Main
- en: 'Next, add a script to `Main` and start with these variables:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，向 `Main` 添加一个脚本，并从以下变量开始：
- en: '[PRE1]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `enum` lists the states the game can be in, while the `power*` and `angle*`
    variables will be used to set their respective values and change them over time.
    Take a look at the following code snippet:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`enum` 列出了游戏可能处于的状态，而 `power*` 和 `angle*` 变量将用于设置它们各自的价值并在时间上改变它们。看看以下代码片段：'
- en: '[PRE2]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'At the beginning, the ball is placed at the location of the `Tee` using both
    bodies'' `transform.origin` properties. Then, the game is put into the `SET_ANGLE`
    state:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始时，使用两个身体的 `transform.origin` 属性将球放置在 `Tee` 的位置。然后，游戏被置于 `SET_ANGLE` 状态：
- en: '[PRE3]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `SET_ANGLE` state places the arrow at the ball's location. Recall that you
    offset the arrow, so it will appear to be pointing out from the ball. When rotating
    the arrow, you rotate it around the *y* axis so that it remains flat (the *y*
    axis points upwards).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`SET_ANGLE` 状态将箭头放置在球的位置。记住，你偏移了箭头，所以它看起来像是从球向外指。当旋转箭头时，你围绕 *y* 轴旋转它，使其保持平坦（*y*
    轴向上指）。'
- en: Also, note that when entering the `SHOOT` state, you call the `shoot()` function
    on the `Ball`. You'll add that function in the next section.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，当进入 `SHOOT` 状态时，你会在 `Ball` 上调用 `shoot()` 函数。你将在下一节中添加该函数。
- en: 'The next step is to check for user input:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是检查用户输入：
- en: '[PRE4]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The only input for the game is clicking the left mouse button. Depending on
    what state you''re in, clicking it will transition to the next state:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的唯一输入是点击左鼠标按钮。根据你处于什么状态，点击它将过渡到下一个状态：
- en: '[PRE5]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In `_process()`, you determine what to animate based on the state. For now,
    it just calls the function that animates the property that''s currently being
    set:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `_process()` 中，你根据状态确定要动画化什么。目前，它只是调用当前正在设置的属性动画的函数：
- en: '[PRE6]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Both of these functions are similar. They gradually change a value between two
    extremes, reversing direction when a limit is hit. Note that the arrow is animating
    over a +/- 90-degree arc.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数都很相似。它们在两个极端之间逐渐改变一个值，当达到限制时反转方向。请注意，箭头在 +/- 90 度的弧上动画。
- en: Ball
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 球
- en: 'In the ball script, there are two functions needed. First, an impulse must
    be applied to the ball to launch it. Second, when the ball stops moving, it needs
    to notify the `Main` scene so that the player can take another shot:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在球脚本中，需要两个函数。首先，必须对球施加冲量以发射它。其次，当球停止移动时，它需要通知 `Main` 场景，以便玩家可以再次击球：
- en: '[PRE7]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you saw in the Space Rocks game, you can use the physics state in `_integrate_forces()`
    to safely stop the ball if the speed has gotten too slow. Remember, due to floating
    point number precision, the velocity may not actually slow to `0` on its own.
    The ball may appear to be stopped, but its velocity may actually be something
    like `0.0000001` instead. Rather than wait for it to reach `0`, you can make the
    ball stop if its speed drops below `0.1`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在 Space Rocks 游戏中所见，你可以在 `_integrate_forces()` 中使用物理状态安全地停止球，如果速度变得太慢。记住，由于浮点数精度，速度可能不会自行减慢到
    `0`。球可能看起来已经停止，但它的速度实际上可能是 `0.0000001`。而不是等待它达到 `0`，你可以使球停止，如果其速度低于 `0.1`。
- en: Hole
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 洞
- en: 'To detect when the ball has dropped into the hole, click on the `Area` in `Main`
    and connect its `body_entered` signal:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要检测球是否掉入洞中，点击 `Main` 中的 `Area` 并连接其 `body_entered` 信号：
- en: '[PRE8]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Changing to the `WIN` state will prevent the ball's `stopped` signal from allowing
    another shot.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到 `WIN` 状态将阻止球的 `stopped` 信号允许另一击。
- en: Testing it out
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: Try running the game. You may want to make sure you have a very easy course
    with a straight shot to the hole for this part. You should see the arrow rotating
    at the ball's position. When you click the mouse button, the arrow stops, and
    the power bar starts moving up and down. When you click a second time, the ball
    is launched.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: If any of those steps don't work, don't go any further, but stop and go back
    to try and find what you missed.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Once everything is working, you'll notice some areas that need improvement.
    First, when the ball stops moving the arrow may not point in the direction you
    want. The reason for this is that the starting angle is always `0`, which points
    along the *z* axis, and then the arrow swings +/- 90 degrees from there. In the
    next sections, you'll have the option of improving the aiming in two ways.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Improving aiming – option 1
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The aim could be improved by making the 180-degree swing of the arrow always
    begin by pointing towards the hole.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a variable called `hole_dir` to the `Main` script. At the start of aiming,
    this will be set to the angle pointing towards the hole using the following function:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Remember that the ball's position is its center, so it's slightly above the
    surface, while the hole's center is somewhat below. Because of this, an arrow
    pointing directly between them would point at a downward angle into the ground.
    To prevent this and keep the arrow level, you can use only the *x* and *z* values
    from the `transform.origin` to produce a `Vector2`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the initial arrow direction is towards the hole, so you can alter the animation
    to add +/-90 degrees to that angle:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Lastly, change the `SET_ANGLE` state to call the function:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Try the game again. The ball should now always point in the general direction
    of the hole. This is better, but you still can't point in any direction you like.
    For that, you can try aiming option 2.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Improving aiming – option 2
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous solution is acceptable, but there is another possibility. Instead
    of the arrow bouncing back and forth, you can aim by moving the mouse side-to-side.
    The benefit of this option is that you're not limited to 180 degrees of motion.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'To accomplish this, you can make use of a particular input event: `InputEventMouseMotion`.
    This event occurs when the mouse moves, and returns with it a `relative` property
    representing how far the mouse moved in the previous frame. You can use this value
    to rotate the arrow by a small amount.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'First, disable the arrow animation by removing the `SET_ANGLE` portion from
    `_process()`. Next, add the following code to `_input()`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This sets the arrow's rotation as you move the mouse left/right on the screen.
    Dividing by `150` ensures that the movement isn't too fast and that you can move
    a full 360 degrees if you move the mouse all the way from one side of the screen
    to the other. Depending on your mouse's sensitivity, you can adjust this to your
    preference.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Camera improvements
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another problem, especially if you have a relatively large course, is that if
    your camera is placed to show the starting area near the tee, it may not show
    the other parts of the course well, or at all. This can make it challenging to
    aim when the ball is in certain places.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you'll learn two different ways to address this problem. One
    involves creating multiple cameras and activating whichever one is closer to the
    ball's position. The other solution is to create an *orbiting* camera that follows
    the ball and that the player can control to view the course from any angle.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Multiple cameras
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add a second `Camera` node and position it near the hole or at the opposite
    end of your course, for example:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c0d98a50-5a24-457c-a9ec-a24693a1a34f.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
- en: 'Add an `Area` child to this second camera. Name it `Camera2Area` and then add
    a `CollisionShape`. You could use a spherical shape just as well, but for this
    example, choose a `BoxShape`. Note that because you''ve rotated the camera, the
    box is rotated as well. You can reverse this by setting the rotation of `CollisionShape`
    to the opposite value, or you can leave it rotated. Either way, adjust the size
    and position of the box to cover the portion of the course you want the camera
    to be responsible for:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3ff1b125-2957-4d17-ac88-f73febd50b34.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
- en: 'Now, connect the area''s `body_entered` signal to the main script. When the
    ball enters the area, the signal will be emitted, and you can change the active
    camera:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Play the game again and hit the ball toward the new camera area. Confirm that
    the camera view changes when the ball enters the area. For a large course, you
    can add as many cameras as you want/need and set them to activate for different
    sections of the course.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: The drawback of this method is that the cameras are still static. Unless you've
    very carefully placed them in the right positions, it still may not be comfortable
    to aim the ball from some locations on the course.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Orbiting camera
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In many 3D games, the player can control a camera that rotates and moves as
    desired. Typically, the control scheme uses a combination of mouse and keyboard.
    The first step will be to add some new input actions:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a34c0387-810d-40db-8426-4dbd57371ac8.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
- en: The WASD keys will be used to orbit the camera by moving it side to side and
    up and down. The mouse wheel will control zooming in/out.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Creating a gimbal
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The camera movement needs to have some restrictions. For one, it should always
    remain level, and not be tilted side to side. Try this: take a camera and rotate
    it a small amount around x (red ring), then a small amount around *z* (blue ring).
    Now, reverse the *x* rotation and click the Preview button. Do you see how the
    camera is now tilted?'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this problem is to place the camera on a *gimbal—*a device designed
    to keep an object level during movement. You can create a gimbal using two `Spatial`
    nodes, which will control the camera's left/right and up/down movement respectively.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: First, make sure to remove any other `Camera` nodes in the scene. If you tried
    the multiple camera setup from the previous section and you'd rather not delete
    them, you can set their Current values to Off and disconnect any `Area` signals
    for them.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new `Spatial` node called `GimbalOut` and place it near the center of
    the course. Make sure not to rotate it. Give it a `Spatial` child called `GimbalIn`,
    and then add a `Camera` to that node. Set the Transform/Translation of Camera
    to `(0, 0, 10)`:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/714f8cff-ee71-4622-91de-a29c0eb92640.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
- en: 'Here''s how the gimbal works: the outer spatial is allowed to rotate *only*
    in *y*, while the inner one rotates *only* in *x*. You can try it yourself, but
    make sure you change to Local Space Mode (see the *Introduction to 3D* section).
    Remember to only move the *green* ring of the outer gimbal node and only the *red*
    ring of the inner one. Don''t change the camera at all. Reset all the rotations
    to `0` once you''ve finished experimenting.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'To control this motion in the game, attach a script to `GimbalOut` and add
    the following:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, the left/right actions rotate `GimbalOut` only on the *y* axis,
    while the up/down actions rotate `GimbalIn` on the *x* axis. The entire gimbal
    system's `scale` property is used to handle zooming. It is also necessary to set
    some limits using `clamp()`. The rotation limit holds up/down movement between
    `-0.2` (almost level with the ground) to `-90` degrees (looking straight down)
    while the zoom limit keeps you from getting too close or too far away.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Run the game and test the camera controls. You should be able to pan in all
    four directions and zoom with your mouse wheel. However, the gimbal's position
    is still static, so you may have trouble seeing the ball properly from certain
    angles.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Tracking camera
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is one final improvement to the camera: making it follow the ball. Now
    that you have a stable, gimbaled camera, it will work great if the gimbal is set
    to follow the ball''s position. Add this line to the `Main` scene''s `_process()`
    function:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that you shouldn't set the gimbal's transform to the ball's transform,
    or it will also *rotate* as the ball rolls!
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Try the game now and observe how the camera tracks the ball's movement while
    still being able to rotate and zoom.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Visual effects
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The appearance of the ball and the other meshes in your scene have been intentionally
    left very plain. You can think of the flat, white ball like a blank canvas, ready
    to be molded and shaped the way you want it. Applying graphics to 3D models can
    be a very complex process, especially if you''re not familiar with it. First,
    a bit of vocabulary:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '**Textures**: Textures are flat, 2D images that are *wrapped* around 3D objects
    to give them more interesting appearances. Imagine wrapping a present: the flat
    paper is folded around the package, conforming to its shape. Textures can be very
    simple or quite complex depending on the shape they are designed to be applied
    to. An example of a simple one would be a small pattern of bricks that can be
    repeated on a large wall object.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**纹理**: 纹理是平面的、2D 图像，被 *包裹* 在 3D 对象周围，以赋予它们更有趣的外观。想象一下包裹一个礼物：平面的纸张折叠在包裹上，适应其形状。纹理可以是非常简单的，也可以非常复杂，这取决于它们设计要应用于的形状。一个简单的例子可能是一小块砖块图案，可以在一个大型的墙面对象上重复。'
- en: '**Shaders**: While textures determine *what* is drawn on an object''s surface,
    shaders determine *how* it is drawn. Imagine that same brick wall. How would it
    look if it were wet? The mesh and the texture would still be the same, but the
    way the light reflects from it would be quite different. This is the function
    of shaders: to alter the appearance of an object without actually changing it. Shaders
    are typically written in a specialized programming language and can use a great
    deal of advanced math, the details of which are beyond the scope of this book.
    For many effects, writing your own shader is unavoidable. However, Godot provides
    an alternative method of creating a shader for your object that allows for a great
    deal of customization without diving into shader code: `ShaderMaterial`.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**着色器**: 当纹理决定了物体表面的 *内容* 时，着色器决定了 *绘制方式*。想象一下同样的砖墙。如果它湿了会是什么样子？网格和纹理仍然是相同的，但光线反射的方式会有很大不同。这就是着色器的功能：在不实际改变对象的情况下改变其外观。着色器通常用一种专门的编程语言编写，并且可以使用大量的高级数学，这些细节超出了本书的范围。对于许多效果，编写自己的着色器是不可避免的。然而，Godot
    提供了一种创建着色器的方法，允许在不深入研究着色器代码的情况下进行大量定制：`ShaderMaterial`。'
- en: '**Materials**: Godot uses a computer graphics model called **Physically Based
    Rendering** (**PBR**). The goal of PBR is to render the surface of objects in
    a way that more accurately models the way light works in the real world. These
    affects are applied to meshes using the `Material` property. Materials are essentially
    containers for textures and shaders. Rather than apply them individually, they
    are contained in the material, which is then added to the object. The material''s
    properties determine how the textures and shader effects are applied. Using Godot''s
    built-in material properties, you can simulate a wide range of realistic (or stylized)
    real-world physical materials, such as stone, cloth, or metal. If the built-in
    properties aren''t enough for your purposes, you can write your own shader code
    to add even more effects.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**材料**: Godot 使用一种名为 **基于物理的渲染**（**PBR**）的计算机图形模型。PBR 的目标是以更准确地模拟现实世界中光线作用的方式渲染物体的表面。这些效果通过
    `Material` 属性应用于网格。材料本质上是对纹理和着色器的容器。而不是单独应用它们，它们被包含在材料中，然后添加到对象上。材料的属性决定了纹理和着色器效果如何应用。使用
    Godot 内置的材料属性，你可以模拟各种真实（或风格化）的现实世界物理材料，如石头、布料或金属。如果内置属性不足以满足你的需求，你可以编写自己的着色器代码以添加更多效果。'
- en: You can add a PBR material to a mesh using a `SpatialMaterial`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `SpatialMaterial` 将 PBR 材料添加到网格中。
- en: SpatialMaterials
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SpatialMaterials
- en: 'Click on the ball''s `MeshInstance` and, under Material, select New SpatialMaterial,
    then click the new material. You will see a great number of parameters, far more
    than can be covered in this book. This section will focus on some of the most
    useful ones for making the ball look more appealing. You are encouraged to visit [http://docs.godotengine.org/en/3.0/tutorials/3d/spatial_material.html](http://docs.godotengine.org/en/3.0/tutorials/3d/spatial_material.html) for
    a full explanation of all the `SpatialMaterial` settings. To improve the look
    of the ball, try experimenting with these parameters:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 点击球体的 `MeshInstance`，然后在材料下选择新建 SpatialMaterial，然后点击新材料。你会看到大量的参数，远超过本书所能涵盖的范围。本节将重点介绍一些制作球体外观更吸引人的最有用参数。鼓励你访问
    [http://docs.godotengine.org/en/3.0/tutorials/3d/spatial_material.html](http://docs.godotengine.org/en/3.0/tutorials/3d/spatial_material.html)
    以获得所有 `SpatialMaterial` 设置的完整解释。为了改善球体的外观，尝试使用这些参数进行实验：
- en: '**Albedo**: This property sets the base color of the material. Change this
    to make the ball whatever color you like. If you''re working with an object that
    needs a texture to be applied, you can add it here as well.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Albedo**: 这个属性设置了材料的基色。更改它以使球体成为你喜欢的任何颜色。如果你正在处理需要应用纹理的对象，你还可以在这里添加它。'
- en: '**Metallic and Roughness**: These parameters control how reflective the surface
    is. Both can be set to values between `0` and `1`. The Metallic value controls
    the *shininess*; higher values will reflect more light. The *Roughness* value
    applies an amount of blur to the reflection. You can simulate a wide variety of
    materials by adjusting these two properties. The following is a guide to how the *Roughness*
    and *Metallic* properties affect the appearance of an object. Keep in mind that
    lighting and other factors will alter the surface appearance as well. Understanding
    how light and reflections interact with surface properties is a big part of learning
    to design effective 3D objects:'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/6e9de086-672a-47b6-ac47-ffefad22074e.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
- en: '**Normal Map**: Normal mapping is a 3D graphics technique for *faking* the
    appearance of bumps and dents in a surface. Modeling these in the mesh itself
    would result in a large increase in the number of polygons, or faces, making up
    the object, leading to reduced performance. Instead, a 2D texture is used that
    maps the pattern of light and shadow that would result from these small surface
    features. The lighting engine then uses that information to alter the lighting
    as if those details were actually there. A properly constructed normal map can
    add a great amount of detail to an otherwise bland-looking object.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The ball is a perfect example of a good use of normal mapping because a real
    golf ball has hundreds of dimples on its surface, but the sphere primitive is
    a smooth surface. Using a regular texture could add spots, but they would look
    flat and painted on. A normal map that would simulate those dimples looks like
    this:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/53e4c234-a06d-422b-9bae-c55ed04bce25.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
- en: It doesn't look like much, but the pattern of red and blue contains information
    telling the engine which direction it should assume the surface is facing at that
    point and therefore which direction light should reflect from it there. Note the
    stretching along the top and the bottom—that's because this image is made to be
    wrapped around a sphere shape.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'Enable the Normal Map property and drag `res://assets/ball_normal_map.png`
    into the *Texture* field. Try this with the *Albedo* color set to white at first,
    so you can best see the effect. Adjust the `Depth` parameter to increase or decrease
    the strength of the effect. A negative value will make the dimples look inset;
    something between `-1.0` and `-1.5` is a good value:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3b01f311-304d-4490-ab96-ff72a6518704.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
- en: Take some time to experiment with these settings and find a combination you
    like. Don't forget to try it in the game as well, as the ambient lighting of the
    `WorldEnvironment` will effect the final result.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Environment options
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you added the WorldEnvironment, the only parameter you changed was the *Ambient
    Light* color. In this section, you''ll learn about some of the other properties
    you can adjust for improved visual appeal:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '**Background**: This parameter lets you specify what the background of the
    world looks like. The default value is Clear Color, which is the plain grey you
    see currently. Change the Mode to Sky and, in the Sky property, choose New Procedural
    Sky. Note that the sky is not just for background appearance—objects will reflect
    and absorb its ambient light. Observe how the ball''s appearance changes as you
    change the `Energy` parameter. This setting can be used to give the impression
    of a day or night sky, or even that of an alien planet.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Screen Space Ambient Occlusion** (**SSAO**): When enabled, this parameter
    works together with any ambient light to produce shadows in corners. You have
    two sources of ambient light now: the *Background* (sky) and the *Ambient Light*
    settings. Enable SSAO and you''ll immediately see an improvement, making the walls
    of the course look much less fake and plastic. Feel free to try adjusting the
    various SSAO properties, but remember, a small change can make a big difference.
    Adjust the properties in small increments, and observe the effects before changing
    them further.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DOF Far Blur**: *Depth of Field* adds a blur effect to objects that are above
    a certain distance from the camera. Try adjusting the Distance property to see
    the effect.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information about advanced usage of environmental effects, see [http://docs.godotengine.org/en/3.0/tutorials/3d/environment_and_post_processing.html](http://docs.godotengine.org/en/3.0/tutorials/3d/environment_and_post_processing.html).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Lighting
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add a `DirectionalLight` to the scene. This type of light simulates an infinite
    number of parallel rays of light, so it''s often used to represent sunlight or
    another very distant source of light that illuminates an entire area equally.
    The location of the node in the scene doesn''t matter, only its direction, so
    you can position it anywhere you like. Aim it using the gizmo so that it strikes
    the course at an angle, then turn Shadow/Enabled to On so that you''ll see shadows
    being cast from the walls and other objects:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dcd72a60-9d4e-4d24-a054-8ea693765621.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
- en: There are a number of properties available to adjust and alter the appearance
    of the shadows, both in the *Shadow* section, which is present for all `Light`
    nodes, and in the *Directional Shadow* section, which is specific to `DirectionalLight`.
    The default values will work for most general cases, but the one property that
    you should probably adjust to improve shadow appearance is *Max Distance*. Lowering
    this value will improve shadow appearance, but only when the camera is closer
    than the given distance. If your camera will mostly be close to objects, you can
    reduce this value. To see the effect, try setting it to just `10` and zooming
    in/out, then do the same with it set to `1000`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Directional light can even be used to simulate the day/night cycle. If you attach
    a script to the light and slowly rotate it around one axis, you'll see the shadows
    change as if the sun is rising and setting.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 转向光甚至可以用来模拟昼夜循环。如果你给灯光附加一个脚本并慢慢绕一个轴旋转它，你会看到阴影变化，就像太阳在升起和落下一样。
- en: Summary
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduced you to the world of 3D graphics. One of Godot's great
    strengths is that the same tools and workflow are used in both 2D and 3D. Everything
    you learned about the process of creating scenes, instancing, and using signals
    works in the same way. For example, an interface you build with control nodes
    for a 2D game can be dropped into a 3D game and will work just the same.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 本章带你进入了3D图形的世界。Godot的一个巨大优势是，在2D和3D中使用了相同的工具和工作流程。你关于创建场景、实例化和使用信号的过程中学到的所有内容都以相同的方式工作。例如，你为2D游戏使用控制节点构建的界面可以放入3D游戏中，并且会以同样的方式工作。
- en: In this chapter, you learned how to navigate in the the 3D editor to view and
    place nodes using gizmos.You learned about meshes and how to quickly make your
    own objects using Godot's primitives. You used GridMap to lay out your minigolf
    course. You learned about using cameras, lighting, and the world environment to
    design how your game will appear on screen. Finally, you got a taste of using
    PBR rendering via Godot's SpatialMaterial resource.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何在3D编辑器中导航，使用工具箱来查看和放置节点。你了解了网格和如何使用Godot的原生形状快速创建自己的对象。你使用了GridMap来布置你的迷你高尔夫球场。你学习了如何使用摄像机、照明和世界环境来设计游戏在屏幕上的显示效果。最后，你体验了通过Godot的SpatialMaterial资源使用PBR渲染。
- en: Congratulations, you've made it to the end! But with these five projects, your
    journey to becoming a game developer has just begun. As you become more proficient
    with Godot's features, you'll be able to make any game you can imagine.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你，你已经走到了终点！但通过这五个项目，你成为游戏开发者的旅程才刚刚开始。随着你对Godot功能的熟练掌握，你将能够制作出任何你能想象到的游戏。
