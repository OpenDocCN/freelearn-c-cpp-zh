<html><head></head><body>
		<div><h1 id="_idParaDest-359"><a id="_idTextAnchor372"/><em class="italic">Chapter 19</em>: Game Programming Design Patterns – Starting the Space Invaders ++ Game</h1>
			<p>Welcome to the final project. As you have come to expect by now, this project will take a significant step forward in terms of learning new C++ techniques. The next four chapters will look at topics such as <strong class="bold">smart pointers</strong>, C++ <strong class="bold">assertions,</strong> using a gamepad controller, debugging using Visual Studio, <strong class="bold">casting</strong> pointers of a base class to become pointers of a specific derived class, debugging, and a first look at <strong class="bold">design patterns</strong>.</p>
			<p>It is my guess that if you are going to make deep, large-scale games in C++, then design patterns are going to be a big part of your learning agenda in the months and years ahead. In order to introduce this vital topic, I have chosen a relatively simple but fun game to serve as an example. In this chapter, we'll find out a bit more about the Space Invaders ++ game, and then we can get on to the topic of design patterns and why we need them.</p>
			<p>In this hefty chapter, we will cover the following topics:</p>
			<ul>
				<li>Find out about Space Invaders ++ and why we chose it for the final project.</li>
				<li>Learn what design patterns are and why they matter to game developers.</li>
				<li>Study the design patterns in the Space Invaders ++ project that will be used over the next four chapters.</li>
				<li>We will get started on the Space Invaders ++ project.</li>
				<li>Code numerous classes to start fleshing out the game.</li>
			</ul>
			<p>Let's talk about the game itself.</p>
			<h1 id="_idParaDest-360"><a id="_idTextAnchor373"/>Space Invaders ++</h1>
			<p>Have a look at the following three screenshots, which visually explain most of what we need to know about Space Invaders ++. Just in case you don't know already, Space Invaders is one of the earliest arcade games and was released in 1978. If you like a bit of history, you can read the Wikipedia Space Invaders game page here: <a href="https://en.wikipedia.org/wiki/Space_Invaders">https://en.wikipedia.org/wiki/Space_Invaders</a>.</p>
			<p>This first screenshot shows the simple starting screen of our game. For the purposes of discussing screens, which we'll do next, we will call this the <strong class="bold">select screen</strong>. The player has two choices to select from: quit or play. However, by the end of this chapter, you will know how to add and switch between as many screens as you like:</p>
			<div><div><img src="img/B14278_19_01.jpg" alt=""/>
				</div>
			</div>
			<p>As you can see, in the preceding screenshot, there is a new feature we have not implemented before: clickable buttons. We will talk more about buttons and their counterparts, such as UI panels and screens, shortly.</p>
			<p>The following screenshot shows the game in action. It is quite simple to play. For the purposes of discussing screens, which we'll do next, we will call the following screenshot the <strong class="bold">play screen</strong>. The invaders move from left to right while shooting bullets at the player. When they reach the edge of the screen, they drop a little lower, speed up, and head back to the left:</p>
			<div><div><img src="img/B14278_19_02.jpg" alt=""/>
				</div>
			</div>
			<p>The player can move left and right as well as up and down, but the vertical movement is restricted to the bottom half of the screen. </p>
			<p class="callout-heading">Important note</p>
			<p class="callout">The original Space Invaders game just allowed horizontal movement.</p>
			<p>The following screenshot shows the options the player is presented with when they have lost three lives. They can choose to play again or quit and go back to the select screen:</p>
			<div><div><img src="img/B14278_19_03.jpg" alt=""/>
				</div>
			</div>
			<p>While Space Invaders ++ does allow us to introduce lots of new C++ topics that I have already mentioned in the introduction to the chapter, as well as some more game-related topics such as using a gamepad controller, it is true that this isn't really a step up in terms of complexity compared to the previous project. So, why choose this as the final project?</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">In this project, there's lots of code. Most of it we have seen before, either in the same context or a different context. It is not possible to explain every single line as a new book would be required to do so. I have very carefully chosen which code to explain in full, which code to just mention, and which code I am guessing you will be able to work out for yourself. I recommend studying all the code in this book and in the download bundle as you progress. I will, however, go into the structure of the code in full detail as that is the real learning objective of this project. Furthermore, all the C++ code is shown in this book, so nothing is missing, although only an overview of the <code>level1.txt</code> file is shown.</p>
			<h2 id="_idParaDest-361"><a id="_idTextAnchor374"/>Why Space Invaders ++?</h2>
			<p>To begin this discussion, please consider my two objectives for this book:</p>
			<ol>
				<li>The first objective of this book is to introduce you to C++ programming using the learning material of video games. I have already admitted on several occasions and several topics that this is just an introduction. C++ and game development are too big to fit into this book alone. </li>
				<li>The second objective of this book is to leave you in a position to continue your study while still using games as the learning material. </li>
			</ol>
			<p>The problem is, as we have seen, each time we build a game with more features than the last, we end up with a more complicated code structure and the code files get longer and longer too. Throughout this book, we have learned new ways to improve the structure of our code and at each stage, we have succeeded, but the increasing complexity of the games always seems to outweigh the code improvements we learn about.</p>
			<p>This project is designed to address this complexity issue and to take back control of our source code. Despite this game being less deep than the previous project, there will be far more classes to deal with.</p>
			<p>This obviously implies quite a complicated structure. It will also mean, however, that once you get to grips with this structure, you will be able to reuse it for much more complicated games without any of the code files going beyond a few hundred lines of code.</p>
			<p>What this project is designed to do is allow you to come up with your own game ideas, even complex ones, and get started on them right away, using the design patterns we'll discuss in the following section.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Note, however, that I am definitely not suggesting the code structure (design patterns) we will learn about here are the ultimate solution to your game development future; in fact, they are far from it. What you will learn are solutions that allow you to get started with your dream project without the complexity stopping you in your tracks. You will still need to study more about design patterns, C++, and game development along the way.</p>
			<p>So, what are design patterns?</p>
			<h1 id="_idParaDest-362"><a id="_idTextAnchor375"/>Design patterns</h1>
			<p>A <strong class="bold">design pattern</strong> is a reusable solution to a coding problem. In fact, most games (including this one) will use multiple design patterns. The key point about design patterns is this: they are already proven to provide a good solution to a common problem. We are not going to invent any design patterns – we are just going to use some that already exist to solve the problem of our ever-expanding code. </p>
			<p>Many design patterns are quite complicated and require further study beyond the level of this book if you want to even begin learning them. What follows is a simplification of a few key game development-related patterns that will help fulfill the second objective of this book. You're urged to continue your study to implement them more comprehensively and alongside even more patterns than will be discussed here.</p>
			<p>Let's look at the design patterns that are used in the Space Invaders ++ project.</p>
			<h2 id="_idParaDest-363"><a id="_idTextAnchor376"/>Screen, InputHandler, UIPanel, and Button</h2>
			<p>This project will abstract some concepts further than any of the other projects. Space Invaders ++ will introduce the concept of a <strong class="bold">screen</strong>. The concept of a screen is most easily understood by giving some examples. A game could have a menu screen, a settings screen, a high score screen, and a game screen. A <strong class="bold">screen</strong> is a logical division of the parts of the game. Every screen has some things in common with all the other screens, yet each screen also needs its own unique features as well. For example, a menu screen might have buttons that enable the player to transition to another screen, as well as a neat graphical image or even a dynamic scene. The high score screen will, of course, have a list of all the high scores and perhaps a button to return to the menu screen. Each screen will have a different layout, different buttons to click, and different responses to different keyboard presses, but they will all need to be drawn at 60 FPS and interact in the same way with the game engine.</p>
			<p>In the previous projects, we crammed this concept of screens into one place. This meant we had sprawling long <code>if</code>, <code>else</code>, and <code>else if</code> blocks of code that handled updating, drawing, and responding to user interaction. Our code was getting quite challenging to handle already. If we are going to build more complicated games, we need to improve on this. The concept of screens means that we can create a class that handles all the stuff that happens for every screen, such as updating, drawing, and user interaction, and then create a derived class for each type of screen, that is, menu, game, high score, and so on, which handles the unique ways that a specific screen needs to update, draw, and respond to the user.</p>
			<p>In Space Invaders ++, we will have a <code>Screen</code> class. We will then inherit from <code>Screen</code> to handle two screens, <code>SelectScreen</code> and <code>GameScreen</code>. Furthermore, we will have a <code>Button</code> class that knows how to display a button, a <code>UIPanel</code> class that knows how to draw text, and <code>Button</code> instances as well as an <code>InputHandler</code> class that knows how to detect keyboard and gamepad interaction. We will then be able to derive from <code>UIPanel</code> and <code>InputHandler</code> to let all the different <code>Screen</code> instances behave exactly as required without coding the basics of a screen, a UI panel, an input handler, or a button more than once. The bigger your game gets and the more screens it has, the bigger the benefit of doing things this way. It also means that the specifics of each screen will not be crammed into long <code>if</code>, <code>else</code>, and <code>else if</code> structures as we have been doing so far.</p>
			<p>This is a bit like how we coded the <code>PlayableCharacter</code> class and derived <code>Thomas</code> and <code>Bob</code> from it. As we will see, however, we go much further with the abstraction this time. Look at the following diagram, which shows a representation of this idea and shows just one screen:</p>
			<div><div><img src="img/B14278_19_04.jpg" alt=""/>
				</div>
			</div>
			<p>In the preceding diagram, we can see that a screen has one or more <code>UIPanel</code> instances that it can display selectively and that <code>UIPanel</code> instances can have zero or more <code>Button</code> instances. Each <code>UIPanel</code> will have a related <code>InputHandler</code> because each <code>UIPanel</code> will have different combinations and layouts of buttons. The buttons are shared via pointers between <code>UIPanel</code> and <code>InputHandler</code> instances.</p>
			<p>If you are wondering which class handles the update stage of the game loop, the answer is the <code>Screen</code> class. However, once you get your head around how this pattern works, it will be simple to add the ability to let <code>UIPanel</code> instances act in the update phase, too. This could be useful if, say, the panel needed to move or maybe show a loading progress bar.</p>
			<p>A screen will decide which <code>UIPanel</code> (and therefore, <code>InputHandler</code>) instances are currently visible and responding. However, only one screen at a time will be visible to the player. We will code a <code>ScreenManager</code> class that will be a fundamental part of the game engine to handle calling the key functions of the appropriate (current) screen. The <code>ScreenManager</code> class will also provide a way for the <code>InputHandler</code> instances to notify us when a change of screen is required, for example, when the player clicks the <strong class="bold">Play</strong> button on the select screen to go to the play screen.</p>
			<p><code>ScreenManager</code> will hold an instance of every screen, remember the current screen the player is on, and call <code>update</code>, <code>draw</code>, and <code>handleInput</code> on the correct screen, as well as switch between screens when required. The following diagram will hopefully help you visualize this concept, which we will also be coding soon:</p>
			<div><div><img src="img/B14278_19_05.jpg" alt=""/>
				</div>
			</div>
			<p>Note that the diagrams and explanation are a simplification of the solution we will be coding, but they give a good overview.</p>
			<p>Should you want to add a high score screen or another <code>UIPanel</code> instance to an existing screen, you will know how to do so by the end of <a href="B14278_22_Final_AG_ePub.xhtml#_idTextAnchor445"><em class="italic">Chapter 22</em></a>,<em class="italic"> Using Game Objects and Building a Game</em>. Of course, it's likely that you will want to get started on your very own game. You will be able to divide up your next game into as many screens with their dedicated layouts and input handling as you need.</p>
			<h2 id="_idParaDest-364"><a id="_idTextAnchor377"/>Entity-Component pattern</h2>
			<p>We will now spend five minutes wallowing in the misery of an apparently unsolvable muddle. Then, we will see how the entity-component pattern comes to the rescue.</p>
			<h3>Why lots of diverse object types are hard to manage</h3>
			<p>In the previous projects, we coded a class for each object. We had classes such as Bat, Ball, Crawler, and Thomas. Then, in the <code>update</code> function, we would update them, and in the <code>draw</code> function, we would draw them. Each object decides how updating and drawing takes place.</p>
			<p>We could just get started and use this same structure for Space Invaders ++. It would work, but we are trying to learn something more manageable so that our games can grow in complexity.</p>
			<p>Another problem with this approach is that we cannot take advantage of inheritance. For example, all the invaders, the bullets, and the player draw themselves in an identical way, but unless we change how we do things, we will end up with three <code>draw</code> functions with nearly identical code. If we make a change to how we call the <code>draw</code> function or the way we handle graphics, we will need to update all three classes.</p>
			<p>There must be a better way.</p>
			<h3>Using a generic GameObject for better code structure</h3>
			<p>If every object, player, alien, and all the bullets were one generic type, then we could pack them away in a <code>vector</code> instance and loop through each of their <code>update</code> functions, followed by each of their <code>draw</code> functions.</p>
			<p>We already know one way of doing this – inheritance. At first glance, inheritance might seem like a perfect solution. We could create an abstract <code>GameObject</code> class and then extend it with the <code>Player</code>, <code>Invader</code>, and <code>Bullet</code> classes.</p>
			<p>The <code>draw</code> function, which is identical in all three classes, could remain in the parent class, and we won't have the problem of all that wasted duplicate code. Great!</p>
			<p>The problem with this approach is how varied – in some respects – the game objects are. Diversity is not a strength; it is just diverse. For example, all the object types move differently. The bullets go up or down, the invaders go left and right and drop down occasionally, and the player's ship responds to inputs.</p>
			<p>How would we put this kind of diversity into the <code>update</code> so that it could control this movement? Maybe we could use something like this:</p>
			<pre>update(){
   switch(objectType){
          case 1:
                // All the player's logic
                break;
          case 2:
                // All the invader's logic here
                Break;
          case 3:
                // All the bullet's logic here
                break;
   }
}</pre>
			<p>The <code>update</code> function alone would be bigger than the whole <code>GameEngine</code> class!</p>
			<p>As you may remember from <a href="B14278_15_Final_AG_ePub.xhtml#_idTextAnchor306"><em class="italic">Chapter 15</em></a>,<em class="italic"> Advanced OOP – Inheritance and Polymorphism</em>, when we inherit from a class, we can also override specific functions. This means we could have a different version of the <code>update</code> function for each object type. Unfortunately, however, there is also a problem with this approach as well.</p>
			<p>The <code>GameEngine</code> engine would have to "know" which type of object it was updating or, at the very least, be able to query the <code>GameObject</code> instance it was updating in order to call the correct version of the <code>update</code> function. What is really needed is for the <code>GameObject</code> to somehow internally choose which version of the update <code>function</code> is required.</p>
			<p>Unfortunately, even the part of the solution which did seem to work falls apart on closer inspection. I said that the code in the <code>draw</code> function was the same for all three of the objects, and therefore the <code>draw</code> function could be part of the parent class and used by all the sub-classes, instead of us having to code three separate <code>draw</code> functions. Well, what happens when we introduce a new object that needs to be drawn differently, such as an animated UFO that flies across the top of the screen? In this scenario, the draw solution falls apart too.</p>
			<p>Now that we have seen the problems that occur when objects are different from each other and yet cry out to be from the same parent class, it is time to look at the solution we will use in the Space Invaders ++ project.</p>
			<p>What we need is a new way of thinking about constructing all our game objects.</p>
			<h2 id="_idParaDest-365"><a id="_idTextAnchor378"/>Prefer composition over inheritance</h2>
			<p>Preferring composition over inheritance refers to the idea of composing objects with other objects. </p>
			<p class="callout-heading">Important note</p>
			<p class="callout">This concept was first suggested in the following publication:</p>
			<p class="callout"><em class="italic">Design Patterns: Elements of Reusable Object-Oriented Software</em></p>
			<p class="callout">by Erich Gamma, Richard Helm, et al.</p>
			<p>What if we could code a class (as opposed to a function) that handled how an object was drawn? Then for all the classes that draw themselves in the same way, we could instantiate one of these special drawing classes within the <code>GameObject</code>, and any objects that need to be drawn differently could have a different drawing object. Then, when a <code>GameObject</code> does something differently, we simply compose it with a different drawing or updating related class to suit it. All the similarities in all our objects can benefit from using the same code, while all the differences can benefit from not only being encapsulated but also abstracted (taken out of) the base class.</p>
			<p>Note that the heading of this section is composition over inheritance, not composition instead of inheritance. Composition doesn't replace inheritance and everything you learned in <a href="B14278_15_Final_AG_ePub.xhtml#_idTextAnchor306"><em class="italic">Chapter 15</em></a>,<em class="italic"> Advanced OOP – Inheritance and Polymorphism</em>, still holds true. However, where possible, compose instead of inheriting.</p>
			<p>The <code>GameObject</code> class is the entity, while the classes it will be composed of that do things such as update its position and draw it to the screen are the components, which is why it's called the Entity-Component pattern.</p>
			<p>Have a look at the following diagram, which represents the Entity-Component pattern in the form we will implement it in this project:</p>
			<div><div><img src="img/B14278_19_06.jpg" alt=""/>
				</div>
			</div>
			<p>In the preceding diagram, we can see that a <code>GameObject</code> instance is composed of multiple <code>Component</code> instances. There will be multiple different classes derived from the <code>Component</code> class, including <code>UpdateComponent</code> and <code>GraphicsComponent</code>. Furthermore, there can be further specific classes derived from them. For example, the <code>BulletUpdateComponent</code> and <code>InvaderUpdateComponent</code> classes will be derived from the <code>UpdateComponent</code> class. These classes will handle how a bullet and an invader (respectively) update themselves each frame of the game. This is great for encapsulation because we don't need the big <code>switch</code> blocks to distinguish between different objects. </p>
			<p>When we use composition over inheritance to create a group of classes that represent behavior/algorithms, as we will here, this is known as the <strong class="bold">Strategy</strong> pattern. You could use everything you have learned here and refer to it as the Strategy pattern. Entity-Component is a lesser known but more specific implementation, and that is why we call it this. The difference is academic, but feel free to turn to Google if you want to explore things further. In <a href="B14278_23_Final_AG_ePub.xhtml#_idTextAnchor457"><em class="italic">Chapter 23</em></a>, <em class="italic">Before You Go…,</em> I will show you some good resources for this kind of detailed research.</p>
			<p>The Entity-Component pattern, along with using composition in preference to inheritance, sounds great at first glance but brings with it some problems of its own. It would mean that our new <code>GameObject</code> class would need to know about all the different types of component and every single type of object in the game. How would it add all the correct components to itself?</p>
			<p>Let's have a look at the solution.</p>
			<h2 id="_idParaDest-366"><a id="_idTextAnchor379"/>Factory pattern</h2>
			<p>It is true that if we are to have this universal <code>GameObject</code> class that can be anything we want it to be, whether that be a bullet, player, invader, or whatever else, then we are going to have to code some logic that "knows" about constructing these super-flexible <code>GameObject</code> instances and composes them with the correct components. But adding all this code into the class itself would make it exceptionally unwieldy and defeat the entire reason for using the Entity-Component pattern in the first place.</p>
			<p>We would need a constructor that did something like this hypothetical <code>GameObject</code> code:</p>
			<pre>class GameObject
{
   UpdateComponent* m_UpdateComponent;
   GraphicsComponent* m_GraphicsComponent;
   // More components
   // The constructor
   GameObject(string type){
      if(type == "invader")
      {
            m_UpdateComp = new InvaderUpdateComponent();   
            m_GraphicsComponent = new StdGraphicsComponent();
      }
      else if(type =="ufo")
       {
              m_UpdateComponent = new 
                   UFOUpdateComponentComponent();
              m_GraphicsComponent = new AnimGraphicsComponent();
       }
      // etc.
      …
   }
};</pre>
			<p>The <code>GameObject</code> class would need to know not just which components go with which <code>GameObject</code> instance, but also which didn't need certain components, such as input-related components for controlling the player. For the Space Invaders ++ project, we could do this and just about survive the complexity, but just about surviving is not the objective; we want to take complete control.</p>
			<p>The <code>GameObject</code> class would also need to understand all this logic. Any benefit or efficiency gained from using composition over inheritance with the Entity-Component pattern would be mainly lost.</p>
			<p>Furthermore, what if we decide we want a new type of invader, perhaps a "Cloaker" alien that teleports near to the player, takes a shot, and then teleports away again? It is fine to code a new <code>GraphicsComponent</code> class, perhaps a <code>CloakingGraphicsComponent</code> that "knows" when it is visible and invisible, along with a new <code>UpdateComponent</code>, perhaps a <code>CloakerUpdateComponent</code> that teleports instead of moving in the conventional manner, but what is not fine is we are going to have to add a whole bunch of new <code>if </code>statements to the <code>GameObject</code> class constructor. </p>
			<p>In fact, the situation is even worse than this. What if we decide that regular invaders can now cloak? Invaders now need not just a different type of <code>GraphicsComponent</code> class. We would have to go back into the <code>GameObject</code> class to edit all of those <code>if</code> statements again. </p>
			<p>In fact, there are even more scenarios that can be imagined, and they all end up with a bigger and bigger <code>GameObject</code> class. The <code>GameObject</code> class-related woes and the perfect partner to the Entity-Component pattern.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">This implementation of the Factory pattern is an easier way to begin to learn about the Factory pattern. Why not do a web search for the Factory pattern once you have completed this project and see how it can be improved?</p>
			<p>The game designer will provide a specification for each and every type of object in the game, and the programmer will provide a factory class that builds <code>GameObject</code> instances from the game designer's specifications. When the game designer comes up with new ideas for entities, then all we need to do is ask for a new specification. Sometimes, that will involve adding a new production line to the factory that uses existing components and, sometimes, it will mean coding new components or perhaps updating existing components. The point is that it won't matter how inventive the game designer is – the <code>GameObject</code> and <code>GameEngine</code> classes remain unchanged.</p>
			<p>In the Factory code, the current object type is checked and the appropriate components (classes) are added to it. The bullet, player, and the invader have the same graphics component, but all have different update components. </p>
			<p>When we use composition, it can be less clear which class is responsible for the memory. Is it the class that creates it, the class that uses it, or some other class? Let's learn some more C++ to help us manage memory a little more simply.</p>
			<h1 id="_idParaDest-367"><a id="_idTextAnchor380"/>C++ smart pointers</h1>
			<p><strong class="bold">Smart pointers</strong> are classes that we can use to get the same functionality as a regular pointer but with an extra feature – the feature being that they take care of their own deletion. In the limited way we have used pointers so far, it has not been a problem for us to delete our own memory, but as your code becomes more complex, and when you are allocating the new memory in one class but using it in another class, it becomes much less clear which class is responsible for deleting the memory when we are done with it. And how can a class or function know whether a different class or function has finished with some allocated memory?</p>
			<p>The solution is smart pointers. There are a few types of smart pointer; we will look at the two of the most commonly used ones here. The key to success with smart pointers is using the correct type.</p>
			<p>The first type we will consider is <strong class="bold">shared pointers</strong>.</p>
			<h2 id="_idParaDest-368"><a id="_idTextAnchor381"/>Shared pointers</h2>
			<p>The way that a shared pointer can safely delete the memory it points to is by keeping a count of the number of different references there are to an area of memory. If you pass a pointer to a function, the count is increased by one. If you pack a pointer into a vector, the count is increased by one. If the function returns, the count is decreased by one. If the vector goes out of scope or has the <code>clear</code> function called on it, the smart pointer will reduce the reference count by one. When the reference count is zero, nothing points to the area of memory anymore and the smart pointer class calls <code>delete</code>. All the smart pointer classes are implemented using regular pointers behind the scenes. We just get the benefit of not having to concern ourselves about where or when to call <code>delete</code>. Let's look at the code for using a shared smart pointer.</p>
			<p>The following code creates a new shared smart pointer called <code>myPointer</code> that will point to an instance of <code>MyClass</code>:</p>
			<pre>shared_ptr&lt;MyClass&gt; myPointer;</pre>
			<p><code>shared_ptr&lt;MyClass&gt;</code> is the type while  <code>myPointer</code> is its name. The following code is how we might initialize <code>myPointer</code>:</p>
			<pre> myPointer = make_shared&lt;MyClass&gt;();</pre>
			<p>The call to <code>make_shared</code> internally calls <code>new</code> to allocate the memory. The parentheses <code>()</code> is the constructor parentheses. If the <code>MyClass</code> class constructor took an <code>int</code> parameter, for example, the preceding code might look like this:</p>
			<pre>myPointer = make_shared&lt;MyClass&gt;(3);</pre>
			<p>The <code>3</code> in the preceding code is an arbitrary example.</p>
			<p>Of course, you can declare and initialize your shared smart pointers in a single line of code if required, as shown in the following code:</p>
			<pre>shared_ptr&lt;MyClass&gt; myPointer = make_shared&lt;MyClass&gt;();</pre>
			<p>It is because <code>myPointer</code> is a <code>shared_ptr</code> that it has an internal reference count that keeps track of how many references point to the area of memory that it created. If we make a copy of the pointer, that reference count is increased.</p>
			<p>Making a copy of the pointer includes passing the pointer to another function, placing it in a <code>vector</code>, <code>map</code>, or other structure, or simply copying it.</p>
			<p>We can use a smart pointer using the same syntax as a regular pointer. It is quite easy to forget sometimes that it isn't a regular pointer. The following code calls the <code>myFunction</code> function on <code>myPointer</code>:</p>
			<pre>myPointer-&gt;myFunction();</pre>
			<p>By using a shared smart pointer, there is some performance and memory <strong class="bold">overhead</strong>. By overhead, I mean that our code runs slower and uses more memory. After all, the smart pointer needs a variable to keep track of the reference count, and it must check the value of the reference count every time a reference goes out of scope. However, this overhead is tiny and only an issue in the most extreme situations since  most of the overhead happens while the smart pointers are being created. Typically, we will create smart pointers outside of the game loop. Calling a function on a smart pointer is as efficient as a regular pointer.</p>
			<p>Sometimes, we know that we will only ever want one reference to a smart pointer and in this situation, <strong class="bold">unique</strong> <strong class="bold">pointers</strong> are the best option.</p>
			<h2 id="_idParaDest-369"><a id="_idTextAnchor382"/>Unique pointers</h2>
			<p>When we know that we only want a single reference to an area of memory, we can use a unique smart pointer. Unique pointers lose much of the overhead that I mentioned shared pointers have. In addition, if you try and make a copy of a unique pointer, the compiler will warn us, and the code will either not compile or it will crash, giving us a clear error. This is a very useful feature that can prevent us from accidentally copying a pointer that was not meant to be copied. You might be wondering if this no copying rule means we can never pass it to a function or even put it in a data structure such as a <code>vector</code>. To find out, let's look at some code for unique smart pointers and explore how they work.</p>
			<p>The following code creates a unique smart pointer called <code>myPointer</code> that points to an instance of <code>MyClass</code>:</p>
			<pre>unique_ptr&lt;MyClass&gt; myPointer = make_unique&lt;MyClass&gt;();</pre>
			<p>Now. let's suppose we want to add a <code>unique_ptr</code> to a <code>vector</code>. The first thing to note is that <code>vector</code> must be of the correct type. The following code declares a <code>vector</code> that holds unique pointers to <code>MyClass</code> instances:</p>
			<pre>vector&lt;unique_ptr&lt;MyClass&gt;&gt; myVector;</pre>
			<p>The <code>vector</code> is called <code>myVector</code> and anything you put into it must be of the unique pointer type to <code>MyClass</code>. But didn't I say that unique pointers can't be copied? When we know that we will only ever want a single refence to an area of memory, we should use <code>unique_ptr</code>. This doesn't mean, however, that the reference can't be moved. Here is an example:</p>
			<pre>// Use move() because otherwise 
// the vector has a COPY which is not allowed
mVector.push_back(move(myPointer));
// mVector.push_back(myPointer); // Won't compile!</pre>
			<p>In the preceding code, we can see that the <code>move</code> function can be used to put a unique smart pointer into a <code>vector</code>. Note that when you use the <code>move</code> function, you are not giving the compiler permission to break the rules and copy a unique pointer – you are moving responsibility from the <code>myPointer</code> variable to the <code>myVector</code> instance. If you attempt to use the <code>myPointer</code> variable after this point, the code will execute and the game will crash, giving you a <strong class="bold">Null pointer access violation error</strong>. The following code will cause a crash:</p>
			<pre>unique_ptr&lt;MyClass&gt; myPointer = make_unique&lt;MyClass&gt;();
vector&lt;unique_ptr&lt;MyClass&gt;&gt; myVector;
// Use move() because otherwise 
// the vector has a COPY which is not allowed
mVector.push_back(move(myPointer));
// mVector.push_back(myPointer); // Won't compile!
<strong class="bold">myPointer-&gt;myFunction();// CRASH!!</strong></pre>
			<p>The exact same rules apply when passing a unique pointer to a function; use the <code>move</code> function to pass responsibility on. We will look at all these scenarios again, as well as some more when we get to the project in a few pages time.</p>
			<h1 id="_idParaDest-370"><a id="_idTextAnchor383"/>Casting smart pointers</h1>
			<p>We will often want to pack the smart pointers of derived classes into data structures or function parameters of the base class such as all the different derived <code>Component</code> classes. This is the essence of polymorphism. Smart pointers can achieve this using casting. But what happens when we later need to access the functionality or data of the derived class?</p>
			<p>A good example of where this will regularly be necessary is when we deal with components inside our game objects. There will be an abstract <code>Component</code> class and derived from that there will be <code>GraphicsComponent</code>, <code>UpdateComponent</code>, and more besides. </p>
			<p>As an example, we will want to call the <code>update</code> function on all the <code>UpdateComponent</code> instances each frame of the game loop. But if all the components are stored as base class <code>Component</code> instances, then it might seem that we can't do this. Casting from the base class to a derived class solves this problem.</p>
			<p>The following code casts <code>myComponent</code>, which is a base class <code>Component</code> instance to an <code>UpdateComponent</code> class instance, which we can then call the <code>update</code> function on:</p>
			<pre>shared_ptr&lt;UpdateComponent&gt; myUpdateComponent =
                static_pointer_cast&lt;UpdateComponent&gt;(MyComponent);</pre>
			<p>Before the equals sign, a new <code>shared_ptr</code> to an <code>UpdateComponent</code> instance is declared. After the equals sign, the <code>static_pointer_cast</code> function specifies the type to cast to in the angle brackets, <code>&lt;UpdateComponent&gt;</code>, and the instance to cast from in parentheses, <code>(MyComponent)</code>.</p>
			<p>We can now use all the functions of the <code>UpdateComponent</code> class, which in our project includes the <code>update</code> function. We would call the <code>update</code> function as follows:</p>
			<pre>myUpdateComponent-&gt;update(fps);</pre>
			<p>There are two ways we can cast a class smart pointer to another class smart pointer. One is by using <code>static_pointer_cast</code>, as we have just seen, and the other is to use <code>dynamic_pointer_cast</code>. The difference is that <code>dynamic_pointer_cast</code> can be used if you are uncertain whether the cast will work. When you use <code>dynamic_pointer_cast</code>, you can then check to see if it worked by testing if the result is a null pointer. You use <code>static_pointer_class</code> when you are certain the result is the type you are casting to. We will use <code>static_pointer_cast</code> throughout the Space Invaders ++ project. </p>
			<p>We will regularly be casting <code>Component</code> instances to different derived types. How we will be sure the type we are casting to is the correct type will become apparent as we progress with the project.</p>
			<h1 id="_idParaDest-371"><a id="_idTextAnchor384"/>C++ assertions</h1>
			<p>In this project, we will be using C++ <strong class="bold">assertions</strong>. As usual, there is more to this topic than we will discuss here, but we can still do some useful things with just an introduction.</p>
			<p>We can use the <code>#define</code> preprocessor statement in a class to define a value for the entire project. We do so with the following code:</p>
			<pre>#define debuggingOnConsole</pre>
			<p>This code would be written at the top of a header file. Now, throughout the project, we can write code like the following:</p>
			<pre>#ifdef debuggingOnConsole
    // C++ code goes here
#endif</pre>
			<p>The <code>#ifdef debuggingOnConsole</code> statement checks whether the <code>#define</code> <code>debuggingOnConsole</code> statement is present. If it is, then any C++ code up to the <code>#endif</code> statement will be included in the game. We can then choose to comment out the <code>#define</code> statement to switch our debugging code on or off. </p>
			<p>Typically, we will include code such as the following in the <code>#ifdef</code> blocks:</p>
			<pre>#ifdef debuggingOnConsole         
        cout &lt;&lt; 
            "Problem x occurred and caused a crash!" 
            &lt;&lt; endl;
#endif</pre>
			<p>The preceding code uses the <code>cout</code> statement to print debugging information to the console window.</p>
			<p>What these assertions amount to is a way to get feedback from the game during development and then with a quick <code>//</code> in front of the <code>#define</code> statement, strip out all the debugging code from the game when we are done.</p>
			<h1 id="_idParaDest-372"><a id="_idTextAnchor385"/>Creating the Space Invaders ++ project</h1>
			<p>You can find the runnable code that represents the project at the end of this chapter in the <code>Space Invaders ++</code> folder. It will take all of chapters 20, 21, and 22 to complete and make the project runnable again. The completed code that is runnable and represents the project at the end of <a href="B14278_22_Final_AG_ePub.xhtml#_idTextAnchor445"><em class="italic">Chapter 22</em></a>, <em class="italic">Using Game Objects and Building a Game</em>, can be found in the <code>Space Invaders ++ 2</code> folder.</p>
			<p>Create a new project in Visual Studio with the same settings that we used in the previous four projects. Call the new project <code>Space Invaders ++</code>.</p>
			<p>Inside the <code>Space Invaders ++</code> folder, copy and paste the <code>fonts</code>, <code>graphics</code>, and <code>sound</code> folders and their contents from the download bundle. The <code>fonts</code>, <code>graphics</code>, and <code>sound</code> folders, as you would expect, contain the font and graphical and audio assets we will use in this game. </p>
			<p>In addition, you will need to download the background file from <a href="https://opengameart.org/content/background-night">https://opengameart.org/content/background-night</a>.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">This image is the work of <a href="https://opengameart.org/users/alekei">https://opengameart.org/users/alekei</a>.</p>
			<p class="callout">You can download this from <a href="https://opengameart.org/content/background-night">https://opengameart.org/content/background-night</a>.</p>
			<p class="callout">You can find the license at <a href="https://creativecommons.org/licenses/by/3.0/">https://creativecommons.org/licenses/by/3.0/</a>.</p>
			<p>Rename the file you just downloaded to <code>background.png</code> and place it in the <code>graphics</code> folder of your project.</p>
			<p>Now, add the <code>world</code> folder, including the <code>level1.txt</code> file. This file contains the layout of all the game objects, and we will discuss it further in <a href="B14278_21_Final_AG_ePub.xhtml#_idTextAnchor432"><em class="italic">Chapter 21</em></a>, <em class="italic">File I/O and the Game Object Factory</em>.</p>
			<h2 id="_idParaDest-373"><a id="_idTextAnchor386"/>Organizing code files with filters</h2>
			<p>Next, we will do something new. As there are more class files in this project than our previous projects, we will be a bit more organized within Visual Studio. We will create a series of <strong class="bold">filters</strong>. These are logical organizers we use to create a structure for our files. This will allow us to view all our header and source files in a more organized way.</p>
			<p>Right-click on the <code>Engine</code>. We will add all the core header files to this filter.</p>
			<p>Right-click on <code>FileIO</code>. We will add all the files that read text to and from <code>level1.txt</code>, as well as some supporting classes.</p>
			<p>Make another new filter in <code>GameObjects</code>. Everything related to all the game objects, including the <code>GameObject</code> class and all the <code>Component</code> class-related header files, will go here.</p>
			<p>Add yet another filter called <code>Screens</code>. Right-click on the <code>Select</code>. Now, create another filter within <code>Game</code>. We will place all the derived versions of <code>Screen</code>, <code>InputHandler</code>, and <code>UIPanel</code> in <strong class="bold">Game</strong> or <strong class="bold">Select</strong> (as appropriate) and all the base classes in <strong class="bold">Screens</strong>.</p>
			<p>Now, repeat all the previous steps of creating filters to create the exact same structure in the <strong class="bold">Source Files</strong> folder. You should now have a Solution Explorer layout that looks as follows:</p>
			<div><div><img src="img/B14278_19_07.jpg" alt=""/>
				</div>
			</div>
			<p>Note t<a id="_idTextAnchor387"/>hat the preceding layout is just for our organizational benefit; it has no effect on the code or the finished game. In fact, if you look in the <code>Space Invaders ++</code> folder using your operating system's file browser, you will see there are no additional folders. As we progress with this project and add new classes, we will add them within specific filters to make them more organized and less cluttered.</p>
			<h2 id="_idParaDest-374"><a id="_idTextAnchor388"/>Adding a DevelopState file</h2>
			<p>In order to output debugging data to the console, we will create the <code>DevelopState</code> class, which does nothing but define <code>debuggingOnConsole</code>. </p>
			<p>Create the <code>DevelopState.h</code> file in the <code>Header Files/Engine</code> filter and add the following code:</p>
			<pre>#pragma once
#define debuggingOnConsole
class DevelopState {};</pre>
			<p>We can comment out <code>#define debuggingOnConsole</code> when the game is working but, when we have unexplained crashes, we can uncomment it. If we then add assertions at parts throughout our code, we can see if these parts are causing the game to crash.</p>
			<h2 id="_idParaDest-375"><a id="_idTextAnchor389"/>Coding SpaceInvaders ++.cpp</h2>
			<p>Next, drag and drop the <code>SpaceInvaders ++.cpp</code> file that was autogenerated when we created the project into the <code>Source Files/Engine</code> filter. This isn't required – it is just to keep things organized. This file is the entry point to the game and is therefore a core file, albeit a very short one.</p>
			<p>Edit <code>SpaceInvaders ++.cpp</code> so that it just has the following code:</p>
			<pre>#include "GameEngine.h"
int main()
{
    GameEngine m_GameEngine;
    m_GameEngine.run();
    return 0;
}</pre>
			<p>The preceding code creates an instance of <code>GameEngine</code> and calls its <code>run</code> function. There will be errors until we code the <code>GameEngine</code> class. We will do that next. Note that, throughout this project, there will usually be one, more, or even many errors. This is due to the interdependent nature of the classes. I will usually mention when there are errors and when they will be dealt with, but perhaps not every single one. By the end of this chapter, we will have an error-free, executable project, but, after that, it will take until <a href="B14278_22_Final_AG_ePub.xhtml#_idTextAnchor445"><em class="italic">Chapter 22</em></a>, <em class="italic">Using Game Objects and Building a Game</em>, until the project is error-free and executable again.</p>
			<h2 id="_idParaDest-376"><a id="_idTextAnchor390"/>Coding the GameEngine class</h2>
			<p>Create a new header file in the <code>Header Files/Engine</code> filter called <code>GameEngine.h</code> and add the following code:</p>
			<pre>#pragma once
#include &lt;SFML/Graphics.hpp&gt;
#include "ScreenManager.h"
#include "SoundEngine.h"
using namespace sf;
class GameEngine {
private:
    Clock m_Clock;
    Time m_DT;
    RenderWindow m_Window;
    unique_ptr&lt;ScreenManager&gt; m_ScreenManager;
    float m_FPS = 0;
    Vector2f m_Resolution;
    void handleInput();
    void update();
    void draw();
public:
    SoundEngine m_SoundEngine;
    GameEngine();
    void run();
};</pre>
			<p>Study the preceding code to get familiar with it. What's new is that we get to see smart pointers in action for the first time. We have a unique pointer of the <code>ScreenManager</code> Type. This implies that this pointer will not be passed to any other classes but, if it is, then ownership will also be passed.</p>
			<p>Other than the smart pointers, there is nothing we haven't seen before. There is a <code>Clock</code> instance, a <code>Time</code> instance, a <code>RenderWindow</code> instance, as well as variables to keep track of the frame rate and the screen resolution. Furthermore, we have functions for handling input, updating, and drawing each frame. This is also nothing new. What we do within these functions, however, will be new. We also have a <code>SoundEngine</code> instance, which will be nearly identical to how we handled sound in our other projects. We also have the <code>run</code> function, which is public, and will kickstart all the private functions.</p>
			<p>There are errors because we need to implement the <code>ScreenManager</code> and <code>SoundEngine</code> classes. We will get to them very soon.</p>
			<p>Create a new source file in the <code>Source Files/Engine</code> filter called <code>GameEngine.cpp</code> and add the following code:</p>
			<pre>#include "GameEngine.h"
GameEngine::GameEngine()
{
    m_Resolution.x = VideoMode::getDesktopMode().width;
    m_Resolution.y = VideoMode::getDesktopMode().height;
    m_Window.create(VideoMode(m_Resolution.x, m_Resolution.y),
        "Space Invaders++", Style::Fullscreen);
    m_ScreenManager = unique_ptr&lt;ScreenManager&gt;(new ScreenManager(
        Vector2i(m_Resolution.x, m_Resolution.y)));
}
void GameEngine::run()
{
    while (m_Window.isOpen())
    {
        m_DT = m_Clock.restart();
        m_FPS = m_DT.asSeconds();
        handleInput();
        update();
        draw();
    }
}
void GameEngine::handleInput()
{
    m_ScreenManager-&gt;handleInput(m_Window);
}
void GameEngine::update()
{
    m_ScreenManager-&gt;update(m_FPS);
}
void GameEngine::draw()
{
    m_Window.clear(Color::Black);
    m_ScreenManager-&gt;draw(m_Window);
    m_Window.display();
}</pre>
			<p>In the <code>GameEngine</code> constructor, the <code>RenderWindow</code> instance is initialized and the unique smart pointer to a <code>ScreenManager</code> instance is initialized using <code>new</code>, which passes in the resolution to the <code>ScreenManager</code> constructor.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">This is an alternative to calling the <code>make_unique</code> function.</p>
			<p>The <code>run</code> function should look very familiar; it restarts the clock and stores the time like we have done in every project so far. It then calls the <code>handleInput</code>, <code>update</code>, and <code>draw</code> functions.</p>
			<p>In the <code>handleInput</code> function, the <code>handleInput</code> function of the <code>ScreenManager</code> instance is called. In the <code>update</code> function, the <code>update</code> function of the <code>ScreenManger</code> instance is called. Finally, in the <code>draw</code> function, the <code>RenderWindow</code> is cleared, the <code>draw</code> function of the <code>ScreenManager</code> instance is called, and the contents of the <code>RenderWindow</code> instance are displayed.</p>
			<p>We have successfully passed full responsibility to the <code>ScreenManager</code> class for handling input, updating, and drawing each frame. As we will see in the <em class="italic">Coding the ScreenManager</em> section, the <code>ScreenManager</code> class will further delegate responsibility for all these tasks to the appropriate class that's derived from the <code>Screen</code> class.</p>
			<p>Like the related <code>GameEngine.h</code> header file, there are errors because we need to implement the <code>ScreenManager</code> and <code>SoundEngine</code> classes.</p>
			<h2 id="_idParaDest-377"><a id="_idTextAnchor391"/>Coding the SoundEngine class</h2>
			<p>Create a new header file in the <code>Header Files/Engine</code> filter called <code>SoundEngine.h</code> and add the following code:</p>
			<pre>#pragma once
#ifndef SOUND_ENGINE_H
#define SOUND_ENGINE_H
#include &lt;SFML/Audio.hpp&gt;
using namespace sf;
class SoundEngine
{
private:
    SoundBuffer m_ShootBuffer;
    SoundBuffer m_PlayerExplodeBuffer;
    SoundBuffer m_InvaderExplodeBuffer;
    SoundBuffer m_ClickBuffer;
    Sound m_ShootSound;
    Sound m_PlayerExplodeSound;
    Sound m_InvaderExplodeSound;
    Sound m_UhSound;
    Sound m_OhSound;
    Sound m_ClickSound;
public:
    SoundEngine();
    static void playShoot();
    static void playPlayerExplode();
    static void playInvaderExplode();
    static void playClick();
    static SoundEngine* m_s_Instance;
};
#endif</pre>
			<p>Create a new source file in the <code>Source Files/Engine</code> filter called <code>SoundEngine.cpp</code> and add the following code:</p>
			<pre>#include &lt;SFML/Audio.hpp&gt;
#include &lt;assert.h&gt;
#include "SoundEngine.h"
using namespace std;
using namespace sf;
SoundEngine* SoundEngine::m_s_Instance = nullptr;
SoundEngine::SoundEngine()
{
    assert(m_s_Instance == nullptr);
    m_s_Instance = this;
    // Load the sound into the buffers
    m_ShootBuffer.loadFromFile("sound/shoot.ogg");
    m_PlayerExplodeBuffer.loadFromFile("sound/playerexplode.ogg");
    m_InvaderExplodeBuffer.loadFromFile("sound/invaderexplode.ogg");
    m_ClickBuffer.loadFromFile("sound/click.ogg");
    // Associate the sounds with the buffers
    m_ShootSound.setBuffer(m_ShootBuffer);
    m_PlayerExplodeSound.setBuffer(m_PlayerExplodeBuffer);
    m_InvaderExplodeSound.setBuffer(m_InvaderExplodeBuffer);
    m_ClickSound.setBuffer(m_ClickBuffer);
}
void SoundEngine::playShoot()
{
    m_s_Instance-&gt;m_ShootSound.play();
}
void SoundEngine::playPlayerExplode()
{
    m_s_Instance-&gt;m_PlayerExplodeSound.play();
}
void SoundEngine::playInvaderExplode()
{
    m_s_Instance-&gt;m_InvaderExplodeSound.play();
}
void SoundEngine::playClick()
{
    m_s_Instance-&gt;m_ClickSound.play();
}</pre>
			<p>The <code>SoundEngine</code> class uses the exact same strategy as the previous <code>SoundManager</code> class from the previous projects. In fact, <code>SoundEngine</code> is slightly simpler than <code>SoundManager</code> because we are not using spatialization features. For a refresher of how the <code>SoundEngine</code> class works, refer to <a href="B14278_17_Final_AG_ePub.xhtml#_idTextAnchor340"><em class="italic">Chapter 17</em></a>, <em class="italic">Sound Spatialization and the HUD</em>.</p>
			<p>Now, we can move on to the <code>ScreenManager</code> class.</p>
			<h2 id="_idParaDest-378"><a id="_idTextAnchor392"/>Coding the ScreenManager class</h2>
			<p>Create a new header file in the <code>Header Files/Engine</code> filter called <code>ScreenManager.h</code> and add the following code:</p>
			<pre>#pragma once
#include &lt;SFML/Graphics.hpp&gt;
#include &lt;map&gt;
#include "GameScreen.h"
#include "ScreenManagerRemoteControl.h"
#include "SelectScreen.h"
//#include "LevelManager.h"
#include "BitmapStore.h"
#include &lt;iostream&gt;
using namespace sf;
using namespace std;
class ScreenManager : public ScreenManagerRemoteControl {
private:
    map &lt;string, unique_ptr&lt;Screen&gt;&gt; m_Screens;
    //LevelManager m_LevelManager;
protected:
    string m_CurrentScreen = "Select";
public:
    BitmapStore m_BS;
    ScreenManager(Vector2i res);
    void update(float fps);
    void draw(RenderWindow&amp; window);
    void handleInput(RenderWindow&amp; window);
    /****************************************************
    *****************************************************
    From ScreenManagerRemoteControl interface
    *****************************************************
    *****************************************************/
    void ScreenManagerRemoteControl::
        SwitchScreens(string screenToSwitchTo)
    {
        m_CurrentScreen = "" + screenToSwitchTo;
        m_Screens[m_CurrentScreen]-&gt;initialise();
    }
    void ScreenManagerRemoteControl::
        loadLevelInPlayMode(string screenToLoad)
    {
        //m_LevelManager.getGameObjects().clear();
        //m_LevelManager.
            //loadGameObjectsForPlayMode(screenToLoad);
        SwitchScreens("Game");
    }
    //vector&lt;GameObject&gt;&amp; 
        //ScreenManagerRemoteControl::getGameObjects()
    //{
        //return m_LevelManager.getGameObjects();
    //}
    //GameObjectSharer&amp; shareGameObjectSharer()
    //{
        //return m_LevelManager;
    //}
};</pre>
			<p>In the previous code, there are some <code>#include</code> statements and some functions that have been commented out. This is because we will not be coding the <code>LevelManager</code> class until <a href="B14278_21_Final_AG_ePub.xhtml#_idTextAnchor432"><em class="italic">Chapter 21</em></a>, <em class="italic">File I/O and the Game Object Factory</em>.</p>
			<p>The next thing to notice is that <code>ScreenManager</code> inherits from <code>ScreenManagerRemoteControl</code>. More on this class shortly.</p>
			<p>We have coded a <code>map</code> with a key-value pair of <code>string</code> and a unique pointer to <code>Screen</code>. This will allow us to grab the functionality of a specific <code>Screen</code> instance by using the corresponding <code>string</code>. Next, we declare the <code>string</code> called <code>m_CurrentScreen</code> and initialize it to <code>Select</code>.</p>
			<p>Next, we declare an instance of <code>BitmapStore</code> called <code>m_BS</code>. This will be a slightly reworked version of the <code>TextureHolder</code> class that we saw in the two preceding projects. We will code the <code>BitmapStore</code> class next.</p>
			<p>Notice that the constructor for <code>ScreenManager</code> takes a <code>Vector2i</code> instance, which is what we should expect from when we initialized a <code>ScreenManager</code> instance in the <code>GameEngine</code> class.</p>
			<p>What follows is the <code>update</code>, <code>draw</code>, and <code>handleInput</code> function prototypes, which are called from the <code>GameEngine</code> class.</p>
			<p>The next two functions are the most interesting. Note that they are from the <code>ScreenManagerRemoteControl</code> class, which <code>ScreenManager</code> inherits from. These are pure virtual functions in <code>ScreenManagerRemoteControl</code> and we do things this way so that we can share some of the functionality of the <code>ScreenManager</code> class with other classes. We will code the <code>ScreenManagerRemoteControl</code> class in a couple of sections time. Remember that, when you inherit from a class that has pure virtual functions, you must implement the functions if you want to create an instance. Furthermore, the implementations should be contained in the same file as where the class is declared. There are four functions, two of which have been commented out for now. The two functions of immediate interest are <code>SwitchScreens</code> and <code>loadLevelInPlayMode</code>. </p>
			<p>The <code>SwitchScreen</code> function changes the value of <code>m_CurrentScreen</code>, while the <code>loadLevelInPlayMode</code> function has some temporarily commented out code and a single line of active code which calls <code>SwitchScreens</code> with the value of <code>Game</code>.</p>
			<p>Let's move on to the <code>ScreenManager.cpp</code> file so that we can look at all the function definitions.</p>
			<p>Create a new source file in the <code>Source Files/Engine</code> filter called <code>ScreenManager.cpp</code> and add the following code:</p>
			<pre>#include "ScreenManager.h"
ScreenManager::ScreenManager(Vector2i res)
{
    m_Screens["Game"] = unique_ptr&lt;GameScreen&gt;(
        new GameScreen(this, res));
    m_Screens["Select"] = unique_ptr&lt;SelectScreen&gt;(
        new SelectScreen(this, res));
}
void ScreenManager::handleInput(RenderWindow&amp; window)
{
    m_Screens[m_CurrentScreen]-&gt;handleInput(window);
}
void ScreenManager::update(float fps)
{
    m_Screens[m_CurrentScreen]-&gt;update(fps);
}
void ScreenManager::draw(RenderWindow&amp; window)
{
    m_Screens[m_CurrentScreen]-&gt;draw(window);
}</pre>
			<p>In the preceding code, the constructor adds two <code>Screen</code> instances to the <code>map</code> instance – first, a <code>GameScreen</code> instance with a key of <code>"Game"</code> and then a <code>SelectScreen</code> instance with a key of <code>"Select"</code>. The three functions, <code>handleInput</code>, <code>update</code>, and <code>draw</code>, use whatever the current screen is, use the corresponding <code>Screen</code> instance, and call its <code>handleInput</code>, <code>update</code>, and <code>draw</code> functions.</p>
			<p>When the game is executed for the first time, the versions of these functions from <code>SelectScreen</code> will be called, but if the <code>ChangeScreen</code> or <code>loadLevelInPlayMode</code> function was called, then then <code>handleInput</code>, <code>update</code>, and <code>draw</code> could be called on the <code>GameScreen</code> instance from the <code>map</code>. You can add as many different types of <code>Screen</code> instance to the map as you like. I recommend that you complete the Space Invaders ++ project before you start doing your own customizations or start your own game, however.</p>
			<h2 id="_idParaDest-379"><a id="_idTextAnchor393"/>Coding the BitmapStore class</h2>
			<p>Create a new header file in the <code>Header Files/Engine</code> filter called <code>BitmapStore.h</code> and add the following code:</p>
			<pre>#pragma once
#ifndef BITMAP_STORE_H
#define BITMAP_STORE_H
#include &lt;SFML/Graphics.hpp&gt;
#include &lt;map&gt;
class BitmapStore
{
private:
    std::map&lt;std::string, sf::Texture&gt; m_BitmapsMap;
    static BitmapStore* m_s_Instance;
public:
    BitmapStore();
    static sf::Texture&amp; getBitmap(std::string const&amp; filename);
    static void addBitmap(std::string const&amp; filename);
};
#endif</pre>
			<p>Create a new source file in the <code>Source Files/Engine</code> filter called <code>BitmapStore.cpp</code> and add the following code:</p>
			<pre>#include "BitmapStore.h"
#include &lt;assert.h&gt;
using namespace sf;
using namespace std;
BitmapStore* BitmapStore::m_s_Instance = nullptr;
BitmapStore::BitmapStore()
{
    assert(m_s_Instance == nullptr);
    m_s_Instance = this;
}
void BitmapStore::addBitmap(std::string const&amp; filename)
{
    // Get a reference to m_Textures using m_S_Instance
    auto&amp; bitmapsMap = m_s_Instance-&gt;m_BitmapsMap;
    // auto is the equivalent of map&lt;string, Texture&gt;
    // Create an iterator to hold a key-value-pair (kvp)
    // and search for the required kvp
    // using the passed in file name
    auto keyValuePair = bitmapsMap.find(filename);
    // auto is equivalent of map&lt;string, Texture&gt;::iterator
    // No match found so save the texture in the map
    if (keyValuePair == bitmapsMap.end())
    {
        // Create a new key value pair using the filename
        auto&amp; texture = bitmapsMap[filename];
        // Load the texture from file in the usual way
        texture.loadFromFile(filename);
    }
}
sf::Texture&amp; BitmapStore::getBitmap(std::string const&amp; filename)
{
    // Get a reference to m_Textures using m_S_Instance
    auto&amp; m = m_s_Instance-&gt;m_BitmapsMap;
    // auto is the equivalent of map&lt;string, Texture&gt;
    // Create an iterator to hold a key-value-pair (kvp)
    // and search for the required kvp
    // using the passed in file name
    auto keyValuePair = m.find(filename);
    // auto is equivalent of map&lt;string, Texture&gt;::iterator    
    // Did we find a match?
    if (keyValuePair != m.end())
    {
        return keyValuePair-&gt;second;
    }
    else
    {
#ifdef debuggingOnConsole         
        cout &lt;&lt; 
            "BitmapStore::getBitmap()Texture not found Crrrashh!" 
            &lt;&lt; endl;
#endif
        return keyValuePair-&gt;second;
    }
}</pre>
			<p>The preceding code is almost a copy and paste from the <code>BitmapStore</code> class from the previous two projects, except for the final <code>else</code> block. Inside the final <code>else</code> block, we use C++ assertions for the first time to output the name of the requested texture to the console in the event that the texture isn't found. This only happens when <code>debuggingOnConsole</code> is defined. Note that this would also crash the game.</p>
			<h2 id="_idParaDest-380"><a id="_idTextAnchor394"/>Coding the ScreenManagerRemoteControl class</h2>
			<p>Create a new header file in the <code>Header Files/Screens</code> filter called <code>ScreenManagerRemoteControl.h</code> and add the following code:</p>
			<pre>#pragma once
#include &lt;string&gt;
#include &lt;vector&gt;
//#include "GameObject.h"
//#include "GameObjectSharer.h"
using namespace std;
class ScreenManagerRemoteControl
{
public:
    virtual void SwitchScreens(string screenToSwitchTo) = 0;
    virtual void loadLevelInPlayMode(string screenToLoad) = 0;
    //virtual vector&lt;GameObject&gt;&amp; getGameObjects() = 0;
    //virtual GameObjectSharer&amp; shareGameObjectSharer() = 0;
};</pre>
			<p>Note in the previous code, that there are some <code>#include</code> statements and some functions that have been commented out. This is because we will not be coding the <code>GameObject</code> and <code>GameObjectSharer</code> classes until the next chapter.</p>
			<p>The rest of the code is for the prototypes that match the definitions we saw previously in the <code>ScreenManager.h</code> file. As you have come to expect, all the functions are pure virtual and therefore must be implemented by any class we wish to have an instance of.</p>
			<p>Create a new source file in the <code>Source Files/Screens</code> filter called <code>ScreenManagerRemoteControl.cpp</code> and add the following code:</p>
			<pre>/*********************************
******THIS IS AN INTERFACE********
*********************************/</pre>
			<p>This code file is empty because all the code is in the <code>.h</code> file. In fact, you don't need to create this file, but I always find it a handy reminder in case I forget that all the functions for the class are pure virtual and waste time looking for the <code>.cpp</code> file, which doesn't exist.</p>
			<h1 id="_idParaDest-381"><a id="_idTextAnchor395"/>Where are we now?</h1>
			<p>At this stage, the only remaining errors in the code are the errors that refer to the <code>SelectScreen</code> class and the <code>GameScreen</code> class. It is going to take quite a bit of work to get rid of these errors and have a runnable program. The reason for this is that <code>SelectScreen</code> and <code>GameScreen</code> are derived from <code>Screen</code> and, in turn, the <code>Screen</code> class is also dependent on <code>InputHandler</code>, <code>UIPanel</code>, and <code>Button</code>. We will get to them next.</p>
			<h1 id="_idParaDest-382"><a id="_idTextAnchor396"/>Coding the Screen class and its dependents</h1>
			<p>What we will do now is code all the screen-related classes. In addition, each of the screens from our game will have their own specific implementation of all these classes. </p>
			<p>Next, we will code all the base classes; <code>Screen</code>, <code>InputHandler</code>, <code>UIPanel</code>, and <code>Button</code>. Following that, we will do the full implementation of the <code>SelectScreen</code> derivations of these classes and a partial implementation of the <code>GameScreen</code> derivations. At this point, we will be able to run the game and see our screens, UI panels, and buttons in action, and also be able to switch between screens. In the next chapter, we will work on the game properly and implement <code>GameObject</code> and <code>LevelManager</code>. In <a href="B14278_22_Final_AG_ePub.xhtml#_idTextAnchor445"><em class="italic">Chapter 22</em></a>, <em class="italic">Using Game Objects and Building a Game, </em>we will see how we can use them all in the <code>GameScreen</code> class.</p>
			<h2 id="_idParaDest-383"><a id="_idTextAnchor397"/>Coding the Button class</h2>
			<p>Create a new header file in the <code>Header Files/Screens</code> filter called <code>Button.h</code> and add the following code:</p>
			<pre>#pragma once
#include &lt;SFML/Graphics.hpp&gt;
using namespace sf;
class Button
{
private:
    RectangleShape m_Button;
    Text m_ButtonText;
    Font m_Font;
public:
    std::string m_Text;
    FloatRect m_Collider;
    Button(Vector2f position, 
        float width, float height, 
        int red, int green, int blue, 
        std::string text);
    void draw(RenderWindow&amp; window);
};</pre>
			<p>As you can see from the preceding code, a button will be visually represented by an SFML <code>RectangleShape</code> instance and an SFML <code>Text</code> instance. Also note that there is a <code>FloatRect</code> instance named <code>m_Collider</code> that will be used to detect mouse clicks on the button. The constructor will receive arguments to configure the position, size, color, and text of the button. The button will draw itself once each frame of the game loop and has a <code>draw</code> function that receives a <code>RenderWindow</code> reference to enable this.</p>
			<p>Create a new source file in the <code>Source Files/Screens</code> filter called <code>Button.cpp</code> and add the following code:</p>
			<pre>#include "Button.h"
Button::Button(Vector2f position, 
    float width, float height, 
    int red, int green, int blue, 
    std::string text)
{
    m_Button.setPosition(position);
    m_Button.setFillColor(sf::Color(red, green, blue));
    m_Button.setSize(Vector2f(width, height));
    m_Text = "" + text;
    float textPaddingX = width /10;
    float textPaddingY= height / 10;
    m_ButtonText.setCharacterSize(height * .7f);
    m_ButtonText.setString(text);
    m_Font.loadFromFile("fonts/Roboto-Bold.ttf");
    m_ButtonText.setFont(m_Font);
    m_ButtonText.setPosition(Vector2f((position.x + textPaddingX),
        (position.y + textPaddingY)));
    m_Collider = FloatRect(position, Vector2f(width, height));
}
void Button::draw(RenderWindow&amp; window)
{
    window.draw(m_Button);
    window.draw(m_ButtonText);
}</pre>
			<p>Most of the action takes place in the constructor, and there is nothing we haven't seen already on numerous occasions in all the other projects. The button is prepared to be drawn using all the values that are passed into the constructor.</p>
			<p>The <code>draw</code> function uses the <code>RenderWindow</code> reference to draw the previously configured <code>Text</code> instance on top of the previously configured <code>RectangleShape</code> instance.</p>
			<h2 id="_idParaDest-384"><a id="_idTextAnchor398"/>Coding the UIPanel class</h2>
			<p>Create a new header file in the <code>Header Files/Screens</code> filter called <code>UIPanel.h</code> and add the following code:</p>
			<pre>#pragma once
#include &lt;SFML/Graphics.hpp&gt;
#include "Button.h"
using namespace std;
class UIPanel {
private:
    RectangleShape m_UIPanel;
    bool m_Hidden = false;
    vector&lt;shared_ptr&lt;Button&gt;&gt; m_Buttons;
protected:
    float m_ButtonWidth = 0;
    float m_ButtonHeight = 0;
    float m_ButtonPadding = 0;
    Font m_Font;
    Text m_Text;
    void addButton(float x, float y, int width, int height,
        int red, int green, int blue,
        string label);
    
public:
    View m_View;
    UIPanel(Vector2i res, int x, int y, 
        float width, float height, 
        int alpha, int red, int green, int blue);
    vector&lt;shared_ptr&lt;Button&gt;&gt; getButtons();
    virtual void draw(RenderWindow&amp; window);
    void show();
    void hide();
};</pre>
			<p>The <code>private</code> section of the <code>UIPanel</code> class consists of a <code>RectangleShape</code> that will visually represent the background of the panel, a Boolean to keep track of whether the panel is currently visible to the player, and a <code>vector</code> of smart pointers to hold all the <code>Button</code> instances for this panel. Note that the smart pointers are of the shared variety so that we can pass them around and let the <code>shared_pointer</code> class take care of counting the references and deleting the memory when necessary.</p>
			<p>In the <code>protected</code> section, there are member variables for remembering the size and spacing of the buttons, as well as a <code>Text</code> and a <code>Font</code> instance for drawing text on the panel. All the panels in this project have just one <code>Text</code> instance, but specific derived classes are free to add extra members as they need. For example, a <code>HighScoreUIPanel</code> class might need a <code>vector</code> full of <code>Text</code> instances to draw a list of the highest scores.</p>
			<p>There is also an <code>addButton</code> function, and it is this function that will call the <code>Button</code> class constructor and add the instances to the <code>vector</code>.</p>
			<p>In the <code>public</code> section, we can see that every <code>UIPanel</code> instance will have its own <code>View</code> instance. This enables every panel and screen to configure its <code>View</code> however it likes. All the <code>View</code> instances will be drawn to and added to <code>RenderWindow</code> in layers.</p>
			<p>The <code>UIPanel</code> constructor receives all the necessary sizes and colors to configure its <code>RectangleShape</code>. The <code>getButtons</code> function shares the <code>vector</code> of <code>Button</code> instances so that other classes can interact with the buttons. For example, the <code>InputHandler</code> class will need the buttons to detect mouse clicks on them. This is why we used shared smart pointers.</p>
			<p>The <code>draw</code> function, of course, is called once each frame of the game loop and is <code>virtual</code>, so it can be optionally overridden and customized by derived classes. The <code>show</code> and <code>hide</code> functions will toggle the value of <code>m_Hidden</code> to keep track of whether this panel is currently visible to the player.</p>
			<p>Create a new source file in the <code>Source Files/Screens</code> filter called <code>UIPanel.cpp</code> and add the following code:</p>
			<pre>#include "UIPanel.h"
UIPanel::UIPanel(Vector2i res, int x, int y, 
    float width, float height, 
    int alpha, int red, int green, int blue)
{
    m_UIPanel.setFillColor(sf::Color(red, green, blue, alpha));
    // How big in pixels is the UI panel
    m_UIPanel.setSize(Vector2f(width, height));
    // How big in pixels is the view
    m_View.setSize(Vector2f(width, height));
    
    // Where in pixels does the center of the view focus
    // This is most relevant when drawing a portion 
   // of the game world
    // width/2, height/2 ensures it is exactly centered around the
    // RectangleShape, mUIPanel
    m_View.setCenter(width / 2, height / 2);
    // Where in the window is the view positioned?
    float viewportStartX = 1.f / (res.x / x);
    float viewportStartY = 1.f / (res.y / y);
    float viewportSizeX = 1.f / (res.x / width);
    float viewportSizeY = 1.f / (res.y / height);
    // Params from left to right
    // StartX as a fraction of 1, startY as a fraction of 1 
    // SizeX as a fraction of 1
    // SizeY as a fraction of 1
    m_View.setViewport(FloatRect(viewportStartX, viewportStartY, 
        viewportSizeX, viewportSizeY));
}
vector&lt;shared_ptr&lt;Button&gt;&gt; UIPanel::getButtons()
{
    return m_Buttons;
}
void UIPanel::addButton(float x, float y, 
    int width, int height,
    int red, int green, int blue,
    string label)
{
    m_Buttons.push_back(make_shared&lt;Button&gt;(Vector2f(x, y), 
        width, height,
        red, green, blue, 
        label));
}
void UIPanel::draw(RenderWindow &amp; window)
{
    window.setView(m_View);
    if (!m_Hidden) {
        window.draw(m_UIPanel);
        for (auto it = m_Buttons.begin(); 
            it != m_Buttons.end(); ++it)
        {
            (*it)-&gt;draw(window);
        }
    }
}
void UIPanel::show()
{
    m_Hidden = false;
}
void UIPanel::hide()
{
    m_Hidden = true;
}</pre>
			<p>In the constructor, the <code>RectangleShape</code> instance is scaled, colored, and positioned. The <code>View</code> instance is scaled to the size of the panel as well. The <code>setViewport</code> function of the <code>View</code> class is used along with some extra calculations to make sure the <code>View</code> takes up the correct proportion of the screen relative to the resolution and will therefore look approximately the same on screens of varying resolutions.</p>
			<p>The <code>getButtons</code> function simply returns the <code>vector</code> of buttons to the calling code. The <code>addButtons</code> function uses the <code>make_shared</code> function to allocate new <code>Button</code> instances on the heap and place them into the <code>vector</code>.</p>
			<p>The <code>draw</code> function uses the <code>setView</code> function to make the specific <code>View</code> instance of this panel the one that is drawn upon. Next, there's <code>RectangleShape</code>, which represents that this panel is drawn. Then, each of the buttons in the <code>vector</code> are looped through and drawn on top of the <code>RectangleShape</code>. All this drawing will only happen if <code>m_Hidden</code> is false.</p>
			<p>The <code>show</code> and <code>hide</code> functions allow users of the class to toggle <code>m_Hidden</code>.</p>
			<h2 id="_idParaDest-385"><a id="_idTextAnchor399"/>Coding the InputHandler class</h2>
			<p>Create a new header file in the <code>Header Files/Screens</code> filter called <code>InputHandler.h</code> and add the following code:</p>
			<pre>#pragma once
#include &lt;SFML/Graphics.hpp&gt;
#include &lt;vector&gt;
#include "Button.h"
#include "Screen.h"
#include "ScreenManagerRemoteControl.h"
using namespace sf;
using namespace std;
class Screen;
class InputHandler
{
private:
    Screen* m_ParentScreen;
    vector&lt;shared_ptr&lt;Button&gt;&gt; m_Buttons;
    View* m_PointerToUIPanelView;
    ScreenManagerRemoteControl* m_ScreenManagerRemoteControl;
public:
    void initialiseInputHandler(
        ScreenManagerRemoteControl* sw, 
        vector&lt;shared_ptr&lt;Button&gt;&gt;,
        View* pointerToUIView, 
        Screen* parentScreen);
    void handleInput(RenderWindow&amp; window, Event&amp; event);
    virtual void handleGamepad();
    virtual void handleKeyPressed(Event&amp; event, 
        RenderWindow&amp; window);
    virtual void handleKeyReleased(Event&amp; event, 
        RenderWindow&amp; window);
    virtual void handleLeftClick(string&amp; buttonInteractedWith, 
        RenderWindow&amp; window);
    View* getPointerToUIView();
    ScreenManagerRemoteControl* 
        getPointerToScreenManagerRemoteControl();
    Screen* getmParentScreen();
};</pre>
			<p>There is an error in this file because the <code>Screen</code> class doesn't exist yet. </p>
			<p>First, study the <code>private</code> section of this header file. Each <code>InputHandler</code> instance will hold a pointer to the screen that holds it. This will be useful in a few situations we will come across as the project continues. There is also a <code>vector</code> of shared smart pointers to <code>Button</code> instances. These are the same <code>Button</code> instances that are in the <code>UIPanel</code> we just coded. Each derived <code>UIPanel</code> will have a matching derived <code>InputHandler</code> with which it shares a <code>vector</code> of buttons.</p>
			<p>The <code>InputHandler</code> class also holds a pointer to the <code>View</code> instance in the <code>UIPanel</code>. When we code the function definitions in <code>InputHandler.cpp</code>, we will see how we get this pointer and how it is useful.</p>
			<p>There is also a pointer to <code>ScreenManagerRemoteControl</code>. Remember from the <code>ScreenManager</code> class that we have implemented some functions from <code>ScreenManagerRemoteControl</code>. This is what will give us access to functions such as <code>SwitchScreen</code>. This is very useful when you consider that <code>InputHandler</code> is the class where we will be detecting button clicks. Of course, we need to see how we can initialize this pointer to make it usable. We will see how in the <code>InputHandler.cpp</code> file soon.</p>
			<p>In the <code>public</code> section, there is an <code>initialiseInputHandler</code> function. This is where the <code>private</code> members we have just talked about will be prepared for use. Look at the parameters; they match the types of the private members exactly.</p>
			<p>Next is the <code>handleInput</code> function. Remember that this is called once per frame by the <code>GameEngine</code> class; the <code>ScreenManager</code> calls it on the current screen and the <code>Screen</code> class (coded next), in turn, will call it on all <code>InputHandler</code> instances that it holds. It receives a <code>RenderWindow</code> and an <code>Event</code> instance.</p>
			<p>Next, there are four <code>virtual</code> functions which each derived from the <code>InputHandler</code> class that it can optionally override if it needs to. They are as follows:</p>
			<ul>
				<li><code>handleGamepad</code></li>
				<li><code>handleKeyPressed</code></li>
				<li><code>handleKeyReleased</code></li>
				<li><code>handleLeftClick</code></li>
			</ul>
			<p>As we will see shortly, in the <code>InputHandler.cpp</code> file, the <code>handleInput</code> function will loop through the data in <code>Event</code>, just as we have done so often before. But then, instead of handling all the events directly as we have done in the past, it will delegate a response to one of the four virtual functions. The derived classes will then receive only the events and data they have decided they want to handle. Default and empty definitions of the four virtual functions are provided in the <code>InputHandler.cpp</code> file.</p>
			<p>The <code>getPointerToUIView</code> function will return the pointer to the panels <code>View</code> that this <code>InputHandler</code> instance holds. We will see shortly that we need <code>View</code> in order to do mouse click collision detection on the buttons.</p>
			<p><code>getPointerToScreenManagerRemoteControl</code> and <code>getmParentScreen</code> return pointers to the member variables that are suggested by the names of the functions.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Note that, if you make the private data protected, then the derived <code>InputHandler</code> classes can access the data without going through the functions we have just discussed. When the project is complete, feel free to revisit this section and change this if you wish.</p>
			<p>Now, we can code all the function definitions.</p>
			<p>Create a new source file in the <code>Source Files/Screens</code> filter called <code>InputHandler.cpp</code> and add the following code:</p>
			<pre>#include &lt;sstream&gt;
#include "InputHandler.h"
using namespace sf;
using namespace std;
void InputHandler::initialiseInputHandler(
    ScreenManagerRemoteControl* sw, 
    vector&lt;shared_ptr&lt;Button&gt;&gt; buttons,
    View* pointerToUIView, 
    Screen* parentScreen)
{
    m_ScreenManagerRemoteControl = sw;
    m_Buttons = buttons;
    m_PointerToUIPanelView = pointerToUIView;
    m_ParentScreen = parentScreen;
}
void InputHandler::handleInput(RenderWindow&amp; window, 
    Event&amp; event)
{
    // Handle any key presses
    if (event.type == Event::KeyPressed)
    {
        handleKeyPressed(event, window);
    }
    if (event.type == Event::KeyReleased)
    {
        handleKeyReleased(event, window);
    }
    // Handle any left mouse click released
    if (event.type == Event::MouseButtonReleased)
    {
        auto end = m_Buttons.end();
        for (auto i = m_Buttons.begin();
            i != end;
            ++i) {
            if ((*i)-&gt;m_Collider.contains(
                window.mapPixelToCoords(Mouse::getPosition(), 
                (*getPointerToUIView()))))
            {
                // Capture the text of the button that was interacted 
                // with and pass it to the specialised version 
                // of this class if implemented
                handleLeftClick((*i)-&gt;m_Text, window);
                break;
            }
        }
    }
    handleGamepad();    
}
void InputHandler::handleGamepad()
{}// Do nothing unless handled by a derived class
void InputHandler::handleKeyPressed(Event&amp; event, 
    RenderWindow&amp; window)
{}// Do nothing unless handled by a derived class
void InputHandler::handleKeyReleased(Event&amp; event, 
    RenderWindow&amp; window)
{}// Do nothing unless handled by a derived class
void InputHandler::handleLeftClick(std::
    string&amp; buttonInteractedWith, 
    RenderWindow&amp; window)
{}// Do nothing unless handled by a derived class
View* InputHandler::getPointerToUIView()
{
    return m_PointerToUIPanelView;
}
ScreenManagerRemoteControl* 
    InputHandler::getPointerToScreenManagerRemoteControl()
{
    return m_ScreenManagerRemoteControl;
}
Screen* InputHandler::getmParentScreen() {
    return m_ParentScreen;
}</pre>
			<p>The <code>initialiseInputHandler</code> function initializes the private data, as we have already discussed, the four <code>virtual</code> functions are empty, as expected, and the getter functions return pointers to the private members, just like we said they would.</p>
			<p>The interesting function definition is the <code>handleInput</code> function, so let's go through it.</p>
			<p>There is a series of <code>if</code> statements, which should look familiar from previous projects. Each <code>if</code> statement tests for a different type of event, such as a key being pressed or a key being released. Instead of handling the event, however, the appropriate <code>virtual</code> function is called. If the derived <code>InputHandler</code> class overrides the <code>virtual</code> function, it will receive the data and get to handle the event. If it doesn't, then the empty default function definition is called, and nothing happens. </p>
			<p>When the <code>MouseButtonReleased</code> event occurs, each of the <code>Button</code> instances in the <code>vector</code> is tested to see if the click occurred within the button. This is achieved using the <code>contains</code> function on the collider in each button and passing in the position of the mouse click. Note that the button coordinates are relative to the panels <code>View</code> and not the screen coordinates. For this reason, the <code>mapPixelToCoords</code> function is used to convert the screen coordinates of the mouse click into the corresponding coordinates of the <code>View</code>.</p>
			<p>When a collision is detected, the <code>handleLeftClick virtual</code> function is called and the text from the button is passed in. The derived <code>InputHandler</code> classes will handle what happens on a button click based on the text of the button.</p>
			<p>The final line of code in the <code>handleInput</code> function calls the final <code>virtual</code> function called <code>handleGamepad</code>. Any derived <code>InputHandler</code> classes that implement this function will get a chance to respond to the player's actions with the gamepad. In this project, only <code>GameInputHandler</code> will be concerned with what the gamepad is doing. You could adapt the project to allow the player to use the gamepad to navigate the menus of the other screen if you want to.</p>
			<h2 id="_idParaDest-386"><a id="_idTextAnchor400"/>Coding the Screen class</h2>
			<p>Create a new header file in the <code>Header Files/Screens</code> filter called <code>Screen.h</code> and add the following code:</p>
			<pre>#pragma once
#include &lt;SFML/Graphics.hpp&gt;
#include &lt;vector&gt;
#include "InputHandler.h"
#include "UIPanel.h"
#include "ScreenManagerRemoteControl.h"
class InputHandler;
class Screen {
private:
    vector&lt;shared_ptr&lt;InputHandler&gt;&gt; m_InputHandlers;
    vector&lt;unique_ptr&lt;UIPanel&gt;&gt; m_Panels;
protected:
    void addPanel(unique_ptr&lt;UIPanel&gt; p, 
        ScreenManagerRemoteControl* smrc, 
        shared_ptr&lt;InputHandler&gt; ih);
    
public:
    virtual void initialise();
    void virtual update(float fps);
    void virtual draw(RenderWindow&amp; window);
    void handleInput(RenderWindow&amp; window);
    View m_View;
};</pre>
			<p>In the <code>private</code> section of the preceding code, there is a vector of shared smart pointers to <code>InputHandler</code> instances. This is where we will store all the derived <code>InputHandler</code> instances. <code>SelectScreen</code> will actually only have one <code>InputHandler</code>, while <code>GameScreen</code> will have two, but you can have as many as you like. Consider, for example, a hypothetical settings screen where you might have options for graphics, sound, controller, gameplay, and so on. Each of these options could then be clicked to reveal a unique <code>UIPanel</code> instance with a related <code>InputHandler</code>. So, we could have avoided using a <code>vector</code> for this project, but any significant project would almost certainly need a <code>vector</code> eventually. The smart pointers are of the shared variety, indicating we will be passing the contents via a function at some point.</p>
			<p>The next member is a <code>vector</code> of unique smart pointers to <code>UIPanel</code> instances. This is where all the derived <code>UIPanel</code> instances will go. The unique variety of pointer indicates we will not share the pointers; if we do, we will have to transfer responsibility.</p>
			<p>In the protected section is the <code>addPanel</code> function, which is where a <code>Screen</code> will pass in all the details of a new <code>UIPanel</code> instance, including its related <code>InputHandler</code>. Note the parameter to receive a <code>ScreenManagerRemoteControl</code> pointer; remember that this is required for passing to <code>InputHandler</code>.</p>
			<p>There is an <code>initialise</code> function as well, which we will see the purpose of shortly. The final three functions are the <code>virtual</code> functions, that is, <code>update</code>, <code>draw</code> and <code>handleInput</code>, which the derived <code>Screen</code> classes can override as they see fit.</p>
			<p>Finally, take note of the <code>View</code> instance. Every <code>Screen</code> instance will also have its own <code>View</code> instance to draw to, just like each <code>UIPanel</code> does.</p>
			<p>Let's take a look at the implementation of the functions we have just discussed.</p>
			<p>Create a new source file in the <code>Source Files/Screens</code> filter called <code>Screen.cpp</code> and add the following code:</p>
			<pre>#include "Screen.h"
void Screen::initialise(){}
void Screen::addPanel(unique_ptr&lt;UIPanel&gt; uip, 
    ScreenManagerRemoteControl* smrc, 
    shared_ptr&lt;InputHandler&gt; ih)
{
    ih-&gt;initialiseInputHandler(smrc, 
        uip-&gt;getButtons(), &amp;uip-&gt;m_View, this);
    // Use move() because otherwise 
    // the vector has a COPY which is not allowed
    m_Panels.push_back(move(uip));        
    m_InputHandlers.push_back(ih);
}
void Screen::handleInput(RenderWindow&amp; window)
{
    Event event;
    auto itr = m_InputHandlers.begin();
    auto end = m_InputHandlers.end();
    while (window.pollEvent(event))
    {
        for (itr;
            itr != end;
            ++itr)
        {
            (*itr)-&gt;handleInput(window, event);
        }
    }
}
void Screen::update(float fps){}
void Screen::draw(RenderWindow&amp; window)
{    
    auto itr = m_Panels.begin();
    auto end = m_Panels.end();
    for (itr;
        itr != end;
        ++itr)
    {
        (*itr)-&gt;draw(window);
    }    
}</pre>
			<p>The <code>initialise</code> function is empty. It is designed to be overridden.</p>
			<p>The <code>addPanel</code> function, as we already know, stores the <code>InputHandler</code> and <code>UIPanel</code> instances that are passed to it. When an <code>InputHandler</code> is passed in, the <code>initialiseInputHandler</code> function is called and three things are passed in. First is the <code>vector</code> of <code>Button</code> instances, next is the <code>View</code> instance from the related <code>UIPanel</code> instance, and third is the <code>this</code> argument. In the current context, <code>this</code> is a pointer to the <code>Screen</code> instance itself. Why not refer to the <code>InputHandler</code> class and verify that these arguments are correct and what happens to them?</p>
			<p>Next, the panel and the input handler are added to the appropriate <code>vector</code>. Something interesting happens, however, if you look closely. Take another look at the line of code which adds the <code>UIPanel</code> instance called <code>uip</code> to the <code>m_Panels</code> vector:</p>
			<pre>m_Panels.push_back(move(uip));</pre>
			<p>The argument that's passed to <code>push_back</code> is encased in a call to <code>move</code>. This transfers responsibility for the unique pointer to the <code>UIPanel</code> in the <code>vector</code>. Any attempt to use <code>uip</code> after this point will result in a read access violation because <code>uip</code> is now a null pointer. The pointer in <code>m_Panels</code>, however, is good to go. You will probably agree that this is simpler than using a regular pointer and working out where to delete it.</p>
			<p>The <code>handleInput</code> function loops through every event, passing it in to each <code>InputHandler</code> in turn.</p>
			<p>The <code>update</code> function has no functionality in the base class and is empty.</p>
			<p>The <code>draw</code> function loops through every <code>UIPanel</code> instance and calls their <code>draw</code> functions.</p>
			<p>Now, we are ready to code all the derived classes. We will start with the select screen (<code>SelectScreen</code>) and then move on to the game screen (<code>GameScreen</code>). We will add one more quick class first, though.</p>
			<h1 id="_idParaDest-387"><a id="_idTextAnchor401"/>Adding the WorldState.h file</h1>
			<p>Create a new header file in the <code>Header Files/Engine</code> filter called <code>WorldState.h</code> and add the following code:</p>
			<pre>#pragma once
class WorldState
{
public:
    static const int WORLD_WIDTH = 100;
    static int WORLD_HEIGHT;
    static int SCORE;
    static int LIVES;
    static int NUM_INVADERS_AT_START;
    static int NUM_INVADERS;
    static int WAVE_NUMBER;
};</pre>
			<p>These variables are public and static. As a result, they will be accessible throughout the project and are guaranteed to have only a single instance.</p>
			<h1 id="_idParaDest-388"><a id="_idTextAnchor402"/>Coding the derived classes for the select screen </h1>
			<p>So far, we have coded the fundamental classes that represent the user interface, as well as the logical division of our game into screens. Next, we will code specific implementations of each of them. Remember that Space Invaders ++ will have two screens: select and game. The select screen will be represented by the <code>SelectScreen</code> class and will have a single <code>UIPanel</code> instance, a single <code>InputHandler</code> instance, and two buttons. The play screen will be represented by the <code>GameScreen</code> class and it will have two <code>UIPanel</code> instances. One is called <code>GameUIPanel</code> and will display the score, lives, and invader wave number. The other is called <code>GameOverUIPanel</code> and will display two buttons, giving the player the option to go back to the select screen or play again. As the <code>GameScreen</code> class is composed of two <code>UIPanel</code> instances, it will also be composed of two <code>InputHandler</code> instances.</p>
			<h2 id="_idParaDest-389"><a id="_idTextAnchor403"/>Coding the SelectScreen class</h2>
			<p>Create a new header file in the <code>Header Files/Screens/Select</code> filter called <code>SelectScreen.h</code> and add the following code:</p>
			<pre>#pragma once
#include "Screen.h"
class SelectScreen : public Screen
{
private:
    ScreenManagerRemoteControl* m_ScreenManagerRemoteControl;
    Texture m_BackgroundTexture;
    Sprite m_BackgroundSprite;
public:
    SelectScreen(ScreenManagerRemoteControl* smrc, Vector2i res);
    void virtual draw(RenderWindow&amp; window);
};</pre>
			<p>The <code>SelectScreen</code> class inherits from <code>Screen</code>. In the <code>private</code> section of the preceding code, there is a <code>ScreenManagerRemoteControl</code> pointer for switching screens, as well as a <code>Texture</code> instance and <code>Sprite</code> instance for drawing a background.</p>
			<p>In the <code>public</code> section, we can see the constructor and the prototype that overrides the <code>draw</code> function. The <code>SelectScreen</code> class does not need to override the <code>update</code> function.</p>
			<p>Create a new source file in the <code>Source Files/Screens/Select</code> filter called <code>SelectScreen.cpp</code> and add the following code:</p>
			<pre>#include "SelectScreen.h"
#include "SelectUIPanel.h"
#include "SelectInputHandler.h"
SelectScreen::SelectScreen(
    ScreenManagerRemoteControl* smrc, Vector2i res)
{
    auto suip = make_unique&lt;SelectUIPanel&gt;(res);
    auto sih = make_shared&lt;SelectInputHandler&gt;();
    addPanel(move(suip), smrc, sih);
    m_ScreenManagerRemoteControl = smrc;
    m_BackgroundTexture.loadFromFile("graphics/background.png");
    m_BackgroundSprite.setTexture(m_BackgroundTexture);
    auto textureSize = m_BackgroundSprite.
        getTexture()-&gt;getSize();
        
    m_BackgroundSprite.setScale(float(
        m_View.getSize().x) / textureSize.x,        
        float(m_View.getSize().y) / textureSize.y);
}
void SelectScreen::draw(RenderWindow&amp; window)
{
    // Change to this screen's view to draw
    window.setView(m_View);
    window.draw(m_BackgroundSprite);
    // Draw the UIPanel view(s)
    Screen::draw(window);
}</pre>
			<p>In the constructor, the purpose of all the coding so far begins to come together. The <code>make_unique</code> function is used to create a unique smart pointer to a <code>SelectUIPanel</code> instance. We will code <code>SelectUIPanel</code> in a couple of sections time. Next, the <code>make_shared</code> function is used to create a shared smart pointer to a <code>SelectInputHandler</code> instance. We will code the <code>SelectInputHandler</code> class next. Now that we have a <code>UIPanel</code> and an <code>InputHandler</code> in the appropriate forms, we can call the <code>addPanel</code> function and pass them both in. Note that, in the call to <code>addPanel</code>, <code>suip</code> is wrapped in a call to <code>move</code>. Any use of <code>suip</code> after this point is not possible without crashing the program because it is now a null pointer, since ownership has been moved to the function argument. Remember that, inside the <code>Screen</code> class <code>addPanel</code> function, ownership is moved again when the unique pointer to <code>UIPanel</code> is stashed away in the <code>vector</code> of <code>UIPanel</code> instances.</p>
			<p>Following this, the <code>ScreenManagerRemoteControl</code> pointer is initialized and can now be used to switch to another screen when required. </p>
			<p>The final few lines of code in the constructor create and scale a <code>Sprite</code> instance that uses the <code>background.png</code> image, which will fill the entire screen.</p>
			<p>In the <code>draw</code> function, the call to the <code>setView</code> function makes this panel's <code>View</code> instance the one to draw on, and then the <code>Sprite</code> instance is drawn to the <code>RenderWindow</code> instance.</p>
			<p>Finally, the <code>draw</code> function is called on the base <code>Screen</code> class, which draws all the panels and their related buttons. In this specific case, it draws just a single panel, <code>SelectUIPanel</code>, which we will code right after we have coded <code>SelectInputHandler</code>.</p>
			<h2 id="_idParaDest-390"><a id="_idTextAnchor404"/>Coding the SelectInputHandler class</h2>
			<p>Create a new header file in the <code>Header Files/Screens/Select</code> filter called <code>SelectInputHandler.h</code> and add the following code:</p>
			<pre>#pragma once
#include "InputHandler.h"
class SelectInputHandler : public InputHandler
{
public:
    void handleKeyPressed(Event&amp; event, 
        RenderWindow&amp; window) override;
    void handleLeftClick(std::string&amp; buttonInteractedWith, 
        RenderWindow&amp; window) override;
};</pre>
			<p>The <code>SelectInputHandler</code> class inherits from <code>InputHandler</code> and overrides the <code>handleKeyPressed</code> and <code>handleLeftClick</code> functions. Let's see how these functions are implemented.</p>
			<p>Create a new source file in the <code>Source Files/Screens/Select</code> filter called <code>SelectInputHandler.cpp</code> and add the following code:</p>
			<pre>#include "SelectInputHandler.h"
#include "SoundEngine.h"
#include "WorldState.h"
#include &lt;iostream&gt;
int WorldState::WAVE_NUMBER;
void SelectInputHandler::handleKeyPressed(
    Event&amp; event, RenderWindow&amp; window)
{
    // Quit the game
    if (Keyboard::isKeyPressed(Keyboard::Escape))
    {
        window.close();
    }
}
void SelectInputHandler::handleLeftClick(
    std::string&amp; buttonInteractedWith, RenderWindow&amp; window)
{
    if (buttonInteractedWith == "Play") {
        SoundEngine::playClick();
        WorldState::WAVE_NUMBER = 0;
        getPointerToScreenManagerRemoteControl()
            -&gt;loadLevelInPlayMode("level1");
    }
    if (buttonInteractedWith == "Quit") {
        SoundEngine::playClick();
        window.close();
    }
}</pre>
			<p>The <code>handleKeyPressed</code> function interacts with just one keyboard key. When the <em class="italic">Escape</em> key is pressed, the game quits.</p>
			<p>In the <code>handleLeftClick</code> function, there are two <code>if</code> statements. Remember that the <code>handleInputFunction</code> of the <code>InputHandler</code> class passes in the text of the button that was clicked, along with a reference to <code>RenderWindow</code>. If the <code>WAVE_NUMBER</code> variable is set to zero, and the <code>ScreenManagerRemoteControl</code> pointer calls the <code>loadLevelInPlayMode</code> function. The <code>loadLevelInPlayMode</code> function has its definition in <code>ScreenManagerClass</code>. Eventually, this function will indeed load a level from the passed in file name, but for now, it simply changes screen to the play screen.</p>
			<p>If the <strong class="bold">Quit</strong> button is clicked, then the game is exited.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">At this stage, despite including <code>WorldState.h</code>, you might have an error using <code>WorldState::WaveNumber</code>. This is fine; this is happening because of the order in which the classes are parsed by Visual Studio. When we add all the game screen-related classes that also use <code>WorldState.h</code>, which is parsed before this file, the error will be gone.</p>
			<p>Let's code <code>SelectUIPanel</code>. Then, we can move on to the <code>GameScreen</code> class.</p>
			<h2 id="_idParaDest-391"><a id="_idTextAnchor405"/>Coding the SelectUIPanel class</h2>
			<p>Create a new header file in the <code>Header Files/Screens/Select</code> filter called <code>SelectUIPanel.h</code> and add the following code:</p>
			<pre>#pragma once
#include "UIPanel.h"
class SelectUIPanel : public UIPanel
{
private:
    void initialiseButtons();
public:
    SelectUIPanel(Vector2i res);
    void virtual draw(RenderWindow&amp; window);
};</pre>
			<p>The <code>SelectUIPanel</code> class inherits from <code>UIPanel</code> and overrides the <code>draw</code> function. In the preceding header file, you can also see that there is a function called <code>initialiseButtons</code>, as well as a constructor. Let's code the definitions.</p>
			<p>Create a new source file in the Source <code>Files/Screens/Select</code> filter called <code>SelectUIPanel.cpp</code> and add the following code:</p>
			<pre>#include "SelectUIPanel.h"
#include &lt;iostream&gt;
SelectUIPanel::SelectUIPanel(Vector2i res) :
    // Create a new UIPanel  
    // by calling the super-class constructor
    UIPanel(res,
        (res.x / 10) * 2, // Start 2/10 across
        res.y / 3, // 1/3 of the resolution from the top
        (res.x / 10) * 6, // as wide as 6/10 of the resolution
        res.y / 3, // and as tall as 1/3 of the resolution
        50, 255, 255, 255) // a, r, g, b
{
    m_ButtonWidth = res.x / 20;
    m_ButtonHeight = res.y / 20;
    m_ButtonPadding = res.x / 100;
    m_Text.setFillColor(sf::Color(0, 255, 0, 255));
    m_Text.setString("SPACE INVADERS ++");
    //https://www.dafont.com/roboto.font
    m_Font.loadFromFile("fonts/Roboto-Bold.ttf");
    m_Text.setFont(m_Font);
    m_Text.setPosition(Vector2f(m_ButtonPadding,
        m_ButtonHeight + (m_ButtonPadding * 2)));
    m_Text.setCharacterSize(160);
    initialiseButtons();
}
void SelectUIPanel::initialiseButtons()
{
    // Buttons are positioned relative to the top left 
    // corner of the UI panel(m_View in UIPanel)
    addButton(m_ButtonPadding,
        m_ButtonPadding,
        m_ButtonWidth,
        m_ButtonHeight,
        0, 255, 0,
        "Play");
    addButton(m_ButtonWidth + (m_ButtonPadding * 2),
        m_ButtonPadding,
        m_ButtonWidth,
        m_ButtonHeight,
        255, 0, 0,
        "Quit");
}
void SelectUIPanel::draw(RenderWindow&amp; window)
{    
        show();
        UIPanel::draw(window);
        window.draw(m_Text);        
}</pre>
			<p>The constructor receives the screen resolution and immediately uses that data to call the superclass constructor. By doing calculations with the values stored in <code>res</code>, the starting position and size of the panel is calculated. It is important that this calculation is done here and not in the <code>UIPanel</code> class because every <code>UIPanel</code> will be a different size and in a different position. Take a look at the comments in the preceding code if you are interested in the effect of each of the specific calculations. The color is also passed in using alpha, red, green, and blue values.</p>
			<p>Next, the member variables from the base class that determine button size and spacing are initialized. The value of <code>20</code> is just an arbitrary value that works, but the important part is that all the values are based on the resolution of the screen, so they will scale well over different screen resolutions.</p>
			<p>The next few lines of code prepare a <code>Text</code> instance, ready to be shown in the draw function. Finally, in the constructor, the <code>initialiseButtons</code> function is called.</p>
			<p>In the <code>initialiseButtons</code> function, the <code>addButton</code> function is called twice, creating a green button with "Play" on it and a red button with "Quit" on it.</p>
			<p>There might be some errors because of the use of the <code>WorldState.h </code>file. These can be ignored as they will correct themselves as we proceed with the next few classes.</p>
			<p>Now, we can code all the game screen-related classes.</p>
			<h1 id="_idParaDest-392"><a id="_idTextAnchor406"/>Coding the derived classes for the game screen </h1>
			<p>The structure of all these classes is the same as the select screen-related classes. I will be sure to point out where they vary, however. Most of the significant differences will be discussed across the next three chapters, however, because that is when we will code all the game objects and components and then put them to work in the <code>GameScreen</code> class. </p>
			<p>The first difference is that the <code>GameScreen</code> class has two <code>UIPanel</code> instances and two <code>InputHandler</code> instances. </p>
			<h2 id="_idParaDest-393"><a id="_idTextAnchor407"/>Coding the GameScreen class</h2>
			<p>Create a new header file in the <code>Header Files/Screens/Game</code> filter called <code>GameScreen.h</code> and add the following code:</p>
			<pre>#pragma once
#include "Screen.h"
#include "GameInputHandler.h"
#include "GameOverInputHandler.h"
class GameScreen : public Screen
{
private:
    ScreenManagerRemoteControl* m_ScreenManagerRemoteControl;
    shared_ptr&lt;GameInputHandler&gt; m_GIH;
    Texture m_BackgroundTexture;
    Sprite m_BackgroundSprite;
public:
    static bool m_GameOver;
    GameScreen(ScreenManagerRemoteControl* smrc, Vector2i res);
    void initialise() override;
    void virtual update(float fps);
    void virtual draw(RenderWindow&amp; window);    
};</pre>
			<p>Note that this is not the finished code – we will add more features to this file in the next chapter. This is just enough code so that we can run the game and see some basic functionality at the end of this chapter.</p>
			<p>The code is familiar to the <code>SelectScreen</code> class. We also override the <code>initialise</code> and <code>update</code> functions. Furthermore, we have added a Boolean called <code>m_GameOver</code>, which will keep track of whether the game is currently playing. </p>
			<p>Let's move on to the function implementations.</p>
			<p>Create a new source file in the <code>Source Files/Screens/Game</code> filter called <code>GameScreen.cpp</code> and add the following code:</p>
			<pre>#include "GameScreen.h"
#include "GameUIPanel.h"
#include "GameInputHandler.h"
#include "GameOverUIPanel.h"
#include "WorldState.h"
int WorldState::WORLD_HEIGHT;
int WorldState::NUM_INVADERS;
int WorldState::NUM_INVADERS_AT_START;
GameScreen::GameScreen(ScreenManagerRemoteControl* smrc,
    Vector2i res)
{
    m_GIH = make_shared&lt;GameInputHandler&gt;();
    auto guip = make_unique&lt;GameUIPanel&gt;(res);
    addPanel(move(guip), smrc, m_GIH);
    auto m_GOIH = make_shared&lt;GameOverInputHandler&gt;();
    auto gouip = make_unique&lt;GameOverUIPanel&gt;(res);
    addPanel(move(gouip), smrc, m_GOIH);
    m_ScreenManagerRemoteControl = smrc;
    float screenRatio = VideoMode::getDesktopMode().width /
        VideoMode::getDesktopMode().height;
    WorldState::WORLD_HEIGHT = WorldState::WORLD_WIDTH /
        screenRatio;
    m_View.setSize(
        WorldState::WORLD_WIDTH, WorldState::WORLD_HEIGHT);
    m_View.setCenter(Vector2f(WorldState::WORLD_WIDTH /
        2, WorldState::WORLD_HEIGHT / 2));
    
    m_BackgroundTexture.loadFromFile("graphics/background.png");
    m_BackgroundSprite.setTexture(m_BackgroundTexture);
    auto textureSize = m_BackgroundSprite.getTexture()-&gt;getSize();
    m_BackgroundSprite.setScale(float(m_View.getSize().x) / 
      textureSize.x,
        float(m_View.getSize().y) / textureSize.y);
}
void GameScreen::initialise()
{
    m_GIH-&gt;initialize();
    WorldState::NUM_INVADERS = 0;
    m_GameOver = false;
    if (WorldState::WAVE_NUMBER == 0)
    {
        WorldState::NUM_INVADERS_AT_START = 
            WorldState::NUM_INVADERS;
            
        WorldState::WAVE_NUMBER = 1;
        WorldState::LIVES = 3;
        WorldState::SCORE = 0;
    }
}
void GameScreen::update(float fps)
{
    Screen::update(fps);
    if (!m_GameOver)
    {
        if (WorldState::NUM_INVADERS &lt;= 0)
        {
            WorldState::WAVE_NUMBER++;
            m_ScreenManagerRemoteControl-&gt;
                loadLevelInPlayMode("level1");
        }
        if (WorldState::LIVES &lt;= 0)
        {
            m_GameOver = true;
        }
    }
}
void GameScreen::draw(RenderWindow&amp; window)
{
    // Change to this screen's view to draw
    window.setView(m_View);
    window.draw(m_BackgroundSprite);
    // Draw the UIPanel view(s)
    Screen::draw(window);
}</pre>
			<p>Everything that happened in the <code>SelectScreen</code> class happens here too, but for two <code>UIPanel</code> instances and two <code>InputHandler</code> instances. The next difference is that <code>GameScreen</code> does implement the <code>update</code> function. This is where all the game objects will be updated each frame of the game.</p>
			<p>The next difference is that we have added some basic logic for the game into the <code>initialise</code> and <code>update</code> functions.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">I apologize for the inconsistent spelling of the <code>initialise</code> and <code>initialize</code> functions. Changing them at this current stage of production is more likely to introduce errors into the book than help you out.</p>
			<p>In the <code>initialize</code> function, the code calls the <code>initialize</code> function of the <code>GameInputHandler</code> class that we will code next. The <code>NUM_INVADERS</code> variable is set to zero, while <code>m_GameOver</code> is set to false. Next, the <code>WAVE_NUMBER</code> variable is tested and, if it equals zero, then the <code>WorldState</code> class has its static variables initialized, ready for a new game.</p>
			<p>In the <code>update </code>function, the <code>m_GameOver</code> variable is used to determine whether the game is running and, if it is, two more tests are done. The first tests whether all the invaders have been destroyed. At this stage of development, because there aren't any invaders, this has the effect of constantly incrementing the wave number.</p>
			<p>The second test checks whether the player has run out of lives and if they have, then <code>m_GameOver</code> is set to true.</p>
			<h2 id="_idParaDest-394"><a id="_idTextAnchor408"/>Coding the GameInputHandler class</h2>
			<p>Create a new header file in the <code>Header Files/Screens/Game</code> filter called <code>GameInputHandler.h</code> and add the following code:</p>
			<pre>#pragma once
#include "InputHandler.h"
class GameScreen;
class GameInputHandler : public InputHandler
{
public:
    void initialize();
    void handleGamepad() override;
    void handleKeyPressed(Event&amp; event,
        RenderWindow&amp; window) override;
    void handleKeyReleased(Event&amp; event,
        RenderWindow&amp; window) override;
};</pre>
			<p>This class works the same way as <code>SelectInputHandler</code> does, but we need to override more of the functions. We will add code to the <code>initialize</code>, <code>handleGamepad</code>, <code>handleKeyPressed</code>, and <code>handleKeyReleased</code> functions here.</p>
			<p>This is not the finished code – we will add lots more features to this file in the next chapter. This is just enough code so that we can run the game and see some basic functionality at the end of the chapter.</p>
			<p>Create a new source file in the <code>Source Files/Screens/Game</code> filter called <code>GameInputHandler.cpp</code> and add the following code:</p>
			<pre>#include "GameInputHandler.h"
#include "SoundEngine.h"
#include "GameScreen.h"
void GameInputHandler::initialize() {
}
void GameInputHandler::handleGamepad()
{
}
void GameInputHandler::handleKeyPressed(
    Event&amp; event, RenderWindow&amp; window)
{
    // Handle key presses
    if (event.key.code == Keyboard::Escape)
    {
        SoundEngine::playClick();
        getPointerToScreenManagerRemoteControl()-&gt;
            SwitchScreens("Select");
    }    
}
void GameInputHandler::handleKeyReleased(
    Event&amp; event, RenderWindow&amp; window)
{
}</pre>
			<p>For now, we only want to add code to the <code>handleKeyPressed</code> function, but why not add the other empty functions that are shown in the preceding code? When the player presses the <em class="italic">Escape</em> key, the <code>ScreenMangerRemoteControl</code> pointer calls the <code>SwitchScreen</code> function to go back to the select screen.</p>
			<p>This is not the finished code – we will add lots more features to this file in the next chapter. This is just enough code so that we can run the game and see some basic functionality at the end of the chapter. </p>
			<h2 id="_idParaDest-395"><a id="_idTextAnchor409"/>Coding the GameUIPanel class</h2>
			<p>Create a new header file in the <code>Header Files/Screens/Game</code> filter called <code>GameUIPanel.h</code> and add the following code:</p>
			<pre>#pragma once
#include "UIPanel.h"
class GameUIPanel : public UIPanel
{
public:
    GameUIPanel(Vector2i res);
    void draw(RenderWindow&amp; window) override;
};</pre>
			<p>Like the previous <code>UIPanel</code> child class, we'll override the <code>draw</code> function and also implement the constructor. Let's code these functions now.</p>
			<p>Create a new source file in the <code>Source Files/Screens/Game</code> filter called <code>GameUIPanel.cpp</code> and add the following code:</p>
			<pre>#include "GameUIPanel.h"
#include &lt;sstream&gt;
#include "WorldState.h"
int WorldState::SCORE;
int WorldState::LIVES;
GameUIPanel::GameUIPanel(Vector2i res) :
    UIPanel(res,
        1, // The left
        1, // The top
        res.x / 3, // 1/3 width screen
        res.y / 12, 
        50, 255, 255, 255) // a, r, g, b 
{
    m_Text.setFillColor(sf::Color(0, 255, 0, 255));
    m_Text.setString("Score: 0 Lives: 3 Wave: 1");
    m_Font.loadFromFile("fonts/Roboto-Bold.ttf");
    m_Text.setFont(m_Font);
    m_Text.setPosition(Vector2f(15,15));
    m_Text.setCharacterSize(60);    
}
void GameUIPanel::draw(RenderWindow&amp; window)
{
    UIPanel::draw(window);
    std::stringstream ss;
    ss &lt;&lt; "Score: " &lt;&lt; WorldState::SCORE &lt;&lt; "  Lives: " 
        &lt;&lt; WorldState::LIVES &lt;&lt; " Wave: " 
        &lt;&lt; WorldState::WAVE_NUMBER;
    m_Text.setString(ss.str());
    window.draw(m_Text);
}</pre>
			<p>The constructor, like the <code>SelectUIPanel</code> class, calls the base class constructor to configure the position, size, and color of the panel. Also, in the constructor, a <code>Text</code> instance is prepared for drawing to the screen.</p>
			<p>In the <code>draw</code> function, a <code>stringstream</code> instance is used to concatenate a String of text that displays the player's score, lives remaining, and number of waves cleared. The <code>RenderWindow</code> instance then passes the <code>Text</code> instance to its <code>draw</code> function.</p>
			<h2 id="_idParaDest-396"><a id="_idTextAnchor410"/>Coding the GameOverInputHandler class</h2>
			<p>Remember that the game screen will have two panels and two input handling classes. When the player loses their last life, the game over panel will be shown. This is what we will code now.</p>
			<p>Create a new header file in the <code>Header Files/Screens/Game</code> filter called <code>GameOverInputHandler.h</code> and add the following code:</p>
			<pre>#pragma once
#include "InputHandler.h"
class GameOverInputHandler :
    public InputHandler
{
public:
    void handleKeyPressed(Event&amp; event, 
        RenderWindow&amp; window) override;
    void handleLeftClick(std::string&amp; 
        buttonInteractedWith, RenderWindow&amp; window) override;
};</pre>
			<p>There is nothing different in the preceding code compared to the header files of the previous two <code>InputHandler</code> derived classes. </p>
			<p>Create a new source file in the <code>Source Files/Screens/Game</code> filter called <code>GameOverInputHandler.cpp</code> and add the following code:</p>
			<pre>#include "GameOverInputHandler.h"
#include "SoundEngine.h"
#include "WorldState.h"
#include &lt;iostream&gt;
void GameOverInputHandler::handleKeyPressed(Event&amp; event, 
    RenderWindow&amp; window)
{
    if (event.key.code == Keyboard::Escape)
    {
        SoundEngine::playClick();
        getPointerToScreenManagerRemoteControl()-&gt;
            SwitchScreens("Select");
    }
}
void GameOverInputHandler::handleLeftClick(
    std::string&amp; buttonInteractedWith, RenderWindow&amp; window)
{
    if (buttonInteractedWith == "Play") {
        SoundEngine::playClick();
        WorldState::WAVE_NUMBER = 0;
        getPointerToScreenManagerRemoteControl()-&gt;
            loadLevelInPlayMode("level1");
    }
    else if (buttonInteractedWith == "Home") {
        SoundEngine::playClick();
        getPointerToScreenManagerRemoteControl()-&gt;
            SwitchScreens("Select");
    }
}</pre>
			<p>The preceding code handles two types of event. First, if the <em class="italic">Escape</em> keyboard key is pressed, the game switches to the select screen.</p>
			<p>In the <code>handleLeftClick</code> function, there are two different buttons that are handled. If the <code>loadLevelInPlayMode</code>, while, if the <strong class="bold">Home</strong> button is clicked, then the select screen will be shown.</p>
			<h2 id="_idParaDest-397"><a id="_idTextAnchor411"/>Coding the GameOverUIPanel class</h2>
			<p>Create a new header file in the <code>Header Files/Screens/Game</code> filter called <code>GameOverUIPanel.h</code> and add the following code:</p>
			<pre>#pragma once
#include "UIPanel.h"
class GameOverUIPanel :
    public UIPanel
{
private:    
    void initialiseButtons();
public:
    GameOverUIPanel(Vector2i res);
    void virtual draw(RenderWindow&amp; window);
};</pre>
			<p>There's nothing new in the preceding header file, so let's look at the function implementations</p>
			<p>Create a new source file in the <code>Source Files/Screens/Game</code> filter called <code>GameOverUIPanel.cpp</code> and add the following code:</p>
			<pre>#include "GameOverUIPanel.h"
#include "GameScreen.h"
bool GameScreen::m_GameOver;
GameOverUIPanel::GameOverUIPanel(Vector2i res) :
    UIPanel(res,
        (res.x / 10) * 3, 
        res.y / 2, // 50% of the resolution from the top
        (res.x / 10) * 3, // as wide as 1/3 of the resolution
        res.y / 6, // and as tall as 1/6 of the resolution
        50, 255, 255, 255) // a, r, g, b    
{
    m_ButtonWidth = res.x / 20;
    m_ButtonHeight = res.y / 20;
    m_ButtonPadding = res.x / 100;
    m_Text.setFillColor(sf::Color(0, 255, 0, 255));// Green
    m_Text.setString("GAME OVER!");
    m_Font.loadFromFile("fonts/Roboto-Bold.ttf");
    m_Text.setFont(m_Font);
    m_Text.setPosition(Vector2f(m_ButtonPadding, 
        (m_ButtonPadding * 2)+ m_ButtonHeight));
    m_Text.setCharacterSize(60);
    initialiseButtons();
}
void GameOverUIPanel::initialiseButtons()
{
    addButton(m_ButtonPadding,
        m_ButtonPadding,
        m_ButtonWidth,
        m_ButtonHeight,
        0, 255, 0,
        "Play");
    addButton(m_ButtonWidth + (m_ButtonPadding * 2),
        m_ButtonPadding,
        m_ButtonWidth,
        m_ButtonHeight,
        255, 0, 0,
        "Home");
}
void GameOverUIPanel::draw(RenderWindow&amp; window) 
{
    if (GameScreen::m_GameOver)
    {
        show();
        UIPanel::draw(window);
        window.draw(m_Text);
    }
    else
    {
        hide();
    }
}</pre>
			<p>The preceding code configures a panel in the middle of the screen with the text <strong class="bold">Game Over!</strong> and two buttons that will allow the player to restart the game or quit, and go back to the starting screen (home/select).</p>
			<h1 id="_idParaDest-398"><a id="_idTextAnchor412"/>Running the game</h1>
			<p>If you run the game, you will see the select screen, as shown in the following screenshot:</p>
			<div><div><img src="img/B14278_19_08.jpg" alt=""/>
				</div>
			</div>
			<p>Press <strong class="bold">Play</strong> to transition to the game screen:</p>
			<div><div><img src="img/B14278_19_09.jpg" alt=""/>
				</div>
			</div>
			<p>Press <strong class="bold">Escape</strong> to quit, and go back to the select screen.</p>
			<p>Quit the game and find the following line of code in the <code>GameScreen</code> class:</p>
			<pre>if (WorldState::LIVES &lt;= 0)</pre>
			<p>Change it to the following:</p>
			<pre>if (true)</pre>
			<p>Now, run the game again and select the <strong class="bold">Play</strong> button. The game over panel will be displayed and can be interacted with:</p>
			<div><div><img src="img/B14278_19_10.jpg" alt=""/>
				</div>
			</div>
			<p>Now, change back <code>if (true)</code> in the <code>GameScreen</code> class back to <code>if (WorldState::LIVES &lt;= 0)</code>.</p>
			<p>Let's take a break; that was a long chapter.</p>
			<h1 id="_idParaDest-399"><a id="_idTextAnchor413"/>Summary</h1>
			<p>You have achieved a lot in this chapter. You have built a solid foundation for the Space Invaders ++ game and you have also coded a reusable system that can be used for almost any game that is divided up into different "screens".</p>
			<p>We now have an input handling system in place that can detect keyboard presses and mouse clicks and route the responsibility to handle them to a specific panel that is part of a specific screen. Furthermore, the abstraction of the concept of a screen allows us to set up as many different game loops as we like. The <code>GameScreen</code> class will be the main class to handle the logic of this game but, once you see how over the next few chapters, you could easily code another screen to play a completely different game. Of course, the most likely thing you will do is get started with your own ideas.</p>
			<p>In the next chapter, we will code the game objects and components which are the basis of our entity-component pattern implementation.</p>
		</div>
		<div><div></div>
		</div>
	</body></html>