<html><head></head><body>
		<div id="_idContainer125">
			<h1 id="_idParaDest-359"><a id="_idTextAnchor372"/><em class="italic">Chapter 19</em>: Game Programming Design Patterns – Starting the Space Invaders ++ Game</h1>
			<p>Welcome to the final project. As you have come to expect by now, this project will take a significant step forward in terms of learning new C++ techniques. The next four chapters will look at topics such as <strong class="bold">smart pointers</strong>, C++ <strong class="bold">assertions,</strong> using a gamepad controller, debugging using Visual Studio, <strong class="bold">casting</strong> pointers of a base class to become pointers of a specific derived class, debugging, and a first look at <strong class="bold">design patterns</strong>.</p>
			<p>It is my guess that if you are going to make deep, large-scale games in C++, then design patterns are going to be a big part of your learning agenda in the months and years ahead. In order to introduce this vital topic, I have chosen a relatively simple but fun game to serve as an example. In this chapter, we'll find out a bit more about the Space Invaders ++ game, and then we can get on to the topic of design patterns and why we need them.</p>
			<p>In this hefty chapter, we will cover the following topics:</p>
			<ul>
				<li>Find out about Space Invaders ++ and why we chose it for the final project.</li>
				<li>Learn what design patterns are and why they matter to game developers.</li>
				<li>Study the design patterns in the Space Invaders ++ project that will be used over the next four chapters.</li>
				<li>We will get started on the Space Invaders ++ project.</li>
				<li>Code numerous classes to start fleshing out the game.</li>
			</ul>
			<p>Let's talk about the game itself.</p>
			<h1 id="_idParaDest-360"><a id="_idTextAnchor373"/>Space Invaders ++</h1>
			<p>Have a look at the following three screenshots, which visually explain most of what we need to know about Space Invaders ++. Just in case you don't know already, Space Invaders is one of the earliest arcade games and was released in 1978. If you like a bit of history, you can read the Wikipedia Space Invaders game page here: <a href="https://en.wikipedia.org/wiki/Space_Invaders">https://en.wikipedia.org/wiki/Space_Invaders</a>.</p>
			<p>This first screenshot shows the simple starting screen of our game. For the purposes of discussing screens, which we'll do next, we will call this the <strong class="bold">select screen</strong>. The player has two choices to select from: quit or play. However, by the end of this chapter, you will know how to add and switch between as many screens as you like:</p>
			<div>
				<div id="_idContainer115" class="IMG---Figure">
					<img src="image/B14278_19_01.jpg" alt=""/>
				</div>
			</div>
			<p>As you can see, in the preceding screenshot, there is a new feature we have not implemented before: clickable buttons. We will talk more about buttons and their counterparts, such as UI panels and screens, shortly.</p>
			<p>The following screenshot shows the game in action. It is quite simple to play. For the purposes of discussing screens, which we'll do next, we will call the following screenshot the <strong class="bold">play screen</strong>. The invaders move from left to right while shooting bullets at the player. When they reach the edge of the screen, they drop a little lower, speed up, and head back to the left:</p>
			<div>
				<div id="_idContainer116" class="IMG---Figure">
					<img src="image/B14278_19_02.jpg" alt=""/>
				</div>
			</div>
			<p>The player can move left and right as well as up and down, but the vertical movement is restricted to the bottom half of the screen. </p>
			<p class="callout-heading">Important note</p>
			<p class="callout">The original Space Invaders game just allowed horizontal movement.</p>
			<p>The following screenshot shows the options the player is presented with when they have lost three lives. They can choose to play again or quit and go back to the select screen:</p>
			<div>
				<div id="_idContainer117" class="IMG---Figure">
					<img src="image/B14278_19_03.jpg" alt=""/>
				</div>
			</div>
			<p>While Space Invaders ++ does allow us to introduce lots of new C++ topics that I have already mentioned in the introduction to the chapter, as well as some more game-related topics such as using a gamepad controller, it is true that this isn't really a step up in terms of complexity compared to the previous project. So, why choose this as the final project?</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">In this project, there's lots of code. Most of it we have seen before, either in the same context or a different context. It is not possible to explain every single line as a new book would be required to do so. I have very carefully chosen which code to explain in full, which code to just mention, and which code I am guessing you will be able to work out for yourself. I recommend studying all the code in this book and in the download bundle as you progress. I will, however, go into the structure of the code in full detail as that is the real learning objective of this project. Furthermore, all the C++ code is shown in this book, so nothing is missing, although only an overview of the <strong class="source-inline">level1.txt</strong> file is shown.</p>
			<h2 id="_idParaDest-361"><a id="_idTextAnchor374"/>Why Space Invaders ++?</h2>
			<p>To begin this discussion, please consider my two objectives for this book:</p>
			<ol>
				<li>The first objective of this book is to introduce you to C++ programming using the learning material of video games. I have already admitted on several occasions and several topics that this is just an introduction. C++ and game development are too big to fit into this book alone. </li>
				<li>The second objective of this book is to leave you in a position to continue your study while still using games as the learning material. </li>
			</ol>
			<p>The problem is, as we have seen, each time we build a game with more features than the last, we end up with a more complicated code structure and the code files get longer and longer too. Throughout this book, we have learned new ways to improve the structure of our code and at each stage, we have succeeded, but the increasing complexity of the games always seems to outweigh the code improvements we learn about.</p>
			<p>This project is designed to address this complexity issue and to take back control of our source code. Despite this game being less deep than the previous project, there will be far more classes to deal with.</p>
			<p>This obviously implies quite a complicated structure. It will also mean, however, that once you get to grips with this structure, you will be able to reuse it for much more complicated games without any of the code files going beyond a few hundred lines of code.</p>
			<p>What this project is designed to do is allow you to come up with your own game ideas, even complex ones, and get started on them right away, using the design patterns we'll discuss in the following section.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Note, however, that I am definitely not suggesting the code structure (design patterns) we will learn about here are the ultimate solution to your game development future; in fact, they are far from it. What you will learn are solutions that allow you to get started with your dream project without the complexity stopping you in your tracks. You will still need to study more about design patterns, C++, and game development along the way.</p>
			<p>So, what are design patterns?</p>
			<h1 id="_idParaDest-362"><a id="_idTextAnchor375"/>Design patterns</h1>
			<p>A <strong class="bold">design pattern</strong> is a reusable solution to a coding problem. In fact, most games (including this one) will use multiple design patterns. The key point about design patterns is this: they are already proven to provide a good solution to a common problem. We are not going to invent any design patterns – we are just going to use some that already exist to solve the problem of our ever-expanding code. </p>
			<p>Many design patterns are quite complicated and require further study beyond the level of this book if you want to even begin learning them. What follows is a simplification of a few key game development-related patterns that will help fulfill the second objective of this book. You're urged to continue your study to implement them more comprehensively and alongside even more patterns than will be discussed here.</p>
			<p>Let's look at the design patterns that are used in the Space Invaders ++ project.</p>
			<h2 id="_idParaDest-363"><a id="_idTextAnchor376"/>Screen, InputHandler, UIPanel, and Button</h2>
			<p>This project will abstract some concepts further than any of the other projects. Space Invaders ++ will introduce the concept of a <strong class="bold">screen</strong>. The concept of a screen is most easily understood by giving some examples. A game could have a menu screen, a settings screen, a high score screen, and a game screen. A <strong class="bold">screen</strong> is a logical division of the parts of the game. Every screen has some things in common with all the other screens, yet each screen also needs its own unique features as well. For example, a menu screen might have buttons that enable the player to transition to another screen, as well as a neat graphical image or even a dynamic scene. The high score screen will, of course, have a list of all the high scores and perhaps a button to return to the menu screen. Each screen will have a different layout, different buttons to click, and different responses to different keyboard presses, but they will all need to be drawn at 60 FPS and interact in the same way with the game engine.</p>
			<p>In the previous projects, we crammed this concept of screens into one place. This meant we had sprawling long <strong class="source-inline">if</strong>, <strong class="source-inline">else</strong>, and <strong class="source-inline">else if</strong> blocks of code that handled updating, drawing, and responding to user interaction. Our code was getting quite challenging to handle already. If we are going to build more complicated games, we need to improve on this. The concept of screens means that we can create a class that handles all the stuff that happens for every screen, such as updating, drawing, and user interaction, and then create a derived class for each type of screen, that is, menu, game, high score, and so on, which handles the unique ways that a specific screen needs to update, draw, and respond to the user.</p>
			<p>In Space Invaders ++, we will have a <strong class="source-inline">Screen</strong> class. We will then inherit from <strong class="source-inline">Screen</strong> to handle two screens, <strong class="source-inline">SelectScreen</strong> and <strong class="source-inline">GameScreen</strong>. Furthermore, we will have a <strong class="source-inline">Button</strong> class that knows how to display a button, a <strong class="source-inline">UIPanel</strong> class that knows how to draw text, and <strong class="source-inline">Button</strong> instances as well as an <strong class="source-inline">InputHandler</strong> class that knows how to detect keyboard and gamepad interaction. We will then be able to derive from <strong class="source-inline">UIPanel</strong> and <strong class="source-inline">InputHandler</strong> to let all the different <strong class="source-inline">Screen</strong> instances behave exactly as required without coding the basics of a screen, a UI panel, an input handler, or a button more than once. The bigger your game gets and the more screens it has, the bigger the benefit of doing things this way. It also means that the specifics of each screen will not be crammed into long <strong class="source-inline">if</strong>, <strong class="source-inline">else</strong>, and <strong class="source-inline">else if</strong> structures as we have been doing so far.</p>
			<p>This is a bit like how we coded the <strong class="source-inline">PlayableCharacter</strong> class and derived <strong class="source-inline">Thomas</strong> and <strong class="source-inline">Bob</strong> from it. As we will see, however, we go much further with the abstraction this time. Look at the following diagram, which shows a representation of this idea and shows just one screen:</p>
			<div>
				<div id="_idContainer118" class="IMG---Figure">
					<img src="image/B14278_19_04.jpg" alt=""/>
				</div>
			</div>
			<p>In the preceding diagram, we can see that a screen has one or more <strong class="source-inline">UIPanel</strong> instances that it can display selectively and that <strong class="source-inline">UIPanel</strong> instances can have zero or more <strong class="source-inline">Button</strong> instances. Each <strong class="source-inline">UIPanel</strong> will have a related <strong class="source-inline">InputHandler</strong> because each <strong class="source-inline">UIPanel</strong> will have different combinations and layouts of buttons. The buttons are shared via pointers between <strong class="source-inline">UIPanel</strong> and <strong class="source-inline">InputHandler</strong> instances.</p>
			<p>If you are wondering which class handles the update stage of the game loop, the answer is the <strong class="source-inline">Screen</strong> class. However, once you get your head around how this pattern works, it will be simple to add the ability to let <strong class="source-inline">UIPanel</strong> instances act in the update phase, too. This could be useful if, say, the panel needed to move or maybe show a loading progress bar.</p>
			<p>A screen will decide which <strong class="source-inline">UIPanel</strong> (and therefore, <strong class="source-inline">InputHandler</strong>) instances are currently visible and responding. However, only one screen at a time will be visible to the player. We will code a <strong class="source-inline">ScreenManager</strong> class that will be a fundamental part of the game engine to handle calling the key functions of the appropriate (current) screen. The <strong class="source-inline">ScreenManager</strong> class will also provide a way for the <strong class="source-inline">InputHandler</strong> instances to notify us when a change of screen is required, for example, when the player clicks the <strong class="bold">Play</strong> button on the select screen to go to the play screen.</p>
			<p><strong class="source-inline">ScreenManager</strong> will hold an instance of every screen, remember the current screen the player is on, and call <strong class="source-inline">update</strong>, <strong class="source-inline">draw</strong>, and <strong class="source-inline">handleInput</strong> on the correct screen, as well as switch between screens when required. The following diagram will hopefully help you visualize this concept, which we will also be coding soon:</p>
			<div>
				<div id="_idContainer119" class="IMG---Figure">
					<img src="image/B14278_19_05.jpg" alt=""/>
				</div>
			</div>
			<p>Note that the diagrams and explanation are a simplification of the solution we will be coding, but they give a good overview.</p>
			<p>Should you want to add a high score screen or another <strong class="source-inline">UIPanel</strong> instance to an existing screen, you will know how to do so by the end of <a href="B14278_22_Final_AG_ePub.xhtml#_idTextAnchor445"><em class="italic">Chapter 22</em></a>,<em class="italic"> Using Game Objects and Building a Game</em>. Of course, it's likely that you will want to get started on your very own game. You will be able to divide up your next game into as many screens with their dedicated layouts and input handling as you need.</p>
			<h2 id="_idParaDest-364"><a id="_idTextAnchor377"/>Entity-Component pattern</h2>
			<p>We will now spend five minutes wallowing in the misery of an apparently unsolvable muddle. Then, we will see how the entity-component pattern comes to the rescue.</p>
			<h3>Why lots of diverse object types are hard to manage</h3>
			<p>In the previous projects, we coded a class for each object. We had classes such as Bat, Ball, Crawler, and Thomas. Then, in the <strong class="source-inline">update</strong> function, we would update them, and in the <strong class="source-inline">draw</strong> function, we would draw them. Each object decides how updating and drawing takes place.</p>
			<p>We could just get started and use this same structure for Space Invaders ++. It would work, but we are trying to learn something more manageable so that our games can grow in complexity.</p>
			<p>Another problem with this approach is that we cannot take advantage of inheritance. For example, all the invaders, the bullets, and the player draw themselves in an identical way, but unless we change how we do things, we will end up with three <strong class="source-inline">draw</strong> functions with nearly identical code. If we make a change to how we call the <strong class="source-inline">draw</strong> function or the way we handle graphics, we will need to update all three classes.</p>
			<p>There must be a better way.</p>
			<h3>Using a generic GameObject for better code structure</h3>
			<p>If every object, player, alien, and all the bullets were one generic type, then we could pack them away in a <strong class="source-inline">vector</strong> instance and loop through each of their <strong class="source-inline">update</strong> functions, followed by each of their <strong class="source-inline">draw</strong> functions.</p>
			<p>We already know one way of doing this – inheritance. At first glance, inheritance might seem like a perfect solution. We could create an abstract <strong class="source-inline">GameObject</strong> class and then extend it with the <strong class="source-inline">Player</strong>, <strong class="source-inline">Invader</strong>, and <strong class="source-inline">Bullet</strong> classes.</p>
			<p>The <strong class="source-inline">draw</strong> function, which is identical in all three classes, could remain in the parent class, and we won't have the problem of all that wasted duplicate code. Great!</p>
			<p>The problem with this approach is how varied – in some respects – the game objects are. Diversity is not a strength; it is just diverse. For example, all the object types move differently. The bullets go up or down, the invaders go left and right and drop down occasionally, and the player's ship responds to inputs.</p>
			<p>How would we put this kind of diversity into the <strong class="source-inline">update</strong> so that it could control this movement? Maybe we could use something like this:</p>
			<p class="source-code">update(){</p>
			<p class="source-code">   switch(objectType){</p>
			<p class="source-code">          case 1:</p>
			<p class="source-code">                // All the player's logic</p>
			<p class="source-code">                break;</p>
			<p class="source-code">          case 2:</p>
			<p class="source-code">                // All the invader's logic here</p>
			<p class="source-code">                Break;</p>
			<p class="source-code">          case 3:</p>
			<p class="source-code">                // All the bullet's logic here</p>
			<p class="source-code">                break;</p>
			<p class="source-code">   }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">update</strong> function alone would be bigger than the whole <strong class="source-inline">GameEngine</strong> class!</p>
			<p>As you may remember from <a href="B14278_15_Final_AG_ePub.xhtml#_idTextAnchor306"><em class="italic">Chapter 15</em></a>,<em class="italic"> Advanced OOP – Inheritance and Polymorphism</em>, when we inherit from a class, we can also override specific functions. This means we could have a different version of the <strong class="source-inline">update</strong> function for each object type. Unfortunately, however, there is also a problem with this approach as well.</p>
			<p>The <strong class="source-inline">GameEngine</strong> engine would have to "know" which type of object it was updating or, at the very least, be able to query the <strong class="source-inline">GameObject</strong> instance it was updating in order to call the correct version of the <strong class="source-inline">update</strong> function. What is really needed is for the <strong class="source-inline">GameObject</strong> to somehow internally choose which version of the update <strong class="source-inline">function</strong> is required.</p>
			<p>Unfortunately, even the part of the solution which did seem to work falls apart on closer inspection. I said that the code in the <strong class="source-inline">draw</strong> function was the same for all three of the objects, and therefore the <strong class="source-inline">draw</strong> function could be part of the parent class and used by all the sub-classes, instead of us having to code three separate <strong class="source-inline">draw</strong> functions. Well, what happens when we introduce a new object that needs to be drawn differently, such as an animated UFO that flies across the top of the screen? In this scenario, the draw solution falls apart too.</p>
			<p>Now that we have seen the problems that occur when objects are different from each other and yet cry out to be from the same parent class, it is time to look at the solution we will use in the Space Invaders ++ project.</p>
			<p>What we need is a new way of thinking about constructing all our game objects.</p>
			<h2 id="_idParaDest-365"><a id="_idTextAnchor378"/>Prefer composition over inheritance</h2>
			<p>Preferring composition over inheritance refers to the idea of composing objects with other objects. </p>
			<p class="callout-heading">Important note</p>
			<p class="callout">This concept was first suggested in the following publication:</p>
			<p class="callout"><em class="italic">Design Patterns: Elements of Reusable Object-Oriented Software</em></p>
			<p class="callout">by Erich Gamma, Richard Helm, et al.</p>
			<p>What if we could code a class (as opposed to a function) that handled how an object was drawn? Then for all the classes that draw themselves in the same way, we could instantiate one of these special drawing classes within the <strong class="source-inline">GameObject</strong>, and any objects that need to be drawn differently could have a different drawing object. Then, when a <strong class="source-inline">GameObject</strong> does something differently, we simply compose it with a different drawing or updating related class to suit it. All the similarities in all our objects can benefit from using the same code, while all the differences can benefit from not only being encapsulated but also abstracted (taken out of) the base class.</p>
			<p>Note that the heading of this section is composition over inheritance, not composition instead of inheritance. Composition doesn't replace inheritance and everything you learned in <a href="B14278_15_Final_AG_ePub.xhtml#_idTextAnchor306"><em class="italic">Chapter 15</em></a>,<em class="italic"> Advanced OOP – Inheritance and Polymorphism</em>, still holds true. However, where possible, compose instead of inheriting.</p>
			<p>The <strong class="source-inline">GameObject</strong> class is the entity, while the classes it will be composed of that do things such as update its position and draw it to the screen are the components, which is why it's called the Entity-Component pattern.</p>
			<p>Have a look at the following diagram, which represents the Entity-Component pattern in the form we will implement it in this project:</p>
			<div>
				<div id="_idContainer120" class="IMG---Figure">
					<img src="image/B14278_19_06.jpg" alt=""/>
				</div>
			</div>
			<p>In the preceding diagram, we can see that a <strong class="source-inline">GameObject</strong> instance is composed of multiple <strong class="source-inline">Component</strong> instances. There will be multiple different classes derived from the <strong class="source-inline">Component</strong> class, including <strong class="source-inline">UpdateComponent</strong> and <strong class="source-inline">GraphicsComponent</strong>. Furthermore, there can be further specific classes derived from them. For example, the <strong class="source-inline">BulletUpdateComponent</strong> and <strong class="source-inline">InvaderUpdateComponent</strong> classes will be derived from the <strong class="source-inline">UpdateComponent</strong> class. These classes will handle how a bullet and an invader (respectively) update themselves each frame of the game. This is great for encapsulation because we don't need the big <strong class="source-inline">switch</strong> blocks to distinguish between different objects. </p>
			<p>When we use composition over inheritance to create a group of classes that represent behavior/algorithms, as we will here, this is known as the <strong class="bold">Strategy</strong> pattern. You could use everything you have learned here and refer to it as the Strategy pattern. Entity-Component is a lesser known but more specific implementation, and that is why we call it this. The difference is academic, but feel free to turn to Google if you want to explore things further. In <a href="B14278_23_Final_AG_ePub.xhtml#_idTextAnchor457"><em class="italic">Chapter 23</em></a>, <em class="italic">Before You Go…,</em> I will show you some good resources for this kind of detailed research.</p>
			<p>The Entity-Component pattern, along with using composition in preference to inheritance, sounds great at first glance but brings with it some problems of its own. It would mean that our new <strong class="source-inline">GameObject</strong> class would need to know about all the different types of component and every single type of object in the game. How would it add all the correct components to itself?</p>
			<p>Let's have a look at the solution.</p>
			<h2 id="_idParaDest-366"><a id="_idTextAnchor379"/>Factory pattern</h2>
			<p>It is true that if we are to have this universal <strong class="source-inline">GameObject</strong> class that can be anything we want it to be, whether that be a bullet, player, invader, or whatever else, then we are going to have to code some logic that "knows" about constructing these super-flexible <strong class="source-inline">GameObject</strong> instances and composes them with the correct components. But adding all this code into the class itself would make it exceptionally unwieldy and defeat the entire reason for using the Entity-Component pattern in the first place.</p>
			<p>We would need a constructor that did something like this hypothetical <strong class="source-inline">GameObject</strong> code:</p>
			<p class="source-code">class GameObject</p>
			<p class="source-code">{</p>
			<p class="source-code">   UpdateComponent* m_UpdateComponent;</p>
			<p class="source-code">   GraphicsComponent* m_GraphicsComponent;</p>
			<p class="source-code">   // More components</p>
			<p class="source-code">   // The constructor</p>
			<p class="source-code">   GameObject(string type){</p>
			<p class="source-code">      if(type == "invader")</p>
			<p class="source-code">      {</p>
			<p class="source-code">            m_UpdateComp = new InvaderUpdateComponent();   </p>
			<p class="source-code">            m_GraphicsComponent = new StdGraphicsComponent();</p>
			<p class="source-code">      }</p>
			<p class="source-code">      else if(type =="ufo")</p>
			<p class="source-code">       {</p>
			<p class="source-code">              m_UpdateComponent = new </p>
			<p class="source-code">                   UFOUpdateComponentComponent();</p>
			<p class="source-code">              m_GraphicsComponent = new AnimGraphicsComponent();</p>
			<p class="source-code">       }</p>
			<p class="source-code">      // etc.</p>
			<p class="source-code">      …</p>
			<p class="source-code">   }</p>
			<p class="source-code">};</p>
			<p>The <strong class="source-inline">GameObject</strong> class would need to know not just which components go with which <strong class="source-inline">GameObject</strong> instance, but also which didn't need certain components, such as input-related components for controlling the player. For the Space Invaders ++ project, we could do this and just about survive the complexity, but just about surviving is not the objective; we want to take complete control.</p>
			<p>The <strong class="source-inline">GameObject</strong> class would also need to understand all this logic. Any benefit or efficiency gained from using composition over inheritance with the Entity-Component pattern would be mainly lost.</p>
			<p>Furthermore, what if we decide we want a new type of invader, perhaps a "Cloaker" alien that teleports near to the player, takes a shot, and then teleports away again? It is fine to code a new <strong class="source-inline">GraphicsComponent</strong> class, perhaps a <strong class="source-inline">CloakingGraphicsComponent</strong> that "knows" when it is visible and invisible, along with a new <strong class="source-inline">UpdateComponent</strong>, perhaps a <strong class="source-inline">CloakerUpdateComponent</strong> that teleports instead of moving in the conventional manner, but what is not fine is we are going to have to add a whole bunch of new <strong class="source-inline">if </strong>statements to the <strong class="source-inline">GameObject</strong> class constructor. </p>
			<p>In fact, the situation is even worse than this. What if we decide that regular invaders can now cloak? Invaders now need not just a different type of <strong class="source-inline">GraphicsComponent</strong> class. We would have to go back into the <strong class="source-inline">GameObject</strong> class to edit all of those <strong class="source-inline">if</strong> statements again. </p>
			<p>In fact, there are even more scenarios that can be imagined, and they all end up with a bigger and bigger <strong class="source-inline">GameObject</strong> class. The <strong class="bold">Factory</strong> pattern is the solution to these <strong class="source-inline">GameObject</strong> class-related woes and the perfect partner to the Entity-Component pattern.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">This implementation of the Factory pattern is an easier way to begin to learn about the Factory pattern. Why not do a web search for the Factory pattern once you have completed this project and see how it can be improved?</p>
			<p>The game designer will provide a specification for each and every type of object in the game, and the programmer will provide a factory class that builds <strong class="source-inline">GameObject</strong> instances from the game designer's specifications. When the game designer comes up with new ideas for entities, then all we need to do is ask for a new specification. Sometimes, that will involve adding a new production line to the factory that uses existing components and, sometimes, it will mean coding new components or perhaps updating existing components. The point is that it won't matter how inventive the game designer is – the <strong class="source-inline">GameObject</strong> and <strong class="source-inline">GameEngine</strong> classes remain unchanged.</p>
			<p>In the Factory code, the current object type is checked and the appropriate components (classes) are added to it. The bullet, player, and the invader have the same graphics component, but all have different update components. </p>
			<p>When we use composition, it can be less clear which class is responsible for the memory. Is it the class that creates it, the class that uses it, or some other class? Let's learn some more C++ to help us manage memory a little more simply.</p>
			<h1 id="_idParaDest-367"><a id="_idTextAnchor380"/>C++ smart pointers</h1>
			<p><strong class="bold">Smart pointers</strong> are classes that we can use to get the same functionality as a regular pointer but with an extra feature – the feature being that they take care of their own deletion. In the limited way we have used pointers so far, it has not been a problem for us to delete our own memory, but as your code becomes more complex, and when you are allocating the new memory in one class but using it in another class, it becomes much less clear which class is responsible for deleting the memory when we are done with it. And how can a class or function know whether a different class or function has finished with some allocated memory?</p>
			<p>The solution is smart pointers. There are a few types of smart pointer; we will look at the two of the most commonly used ones here. The key to success with smart pointers is using the correct type.</p>
			<p>The first type we will consider is <strong class="bold">shared pointers</strong>.</p>
			<h2 id="_idParaDest-368"><a id="_idTextAnchor381"/>Shared pointers</h2>
			<p>The way that a shared pointer can safely delete the memory it points to is by keeping a count of the number of different references there are to an area of memory. If you pass a pointer to a function, the count is increased by one. If you pack a pointer into a vector, the count is increased by one. If the function returns, the count is decreased by one. If the vector goes out of scope or has the <strong class="source-inline">clear</strong> function called on it, the smart pointer will reduce the reference count by one. When the reference count is zero, nothing points to the area of memory anymore and the smart pointer class calls <strong class="source-inline">delete</strong>. All the smart pointer classes are implemented using regular pointers behind the scenes. We just get the benefit of not having to concern ourselves about where or when to call <strong class="source-inline">delete</strong>. Let's look at the code for using a shared smart pointer.</p>
			<p>The following code creates a new shared smart pointer called <strong class="source-inline">myPointer</strong> that will point to an instance of <strong class="source-inline">MyClass</strong>:</p>
			<p class="source-code">shared_ptr&lt;MyClass&gt; myPointer;</p>
			<p><strong class="source-inline">shared_ptr&lt;MyClass&gt;</strong> is the type while  <strong class="source-inline">myPointer</strong> is its name. The following code is how we might initialize <strong class="source-inline">myPointer</strong>:</p>
			<p class="source-code"> myPointer = make_shared&lt;MyClass&gt;();</p>
			<p>The call to <strong class="source-inline">make_shared</strong> internally calls <strong class="source-inline">new</strong> to allocate the memory. The parentheses <strong class="source-inline">()</strong> is the constructor parentheses. If the <strong class="source-inline">MyClass</strong> class constructor took an <strong class="source-inline">int</strong> parameter, for example, the preceding code might look like this:</p>
			<p class="source-code">myPointer = make_shared&lt;MyClass&gt;(3);</p>
			<p>The <strong class="source-inline">3</strong> in the preceding code is an arbitrary example.</p>
			<p>Of course, you can declare and initialize your shared smart pointers in a single line of code if required, as shown in the following code:</p>
			<p class="source-code">shared_ptr&lt;MyClass&gt; myPointer = make_shared&lt;MyClass&gt;();</p>
			<p>It is because <strong class="source-inline">myPointer</strong> is a <strong class="source-inline">shared_ptr</strong> that it has an internal reference count that keeps track of how many references point to the area of memory that it created. If we make a copy of the pointer, that reference count is increased.</p>
			<p>Making a copy of the pointer includes passing the pointer to another function, placing it in a <strong class="source-inline">vector</strong>, <strong class="source-inline">map</strong>, or other structure, or simply copying it.</p>
			<p>We can use a smart pointer using the same syntax as a regular pointer. It is quite easy to forget sometimes that it isn't a regular pointer. The following code calls the <strong class="source-inline">myFunction</strong> function on <strong class="source-inline">myPointer</strong>:</p>
			<p class="source-code">myPointer-&gt;myFunction();</p>
			<p>By using a shared smart pointer, there is some performance and memory <strong class="bold">overhead</strong>. By overhead, I mean that our code runs slower and uses more memory. After all, the smart pointer needs a variable to keep track of the reference count, and it must check the value of the reference count every time a reference goes out of scope. However, this overhead is tiny and only an issue in the most extreme situations since  most of the overhead happens while the smart pointers are being created. Typically, we will create smart pointers outside of the game loop. Calling a function on a smart pointer is as efficient as a regular pointer.</p>
			<p>Sometimes, we know that we will only ever want one reference to a smart pointer and in this situation, <strong class="bold">unique</strong> <strong class="bold">pointers</strong> are the best option.</p>
			<h2 id="_idParaDest-369"><a id="_idTextAnchor382"/>Unique pointers</h2>
			<p>When we know that we only want a single reference to an area of memory, we can use a unique smart pointer. Unique pointers lose much of the overhead that I mentioned shared pointers have. In addition, if you try and make a copy of a unique pointer, the compiler will warn us, and the code will either not compile or it will crash, giving us a clear error. This is a very useful feature that can prevent us from accidentally copying a pointer that was not meant to be copied. You might be wondering if this no copying rule means we can never pass it to a function or even put it in a data structure such as a <strong class="source-inline">vector</strong>. To find out, let's look at some code for unique smart pointers and explore how they work.</p>
			<p>The following code creates a unique smart pointer called <strong class="source-inline">myPointer</strong> that points to an instance of <strong class="source-inline">MyClass</strong>:</p>
			<p class="source-code">unique_ptr&lt;MyClass&gt; myPointer = make_unique&lt;MyClass&gt;();</p>
			<p>Now. let's suppose we want to add a <strong class="source-inline">unique_ptr</strong> to a <strong class="source-inline">vector</strong>. The first thing to note is that <strong class="source-inline">vector</strong> must be of the correct type. The following code declares a <strong class="source-inline">vector</strong> that holds unique pointers to <strong class="source-inline">MyClass</strong> instances:</p>
			<p class="source-code">vector&lt;unique_ptr&lt;MyClass&gt;&gt; myVector;</p>
			<p>The <strong class="source-inline">vector</strong> is called <strong class="source-inline">myVector</strong> and anything you put into it must be of the unique pointer type to <strong class="source-inline">MyClass</strong>. But didn't I say that unique pointers can't be copied? When we know that we will only ever want a single refence to an area of memory, we should use <strong class="source-inline">unique_ptr</strong>. This doesn't mean, however, that the reference can't be moved. Here is an example:</p>
			<p class="source-code">// Use move() because otherwise </p>
			<p class="source-code">// the vector has a COPY which is not allowed</p>
			<p class="source-code">mVector.push_back(move(myPointer));</p>
			<p class="source-code">// mVector.push_back(myPointer); // Won't compile!</p>
			<p>In the preceding code, we can see that the <strong class="source-inline">move</strong> function can be used to put a unique smart pointer into a <strong class="source-inline">vector</strong>. Note that when you use the <strong class="source-inline">move</strong> function, you are not giving the compiler permission to break the rules and copy a unique pointer – you are moving responsibility from the <strong class="source-inline">myPointer</strong> variable to the <strong class="source-inline">myVector</strong> instance. If you attempt to use the <strong class="source-inline">myPointer</strong> variable after this point, the code will execute and the game will crash, giving you a <strong class="bold">Null pointer access violation error</strong>. The following code will cause a crash:</p>
			<p class="source-code">unique_ptr&lt;MyClass&gt; myPointer = make_unique&lt;MyClass&gt;();</p>
			<p class="source-code">vector&lt;unique_ptr&lt;MyClass&gt;&gt; myVector;</p>
			<p class="source-code">// Use move() because otherwise </p>
			<p class="source-code">// the vector has a COPY which is not allowed</p>
			<p class="source-code">mVector.push_back(move(myPointer));</p>
			<p class="source-code">// mVector.push_back(myPointer); // Won't compile!</p>
			<p class="source-code"><strong class="bold">myPointer-&gt;myFunction();// CRASH!!</strong></p>
			<p>The exact same rules apply when passing a unique pointer to a function; use the <strong class="source-inline">move</strong> function to pass responsibility on. We will look at all these scenarios again, as well as some more when we get to the project in a few pages time.</p>
			<h1 id="_idParaDest-370"><a id="_idTextAnchor383"/>Casting smart pointers</h1>
			<p>We will often want to pack the smart pointers of derived classes into data structures or function parameters of the base class such as all the different derived <strong class="source-inline">Component</strong> classes. This is the essence of polymorphism. Smart pointers can achieve this using casting. But what happens when we later need to access the functionality or data of the derived class?</p>
			<p>A good example of where this will regularly be necessary is when we deal with components inside our game objects. There will be an abstract <strong class="source-inline">Component</strong> class and derived from that there will be <strong class="source-inline">GraphicsComponent</strong>, <strong class="source-inline">UpdateComponent</strong>, and more besides. </p>
			<p>As an example, we will want to call the <strong class="source-inline">update</strong> function on all the <strong class="source-inline">UpdateComponent</strong> instances each frame of the game loop. But if all the components are stored as base class <strong class="source-inline">Component</strong> instances, then it might seem that we can't do this. Casting from the base class to a derived class solves this problem.</p>
			<p>The following code casts <strong class="source-inline">myComponent</strong>, which is a base class <strong class="source-inline">Component</strong> instance to an <strong class="source-inline">UpdateComponent</strong> class instance, which we can then call the <strong class="source-inline">update</strong> function on:</p>
			<p class="source-code">shared_ptr&lt;UpdateComponent&gt; myUpdateComponent =</p>
			<p class="source-code">                static_pointer_cast&lt;UpdateComponent&gt;(MyComponent);</p>
			<p>Before the equals sign, a new <strong class="source-inline">shared_ptr</strong> to an <strong class="source-inline">UpdateComponent</strong> instance is declared. After the equals sign, the <strong class="source-inline">static_pointer_cast</strong> function specifies the type to cast to in the angle brackets, <strong class="source-inline">&lt;UpdateComponent&gt;</strong>, and the instance to cast from in parentheses, <strong class="source-inline">(MyComponent)</strong>.</p>
			<p>We can now use all the functions of the <strong class="source-inline">UpdateComponent</strong> class, which in our project includes the <strong class="source-inline">update</strong> function. We would call the <strong class="source-inline">update</strong> function as follows:</p>
			<p class="source-code">myUpdateComponent-&gt;update(fps);</p>
			<p>There are two ways we can cast a class smart pointer to another class smart pointer. One is by using <strong class="source-inline">static_pointer_cast</strong>, as we have just seen, and the other is to use <strong class="source-inline">dynamic_pointer_cast</strong>. The difference is that <strong class="source-inline">dynamic_pointer_cast</strong> can be used if you are uncertain whether the cast will work. When you use <strong class="source-inline">dynamic_pointer_cast</strong>, you can then check to see if it worked by testing if the result is a null pointer. You use <strong class="source-inline">static_pointer_class</strong> when you are certain the result is the type you are casting to. We will use <strong class="source-inline">static_pointer_cast</strong> throughout the Space Invaders ++ project. </p>
			<p>We will regularly be casting <strong class="source-inline">Component</strong> instances to different derived types. How we will be sure the type we are casting to is the correct type will become apparent as we progress with the project.</p>
			<h1 id="_idParaDest-371"><a id="_idTextAnchor384"/>C++ assertions</h1>
			<p>In this project, we will be using C++ <strong class="bold">assertions</strong>. As usual, there is more to this topic than we will discuss here, but we can still do some useful things with just an introduction.</p>
			<p>We can use the <strong class="source-inline">#define</strong> preprocessor statement in a class to define a value for the entire project. We do so with the following code:</p>
			<p class="source-code">#define debuggingOnConsole</p>
			<p>This code would be written at the top of a header file. Now, throughout the project, we can write code like the following:</p>
			<p class="source-code">#ifdef debuggingOnConsole</p>
			<p class="source-code">    // C++ code goes here</p>
			<p class="source-code">#endif</p>
			<p>The <strong class="source-inline">#ifdef debuggingOnConsole</strong> statement checks whether the <strong class="source-inline">#define</strong> <strong class="source-inline">debuggingOnConsole</strong> statement is present. If it is, then any C++ code up to the <strong class="source-inline">#endif</strong> statement will be included in the game. We can then choose to comment out the <strong class="source-inline">#define</strong> statement to switch our debugging code on or off. </p>
			<p>Typically, we will include code such as the following in the <strong class="source-inline">#ifdef</strong> blocks:</p>
			<p class="source-code">#ifdef debuggingOnConsole         </p>
			<p class="source-code">        cout &lt;&lt; </p>
			<p class="source-code">            "Problem x occurred and caused a crash!" </p>
			<p class="source-code">            &lt;&lt; endl;</p>
			<p class="source-code">#endif</p>
			<p>The preceding code uses the <strong class="source-inline">cout</strong> statement to print debugging information to the console window.</p>
			<p>What these assertions amount to is a way to get feedback from the game during development and then with a quick <strong class="source-inline">//</strong> in front of the <strong class="source-inline">#define</strong> statement, strip out all the debugging code from the game when we are done.</p>
			<h1 id="_idParaDest-372"><a id="_idTextAnchor385"/>Creating the Space Invaders ++ project</h1>
			<p>You can find the runnable code that represents the project at the end of this chapter in the <strong class="source-inline">Space Invaders ++</strong> folder. It will take all of chapters 20, 21, and 22 to complete and make the project runnable again. The completed code that is runnable and represents the project at the end of <a href="B14278_22_Final_AG_ePub.xhtml#_idTextAnchor445"><em class="italic">Chapter 22</em></a>, <em class="italic">Using Game Objects and Building a Game</em>, can be found in the <strong class="source-inline">Space Invaders ++ 2</strong> folder.</p>
			<p>Create a new project in Visual Studio with the same settings that we used in the previous four projects. Call the new project <strong class="source-inline">Space Invaders ++</strong>.</p>
			<p>Inside the <strong class="source-inline">Space Invaders ++</strong> folder, copy and paste the <strong class="source-inline">fonts</strong>, <strong class="source-inline">graphics</strong>, and <strong class="source-inline">sound</strong> folders and their contents from the download bundle. The <strong class="source-inline">fonts</strong>, <strong class="source-inline">graphics</strong>, and <strong class="source-inline">sound</strong> folders, as you would expect, contain the font and graphical and audio assets we will use in this game. </p>
			<p>In addition, you will need to download the background file from <a href="https://opengameart.org/content/background-night">https://opengameart.org/content/background-night</a>.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">This image is the work of <a href="https://opengameart.org/users/alekei">https://opengameart.org/users/alekei</a>.</p>
			<p class="callout">You can download this from <a href="https://opengameart.org/content/background-night">https://opengameart.org/content/background-night</a>.</p>
			<p class="callout">You can find the license at <a href="https://creativecommons.org/licenses/by/3.0/">https://creativecommons.org/licenses/by/3.0/</a>.</p>
			<p>Rename the file you just downloaded to <strong class="source-inline">background.png</strong> and place it in the <strong class="source-inline">graphics</strong> folder of your project.</p>
			<p>Now, add the <strong class="source-inline">world</strong> folder, including the <strong class="source-inline">level1.txt</strong> file. This file contains the layout of all the game objects, and we will discuss it further in <a href="B14278_21_Final_AG_ePub.xhtml#_idTextAnchor432"><em class="italic">Chapter 21</em></a>, <em class="italic">File I/O and the Game Object Factory</em>.</p>
			<h2 id="_idParaDest-373"><a id="_idTextAnchor386"/>Organizing code files with filters</h2>
			<p>Next, we will do something new. As there are more class files in this project than our previous projects, we will be a bit more organized within Visual Studio. We will create a series of <strong class="bold">filters</strong>. These are logical organizers we use to create a structure for our files. This will allow us to view all our header and source files in a more organized way.</p>
			<p>Right-click on the <strong class="bold">Header Files</strong> folder in the <strong class="bold">Solution Explorer</strong> window and select <strong class="bold">New Filter</strong>. Give the filter the name of <strong class="source-inline">Engine</strong>. We will add all the core header files to this filter.</p>
			<p>Right-click on <strong class="bold">Header Files</strong> again and add another filter called <strong class="source-inline">FileIO</strong>. We will add all the files that read text to and from <strong class="source-inline">level1.txt</strong>, as well as some supporting classes.</p>
			<p>Make another new filter in <strong class="bold">Header Files</strong> called <strong class="source-inline">GameObjects</strong>. Everything related to all the game objects, including the <strong class="source-inline">GameObject</strong> class and all the <strong class="source-inline">Component</strong> class-related header files, will go here.</p>
			<p>Add yet another filter called <strong class="source-inline">Screens</strong>. Right-click on the <strong class="bold">Screens</strong> filter you just added and create a filter within <strong class="bold">Screens</strong> called <strong class="source-inline">Select</strong>. Now, create another filter within <strong class="bold">Screens</strong> called <strong class="source-inline">Game</strong>. We will place all the derived versions of <strong class="source-inline">Screen</strong>, <strong class="source-inline">InputHandler</strong>, and <strong class="source-inline">UIPanel</strong> in <strong class="bold">Game</strong> or <strong class="bold">Select</strong> (as appropriate) and all the base classes in <strong class="bold">Screens</strong>.</p>
			<p>Now, repeat all the previous steps of creating filters to create the exact same structure in the <strong class="bold">Source Files</strong> folder. You should now have a Solution Explorer layout that looks as follows:</p>
			<div>
				<div id="_idContainer121" class="IMG---Figure">
					<img src="image/B14278_19_07.jpg" alt=""/>
				</div>
			</div>
			<p>Note t<a id="_idTextAnchor387"/>hat the preceding layout is just for our organizational benefit; it has no effect on the code or the finished game. In fact, if you look in the <strong class="source-inline">Space Invaders ++</strong> folder using your operating system's file browser, you will see there are no additional folders. As we progress with this project and add new classes, we will add them within specific filters to make them more organized and less cluttered.</p>
			<h2 id="_idParaDest-374"><a id="_idTextAnchor388"/>Adding a DevelopState file</h2>
			<p>In order to output debugging data to the console, we will create the <strong class="source-inline">DevelopState</strong> class, which does nothing but define <strong class="source-inline">debuggingOnConsole</strong>. </p>
			<p>Create the <strong class="source-inline">DevelopState.h</strong> file in the <strong class="source-inline">Header Files/Engine</strong> filter and add the following code:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#define debuggingOnConsole</p>
			<p class="source-code">class DevelopState {};</p>
			<p>We can comment out <strong class="source-inline">#define debuggingOnConsole</strong> when the game is working but, when we have unexplained crashes, we can uncomment it. If we then add assertions at parts throughout our code, we can see if these parts are causing the game to crash.</p>
			<h2 id="_idParaDest-375"><a id="_idTextAnchor389"/>Coding SpaceInvaders ++.cpp</h2>
			<p>Next, drag and drop the <strong class="source-inline">SpaceInvaders ++.cpp</strong> file that was autogenerated when we created the project into the <strong class="source-inline">Source Files/Engine</strong> filter. This isn't required – it is just to keep things organized. This file is the entry point to the game and is therefore a core file, albeit a very short one.</p>
			<p>Edit <strong class="source-inline">SpaceInvaders ++.cpp</strong> so that it just has the following code:</p>
			<p class="source-code">#include "GameEngine.h"</p>
			<p class="source-code">int main()</p>
			<p class="source-code">{</p>
			<p class="source-code">    GameEngine m_GameEngine;</p>
			<p class="source-code">    m_GameEngine.run();</p>
			<p class="source-code">    return 0;</p>
			<p class="source-code">}</p>
			<p>The preceding code creates an instance of <strong class="source-inline">GameEngine</strong> and calls its <strong class="source-inline">run</strong> function. There will be errors until we code the <strong class="source-inline">GameEngine</strong> class. We will do that next. Note that, throughout this project, there will usually be one, more, or even many errors. This is due to the interdependent nature of the classes. I will usually mention when there are errors and when they will be dealt with, but perhaps not every single one. By the end of this chapter, we will have an error-free, executable project, but, after that, it will take until <a href="B14278_22_Final_AG_ePub.xhtml#_idTextAnchor445"><em class="italic">Chapter 22</em></a>, <em class="italic">Using Game Objects and Building a Game</em>, until the project is error-free and executable again.</p>
			<h2 id="_idParaDest-376"><a id="_idTextAnchor390"/>Coding the GameEngine class</h2>
			<p>Create a new header file in the <strong class="source-inline">Header Files/Engine</strong> filter called <strong class="source-inline">GameEngine.h</strong> and add the following code:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#include &lt;SFML/Graphics.hpp&gt;</p>
			<p class="source-code">#include "ScreenManager.h"</p>
			<p class="source-code">#include "SoundEngine.h"</p>
			<p class="source-code">using namespace sf;</p>
			<p class="source-code">class GameEngine {</p>
			<p class="source-code">private:</p>
			<p class="source-code">    Clock m_Clock;</p>
			<p class="source-code">    Time m_DT;</p>
			<p class="source-code">    RenderWindow m_Window;</p>
			<p class="source-code">    unique_ptr&lt;ScreenManager&gt; m_ScreenManager;</p>
			<p class="source-code">    float m_FPS = 0;</p>
			<p class="source-code">    Vector2f m_Resolution;</p>
			<p class="source-code">    void handleInput();</p>
			<p class="source-code">    void update();</p>
			<p class="source-code">    void draw();</p>
			<p class="source-code">public:</p>
			<p class="source-code">    SoundEngine m_SoundEngine;</p>
			<p class="source-code">    GameEngine();</p>
			<p class="source-code">    void run();</p>
			<p class="source-code">};</p>
			<p>Study the preceding code to get familiar with it. What's new is that we get to see smart pointers in action for the first time. We have a unique pointer of the <strong class="source-inline">ScreenManager</strong> Type. This implies that this pointer will not be passed to any other classes but, if it is, then ownership will also be passed.</p>
			<p>Other than the smart pointers, there is nothing we haven't seen before. There is a <strong class="source-inline">Clock</strong> instance, a <strong class="source-inline">Time</strong> instance, a <strong class="source-inline">RenderWindow</strong> instance, as well as variables to keep track of the frame rate and the screen resolution. Furthermore, we have functions for handling input, updating, and drawing each frame. This is also nothing new. What we do within these functions, however, will be new. We also have a <strong class="source-inline">SoundEngine</strong> instance, which will be nearly identical to how we handled sound in our other projects. We also have the <strong class="source-inline">run</strong> function, which is public, and will kickstart all the private functions.</p>
			<p>There are errors because we need to implement the <strong class="source-inline">ScreenManager</strong> and <strong class="source-inline">SoundEngine</strong> classes. We will get to them very soon.</p>
			<p>Create a new source file in the <strong class="source-inline">Source Files/Engine</strong> filter called <strong class="source-inline">GameEngine.cpp</strong> and add the following code:</p>
			<p class="source-code">#include "GameEngine.h"</p>
			<p class="source-code">GameEngine::GameEngine()</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_Resolution.x = VideoMode::getDesktopMode().width;</p>
			<p class="source-code">    m_Resolution.y = VideoMode::getDesktopMode().height;</p>
			<p class="source-code">    m_Window.create(VideoMode(m_Resolution.x, m_Resolution.y),</p>
			<p class="source-code">        "Space Invaders++", Style::Fullscreen);</p>
			<p class="source-code">    m_ScreenManager = unique_ptr&lt;ScreenManager&gt;(new ScreenManager(</p>
			<p class="source-code">        Vector2i(m_Resolution.x, m_Resolution.y)));</p>
			<p class="source-code">}</p>
			<p class="source-code">void GameEngine::run()</p>
			<p class="source-code">{</p>
			<p class="source-code">    while (m_Window.isOpen())</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_DT = m_Clock.restart();</p>
			<p class="source-code">        m_FPS = m_DT.asSeconds();</p>
			<p class="source-code">        handleInput();</p>
			<p class="source-code">        update();</p>
			<p class="source-code">        draw();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">void GameEngine::handleInput()</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_ScreenManager-&gt;handleInput(m_Window);</p>
			<p class="source-code">}</p>
			<p class="source-code">void GameEngine::update()</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_ScreenManager-&gt;update(m_FPS);</p>
			<p class="source-code">}</p>
			<p class="source-code">void GameEngine::draw()</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_Window.clear(Color::Black);</p>
			<p class="source-code">    m_ScreenManager-&gt;draw(m_Window);</p>
			<p class="source-code">    m_Window.display();</p>
			<p class="source-code">}</p>
			<p>In the <strong class="source-inline">GameEngine</strong> constructor, the <strong class="source-inline">RenderWindow</strong> instance is initialized and the unique smart pointer to a <strong class="source-inline">ScreenManager</strong> instance is initialized using <strong class="source-inline">new</strong>, which passes in the resolution to the <strong class="source-inline">ScreenManager</strong> constructor.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">This is an alternative to calling the <strong class="source-inline">make_unique</strong> function.</p>
			<p>The <strong class="source-inline">run</strong> function should look very familiar; it restarts the clock and stores the time like we have done in every project so far. It then calls the <strong class="source-inline">handleInput</strong>, <strong class="source-inline">update</strong>, and <strong class="source-inline">draw</strong> functions.</p>
			<p>In the <strong class="source-inline">handleInput</strong> function, the <strong class="source-inline">handleInput</strong> function of the <strong class="source-inline">ScreenManager</strong> instance is called. In the <strong class="source-inline">update</strong> function, the <strong class="source-inline">update</strong> function of the <strong class="source-inline">ScreenManger</strong> instance is called. Finally, in the <strong class="source-inline">draw</strong> function, the <strong class="source-inline">RenderWindow</strong> is cleared, the <strong class="source-inline">draw</strong> function of the <strong class="source-inline">ScreenManager</strong> instance is called, and the contents of the <strong class="source-inline">RenderWindow</strong> instance are displayed.</p>
			<p>We have successfully passed full responsibility to the <strong class="source-inline">ScreenManager</strong> class for handling input, updating, and drawing each frame. As we will see in the <em class="italic">Coding the ScreenManager</em> section, the <strong class="source-inline">ScreenManager</strong> class will further delegate responsibility for all these tasks to the appropriate class that's derived from the <strong class="source-inline">Screen</strong> class.</p>
			<p>Like the related <strong class="source-inline">GameEngine.h</strong> header file, there are errors because we need to implement the <strong class="source-inline">ScreenManager</strong> and <strong class="source-inline">SoundEngine</strong> classes.</p>
			<h2 id="_idParaDest-377"><a id="_idTextAnchor391"/>Coding the SoundEngine class</h2>
			<p>Create a new header file in the <strong class="source-inline">Header Files/Engine</strong> filter called <strong class="source-inline">SoundEngine.h</strong> and add the following code:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#ifndef SOUND_ENGINE_H</p>
			<p class="source-code">#define SOUND_ENGINE_H</p>
			<p class="source-code">#include &lt;SFML/Audio.hpp&gt;</p>
			<p class="source-code">using namespace sf;</p>
			<p class="source-code">class SoundEngine</p>
			<p class="source-code">{</p>
			<p class="source-code">private:</p>
			<p class="source-code">    SoundBuffer m_ShootBuffer;</p>
			<p class="source-code">    SoundBuffer m_PlayerExplodeBuffer;</p>
			<p class="source-code">    SoundBuffer m_InvaderExplodeBuffer;</p>
			<p class="source-code">    SoundBuffer m_ClickBuffer;</p>
			<p class="source-code">    Sound m_ShootSound;</p>
			<p class="source-code">    Sound m_PlayerExplodeSound;</p>
			<p class="source-code">    Sound m_InvaderExplodeSound;</p>
			<p class="source-code">    Sound m_UhSound;</p>
			<p class="source-code">    Sound m_OhSound;</p>
			<p class="source-code">    Sound m_ClickSound;</p>
			<p class="source-code">public:</p>
			<p class="source-code">    SoundEngine();</p>
			<p class="source-code">    static void playShoot();</p>
			<p class="source-code">    static void playPlayerExplode();</p>
			<p class="source-code">    static void playInvaderExplode();</p>
			<p class="source-code">    static void playClick();</p>
			<p class="source-code">    static SoundEngine* m_s_Instance;</p>
			<p class="source-code">};</p>
			<p class="source-code">#endif</p>
			<p>Create a new source file in the <strong class="source-inline">Source Files/Engine</strong> filter called <strong class="source-inline">SoundEngine.cpp</strong> and add the following code:</p>
			<p class="source-code">#include &lt;SFML/Audio.hpp&gt;</p>
			<p class="source-code">#include &lt;assert.h&gt;</p>
			<p class="source-code">#include "SoundEngine.h"</p>
			<p class="source-code">using namespace std;</p>
			<p class="source-code">using namespace sf;</p>
			<p class="source-code">SoundEngine* SoundEngine::m_s_Instance = nullptr;</p>
			<p class="source-code">SoundEngine::SoundEngine()</p>
			<p class="source-code">{</p>
			<p class="source-code">    assert(m_s_Instance == nullptr);</p>
			<p class="source-code">    m_s_Instance = this;</p>
			<p class="source-code">    // Load the sound into the buffers</p>
			<p class="source-code">    m_ShootBuffer.loadFromFile("sound/shoot.ogg");</p>
			<p class="source-code">    m_PlayerExplodeBuffer.loadFromFile("sound/playerexplode.ogg");</p>
			<p class="source-code">    m_InvaderExplodeBuffer.loadFromFile("sound/invaderexplode.ogg");</p>
			<p class="source-code">    m_ClickBuffer.loadFromFile("sound/click.ogg");</p>
			<p class="source-code">    // Associate the sounds with the buffers</p>
			<p class="source-code">    m_ShootSound.setBuffer(m_ShootBuffer);</p>
			<p class="source-code">    m_PlayerExplodeSound.setBuffer(m_PlayerExplodeBuffer);</p>
			<p class="source-code">    m_InvaderExplodeSound.setBuffer(m_InvaderExplodeBuffer);</p>
			<p class="source-code">    m_ClickSound.setBuffer(m_ClickBuffer);</p>
			<p class="source-code">}</p>
			<p class="source-code">void SoundEngine::playShoot()</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_s_Instance-&gt;m_ShootSound.play();</p>
			<p class="source-code">}</p>
			<p class="source-code">void SoundEngine::playPlayerExplode()</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_s_Instance-&gt;m_PlayerExplodeSound.play();</p>
			<p class="source-code">}</p>
			<p class="source-code">void SoundEngine::playInvaderExplode()</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_s_Instance-&gt;m_InvaderExplodeSound.play();</p>
			<p class="source-code">}</p>
			<p class="source-code">void SoundEngine::playClick()</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_s_Instance-&gt;m_ClickSound.play();</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">SoundEngine</strong> class uses the exact same strategy as the previous <strong class="source-inline">SoundManager</strong> class from the previous projects. In fact, <strong class="source-inline">SoundEngine</strong> is slightly simpler than <strong class="source-inline">SoundManager</strong> because we are not using spatialization features. For a refresher of how the <strong class="source-inline">SoundEngine</strong> class works, refer to <a href="B14278_17_Final_AG_ePub.xhtml#_idTextAnchor340"><em class="italic">Chapter 17</em></a>, <em class="italic">Sound Spatialization and the HUD</em>.</p>
			<p>Now, we can move on to the <strong class="source-inline">ScreenManager</strong> class.</p>
			<h2 id="_idParaDest-378"><a id="_idTextAnchor392"/>Coding the ScreenManager class</h2>
			<p>Create a new header file in the <strong class="source-inline">Header Files/Engine</strong> filter called <strong class="source-inline">ScreenManager.h</strong> and add the following code:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#include &lt;SFML/Graphics.hpp&gt;</p>
			<p class="source-code">#include &lt;map&gt;</p>
			<p class="source-code">#include "GameScreen.h"</p>
			<p class="source-code">#include "ScreenManagerRemoteControl.h"</p>
			<p class="source-code">#include "SelectScreen.h"</p>
			<p class="source-code">//#include "LevelManager.h"</p>
			<p class="source-code">#include "BitmapStore.h"</p>
			<p class="source-code">#include &lt;iostream&gt;</p>
			<p class="source-code">using namespace sf;</p>
			<p class="source-code">using namespace std;</p>
			<p class="source-code">class ScreenManager : public ScreenManagerRemoteControl {</p>
			<p class="source-code">private:</p>
			<p class="source-code">    map &lt;string, unique_ptr&lt;Screen&gt;&gt; m_Screens;</p>
			<p class="source-code">    //LevelManager m_LevelManager;</p>
			<p class="source-code">protected:</p>
			<p class="source-code">    string m_CurrentScreen = "Select";</p>
			<p class="source-code">public:</p>
			<p class="source-code">    BitmapStore m_BS;</p>
			<p class="source-code">    ScreenManager(Vector2i res);</p>
			<p class="source-code">    void update(float fps);</p>
			<p class="source-code">    void draw(RenderWindow&amp; window);</p>
			<p class="source-code">    void handleInput(RenderWindow&amp; window);</p>
			<p class="source-code">    /****************************************************</p>
			<p class="source-code">    *****************************************************</p>
			<p class="source-code">    From ScreenManagerRemoteControl interface</p>
			<p class="source-code">    *****************************************************</p>
			<p class="source-code">    *****************************************************/</p>
			<p class="source-code">    void ScreenManagerRemoteControl::</p>
			<p class="source-code">        SwitchScreens(string screenToSwitchTo)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_CurrentScreen = "" + screenToSwitchTo;</p>
			<p class="source-code">        m_Screens[m_CurrentScreen]-&gt;initialise();</p>
			<p class="source-code">    }</p>
			<p class="source-code">    void ScreenManagerRemoteControl::</p>
			<p class="source-code">        loadLevelInPlayMode(string screenToLoad)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        //m_LevelManager.getGameObjects().clear();</p>
			<p class="source-code">        //m_LevelManager.</p>
			<p class="source-code">            //loadGameObjectsForPlayMode(screenToLoad);</p>
			<p class="source-code">        SwitchScreens("Game");</p>
			<p class="source-code">    }</p>
			<p class="source-code">    //vector&lt;GameObject&gt;&amp; </p>
			<p class="source-code">        //ScreenManagerRemoteControl::getGameObjects()</p>
			<p class="source-code">    //{</p>
			<p class="source-code">        //return m_LevelManager.getGameObjects();</p>
			<p class="source-code">    //}</p>
			<p class="source-code">    //GameObjectSharer&amp; shareGameObjectSharer()</p>
			<p class="source-code">    //{</p>
			<p class="source-code">        //return m_LevelManager;</p>
			<p class="source-code">    //}</p>
			<p class="source-code">};</p>
			<p>In the previous code, there are some <strong class="source-inline">#include</strong> statements and some functions that have been commented out. This is because we will not be coding the <strong class="source-inline">LevelManager</strong> class until <a href="B14278_21_Final_AG_ePub.xhtml#_idTextAnchor432"><em class="italic">Chapter 21</em></a>, <em class="italic">File I/O and the Game Object Factory</em>.</p>
			<p>The next thing to notice is that <strong class="source-inline">ScreenManager</strong> inherits from <strong class="source-inline">ScreenManagerRemoteControl</strong>. More on this class shortly.</p>
			<p>We have coded a <strong class="source-inline">map</strong> with a key-value pair of <strong class="source-inline">string</strong> and a unique pointer to <strong class="source-inline">Screen</strong>. This will allow us to grab the functionality of a specific <strong class="source-inline">Screen</strong> instance by using the corresponding <strong class="source-inline">string</strong>. Next, we declare the <strong class="source-inline">string</strong> called <strong class="source-inline">m_CurrentScreen</strong> and initialize it to <strong class="source-inline">Select</strong>.</p>
			<p>Next, we declare an instance of <strong class="source-inline">BitmapStore</strong> called <strong class="source-inline">m_BS</strong>. This will be a slightly reworked version of the <strong class="source-inline">TextureHolder</strong> class that we saw in the two preceding projects. We will code the <strong class="source-inline">BitmapStore</strong> class next.</p>
			<p>Notice that the constructor for <strong class="source-inline">ScreenManager</strong> takes a <strong class="source-inline">Vector2i</strong> instance, which is what we should expect from when we initialized a <strong class="source-inline">ScreenManager</strong> instance in the <strong class="source-inline">GameEngine</strong> class.</p>
			<p>What follows is the <strong class="source-inline">update</strong>, <strong class="source-inline">draw</strong>, and <strong class="source-inline">handleInput</strong> function prototypes, which are called from the <strong class="source-inline">GameEngine</strong> class.</p>
			<p>The next two functions are the most interesting. Note that they are from the <strong class="source-inline">ScreenManagerRemoteControl</strong> class, which <strong class="source-inline">ScreenManager</strong> inherits from. These are pure virtual functions in <strong class="source-inline">ScreenManagerRemoteControl</strong> and we do things this way so that we can share some of the functionality of the <strong class="source-inline">ScreenManager</strong> class with other classes. We will code the <strong class="source-inline">ScreenManagerRemoteControl</strong> class in a couple of sections time. Remember that, when you inherit from a class that has pure virtual functions, you must implement the functions if you want to create an instance. Furthermore, the implementations should be contained in the same file as where the class is declared. There are four functions, two of which have been commented out for now. The two functions of immediate interest are <strong class="source-inline">SwitchScreens</strong> and <strong class="source-inline">loadLevelInPlayMode</strong>. </p>
			<p>The <strong class="source-inline">SwitchScreen</strong> function changes the value of <strong class="source-inline">m_CurrentScreen</strong>, while the <strong class="source-inline">loadLevelInPlayMode</strong> function has some temporarily commented out code and a single line of active code which calls <strong class="source-inline">SwitchScreens</strong> with the value of <strong class="source-inline">Game</strong>.</p>
			<p>Let's move on to the <strong class="source-inline">ScreenManager.cpp</strong> file so that we can look at all the function definitions.</p>
			<p>Create a new source file in the <strong class="source-inline">Source Files/Engine</strong> filter called <strong class="source-inline">ScreenManager.cpp</strong> and add the following code:</p>
			<p class="source-code">#include "ScreenManager.h"</p>
			<p class="source-code">ScreenManager::ScreenManager(Vector2i res)</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_Screens["Game"] = unique_ptr&lt;GameScreen&gt;(</p>
			<p class="source-code">        new GameScreen(this, res));</p>
			<p class="source-code">    m_Screens["Select"] = unique_ptr&lt;SelectScreen&gt;(</p>
			<p class="source-code">        new SelectScreen(this, res));</p>
			<p class="source-code">}</p>
			<p class="source-code">void ScreenManager::handleInput(RenderWindow&amp; window)</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_Screens[m_CurrentScreen]-&gt;handleInput(window);</p>
			<p class="source-code">}</p>
			<p class="source-code">void ScreenManager::update(float fps)</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_Screens[m_CurrentScreen]-&gt;update(fps);</p>
			<p class="source-code">}</p>
			<p class="source-code">void ScreenManager::draw(RenderWindow&amp; window)</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_Screens[m_CurrentScreen]-&gt;draw(window);</p>
			<p class="source-code">}</p>
			<p>In the preceding code, the constructor adds two <strong class="source-inline">Screen</strong> instances to the <strong class="source-inline">map</strong> instance – first, a <strong class="source-inline">GameScreen</strong> instance with a key of <strong class="source-inline">"Game"</strong> and then a <strong class="source-inline">SelectScreen</strong> instance with a key of <strong class="source-inline">"Select"</strong>. The three functions, <strong class="source-inline">handleInput</strong>, <strong class="source-inline">update</strong>, and <strong class="source-inline">draw</strong>, use whatever the current screen is, use the corresponding <strong class="source-inline">Screen</strong> instance, and call its <strong class="source-inline">handleInput</strong>, <strong class="source-inline">update</strong>, and <strong class="source-inline">draw</strong> functions.</p>
			<p>When the game is executed for the first time, the versions of these functions from <strong class="source-inline">SelectScreen</strong> will be called, but if the <strong class="source-inline">ChangeScreen</strong> or <strong class="source-inline">loadLevelInPlayMode</strong> function was called, then then <strong class="source-inline">handleInput</strong>, <strong class="source-inline">update</strong>, and <strong class="source-inline">draw</strong> could be called on the <strong class="source-inline">GameScreen</strong> instance from the <strong class="source-inline">map</strong>. You can add as many different types of <strong class="source-inline">Screen</strong> instance to the map as you like. I recommend that you complete the Space Invaders ++ project before you start doing your own customizations or start your own game, however.</p>
			<h2 id="_idParaDest-379"><a id="_idTextAnchor393"/>Coding the BitmapStore class</h2>
			<p>Create a new header file in the <strong class="source-inline">Header Files/Engine</strong> filter called <strong class="source-inline">BitmapStore.h</strong> and add the following code:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#ifndef BITMAP_STORE_H</p>
			<p class="source-code">#define BITMAP_STORE_H</p>
			<p class="source-code">#include &lt;SFML/Graphics.hpp&gt;</p>
			<p class="source-code">#include &lt;map&gt;</p>
			<p class="source-code">class BitmapStore</p>
			<p class="source-code">{</p>
			<p class="source-code">private:</p>
			<p class="source-code">    std::map&lt;std::string, sf::Texture&gt; m_BitmapsMap;</p>
			<p class="source-code">    static BitmapStore* m_s_Instance;</p>
			<p class="source-code">public:</p>
			<p class="source-code">    BitmapStore();</p>
			<p class="source-code">    static sf::Texture&amp; getBitmap(std::string const&amp; filename);</p>
			<p class="source-code">    static void addBitmap(std::string const&amp; filename);</p>
			<p class="source-code">};</p>
			<p class="source-code">#endif</p>
			<p>Create a new source file in the <strong class="source-inline">Source Files/Engine</strong> filter called <strong class="source-inline">BitmapStore.cpp</strong> and add the following code:</p>
			<p class="source-code">#include "BitmapStore.h"</p>
			<p class="source-code">#include &lt;assert.h&gt;</p>
			<p class="source-code">using namespace sf;</p>
			<p class="source-code">using namespace std;</p>
			<p class="source-code">BitmapStore* BitmapStore::m_s_Instance = nullptr;</p>
			<p class="source-code">BitmapStore::BitmapStore()</p>
			<p class="source-code">{</p>
			<p class="source-code">    assert(m_s_Instance == nullptr);</p>
			<p class="source-code">    m_s_Instance = this;</p>
			<p class="source-code">}</p>
			<p class="source-code">void BitmapStore::addBitmap(std::string const&amp; filename)</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Get a reference to m_Textures using m_S_Instance</p>
			<p class="source-code">    auto&amp; bitmapsMap = m_s_Instance-&gt;m_BitmapsMap;</p>
			<p class="source-code">    // auto is the equivalent of map&lt;string, Texture&gt;</p>
			<p class="source-code">    // Create an iterator to hold a key-value-pair (kvp)</p>
			<p class="source-code">    // and search for the required kvp</p>
			<p class="source-code">    // using the passed in file name</p>
			<p class="source-code">    auto keyValuePair = bitmapsMap.find(filename);</p>
			<p class="source-code">    // auto is equivalent of map&lt;string, Texture&gt;::iterator</p>
			<p class="source-code">    // No match found so save the texture in the map</p>
			<p class="source-code">    if (keyValuePair == bitmapsMap.end())</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // Create a new key value pair using the filename</p>
			<p class="source-code">        auto&amp; texture = bitmapsMap[filename];</p>
			<p class="source-code">        // Load the texture from file in the usual way</p>
			<p class="source-code">        texture.loadFromFile(filename);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">sf::Texture&amp; BitmapStore::getBitmap(std::string const&amp; filename)</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Get a reference to m_Textures using m_S_Instance</p>
			<p class="source-code">    auto&amp; m = m_s_Instance-&gt;m_BitmapsMap;</p>
			<p class="source-code">    // auto is the equivalent of map&lt;string, Texture&gt;</p>
			<p class="source-code">    // Create an iterator to hold a key-value-pair (kvp)</p>
			<p class="source-code">    // and search for the required kvp</p>
			<p class="source-code">    // using the passed in file name</p>
			<p class="source-code">    auto keyValuePair = m.find(filename);</p>
			<p class="source-code">    // auto is equivalent of map&lt;string, Texture&gt;::iterator    </p>
			<p class="source-code">    // Did we find a match?</p>
			<p class="source-code">    if (keyValuePair != m.end())</p>
			<p class="source-code">    {</p>
			<p class="source-code">        return keyValuePair-&gt;second;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    else</p>
			<p class="source-code">    {</p>
			<p class="source-code">#ifdef debuggingOnConsole         </p>
			<p class="source-code">        cout &lt;&lt; </p>
			<p class="source-code">            "BitmapStore::getBitmap()Texture not found Crrrashh!" </p>
			<p class="source-code">            &lt;&lt; endl;</p>
			<p class="source-code">#endif</p>
			<p class="source-code">        return keyValuePair-&gt;second;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The preceding code is almost a copy and paste from the <strong class="source-inline">BitmapStore</strong> class from the previous two projects, except for the final <strong class="source-inline">else</strong> block. Inside the final <strong class="source-inline">else</strong> block, we use C++ assertions for the first time to output the name of the requested texture to the console in the event that the texture isn't found. This only happens when <strong class="source-inline">debuggingOnConsole</strong> is defined. Note that this would also crash the game.</p>
			<h2 id="_idParaDest-380"><a id="_idTextAnchor394"/>Coding the ScreenManagerRemoteControl class</h2>
			<p>Create a new header file in the <strong class="source-inline">Header Files/Screens</strong> filter called <strong class="source-inline">ScreenManagerRemoteControl.h</strong> and add the following code:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#include &lt;string&gt;</p>
			<p class="source-code">#include &lt;vector&gt;</p>
			<p class="source-code">//#include "GameObject.h"</p>
			<p class="source-code">//#include "GameObjectSharer.h"</p>
			<p class="source-code">using namespace std;</p>
			<p class="source-code">class ScreenManagerRemoteControl</p>
			<p class="source-code">{</p>
			<p class="source-code">public:</p>
			<p class="source-code">    virtual void SwitchScreens(string screenToSwitchTo) = 0;</p>
			<p class="source-code">    virtual void loadLevelInPlayMode(string screenToLoad) = 0;</p>
			<p class="source-code">    //virtual vector&lt;GameObject&gt;&amp; getGameObjects() = 0;</p>
			<p class="source-code">    //virtual GameObjectSharer&amp; shareGameObjectSharer() = 0;</p>
			<p class="source-code">};</p>
			<p>Note in the previous code, that there are some <strong class="source-inline">#include</strong> statements and some functions that have been commented out. This is because we will not be coding the <strong class="source-inline">GameObject</strong> and <strong class="source-inline">GameObjectSharer</strong> classes until the next chapter.</p>
			<p>The rest of the code is for the prototypes that match the definitions we saw previously in the <strong class="source-inline">ScreenManager.h</strong> file. As you have come to expect, all the functions are pure virtual and therefore must be implemented by any class we wish to have an instance of.</p>
			<p>Create a new source file in the <strong class="source-inline">Source Files/Screens</strong> filter called <strong class="source-inline">ScreenManagerRemoteControl.cpp</strong> and add the following code:</p>
			<p class="source-code">/*********************************</p>
			<p class="source-code">******THIS IS AN INTERFACE********</p>
			<p class="source-code">*********************************/</p>
			<p>This code file is empty because all the code is in the <strong class="source-inline">.h</strong> file. In fact, you don't need to create this file, but I always find it a handy reminder in case I forget that all the functions for the class are pure virtual and waste time looking for the <strong class="source-inline">.cpp</strong> file, which doesn't exist.</p>
			<h1 id="_idParaDest-381"><a id="_idTextAnchor395"/>Where are we now?</h1>
			<p>At this stage, the only remaining errors in the code are the errors that refer to the <strong class="source-inline">SelectScreen</strong> class and the <strong class="source-inline">GameScreen</strong> class. It is going to take quite a bit of work to get rid of these errors and have a runnable program. The reason for this is that <strong class="source-inline">SelectScreen</strong> and <strong class="source-inline">GameScreen</strong> are derived from <strong class="source-inline">Screen</strong> and, in turn, the <strong class="source-inline">Screen</strong> class is also dependent on <strong class="source-inline">InputHandler</strong>, <strong class="source-inline">UIPanel</strong>, and <strong class="source-inline">Button</strong>. We will get to them next.</p>
			<h1 id="_idParaDest-382"><a id="_idTextAnchor396"/>Coding the Screen class and its dependents</h1>
			<p>What we will do now is code all the screen-related classes. In addition, each of the screens from our game will have their own specific implementation of all these classes. </p>
			<p>Next, we will code all the base classes; <strong class="source-inline">Screen</strong>, <strong class="source-inline">InputHandler</strong>, <strong class="source-inline">UIPanel</strong>, and <strong class="source-inline">Button</strong>. Following that, we will do the full implementation of the <strong class="source-inline">SelectScreen</strong> derivations of these classes and a partial implementation of the <strong class="source-inline">GameScreen</strong> derivations. At this point, we will be able to run the game and see our screens, UI panels, and buttons in action, and also be able to switch between screens. In the next chapter, we will work on the game properly and implement <strong class="source-inline">GameObject</strong> and <strong class="source-inline">LevelManager</strong>. In <a href="B14278_22_Final_AG_ePub.xhtml#_idTextAnchor445"><em class="italic">Chapter 22</em></a>, <em class="italic">Using Game Objects and Building a Game, </em>we will see how we can use them all in the <strong class="source-inline">GameScreen</strong> class.</p>
			<h2 id="_idParaDest-383"><a id="_idTextAnchor397"/>Coding the Button class</h2>
			<p>Create a new header file in the <strong class="source-inline">Header Files/Screens</strong> filter called <strong class="source-inline">Button.h</strong> and add the following code:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#include &lt;SFML/Graphics.hpp&gt;</p>
			<p class="source-code">using namespace sf;</p>
			<p class="source-code">class Button</p>
			<p class="source-code">{</p>
			<p class="source-code">private:</p>
			<p class="source-code">    RectangleShape m_Button;</p>
			<p class="source-code">    Text m_ButtonText;</p>
			<p class="source-code">    Font m_Font;</p>
			<p class="source-code">public:</p>
			<p class="source-code">    std::string m_Text;</p>
			<p class="source-code">    FloatRect m_Collider;</p>
			<p class="source-code">    Button(Vector2f position, </p>
			<p class="source-code">        float width, float height, </p>
			<p class="source-code">        int red, int green, int blue, </p>
			<p class="source-code">        std::string text);</p>
			<p class="source-code">    void draw(RenderWindow&amp; window);</p>
			<p class="source-code">};</p>
			<p>As you can see from the preceding code, a button will be visually represented by an SFML <strong class="source-inline">RectangleShape</strong> instance and an SFML <strong class="source-inline">Text</strong> instance. Also note that there is a <strong class="source-inline">FloatRect</strong> instance named <strong class="source-inline">m_Collider</strong> that will be used to detect mouse clicks on the button. The constructor will receive arguments to configure the position, size, color, and text of the button. The button will draw itself once each frame of the game loop and has a <strong class="source-inline">draw</strong> function that receives a <strong class="source-inline">RenderWindow</strong> reference to enable this.</p>
			<p>Create a new source file in the <strong class="source-inline">Source Files/Screens</strong> filter called <strong class="source-inline">Button.cpp</strong> and add the following code:</p>
			<p class="source-code">#include "Button.h"</p>
			<p class="source-code">Button::Button(Vector2f position, </p>
			<p class="source-code">    float width, float height, </p>
			<p class="source-code">    int red, int green, int blue, </p>
			<p class="source-code">    std::string text)</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_Button.setPosition(position);</p>
			<p class="source-code">    m_Button.setFillColor(sf::Color(red, green, blue));</p>
			<p class="source-code">    m_Button.setSize(Vector2f(width, height));</p>
			<p class="source-code">    m_Text = "" + text;</p>
			<p class="source-code">    float textPaddingX = width /10;</p>
			<p class="source-code">    float textPaddingY= height / 10;</p>
			<p class="source-code">    m_ButtonText.setCharacterSize(height * .7f);</p>
			<p class="source-code">    m_ButtonText.setString(text);</p>
			<p class="source-code">    m_Font.loadFromFile("fonts/Roboto-Bold.ttf");</p>
			<p class="source-code">    m_ButtonText.setFont(m_Font);</p>
			<p class="source-code">    m_ButtonText.setPosition(Vector2f((position.x + textPaddingX),</p>
			<p class="source-code">        (position.y + textPaddingY)));</p>
			<p class="source-code">    m_Collider = FloatRect(position, Vector2f(width, height));</p>
			<p class="source-code">}</p>
			<p class="source-code">void Button::draw(RenderWindow&amp; window)</p>
			<p class="source-code">{</p>
			<p class="source-code">    window.draw(m_Button);</p>
			<p class="source-code">    window.draw(m_ButtonText);</p>
			<p class="source-code">}</p>
			<p>Most of the action takes place in the constructor, and there is nothing we haven't seen already on numerous occasions in all the other projects. The button is prepared to be drawn using all the values that are passed into the constructor.</p>
			<p>The <strong class="source-inline">draw</strong> function uses the <strong class="source-inline">RenderWindow</strong> reference to draw the previously configured <strong class="source-inline">Text</strong> instance on top of the previously configured <strong class="source-inline">RectangleShape</strong> instance.</p>
			<h2 id="_idParaDest-384"><a id="_idTextAnchor398"/>Coding the UIPanel class</h2>
			<p>Create a new header file in the <strong class="source-inline">Header Files/Screens</strong> filter called <strong class="source-inline">UIPanel.h</strong> and add the following code:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#include &lt;SFML/Graphics.hpp&gt;</p>
			<p class="source-code">#include "Button.h"</p>
			<p class="source-code">using namespace std;</p>
			<p class="source-code">class UIPanel {</p>
			<p class="source-code">private:</p>
			<p class="source-code">    RectangleShape m_UIPanel;</p>
			<p class="source-code">    bool m_Hidden = false;</p>
			<p class="source-code">    vector&lt;shared_ptr&lt;Button&gt;&gt; m_Buttons;</p>
			<p class="source-code">protected:</p>
			<p class="source-code">    float m_ButtonWidth = 0;</p>
			<p class="source-code">    float m_ButtonHeight = 0;</p>
			<p class="source-code">    float m_ButtonPadding = 0;</p>
			<p class="source-code">    Font m_Font;</p>
			<p class="source-code">    Text m_Text;</p>
			<p class="source-code">    void addButton(float x, float y, int width, int height,</p>
			<p class="source-code">        int red, int green, int blue,</p>
			<p class="source-code">        string label);</p>
			<p class="source-code">    </p>
			<p class="source-code">public:</p>
			<p class="source-code">    View m_View;</p>
			<p class="source-code">    UIPanel(Vector2i res, int x, int y, </p>
			<p class="source-code">        float width, float height, </p>
			<p class="source-code">        int alpha, int red, int green, int blue);</p>
			<p class="source-code">    vector&lt;shared_ptr&lt;Button&gt;&gt; getButtons();</p>
			<p class="source-code">    virtual void draw(RenderWindow&amp; window);</p>
			<p class="source-code">    void show();</p>
			<p class="source-code">    void hide();</p>
			<p class="source-code">};</p>
			<p>The <strong class="source-inline">private</strong> section of the <strong class="source-inline">UIPanel</strong> class consists of a <strong class="source-inline">RectangleShape</strong> that will visually represent the background of the panel, a Boolean to keep track of whether the panel is currently visible to the player, and a <strong class="source-inline">vector</strong> of smart pointers to hold all the <strong class="source-inline">Button</strong> instances for this panel. Note that the smart pointers are of the shared variety so that we can pass them around and let the <strong class="source-inline">shared_pointer</strong> class take care of counting the references and deleting the memory when necessary.</p>
			<p>In the <strong class="source-inline">protected</strong> section, there are member variables for remembering the size and spacing of the buttons, as well as a <strong class="source-inline">Text</strong> and a <strong class="source-inline">Font</strong> instance for drawing text on the panel. All the panels in this project have just one <strong class="source-inline">Text</strong> instance, but specific derived classes are free to add extra members as they need. For example, a <strong class="source-inline">HighScoreUIPanel</strong> class might need a <strong class="source-inline">vector</strong> full of <strong class="source-inline">Text</strong> instances to draw a list of the highest scores.</p>
			<p>There is also an <strong class="source-inline">addButton</strong> function, and it is this function that will call the <strong class="source-inline">Button</strong> class constructor and add the instances to the <strong class="source-inline">vector</strong>.</p>
			<p>In the <strong class="source-inline">public</strong> section, we can see that every <strong class="source-inline">UIPanel</strong> instance will have its own <strong class="source-inline">View</strong> instance. This enables every panel and screen to configure its <strong class="source-inline">View</strong> however it likes. All the <strong class="source-inline">View</strong> instances will be drawn to and added to <strong class="source-inline">RenderWindow</strong> in layers.</p>
			<p>The <strong class="source-inline">UIPanel</strong> constructor receives all the necessary sizes and colors to configure its <strong class="source-inline">RectangleShape</strong>. The <strong class="source-inline">getButtons</strong> function shares the <strong class="source-inline">vector</strong> of <strong class="source-inline">Button</strong> instances so that other classes can interact with the buttons. For example, the <strong class="source-inline">InputHandler</strong> class will need the buttons to detect mouse clicks on them. This is why we used shared smart pointers.</p>
			<p>The <strong class="source-inline">draw</strong> function, of course, is called once each frame of the game loop and is <strong class="source-inline">virtual</strong>, so it can be optionally overridden and customized by derived classes. The <strong class="source-inline">show</strong> and <strong class="source-inline">hide</strong> functions will toggle the value of <strong class="source-inline">m_Hidden</strong> to keep track of whether this panel is currently visible to the player.</p>
			<p>Create a new source file in the <strong class="source-inline">Source Files/Screens</strong> filter called <strong class="source-inline">UIPanel.cpp</strong> and add the following code:</p>
			<p class="source-code">#include "UIPanel.h"</p>
			<p class="source-code">UIPanel::UIPanel(Vector2i res, int x, int y, </p>
			<p class="source-code">    float width, float height, </p>
			<p class="source-code">    int alpha, int red, int green, int blue)</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_UIPanel.setFillColor(sf::Color(red, green, blue, alpha));</p>
			<p class="source-code">    // How big in pixels is the UI panel</p>
			<p class="source-code">    m_UIPanel.setSize(Vector2f(width, height));</p>
			<p class="source-code">    // How big in pixels is the view</p>
			<p class="source-code">    m_View.setSize(Vector2f(width, height));</p>
			<p class="source-code">    </p>
			<p class="source-code">    // Where in pixels does the center of the view focus</p>
			<p class="source-code">    // This is most relevant when drawing a portion </p>
			<p class="source-code">   // of the game world</p>
			<p class="source-code">    // width/2, height/2 ensures it is exactly centered around the</p>
			<p class="source-code">    // RectangleShape, mUIPanel</p>
			<p class="source-code">    m_View.setCenter(width / 2, height / 2);</p>
			<p class="source-code">    // Where in the window is the view positioned?</p>
			<p class="source-code">    float viewportStartX = 1.f / (res.x / x);</p>
			<p class="source-code">    float viewportStartY = 1.f / (res.y / y);</p>
			<p class="source-code">    float viewportSizeX = 1.f / (res.x / width);</p>
			<p class="source-code">    float viewportSizeY = 1.f / (res.y / height);</p>
			<p class="source-code">    // Params from left to right</p>
			<p class="source-code">    // StartX as a fraction of 1, startY as a fraction of 1 </p>
			<p class="source-code">    // SizeX as a fraction of 1</p>
			<p class="source-code">    // SizeY as a fraction of 1</p>
			<p class="source-code">    m_View.setViewport(FloatRect(viewportStartX, viewportStartY, </p>
			<p class="source-code">        viewportSizeX, viewportSizeY));</p>
			<p class="source-code">}</p>
			<p class="source-code">vector&lt;shared_ptr&lt;Button&gt;&gt; UIPanel::getButtons()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_Buttons;</p>
			<p class="source-code">}</p>
			<p class="source-code">void UIPanel::addButton(float x, float y, </p>
			<p class="source-code">    int width, int height,</p>
			<p class="source-code">    int red, int green, int blue,</p>
			<p class="source-code">    string label)</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_Buttons.push_back(make_shared&lt;Button&gt;(Vector2f(x, y), </p>
			<p class="source-code">        width, height,</p>
			<p class="source-code">        red, green, blue, </p>
			<p class="source-code">        label));</p>
			<p class="source-code">}</p>
			<p class="source-code">void UIPanel::draw(RenderWindow &amp; window)</p>
			<p class="source-code">{</p>
			<p class="source-code">    window.setView(m_View);</p>
			<p class="source-code">    if (!m_Hidden) {</p>
			<p class="source-code">        window.draw(m_UIPanel);</p>
			<p class="source-code">        for (auto it = m_Buttons.begin(); </p>
			<p class="source-code">            it != m_Buttons.end(); ++it)</p>
			<p class="source-code">        {</p>
			<p class="source-code">            (*it)-&gt;draw(window);</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">void UIPanel::show()</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_Hidden = false;</p>
			<p class="source-code">}</p>
			<p class="source-code">void UIPanel::hide()</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_Hidden = true;</p>
			<p class="source-code">}</p>
			<p>In the constructor, the <strong class="source-inline">RectangleShape</strong> instance is scaled, colored, and positioned. The <strong class="source-inline">View</strong> instance is scaled to the size of the panel as well. The <strong class="source-inline">setViewport</strong> function of the <strong class="source-inline">View</strong> class is used along with some extra calculations to make sure the <strong class="source-inline">View</strong> takes up the correct proportion of the screen relative to the resolution and will therefore look approximately the same on screens of varying resolutions.</p>
			<p>The <strong class="source-inline">getButtons</strong> function simply returns the <strong class="source-inline">vector</strong> of buttons to the calling code. The <strong class="source-inline">addButtons</strong> function uses the <strong class="source-inline">make_shared</strong> function to allocate new <strong class="source-inline">Button</strong> instances on the heap and place them into the <strong class="source-inline">vector</strong>.</p>
			<p>The <strong class="source-inline">draw</strong> function uses the <strong class="source-inline">setView</strong> function to make the specific <strong class="source-inline">View</strong> instance of this panel the one that is drawn upon. Next, there's <strong class="source-inline">RectangleShape</strong>, which represents that this panel is drawn. Then, each of the buttons in the <strong class="source-inline">vector</strong> are looped through and drawn on top of the <strong class="source-inline">RectangleShape</strong>. All this drawing will only happen if <strong class="source-inline">m_Hidden</strong> is false.</p>
			<p>The <strong class="source-inline">show</strong> and <strong class="source-inline">hide</strong> functions allow users of the class to toggle <strong class="source-inline">m_Hidden</strong>.</p>
			<h2 id="_idParaDest-385"><a id="_idTextAnchor399"/>Coding the InputHandler class</h2>
			<p>Create a new header file in the <strong class="source-inline">Header Files/Screens</strong> filter called <strong class="source-inline">InputHandler.h</strong> and add the following code:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#include &lt;SFML/Graphics.hpp&gt;</p>
			<p class="source-code">#include &lt;vector&gt;</p>
			<p class="source-code">#include "Button.h"</p>
			<p class="source-code">#include "Screen.h"</p>
			<p class="source-code">#include "ScreenManagerRemoteControl.h"</p>
			<p class="source-code">using namespace sf;</p>
			<p class="source-code">using namespace std;</p>
			<p class="source-code">class Screen;</p>
			<p class="source-code">class InputHandler</p>
			<p class="source-code">{</p>
			<p class="source-code">private:</p>
			<p class="source-code">    Screen* m_ParentScreen;</p>
			<p class="source-code">    vector&lt;shared_ptr&lt;Button&gt;&gt; m_Buttons;</p>
			<p class="source-code">    View* m_PointerToUIPanelView;</p>
			<p class="source-code">    ScreenManagerRemoteControl* m_ScreenManagerRemoteControl;</p>
			<p class="source-code">public:</p>
			<p class="source-code">    void initialiseInputHandler(</p>
			<p class="source-code">        ScreenManagerRemoteControl* sw, </p>
			<p class="source-code">        vector&lt;shared_ptr&lt;Button&gt;&gt;,</p>
			<p class="source-code">        View* pointerToUIView, </p>
			<p class="source-code">        Screen* parentScreen);</p>
			<p class="source-code">    void handleInput(RenderWindow&amp; window, Event&amp; event);</p>
			<p class="source-code">    virtual void handleGamepad();</p>
			<p class="source-code">    virtual void handleKeyPressed(Event&amp; event, </p>
			<p class="source-code">        RenderWindow&amp; window);</p>
			<p class="source-code">    virtual void handleKeyReleased(Event&amp; event, </p>
			<p class="source-code">        RenderWindow&amp; window);</p>
			<p class="source-code">    virtual void handleLeftClick(string&amp; buttonInteractedWith, </p>
			<p class="source-code">        RenderWindow&amp; window);</p>
			<p class="source-code">    View* getPointerToUIView();</p>
			<p class="source-code">    ScreenManagerRemoteControl* </p>
			<p class="source-code">        getPointerToScreenManagerRemoteControl();</p>
			<p class="source-code">    Screen* getmParentScreen();</p>
			<p class="source-code">};</p>
			<p>There is an error in this file because the <strong class="source-inline">Screen</strong> class doesn't exist yet. </p>
			<p>First, study the <strong class="source-inline">private</strong> section of this header file. Each <strong class="source-inline">InputHandler</strong> instance will hold a pointer to the screen that holds it. This will be useful in a few situations we will come across as the project continues. There is also a <strong class="source-inline">vector</strong> of shared smart pointers to <strong class="source-inline">Button</strong> instances. These are the same <strong class="source-inline">Button</strong> instances that are in the <strong class="source-inline">UIPanel</strong> we just coded. Each derived <strong class="source-inline">UIPanel</strong> will have a matching derived <strong class="source-inline">InputHandler</strong> with which it shares a <strong class="source-inline">vector</strong> of buttons.</p>
			<p>The <strong class="source-inline">InputHandler</strong> class also holds a pointer to the <strong class="source-inline">View</strong> instance in the <strong class="source-inline">UIPanel</strong>. When we code the function definitions in <strong class="source-inline">InputHandler.cpp</strong>, we will see how we get this pointer and how it is useful.</p>
			<p>There is also a pointer to <strong class="source-inline">ScreenManagerRemoteControl</strong>. Remember from the <strong class="source-inline">ScreenManager</strong> class that we have implemented some functions from <strong class="source-inline">ScreenManagerRemoteControl</strong>. This is what will give us access to functions such as <strong class="source-inline">SwitchScreen</strong>. This is very useful when you consider that <strong class="source-inline">InputHandler</strong> is the class where we will be detecting button clicks. Of course, we need to see how we can initialize this pointer to make it usable. We will see how in the <strong class="source-inline">InputHandler.cpp</strong> file soon.</p>
			<p>In the <strong class="source-inline">public</strong> section, there is an <strong class="source-inline">initialiseInputHandler</strong> function. This is where the <strong class="source-inline">private</strong> members we have just talked about will be prepared for use. Look at the parameters; they match the types of the private members exactly.</p>
			<p>Next is the <strong class="source-inline">handleInput</strong> function. Remember that this is called once per frame by the <strong class="source-inline">GameEngine</strong> class; the <strong class="source-inline">ScreenManager</strong> calls it on the current screen and the <strong class="source-inline">Screen</strong> class (coded next), in turn, will call it on all <strong class="source-inline">InputHandler</strong> instances that it holds. It receives a <strong class="source-inline">RenderWindow</strong> and an <strong class="source-inline">Event</strong> instance.</p>
			<p>Next, there are four <strong class="source-inline">virtual</strong> functions which each derived from the <strong class="source-inline">InputHandler</strong> class that it can optionally override if it needs to. They are as follows:</p>
			<ul>
				<li><strong class="source-inline">handleGamepad</strong></li>
				<li><strong class="source-inline">handleKeyPressed</strong></li>
				<li><strong class="source-inline">handleKeyReleased</strong></li>
				<li><strong class="source-inline">handleLeftClick</strong></li>
			</ul>
			<p>As we will see shortly, in the <strong class="source-inline">InputHandler.cpp</strong> file, the <strong class="source-inline">handleInput</strong> function will loop through the data in <strong class="source-inline">Event</strong>, just as we have done so often before. But then, instead of handling all the events directly as we have done in the past, it will delegate a response to one of the four virtual functions. The derived classes will then receive only the events and data they have decided they want to handle. Default and empty definitions of the four virtual functions are provided in the <strong class="source-inline">InputHandler.cpp</strong> file.</p>
			<p>The <strong class="source-inline">getPointerToUIView</strong> function will return the pointer to the panels <strong class="source-inline">View</strong> that this <strong class="source-inline">InputHandler</strong> instance holds. We will see shortly that we need <strong class="source-inline">View</strong> in order to do mouse click collision detection on the buttons.</p>
			<p><strong class="source-inline">getPointerToScreenManagerRemoteControl</strong> and <strong class="source-inline">getmParentScreen</strong> return pointers to the member variables that are suggested by the names of the functions.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Note that, if you make the private data protected, then the derived <strong class="source-inline">InputHandler</strong> classes can access the data without going through the functions we have just discussed. When the project is complete, feel free to revisit this section and change this if you wish.</p>
			<p>Now, we can code all the function definitions.</p>
			<p>Create a new source file in the <strong class="source-inline">Source Files/Screens</strong> filter called <strong class="source-inline">InputHandler.cpp</strong> and add the following code:</p>
			<p class="source-code">#include &lt;sstream&gt;</p>
			<p class="source-code">#include "InputHandler.h"</p>
			<p class="source-code">using namespace sf;</p>
			<p class="source-code">using namespace std;</p>
			<p class="source-code">void InputHandler::initialiseInputHandler(</p>
			<p class="source-code">    ScreenManagerRemoteControl* sw, </p>
			<p class="source-code">    vector&lt;shared_ptr&lt;Button&gt;&gt; buttons,</p>
			<p class="source-code">    View* pointerToUIView, </p>
			<p class="source-code">    Screen* parentScreen)</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_ScreenManagerRemoteControl = sw;</p>
			<p class="source-code">    m_Buttons = buttons;</p>
			<p class="source-code">    m_PointerToUIPanelView = pointerToUIView;</p>
			<p class="source-code">    m_ParentScreen = parentScreen;</p>
			<p class="source-code">}</p>
			<p class="source-code">void InputHandler::handleInput(RenderWindow&amp; window, </p>
			<p class="source-code">    Event&amp; event)</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Handle any key presses</p>
			<p class="source-code">    if (event.type == Event::KeyPressed)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        handleKeyPressed(event, window);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    if (event.type == Event::KeyReleased)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        handleKeyReleased(event, window);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    // Handle any left mouse click released</p>
			<p class="source-code">    if (event.type == Event::MouseButtonReleased)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        auto end = m_Buttons.end();</p>
			<p class="source-code">        for (auto i = m_Buttons.begin();</p>
			<p class="source-code">            i != end;</p>
			<p class="source-code">            ++i) {</p>
			<p class="source-code">            if ((*i)-&gt;m_Collider.contains(</p>
			<p class="source-code">                window.mapPixelToCoords(Mouse::getPosition(), </p>
			<p class="source-code">                (*getPointerToUIView()))))</p>
			<p class="source-code">            {</p>
			<p class="source-code">                // Capture the text of the button that was interacted </p>
			<p class="source-code">                // with and pass it to the specialised version </p>
			<p class="source-code">                // of this class if implemented</p>
			<p class="source-code">                handleLeftClick((*i)-&gt;m_Text, window);</p>
			<p class="source-code">                break;</p>
			<p class="source-code">            }</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    handleGamepad();    </p>
			<p class="source-code">}</p>
			<p class="source-code">void InputHandler::handleGamepad()</p>
			<p class="source-code">{}// Do nothing unless handled by a derived class</p>
			<p class="source-code">void InputHandler::handleKeyPressed(Event&amp; event, </p>
			<p class="source-code">    RenderWindow&amp; window)</p>
			<p class="source-code">{}// Do nothing unless handled by a derived class</p>
			<p class="source-code">void InputHandler::handleKeyReleased(Event&amp; event, </p>
			<p class="source-code">    RenderWindow&amp; window)</p>
			<p class="source-code">{}// Do nothing unless handled by a derived class</p>
			<p class="source-code">void InputHandler::handleLeftClick(std::</p>
			<p class="source-code">    string&amp; buttonInteractedWith, </p>
			<p class="source-code">    RenderWindow&amp; window)</p>
			<p class="source-code">{}// Do nothing unless handled by a derived class</p>
			<p class="source-code">View* InputHandler::getPointerToUIView()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_PointerToUIPanelView;</p>
			<p class="source-code">}</p>
			<p class="source-code">ScreenManagerRemoteControl* </p>
			<p class="source-code">    InputHandler::getPointerToScreenManagerRemoteControl()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_ScreenManagerRemoteControl;</p>
			<p class="source-code">}</p>
			<p class="source-code">Screen* InputHandler::getmParentScreen() {</p>
			<p class="source-code">    return m_ParentScreen;</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">initialiseInputHandler</strong> function initializes the private data, as we have already discussed, the four <strong class="source-inline">virtual</strong> functions are empty, as expected, and the getter functions return pointers to the private members, just like we said they would.</p>
			<p>The interesting function definition is the <strong class="source-inline">handleInput</strong> function, so let's go through it.</p>
			<p>There is a series of <strong class="source-inline">if</strong> statements, which should look familiar from previous projects. Each <strong class="source-inline">if</strong> statement tests for a different type of event, such as a key being pressed or a key being released. Instead of handling the event, however, the appropriate <strong class="source-inline">virtual</strong> function is called. If the derived <strong class="source-inline">InputHandler</strong> class overrides the <strong class="source-inline">virtual</strong> function, it will receive the data and get to handle the event. If it doesn't, then the empty default function definition is called, and nothing happens. </p>
			<p>When the <strong class="source-inline">MouseButtonReleased</strong> event occurs, each of the <strong class="source-inline">Button</strong> instances in the <strong class="source-inline">vector</strong> is tested to see if the click occurred within the button. This is achieved using the <strong class="source-inline">contains</strong> function on the collider in each button and passing in the position of the mouse click. Note that the button coordinates are relative to the panels <strong class="source-inline">View</strong> and not the screen coordinates. For this reason, the <strong class="source-inline">mapPixelToCoords</strong> function is used to convert the screen coordinates of the mouse click into the corresponding coordinates of the <strong class="source-inline">View</strong>.</p>
			<p>When a collision is detected, the <strong class="source-inline">handleLeftClick virtual</strong> function is called and the text from the button is passed in. The derived <strong class="source-inline">InputHandler</strong> classes will handle what happens on a button click based on the text of the button.</p>
			<p>The final line of code in the <strong class="source-inline">handleInput</strong> function calls the final <strong class="source-inline">virtual</strong> function called <strong class="source-inline">handleGamepad</strong>. Any derived <strong class="source-inline">InputHandler</strong> classes that implement this function will get a chance to respond to the player's actions with the gamepad. In this project, only <strong class="source-inline">GameInputHandler</strong> will be concerned with what the gamepad is doing. You could adapt the project to allow the player to use the gamepad to navigate the menus of the other screen if you want to.</p>
			<h2 id="_idParaDest-386"><a id="_idTextAnchor400"/>Coding the Screen class</h2>
			<p>Create a new header file in the <strong class="source-inline">Header Files/Screens</strong> filter called <strong class="source-inline">Screen.h</strong> and add the following code:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#include &lt;SFML/Graphics.hpp&gt;</p>
			<p class="source-code">#include &lt;vector&gt;</p>
			<p class="source-code">#include "InputHandler.h"</p>
			<p class="source-code">#include "UIPanel.h"</p>
			<p class="source-code">#include "ScreenManagerRemoteControl.h"</p>
			<p class="source-code">class InputHandler;</p>
			<p class="source-code">class Screen {</p>
			<p class="source-code">private:</p>
			<p class="source-code">    vector&lt;shared_ptr&lt;InputHandler&gt;&gt; m_InputHandlers;</p>
			<p class="source-code">    vector&lt;unique_ptr&lt;UIPanel&gt;&gt; m_Panels;</p>
			<p class="source-code">protected:</p>
			<p class="source-code">    void addPanel(unique_ptr&lt;UIPanel&gt; p, </p>
			<p class="source-code">        ScreenManagerRemoteControl* smrc, </p>
			<p class="source-code">        shared_ptr&lt;InputHandler&gt; ih);</p>
			<p class="source-code">    </p>
			<p class="source-code">public:</p>
			<p class="source-code">    virtual void initialise();</p>
			<p class="source-code">    void virtual update(float fps);</p>
			<p class="source-code">    void virtual draw(RenderWindow&amp; window);</p>
			<p class="source-code">    void handleInput(RenderWindow&amp; window);</p>
			<p class="source-code">    View m_View;</p>
			<p class="source-code">};</p>
			<p>In the <strong class="source-inline">private</strong> section of the preceding code, there is a vector of shared smart pointers to <strong class="source-inline">InputHandler</strong> instances. This is where we will store all the derived <strong class="source-inline">InputHandler</strong> instances. <strong class="source-inline">SelectScreen</strong> will actually only have one <strong class="source-inline">InputHandler</strong>, while <strong class="source-inline">GameScreen</strong> will have two, but you can have as many as you like. Consider, for example, a hypothetical settings screen where you might have options for graphics, sound, controller, gameplay, and so on. Each of these options could then be clicked to reveal a unique <strong class="source-inline">UIPanel</strong> instance with a related <strong class="source-inline">InputHandler</strong>. So, we could have avoided using a <strong class="source-inline">vector</strong> for this project, but any significant project would almost certainly need a <strong class="source-inline">vector</strong> eventually. The smart pointers are of the shared variety, indicating we will be passing the contents via a function at some point.</p>
			<p>The next member is a <strong class="source-inline">vector</strong> of unique smart pointers to <strong class="source-inline">UIPanel</strong> instances. This is where all the derived <strong class="source-inline">UIPanel</strong> instances will go. The unique variety of pointer indicates we will not share the pointers; if we do, we will have to transfer responsibility.</p>
			<p>In the protected section is the <strong class="source-inline">addPanel</strong> function, which is where a <strong class="source-inline">Screen</strong> will pass in all the details of a new <strong class="source-inline">UIPanel</strong> instance, including its related <strong class="source-inline">InputHandler</strong>. Note the parameter to receive a <strong class="source-inline">ScreenManagerRemoteControl</strong> pointer; remember that this is required for passing to <strong class="source-inline">InputHandler</strong>.</p>
			<p>There is an <strong class="source-inline">initialise</strong> function as well, which we will see the purpose of shortly. The final three functions are the <strong class="source-inline">virtual</strong> functions, that is, <strong class="source-inline">update</strong>, <strong class="source-inline">draw</strong> and <strong class="source-inline">handleInput</strong>, which the derived <strong class="source-inline">Screen</strong> classes can override as they see fit.</p>
			<p>Finally, take note of the <strong class="source-inline">View</strong> instance. Every <strong class="source-inline">Screen</strong> instance will also have its own <strong class="source-inline">View</strong> instance to draw to, just like each <strong class="source-inline">UIPanel</strong> does.</p>
			<p>Let's take a look at the implementation of the functions we have just discussed.</p>
			<p>Create a new source file in the <strong class="source-inline">Source Files/Screens</strong> filter called <strong class="source-inline">Screen.cpp</strong> and add the following code:</p>
			<p class="source-code">#include "Screen.h"</p>
			<p class="source-code">void Screen::initialise(){}</p>
			<p class="source-code">void Screen::addPanel(unique_ptr&lt;UIPanel&gt; uip, </p>
			<p class="source-code">    ScreenManagerRemoteControl* smrc, </p>
			<p class="source-code">    shared_ptr&lt;InputHandler&gt; ih)</p>
			<p class="source-code">{</p>
			<p class="source-code">    ih-&gt;initialiseInputHandler(smrc, </p>
			<p class="source-code">        uip-&gt;getButtons(), &amp;uip-&gt;m_View, this);</p>
			<p class="source-code">    // Use move() because otherwise </p>
			<p class="source-code">    // the vector has a COPY which is not allowed</p>
			<p class="source-code">    m_Panels.push_back(move(uip));        </p>
			<p class="source-code">    m_InputHandlers.push_back(ih);</p>
			<p class="source-code">}</p>
			<p class="source-code">void Screen::handleInput(RenderWindow&amp; window)</p>
			<p class="source-code">{</p>
			<p class="source-code">    Event event;</p>
			<p class="source-code">    auto itr = m_InputHandlers.begin();</p>
			<p class="source-code">    auto end = m_InputHandlers.end();</p>
			<p class="source-code">    while (window.pollEvent(event))</p>
			<p class="source-code">    {</p>
			<p class="source-code">        for (itr;</p>
			<p class="source-code">            itr != end;</p>
			<p class="source-code">            ++itr)</p>
			<p class="source-code">        {</p>
			<p class="source-code">            (*itr)-&gt;handleInput(window, event);</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">void Screen::update(float fps){}</p>
			<p class="source-code">void Screen::draw(RenderWindow&amp; window)</p>
			<p class="source-code">{    </p>
			<p class="source-code">    auto itr = m_Panels.begin();</p>
			<p class="source-code">    auto end = m_Panels.end();</p>
			<p class="source-code">    for (itr;</p>
			<p class="source-code">        itr != end;</p>
			<p class="source-code">        ++itr)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        (*itr)-&gt;draw(window);</p>
			<p class="source-code">    }    </p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">initialise</strong> function is empty. It is designed to be overridden.</p>
			<p>The <strong class="source-inline">addPanel</strong> function, as we already know, stores the <strong class="source-inline">InputHandler</strong> and <strong class="source-inline">UIPanel</strong> instances that are passed to it. When an <strong class="source-inline">InputHandler</strong> is passed in, the <strong class="source-inline">initialiseInputHandler</strong> function is called and three things are passed in. First is the <strong class="source-inline">vector</strong> of <strong class="source-inline">Button</strong> instances, next is the <strong class="source-inline">View</strong> instance from the related <strong class="source-inline">UIPanel</strong> instance, and third is the <strong class="source-inline">this</strong> argument. In the current context, <strong class="source-inline">this</strong> is a pointer to the <strong class="source-inline">Screen</strong> instance itself. Why not refer to the <strong class="source-inline">InputHandler</strong> class and verify that these arguments are correct and what happens to them?</p>
			<p>Next, the panel and the input handler are added to the appropriate <strong class="source-inline">vector</strong>. Something interesting happens, however, if you look closely. Take another look at the line of code which adds the <strong class="source-inline">UIPanel</strong> instance called <strong class="source-inline">uip</strong> to the <strong class="source-inline">m_Panels</strong> vector:</p>
			<p class="source-code">m_Panels.push_back(move(uip));</p>
			<p>The argument that's passed to <strong class="source-inline">push_back</strong> is encased in a call to <strong class="source-inline">move</strong>. This transfers responsibility for the unique pointer to the <strong class="source-inline">UIPanel</strong> in the <strong class="source-inline">vector</strong>. Any attempt to use <strong class="source-inline">uip</strong> after this point will result in a read access violation because <strong class="source-inline">uip</strong> is now a null pointer. The pointer in <strong class="source-inline">m_Panels</strong>, however, is good to go. You will probably agree that this is simpler than using a regular pointer and working out where to delete it.</p>
			<p>The <strong class="source-inline">handleInput</strong> function loops through every event, passing it in to each <strong class="source-inline">InputHandler</strong> in turn.</p>
			<p>The <strong class="source-inline">update</strong> function has no functionality in the base class and is empty.</p>
			<p>The <strong class="source-inline">draw</strong> function loops through every <strong class="source-inline">UIPanel</strong> instance and calls their <strong class="source-inline">draw</strong> functions.</p>
			<p>Now, we are ready to code all the derived classes. We will start with the select screen (<strong class="source-inline">SelectScreen</strong>) and then move on to the game screen (<strong class="source-inline">GameScreen</strong>). We will add one more quick class first, though.</p>
			<h1 id="_idParaDest-387"><a id="_idTextAnchor401"/>Adding the WorldState.h file</h1>
			<p>Create a new header file in the <strong class="source-inline">Header Files/Engine</strong> filter called <strong class="source-inline">WorldState.h</strong> and add the following code:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">class WorldState</p>
			<p class="source-code">{</p>
			<p class="source-code">public:</p>
			<p class="source-code">    static const int WORLD_WIDTH = 100;</p>
			<p class="source-code">    static int WORLD_HEIGHT;</p>
			<p class="source-code">    static int SCORE;</p>
			<p class="source-code">    static int LIVES;</p>
			<p class="source-code">    static int NUM_INVADERS_AT_START;</p>
			<p class="source-code">    static int NUM_INVADERS;</p>
			<p class="source-code">    static int WAVE_NUMBER;</p>
			<p class="source-code">};</p>
			<p>These variables are public and static. As a result, they will be accessible throughout the project and are guaranteed to have only a single instance.</p>
			<h1 id="_idParaDest-388"><a id="_idTextAnchor402"/>Coding the derived classes for the select screen </h1>
			<p>So far, we have coded the fundamental classes that represent the user interface, as well as the logical division of our game into screens. Next, we will code specific implementations of each of them. Remember that Space Invaders ++ will have two screens: select and game. The select screen will be represented by the <strong class="source-inline">SelectScreen</strong> class and will have a single <strong class="source-inline">UIPanel</strong> instance, a single <strong class="source-inline">InputHandler</strong> instance, and two buttons. The play screen will be represented by the <strong class="source-inline">GameScreen</strong> class and it will have two <strong class="source-inline">UIPanel</strong> instances. One is called <strong class="source-inline">GameUIPanel</strong> and will display the score, lives, and invader wave number. The other is called <strong class="source-inline">GameOverUIPanel</strong> and will display two buttons, giving the player the option to go back to the select screen or play again. As the <strong class="source-inline">GameScreen</strong> class is composed of two <strong class="source-inline">UIPanel</strong> instances, it will also be composed of two <strong class="source-inline">InputHandler</strong> instances.</p>
			<h2 id="_idParaDest-389"><a id="_idTextAnchor403"/>Coding the SelectScreen class</h2>
			<p>Create a new header file in the <strong class="source-inline">Header Files/Screens/Select</strong> filter called <strong class="source-inline">SelectScreen.h</strong> and add the following code:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#include "Screen.h"</p>
			<p class="source-code">class SelectScreen : public Screen</p>
			<p class="source-code">{</p>
			<p class="source-code">private:</p>
			<p class="source-code">    ScreenManagerRemoteControl* m_ScreenManagerRemoteControl;</p>
			<p class="source-code">    Texture m_BackgroundTexture;</p>
			<p class="source-code">    Sprite m_BackgroundSprite;</p>
			<p class="source-code">public:</p>
			<p class="source-code">    SelectScreen(ScreenManagerRemoteControl* smrc, Vector2i res);</p>
			<p class="source-code">    void virtual draw(RenderWindow&amp; window);</p>
			<p class="source-code">};</p>
			<p>The <strong class="source-inline">SelectScreen</strong> class inherits from <strong class="source-inline">Screen</strong>. In the <strong class="source-inline">private</strong> section of the preceding code, there is a <strong class="source-inline">ScreenManagerRemoteControl</strong> pointer for switching screens, as well as a <strong class="source-inline">Texture</strong> instance and <strong class="source-inline">Sprite</strong> instance for drawing a background.</p>
			<p>In the <strong class="source-inline">public</strong> section, we can see the constructor and the prototype that overrides the <strong class="source-inline">draw</strong> function. The <strong class="source-inline">SelectScreen</strong> class does not need to override the <strong class="source-inline">update</strong> function.</p>
			<p>Create a new source file in the <strong class="source-inline">Source Files/Screens/Select</strong> filter called <strong class="source-inline">SelectScreen.cpp</strong> and add the following code:</p>
			<p class="source-code">#include "SelectScreen.h"</p>
			<p class="source-code">#include "SelectUIPanel.h"</p>
			<p class="source-code">#include "SelectInputHandler.h"</p>
			<p class="source-code">SelectScreen::SelectScreen(</p>
			<p class="source-code">    ScreenManagerRemoteControl* smrc, Vector2i res)</p>
			<p class="source-code">{</p>
			<p class="source-code">    auto suip = make_unique&lt;SelectUIPanel&gt;(res);</p>
			<p class="source-code">    auto sih = make_shared&lt;SelectInputHandler&gt;();</p>
			<p class="source-code">    addPanel(move(suip), smrc, sih);</p>
			<p class="source-code">    m_ScreenManagerRemoteControl = smrc;</p>
			<p class="source-code">    m_BackgroundTexture.loadFromFile("graphics/background.png");</p>
			<p class="source-code">    m_BackgroundSprite.setTexture(m_BackgroundTexture);</p>
			<p class="source-code">    auto textureSize = m_BackgroundSprite.</p>
			<p class="source-code">        getTexture()-&gt;getSize();</p>
			<p class="source-code">        </p>
			<p class="source-code">    m_BackgroundSprite.setScale(float(</p>
			<p class="source-code">        m_View.getSize().x) / textureSize.x,        </p>
			<p class="source-code">        float(m_View.getSize().y) / textureSize.y);</p>
			<p class="source-code">}</p>
			<p class="source-code">void SelectScreen::draw(RenderWindow&amp; window)</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Change to this screen's view to draw</p>
			<p class="source-code">    window.setView(m_View);</p>
			<p class="source-code">    window.draw(m_BackgroundSprite);</p>
			<p class="source-code">    // Draw the UIPanel view(s)</p>
			<p class="source-code">    Screen::draw(window);</p>
			<p class="source-code">}</p>
			<p>In the constructor, the purpose of all the coding so far begins to come together. The <strong class="source-inline">make_unique</strong> function is used to create a unique smart pointer to a <strong class="source-inline">SelectUIPanel</strong> instance. We will code <strong class="source-inline">SelectUIPanel</strong> in a couple of sections time. Next, the <strong class="source-inline">make_shared</strong> function is used to create a shared smart pointer to a <strong class="source-inline">SelectInputHandler</strong> instance. We will code the <strong class="source-inline">SelectInputHandler</strong> class next. Now that we have a <strong class="source-inline">UIPanel</strong> and an <strong class="source-inline">InputHandler</strong> in the appropriate forms, we can call the <strong class="source-inline">addPanel</strong> function and pass them both in. Note that, in the call to <strong class="source-inline">addPanel</strong>, <strong class="source-inline">suip</strong> is wrapped in a call to <strong class="source-inline">move</strong>. Any use of <strong class="source-inline">suip</strong> after this point is not possible without crashing the program because it is now a null pointer, since ownership has been moved to the function argument. Remember that, inside the <strong class="source-inline">Screen</strong> class <strong class="source-inline">addPanel</strong> function, ownership is moved again when the unique pointer to <strong class="source-inline">UIPanel</strong> is stashed away in the <strong class="source-inline">vector</strong> of <strong class="source-inline">UIPanel</strong> instances.</p>
			<p>Following this, the <strong class="source-inline">ScreenManagerRemoteControl</strong> pointer is initialized and can now be used to switch to another screen when required. </p>
			<p>The final few lines of code in the constructor create and scale a <strong class="source-inline">Sprite</strong> instance that uses the <strong class="source-inline">background.png</strong> image, which will fill the entire screen.</p>
			<p>In the <strong class="source-inline">draw</strong> function, the call to the <strong class="source-inline">setView</strong> function makes this panel's <strong class="source-inline">View</strong> instance the one to draw on, and then the <strong class="source-inline">Sprite</strong> instance is drawn to the <strong class="source-inline">RenderWindow</strong> instance.</p>
			<p>Finally, the <strong class="source-inline">draw</strong> function is called on the base <strong class="source-inline">Screen</strong> class, which draws all the panels and their related buttons. In this specific case, it draws just a single panel, <strong class="source-inline">SelectUIPanel</strong>, which we will code right after we have coded <strong class="source-inline">SelectInputHandler</strong>.</p>
			<h2 id="_idParaDest-390"><a id="_idTextAnchor404"/>Coding the SelectInputHandler class</h2>
			<p>Create a new header file in the <strong class="source-inline">Header Files/Screens/Select</strong> filter called <strong class="source-inline">SelectInputHandler.h</strong> and add the following code:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#include "InputHandler.h"</p>
			<p class="source-code">class SelectInputHandler : public InputHandler</p>
			<p class="source-code">{</p>
			<p class="source-code">public:</p>
			<p class="source-code">    void handleKeyPressed(Event&amp; event, </p>
			<p class="source-code">        RenderWindow&amp; window) override;</p>
			<p class="source-code">    void handleLeftClick(std::string&amp; buttonInteractedWith, </p>
			<p class="source-code">        RenderWindow&amp; window) override;</p>
			<p class="source-code">};</p>
			<p>The <strong class="source-inline">SelectInputHandler</strong> class inherits from <strong class="source-inline">InputHandler</strong> and overrides the <strong class="source-inline">handleKeyPressed</strong> and <strong class="source-inline">handleLeftClick</strong> functions. Let's see how these functions are implemented.</p>
			<p>Create a new source file in the <strong class="source-inline">Source Files/Screens/Select</strong> filter called <strong class="source-inline">SelectInputHandler.cpp</strong> and add the following code:</p>
			<p class="source-code">#include "SelectInputHandler.h"</p>
			<p class="source-code">#include "SoundEngine.h"</p>
			<p class="source-code">#include "WorldState.h"</p>
			<p class="source-code">#include &lt;iostream&gt;</p>
			<p class="source-code">int WorldState::WAVE_NUMBER;</p>
			<p class="source-code">void SelectInputHandler::handleKeyPressed(</p>
			<p class="source-code">    Event&amp; event, RenderWindow&amp; window)</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Quit the game</p>
			<p class="source-code">    if (Keyboard::isKeyPressed(Keyboard::Escape))</p>
			<p class="source-code">    {</p>
			<p class="source-code">        window.close();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">void SelectInputHandler::handleLeftClick(</p>
			<p class="source-code">    std::string&amp; buttonInteractedWith, RenderWindow&amp; window)</p>
			<p class="source-code">{</p>
			<p class="source-code">    if (buttonInteractedWith == "Play") {</p>
			<p class="source-code">        SoundEngine::playClick();</p>
			<p class="source-code">        WorldState::WAVE_NUMBER = 0;</p>
			<p class="source-code">        getPointerToScreenManagerRemoteControl()</p>
			<p class="source-code">            -&gt;loadLevelInPlayMode("level1");</p>
			<p class="source-code">    }</p>
			<p class="source-code">    if (buttonInteractedWith == "Quit") {</p>
			<p class="source-code">        SoundEngine::playClick();</p>
			<p class="source-code">        window.close();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">handleKeyPressed</strong> function interacts with just one keyboard key. When the <em class="italic">Escape</em> key is pressed, the game quits.</p>
			<p>In the <strong class="source-inline">handleLeftClick</strong> function, there are two <strong class="source-inline">if</strong> statements. Remember that the <strong class="source-inline">handleInputFunction</strong> of the <strong class="source-inline">InputHandler</strong> class passes in the text of the button that was clicked, along with a reference to <strong class="source-inline">RenderWindow</strong>. If the <strong class="bold">Play</strong> button is clicked, then a click sound is played, the <strong class="source-inline">WAVE_NUMBER</strong> variable is set to zero, and the <strong class="source-inline">ScreenManagerRemoteControl</strong> pointer calls the <strong class="source-inline">loadLevelInPlayMode</strong> function. The <strong class="source-inline">loadLevelInPlayMode</strong> function has its definition in <strong class="source-inline">ScreenManagerClass</strong>. Eventually, this function will indeed load a level from the passed in file name, but for now, it simply changes screen to the play screen.</p>
			<p>If the <strong class="bold">Quit</strong> button is clicked, then the game is exited.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">At this stage, despite including <strong class="source-inline">WorldState.h</strong>, you might have an error using <strong class="source-inline">WorldState::WaveNumber</strong>. This is fine; this is happening because of the order in which the classes are parsed by Visual Studio. When we add all the game screen-related classes that also use <strong class="source-inline">WorldState.h</strong>, which is parsed before this file, the error will be gone.</p>
			<p>Let's code <strong class="source-inline">SelectUIPanel</strong>. Then, we can move on to the <strong class="source-inline">GameScreen</strong> class.</p>
			<h2 id="_idParaDest-391"><a id="_idTextAnchor405"/>Coding the SelectUIPanel class</h2>
			<p>Create a new header file in the <strong class="source-inline">Header Files/Screens/Select</strong> filter called <strong class="source-inline">SelectUIPanel.h</strong> and add the following code:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#include "UIPanel.h"</p>
			<p class="source-code">class SelectUIPanel : public UIPanel</p>
			<p class="source-code">{</p>
			<p class="source-code">private:</p>
			<p class="source-code">    void initialiseButtons();</p>
			<p class="source-code">public:</p>
			<p class="source-code">    SelectUIPanel(Vector2i res);</p>
			<p class="source-code">    void virtual draw(RenderWindow&amp; window);</p>
			<p class="source-code">};</p>
			<p>The <strong class="source-inline">SelectUIPanel</strong> class inherits from <strong class="source-inline">UIPanel</strong> and overrides the <strong class="source-inline">draw</strong> function. In the preceding header file, you can also see that there is a function called <strong class="source-inline">initialiseButtons</strong>, as well as a constructor. Let's code the definitions.</p>
			<p>Create a new source file in the Source <strong class="source-inline">Files/Screens/Select</strong> filter called <strong class="source-inline">SelectUIPanel.cpp</strong> and add the following code:</p>
			<p class="source-code">#include "SelectUIPanel.h"</p>
			<p class="source-code">#include &lt;iostream&gt;</p>
			<p class="source-code">SelectUIPanel::SelectUIPanel(Vector2i res) :</p>
			<p class="source-code">    // Create a new UIPanel  </p>
			<p class="source-code">    // by calling the super-class constructor</p>
			<p class="source-code">    UIPanel(res,</p>
			<p class="source-code">        (res.x / 10) * 2, // Start 2/10 across</p>
			<p class="source-code">        res.y / 3, // 1/3 of the resolution from the top</p>
			<p class="source-code">        (res.x / 10) * 6, // as wide as 6/10 of the resolution</p>
			<p class="source-code">        res.y / 3, // and as tall as 1/3 of the resolution</p>
			<p class="source-code">        50, 255, 255, 255) // a, r, g, b</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_ButtonWidth = res.x / 20;</p>
			<p class="source-code">    m_ButtonHeight = res.y / 20;</p>
			<p class="source-code">    m_ButtonPadding = res.x / 100;</p>
			<p class="source-code">    m_Text.setFillColor(sf::Color(0, 255, 0, 255));</p>
			<p class="source-code">    m_Text.setString("SPACE INVADERS ++");</p>
			<p class="source-code">    //https://www.dafont.com/roboto.font</p>
			<p class="source-code">    m_Font.loadFromFile("fonts/Roboto-Bold.ttf");</p>
			<p class="source-code">    m_Text.setFont(m_Font);</p>
			<p class="source-code">    m_Text.setPosition(Vector2f(m_ButtonPadding,</p>
			<p class="source-code">        m_ButtonHeight + (m_ButtonPadding * 2)));</p>
			<p class="source-code">    m_Text.setCharacterSize(160);</p>
			<p class="source-code">    initialiseButtons();</p>
			<p class="source-code">}</p>
			<p class="source-code">void SelectUIPanel::initialiseButtons()</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Buttons are positioned relative to the top left </p>
			<p class="source-code">    // corner of the UI panel(m_View in UIPanel)</p>
			<p class="source-code">    addButton(m_ButtonPadding,</p>
			<p class="source-code">        m_ButtonPadding,</p>
			<p class="source-code">        m_ButtonWidth,</p>
			<p class="source-code">        m_ButtonHeight,</p>
			<p class="source-code">        0, 255, 0,</p>
			<p class="source-code">        "Play");</p>
			<p class="source-code">    addButton(m_ButtonWidth + (m_ButtonPadding * 2),</p>
			<p class="source-code">        m_ButtonPadding,</p>
			<p class="source-code">        m_ButtonWidth,</p>
			<p class="source-code">        m_ButtonHeight,</p>
			<p class="source-code">        255, 0, 0,</p>
			<p class="source-code">        "Quit");</p>
			<p class="source-code">}</p>
			<p class="source-code">void SelectUIPanel::draw(RenderWindow&amp; window)</p>
			<p class="source-code">{    </p>
			<p class="source-code">        show();</p>
			<p class="source-code">        UIPanel::draw(window);</p>
			<p class="source-code">        window.draw(m_Text);        </p>
			<p class="source-code">}</p>
			<p>The constructor receives the screen resolution and immediately uses that data to call the superclass constructor. By doing calculations with the values stored in <strong class="source-inline">res</strong>, the starting position and size of the panel is calculated. It is important that this calculation is done here and not in the <strong class="source-inline">UIPanel</strong> class because every <strong class="source-inline">UIPanel</strong> will be a different size and in a different position. Take a look at the comments in the preceding code if you are interested in the effect of each of the specific calculations. The color is also passed in using alpha, red, green, and blue values.</p>
			<p>Next, the member variables from the base class that determine button size and spacing are initialized. The value of <strong class="source-inline">20</strong> is just an arbitrary value that works, but the important part is that all the values are based on the resolution of the screen, so they will scale well over different screen resolutions.</p>
			<p>The next few lines of code prepare a <strong class="source-inline">Text</strong> instance, ready to be shown in the draw function. Finally, in the constructor, the <strong class="source-inline">initialiseButtons</strong> function is called.</p>
			<p>In the <strong class="source-inline">initialiseButtons</strong> function, the <strong class="source-inline">addButton</strong> function is called twice, creating a green button with "Play" on it and a red button with "Quit" on it.</p>
			<p>There might be some errors because of the use of the <strong class="source-inline">WorldState.h </strong>file. These can be ignored as they will correct themselves as we proceed with the next few classes.</p>
			<p>Now, we can code all the game screen-related classes.</p>
			<h1 id="_idParaDest-392"><a id="_idTextAnchor406"/>Coding the derived classes for the game screen </h1>
			<p>The structure of all these classes is the same as the select screen-related classes. I will be sure to point out where they vary, however. Most of the significant differences will be discussed across the next three chapters, however, because that is when we will code all the game objects and components and then put them to work in the <strong class="source-inline">GameScreen</strong> class. </p>
			<p>The first difference is that the <strong class="source-inline">GameScreen</strong> class has two <strong class="source-inline">UIPanel</strong> instances and two <strong class="source-inline">InputHandler</strong> instances. </p>
			<h2 id="_idParaDest-393"><a id="_idTextAnchor407"/>Coding the GameScreen class</h2>
			<p>Create a new header file in the <strong class="source-inline">Header Files/Screens/Game</strong> filter called <strong class="source-inline">GameScreen.h</strong> and add the following code:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#include "Screen.h"</p>
			<p class="source-code">#include "GameInputHandler.h"</p>
			<p class="source-code">#include "GameOverInputHandler.h"</p>
			<p class="source-code">class GameScreen : public Screen</p>
			<p class="source-code">{</p>
			<p class="source-code">private:</p>
			<p class="source-code">    ScreenManagerRemoteControl* m_ScreenManagerRemoteControl;</p>
			<p class="source-code">    shared_ptr&lt;GameInputHandler&gt; m_GIH;</p>
			<p class="source-code">    Texture m_BackgroundTexture;</p>
			<p class="source-code">    Sprite m_BackgroundSprite;</p>
			<p class="source-code">public:</p>
			<p class="source-code">    static bool m_GameOver;</p>
			<p class="source-code">    GameScreen(ScreenManagerRemoteControl* smrc, Vector2i res);</p>
			<p class="source-code">    void initialise() override;</p>
			<p class="source-code">    void virtual update(float fps);</p>
			<p class="source-code">    void virtual draw(RenderWindow&amp; window);    </p>
			<p class="source-code">};</p>
			<p>Note that this is not the finished code – we will add more features to this file in the next chapter. This is just enough code so that we can run the game and see some basic functionality at the end of this chapter.</p>
			<p>The code is familiar to the <strong class="source-inline">SelectScreen</strong> class. We also override the <strong class="source-inline">initialise</strong> and <strong class="source-inline">update</strong> functions. Furthermore, we have added a Boolean called <strong class="source-inline">m_GameOver</strong>, which will keep track of whether the game is currently playing. </p>
			<p>Let's move on to the function implementations.</p>
			<p>Create a new source file in the <strong class="source-inline">Source Files/Screens/Game</strong> filter called <strong class="source-inline">GameScreen.cpp</strong> and add the following code:</p>
			<p class="source-code">#include "GameScreen.h"</p>
			<p class="source-code">#include "GameUIPanel.h"</p>
			<p class="source-code">#include "GameInputHandler.h"</p>
			<p class="source-code">#include "GameOverUIPanel.h"</p>
			<p class="source-code">#include "WorldState.h"</p>
			<p class="source-code">int WorldState::WORLD_HEIGHT;</p>
			<p class="source-code">int WorldState::NUM_INVADERS;</p>
			<p class="source-code">int WorldState::NUM_INVADERS_AT_START;</p>
			<p class="source-code">GameScreen::GameScreen(ScreenManagerRemoteControl* smrc,</p>
			<p class="source-code">    Vector2i res)</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_GIH = make_shared&lt;GameInputHandler&gt;();</p>
			<p class="source-code">    auto guip = make_unique&lt;GameUIPanel&gt;(res);</p>
			<p class="source-code">    addPanel(move(guip), smrc, m_GIH);</p>
			<p class="source-code">    auto m_GOIH = make_shared&lt;GameOverInputHandler&gt;();</p>
			<p class="source-code">    auto gouip = make_unique&lt;GameOverUIPanel&gt;(res);</p>
			<p class="source-code">    addPanel(move(gouip), smrc, m_GOIH);</p>
			<p class="source-code">    m_ScreenManagerRemoteControl = smrc;</p>
			<p class="source-code">    float screenRatio = VideoMode::getDesktopMode().width /</p>
			<p class="source-code">        VideoMode::getDesktopMode().height;</p>
			<p class="source-code">    WorldState::WORLD_HEIGHT = WorldState::WORLD_WIDTH /</p>
			<p class="source-code">        screenRatio;</p>
			<p class="source-code">    m_View.setSize(</p>
			<p class="source-code">        WorldState::WORLD_WIDTH, WorldState::WORLD_HEIGHT);</p>
			<p class="source-code">    m_View.setCenter(Vector2f(WorldState::WORLD_WIDTH /</p>
			<p class="source-code">        2, WorldState::WORLD_HEIGHT / 2));</p>
			<p class="source-code">    </p>
			<p class="source-code">    m_BackgroundTexture.loadFromFile("graphics/background.png");</p>
			<p class="source-code">    m_BackgroundSprite.setTexture(m_BackgroundTexture);</p>
			<p class="source-code">    auto textureSize = m_BackgroundSprite.getTexture()-&gt;getSize();</p>
			<p class="source-code">    m_BackgroundSprite.setScale(float(m_View.getSize().x) / </p>
			<p class="source-code">      textureSize.x,</p>
			<p class="source-code">        float(m_View.getSize().y) / textureSize.y);</p>
			<p class="source-code">}</p>
			<p class="source-code">void GameScreen::initialise()</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_GIH-&gt;initialize();</p>
			<p class="source-code">    WorldState::NUM_INVADERS = 0;</p>
			<p class="source-code">    m_GameOver = false;</p>
			<p class="source-code">    if (WorldState::WAVE_NUMBER == 0)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        WorldState::NUM_INVADERS_AT_START = </p>
			<p class="source-code">            WorldState::NUM_INVADERS;</p>
			<p class="source-code">            </p>
			<p class="source-code">        WorldState::WAVE_NUMBER = 1;</p>
			<p class="source-code">        WorldState::LIVES = 3;</p>
			<p class="source-code">        WorldState::SCORE = 0;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">void GameScreen::update(float fps)</p>
			<p class="source-code">{</p>
			<p class="source-code">    Screen::update(fps);</p>
			<p class="source-code">    if (!m_GameOver)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        if (WorldState::NUM_INVADERS &lt;= 0)</p>
			<p class="source-code">        {</p>
			<p class="source-code">            WorldState::WAVE_NUMBER++;</p>
			<p class="source-code">            m_ScreenManagerRemoteControl-&gt;</p>
			<p class="source-code">                loadLevelInPlayMode("level1");</p>
			<p class="source-code">        }</p>
			<p class="source-code">        if (WorldState::LIVES &lt;= 0)</p>
			<p class="source-code">        {</p>
			<p class="source-code">            m_GameOver = true;</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">void GameScreen::draw(RenderWindow&amp; window)</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Change to this screen's view to draw</p>
			<p class="source-code">    window.setView(m_View);</p>
			<p class="source-code">    window.draw(m_BackgroundSprite);</p>
			<p class="source-code">    // Draw the UIPanel view(s)</p>
			<p class="source-code">    Screen::draw(window);</p>
			<p class="source-code">}</p>
			<p>Everything that happened in the <strong class="source-inline">SelectScreen</strong> class happens here too, but for two <strong class="source-inline">UIPanel</strong> instances and two <strong class="source-inline">InputHandler</strong> instances. The next difference is that <strong class="source-inline">GameScreen</strong> does implement the <strong class="source-inline">update</strong> function. This is where all the game objects will be updated each frame of the game.</p>
			<p>The next difference is that we have added some basic logic for the game into the <strong class="source-inline">initialise</strong> and <strong class="source-inline">update</strong> functions.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">I apologize for the inconsistent spelling of the <strong class="source-inline">initialise</strong> and <strong class="source-inline">initialize</strong> functions. Changing them at this current stage of production is more likely to introduce errors into the book than help you out.</p>
			<p>In the <strong class="source-inline">initialize</strong> function, the code calls the <strong class="source-inline">initialize</strong> function of the <strong class="source-inline">GameInputHandler</strong> class that we will code next. The <strong class="source-inline">NUM_INVADERS</strong> variable is set to zero, while <strong class="source-inline">m_GameOver</strong> is set to false. Next, the <strong class="source-inline">WAVE_NUMBER</strong> variable is tested and, if it equals zero, then the <strong class="source-inline">WorldState</strong> class has its static variables initialized, ready for a new game.</p>
			<p>In the <strong class="source-inline">update </strong>function, the <strong class="source-inline">m_GameOver</strong> variable is used to determine whether the game is running and, if it is, two more tests are done. The first tests whether all the invaders have been destroyed. At this stage of development, because there aren't any invaders, this has the effect of constantly incrementing the wave number.</p>
			<p>The second test checks whether the player has run out of lives and if they have, then <strong class="source-inline">m_GameOver</strong> is set to true.</p>
			<h2 id="_idParaDest-394"><a id="_idTextAnchor408"/>Coding the GameInputHandler class</h2>
			<p>Create a new header file in the <strong class="source-inline">Header Files/Screens/Game</strong> filter called <strong class="source-inline">GameInputHandler.h</strong> and add the following code:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#include "InputHandler.h"</p>
			<p class="source-code">class GameScreen;</p>
			<p class="source-code">class GameInputHandler : public InputHandler</p>
			<p class="source-code">{</p>
			<p class="source-code">public:</p>
			<p class="source-code">    void initialize();</p>
			<p class="source-code">    void handleGamepad() override;</p>
			<p class="source-code">    void handleKeyPressed(Event&amp; event,</p>
			<p class="source-code">        RenderWindow&amp; window) override;</p>
			<p class="source-code">    void handleKeyReleased(Event&amp; event,</p>
			<p class="source-code">        RenderWindow&amp; window) override;</p>
			<p class="source-code">};</p>
			<p>This class works the same way as <strong class="source-inline">SelectInputHandler</strong> does, but we need to override more of the functions. We will add code to the <strong class="source-inline">initialize</strong>, <strong class="source-inline">handleGamepad</strong>, <strong class="source-inline">handleKeyPressed</strong>, and <strong class="source-inline">handleKeyReleased</strong> functions here.</p>
			<p>This is not the finished code – we will add lots more features to this file in the next chapter. This is just enough code so that we can run the game and see some basic functionality at the end of the chapter.</p>
			<p>Create a new source file in the <strong class="source-inline">Source Files/Screens/Game</strong> filter called <strong class="source-inline">GameInputHandler.cpp</strong> and add the following code:</p>
			<p class="source-code">#include "GameInputHandler.h"</p>
			<p class="source-code">#include "SoundEngine.h"</p>
			<p class="source-code">#include "GameScreen.h"</p>
			<p class="source-code">void GameInputHandler::initialize() {</p>
			<p class="source-code">}</p>
			<p class="source-code">void GameInputHandler::handleGamepad()</p>
			<p class="source-code">{</p>
			<p class="source-code">}</p>
			<p class="source-code">void GameInputHandler::handleKeyPressed(</p>
			<p class="source-code">    Event&amp; event, RenderWindow&amp; window)</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Handle key presses</p>
			<p class="source-code">    if (event.key.code == Keyboard::Escape)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        SoundEngine::playClick();</p>
			<p class="source-code">        getPointerToScreenManagerRemoteControl()-&gt;</p>
			<p class="source-code">            SwitchScreens("Select");</p>
			<p class="source-code">    }    </p>
			<p class="source-code">}</p>
			<p class="source-code">void GameInputHandler::handleKeyReleased(</p>
			<p class="source-code">    Event&amp; event, RenderWindow&amp; window)</p>
			<p class="source-code">{</p>
			<p class="source-code">}</p>
			<p>For now, we only want to add code to the <strong class="source-inline">handleKeyPressed</strong> function, but why not add the other empty functions that are shown in the preceding code? When the player presses the <em class="italic">Escape</em> key, the <strong class="source-inline">ScreenMangerRemoteControl</strong> pointer calls the <strong class="source-inline">SwitchScreen</strong> function to go back to the select screen.</p>
			<p>This is not the finished code – we will add lots more features to this file in the next chapter. This is just enough code so that we can run the game and see some basic functionality at the end of the chapter. </p>
			<h2 id="_idParaDest-395"><a id="_idTextAnchor409"/>Coding the GameUIPanel class</h2>
			<p>Create a new header file in the <strong class="source-inline">Header Files/Screens/Game</strong> filter called <strong class="source-inline">GameUIPanel.h</strong> and add the following code:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#include "UIPanel.h"</p>
			<p class="source-code">class GameUIPanel : public UIPanel</p>
			<p class="source-code">{</p>
			<p class="source-code">public:</p>
			<p class="source-code">    GameUIPanel(Vector2i res);</p>
			<p class="source-code">    void draw(RenderWindow&amp; window) override;</p>
			<p class="source-code">};</p>
			<p>Like the previous <strong class="source-inline">UIPanel</strong> child class, we'll override the <strong class="source-inline">draw</strong> function and also implement the constructor. Let's code these functions now.</p>
			<p>Create a new source file in the <strong class="source-inline">Source Files/Screens/Game</strong> filter called <strong class="source-inline">GameUIPanel.cpp</strong> and add the following code:</p>
			<p class="source-code">#include "GameUIPanel.h"</p>
			<p class="source-code">#include &lt;sstream&gt;</p>
			<p class="source-code">#include "WorldState.h"</p>
			<p class="source-code">int WorldState::SCORE;</p>
			<p class="source-code">int WorldState::LIVES;</p>
			<p class="source-code">GameUIPanel::GameUIPanel(Vector2i res) :</p>
			<p class="source-code">    UIPanel(res,</p>
			<p class="source-code">        1, // The left</p>
			<p class="source-code">        1, // The top</p>
			<p class="source-code">        res.x / 3, // 1/3 width screen</p>
			<p class="source-code">        res.y / 12, </p>
			<p class="source-code">        50, 255, 255, 255) // a, r, g, b </p>
			<p class="source-code">{</p>
			<p class="source-code">    m_Text.setFillColor(sf::Color(0, 255, 0, 255));</p>
			<p class="source-code">    m_Text.setString("Score: 0 Lives: 3 Wave: 1");</p>
			<p class="source-code">    m_Font.loadFromFile("fonts/Roboto-Bold.ttf");</p>
			<p class="source-code">    m_Text.setFont(m_Font);</p>
			<p class="source-code">    m_Text.setPosition(Vector2f(15,15));</p>
			<p class="source-code">    m_Text.setCharacterSize(60);    </p>
			<p class="source-code">}</p>
			<p class="source-code">void GameUIPanel::draw(RenderWindow&amp; window)</p>
			<p class="source-code">{</p>
			<p class="source-code">    UIPanel::draw(window);</p>
			<p class="source-code">    std::stringstream ss;</p>
			<p class="source-code">    ss &lt;&lt; "Score: " &lt;&lt; WorldState::SCORE &lt;&lt; "  Lives: " </p>
			<p class="source-code">        &lt;&lt; WorldState::LIVES &lt;&lt; " Wave: " </p>
			<p class="source-code">        &lt;&lt; WorldState::WAVE_NUMBER;</p>
			<p class="source-code">    m_Text.setString(ss.str());</p>
			<p class="source-code">    window.draw(m_Text);</p>
			<p class="source-code">}</p>
			<p>The constructor, like the <strong class="source-inline">SelectUIPanel</strong> class, calls the base class constructor to configure the position, size, and color of the panel. Also, in the constructor, a <strong class="source-inline">Text</strong> instance is prepared for drawing to the screen.</p>
			<p>In the <strong class="source-inline">draw</strong> function, a <strong class="source-inline">stringstream</strong> instance is used to concatenate a String of text that displays the player's score, lives remaining, and number of waves cleared. The <strong class="source-inline">RenderWindow</strong> instance then passes the <strong class="source-inline">Text</strong> instance to its <strong class="source-inline">draw</strong> function.</p>
			<h2 id="_idParaDest-396"><a id="_idTextAnchor410"/>Coding the GameOverInputHandler class</h2>
			<p>Remember that the game screen will have two panels and two input handling classes. When the player loses their last life, the game over panel will be shown. This is what we will code now.</p>
			<p>Create a new header file in the <strong class="source-inline">Header Files/Screens/Game</strong> filter called <strong class="source-inline">GameOverInputHandler.h</strong> and add the following code:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#include "InputHandler.h"</p>
			<p class="source-code">class GameOverInputHandler :</p>
			<p class="source-code">    public InputHandler</p>
			<p class="source-code">{</p>
			<p class="source-code">public:</p>
			<p class="source-code">    void handleKeyPressed(Event&amp; event, </p>
			<p class="source-code">        RenderWindow&amp; window) override;</p>
			<p class="source-code">    void handleLeftClick(std::string&amp; </p>
			<p class="source-code">        buttonInteractedWith, RenderWindow&amp; window) override;</p>
			<p class="source-code">};</p>
			<p>There is nothing different in the preceding code compared to the header files of the previous two <strong class="source-inline">InputHandler</strong> derived classes. </p>
			<p>Create a new source file in the <strong class="source-inline">Source Files/Screens/Game</strong> filter called <strong class="source-inline">GameOverInputHandler.cpp</strong> and add the following code:</p>
			<p class="source-code">#include "GameOverInputHandler.h"</p>
			<p class="source-code">#include "SoundEngine.h"</p>
			<p class="source-code">#include "WorldState.h"</p>
			<p class="source-code">#include &lt;iostream&gt;</p>
			<p class="source-code">void GameOverInputHandler::handleKeyPressed(Event&amp; event, </p>
			<p class="source-code">    RenderWindow&amp; window)</p>
			<p class="source-code">{</p>
			<p class="source-code">    if (event.key.code == Keyboard::Escape)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        SoundEngine::playClick();</p>
			<p class="source-code">        getPointerToScreenManagerRemoteControl()-&gt;</p>
			<p class="source-code">            SwitchScreens("Select");</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">void GameOverInputHandler::handleLeftClick(</p>
			<p class="source-code">    std::string&amp; buttonInteractedWith, RenderWindow&amp; window)</p>
			<p class="source-code">{</p>
			<p class="source-code">    if (buttonInteractedWith == "Play") {</p>
			<p class="source-code">        SoundEngine::playClick();</p>
			<p class="source-code">        WorldState::WAVE_NUMBER = 0;</p>
			<p class="source-code">        getPointerToScreenManagerRemoteControl()-&gt;</p>
			<p class="source-code">            loadLevelInPlayMode("level1");</p>
			<p class="source-code">    }</p>
			<p class="source-code">    else if (buttonInteractedWith == "Home") {</p>
			<p class="source-code">        SoundEngine::playClick();</p>
			<p class="source-code">        getPointerToScreenManagerRemoteControl()-&gt;</p>
			<p class="source-code">            SwitchScreens("Select");</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The preceding code handles two types of event. First, if the <em class="italic">Escape</em> keyboard key is pressed, the game switches to the select screen.</p>
			<p>In the <strong class="source-inline">handleLeftClick</strong> function, there are two different buttons that are handled. If the <strong class="bold">Play</strong> button is clicked, a new game is started by calling <strong class="source-inline">loadLevelInPlayMode</strong>, while, if the <strong class="bold">Home</strong> button is clicked, then the select screen will be shown.</p>
			<h2 id="_idParaDest-397"><a id="_idTextAnchor411"/>Coding the GameOverUIPanel class</h2>
			<p>Create a new header file in the <strong class="source-inline">Header Files/Screens/Game</strong> filter called <strong class="source-inline">GameOverUIPanel.h</strong> and add the following code:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#include "UIPanel.h"</p>
			<p class="source-code">class GameOverUIPanel :</p>
			<p class="source-code">    public UIPanel</p>
			<p class="source-code">{</p>
			<p class="source-code">private:    </p>
			<p class="source-code">    void initialiseButtons();</p>
			<p class="source-code">public:</p>
			<p class="source-code">    GameOverUIPanel(Vector2i res);</p>
			<p class="source-code">    void virtual draw(RenderWindow&amp; window);</p>
			<p class="source-code">};</p>
			<p>There's nothing new in the preceding header file, so let's look at the function implementations</p>
			<p>Create a new source file in the <strong class="source-inline">Source Files/Screens/Game</strong> filter called <strong class="source-inline">GameOverUIPanel.cpp</strong> and add the following code:</p>
			<p class="source-code">#include "GameOverUIPanel.h"</p>
			<p class="source-code">#include "GameScreen.h"</p>
			<p class="source-code">bool GameScreen::m_GameOver;</p>
			<p class="source-code">GameOverUIPanel::GameOverUIPanel(Vector2i res) :</p>
			<p class="source-code">    UIPanel(res,</p>
			<p class="source-code">        (res.x / 10) * 3, </p>
			<p class="source-code">        res.y / 2, // 50% of the resolution from the top</p>
			<p class="source-code">        (res.x / 10) * 3, // as wide as 1/3 of the resolution</p>
			<p class="source-code">        res.y / 6, // and as tall as 1/6 of the resolution</p>
			<p class="source-code">        50, 255, 255, 255) // a, r, g, b    </p>
			<p class="source-code">{</p>
			<p class="source-code">    m_ButtonWidth = res.x / 20;</p>
			<p class="source-code">    m_ButtonHeight = res.y / 20;</p>
			<p class="source-code">    m_ButtonPadding = res.x / 100;</p>
			<p class="source-code">    m_Text.setFillColor(sf::Color(0, 255, 0, 255));// Green</p>
			<p class="source-code">    m_Text.setString("GAME OVER!");</p>
			<p class="source-code">    m_Font.loadFromFile("fonts/Roboto-Bold.ttf");</p>
			<p class="source-code">    m_Text.setFont(m_Font);</p>
			<p class="source-code">    m_Text.setPosition(Vector2f(m_ButtonPadding, </p>
			<p class="source-code">        (m_ButtonPadding * 2)+ m_ButtonHeight));</p>
			<p class="source-code">    m_Text.setCharacterSize(60);</p>
			<p class="source-code">    initialiseButtons();</p>
			<p class="source-code">}</p>
			<p class="source-code">void GameOverUIPanel::initialiseButtons()</p>
			<p class="source-code">{</p>
			<p class="source-code">    addButton(m_ButtonPadding,</p>
			<p class="source-code">        m_ButtonPadding,</p>
			<p class="source-code">        m_ButtonWidth,</p>
			<p class="source-code">        m_ButtonHeight,</p>
			<p class="source-code">        0, 255, 0,</p>
			<p class="source-code">        "Play");</p>
			<p class="source-code">    addButton(m_ButtonWidth + (m_ButtonPadding * 2),</p>
			<p class="source-code">        m_ButtonPadding,</p>
			<p class="source-code">        m_ButtonWidth,</p>
			<p class="source-code">        m_ButtonHeight,</p>
			<p class="source-code">        255, 0, 0,</p>
			<p class="source-code">        "Home");</p>
			<p class="source-code">}</p>
			<p class="source-code">void GameOverUIPanel::draw(RenderWindow&amp; window) </p>
			<p class="source-code">{</p>
			<p class="source-code">    if (GameScreen::m_GameOver)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        show();</p>
			<p class="source-code">        UIPanel::draw(window);</p>
			<p class="source-code">        window.draw(m_Text);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    else</p>
			<p class="source-code">    {</p>
			<p class="source-code">        hide();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The preceding code configures a panel in the middle of the screen with the text <strong class="bold">Game Over!</strong> and two buttons that will allow the player to restart the game or quit, and go back to the starting screen (home/select).</p>
			<h1 id="_idParaDest-398"><a id="_idTextAnchor412"/>Running the game</h1>
			<p>If you run the game, you will see the select screen, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer122" class="IMG---Figure">
					<img src="image/B14278_19_08.jpg" alt=""/>
				</div>
			</div>
			<p>Press <strong class="bold">Play</strong> to transition to the game screen:</p>
			<div>
				<div id="_idContainer123" class="IMG---Figure">
					<img src="image/B14278_19_09.jpg" alt=""/>
				</div>
			</div>
			<p>Press <strong class="bold">Escape</strong> to quit, and go back to the select screen.</p>
			<p>Quit the game and find the following line of code in the <strong class="source-inline">GameScreen</strong> class:</p>
			<p class="source-code">if (WorldState::LIVES &lt;= 0)</p>
			<p>Change it to the following:</p>
			<p class="source-code">if (true)</p>
			<p>Now, run the game again and select the <strong class="bold">Play</strong> button. The game over panel will be displayed and can be interacted with:</p>
			<div>
				<div id="_idContainer124" class="IMG---Figure">
					<img src="image/B14278_19_10.jpg" alt=""/>
				</div>
			</div>
			<p>Now, change back <strong class="source-inline">if (true)</strong> in the <strong class="source-inline">GameScreen</strong> class back to <strong class="source-inline">if (WorldState::LIVES &lt;= 0)</strong>.</p>
			<p>Let's take a break; that was a long chapter.</p>
			<h1 id="_idParaDest-399"><a id="_idTextAnchor413"/>Summary</h1>
			<p>You have achieved a lot in this chapter. You have built a solid foundation for the Space Invaders ++ game and you have also coded a reusable system that can be used for almost any game that is divided up into different "screens".</p>
			<p>We now have an input handling system in place that can detect keyboard presses and mouse clicks and route the responsibility to handle them to a specific panel that is part of a specific screen. Furthermore, the abstraction of the concept of a screen allows us to set up as many different game loops as we like. The <strong class="source-inline">GameScreen</strong> class will be the main class to handle the logic of this game but, once you see how over the next few chapters, you could easily code another screen to play a completely different game. Of course, the most likely thing you will do is get started with your own ideas.</p>
			<p>In the next chapter, we will code the game objects and components which are the basis of our entity-component pattern implementation.</p>
		</div>
		<div>
			<div id="_idContainer126">
			</div>
		</div>
	</body></html>