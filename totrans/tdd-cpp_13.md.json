["```cpp\ntemplate <typename T>\nT calculateFraction (T input)\n{\n    T denominator {10};\n    return input / denominator;\n}\n```", "```cpp\ntemplate <typename T>\nT accumulateError (T input)\n{\n    // First add many small amounts.\n    T partialAmount {0.1};\n    for (int i = 0; i < 10; ++i)\n    {\n        input += partialAmount;\n    }\n    // Then subtract to get back to the original.\n    T wholeAmount {1};\n    input -= wholeAmount;\n    return input;\n}\n```", "```cpp\ntemplate <typename T>\nint performComparisons (int totalCount)\n{\n    int passCount {0};\n    for (int i = 0; i < totalCount; ++i)\n    {\n        T expected = static_cast<T>(i);\n        expected = calculateFraction(expected);\n        T actual = accumulateError(expected);\n        if (actual == expected)\n        {\n            ++passCount;\n        }\n    }\n    return passCount;\n}\n```", "```cpp\nTEST(\"Test many float comparisons\")\n{\n    int totalCount {1'000};\n    int passCount = performComparisons<float>(totalCount);\n    CONFIRM_THAT(passCount, Equals(totalCount));\n}\n```", "```cpp\n------- Test: Test many float comparisons\nFailed confirm on line 125\n    Expected: 1000\n    Actual  : 4\n```", "```cpp\nTEST(\"Test many double comparisons\")\n{\n    int totalCount {1'000};\n    int passCount = performComparisons<double>(totalCount);\n    CONFIRM_THAT(passCount, Equals(totalCount));\n}\nTEST(\"Test many long double comparisons\")\n{\n    int totalCount {1'000};\n    int passCount = performComparisons<long                     double>(totalCount);\n    CONFIRM_THAT(passCount, Equals(totalCount));\n}\n```", "```cpp\n------- Test: Test many double comparisons\nFailed confirm on line 132\n    Expected: 1000\n    Actual  : 4\n------- Test: Test many long double comparisons\nFailed confirm on line 139\n    Expected: 1000\n    Actual  : 0\n```", "```cpp\ninline void confirm (\n    float expected,\n    float actual,\n    int line)\n{\n    if (actual < (expected - 0.0001f) ||\n        actual > (expected + 0.0001f))\n    {\n        throw ActualConfirmException(\n            std::to_string(expected),\n            std::to_string(actual),\n            line);\n    }\n}\n```", "```cpp\nconstexpr float getMargin (float)\n{\n    return 0.0001f;\n}\nconstexpr double getMargin (double)\n{\n    return 0.000001;\n}\nconstexpr long double getMargin (long double)\n{\n    return 0.000001L;\n}\n```", "```cpp\n    if (actual < (expected - 0.0001f) ||\n        actual > (expected + 0.0001f))\n```", "```cpp\n#include \"../Test.h\"\n#include <cmath>\n#include <limits>\n```", "```cpp\ntemplate <typename T>\nint performComparisons (int totalCount)\n{\n    int passCount {0};\n    for (int i = 0; i < totalCount; ++i)\n    {\n        T expected = static_cast<T>(i);\n        expected = calculateFraction(expected);\n        T actual = accumulateError(expected);\n        if (std::abs(actual - expected) < getMargin(actual))\n        {\n            ++passCount;\n        }\n    }\n    return passCount;\n}\n```", "```cpp\n------- Test: Test many float comparisons\nPassed\n------- Test: Test many double comparisons\nPassed\n------- Test: Test many long double comparisons\nPassed\n```", "```cpp\ntemplate <typename T>\nbool compareEq (T lhs, T rhs)\n{\n    return std::abs(lhs - rhs) < getMargin(lhs);\n}\ntemplate <typename T>\nint performComparisons (int totalCount)\n{\n    int passCount {0};\n    for (int i = 0; i < totalCount; ++i)\n    {\n        T expected = static_cast<T>(i);\n        expected = calculateFraction(expected);\n        T actual = accumulateError(expected);\n        if (compareEq(actual, expected))\n        {\n            ++passCount;\n        }\n    }\n    return passCount;\n}\n```", "```cpp\nTEST(\"Test small float values\")\n{\n    // Based on float epsilon = 1.1920928955078125e-07\n    bool result = compareEq(0.000001f, 0.000002f);\n    CONFIRM_FALSE(result);\n}\nTEST(\"Test large float values\")\n{\n    // Based on float epsilon = 1.1920928955078125e-07\n    bool result = compareEq(9'999.0f, 9'999.001f);\n    CONFIRM_TRUE(result);\n}\n```", "```cpp\nTEST(\"Test small double values\")\n{\n    // Based on double epsilon = 2.2204460492503130808e-16\n    bool result = compareEq(0.000000000000001,                   0.000000000000002);\n    CONFIRM_FALSE(result);\n}\nTEST(\"Test large double values\")\n{\n    // Based on double epsilon = 2.2204460492503130808e-16\n    bool result = compareEq(1'500'000'000'000.0,                   1'500'000'000'000.0003);\n    CONFIRM_TRUE(result);\n}\n```", "```cpp\nTEST(\"Test small long double values\")\n{\n    // Based on double epsilon = 2.2204460492503130808e-16\n    bool result = compareEq(0.000000000000001L,                   0.000000000000002L);\n    CONFIRM_FALSE(result);\n}\nTEST(\"Test large long double values\")\n{\n    // Based on double epsilon = 2.2204460492503130808e-16\n    bool result = compareEq(1'500'000'000'000.0L,                   1'500'000'000'000.0003L);\n    CONFIRM_TRUE(result);\n}\n```", "```cpp\nconstexpr float getMargin (float)\n{\n    // 4 is chosen to pass a reasonable amount of error.\n    return std::numeric_limits<float>::epsilon() * 4;\n}\nconstexpr double getMargin (double)\n{\n    // 4 is chosen to pass a reasonable amount of error.\n    return std::numeric_limits<double>::epsilon() * 4;\n}\nconstexpr long double getMargin (long double)\n{\n    // Use double epsilon instead of long double epsilon.\n    // Double epsilon is already much bigger than\n    // long double epsilon so we don't need to multiply it.\n    return std::numeric_limits<double>::epsilon();\n}\n```", "```cpp\ntemplate <typename T>\nbool compareEq (T lhs, T rhs)\n{\n    // Check for an exact match with operator == first.\n    if (lhs == rhs)\n    {\n        return true;\n    }\n    // Subnormal diffs near zero are treated as equal.\n    T diff = std::abs(lhs - rhs);\n    if (diff <= std::numeric_limits<T>::min())\n    {\n        return true;\n    }\n    // The margin should get bigger with bigger absolute values.\n    // We scale the margin up by the larger value or\n    // leave the margin unchanged if larger is less than 1.\n    lhs = std::abs(lhs);\n    rhs = std::abs(rhs);\n    T larger = (lhs > rhs) ? lhs : rhs;\n    larger = (larger < 1.0) ? 1.0 : larger;\n    return diff <= getMargin(lhs) * larger;\n}\n```", "```cpp\n3 == 4\n```", "```cpp\n#include <cmath>\n#include <cstring>\n#include <limits>\n#include <map>\n#include <ostream>\n#include <string_view>\n#include <type_traits>\n#include <vector>\n```", "```cpp\ninline void confirm (\n    float expected,\n    float actual,\n    int line)\n{\n    if (not compareEq(actual, expected))\n    {\n        throw ActualConfirmException(\n            std::to_string(expected),\n            std::to_string(actual),\n            line);\n    }\n}\n```", "```cpp\n#include <concepts>\n#include <cmath>\n#include <cstring>\n#include <limits>\n#include <map>\n#include <ostream>\n#include <string_view>\n#include <type_traits>\n#include <vector>\n```", "```cpp\ntemplate <std::floating_point T>\nvoid confirm (\n    T expected,\n    T actual,\n    int line)\n{\n    if (not compareEq(actual, expected))\n    {\n        throw ActualConfirmException(\n            std::to_string(expected),\n            std::to_string(actual),\n            line);\n    }\n}\n```", "```cpp\nTEST(\"Test large float values\")\n{\n    // Based on float epsilon = 1.1920928955078125e-07\n    CONFIRM_THAT(9'999.0f, Equals(9'999.001f));\n}\nTEST(\"Test large double values\")\n{\n    // Based on double epsilon = 2.2204460492503130808e-16\n    CONFIRM_THAT(1'500'000'000'000.0,                 Equals(1'500'000'000'000.0003));\n}\nTEST(\"Test large long double values\")\n{\n    // Based on double epsilon = 2.2204460492503130808e-16\n    CONFIRM_THAT(1'500'000'000'000.0L,             Equals(1'500'000'000'000.0003L));\n}\n```", "```cpp\n------- Test: Test large float values\nFailed confirm on line 152\n    Expected: 9999.000977\n    Actual  : 9999.000000\n------- Test: Test small double values\nPassed\n------- Test: Test large double values\nFailed confirm on line 165\n    Expected: 1500000000000.000244\n    Actual  : 1500000000000.000000\n------- Test: Test small long double values\nPassed\n------- Test: Test large long double values\nFailed confirm on line 178\n    Expected: 1500000000000.000300\n    Actual  : 1500000000000.000000\n```", "```cpp\ntemplate <std::floating_point T>\nclass Equals<T> : public Matcher\n{\npublic:\n    Equals (T const & expected)\n    : mExpected(expected)\n    { }\n    bool pass (T const & actual) const\n    {\n        return compareEq(actual, mExpected);\n    }\n    std::string to_string () const override\n    {\n        return std::to_string(mExpected);\n    }\nprivate:\n    T mExpected;\n};\n```", "```cpp\nTEST(\"Test small float values\")\n{\n    // Based on float epsilon = 1.1920928955078125e-07\n    CONFIRM_THAT(0.000001f, not Equals(0.000002f));\n}\nTEST(\"Test small double values\")\n{\n    // Based on double epsilon = 2.2204460492503130808e-16\n    CONFIRM_THAT(0.000000000000001,             not Equals(0.000000000000002));\n}\nTEST(\"Test small long double values\")\n{\n    // Based on double epsilon = 2.2204460492503130808e-16\n    CONFIRM_THAT(0.000000000000001L,             not Equals(0.000000000000002L));\n}\n```", "```cpp\nMereTDD/tests/Hamcrest.cpp:145:29: error: no match for 'operator!' (operand type is 'MereTDD::Equals<float>')\n  145 |     CONFIRM_THAT(0.000001f, not Equals(0.000002f));\n      |                             ^~~~~~~~~~~~~~~~~~~~~\n```", "```cpp\nTEST(\"Test small float values\")\n{\n    // Based on float epsilon = 1.1920928955078125e-07\n    CONFIRM_THAT(0.000001f, NotEquals(0.000002f));\n}\nTEST(\"Test small double values\")\n{\n    // Based on double epsilon = 2.2204460492503130808e-16\n    CONFIRM_THAT(0.000000000000001,             NotEquals(0.000000000000002));\n}\nTEST(\"Test small long double values\")\n{\n    // Based on double epsilon = 2.2204460492503130808e-16\n    CONFIRM_THAT(0.000000000000001L,             NotEquals(0.000000000000002L));\n}\n```", "```cpp\ntemplate <typename T>\nclass NotEquals : public Matcher\n{\npublic:\n    NotEquals (T const & expected)\n    : mExpected(expected)\n    { }\n    template <typename U>\n    bool pass (U const & actual) const\n    {\n        return not mExpected.pass(actual);\n    }\n    std::string to_string () const override\n    {\n        return \"not \" + mExpected.to_string();\n    }\nprivate:\n    Equals<T> mExpected;\n};\n```", "```cpp\nTEST(\"Test hamcrest style string confirms\")\n{\n    std::string s1 = \"abc\";\n    std::string s2 = \"abc\";\n    CONFIRM_THAT(s1, Equals(s2));       // string vs. string\n    CONFIRM_THAT(s1, Equals(\"abc\"));    // string vs. literal\n    CONFIRM_THAT(\"abc\", Equals(s1));    // literal vs. string\n    // Probably not needed, but this works too.\n    CONFIRM_THAT(\"abc\", Equals(\"abc\")); // literal vs. literal\n    std::string s3 = \"def\";\n    CONFIRM_THAT(s1, NotEquals(s3));       // string vs. string\n    CONFIRM_THAT(s1, NotEquals(\"def\"));    // string vs. literal\n    CONFIRM_THAT(\"def\", NotEquals(s1));    // literal vs. string\n}\n```", "```cpp\nTEST(\"Test hamcrest style string pointer confirms\")\n{\n    char const * sp1 = \"abc\";\n    std::string s1 = \"abc\";\n    char const * sp2 = s1.c_str();    // avoid sp1 and sp2 being same\n    CONFIRM_THAT(sp1, Equals(sp2));   // pointer vs. pointer\n    CONFIRM_THAT(sp2, Equals(\"abc\")); // pointer vs. literal\n    CONFIRM_THAT(\"abc\", Equals(sp2)); // literal vs. pointer\n    CONFIRM_THAT(sp1, Equals(s1));    // pointer vs. string\n    CONFIRM_THAT(s1, Equals(sp1));    // string vs. pointer\n    char const * sp3 = \"def\";\n    CONFIRM_THAT(sp1, NotEquals(sp3));   // pointer vs. pointer\n    CONFIRM_THAT(sp1, NotEquals(\"def\")); // pointer vs. literal\n    CONFIRM_THAT(\"def\", NotEquals(sp1)); // literal vs. pointer\n    CONFIRM_THAT(sp3, NotEquals(s1));    // pointer vs. string\n    CONFIRM_THAT(s1, NotEquals(sp3));    // string vs. pointer\n}\n```", "```cpp\nTEST(\"Test even integral value\")\n{\n    CONFIRM_THAT(10, IsEven<int>());\n}\nTEST(\"Test even integral value confirm failure\")\n{\n    CONFIRM_THAT(11, IsEven<int>());\n}\n```", "```cpp\nIsEven<int>()\n```", "```cpp\ntemplate <std::integral T>\nclass IsEven : public Matcher\n{\npublic:\n    IsEven ()\n    { }\n    bool pass (T const & actual) const\n    {\n        return actual % 2 == 0;\n    }\n    std::string to_string () const override\n    {\n        return \"is even\";\n    }\n};\n```", "```cpp\n------- Test: Test even integral value\nPassed\n------- Test: Test even integral value confirm failure\nFailed confirm on line 185\n    Expected: is even\n    Actual  : 11\n```", "```cpp\nTEST(\"Test even integral value confirm failure\")\n{\n    std::string reason = \"    Expected: is even\\n\";\n    reason += \"    Actual  : 11\";\n    setExpectedFailureReason(reason);\n    CONFIRM_THAT(11, IsEven<int>());\n}\n```", "```cpp\n------- Test: Test even integral value\nPassed\n------- Test: Test even integral value confirm failure\nExpected failure\n    Expected: is even\n    Actual  : 11\n```"]