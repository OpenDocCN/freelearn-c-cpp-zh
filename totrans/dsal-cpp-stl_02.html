<html><head></head><body>
		<div><h1 id="_idParaDest-35" class="chapter-number"><a id="_idTextAnchor035"/>2</h1>
			<h1 id="_idParaDest-36"><a id="_idTextAnchor036"/>Mastering Iterators with std::vector</h1>
			<p>In this chapter, we will gain a deeper exploration of <code>std::vector</code>, focusing on the intricacies of iteration. This chapter equips us with the knowledge to handle the ins and outs of vector traversal. Mastering these core areas bolsters the efficiency and reliability of one’s C++ code and provides insights into the underpinnings of dynamic array behavior, which is critical for effective C++.</p>
			<p>In this chapter, we’re going to cover the following main topics:</p>
			<ul>
				<li>Types of iterators in the STL</li>
				<li>Basic iteration techniques with <code>std::vector</code></li>
				<li>Using <code>std::begin</code> and <code>std::end</code></li>
				<li>Understanding iterator requirements</li>
				<li>Range-based <code>for</code> loops</li>
				<li>Creating a custom iterator</li>
			</ul>
			<h1 id="_idParaDest-37"><a id="_idTextAnchor037"/>Technical requirements</h1>
			<p>The code in this chapter can be found on GitHub:</p>
			<p><a href="https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL">https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL</a></p>
			<h1 id="_idParaDest-38"><a id="_idTextAnchor038"/>Types of iterators in the STL</h1>
			<p>In the <strong class="bold">Standard Template Library </strong>(<strong class="bold">STL</strong>), iterators play a pivotal role by connecting algorithms to<a id="_idIndexMarker053"/> containers. They provide a means for <a id="_idIndexMarker054"/>developers to traverse, access, and potentially modify the elements of a container. Iterators are essential tools for efficient data manipulation in the STL. However, they aren’t uniform in their functionalities. The STL delineates iterators into five primary types, each offering varying access and control over the elements. This section will get into these iterator types, elaborating on their distinct capabilities and uses.</p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor039"/>Input iterators</h2>
			<p>Input iterators (<em class="italic">LegacyInputIterator</em>) are<a id="_idIndexMarker055"/> the starting point in exploring iterator types. They <a id="_idIndexMarker056"/>represent the foundational category of iterators. As their name implies, input iterators focus on reading and progressing through elements. They enable developers to advance to the subsequent element in the container and retrieve its value. It’s crucial to note that revisiting the prior element is impossible after moving an input iterator forward, and modifying the present element is not permitted. This iterator category is often employed in algorithms that require data processing without modification.</p>
			<p>The following is a simple example using <code>std::vector</code> and its input iterator:</p>
			<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;vector&gt;
int main() {
  std::vector&lt;int&gt; numbers = {10, 20, 30, 40, 50};
  for (auto it = numbers.begin(); it != numbers.end();
       ++it) {
    std::cout &lt;&lt; *it &lt;&lt; " ";
  }
  std::cout &lt;&lt; "\n";
  return 0;
}</pre>			<p>In this<a id="_idIndexMarker057"/> example, we use <code>std::vector&lt;int&gt;::const_iterator</code> as the input iterator to traverse the vector and print its<a id="_idIndexMarker058"/> elements. We’re following the principles of the input iterator by not modifying the elements or moving the iterator backward. It is important to note that we cannot change the element or go back to the previous element with the input iterator.</p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor040"/>Output iterators</h2>
			<p>Next, we <a id="_idIndexMarker059"/>will look into output iterators (<em class="italic">LegacyOutputIterator</em>). Although<a id="_idIndexMarker060"/> they bear similarities to input iterators, they serve a different primary function: writing to elements. Output iterators facilitate assignment to the elements they reference. However, directly reading these elements through the iterator is not supported. They are commonly utilized in algorithms designed to produce and populate a sequence of values within a container.</p>
			<p>Here’s an example demonstrating the use of output iterators with <code>std::vector</code>:</p>
			<pre class="source-code">
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;
int main() {
  std::vector&lt;int&gt; numbers;
  std::generate_n(std::back_inserter(numbers), 10,
                  [n = 0]() mutable { return ++n; });
  for (auto num : numbers) { std::cout &lt;&lt; num &lt;&lt; " "; }
  std::cout &lt;&lt; "\n";
  return 0;
}</pre>			<p>In the<a id="_idIndexMarker061"/> preceding code, <code>std::back_inserter</code> is an output iterator adapter designed to work with containers like <code>std::vector</code>. It allows you to <em class="italic">write</em> or push new values to the<a id="_idIndexMarker062"/> back of the vector. We use the <code>std::generate_n</code> algorithm to generate and insert the numbers. This pattern perfectly encapsulates the <em class="italic">write-only</em> characteristic of output iterators. We don’t use the output iterator to read. For reading, we use a regular iterator.</p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor041"/>Forward iterators</h2>
			<p>With the <a id="_idIndexMarker063"/>basics behind us, let’s move on to the forward iterators (<em class="italic">LegacyForwardIterator</em>). Forward iterators combine the capabilities of both<a id="_idIndexMarker064"/> input iterators and output iterators. Thus, they support reading, writing, and—as the name implies—always moving forward. Forward iterators never reverse their direction. Their versatility makes them well-suited for many algorithms that operate on singly linked lists (i.e., <code>std::forward_list</code>).</p>
			<p><code>std::forward_list</code> is explicitly designed for singly linked lists, making it the ideal candidate for illustrating forward iterators.</p>
			<p>Here’s a simple code example to illustrate their use:</p>
			<pre class="source-code">
#include &lt;forward_list&gt;
#include &lt;iostream&gt;
int main() {
  std::forward_list&lt;int&gt; flist = {10, 20, 30, 40, 50};
  std::cout &lt;&lt; "Original list: ";
  for (auto it = flist.begin(); it != flist.end(); ++it) {
    std::cout &lt;&lt; *it &lt;&lt; " ";
  }
  std::cout &lt;&lt; "\n";
  for (auto it = flist.begin(); it != flist.end(); ++it) {
    (*it)++;
  }
  std::cout &lt;&lt; "Modified list: ";
  for (auto it = flist.begin(); it != flist.end(); ++it) {
    std::cout &lt;&lt; *it &lt;&lt; " ";
  }
  std::cout &lt;&lt; "\n";
  return 0;
}</pre>			<p>Here <a id="_idIndexMarker065"/>is the example output:</p>
			<pre class="console">
Original list: 10 20 30 40 50
Modified list: 11 21 31 41 51</pre>			<p>This <a id="_idIndexMarker066"/>code initializes a <code>std::forward_list</code>, uses a forward iterator to traverse and display its elements, and then increments each element by 1, demonstrating the reading and writing capabilities of the forward iterator.</p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor042"/>Reverse iterators</h2>
			<p>Sometimes, you<a id="_idIndexMarker067"/> might find the need to traverse the vector in<a id="_idIndexMarker068"/> reverse. Enter <code>rbegin()</code> and <code>rend()</code>. These functions return reverse iterators that start at the end of the vector and conclude at the beginning. Such backward traversal can be handy in specific algorithms and data-processing tasks.</p>
			<p>Note the<a id="_idIndexMarker069"/> reverse iterator is technically an iterator adaptor. <code>std::reverse_iterator</code> is classified as an iterator adaptor. It takes a given iterator, which should either be a <em class="italic">LegacyBidirectionalIterator,</em> or comply with the <code>bidirectional_iterator</code> criteria introduced from C++20 onwards, and reverses its direction. When<a id="_idIndexMarker070"/> given a bidirectional iterator, <code>std::reverse_iterator</code> yields a new iterator that traverses the sequence in the opposite direction—from the end to the beginning.</p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor043"/>Bidirectional iterators</h2>
			<p>Continuing, we <a id="_idIndexMarker071"/>address bidirectional iterators (<em class="italic">LegacyBidirectionalIterator</em>). These iterators permit traversal in both forward and backward directions<a id="_idIndexMarker072"/> within a container. Inheriting all functionalities of forward iterators, they introduce the ability to move in the reverse direction. Their design is particularly beneficial for data structures such as doubly linked lists, where bidirectional traversal is frequently required.</p>
			<p>Here’s an example using <code>std::list</code> and its bidirectional iterators:</p>
			<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;list&gt;
int main() {
  std::list&lt;int&gt; numbers = {1, 2, 3, 4, 5};
  std::cout &lt;&lt; "Traversing the list forwards:\n";
  for (std::list&lt;int&gt;::iterator it = numbers.begin();
       it != numbers.end(); ++it) {
    std::cout &lt;&lt; *it &lt;&lt; " ";
  }
  std::cout &lt;&lt; "\n";
  std::cout &lt;&lt; "Traversing the list backwards:\n";
  for (std::list&lt;int&gt;::reverse_iterator rit =
           numbers.rbegin();
       rit != numbers.rend(); ++rit) {
    std::cout &lt;&lt; *rit &lt;&lt; " ";
  }
  std::cout &lt;&lt; "\n";
  return 0;
}</pre>			<p>Here<a id="_idIndexMarker073"/> is the example output:</p>
			<pre class="console">
Traversing the list forwards:
1 2 3 4 5
Traversing the list backward:
5 4 3 2 1</pre>			<p>In this example, we<a id="_idIndexMarker074"/> create a <code>std::list</code> of integers. We then demonstrate bidirectional iteration by first traversing the list in a forward direction using a regular iterator and then in reverse using a reverse iterator.</p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor044"/>Random access iterators</h2>
			<p>Concluding <a id="_idIndexMarker075"/>our iterator categorization, we introduce the random access iterators (<em class="italic">LegacyRandomAccessIterator </em>and <em class="italic">LegacyContiguousIterator</em>). These iterators represent the <a id="_idIndexMarker076"/>highest versatility, enabling more than just sequential access. With random access iterators, developers can move forward by multiple steps, retreat backward, or access elements directly without sequential traversal. Such capabilities make them highly suitable for data structures such as arrays or vectors, which allow direct element access.</p>
			<p>Here’s an example showcasing the<a id="_idIndexMarker077"/> flexibility and <a id="_idIndexMarker078"/>capabilities of random access iterators with <code>std::vector</code>:</p>
			<pre class="source-code">
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;
std::mutex vecMutex;
void add_to_vector(std::vector&lt;int&gt; &amp;numbers, int value) {
  std::lock_guard&lt;std::mutex&gt; guard(vecMutex);
  numbers.push_back(value);
}
void print_vector(const std::vector&lt;int&gt; &amp;numbers) {
  std::lock_guard&lt;std::mutex&gt; guard(vecMutex);
  for (int num : numbers) { std::cout &lt;&lt; num &lt;&lt; " "; }
  std::cout &lt;&lt; "\n";
}
int main() {
  std::vector&lt;int&gt; numbers;
  std::thread t1(add_to_vector, std::ref(numbers), 1);
  std::thread t2(add_to_vector, std::ref(numbers), 2);
  t1.join();
  t2.join();
  std::thread t3(print_vector, std::ref(numbers));
  t3.join();
  return 0;
}</pre>			<p>This<a id="_idIndexMarker079"/> example demonstrates the various capabilities of random access iterators. We start with direct access, then jump positions, leap back, calculate distances, and even access elements in a non-linear manner.</p>
			<p>It is vital to<a id="_idIndexMarker080"/> understand that the choice of iterator type is not arbitrary. Each one is designed with specific use cases in mind, and choosing the right one can significantly enhance the efficiency and elegance of your C++ code. When working with STL algorithms and containers, having a solid grasp of the different iterator types and their functionalities is paramount. This knowledge not only streamlines the coding process but also aids in debugging and optimizing the performance of your applications.</p>
			<p>In exploring the STL’s iterators, we’ve learned the six core types: input, output, forward, reverse, bidirectional, and random access. Recognizing each type’s unique functions is vital for efficient C++ programming, as it affects how we traverse and interact with STL containers. Grasping these differences is not just academic; it’s practical. It enables us to choose the right iterator for tasks, such as using random access iterators with <code>std::vector</code> for their rapid element access capability.</p>
			<p>In the next section, we’ll apply this knowledge, where we’ll see iteration in action, emphasize the use of constant iterators for read-only purposes, and underscore the adaptability of iterators across various containers, setting the stage for robust and versatile code development.</p>
			<h1 id="_idParaDest-45"><a id="_idTextAnchor045"/>Basic iteration techniques with std::vector</h1>
			<p>Now that <a id="_idIndexMarker081"/>we understand the different types of iterators available, let’s explore the essential concept of iterating over data structures. Iteration is a<a id="_idIndexMarker082"/> fundamental technique in programming that allows developers to access and manipulate each element in a data structure efficiently. Specifically for <code>std::vector</code>, iteration is crucial due to its dynamic nature and widespread use in C++ applications. By mastering iteration, you can harness the full potential of <code>std::vector</code>, enabling operations such as searching, sorting, and modifying elements with precision <a id="_idIndexMarker083"/>and ease. This<a id="_idIndexMarker084"/> section aims to deepen your understanding of why iteration is a crucial skill in managing and utilizing data structures effectively, setting the stage for more advanced applications in your programs.</p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor046"/>Iterating over std::vector</h2>
			<p>One of <a id="_idIndexMarker085"/>the powerful features of <code>std::vector</code> is its ability to allow seamless traversal of its elements. Whether you’re accessing individual elements or looping through each one, understanding the iterative capabilities of <code>std::vector</code> is crucial. Iteration is fundamental to numerous operations in programming, from data processing to algorithmic transformations. As you journey through this section, you’ll become well acquainted with how to traverse vectors in C++ efficiently and effectively.</p>
			<p>At the heart of iteration in the C++ STL is the concept of iterators. Think of iterators as sophisticated pointers, guiding you through each element in a container, such as our beloved <code>std::vector</code>. Armed with iterators, one can move forward, backward, jump to the start or the end, and access the content they point to, making them indispensable tools in your C++ toolkit.</p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor047"/>Basic iteration using iterators</h2>
			<p>Every <code>std::vector</code> provides<a id="_idIndexMarker086"/> a set of member functions that return iterators. The two primary ones are <code>begin()</code> and <code>end()</code>. While we’ll dive deeper into these functions in the next section, understand that <code>begin()</code> returns an iterator pointing to the first element, and <code>end()</code> returns an iterator pointing just <em class="italic">past</em> the last element.</p>
			<p>For instance, to traverse a vector named <code>values</code>, you would typically use a loop, as shown in the following code:</p>
			<pre class="source-code">
for(auto it = values.begin(); it != values.end(); ++it) {
  std::cout &lt;&lt; *it &lt;&lt; "\n";
}</pre>			<p>In this code example, <code>it</code> is an iterator that moves through each element in values. The loop continues until <code>it</code> reaches the position indicated by <code>values.end()</code>.</p>
			<h2 id="_idParaDest-48"><a id="_idTextAnchor048"/>Using constant iterators</h2>
			<p>When<a id="_idIndexMarker087"/> you’re sure you won’t modify the elements during iteration, it is good practice to use constant iterators. They ensure that the elements remain immutable during traversal.</p>
			<p>Imagine you’re a museum guide showing visitors the precious artifacts. You want them to appreciate and understand the history, but you wouldn’t want them to touch or modify these delicate items. Similarly, in programming, there are scenarios where you’d like to traverse a collection, showcasing (or reading) its contents but not altering them. This is where constant iterators come into play.</p>
			<p>To employ a constant iterator, <code>std::vector</code> provides the <code>cbegin()</code> and <code>cend()</code> member functions:</p>
			<pre class="source-code">
for(auto cit = values.cbegin(); cit != values.cend(); ++cit) {
  std::cout &lt;&lt; *cit &lt;&lt; "\n";
}</pre>			<h2 id="_idParaDest-49"><a id="_idTextAnchor049"/>Benefits of iteration</h2>
			<p>Why is<a id="_idIndexMarker088"/> iteration so pivotal? By effectively iterating over vectors, you can do the following:</p>
			<ul>
				<li><strong class="bold">Process data</strong>: Whether normalizing data, filtering it, or performing any transformation, iteration is at the core of these operations.</li>
				<li><strong class="bold">Search operations</strong>: Looking for a particular element? Iteration allows you to comb through each item, checking against a condition or a value.</li>
				<li><code>sort</code>, <code>find</code>, and <code>transform</code>, require iterators to specify the range they operate on.</li>
			</ul>
			<p>The versatility and efficiency of <code>std::vector</code> iteration make it a prime choice for developers. While arrays also allow for traversal, vectors offer dynamic size, robustness against overflows, and integration with the rest of the C++ STL, making them a preferred choice in many scenarios.</p>
			<p>In conclusion, mastering<a id="_idIndexMarker089"/> iteration with <code>std::vector</code> is foundational to becoming proficient in C++. By understanding how to traverse this dynamic array, you unlock a wide range of capabilities, enabling you to harness the power of algorithms, efficiently process data, and craft robust, performant software. You’ll build a deeper understanding of other vector utilities as we progress, solidifying your knowledge and skills in this vibrant language.</p>
			<p>In this section, we’ve navigated <code>std::vector</code> traversal with iterators, learning to access elements sequentially and utilize constant iterators for read-only operations. Understanding these techniques is critical for crafting flexible and optimized C++ code compatible with various container types. Iteration is a cornerstone of data manipulation in the STL; mastering it is essential for harnessing the library’s full potential.</p>
			<p>Next, we turn to the <em class="italic">Using std::begin and std::end</em> section to further our iterator knowledge. We’ll uncover how these functions standardize the initiation and conclusion of iterations across different containers, paving the way for more versatile and decoupled code.</p>
			<h1 id="_idParaDest-50"><a id="_idTextAnchor050"/>Using std::begin and std::end</h1>
			<p>As you<a id="_idIndexMarker090"/> discover more use cases for <code>std::vector</code>, you’ll encounter <a id="_idIndexMarker091"/>situations where it is advantageous, or even necessary, to venture beyond member functions. Here’s where non-member functions, specifically <code>std::begin</code> and <code>std::end</code>, step into the spotlight. These two functions are handy and offer a more generic way to access the beginning and end of a container, including but not limited to <code>std::vector</code>.</p>
			<p>Why the distinction, you might ask? Aren’t there member functions such as <code>vector::begin()</code> and <code>vector::end()</code>? Indeed, there are. However, the beauty of the non-member <code>std::begin</code> and <code>std::end</code> is their broader applicability across different container types, making your code more flexible and adaptable.</p>
			<p>Vectors in C++ offer a potent blend of dynamic memory and continuous storage, making them indispensable in many coding scenarios. But to truly leverage their potential, understanding their interaction with iterators is crucial. While the spotlight often shines on the <code>begin()</code> and <code>end()</code> member functions, there are two versatile actors behind the curtains: <code>std::begin</code> and <code>std::end</code>.</p>
			<p>When <a id="_idIndexMarker092"/>working with C++ containers, the <code>std::begin</code> function might seem <a id="_idIndexMarker093"/>like another way to start iterating through a container. However, it comes with its own set of marvels. While it primarily fetches an iterator pointing to the first element of a container, its application isn’t limited to vectors alone.</p>
			<p>When you pass <code>std::vector</code> to <code>std::begin</code>, it is like having a backstage pass. Behind the scenes, the function smoothly delegates the task by calling the vector’s <code>begin()</code> member function. This intuitive behavior ensures that the transition remains seamless even as you venture into generic programming.</p>
			<p>Mirroring its counterpart, <code>std::end</code> is more than just a function that returns an iterator pointing past the last element. It’s a testament to C++’s commitment to consistency. Just as <code>std::begin</code> relies on <code>begin()</code>, when you engage with <code>std::end</code>, it subtly and efficiently calls upon the container’s <code>end()</code> member function.</p>
			<p>And here’s the true magic: while these non-member functions shine with <code>std::vector</code>, they are not constrained by it. Their generic nature means they play well with various containers, from traditional arrays to lists, making them indispensable tools for those seeking adaptability in their code.</p>
			<p>Let’s look at an example that demonstrates the utility of the <code>std::begin</code> and <code>std::end</code> non-member functions in contrast to their member counterparts:</p>
			<pre class="source-code">
#include &lt;array&gt;
#include &lt;iostream&gt;
#include &lt;list&gt;
#include &lt;vector&gt;
template &lt;typename Container&gt;
void displayElements(const Container &amp;c) {
  for (auto it = std::begin(c); it != std::end(c); ++it) {
    std::cout &lt;&lt; *it &lt;&lt; " ";
  }
  std::cout &lt;&lt; "\n";
}
int main() {
  std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};
  std::list&lt;int&gt; lst = {6, 7, 8, 9, 10};
  std::array&lt;int, 5&gt; arr = {11, 12, 13, 14, 15};
  std::cout &lt;&lt; "Elements in vector: ";
  displayElements(vec);
  std::cout &lt;&lt; "Elements in list: ";
  displayElements(lst);
  std::cout &lt;&lt; "Elements in array: ";
  displayElements(arr);
  return 0;
}</pre>			<p>In this<a id="_idIndexMarker094"/> preceding <a id="_idIndexMarker095"/>example, we notice the following:</p>
			<ul>
				<li>We have a <code>displayElements</code> generic function that takes any container and uses the <code>std::begin</code> and <code>std::end</code> non-member functions to iterate over its elements.</li>
				<li>We then create three containers: a <code>std::vector</code>, a <code>std::list</code>, and a <code>std::array.</code></li>
				<li>We call <code>displayElements</code> for each container to display its elements.</li>
			</ul>
			<p>Using <code>std::begin</code> and <code>std::end</code>, our <code>displayElements</code> function is versatile and works across different container types. This would not have been as straightforward if we relied solely on member functions such as <code>vector::begin()</code> and <code>vector::end()</code>, emphasizing the power and flexibility of non-member functions.</p>
			<p>Imagine <a id="_idIndexMarker096"/>being handed a toolkit that promises not just efficiency but also <a id="_idIndexMarker097"/>adaptability. That’s what <code>std::vector</code> offers, complemented beautifully by functions such as <code>std::begin</code> and <code>std::end</code>. They’re not just functions but gateways to more type-agnostic memory management and iteration.</p>
			<p>We’ve seen how <code>std::begin</code> and <code>std::end</code> elevate our code by extending iteration capabilities to all STL containers, not just <code>std::vector</code>. Embracing these non-member functions is key to crafting container-independent, reusable code—a pillar for versatile algorithm implementation in C++. Understanding this distinction is fundamental for employing iterators effectively across the STL.</p>
			<p>Looking ahead, the next section will guide us through the nuances of iterator categories and their essentials. This insight is pivotal for aligning algorithms with appropriate iterator capabilities, reflecting the depth of C++’s type system and its close ties with pointer semantics.</p>
			<h1 id="_idParaDest-51"><a id="_idTextAnchor051"/>Understanding iterator requirements</h1>
			<p>Iterators in C++ serve<a id="_idIndexMarker098"/> as a consistent interface to various data structures, such as containers and, since C++20, ranges. The iterator library supplies definitions for iterators and associated traits, adaptors, and utility functions.</p>
			<p>Given that iterators extend the idea of pointers, they inherently adopt many pointer semantics in C++. Consequently, any function template accepting iterators can also seamlessly work with regular pointers.</p>
			<p>Iterators are categorized into six types: <em class="italic">LegacyInputIterator</em>, <em class="italic">LegacyOutputIterator</em>, <em class="italic">LegacyForwardIterator</em>, <em class="italic">LegacyBidirectionalIterator</em>, <em class="italic">LegacyRandomAccessIterator</em>, and <em class="italic">LegacyContiguousIterator</em>. Instead of being determined by their intrinsic types, these categories are distinguished by the operations they support. As an illustration, pointers accommodate all the operations defined for <em class="italic">LegacyRandomAccessIterator</em>, allowing them to be utilized wherever a <em class="italic">LegacyRandomAccessIterator</em> is required.</p>
			<p>These iterator categories, except for <em class="italic">LegacyOutputIterator</em>, can be arranged hierarchically. More versatile iterator categories, such as <em class="italic">LegacyRandomAccessIterator</em>, encompass the capabilities of the less powerful ones, such as <em class="italic">LegacyInputIterator</em>. If an iterator conforms to any of these categories and also meets the criteria for <em class="italic">LegacyOutputIterator</em>, it’s termed a mutable iterator, capable of input and output functions. Iterators that aren’t mutable are referred to as constant iterators.</p>
			<p>In this section, we<a id="_idIndexMarker099"/> discovered the critical role of iterators as the unifying interface for C++ data structures, including containers and ranges. We examined how the iterator library in C++ defines iterator types, associated traits, adaptors, and utility functions, providing a standardized way to traverse these structures.</p>
			<p>We learned that iterators extend pointer semantics, allowing any function template that accepts iterators to work seamlessly with pointers. We further explored the hierarchy of iterator categories—<em class="italic">LegacyInputIterator</em>, <em class="italic">LegacyOutputIterator</em>, <em class="italic">LegacyForwardIterator</em>, <em class="italic">LegacyBidirectionalIterator</em>, <em class="italic">LegacyRandomAccessIterator</em>, and <em class="italic">LegacyContiguousIterator</em>. These categories are defined not by their types but by the operations they support, with more advanced iterators inheriting the capabilities of the simpler ones.</p>
			<p>This knowledge is crucial for us as it informs our choice of iterator based on the operations we need to perform. Understanding the requirements and capabilities of each iterator category enables us to write more efficient and robust code, as we can choose the least powerful iterator that satisfies our needs, thereby avoiding unnecessary performance overhead.</p>
			<p>In the next section, titled <em class="italic">Range-based for loops in C++</em>, we will transition from the theoretical underpinnings of iterators to practical application by learning how to use range-based <code>for</code> loops to iterate over <code>std::vector</code>. We will understand how these loops utilize <code>std::begin</code> and <code>std::end</code> under the hood, providing a more intuitive and error-resistant method for element access and modification.</p>
			<h1 id="_idParaDest-52"><a id="_idTextAnchor052"/>Range-based for loops</h1>
			<p>In C++, range-based <code>for</code> loops provide <a id="_idIndexMarker100"/>a concise and practical mechanism for iterating over containers such as <code>std::vector</code>. Armed with knowledge about <code>std::vector</code> operations and the <code>std::begin</code> and <code>std::end</code> functions, it’s evident that range-based <code>for</code> loops offer a streamlined traversal technique.</p>
			<p>Traditional iteration over a vector necessitates declaring an iterator, initializing it to the container’s start, and updating it to progress to the end. Although this method works, it requires careful management and is prone to errors. Range-based <code>for</code> loops present a more efficient solution.</p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor053"/>Overview of range-based for loops</h2>
			<p>The <a id="_idIndexMarker101"/>following code demonstrates the basic structure of a range-based <code>for</code> loop:</p>
			<pre class="source-code">
std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5};
for (int num : numbers) {
  std::cout &lt;&lt; num &lt;&lt; " ";
}</pre>			<p>In this example, every integer within the <code>numbers</code> vector is printed. This approach eliminates the need for explicit iterators and manual loop boundary definitions.</p>
			<h3>Underlying mechanism</h3>
			<p>Internally, the<a id="_idIndexMarker102"/> range-based <code>for</code> loop leverages the <code>begin()</code> and <code>end()</code> functions to navigate the container. The loop successively retrieves each item from the container, assigning it to the loop variable (<code>num</code> in this case).</p>
			<p>This approach simplifies the iteration process, allowing developers to concentrate on operations to perform on each element rather than the retrieval process.</p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor054"/>When to use range-based for loops</h2>
			<p>Range-based <code>for</code> loops are <a id="_idIndexMarker103"/>particularly beneficial in the following situations:</p>
			<ul>
				<li><code>for</code> loops are optimal for complete vector traversal.</li>
				<li><strong class="bold">Direct iterator access isn’t necessary</strong>: These loops are excellent for displaying or altering elements. However, traditional loops are more appropriate if access to the iterator itself is required (e.g., for mid-traversal element insertion or deletion).</li>
				<li><code>for</code> loops succinctly express the intention to operate on every container element.</li>
			</ul>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor055"/>Modifying elements during iteration</h2>
			<p>For <a id="_idIndexMarker104"/>scenarios where vector element modification is needed during iteration, it’s essential to use a reference as the loop variable, which is shown in the following code:</p>
			<pre class="source-code">
for (auto &amp;num : numbers) {
  num *= 2;
}</pre>			<p>In this case, each integer within the numbers vector is multiplied by two. Without the reference <code>(&amp;)</code>, the loop would alter a copied element, leaving the original vector untouched.</p>
			<p>Range-based <code>for</code> loops are a testament to C++’s ongoing development, striking a balance between performance and readability. They grant developers a direct way to navigate containers, enhancing code clarity and minimizing potential mistakes. As you progress in C++, it’s crucial to understand the available tools and select the most fitting ones for your tasks. A thorough grasp of <code>std::vector</code> functions and capabilities ensures effective utilization in diverse situations.</p>
			<p>This section highlighted range-based for loops’ advantages in iterating through STL containers, emphasizing their readability and minimized error potential compared to traditional <code>for</code> loops. Utilizing <code>std::begin</code> and <code>std::end</code>, these loops streamline the iteration process, letting us concentrate on the element-level logic. They are optimal when direct<a id="_idIndexMarker105"/> iterator control isn’t needed, exemplifying modern C++’s emphasis on high-level abstractions for efficiency and clarity.</p>
			<p>Moving forward, the <em class="italic">Creating a custom iterator</em> section will utilize our iterators for advanced abstraction, data transformation, or filtered data views. We’ll explore the technical requirements and how to align our custom iterators with the STL’s categorization.</p>
			<h1 id="_idParaDest-56"><a id="_idTextAnchor056"/>Creating a custom iterator</h1>
			<p>One<a id="_idIndexMarker106"/> of the beauties of C++ is its flexibility, empowering developers to mold the language to suit their needs. This flexibility doesn’t stop with built-in functionality for container iteration. While <code>std::vector</code> comes with its set of built-in iterators, nothing is stopping us from creating our own. But why might we want to?</p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor057"/>The appeal of custom iterators</h2>
			<p>Let’s examine<a id="_idIndexMarker107"/> the reasons you’d want to implement a custom iterator:</p>
			<ul>
				<li><strong class="bold">Enhanced abstraction</strong>: Consider a vector storing a matrix in a flat format. Wouldn’t it be more intuitive to iterate through rows or columns rather than individual elements? Custom iterators can facilitate this.</li>
				<li><strong class="bold">Data transformation</strong>: Perhaps you wish to iterate through the vector but retrieve transformed data, like the squared values of each element. Instead of changing the data before or during retrieval, a custom iterator can abstract this.</li>
				<li><code>std::vector</code>.</li>
			</ul>
			<p>Creating a custom STL iterator might seem like an arduous task, but with the proper guidance, it is a breeze! At its core, an iterator is a fancy pointer—a guide that escorts you through the elements of a container. To make your iterator play well with the STL, there are certain member functions you’ll need to implement.</p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor058"/>Core requirements</h2>
			<p>The <a id="_idIndexMarker108"/>exact set of these functions varies based on the type of iterator you’re <a id="_idIndexMarker109"/>creating, but some are common across the board.</p>
			<ol>
				<li><code>value_type</code>: Denotes the type of the element the iterator points to.</li><li><code>difference_type</code>: Represents the distance between two iterators.</li><li><code>pointer</code> and <code>reference</code>: Define the iterator’s pointer and reference types.</li><li><code>iterator_category</code>: Classifies the iterator into categories such as input, output, forward, bidirectional, or random access. Each category has its unique characteristics, making iterators versatile and fun!</li></ul></li>
				<li><code>operator*</code>: The <a id="_idIndexMarker110"/>dereference operator, granting access to the element your iterator points to.</li><li><code>operator++</code>: The increment operators! These move your iterator forward (either in pre-increment or post-increment style).</li><li><code>operator==</code> and <code>operator!=</code>: Equipped with these, your iterators can be compared, letting algorithms know if they’ve reached the end or need to keep going.</li></ul></li>
			</ol>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor059"/>Iterator categories and their specialties</h2>
			<p>Iterators<a id="_idIndexMarker111"/> come in different flavors; each flavor (or category) has unique requirements:</p>
			<ul>
				<li><code>operator*</code>, <code>operator++</code>, <code>operator==</code>, and <code>operator!=</code></li></ul></li>
				<li><code>operator*</code> and <code>operator++</code></li></ul></li>
				<li><strong class="bold">Forward iterators</strong>: They combine input and output iterators—reading, writing, and always moving forward.<ul><li><strong class="bold">Essential</strong>: All the core requirements</li></ul></li>
				<li><code>operator--</code> to step back</li></ul></li>
				<li><code>std::vector</code>.<ul><li><code>operator+</code>, <code>operator-</code>, <code>operator+=</code>, <code>operator-=</code>, <code>operator[]</code>, and relational operators such as <code>operator&lt;</code>, <code>operator&lt;=</code>, <code>operator&gt;</code>, and <code>operator&gt;=</code></li></ul><p class="list-inset">A random access iterator in C++ is one of the most potent iterator categories and requires several <a id="_idIndexMarker112"/>functions and operators to be fully compatible with STL algorithms and containers.</p></li>
			</ul>
			<p>Here’s a list of functions and operators you’d typically implement for a random access iterator:</p>
			<ul>
				<li><code>iterator_category</code> (should be set to <code>std::random_access_iterator_tag</code>)</li><li><code>value_type</code></li><li><code>difference_type</code></li><li><code>pointer</code></li><li><code>reference</code></li></ul></li>
				<li><code>operator*()</code> (dereference operator)</li><li><code>operator-&gt;()</code> (arrow operator)</li></ul></li>
				<li><code>operator++()</code> (prefix increment)</li><li><code>operator++(int)</code> (postfix increment)</li><li><code>operator--()</code> (prefix decrement)</li><li><code>operator--(int)</code> (postfix decrement)</li></ul></li>
				<li><code>ptrdiff_t</code>):<ul><li><code>operator+(difference_type)</code> (move iterator forward by some amount)</li><li><code>operator-(difference_type)</code> (move iterator backward by some amount)</li><li><code>operator+=(difference_type)</code> (increment iterator by some amount)</li><li><code>operator-=(difference_type)</code> (decrement iterator by some amount)</li></ul></li>
				<li><code>operator-(const RandomAccessIteratorType&amp;)</code></li></ul></li>
				<li><code>operator[](difference_type)</code></li></ul></li>
				<li><code>operator==</code> (equality)</li><li><code>operator!= </code>(inequality)</li><li><code>operator&lt;</code> (less than)</li><li><code>operator&lt;= </code>(less than or equal to)</li><li><code>operator&gt;</code> (greater than)</li><li><code>operator&gt;=</code> (greater than or equal to)</li></ul></li>
				<li><strong class="bold">Swap</strong> (sometimes useful, though not strictly required for the iterator itself):<ul><li>A swap function to swap two iterators</li></ul></li>
			</ul>
			<p>Not all of these <a id="_idIndexMarker113"/>will always be applicable, especially if the underlying data structure has limitations or the iterator’s specific usage case doesn’t require all these operations. However, for full compatibility with STL’s random access iterators, this is the complete set of functions and operators you’d want to consider implementing.</p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor060"/>A custom iterator example</h2>
			<p>Let’s <a id="_idIndexMarker114"/>create a custom iterator for <code>std::vector&lt;int&gt;</code> that, when dereferenced, returns the square of the value in the vector:</p>
			<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;
class SquareIterator {
public:
  using iterator_category =
      std::random_access_iterator_tag;
  using value_type = int;
  using difference_type = std::ptrdiff_t;
  using pointer = int *;
  using reference = int &amp;;
  explicit SquareIterator(pointer ptr) : ptr(ptr) {}
  value_type operator*() const { return (*ptr) * (*ptr); }
  pointer operator-&gt;() { return ptr; }
  SquareIterator &amp;operator++() {
    ++ptr;
    return *this;
  }
  SquareIterator operator++(int) {
    SquareIterator tmp = *this;
    ++ptr;
    return tmp;
  }
  SquareIterator &amp;operator+=(difference_type diff) {
    ptr += diff;
    return *this;
  }
  SquareIterator operator+(difference_type diff) const {
    return SquareIterator(ptr + diff);
  }
  value_type operator[](difference_type diff) const {
    return *(ptr + diff) * *(ptr + diff);
  }
  bool operator!=(const SquareIterator &amp;other) const {
    return ptr != other.ptr;
  }
private:
  pointer ptr;
};
int main() {
  std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};
  SquareIterator begin(vec.data());
  SquareIterator end(vec.data() + vec.size());
  for (auto it = begin; it != end; ++it) {
    std::cout &lt;&lt; *it &lt;&lt; ' ';
  }
  SquareIterator it = begin + 2;
  std::cout &lt;&lt; "\nValue at position 2: " &lt;&lt; *it;
  std::cout
      &lt;&lt; "\nValue at position 3 using subscript operator: "
      &lt;&lt; it[1];
  return 0;
}</pre>			<p>When run, this code will output the following:</p>
			<pre class="console">
1 4 9 16 25
Value at position 2: 9
Value at position 3 using subscript operator: 16</pre>			<p>The iterators<a id="_idIndexMarker115"/> in the code can be used very similarly to a built-in array or <code>std::vector</code> iterators but with the unique functionality of squaring values when dereferenced.</p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor061"/>Custom iterator challenges and use cases</h2>
			<p>Creating a <a id="_idIndexMarker116"/>custom iterator isn’t just about understanding your<a id="_idIndexMarker117"/> data or use case; it is also about grappling with some challenges:</p>
			<ul>
				<li><strong class="bold">Complexity</strong>: Crafting an iterator requires adherence to certain iterator concepts. Different requirements must be met whether it is an input, forward, bidirectional, or random access iterator.</li>
				<li><code>push_back</code> or <code>erase</code>. Ensuring the custom iterator remains valid is essential for safe and predictable behavior.</li>
				<li><strong class="bold">Performance overhead</strong>: With added functionality can come extra computation. Ensuring that the iterator’s overhead doesn’t negate its benefits is crucial.</li>
			</ul>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor062"/>Illustrative use cases of custom iterators</h2>
			<p>To wrap our<a id="_idIndexMarker118"/> minds around the idea, let’s briefly look at a couple of scenarios where custom iterators shine:</p>
			<ul>
				<li><code>std::vector</code> might store pixel data linearly for an image. A custom iterator could facilitate iteration by rows, channels, or even regions of interest.</li>
				<li><code>std::vector&lt;char&gt;</code>, an iterator could be designed to jump from word to word or sentence to sentence, ignoring whitespace and punctuation.</li>
				<li><strong class="bold">Statistical sampling</strong>: An iterator might sample every <em class="italic">n</em>th element for large datasets stored in vectors, providing a quick overview without traversing each element.</li>
			</ul>
			<p>Creating a custom iterator involves adhering to specific conventions and defining a set of required operators to give it the behavior of an iterator.</p>
			<p>The following code shows us how to create a custom iterator for extracting the alpha channel from a bitmap stored in <code>std::vector</code>:</p>
			<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;
struct RGBA {
  uint8_t r, g, b, a;
};
class AlphaIterator {
public:
  using iterator_category = std::input_iterator_tag;
  using value_type = uint8_t;
  using difference_type = std::ptrdiff_t;
  using pointer = uint8_t *;
  using reference = uint8_t &amp;;
  explicit AlphaIterator(std::vector&lt;RGBA&gt;::iterator itr)
      : itr_(itr) {}
  reference operator*() { return itr_-&gt;a; }
  AlphaIterator &amp;operator++() {
    ++itr_;
    return *this;
  }
  AlphaIterator operator++(int) {
    AlphaIterator tmp(*this);
    ++itr_;
    return tmp;
  }
  bool operator==(const AlphaIterator &amp;other) const {
    return itr_ == other.itr_;
  }
  bool operator!=(const AlphaIterator &amp;other) const {
    return itr_ != other.itr_;
  }
private:
  std::vector&lt;RGBA&gt;::iterator itr_;
};
int main() {
  std::vector&lt;RGBA&gt; bitmap = {
      {255, 0, 0, 128}, {0, 255, 0, 200}, {0, 0, 255, 255},
      // ... add more colors
  };
  std::cout &lt;&lt; "Alpha values:\n";
  for (AlphaIterator it = AlphaIterator(bitmap.begin());
       it != AlphaIterator(bitmap.end()); ++it) {
    std::cout &lt;&lt; static_cast&lt;int&gt;(*it) &lt;&lt; " ";
  }
  std::cout &lt;&lt; "\n";
  return 0;
}</pre>			<p>We’ve<a id="_idIndexMarker119"/> defined an <code>RGBA</code> struct in this example to represent the color. We then create a custom <code>AlphaIterator</code> iterator to navigate the alpha channel. Next, the iterator uses the underlying <code>std::vector&lt;RGBA&gt;::iterator</code>, but exposes only the alpha channel when dereferenced. Finally, the <code>main</code> function demonstrates using this iterator to print alpha values.</p>
			<p>This custom iterator adheres to the conventions of a C++ input iterator, making it usable with various algorithms and range-based <code>for</code> loops. The <code>AlphaIterator</code> class in the example demonstrates a custom input iterator’s basic structure and behavior in C++. Here’s a breakdown<a id="_idIndexMarker120"/> of the key member functions and their significance for STL compatibility:</p>
			<ul>
				<li><code>iterator_category</code>: Defines the type/category of the iterator. It helps algorithms determine the operations supported by the iterator. Here, it is defined as <code>std::input_iterator_tag</code>, indicating it is an input iterator.</li><li><code>value_type</code>: The data type that can be read from the underlying container. Here, it is <code>uint8_t</code> representing the alpha channel.</li><li><code>difference_type</code>: Used to represent the result of subtracting two iterators. Commonly used in random access iterators.</li><li><code>pointer</code> and <code>reference</code>: The pointer and reference types to <code>value_type</code>. They give direct access to the value.</li></ul></li>
				<li><code>explicit AlphaIterator</code>(<code>std::vector&lt;RGBA&gt;::iterator itr</code>): This constructor is essential to initialize the iterator with an instance of the underlying <code>std::vector</code> iterator.</li></ul></li>
				<li><code>reference operator*()</code>: The dereference operator returns a reference to the current item in the sequence. For this iterator, it returns a reference to the alpha channel of the RGBA value.</li></ul></li>
				<li><code>AlphaIterator&amp; operator++()</code>: The pre-increment operator advances the iterator to the next element.</li><li><code>AlphaIterator operator++(int)</code>: The post-increment operator advances the iterator to the next element but returns an iterator to the current element before the increment. This behavior is needed for constructs such as <code>it++</code>.</li></ul></li>
				<li><code>bool operator==(const AlphaIterator&amp; other) const</code>: Checks whether two iterators point to the same position. This is crucial for comparison and to determine the end of a sequence.</li><li><code>bool operator!=(const AlphaIterator&amp; other) const</code>: The opposite of the previous one: this checks whether two iterators are not equal.</li></ul></li>
			</ul>
			<p>These member <a id="_idIndexMarker121"/>functions and type aliases are essential to make the iterator compatible with the STL and enable its seamless use with various STL algorithms and constructs. They define the fundamental interface and semantics required for a functioning input iterator.</p>
			<p>Additional operations would be required for iterators with more capabilities (such as bidirectional or random access). But for the input iterator demonstrated in the <code>AlphaIterator</code>, the preceding are the core components.</p>
			<p>This section covered custom iterators and understanding their creation for specific needs such as data abstraction, transformation, and filtering. Learning to define essential type aliases and implement key operators is crucial in extending the functionality of <code>std::vector</code>. This knowledge lets us customize data interaction, ensuring our code meets the unique domain requirements with precision.</p>
			<h1 id="_idParaDest-63"><a id="_idTextAnchor063"/>Summary</h1>
			<p>In this chapter, we have comprehensively explored the role and usage of iterators as they apply to one of the most versatile containers in the C++ STL. We started by discussing the various types of iterators available in the STL—input, output, forward, reverse, bidirectional, and random access—and their specific applications and support operations.</p>
			<p>We then moved on to practical iteration techniques, detailing how to traverse <code>std::vector</code> effectively using standard and constant iterators. We underscored the importance of choosing the correct type of iterator for the task at hand to write clean, efficient, and error-resistant code.</p>
			<p>The section on using <code>std::begin</code> and <code>std::end</code> expanded our toolkit, showing how these non-member functions can make our code more flexible by not being tightly bound to container types. We also covered the requirements and categorization of iterators, essential knowledge for understanding the STL’s inner workings, and implementing custom iterators.</p>
			<p>Range-based <code>for</code> loops were introduced as a modern C++ feature that simplifies iteration by abstracting the details of iterator management. We learned when and how to use these loops to their fullest potential, particularly noting the ease with which they allow the modification of elements during iteration.</p>
			<p>Finally, we tackled the advanced topic of creating custom iterators. We discovered the motivations behind this, such as providing more intuitive navigation or presenting a filtered data view. We examined the core requirements, challenges, and use cases for custom iterators, rounding out our understanding of how they can be tailored to fit specialized needs.</p>
			<p>While the standard iterators provided with <code>std::vector</code> cover many use cases, they’re not the end of the story. Custom iterators offer an avenue to stretch the boundaries of what’s possible with iteration, tailor-fitting traversal logic to specific needs. The complexity of crafting reliable custom iterators is not to be underestimated. As we close this chapter, remember that custom iterators can be powerful tools in the right hands. You can make informed decisions about when and how to wield them with a solid understanding of their workings.</p>
			<p>The knowledge gained in this chapter is beneficial as it enables the creation of more sophisticated, robust, and performant C++ applications. Understanding and utilizing iterators effectively allows us to harness the full power of <code>std::vector</code> and write container-agnostic and highly optimized algorithms.</p>
			<p>The upcoming chapter, <em class="italic">Mastering Memory and Allocators with std::vector</em>, builds upon our existing knowledge and directs our focus toward memory efficiency, a critical aspect of high-performance C++ programming. We will continue to emphasize the practical, real-world applications of these concepts, ensuring that the content remains valuable and directly applicable to our work as intermediate-level C++ developers.</p>
		</div>
	</body></html>