- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: External Interrupts and Events (EXTI)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn about interrupts and their critical role in embedded
    systems development. Interrupts are pivotal for creating responsive and efficient
    firmware, allowing microcontrollers to handle real-time events effectively. By
    understanding interrupts, you can develop systems that can react promptly to external
    stimuli, making your embedded applications more robust and versatile.
  prefs: []
  type: TYPE_NORMAL
- en: We will begin by exploring the fundamental role of interrupts in firmware, contrasting
    them with exceptions to highlight their unique purposes and handling mechanisms.
    Following this, we will dive into the specifics of the **Interrupt Service Routine**
    (**ISR**), the **Interrupt Vector Table** (**IVT**), and the **Nested Vectored
    Interrupt Controller** (**NVIC**), which collectively form the backbone of interrupt
    handling in Arm Cortex-M microcontrollers.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will focus on the STM32 **External Interrupt** (**EXTI**) controller,
    an essential peripheral for managing external interrupts in STM32 microcontrollers.
    We will examine the key features and registers of the EXTI controller, learning
    how to configure and utilize it for various applications.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will apply this knowledge by developing an EXTI driver, providing
    you with practical experience in implementing interrupt-driven firmware. This
    hands-on approach will solidify your understanding and enable you to create responsive,
    interrupt-based systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Interrupts and their role in firmware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The STM32 EXTI controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing the EXTI driver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a comprehensive understanding of interrupts
    and how to develop bare-metal EXTI drivers for STM32 microcontrollers, empowering
    you to create responsive and efficient embedded systems.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All the code examples for this chapter can be found on GitHub at the following
    link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming](https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming)'
  prefs: []
  type: TYPE_NORMAL
- en: Interrupts and their role in firmware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interrupts are one of the most critical mechanisms in embedded systems, allowing
    microcontrollers to react to real-time events efficiently. To fully appreciate
    their role in firmware, it’s essential to understand what interrupts are, how
    they work, and the various scenarios where they prove indispensable. So, let’s
    dive in and explore the fascinating world of interrupts, their operation, and
    their practical applications.
  prefs: []
  type: TYPE_NORMAL
- en: What are interrupts?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine you’re deeply engrossed in reading a book but then the doorbell rings.
    You momentarily stop reading, attend to the visitor, and then return to your book.
    Interrupts in microcontrollers work similarly. They are signals that temporarily
    halt the current execution of a program to allow a special routine, known as an
    ISR, to run. Once the ISR completes, the microcontroller resumes its previous
    task right where it left off.
  prefs: []
  type: TYPE_NORMAL
- en: Interrupts can be triggered by hardware events, such as a timer overflow, a
    key press, or data reception on a communication interface. They can also be generated
    by software, providing a flexible way to manage both external and internal events.
    Now, let’s see how they work.
  prefs: []
  type: TYPE_NORMAL
- en: How do interrupts work?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At the heart of interrupt handling is the concept of context switching. When
    an interrupt occurs, the microcontroller saves its current state—essentially,
    a snapshot of all the important information, such as the program counter and CPU
    registers. This allows the microcontroller to pause its current task, execute
    the ISR, and then restore the saved state to continue where it left off. The process
    typically follows these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Interrupt request**: An event triggers an **Interrupt** **Request** (**IRQ**).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Acknowledge and prioritize**: The interrupt controller acknowledges the request
    and prioritizes it based on predefined levels.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Context save**: The CPU saves its current execution context.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Vector fetch**: The CPU fetches the address of the ISR from the IVT.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**ISR execution**: The ISR runs to handle the interrupt.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Context restore**: After the ISR completes, the CPU restores the saved context.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Resume execution**: The CPU resumes the interrupted task.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You may wonder why interrupts are important. Let’s find out.
  prefs: []
  type: TYPE_NORMAL
- en: Importance of interrupts in firmware
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Interrupts are important for creating efficient and responsive embedded systems.
    Here are some key reasons why they are so important:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Real-time response**: Interrupts allow a microcontroller to react almost
    instantaneously to critical events. For instance, in a motor control system, an
    interrupt can immediately handle a sensor signal indicating that the motor has
    reached its desired position.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource optimization**: Instead of constantly polling for events (which
    wastes CPU cycles and power), interrupts enable the CPU to remain in a low-power
    state or focus on other tasks until an event occurs. This optimization is crucial
    for battery-powered devices such as wearables or remote sensors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prioritization and preemption**: Interrupts can be prioritized, allowing
    more critical tasks to preempt less critical ones. This ensures that high-priority
    tasks, such as emergency stop signals in industrial machinery, are addressed immediately.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When discussing interrupts, we often encounter another key term: exceptions.
    Although they share similarities, they serve different purposes in embedded systems.
    Let’s explore the differences between interrupts and exceptions.'
  prefs: []
  type: TYPE_NORMAL
- en: Interrupts versus exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Interrupts are signals from hardware or software indicating an event that needs
    immediate attention. Examples include timer overflows, GPIO pin changes, and peripheral
    data reception.
  prefs: []
  type: TYPE_NORMAL
- en: As we learned earlier, interrupts enable embedded systems to handle real-time
    events and are essential for responsive and efficient system behavior. When an
    interrupt occurs, the CPU stops executing the main program and jumps to a predefined
    address to execute the ISR.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions are events that disrupt the normal execution flow, often due to errors
    such as divide-by-zero operations or accessing invalid memory addresses. While
    similar to interrupts, exceptions typically handle error conditions and system-level
    events.
  prefs: []
  type: TYPE_NORMAL
- en: Differences between interrupts and exceptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are some of the differences between the two:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source**: Interrupts usually originate from external hardware devices or
    other peripherals within the microcontroller, while exceptions are typically the
    result of internal CPU operations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Purpose**: Interrupts manage real-time events, whereas exceptions handle
    error conditions and system anomalies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Handling**: Both use ISRs, but exceptions often involve more complex error
    handling and recovery mechanisms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To properly understand how interrupts are handled, we need to examine the three
    key components involved: the NVIC, the ISR, and the IVT.'
  prefs: []
  type: TYPE_NORMAL
- en: The NVIC, ISR, and IVT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The NVIC in Arm Cortex-M microcontrollers, such as the STM32 series, plays a
    pivotal role in managing interrupts. Let’s explore what the NVIC is, how it works,
    and why it’s so important for embedded development.
  prefs: []
  type: TYPE_NORMAL
- en: The NVIC
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The NVIC is a hardware module integrated into Arm Cortex-M microcontrollers
    that manages the prioritization and handling of interrupts. It enables the microcontroller
    to respond to interrupts quickly and efficiently, while also allowing for nested
    interrupts, where higher-priority interrupts can preempt lower-priority ones.
    This capability is essential for real-time applications where timely responses
    to events are critical.
  prefs: []
  type: TYPE_NORMAL
- en: 'Its key features include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Interrupt prioritization**: The NVIC supports multiple priority levels, allowing
    us to assign different priorities to different interrupts. This ensures that more
    critical tasks are handled first.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Nested interrupts**: The NVIC allows higher-priority interrupts to interrupt
    lower-priority ones. This feature is crucial for maintaining system responsiveness
    in real-time applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic priority adjustment**: We can dynamically adjust the priority of
    interrupts during runtime, providing flexibility to adapt to changing conditions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The diagram in *Figure 14**.1* illustrates the NVIC and its connections to various
    components within the microcontroller.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 14.1: The NVIC](img/B21914_14_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.1: The NVIC'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have the ISR.
  prefs: []
  type: TYPE_NORMAL
- en: The ISR
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The ISR is a crucial piece of the puzzle when it comes to handling interrupts
    in embedded systems. The ISR is a specialized function that the CPU executes in
    response to an interrupt. Every interrupt has its own ISR. When an interrupt occurs,
    the CPU temporarily halts its current task, saves its state, and jumps to the
    ISR’s predefined address (function) to execute the necessary code.
  prefs: []
  type: TYPE_NORMAL
- en: The final critical component is the IVT.
  prefs: []
  type: TYPE_NORMAL
- en: The IVT
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The IVT is like the roadmap for the CPU when an interrupt occurs. It’s a data
    structure that holds the addresses of all the ISRs. Each interrupt source is assigned
    a specific entry in this table, mapping it to its corresponding ISR. When an interrupt
    is triggered, the CPU consults the IVT to find the address of the ISR associated
    with that interrupt. This lookup ensures that the CPU can quickly and efficiently
    jump to the right piece of code to handle the event.
  prefs: []
  type: TYPE_NORMAL
- en: 'Its key features include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`0x00000000`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ISR addresses**: Each entry in the IVT contains the address of an ISR. When
    an interrupt occurs, the CPU uses the IVT to quickly locate and jump to the appropriate
    ISR.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0` might be for a reset interrupt, vector number `1` for a **non-maskable
    interrupt** (**NMI**), and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configurable**: In many systems, the IVT can be configured during system
    initialization to point to the ISRs defined in your firmware.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparative analysis—interrupt-driven solutions versus polling-based solutions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: But what happens when we don’t use interrupts? Let’s explore some real-world
    case studies to illustrate the difference between solutions using interrupts and
    those that rely on polling.
  prefs: []
  type: TYPE_NORMAL
- en: Case study 1—button debouncing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In embedded systems, handling user inputs such as button presses is a common
    task. However, the way these inputs are managed can significantly impact the efficiency
    and responsiveness of the system. One particular issue is dealing with the problem
    of “bouncing,” where a mechanical button generates multiple rapid signals due
    to its physical characteristics. This can lead to incorrect readings and erratic
    behavior if not properly managed. In this case study, we will explore two approaches
    to handling button debouncing: one without interrupts and the other using interrupts.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start with the approach that doesn’t use interrupts.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you have a simple user interface with a button that, when pressed, toggles
    an LED. Without interrupts, the most straightforward approach is to continuously
    check (or “poll”) the button’s state in the main loop. This involves repeatedly
    reading the button’s input pin to see whether it has changed from high to low,
    indicating a press. The problem here is that mechanical buttons can generate spurious
    signals due to physical bouncing, leading to multiple detections of a single press.
    To handle this, you need to add a delay after detecting a press, effectively ignoring
    further signals for a short period.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Inefficiency**: The CPU is constantly busy checking the button state, wasting
    valuable processing time that could be used for other tasks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Delayed response**: Adding a delay to handle debouncing means the system
    might miss other important tasks while waiting for the button to stabilize'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s look at the approach with interrupts.
  prefs: []
  type: TYPE_NORMAL
- en: Using interrupts, you configure the button pin to generate an interrupt on a
    falling edge (when the button is pressed). The ISR is triggered immediately when
    the button is pressed, handling the debouncing logic. The main loop remains free
    to perform other tasks without the overhead of constantly polling the button.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Efficiency**: The CPU can focus on other tasks and only respond to the button
    press when necessary'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Immediate response**: The ISR responds instantly to the button press, making
    the system more responsive'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Case study 2—sensor data acquisition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another common task in embedded systems is acquiring data from sensors, especially
    in applications such as weather stations, where multiple sensors continuously
    monitor environmental conditions. The method used to handle sensor data acquisition
    can greatly affect the system’s complexity and efficiency. Let’s compare two approaches:
    one without using interrupts and the other leveraging interrupts to optimize the
    process.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start with the approach that doesn’t use interrupts.
  prefs: []
  type: TYPE_NORMAL
- en: Consider a weather station that reads data from various sensors such as temperature,
    humidity, and pressure at regular intervals. Without interrupts, the main loop
    would include code to periodically read data from each sensor. This could be done
    using timers to create delays between readings, ensuring data is acquired at the
    right intervals.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Complexity**: Managing multiple sensors with precise timing using polling
    can lead to a complicated main loop'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inefficiency**: The main loop might spend a lot of time waiting for timers
    to expire—again, wasting CPU resources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s look at the approach with interrupts.
  prefs: []
  type: TYPE_NORMAL
- en: Using interrupts, each sensor can trigger an interrupt when new data is available.
    The ISR for each sensor reads the data and stores it in a buffer for the main
    loop to process later. This approach decouples data acquisition from the main
    loop, allowing it to focus on data processing and other tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simplified code**: The main loop is cleaner and easier to manage, as it doesn’t
    need to handle timing and sensor polling directly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource efficiency**: The CPU spends less time waiting and more time processing,
    leading to more efficient use of resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Case study 3—communication protocols
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, let’s see how interrupts can improve communication. Effective communication
    between a microcontroller and external devices is crucial for many embedded systems,
    whether you’re dealing with sensors, displays, or other peripherals. The approach
    you take to manage data transmission and reception can have a significant impact
    on your system’s performance, particularly in terms of CPU load and latency. Let’s
    analyze two methods for handling communication over **Universal Asynchronous Receiver/Transmitter**
    (**UART**): one without using interrupts and the other leveraging interrupts to
    optimize the process.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start with the approach that doesn’t use interrupts.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at a scenario where a microcontroller communicates with another device
    over UART. Without interrupts, the firmware would continuously check the UART
    status register to see whether new data has arrived or whether the transmitter
    is ready to send data. This polling approach ensures no data is missed, but it
    can be very CPU-intensive.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Resource efficiency**: Continuous polling keeps the CPU busy, leaving less
    processing power for other tasks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Latency**: The time between data arrival and processing depends on how frequently
    the UART status is checked'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s look at the approach with interrupts.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling UART interrupts allows the microcontroller to handle data reception
    and transmission events automatically. When new data arrives, an interrupt is
    triggered, and the ISR reads the data and processes it. Similarly, when the transmitter
    is ready, another interrupt can handle sending data.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Low CPU load**: The CPU can perform other tasks and only deal with UART events
    when necessary'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Real-time handling**: Data is processed immediately upon arrival, reducing
    latency and improving communication efficiency'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interrupts provide a powerful and efficient way to handle real-time events in
    embedded systems. Compared to polling methods, interrupts offer significant benefits
    in terms of responsiveness, efficiency, and code simplicity. By understanding
    and leveraging interrupts, you can develop more robust and efficient firmware,
    capable of handling a wide range of real-time applications. Whether it’s managing
    user inputs, acquiring sensor data, handling communication protocols, or maintaining
    accurate timekeeping, interrupts are an indispensable tool.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we shall explore the STM32 EXTI controller peripheral.
  prefs: []
  type: TYPE_NORMAL
- en: The STM32 EXTI controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The EXTI module in STM32 microcontrollers is designed to manage external interrupt
    lines. These lines can be triggered by signals on GPIO pins, enabling your microcontroller
    to react to changes in the external environment quickly and efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: The EXTI controller is equipped with a range of features that enhance its flexibility
    and utility in embedded systems. Let’s explore these features in detail and understand
    their practical applications.
  prefs: []
  type: TYPE_NORMAL
- en: Key features of the EXTI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are the key features of the EXTI module that make it a versatile and powerful
    tool for managing external and internal events in STM32 microcontrollers:'
  prefs: []
  type: TYPE_NORMAL
- en: Provides up to 23 independent interrupt/event lines, with up to 16 from GPIO
    pins, and the rest from internal signals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each line can be independently configured as either an interrupt or an event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Edge detection options for each line: rising, falling, or both edges'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dedicated status flags for each line to indicate pending interrupts/events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ability to generate software interrupts/events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An event registers that something happened by setting a corresponding status
    flag bit, but does not trigger an interrupt or execute any code (ISR).
  prefs: []
  type: TYPE_NORMAL
- en: For example, events can be used to wake the system from sleep mode without executing
    an ISR.
  prefs: []
  type: TYPE_NORMAL
- en: To use the EXTI for generating interrupts, we need to configure and enable the
    interrupt line properly. This involves programming the trigger registers to detect
    the desired edge (rising, falling, or both) and enabling the IRQ by setting the
    appropriate bit in the interrupt mask register. When the specified edge is detected
    on the external interrupt line, an IRQ is generated, and the corresponding pending
    bit is set. This pending bit must be cleared by writing a *1* to it in the pending
    register.
  prefs: []
  type: TYPE_NORMAL
- en: To generate events, we simply configure the event line by setting the appropriate
    trigger registers and enabling the corresponding bit in the event mask register.
  prefs: []
  type: TYPE_NORMAL
- en: We can also generate interrupts/events by software by writing a *1* to the software
    interrupt/event register (EXTI_SWIER).
  prefs: []
  type: TYPE_NORMAL
- en: 'Configuring the lines as interrupt sources involves three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Configure mask bits**: Set the mask bits for the 23 interrupt lines using
    the **Interrupt Mask** **Register** (**EXTI_IMR**).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Configure trigger selection bits**: Use the **Rising Trigger Selection Register**
    (**EXTI_RTSR**) and **Falling Trigger Selection Register** (**EXTI_FTSR**) to
    set the desired trigger conditions for the interrupt lines.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Enable the NVIC IRQ channel**: Over here, we simply configure the **enable**
    and **mask** bits that control the NVIC IRQ channel mapped to the EXTI.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before we develop the EXTI driver, let’s first understand how the EXTI lines
    are mapped to the GPIO pins.
  prefs: []
  type: TYPE_NORMAL
- en: External interrupt/event line mapping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The EXTI controller can connect up to 81 GPIOs (in the STM32F411xC/E series)
    to the 16 external interrupt/event lines. The GPIO pins are mapped to the EXTI
    lines through the SYSCFG_EXTICR registers.
  prefs: []
  type: TYPE_NORMAL
- en: GPIO pins and EXTI lines
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Each GPIO pin on the STM32 microcontroller can be connected to an EXTI line,
    allowing it to generate external interrupts. This flexibility means you can enable
    interrupts for any GPIO pin, but there’s a catch: multiple pins share the same
    EXTI line. This sharing is based on the pin number, not the port.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a breakdown of how the pins are connected:'
  prefs: []
  type: TYPE_NORMAL
- en: Pin 0 of every port is connected to EXTI0_IRQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pin 1 of every port is connected to EXTI1_IRQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pin 2 of every port is connected to EXTI2_IRQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pin 3 of every port is connected to EXTI3_IRQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And so on...
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This mapping means that all pins with the same number across different ports
    share the same EXTI line. For example, PA0, PB0, PC0, PD0, PE0, and PH0 are all
    connected to EXTI0.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: '**Shared EXTI lines**: Since multiple pins share the same EXTI line, you cannot
    enable interrupts on two pins with the same number across different ports simultaneously.
    For instance, if you enable an interrupt on PB0, you cannot also enable an interrupt
    on PA0 because both pins share EXTI0.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Configuration in SYSCFG_EXTICR**: The SYSCFG **external interrupt configuration
    registers** (**EXTICRs**) are used to select which port’s pin will be connected
    to a particular EXTI line. This selection ensures that only one pin from one port
    can be the source for a given EXTI line.'
  prefs: []
  type: TYPE_NORMAL
- en: Developing the EXTI driver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The STM32 EXTI module relies on several key registers to configure its operation.
    These registers allow you to set up trigger conditions, enable interrupts, and
    manage pending interrupt requests. Understanding these registers is crucial for
    effectively using the EXTI module in your embedded projects.
  prefs: []
  type: TYPE_NORMAL
- en: EXTI_IMR
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We use the EXTI_IMR to enable or disable interrupts on each EXTI line.
  prefs: []
  type: TYPE_NORMAL
- en: The bits in this register are named `x` = `0` to `22`). Setting a bit to `1`
    unmasks the interrupt line, allowing it to generate an interrupt request. Conversely,
    setting it to `0` masks the line, preventing it from generating interrupts.
  prefs: []
  type: TYPE_NORMAL
- en: EXTI_RTSR
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The EXTI_RTSR configures the rising edge trigger for each EXTI line. When a
    rising edge is detected on a line configured in this register, it can generate
    an interrupt or an event.
  prefs: []
  type: TYPE_NORMAL
- en: The bits in this register are named `x` = `0` to `22`). Setting a bit to `1`
    configures the line to trigger on a rising edge.
  prefs: []
  type: TYPE_NORMAL
- en: EXTI_FTSR
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The EXTI_FTSR is used to configure the falling edge trigger for each EXTI line.
    When a falling edge is detected on a line set in this register, it can generate
    an interrupt or an event.
  prefs: []
  type: TYPE_NORMAL
- en: The bits in this register are named `x` = `0` to `22`). Setting a bit to `1`
    configures the line to trigger on a falling edge.
  prefs: []
  type: TYPE_NORMAL
- en: Pending Register (EXTI_PR)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The EXTI_PR indicates which EXTI lines have pending interrupt requests. This
    register is also used to clear pending interrupts by writing a `1` to the appropriate
    bit.
  prefs: []
  type: TYPE_NORMAL
- en: The bits in this register are named `x` = `0` to `22`). A bit set to `1` indicates
    a pending interrupt request. Writing `1` to the bit clears the pending request.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s configure PC13 as an EXTI pin.
  prefs: []
  type: TYPE_NORMAL
- en: The EXTI driver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a copy of your previous project in your IDE and rename this copied project
    `EXTI`. Next, create a new file named `gpio_exti.c` in the `Src` folder and another
    file named `gpio_exti.h` in the `Inc` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Populate `gpio_exti.c` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break down each step within the `pc13_exti_init` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This line disables global interrupts to ensure that the configuration process
    is not interrupted, which is crucial for maintaining consistency and avoiding
    race conditions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This line enables the clock for GPIOC by setting the appropriate bit in the
    `AHB1` peripheral clock enable register (`AHB1ENR`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: These lines configure pin `PC13` as an input by clearing the appropriate bits
    in the GPIO mode register (`MODER`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This line enables the clock for `SYSCFG` by setting the appropriate bit in the
    `APB2` peripheral clock enable register (`APB2ENR`). `SYSCFG` is required for
    configuring the EXTI lines to map to the appropriate GPIO pins.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This line configures the `SYSCFG` external interrupt configuration register
    to map EXTI line 13 to `PORTC`. The `EXTICR[3]` register controls EXTI lines 12
    to 15, and setting the correct bits ensures that `EXTI13` is connected to `PC13`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This line unmasks EXTI line 13 by setting the appropriate bit in the interrupt
    mask register (`IMR`). Unmasking the line allows it to generate interrupt requests.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This line sets EXTI line 13 to trigger on a falling edge by setting the appropriate
    bit in the FTSR. This configuration is essential for detecting when the signal
    transitions from high to low.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This line enables the `EXTI15_10` interrupt line in the NVIC. EXTI lines 10
    to 15 share an IRQ in the NVIC, and enabling it allows the microcontroller to
    handle interrupts from these lines.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This line re-enables global interrupts after the configuration is complete,
    allowing the microcontroller to respond to interrupts.
  prefs: []
  type: TYPE_NORMAL
- en: Our next task is to populate the `gpio_exti.h` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '#include <stdio.h>'
  prefs: []
  type: TYPE_NORMAL
- en: '#include "adc.h"'
  prefs: []
  type: TYPE_NORMAL
- en: '#include "uart.h"'
  prefs: []
  type: TYPE_NORMAL
- en: '#include "gpio.h"'
  prefs: []
  type: TYPE_NORMAL
- en: '#include "gpio_exti.h"'
  prefs: []
  type: TYPE_NORMAL
- en: uint8_t g_btn_press;
  prefs: []
  type: TYPE_NORMAL
- en: int main(void)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: /*Initialize debug UART*/
  prefs: []
  type: TYPE_NORMAL
- en: uart_init();
  prefs: []
  type: TYPE_NORMAL
- en: /*Initialize LED*/
  prefs: []
  type: TYPE_NORMAL
- en: led_init();
  prefs: []
  type: TYPE_NORMAL
- en: /*Initialize EXTI*/
  prefs: []
  type: TYPE_NORMAL
- en: pc13_exti_init();
  prefs: []
  type: TYPE_NORMAL
- en: while(1)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: static void exti_callback(void)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: printf("BTN Pressed...\n\r");
  prefs: []
  type: TYPE_NORMAL
- en: led_toggle();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void EXTI15_10_IRQHandler(void) {
  prefs: []
  type: TYPE_NORMAL
- en: if((EXTI->PR & LINE13)!=0)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: /*Clear PR flag*/
  prefs: []
  type: TYPE_NORMAL
- en: EXTI->PR |=LINE13;
  prefs: []
  type: TYPE_NORMAL
- en: //Do something...
  prefs: []
  type: TYPE_NORMAL
- en: exti_callback();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: if((EXTI->PR & LINE13) != 0)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: EXTI->PR |= LINE13;
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: exti_callback();
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
