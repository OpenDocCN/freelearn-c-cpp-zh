["```cpp\nupdate(){\n   switch(objectType){\n          case 1:\n                // All the player's logic\n                break;\n          case 2:\n                // All the invader's logic here\n                Break;\n          case 3:\n                // All the bullet's logic here\n                break;\n   }\n}\n```", "```cpp\nclass GameObject\n{\n   UpdateComponent* m_UpdateComponent;\n   GraphicsComponent* m_GraphicsComponent;\n   // More components\n   // The constructor\n   GameObject(string type){\n      if(type == \"invader\")\n      {\n            m_UpdateComp = new InvaderUpdateComponent();   \n            m_GraphicsComponent = new StdGraphicsComponent();\n      }\n      else if(type ==\"ufo\")\n       {\n              m_UpdateComponent = new \n                   UFOUpdateComponentComponent();\n              m_GraphicsComponent = new AnimGraphicsComponent();\n       }\n      // etc.\n      …\n   }\n};\n```", "```cpp\nshared_ptr<MyClass> myPointer;\n```", "```cpp\n myPointer = make_shared<MyClass>();\n```", "```cpp\nmyPointer = make_shared<MyClass>(3);\n```", "```cpp\nshared_ptr<MyClass> myPointer = make_shared<MyClass>();\n```", "```cpp\nmyPointer->myFunction();\n```", "```cpp\nunique_ptr<MyClass> myPointer = make_unique<MyClass>();\n```", "```cpp\nvector<unique_ptr<MyClass>> myVector;\n```", "```cpp\n// Use move() because otherwise \n// the vector has a COPY which is not allowed\nmVector.push_back(move(myPointer));\n// mVector.push_back(myPointer); // Won't compile!\n```", "```cpp\nunique_ptr<MyClass> myPointer = make_unique<MyClass>();\nvector<unique_ptr<MyClass>> myVector;\n// Use move() because otherwise \n// the vector has a COPY which is not allowed\nmVector.push_back(move(myPointer));\n// mVector.push_back(myPointer); // Won't compile!\nmyPointer->myFunction();// CRASH!!\n```", "```cpp\nshared_ptr<UpdateComponent> myUpdateComponent =\n                static_pointer_cast<UpdateComponent>(MyComponent);\n```", "```cpp\nmyUpdateComponent->update(fps);\n```", "```cpp\n#define debuggingOnConsole\n```", "```cpp\n#ifdef debuggingOnConsole\n    // C++ code goes here\n#endif\n```", "```cpp\n#ifdef debuggingOnConsole         \n        cout << \n            \"Problem x occurred and caused a crash!\" \n            << endl;\n#endif\n```", "```cpp\n#pragma once\n#define debuggingOnConsole\nclass DevelopState {};\n```", "```cpp\n#include \"GameEngine.h\"\nint main()\n{\n    GameEngine m_GameEngine;\n    m_GameEngine.run();\n    return 0;\n}\n```", "```cpp\n#pragma once\n#include <SFML/Graphics.hpp>\n#include \"ScreenManager.h\"\n#include \"SoundEngine.h\"\nusing namespace sf;\nclass GameEngine {\nprivate:\n    Clock m_Clock;\n    Time m_DT;\n    RenderWindow m_Window;\n    unique_ptr<ScreenManager> m_ScreenManager;\n    float m_FPS = 0;\n    Vector2f m_Resolution;\n    void handleInput();\n    void update();\n    void draw();\npublic:\n    SoundEngine m_SoundEngine;\n    GameEngine();\n    void run();\n};\n```", "```cpp\n#include \"GameEngine.h\"\nGameEngine::GameEngine()\n{\n    m_Resolution.x = VideoMode::getDesktopMode().width;\n    m_Resolution.y = VideoMode::getDesktopMode().height;\n    m_Window.create(VideoMode(m_Resolution.x, m_Resolution.y),\n        \"Space Invaders++\", Style::Fullscreen);\n    m_ScreenManager = unique_ptr<ScreenManager>(new ScreenManager(\n        Vector2i(m_Resolution.x, m_Resolution.y)));\n}\nvoid GameEngine::run()\n{\n    while (m_Window.isOpen())\n    {\n        m_DT = m_Clock.restart();\n        m_FPS = m_DT.asSeconds();\n        handleInput();\n        update();\n        draw();\n    }\n}\nvoid GameEngine::handleInput()\n{\n    m_ScreenManager->handleInput(m_Window);\n}\nvoid GameEngine::update()\n{\n    m_ScreenManager->update(m_FPS);\n}\nvoid GameEngine::draw()\n{\n    m_Window.clear(Color::Black);\n    m_ScreenManager->draw(m_Window);\n    m_Window.display();\n}\n```", "```cpp\n#pragma once\n#ifndef SOUND_ENGINE_H\n#define SOUND_ENGINE_H\n#include <SFML/Audio.hpp>\nusing namespace sf;\nclass SoundEngine\n{\nprivate:\n    SoundBuffer m_ShootBuffer;\n    SoundBuffer m_PlayerExplodeBuffer;\n    SoundBuffer m_InvaderExplodeBuffer;\n    SoundBuffer m_ClickBuffer;\n    Sound m_ShootSound;\n    Sound m_PlayerExplodeSound;\n    Sound m_InvaderExplodeSound;\n    Sound m_UhSound;\n    Sound m_OhSound;\n    Sound m_ClickSound;\npublic:\n    SoundEngine();\n    static void playShoot();\n    static void playPlayerExplode();\n    static void playInvaderExplode();\n    static void playClick();\n    static SoundEngine* m_s_Instance;\n};\n#endif\n```", "```cpp\n#include <SFML/Audio.hpp>\n#include <assert.h>\n#include \"SoundEngine.h\"\nusing namespace std;\nusing namespace sf;\nSoundEngine* SoundEngine::m_s_Instance = nullptr;\nSoundEngine::SoundEngine()\n{\n    assert(m_s_Instance == nullptr);\n    m_s_Instance = this;\n    // Load the sound into the buffers\n    m_ShootBuffer.loadFromFile(\"sound/shoot.ogg\");\n    m_PlayerExplodeBuffer.loadFromFile(\"sound/playerexplode.ogg\");\n    m_InvaderExplodeBuffer.loadFromFile(\"sound/invaderexplode.ogg\");\n    m_ClickBuffer.loadFromFile(\"sound/click.ogg\");\n    // Associate the sounds with the buffers\n    m_ShootSound.setBuffer(m_ShootBuffer);\n    m_PlayerExplodeSound.setBuffer(m_PlayerExplodeBuffer);\n    m_InvaderExplodeSound.setBuffer(m_InvaderExplodeBuffer);\n    m_ClickSound.setBuffer(m_ClickBuffer);\n}\nvoid SoundEngine::playShoot()\n{\n    m_s_Instance->m_ShootSound.play();\n}\nvoid SoundEngine::playPlayerExplode()\n{\n    m_s_Instance->m_PlayerExplodeSound.play();\n}\nvoid SoundEngine::playInvaderExplode()\n{\n    m_s_Instance->m_InvaderExplodeSound.play();\n}\nvoid SoundEngine::playClick()\n{\n    m_s_Instance->m_ClickSound.play();\n}\n```", "```cpp\n#pragma once\n#include <SFML/Graphics.hpp>\n#include <map>\n#include \"GameScreen.h\"\n#include \"ScreenManagerRemoteControl.h\"\n#include \"SelectScreen.h\"\n//#include \"LevelManager.h\"\n#include \"BitmapStore.h\"\n#include <iostream>\nusing namespace sf;\nusing namespace std;\nclass ScreenManager : public ScreenManagerRemoteControl {\nprivate:\n    map <string, unique_ptr<Screen>> m_Screens;\n    //LevelManager m_LevelManager;\nprotected:\n    string m_CurrentScreen = \"Select\";\npublic:\n    BitmapStore m_BS;\n    ScreenManager(Vector2i res);\n    void update(float fps);\n    void draw(RenderWindow& window);\n    void handleInput(RenderWindow& window);\n    /****************************************************\n    *****************************************************\n    From ScreenManagerRemoteControl interface\n    *****************************************************\n    *****************************************************/\n    void ScreenManagerRemoteControl::\n        SwitchScreens(string screenToSwitchTo)\n    {\n        m_CurrentScreen = \"\" + screenToSwitchTo;\n        m_Screens[m_CurrentScreen]->initialise();\n    }\n    void ScreenManagerRemoteControl::\n        loadLevelInPlayMode(string screenToLoad)\n    {\n        //m_LevelManager.getGameObjects().clear();\n        //m_LevelManager.\n            //loadGameObjectsForPlayMode(screenToLoad);\n        SwitchScreens(\"Game\");\n    }\n    //vector<GameObject>& \n        //ScreenManagerRemoteControl::getGameObjects()\n    //{\n        //return m_LevelManager.getGameObjects();\n    //}\n    //GameObjectSharer& shareGameObjectSharer()\n    //{\n        //return m_LevelManager;\n    //}\n};\n```", "```cpp\n#include \"ScreenManager.h\"\nScreenManager::ScreenManager(Vector2i res)\n{\n    m_Screens[\"Game\"] = unique_ptr<GameScreen>(\n        new GameScreen(this, res));\n    m_Screens[\"Select\"] = unique_ptr<SelectScreen>(\n        new SelectScreen(this, res));\n}\nvoid ScreenManager::handleInput(RenderWindow& window)\n{\n    m_Screens[m_CurrentScreen]->handleInput(window);\n}\nvoid ScreenManager::update(float fps)\n{\n    m_Screens[m_CurrentScreen]->update(fps);\n}\nvoid ScreenManager::draw(RenderWindow& window)\n{\n    m_Screens[m_CurrentScreen]->draw(window);\n}\n```", "```cpp\n#pragma once\n#ifndef BITMAP_STORE_H\n#define BITMAP_STORE_H\n#include <SFML/Graphics.hpp>\n#include <map>\nclass BitmapStore\n{\nprivate:\n    std::map<std::string, sf::Texture> m_BitmapsMap;\n    static BitmapStore* m_s_Instance;\npublic:\n    BitmapStore();\n    static sf::Texture& getBitmap(std::string const& filename);\n    static void addBitmap(std::string const& filename);\n};\n#endif\n```", "```cpp\n#include \"BitmapStore.h\"\n#include <assert.h>\nusing namespace sf;\nusing namespace std;\nBitmapStore* BitmapStore::m_s_Instance = nullptr;\nBitmapStore::BitmapStore()\n{\n    assert(m_s_Instance == nullptr);\n    m_s_Instance = this;\n}\nvoid BitmapStore::addBitmap(std::string const& filename)\n{\n    // Get a reference to m_Textures using m_S_Instance\n    auto& bitmapsMap = m_s_Instance->m_BitmapsMap;\n    // auto is the equivalent of map<string, Texture>\n    // Create an iterator to hold a key-value-pair (kvp)\n    // and search for the required kvp\n    // using the passed in file name\n    auto keyValuePair = bitmapsMap.find(filename);\n    // auto is equivalent of map<string, Texture>::iterator\n    // No match found so save the texture in the map\n    if (keyValuePair == bitmapsMap.end())\n    {\n        // Create a new key value pair using the filename\n        auto& texture = bitmapsMap[filename];\n        // Load the texture from file in the usual way\n        texture.loadFromFile(filename);\n    }\n}\nsf::Texture& BitmapStore::getBitmap(std::string const& filename)\n{\n    // Get a reference to m_Textures using m_S_Instance\n    auto& m = m_s_Instance->m_BitmapsMap;\n    // auto is the equivalent of map<string, Texture>\n    // Create an iterator to hold a key-value-pair (kvp)\n    // and search for the required kvp\n    // using the passed in file name\n    auto keyValuePair = m.find(filename);\n    // auto is equivalent of map<string, Texture>::iterator    \n    // Did we find a match?\n    if (keyValuePair != m.end())\n    {\n        return keyValuePair->second;\n    }\n    else\n    {\n#ifdef debuggingOnConsole         \n        cout << \n            \"BitmapStore::getBitmap()Texture not found Crrrashh!\" \n            << endl;\n#endif\n        return keyValuePair->second;\n    }\n}\n```", "```cpp\n#pragma once\n#include <string>\n#include <vector>\n//#include \"GameObject.h\"\n//#include \"GameObjectSharer.h\"\nusing namespace std;\nclass ScreenManagerRemoteControl\n{\npublic:\n    virtual void SwitchScreens(string screenToSwitchTo) = 0;\n    virtual void loadLevelInPlayMode(string screenToLoad) = 0;\n    //virtual vector<GameObject>& getGameObjects() = 0;\n    //virtual GameObjectSharer& shareGameObjectSharer() = 0;\n};\n```", "```cpp\n/*********************************\n******THIS IS AN INTERFACE********\n*********************************/\n```", "```cpp\n#pragma once\n#include <SFML/Graphics.hpp>\nusing namespace sf;\nclass Button\n{\nprivate:\n    RectangleShape m_Button;\n    Text m_ButtonText;\n    Font m_Font;\npublic:\n    std::string m_Text;\n    FloatRect m_Collider;\n    Button(Vector2f position, \n        float width, float height, \n        int red, int green, int blue, \n        std::string text);\n    void draw(RenderWindow& window);\n};\n```", "```cpp\n#include \"Button.h\"\nButton::Button(Vector2f position, \n    float width, float height, \n    int red, int green, int blue, \n    std::string text)\n{\n    m_Button.setPosition(position);\n    m_Button.setFillColor(sf::Color(red, green, blue));\n    m_Button.setSize(Vector2f(width, height));\n    m_Text = \"\" + text;\n    float textPaddingX = width /10;\n    float textPaddingY= height / 10;\n    m_ButtonText.setCharacterSize(height * .7f);\n    m_ButtonText.setString(text);\n    m_Font.loadFromFile(\"fonts/Roboto-Bold.ttf\");\n    m_ButtonText.setFont(m_Font);\n    m_ButtonText.setPosition(Vector2f((position.x + textPaddingX),\n        (position.y + textPaddingY)));\n    m_Collider = FloatRect(position, Vector2f(width, height));\n}\nvoid Button::draw(RenderWindow& window)\n{\n    window.draw(m_Button);\n    window.draw(m_ButtonText);\n}\n```", "```cpp\n#pragma once\n#include <SFML/Graphics.hpp>\n#include \"Button.h\"\nusing namespace std;\nclass UIPanel {\nprivate:\n    RectangleShape m_UIPanel;\n    bool m_Hidden = false;\n    vector<shared_ptr<Button>> m_Buttons;\nprotected:\n    float m_ButtonWidth = 0;\n    float m_ButtonHeight = 0;\n    float m_ButtonPadding = 0;\n    Font m_Font;\n    Text m_Text;\n    void addButton(float x, float y, int width, int height,\n        int red, int green, int blue,\n        string label);\n\npublic:\n    View m_View;\n    UIPanel(Vector2i res, int x, int y, \n        float width, float height, \n        int alpha, int red, int green, int blue);\n    vector<shared_ptr<Button>> getButtons();\n    virtual void draw(RenderWindow& window);\n    void show();\n    void hide();\n};\n```", "```cpp\n#include \"UIPanel.h\"\nUIPanel::UIPanel(Vector2i res, int x, int y, \n    float width, float height, \n    int alpha, int red, int green, int blue)\n{\n    m_UIPanel.setFillColor(sf::Color(red, green, blue, alpha));\n    // How big in pixels is the UI panel\n    m_UIPanel.setSize(Vector2f(width, height));\n    // How big in pixels is the view\n    m_View.setSize(Vector2f(width, height));\n\n    // Where in pixels does the center of the view focus\n    // This is most relevant when drawing a portion \n   // of the game world\n    // width/2, height/2 ensures it is exactly centered around the\n    // RectangleShape, mUIPanel\n    m_View.setCenter(width / 2, height / 2);\n    // Where in the window is the view positioned?\n    float viewportStartX = 1.f / (res.x / x);\n    float viewportStartY = 1.f / (res.y / y);\n    float viewportSizeX = 1.f / (res.x / width);\n    float viewportSizeY = 1.f / (res.y / height);\n    // Params from left to right\n    // StartX as a fraction of 1, startY as a fraction of 1 \n    // SizeX as a fraction of 1\n    // SizeY as a fraction of 1\n    m_View.setViewport(FloatRect(viewportStartX, viewportStartY, \n        viewportSizeX, viewportSizeY));\n}\nvector<shared_ptr<Button>> UIPanel::getButtons()\n{\n    return m_Buttons;\n}\nvoid UIPanel::addButton(float x, float y, \n    int width, int height,\n    int red, int green, int blue,\n    string label)\n{\n    m_Buttons.push_back(make_shared<Button>(Vector2f(x, y), \n        width, height,\n        red, green, blue, \n        label));\n}\nvoid UIPanel::draw(RenderWindow & window)\n{\n    window.setView(m_View);\n    if (!m_Hidden) {\n        window.draw(m_UIPanel);\n        for (auto it = m_Buttons.begin(); \n            it != m_Buttons.end(); ++it)\n        {\n            (*it)->draw(window);\n        }\n    }\n}\nvoid UIPanel::show()\n{\n    m_Hidden = false;\n}\nvoid UIPanel::hide()\n{\n    m_Hidden = true;\n}\n```", "```cpp\n#pragma once\n#include <SFML/Graphics.hpp>\n#include <vector>\n#include \"Button.h\"\n#include \"Screen.h\"\n#include \"ScreenManagerRemoteControl.h\"\nusing namespace sf;\nusing namespace std;\nclass Screen;\nclass InputHandler\n{\nprivate:\n    Screen* m_ParentScreen;\n    vector<shared_ptr<Button>> m_Buttons;\n    View* m_PointerToUIPanelView;\n    ScreenManagerRemoteControl* m_ScreenManagerRemoteControl;\npublic:\n    void initialiseInputHandler(\n        ScreenManagerRemoteControl* sw, \n        vector<shared_ptr<Button>>,\n        View* pointerToUIView, \n        Screen* parentScreen);\n    void handleInput(RenderWindow& window, Event& event);\n    virtual void handleGamepad();\n    virtual void handleKeyPressed(Event& event, \n        RenderWindow& window);\n    virtual void handleKeyReleased(Event& event, \n        RenderWindow& window);\n    virtual void handleLeftClick(string& buttonInteractedWith, \n        RenderWindow& window);\n    View* getPointerToUIView();\n    ScreenManagerRemoteControl* \n        getPointerToScreenManagerRemoteControl();\n    Screen* getmParentScreen();\n};\n```", "```cpp\n#include <sstream>\n#include \"InputHandler.h\"\nusing namespace sf;\nusing namespace std;\nvoid InputHandler::initialiseInputHandler(\n    ScreenManagerRemoteControl* sw, \n    vector<shared_ptr<Button>> buttons,\n    View* pointerToUIView, \n    Screen* parentScreen)\n{\n    m_ScreenManagerRemoteControl = sw;\n    m_Buttons = buttons;\n    m_PointerToUIPanelView = pointerToUIView;\n    m_ParentScreen = parentScreen;\n}\nvoid InputHandler::handleInput(RenderWindow& window, \n    Event& event)\n{\n    // Handle any key presses\n    if (event.type == Event::KeyPressed)\n    {\n        handleKeyPressed(event, window);\n    }\n    if (event.type == Event::KeyReleased)\n    {\n        handleKeyReleased(event, window);\n    }\n    // Handle any left mouse click released\n    if (event.type == Event::MouseButtonReleased)\n    {\n        auto end = m_Buttons.end();\n        for (auto i = m_Buttons.begin();\n            i != end;\n            ++i) {\n            if ((*i)->m_Collider.contains(\n                window.mapPixelToCoords(Mouse::getPosition(), \n                (*getPointerToUIView()))))\n            {\n                // Capture the text of the button that was interacted \n                // with and pass it to the specialised version \n                // of this class if implemented\n                handleLeftClick((*i)->m_Text, window);\n                break;\n            }\n        }\n    }\n    handleGamepad();    \n}\nvoid InputHandler::handleGamepad()\n{}// Do nothing unless handled by a derived class\nvoid InputHandler::handleKeyPressed(Event& event, \n    RenderWindow& window)\n{}// Do nothing unless handled by a derived class\nvoid InputHandler::handleKeyReleased(Event& event, \n    RenderWindow& window)\n{}// Do nothing unless handled by a derived class\nvoid InputHandler::handleLeftClick(std::\n    string& buttonInteractedWith, \n    RenderWindow& window)\n{}// Do nothing unless handled by a derived class\nView* InputHandler::getPointerToUIView()\n{\n    return m_PointerToUIPanelView;\n}\nScreenManagerRemoteControl* \n    InputHandler::getPointerToScreenManagerRemoteControl()\n{\n    return m_ScreenManagerRemoteControl;\n}\nScreen* InputHandler::getmParentScreen() {\n    return m_ParentScreen;\n}\n```", "```cpp\n#pragma once\n#include <SFML/Graphics.hpp>\n#include <vector>\n#include \"InputHandler.h\"\n#include \"UIPanel.h\"\n#include \"ScreenManagerRemoteControl.h\"\nclass InputHandler;\nclass Screen {\nprivate:\n    vector<shared_ptr<InputHandler>> m_InputHandlers;\n    vector<unique_ptr<UIPanel>> m_Panels;\nprotected:\n    void addPanel(unique_ptr<UIPanel> p, \n        ScreenManagerRemoteControl* smrc, \n        shared_ptr<InputHandler> ih);\n\npublic:\n    virtual void initialise();\n    void virtual update(float fps);\n    void virtual draw(RenderWindow& window);\n    void handleInput(RenderWindow& window);\n    View m_View;\n};\n```", "```cpp\n#include \"Screen.h\"\nvoid Screen::initialise(){}\nvoid Screen::addPanel(unique_ptr<UIPanel> uip, \n    ScreenManagerRemoteControl* smrc, \n    shared_ptr<InputHandler> ih)\n{\n    ih->initialiseInputHandler(smrc, \n        uip->getButtons(), &uip->m_View, this);\n    // Use move() because otherwise \n    // the vector has a COPY which is not allowed\n    m_Panels.push_back(move(uip));        \n    m_InputHandlers.push_back(ih);\n}\nvoid Screen::handleInput(RenderWindow& window)\n{\n    Event event;\n    auto itr = m_InputHandlers.begin();\n    auto end = m_InputHandlers.end();\n    while (window.pollEvent(event))\n    {\n        for (itr;\n            itr != end;\n            ++itr)\n        {\n            (*itr)->handleInput(window, event);\n        }\n    }\n}\nvoid Screen::update(float fps){}\nvoid Screen::draw(RenderWindow& window)\n{    \n    auto itr = m_Panels.begin();\n    auto end = m_Panels.end();\n    for (itr;\n        itr != end;\n        ++itr)\n    {\n        (*itr)->draw(window);\n    }    \n}\n```", "```cpp\nm_Panels.push_back(move(uip));\n```", "```cpp\n#pragma once\nclass WorldState\n{\npublic:\n    static const int WORLD_WIDTH = 100;\n    static int WORLD_HEIGHT;\n    static int SCORE;\n    static int LIVES;\n    static int NUM_INVADERS_AT_START;\n    static int NUM_INVADERS;\n    static int WAVE_NUMBER;\n};\n```", "```cpp\n#pragma once\n#include \"Screen.h\"\nclass SelectScreen : public Screen\n{\nprivate:\n    ScreenManagerRemoteControl* m_ScreenManagerRemoteControl;\n    Texture m_BackgroundTexture;\n    Sprite m_BackgroundSprite;\npublic:\n    SelectScreen(ScreenManagerRemoteControl* smrc, Vector2i res);\n    void virtual draw(RenderWindow& window);\n};\n```", "```cpp\n#include \"SelectScreen.h\"\n#include \"SelectUIPanel.h\"\n#include \"SelectInputHandler.h\"\nSelectScreen::SelectScreen(\n    ScreenManagerRemoteControl* smrc, Vector2i res)\n{\n    auto suip = make_unique<SelectUIPanel>(res);\n    auto sih = make_shared<SelectInputHandler>();\n    addPanel(move(suip), smrc, sih);\n    m_ScreenManagerRemoteControl = smrc;\n    m_BackgroundTexture.loadFromFile(\"graphics/background.png\");\n    m_BackgroundSprite.setTexture(m_BackgroundTexture);\n    auto textureSize = m_BackgroundSprite.\n        getTexture()->getSize();\n\n    m_BackgroundSprite.setScale(float(\n        m_View.getSize().x) / textureSize.x,        \n        float(m_View.getSize().y) / textureSize.y);\n}\nvoid SelectScreen::draw(RenderWindow& window)\n{\n    // Change to this screen's view to draw\n    window.setView(m_View);\n    window.draw(m_BackgroundSprite);\n    // Draw the UIPanel view(s)\n    Screen::draw(window);\n}\n```", "```cpp\n#pragma once\n#include \"InputHandler.h\"\nclass SelectInputHandler : public InputHandler\n{\npublic:\n    void handleKeyPressed(Event& event, \n        RenderWindow& window) override;\n    void handleLeftClick(std::string& buttonInteractedWith, \n        RenderWindow& window) override;\n};\n```", "```cpp\n#include \"SelectInputHandler.h\"\n#include \"SoundEngine.h\"\n#include \"WorldState.h\"\n#include <iostream>\nint WorldState::WAVE_NUMBER;\nvoid SelectInputHandler::handleKeyPressed(\n    Event& event, RenderWindow& window)\n{\n    // Quit the game\n    if (Keyboard::isKeyPressed(Keyboard::Escape))\n    {\n        window.close();\n    }\n}\nvoid SelectInputHandler::handleLeftClick(\n    std::string& buttonInteractedWith, RenderWindow& window)\n{\n    if (buttonInteractedWith == \"Play\") {\n        SoundEngine::playClick();\n        WorldState::WAVE_NUMBER = 0;\n        getPointerToScreenManagerRemoteControl()\n            ->loadLevelInPlayMode(\"level1\");\n    }\n    if (buttonInteractedWith == \"Quit\") {\n        SoundEngine::playClick();\n        window.close();\n    }\n}\n```", "```cpp\n#pragma once\n#include \"UIPanel.h\"\nclass SelectUIPanel : public UIPanel\n{\nprivate:\n    void initialiseButtons();\npublic:\n    SelectUIPanel(Vector2i res);\n    void virtual draw(RenderWindow& window);\n};\n```", "```cpp\n#include \"SelectUIPanel.h\"\n#include <iostream>\nSelectUIPanel::SelectUIPanel(Vector2i res) :\n    // Create a new UIPanel  \n    // by calling the super-class constructor\n    UIPanel(res,\n        (res.x / 10) * 2, // Start 2/10 across\n        res.y / 3, // 1/3 of the resolution from the top\n        (res.x / 10) * 6, // as wide as 6/10 of the resolution\n        res.y / 3, // and as tall as 1/3 of the resolution\n        50, 255, 255, 255) // a, r, g, b\n{\n    m_ButtonWidth = res.x / 20;\n    m_ButtonHeight = res.y / 20;\n    m_ButtonPadding = res.x / 100;\n    m_Text.setFillColor(sf::Color(0, 255, 0, 255));\n    m_Text.setString(\"SPACE INVADERS ++\");\n    //https://www.dafont.com/roboto.font\n    m_Font.loadFromFile(\"fonts/Roboto-Bold.ttf\");\n    m_Text.setFont(m_Font);\n    m_Text.setPosition(Vector2f(m_ButtonPadding,\n        m_ButtonHeight + (m_ButtonPadding * 2)));\n    m_Text.setCharacterSize(160);\n    initialiseButtons();\n}\nvoid SelectUIPanel::initialiseButtons()\n{\n    // Buttons are positioned relative to the top left \n    // corner of the UI panel(m_View in UIPanel)\n    addButton(m_ButtonPadding,\n        m_ButtonPadding,\n        m_ButtonWidth,\n        m_ButtonHeight,\n        0, 255, 0,\n        \"Play\");\n    addButton(m_ButtonWidth + (m_ButtonPadding * 2),\n        m_ButtonPadding,\n        m_ButtonWidth,\n        m_ButtonHeight,\n        255, 0, 0,\n        \"Quit\");\n}\nvoid SelectUIPanel::draw(RenderWindow& window)\n{    \n        show();\n        UIPanel::draw(window);\n        window.draw(m_Text);        \n}\n```", "```cpp\n#pragma once\n#include \"Screen.h\"\n#include \"GameInputHandler.h\"\n#include \"GameOverInputHandler.h\"\nclass GameScreen : public Screen\n{\nprivate:\n    ScreenManagerRemoteControl* m_ScreenManagerRemoteControl;\n    shared_ptr<GameInputHandler> m_GIH;\n    Texture m_BackgroundTexture;\n    Sprite m_BackgroundSprite;\npublic:\n    static bool m_GameOver;\n    GameScreen(ScreenManagerRemoteControl* smrc, Vector2i res);\n    void initialise() override;\n    void virtual update(float fps);\n    void virtual draw(RenderWindow& window);    \n};\n```", "```cpp\n#include \"GameScreen.h\"\n#include \"GameUIPanel.h\"\n#include \"GameInputHandler.h\"\n#include \"GameOverUIPanel.h\"\n#include \"WorldState.h\"\nint WorldState::WORLD_HEIGHT;\nint WorldState::NUM_INVADERS;\nint WorldState::NUM_INVADERS_AT_START;\nGameScreen::GameScreen(ScreenManagerRemoteControl* smrc,\n    Vector2i res)\n{\n    m_GIH = make_shared<GameInputHandler>();\n    auto guip = make_unique<GameUIPanel>(res);\n    addPanel(move(guip), smrc, m_GIH);\n    auto m_GOIH = make_shared<GameOverInputHandler>();\n    auto gouip = make_unique<GameOverUIPanel>(res);\n    addPanel(move(gouip), smrc, m_GOIH);\n    m_ScreenManagerRemoteControl = smrc;\n    float screenRatio = VideoMode::getDesktopMode().width /\n        VideoMode::getDesktopMode().height;\n    WorldState::WORLD_HEIGHT = WorldState::WORLD_WIDTH /\n        screenRatio;\n    m_View.setSize(\n        WorldState::WORLD_WIDTH, WorldState::WORLD_HEIGHT);\n    m_View.setCenter(Vector2f(WorldState::WORLD_WIDTH /\n        2, WorldState::WORLD_HEIGHT / 2));\n\n    m_BackgroundTexture.loadFromFile(\"graphics/background.png\");\n    m_BackgroundSprite.setTexture(m_BackgroundTexture);\n    auto textureSize = m_BackgroundSprite.getTexture()->getSize();\n    m_BackgroundSprite.setScale(float(m_View.getSize().x) / \n      textureSize.x,\n        float(m_View.getSize().y) / textureSize.y);\n}\nvoid GameScreen::initialise()\n{\n    m_GIH->initialize();\n    WorldState::NUM_INVADERS = 0;\n    m_GameOver = false;\n    if (WorldState::WAVE_NUMBER == 0)\n    {\n        WorldState::NUM_INVADERS_AT_START = \n            WorldState::NUM_INVADERS;\n\n        WorldState::WAVE_NUMBER = 1;\n        WorldState::LIVES = 3;\n        WorldState::SCORE = 0;\n    }\n}\nvoid GameScreen::update(float fps)\n{\n    Screen::update(fps);\n    if (!m_GameOver)\n    {\n        if (WorldState::NUM_INVADERS <= 0)\n        {\n            WorldState::WAVE_NUMBER++;\n            m_ScreenManagerRemoteControl->\n                loadLevelInPlayMode(\"level1\");\n        }\n        if (WorldState::LIVES <= 0)\n        {\n            m_GameOver = true;\n        }\n    }\n}\nvoid GameScreen::draw(RenderWindow& window)\n{\n    // Change to this screen's view to draw\n    window.setView(m_View);\n    window.draw(m_BackgroundSprite);\n    // Draw the UIPanel view(s)\n    Screen::draw(window);\n}\n```", "```cpp\n#pragma once\n#include \"InputHandler.h\"\nclass GameScreen;\nclass GameInputHandler : public InputHandler\n{\npublic:\n    void initialize();\n    void handleGamepad() override;\n    void handleKeyPressed(Event& event,\n        RenderWindow& window) override;\n    void handleKeyReleased(Event& event,\n        RenderWindow& window) override;\n};\n```", "```cpp\n#include \"GameInputHandler.h\"\n#include \"SoundEngine.h\"\n#include \"GameScreen.h\"\nvoid GameInputHandler::initialize() {\n}\nvoid GameInputHandler::handleGamepad()\n{\n}\nvoid GameInputHandler::handleKeyPressed(\n    Event& event, RenderWindow& window)\n{\n    // Handle key presses\n    if (event.key.code == Keyboard::Escape)\n    {\n        SoundEngine::playClick();\n        getPointerToScreenManagerRemoteControl()->\n            SwitchScreens(\"Select\");\n    }    \n}\nvoid GameInputHandler::handleKeyReleased(\n    Event& event, RenderWindow& window)\n{\n}\n```", "```cpp\n#pragma once\n#include \"UIPanel.h\"\nclass GameUIPanel : public UIPanel\n{\npublic:\n    GameUIPanel(Vector2i res);\n    void draw(RenderWindow& window) override;\n};\n```", "```cpp\n#include \"GameUIPanel.h\"\n#include <sstream>\n#include \"WorldState.h\"\nint WorldState::SCORE;\nint WorldState::LIVES;\nGameUIPanel::GameUIPanel(Vector2i res) :\n    UIPanel(res,\n        1, // The left\n        1, // The top\n        res.x / 3, // 1/3 width screen\n        res.y / 12, \n        50, 255, 255, 255) // a, r, g, b \n{\n    m_Text.setFillColor(sf::Color(0, 255, 0, 255));\n    m_Text.setString(\"Score: 0 Lives: 3 Wave: 1\");\n    m_Font.loadFromFile(\"fonts/Roboto-Bold.ttf\");\n    m_Text.setFont(m_Font);\n    m_Text.setPosition(Vector2f(15,15));\n    m_Text.setCharacterSize(60);    \n}\nvoid GameUIPanel::draw(RenderWindow& window)\n{\n    UIPanel::draw(window);\n    std::stringstream ss;\n    ss << \"Score: \" << WorldState::SCORE << \"  Lives: \" \n        << WorldState::LIVES << \" Wave: \" \n        << WorldState::WAVE_NUMBER;\n    m_Text.setString(ss.str());\n    window.draw(m_Text);\n}\n```", "```cpp\n#pragma once\n#include \"InputHandler.h\"\nclass GameOverInputHandler :\n    public InputHandler\n{\npublic:\n    void handleKeyPressed(Event& event, \n        RenderWindow& window) override;\n    void handleLeftClick(std::string& \n        buttonInteractedWith, RenderWindow& window) override;\n};\n```", "```cpp\n#include \"GameOverInputHandler.h\"\n#include \"SoundEngine.h\"\n#include \"WorldState.h\"\n#include <iostream>\nvoid GameOverInputHandler::handleKeyPressed(Event& event, \n    RenderWindow& window)\n{\n    if (event.key.code == Keyboard::Escape)\n    {\n        SoundEngine::playClick();\n        getPointerToScreenManagerRemoteControl()->\n            SwitchScreens(\"Select\");\n    }\n}\nvoid GameOverInputHandler::handleLeftClick(\n    std::string& buttonInteractedWith, RenderWindow& window)\n{\n    if (buttonInteractedWith == \"Play\") {\n        SoundEngine::playClick();\n        WorldState::WAVE_NUMBER = 0;\n        getPointerToScreenManagerRemoteControl()->\n            loadLevelInPlayMode(\"level1\");\n    }\n    else if (buttonInteractedWith == \"Home\") {\n        SoundEngine::playClick();\n        getPointerToScreenManagerRemoteControl()->\n            SwitchScreens(\"Select\");\n    }\n}\n```", "```cpp\n#pragma once\n#include \"UIPanel.h\"\nclass GameOverUIPanel :\n    public UIPanel\n{\nprivate:    \n    void initialiseButtons();\npublic:\n    GameOverUIPanel(Vector2i res);\n    void virtual draw(RenderWindow& window);\n};\n```", "```cpp\n#include \"GameOverUIPanel.h\"\n#include \"GameScreen.h\"\nbool GameScreen::m_GameOver;\nGameOverUIPanel::GameOverUIPanel(Vector2i res) :\n    UIPanel(res,\n        (res.x / 10) * 3, \n        res.y / 2, // 50% of the resolution from the top\n        (res.x / 10) * 3, // as wide as 1/3 of the resolution\n        res.y / 6, // and as tall as 1/6 of the resolution\n        50, 255, 255, 255) // a, r, g, b    \n{\n    m_ButtonWidth = res.x / 20;\n    m_ButtonHeight = res.y / 20;\n    m_ButtonPadding = res.x / 100;\n    m_Text.setFillColor(sf::Color(0, 255, 0, 255));// Green\n    m_Text.setString(\"GAME OVER!\");\n    m_Font.loadFromFile(\"fonts/Roboto-Bold.ttf\");\n    m_Text.setFont(m_Font);\n    m_Text.setPosition(Vector2f(m_ButtonPadding, \n        (m_ButtonPadding * 2)+ m_ButtonHeight));\n    m_Text.setCharacterSize(60);\n    initialiseButtons();\n}\nvoid GameOverUIPanel::initialiseButtons()\n{\n    addButton(m_ButtonPadding,\n        m_ButtonPadding,\n        m_ButtonWidth,\n        m_ButtonHeight,\n        0, 255, 0,\n        \"Play\");\n    addButton(m_ButtonWidth + (m_ButtonPadding * 2),\n        m_ButtonPadding,\n        m_ButtonWidth,\n        m_ButtonHeight,\n        255, 0, 0,\n        \"Home\");\n}\nvoid GameOverUIPanel::draw(RenderWindow& window) \n{\n    if (GameScreen::m_GameOver)\n    {\n        show();\n        UIPanel::draw(window);\n        window.draw(m_Text);\n    }\n    else\n    {\n        hide();\n    }\n}\n```", "```cpp\nif (WorldState::LIVES <= 0)\n```", "```cpp\nif (true)\n```"]