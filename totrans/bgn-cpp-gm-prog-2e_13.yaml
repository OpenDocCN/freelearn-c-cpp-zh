- en: '*Chapter 12*: Layering Views and Implementing the HUD'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will get to see the real value of SFML Views. We will add
    a large array of SFML `Text` objects and manipulate them, like we did before in
    the Timber!!! project and the Pong project. What's new is that we will draw the
    HUD using a second View instance. This way, the HUD will stay neatly positioned
    over the top of the main game action, regardless of what the background, player,
    zombies, and other game objects are doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what we will do in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Add text and a background to the home/game over screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add text to the level-up screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the second View
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a HUD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding all the Text and HUD objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be manipulating a few strings in this chapter. We are doing this so
    we can format the HUD and the level-up screen with the necessary text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the extra `include` directive highlighted in the following code so that
    we can make some `sstream` objects to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add this rather lengthy, but easily explainable, piece of code. To help
    identify where you should add the code, the new code is highlighted, and the existing
    code is not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The previous code is very simple and nothing new. It basically creates a whole
    bunch of SFML `Text` objects. It assigns their colors and sizes and then formats
    their positions using functions we have seen before.
  prefs: []
  type: TYPE_NORMAL
- en: The most important thing to note is that we create another `View` object called
    `hudView` and initialize it to fit the resolution of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen, the main `View` object scrolls around as it follows the player.
    In contrast, we will never move `hudView`. The result of this is that if we switch
    to this view before we draw the elements of the HUD, we will create the effect
    of allowing the game world to scroll by underneath while the player's HUD remains
    stationary.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: As an analogy, you can think of laying a transparent sheet of plastic with some
    writing on it over a TV screen. The TV will carry on as normal with moving pictures,
    and the text on the plastic sheet will stay in the same place, regardless of what
    goes on underneath it. We will take this concept a step further in the next project
    when we split the screen and separate moving views of the game world.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing to notice, however, is that the hi-score is not set in any meaningful
    way. We will need to wait until the next chapter, when we investigate file I/O,
    to save and retrieve the high score.
  prefs: []
  type: TYPE_NORMAL
- en: Another point worth noting is that we declare and initialize a `RectangleShape`
    called `healthBar`, which will be a visual representation of the player's remaining
    health. This will work in almost the same way that the time-bar worked in the
    Timber!!! project, except it will represent health instead of time.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous code, there is a new `Sprite` instance called `ammoIcon` that
    gives context to the bullet and clip statistics that we will draw next to it,
    at the bottom-left of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Although there is nothing new or technical about the large amount of code that
    we just added, be sure to familiarize yourself with the details – especially the
    variable names – to make the rest of this chapter easier to follow.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the HUD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you might expect, we will update the HUD variables in the update section
    of our code. We will not, however, do so every frame. The reason for this is that
    it is unnecessary, and it also slows our game loop down.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, consider the scenario when the player kills a zombie and gets
    some more points. It doesn't matter whether the `Text` object that holds the score
    is updated in one-thousandth, one-hundredth, or even one-tenth of a second. The
    player will discern no difference. This means there is no point rebuilding strings
    that we set for the `Text` objects every frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, we can time when and how often we update the HUD. Add the following
    highlighted variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we have variables to track how many frames it has been
    since the last time the HUD was updated, and the interval, measured in frames,
    we would like to wait between HUD updates.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can use these new variables and update the HUD each frame. We won't
    see all the HUD elements change, however, until we begin to manipulate the final
    variables, such as  `wave`, in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following highlighted code in the update section of the game loop,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the new code, we update the size of the `healthBar` sprite then increment
    the `framesSinceLastHUDUpdate` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we start an `if` block that tests whether `framesSinceLastHUDUpdate` is
    greater than our preferred interval, which is stored in `fpsMeasurementFrameInterval`.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this `if` block is where all the action takes place. First, we declare
    a `stringstream` object for each string that we need to set to a `Text` object.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we use each of those `stringstream` objects in turn and use the `setString`
    function to set the result to the appropriate `Text` object.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, before the `if` block is exited, `framesSinceLastHUDUpdate` is set
    back to zero so that the count can begin again.
  prefs: []
  type: TYPE_NORMAL
- en: Now, when we redraw the scene, the new values will appear in the player's HUD.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the HUD, home, and level-up screens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the code in the following three code blocks goes in the drawing phase of
    our game loop. All we need to do is draw the appropriate `Text` objects during
    the appropriate states, in the draw section of the main game loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `PLAYING` state, add the following highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The vital thing to notice in the preceding block of code is that we switch views
    to the HUD view. This causes everything to be drawn at the precise screen positions
    we gave each of the elements of the HUD. They will never move.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `LEVELING_UP` state, add the following highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `PAUSED` state, add the following highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `GAME_OVER` state, add the following highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can run the game and see our HUD update during gameplay:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14278_12_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows the high score and score on the home/game over
    screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14278_12_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we see text that tells the player what their level-up options are, although
    these options don''t do anything yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14278_12_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, we can see a helpful message on the pause screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14278_12_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: SFML Views are more powerful than this simple HUD can demonstrate. For an insight
    into the potential of the SFML `View` class and how easy they are to use, look
    at the SFML website's tutorial on `View` at [https://www.sfml-dev.org/tutorials/2.5/graphics-view.php](https://www.sfml-dev.org/tutorials/2.5/graphics-view.php).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This was a quick and simple chapter. We looked at how to display the values
    that are held by variables of different types using `sstream` and then learned
    how to draw them over the top of the main game action using a second SFML `View`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: We are nearly done with Zombie Arena now. All the screenshots in this chapter
    show a small arena that doesn't take advantage of the full monitor.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, the final one for this project, we will put in some finishing
    touches, such as leveling up, sound effects, and saving the high score. The arena
    can then grow to the same size as the monitor and far beyond.
  prefs: []
  type: TYPE_NORMAL
- en: FAQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is a question that might be on your mind:'
  prefs: []
  type: TYPE_NORMAL
- en: Q) Where can I see more of the power of the `View` class in action?
  prefs: []
  type: TYPE_NORMAL
- en: 'A) Take a look at the enhanced edition of the Zombie Arena game, in the download
    bundle. You can use the cursor keyboard keys to spin and zoom the game. Warning!
    Spinning the scene makes the controls awkward, but you get to see some of the
    things that can be done with the View class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14278_12_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The zoom and rotate functionality were achieved with just a few lines of code
    in the input handling section of the main game loop. You can see the code in the
    `Zombie Arena Enhanced Version` folder of the download bundle or run the enhanced
    version from the `Runnable Games/Zombie Arena` folder.
  prefs: []
  type: TYPE_NORMAL
