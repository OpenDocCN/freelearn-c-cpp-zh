["```cpp\nstruct factor_t {\n    bool is_prime;\n    long factor;\n};\nfactor_t factor(long n) {\n    factor_t r{};\n    for(long i = 2; i <= n / 2; ++i) {\n        if (n % i == 0) {\n            r.is_prime = false;\n            r.factor = i;\n            return r;\n        }\n    }\n    r.is_prime = true;\n    return r;\n}\n```", "```cpp\noptional<long> factor(long n) {\n    for (long i = 2; i <= n / 2; ++i) {\n        if (n % i == 0) return {i};\n    }\n    return {};\n}\n```", "```cpp\nlong a{ 42 };\nlong b{ 73 };\nauto x = factor(a);\nauto y = factor(b);\nif(x) cout << format(\"lowest factor of {} is {}\\n\", a, *x);\nelse cout << format(\"{} is prime\\n\", a);\nif(y) cout << format(\"lowest factor of {} is {}\\n\", b, *y);\nelse cout << format(\"{} is prime\\n\", b);\n```", "```cpp\nlowest factor of 42 is 2\n73 is prime\n```", "```cpp\n    optional<int> a{ 42 };\n    cout << *a << '\\n';\n    ```", "```cpp\n42\n```", "```cpp\noptional<int> a{};\n```", "```cpp\nno value\n```", "```cpp\n    using oint = std::optional<int>;\n    oint a{ 42 };\n    oint b{ 73 };\n    ```", "```cpp\n    oint operator+(const oint& a, const oint& b) {\n        if(a && b) return *a + *b;\n        else return {};\n    }\n    oint operator+(const oint& a, const int b) {\n        if(a) return *a + b;\n        else return {};\n    }\n    ```", "```cpp\nauto sum{ a + b };\nif(sum) {\n    cout << format(\"{} + {} = {}\\n\", *a, *b, *sum);\n} else {\n    cout << \"NAN\\n\";\n}\n```", "```cpp\n42 + 73 = 115\n```", "```cpp\n    oint b{};\n    ```", "```cpp\nNAN\n```", "```cpp\noptional<int> n{ 42 };\nif(n) ... // has a value\n```", "```cpp\nif(n.has_value()) ... // has a value\n```", "```cpp\nx = *n;  // * retruns the value\n```", "```cpp\nx = n.value();  // * retruns the value\n```", "```cpp\nn.reset();      // no longer has a value\n```", "```cpp\nb.reset();\ntry {\n    cout << b.value() << '\\n';\n} catch(const std::bad_optional_access& e) {\n    cout << format(\"b.value(): {}\\n\", e.what());\n}\n```", "```cpp\nb.value(): bad optional access\n```", "```cpp\nany x{};\n```", "```cpp\nif(x.has_value()) cout << \"have value\\n\";\nelse cout << \"no value\\n\";\n```", "```cpp\nno value\n```", "```cpp\nx = 42;\n```", "```cpp\nif(x.has_value()) {\n    cout << format(\"x has type: {}\\n\", x.type().name());\n    cout << format(\"x has value: {}\\n\", any_cast<int>(x));\n} else {\n    cout << \"no value\\n\";\n}\n```", "```cpp\nx has type: i\nx has value: 42\n```", "```cpp\nx = \"abc\"s;\ncout << format(\"x is type {} with value {}\\n\", \n    x.type().name(), any_cast<string>(x))\n```", "```cpp\nx is type NSt7__cxx1112basic_string... with value abc\n```", "```cpp\n    void p_any(const any& a) {\n        if (!a.has_value()) {\n            cout << \"None.\\n\";\n        } else if (a.type() == typeid(int)) {\n            cout << format(\"int: {}\\n\", any_cast<int>(a));\n        } else if (a.type() == typeid(string)) {\n            cout << format(\"string: \\\"{}\\\"\\n\", \n                any_cast<const string&>(a));\n        } else if (a.type() == typeid(list<int>)) {\n            cout << \"list<int>: \";\n            for(auto& i : any_cast<const list<int>&>(a)) \n                cout << format(\"{} \", i);\n            cout << '\\n';\n        } else {\n            cout << format(\"something else: {}\\n\", \n                a.type().name());\n        }\n    }\n    ```", "```cpp\n    p_any({});\n    p_any(47);\n    p_any(\"abc\"s);\n    p_any(any(list{ 1, 2, 3 }));\n    p_any(any(vector{ 1, 2, 3 }));\n    ```", "```cpp\nNone.\nint: 47\nstring: \"abc\"\nlist<int>: 1 2 3\nsomething else: St6vectorIiSaIiEE\n```", "```cpp\ntry {\n    cout << any_cast<int>(x) << '\\n';\n} catch(std::bad_any_cast& e) {\n    cout << format(\"any: {}\\n\", e.what());\n}\n```", "```cpp\nany: bad any_cast\n```", "```cpp\nunion ipv4 {\n    struct {\n        uint8_t a; uint8_t b; uint8_t c; uint8_t d;\n    } quad;\n    uint32_t int32;\n} addr;\naddr.int32 = 0x2A05A8C0;\ncout << format(\"ip addr dotted quad: {}.{}.{}.{}\\n\", \n    addr.quad.a, addr.quad.b, addr.quad.c, addr.quad.d);\ncout << format(\"ip addr int32 (LE): {:08X}\\n\", addr.int32);\n```", "```cpp\nip addr dotted quad: 192.168.5.42\nip addr int32 (LE): 2A05A8C0\n```", "```cpp\n    class Animal {\n        string_view _name{};\n        string_view _sound{};\n        Animal();\n    public:\n        Animal(string_view n, string_view s) \n            : _name{ n }, _sound{ s } {}\n        void speak() const {\n            cout << format(\"{} says {}\\n\", _name, _sound);\n        }\n        void sound(string_view s) {\n            _sound = s;\n        }\n    };\n    ```", "```cpp\n    class Cat : public Animal {\n    public:\n        Cat(string_view n) : Animal(n, \"meow\") {}\n    };\n    class Dog : public Animal {\n    public:\n        Dog(string_view n) : Animal(n, \"arf!\") {}\n    };\n    class Wookie : public Animal {\n    public:\n        Wookie(string_view n) : Animal(n, \"grrraarrgghh!\") {}\n    };\n    ```", "```cpp\n    using v_animal = std::variant<Cat, Dog, Wookie>;\n    ```", "```cpp\n    int main() {\n        list<v_animal> pets{ \n            Cat{\"Hobbes\"}, Dog{\"Fido\"}, Cat{\"Max\"}, \n            Wookie{\"Chewie\"}\n        };\n        ...\n    ```", "```cpp\nstruct animal_speaks {\n    void operator()(const Dog& d) const { d.speak(); }\n    void operator()(const Cat& c) const { c.speak(); }\n    void operator()(const Wookie& w) const { \n      w.speak(); }\n};\n```", "```cpp\nfor (const v_animal& a : pets) {\n    visit(animal_speaks{}, a);\n}\n```", "```cpp\nHobbes says meow\nFido says arf!\nMax says meow\nChewie says grrraarrgghh!\n```", "```cpp\n    for(const v_animal &a : pets) {\n        auto idx{ a.index() };\n        if(idx == 0) get<Cat>(a).speak();\n        if(idx == 1) get<Dog>(a).speak();\n        if(idx == 2) get<Wookie>(a).speak();\n    }\n    ```", "```cpp\nHobbes says meow\nFido says arf!\nMax says meow\nChewie says grrraarrgghh!\n```", "```cpp\n    for (const v_animal& a : pets) {\n        if(const auto c{ get_if<Cat>(&a) }; c) {\n            c->speak();\n        } else if(const auto d{ get_if<Dog>(&a) }; d) {\n            d->speak();\n        } else if(const auto w{ get_if<Wookie>(&a) }; w) {\n            w->speak();\n        }\n    }\n    ```", "```cpp\nHobbes says meow\nFido says arf!\nMax says meow\nChewie says grrraarrgghh!\n```", "```cpp\n    size_t n_cats{}, n_dogs{}, n_wookies{};\n    for(const v_animal& a : pets) {\n        if(holds_alternative<Cat>(a)) ++n_cats;\n        if(holds_alternative<Dog>(a)) ++n_dogs;\n        if(holds_alternative<Wookie>(a)) ++n_wookies;\n    }\n    cout << format(\"there are {} cat(s), \"\n                   \"{} dog(s), \"\n                   \"and {} wookie(s)\\n\",\n                   n_cats, n_dogs, n_wookies);\n    ```", "```cpp\nthere are 2 cat(s), 1 dog(s), and 1 wookie(s)\n```", "```cpp\nif(v.index() == 0) // if variant is type X\n```", "```cpp\nif(holds_alternative<X>(v))  // if current variant obj is type X\n```", "```cpp\nauto o{ get<X>(v) };  // current variant obj must be type X\n```", "```cpp\nauto* p{ get_if<X>(v) };  // nullptr if current obj not type X\n```", "```cpp\nvisit(f, v);  // calls f(v) with current variant obj\n```", "```cpp\nstruct animal_speaks {\n    void operator()(const Dog& d) const { d.speak(); }\n    void operator()(const Cat& c) const { c.speak(); }\n    void operator()(const Wookie& v) const { v.speak(); }\n};\nmain() {\n    for (const v_animal& a : pets) {\n        visit(animal_speaks{}, a);\n    } \n}\n```", "```cpp\nHobbes says meow\nFido says arf!\nMax says meow\nChewie says grrraarrgghh!\n```", "```cpp\n    using std::chrono::system_clock;\n    using std::chrono::steady_clock;\n    using std::chrono::high_resolution_clock;\n    using std::chrono::duration;\n    using seconds = duration<double>;\n    using milliseconds = duration<double, std::milli>;\n    using microseconds = duration<double, std::micro>;\n    using fps24 = duration<unsigned long, std::ratio<1, 24>>;\n    ```", "```cpp\n    auto t = system_clock::now();\n    cout << format(\"system_clock::now is {:%F %T}\\n\", t);\n    ```", "```cpp\nsystem_clock::now is 2022-02-05 13:52:15\n```", "```cpp\nstd::time_t now_t = system_clock::to_time_t(t);\ncout << \"system_clock::now is \" \n     << std::put_time(std::localtime(&now_t), \"%F %T\") \n     << '\\n';\n```", "```cpp\nsystem_clock::now is 2022-02-05 13:52:15\n```", "```cpp\n    constexpr uint64_t MAX_PRIME{ 0x1FFFF }\n    uint64_t count_primes() {\n        constexpr auto is_prime = [](const uint64_t n) {\n            for(uint64_t i{ 2 }; i < n / 2; ++i) {\n                if(n % i == 0) return false;\n            }\n            return true;\n        };\n        uint64_t count{ 0 };\n        uint64_t start{ 2 };\n        uint64_t end{ MAX_PRIME };\n        for(uint64_t i{ start }; i <= end ; ++i) {\n            if(is_prime(i)) ++count;\n       }\n       return count;\n    }\n    ```", "```cpp\n    seconds timer(uint64_t(*f)()) {\n        auto t1{ system_clock::now() };\n        uint64_t count{ f() };\n        auto t2{ system_clock::now() };\n        seconds secs{ t2 - t1 };\n        cout << format(\"there are {} primes in range\\n\", \n          count);\n        return secs;\n    }\n    ```", "```cpp\n    int main() {\n        auto secs{ timer(count_primes) };\n        cout << format(\"time elapsed: {:.3f} seconds\\n\", \n            secs.count());\n        ...\n    ```", "```cpp\nthere are 12252 primes in range\ntime elapsed: 3.573 seconds\n```", "```cpp\nseconds timer(uint64_t(*f)()) {\n    auto t1{ steady_clock::now() };\n    uint64_t count{ f() };\n    auto t2{ steady_clock::now() };\n    seconds secs{ t2 - t1 };\n    cout << format(\"there are {} primes in range\\n\", \n      count);\n    return secs;\n}\n```", "```cpp\n    using seconds = duration<double>;\n    ```", "```cpp\ntemplate<class Rep, class Period = std::ratio<1>>\nclass duration;\n```", "```cpp\nusing milliseconds = duration<double, std::milli>;\nusing microseconds = duration<double, std::micro>;\n```", "```cpp\nusing fps24 = duration<unsigned long, std::ratio<1, 24>>;\n```", "```cpp\ncout << format(\"time elapsed: {:.3f} sec\\n\", secs.count());\ncout << format(\"time elapsed: {:.3f} ms\\n\", \n    milliseconds(secs).count());\ncout << format(\"time elapsed: {:.3e} μs\\n\", \n    microseconds(secs).count());\ncout << format(\"time elapsed: {} frames at 24 fps\\n\", \n    floor<fps24>(secs).count());\n```", "```cpp\ntime elapsed: 3.573 sec\ntime elapsed: 3573.077 ms\ntime elapsed: 3.573e+06 μs\ntime elapsed: 85 frames at 24 fps\n```", "```cpp\n    cout << format(\"time elapsed: {:.3}\\n\", secs);\n    cout << format(\"time elapsed: {:.3}\\n\", milliseconds(secs));\n    cout << format(\"time elapsed: {:.3}\\n\", microseconds(secs));\n    ```", "```cpp\ntime elapsed: 3.573s\ntime elapsed: 3573.077ms\ntime elapsed: 3573076.564μs\n```", "```cpp\nauto t1{ steady_clock::now() };\n```", "```cpp\nduration<double> secs{ t2 - t1 };\n```", "```cpp\ntemplate<class C, class D1, class D2>\nconstexpr duration<D1,D2>\noperator-( const time_point<C,D1>& pt_lhs,\n    const time_point<C,D2>& pt_rhs );\n```", "```cpp\ntemplate<class Rep, class Period = std::ratio<1>>\nclass duration;\n```", "```cpp\nusing milliseconds = duration<double, std::milli>;\nusing microseconds = duration<double, std::micro>;\n```", "```cpp\nconstexpr Rep count() const;\n```", "```cpp\ncout << format(\"duration: {}\\n\", secs.count());\n```", "```cpp\ntemplate<typename T>\nvoid f(T final) {\n    cout << final << '\\n';\n}\ntemplate<typename T, typename... Args>\nvoid f(T first, Args... args) {\n    cout << first;\n    f(args...);\n}\nint main() {\n    f(\"hello\", ' ', 47, ' ', \"world\");\n}\n```", "```cpp\nhello 47 world\n```", "```cpp\ntemplate<typename... Args>\nvoid f(Args... args) {\n    (cout << ... << args);\n    cout << '\\n';\n}\n```", "```cpp\nhello 47 world\n```", "```cpp\n(cout << ... << args);\n```", "```cpp\ncout << \"hello\" << ' ' << 47 << ' ' << \"world\";\n```", "```cpp\n    template<typename... T>\n    constexpr void print_t(const tuple<T...>& tup) {\n        auto lpt =\n            [&tup] <size_t... I> \n              (std::index_sequence<I...>)\n                constexpr {\n                (..., ( cout <<\n                    format((I? \", {}\" : \"{}\"), \n                      get<I>(tup))\n                ));\n                cout << '\\n';\n            };\n        lpt(std::make_index_sequence<sizeof...(T)>());\n    }\n    ```", "```cpp\n    int main() {\n        tuple lables{ \"ID\", \"Name\", \"Scale\" };\n        tuple employee{ 123456, \"John Doe\", 3.7 };\n        tuple nums{ 1, 7, \"forty-two\", 47, 73L, -111.11 };\n\n        print_t(lables);\n        print_t(employee);\n        print_t(nums);\n    }\n    ```", "```cpp\nID, Name, Scale\n123456, John Doe, 3.7\n1, 7, forty-two, 47, 73, -111.11\n```", "```cpp\nlpt(std::make_index_sequence<sizeof...(T)>());\n```", "```cpp\n[&tup] <size_t... I> (std::index_sequence<I...>) constexpr {\n   ...\n};\n```", "```cpp\n(..., ( cout << format(\"{} \", std::get<I>(tup))));\n```", "```cpp\ntemplate<typename... T>\nconstexpr int sum_t(const tuple<T...>& tup) {\n    int accum{};\n    auto lpt =\n        [&tup, &accum] <size_t... I> \n          (std::index_sequence<I...>) \n        constexpr {\n            (..., ( \n                accum += get<I>(tup)\n            ));\n        };\n    lpt(std::make_index_sequence<sizeof...(T)>());\n    return accum;\n}\n```", "```cpp\ntuple ti1{ 1, 2, 3, 4, 5 };\ntuple ti2{ 9, 10, 11, 12, 13, 14, 15 };\ntuple ti3{ 47, 73, 42 };\nauto sum1{ sum_t(ti1) };\nauto sum2{ sum_t(ti2) };\nauto sum3{ sum_t(ti3) };\ncout << format(\"sum of ti1: {}\\n\", sum1);\ncout << format(\"sum of ti2: {}\\n\", sum2);\ncout << format(\"sum of ti3: {}\\n\", sum3);\n```", "```cpp\nsum of ti1: 15\nsum of ti2: 84\nsum of ti3: 162\n```", "```cpp\n{   // beginning of scope\n    auto p = make_unique<Thing>(); // memory alloc’d,\n                                   // ctor called\n    process_thing(p);   // p is unique_ptr<Thing>\n}   // end of scope, dtor called, memory freed\n```", "```cpp\nauto x = *p;  // *p derefs the pointer, returns Thing object\nauto y = p->thname; // p-> derefs the pointer, returns member\n```", "```cpp\n    struct Thing {\n        string_view thname{ \"unk\" };\n        Thing() {\n            cout << format(\"default ctor: {}\\n\", thname);\n        }\n        Thing(const string_view& n) : thname(n) {\n            cout << format(\"param ctor: {}\\n\", thname);\n        }\n        ~Thing() {\n            cout << format(\"dtor: {}\\n\", thname);\n        }\n    };\n    ```", "```cpp\n    int main() {\n        unique_ptr<Thing> p1;\n        cout << \"end of main()\\n\";\n    }\n    ```", "```cpp\nend of main()\n```", "```cpp\n    int main() {\n        unique_ptr<Thing> p1{ new Thing };\n        cout << \"end of main()\\n\";\n    }\n    ```", "```cpp\ndefault ctor: unk\nend of main()\ndtor: unk\n```", "```cpp\n    int main() {\n        auto p1 = make_unique<Thing>();\n        cout << \"end of main()\\n\";\n    }\n    ```", "```cpp\ndefault ctor: unk\nend of main()\ndtor: unk\n```", "```cpp\n    int main() {\n        auto p1 = make_unique<Thing>(\"Thing 1\") };\n        cout << \"end of main()\\n\";\n    }\n    ```", "```cpp\nparam ctor: Thing 1\nend of main()\ndtor: Thing 1\n```", "```cpp\n    void process_thing(unique_ptr<Thing> p) {\n        if(p) cout << format(\"processing: {}\\n\", \n          p->thname);\n        else cout << \"invalid pointer\\n\";\n    }\n    ```", "```cpp\nprocess_thing(p1);\n```", "```cpp\nerror: use of deleted function...\n```", "```cpp\nvoid process_thing(const unique_ptr<Thing>& p) {\n    if(p) cout << format(\"processing: {}\\n\", \n      p->thname);\n    else cout << \"invalid pointer\\n\";\n}\n```", "```cpp\nparam ctor: Thing 1\nprocessing: Thing 1\nend of main()\ndtor: Thing 1\n```", "```cpp\n    int main() {\n        auto p1{ make_unique<Thing>(\"Thing 1\") };\n        process_thing(p1);\n        process_thing(make_unique<Thing>(\"Thing 2\"));\n        cout << \"end of main()\\n\";\n    }\n    ```", "```cpp\nparam ctor: Thing 1\nprocessing: Thing 1\nparam ctor: Thing 2\nprocessing: Thing 2\ndtor: Thing 2\nend of main()\ndtor: Thing 1\n```", "```cpp\nauto p2 = p1;\n```", "```cpp\nerror: use of deleted function...\n```", "```cpp\nauto p2 = std::move(p1);\nprocess_thing(p1);\nprocess_thing(p2);\n```", "```cpp\ninvalid pointer\nprocessing: Thing 1\nend of main()\ndtor: Thing 1\n```", "```cpp\np1.reset();  // pointer is now invalid\nprocess_thing(p1);\n```", "```cpp\ndtor: Thing 1\ninvalid pointer\n```", "```cpp\np1.reset(new Thing(\"Thing 3\"));\nprocess_thing(p1);\n```", "```cpp\nparam ctor: Thing 3\ndtor: Thing 1\nprocessing: Thing 3\n```", "```cpp\n    struct Thing {\n        string_view thname{ \"unk\" };\n        Thing() {\n            cout << format(\"default ctor: {}\\n\", thname);\n        }\n        Thing(const string_view& n) : thname(n) {\n            cout << format(\"param ctor: {}\\n\", thname);\n        }\n        ~Thing() {\n            cout << format(\"dtor: {}\\n\", thname);\n        }\n    };\n    ```", "```cpp\n    int main() {\n        shared_ptr<Thing> p1{ new Thing(\"Thing 1\") };\n        auto p2 = make_shared<Thing>(\"Thing 2\");\n        cout << \"end of main()\\n\";\n    }\n    ```", "```cpp\nparam ctor: Thing 1\nparam ctor: Thing 2\nend of main()\ndtor: Thing 2\ndtor: Thing 1\n```", "```cpp\n    void check_thing_ptr(const shared_ptr<Thing>& p) {\n        if(p) cout << format(\"{} use count: {}\\n\", \n            p->thname, p.use_count());\n        else cout << \"invalid pointer\\n\";\n    }\n    ```", "```cpp\ncheck_thing_ptr(p1);\ncheck_thing_ptr(p2);\n```", "```cpp\nThing 1 use count: 1\nThing 2 use count: 1\n```", "```cpp\n    cout << \"make 4 copies of p1:\\n\";\n    auto pa = p1;\n    auto pb = p1;\n    auto pc = p1;\n    auto pd = p1;\n    check_thing_ptr(p1);\n    ```", "```cpp\nmake 4 copies of p1:\nThing 1 use count: 5\n```", "```cpp\n    check_thing_ptr(pa);\n    check_thing_ptr(pb);\n    check_thing_ptr(pc);\n    check_thing_ptr(pd);\n    ```", "```cpp\nThing 1 use count: 5\nThing 1 use count: 5\nThing 1 use count: 5\nThing 1 use count: 5\n```", "```cpp\n    {   // new scope\n        cout << \"make 4 copies of p1:\\n\";\n        auto pa = p1;\n        auto pb = p1;\n        auto pc = p1;\n        auto pd = p1;\n        check_thing_ptr(p1);\n    }   // end of scope\n    check_thing_ptr(p1);\n    ```", "```cpp\nmake 4 copies of p1:\nThing 1 use count: 5\nThing 1 use count: 1\n```", "```cpp\n    {    \n        cout << \"make 4 copies of p1:\\n\";\n        auto pa = p1;\n        auto pb = p1;\n        auto pc = p1;\n        auto pd = p1;\n        check_thing_ptr(p1);\n        pb.reset();\n        p1.reset();\n        check_thing_ptr(pd);\n    }   // end of scope\n    ```", "```cpp\nmake 4 copies of p1:\nThing 1 use count: 5\nThing 1 use count: 3\ndtor: Thing 1\n```", "```cpp\n    struct Thing {\n        string_view thname{ \"unk\" };\n        Thing() {\n            cout << format(\"default ctor: {}\\n\", thname);\n        }\n        Thing(const string_view& n) : thname(n) {\n            cout << format(\"param ctor: {}\\n\", thname);\n        }\n        ~Thing() {\n            cout << format(\"dtor: {}\\n\", thname);\n        }\n    };\n    ```", "```cpp\n    void get_weak_thing(const weak_ptr<Thing>& p) {\n        if(auto sp = p.lock()) cout << \n            format(\"{}: count {}\\n\", sp->thname, \n              p.use_count());\n        else cout << \"no shared object\\n\";\n    }\n    ```", "```cpp\n    int main() {\n        auto thing1 = make_shared<Thing>(\"Thing 1\");\n        weak_ptr<Thing> wp1;\n        cout << format(\"expired: {}\\n\", wp1.expired());\n        get_weak_thing(wp1);\n    }\n    ```", "```cpp\nparam ctor: Thing 1\nexpired: true\nno shared object\n```", "```cpp\n    wp1 = thing1;\n    get_weak_thing(wp1);\n    ```", "```cpp\nThing 1: count 2\n```", "```cpp\n    weak_ptr<Thing> wp2(thing1);\n    get_weak_thing(wp2);\n    ```", "```cpp\nThing 1: count 2\n```", "```cpp\n    thing1.reset();\n    get_weak_thing(wp1);\n    get_weak_thing(wp2);\n    ```", "```cpp\ndtor: Thing 1\nno shared object\nno shared object\n```", "```cpp\nlong use_count() const noexcept;\n```", "```cpp\nbool expired() const noexcept;\n```", "```cpp\nstd::shared_ptr<T> lock() const noexcept;\n```", "```cpp\nstruct circB;\nstruct circA {\n    shared_ptr<circB> p;\n    ~circA() { cout << \"dtor A\\n\"; }\n};\nstruct circB {\n    shared_ptr<circA> p;\n    ~circB() { cout << \"dtor B\\n\"; }\n};\n```", "```cpp\nint main() {\n    auto a{ make_shared<circA>() };\n    auto b{ make_shared<circB>() };\n    a->p = b;\n    b->p = a;\n    cout << \"end of main()\\n\";\n}\n```", "```cpp\nend of main()\n```", "```cpp\nstruct circB {\n    weak_ptr<circA> p;\n    ~circB() { cout << \"dtor B\\n\"; }\n};\n```", "```cpp\nend of main()\ndtor A\ndtor B\n```", "```cpp\nshared_ptr( shared_ptr<Y>&& ref, element_type* ptr ) noexcept;\n```", "```cpp\n    struct animal {\n        string name{};\n        string sound{};\n        animal(const string& n, const string& a)\n                : name{n}, sound{a} {\n            cout << format(\"ctor: {}\\n\", name);\n        }\n        ~animal() {\n            cout << format(\"dtor: {}\\n\", name);\n        }\n    };\n    ```", "```cpp\n    auto make_animal(const string& n, const string& s) {\n        auto ap = make_shared<animal>(n, s);\n        auto np = shared_ptr<string>(ap, &ap->name);\n        auto sp = shared_ptr<string>(ap, &ap->sound);\n        return tuple(np, sp);\n    }\n    ```", "```cpp\n    int main() {\n        auto [name, sound] =\n            make_animal(\"Velociraptor\", \"Grrrr!\");\n        cout << format(\"The {} says {}\\n\", *name, *sound);\n        cout << format(\"Use count: name {}, sound {}\\n\", \n            name.use_count(), sound.use_count()); \n    }\n    ```", "```cpp\nctor: Velociraptor\nThe Velociraptor says Grrrr!\nUse count: name 2, sound 2\ndtor: Velociraptor\n```", "```cpp\n    constexpr size_t n_samples{ 1000 };\n    constexpr size_t n_partitions{ 10 };\n    constexpr size_t n_max{ 50 };\n    ```", "```cpp\n    template <typename RNG>\n    void histogram(const string_view& rng_name) {\n        auto p_ratio = (double)RNG::max() / n_partitions;\n        RNG rng{};  // construct the engine object\n        // collect the samples\n        vector<size_t> v(n_partitions);\n        for(size_t i{}; i < n_samples; ++i) {\n            ++v[rng() / p_ratio];\n        }\n        // display the histogram\n        auto max_el = std::max_element(v.begin(), \n          v.end());\n        auto v_ratio = *max_el / n_max;\n        if(v_ratio < 1) v_ratio = 1;\n        cout << format(\"engine: {}\\n\", rng_name);\n        for(size_t i{}; i < n_partitions; ++i) {\n            cout << format(\"{:02}:{:*<{}}\\n\",\n                i + 1, ' ', v[i] / v_ratio);\n        }\n        cout << '\\n';\n    }\n    ```", "```cpp\n    int main() {\n        histogram<std::random_device>(\"random_device\");\n        histogram<std::default_random_engine>\n            (\"default_random_engine\");\n        histogram<std::minstd_rand0>(\"minstd_rand0\");\n        histogram<std::minstd_rand>(\"minstd_rand\");\n        histogram<std::mt19937>(\"mt19937\");\n        histogram<std::mt19937_64>(\"mt19937_64\");\n        histogram<std::ranlux24_base>(\"ranlux24_base\");\n        histogram<std::ranlux48_base>(\"ranlux48_base\");\n        histogram<std::ranlux24>(\"ranlux24\");\n        histogram<std::ranlux48>(\"ranlux48\");\n        histogram<std::knuth_b>(\"knuth_b\");\n    }\n    ```", "```cpp\nresult_type operator()();\n```", "```cpp\ntemplate <typename RNG>\n```", "```cpp\nRNG rng{};\nvector<size_t> v(n_partitions);\nfor(size_t i{}; i < n_samples; ++i) {\n    ++v[rng() / p_ratio];\n}\n```", "```cpp\n    constexpr size_t n_samples{ 10 * 1000 };\n    constexpr size_t n_max{ 50 };\n    ```", "```cpp\n    void dist_histogram(auto distro,\n            const string_view& dist_name) {\n        std::default_random_engine rng{};\n        map<long, size_t> m;\n        // create the histogram map\n        for(size_t i{}; i < n_samples; ++i) \n            ++m[(long)distro(rng)];\n        // print the histogram\n        auto max_elm_it = max_element(m.begin(), m.end(),\n            [](const auto& a, const auto& b)\n            { return a.second < b.second; }\n            );\n        size_t max_elm = max_elm_it->second;\n        size_t max_div = std::max(max_elm / n_max,\n            size_t(1));\n        cout << format(\"{}:\\n\", dist_name);\n        for (const auto [randval, count] : m) {\n            if (count < max_elm / n_max) continue;\n            cout << format(\"{:3}:{:*<{}}\\n\",\n                randval, ' ', count / max_div);\n        }\n    }\n    ```", "```cpp\n    int main() {\n        dist_histogram(std::uniform_int_distribution<int>\n            {0, 9}, uniform_int_distribution\");\n        dist_histogram(std::normal_distribution<double>\n            {0.0, 2.0}, \"normal_distribution\");\n    ...\n    ```", "```cpp\nresult_type operator()( Generator& g );\n```", "```cpp\nstd::default_random_engine rng{};\nmap<long, size_t> m;\nfor (size_t i{}; i < n_samples; ++i) ++m[(long)distro(rng)];\n```"]