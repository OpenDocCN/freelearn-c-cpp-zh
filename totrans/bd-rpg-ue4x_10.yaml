- en: Chapter 10. Leveling, Abilities, and Saving Progress
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章。等级提升、能力和保存进度
- en: In the previous chapter, we covered how to create and apply equipment to the
    player, which when equipped, affects the stats of the player. In this chapter,
    we will allow the player to level up by setting up an experience system for each
    party member, allowing party members to gain experience from enemies when winning
    in combat. When each party member gains enough experience, they will level up
    and their stats will increase at each level that the party member has gained.
    We will also fix the combat damage settings so that attacks in combat will utilize
    character stats rather than hardcoded values. Once we have fixed the combat logic,
    we will then move on to creating an ability for our character that will be activated
    by gaining a level.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了如何创建并应用装备到玩家身上，当装备后，会影响玩家的属性。在本章中，我们将允许玩家通过为每个团队成员设置经验系统来提升等级，使团队成员在战斗中获胜时从敌人那里获得经验。当每个团队成员获得足够经验时，他们将会提升等级，并且每提升一个等级，他们的属性都会增加。我们还将修复战斗伤害设置，以便战斗中的攻击将利用角色属性而不是硬编码的值。一旦我们修复了战斗逻辑，我们接下来将创建一个能力，该能力将在角色获得等级时激活。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: XP and Leveling source code
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XP 和等级提升源代码
- en: Data Table starting values
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据表起始值
- en: Displaying levels and experience in the pause menu
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在暂停菜单中显示等级和经验
- en: Applying the correct damage in combat
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在战斗中应用正确的伤害
- en: Setting up the abilities array
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置能力数组
- en: Abilities logic
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能力逻辑
- en: Saving
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存
- en: Loading
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载
- en: XP and leveling source code
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: XP 和等级提升源代码
- en: 'In order to allow party members to gain experience points from battle, we need
    to add experience points (which we will call XP) variables to our code. Moreover,
    the XP variables need to accumulate to a given XP cap (which we will call MXP
    for maximum XP), and if this cap is hit, the player will gain a level. The best
    way to do this is to add these variables to our source code, which we will then
    apply to every party member and enemy that we have in the game. The first thing
    we will do is add XP and leveling data to our Data classes. Navigate to **UnrealRPG**
    | **Source** | **Data** and open `FCharacterClassInfo.h`. In the `FCharacterClassInfo
    : public FTableRowBase` struct, add `UPROPERTY` to `XP` that will hold cumulative
    experience, `MXP` that will hold the experience cap to the next level, and `Lvl`
    that will hold the party member''s current level:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '为了使团队成员能够从战斗中获得经验值，我们需要在我们的代码中添加经验值（我们将称之为 XP）变量。此外，XP 变量需要累积到一个给定的 XP 上限（我们将称之为
    MXP，即最大 XP），如果达到这个上限，玩家将获得一个等级。最好的方法是将这些变量添加到我们的源代码中，然后将其应用到游戏中我们拥有的每个团队成员和敌人身上。我们首先将做的是将
    XP 和等级数据添加到我们的数据类中。导航到 **UnrealRPG** | **Source** | **Data** 并打开 `FCharacterClassInfo.h`。在
    `FCharacterClassInfo : public FTableRowBase` 结构体中，为 `XP` 添加 `UPROPERTY` 以存储累积经验，为
    `MXP` 添加 `UPROPERTY` 以存储达到下一个等级的经验上限，为 `Lvl` 添加 `UPROPERTY` 以存储团队成员的当前等级：'
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, open `FEnemyInfo.h`, which is located in the same folder as `FCharacterClassInfo.h`.
    We need to add XP to the enemy''s info because each enemy will give a certain
    amount of XP to party members. In the `FEnemyInfo : public FTableRowBase` struct,
    add a `UPROPERTY` to `XP`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来，打开 `FEnemyInfo.h`，它位于 `FCharacterClassInfo.h` 相同的文件夹中。我们需要为敌人的信息添加 XP，因为每个敌人都会给团队成员提供一定数量的
    XP。在 `FEnemyInfo : public FTableRowBase` 结构体中，为 `XP` 添加 `UPROPERTY`：'
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We will now need to use these variables in the `GameCharacter` instances of
    the game. Navigate to **UnrealRPG** | **Source** and open `GameCharacter.h`. In
    the `class RPG_API UGameCharacter : public UObject` struct, add `UPROPERTY` to
    `XP`, `MXP`, and `Lvl`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '我们现在需要在游戏的 `GameCharacter` 实例中使用这些变量。导航到 **UnrealRPG** | **Source** 并打开 `GameCharacter.h`。在
    `class RPG_API UGameCharacter : public UObject` 结构体中，为 `XP`、`MXP` 和 `Lvl` 添加 `UPROPERTY`：'
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Open `GameCharacter.cpp` so that we set game character instances equal to the
    party member and enemy data. First, in `UGameCharacter* UGameCharacter::CreateGameCharacter(
    FCharacterInfo* characterInfo, UObject* outer )`, set the character''s `XP`, `MXP`,
    and `Lvl` equal to the party member''s data:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `GameCharacter.cpp` 以设置游戏角色实例等于团队成员和敌人数据。首先，在 `UGameCharacter* UGameCharacter::CreateGameCharacter(
    FCharacterInfo* characterInfo, UObject* outer )` 中，将角色的 `XP`、`MXP` 和 `Lvl` 设置为团队成员的数据：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, set each instance of the enemy character''s XP equal to the XP enemy
    data:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将每个敌人角色的 XP 设置等于 XP 敌人数据：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can now add an XP framework to our combat engine. Open `CombatEngine.h`.
    Add `XPTotal` as a public variable:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以向我们的战斗引擎添加一个 XP 框架。打开 `CombatEngine.h`。添加 `XPTotal` 作为公共变量：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `XPTotal` will be responsible for holding the total amount of XP gained
    from battle if all of the enemies have perished.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`XPTotal`将负责存储所有敌人阵亡时从战斗中获得的总经验值。'
- en: 'At this point, let''s use the XP variables that we created to calculate the
    amount of XP gained from battle. Open `CombatEngine.cpp`. In `bool CombatEngine::Tick(
    float DeltaSeconds )`, add XP to our check for victory section. To do this, we
    will set the local `XP` variable to `0`, and for every enemy in the battle, we
    will accumulate the total amount of experience in the `XP` variable:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，让我们使用我们创建的经验值变量来计算从战斗中获得的经验值数量。打开`CombatEngine.cpp`。在`bool CombatEngine::Tick(float
    DeltaSeconds)`中，将经验值添加到我们的胜利检查部分。为此，我们将局部`XP`变量设置为`0`，并且对于战斗中的每个敌人，我们将累积的经验值累加到`XP`变量中：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If all of the party members have died, we will store the total XP of the enemies
    in our public `XPTotal` variable to be used outside this class:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有玩家成员都已阵亡，我们将把敌人的总经验值存储在我们的公共`XPTotal`变量中，以便在类外使用：
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Lastly, we can add the XP gained to each party member in our game instance.
    To do this, open `RPGGameMode.cpp`. In `void ARPGGameMode::Tick( float DeltaTime
    )`, where we added a check to the victory phase, we will create a `for` loop.
    This `for` loop will cycle through every party member, and for each party member,
    we will set their current XP to be a cumulative of the XP gained from the battle:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以在我们的游戏实例中为每个玩家成员添加获得的经验值。为此，打开`RPGGameMode.cpp`。在`void ARPGGameMode::Tick(float
    DeltaTime)`中，我们添加了对胜利阶段的检查，我们将创建一个`for`循环。这个`for`循环将遍历每个玩家成员，并且对于每个玩家成员，我们将他们的当前经验值设置为从战斗中获得的经验值的累积：
- en: '[PRE8]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this `for` loop, we can also check the current XP with the current XP cap
    for the level the player is currently at. If the current XP of the party member
    is more than or equal to `MXP`, the player will level up, gain increased base
    stats, and the XP cap to gain the next level (`MXP`) will increase:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`for`循环中，我们还可以检查玩家当前所在等级的当前经验值与当前经验值上限。如果玩家成员的当前经验值超过或等于`MXP`，玩家将升级，获得增加的基础属性，并且获得下一个等级（`MXP`）的经验值上限将增加：
- en: '[PRE9]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this example, we kept our calculations simple by only allowing the stats
    to increase by one when the party member gains a level, and setting the cap to
    the next level to just be double of what the previous level was. If you like,
    you can come up with more complex calculations specific to your game here. Note
    that all the calculations used for differentiating stat numbers and for each party
    member can be done here.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们通过只允许玩家成员获得等级时属性增加1，并将下一个等级的上限设置为上一个等级的两倍来简化了计算。如果你喜欢，你可以在你的游戏中提出更复杂的计算。请注意，用于区分属性数值和每个玩家成员的所有计算都可以在这里完成。
- en: 'When you are done, the victory condition will look like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成时，胜利条件将如下所示：
- en: '[PRE10]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: At this point, you can compile your source code and restart/open your project
    in UE4.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可以编译你的源代码，并在UE4中重新启动/打开你的项目。
- en: We are now done with creating the framework for our experience system in our
    source code, and we can now move on to providing specific starting values for
    each of these in our game.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了在源代码中创建经验系统框架的工作，现在我们可以继续为游戏中的每个这些值提供特定的起始值。
- en: Data Table starting values
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据表起始值
- en: 'In **Content Browser**, open the **CharacterClasses** Data Table by navigating
    to **Content** | **Data**. Here, we can change the starting values of our party
    members. For the soldier, we will have the starting XP as 0 because the party
    member should start with 0 experience. The **MXP** value will be **200**, which
    means that the Soldier will have to gain 200 experience points before making it
    to the next level. The **Lvl** value will be at **1** since we want each character
    to start at level 1:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在**内容浏览器**中，通过导航到**内容** | **数据**来打开**CharacterClasses**数据表。在这里，我们可以更改我们玩家成员的起始值。对于士兵，我们将起始经验值设为0，因为玩家成员应该从0经验值开始。**MXP**值将是**200**，这意味着士兵必须获得200经验值才能达到下一个等级。**Lvl**值将是**1**，因为我们希望每个角色从等级1开始：
- en: '![Data Table starting values](img/B04548_10_01.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![数据表起始值](img/B04548_10_01.jpg)'
- en: 'We should now set how much XP our enemies give. In the same folder, open the
    **Enemies** Data Table, where we have at least one enemy. For each enemy, we need
    to set a value for **XP** that will determine how much experience the enemy drops
    when they are killed. For this particular enemy, we set the **XP** value to **50**:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在应该设置敌人给予的多少经验值。在同一个文件夹中，打开**敌人** 数据表，其中至少有一个敌人。对于每个敌人，我们需要设置一个**经验值**，这将决定当敌人被杀死时掉落多少经验。对于这个特定的敌人，我们将**经验值**设置为**50**：
- en: '![Data Table starting values](img/B04548_10_02.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![数据表起始值](img/B04548_10_02.jpg)'
- en: Displaying levels and experience in the pause menu
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 暂停菜单中显示等级和经验
- en: 'At this point, if you test the build, the party members will gain experience
    from battle and level up accordingly (you will be able to tell by watching the
    stats grow if a party member has gained enough experience to level up), but we
    will not yet display the proper level or experience points of the party members.
    We can easily do this by binding these values to our pause menu. Navigate to **Content**
    | **Blueprints** | **UI**. Open the **Pause_Main** Widget Blueprint. In the **Designer**
    view, select the **Editable_Soldier_Level** Text Block on the right-hand side
    of **Soldier Lvl** that we created in [Chapter 4](ch04.html "Chapter 4. Pause
    Menu Framework"), *Pause Menu Framework*:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，如果你测试构建，团队成员将在战斗中获得经验并相应地升级（如果你看到统计信息增长，就可以知道是否有团队成员获得了足够的经验以升级），但我们还没有显示团队成员的正确等级或经验值。我们可以通过将这些值绑定到我们的暂停菜单中轻松地做到这一点。导航到**内容**
    | **蓝图** | **UI**。打开**Pause_Main** Widget 蓝图。在**设计师**视图中，选择**Soldier Lvl**右侧我们创建于[第4章](ch04.html
    "第4章。暂停菜单框架")的**Editable_Soldier_Level** 文本块，*暂停菜单框架*：
- en: '![Displaying levels and experience in the pause menu](img/B04548_10_03.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![暂停菜单中显示等级和经验](img/B04548_10_03.jpg)'
- en: 'In the **Details** tab under **Content**, create a bind to that text by clicking
    on the **Bind** drop-down menu and selecting **+Create Binding**:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在**内容**下的**详细信息**选项卡中，通过点击**绑定**下拉菜单并选择**+创建绑定**来为此文本创建一个绑定：
- en: '![Displaying levels and experience in the pause menu](img/B04548_10_04.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![暂停菜单中显示等级和经验](img/B04548_10_04.jpg)'
- en: 'This will automatically open the graph of the **Get Editable_Soldier_Level_Text**
    function. In the graph, we need to simply get the variables from the **RPGGameInstance**,
    like we did before, but this time, we are specifically getting the current **Lvl**
    variable and returning it as text:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这将自动打开**Get Editable_Soldier_Level_Text**函数的图表。在图表中，我们需要简单地从**RPGGameInstance**获取变量，就像我们之前做的那样，但这次我们特别获取当前的**Lvl**变量并将其作为文本返回：
- en: '![Displaying levels and experience in the pause menu](img/B04548_10_05.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![暂停菜单中显示等级和经验](img/B04548_10_05.jpg)'
- en: In this example, we are only getting the level for one party member (our soldier),
    which is in an index 0 in the array. If you have more than one party member, you
    will just need to change the index in your **GET** function to the proper index;
    for instance, an index of 1 will find the second party member in your array of
    party members and their stats, and would, therefore, return a different set of
    stats.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们只获取一个团队成员（我们的士兵）的等级，这在数组中的索引是0。如果你有多个团队成员，你只需在**GET**函数中更改索引到正确的索引；例如，索引1将找到你的团队成员数组中的第二个成员及其统计数据，因此将返回不同的统计数据集。
- en: 'The only undefined Text Block that we have in our pause menu is the **Editable_Soldier_XP**
    Text Block located on the right-hand side of the **XP/Next Lvl** text. Select
    this Text Block, navigate to the **Details** tab, and under **Content**, add a
    binding for the Text Block, like we did for our last Text Block, and the graph
    for the function labeled **Get Editable_Soldier_XP_Text** will pop up. Just like
    the last Text Block, we will get the correct party member''s current data; in
    particular, we will get XP and MXP because we want this Text Block to show the
    cumulative XP and the XP needed to get to the next level:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们暂停菜单中唯一未定义的文本块是位于**XP/Next Lvl**文本右侧的**Editable_Soldier_XP** 文本块。选择此文本块，导航到**详细信息**选项卡，并在**内容**下添加一个绑定，就像我们为最后一个文本块所做的那样，并且将弹出标记为**Get
    Editable_Soldier_XP_Text**的函数图。就像上一个文本块一样，我们将获取正确的团队成员当前数据；特别是，我们将获取经验值和MXP，因为我们希望这个文本块显示累积的经验值和达到下一级所需的经验值：
- en: '![Displaying levels and experience in the pause menu](img/B04548_10_06.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![暂停菜单中显示等级和经验](img/B04548_10_06.jpg)'
- en: 'You will notice that **ReturnNode** can only take one **Return Value** pin,
    and we have two separate values. We can easily solve this problem using the **Append**
    function and appending the text. We will find the **Append** function by simply
    right-clicking on our Blueprint, navigating to **Utilities** | **String**, and
    selecting **Append**:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到**ReturnNode**只能接受一个**返回值**引脚，而我们有两个不同的值。我们可以通过使用**Append**函数和追加文本来轻松解决这个问题。我们将通过在蓝图上右键单击，导航到**实用工具**
    | **字符串**，并选择**Append**来找到**Append**函数：
- en: '![Displaying levels and experience in the pause menu](img/B04548_10_07.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![在暂停菜单中显示等级和经验](img/B04548_10_07.jpg)'
- en: '**Append** takes two strings at a time. Since the Text Block should have a
    **/** to separate the current XP with the XP needed to make it to the next level,
    we will need two **Append** functions. For the first **Append**, link **XP** to
    the **A** pin, and in the **B** pin, simply append a **/**:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**Append**一次处理两个字符串。由于文本块应该有一个**/**来分隔当前经验值和达到下一级所需的经验值，我们需要两个**Append**函数。对于第一个**Append**，将**XP**连接到**A**引脚，并在**B**引脚中简单地追加一个**/**：'
- en: '![Displaying levels and experience in the pause menu](img/B04548_10_08.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![在暂停菜单中显示等级和经验](img/B04548_10_08.jpg)'
- en: 'Next, create another **Append** function, and connect the **Return Value**
    of the first **Append** function to the **A** pin of the second **Append** function.
    Then, connect **MXP** to the **B** pin of the second **Append** function in order
    to have **MXP** append the last set of strings:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建另一个**Append**函数，并将第一个**Append**函数的**返回值**连接到第二个**Append**函数的**A**引脚。然后，将**MXP**连接到第二个**Append**函数的**B**引脚，以便**MXP**追加最后一组字符串：
- en: '![Displaying levels and experience in the pause menu](img/B04548_10_09.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![在暂停菜单中显示等级和经验](img/B04548_10_09.jpg)'
- en: 'When you are done, simply connect the **Return Value** of the second **Append**
    function to the **Return Value** of the **ReturnNode**:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，只需将第二个**Append**函数的**返回值**连接到**ReturnNode**的**返回值**：
- en: '![Displaying levels and experience in the pause menu](img/B04548_10_10.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![在暂停菜单中显示等级和经验](img/B04548_10_10.jpg)'
- en: 'At this point, if you test your game by going into battle and leveling up,
    you will see that all of your stats will update correctly in the pause menu (the
    following screenshot is from after we have tested combat and gaining experience
    with foes):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，如果你通过进入战斗和升级来测试你的游戏，你将看到所有你的统计数据都会在暂停菜单中正确更新（以下截图是在我们测试了战斗和与敌人获得经验之后）：
- en: '![Displaying levels and experience in the pause menu](img/B04548_10_11.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![在暂停菜单中显示等级和经验](img/B04548_10_11.jpg)'
- en: Applying the correct damage in combat
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在战斗中应用正确的伤害
- en: In battle, you will notice that the enemy and the player both do 10 points of
    damage no matter what. The current attack power and defense do not seem to be
    calculated. This is because, in [Chapter 3](ch03.html "Chapter 3. Exploration
    and Combat"), *Exploration and Combat*, when we created the combat actions, we
    hardcoded the damage to be `target->HP -= 10`, which means that no matter who
    is attacking, they will deal 10 points of damage to the player. We can easily
    fix this to use the actual stats of enemies and players by navigating to **Source**
    | **RPG** | **Combat** | **Actions** and opening `TestCombatAction.cpp`. Find
    `target->HP -= 10;` and replace it with `target->HP -= (character->ATK - target->DEF)
    >= 0 ? (character->ATK - target->DEF):0;`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在战斗中，你会注意到无论发生什么情况，敌人和玩家都会造成10点伤害。当前的攻击力和防御力似乎没有被计算。这是因为，在[第3章](ch03.html "第3章。探索和战斗")中，当我们创建战斗动作时，我们硬编码了伤害为`target->HP
    -= 10`，这意味着无论谁攻击，他们都会对玩家造成10点伤害。我们可以很容易地通过导航到**源** | **RPG** | **战斗** | **动作**并打开`TestCombatAction.cpp`来修复这个问题。找到`target->HP
    -= 10;`并将其替换为`target->HP -= (character->ATK - target->DEF) >= 0 ? (character->ATK
    - target->DEF):0;`。
- en: 'This is a ternary operator. When a target is attacked, whether it is a party
    member or an enemy, the target''s HP will go down by the attacker''s attack power
    minus the target''s defense power only if this result ends up being the same or
    greater than 0\. If the result is less than 0, then HP will default to 0\. When
    you are done, `void TestCombatAction::BeginExecuteAction( UGameCharacter* character
    )` will look like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个三元运算符。当一个目标被攻击时，无论是团队成员还是敌人，只有当攻击者的攻击力减去目标防御力的结果等于或大于0时，目标的HP才会下降。如果结果是小于0，则HP默认为0。完成操作后，`void
    TestCombatAction::BeginExecuteAction( UGameCharacter* character )`将看起来像这样：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Setting up the abilities array
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置能力数组
- en: 'In [Chapter 3](ch03.html "Chapter 3. Exploration and Combat"), *Exploration
    and Combat*, we created a character class info for learned abilities, which was
    done in `FCharacterClassInfo.h`, which is an array used to hold an array of abilities
    for each character that inherits a class. We need to extend this array so that
    it is adopted by any game character to hold abilities that they learn throughout
    the game. To do this, open `GameCharacter.h` by navigating to **Source** | **RPG**.
    In `class RPG_API UGameCharacter : public UObject`, add a public `UPROPERTY` to
    learned abilities and allow it to be editable anywhere:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '在[第3章](ch03.html "第3章。探索和战斗")中，我们在`FCharacterClassInfo.h`中创建了一个用于学习能力的角色类信息，这是一个用于为继承类的每个角色存放能力数组的数组。我们需要扩展这个数组，使其被任何游戏角色采用，以存放他们在游戏中学习的能力。为此，通过导航到**源**
    | **RPG**打开`GameCharacter.h`。在`class RPG_API UGameCharacter : public UObject`中，向学习能力添加一个公共`UPROPERTY`，并允许它在任何地方进行编辑：'
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, open `GameCharacter.cpp` located in the same folder, and set `LearnedAbilities`
    to be equal to `LearnedAbilities` from the class info that we created the variable
    in:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开位于同一文件夹中的`GameCharacter.cpp`，并将`LearnedAbilities`设置为等于我们在类信息中创建的变量的`LearnedAbilities`：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This will allow each instance of a party member to hold its own `LearnedAbilities`
    array that we can now edit either in code or in Blueprint. Your game character
    will now look like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许每个团队成员实例都拥有自己的`LearnedAbilities`数组，我们可以现在在代码或蓝图中进行编辑。你的游戏角色现在看起来像这样：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Once done, compile and restart the editor. We can now create a spot in our game
    where we can hold and use abilities. In this game, we will choose to use abilities
    in battle only, but if you want to use abilities elsewhere, for example, outside
    battle, you can easily accomplish this by following similar steps. Since we will
    be applying abilities in battle, let's add a new abilities button to our combat
    interface. In the editor, navigate to **Content** | **Blueprints** | **UI**, and
    open the **CombatUI** Widget Blueprint.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，编译并重新启动编辑器。现在我们可以在游戏中创建一个位置来存放和使用能力。在这个游戏中，我们将选择只在战斗中使用能力，但如果你想在其他地方使用能力，例如，在战斗之外，你可以通过遵循类似的步骤轻松实现这一点。由于我们将在战斗中应用能力，让我们在战斗界面中添加一个新的能力按钮。在编辑器中，导航到**内容**
    | **蓝图** | **UI**，并打开**CombatUI** Widget 蓝图。
- en: 'In the **Designer** view, create a Combo Box that will allow us to have a drop-down
    menu with multiple entries, which we will use to hold and select our abilities,
    and place them in the **characterActions** Canvas Panel:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在**设计器**视图中，创建一个组合框，允许我们有一个具有多个条目的下拉菜单，我们将使用它来存放和选择我们的能力，并将它们放置在**characterActions**画布面板中：
- en: '![Setting up the abilities array](img/B04548_10_12.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![设置能力数组](img/B04548_10_12.jpg)'
- en: 'Resize the Combo Box to the same size as that of the **Attack** button, and
    place it in alignment with the **Attack** button:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 将组合框调整到与**攻击**按钮相同的大小，并将其放置在与**攻击**按钮对齐的位置：
- en: '![Setting up the abilities array](img/B04548_10_13.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![设置能力数组](img/B04548_10_13.jpg)'
- en: 'Lastly, rename the Combo Box to fit to the elements that will be contained
    in the Combo Box. We can name this **ComboBoxString_Abilities**, and check **Is
    Variable**:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将组合框重命名为适合其中包含的元素。我们可以将其命名为**ComboBoxString_Abilities**，并检查**是否为变量**：
- en: '![Setting up the abilities array](img/B04548_10_14.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![设置能力数组](img/B04548_10_14.jpg)'
- en: 'Now that we have a Combo Box that can hold abilities, it is now time to populate
    the Combo Box with appropriate abilities. Open the **CombatUI** Event Graph. Since
    we are concerned with having the correct abilities that are accessible during
    battle, it would be best to populate the Combo Box with abilities as soon as the
    **CombatUI** is created. To do this, create an **Event Construct** by navigating
    to **Add Event** | **User Interface**:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个可以存放能力的组合框，现在是时候用适当的能力填充组合框了。打开**CombatUI**事件图。由于我们关心在战斗期间可访问的正确能力，最好在**CombatUI**创建时立即填充组合框。为此，通过导航到**添加事件**
    | **用户界面**创建一个**事件构造**：
- en: '![Setting up the abilities array](img/B04548_10_15.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![设置能力数组](img/B04548_10_15.jpg)'
- en: 'Connect the **Event Construct** to **Cast To RPGGameInstance**, which will
    get all the party members, so that we can get and set the proper abilities:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 将**事件构造**连接到**Cast To RPGGameInstance**，这将获取所有团队成员，以便我们可以获取和设置适当的能力：
- en: '![Setting up the abilities array](img/B04548_10_16.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![设置能力数组](img/B04548_10_16.jpg)'
- en: 'What we can do here is set an ability for one of the party members (in this
    case, the soldier) by getting an index 0 of the **Party Members** Array. We will
    give the Soldier an ability called **Attack x2** if the Soldier has reached level
    2\. To do this, we will get the current level of the target using the **Lvl**
    variable and compare it with the integer 2 using the **CompareInt** macro:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这里为党派成员之一（在这种情况下，是士兵）设置一个能力，通过获取**Party Members**数组的索引0。如果士兵达到等级2，我们将给士兵一个名为**Attack
    x2**的能力。为此，我们将使用**Lvl**变量获取目标当前等级，并使用**CompareInt**宏将其与整数2进行比较：
- en: '![Setting up the abilities array](img/B04548_10_17.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![设置能力数组](img/B04548_10_17.jpg)'
- en: 'If the **Lvl** variable is more than or equal to 2, we can set the first element
    of the **LearnedAbilities** array to **Attack x2**:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果**Lvl**变量大于或等于2，我们可以将**LearnedAbilities**数组的第一个元素设置为**Attack x2**：
- en: '![Setting up the abilities array](img/B04548_10_18.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![设置能力数组](img/B04548_10_18.jpg)'
- en: 'After we have populated the array with the new **Attack x2** ability, we can
    now populate the Combo Box with every ability that we have by simply executing
    a **ForEachLoop** and cycling through every element of the array, and adding it
    to the Combo Box using the **Add Option** function by navigating to **Combo Box**
    | **Add Option**:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将新的**Attack x2**能力填充到数组中之后，现在我们可以通过简单地执行**ForEachLoop**遍历数组的每个元素，并使用**Add
    Option**函数将其添加到组合框中，通过导航到**组合框** | **添加选项**来填充组合框中的每个能力：
- en: '![Setting up the abilities array](img/B04548_10_19.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![设置能力数组](img/B04548_10_19.jpg)'
- en: This is a very simple way to add combat abilities to an abilities drop-down
    menu in accordance with party member levels. If you want to create more abilities,
    all you need to do is simply compare your level with another level using the **CompareInt**,
    and you can add more abilities to the **LearnedAbilities** array. If you end up
    having additional characters in the game, it is best to create a new Combo Box
    for each party member, get that party member from whichever index they are in
    the **Party Members** array, and then add abilities to their own **LearnedAbilities**
    array like we did with the Soldier.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种非常简单的方法，可以根据党派成员等级将战斗能力添加到能力下拉菜单中。如果你想创建更多能力，你只需要简单地使用**CompareInt**比较你的等级和另一个等级，然后你可以将更多能力添加到**LearnedAbilities**数组中。如果你最终在游戏中拥有额外的角色，最好为每个党派成员创建一个新的组合框，从他们在**Party
    Members**数组中的索引获取该党派成员，然后像我们对士兵所做的那样，将能力添加到他们自己的**LearnedAbilities**数组中。
- en: 'You should now be able to test this and see that when the player presses the
    Combo Box, **Attack x2** will appear if the Soldier party member hits level 2:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该能够测试这个功能，并看到当玩家按下组合框时，如果士兵党派成员达到等级2，**Attack x2**将会出现：
- en: '![Setting up the abilities array](img/B04548_10_20.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![设置能力数组](img/B04548_10_20.jpg)'
- en: Abilities logic
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 能力逻辑
- en: 'We can now create a logic for our **Attack x2** ability. As the name suggests,
    **Attack x2** should perform an attack that does double damage. Before we apply
    this sort of logic, we must first create an event that occurs after selecting
    the ability from the Combo Box and pressing it. Head back into the **Designer**
    view. In the **Details** tab, navigate to **Events**, and press **+** next to
    the **OnOpening** event:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以为我们 的**Attack x2**能力创建一个逻辑。正如其名所示，**Attack x2**应该执行造成双倍伤害的攻击。在我们应用这种逻辑之前，我们必须首先创建一个事件，该事件在从组合框中选择能力并按下它之后发生。返回到**Designer**视图。在**Details**选项卡中，导航到**Events**，然后按**OnOpening**事件旁边的**+**：
- en: '![Abilities logic](img/B04548_10_21.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![能力逻辑](img/B04548_10_21.jpg)'
- en: 'This will create an **OnOpening** event in your Event Graph. By selecting and
    clicking on the ability from the Combo Box, we need to first clear all the children
    from the **Panel** Widget using the **Clear Children** function, similar to what
    we did by clicking on the **Attack** button. This will prevent multiple buttons
    of the same target from popping up:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在你的事件图中创建一个**OnOpening**事件。通过从组合框中选择并点击能力，我们需要首先使用**Clear Children**函数清除**Panel**小部件的所有子项，类似于我们通过点击**Attack**按钮所做的那样。这将防止同一目标的多个按钮弹出：
- en: '![Abilities logic](img/B04548_10_22.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![能力逻辑](img/B04548_10_22.jpg)'
- en: 'Next, we will check whether the **Attack x2** ability has been opened by first
    calling the **Get Selected Option** function located under Combo Box (you will
    need to turn off **Context Sensitive** for this):'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将检查**Attack x2**能力是否已被打开，首先调用位于组合框下的**Get Selected Option**函数（你需要关闭**Context
    Sensitive**才能这样做）：
- en: '![Abilities logic](img/B04548_10_23.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![能力逻辑](img/B04548_10_23.jpg)'
- en: 'We set the **Target** of **Get Selected Option** to the **Get Combo Box String
    Abilities**:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将**Get Selected Option**的**目标**设置为**Get Combo Box String Abilities**：
- en: '![Abilities logic](img/B04548_10_24.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![能力逻辑](img/B04548_10_24.jpg)'
- en: 'Then, check whether the selected option is equal to **Attack x2**:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，检查所选选项是否等于**攻击 x2**：
- en: '![Abilities logic](img/B04548_10_25.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![能力逻辑](img/B04548_10_25.jpg)'
- en: 'If it is equal, this means that we have selected **Attack x2**, and we will
    then get the **RPGGameInstance**. However, we need to first check whether the
    party member has enough MP to use the ability. In this case, we will set the ability
    to use 10 MP, so let''s make sure that the party member has at least 10 MP before
    using the ability:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果相等，这意味着我们选择了**攻击 x2**，然后我们将获取**RPGGameInstance**。然而，我们需要首先检查党派成员是否有足够的MP来使用该能力。在这种情况下，我们将设置该能力使用10
    MP，所以让我们在使用能力之前确保党派成员至少有10 MP：
- en: '![Abilities logic](img/B04548_10_26.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![能力逻辑](img/B04548_10_26.jpg)'
- en: 'If the player has enough MP to use the ability, we will use a logic that allows
    the player to perform an attack that does double damage. Since the player will
    be doing double damage, this means that it will be easy to multiply the **ATK**
    variable of the player by two; however, we do not want the **ATK** variable to
    be doubled forever, only for this turn. To do this, it would be best to create
    a local variable that will temporarily hold the base **ATK** value so that on
    the next turn, we can reset the **ATK** value back to its normal value. We can
    easily do this by creating a local integer called **Temp Atk**, and set **Temp
    Atk** to the party member''s **ATK** value:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家有足够的MP来使用这个能力，我们将使用一种逻辑，允许玩家执行造成双倍伤害的攻击。由于玩家将造成双倍伤害，这意味着我们可以很容易地将玩家的**ATK**变量乘以二；然而，我们不想让**ATK**变量永远加倍，只在本回合加倍。为此，最好创建一个局部变量，暂时保存基础**ATK**值，这样在下个回合，我们可以将**ATK**值重置回正常值。我们可以通过创建一个名为**Temp
    Atk**的局部整数来轻松做到这一点，并将**Temp Atk**设置为党派成员的**ATK**值：
- en: '![Abilities logic](img/B04548_10_27.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![能力逻辑](img/B04548_10_27.jpg)'
- en: 'Next, we will set the **ATK** value of the party member to double its value
    by multiplying it by two, and set the **ATK** variable to the product of that
    operation:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将将党派成员的**ATK**值设置为原来的两倍，通过将其乘以二，并将**ATK**变量设置为该操作的结果：
- en: '![Abilities logic](img/B04548_10_28.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![能力逻辑](img/B04548_10_28.jpg)'
- en: 'We also need to set a Boolean to tell when we have used **Attack x2**. Because
    if we have used it, we need to subtract MP from the party member, and set our
    **ATK** variable back to normal. To do this, we need to create a local Boolean,
    which we will call `attackx2`. After we set the attack to be double, set `attackx2`
    to true, and allow the **CombatUI** to show all the available enemy targets by
    connecting **SET attackx2** to the **Get Character Targets** function:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要设置一个布尔值来告诉我们何时使用了**攻击 x2**。因为如果我们使用了它，我们需要从党派成员那里减去MP，并将我们的**ATK**变量恢复到正常状态。为此，我们需要创建一个局部布尔值，我们将称之为`attackx2`。在我们将攻击设置为双倍后，将`attackx2`设置为true，并通过将**SET
    attackx2**连接到**Get Character Targets**函数来允许**CombatUI**显示所有可用的敌方目标：
- en: '![Abilities logic](img/B04548_10_29.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![能力逻辑](img/B04548_10_29.jpg)'
- en: 'Once this is done, we can reset the `attackx2` Boolean to false, set the **ATK**
    variable back to its normal value, and remove 10 MP from the party member for
    using the ability. The best place to do this is after the **Event Show Actions
    Panel** occurs again, when the character actions become visible and the targets
    become invisible. After the targets become invisible, we will check whether the
    `attackx2` Boolean is true. If it is true, we will set it to false, and then set
    the **ATK** value equal to the **Temp Atk** value. Then, we subtract 10 from the
    party member''s MP variable:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，我们可以将`attackx2`布尔值重置为false，将**ATK**变量恢复到正常值，并从党派成员那里减去10 MP以使用该能力。最好的地方是在**Event
    Show Actions Panel**再次发生时进行，当角色动作变得可见且目标变得不可见时。在目标变得不可见后，我们将检查`attackx2`布尔值是否为true。如果是true，我们将将其设置为false，然后将**ATK**值设置为**Temp
    Atk**值。然后，我们从党派成员的MP变量中减去10：
- en: '![Abilities logic](img/B04548_10_30.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![能力逻辑](img/B04548_10_30.jpg)'
- en: Saving and loading game progress
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存和加载游戏进度
- en: The last thing that we will focus on is saving and loading game progress. Saving
    and loading can be done in many ways, but at its heart, saving the progress revolves
    around specific variables that you would like to save.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后要关注的是保存和加载游戏进度。保存和加载可以通过许多方式完成，但本质上，保存进度围绕着你想要保存的特定变量。
- en: Saving
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保存
- en: Most games save a lot of different variables, such as the level or area the
    player is in, the player's stats, the player's inventory, and gold. In our example,
    we will choose to save the player's gold, but using the method that we are about
    to perform, you can easily figure out how to save all the other progress in the
    game.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数游戏会保存很多不同的变量，例如玩家所在的关卡或区域、玩家的统计数据、玩家的库存和金币。在我们的例子中，我们将选择保存玩家的金币，但使用我们即将执行的方法，你可以轻松地找出如何保存游戏中的所有其他进度。
- en: 'To start with, create a new Blueprint class in **Content Browser** by navigating
    to **Content** | **Blueprints**. The **Pick Parent Class** window will pop up,
    and from **All Classes**, select **SaveGame**:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过导航到**Content** | **Blueprints**在**内容浏览器**中创建一个新的Blueprint类。**Pick Parent
    Class**窗口将弹出，从**All Classes**中选择**SaveGame**：
- en: '![Saving](img/B04548_10_31.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![保存](img/B04548_10_31.jpg)'
- en: 'Name this class **NewSaveGame**, and open the class. The purpose of this class
    is to hold the values of every variable that you would like to save. As mentioned
    earlier, for this example, we will be saving the gold variable, but if you would
    like to save more variables, the **NewSaveGame** class that you just created will
    store those variables as well. At this point, add a new variable to this class
    from the **Add New** variable in the **My Blueprint** tab. Name it **Gold**, and
    make its variable an **Integer** type:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个类命名为**NewSaveGame**，并打开这个类。这个类的目的是保存你想要保存的每个变量的值。如前所述，对于这个例子，我们将保存金币变量，但如果你想要保存更多的变量，你刚刚创建的**NewSaveGame**类也会存储这些变量。在这个时候，从**My
    Blueprint**选项卡中的**Add New**变量添加一个新的变量到这个类中。将其命名为**Gold**，并使其变量类型为**Integer**：
- en: '![Saving](img/B04548_10_32.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![保存](img/B04548_10_32.jpg)'
- en: 'Now that you are done, it is time to find a good spot for the game to be saved
    and the gold variable to be saved. Since we already have a pause menu and learned
    how to add buttons to the pause menu in the previous chapters, it would be easy
    to create a new button that we can call **Save** in the **Pause_Main** Widget
    Blueprint and add an **OnClicked** event to it:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经完成了，是时候找到一个合适的地点来保存游戏以及保存金变量了。由于我们已经在之前的章节中有了暂停菜单，并且学习了如何向暂停菜单中添加按钮，因此创建一个名为**保存**的新按钮在**Pause_Main**
    Widget Blueprint中并将一个**OnClicked**事件添加到它上面将会很容易：
- en: '![Saving](img/B04548_10_33.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![保存](img/B04548_10_33.jpg)'
- en: 'Once you click on **+** next to the **OnClicked** event, the Event Graph will
    open up, and you will see the **OnClicked** event for your **Save** button. Here,
    allow the button, when pressed, to create a save game object. To do this, create
    **Create Save Game Object** whose **Save Game Class** is set to **New Save Game**,
    and allow it to start when you click on the button:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你点击**OnClicked**事件旁边的**+**，事件图将打开，你将看到你的**Save**按钮的**OnClicked**事件。在这里，允许按钮在被按下时创建一个保存游戏对象。为此，创建一个**Create
    Save Game Object**，其**Save Game Class**设置为**New Save Game**，并允许它在点击按钮时启动：
- en: '![Saving](img/B04548_10_34.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![保存](img/B04548_10_34.jpg)'
- en: 'Here, we will need to create a new variable of the **Save Game** type, and
    we will call this variable **save**:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要创建一个新的**Save Game**类型的变量，我们将称这个变量为**save**：
- en: '![Saving](img/B04548_10_35.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![保存](img/B04548_10_35.jpg)'
- en: 'Here, we will create a **SET Save** variable in our Blueprint, and pass the
    **Return Value** of the **Create Save Game Object** function to **SET Save**:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将在我们的Blueprint中创建一个**SET Save**变量，并将**Create Save Game Object**函数的**Return
    Value**传递给**SET Save**：
- en: '![Saving](img/B04548_10_36.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![保存](img/B04548_10_36.jpg)'
- en: 'We will now need to cast the **NewSaveGame** class so that we can set the **Gold**
    variable that we created to the game''s gold. To do this, cast **SET Save** to
    **NewSaveGame** by connecting the **Save** value to the **Object** of **Cast To
    NewSaveGame**:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要将**NewSaveGame**类进行转换，以便我们可以将我们创建的**Gold**变量设置到游戏的金上。为此，通过将**Save**值连接到**Cast
    To NewSaveGame**的**Object**来将**SET Save**转换为**NewSaveGame**：
- en: '![Saving](img/B04548_10_37.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![保存](img/B04548_10_37.jpg)'
- en: 'Next, allow **Cast To NewSaveGame** to fire off a **Cast To RPGInstance** whose
    **Object** is a reference to **Get Game Instance**. We are doing this so that
    we can get an instance of the **GameGold**, so link the **As RPGGame Instance**
    pin from **Cast To RPGGameInstance** to the **Get GameGold** variable from the
    RPG instance:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，允许**Cast To NewSaveGame**触发一个**Cast To RPGInstance**，其**Object**是对**Get
    Game Instance**的引用。我们这样做是为了获取**GameGold**的实例，因此将**Cast To RPGGameInstance**的**As
    RPGGame Instance**引脚链接到RPG实例中的**Get GameGold**变量：
- en: '![Saving](img/B04548_10_38.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![保存](img/B04548_10_38.jpg)'
- en: 'Now that we are getting the game gold, we can set the game gold''s value to
    the **Gold** variable from the **NewSaveGame** class by linking the **SET Gold**
    to fire off when the **RPGGameInstance** is cast, and then linking the **GameGold**
    value pin to the **Gold** value pin and the **Target** pin of **SET Gold** to
    the **As New Save Game** pin from **Cast To NewSaveGame**:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经获取了游戏金币，我们可以通过将**SET Gold**连接到当**RPGGameInstance**被转换时触发，并将**GameGold**值引脚连接到**Gold**值引脚，以及将**SET
    Gold**的**目标**引脚连接到**Cast To NewSaveGame**的**As New Save Game**引脚，将游戏金币的值设置为**NewSaveGame**类中的**Gold**变量：
- en: '![Saving](img/B04548_10_39.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![Saving](img/B04548_10_39.jpg)'
- en: This particular method will allow us to save whatever the current game gold
    is to our **Gold** variable in the **NewSaveGame** class. Note that if you want
    to save more variables, set the values of those variables just like you set the
    value of the **Gold** variable by adding a **SET** node for each individual variable
    that you have.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这种特定方法将允许我们将当前游戏金币的任何值保存到**NewSaveGame**类中的**Gold**变量。请注意，如果您想保存更多变量，就像设置**Gold**变量的值一样设置这些变量的值，为每个单独的变量添加一个**SET**节点。
- en: 'The last thing we will need to do is create a save game slot, which will hold
    our save game object. To do this, create a **Save Game to Slot** action, which
    you will find under **Game** in your **Actions** window:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后需要做的是创建一个存档游戏槽位，它将保存我们的存档游戏对象。为此，创建一个**存档游戏到槽位**动作，你可以在你的**动作**窗口中的**游戏**下找到它：
- en: '![Saving](img/B04548_10_40.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![Saving](img/B04548_10_40.jpg)'
- en: 'Create a slot name for this; in this example, we will use **A** as **Slot Name**.
    Link the **Save Game Object** pin of **Save Game to Slot** to the **Save** value
    pin, and allow the **Save Game to Slot** to fire when the **Gold** variable is
    set:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为此创建一个槽位名称；在这个例子中，我们将使用**A**作为**槽位名称**。将**Save Game to Slot**的**Save Game Object**引脚连接到**Save**值引脚，并允许当**Gold**变量被设置时**Save
    Game to Slot**触发：
- en: '![Saving](img/B04548_10_41.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![Saving](img/B04548_10_41.jpg)'
- en: We are now done with the saving part of the game. We will now move on to loading
    a game slot.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了游戏的存档部分。我们现在将转到加载游戏槽位。
- en: Loading
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载
- en: Just like saving, loading can be done in a number of ways. In our game, we will
    simply load the player's save data on launching the game. To do this, open the
    **FieldPlayer** Blueprint since we know that the FieldPlayer will always exist
    in our game.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 就像保存一样，加载也可以以多种方式完成。在我们的游戏中，我们将在游戏启动时简单地加载玩家的存档数据。为此，打开**FieldPlayer**蓝图，因为我们知道FieldPlayer将始终存在于我们的游戏中。
- en: 'Next, we will create a **Load** variable of the **Save Game** type similar
    to what we did when we saved the game, so that we can properly cast the variables
    and their values from **NewSaveGame**:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个与保存游戏时类似的**Load**变量，这样我们就可以正确地转换变量及其值从**NewSaveGame**：
- en: '![Loading](img/B04548_10_42.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![Loading](img/B04548_10_42.jpg)'
- en: 'Here, we will create an **Event Begin Play**, and from **Event Begin Play**,
    we will call the **Does Save Game Exist** function from the **Game** category
    in the **Actions** window, and under **Slot Name**, we will look for **A** since
    we named our save slot **A** in the previous section:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将创建一个**事件开始播放**，并且从**事件开始播放**，我们将调用**动作**窗口中**游戏**类别下的**Does Save Game
    Exist**函数，并且在**槽位名称**下，我们将寻找**A**，因为我们之前将我们的存档槽位命名为**A**：
- en: '![Loading](img/B04548_10_43.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![Loading](img/B04548_10_43.jpg)'
- en: 'From **Does Save Game Exist**, we will call a branch; if **Does Save Game Exist**
    is true, we will call **Load Game from Slot** and its **Slot Name** will also
    be **A**:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 从**存档游戏是否存在**，我们将调用一个分支；如果**存档游戏是否存在**为真，我们将调用**从槽位加载游戏**，并且它的**槽位名称**也将是**A**：
- en: '![Loading](img/B04548_10_44.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![Loading](img/B04548_10_44.jpg)'
- en: At this point, we have created a logic where, when the game starts, we check
    whether the saved game in slot A exists. If it does exist, we load the game from
    slot A; if it does not exist, we do nothing.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们已经创建了一个逻辑，当游戏开始时，我们检查槽位A中的存档游戏是否存在。如果它存在，我们就从槽位A加载游戏；如果它不存在，我们就不做任何事情。
- en: 'We can now set the **Load** variable that we created in the beginning of this
    section whose data type is **Save Game** to the **Return Value** of **Load Game
    from Slot** and cast it to **NewSaveGame** similar to what we did with our save
    game data:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将我们在本节开头创建的**Load**变量设置为**Save Game**类型的数据，类似于我们保存游戏时所做的，这样我们就可以正确地将变量及其值从**NewSaveGame**转换过来：
- en: '![Loading](img/B04548_10_45.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![Loading](img/B04548_10_45.jpg)'
- en: 'Note that since we now have access to all the variables in **NewSaveGame**,
    it means that we have access to the gold value that we saved. So from here, we
    get the gold value from **Cast To NewSaveGame** so that you have whatever value
    was stored in **Gold** since the player last saved, and you will need to set the
    **GameGold** value from **RPGGameInstance** to **Gold** from **NewSaveGame**:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于我们现在可以访问**NewSaveGame**中的所有变量，这意味着我们可以访问我们保存的金币值。所以从这里，我们从**Cast To NewSaveGame**获取金币值，这样你就有玩家上次保存时存储的任何值，并且你需要将**RPGGameInstance**中的**GameGold**值设置为**NewSaveGame**中的**Gold**：
- en: '![Loading](img/B04548_10_46.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![加载](img/B04548_10_46.jpg)'
- en: Just like when we created the saving logic, in this loading logic, if there
    are any other variables you need to load, you can easily do so by getting more
    variables from the **NewSaveGame** class and setting it to other variables from
    the **RPG Game Instance**.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在创建保存逻辑时一样，在这个加载逻辑中，如果你需要加载其他任何变量，你可以很容易地通过从**NewSaveGame**类获取更多变量并将其设置到**RPG
    Game Instance**中的其他变量来实现。
- en: You can now test this by simply playing the game, doing battle to get the game
    gold, saving the game with the **Save** button that we created in the pause menu,
    and then closing the game. When you reopen the game, you will notice that the
    gold you had when you saved the game is automatically loaded when you start the
    game. Using this framework, feel free to save other game variables such as your
    status and inventory
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以通过简单地玩游戏来测试这个功能，进行战斗以获得游戏金币，使用我们在暂停菜单中创建的**保存**按钮保存游戏，然后关闭游戏。当你重新打开游戏时，你会注意到你在保存游戏时拥有的金币会自动加载。使用这个框架，你可以自由地保存其他游戏变量，比如你的状态和库存。
- en: Summary
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We now have a solution to allow party members to earn experience, gain levels
    with enough experience gained, and earn abilities through hitting specific levels.
    We have also fixed the combat system to allow party members and enemies to do
    damage based on their stats, as well as allow party members to use abilities in
    battle. Additionally, you now have the ability to save and load player progress
    throughout the game. Using the framework covered in this chapter, every party
    member can level up, and you can easily add more abilities to various party members,
    use them in battle, and players can save their game at any time and then come
    back to continue from where they left off.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个解决方案，可以让队伍成员通过获得足够的经验来获得等级，并通过达到特定等级来获得能力。我们还修复了战斗系统，以便让队伍成员和敌人根据他们的统计数据造成伤害，并允许队伍成员在战斗中使用能力。此外，你现在可以在整个游戏过程中保存和加载玩家进度。使用本章中介绍的框架，每个队伍成员都可以升级，你可以轻松地为不同的队伍成员添加更多能力，在战斗中使用它们，并且玩家可以在任何时候保存游戏，然后回来继续他们离开的地方。
- en: At this juncture, you have successfully completed a working framework for a
    turn-based RPG. You have core gameplay working with the ability to allow a party
    of characters to explore a world in isometric 3D. You can battle enemies with
    new-found abilities and equipment and interact with NPCs by conversing with them
    and buying items and equipment with gold you earned from defeating enemies. And
    just like most other RPGs, you can level up through gaining experience, as well
    as save game status so players can come back to continue their games at a later
    date.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经成功完成了一个回合制RPG的工作框架。你有一个核心游戏玩法，可以允许一个角色队伍以等距3D的方式探索世界。你可以使用新获得的能力和装备与敌人战斗，通过与NPC交谈和用击败敌人获得的金币购买物品和装备来与他们互动。就像大多数其他RPG一样，你可以通过获得经验来升级，以及保存游戏状态，这样玩家就可以在以后的时间回来继续他们的游戏。
- en: Your quest is not over yet though! Now that you know the basics, venture off
    to add more content to your game, like additional enemies, party members, NPCs
    and equipment. Through this process, create levels of your own using the framework
    and content you have created for yourself through following this book.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你的探索之旅还没有结束！现在你已经掌握了基础知识，就可以开始为你的游戏添加更多内容了，比如额外的敌人、队伍成员、NPC 和装备。通过这个过程，你可以使用本书中创建的框架和内容来创建自己的关卡。
