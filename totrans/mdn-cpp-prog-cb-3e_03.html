<html><head></head><body>
<div><h1 class="chapterNumber">3</h1>
<h1 class="chapterTitle" id="_idParaDest-174">Exploring Functions</h1>
<p class="normal">Functions<a id="_idIndexMarker348"/> are a fundamental concept in programming; regardless of what topic we are discussing, we will end up talking about functions. Trying to cover everything about functions in a single chapter is not only hard but also not very rational. Being a fundamental element of the language, functions are encountered in every recipe in this book. This chapter, however, covers modern language features related to functions and callable objects, with a focus on lambda expressions, concepts from functional languages such as higher-order functions, and function templates.</p>
<p class="normal">The recipes included in this chapter are as follows:</p>
<ul>
<li class="bulletList">Defaulted and deleted functions</li>
<li class="bulletList">Using lambdas with standard algorithms</li>
<li class="bulletList">Using generic and template lambdas</li>
<li class="bulletList">Writing a recursive lambda</li>
<li class="bulletList">Writing function templates</li>
<li class="bulletList">Writing a function template with a variable number of arguments</li>
<li class="bulletList">Using fold expressions to simplify variadic function templates</li>
<li class="bulletList">Implementing the higher-order functions <code class="inlineCode">map</code> and <code class="inlineCode">fold</code></li>
<li class="bulletList">Composing functions into a higher-order function</li>
<li class="bulletList">Uniformly invoking anything callable</li>
</ul>
<p class="normal">We will start this chapter by learning about a feature that makes it easier for us to provide special class member functions or prevent any function (member or non-member) from being invoked.</p>
<h1 class="heading-1" id="_idParaDest-175">Defaulted and deleted functions</h1>
<p class="normal">In C++, classes have special members (constructors, a destructor, and assignment operators) that may be either implemented by default by the compiler or supplied by the developer. However, the rules for what can be default implemented are a bit complicated and can lead to problems. On the other hand, developers sometimes want to prevent objects from being copied, moved, or constructed in a particular way. </p>
<p class="normal">This is possible by implementing different tricks using these special members. The C++11 standard has simplified many of these by allowing functions to be deleted or defaulted in the manner we will see in the next section.</p>
<h2 class="heading-2" id="_idParaDest-176">Getting started</h2>
<p class="normal">For this recipe, you need to be familiar with the following concepts:</p>
<ul>
<li class="bulletList">Special <a id="_idIndexMarker349"/>member functions (default constructor, destructor, copy constructor, move constructor, copy assignment operator, and move assignment operator)</li>
<li class="bulletList">The copyable<a id="_idIndexMarker350"/> concept (a class features a copy constructor and copy assignment operator, making it possible to create copies)</li>
<li class="bulletList">The movable<a id="_idIndexMarker351"/> concept (a class features a move constructor and a move assignment operator, making it possible to move objects)</li>
</ul>
<p class="normal">With this in mind, let’s learn how to define default and deleted special functions.</p>
<h2 class="heading-2" id="_idParaDest-177">How to do it...</h2>
<p class="normal">Use the following syntax to specify how functions should be handled:</p>
<ul>
<li class="bulletList">To default a<a id="_idIndexMarker352"/> function, use <code class="inlineCode">=default</code> instead of the function body. Only special class member functions for which the compiler can provide default implementations can be defaulted:
        <pre class="programlisting code"><code class="hljs-code">struct foo
{
  foo() = default;
};
</code></pre>
</li>
<li class="bulletList">To delete a <a id="_idIndexMarker353"/>function, use <code class="inlineCode">=delete</code> instead of the function body. Any function, including non-member functions, can be deleted:
        <pre class="programlisting code"><code class="hljs-code">struct foo
{
  foo(foo const &amp;) = delete;
};
void func(int) = delete;
</code></pre>
</li>
</ul>
<p class="normal">Use defaulted and<a id="_idIndexMarker354"/> deleted <a id="_idIndexMarker355"/>functions to achieve various design goals, such as the following examples:</p>
<ul>
<li class="bulletList">To implement a class that is not copyable and implicitly not movable, declare the copy constructor and the copy assignment operator as deleted:
        <pre class="programlisting code"><code class="hljs-code">class foo_not_copyable
{
public:
  foo_not_copyable() = default;
  foo_not_copyable(foo_not_copyable const &amp;) = delete;
  foo_not_copyable&amp; operator=(foo_not_copyable const&amp;) = delete;
};
</code></pre>
</li>
<li class="bulletList">To implement a class that is not copyable but is movable, declare the copy operations as deleted and explicitly implement the move operations (and provide any additional constructors that are needed):
        <pre class="programlisting code"><code class="hljs-code">class data_wrapper
{
  Data* data;
public:
  data_wrapper(Data* d = nullptr) : data(d) {}
  ~data_wrapper() { delete data; }
  data_wrapper(data_wrapper const&amp;) = delete;
  data_wrapper&amp; operator=(data_wrapper const &amp;) = delete;
  data_wrapper(data_wrapper&amp;&amp; other)  
 :data(std::move(other.data))
  {
    other.data = nullptr;
  }
  data_wrapper&amp; operator=(data_wrapper&amp;&amp; other)
  {
    if (data != other.data))
    {
      delete data;
      data = std::move(other.data);
      other.data = nullptr;
    }
    return *this;
  }
};
</code></pre>
</li>
<li class="bulletList">To ensure a function is called only with objects of a specific type, and perhaps prevent type promotion, provide deleted overloads for the function (the following example with free functions can also be applied to any class member functions):
        <pre class="programlisting code"><code class="hljs-code">template &lt;typename T&gt;
void run(T val) = delete;
void run(long val) {} // can only be called with long integers
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-178">How it works...</h2>
<p class="normal">A<a id="_idIndexMarker356"/> class has several <a id="_idIndexMarker357"/>special members that can be implemented, by default, by the compiler. These are the default constructor, copy constructor, move constructor, copy assignment, move assignment, and destructor (for a discussion on move semantics, refer to the <em class="italic">Implementing move semantics</em> recipe in <em class="chapterRef">Chapter 9</em>, <em class="italic">Robustness and Performance</em>). If you don’t implement them, then the compiler does it so that, if needed, instances of a class can be created, moved, copied, and destructed. However, if you explicitly provide one or more of these special methods, then the compiler will not generate the others according to the following rules:</p>
<ul>
<li class="bulletList">If a user-defined constructor exists, the default constructor is not generated by default.</li>
<li class="bulletList">If a user-defined virtual destructor exists, the default destructor is not generated.</li>
<li class="bulletList">If a user-defined move constructor or move assignment operator exists, then the copy constructor and copy assignment operator are not generated by default.</li>
<li class="bulletList">If a user-defined copy constructor, move constructor, copy assignment operator, move assignment operator, or destructor exists, then the move constructor and move assignment operator are not generated by default.</li>
<li class="bulletList">If a user-defined copy constructor or destructor exists, then the copy assignment operator is generated by default.</li>
<li class="bulletList">If a user-defined copy assignment operator or destructor exists, then the copy constructor is generated by default.</li>
</ul>
<div><p class="normal">Note that the last two rules in the preceding list are deprecated rules and may no longer be supported by your compiler.</p>
</div>
<p class="normal">Sometimes, developers need to provide empty implementations of these special members or hide them in order to prevent the instances of the class from being constructed in a specific manner. A typical example is a class that is not supposed to be copyable. The classical pattern for this is to provide a default constructor and hide the copy constructor and copy assignment operators. While this works, the explicitly defined default<a id="_idIndexMarker358"/> constructor ensures the class is no longer considered trivial and, therefore, a <strong class="keyWord">Plain Old Data</strong> (<strong class="keyWord">POD</strong>) type. The modern alternative to this is using a deleted function, as shown in the preceding section.</p>
<p class="normal">When the <a id="_idIndexMarker359"/>compiler <a id="_idIndexMarker360"/>encounters <code class="inlineCode">=default</code> in the definition of a function, it will provide the default implementation. The rules for special member functions mentioned earlier still apply. Functions can be declared <code class="inlineCode">=default</code> outside the body of a class if and only if they are inlined:</p>
<pre class="programlisting code"><code class="hljs-code">class foo
{
public:
  foo() = default;
  inline foo&amp; operator=(foo const &amp;);
};
inline foo&amp; foo::operator=(foo const &amp;) = default;
</code></pre>
<p class="normal">The defaulted implementations have several benefits, including the following:</p>
<ul>
<li class="bulletList">Can be more efficient than the explicit ones.</li>
<li class="bulletList">Non-defaulted implementations, even if they are empty, are considered non-trivial, and that affects the semantics of the type, which becomes non-trivial (and, therefore, non-POD).</li>
<li class="bulletList">Helps the user not write explicit default implementations. For instance, if a user-defined move constructor is present, then the copy constructor and the copy assignment operator are not provided by default by the compiler. However, you can still default explicitly and ask the compiler to provide them so that you don’t have to do it manually.</li>
</ul>
<p class="normal">When the <a id="_idIndexMarker361"/>compiler encounters <code class="inlineCode">=delete</code> in the definition of a function, it will prevent the calling of the<a id="_idIndexMarker362"/> function. However, the function is still considered during overload resolution, and only if the deleted function is the best match does the compiler generate an error. For example, by giving the previously defined overloads for the <code class="inlineCode">run()</code> function, only calls with long integers are possible. Calls with arguments of any other type (including <code class="inlineCode">int</code>, for which an automatic type promotion to <code class="inlineCode">long</code> exists) will determine a deleted overload to be considered the best match and, therefore, the compiler will generate an error:</p>
<pre class="programlisting code"><code class="hljs-code">run(42);  // error, matches a deleted overload
run(42L); // OK, long integer arguments are allowed
</code></pre>
<p class="normal">Note that previously declared functions cannot be deleted as the <code class="inlineCode">=delete</code> definition must be the first declaration in a translation unit:</p>
<pre class="programlisting code"><code class="hljs-code">void forward_declared_function();
// ...
void forward_declared_function() = delete; // error
</code></pre>
<p class="normal">The rule of thumb (also known as the<em class="italic"> Rule of Five</em>) for<a id="_idIndexMarker363"/> class special member functions is that if you explicitly define any copy constructor, move constructor, copy assignment operator, move assignment operator, or destructor, then you must either explicitly define or default all of them.</p>
<p class="normal">The user-defined destructor, copy-constructor, and copy assignment operator are necessary because objects are constructed from copies in various situations (like passing parameters to functions). If they are not user-defined, they are provided by the compiler, but their default implementation may be wrong. If the class manages resources, then the default implementation does a shallow copy, meaning that it copies the value of the handle of the resource (such as a pointer to an object) and not the resource itself. In such cases, a user-defined implementation must do a deep copy that copies the resource, not the handle to it. The presence of the move constructor and move assignment operator are desirable in this case because they represent a performance improvement. Lacking these two is not an error but a missed optimization opportunity.</p>
<p class="normal">Opposed to the <a id="_idIndexMarker364"/>Rule of Five on the one hand but complementing it on the other is the <a id="_idIndexMarker365"/>so-called <em class="italic">Rule of Zero</em>. This rule states that unless a class deals with ownership of resources, it should have no custom destructors, copy and move constructors, and, respectively, copy and move assignment operators.</p>
<p class="normal">When designing classes, you should follow these guidelines:</p>
<ul>
<li class="bulletList">A class that <a id="_idIndexMarker366"/>manages a resource should have the single responsibility of handling the ownership of that resource. Such a class must follow the Rule of Five and implement a custom destructor, copy/move constructors, and copy/move assignment operators.</li>
<li class="bulletList">A class that doesn’t manage resources should not have a custom destructor, copy/move constructors, and copy/move assignment operators (therefore following the Rule of Zero).</li>
</ul>
<h2 class="heading-2" id="_idParaDest-179">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Uniformly invoking anything callable</em>, to learn how to use <code class="inlineCode">std::invoke()</code> to invoke any callable object with the provided arguments</li>
</ul>
<h1 class="heading-1" id="_idParaDest-180">Using lambdas with standard algorithms</h1>
<p class="normal">One of the most important modern features of C++ is lambda expressions, also referred to as lambda functions or simply lambdas. Lambda expressions enable us to define anonymous function objects that can capture variables in the scope and be invoked or passed as arguments to functions. They avoid having to define named functions or function objects. Lambdas are<a id="_idIndexMarker367"/> useful for many purposes, and in this recipe, we will learn how to use them with standard algorithms.</p>
<h2 class="heading-2" id="_idParaDest-181">Getting ready</h2>
<p class="normal">In this recipe, we’ll discuss standard algorithms<a id="_idIndexMarker368"/> that take an argument that’s a function or predicate that’s applied to the elements it iterates through. You need to know what unary and binary functions are and what predicates and comparison functions are. You also need to be familiar with function objects because lambda expressions are syntactic sugar for function objects.</p>
<h2 class="heading-2" id="_idParaDest-182">How to do it...</h2>
<p class="normal">You <a id="_idIndexMarker369"/>should prefer to use lambda expressions to <a id="_idIndexMarker370"/>pass callbacks to standard algorithms instead of functions or function objects:</p>
<ul>
<li class="bulletList">Define anonymous lambda expressions in the place of the call if you only need to use the lambda in a single place:
        <pre class="programlisting code"><code class="hljs-code">auto numbers =
  std::vector&lt;int&gt;{ 0, 2, -3, 5, -1, 6, 8, -4, 9 };
auto positives = std::count_if(
  std::begin(numbers), std::end(numbers),
  [](int const n) {return n &gt; 0; });
</code></pre>
</li>
<li class="bulletList">Define a named lambda, that is, one assigned to a variable (usually with the <code class="inlineCode">auto</code> specifier for the type), if you need to call the lambda in multiple places:
        <pre class="programlisting code"><code class="hljs-code">auto ispositive = [](int const n) {return n &gt; 0; };
auto positives = std::count_if(
  std::begin(numbers), std::end(numbers), ispositive);
</code></pre>
</li>
<li class="bulletList">Use generic lambda expressions if you need lambdas that only differ in terms of their argument types (available since C++14):
        <pre class="programlisting code"><code class="hljs-code">auto positives = std::count_if(
  std::begin(numbers), std::end(numbers),
  [](auto const n) {return n &gt; 0; });
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-183">How it works...</h2>
<p class="normal">The non-generic lambda expression shown in the second bullet takes a constant integer and returns <code class="inlineCode">true</code> if it is greater than <code class="inlineCode">0</code>, or <code class="inlineCode">false</code> otherwise. The compiler defines an unnamed function object with the call operator, which has the signature of the lambda expression:</p>
<pre class="programlisting code"><code class="hljs-code">struct __lambda_name__
{
  bool operator()(int const n) const { return n &gt; 0; }
};
</code></pre>
<p class="normal">The way the unnamed function object is defined by the compiler depends on the way we define the lambda expression that can capture variables, use the <code class="inlineCode">mutable</code> specifier or exception specifications, or have a trailing return type. The <code class="inlineCode">__lambda_name__</code> function object shown earlier is actually a simplification of what the compiler generates because it also defines a default copy and move constructor, a default destructor, and a deleted assignment operator.</p>
<div><p class="normal">It must be well understood that the lambda expression is actually a class. In order to call it, the compiler needs to instantiate an object of the class. The object instantiated from a lambda expression is <a id="_idIndexMarker371"/>called a <em class="italic">lambda closure</em>.</p>
</div>
<p class="normal">In the following example, we want to count the number of elements in a range that are greater than or equal to 5 and less than or equal to 10. The lambda expression, in this case, will look like this:</p>
<pre class="programlisting code"><code class="hljs-code">auto numbers = std::vector&lt;int&gt;{ 0, 2, -3, 5, -1, 6, 8, -4, 9 };
auto minimum { 5 };
auto maximum { 10 };
auto inrange = std::count_if(
    std::begin(numbers), std::end(numbers),
    [minimum, maximum](int const n) {
      return minimum &lt;= n &amp;&amp; n &lt;= maximum;});
</code></pre>
<p class="normal">This <a id="_idIndexMarker372"/>lambda captures two variables, <code class="inlineCode">minimum</code> and <code class="inlineCode">maximum</code>, by copy (that is, value). The resulting unnamed function object created by <a id="_idIndexMarker373"/>the compiler looks very much like the one we defined earlier. With the default and deleted special members mentioned earlier, the class looks like this:</p>
<pre class="programlisting code"><code class="hljs-code">class __lambda_name_2__
{
  int minimum_;
  int maximum_;
public:
  explicit __lambda_name_2__(int const minimum, int const maximum) :
    minimum_( minimum), maximum_( maximum)
  {}
  __lambda_name_2__(const __lambda_name_2__&amp;) = default;
  __lambda_name_2__(__lambda_name_2__&amp;&amp;) = default;
  __lambda_name_2__&amp; operator=(const __lambda_name_2__&amp;)
    = delete;
  ~__lambda_name_2__() = default;
  bool operator() (int const n) const
 {
    return minimum_ &lt;= n &amp;&amp; n &lt;= maximum_;
  }
};
</code></pre>
<p class="normal">The <a id="_idIndexMarker374"/>lambda expression can capture variables <a id="_idIndexMarker375"/>by copy (or value) or by reference, and different combinations of the two are possible. However, it is not possible to capture a variable multiple times and it is only possible to have <code class="inlineCode">&amp;</code> or <code class="inlineCode">=</code> at the beginning of the capture list.</p>
<div><p class="normal">A lambda expression can access the following kinds of variables: variables captured from the enclosing scope, lambda parameters, variables declared locally within its body, class data members when the lambda is declared inside a class and the pointer is captured by the lambda, and any variable with static storage duration such as global variables.</p>
<p class="normal">A lambda can only capture variables from an enclosing function scope. It cannot capture variables with static storage duration (that is, variables declared in a namespace scope or with the <code class="inlineCode">static</code> or <code class="inlineCode">external</code> specifier).</p>
</div>
<p class="normal">The following table shows various combinations for lambda capture semantics:</p>
<table class="table-container" id="table001-2">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Lambda</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Description</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">[](){}</code></p>
</td>
<td class="table-cell">
<p class="normal">Does not capture anything.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">[&amp;](){}</code></p>
</td>
<td class="table-cell">
<p class="normal">Captures everything by reference.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">[=](){}</code></p>
</td>
<td class="table-cell">
<p class="normal">Captures everything by copy. Implicit capturing of the pointer <code class="inlineCode">this</code> is deprecated in C++20.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">[&amp;x](){}</code></p>
</td>
<td class="table-cell">
<p class="normal">Captures only <code class="inlineCode">x</code> by reference.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">[x](){}</code></p>
</td>
<td class="table-cell">
<p class="normal">Captures only <code class="inlineCode">x</code> by copy.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">[&amp;x...](){}</code></p>
</td>
<td class="table-cell">
<p class="normal">Captures pack extension <code class="inlineCode">x</code> by reference.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">[x...](){}</code></p>
</td>
<td class="table-cell">
<p class="normal">Captures pack extension <code class="inlineCode">x</code> by copy.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">[&amp;, x](){}</code></p>
</td>
<td class="table-cell">
<p class="normal">Captures everything by reference except for <code class="inlineCode">x</code> that is captured by copy.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">[=, &amp;x](){}</code></p>
</td>
<td class="table-cell">
<p class="normal">Captures everything by copy except for <code class="inlineCode">x</code> that is captured by reference.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">[&amp;, this](){}</code></p>
</td>
<td class="table-cell">
<p class="normal">Captures everything by reference except for the pointer <code class="inlineCode">this</code>, which is captured by copy (<code class="inlineCode">this</code> is always captured by copy).</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">[x, x](){}</code></p>
</td>
<td class="table-cell">
<p class="normal">Error; <code class="inlineCode">x</code> is captured twice.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">[&amp;, &amp;x](){}</code></p>
</td>
<td class="table-cell">
<p class="normal">Error; everything is captured by reference, and we cannot specify again to capture <code class="inlineCode">x</code> by reference.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">[=, =x](){}</code></p>
</td>
<td class="table-cell">
<p class="normal">Error; everything is captured by copy, and we cannot specify again to capture <code class="inlineCode">x</code> by copy.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">[&amp;this](){}</code></p>
</td>
<td class="table-cell">
<p class="normal">Error; the pointer <code class="inlineCode">this</code> is always captured by copy.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">[&amp;, =](){}</code></p>
</td>
<td class="table-cell">
<p class="normal">Error; cannot capture everything both by copy and by reference.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">[x=expr](){}</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">x</code> is a data member of the lambda’s closure initialized from the expression <code class="inlineCode">expr</code>.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">[&amp;x=expr](){}</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">x</code> is a reference data member of the lambda’s closure initialized from the expression <code class="inlineCode">expr</code>.</p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 3.1: Examples of lambda captures with explanations</p>
<p class="normal">The general form of a lambda expression, as of C++17, looks like this:</p>
<pre class="programlisting code"><code class="hljs-code">[capture-list](params) mutable constexpr exception attr -&gt; ret
{ body }
</code></pre>
<p class="normal">All parts <a id="_idIndexMarker376"/>shown in this syntax are actually<a id="_idIndexMarker377"/> optional except for the capture list, which can, however, be empty, and the body, which can also be empty. The parameter list can actually be omitted if no parameters are needed. The return type does not need to be specified as the compiler can infer it from the type of the returned expression. The <code class="inlineCode">mutable</code> specifier (which tells the compiler the lambda can actually modify variables captured by copy, which is not the same as capturing by value because the changes are only observed within the lambda), the <code class="inlineCode">constexpr</code> specifier (which tells the compiler to generate a <code class="inlineCode">constexpr</code> call operator), and the exception specifiers and attributes are all optional.</p>
<div><p class="normal">The simplest possible lambda expression is <code class="inlineCode">[]{}</code>, though it is often written as <code class="inlineCode">[](){}</code>.</p>
</div>
<p class="normal">The latter two examples in the preceding table are forms of generalized lambda captures. These were introduced in C++14 to allow us to capture variables with move-only semantics, but they can also be used to define new arbitrary objects in the lambda. The following example shows how variables can be captured by <code class="inlineCode">move</code> with generalized lambda captures:</p>
<pre class="programlisting code"><code class="hljs-code">auto ptr = std::make_unique&lt;int&gt;(42);
auto l = [lptr = std::move(ptr)](){return ++*lptr;};
</code></pre>
<p class="normal">Lambdas that are written in class methods and need to capture class data members can do so in several ways:</p>
<ul>
<li class="bulletList">Capturing individual data members with the form <code class="inlineCode">[x=expr]</code>:
        <pre class="programlisting code"><code class="hljs-code">struct foo
{
  int         id;
  std::string name;
  auto run()
 {
    return [i=id, n=name] { std::cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; n &lt;&lt; '\n'; };
  }
};
</code></pre>
</li>
<li class="bulletList">Capturing the entire object with the form <code class="inlineCode">[=]</code> (please note that the implicit capture of pointer <code class="inlineCode">this</code> via <code class="inlineCode">[=]</code> is deprecated in C++20):
        <pre class="programlisting code"><code class="hljs-code">struct foo
{
  int         id;
  std::string name;
  auto run()
 {
    return [=] { std::cout &lt;&lt; id &lt;&lt; ' ' &lt;&lt; name &lt;&lt; '\n'; };
  }
};
</code></pre>
</li>
<li class="bulletList">Capturing the <a id="_idIndexMarker378"/>entire object by capturing <a id="_idIndexMarker379"/>the <code class="inlineCode">this</code> pointer. This is necessary if you need to invoke other methods of the class. This can be captured either as <code class="inlineCode">[this]</code> when the pointer is captured by value, or <code class="inlineCode">[*this]</code> when the object itself is captured by value. This can make a big difference if the object may go out of scope after the capture occurs but before the lambda is invoked:
        <pre class="programlisting code"><code class="hljs-code">struct foo
{
  int         id;
  std::string name;
  auto run()
 {
    return[this]{ std::cout &lt;&lt; id &lt;&lt; ' ' &lt;&lt; name &lt;&lt; '\n'; };
  }
};
auto l = foo{ 42, "john" }.run();
l(); // does not print 42 john
</code></pre>
</li>
</ul>
<p class="normal">In this<a id="_idIndexMarker380"/> latter case, the correct capture should <a id="_idIndexMarker381"/>be <code class="inlineCode">[*this]</code> so that the object is copied by value. In this case, invoking the lambda will print <em class="italic">42 john</em>, even though the temporary has gone out of scope.</p>
<p class="normal">The C++20 standard introduces several changes to capturing the pointer <code class="inlineCode">this</code>:</p>
<ul>
<li class="bulletList">It deprecates the implicit capturing of <code class="inlineCode">this</code> when you use <code class="inlineCode">[=]</code>. This will produce a deprecation warning to be issued by the compiler.</li>
<li class="bulletList">It introduces explicit capturing of the <code class="inlineCode">this</code> pointer by value when you want to capture everything with <code class="inlineCode">[=, this]</code>. You can still only capture the pointer <code class="inlineCode">this</code> with a <code class="inlineCode">[this]</code> capture.</li>
</ul>
<p class="normal">There are cases where lambda expressions only differ in terms of their arguments. In this case, the lambdas can be written in a generic way, just like templates, but using the <code class="inlineCode">auto</code> specifier for the type parameters (no template syntax is involved). This is addressed in the next recipe, as noted in the upcoming <em class="italic">See also</em> section.</p>
<p class="normal">Before C++23, attributes could be specified on a lambda expression between the optional exception specifier and the optional trailing return type. Such attributes would apply to the type, not the function call operator. However, attributes such as <code class="inlineCode">[[nodiscard]]</code> or <code class="inlineCode">[[noreturn]]</code> would only make sense on a function, not a type. </p>
<p class="normal">Therefore, as of C++23, this restriction has changed so that attributes can also be specified:</p>
<ul>
<li class="bulletList">after the lambda introducer and its optional capture, or </li>
<li class="bulletList">after the template parameter list and its optional requires clause.</li>
</ul>
<p class="normal">The attributes declared in any of these parts of a lambda declaration apply to the function call operator and not the type.</p>
<p class="normal">Let’s examine the following example:</p>
<pre class="programlisting code"><code class="hljs-code">auto linc = [](int a) [[deprecated]] { return a+1; };
linc(42);
</code></pre>
<p class="normal">The <code class="inlineCode">[[deprecated]]</code> attribute applies to the type of the lambda and no warning is produced when compiling the snippet. In C++23, we can write the following:</p>
<pre class="programlisting code"><code class="hljs-code">auto linc = [][[nodiscard,deprecated]](int a) { return a+1; };
linc(42);
</code></pre>
<p class="normal">With this <a id="_idIndexMarker382"/>change, both the <code class="inlineCode">[[nodiscard]]</code> and <code class="inlineCode">[[deprecated]]</code> attributes apply to the function call operator of the lambda type. This <a id="_idIndexMarker383"/>results in two warnings being issued: one that a deprecated function is being used, and one that the return type is being ignored.</p>
<h2 class="heading-2" id="_idParaDest-184">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Using generic and template lambdas</em>, to learn how to use <code class="inlineCode">auto</code> for lambda parameters and how to define template lambdas in C++20</li>
<li class="bulletList"><em class="italic">Writing a recursive lambda</em>, to understand the technique we can use to make a lambda call itself recursively</li>
<li class="bulletList"><em class="chapterRef">Chapter 4</em>,<em class="italic"> Providing metadata to the compiler with attributes</em>, to learn about available standard attributes and how to use them</li>
</ul>
<h1 class="heading-1" id="_idParaDest-185">Using generic and template lambdas</h1>
<p class="normal">In the preceding recipe, we saw how to write lambda expressions and use them with standard algorithms. In C++, lambdas<a id="_idIndexMarker384"/> are basically syntactic sugar for unnamed function objects, which are classes that implement the call operator. However, just like any other function, this can be implemented generically with templates. C++14 takes advantage of this and introduces generic lambdas<a id="_idIndexMarker385"/> that do not need to specify actual types for their parameters and use the <code class="inlineCode">auto</code> specifier instead. Though not referred to by this name, generic lambdas are basically lambda templates. They are useful in cases where we want to use the same lambda but with different types of parameters. Moreover, the C++20 standard takes this a step further and supports explicitly defining <a id="_idIndexMarker386"/>template lambdas. This helps with some scenarios where generic lambdas are cumbersome.</p>
<h2 class="heading-2" id="_idParaDest-186">Getting started</h2>
<p class="normal">It is recommended that you read the preceding recipe, <em class="italic">Using lambdas with standard algorithms</em>, before you continue with this one to familiarize yourself with the fundamentals of lambdas in C++.</p>
<h2 class="heading-2" id="_idParaDest-187">How to do it...</h2>
<p class="normal">Since C++14, we can write <a id="_idIndexMarker387"/>generic lambdas:</p>
<ul>
<li class="bulletList">By using the <code class="inlineCode">auto</code> specifier instead of actual types for lambda expression parameters</li>
<li class="bulletList">When we need to use multiple lambdas that only differ by their parameter types</li>
</ul>
<p class="normal">The following example shows a generic lambda used with the <code class="inlineCode">std::accumulate()</code> algorithm, first with a vector of integers and then with a vector of strings:</p>
<pre class="programlisting code"><code class="hljs-code">auto numbers =
  std::vector&lt;int&gt;{0, 2, -3, 5, -1, 6, 8, -4, 9};
using namespace std::string_literals;
auto texts =
  std::vector&lt;std::string&gt;{"hello"s, " "s, "world"s, "!"s};
auto lsum = [](auto const s, auto const n) {return s + n;};
auto sum = std::accumulate(
  std::begin(numbers), std::end(numbers), 0, lsum);
  // sum = 22
auto text = std::accumulate(
  std::begin(texts), std::end(texts), ""s, lsum);
  // sum = "hello world!"s
</code></pre>
<p class="normal">Since C++20, we can write<a id="_idIndexMarker388"/> template lambdas:</p>
<ul>
<li class="bulletList">By using a template parameter list in angle brackets (such as <code class="inlineCode">&lt;template T&gt;</code>) after the capture clause</li>
<li class="bulletList">When you want to:<ul>
<li class="bulletList">Restrict the use of a generic lambda with only some types, such as a container, or types that satisfy a concept.</li>
<li class="bulletList">Make sure that two or more arguments of a generic lambda actually do have the same type.</li>
<li class="bulletList">Retrieve the type of a generic parameter so that, for example, we can create instances of it, invoke static methods, or use its iterator types.</li>
<li class="bulletList">Perform <a id="_idIndexMarker389"/>perfect forwarding in a generic lambda.</li>
</ul>
</li>
</ul>
<p class="normal">The following example shows a template lambda that can be invoked only using an <code class="inlineCode">std::vector</code>:</p>
<pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; vi { 1, 1, 2, 3, 5, 8 };
auto tl = []&lt;typename T&gt;(std::vector&lt;T&gt; const&amp; vec)
{
   std::cout &lt;&lt; std::size(vec) &lt;&lt; '\n';
};
tl(vi); // OK, prints 6
tl(42); // error
</code></pre>
<h2 class="heading-2" id="_idParaDest-188">How it works...</h2>
<p class="normal">In the<a id="_idIndexMarker390"/> first example<a id="_idIndexMarker391"/> from the previous section, we defined a named lambda expression—that is, a lambda expression that has its closure assigned to a variable. This variable is then passed as an argument to the <code class="inlineCode">std::accumulate()</code> function.</p>
<p class="normal">This general algorithm takes the beginning and the ending iterators, which define a range, an initial value to accumulate over, and a function that is supposed to accumulate each value in the range to the total. This function takes a first parameter representing the currently accumulated value and a second parameter representing the current value to accumulate to the total, and it returns the new accumulated value. Note that I did not use the term <code class="inlineCode">add</code> because this can be used for more things than just adding. It can also be used for calculating a product, concatenating, or other operations that aggregate values together.</p>
<p class="normal">The two calls to <code class="inlineCode">std::accumulate()</code> in this example are almost the same; only the types of the arguments are different:</p>
<ul>
<li class="bulletList">In the first call, we pass iterators to a range of integers (from a <code class="inlineCode">vector&lt;int&gt;</code>), 0 for the initial sum, and a lambda that adds two integers and returns their sum. This produces a sum of all integers in the range; for this example, it is <code class="inlineCode">22</code>.</li>
<li class="bulletList">In the second call, we pass iterators to a range of strings (from a <code class="inlineCode">vector&lt;string&gt;</code>), an empty string for the initial value, and a lambda that concatenates two strings by adding them together and returning the result. This produces a string that contains all the strings in the range put together one after another; for this example, the result is <code class="inlineCode">hello world!</code>.</li>
</ul>
<p class="normal">Though generic lambdas can be defined anonymously in the place where they are called, it does not really make sense because the very purpose of a generic lambda (which is basically, as we mentioned earlier, a lambda expression template) is to be reused, as shown in the example from the <em class="italic">How to do it...</em> section.</p>
<p class="normal">When defining this<a id="_idIndexMarker392"/> lambda expression, when used with multiple calls to <code class="inlineCode">std::accumulate()</code>, instead of specifying concrete types for the lambda parameters (such as <code class="inlineCode">int</code> or <code class="inlineCode">std::string</code>), we used the <code class="inlineCode">auto</code> specifier and let the compiler deduce the<a id="_idIndexMarker393"/> type. </p>
<p class="normal">When encountering a lambda expression that has the <code class="inlineCode">auto</code> specifier for a parameter type, the compiler generates an unnamed function object that has a call operator template. For the generic lambda expression in this example, the function object would look like this:</p>
<pre class="programlisting code"><code class="hljs-code">struct __lambda_name__
{
  template&lt;typename T1, typename T2&gt;
 auto operator()(T1 const s, T2 const n) const { return s + n; }
  __lambda_name__(const __lambda_name__&amp;) = default;
  __lambda_name__(__lambda_name__&amp;&amp;) = default;
  __lambda_name__&amp; operator=(const __lambda_name__&amp;) = delete;
  ~__lambda_name__() = default;
};
</code></pre>
<p class="normal">The call operator is a template with a type parameter for each parameter in the lambda that was specified with <code class="inlineCode">auto</code>. The return type of the call operator is also <code class="inlineCode">auto</code>, which means the compiler will deduce it from the type of the returned value. This operator template will be instantiated with the actual types that the compiler will identify in the context where the generic lambda is used.</p>
<p class="normal">The C++20 template lambdas are an improvement of the C++14 generic lambdas, making some scenarios easier. A typical one was shown in the second example of the previous section, where the use of lambda was restricted with arguments of the type <code class="inlineCode">std::vector</code>. Another example is when you want to make sure that two parameters of the lambda have the same type. Prior to C++20, this was difficult to do, but with template lambdas, it is very easy, as shown in the following example:</p>
<pre class="programlisting code"><code class="hljs-code">auto tl = []&lt;typename T&gt;(T x, T y)
{
  std::cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; '\n';
};
tl(10, 20);   // OK
tl(10, "20"); // error
</code></pre>
<p class="normal">Another scenario for template lambdas is when you need to know the type of a parameter so that you can create instances of that type or invoke static members of it. With generic lambdas, the solution is as follows:</p>
<pre class="programlisting code"><code class="hljs-code">struct foo
{
   static void f() { std::cout &lt;&lt; "foo\n"; }
};
auto tl = [](auto x)
{
  using T = std::decay_t&lt;decltype(x)&gt;;
  T other;
  T::f();
};
tl(foo{});
</code></pre>
<p class="normal">This solution<a id="_idIndexMarker394"/> requires the use of <code class="inlineCode">std::decay_t</code> and <code class="inlineCode">decltype</code>. <code class="inlineCode">decltype</code> is <a id="_idIndexMarker395"/>a type specifier that yields the type of a specified expression and is primarily used in writing templates. On the other hand, <code class="inlineCode">std::decay</code> is a utility from <code class="inlineCode">&lt;type_traits&gt;</code> that performs the same type conversions as when passing function arguments by value.</p>
<p class="normal">However, in C++20, the same lambda can be written as follows:</p>
<pre class="programlisting code"><code class="hljs-code">auto tl = []&lt;typename T&gt;(T x)
{
  T other;
  T::f();
};
</code></pre>
<p class="normal">A similar situation occurs when we need to do perfect forwarding in a generic lambda, which requires the use of <code class="inlineCode">decltype</code> to determine the types of the arguments:</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;typename ...T&gt;
void foo(T&amp;&amp; ... args)
{ /* ... */ }
auto tl = [](auto&amp;&amp; ...args)
{
  return foo(std::forward&lt;decltype(args)&gt;(args)...);
};
tl(1, 42.99, "lambda");
</code></pre>
<p class="normal">With template lambda, we can rewrite it in a simpler way as follows:</p>
<pre class="programlisting code"><code class="hljs-code">auto tl = []&lt;typename ...T&gt;(T &amp;&amp; ...args)
{
  return foo(std::forward&lt;T&gt;(args)...);
};
</code></pre>
<p class="normal">As seen in these<a id="_idIndexMarker396"/> examples, template lambdas are an improvement on generic <a id="_idIndexMarker397"/>lambdas, making it easier to handle the scenarios mentioned in this recipe.</p>
<h2 class="heading-2" id="_idParaDest-189">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Using lambdas with standard algorithms</em>, to explore the basics of lambda expressions and how you can utilize them with the standard algorithms</li>
<li class="bulletList"><em class="chapterRef">Chapter 1</em>, <em class="italic">Using auto whenever possible</em>, to understand how automatic type deduction works in C++</li>
</ul>
<h1 class="heading-1" id="_idParaDest-190">Writing a recursive lambda</h1>
<p class="normal">Lambdas are <a id="_idIndexMarker398"/>basically unnamed function objects, which means that it should be possible to call them recursively. Indeed, they can be called recursively; however, the mechanism for doing so is not obvious as it requires assigning the lambda to a function wrapper and capturing the wrapper by reference. Though it can be argued that a recursive lambda does not really make sense and that a function is probably a better design choice, in this recipe, we will look at how to write a recursive lambda.</p>
<h2 class="heading-2" id="_idParaDest-191">Getting ready</h2>
<p class="normal">To demonstrate how to write a recursive lambda, we will consider the well-known example of the Fibonacci function. This is usually implemented recursively in C++, as follows:</p>
<pre class="programlisting code"><code class="hljs-code">constexpr int fib(int const n)
{
  return n &lt;= 2 ? 1 : fib(n - 1) + fib(n - 2);
}
</code></pre>
<p class="normal">Having this implementation as a starting point, let’s see how we can rewrite it using a recursive lambda.</p>
<h2 class="heading-2" id="_idParaDest-192">How to do it...</h2>
<p class="normal">In C++11, in<a id="_idIndexMarker399"/> order to write a recursive lambda function, you must do the following:</p>
<ul>
<li class="bulletList">Define the lambda in a function scope.</li>
<li class="bulletList">Assign the lambda to an <code class="inlineCode">std::function</code> wrapper.</li>
<li class="bulletList">Capture the <code class="inlineCode">std::function</code> object by reference in the lambda in order to call it recursively.</li>
</ul>
<p class="normal">In C++14, the above pattern can be simplified using a generic lambda:</p>
<ul>
<li class="bulletList">Define the lambda in a function scope.</li>
<li class="bulletList">Declare the first argument with the <code class="inlineCode">auto</code> placeholder; this is used to pass the lambda expression as an argument to itself.</li>
<li class="bulletList">Invoke the lambda expression by passing the lambda itself for the first argument.</li>
</ul>
<p class="normal">In C++23, this pattern can be further simplified as follows:</p>
<ul>
<li class="bulletList">Define the lambda in a function scope.</li>
<li class="bulletList">Declare the first argument <code class="inlineCode">this const auto&amp;&amp; self</code>; this is to enable a new C++23 feature called <em class="italic">deducing this</em> or <em class="italic">explicit object parameter</em>. You can recursively call the lambda expression through the <code class="inlineCode">self</code> argument.</li>
<li class="bulletList">Invoke the lambda expression by calling it with the explicit arguments (if any) and let the compiler deduce the first one.</li>
</ul>
<p class="normal">The following are <a id="_idIndexMarker400"/>examples of recursive lambdas:</p>
<ul>
<li class="bulletList">A recursive Fibonacci lambda expression in the scope of a function that is invoked from the scope where it is defined:
        <pre class="programlisting code"><code class="hljs-code">void sample()
{
  std::function&lt;int(int const)&gt; lfib =
    [&amp;lfib](int const n)
    {
      return n &lt;= 2 ? 1 : lfib(n - 1) + lfib(n - 2);
    };
  auto f10 = lfib(10);
}
</code></pre>
</li>
<li class="bulletList">A recursive Fibonacci lambda expression returned by a function, which can be invoked from any scope:
        <pre class="programlisting code"><code class="hljs-code">std::function&lt;int(int const)&gt; fib_create()
{
  std::function&lt;int(int const)&gt; f = [](int const n)
  {
    std::function&lt;int(int const)&gt; lfib = [&amp;lfib](int n)
    {
      return n &lt;= 2 ? 1 : lfib(n - 1) + lfib(n - 2);
    };
    return lfib(n);
  };
  return f;
}
void sample()
{
  auto lfib = fib_create();
  auto f10 = lfib(10);
}
</code></pre>
</li>
<li class="bulletList">A lambda expression as a member of a class that is invoked recursively:
        <pre class="programlisting code"><code class="hljs-code">struct fibonacci
{
  std::function&lt;int(int const)&gt; lfib =
    [this](int const n)
    {
      return n &lt;= 2 ? 1 : lfib(n - 1) + lfib(n - 2);
    };
};
fibonacci f;
f.lfib(10);
</code></pre>
</li>
<li class="bulletList">A recursive <a id="_idIndexMarker401"/>Fibonacci generic lambda expression—the C++14 alternative for the example from the first bullet:
        <pre class="programlisting code"><code class="hljs-code">void sample()
{
   auto lfib = [](auto f, int const n)
   {
      if (n &lt; 2) return 1;
      else return f(f, n - 1) + f(f, n - 2);
   };
   lfib(lfib, 10);
}
</code></pre>
</li>
<li class="bulletList">A recursive Fibonacci lambda expression, taking advantage of the C++23 feature called explicit object parameter (or deducing this), a further simplified alternative to the one above:
        <pre class="programlisting code"><code class="hljs-code">void sample()
{
  auto lfib = [](this const auto&amp; self, int n) -&gt; int
  {
    return n &lt;= 2 ? 1 : self(n - 1) + self(n - 2);
  };
  lfib(5);
}
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-193">How it works...</h2>
<p class="normal">The first thing you<a id="_idIndexMarker402"/> need to consider when writing a recursive lambda in C++11 is that a lambda expression is a function object and, in order to call it recursively from the lambda’s body, the lambda must capture its closure (that is, the instantiation of the lambda). In other words, the lambda must capture itself, and this has several implications:</p>
<ul>
<li class="bulletList">First of all, the lambda must have a name; an unnamed lambda cannot be captured so that it can be called again.</li>
<li class="bulletList">Secondly, the lambda can only be defined in a function scope. The reason for this is that a lambda can only capture variables from a function scope; it cannot capture any variable that has a static storage duration. Objects defined in a namespace scope or with the static or external specifiers have static storage duration. If the lambda was defined in a namespace scope, its closure would have static storage duration and, therefore, the lambda would not capture it.</li>
<li class="bulletList">The third implication is that the type of the lambda closure cannot remain unspecified; that is, it cannot be declared with the <code class="inlineCode">auto</code> specifier. It is not possible for a variable declared with the <code class="inlineCode">auto</code> type specifier to appear in its own initializer. This is because the type of the variable is not known when the initializer is being processed. Therefore, you must specify the type of the lambda closure. The way we can do this is by using the general-purpose function wrapper <code class="inlineCode">std::function</code>.</li>
<li class="bulletList">Last, but not least, the lambda closure must be captured by reference. If we capture by copy (or value), then a copy of the function wrapper is made but the wrapper is uninitialized when the capturing is done. We end up with an object that we are not able to call. Even though the compiler will not complain about capturing by value, when the closure is invoked, an <code class="inlineCode">std::bad_function_call</code> is thrown.</li>
</ul>
<p class="normal">In the first example <a id="_idIndexMarker403"/>from the <em class="italic">How to do it...</em> section, the recursive lambda is defined inside another function called <code class="inlineCode">sample()</code>. The signature and the body of the lambda expression are the same as those of the regular recursive function <code class="inlineCode">fib</code> <code class="inlineCode">()</code>, which was defined in the introductory section. The lambda closure is assigned to a function wrapper called <code class="inlineCode">lfib</code>, which is then captured by reference by the lambda and called recursively from its body. Since the closure is captured by reference, it will be initialized at the time it has to be called from the lambda’s body.</p>
<p class="normal">In the second example, we defined a function that returns the closure of a lambda expression that, in turn, defines and invokes a recursive lambda with the argument it was in turn invoked with. This is a pattern that must be implemented when a recursive lambda needs to be returned from a function. This is necessary because the lambda closure must still be available at the time the recursive lambda is called. The <code class="inlineCode">fib_create()</code> method returns a function wrapper that, when invoked, creates the recursive lambda that captures itself. The outer <code class="inlineCode">f</code> lambda does not capture anything, especially by reference; therefore, we don’t have this issue with dangling references. However, when invoked, it creates a closure of the nested lambda, which is the actual lambda we are interested in calling, and returns the result of applying that recursive <code class="inlineCode">lfib</code> lambda to <a id="_idIndexMarker404"/>its parameter.</p>
<p class="normal">Writing a recursive lambda is simpler in C++14, as the fourth example from the <em class="italic">How to do it…</em> section shows. Instead of capturing the lambda’s closure, it is passed as an argument (typically, the first). For this purpose, a parameter is declared using the <code class="inlineCode">auto</code> placeholder. Let’s revisit the implementation in order to discuss it:</p>
<pre class="programlisting code"><code class="hljs-code">auto lfib = [](auto f, int const n)
{
   if (n &lt; 2) return 1;
   else return f(f, n - 1) + f(f, n - 2);
};
lfib(lfib, 10);
</code></pre>
<p class="normal">A lambda expression<a id="_idIndexMarker405"/> is a function object with a function call operator. A generic lambda<a id="_idIndexMarker406"/> is a function object with a template function call operator. The compiler generates code similar to the following for the previous snippet:</p>
<pre class="programlisting code"><code class="hljs-code">class __lambda_name_3
{
public:
   template&lt;class T1&gt;
 inline int operator()(T1 f, const int n) const
 {
      if (n &lt; 2) {
         return 1;
      }
      else {
         return f(f, n - 1) + f(f, n - 2);
      }
   }
   template&lt;&gt;
   inline int operator()&lt;__lambda_name_3&gt; (__lambda_name_3 f, 
 const int n) const
 {
      if (n &lt; 2) {
         return 1;
      }
      else {
         return f.operator()(__lambda_name_3(f), n - 1) + 
                f.operator()(__lambda_name_3(f), n - 2);
      }
   }
};
__lambda_name_3 lfib = __lambda_name_3{};
lfib.operator()(__lambda_name_3(lfib), 10);
</code></pre>
<p class="normal">The function call operator is a template function. Its first parameter has the type of the type template parameter. For this primary template, a full explicit specialization for the class type itself is provided. This makes it possible to invoke the lambda, passing itself as an argument, and therefore, avoiding the capturing of an <code class="inlineCode">std::function</code> object, as it was necessary to do in C++11.</p>
<p class="normal">If your compiler<a id="_idIndexMarker407"/> supports C++23, then it’s possible to simplify this even further with the help of the <em class="italic">explicit object parameter</em> feature (also known as <em class="italic">deducing this</em>). This feature was designed to enable the compiler to figure out from within a function whether the expression it’s invoked on is an lvalue or an rvalue, or if it is <em class="italic">cv-</em> or <em class="italic">ref-</em>qualified, and what the type of the expression is. This feature makes possible scenarios such as:</p>
<ul>
<li class="bulletList">Avoiding duplicating code with overloads-based <em class="italic">cv-</em> and <em class="italic">ref-</em>qualifiers (for instance, the same function with no qualifiers and with a <code class="inlineCode">const</code> qualifier, which is the most usual case).</li>
<li class="bulletList">Simplifying <a id="_idIndexMarker408"/>the <strong class="keyWord">curiously recurring template pattern</strong> (<strong class="keyWord">CRTP</strong>) by using simple inheritance and, therefore, removing the recurrence from the pattern.</li>
<li class="bulletList">Simplifying writing recursive lambdas.</li>
</ul>
<p class="normal">For the example<a id="_idIndexMarker409"/> given in the <em class="italic">How to do it…</em> section, the compiler is able to deduce the type of the first argument, <code class="inlineCode">self</code>, making it unnecessary to explicitly pass the lambda closure as an argument.</p>
<p class="normal">Notice that in the C++23 example, we have defined a lambda expression using the trailing return type syntax:</p>
<pre class="programlisting code"><code class="hljs-code">[](this auto const &amp; self, int n) -&gt; int
</code></pre>
<p class="normal">Without this, you would get a compiler error such as the following:</p>
<pre class="programlisting con"><code class="hljs-con">error: function 'operator()&lt;(lambda)&gt;' with deduced return type cannot be used before it is defined
</code></pre>
<p class="normal">With a small change in the function implementation, shown next, the trailing return type is no longer needed, and the deduce this feature works again:</p>
<pre class="programlisting code"><code class="hljs-code">auto lfib = [](this auto const&amp; self, int n)
{
   if (n &lt;= 2) return 1;
   return self(n - 1) + self(n - 2);
};
</code></pre>
<h2 class="heading-2" id="_idParaDest-194">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Using generic and template lambdas</em>, to learn how to use <code class="inlineCode">auto</code> for lambda parameters and how to define template lambdas in C++20</li>
<li class="bulletList"><em class="chapterRef">Chapter 9</em>, <em class="italic">Static polymorphism with the curiously recurring template pattern</em>, to learn about what the CRTP is and how it works</li>
</ul>
<h1 class="heading-1" id="_idParaDest-195">Writing function templates</h1>
<p class="normal">Generic code<a id="_idIndexMarker410"/> is key to avoid writing repetitive code. In C++, this is achieved with the help of templates. Classes, functions, and variables can be templated. Although templates are often seen as complex and cumbersome, they enable the creation of general-purpose libraries, such as the standard library, and help us write less and better code. </p>
<p class="normal">Templates <a id="_idIndexMarker411"/>are first-class citizens of the C++ language and could take an entire book to cover in detail. In fact, multiple recipes in this book deal with various aspects of templates. In this recipe, we will discuss the basics of writing function templates.</p>
<h2 class="heading-2" id="_idParaDest-196">How to do it…</h2>
<p class="normal">Do the following to create<a id="_idIndexMarker412"/> function templates:</p>
<ul>
<li class="bulletList">To create a function template, precede the function declaration with the <code class="inlineCode">template</code> keyword followed by the list of template parameters in angle brackets:
        <pre class="programlisting code"><code class="hljs-code">template &lt;typename T&gt;
T minimum(T a, T b)
{
   return a &lt;= b ? a : b;
}
minimum(3, 4);
minimum(3.99, 4.01);
</code></pre>
</li>
<li class="bulletList">To specialize a function template, leave the list of template parameters empty and replace the template parameters with actual types or values in the function signature:
        <pre class="programlisting code"><code class="hljs-code">template &lt;&gt;
const char* minimum(const char* a, const char* b)
{
   return std::strcmp(a, b) &lt;= 1 ? a : b;
}
minimum("abc", "acxyz");
</code></pre>
</li>
<li class="bulletList">To overload a function template, provide another definition, which can be either a template or a non-template:
        <pre class="programlisting code"><code class="hljs-code">template &lt;typename T&gt;
std::basic_string&lt;T&gt; minimum(std::basic_string&lt;T&gt; a, 
                             std::basic_string&lt;T&gt; b) // [1]
{
   return a.length() &lt;= b.length() ? a : b;
}
std::string minimum(std::string a, std::string b) // [2]
{
   return a.length() &lt;= b.length() ? a : b;
}
minimum(std::string("def"), std::string("acxyz")); // calls [2]
minimum(std::wstring(L"def"), std::wstring(L"acxyz")); // calls [1]
</code></pre>
</li>
<li class="bulletList">To ensure a particular function template or specialization of a function template cannot be called (is deleted from the overload set), declare it as <code class="inlineCode">deleted</code>:
        <pre class="programlisting code"><code class="hljs-code">template &lt;typename T&gt;
T* minimum(T* a, T* b) = delete;
int a = 3;
int b = 4;
minimum(&amp;a, &amp;b); // error
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-197">How it works…</h2>
<p class="normal">At least at <a id="_idIndexMarker413"/>first look, function templates are only slightly different from other functions. They are introduced with a template syntax and can be parameterized with types, values, or even other templates. However, since templates are only blueprints for creating actual code, a function template is basically a blueprint that defines a family of functions. Templates only exist in source code, until they are used.</p>
<p class="normal">The compiler instantiates the templates based on their use. This process is called <em class="italic">template instantiation</em>. This is<a id="_idIndexMarker414"/> done by the compiler by substituting the template arguments. For instance, in the case of the <code class="inlineCode">minimum&lt;T&gt;</code> function template shown previously, when we invoke this as <code class="inlineCode">minimum&lt;int&gt;(1, 2)</code>, the compiler substitutes the <code class="inlineCode">int</code> type for the <code class="inlineCode">T</code> parameter. There are two forms of instantiation:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Implicit instantiation</strong> occurs when the compiler generates code from a template based on the <a id="_idIndexMarker415"/>templates used in the code. For instance, if the <code class="inlineCode">minimum&lt;T&gt;</code> function is invoked with <code class="inlineCode">int</code> and <code class="inlineCode">double</code> values throughout your code, then two overloads (one with integer parameters and one with <code class="inlineCode">double</code> parameters) are generated. This is the implicit instantiation, as shown in the following snippet:
        <pre class="programlisting code"><code class="hljs-code">minimum&lt;int&gt;(1, 2);  // explicit int template argument
minimum(3.99, 4.50); // deduced double template argument
</code></pre>
</li>
<li class="bulletList"><strong class="keyWord">Explicit instantiation</strong> occurs when you, as a user, request the compiler to generate code from a template even if that instantiation is not used in the code. An example of<a id="_idIndexMarker416"/> where this is useful is when creating library (binary) files, since uninstantiated templates (which are only blueprints) are not put into object files. The following shows an example of explicit instantiation of the <code class="inlineCode">minimum&lt;T&gt;</code> function for the <code class="inlineCode">char</code> type. Keep in mind that if an explicit instantiation is not defined in the same namespace as the template, the name must be fully qualified in the explicit instantiation definition:
        <pre class="programlisting code"><code class="hljs-code">template char minimum(char a, char b);
</code></pre>
</li>
</ul>
<p class="normal">As <a id="_idIndexMarker417"/>previously mentioned, templates can have different kinds of parameters. These are provided in angle brackets after the <code class="inlineCode">template</code> keyword and can be the following:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Type template parameters</strong>, where<a id="_idIndexMarker418"/> the parameter is a placeholder for a type. This is the case for all the examples seen in the previous section.</li>
<li class="bulletList"><strong class="keyWord">Non-type template parameters</strong>, where the parameter is a value of a structural type. The <a id="_idIndexMarker419"/>integer types, floating-point types (since C++20), pointer types, enumeration types, and lvalue reference types are all structural types. In the following example, <code class="inlineCode">T</code> is a type template parameter and <code class="inlineCode">S</code> is a non-type template parameter:
        <pre class="programlisting code"><code class="hljs-code">template &lt;typename T, std::size_t S&gt;
std::array&lt;T, S&gt; make_array()
{
   return std::array&lt;T, S&gt;{};
}
</code></pre>
</li>
</ul>
<p class="normal">In C++17, non-type template parameters can be declared using the <code class="inlineCode">auto</code> keyword:</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;typename T, auto S&gt;
std::array&lt;T, S&gt; make_array()
{
   return std::array&lt;T, S&gt;{};
}
</code></pre>
<ul>
<li class="bulletList"><strong class="keyWord">Template template parameters</strong>, where the type of the parameter is another type. In the <a id="_idIndexMarker420"/>following example, the <code class="inlineCode">trimin</code> function template has two template parameters, a type template parameter <code class="inlineCode">T</code>, and a template template parameter <code class="inlineCode">M</code>:
        <pre class="programlisting code"><code class="hljs-code">template &lt;typename T&gt;
struct Minimum
{
   T operator()(T a, T b)
 {
      return a &lt;= b ? a : b;
   }
};
template &lt;typename T, template &lt;typename&gt; class M&gt;
T trimin(T a, T b, T c)
{
   return M&lt;T&gt;{}(a, M&lt;T&gt;{}(b, c));
}
trimin&lt;int, Minimum&gt;(5, 2, 7);
</code></pre>
</li>
</ul>
<p class="normal">Although templates allow us to write one implementation for many types (or template parameters, more generally), it is often useful, or maybe necessary, to provide modified implementations for different types. This process of providing alternative implementations for some template parameters <a id="_idIndexMarker421"/>is called specialization. The template that is being specialized is <a id="_idIndexMarker422"/>called the <em class="italic">primary template</em>. There are two possible forms:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Partial specialization</strong> is <a id="_idIndexMarker423"/>when you provide a different implementation only for some of the template parameters.</li>
<li class="bulletList"><strong class="keyWord">Full specialization</strong> is when<a id="_idIndexMarker424"/> you provide a different implementation for the entire set of template parameters.</li>
</ul>
<p class="normal">Function templates<a id="_idIndexMarker425"/> only support full specialization. Partial specialization is only possible for class templates. An example of a full specialization was provided in the <em class="italic">How to do it…</em> section when we specialized the <code class="inlineCode">minimum&lt;T&gt;</code> function template for the <code class="inlineCode">const char*</code> type. Instead of lexicographically comparing the two arguments of the function, we decided which is “smaller” based on their length. Keep in mind this was an example given only for the purpose of understanding specialization.</p>
<p class="normal">Function templates can be overloaded just like any other function. You should note that when multiple overloads are available, both template and non-template, the compiler will prefer a non-template overload. An example was provided earlier. Let’s see it again, with only the declarations of the functions:</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;typename T&gt;
std::basic_string&lt;T&gt; minimum(std::basic_string&lt;T&gt; a, std::basic_string&lt;T&gt; b);
std::string minimum(std::string a, std::string b);
minimum(std::string("def"), std::string("acxyz"));
minimum(std::wstring(L"def"), std::wstring(L"acxyz"));
</code></pre>
<p class="normal">The first call to the <code class="inlineCode">minimum</code> function takes <code class="inlineCode">std::string</code> arguments, and, therefore, the non-template overload will be invoked. The second call takes <code class="inlineCode">std::wstring</code> arguments, and since the function template is the only matching overload, its <code class="inlineCode">std::wstring</code> instantiation will be invoked.</p>
<p class="normal">Specifying the template arguments during the invocation of a function template is not always necessary. The following two calls are identical:</p>
<pre class="programlisting code"><code class="hljs-code">minimum(1, 2);
minimum&lt;int&gt;(1, 2);
</code></pre>
<p class="normal">There are many cases<a id="_idIndexMarker426"/> where the compiler can deduce the template arguments from the invocation of the function. In this example, since both function arguments are integers, it can figure out that the template argument should be the <code class="inlineCode">int</code> type. Therefore, explicitly specifying this is not necessary. However, there are also situations in which the compiler cannot deduce the types. In these cases, you must provide them explicitly. An example is given next:</p>
<pre class="programlisting code"><code class="hljs-code">minimum(1, 2u); // error, ambiguous template parameter T
</code></pre>
<p class="normal">The two arguments are an <code class="inlineCode">int</code> and an <code class="inlineCode">unsigned int</code>. Therefore, the compiler does not know whether the <code class="inlineCode">T</code> type should be deduced as <code class="inlineCode">int</code> or <code class="inlineCode">unsigned int</code>. To solve this ambiguity, you must provide the template argument explicitly:</p>
<pre class="programlisting code"><code class="hljs-code">minimum&lt;unsigned&gt;(1, 2u); // OK
</code></pre>
<p class="normal">When deducing template arguments, the compiler performs a comparison between the template parameters and the arguments used to invoke the function. These must have a certain structure for the comparison to succeed and for the compiler to successfully deduce all the arguments. A detailed look at this process is, however, beyond the scope of this recipe. You can consult other resources, including my book <em class="chapterRef">Template Metaprogramming with C++</em>, which discusses this in detail in <em class="italic">Chapter 4</em>, both for function templates and class templates.</p>
<p class="normal">As mentioned in the <a id="_idIndexMarker427"/>introduction, templates are a broad topic that cannot be covered in one recipe. We will learn more about templates throughout the book, including in the next two recipes, where we will discuss function templates with a variable number of arguments.</p>
<h2 class="heading-2" id="_idParaDest-198">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Writing a function template with a variable number of arguments</em>, to learn how to write functions that take a variable number of arguments</li>
<li class="bulletList"><em class="chapterRef">Chapter 1</em>, <em class="italic">Simplifying code with class template argument deduction</em>, to see how template argument deduction works for class templates</li>
</ul>
<h1 class="heading-1" id="_idParaDest-199">Writing a function template with a variable number of arguments</h1>
<p class="normal">It is sometimes <a id="_idIndexMarker428"/>useful to write functions with a variable number of arguments or classes with a variable number of members. Typical examples include functions such as <code class="inlineCode">printf</code>, which takes a format and a variable number of arguments, or classes such as <code class="inlineCode">tuple</code>. Before C++11, the former was possible only with the use of variadic macros (which enable writing only type-unsafe functions) and the latter was not possible at all. C++11 introduced variadic templates, which are templates with a variable number of arguments that make it possible to write both type-safe function templates with a variable number of arguments, and also class templates with a variable number of members. In this recipe, we will look at writing function templates.</p>
<h2 class="heading-2" id="_idParaDest-200">Getting ready</h2>
<p class="normal">Functions <a id="_idIndexMarker429"/>with a variable number of arguments are <a id="_idIndexMarker430"/>called <em class="italic">variadic functions</em>. Function<a id="_idIndexMarker431"/> templates with a variable number of arguments are called <em class="italic">variadic function templates</em>. Knowledge of C++ variadic macros (<code class="inlineCode">va_start</code>, <code class="inlineCode">va_end</code>, <code class="inlineCode">va_arg</code>, <code class="inlineCode">va_copy</code>, and <code class="inlineCode">va_list</code>) is not necessary for learning how to write variadic function templates, but it represents a good starting point.</p>
<p class="normal">We have already used variadic templates in our previous recipes, but this one will provide detailed explanations.</p>
<h2 class="heading-2" id="_idParaDest-201">How to do it...</h2>
<p class="normal">In order to write variadic function templates, you must perform the following steps:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Define an overload with a fixed number of arguments to end compile-time recursion if the semantics of the variadic function template require it (refer to <code class="inlineCode">[1]</code> in the following code).</li>
<li class="numberedList">Define a template parameter pack that is a template parameter that can hold any number of arguments, including zero; these arguments can be either types, non-types, or templates (refer to <code class="inlineCode">[2]</code>).</li>
<li class="numberedList">Define a function parameter pack to hold any number of function arguments, including zero; the size of the template parameter pack and the corresponding function parameter pack is the same. This size can be determined with the <code class="inlineCode">sizeof...</code> operator (refer to <code class="inlineCode">[3]</code> and refer to the end of the <em class="italic">How it works...</em> section for information on this operator).</li>
<li class="numberedList">Expand the parameter pack in order to replace it with the actual arguments being supplied (refer to <code class="inlineCode">[4]</code>).</li>
</ol>
<p class="normal">The following example, which illustrates all the preceding points, is a variadic function template that adds a variable number of arguments using <code class="inlineCode">operator+</code>:</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;typename T&gt;                 // [1] overload with fixed
T add(T value) //     number of arguments
{
  return value;
}
template &lt;typename T, typename... Ts&gt; // [2] typename... Ts
T add(T head, Ts... rest) // [3] Ts... rest
{
  return head + add(rest...);         // [4] rest...
}
</code></pre>
<h2 class="heading-2" id="_idParaDest-202">How it works...</h2>
<p class="normal">At first <a id="_idIndexMarker432"/>glance, the preceding implementation looks like recursion because the function <code class="inlineCode">add()</code> calls itself, and in a way it is, but it is a compile-time recursion that does not incur any sort of runtime recursion and overhead. The compiler actually generates several functions with a different number of arguments, based on the variadic function template’s usage, so only function overloading is involved and not any sort of recursion. However, implementation is done as if parameters would be processed in a recursive manner with an end condition.</p>
<p class="normal">In the preceding code, we can identify the following key parts:</p>
<ul>
<li class="bulletList"><code class="inlineCode">Typename... Ts</code> is a template parameter pack that indicates a variable number of template type arguments.</li>
<li class="bulletList"><code class="inlineCode">Ts... rest</code> is a function parameter pack that indicates a variable number of function arguments.</li>
<li class="bulletList"><code class="inlineCode">rest...</code> is an expansion of the function parameter pack.</li>
</ul>
<div><p class="normal">The position of the ellipsis is not syntactically relevant. <code class="inlineCode">typename... Ts</code>, <code class="inlineCode">typename ... Ts</code>, and <code class="inlineCode">typename ...Ts</code> are all equivalent.</p>
</div>
<p class="normal">In the <code class="inlineCode">add(T head, Ts... rest)</code> parameter, <code class="inlineCode">head</code> is the first element of the list of arguments, while <code class="inlineCode">...rest</code> is a pack with the rest of the parameters in the list (this can be zero or more). In the body of the function, <code class="inlineCode">rest...</code> is an expansion of the function parameter pack. This means the compiler replaces the parameter pack with its elements in their order. In the <code class="inlineCode">add()</code> function, we basically add the first argument to the sum of the remaining arguments, which gives the impression of recursive processing. This recursion ends when there is a single argument left, in which case the first <code class="inlineCode">add()</code> overload (with a single argument) is called and returns the value of its argument.</p>
<p class="normal">This implementation of the function template <code class="inlineCode">add()</code> enables us to write code, as shown here:</p>
<pre class="programlisting code"><code class="hljs-code">auto s1 = add(1, 2, 3, 4, 5); // s1 = 15
auto s2 = add("hello"s, " "s, "world"s, "!"s); // s2 = "hello world!"
</code></pre>
<p class="normal">When the compiler encounters <code class="inlineCode">add(1, 2, 3, 4, 5)</code>, it generates the following functions (notice that <code class="inlineCode">arg1</code>, <code class="inlineCode">arg2</code>, and so on are not the actual names the compiler generates), which shows that this process is actually only a sequence of calls to overloaded functions and not recursion:</p>
<pre class="programlisting code"><code class="hljs-code">int add(int head, int arg1, int arg2, int arg3, int arg4)
{return head + add(arg1, arg2, arg3, arg4);}
int add(int head, int arg1, int arg2, int arg3)
{return head + add(arg1, arg2, arg3);}
int add(int head, int arg1, int arg2)
{return head + add(arg1, arg2);}
int add(int head, int arg1)
{return head + add(arg1);}
int add(int value)
{return value;}
</code></pre>
<div><p class="normal">With GCC and Clang, you can use the <code class="inlineCode">__PRETTY_FUNCTION__</code> macro to print the name and the signature of the function.</p>
</div>
<p class="normal">By adding <a id="_idIndexMarker433"/>an <code class="inlineCode">std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl</code>, when using GCC or Clang, at the beginning of the two functions we wrote, we get the following when running the code:</p>
<ul>
<li class="bulletList">With GCC:
        <pre class="programlisting con"><code class="hljs-con">T add(T, Ts ...) [with T = int; Ts = {int, int, int, int}]
T add(T, Ts ...) [with T = int; Ts = {int, int, int}]
T add(T, Ts ...) [with T = int; Ts = {int, int}]
T add(T, Ts ...) [with T = int; Ts = {int}]
T add(T) [with T = int]
</code></pre>
</li>
<li class="bulletList">With Clang:
        <pre class="programlisting con"><code class="hljs-con">T add(T, Ts...) [T = int, Ts = &lt;int, int, int, int&gt;]
T add(T, Ts...) [T = int, Ts = &lt;int, int, int&gt;]
T add(T, Ts...) [T = int, Ts = &lt;int, int&gt;]
T add(T, Ts...) [T = int, Ts = &lt;int&gt;]
T add(T) [T = int]
</code></pre>
</li>
</ul>
<p class="normal">Since this is a function template, it can be used with any type that supports <code class="inlineCode">operator+</code>. The other example, <code class="inlineCode">add("hello"s, " "s, "world"s, "!"s)</code>, produces the <em class="italic">hello world!</em> string. However, the <code class="inlineCode">std::basic_string</code> type has different overloads for <code class="inlineCode">operator+</code>, including one that can concatenate a string into a character, so we should be able to also write the following:</p>
<pre class="programlisting code"><code class="hljs-code">auto s3 = add("hello"s, ' ', "world"s, '!'); // s3 = "hello world!"
</code></pre>
<p class="normal">However, that will generate compiler errors, as follows (note that I actually replaced <code class="inlineCode">std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;</code> with the string <em class="italic">hello world!</em> for simplicity):</p>
<pre class="programlisting con"><code class="hljs-con">In instantiation of 'T add(T, Ts ...) [with T = char; Ts = {string, char}]':
16:29:   required from 'T add(T, Ts ...) [with T = string; Ts = {char, string, char}]'
22:46:   required from here
16:29: error: cannot convert 'string' to 'char' in return
 In function 'T add(T, Ts ...) [with T = char; Ts = {string, char}]':
17:1: warning: control reaches end of non-void function [-Wreturn-type]
</code></pre>
<p class="normal">What<a id="_idIndexMarker434"/> happens is that the compiler generates the code shown here, where the return type is the same as the type of the first argument. However, the first argument is either an <code class="inlineCode">std::string</code> or a <code class="inlineCode">char</code> (again, <code class="inlineCode">std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;</code> was replaced with <code class="inlineCode">string</code> for simplicity). In cases where <code class="inlineCode">char</code> is the type of the first argument, the type of the return value <code class="inlineCode">head+add</code> <code class="inlineCode">(...)</code>, which is an <code class="inlineCode">std::string</code>, does not match the function return type and does not have an implicit conversion to it:</p>
<pre class="programlisting code"><code class="hljs-code">string add(string head, char arg1, string arg2, char arg3)
{return head + add(arg1, arg2, arg3);}
char add(char head, string arg1, char arg2)
{return head + add(arg1, arg2);}
string add(string head, char arg1)
{return head + add(arg1);}
char add(char value)
{return value;}
</code></pre>
<p class="normal">We can fix this by modifying the variadic function template so that it has <code class="inlineCode">auto</code> for the return type instead of <code class="inlineCode">T</code>. In this case, the return type is always inferred from the return expression, and in our example, it will be <code class="inlineCode">std::string</code> in all cases:</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;typename T, typename... Ts&gt;
auto add(T head, Ts... rest)
{
  return head + add(rest...);
}
</code></pre>
<p class="normal">It should be<a id="_idIndexMarker435"/> further added that a parameter pack can appear in a brace initialization and that its size can be determined using the <code class="inlineCode">sizeof...</code> operator. Also, variadic function templates do not necessarily imply compile-time recursion, as we have shown in this recipe. All these are shown in the following example:</p>
<pre class="programlisting code"><code class="hljs-code">template&lt;typename... T&gt;
auto make_even_tuple(T... a)
{
  static_assert(sizeof...(a) % 2 == 0,
                "expected an even number of arguments");
  std::tuple&lt;T...&gt; t { a... };
  return t;
}
auto t1 = make_even_tuple(1, 2, 3, 4); // OK
// error: expected an even number of arguments
auto t2 = make_even_tuple(1, 2, 3);
</code>
sizeof...(a)</code> to make sure that we have an even number of arguments and assert by generating a compiler error otherwise. The <code class="inlineCode">sizeof...</code> operator can be used with both template parameter packs and function parameter packs. <code class="inlineCode">sizeof...(a)</code> and <code class="inlineCode">sizeof...(T)</code> would produce the same value. Then, we create and return a tuple. </pre>
<p class="normal">The template parameter pack <code class="inlineCode">T</code> is expanded (with <code class="inlineCode">T...</code>) into the type arguments of the <code class="inlineCode">std::tuple</code> class template, and the function parameter pack <code class="inlineCode">a</code> is expanded (with <code class="inlineCode">a...</code>) into the values for the tuple members using brace <a id="_idIndexMarker436"/>initialization.</p>
<h2 class="heading-2" id="_idParaDest-203">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Using fold expressions to simplify variadic function templates</em>, to learn how to write simpler and clearer code when creating function templates with a variable number of arguments</li>
<li class="bulletList"><em class="chapterRef">Chapter 2</em>, <em class="italic">Creating raw user-defined literals</em>, to understand how to provide a custom interpretation of an input sequence so that it changes the normal behavior of the compiler</li>
</ul>
<h1 class="heading-1" id="_idParaDest-204">Using fold expressions to simplify variadic function templates</h1>
<p class="normal">In this chapter, we have already discussed folding several times; this is an operation that applies a binary function to a range of values to produce a single value. We saw this when we discussed variadic function templates and we will see it again with higher-order functions. It turns out there is a significant number of cases where the expansion of a parameter pack in variadic function templates is basically a folding operation. To simplify writing such variadic function templates, C++17 introduced fold expressions, which fold an <a id="_idIndexMarker437"/>expansion of a parameter pack over a binary operator. In this recipe, we will learn how to use fold expressions to simplify writing variadic function templates.</p>
<h2 class="heading-2" id="_idParaDest-205">Getting ready</h2>
<p class="normal">The<a id="_idIndexMarker438"/> examples in this recipe are<a id="_idIndexMarker439"/> based on the variadic function template <code class="inlineCode">add</code> <code class="inlineCode">()</code>, which we wrote in the previous recipe, <em class="italic">Writing a function template with a variable number of arguments</em>. That implementation is a left-folding operation. For simplicity, we’ll present the function again:</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;typename T&gt;
T add(T value)
{
  return value;
}
template &lt;typename T, typename... Ts&gt;
T add(T head, Ts... rest)
{
  return head + add(rest...);
}
</code></pre>
<p class="normal">In the next section, we will learn how this particular implementation can be simplified, as well as other examples of using fold expressions.</p>
<h2 class="heading-2" id="_idParaDest-206">How to do it...</h2>
<p class="normal">To fold <a id="_idIndexMarker440"/>a parameter<a id="_idIndexMarker441"/> pack over a binary operator, use one of the following forms:</p>
<ul>
<li class="bulletList">Left folding with a unary form <code class="inlineCode">(... op pack)</code>:
        <pre class="programlisting code"><code class="hljs-code">template &lt;typename... Ts&gt;
auto add(Ts... args)
{
  return (... + args);
}
</code></pre>
</li>
<li class="bulletList">Left folding with a binary form <code class="inlineCode">(init op ... op pack)</code>:
        <pre class="programlisting code"><code class="hljs-code">template &lt;typename... Ts&gt;
auto add_to_one(Ts... args)
{
  return (1 + ... + args);
}
</code></pre>
</li>
<li class="bulletList">Right folding with a unary form <code class="inlineCode">(pack op ...)</code>:
        <pre class="programlisting code"><code class="hljs-code">template &lt;typename... Ts&gt;
auto add(Ts... args)
{
  return (args + ...);
}
</code></pre>
</li>
<li class="bulletList">Right folding with a binary form <code class="inlineCode">(pack op ... op init)</code>:
        <pre class="programlisting code"><code class="hljs-code">template &lt;typename... Ts&gt;
auto add_to_one(Ts... args)
{
  return (args + ... + 1);
}
</code></pre>
<div><p class="normal">The parentheses shown here are part of the fold expression and cannot be omitted.</p>
</div>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-207">How it works...</h2>
<p class="normal">When the<a id="_idIndexMarker442"/> compiler <a id="_idIndexMarker443"/>encounters a fold expression, it expands it in one of the following expressions:</p>
<table class="table-container" id="table002-1">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Expression</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Expansion</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">(... op pack)</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">((pack$1 op pack$2) op ...) op pack$n</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">(init op ... op pack)</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">(((init op pack$1) op pack$2) op ...) op pack$n</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">(pack op ...)</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">pack$1 op (... op (pack$n-1 op pack$n))</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">(pack op ... op init)</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">pack$1 op (... op (pack$n-1 op (pack$n op init)))</code></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 3.2: The possible forms of a fold expression</p>
<p class="normal">When the binary form is used, the operator on both the left-hand and right-hand sides of the ellipses must be the same, and the initialization value must not contain an unexpanded parameter pack.</p>
<p class="normal">The following binary operators are supported with fold expressions:</p>
<table class="table-container" id="table003-1">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">+</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">-</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">*</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">/</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">%</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">^</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">&amp;</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">|</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">=</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">&lt;</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">&gt;</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">&lt;&lt;</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">&gt;&gt;</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">+=</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">-=</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">*=</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">/=</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">%=</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">^=</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">&amp;=</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">|=</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">&lt;&lt;=</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">&gt;&gt;=</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">==</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">!=</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">&lt;=</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">&gt;=</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">&amp;&amp;</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">||</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">,</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">.*</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">-&gt;*.</code></p>
</td>
<td class="table-cell"/>
<td class="table-cell"/>
<td class="table-cell"/>
<td class="table-cell"/>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 3.3: The binary operator supported with fold expressions</p>
<p class="normal">When using the unary form, only operators such as <code class="inlineCode">*</code>, <code class="inlineCode">+</code>, <code class="inlineCode">&amp;</code>, <code class="inlineCode">|</code>, <code class="inlineCode">&amp;&amp;</code>, <code class="inlineCode">||</code>, and <code class="inlineCode">,</code> (comma) are allowed with an empty parameter pack. In this case, the value of the empty pack is as follows:</p>
<table class="table-container" id="table004-1">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Operator</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Empty pack value</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">+</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">0</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">*</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">1</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">&amp;</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">-1</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">|</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">0</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">&amp;&amp;</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">true</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">||</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">false</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">,</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">void()</code></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 3.4: Operators that can be used with an empty parameter pack</p>
<p class="normal">Now that we have the function templates we implemented earlier (let’s consider the left-folding version), we can write the following code:</p>
<pre class="programlisting code"><code class="hljs-code">auto sum = add(1, 2, 3, 4, 5);         // sum = 15
auto sum1 = add_to_one(1, 2, 3, 4, 5); // sum = 16
</code></pre>
<p class="normal">Considering the <code class="inlineCode">add(1, 2, 3, 4, 5)</code> call, it will produce the following function:</p>
<pre class="programlisting code"><code class="hljs-code">int add(int arg1, int arg2, int arg3, int arg4, int arg5)
{
  return ((((arg1 + arg2) + arg3) + arg4) + arg5);
}
</code></pre>
<p class="normal">It’s worth <a id="_idIndexMarker444"/>mentioning that <a id="_idIndexMarker445"/>due to the aggressive ways modern compilers do optimizations, this function can be inlined and, eventually, we may end up with an expression such as <code class="inlineCode">auto sum = 1 + 2 + 3 + 4 + 5</code>.</p>
<h2 class="heading-2" id="_idParaDest-208">There’s more...</h2>
<p class="normal">Fold expressions<a id="_idIndexMarker446"/> work with all overloads for the supported binary operators, but do not work with arbitrary binary functions. It is possible to implement a workaround for that by providing a wrapper type that will hold a value and an overloaded operator for that wrapper type:</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;typename T&gt;
struct wrapper
{
  T const &amp; value;
};
template &lt;typename T&gt;
constexpr auto operator&lt;(wrapper&lt;T&gt; const &amp; lhs, wrapper&lt;T&gt; const &amp; rhs)
{
  return wrapper&lt;T&gt; {lhs.value &lt; rhs.value ? lhs.value : rhs.value};
}
</code></pre>
<p class="normal">In the preceding code, <code class="inlineCode">wrapper</code> is a simple class template that holds a constant reference to a value of type <code class="inlineCode">T</code>. An overloaded <code class="inlineCode">operator&lt;</code> is provided for this class template; this overload does not return a Boolean to indicate that the first argument is less than the second, but actually an instance of the <code class="inlineCode">wrapper</code> class type to hold the minimum value of the two arguments. The variadic function template <code class="inlineCode">min</code> <code class="inlineCode">()</code>, shown here, uses this overloaded <code class="inlineCode">operator&lt;</code> to fold the pack of arguments expanded to instances of the <code class="inlineCode">wrapper</code> class template:</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;typename... Ts&gt;
constexpr auto min(Ts&amp;&amp;... args)
{
  return (wrapper&lt;Ts&gt;{args} &lt; ...).value;
}
auto m = min(3, 1, 2); // m = 1
</code></pre>
<p class="normal">This <code class="inlineCode">min()</code> function is expanded by the compiler to something that could look like the following:</p>
<pre class="programlisting code"><code class="hljs-code">template&lt;&gt;
inline constexpr int min&lt;int, int, int&gt;(int &amp;&amp; __args0,
                                        int &amp;&amp; __args1,
                                        int &amp;&amp; __args2)
{
  return
operator&lt;(wrapper_min&lt;int&gt;{__args0},
      operator&lt;(wrapper_min&lt;int&gt;{__args1},
                wrapper_min&lt;int&gt;{__args2})).value;
}
</code></pre>
<p class="normal">What we can see here is cascading calls to the binary <code class="inlineCode">operator &lt;</code> that return a <code class="inlineCode">Wrapper&lt;int&gt;</code> value. Without this, an implementation of the <code class="inlineCode">min()</code> function using fold expressions would not be possible. The following implementation does not work:</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;typename... Ts&gt;
constexpr auto minimum(Ts&amp;&amp;... args)
{
  return (args &lt; ...);
}
</code></pre>
<p class="normal">The compiler would transform this, based on the call <code class="inlineCode">min(3, 1, 2)</code>, to something such as the following:</p>
<pre class="programlisting code"><code class="hljs-code">template&lt;&gt;
inline constexpr bool minimum&lt;int, int, int&gt;(int &amp;&amp; __args0,
                                             int &amp;&amp; __args1,
                                             int &amp;&amp; __args2)
{
  return __args0 &lt; (static_cast&lt;int&gt;(__args1 &lt; __args2));
}
</code></pre>
<p class="normal">The result is a function that returns a Boolean, and not the actual integer value, which is the minimum between the supplied arguments.</p>
<h2 class="heading-2" id="_idParaDest-209">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Implementing higher-order functions map and fold</em>, to learn about higher-order functions in functional programming and how to implement the widely used <code class="inlineCode">map</code> and <code class="inlineCode">fold</code> (or <code class="inlineCode">reduce</code>) functions</li>
</ul>
<h1 class="heading-1" id="_idParaDest-210">Implementing the higher-order functions map and fold</h1>
<p class="normal">Throughout the preceding recipes in this book, we have used the general-purpose algorithms <code class="inlineCode">std::transform()</code> and <code class="inlineCode">std::accumulate()</code> in several examples, such as for implementing string utilities to create uppercase or lowercase copies of a string or for summing the values of a range. </p>
<p class="normal">These are basically implementations of the higher-order functions, <code class="inlineCode">map</code> and <code class="inlineCode">fold</code>. A higher-order function<a id="_idIndexMarker447"/> is a function that takes one or <a id="_idIndexMarker448"/>more other functions as arguments and applies them to <a id="_idIndexMarker449"/>a range (a list, vector, map, tree, and so on), thus producing either a new range or a value. In this recipe, we will learn how to implement the <code class="inlineCode">map</code> and <code class="inlineCode">fold</code> functions so that they work with C++ standard containers.</p>
<h2 class="heading-2" id="_idParaDest-211">Getting ready</h2>
<p class="normal"><code class="inlineCode">map</code> is a <a id="_idIndexMarker450"/>higher-order function that applies a function to the elements of a range and returns a new range in the same order.</p>
<p class="normal"><code class="inlineCode">fold</code> is a <a id="_idIndexMarker451"/>higher-order function that applies a combining function to the elements of the range to produce a single result. Since the order of the processing can be important, there are usually two versions of this function. One is <code class="inlineCode">fold_left</code>, which processes elements from left to right, while the other is <code class="inlineCode">fold_right</code>, which combines the elements from right to left.</p>
<div><p class="normal">Most descriptions of the function map indicate that it is applied to a list, but this is a general term that can indicate different sequential types, such as list, vector, and array, and also dictionaries (that is, maps), queues, and so on. For this reason, I prefer to use the term range when describing these higher-order functions.</p>
</div>
<p class="normal">As an example, the mapping operation could transform a range of strings into a range of integers representing the length of each string. The fold operation could then add these lengths to determine the combined length of all the strings.</p>
<h2 class="heading-2" id="_idParaDest-212">How to do it...</h2>
<p class="normal">To<a id="_idIndexMarker452"/> implement the <code class="inlineCode">map</code> function, you should:</p>
<ul>
<li class="bulletList">Use <code class="inlineCode">std::transform</code> on containers that support iterating and assignment to the elements, such as <code class="inlineCode">std::vector</code> or <code class="inlineCode">std::list</code>:
        <pre class="programlisting code"><code class="hljs-code">template &lt;typename F, typename R&gt;
R mapf(F&amp;&amp; func, R range)
{
  std::transform(
    std::begin(range), std::end(range), std::begin(range),
    std::forward&lt;F&gt;(func));
  return range;
}
</code></pre>
</li>
<li class="bulletList">Use other<a id="_idIndexMarker453"/> means such as explicit iteration and insertion for containers that do not support assignment to the elements, such as <code class="inlineCode">std::map</code> and <code class="inlineCode">std::queue</code>:
        <pre class="programlisting code"><code class="hljs-code">template&lt;typename F, typename T, typename U&gt;
std::map&lt;T, U&gt; mapf(F&amp;&amp; func, std::map&lt;T, U&gt; const &amp; m)
{
  std::map&lt;T, U&gt; r;
  for (auto const kvp : m)
    r.insert(func(kvp));
  return r;
}
template&lt;typename F, typename T&gt;
std::queue&lt;T&gt; mapf(F&amp;&amp; func, std::queue&lt;T&gt; q)
{
  std::queue&lt;T&gt; r;
  while (!q.empty())
  {
    r.push(func(q.front()));
    q.pop();
  }
  return r;
}
</code></pre>
</li>
</ul>
<p class="normal">To implement <a id="_idIndexMarker454"/>the <code class="inlineCode">fold</code> function, you should:</p>
<ul>
<li class="bulletList">Use <code class="inlineCode">std::accumulate()</code> on containers that support iterating:
        <pre class="programlisting code"><code class="hljs-code">template &lt;typename F, typename R, typename T&gt;
constexpr T fold_left(F&amp;&amp; func, R&amp;&amp; range, T init)
{
  return std::accumulate(
    std::begin(range), std::end(range),
    std::move(init),
    std::forward&lt;F&gt;(func));
}
template &lt;typename F, typename R, typename T&gt;
constexpr T fold_right(F&amp;&amp; func, R&amp;&amp; range, T init)
{
  return std::accumulate(
    std::rbegin(range), std::rend(range),
    std::move(init),
    std::forward&lt;F&gt;(func));
}
</code></pre>
</li>
<li class="bulletList">Use other <a id="_idIndexMarker455"/>means to explicitly process containers that do not support iterating, such as <code class="inlineCode">std::queue</code>:
        <pre class="programlisting code"><code class="hljs-code">template &lt;typename F, typename T&gt;
constexpr T fold_left(F&amp;&amp; func, std::queue&lt;T&gt; q, T init)
{
  while (!q.empty())
  {
    init = func(init, q.front());
    q.pop();
  }
  return init;
}
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-213">How it works...</h2>
<p class="normal">In the preceding examples, we implemented the <code class="inlineCode">map</code> higher-order function in a functional way, without side effects. This means it preserves the original range and returns a new one. The arguments of the function are the function to apply and the range. In order to avoid confusion with the <code class="inlineCode">std::map</code> container, we have called this function <code class="inlineCode">mapf</code>. There are several overloads<a id="_idIndexMarker456"/> for <code class="inlineCode">mapf</code>, as shown earlier:</p>
<ul>
<li class="bulletList">The first overload is for containers that support iterating and assignment to its elements; this includes <code class="inlineCode">std::vector</code>, <code class="inlineCode">std::list</code>, and <code class="inlineCode">std::array</code>, but also C-like arrays. The function takes an <code class="inlineCode">rvalue</code> reference to a function and a range for which <code class="inlineCode">std::begin()</code> and <code class="inlineCode">std::end()</code> are defined. The range is passed by value so that modifying the local copy does not affect the original range. The range is transformed by applying the given function to each element using the standard algorithm <code class="inlineCode">std::transform()</code>; the transformed range is then returned.</li>
<li class="bulletList">The second overload is specialized for <code class="inlineCode">std::map</code>, which does not support direct assignment to its elements (<code class="inlineCode">std::pair&lt;T, U&gt;</code>). Therefore, this overload creates a new map, then iterates through its elements using a range-based <code class="inlineCode">for</code> loop, and inserts the result of applying the input function to each element of the original map into the new map.</li>
<li class="bulletList">The third overload is specialized for <code class="inlineCode">std::queue</code>, which is a container that does not support iterating. It can be argued that a queue is not a typical structure to map over, but for the sake of demonstrating different possible implementations, we are considering it. In order to iterate over the elements of a queue, the queue must be altered—you need to pop elements from the front until the list is empty. This is what the third overload does—it processes each element of the input queue (passed by value) and pushes the result of applying the given function to the front element of the <a id="_idIndexMarker457"/>remaining queue.</li>
</ul>
<p class="normal">Now that we have these<a id="_idIndexMarker458"/> overloads implemented, we can apply them to a lot of containers, as shown in the following examples:</p>
<ul>
<li class="bulletList">Retain absolute values from a vector. In this example, the vector contains both negative and positive values. After applying the mapping, the result is a new vector with only positive values:
        <pre class="programlisting code"><code class="hljs-code">auto vnums =
  std::vector&lt;int&gt;{0, 2, -3, 5, -1, 6, 8, -4, 9};
auto r =mapf([](int const i) { return std::abs(i); }, vnums);
// r = {0, 2, 3, 5, 1, 6, 8, 4, 9}
</code></pre>
</li>
<li class="bulletList">Square the numerical values of a list. In this example, the list contains integral values. After applying the mapping, the result is a list containing the squares of the initial values:
        <pre class="programlisting code"><code class="hljs-code">auto lnums = std::list&lt;int&gt;{1, 2, 3, 4, 5};
auto l = mapf([](int const i) { return i*i; }, lnums);
// l = {1, 4, 9, 16, 25}
</code></pre>
</li>
<li class="bulletList">Rounded amounts of floating points. For this example, we need to use <code class="inlineCode">std::round()</code>; however, this has overloads for all floating-point types, which makes it impossible for the compiler to pick the right one. As a result, we either have to write a lambda that takes an argument of a specific floating-point type and returns the value of <code class="inlineCode">std::round()</code> applied to that value, or create a function object template that wraps <code class="inlineCode">std::round()</code> and enables its call operator only for floating-point types. This technique is used in the following example:
        <pre class="programlisting code"><code class="hljs-code">template&lt;class T = double&gt;
struct fround
{
  typename std::enable_if_t&lt;std::is_floating_point_v&lt;T&gt;, T&gt;
  operator()(const T&amp; value) const
  {
    return std::round(value);
  }
};
auto amounts =
  std::array&lt;double, 5&gt; {10.42, 2.50, 100.0, 23.75, 12.99};
auto a = mapf(fround&lt;&gt;(), amounts);
// a = {10.0, 3.0, 100.0, 24.0, 13.0}
</code></pre>
</li>
<li class="bulletList">Uppercase<a id="_idIndexMarker459"/> the string keys of a map of words (where the key is the word and the value is the number of appearances in the text). Note that creating an uppercase copy of a string is itself a mapping operation. Therefore, in this example, we use <code class="inlineCode">mapf</code> to apply <code class="inlineCode">toupper()</code> to the elements of the string representing the key in order to produce an uppercase copy:
        <pre class="programlisting code"><code class="hljs-code">auto words = std::map&lt;std::string, int&gt;{
  {"one", 1}, {"two", 2}, {"three", 3}
};
auto m = mapf(
  [](std::pair&lt;std::string, int&gt; const kvp) {
    return std::make_pair(
      funclib::mapf(toupper, kvp.first),
      kvp.second);
    },
    words);
// m = {{"ONE", 1}, {"TWO", 2}, {"THREE", 3}}
</code></pre>
</li>
<li class="bulletList">Normalize<a id="_idIndexMarker460"/> values from a queue of priorities; initially, the values are from 1 to 100, but we want to normalize them into two values, 1=high and 2=normal. All the initial priorities that have a value up to 30 get high priority; the others get normal priority:
        <pre class="programlisting code"><code class="hljs-code">auto priorities = std::queue&lt;int&gt;();
priorities.push(10);
priorities.push(20);
priorities.push(30);
priorities.push(40);
priorities.push(50);
auto p = mapf(
  [](int const i) { return i &gt; 30 ? 2 : 1; },
  priorities);
// p = {1, 1, 1, 2, 2}
</code></pre>
</li>
</ul>
<p class="normal">To implement <code class="inlineCode">fold</code>, we actually have to consider the two possible types of folding—that is, from left to right and from right to left. Therefore, we have provided two functions called <code class="inlineCode">fold_left</code> (for left folding) and <code class="inlineCode">fold_right</code> (for right folding). The implementations shown in the previous section are very similar: they both take a function, range, and initial value and call <code class="inlineCode">std::accumulate()</code> to fold the values of the range into a single value. However, <code class="inlineCode">fold_left</code> uses direct iterators, whereas <code class="inlineCode">fold_right</code> uses reverse iterators to traverse and process the range. The second overload is a specialization for the type <code class="inlineCode">std::queue</code>, which does not have iterators.</p>
<p class="normal">Based on these implementations<a id="_idIndexMarker461"/> for folding, we can implement the following examples:</p>
<ul>
<li class="bulletList">Adding the values of a vector of integers. In this case, both left and right folding will produce the same result. In the following examples, we pass either a lambda that takes a sum and a number and returns a new sum or the function object <code class="inlineCode">std::plus&lt;&gt;</code> from the standard library, which applies <code class="inlineCode">operator+</code> to two operands of the same type (basically similar to the closure of the lambda):
        <pre class="programlisting code"><code class="hljs-code">auto vnums =
  std::vector&lt;int&gt;{0, 2, -3, 5, -1, 6, 8, -4, 9};
auto s1 = fold_left(
  [](const int s, const int n) {return s + n; },
  vnums, 0);                // s1 = 22
auto s2 = fold_left(
  std::plus&lt;&gt;(), vnums, 0); // s2 = 22
auto s3 = fold_right(
  [](const int s, const int n) {return s + n; },
  vnums, 0);                // s3 = 22
auto s4 = fold_right(
  std::plus&lt;&gt;(), vnums, 0); // s4 = 22
</code></pre>
</li>
<li class="bulletList">Concatenating strings from a vector into a single string:
        <pre class="programlisting code"><code class="hljs-code">auto texts =
  std::vector&lt;std::string&gt;{"hello"s, " "s, "world"s, "!"s};
auto txt1 = fold_left(
  [](std::string const &amp; s, std::string const &amp; n) {
  return s + n;},
  texts, ""s);    // txt1 = "hello world!"
auto txt2 = fold_right(
  [](std::string const &amp; s, std::string const &amp; n) {
  return s + n; },
  texts, ""s);    // txt2 = "!world hello"
</code></pre>
</li>
<li class="bulletList">Concatenating an array of characters into a string:
        <pre class="programlisting code"><code class="hljs-code">char chars[] = {'c','i','v','i','c'};
auto str1 = fold_left(std::plus&lt;&gt;(), chars, ""s);
// str1 = "civic"
Auto str2 = fold_right(std::plus&lt;&gt;(), chars, ""s);
// str2 = "civic"
</code></pre>
</li>
<li class="bulletList">Counting the<a id="_idIndexMarker462"/> number of words in text based on their already computed appearances, available in a <code class="inlineCode">map&lt;string, int&gt;</code>:
        <pre class="programlisting code"><code class="hljs-code">auto words = std::map&lt;std::string, int&gt;{
  {"one", 1}, {"two", 2}, {"three", 3} };
auto count = fold_left(
  [](int const s, std::pair&lt;std::string, int&gt; const kvp) {
    return s + kvp.second; },
  words, 0); // count = 6
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-214">There’s more...</h2>
<p class="normal">These functions can be pipelined—that is, they can call one function with the result of another. The following example maps a range of integers into a range of positive integers by applying the <code class="inlineCode">std::abs()</code> function to its elements. The result is then mapped into another range of squares. These are then summed together by applying a left fold on the range:</p>
<pre class="programlisting code"><code class="hljs-code">auto vnums = std::vector&lt;int&gt;{ 0, 2, -3, 5, -1, 6, 8, -4, 9 };
auto s = fold_left(
  std::plus&lt;&gt;(),
  mapf(
    [](int const i) {return i*I; },
    mapf(
      [](int const i) {return std::abs(i); },
      vnums)),
  0); // s = 236
</code></pre>
<p class="normal">As an exercise, we could implement the <code class="inlineCode">fold</code> function as a variadic function template, in the manner seen earlier. The function that performs the actual folding is provided as an argument:</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;typename F, typename T1, typename T2&gt;
auto fold_left(F&amp;&amp;f, T1 arg1, T2 arg2)
{
  return f(arg1, arg2);
}
template &lt;typename F, typename T, typename... Ts&gt;
auto fold_left(F&amp;&amp; f, T head, Ts… rest)
{
  return f(head, fold_left(std::forward&lt;F&gt;(f), rest...));
}
</code></pre>
<p class="normal">When we compare this with the <code class="inlineCode">add()</code> function template that we wrote in the <em class="italic">Writing a function template with a variable number of arguments</em> recipe, we can notice several differences:</p>
<ul>
<li class="bulletList">The first argument is a function, which is perfectly forwarded when calling <code class="inlineCode">fold_left</code> recursively.</li>
<li class="bulletList">The end case is a function that requires two arguments because the function we use for folding is a binary one (taking two arguments).</li>
<li class="bulletList">The return type of the two functions we wrote is declared as <code class="inlineCode">auto</code> because it must match the return type of the supplied binary function <code class="inlineCode">f</code>, which is not known until we call <code class="inlineCode">fold_left</code>.</li>
</ul>
<p class="normal">The <code class="inlineCode">fold_left()</code> function can be used as follows:</p>
<pre class="programlisting code"><code class="hljs-code">auto s1 = fold_left(std::plus&lt;&gt;(), 1, 2, 3, 4, 5);
// s1 = 15
auto s2 = fold_left(std::plus&lt;&gt;(), "hello"s, ' ', "world"s, '!');
// s2 = "hello world!"
auto s3 = fold_left(std::plus&lt;&gt;(), 1); // error, too few arguments
</code></pre>
<p class="normal">Notice that the last call produces a compiler error because the variadic function template <code class="inlineCode">fold_left()</code> requires at least two arguments to be passed in order to invoke the supplied binary function.</p>
<h2 class="heading-2" id="_idParaDest-215">See also</h2>
<ul>
<li class="bulletList"><em class="chapterRef">Chapter 2</em>, <em class="italic">Creating a library of string helpers</em>, to see how to create useful text utilities that are not directly available in the standard library</li>
<li class="bulletList"><em class="italic">Writing a function template with a variable number of arguments</em>, to see how variadic templates enable us to write functions that can take any number of arguments</li>
<li class="bulletList"><em class="italic">Composing functions into a higher-order function</em>, to learn the functional programming technique for creating a new function from one or more other functions</li>
</ul>
<h1 class="heading-1" id="_idParaDest-216">Composing functions into a higher-order function</h1>
<p class="normal">In the previous recipe, we implemented two <a id="_idIndexMarker463"/>higher-order functions, <code class="inlineCode">map</code> and <code class="inlineCode">fold</code>, and saw various examples of using them. At the end of the recipe, we saw how they can be pipelined to produce a final value after several transformations of the original data. Pipelining is a form of composition, which means creating one new function from two or more given functions. In the mentioned example, we didn’t actually compose functions; we only called a function with the result produced by another, but in this recipe, we will learn how to actually compose functions together into a new function. For simplicity, we will only consider unary functions (functions that take only one argument).</p>
<h2 class="heading-2" id="_idParaDest-217">Getting ready</h2>
<p class="normal">Before you go forward, it is recommended that you read the previous recipe, <em class="italic">Implementing the higher-order functions map and fold</em>. It is not mandatory for understanding this recipe, but we will refer to the <code class="inlineCode">map</code> and <code class="inlineCode">fold</code> functions we implemented there.</p>
<h2 class="heading-2" id="_idParaDest-218">How to do it...</h2>
<p class="normal">To compose<a id="_idIndexMarker464"/> unary functions<a id="_idIndexMarker465"/> into a higher-order function, you should do the following:</p>
<ul>
<li class="bulletList">To compose two functions, provide a function that takes two functions, <code class="inlineCode">f</code> and <code class="inlineCode">g</code>, as arguments and returns a new function (a lambda) that returns <code class="inlineCode">f(g(x))</code>, where <code class="inlineCode">x</code> is the argument of the composed function:
        <pre class="programlisting code"><code class="hljs-code">template &lt;typename F, typename G&gt;
auto compose(F&amp;&amp; f, G&amp;&amp; g)
{
  return [=](auto x) { return f(g(x)); };
}
auto v = compose(
  [](int const n) {return std::to_string(n); },
  [](int const n) {return n * n; })(-3); // v = "9"
</code></pre>
</li>
<li class="bulletList">To compose a variable number of functions, provide a variadic template overload of the function described previously:
        <pre class="programlisting code"><code class="hljs-code">template &lt;typename F, typename... R&gt;
auto compose(F&amp;&amp; f, R&amp;&amp;... r)
{
  return [=](auto x) { return f(compose(r...)(x)); };
}
auto n = compose(
  [](int const n) {return std::to_string(n); },
  [](int const n) {return n * n; },
  [](int const n) {return n + n; },
  [](int const n) {return std::abs(n); })(-3); // n = "36"
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-219">How it works...</h2>
<p class="normal">Composing two unary functions into a new one is relatively trivial. Create a template function, which we called <code class="inlineCode">compose()</code> in the earlier examples, with two arguments—<code class="inlineCode">f</code> and <code class="inlineCode">g</code>—that represent functions, and return a function that takes one argument, <code class="inlineCode">x</code>, and returns <code class="inlineCode">f(g(x))</code>. It is important that the type of the value returned by the <code class="inlineCode">g</code> function is the same as the type of the argument of the <code class="inlineCode">f</code> function. The returned value of the compose function is a closure—that is, it’s an instantiation of a lambda.</p>
<p class="normal">In practice, it is useful <a id="_idIndexMarker466"/>to be able to combine more <a id="_idIndexMarker467"/>than just two functions. This can be achieved by writing a variadic template version of the <code class="inlineCode">compose()</code> function. Variadic templates are explained in more detail in the <em class="italic">Writing a function template with a variable number of arguments</em> recipe.</p>
<p class="normal">Variadic<a id="_idIndexMarker468"/> templates imply compile-time recursion by expanding the parameter pack. This implementation is very similar to the first version of <code class="inlineCode">compose()</code>, except for the following:</p>
<ul>
<li class="bulletList">It takes a variable number of functions as arguments.</li>
<li class="bulletList">The returned closure calls <code class="inlineCode">compose()</code> recursively with the expanded parameter pack; recursion ends when only two functions are left, in which case the previously implemented overload is called.</li>
</ul>
<p class="normal">Even if the code looks like recursion is happening, this is not true recursion. It could be called compile-time recursion, but with every expansion, we get a call to another method with the same name but a different number of arguments, which does not represent recursion.</p>
<p class="normal">Now that we have these variadic template<a id="_idIndexMarker469"/> overloads implemented, we can rewrite the last example from the previous recipe, <em class="italic">Implementing the higher-order functions map and fold</em>. Refer to the following snippet:</p>
<pre class="programlisting code"><code class="hljs-code">auto s = compose(
  [](std::vector&lt;int&gt; const &amp; v) {
    return fold_left(std::plus&lt;&gt;(), v, 0); },
  [](std::vector&lt;int&gt; const &amp; v) {
    return mapf([](int const i) {return i + i; }, v); },
  [](std::vector&lt;int&gt; const &amp; v) {
    return mapf([](int const i) {return std::abs(i); }, v); })(vnums);
</code></pre>
<p class="normal">Having an initial <a id="_idIndexMarker470"/>vector of integers, we map it to a <a id="_idIndexMarker471"/>new vector with only positive values by applying <code class="inlineCode">std::abs()</code> to each element. The result is then mapped to a new vector by doubling the value of each element. Finally, the values in the resulting vector are folded together by adding them to the initial value, <code class="inlineCode">0</code>.</p>
<h2 class="heading-2" id="_idParaDest-220">There’s more...</h2>
<p class="normal">Composition<a id="_idIndexMarker472"/> is usually represented by a dot (<code class="inlineCode">.</code>) or asterisk (<code class="inlineCode">*</code>), such as <code class="inlineCode">f . g</code> or <code class="inlineCode">f * g</code>. We can actually do something similar in C++ by overloading <code class="inlineCode">operator*</code> (it would make little sense to try to overload the operator dot). Similar to the <code class="inlineCode">compose()</code> function, <code class="inlineCode">operator*</code> should work with any number of arguments; therefore, we will have two overloads, just like in the case of <code class="inlineCode">compose()</code>:</p>
<ul>
<li class="bulletList">The first overload takes two arguments and calls <code class="inlineCode">compose()</code> to return a new function.</li>
<li class="bulletList">The second overload is a variadic template function that, again, calls <code class="inlineCode">operator*</code> by expanding the parameter pack.</li>
</ul>
<p class="normal">Based on these considerations, we can implement <code class="inlineCode">operator*</code> as follows:</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;typename F, typename G&gt;
auto operator*(F&amp;&amp; f, G&amp;&amp; g)
{
  return compose(std::forward&lt;F&gt;(f), std::forward&lt;G&gt;(g));
}
template &lt;typename F, typename... R&gt;
auto operator*(F&amp;&amp; f, R&amp;&amp;... r)
{
  return operator*(std::forward&lt;F&gt;(f), r...);
}
</code></pre>
<p class="normal">We can now simplify the actual composition of functions by applying <code class="inlineCode">operator*</code> instead of the more verbose call to <code class="inlineCode">compose()</code>:</p>
<pre class="programlisting code"><code class="hljs-code">auto n =
  ([](int const n) {return std::to_string(n); } *
   [](int const n) {return n * n; } *
   [](int const n) {return n + n; } *
   [](int const n) {return std::abs(n); })(-3); // n = "36"
auto c =
  [](std::vector&lt;int&gt; const &amp; v) {
    return fold_left(std::plus&lt;&gt;(), v, 0); } *
  [](std::vector&lt;int&gt; const &amp; v) {
    return mapf([](int const i) {return i + i; }, v); } *
  [](std::vector&lt;int&gt; const &amp; v) {
    return mapf([](int const i) {return std::abs(i); }, v); };
auto vnums = std::vector&lt;int&gt;{ 2, -3, 5 };
auto s = c(vnums); // s = 20
</code></pre>
<p class="normal">Although it may not be intuitive at first glance, the functions are applied in reverse order rather than the one shown in the text. For instance, in the first example, the absolute value of the argument is retained. Then, the result is doubled, and the result of that operation is then multiplied by itself. Finally, the result is converted to a string. For the supplied argument, <code class="inlineCode">-3</code>, the final result is the string <code class="inlineCode">"36"</code>.</p>
<h2 class="heading-2" id="_idParaDest-221">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Writing a function template with a variable number of arguments</em>, to see how variadic templates enable us to write functions that can take any number of arguments</li>
</ul>
<h1 class="heading-1" id="_idParaDest-222">Uniformly invoking anything callable</h1>
<p class="normal">Developers, especially those who implement libraries, sometimes need to invoke a callable object <a id="_idIndexMarker473"/>in a uniform manner. This can be a function, a pointer to a function, a pointer to a member function, or a function object. Examples of such cases include <code class="inlineCode">std::bind</code>, <code class="inlineCode">std::function</code>, <code class="inlineCode">std::mem_fn</code>, and <code class="inlineCode">std::thread::thread</code>. C++17 defines a standard function called <code class="inlineCode">std::invoke()</code> that can invoke any callable object with the provided arguments. This is not intended to replace direct calls to functions or function objects, but it is useful in template metaprogramming for implementing various library functions.</p>
<h2 class="heading-2" id="_idParaDest-223">Getting ready</h2>
<p class="normal">For this recipe, you should be familiar with how to define and use function pointers.</p>
<p class="normal">To exemplify how <code class="inlineCode">std::invoke()</code> can be used in different contexts, we will use the following function and class:</p>
<pre class="programlisting code"><code class="hljs-code">int add(int const a, int const b)
{
  return a + b;
}
struct foo
{
  int x = 0;
  void increment_by(int const n) { x += n; }
};
</code></pre>
<p class="normal">In the next section, we’ll explore the possible use cases for the <code class="inlineCode">std::invoke()</code> function.</p>
<h2 class="heading-2" id="_idParaDest-224">How to do it...</h2>
<p class="normal">The <code class="inlineCode">std::invoke()</code> function<a id="_idIndexMarker474"/> is a <a id="_idIndexMarker475"/>variadic function template that takes the callable object as the first argument and a variable list of arguments that are passed to the call. <code class="inlineCode">std::invoke()</code> can be used to call the following:</p>
<ul>
<li class="bulletList">Free functions:
        <pre class="programlisting code"><code class="hljs-code">auto a1 = std::invoke(add, 1, 2);   // a1 = 3
</code></pre>
</li>
<li class="bulletList">Free functions through a pointer to function:
        <pre class="programlisting code"><code class="hljs-code">auto a2 = std::invoke(&amp;add, 1, 2);  // a2 = 3
int(*fadd)(int const, int const) = &amp;add;
auto a3 = std::invoke(fadd, 1, 2);  // a3 = 3
</code></pre>
</li>
<li class="bulletList">Member functions through a pointer to member function:
        <pre class="programlisting code"><code class="hljs-code">foo f;
std::invoke(&amp;foo::increment_by, f, 10);
</code></pre>
</li>
<li class="bulletList">Data members:
        <pre class="programlisting code"><code class="hljs-code">foo f;
auto x1 = std::invoke(&amp;foo::x, f);  // x1 = 0
</code></pre>
</li>
<li class="bulletList">Function objects:
        <pre class="programlisting code"><code class="hljs-code">foo f;
auto x3 = std::invoke(std::plus&lt;&gt;(),
  std::invoke(&amp;foo::x, f), 3); // x3 = 3
</code></pre>
</li>
<li class="bulletList">Lambda expressions:
        <pre class="programlisting code"><code class="hljs-code">auto l = [](auto a, auto b) {return a + b; };
auto a = std::invoke(l, 1, 2); // a = 3
</code></pre>
</li>
</ul>
<p class="normal">In practice, <code class="inlineCode">std:invoke()</code> should <a id="_idIndexMarker476"/>be used in template metaprogramming to invoke a function with an arbitrary number of arguments. To exemplify such a case, we’ll present a possible implementation for our <code class="inlineCode">std::apply()</code> function, and also a part of the standard library, as of C++17, that calls a function by unpacking the members of a tuple into the arguments of the function:</p>
<pre class="programlisting code"><code class="hljs-code">namespace details
{
  template &lt;class F, class T, std::size_t... I&gt;
  auto apply(F&amp;&amp; f, T&amp;&amp; t, std::index_sequence&lt;I...&gt;)
 {
    return std::invoke(
      std::forward&lt;F&gt;(f),
      std::get&lt;I&gt;(std::forward&lt;T&gt;(t))...);
  }
}
template &lt;class F, class T&gt;
auto apply(F&amp;&amp; f, T&amp;&amp; t)
{
  return details::apply(
    std::forward&lt;F&gt;(f),
    std::forward&lt;T&gt;(t),
    std::make_index_sequence&lt;
      std::tuple_size_v&lt;std::decay_t&lt;T&gt;&gt;&gt; {}); 
}
</code></pre>
<h2 class="heading-2" id="_idParaDest-225">How it works...</h2>
<p class="normal">Before we <a id="_idIndexMarker477"/>see how <code class="inlineCode">std::invoke()</code> works, let’s have a quick look at how <a id="_idIndexMarker478"/>different callable objects can be invoked. Given a function, obviously, the ubiquitous way of invoking it is by directly passing it the necessary parameters. However, we can also invoke the function using function pointers. The trouble with function pointers is that defining the type of the pointer can be cumbersome. Using <code class="inlineCode">auto</code> can simplify things (as shown in the following code), but in practice, you usually need to define the type of the pointer to function first, and then define an object and initialize it with the correct function address. Here are several examples:</p>
<pre class="programlisting code"><code class="hljs-code">// direct call
auto a1 = add(1, 2);    // a1 = 3
// call through function pointer
int(*fadd)(int const, int const) = &amp;add;
auto a2 = fadd(1, 2);   // a2 = 3
auto fadd2 = &amp;add;
auto a3 = fadd2(1, 2);  // a3 = 3
</code></pre>
<p class="normal">Calling through a function pointer becomes more cumbersome when you need to invoke a class function through an object that is an instance of the class. The syntax for defining the pointer to a member function and invoking it is not simple:</p>
<pre class="programlisting code"><code class="hljs-code">foo f;
f.increment_by(3);
auto x1 = f.x;    // x1 = 3
void(foo::*finc)(int const) = &amp;foo::increment_by;
(f.*finc)(3);
auto x2 = f.x;    // x2 = 6
auto finc2 = &amp;foo::increment_by;
(f.*finc2)(3);
auto x3 = f.x;    // x3 = 9
</code></pre>
<p class="normal">Regardless of how<a id="_idIndexMarker479"/> cumbersome this kind of call may look, the actual problem is writing library components (functions or classes) that are able to call any of these types of callable objects, in a uniform manner. This is what benefits, in practice, from a standard function, such as <code class="inlineCode">std::invoke()</code>.</p>
<p class="normal">The implementation <a id="_idIndexMarker480"/>details of <code class="inlineCode">std::invoke()</code> are complex, but the way it works can be explained in simple terms. Supposing the call has the form <code class="inlineCode">invoke(f, arg1, arg2, ..., argN)</code>, then consider the following:</p>
<ul>
<li class="bulletList">If <code class="inlineCode">f</code> is a pointer to a member function of a <code class="inlineCode">T</code> class, then the call is equivalent to either:<ul>
<li class="bulletList"><code class="inlineCode">(arg1.*f)(arg2, ..., argN)</code>, if <code class="inlineCode">arg1</code> is an instance of <code class="inlineCode">T</code></li>
<li class="bulletList"><code class="inlineCode">(arg1.get().*f)(arg2, ..., argN)</code>, if <code class="inlineCode">arg1</code> is a specialization of <code class="inlineCode">reference_wrapper</code></li>
<li class="bulletList"><code class="inlineCode">((*arg1).*f)(arg2, ..., argN)</code>, if it is otherwise</li>
</ul>
</li>
<li class="bulletList">If <code class="inlineCode">f</code> is a pointer to a data member of a <code class="inlineCode">T</code> class and there is a single argument—in other words, the call has the form <code class="inlineCode">invoke(f, arg1)</code>—then the call is equivalent to either:<ul>
<li class="bulletList"><code class="inlineCode">arg1.*f</code> if <code class="inlineCode">arg1</code> is an instance class <code class="inlineCode">T</code></li>
<li class="bulletList"><code class="inlineCode">arg1.get().*f</code> if <code class="inlineCode">arg1</code> is a specialization of <code class="inlineCode">reference_wrapper</code></li>
<li class="bulletList"><code class="inlineCode">(*arg1).*f</code>, if it is otherwise</li>
</ul>
</li>
<li class="bulletList">If <code class="inlineCode">f</code> is a function object, then the call is equivalent to <code class="inlineCode">f(arg1, arg2, ..., argN)</code></li>
</ul>
<p class="normal">The standard library also provides a series of related type traits: <code class="inlineCode">std::is_invocable</code> and <code class="inlineCode">std::is_nothrow_invocable</code> on the one hand, and <code class="inlineCode">std::is_invocable_r</code> and <code class="inlineCode">std::is_nothrow_invocable_r</code> on the other hand. The first set determines whether a function can be invocable with the supplied arguments, while the second determines whether it can be invocable with the supplied arguments and produce a result that can be implicitly converted to a specified type. The <em class="italic">nothrow</em> versions of these type traits verify that the call can be done without any exception being thrown.</p>
<p class="normal">As of C++20, the <code class="inlineCode">std::invoke</code> function <a id="_idIndexMarker481"/>is <code class="inlineCode">constexpr</code>, which means it can be used to invoke callable objects at compile-time.</p>
<p class="normal">In C++23, a similar<a id="_idIndexMarker482"/> utility called <code class="inlineCode">std::invoke_r</code> has been added. This has one additional template <a id="_idIndexMarker483"/>parameter (the first one), which is a type template parameter that represents the type of the return value (unless it is <code class="inlineCode">void</code>) or a type to which the return value can be implicitly converted.</p>
<h2 class="heading-2" id="_idParaDest-226">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Writing a function template with a variable number of arguments</em>, to see how variadic templates enable us to write functions that can take any number of arguments</li>
</ul>
<h1 class="heading-1">Learn more on Discord</h1>
<p class="normal">Join our community’s Discord space for discussions with the author and other readers:</p>
<p class="normal"><a href="Chapter_03.xhtml">https://discord.gg/7xRaTCeEhx</a></p>
<p class="normal"><img alt="" src="img/QR_Code2659294082093549796.png"/></p>
</div>
</body></html>