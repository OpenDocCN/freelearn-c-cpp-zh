<html><head></head><body>
<div class="Basic-Text-Frame" id="_idContainer066">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">3</span></h1>
<h1 class="chapterTitle" id="_idParaDest-174"><span class="koboSpan" id="kobo.2.1">Exploring Functions</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">Functions</span><a id="_idIndexMarker348"/><span class="koboSpan" id="kobo.4.1"> are a fundamental concept in programming; regardless of what topic we are discussing, we will end up talking about functions. </span><span class="koboSpan" id="kobo.4.2">Trying to cover everything about functions in a single chapter is not only hard but also not very rational. </span><span class="koboSpan" id="kobo.4.3">Being a fundamental element of the language, functions are encountered in every recipe in this book. </span><span class="koboSpan" id="kobo.4.4">This chapter, however, covers modern language features related to functions and callable objects, with a focus on lambda expressions, concepts from functional languages such as higher-order functions, and function templates.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5.1">The recipes included in this chapter are as follows:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.6.1">Defaulted and deleted functions</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.7.1">Using lambdas with standard algorithms</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.8.1">Using generic and template lambdas</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.9.1">Writing a recursive lambda</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.10.1">Writing function templates</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.11.1">Writing a function template with a variable number of arguments</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.12.1">Using fold expressions to simplify variadic function templates</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.13.1">Implementing the higher-order functions </span><code class="inlineCode"><span class="koboSpan" id="kobo.14.1">map</span></code><span class="koboSpan" id="kobo.15.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.16.1">fold</span></code></li>
<li class="bulletList"><span class="koboSpan" id="kobo.17.1">Composing functions into a higher-order function</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.18.1">Uniformly invoking anything callable</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.19.1">We will start this chapter by learning about a feature that makes it easier for us to provide special class member functions or prevent any function (member or non-member) from being invoked.</span></p>
<h1 class="heading-1" id="_idParaDest-175"><span class="koboSpan" id="kobo.20.1">Defaulted and deleted functions</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.21.1">In C++, classes have special members (constructors, a destructor, and assignment operators) that may be either implemented by default by the compiler or supplied by the developer. </span><span class="koboSpan" id="kobo.21.2">However, the rules for what can be default implemented are a bit complicated and can lead to problems. </span><span class="koboSpan" id="kobo.21.3">On the other hand, developers sometimes want to prevent objects from being copied, moved, or constructed in a particular way. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.22.1">This is possible by implementing different tricks using these special members. </span><span class="koboSpan" id="kobo.22.2">The C++11 standard has simplified many of these by allowing functions to be deleted or defaulted in the manner we will see in the next section.</span></p>
<h2 class="heading-2" id="_idParaDest-176"><span class="koboSpan" id="kobo.23.1">Getting started</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.24.1">For this recipe, you need to be familiar with the following concepts:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.25.1">Special </span><a id="_idIndexMarker349"/><span class="koboSpan" id="kobo.26.1">member functions (default constructor, destructor, copy constructor, move constructor, copy assignment operator, and move assignment operator)</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.27.1">The copyable</span><a id="_idIndexMarker350"/><span class="koboSpan" id="kobo.28.1"> concept (a class features a copy constructor and copy assignment operator, making it possible to create copies)</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.29.1">The movable</span><a id="_idIndexMarker351"/><span class="koboSpan" id="kobo.30.1"> concept (a class features a move constructor and a move assignment operator, making it possible to move objects)</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.31.1">With this in mind, let’s learn how to define default and deleted special functions.</span></p>
<h2 class="heading-2" id="_idParaDest-177"><span class="koboSpan" id="kobo.32.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.33.1">Use the following syntax to specify how functions should be handled:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.34.1">To default a</span><a id="_idIndexMarker352"/><span class="koboSpan" id="kobo.35.1"> function, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.36.1">=default</span></code><span class="koboSpan" id="kobo.37.1"> instead of the function body. </span><span class="koboSpan" id="kobo.37.2">Only special class member functions for which the compiler can provide default implementations can be defaulted:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.38.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.39.1">foo</span></span><span class="koboSpan" id="kobo.40.1">
{
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.41.1">foo</span></span><span class="koboSpan" id="kobo.42.1">() = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.43.1">default</span></span><span class="koboSpan" id="kobo.44.1">;
};
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.45.1">To delete a </span><a id="_idIndexMarker353"/><span class="koboSpan" id="kobo.46.1">function, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.47.1">=delete</span></code><span class="koboSpan" id="kobo.48.1"> instead of the function body. </span><span class="koboSpan" id="kobo.48.2">Any function, including non-member functions, can be deleted:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.49.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.50.1">foo</span></span><span class="koboSpan" id="kobo.51.1">
{
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.52.1">foo</span></span><span class="koboSpan" id="kobo.53.1">(foo </span><span class="hljs-type"><span class="koboSpan" id="kobo.54.1">const</span></span><span class="koboSpan" id="kobo.55.1"> &amp;) = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.56.1">delete</span></span><span class="koboSpan" id="kobo.57.1">;
};
</span><span class="hljs-type"><span class="koboSpan" id="kobo.58.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.59.1">func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.60.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.61.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.62.1">)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.63.1">= </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.64.1">delete</span></span><span class="koboSpan" id="kobo.65.1">;
</span></code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.66.1">Use defaulted and</span><a id="_idIndexMarker354"/><span class="koboSpan" id="kobo.67.1"> deleted </span><a id="_idIndexMarker355"/><span class="koboSpan" id="kobo.68.1">functions to achieve various design goals, such as the following examples:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.69.1">To implement a class that is not copyable and implicitly not movable, declare the copy constructor and the copy assignment operator as deleted:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.70.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.71.1">foo_not_copyable</span></span><span class="koboSpan" id="kobo.72.1">
{
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.73.1">public</span></span><span class="koboSpan" id="kobo.74.1">:
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.75.1">foo_not_copyable</span></span><span class="koboSpan" id="kobo.76.1">() = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.77.1">default</span></span><span class="koboSpan" id="kobo.78.1">;
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.79.1">foo_not_copyable</span></span><span class="koboSpan" id="kobo.80.1">(foo_not_copyable </span><span class="hljs-type"><span class="koboSpan" id="kobo.81.1">const</span></span><span class="koboSpan" id="kobo.82.1"> &amp;) = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.83.1">delete</span></span><span class="koboSpan" id="kobo.84.1">;
  foo_not_copyable&amp; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.85.1">operator</span></span><span class="koboSpan" id="kobo.86.1">=(foo_not_copyable </span><span class="hljs-type"><span class="koboSpan" id="kobo.87.1">const</span></span><span class="koboSpan" id="kobo.88.1">&amp;) = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.89.1">delete</span></span><span class="koboSpan" id="kobo.90.1">;
};
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.91.1">To implement a class that is not copyable but is movable, declare the copy operations as deleted and explicitly implement the move operations (and provide any additional constructors that are needed):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.92.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.93.1">data_wrapper</span></span><span class="koboSpan" id="kobo.94.1">
{
  Data* data;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.95.1">public</span></span><span class="koboSpan" id="kobo.96.1">:
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.97.1">data_wrapper</span></span><span class="koboSpan" id="kobo.98.1">(Data* d = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.99.1">nullptr</span></span><span class="koboSpan" id="kobo.100.1">) : </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.101.1">data</span></span><span class="koboSpan" id="kobo.102.1">(d) {}
  ~</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.103.1">data_wrapper</span></span><span class="koboSpan" id="kobo.104.1">() { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.105.1">delete</span></span><span class="koboSpan" id="kobo.106.1"> data; }
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.107.1">data_wrapper</span></span><span class="koboSpan" id="kobo.108.1">(data_wrapper </span><span class="hljs-type"><span class="koboSpan" id="kobo.109.1">const</span></span><span class="koboSpan" id="kobo.110.1">&amp;) = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.111.1">delete</span></span><span class="koboSpan" id="kobo.112.1">;
  data_wrapper&amp; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.113.1">operator</span></span><span class="koboSpan" id="kobo.114.1">=(data_wrapper </span><span class="hljs-type"><span class="koboSpan" id="kobo.115.1">const</span></span><span class="koboSpan" id="kobo.116.1"> &amp;) = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.117.1">delete</span></span><span class="koboSpan" id="kobo.118.1">;
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.119.1">data_wrapper</span></span><span class="koboSpan" id="kobo.120.1">(data_wrapper&amp;&amp; other)  
</span><span class="hljs-built_in"> </span><span class="koboSpan" id="kobo.121.1">:</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.122.1">data</span></span><span class="koboSpan" id="kobo.123.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.124.1">move</span></span><span class="koboSpan" id="kobo.125.1">(other.data))
  {
    other.data = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.126.1">nullptr</span></span><span class="koboSpan" id="kobo.127.1">;
  }
  data_wrapper&amp; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.128.1">operator</span></span><span class="koboSpan" id="kobo.129.1">=(data_wrapper&amp;&amp; other)
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.130.1">if</span></span><span class="koboSpan" id="kobo.131.1"> (data != other.data))
    {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.132.1">delete</span></span><span class="koboSpan" id="kobo.133.1"> data;
      data = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.134.1">move</span></span><span class="koboSpan" id="kobo.135.1">(other.data);
      other.data = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.136.1">nullptr</span></span><span class="koboSpan" id="kobo.137.1">;
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.138.1">return</span></span><span class="koboSpan" id="kobo.139.1"> *</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.140.1">this</span></span><span class="koboSpan" id="kobo.141.1">;
  }
};
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.142.1">To ensure a function is called only with objects of a specific type, and perhaps prevent type promotion, provide deleted overloads for the function (the following example with free functions can also be applied to any class member functions):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.143.1">template</span></span><span class="koboSpan" id="kobo.144.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.145.1">typename</span></span><span class="koboSpan" id="kobo.146.1"> T&gt;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.147.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.148.1">run</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.149.1">(T val)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.150.1">= </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.151.1">delete</span></span><span class="koboSpan" id="kobo.152.1">;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.153.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.154.1">run</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.155.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.156.1">long</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.157.1"> val)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.158.1">{} </span><span class="hljs-comment"><span class="koboSpan" id="kobo.159.1">// can only be called with long integers</span></span>
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-178"><span class="koboSpan" id="kobo.160.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.161.1">A</span><a id="_idIndexMarker356"/><span class="koboSpan" id="kobo.162.1"> class has several </span><a id="_idIndexMarker357"/><span class="koboSpan" id="kobo.163.1">special members that can be implemented, by default, by the compiler. </span><span class="koboSpan" id="kobo.163.2">These are the default constructor, copy constructor, move constructor, copy assignment, move assignment, and destructor (for a discussion on move semantics, refer to the </span><em class="italic"><span class="koboSpan" id="kobo.164.1">Implementing move semantics</span></em><span class="koboSpan" id="kobo.165.1"> recipe in </span><em class="chapterRef"><span class="koboSpan" id="kobo.166.1">Chapter 9</span></em><span class="koboSpan" id="kobo.167.1">, </span><em class="italic"><span class="koboSpan" id="kobo.168.1">Robustness and Performance</span></em><span class="koboSpan" id="kobo.169.1">). </span><span class="koboSpan" id="kobo.169.2">If you don’t implement them, then the compiler does it so that, if needed, instances of a class can be created, moved, copied, and destructed. </span><span class="koboSpan" id="kobo.169.3">However, if you explicitly provide one or more of these special methods, then the compiler will not generate the others according to the following rules:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.170.1">If a user-defined constructor exists, the default constructor is not generated by default.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.171.1">If a user-defined virtual destructor exists, the default destructor is not generated.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.172.1">If a user-defined move constructor or move assignment operator exists, then the copy constructor and copy assignment operator are not generated by default.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.173.1">If a user-defined copy constructor, move constructor, copy assignment operator, move assignment operator, or destructor exists, then the move constructor and move assignment operator are not generated by default.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.174.1">If a user-defined copy constructor or destructor exists, then the copy assignment operator is generated by default.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.175.1">If a user-defined copy assignment operator or destructor exists, then the copy constructor is generated by default.</span></li>
</ul>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.176.1">Note that the last two rules in the preceding list are deprecated rules and may no longer be supported by your compiler.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.177.1">Sometimes, developers need to provide empty implementations of these special members or hide them in order to prevent the instances of the class from being constructed in a specific manner. </span><span class="koboSpan" id="kobo.177.2">A typical example is a class that is not supposed to be copyable. </span><span class="koboSpan" id="kobo.177.3">The classical pattern for this is to provide a default constructor and hide the copy constructor and copy assignment operators. </span><span class="koboSpan" id="kobo.177.4">While this works, the explicitly defined default</span><a id="_idIndexMarker358"/><span class="koboSpan" id="kobo.178.1"> constructor ensures the class is no longer considered trivial and, therefore, a </span><strong class="keyWord"><span class="koboSpan" id="kobo.179.1">Plain Old Data</span></strong><span class="koboSpan" id="kobo.180.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.181.1">POD</span></strong><span class="koboSpan" id="kobo.182.1">) type. </span><span class="koboSpan" id="kobo.182.2">The modern alternative to this is using a deleted function, as shown in the preceding section.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.183.1">When the </span><a id="_idIndexMarker359"/><span class="koboSpan" id="kobo.184.1">compiler </span><a id="_idIndexMarker360"/><span class="koboSpan" id="kobo.185.1">encounters </span><code class="inlineCode"><span class="koboSpan" id="kobo.186.1">=default</span></code><span class="koboSpan" id="kobo.187.1"> in the definition of a function, it will provide the default implementation. </span><span class="koboSpan" id="kobo.187.2">The rules for special member functions mentioned earlier still apply. </span><span class="koboSpan" id="kobo.187.3">Functions can be declared </span><code class="inlineCode"><span class="koboSpan" id="kobo.188.1">=default</span></code><span class="koboSpan" id="kobo.189.1"> outside the body of a class if and only if they are inlined:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.190.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.191.1">foo</span></span><span class="koboSpan" id="kobo.192.1">
{
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.193.1">public</span></span><span class="koboSpan" id="kobo.194.1">:
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.195.1">foo</span></span><span class="koboSpan" id="kobo.196.1">() = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.197.1">default</span></span><span class="koboSpan" id="kobo.198.1">;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.199.1">inline</span></span><span class="koboSpan" id="kobo.200.1"> foo&amp; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.201.1">operator</span></span><span class="koboSpan" id="kobo.202.1">=(foo </span><span class="hljs-type"><span class="koboSpan" id="kobo.203.1">const</span></span><span class="koboSpan" id="kobo.204.1"> &amp;);
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.205.1">inline</span></span><span class="koboSpan" id="kobo.206.1"> foo&amp; foo::</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.207.1">operator</span></span><span class="koboSpan" id="kobo.208.1">=(foo </span><span class="hljs-type"><span class="koboSpan" id="kobo.209.1">const</span></span><span class="koboSpan" id="kobo.210.1"> &amp;) = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.211.1">default</span></span><span class="koboSpan" id="kobo.212.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.213.1">The defaulted implementations have several benefits, including the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.214.1">Can be more efficient than the explicit ones.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.215.1">Non-defaulted implementations, even if they are empty, are considered non-trivial, and that affects the semantics of the type, which becomes non-trivial (and, therefore, non-POD).</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.216.1">Helps the user not write explicit default implementations. </span><span class="koboSpan" id="kobo.216.2">For instance, if a user-defined move constructor is present, then the copy constructor and the copy assignment operator are not provided by default by the compiler. </span><span class="koboSpan" id="kobo.216.3">However, you can still default explicitly and ask the compiler to provide them so that you don’t have to do it manually.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.217.1">When the </span><a id="_idIndexMarker361"/><span class="koboSpan" id="kobo.218.1">compiler encounters </span><code class="inlineCode"><span class="koboSpan" id="kobo.219.1">=delete</span></code><span class="koboSpan" id="kobo.220.1"> in the definition of a function, it will prevent the calling of the</span><a id="_idIndexMarker362"/><span class="koboSpan" id="kobo.221.1"> function. </span><span class="koboSpan" id="kobo.221.2">However, the function is still considered during overload resolution, and only if the deleted function is the best match does the compiler generate an error. </span><span class="koboSpan" id="kobo.221.3">For example, by giving the previously defined overloads for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.222.1">run()</span></code><span class="koboSpan" id="kobo.223.1"> function, only calls with long integers are possible. </span><span class="koboSpan" id="kobo.223.2">Calls with arguments of any other type (including </span><code class="inlineCode"><span class="koboSpan" id="kobo.224.1">int</span></code><span class="koboSpan" id="kobo.225.1">, for which an automatic type promotion to </span><code class="inlineCode"><span class="koboSpan" id="kobo.226.1">long</span></code><span class="koboSpan" id="kobo.227.1"> exists) will determine a deleted overload to be considered the best match and, therefore, the compiler will generate an error:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.228.1">run</span></span><span class="koboSpan" id="kobo.229.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.230.1">42</span></span><span class="koboSpan" id="kobo.231.1">);  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.232.1">// error, matches a deleted overload</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.233.1">run</span></span><span class="koboSpan" id="kobo.234.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.235.1">42L</span></span><span class="koboSpan" id="kobo.236.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.237.1">// OK, long integer arguments are allowed</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.238.1">Note that previously declared functions cannot be deleted as the </span><code class="inlineCode"><span class="koboSpan" id="kobo.239.1">=delete</span></code><span class="koboSpan" id="kobo.240.1"> definition must be the first declaration in a translation unit:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.241.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.242.1">forward_declared_function</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.243.1">()</span></span><span class="koboSpan" id="kobo.244.1">;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.245.1">// ...</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.246.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.247.1">forward_declared_function</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.248.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.249.1">= </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.250.1">delete</span></span><span class="koboSpan" id="kobo.251.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.252.1">// error</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.253.1">The rule of thumb (also known as the</span><em class="italic"><span class="koboSpan" id="kobo.254.1"> Rule of Five</span></em><span class="koboSpan" id="kobo.255.1">) for</span><a id="_idIndexMarker363"/><span class="koboSpan" id="kobo.256.1"> class special member functions is that if you explicitly define any copy constructor, move constructor, copy assignment operator, move assignment operator, or destructor, then you must either explicitly define or default all of them.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.257.1">The user-defined destructor, copy-constructor, and copy assignment operator are necessary because objects are constructed from copies in various situations (like passing parameters to functions). </span><span class="koboSpan" id="kobo.257.2">If they are not user-defined, they are provided by the compiler, but their default implementation may be wrong. </span><span class="koboSpan" id="kobo.257.3">If the class manages resources, then the default implementation does a shallow copy, meaning that it copies the value of the handle of the resource (such as a pointer to an object) and not the resource itself. </span><span class="koboSpan" id="kobo.257.4">In such cases, a user-defined implementation must do a deep copy that copies the resource, not the handle to it. </span><span class="koboSpan" id="kobo.257.5">The presence of the move constructor and move assignment operator are desirable in this case because they represent a performance improvement. </span><span class="koboSpan" id="kobo.257.6">Lacking these two is not an error but a missed optimization opportunity.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.258.1">Opposed to the </span><a id="_idIndexMarker364"/><span class="koboSpan" id="kobo.259.1">Rule of Five on the one hand but complementing it on the other is the </span><a id="_idIndexMarker365"/><span class="koboSpan" id="kobo.260.1">so-called </span><em class="italic"><span class="koboSpan" id="kobo.261.1">Rule of Zero</span></em><span class="koboSpan" id="kobo.262.1">. </span><span class="koboSpan" id="kobo.262.2">This rule states that unless a class deals with ownership of resources, it should have no custom destructors, copy and move constructors, and, respectively, copy and move assignment operators.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.263.1">When designing classes, you should follow these guidelines:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.264.1">A class that </span><a id="_idIndexMarker366"/><span class="koboSpan" id="kobo.265.1">manages a resource should have the single responsibility of handling the ownership of that resource. </span><span class="koboSpan" id="kobo.265.2">Such a class must follow the Rule of Five and implement a custom destructor, copy/move constructors, and copy/move assignment operators.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.266.1">A class that doesn’t manage resources should not have a custom destructor, copy/move constructors, and copy/move assignment operators (therefore following the Rule of Zero).</span></li>
</ul>
<h2 class="heading-2" id="_idParaDest-179"><span class="koboSpan" id="kobo.267.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.268.1">Uniformly invoking anything callable</span></em><span class="koboSpan" id="kobo.269.1">, to learn how to use </span><code class="inlineCode"><span class="koboSpan" id="kobo.270.1">std::invoke()</span></code><span class="koboSpan" id="kobo.271.1"> to invoke any callable object with the provided arguments</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-180"><span class="koboSpan" id="kobo.272.1">Using lambdas with standard algorithms</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.273.1">One of the most important modern features of C++ is lambda expressions, also referred to as lambda functions or simply lambdas. </span><span class="koboSpan" id="kobo.273.2">Lambda expressions enable us to define anonymous function objects that can capture variables in the scope and be invoked or passed as arguments to functions. </span><span class="koboSpan" id="kobo.273.3">They avoid having to define named functions or function objects. </span><span class="koboSpan" id="kobo.273.4">Lambdas are</span><a id="_idIndexMarker367"/><span class="koboSpan" id="kobo.274.1"> useful for many purposes, and in this recipe, we will learn how to use them with standard algorithms.</span></p>
<h2 class="heading-2" id="_idParaDest-181"><span class="koboSpan" id="kobo.275.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.276.1">In this recipe, we’ll discuss standard algorithms</span><a id="_idIndexMarker368"/><span class="koboSpan" id="kobo.277.1"> that take an argument that’s a function or predicate that’s applied to the elements it iterates through. </span><span class="koboSpan" id="kobo.277.2">You need to know what unary and binary functions are and what predicates and comparison functions are. </span><span class="koboSpan" id="kobo.277.3">You also need to be familiar with function objects because lambda expressions are syntactic sugar for function objects.</span></p>
<h2 class="heading-2" id="_idParaDest-182"><span class="koboSpan" id="kobo.278.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.279.1">You </span><a id="_idIndexMarker369"/><span class="koboSpan" id="kobo.280.1">should prefer to use lambda expressions to </span><a id="_idIndexMarker370"/><span class="koboSpan" id="kobo.281.1">pass callbacks to standard algorithms instead of functions or function objects:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.282.1">Define anonymous lambda expressions in the place of the call if you only need to use the lambda in a single place:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.283.1">auto</span></span><span class="koboSpan" id="kobo.284.1"> numbers =
  std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.285.1">int</span></span><span class="koboSpan" id="kobo.286.1">&gt;{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.287.1">0</span></span><span class="koboSpan" id="kobo.288.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.289.1">2</span></span><span class="koboSpan" id="kobo.290.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.291.1">-3</span></span><span class="koboSpan" id="kobo.292.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.293.1">5</span></span><span class="koboSpan" id="kobo.294.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.295.1">-1</span></span><span class="koboSpan" id="kobo.296.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.297.1">6</span></span><span class="koboSpan" id="kobo.298.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.299.1">8</span></span><span class="koboSpan" id="kobo.300.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.301.1">-4</span></span><span class="koboSpan" id="kobo.302.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.303.1">9</span></span><span class="koboSpan" id="kobo.304.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.305.1">auto</span></span><span class="koboSpan" id="kobo.306.1"> positives = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.307.1">count_if</span></span><span class="koboSpan" id="kobo.308.1">(
  std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.309.1">begin</span></span><span class="koboSpan" id="kobo.310.1">(numbers), std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.311.1">end</span></span><span class="koboSpan" id="kobo.312.1">(numbers),
  [](</span><span class="hljs-type"><span class="koboSpan" id="kobo.313.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.314.1">const</span></span><span class="koboSpan" id="kobo.315.1"> n) {</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.316.1">return</span></span><span class="koboSpan" id="kobo.317.1"> n &gt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.318.1">0</span></span><span class="koboSpan" id="kobo.319.1">; });
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.320.1">Define a named lambda, that is, one assigned to a variable (usually with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.321.1">auto</span></code><span class="koboSpan" id="kobo.322.1"> specifier for the type), if you need to call the lambda in multiple places:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.323.1">auto</span></span><span class="koboSpan" id="kobo.324.1"> ispositive = [](</span><span class="hljs-type"><span class="koboSpan" id="kobo.325.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.326.1">const</span></span><span class="koboSpan" id="kobo.327.1"> n) {</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.328.1">return</span></span><span class="koboSpan" id="kobo.329.1"> n &gt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.330.1">0</span></span><span class="koboSpan" id="kobo.331.1">; };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.332.1">auto</span></span><span class="koboSpan" id="kobo.333.1"> positives = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.334.1">count_if</span></span><span class="koboSpan" id="kobo.335.1">(
  std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.336.1">begin</span></span><span class="koboSpan" id="kobo.337.1">(numbers), std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.338.1">end</span></span><span class="koboSpan" id="kobo.339.1">(numbers), ispositive);
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.340.1">Use generic lambda expressions if you need lambdas that only differ in terms of their argument types (available since C++14):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.341.1">auto</span></span><span class="koboSpan" id="kobo.342.1"> positives = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.343.1">count_if</span></span><span class="koboSpan" id="kobo.344.1">(
  std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.345.1">begin</span></span><span class="koboSpan" id="kobo.346.1">(numbers), std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.347.1">end</span></span><span class="koboSpan" id="kobo.348.1">(numbers),
  [](</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.349.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.350.1">const</span></span><span class="koboSpan" id="kobo.351.1"> n) {</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.352.1">return</span></span><span class="koboSpan" id="kobo.353.1"> n &gt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.354.1">0</span></span><span class="koboSpan" id="kobo.355.1">; });
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-183"><span class="koboSpan" id="kobo.356.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.357.1">The non-generic lambda expression shown in the second bullet takes a constant integer and returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.358.1">true</span></code><span class="koboSpan" id="kobo.359.1"> if it is greater than </span><code class="inlineCode"><span class="koboSpan" id="kobo.360.1">0</span></code><span class="koboSpan" id="kobo.361.1">, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.362.1">false</span></code><span class="koboSpan" id="kobo.363.1"> otherwise. </span><span class="koboSpan" id="kobo.363.2">The compiler defines an unnamed function object with the call operator, which has the signature of the lambda expression:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.364.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.365.1">__lambda_name__</span></span><span class="koboSpan" id="kobo.366.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.367.1">bool</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.368.1">operator</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.369.1">()(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.370.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.371.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.372.1"> n)</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.373.1">const</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.374.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.375.1">return</span></span><span class="koboSpan" id="kobo.376.1"> n &gt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.377.1">0</span></span><span class="koboSpan" id="kobo.378.1">; }
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.379.1">The way the unnamed function object is defined by the compiler depends on the way we define the lambda expression that can capture variables, use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.380.1">mutable</span></code><span class="koboSpan" id="kobo.381.1"> specifier or exception specifications, or have a trailing return type. </span><span class="koboSpan" id="kobo.381.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.382.1">__lambda_name__</span></code><span class="koboSpan" id="kobo.383.1"> function object shown earlier is actually a simplification of what the compiler generates because it also defines a default copy and move constructor, a default destructor, and a deleted assignment operator.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.384.1">It must be well understood that the lambda expression is actually a class. </span><span class="koboSpan" id="kobo.384.2">In order to call it, the compiler needs to instantiate an object of the class. </span><span class="koboSpan" id="kobo.384.3">The object instantiated from a lambda expression is </span><a id="_idIndexMarker371"/><span class="koboSpan" id="kobo.385.1">called a </span><em class="italic"><span class="koboSpan" id="kobo.386.1">lambda closure</span></em><span class="koboSpan" id="kobo.387.1">.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.388.1">In the following example, we want to count the number of elements in a range that are greater than or equal to 5 and less than or equal to 10. </span><span class="koboSpan" id="kobo.388.2">The lambda expression, in this case, will look like this:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.389.1">auto</span></span><span class="koboSpan" id="kobo.390.1"> numbers = std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.391.1">int</span></span><span class="koboSpan" id="kobo.392.1">&gt;{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.393.1">0</span></span><span class="koboSpan" id="kobo.394.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.395.1">2</span></span><span class="koboSpan" id="kobo.396.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.397.1">-3</span></span><span class="koboSpan" id="kobo.398.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.399.1">5</span></span><span class="koboSpan" id="kobo.400.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.401.1">-1</span></span><span class="koboSpan" id="kobo.402.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.403.1">6</span></span><span class="koboSpan" id="kobo.404.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.405.1">8</span></span><span class="koboSpan" id="kobo.406.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.407.1">-4</span></span><span class="koboSpan" id="kobo.408.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.409.1">9</span></span><span class="koboSpan" id="kobo.410.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.411.1">auto</span></span><span class="koboSpan" id="kobo.412.1"> minimum { </span><span class="hljs-number"><span class="koboSpan" id="kobo.413.1">5</span></span><span class="koboSpan" id="kobo.414.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.415.1">auto</span></span><span class="koboSpan" id="kobo.416.1"> maximum { </span><span class="hljs-number"><span class="koboSpan" id="kobo.417.1">10</span></span><span class="koboSpan" id="kobo.418.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.419.1">auto</span></span><span class="koboSpan" id="kobo.420.1"> inrange = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.421.1">count_if</span></span><span class="koboSpan" id="kobo.422.1">(
    std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.423.1">begin</span></span><span class="koboSpan" id="kobo.424.1">(numbers), std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.425.1">end</span></span><span class="koboSpan" id="kobo.426.1">(numbers),
    [minimum, maximum](</span><span class="hljs-type"><span class="koboSpan" id="kobo.427.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.428.1">const</span></span><span class="koboSpan" id="kobo.429.1"> n) {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.430.1">return</span></span><span class="koboSpan" id="kobo.431.1"> minimum &lt;= n &amp;&amp; n &lt;= maximum;});
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.432.1">This </span><a id="_idIndexMarker372"/><span class="koboSpan" id="kobo.433.1">lambda captures two variables, </span><code class="inlineCode"><span class="koboSpan" id="kobo.434.1">minimum</span></code><span class="koboSpan" id="kobo.435.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.436.1">maximum</span></code><span class="koboSpan" id="kobo.437.1">, by copy (that is, value). </span><span class="koboSpan" id="kobo.437.2">The resulting unnamed function object created by </span><a id="_idIndexMarker373"/><span class="koboSpan" id="kobo.438.1">the compiler looks very much like the one we defined earlier. </span><span class="koboSpan" id="kobo.438.2">With the default and deleted special members mentioned earlier, the class looks like this:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.439.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.440.1">__lambda_name_2__</span></span><span class="koboSpan" id="kobo.441.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.442.1">int</span></span><span class="koboSpan" id="kobo.443.1"> minimum_;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.444.1">int</span></span><span class="koboSpan" id="kobo.445.1"> maximum_;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.446.1">public</span></span><span class="koboSpan" id="kobo.447.1">:
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.448.1">explicit</span></span><span class="koboSpan" id="kobo.449.1"> __lambda_name_2__(</span><span class="hljs-type"><span class="koboSpan" id="kobo.450.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.451.1">const</span></span><span class="koboSpan" id="kobo.452.1"> minimum, </span><span class="hljs-type"><span class="koboSpan" id="kobo.453.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.454.1">const</span></span><span class="koboSpan" id="kobo.455.1"> maximum) :
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.456.1">minimum_</span></span><span class="koboSpan" id="kobo.457.1">( minimum), </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.458.1">maximum_</span></span><span class="koboSpan" id="kobo.459.1">( maximum)
  {}
  __lambda_name_2__(</span><span class="hljs-type"><span class="koboSpan" id="kobo.460.1">const</span></span><span class="koboSpan" id="kobo.461.1"> __lambda_name_2__&amp;) = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.462.1">default</span></span><span class="koboSpan" id="kobo.463.1">;
  __lambda_name_2__(__lambda_name_2__&amp;&amp;) = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.464.1">default</span></span><span class="koboSpan" id="kobo.465.1">;
  __lambda_name_2__&amp; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.466.1">operator</span></span><span class="koboSpan" id="kobo.467.1">=(</span><span class="hljs-type"><span class="koboSpan" id="kobo.468.1">const</span></span><span class="koboSpan" id="kobo.469.1"> __lambda_name_2__&amp;)
    = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.470.1">delete</span></span><span class="koboSpan" id="kobo.471.1">;
  ~__lambda_name_2__() = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.472.1">default</span></span><span class="koboSpan" id="kobo.473.1">;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.474.1">bool</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.475.1">operator</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.476.1">()</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.477.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.478.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.479.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.480.1"> n)</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.481.1">const</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.482.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.483.1">return</span></span><span class="koboSpan" id="kobo.484.1"> minimum_ &lt;= n &amp;&amp; n &lt;= maximum_;
  }
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.485.1">The </span><a id="_idIndexMarker374"/><span class="koboSpan" id="kobo.486.1">lambda expression can capture variables </span><a id="_idIndexMarker375"/><span class="koboSpan" id="kobo.487.1">by copy (or value) or by reference, and different combinations of the two are possible. </span><span class="koboSpan" id="kobo.487.2">However, it is not possible to capture a variable multiple times and it is only possible to have </span><code class="inlineCode"><span class="koboSpan" id="kobo.488.1">&amp;</span></code><span class="koboSpan" id="kobo.489.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.490.1">=</span></code><span class="koboSpan" id="kobo.491.1"> at the beginning of the capture list.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.492.1">A lambda expression can access the following kinds of variables: variables captured from the enclosing scope, lambda parameters, variables declared locally within its body, class data members when the lambda is declared inside a class and the pointer is captured by the lambda, and any variable with static storage duration such as global variables.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.493.1">A lambda can only capture variables from an enclosing function scope. </span><span class="koboSpan" id="kobo.493.2">It cannot capture variables with static storage duration (that is, variables declared in a namespace scope or with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.494.1">static</span></code><span class="koboSpan" id="kobo.495.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.496.1">external</span></code><span class="koboSpan" id="kobo.497.1"> specifier).</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.498.1">The following table shows various combinations for lambda capture semantics:</span></p>
<table class="table-container" id="table001-2">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.499.1">Lambda</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.500.1">Description</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.501.1">[](){}</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.502.1">Does not capture anything.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.503.1">[&amp;](){}</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.504.1">Captures everything by reference.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.505.1">[=](){}</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.506.1">Captures everything by copy. </span><span class="koboSpan" id="kobo.506.2">Implicit capturing of the pointer </span><code class="inlineCode"><span class="koboSpan" id="kobo.507.1">this</span></code><span class="koboSpan" id="kobo.508.1"> is deprecated in C++20.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.509.1">[&amp;x](){}</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.510.1">Captures only </span><code class="inlineCode"><span class="koboSpan" id="kobo.511.1">x</span></code><span class="koboSpan" id="kobo.512.1"> by reference.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.513.1">[x](){}</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.514.1">Captures only </span><code class="inlineCode"><span class="koboSpan" id="kobo.515.1">x</span></code><span class="koboSpan" id="kobo.516.1"> by copy.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.517.1">[&amp;x...](){}</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.518.1">Captures pack extension </span><code class="inlineCode"><span class="koboSpan" id="kobo.519.1">x</span></code><span class="koboSpan" id="kobo.520.1"> by reference.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.521.1">[x...](){}</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.522.1">Captures pack extension </span><code class="inlineCode"><span class="koboSpan" id="kobo.523.1">x</span></code><span class="koboSpan" id="kobo.524.1"> by copy.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.525.1">[&amp;, x](){}</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.526.1">Captures everything by reference except for </span><code class="inlineCode"><span class="koboSpan" id="kobo.527.1">x</span></code><span class="koboSpan" id="kobo.528.1"> that is captured by copy.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.529.1">[=, &amp;x](){}</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.530.1">Captures everything by copy except for </span><code class="inlineCode"><span class="koboSpan" id="kobo.531.1">x</span></code><span class="koboSpan" id="kobo.532.1"> that is captured by reference.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.533.1">[&amp;, this](){}</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.534.1">Captures everything by reference except for the pointer </span><code class="inlineCode"><span class="koboSpan" id="kobo.535.1">this</span></code><span class="koboSpan" id="kobo.536.1">, which is captured by copy (</span><code class="inlineCode"><span class="koboSpan" id="kobo.537.1">this</span></code><span class="koboSpan" id="kobo.538.1"> is always captured by copy).</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.539.1">[x, x](){}</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.540.1">Error; </span><code class="inlineCode"><span class="koboSpan" id="kobo.541.1">x</span></code><span class="koboSpan" id="kobo.542.1"> is captured twice.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.543.1">[&amp;, &amp;x](){}</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.544.1">Error; everything is captured by reference, and we cannot specify again to capture </span><code class="inlineCode"><span class="koboSpan" id="kobo.545.1">x</span></code><span class="koboSpan" id="kobo.546.1"> by reference.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.547.1">[=, =x](){}</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.548.1">Error; everything is captured by copy, and we cannot specify again to capture </span><code class="inlineCode"><span class="koboSpan" id="kobo.549.1">x</span></code><span class="koboSpan" id="kobo.550.1"> by copy.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.551.1">[&amp;this](){}</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.552.1">Error; the pointer </span><code class="inlineCode"><span class="koboSpan" id="kobo.553.1">this</span></code><span class="koboSpan" id="kobo.554.1"> is always captured by copy.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.555.1">[&amp;, =](){}</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.556.1">Error; cannot capture everything both by copy and by reference.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.557.1">[x=expr](){}</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.558.1">x</span></code><span class="koboSpan" id="kobo.559.1"> is a data member of the lambda’s closure initialized from the expression </span><code class="inlineCode"><span class="koboSpan" id="kobo.560.1">expr</span></code><span class="koboSpan" id="kobo.561.1">.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.562.1">[&amp;x=expr](){}</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.563.1">x</span></code><span class="koboSpan" id="kobo.564.1"> is a reference data member of the lambda’s closure initialized from the expression </span><code class="inlineCode"><span class="koboSpan" id="kobo.565.1">expr</span></code><span class="koboSpan" id="kobo.566.1">.</span></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.567.1">Table 3.1: Examples of lambda captures with explanations</span></p>
<p class="normal"><span class="koboSpan" id="kobo.568.1">The general form of a lambda expression, as of C++17, looks like this:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.569.1">[capture-list](params) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.570.1">mutable</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.571.1">constexpr</span></span><span class="koboSpan" id="kobo.572.1"> exception attr -&gt; ret
{ body }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.573.1">All parts </span><a id="_idIndexMarker376"/><span class="koboSpan" id="kobo.574.1">shown in this syntax are actually</span><a id="_idIndexMarker377"/><span class="koboSpan" id="kobo.575.1"> optional except for the capture list, which can, however, be empty, and the body, which can also be empty. </span><span class="koboSpan" id="kobo.575.2">The parameter list can actually be omitted if no parameters are needed. </span><span class="koboSpan" id="kobo.575.3">The return type does not need to be specified as the compiler can infer it from the type of the returned expression. </span><span class="koboSpan" id="kobo.575.4">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.576.1">mutable</span></code><span class="koboSpan" id="kobo.577.1"> specifier (which tells the compiler the lambda can actually modify variables captured by copy, which is not the same as capturing by value because the changes are only observed within the lambda), the </span><code class="inlineCode"><span class="koboSpan" id="kobo.578.1">constexpr</span></code><span class="koboSpan" id="kobo.579.1"> specifier (which tells the compiler to generate a </span><code class="inlineCode"><span class="koboSpan" id="kobo.580.1">constexpr</span></code><span class="koboSpan" id="kobo.581.1"> call operator), and the exception specifiers and attributes are all optional.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.582.1">The simplest possible lambda expression is </span><code class="inlineCode"><span class="koboSpan" id="kobo.583.1">[]{}</span></code><span class="koboSpan" id="kobo.584.1">, though it is often written as </span><code class="inlineCode"><span class="koboSpan" id="kobo.585.1">[](){}</span></code><span class="koboSpan" id="kobo.586.1">.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.587.1">The latter two examples in the preceding table are forms of generalized lambda captures. </span><span class="koboSpan" id="kobo.587.2">These were introduced in C++14 to allow us to capture variables with move-only semantics, but they can also be used to define new arbitrary objects in the lambda. </span><span class="koboSpan" id="kobo.587.3">The following example shows how variables can be captured by </span><code class="inlineCode"><span class="koboSpan" id="kobo.588.1">move</span></code><span class="koboSpan" id="kobo.589.1"> with generalized lambda captures:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.590.1">auto</span></span><span class="koboSpan" id="kobo.591.1"> ptr = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.592.1">make_unique</span></span><span class="koboSpan" id="kobo.593.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.594.1">int</span></span><span class="koboSpan" id="kobo.595.1">&gt;(</span><span class="hljs-number"><span class="koboSpan" id="kobo.596.1">42</span></span><span class="koboSpan" id="kobo.597.1">);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.598.1">auto</span></span><span class="koboSpan" id="kobo.599.1"> l = [lptr = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.600.1">move</span></span><span class="koboSpan" id="kobo.601.1">(ptr)](){</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.602.1">return</span></span><span class="koboSpan" id="kobo.603.1"> ++*lptr;};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.604.1">Lambdas that are written in class methods and need to capture class data members can do so in several ways:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.605.1">Capturing individual data members with the form </span><code class="inlineCode"><span class="koboSpan" id="kobo.606.1">[x=expr]</span></code><span class="koboSpan" id="kobo.607.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.608.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.609.1">foo</span></span><span class="koboSpan" id="kobo.610.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.611.1">int</span></span><span class="koboSpan" id="kobo.612.1">         id;
  std::string name;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.613.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.614.1">run</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.615.1">()</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.616.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.617.1">return</span></span><span class="koboSpan" id="kobo.618.1"> [i=id, n=name] { std::cout &lt;&lt; i &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.619.1">' '</span></span><span class="koboSpan" id="kobo.620.1"> &lt;&lt; n &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.621.1">'\n'</span></span><span class="koboSpan" id="kobo.622.1">; };
  }
};
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.623.1">Capturing the entire object with the form </span><code class="inlineCode"><span class="koboSpan" id="kobo.624.1">[=]</span></code><span class="koboSpan" id="kobo.625.1"> (please note that the implicit capture of pointer </span><code class="inlineCode"><span class="koboSpan" id="kobo.626.1">this</span></code><span class="koboSpan" id="kobo.627.1"> via </span><code class="inlineCode"><span class="koboSpan" id="kobo.628.1">[=]</span></code><span class="koboSpan" id="kobo.629.1"> is deprecated in C++20):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.630.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.631.1">foo</span></span><span class="koboSpan" id="kobo.632.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.633.1">int</span></span><span class="koboSpan" id="kobo.634.1">         id;
  std::string name;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.635.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.636.1">run</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.637.1">()</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.638.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.639.1">return</span></span><span class="koboSpan" id="kobo.640.1"> [=] { std::cout &lt;&lt; id &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.641.1">' '</span></span><span class="koboSpan" id="kobo.642.1"> &lt;&lt; name &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.643.1">'\n'</span></span><span class="koboSpan" id="kobo.644.1">; };
  }
};
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.645.1">Capturing the </span><a id="_idIndexMarker378"/><span class="koboSpan" id="kobo.646.1">entire object by capturing </span><a id="_idIndexMarker379"/><span class="koboSpan" id="kobo.647.1">the </span><code class="inlineCode"><span class="koboSpan" id="kobo.648.1">this</span></code><span class="koboSpan" id="kobo.649.1"> pointer. </span><span class="koboSpan" id="kobo.649.2">This is necessary if you need to invoke other methods of the class. </span><span class="koboSpan" id="kobo.649.3">This can be captured either as </span><code class="inlineCode"><span class="koboSpan" id="kobo.650.1">[this]</span></code><span class="koboSpan" id="kobo.651.1"> when the pointer is captured by value, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.652.1">[*this]</span></code><span class="koboSpan" id="kobo.653.1"> when the object itself is captured by value. </span><span class="koboSpan" id="kobo.653.2">This can make a big difference if the object may go out of scope after the capture occurs but before the lambda is invoked:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.654.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.655.1">foo</span></span><span class="koboSpan" id="kobo.656.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.657.1">int</span></span><span class="koboSpan" id="kobo.658.1">         id;
  std::string name;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.659.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.660.1">run</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.661.1">()</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.662.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.663.1">return</span></span><span class="koboSpan" id="kobo.664.1">[</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.665.1">this</span></span><span class="koboSpan" id="kobo.666.1">]{ std::cout &lt;&lt; id &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.667.1">' '</span></span><span class="koboSpan" id="kobo.668.1"> &lt;&lt; name &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.669.1">'\n'</span></span><span class="koboSpan" id="kobo.670.1">; };
  }
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.671.1">auto</span></span><span class="koboSpan" id="kobo.672.1"> l = foo{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.673.1">42</span></span><span class="koboSpan" id="kobo.674.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.675.1">"john"</span></span><span class="koboSpan" id="kobo.676.1"> }.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.677.1">run</span></span><span class="koboSpan" id="kobo.678.1">();
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.679.1">l</span></span><span class="koboSpan" id="kobo.680.1">(); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.681.1">// does not print 42 john</span></span>
</code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.682.1">In this</span><a id="_idIndexMarker380"/><span class="koboSpan" id="kobo.683.1"> latter case, the correct capture should </span><a id="_idIndexMarker381"/><span class="koboSpan" id="kobo.684.1">be </span><code class="inlineCode"><span class="koboSpan" id="kobo.685.1">[*this]</span></code><span class="koboSpan" id="kobo.686.1"> so that the object is copied by value. </span><span class="koboSpan" id="kobo.686.2">In this case, invoking the lambda will print </span><em class="italic"><span class="koboSpan" id="kobo.687.1">42 john</span></em><span class="koboSpan" id="kobo.688.1">, even though the temporary has gone out of scope.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.689.1">The C++20 standard introduces several changes to capturing the pointer </span><code class="inlineCode"><span class="koboSpan" id="kobo.690.1">this</span></code><span class="koboSpan" id="kobo.691.1">:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.692.1">It deprecates the implicit capturing of </span><code class="inlineCode"><span class="koboSpan" id="kobo.693.1">this</span></code><span class="koboSpan" id="kobo.694.1"> when you use </span><code class="inlineCode"><span class="koboSpan" id="kobo.695.1">[=]</span></code><span class="koboSpan" id="kobo.696.1">. </span><span class="koboSpan" id="kobo.696.2">This will produce a deprecation warning to be issued by the compiler.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.697.1">It introduces explicit capturing of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.698.1">this</span></code><span class="koboSpan" id="kobo.699.1"> pointer by value when you want to capture everything with </span><code class="inlineCode"><span class="koboSpan" id="kobo.700.1">[=, this]</span></code><span class="koboSpan" id="kobo.701.1">. </span><span class="koboSpan" id="kobo.701.2">You can still only capture the pointer </span><code class="inlineCode"><span class="koboSpan" id="kobo.702.1">this</span></code><span class="koboSpan" id="kobo.703.1"> with a </span><code class="inlineCode"><span class="koboSpan" id="kobo.704.1">[this]</span></code><span class="koboSpan" id="kobo.705.1"> capture.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.706.1">There are cases where lambda expressions only differ in terms of their arguments. </span><span class="koboSpan" id="kobo.706.2">In this case, the lambdas can be written in a generic way, just like templates, but using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.707.1">auto</span></code><span class="koboSpan" id="kobo.708.1"> specifier for the type parameters (no template syntax is involved). </span><span class="koboSpan" id="kobo.708.2">This is addressed in the next recipe, as noted in the upcoming </span><em class="italic"><span class="koboSpan" id="kobo.709.1">See also</span></em><span class="koboSpan" id="kobo.710.1"> section.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.711.1">Before C++23, attributes could be specified on a lambda expression between the optional exception specifier and the optional trailing return type. </span><span class="koboSpan" id="kobo.711.2">Such attributes would apply to the type, not the function call operator. </span><span class="koboSpan" id="kobo.711.3">However, attributes such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.712.1">[[nodiscard]]</span></code><span class="koboSpan" id="kobo.713.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.714.1">[[noreturn]]</span></code><span class="koboSpan" id="kobo.715.1"> would only make sense on a function, not a type. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.716.1">Therefore, as of C++23, this restriction has changed so that attributes can also be specified:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.717.1">after the lambda introducer and its optional capture, or </span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.718.1">after the template parameter list and its optional requires clause.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.719.1">The attributes declared in any of these parts of a lambda declaration apply to the function call operator and not the type.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.720.1">Let’s examine the following example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.721.1">auto</span></span><span class="koboSpan" id="kobo.722.1"> linc = [](</span><span class="hljs-type"><span class="koboSpan" id="kobo.723.1">int</span></span><span class="koboSpan" id="kobo.724.1"> a) [[deprecated]] { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.725.1">return</span></span><span class="koboSpan" id="kobo.726.1"> a+</span><span class="hljs-number"><span class="koboSpan" id="kobo.727.1">1</span></span><span class="koboSpan" id="kobo.728.1">; };
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.729.1">linc</span></span><span class="koboSpan" id="kobo.730.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.731.1">42</span></span><span class="koboSpan" id="kobo.732.1">);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.733.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.734.1">[[deprecated]]</span></code><span class="koboSpan" id="kobo.735.1"> attribute applies to the type of the lambda and no warning is produced when compiling the snippet. </span><span class="koboSpan" id="kobo.735.2">In C++23, we can write the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.736.1">auto</span></span><span class="koboSpan" id="kobo.737.1"> linc = [][[nodiscard,deprecated]](</span><span class="hljs-type"><span class="koboSpan" id="kobo.738.1">int</span></span><span class="koboSpan" id="kobo.739.1"> a) { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.740.1">return</span></span><span class="koboSpan" id="kobo.741.1"> a+</span><span class="hljs-number"><span class="koboSpan" id="kobo.742.1">1</span></span><span class="koboSpan" id="kobo.743.1">; };
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.744.1">linc</span></span><span class="koboSpan" id="kobo.745.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.746.1">42</span></span><span class="koboSpan" id="kobo.747.1">);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.748.1">With this </span><a id="_idIndexMarker382"/><span class="koboSpan" id="kobo.749.1">change, both the </span><code class="inlineCode"><span class="koboSpan" id="kobo.750.1">[[nodiscard]]</span></code><span class="koboSpan" id="kobo.751.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.752.1">[[deprecated]]</span></code><span class="koboSpan" id="kobo.753.1"> attributes apply to the function call operator of the lambda type. </span><span class="koboSpan" id="kobo.753.2">This </span><a id="_idIndexMarker383"/><span class="koboSpan" id="kobo.754.1">results in two warnings being issued: one that a deprecated function is being used, and one that the return type is being ignored.</span></p>
<h2 class="heading-2" id="_idParaDest-184"><span class="koboSpan" id="kobo.755.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.756.1">Using generic and template lambdas</span></em><span class="koboSpan" id="kobo.757.1">, to learn how to use </span><code class="inlineCode"><span class="koboSpan" id="kobo.758.1">auto</span></code><span class="koboSpan" id="kobo.759.1"> for lambda parameters and how to define template lambdas in C++20</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.760.1">Writing a recursive lambda</span></em><span class="koboSpan" id="kobo.761.1">, to understand the technique we can use to make a lambda call itself recursively</span></li>
<li class="bulletList"><em class="chapterRef"><span class="koboSpan" id="kobo.762.1">Chapter 4</span></em><span class="koboSpan" id="kobo.763.1">,</span><em class="italic"><span class="koboSpan" id="kobo.764.1"> Providing metadata to the compiler with attributes</span></em><span class="koboSpan" id="kobo.765.1">, to learn about available standard attributes and how to use them</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-185"><span class="koboSpan" id="kobo.766.1">Using generic and template lambdas</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.767.1">In the preceding recipe, we saw how to write lambda expressions and use them with standard algorithms. </span><span class="koboSpan" id="kobo.767.2">In C++, lambdas</span><a id="_idIndexMarker384"/><span class="koboSpan" id="kobo.768.1"> are basically syntactic sugar for unnamed function objects, which are classes that implement the call operator. </span><span class="koboSpan" id="kobo.768.2">However, just like any other function, this can be implemented generically with templates. </span><span class="koboSpan" id="kobo.768.3">C++14 takes advantage of this and introduces generic lambdas</span><a id="_idIndexMarker385"/><span class="koboSpan" id="kobo.769.1"> that do not need to specify actual types for their parameters and use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.770.1">auto</span></code><span class="koboSpan" id="kobo.771.1"> specifier instead. </span><span class="koboSpan" id="kobo.771.2">Though not referred to by this name, generic lambdas are basically lambda templates. </span><span class="koboSpan" id="kobo.771.3">They are useful in cases where we want to use the same lambda but with different types of parameters. </span><span class="koboSpan" id="kobo.771.4">Moreover, the C++20 standard takes this a step further and supports explicitly defining </span><a id="_idIndexMarker386"/><span class="koboSpan" id="kobo.772.1">template lambdas. </span><span class="koboSpan" id="kobo.772.2">This helps with some scenarios where generic lambdas are cumbersome.</span></p>
<h2 class="heading-2" id="_idParaDest-186"><span class="koboSpan" id="kobo.773.1">Getting started</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.774.1">It is recommended that you read the preceding recipe, </span><em class="italic"><span class="koboSpan" id="kobo.775.1">Using lambdas with standard algorithms</span></em><span class="koboSpan" id="kobo.776.1">, before you continue with this one to familiarize yourself with the fundamentals of lambdas in C++.</span></p>
<h2 class="heading-2" id="_idParaDest-187"><span class="koboSpan" id="kobo.777.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.778.1">Since C++14, we can write </span><a id="_idIndexMarker387"/><span class="koboSpan" id="kobo.779.1">generic lambdas:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.780.1">By using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.781.1">auto</span></code><span class="koboSpan" id="kobo.782.1"> specifier instead of actual types for lambda expression parameters</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.783.1">When we need to use multiple lambdas that only differ by their parameter types</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.784.1">The following example shows a generic lambda used with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.785.1">std::accumulate()</span></code><span class="koboSpan" id="kobo.786.1"> algorithm, first with a vector of integers and then with a vector of strings:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.787.1">auto</span></span><span class="koboSpan" id="kobo.788.1"> numbers =
  std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.789.1">int</span></span><span class="koboSpan" id="kobo.790.1">&gt;{</span><span class="hljs-number"><span class="koboSpan" id="kobo.791.1">0</span></span><span class="koboSpan" id="kobo.792.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.793.1">2</span></span><span class="koboSpan" id="kobo.794.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.795.1">-3</span></span><span class="koboSpan" id="kobo.796.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.797.1">5</span></span><span class="koboSpan" id="kobo.798.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.799.1">-1</span></span><span class="koboSpan" id="kobo.800.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.801.1">6</span></span><span class="koboSpan" id="kobo.802.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.803.1">8</span></span><span class="koboSpan" id="kobo.804.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.805.1">-4</span></span><span class="koboSpan" id="kobo.806.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.807.1">9</span></span><span class="koboSpan" id="kobo.808.1">};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.809.1">using</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.810.1">namespace</span></span><span class="koboSpan" id="kobo.811.1"> std::string_literals;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.812.1">auto</span></span><span class="koboSpan" id="kobo.813.1"> texts =
  std::vector&lt;std::string&gt;{</span><span class="hljs-string"><span class="koboSpan" id="kobo.814.1">"hello"</span></span><span class="koboSpan" id="kobo.815.1">s, </span><span class="hljs-string"><span class="koboSpan" id="kobo.816.1">" "</span></span><span class="koboSpan" id="kobo.817.1">s, </span><span class="hljs-string"><span class="koboSpan" id="kobo.818.1">"world"</span></span><span class="koboSpan" id="kobo.819.1">s, </span><span class="hljs-string"><span class="koboSpan" id="kobo.820.1">"!"</span></span><span class="koboSpan" id="kobo.821.1">s};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.822.1">auto</span></span><span class="koboSpan" id="kobo.823.1"> lsum = [](</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.824.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.825.1">const</span></span><span class="koboSpan" id="kobo.826.1"> s, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.827.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.828.1">const</span></span><span class="koboSpan" id="kobo.829.1"> n) {</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.830.1">return</span></span><span class="koboSpan" id="kobo.831.1"> s + n;};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.832.1">auto</span></span><span class="koboSpan" id="kobo.833.1"> sum = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.834.1">accumulate</span></span><span class="koboSpan" id="kobo.835.1">(
  std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.836.1">begin</span></span><span class="koboSpan" id="kobo.837.1">(numbers), std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.838.1">end</span></span><span class="koboSpan" id="kobo.839.1">(numbers), </span><span class="hljs-number"><span class="koboSpan" id="kobo.840.1">0</span></span><span class="koboSpan" id="kobo.841.1">, lsum);
  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.842.1">// sum = 22</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.843.1">auto</span></span><span class="koboSpan" id="kobo.844.1"> text = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.845.1">accumulate</span></span><span class="koboSpan" id="kobo.846.1">(
  std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.847.1">begin</span></span><span class="koboSpan" id="kobo.848.1">(texts), std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.849.1">end</span></span><span class="koboSpan" id="kobo.850.1">(texts), </span><span class="hljs-string"><span class="koboSpan" id="kobo.851.1">""</span></span><span class="koboSpan" id="kobo.852.1">s, lsum);
  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.853.1">// sum = "hello world!"s</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.854.1">Since C++20, we can write</span><a id="_idIndexMarker388"/><span class="koboSpan" id="kobo.855.1"> template lambdas:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.856.1">By using a template parameter list in angle brackets (such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.857.1">&lt;template T&gt;</span></code><span class="koboSpan" id="kobo.858.1">) after the capture clause</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.859.1">When you want to:</span><ul>
<li class="bulletList"><span class="koboSpan" id="kobo.860.1">Restrict the use of a generic lambda with only some types, such as a container, or types that satisfy a concept.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.861.1">Make sure that two or more arguments of a generic lambda actually do have the same type.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.862.1">Retrieve the type of a generic parameter so that, for example, we can create instances of it, invoke static methods, or use its iterator types.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.863.1">Perform </span><a id="_idIndexMarker389"/><span class="koboSpan" id="kobo.864.1">perfect forwarding in a generic lambda.</span></li>
</ul>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.865.1">The following example shows a template lambda that can be invoked only using an </span><code class="inlineCode"><span class="koboSpan" id="kobo.866.1">std::vector</span></code><span class="koboSpan" id="kobo.867.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.868.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.869.1">int</span></span><span class="koboSpan" id="kobo.870.1">&gt; vi { </span><span class="hljs-number"><span class="koboSpan" id="kobo.871.1">1</span></span><span class="koboSpan" id="kobo.872.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.873.1">1</span></span><span class="koboSpan" id="kobo.874.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.875.1">2</span></span><span class="koboSpan" id="kobo.876.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.877.1">3</span></span><span class="koboSpan" id="kobo.878.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.879.1">5</span></span><span class="koboSpan" id="kobo.880.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.881.1">8</span></span><span class="koboSpan" id="kobo.882.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.883.1">auto</span></span><span class="koboSpan" id="kobo.884.1"> tl = []&lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.885.1">typename</span></span><span class="koboSpan" id="kobo.886.1"> T&gt;(std::vector&lt;T&gt; </span><span class="hljs-type"><span class="koboSpan" id="kobo.887.1">const</span></span><span class="koboSpan" id="kobo.888.1">&amp; vec)
{
   std::cout &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.889.1">size</span></span><span class="koboSpan" id="kobo.890.1">(vec) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.891.1">'\n'</span></span><span class="koboSpan" id="kobo.892.1">;
};
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.893.1">tl</span></span><span class="koboSpan" id="kobo.894.1">(vi); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.895.1">// OK, prints 6</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.896.1">tl</span></span><span class="koboSpan" id="kobo.897.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.898.1">42</span></span><span class="koboSpan" id="kobo.899.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.900.1">// error</span></span>
</code></pre>
<h2 class="heading-2" id="_idParaDest-188"><span class="koboSpan" id="kobo.901.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.902.1">In the</span><a id="_idIndexMarker390"/><span class="koboSpan" id="kobo.903.1"> first example</span><a id="_idIndexMarker391"/><span class="koboSpan" id="kobo.904.1"> from the previous section, we defined a named lambda expression—that is, a lambda expression that has its closure assigned to a variable. </span><span class="koboSpan" id="kobo.904.2">This variable is then passed as an argument to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.905.1">std::accumulate()</span></code><span class="koboSpan" id="kobo.906.1"> function.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.907.1">This general algorithm takes the beginning and the ending iterators, which define a range, an initial value to accumulate over, and a function that is supposed to accumulate each value in the range to the total. </span><span class="koboSpan" id="kobo.907.2">This function takes a first parameter representing the currently accumulated value and a second parameter representing the current value to accumulate to the total, and it returns the new accumulated value. </span><span class="koboSpan" id="kobo.907.3">Note that I did not use the term </span><code class="inlineCode"><span class="koboSpan" id="kobo.908.1">add</span></code><span class="koboSpan" id="kobo.909.1"> because this can be used for more things than just adding. </span><span class="koboSpan" id="kobo.909.2">It can also be used for calculating a product, concatenating, or other operations that aggregate values together.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.910.1">The two calls to </span><code class="inlineCode"><span class="koboSpan" id="kobo.911.1">std::accumulate()</span></code><span class="koboSpan" id="kobo.912.1"> in this example are almost the same; only the types of the arguments are different:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.913.1">In the first call, we pass iterators to a range of integers (from a </span><code class="inlineCode"><span class="koboSpan" id="kobo.914.1">vector&lt;int&gt;</span></code><span class="koboSpan" id="kobo.915.1">), 0 for the initial sum, and a lambda that adds two integers and returns their sum. </span><span class="koboSpan" id="kobo.915.2">This produces a sum of all integers in the range; for this example, it is </span><code class="inlineCode"><span class="koboSpan" id="kobo.916.1">22</span></code><span class="koboSpan" id="kobo.917.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.918.1">In the second call, we pass iterators to a range of strings (from a </span><code class="inlineCode"><span class="koboSpan" id="kobo.919.1">vector&lt;string&gt;</span></code><span class="koboSpan" id="kobo.920.1">), an empty string for the initial value, and a lambda that concatenates two strings by adding them together and returning the result. </span><span class="koboSpan" id="kobo.920.2">This produces a string that contains all the strings in the range put together one after another; for this example, the result is </span><code class="inlineCode"><span class="koboSpan" id="kobo.921.1">hello world!</span></code><span class="koboSpan" id="kobo.922.1">.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.923.1">Though generic lambdas can be defined anonymously in the place where they are called, it does not really make sense because the very purpose of a generic lambda (which is basically, as we mentioned earlier, a lambda expression template) is to be reused, as shown in the example from the </span><em class="italic"><span class="koboSpan" id="kobo.924.1">How to do it...</span></em><span class="koboSpan" id="kobo.925.1"> section.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.926.1">When defining this</span><a id="_idIndexMarker392"/><span class="koboSpan" id="kobo.927.1"> lambda expression, when used with multiple calls to </span><code class="inlineCode"><span class="koboSpan" id="kobo.928.1">std::accumulate()</span></code><span class="koboSpan" id="kobo.929.1">, instead of specifying concrete types for the lambda parameters (such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.930.1">int</span></code><span class="koboSpan" id="kobo.931.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.932.1">std::string</span></code><span class="koboSpan" id="kobo.933.1">), we used the </span><code class="inlineCode"><span class="koboSpan" id="kobo.934.1">auto</span></code><span class="koboSpan" id="kobo.935.1"> specifier and let the compiler deduce the</span><a id="_idIndexMarker393"/><span class="koboSpan" id="kobo.936.1"> type. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.937.1">When encountering a lambda expression that has the </span><code class="inlineCode"><span class="koboSpan" id="kobo.938.1">auto</span></code><span class="koboSpan" id="kobo.939.1"> specifier for a parameter type, the compiler generates an unnamed function object that has a call operator template. </span><span class="koboSpan" id="kobo.939.2">For the generic lambda expression in this example, the function object would look like this:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.940.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.941.1">__lambda_name__</span></span><span class="koboSpan" id="kobo.942.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.943.1">template</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.944.1">&lt;</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.945.1">typename</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.946.1"> T1, </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.947.1">typename</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.948.1"> T2&gt;</span></span>
<span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.949.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.950.1">operator</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.951.1">()(T1 </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.952.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.953.1"> s, T2 </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.954.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.955.1"> n)</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.956.1">const</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.957.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.958.1">return</span></span><span class="koboSpan" id="kobo.959.1"> s + n; }
  __lambda_name__(</span><span class="hljs-type"><span class="koboSpan" id="kobo.960.1">const</span></span><span class="koboSpan" id="kobo.961.1"> __lambda_name__&amp;) = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.962.1">default</span></span><span class="koboSpan" id="kobo.963.1">;
  __lambda_name__(__lambda_name__&amp;&amp;) = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.964.1">default</span></span><span class="koboSpan" id="kobo.965.1">;
  __lambda_name__&amp; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.966.1">operator</span></span><span class="koboSpan" id="kobo.967.1">=(</span><span class="hljs-type"><span class="koboSpan" id="kobo.968.1">const</span></span><span class="koboSpan" id="kobo.969.1"> __lambda_name__&amp;) = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.970.1">delete</span></span><span class="koboSpan" id="kobo.971.1">;
  ~__lambda_name__() = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.972.1">default</span></span><span class="koboSpan" id="kobo.973.1">;
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.974.1">The call operator is a template with a type parameter for each parameter in the lambda that was specified with </span><code class="inlineCode"><span class="koboSpan" id="kobo.975.1">auto</span></code><span class="koboSpan" id="kobo.976.1">. </span><span class="koboSpan" id="kobo.976.2">The return type of the call operator is also </span><code class="inlineCode"><span class="koboSpan" id="kobo.977.1">auto</span></code><span class="koboSpan" id="kobo.978.1">, which means the compiler will deduce it from the type of the returned value. </span><span class="koboSpan" id="kobo.978.2">This operator template will be instantiated with the actual types that the compiler will identify in the context where the generic lambda is used.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.979.1">The C++20 template lambdas are an improvement of the C++14 generic lambdas, making some scenarios easier. </span><span class="koboSpan" id="kobo.979.2">A typical one was shown in the second example of the previous section, where the use of lambda was restricted with arguments of the type </span><code class="inlineCode"><span class="koboSpan" id="kobo.980.1">std::vector</span></code><span class="koboSpan" id="kobo.981.1">. </span><span class="koboSpan" id="kobo.981.2">Another example is when you want to make sure that two parameters of the lambda have the same type. </span><span class="koboSpan" id="kobo.981.3">Prior to C++20, this was difficult to do, but with template lambdas, it is very easy, as shown in the following example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.982.1">auto</span></span><span class="koboSpan" id="kobo.983.1"> tl = []&lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.984.1">typename</span></span><span class="koboSpan" id="kobo.985.1"> T&gt;(T x, T y)
{
  std::cout &lt;&lt; x &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.986.1">' '</span></span><span class="koboSpan" id="kobo.987.1"> &lt;&lt; y &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.988.1">'\n'</span></span><span class="koboSpan" id="kobo.989.1">;
};
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.990.1">tl</span></span><span class="koboSpan" id="kobo.991.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.992.1">10</span></span><span class="koboSpan" id="kobo.993.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.994.1">20</span></span><span class="koboSpan" id="kobo.995.1">);   </span><span class="hljs-comment"><span class="koboSpan" id="kobo.996.1">// OK</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.997.1">tl</span></span><span class="koboSpan" id="kobo.998.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.999.1">10</span></span><span class="koboSpan" id="kobo.1000.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1001.1">"20"</span></span><span class="koboSpan" id="kobo.1002.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1003.1">// error</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1004.1">Another scenario for template lambdas is when you need to know the type of a parameter so that you can create instances of that type or invoke static members of it. </span><span class="koboSpan" id="kobo.1004.2">With generic lambdas, the solution is as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1005.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1006.1">foo</span></span><span class="koboSpan" id="kobo.1007.1">
{
   </span><span class="hljs-type"><span class="koboSpan" id="kobo.1008.1">static</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1009.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1010.1">f</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1011.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1012.1">{ std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1013.1">"foo\n"</span></span><span class="koboSpan" id="kobo.1014.1">; }
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1015.1">auto</span></span><span class="koboSpan" id="kobo.1016.1"> tl = [](</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1017.1">auto</span></span><span class="koboSpan" id="kobo.1018.1"> x)
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1019.1">using</span></span><span class="koboSpan" id="kobo.1020.1"> T = std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.1021.1">decay_t</span></span><span class="koboSpan" id="kobo.1022.1">&lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1023.1">decltype</span></span><span class="koboSpan" id="kobo.1024.1">(x)&gt;;
  T other;
  T::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1025.1">f</span></span><span class="koboSpan" id="kobo.1026.1">();
};
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1027.1">tl</span></span><span class="koboSpan" id="kobo.1028.1">(foo{});
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1029.1">This solution</span><a id="_idIndexMarker394"/><span class="koboSpan" id="kobo.1030.1"> requires the use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1031.1">std::decay_t</span></code><span class="koboSpan" id="kobo.1032.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1033.1">decltype</span></code><span class="koboSpan" id="kobo.1034.1">. </span><code class="inlineCode"><span class="koboSpan" id="kobo.1035.1">decltype</span></code><span class="koboSpan" id="kobo.1036.1"> is </span><a id="_idIndexMarker395"/><span class="koboSpan" id="kobo.1037.1">a type specifier that yields the type of a specified expression and is primarily used in writing templates. </span><span class="koboSpan" id="kobo.1037.2">On the other hand, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1038.1">std::decay</span></code><span class="koboSpan" id="kobo.1039.1"> is a utility from </span><code class="inlineCode"><span class="koboSpan" id="kobo.1040.1">&lt;type_traits&gt;</span></code><span class="koboSpan" id="kobo.1041.1"> that performs the same type conversions as when passing function arguments by value.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1042.1">However, in C++20, the same lambda can be written as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1043.1">auto</span></span><span class="koboSpan" id="kobo.1044.1"> tl = []&lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1045.1">typename</span></span><span class="koboSpan" id="kobo.1046.1"> T&gt;(T x)
{
  T other;
  T::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1047.1">f</span></span><span class="koboSpan" id="kobo.1048.1">();
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1049.1">A similar situation occurs when we need to do perfect forwarding in a generic lambda, which requires the use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1050.1">decltype</span></code><span class="koboSpan" id="kobo.1051.1"> to determine the types of the arguments:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1052.1">template</span></span><span class="koboSpan" id="kobo.1053.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1054.1">typename</span></span><span class="koboSpan" id="kobo.1055.1"> ...T&gt;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1056.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1057.1">foo</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1058.1">(T&amp;&amp; ... </span><span class="koboSpan" id="kobo.1058.2">args)</span></span><span class="koboSpan" id="kobo.1059.1">
{ </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1060.1">/* ... </span><span class="koboSpan" id="kobo.1060.2">*/</span></span><span class="koboSpan" id="kobo.1061.1"> }
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1062.1">auto</span></span><span class="koboSpan" id="kobo.1063.1"> tl = [](</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1064.1">auto</span></span><span class="koboSpan" id="kobo.1065.1">&amp;&amp; ...args)
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1066.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1067.1">foo</span></span><span class="koboSpan" id="kobo.1068.1">(std::forward&lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1069.1">decltype</span></span><span class="koboSpan" id="kobo.1070.1">(args)&gt;(args)...);
};
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1071.1">tl</span></span><span class="koboSpan" id="kobo.1072.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1073.1">1</span></span><span class="koboSpan" id="kobo.1074.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1075.1">42.99</span></span><span class="koboSpan" id="kobo.1076.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1077.1">"lambda"</span></span><span class="koboSpan" id="kobo.1078.1">);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1079.1">With template lambda, we can rewrite it in a simpler way as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1080.1">auto</span></span><span class="koboSpan" id="kobo.1081.1"> tl = []&lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1082.1">typename</span></span><span class="koboSpan" id="kobo.1083.1"> ...T&gt;(T &amp;&amp; ...args)
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1084.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1085.1">foo</span></span><span class="koboSpan" id="kobo.1086.1">(std::forward&lt;T&gt;(args)...);
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1087.1">As seen in these</span><a id="_idIndexMarker396"/><span class="koboSpan" id="kobo.1088.1"> examples, template lambdas are an improvement on generic </span><a id="_idIndexMarker397"/><span class="koboSpan" id="kobo.1089.1">lambdas, making it easier to handle the scenarios mentioned in this recipe.</span></p>
<h2 class="heading-2" id="_idParaDest-189"><span class="koboSpan" id="kobo.1090.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1091.1">Using lambdas with standard algorithms</span></em><span class="koboSpan" id="kobo.1092.1">, to explore the basics of lambda expressions and how you can utilize them with the standard algorithms</span></li>
<li class="bulletList"><em class="chapterRef"><span class="koboSpan" id="kobo.1093.1">Chapter 1</span></em><span class="koboSpan" id="kobo.1094.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1095.1">Using auto whenever possible</span></em><span class="koboSpan" id="kobo.1096.1">, to understand how automatic type deduction works in C++</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-190"><span class="koboSpan" id="kobo.1097.1">Writing a recursive lambda</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1098.1">Lambdas are </span><a id="_idIndexMarker398"/><span class="koboSpan" id="kobo.1099.1">basically unnamed function objects, which means that it should be possible to call them recursively. </span><span class="koboSpan" id="kobo.1099.2">Indeed, they can be called recursively; however, the mechanism for doing so is not obvious as it requires assigning the lambda to a function wrapper and capturing the wrapper by reference. </span><span class="koboSpan" id="kobo.1099.3">Though it can be argued that a recursive lambda does not really make sense and that a function is probably a better design choice, in this recipe, we will look at how to write a recursive lambda.</span></p>
<h2 class="heading-2" id="_idParaDest-191"><span class="koboSpan" id="kobo.1100.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1101.1">To demonstrate how to write a recursive lambda, we will consider the well-known example of the Fibonacci function. </span><span class="koboSpan" id="kobo.1101.2">This is usually implemented recursively in C++, as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1102.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1103.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1104.1">fib</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1105.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1106.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1107.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1108.1"> n)</span></span><span class="koboSpan" id="kobo.1109.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1110.1">return</span></span><span class="koboSpan" id="kobo.1111.1"> n &lt;= </span><span class="hljs-number"><span class="koboSpan" id="kobo.1112.1">2</span></span><span class="koboSpan" id="kobo.1113.1"> ? </span><span class="hljs-number"><span class="koboSpan" id="kobo.1114.1">1</span></span><span class="koboSpan" id="kobo.1115.1"> : </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1116.1">fib</span></span><span class="koboSpan" id="kobo.1117.1">(n - </span><span class="hljs-number"><span class="koboSpan" id="kobo.1118.1">1</span></span><span class="koboSpan" id="kobo.1119.1">) + </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1120.1">fib</span></span><span class="koboSpan" id="kobo.1121.1">(n - </span><span class="hljs-number"><span class="koboSpan" id="kobo.1122.1">2</span></span><span class="koboSpan" id="kobo.1123.1">);
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1124.1">Having this implementation as a starting point, let’s see how we can rewrite it using a recursive lambda.</span></p>
<h2 class="heading-2" id="_idParaDest-192"><span class="koboSpan" id="kobo.1125.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1126.1">In C++11, in</span><a id="_idIndexMarker399"/><span class="koboSpan" id="kobo.1127.1"> order to write a recursive lambda function, you must do the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1128.1">Define the lambda in a function scope.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1129.1">Assign the lambda to an </span><code class="inlineCode"><span class="koboSpan" id="kobo.1130.1">std::function</span></code><span class="koboSpan" id="kobo.1131.1"> wrapper.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1132.1">Capture the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1133.1">std::function</span></code><span class="koboSpan" id="kobo.1134.1"> object by reference in the lambda in order to call it recursively.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1135.1">In C++14, the above pattern can be simplified using a generic lambda:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1136.1">Define the lambda in a function scope.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1137.1">Declare the first argument with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1138.1">auto</span></code><span class="koboSpan" id="kobo.1139.1"> placeholder; this is used to pass the lambda expression as an argument to itself.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1140.1">Invoke the lambda expression by passing the lambda itself for the first argument.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1141.1">In C++23, this pattern can be further simplified as follows:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1142.1">Define the lambda in a function scope.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1143.1">Declare the first argument </span><code class="inlineCode"><span class="koboSpan" id="kobo.1144.1">this const auto&amp;&amp; self</span></code><span class="koboSpan" id="kobo.1145.1">; this is to enable a new C++23 feature called </span><em class="italic"><span class="koboSpan" id="kobo.1146.1">deducing this</span></em><span class="koboSpan" id="kobo.1147.1"> or </span><em class="italic"><span class="koboSpan" id="kobo.1148.1">explicit object parameter</span></em><span class="koboSpan" id="kobo.1149.1">. </span><span class="koboSpan" id="kobo.1149.2">You can recursively call the lambda expression through the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1150.1">self</span></code><span class="koboSpan" id="kobo.1151.1"> argument.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1152.1">Invoke the lambda expression by calling it with the explicit arguments (if any) and let the compiler deduce the first one.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1153.1">The following are </span><a id="_idIndexMarker400"/><span class="koboSpan" id="kobo.1154.1">examples of recursive lambdas:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1155.1">A recursive Fibonacci lambda expression in the scope of a function that is invoked from the scope where it is defined:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.1156.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1157.1">sample</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1158.1">()</span></span><span class="koboSpan" id="kobo.1159.1">
{
  std::function&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1160.1">int</span></span><span class="koboSpan" id="kobo.1161.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.1162.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1163.1">const</span></span><span class="koboSpan" id="kobo.1164.1">)&gt; lfib =
    [&amp;lfib](</span><span class="hljs-type"><span class="koboSpan" id="kobo.1165.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1166.1">const</span></span><span class="koboSpan" id="kobo.1167.1"> n)
    {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1168.1">return</span></span><span class="koboSpan" id="kobo.1169.1"> n &lt;= </span><span class="hljs-number"><span class="koboSpan" id="kobo.1170.1">2</span></span><span class="koboSpan" id="kobo.1171.1"> ? </span><span class="hljs-number"><span class="koboSpan" id="kobo.1172.1">1</span></span><span class="koboSpan" id="kobo.1173.1"> : </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1174.1">lfib</span></span><span class="koboSpan" id="kobo.1175.1">(n - </span><span class="hljs-number"><span class="koboSpan" id="kobo.1176.1">1</span></span><span class="koboSpan" id="kobo.1177.1">) + </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1178.1">lfib</span></span><span class="koboSpan" id="kobo.1179.1">(n - </span><span class="hljs-number"><span class="koboSpan" id="kobo.1180.1">2</span></span><span class="koboSpan" id="kobo.1181.1">);
    };
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1182.1">auto</span></span><span class="koboSpan" id="kobo.1183.1"> f10 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1184.1">lfib</span></span><span class="koboSpan" id="kobo.1185.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1186.1">10</span></span><span class="koboSpan" id="kobo.1187.1">);
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1188.1">A recursive Fibonacci lambda expression returned by a function, which can be invoked from any scope:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.1189.1">std::function&lt;</span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1190.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1191.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1192.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1193.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1194.1">)</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1195.1">&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1196.1">fib_create</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1197.1">()</span></span><span class="koboSpan" id="kobo.1198.1">
{
  std::function&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1199.1">int</span></span><span class="koboSpan" id="kobo.1200.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.1201.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1202.1">const</span></span><span class="koboSpan" id="kobo.1203.1">)&gt; f = [](</span><span class="hljs-type"><span class="koboSpan" id="kobo.1204.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1205.1">const</span></span><span class="koboSpan" id="kobo.1206.1"> n)
  {
    std::function&lt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1207.1">int</span></span><span class="koboSpan" id="kobo.1208.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.1209.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1210.1">const</span></span><span class="koboSpan" id="kobo.1211.1">)&gt; lfib = [&amp;lfib](</span><span class="hljs-type"><span class="koboSpan" id="kobo.1212.1">int</span></span><span class="koboSpan" id="kobo.1213.1"> n)
    {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1214.1">return</span></span><span class="koboSpan" id="kobo.1215.1"> n &lt;= </span><span class="hljs-number"><span class="koboSpan" id="kobo.1216.1">2</span></span><span class="koboSpan" id="kobo.1217.1"> ? </span><span class="hljs-number"><span class="koboSpan" id="kobo.1218.1">1</span></span><span class="koboSpan" id="kobo.1219.1"> : </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1220.1">lfib</span></span><span class="koboSpan" id="kobo.1221.1">(n - </span><span class="hljs-number"><span class="koboSpan" id="kobo.1222.1">1</span></span><span class="koboSpan" id="kobo.1223.1">) + </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1224.1">lfib</span></span><span class="koboSpan" id="kobo.1225.1">(n - </span><span class="hljs-number"><span class="koboSpan" id="kobo.1226.1">2</span></span><span class="koboSpan" id="kobo.1227.1">);
    };
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1228.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1229.1">lfib</span></span><span class="koboSpan" id="kobo.1230.1">(n);
  };
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1231.1">return</span></span><span class="koboSpan" id="kobo.1232.1"> f;
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1233.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1234.1">sample</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1235.1">()</span></span><span class="koboSpan" id="kobo.1236.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1237.1">auto</span></span><span class="koboSpan" id="kobo.1238.1"> lfib = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1239.1">fib_create</span></span><span class="koboSpan" id="kobo.1240.1">();
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1241.1">auto</span></span><span class="koboSpan" id="kobo.1242.1"> f10 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1243.1">lfib</span></span><span class="koboSpan" id="kobo.1244.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1245.1">10</span></span><span class="koboSpan" id="kobo.1246.1">);
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1247.1">A lambda expression as a member of a class that is invoked recursively:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1248.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1249.1">fibonacci</span></span><span class="koboSpan" id="kobo.1250.1">
{
  std::function&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1251.1">int</span></span><span class="koboSpan" id="kobo.1252.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.1253.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1254.1">const</span></span><span class="koboSpan" id="kobo.1255.1">)&gt; lfib =
    [</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1256.1">this</span></span><span class="koboSpan" id="kobo.1257.1">](</span><span class="hljs-type"><span class="koboSpan" id="kobo.1258.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1259.1">const</span></span><span class="koboSpan" id="kobo.1260.1"> n)
    {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1261.1">return</span></span><span class="koboSpan" id="kobo.1262.1"> n &lt;= </span><span class="hljs-number"><span class="koboSpan" id="kobo.1263.1">2</span></span><span class="koboSpan" id="kobo.1264.1"> ? </span><span class="hljs-number"><span class="koboSpan" id="kobo.1265.1">1</span></span><span class="koboSpan" id="kobo.1266.1"> : </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1267.1">lfib</span></span><span class="koboSpan" id="kobo.1268.1">(n - </span><span class="hljs-number"><span class="koboSpan" id="kobo.1269.1">1</span></span><span class="koboSpan" id="kobo.1270.1">) + </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1271.1">lfib</span></span><span class="koboSpan" id="kobo.1272.1">(n - </span><span class="hljs-number"><span class="koboSpan" id="kobo.1273.1">2</span></span><span class="koboSpan" id="kobo.1274.1">);
    };
};
fibonacci f;
f.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1275.1">lfib</span></span><span class="koboSpan" id="kobo.1276.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1277.1">10</span></span><span class="koboSpan" id="kobo.1278.1">);
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1279.1">A recursive </span><a id="_idIndexMarker401"/><span class="koboSpan" id="kobo.1280.1">Fibonacci generic lambda expression—the C++14 alternative for the example from the first bullet:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.1281.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1282.1">sample</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1283.1">()</span></span><span class="koboSpan" id="kobo.1284.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1285.1">auto</span></span><span class="koboSpan" id="kobo.1286.1"> lfib = [](</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1287.1">auto</span></span><span class="koboSpan" id="kobo.1288.1"> f, </span><span class="hljs-type"><span class="koboSpan" id="kobo.1289.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1290.1">const</span></span><span class="koboSpan" id="kobo.1291.1"> n)
   {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1292.1">if</span></span><span class="koboSpan" id="kobo.1293.1"> (n &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.1294.1">2</span></span><span class="koboSpan" id="kobo.1295.1">) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1296.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1297.1">1</span></span><span class="koboSpan" id="kobo.1298.1">;
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1299.1">else</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1300.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1301.1">f</span></span><span class="koboSpan" id="kobo.1302.1">(f, n - </span><span class="hljs-number"><span class="koboSpan" id="kobo.1303.1">1</span></span><span class="koboSpan" id="kobo.1304.1">) + </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1305.1">f</span></span><span class="koboSpan" id="kobo.1306.1">(f, n - </span><span class="hljs-number"><span class="koboSpan" id="kobo.1307.1">2</span></span><span class="koboSpan" id="kobo.1308.1">);
   };
   </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1309.1">lfib</span></span><span class="koboSpan" id="kobo.1310.1">(lfib, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1311.1">10</span></span><span class="koboSpan" id="kobo.1312.1">);
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1313.1">A recursive Fibonacci lambda expression, taking advantage of the C++23 feature called explicit object parameter (or deducing this), a further simplified alternative to the one above:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.1314.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1315.1">sample</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1316.1">()</span></span><span class="koboSpan" id="kobo.1317.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1318.1">auto</span></span><span class="koboSpan" id="kobo.1319.1"> lfib = [](</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1320.1">this</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1321.1">const</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1322.1">auto</span></span><span class="koboSpan" id="kobo.1323.1">&amp; self, </span><span class="hljs-type"><span class="koboSpan" id="kobo.1324.1">int</span></span><span class="koboSpan" id="kobo.1325.1"> n) -&gt; </span><span class="hljs-type"><span class="koboSpan" id="kobo.1326.1">int</span></span><span class="koboSpan" id="kobo.1327.1">
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1328.1">return</span></span><span class="koboSpan" id="kobo.1329.1"> n &lt;= </span><span class="hljs-number"><span class="koboSpan" id="kobo.1330.1">2</span></span><span class="koboSpan" id="kobo.1331.1"> ? </span><span class="hljs-number"><span class="koboSpan" id="kobo.1332.1">1</span></span><span class="koboSpan" id="kobo.1333.1"> : </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1334.1">self</span></span><span class="koboSpan" id="kobo.1335.1">(n - </span><span class="hljs-number"><span class="koboSpan" id="kobo.1336.1">1</span></span><span class="koboSpan" id="kobo.1337.1">) + </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1338.1">self</span></span><span class="koboSpan" id="kobo.1339.1">(n - </span><span class="hljs-number"><span class="koboSpan" id="kobo.1340.1">2</span></span><span class="koboSpan" id="kobo.1341.1">);
  };
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1342.1">lfib</span></span><span class="koboSpan" id="kobo.1343.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1344.1">5</span></span><span class="koboSpan" id="kobo.1345.1">);
}
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-193"><span class="koboSpan" id="kobo.1346.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1347.1">The first thing you</span><a id="_idIndexMarker402"/><span class="koboSpan" id="kobo.1348.1"> need to consider when writing a recursive lambda in C++11 is that a lambda expression is a function object and, in order to call it recursively from the lambda’s body, the lambda must capture its closure (that is, the instantiation of the lambda). </span><span class="koboSpan" id="kobo.1348.2">In other words, the lambda must capture itself, and this has several implications:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1349.1">First of all, the lambda must have a name; an unnamed lambda cannot be captured so that it can be called again.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1350.1">Secondly, the lambda can only be defined in a function scope. </span><span class="koboSpan" id="kobo.1350.2">The reason for this is that a lambda can only capture variables from a function scope; it cannot capture any variable that has a static storage duration. </span><span class="koboSpan" id="kobo.1350.3">Objects defined in a namespace scope or with the static or external specifiers have static storage duration. </span><span class="koboSpan" id="kobo.1350.4">If the lambda was defined in a namespace scope, its closure would have static storage duration and, therefore, the lambda would not capture it.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1351.1">The third implication is that the type of the lambda closure cannot remain unspecified; that is, it cannot be declared with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1352.1">auto</span></code><span class="koboSpan" id="kobo.1353.1"> specifier. </span><span class="koboSpan" id="kobo.1353.2">It is not possible for a variable declared with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1354.1">auto</span></code><span class="koboSpan" id="kobo.1355.1"> type specifier to appear in its own initializer. </span><span class="koboSpan" id="kobo.1355.2">This is because the type of the variable is not known when the initializer is being processed. </span><span class="koboSpan" id="kobo.1355.3">Therefore, you must specify the type of the lambda closure. </span><span class="koboSpan" id="kobo.1355.4">The way we can do this is by using the general-purpose function wrapper </span><code class="inlineCode"><span class="koboSpan" id="kobo.1356.1">std::function</span></code><span class="koboSpan" id="kobo.1357.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1358.1">Last, but not least, the lambda closure must be captured by reference. </span><span class="koboSpan" id="kobo.1358.2">If we capture by copy (or value), then a copy of the function wrapper is made but the wrapper is uninitialized when the capturing is done. </span><span class="koboSpan" id="kobo.1358.3">We end up with an object that we are not able to call. </span><span class="koboSpan" id="kobo.1358.4">Even though the compiler will not complain about capturing by value, when the closure is invoked, an </span><code class="inlineCode"><span class="koboSpan" id="kobo.1359.1">std::bad_function_call</span></code><span class="koboSpan" id="kobo.1360.1"> is thrown.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1361.1">In the first example </span><a id="_idIndexMarker403"/><span class="koboSpan" id="kobo.1362.1">from the </span><em class="italic"><span class="koboSpan" id="kobo.1363.1">How to do it...</span></em><span class="koboSpan" id="kobo.1364.1"> section, the recursive lambda is defined inside another function called </span><code class="inlineCode"><span class="koboSpan" id="kobo.1365.1">sample()</span></code><span class="koboSpan" id="kobo.1366.1">. </span><span class="koboSpan" id="kobo.1366.2">The signature and the body of the lambda expression are the same as those of the regular recursive function </span><code class="inlineCode"><span class="koboSpan" id="kobo.1367.1">fib</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.1368.1">()</span></code><span class="koboSpan" id="kobo.1369.1">, which was defined in the introductory section. </span><span class="koboSpan" id="kobo.1369.2">The lambda closure is assigned to a function wrapper called </span><code class="inlineCode"><span class="koboSpan" id="kobo.1370.1">lfib</span></code><span class="koboSpan" id="kobo.1371.1">, which is then captured by reference by the lambda and called recursively from its body. </span><span class="koboSpan" id="kobo.1371.2">Since the closure is captured by reference, it will be initialized at the time it has to be called from the lambda’s body.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1372.1">In the second example, we defined a function that returns the closure of a lambda expression that, in turn, defines and invokes a recursive lambda with the argument it was in turn invoked with. </span><span class="koboSpan" id="kobo.1372.2">This is a pattern that must be implemented when a recursive lambda needs to be returned from a function. </span><span class="koboSpan" id="kobo.1372.3">This is necessary because the lambda closure must still be available at the time the recursive lambda is called. </span><span class="koboSpan" id="kobo.1372.4">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1373.1">fib_create()</span></code><span class="koboSpan" id="kobo.1374.1"> method returns a function wrapper that, when invoked, creates the recursive lambda that captures itself. </span><span class="koboSpan" id="kobo.1374.2">The outer </span><code class="inlineCode"><span class="koboSpan" id="kobo.1375.1">f</span></code><span class="koboSpan" id="kobo.1376.1"> lambda does not capture anything, especially by reference; therefore, we don’t have this issue with dangling references. </span><span class="koboSpan" id="kobo.1376.2">However, when invoked, it creates a closure of the nested lambda, which is the actual lambda we are interested in calling, and returns the result of applying that recursive </span><code class="inlineCode"><span class="koboSpan" id="kobo.1377.1">lfib</span></code><span class="koboSpan" id="kobo.1378.1"> lambda to </span><a id="_idIndexMarker404"/><span class="koboSpan" id="kobo.1379.1">its parameter.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1380.1">Writing a recursive lambda is simpler in C++14, as the fourth example from the </span><em class="italic"><span class="koboSpan" id="kobo.1381.1">How to do it…</span></em><span class="koboSpan" id="kobo.1382.1"> section shows. </span><span class="koboSpan" id="kobo.1382.2">Instead of capturing the lambda’s closure, it is passed as an argument (typically, the first). </span><span class="koboSpan" id="kobo.1382.3">For this purpose, a parameter is declared using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1383.1">auto</span></code><span class="koboSpan" id="kobo.1384.1"> placeholder. </span><span class="koboSpan" id="kobo.1384.2">Let’s revisit the implementation in order to discuss it:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1385.1">auto</span></span><span class="koboSpan" id="kobo.1386.1"> lfib = [](</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1387.1">auto</span></span><span class="koboSpan" id="kobo.1388.1"> f, </span><span class="hljs-type"><span class="koboSpan" id="kobo.1389.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1390.1">const</span></span><span class="koboSpan" id="kobo.1391.1"> n)
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1392.1">if</span></span><span class="koboSpan" id="kobo.1393.1"> (n &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.1394.1">2</span></span><span class="koboSpan" id="kobo.1395.1">) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1396.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1397.1">1</span></span><span class="koboSpan" id="kobo.1398.1">;
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1399.1">else</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1400.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1401.1">f</span></span><span class="koboSpan" id="kobo.1402.1">(f, n - </span><span class="hljs-number"><span class="koboSpan" id="kobo.1403.1">1</span></span><span class="koboSpan" id="kobo.1404.1">) + </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1405.1">f</span></span><span class="koboSpan" id="kobo.1406.1">(f, n - </span><span class="hljs-number"><span class="koboSpan" id="kobo.1407.1">2</span></span><span class="koboSpan" id="kobo.1408.1">);
};
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1409.1">lfib</span></span><span class="koboSpan" id="kobo.1410.1">(lfib, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1411.1">10</span></span><span class="koboSpan" id="kobo.1412.1">);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1413.1">A lambda expression</span><a id="_idIndexMarker405"/><span class="koboSpan" id="kobo.1414.1"> is a function object with a function call operator. </span><span class="koboSpan" id="kobo.1414.2">A generic lambda</span><a id="_idIndexMarker406"/><span class="koboSpan" id="kobo.1415.1"> is a function object with a template function call operator. </span><span class="koboSpan" id="kobo.1415.2">The compiler generates code similar to the following for the previous snippet:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1416.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1417.1">__lambda_name_3</span></span><span class="koboSpan" id="kobo.1418.1">
{
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1419.1">public</span></span><span class="koboSpan" id="kobo.1420.1">:
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1421.1">template</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1422.1">&lt;</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1423.1">class</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1424.1"> T1&gt;</span></span>
<span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1425.1">inline</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1426.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1427.1">operator</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1428.1">()(T1 f, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1429.1">const</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1430.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1431.1"> n)</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1432.1">const</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.1433.1">{
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1434.1">if</span></span><span class="koboSpan" id="kobo.1435.1"> (n &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.1436.1">2</span></span><span class="koboSpan" id="kobo.1437.1">) {
         </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1438.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1439.1">1</span></span><span class="koboSpan" id="kobo.1440.1">;
      }
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1441.1">else</span></span><span class="koboSpan" id="kobo.1442.1"> {
         </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1443.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1444.1">f</span></span><span class="koboSpan" id="kobo.1445.1">(f, n - </span><span class="hljs-number"><span class="koboSpan" id="kobo.1446.1">1</span></span><span class="koboSpan" id="kobo.1447.1">) + </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1448.1">f</span></span><span class="koboSpan" id="kobo.1449.1">(f, n - </span><span class="hljs-number"><span class="koboSpan" id="kobo.1450.1">2</span></span><span class="koboSpan" id="kobo.1451.1">);
      }
   }
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1452.1">template</span></span><span class="koboSpan" id="kobo.1453.1">&lt;&gt;
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1454.1">inline</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1455.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1456.1">operator</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1457.1">()</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1458.1">&lt;__lambda_name_3&gt; </span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1459.1">(__lambda_name_3 f, </span></span>
<span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1460.1">const</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1461.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1462.1"> n)</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1463.1">const</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.1464.1">{
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1465.1">if</span></span><span class="koboSpan" id="kobo.1466.1"> (n &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.1467.1">2</span></span><span class="koboSpan" id="kobo.1468.1">) {
         </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1469.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1470.1">1</span></span><span class="koboSpan" id="kobo.1471.1">;
      }
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1472.1">else</span></span><span class="koboSpan" id="kobo.1473.1"> {
         </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1474.1">return</span></span><span class="koboSpan" id="kobo.1475.1"> f.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1476.1">operator</span></span><span class="koboSpan" id="kobo.1477.1">()(__lambda_name_3(f), n - </span><span class="hljs-number"><span class="koboSpan" id="kobo.1478.1">1</span></span><span class="koboSpan" id="kobo.1479.1">) + 
                f.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1480.1">operator</span></span><span class="koboSpan" id="kobo.1481.1">()(__lambda_name_3(f), n - </span><span class="hljs-number"><span class="koboSpan" id="kobo.1482.1">2</span></span><span class="koboSpan" id="kobo.1483.1">);
      }
   }
};
__lambda_name_3 lfib = __lambda_name_3{};
lfib.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1484.1">operator</span></span><span class="koboSpan" id="kobo.1485.1">()(__lambda_name_3(lfib), </span><span class="hljs-number"><span class="koboSpan" id="kobo.1486.1">10</span></span><span class="koboSpan" id="kobo.1487.1">);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1488.1">The function call operator is a template function. </span><span class="koboSpan" id="kobo.1488.2">Its first parameter has the type of the type template parameter. </span><span class="koboSpan" id="kobo.1488.3">For this primary template, a full explicit specialization for the class type itself is provided. </span><span class="koboSpan" id="kobo.1488.4">This makes it possible to invoke the lambda, passing itself as an argument, and therefore, avoiding the capturing of an </span><code class="inlineCode"><span class="koboSpan" id="kobo.1489.1">std::function</span></code><span class="koboSpan" id="kobo.1490.1"> object, as it was necessary to do in C++11.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1491.1">If your compiler</span><a id="_idIndexMarker407"/><span class="koboSpan" id="kobo.1492.1"> supports C++23, then it’s possible to simplify this even further with the help of the </span><em class="italic"><span class="koboSpan" id="kobo.1493.1">explicit object parameter</span></em><span class="koboSpan" id="kobo.1494.1"> feature (also known as </span><em class="italic"><span class="koboSpan" id="kobo.1495.1">deducing this</span></em><span class="koboSpan" id="kobo.1496.1">). </span><span class="koboSpan" id="kobo.1496.2">This feature was designed to enable the compiler to figure out from within a function whether the expression it’s invoked on is an lvalue or an rvalue, or if it is </span><em class="italic"><span class="koboSpan" id="kobo.1497.1">cv-</span></em><span class="koboSpan" id="kobo.1498.1"> or </span><em class="italic"><span class="koboSpan" id="kobo.1499.1">ref-</span></em><span class="koboSpan" id="kobo.1500.1">qualified, and what the type of the expression is. </span><span class="koboSpan" id="kobo.1500.2">This feature makes possible scenarios such as:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1501.1">Avoiding duplicating code with overloads-based </span><em class="italic"><span class="koboSpan" id="kobo.1502.1">cv-</span></em><span class="koboSpan" id="kobo.1503.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.1504.1">ref-</span></em><span class="koboSpan" id="kobo.1505.1">qualifiers (for instance, the same function with no qualifiers and with a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1506.1">const</span></code><span class="koboSpan" id="kobo.1507.1"> qualifier, which is the most usual case).</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1508.1">Simplifying </span><a id="_idIndexMarker408"/><span class="koboSpan" id="kobo.1509.1">the </span><strong class="keyWord"><span class="koboSpan" id="kobo.1510.1">curiously recurring template pattern</span></strong><span class="koboSpan" id="kobo.1511.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.1512.1">CRTP</span></strong><span class="koboSpan" id="kobo.1513.1">) by using simple inheritance and, therefore, removing the recurrence from the pattern.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1514.1">Simplifying writing recursive lambdas.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1515.1">For the example</span><a id="_idIndexMarker409"/><span class="koboSpan" id="kobo.1516.1"> given in the </span><em class="italic"><span class="koboSpan" id="kobo.1517.1">How to do it…</span></em><span class="koboSpan" id="kobo.1518.1"> section, the compiler is able to deduce the type of the first argument, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1519.1">self</span></code><span class="koboSpan" id="kobo.1520.1">, making it unnecessary to explicitly pass the lambda closure as an argument.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1521.1">Notice that in the C++23 example, we have defined a lambda expression using the trailing return type syntax:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1522.1">[](</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1523.1">this</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1524.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1525.1">const</span></span><span class="koboSpan" id="kobo.1526.1"> &amp; self, </span><span class="hljs-type"><span class="koboSpan" id="kobo.1527.1">int</span></span><span class="koboSpan" id="kobo.1528.1"> n) -&gt; </span><span class="hljs-type"><span class="koboSpan" id="kobo.1529.1">int</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1530.1">Without this, you would get a compiler error such as the following:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1531.1">error: function 'operator()&lt;(lambda)&gt;' with deduced return type cannot be used before it is defined
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1532.1">With a small change in the function implementation, shown next, the trailing return type is no longer needed, and the deduce this feature works again:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1533.1">auto</span></span><span class="koboSpan" id="kobo.1534.1"> lfib = [](</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1535.1">this</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1536.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1537.1">const</span></span><span class="koboSpan" id="kobo.1538.1">&amp; self, </span><span class="hljs-type"><span class="koboSpan" id="kobo.1539.1">int</span></span><span class="koboSpan" id="kobo.1540.1"> n)
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1541.1">if</span></span><span class="koboSpan" id="kobo.1542.1"> (n &lt;= </span><span class="hljs-number"><span class="koboSpan" id="kobo.1543.1">2</span></span><span class="koboSpan" id="kobo.1544.1">) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1545.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1546.1">1</span></span><span class="koboSpan" id="kobo.1547.1">;
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1548.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1549.1">self</span></span><span class="koboSpan" id="kobo.1550.1">(n - </span><span class="hljs-number"><span class="koboSpan" id="kobo.1551.1">1</span></span><span class="koboSpan" id="kobo.1552.1">) + </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1553.1">self</span></span><span class="koboSpan" id="kobo.1554.1">(n - </span><span class="hljs-number"><span class="koboSpan" id="kobo.1555.1">2</span></span><span class="koboSpan" id="kobo.1556.1">);
};
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-194"><span class="koboSpan" id="kobo.1557.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1558.1">Using generic and template lambdas</span></em><span class="koboSpan" id="kobo.1559.1">, to learn how to use </span><code class="inlineCode"><span class="koboSpan" id="kobo.1560.1">auto</span></code><span class="koboSpan" id="kobo.1561.1"> for lambda parameters and how to define template lambdas in C++20</span></li>
<li class="bulletList"><em class="chapterRef"><span class="koboSpan" id="kobo.1562.1">Chapter 9</span></em><span class="koboSpan" id="kobo.1563.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1564.1">Static polymorphism with the curiously recurring template pattern</span></em><span class="koboSpan" id="kobo.1565.1">, to learn about what the CRTP is and how it works</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-195"><span class="koboSpan" id="kobo.1566.1">Writing function templates</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1567.1">Generic code</span><a id="_idIndexMarker410"/><span class="koboSpan" id="kobo.1568.1"> is key to avoid writing repetitive code. </span><span class="koboSpan" id="kobo.1568.2">In C++, this is achieved with the help of templates. </span><span class="koboSpan" id="kobo.1568.3">Classes, functions, and variables can be templated. </span><span class="koboSpan" id="kobo.1568.4">Although templates are often seen as complex and cumbersome, they enable the creation of general-purpose libraries, such as the standard library, and help us write less and better code. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.1569.1">Templates </span><a id="_idIndexMarker411"/><span class="koboSpan" id="kobo.1570.1">are first-class citizens of the C++ language and could take an entire book to cover in detail. </span><span class="koboSpan" id="kobo.1570.2">In fact, multiple recipes in this book deal with various aspects of templates. </span><span class="koboSpan" id="kobo.1570.3">In this recipe, we will discuss the basics of writing function templates.</span></p>
<h2 class="heading-2" id="_idParaDest-196"><span class="koboSpan" id="kobo.1571.1">How to do it…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1572.1">Do the following to create</span><a id="_idIndexMarker412"/><span class="koboSpan" id="kobo.1573.1"> function templates:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1574.1">To create a function template, precede the function declaration with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1575.1">template</span></code><span class="koboSpan" id="kobo.1576.1"> keyword followed by the list of template parameters in angle brackets:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1577.1">template</span></span><span class="koboSpan" id="kobo.1578.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1579.1">typename</span></span><span class="koboSpan" id="kobo.1580.1"> T&gt;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.1581.1">T </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1582.1">minimum</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1583.1">(T a, T b)</span></span><span class="koboSpan" id="kobo.1584.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1585.1">return</span></span><span class="koboSpan" id="kobo.1586.1"> a &lt;= b ? </span><span class="koboSpan" id="kobo.1586.2">a : b;
}
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1587.1">minimum</span></span><span class="koboSpan" id="kobo.1588.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1589.1">3</span></span><span class="koboSpan" id="kobo.1590.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1591.1">4</span></span><span class="koboSpan" id="kobo.1592.1">);
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1593.1">minimum</span></span><span class="koboSpan" id="kobo.1594.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1595.1">3.99</span></span><span class="koboSpan" id="kobo.1596.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1597.1">4.01</span></span><span class="koboSpan" id="kobo.1598.1">);
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1599.1">To specialize a function template, leave the list of template parameters empty and replace the template parameters with actual types or values in the function signature:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1600.1">template</span></span><span class="koboSpan" id="kobo.1601.1"> &lt;&gt;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1602.1">const</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1603.1">char</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1604.1">* </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1605.1">minimum</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1606.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1607.1">const</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1608.1">char</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1609.1">* a, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1610.1">const</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1611.1">char</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1612.1">* b)</span></span><span class="koboSpan" id="kobo.1613.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1614.1">return</span></span><span class="koboSpan" id="kobo.1615.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1616.1">strcmp</span></span><span class="koboSpan" id="kobo.1617.1">(a, b) &lt;= </span><span class="hljs-number"><span class="koboSpan" id="kobo.1618.1">1</span></span><span class="koboSpan" id="kobo.1619.1"> ? </span><span class="koboSpan" id="kobo.1619.2">a : b;
}
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1620.1">minimum</span></span><span class="koboSpan" id="kobo.1621.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1622.1">"abc"</span></span><span class="koboSpan" id="kobo.1623.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1624.1">"acxyz"</span></span><span class="koboSpan" id="kobo.1625.1">);
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1626.1">To overload a function template, provide another definition, which can be either a template or a non-template:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1627.1">template</span></span><span class="koboSpan" id="kobo.1628.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1629.1">typename</span></span><span class="koboSpan" id="kobo.1630.1"> T&gt;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.1631.1">std::basic_string&lt;T&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1632.1">minimum</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1633.1">(std::basic_string&lt;T&gt; a, </span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.1634.1">                             std::basic_string&lt;T&gt; b)</span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1635.1">// [1]</span></span><span class="koboSpan" id="kobo.1636.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1637.1">return</span></span><span class="koboSpan" id="kobo.1638.1"> a.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1639.1">length</span></span><span class="koboSpan" id="kobo.1640.1">() &lt;= b.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1641.1">length</span></span><span class="koboSpan" id="kobo.1642.1">() ? </span><span class="koboSpan" id="kobo.1642.2">a : b;
}
</span><span class="hljs-function"><span class="koboSpan" id="kobo.1643.1">std::string </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1644.1">minimum</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1645.1">(std::string a, std::string b)</span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1646.1">// [2]</span></span><span class="koboSpan" id="kobo.1647.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1648.1">return</span></span><span class="koboSpan" id="kobo.1649.1"> a.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1650.1">length</span></span><span class="koboSpan" id="kobo.1651.1">() &lt;= b.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1652.1">length</span></span><span class="koboSpan" id="kobo.1653.1">() ? </span><span class="koboSpan" id="kobo.1653.2">a : b;
}
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1654.1">minimum</span></span><span class="koboSpan" id="kobo.1655.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1656.1">string</span></span><span class="koboSpan" id="kobo.1657.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1658.1">"def"</span></span><span class="koboSpan" id="kobo.1659.1">), std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1660.1">string</span></span><span class="koboSpan" id="kobo.1661.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1662.1">"acxyz"</span></span><span class="koboSpan" id="kobo.1663.1">)); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1664.1">// calls [2]</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.1665.1">minimum</span></span><span class="koboSpan" id="kobo.1666.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1667.1">wstring</span></span><span class="koboSpan" id="kobo.1668.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1669.1">L"def"</span></span><span class="koboSpan" id="kobo.1670.1">), std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1671.1">wstring</span></span><span class="koboSpan" id="kobo.1672.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1673.1">L"acxyz"</span></span><span class="koboSpan" id="kobo.1674.1">)); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1675.1">// calls [1]</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1676.1">To ensure a particular function template or specialization of a function template cannot be called (is deleted from the overload set), declare it as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1677.1">deleted</span></code><span class="koboSpan" id="kobo.1678.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1679.1">template</span></span><span class="koboSpan" id="kobo.1680.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1681.1">typename</span></span><span class="koboSpan" id="kobo.1682.1"> T&gt;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.1683.1">T* </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1684.1">minimum</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1685.1">(T* a, T* b)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1686.1">= </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1687.1">delete</span></span><span class="koboSpan" id="kobo.1688.1">;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1689.1">int</span></span><span class="koboSpan" id="kobo.1690.1"> a = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1691.1">3</span></span><span class="koboSpan" id="kobo.1692.1">;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1693.1">int</span></span><span class="koboSpan" id="kobo.1694.1"> b = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1695.1">4</span></span><span class="koboSpan" id="kobo.1696.1">;
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1697.1">minimum</span></span><span class="koboSpan" id="kobo.1698.1">(&amp;a, &amp;b); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1699.1">// error</span></span>
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-197"><span class="koboSpan" id="kobo.1700.1">How it works…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1701.1">At least at </span><a id="_idIndexMarker413"/><span class="koboSpan" id="kobo.1702.1">first look, function templates are only slightly different from other functions. </span><span class="koboSpan" id="kobo.1702.2">They are introduced with a template syntax and can be parameterized with types, values, or even other templates. </span><span class="koboSpan" id="kobo.1702.3">However, since templates are only blueprints for creating actual code, a function template is basically a blueprint that defines a family of functions. </span><span class="koboSpan" id="kobo.1702.4">Templates only exist in source code, until they are used.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1703.1">The compiler instantiates the templates based on their use. </span><span class="koboSpan" id="kobo.1703.2">This process is called </span><em class="italic"><span class="koboSpan" id="kobo.1704.1">template instantiation</span></em><span class="koboSpan" id="kobo.1705.1">. </span><span class="koboSpan" id="kobo.1705.2">This is</span><a id="_idIndexMarker414"/><span class="koboSpan" id="kobo.1706.1"> done by the compiler by substituting the template arguments. </span><span class="koboSpan" id="kobo.1706.2">For instance, in the case of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1707.1">minimum&lt;T&gt;</span></code><span class="koboSpan" id="kobo.1708.1"> function template shown previously, when we invoke this as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1709.1">minimum&lt;int&gt;(1, 2)</span></code><span class="koboSpan" id="kobo.1710.1">, the compiler substitutes the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1711.1">int</span></code><span class="koboSpan" id="kobo.1712.1"> type for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1713.1">T</span></code><span class="koboSpan" id="kobo.1714.1"> parameter. </span><span class="koboSpan" id="kobo.1714.2">There are two forms of instantiation:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.1715.1">Implicit instantiation</span></strong><span class="koboSpan" id="kobo.1716.1"> occurs when the compiler generates code from a template based on the </span><a id="_idIndexMarker415"/><span class="koboSpan" id="kobo.1717.1">templates used in the code. </span><span class="koboSpan" id="kobo.1717.2">For instance, if the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1718.1">minimum&lt;T&gt;</span></code><span class="koboSpan" id="kobo.1719.1"> function is invoked with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1720.1">int</span></code><span class="koboSpan" id="kobo.1721.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1722.1">double</span></code><span class="koboSpan" id="kobo.1723.1"> values throughout your code, then two overloads (one with integer parameters and one with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1724.1">double</span></code><span class="koboSpan" id="kobo.1725.1"> parameters) are generated. </span><span class="koboSpan" id="kobo.1725.2">This is the implicit instantiation, as shown in the following snippet:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.1726.1">minimum</span></span><span class="koboSpan" id="kobo.1727.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1728.1">int</span></span><span class="koboSpan" id="kobo.1729.1">&gt;(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1730.1">1</span></span><span class="koboSpan" id="kobo.1731.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1732.1">2</span></span><span class="koboSpan" id="kobo.1733.1">);  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1734.1">// explicit int template argument</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.1735.1">minimum</span></span><span class="koboSpan" id="kobo.1736.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1737.1">3.99</span></span><span class="koboSpan" id="kobo.1738.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1739.1">4.50</span></span><span class="koboSpan" id="kobo.1740.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1741.1">// deduced double template argument</span></span>
</code></pre>
</li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.1742.1">Explicit instantiation</span></strong><span class="koboSpan" id="kobo.1743.1"> occurs when you, as a user, request the compiler to generate code from a template even if that instantiation is not used in the code. </span><span class="koboSpan" id="kobo.1743.2">An example of</span><a id="_idIndexMarker416"/><span class="koboSpan" id="kobo.1744.1"> where this is useful is when creating library (binary) files, since uninstantiated templates (which are only blueprints) are not put into object files. </span><span class="koboSpan" id="kobo.1744.2">The following shows an example of explicit instantiation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1745.1">minimum&lt;T&gt;</span></code><span class="koboSpan" id="kobo.1746.1"> function for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1747.1">char</span></code><span class="koboSpan" id="kobo.1748.1"> type. </span><span class="koboSpan" id="kobo.1748.2">Keep in mind that if an explicit instantiation is not defined in the same namespace as the template, the name must be fully qualified in the explicit instantiation definition:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1749.1">template</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1750.1">char</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1751.1">minimum</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1752.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1753.1">char</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1754.1"> a, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1755.1">char</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1756.1"> b)</span></span><span class="koboSpan" id="kobo.1757.1">;
</span></code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1758.1">As </span><a id="_idIndexMarker417"/><span class="koboSpan" id="kobo.1759.1">previously mentioned, templates can have different kinds of parameters. </span><span class="koboSpan" id="kobo.1759.2">These are provided in angle brackets after the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1760.1">template</span></code><span class="koboSpan" id="kobo.1761.1"> keyword and can be the following:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.1762.1">Type template parameters</span></strong><span class="koboSpan" id="kobo.1763.1">, where</span><a id="_idIndexMarker418"/><span class="koboSpan" id="kobo.1764.1"> the parameter is a placeholder for a type. </span><span class="koboSpan" id="kobo.1764.2">This is the case for all the examples seen in the previous section.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.1765.1">Non-type template parameters</span></strong><span class="koboSpan" id="kobo.1766.1">, where the parameter is a value of a structural type. </span><span class="koboSpan" id="kobo.1766.2">The </span><a id="_idIndexMarker419"/><span class="koboSpan" id="kobo.1767.1">integer types, floating-point types (since C++20), pointer types, enumeration types, and lvalue reference types are all structural types. </span><span class="koboSpan" id="kobo.1767.2">In the following example, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1768.1">T</span></code><span class="koboSpan" id="kobo.1769.1"> is a type template parameter and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1770.1">S</span></code><span class="koboSpan" id="kobo.1771.1"> is a non-type template parameter:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1772.1">template</span></span><span class="koboSpan" id="kobo.1773.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1774.1">typename</span></span><span class="koboSpan" id="kobo.1775.1"> T, std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.1776.1">size_t</span></span><span class="koboSpan" id="kobo.1777.1"> S&gt;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.1778.1">std::array&lt;T, S&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1779.1">make_array</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1780.1">()</span></span><span class="koboSpan" id="kobo.1781.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1782.1">return</span></span><span class="koboSpan" id="kobo.1783.1"> std::array&lt;T, S&gt;{};
}
</span></code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1784.1">In C++17, non-type template parameters can be declared using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1785.1">auto</span></code><span class="koboSpan" id="kobo.1786.1"> keyword:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1787.1">template</span></span><span class="koboSpan" id="kobo.1788.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1789.1">typename</span></span><span class="koboSpan" id="kobo.1790.1"> T, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1791.1">auto</span></span><span class="koboSpan" id="kobo.1792.1"> S&gt;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.1793.1">std::array&lt;T, S&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1794.1">make_array</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1795.1">()</span></span><span class="koboSpan" id="kobo.1796.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1797.1">return</span></span><span class="koboSpan" id="kobo.1798.1"> std::array&lt;T, S&gt;{};
}
</span></code></pre>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.1799.1">Template template parameters</span></strong><span class="koboSpan" id="kobo.1800.1">, where the type of the parameter is another type. </span><span class="koboSpan" id="kobo.1800.2">In the </span><a id="_idIndexMarker420"/><span class="koboSpan" id="kobo.1801.1">following example, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1802.1">trimin</span></code><span class="koboSpan" id="kobo.1803.1"> function template has two template parameters, a type template parameter </span><code class="inlineCode"><span class="koboSpan" id="kobo.1804.1">T</span></code><span class="koboSpan" id="kobo.1805.1">, and a template template parameter </span><code class="inlineCode"><span class="koboSpan" id="kobo.1806.1">M</span></code><span class="koboSpan" id="kobo.1807.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1808.1">template</span></span><span class="koboSpan" id="kobo.1809.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1810.1">typename</span></span><span class="koboSpan" id="kobo.1811.1"> T&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1812.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1813.1">Minimum</span></span><span class="koboSpan" id="kobo.1814.1">
{
   </span><span class="hljs-function"><span class="koboSpan" id="kobo.1815.1">T </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1816.1">operator</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1817.1">()(T a, T b)</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.1818.1">{
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1819.1">return</span></span><span class="koboSpan" id="kobo.1820.1"> a &lt;= b ? </span><span class="koboSpan" id="kobo.1820.2">a : b;
   }
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1821.1">template</span></span><span class="koboSpan" id="kobo.1822.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1823.1">typename</span></span><span class="koboSpan" id="kobo.1824.1"> T, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1825.1">template</span></span><span class="koboSpan" id="kobo.1826.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1827.1">typename</span></span><span class="koboSpan" id="kobo.1828.1">&gt; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1829.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1830.1">M</span></span><span class="koboSpan" id="kobo.1831.1">&gt;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.1832.1">T </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1833.1">trimin</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1834.1">(T a, T b, T c)</span></span><span class="koboSpan" id="kobo.1835.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1836.1">return</span></span><span class="koboSpan" id="kobo.1837.1"> M&lt;T&gt;{}(a, M&lt;T&gt;{}(b, c));
}
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1838.1">trimin</span></span><span class="koboSpan" id="kobo.1839.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1840.1">int</span></span><span class="koboSpan" id="kobo.1841.1">, Minimum&gt;(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1842.1">5</span></span><span class="koboSpan" id="kobo.1843.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1844.1">2</span></span><span class="koboSpan" id="kobo.1845.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1846.1">7</span></span><span class="koboSpan" id="kobo.1847.1">);
</span></code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1848.1">Although templates allow us to write one implementation for many types (or template parameters, more generally), it is often useful, or maybe necessary, to provide modified implementations for different types. </span><span class="koboSpan" id="kobo.1848.2">This process of providing alternative implementations for some template parameters </span><a id="_idIndexMarker421"/><span class="koboSpan" id="kobo.1849.1">is called specialization. </span><span class="koboSpan" id="kobo.1849.2">The template that is being specialized is </span><a id="_idIndexMarker422"/><span class="koboSpan" id="kobo.1850.1">called the </span><em class="italic"><span class="koboSpan" id="kobo.1851.1">primary template</span></em><span class="koboSpan" id="kobo.1852.1">. </span><span class="koboSpan" id="kobo.1852.2">There are two possible forms:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.1853.1">Partial specialization</span></strong><span class="koboSpan" id="kobo.1854.1"> is </span><a id="_idIndexMarker423"/><span class="koboSpan" id="kobo.1855.1">when you provide a different implementation only for some of the template parameters.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.1856.1">Full specialization</span></strong><span class="koboSpan" id="kobo.1857.1"> is when</span><a id="_idIndexMarker424"/><span class="koboSpan" id="kobo.1858.1"> you provide a different implementation for the entire set of template parameters.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1859.1">Function templates</span><a id="_idIndexMarker425"/><span class="koboSpan" id="kobo.1860.1"> only support full specialization. </span><span class="koboSpan" id="kobo.1860.2">Partial specialization is only possible for class templates. </span><span class="koboSpan" id="kobo.1860.3">An example of a full specialization was provided in the </span><em class="italic"><span class="koboSpan" id="kobo.1861.1">How to do it…</span></em><span class="koboSpan" id="kobo.1862.1"> section when we specialized the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1863.1">minimum&lt;T&gt;</span></code><span class="koboSpan" id="kobo.1864.1"> function template for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1865.1">const char*</span></code><span class="koboSpan" id="kobo.1866.1"> type. </span><span class="koboSpan" id="kobo.1866.2">Instead of lexicographically comparing the two arguments of the function, we decided which is “smaller” based on their length. </span><span class="koboSpan" id="kobo.1866.3">Keep in mind this was an example given only for the purpose of understanding specialization.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1867.1">Function templates can be overloaded just like any other function. </span><span class="koboSpan" id="kobo.1867.2">You should note that when multiple overloads are available, both template and non-template, the compiler will prefer a non-template overload. </span><span class="koboSpan" id="kobo.1867.3">An example was provided earlier. </span><span class="koboSpan" id="kobo.1867.4">Let’s see it again, with only the declarations of the functions:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1868.1">template</span></span><span class="koboSpan" id="kobo.1869.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1870.1">typename</span></span><span class="koboSpan" id="kobo.1871.1"> T&gt;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.1872.1">std::basic_string&lt;T&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1873.1">minimum</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1874.1">(std::basic_string&lt;T&gt; a, std::basic_string&lt;T&gt; b)</span></span><span class="koboSpan" id="kobo.1875.1">;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.1876.1">std::string </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1877.1">minimum</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1878.1">(std::string a, std::string b)</span></span><span class="koboSpan" id="kobo.1879.1">;
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1880.1">minimum</span></span><span class="koboSpan" id="kobo.1881.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1882.1">string</span></span><span class="koboSpan" id="kobo.1883.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1884.1">"def"</span></span><span class="koboSpan" id="kobo.1885.1">), std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1886.1">string</span></span><span class="koboSpan" id="kobo.1887.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1888.1">"acxyz"</span></span><span class="koboSpan" id="kobo.1889.1">));
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1890.1">minimum</span></span><span class="koboSpan" id="kobo.1891.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1892.1">wstring</span></span><span class="koboSpan" id="kobo.1893.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1894.1">L"def"</span></span><span class="koboSpan" id="kobo.1895.1">), std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1896.1">wstring</span></span><span class="koboSpan" id="kobo.1897.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1898.1">L"acxyz"</span></span><span class="koboSpan" id="kobo.1899.1">));
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1900.1">The first call to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1901.1">minimum</span></code><span class="koboSpan" id="kobo.1902.1"> function takes </span><code class="inlineCode"><span class="koboSpan" id="kobo.1903.1">std::string</span></code><span class="koboSpan" id="kobo.1904.1"> arguments, and, therefore, the non-template overload will be invoked. </span><span class="koboSpan" id="kobo.1904.2">The second call takes </span><code class="inlineCode"><span class="koboSpan" id="kobo.1905.1">std::wstring</span></code><span class="koboSpan" id="kobo.1906.1"> arguments, and since the function template is the only matching overload, its </span><code class="inlineCode"><span class="koboSpan" id="kobo.1907.1">std::wstring</span></code><span class="koboSpan" id="kobo.1908.1"> instantiation will be invoked.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1909.1">Specifying the template arguments during the invocation of a function template is not always necessary. </span><span class="koboSpan" id="kobo.1909.2">The following two calls are identical:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.1910.1">minimum</span></span><span class="koboSpan" id="kobo.1911.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1912.1">1</span></span><span class="koboSpan" id="kobo.1913.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1914.1">2</span></span><span class="koboSpan" id="kobo.1915.1">);
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1916.1">minimum</span></span><span class="koboSpan" id="kobo.1917.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1918.1">int</span></span><span class="koboSpan" id="kobo.1919.1">&gt;(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1920.1">1</span></span><span class="koboSpan" id="kobo.1921.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1922.1">2</span></span><span class="koboSpan" id="kobo.1923.1">);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1924.1">There are many cases</span><a id="_idIndexMarker426"/><span class="koboSpan" id="kobo.1925.1"> where the compiler can deduce the template arguments from the invocation of the function. </span><span class="koboSpan" id="kobo.1925.2">In this example, since both function arguments are integers, it can figure out that the template argument should be the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1926.1">int</span></code><span class="koboSpan" id="kobo.1927.1"> type. </span><span class="koboSpan" id="kobo.1927.2">Therefore, explicitly specifying this is not necessary. </span><span class="koboSpan" id="kobo.1927.3">However, there are also situations in which the compiler cannot deduce the types. </span><span class="koboSpan" id="kobo.1927.4">In these cases, you must provide them explicitly. </span><span class="koboSpan" id="kobo.1927.5">An example is given next:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.1928.1">minimum</span></span><span class="koboSpan" id="kobo.1929.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1930.1">1</span></span><span class="koboSpan" id="kobo.1931.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1932.1">2u</span></span><span class="koboSpan" id="kobo.1933.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1934.1">// error, ambiguous template parameter T</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1935.1">The two arguments are an </span><code class="inlineCode"><span class="koboSpan" id="kobo.1936.1">int</span></code><span class="koboSpan" id="kobo.1937.1"> and an </span><code class="inlineCode"><span class="koboSpan" id="kobo.1938.1">unsigned int</span></code><span class="koboSpan" id="kobo.1939.1">. </span><span class="koboSpan" id="kobo.1939.2">Therefore, the compiler does not know whether the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1940.1">T</span></code><span class="koboSpan" id="kobo.1941.1"> type should be deduced as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1942.1">int</span></code><span class="koboSpan" id="kobo.1943.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1944.1">unsigned int</span></code><span class="koboSpan" id="kobo.1945.1">. </span><span class="koboSpan" id="kobo.1945.2">To solve this ambiguity, you must provide the template argument explicitly:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.1946.1">minimum</span></span><span class="koboSpan" id="kobo.1947.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1948.1">unsigned</span></span><span class="koboSpan" id="kobo.1949.1">&gt;(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1950.1">1</span></span><span class="koboSpan" id="kobo.1951.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1952.1">2u</span></span><span class="koboSpan" id="kobo.1953.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1954.1">// OK</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1955.1">When deducing template arguments, the compiler performs a comparison between the template parameters and the arguments used to invoke the function. </span><span class="koboSpan" id="kobo.1955.2">These must have a certain structure for the comparison to succeed and for the compiler to successfully deduce all the arguments. </span><span class="koboSpan" id="kobo.1955.3">A detailed look at this process is, however, beyond the scope of this recipe. </span><span class="koboSpan" id="kobo.1955.4">You can consult other resources, including my book </span><em class="chapterRef"><span class="koboSpan" id="kobo.1956.1">Template Metaprogramming with C++</span></em><span class="koboSpan" id="kobo.1957.1">, which discusses this in detail in </span><em class="italic"><span class="koboSpan" id="kobo.1958.1">Chapter 4</span></em><span class="koboSpan" id="kobo.1959.1">, both for function templates and class templates.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1960.1">As mentioned in the </span><a id="_idIndexMarker427"/><span class="koboSpan" id="kobo.1961.1">introduction, templates are a broad topic that cannot be covered in one recipe. </span><span class="koboSpan" id="kobo.1961.2">We will learn more about templates throughout the book, including in the next two recipes, where we will discuss function templates with a variable number of arguments.</span></p>
<h2 class="heading-2" id="_idParaDest-198"><span class="koboSpan" id="kobo.1962.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1963.1">Writing a function template with a variable number of arguments</span></em><span class="koboSpan" id="kobo.1964.1">, to learn how to write functions that take a variable number of arguments</span></li>
<li class="bulletList"><em class="chapterRef"><span class="koboSpan" id="kobo.1965.1">Chapter 1</span></em><span class="koboSpan" id="kobo.1966.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1967.1">Simplifying code with class template argument deduction</span></em><span class="koboSpan" id="kobo.1968.1">, to see how template argument deduction works for class templates</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-199"><span class="koboSpan" id="kobo.1969.1">Writing a function template with a variable number of arguments</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1970.1">It is sometimes </span><a id="_idIndexMarker428"/><span class="koboSpan" id="kobo.1971.1">useful to write functions with a variable number of arguments or classes with a variable number of members. </span><span class="koboSpan" id="kobo.1971.2">Typical examples include functions such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1972.1">printf</span></code><span class="koboSpan" id="kobo.1973.1">, which takes a format and a variable number of arguments, or classes such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1974.1">tuple</span></code><span class="koboSpan" id="kobo.1975.1">. </span><span class="koboSpan" id="kobo.1975.2">Before C++11, the former was possible only with the use of variadic macros (which enable writing only type-unsafe functions) and the latter was not possible at all. </span><span class="koboSpan" id="kobo.1975.3">C++11 introduced variadic templates, which are templates with a variable number of arguments that make it possible to write both type-safe function templates with a variable number of arguments, and also class templates with a variable number of members. </span><span class="koboSpan" id="kobo.1975.4">In this recipe, we will look at writing function templates.</span></p>
<h2 class="heading-2" id="_idParaDest-200"><span class="koboSpan" id="kobo.1976.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1977.1">Functions </span><a id="_idIndexMarker429"/><span class="koboSpan" id="kobo.1978.1">with a variable number of arguments are </span><a id="_idIndexMarker430"/><span class="koboSpan" id="kobo.1979.1">called </span><em class="italic"><span class="koboSpan" id="kobo.1980.1">variadic functions</span></em><span class="koboSpan" id="kobo.1981.1">. </span><span class="koboSpan" id="kobo.1981.2">Function</span><a id="_idIndexMarker431"/><span class="koboSpan" id="kobo.1982.1"> templates with a variable number of arguments are called </span><em class="italic"><span class="koboSpan" id="kobo.1983.1">variadic function templates</span></em><span class="koboSpan" id="kobo.1984.1">. </span><span class="koboSpan" id="kobo.1984.2">Knowledge of C++ variadic macros (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1985.1">va_start</span></code><span class="koboSpan" id="kobo.1986.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1987.1">va_end</span></code><span class="koboSpan" id="kobo.1988.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1989.1">va_arg</span></code><span class="koboSpan" id="kobo.1990.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1991.1">va_copy</span></code><span class="koboSpan" id="kobo.1992.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1993.1">va_list</span></code><span class="koboSpan" id="kobo.1994.1">) is not necessary for learning how to write variadic function templates, but it represents a good starting point.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1995.1">We have already used variadic templates in our previous recipes, but this one will provide detailed explanations.</span></p>
<h2 class="heading-2" id="_idParaDest-201"><span class="koboSpan" id="kobo.1996.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1997.1">In order to write variadic function templates, you must perform the following steps:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.1998.1">Define an overload with a fixed number of arguments to end compile-time recursion if the semantics of the variadic function template require it (refer to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1999.1">[1]</span></code><span class="koboSpan" id="kobo.2000.1"> in the following code).</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.2001.1">Define a template parameter pack that is a template parameter that can hold any number of arguments, including zero; these arguments can be either types, non-types, or templates (refer to </span><code class="inlineCode"><span class="koboSpan" id="kobo.2002.1">[2]</span></code><span class="koboSpan" id="kobo.2003.1">).</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.2004.1">Define a function parameter pack to hold any number of function arguments, including zero; the size of the template parameter pack and the corresponding function parameter pack is the same. </span><span class="koboSpan" id="kobo.2004.2">This size can be determined with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2005.1">sizeof...</span></code><span class="koboSpan" id="kobo.2006.1"> operator (refer to </span><code class="inlineCode"><span class="koboSpan" id="kobo.2007.1">[3]</span></code><span class="koboSpan" id="kobo.2008.1"> and refer to the end of the </span><em class="italic"><span class="koboSpan" id="kobo.2009.1">How it works...</span></em><span class="koboSpan" id="kobo.2010.1"> section for information on this operator).</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.2011.1">Expand the parameter pack in order to replace it with the actual arguments being supplied (refer to </span><code class="inlineCode"><span class="koboSpan" id="kobo.2012.1">[4]</span></code><span class="koboSpan" id="kobo.2013.1">).</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.2014.1">The following example, which illustrates all the preceding points, is a variadic function template that adds a variable number of arguments using </span><code class="inlineCode"><span class="koboSpan" id="kobo.2015.1">operator+</span></code><span class="koboSpan" id="kobo.2016.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2017.1">template</span></span><span class="koboSpan" id="kobo.2018.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2019.1">typename</span></span><span class="koboSpan" id="kobo.2020.1"> T&gt;                 </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2021.1">// [1] overload with fixed</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.2022.1">T </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.2023.1">add</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2024.1">(T value)</span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2025.1">//     number of arguments</span></span><span class="koboSpan" id="kobo.2026.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2027.1">return</span></span><span class="koboSpan" id="kobo.2028.1"> value;
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2029.1">template</span></span><span class="koboSpan" id="kobo.2030.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2031.1">typename</span></span><span class="koboSpan" id="kobo.2032.1"> T, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2033.1">typename</span></span><span class="koboSpan" id="kobo.2034.1">... </span><span class="koboSpan" id="kobo.2034.2">Ts&gt; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2035.1">// [2] typename... </span><span class="koboSpan" id="kobo.2035.2">Ts</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.2036.1">T </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.2037.1">add</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2038.1">(T head, Ts... </span><span class="koboSpan" id="kobo.2038.2">rest)</span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2039.1">// [3] Ts... </span><span class="koboSpan" id="kobo.2039.2">rest</span></span><span class="koboSpan" id="kobo.2040.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2041.1">return</span></span><span class="koboSpan" id="kobo.2042.1"> head + </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2043.1">add</span></span><span class="koboSpan" id="kobo.2044.1">(rest...);         </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2045.1">// [4] rest...</span></span><span class="koboSpan" id="kobo.2046.1">
}
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-202"><span class="koboSpan" id="kobo.2047.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2048.1">At first </span><a id="_idIndexMarker432"/><span class="koboSpan" id="kobo.2049.1">glance, the preceding implementation looks like recursion because the function </span><code class="inlineCode"><span class="koboSpan" id="kobo.2050.1">add()</span></code><span class="koboSpan" id="kobo.2051.1"> calls itself, and in a way it is, but it is a compile-time recursion that does not incur any sort of runtime recursion and overhead. </span><span class="koboSpan" id="kobo.2051.2">The compiler actually generates several functions with a different number of arguments, based on the variadic function template’s usage, so only function overloading is involved and not any sort of recursion. </span><span class="koboSpan" id="kobo.2051.3">However, implementation is done as if parameters would be processed in a recursive manner with an end condition.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2052.1">In the preceding code, we can identify the following key parts:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.2053.1">Typename... </span><span class="koboSpan" id="kobo.2053.2">Ts</span></code><span class="koboSpan" id="kobo.2054.1"> is a template parameter pack that indicates a variable number of template type arguments.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.2055.1">Ts... </span><span class="koboSpan" id="kobo.2055.2">rest</span></code><span class="koboSpan" id="kobo.2056.1"> is a function parameter pack that indicates a variable number of function arguments.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.2057.1">rest...</span></code><span class="koboSpan" id="kobo.2058.1"> is an expansion of the function parameter pack.</span></li>
</ul>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.2059.1">The position of the ellipsis is not syntactically relevant. </span><code class="inlineCode"><span class="koboSpan" id="kobo.2060.1">typename... </span><span class="koboSpan" id="kobo.2060.2">Ts</span></code><span class="koboSpan" id="kobo.2061.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2062.1">typename ... </span><span class="koboSpan" id="kobo.2062.2">Ts</span></code><span class="koboSpan" id="kobo.2063.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2064.1">typename ...Ts</span></code><span class="koboSpan" id="kobo.2065.1"> are all equivalent.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.2066.1">In the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2067.1">add(T head, Ts... </span><span class="koboSpan" id="kobo.2067.2">rest)</span></code><span class="koboSpan" id="kobo.2068.1"> parameter, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2069.1">head</span></code><span class="koboSpan" id="kobo.2070.1"> is the first element of the list of arguments, while </span><code class="inlineCode"><span class="koboSpan" id="kobo.2071.1">...rest</span></code><span class="koboSpan" id="kobo.2072.1"> is a pack with the rest of the parameters in the list (this can be zero or more). </span><span class="koboSpan" id="kobo.2072.2">In the body of the function, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2073.1">rest...</span></code><span class="koboSpan" id="kobo.2074.1"> is an expansion of the function parameter pack. </span><span class="koboSpan" id="kobo.2074.2">This means the compiler replaces the parameter pack with its elements in their order. </span><span class="koboSpan" id="kobo.2074.3">In the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2075.1">add()</span></code><span class="koboSpan" id="kobo.2076.1"> function, we basically add the first argument to the sum of the remaining arguments, which gives the impression of recursive processing. </span><span class="koboSpan" id="kobo.2076.2">This recursion ends when there is a single argument left, in which case the first </span><code class="inlineCode"><span class="koboSpan" id="kobo.2077.1">add()</span></code><span class="koboSpan" id="kobo.2078.1"> overload (with a single argument) is called and returns the value of its argument.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2079.1">This implementation of the function template </span><code class="inlineCode"><span class="koboSpan" id="kobo.2080.1">add()</span></code><span class="koboSpan" id="kobo.2081.1"> enables us to write code, as shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2082.1">auto</span></span><span class="koboSpan" id="kobo.2083.1"> s1 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2084.1">add</span></span><span class="koboSpan" id="kobo.2085.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2086.1">1</span></span><span class="koboSpan" id="kobo.2087.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2088.1">2</span></span><span class="koboSpan" id="kobo.2089.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2090.1">3</span></span><span class="koboSpan" id="kobo.2091.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2092.1">4</span></span><span class="koboSpan" id="kobo.2093.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2094.1">5</span></span><span class="koboSpan" id="kobo.2095.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2096.1">// s1 = 15</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2097.1">auto</span></span><span class="koboSpan" id="kobo.2098.1"> s2 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2099.1">add</span></span><span class="koboSpan" id="kobo.2100.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2101.1">"hello"</span></span><span class="koboSpan" id="kobo.2102.1">s, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2103.1">" "</span></span><span class="koboSpan" id="kobo.2104.1">s, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2105.1">"world"</span></span><span class="koboSpan" id="kobo.2106.1">s, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2107.1">"!"</span></span><span class="koboSpan" id="kobo.2108.1">s); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2109.1">// s2 = "hello world!"</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2110.1">When the compiler encounters </span><code class="inlineCode"><span class="koboSpan" id="kobo.2111.1">add(1, 2, 3, 4, 5)</span></code><span class="koboSpan" id="kobo.2112.1">, it generates the following functions (notice that </span><code class="inlineCode"><span class="koboSpan" id="kobo.2113.1">arg1</span></code><span class="koboSpan" id="kobo.2114.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2115.1">arg2</span></code><span class="koboSpan" id="kobo.2116.1">, and so on are not the actual names the compiler generates), which shows that this process is actually only a sequence of calls to overloaded functions and not recursion:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.2117.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2118.1">add</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2119.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2120.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2121.1"> head, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2122.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2123.1"> arg1, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2124.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2125.1"> arg2, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2126.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2127.1"> arg3, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2128.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2129.1"> arg4)</span></span><span class="koboSpan" id="kobo.2130.1">
{</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2131.1">return</span></span><span class="koboSpan" id="kobo.2132.1"> head + </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2133.1">add</span></span><span class="koboSpan" id="kobo.2134.1">(arg1, arg2, arg3, arg4);}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.2135.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2136.1">add</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2137.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2138.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2139.1"> head, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2140.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2141.1"> arg1, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2142.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2143.1"> arg2, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2144.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2145.1"> arg3)</span></span><span class="koboSpan" id="kobo.2146.1">
{</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2147.1">return</span></span><span class="koboSpan" id="kobo.2148.1"> head + </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2149.1">add</span></span><span class="koboSpan" id="kobo.2150.1">(arg1, arg2, arg3);}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.2151.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2152.1">add</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2153.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2154.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2155.1"> head, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2156.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2157.1"> arg1, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2158.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2159.1"> arg2)</span></span><span class="koboSpan" id="kobo.2160.1">
{</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2161.1">return</span></span><span class="koboSpan" id="kobo.2162.1"> head + </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2163.1">add</span></span><span class="koboSpan" id="kobo.2164.1">(arg1, arg2);}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.2165.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2166.1">add</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2167.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2168.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2169.1"> head, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2170.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2171.1"> arg1)</span></span><span class="koboSpan" id="kobo.2172.1">
{</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2173.1">return</span></span><span class="koboSpan" id="kobo.2174.1"> head + </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2175.1">add</span></span><span class="koboSpan" id="kobo.2176.1">(arg1);}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.2177.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2178.1">add</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2179.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2180.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2181.1"> value)</span></span><span class="koboSpan" id="kobo.2182.1">
{</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2183.1">return</span></span><span class="koboSpan" id="kobo.2184.1"> value;}
</span></code></pre>
<div class="packt_tip">
<p class="normal"><span class="koboSpan" id="kobo.2185.1">With GCC and Clang, you can use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2186.1">__PRETTY_FUNCTION__</span></code><span class="koboSpan" id="kobo.2187.1"> macro to print the name and the signature of the function.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.2188.1">By adding </span><a id="_idIndexMarker433"/><span class="koboSpan" id="kobo.2189.1">an </span><code class="inlineCode"><span class="koboSpan" id="kobo.2190.1">std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl</span></code><span class="koboSpan" id="kobo.2191.1">, when using GCC or Clang, at the beginning of the two functions we wrote, we get the following when running the code:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2192.1">With GCC:
        </span><pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2193.1">T add(T, Ts ...) [with T = int; Ts = {int, int, int, int}]
T add(T, Ts ...) [with T = int; Ts = {int, int, int}]
T add(T, Ts ...) [with T = int; Ts = {int, int}]
T add(T, Ts ...) [with T = int; Ts = {int}]
T add(T) [with T = int]
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2194.1">With Clang:
        </span><pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2195.1">T add(T, Ts...) [T = int, Ts = &lt;int, int, int, int&gt;]
T add(T, Ts...) [T = int, Ts = &lt;int, int, int&gt;]
T add(T, Ts...) [T = int, Ts = &lt;int, int&gt;]
T add(T, Ts...) [T = int, Ts = &lt;int&gt;]
T add(T) [T = int]
</span></code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.2196.1">Since this is a function template, it can be used with any type that supports </span><code class="inlineCode"><span class="koboSpan" id="kobo.2197.1">operator+</span></code><span class="koboSpan" id="kobo.2198.1">. </span><span class="koboSpan" id="kobo.2198.2">The other example, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2199.1">add("hello"s, " "s, "world"s, "!"s)</span></code><span class="koboSpan" id="kobo.2200.1">, produces the </span><em class="italic"><span class="koboSpan" id="kobo.2201.1">hello world!</span></em><span class="koboSpan" id="kobo.2202.1"> string. </span><span class="koboSpan" id="kobo.2202.2">However, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2203.1">std::basic_string</span></code><span class="koboSpan" id="kobo.2204.1"> type has different overloads for </span><code class="inlineCode"><span class="koboSpan" id="kobo.2205.1">operator+</span></code><span class="koboSpan" id="kobo.2206.1">, including one that can concatenate a string into a character, so we should be able to also write the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2207.1">auto</span></span><span class="koboSpan" id="kobo.2208.1"> s3 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2209.1">add</span></span><span class="koboSpan" id="kobo.2210.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2211.1">"hello"</span></span><span class="koboSpan" id="kobo.2212.1">s, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2213.1">' '</span></span><span class="koboSpan" id="kobo.2214.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2215.1">"world"</span></span><span class="koboSpan" id="kobo.2216.1">s, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2217.1">'!'</span></span><span class="koboSpan" id="kobo.2218.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2219.1">// s3 = "hello world!"</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2220.1">However, that will generate compiler errors, as follows (note that I actually replaced </span><code class="inlineCode"><span class="koboSpan" id="kobo.2221.1">std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;</span></code><span class="koboSpan" id="kobo.2222.1"> with the string </span><em class="italic"><span class="koboSpan" id="kobo.2223.1">hello world!</span></em><span class="koboSpan" id="kobo.2224.1"> for simplicity):</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2225.1">In instantiation of 'T add(T, Ts ...) [with T = char; Ts = {string, char}]':
16:29:   required from 'T add(T, Ts ...) [with T = string; Ts = {char, string, char}]'
22:46:   required from here
16:29: error: cannot convert 'string' to 'char' in return
 In function 'T add(T, Ts ...) [with T = char; Ts = {string, char}]':
17:1: warning: control reaches end of non-void function [-Wreturn-type]
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2226.1">What</span><a id="_idIndexMarker434"/><span class="koboSpan" id="kobo.2227.1"> happens is that the compiler generates the code shown here, where the return type is the same as the type of the first argument. </span><span class="koboSpan" id="kobo.2227.2">However, the first argument is either an </span><code class="inlineCode"><span class="koboSpan" id="kobo.2228.1">std::string</span></code><span class="koboSpan" id="kobo.2229.1"> or a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2230.1">char</span></code><span class="koboSpan" id="kobo.2231.1"> (again, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2232.1">std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;</span></code><span class="koboSpan" id="kobo.2233.1"> was replaced with </span><code class="inlineCode"><span class="koboSpan" id="kobo.2234.1">string</span></code><span class="koboSpan" id="kobo.2235.1"> for simplicity). </span><span class="koboSpan" id="kobo.2235.2">In cases where </span><code class="inlineCode"><span class="koboSpan" id="kobo.2236.1">char</span></code><span class="koboSpan" id="kobo.2237.1"> is the type of the first argument, the type of the return value </span><code class="inlineCode"><span class="koboSpan" id="kobo.2238.1">head+add</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.2239.1">(...)</span></code><span class="koboSpan" id="kobo.2240.1">, which is an </span><code class="inlineCode"><span class="koboSpan" id="kobo.2241.1">std::string</span></code><span class="koboSpan" id="kobo.2242.1">, does not match the function return type and does not have an implicit conversion to it:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.2243.1">string </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.2244.1">add</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2245.1">(string head, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2246.1">char</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2247.1"> arg1, string arg2, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2248.1">char</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2249.1"> arg3)</span></span><span class="koboSpan" id="kobo.2250.1">
{</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2251.1">return</span></span><span class="koboSpan" id="kobo.2252.1"> head + </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2253.1">add</span></span><span class="koboSpan" id="kobo.2254.1">(arg1, arg2, arg3);}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.2255.1">char</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2256.1">add</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2257.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2258.1">char</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2259.1"> head, string arg1, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2260.1">char</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2261.1"> arg2)</span></span><span class="koboSpan" id="kobo.2262.1">
{</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2263.1">return</span></span><span class="koboSpan" id="kobo.2264.1"> head + </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2265.1">add</span></span><span class="koboSpan" id="kobo.2266.1">(arg1, arg2);}
</span><span class="hljs-function"><span class="koboSpan" id="kobo.2267.1">string </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.2268.1">add</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2269.1">(string head, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2270.1">char</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2271.1"> arg1)</span></span><span class="koboSpan" id="kobo.2272.1">
{</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2273.1">return</span></span><span class="koboSpan" id="kobo.2274.1"> head + </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2275.1">add</span></span><span class="koboSpan" id="kobo.2276.1">(arg1);}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.2277.1">char</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2278.1">add</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2279.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2280.1">char</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2281.1"> value)</span></span><span class="koboSpan" id="kobo.2282.1">
{</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2283.1">return</span></span><span class="koboSpan" id="kobo.2284.1"> value;}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2285.1">We can fix this by modifying the variadic function template so that it has </span><code class="inlineCode"><span class="koboSpan" id="kobo.2286.1">auto</span></code><span class="koboSpan" id="kobo.2287.1"> for the return type instead of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2288.1">T</span></code><span class="koboSpan" id="kobo.2289.1">. </span><span class="koboSpan" id="kobo.2289.2">In this case, the return type is always inferred from the return expression, and in our example, it will be </span><code class="inlineCode"><span class="koboSpan" id="kobo.2290.1">std::string</span></code><span class="koboSpan" id="kobo.2291.1"> in all cases:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2292.1">template</span></span><span class="koboSpan" id="kobo.2293.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2294.1">typename</span></span><span class="koboSpan" id="kobo.2295.1"> T, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2296.1">typename</span></span><span class="koboSpan" id="kobo.2297.1">... </span><span class="koboSpan" id="kobo.2297.2">Ts&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2298.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2299.1">add</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2300.1">(T head, Ts... </span><span class="koboSpan" id="kobo.2300.2">rest)</span></span><span class="koboSpan" id="kobo.2301.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2302.1">return</span></span><span class="koboSpan" id="kobo.2303.1"> head + </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2304.1">add</span></span><span class="koboSpan" id="kobo.2305.1">(rest...);
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2306.1">It should be</span><a id="_idIndexMarker435"/><span class="koboSpan" id="kobo.2307.1"> further added that a parameter pack can appear in a brace initialization and that its size can be determined using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2308.1">sizeof...</span></code><span class="koboSpan" id="kobo.2309.1"> operator. </span><span class="koboSpan" id="kobo.2309.2">Also, variadic function templates do not necessarily imply compile-time recursion, as we have shown in this recipe. </span><span class="koboSpan" id="kobo.2309.3">All these are shown in the following example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2310.1">template</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.2311.1">&lt;</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2312.1">typename</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.2313.1">... </span><span class="koboSpan" id="kobo.2313.2">T&gt;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2314.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2315.1">make_even_tuple</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2316.1">(T... </span><span class="koboSpan" id="kobo.2316.2">a)</span></span><span class="koboSpan" id="kobo.2317.1">
{
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2318.1">static_assert</span></span><span class="koboSpan" id="kobo.2319.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2320.1">sizeof</span></span><span class="koboSpan" id="kobo.2321.1">...(a) % </span><span class="hljs-number"><span class="koboSpan" id="kobo.2322.1">2</span></span><span class="koboSpan" id="kobo.2323.1"> == </span><span class="hljs-number"><span class="koboSpan" id="kobo.2324.1">0</span></span><span class="koboSpan" id="kobo.2325.1">,
                </span><span class="hljs-string"><span class="koboSpan" id="kobo.2326.1">"expected an even number of arguments"</span></span><span class="koboSpan" id="kobo.2327.1">);
  std::tuple&lt;T...&gt; t { a... </span><span class="koboSpan" id="kobo.2327.2">};
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2328.1">return</span></span><span class="koboSpan" id="kobo.2329.1"> t;
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2330.1">auto</span></span><span class="koboSpan" id="kobo.2331.1"> t1 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2332.1">make_even_tuple</span></span><span class="koboSpan" id="kobo.2333.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2334.1">1</span></span><span class="koboSpan" id="kobo.2335.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2336.1">2</span></span><span class="koboSpan" id="kobo.2337.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2338.1">3</span></span><span class="koboSpan" id="kobo.2339.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2340.1">4</span></span><span class="koboSpan" id="kobo.2341.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2342.1">// OK</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.2343.1">// error: expected an even number of arguments</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2344.1">auto</span></span><span class="koboSpan" id="kobo.2345.1"> t2 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2346.1">make_even_tuple</span></span><span class="koboSpan" id="kobo.2347.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2348.1">1</span></span><span class="koboSpan" id="kobo.2349.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2350.1">2</span></span><span class="koboSpan" id="kobo.2351.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2352.1">3</span></span><span class="koboSpan" id="kobo.2353.1">);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2354.1">In the preceding snippet, we have defined a function that creates a tuple with an even number of members. </span><span class="koboSpan" id="kobo.2354.2">We first use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2355.1">sizeof...(a)</span></code><span class="koboSpan" id="kobo.2356.1"> to make sure that we have an even number of arguments and assert by generating a compiler error otherwise. </span><span class="koboSpan" id="kobo.2356.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2357.1">sizeof...</span></code><span class="koboSpan" id="kobo.2358.1"> operator can be used with both template parameter packs and function parameter packs. </span><code class="inlineCode"><span class="koboSpan" id="kobo.2359.1">sizeof...(a)</span></code><span class="koboSpan" id="kobo.2360.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2361.1">sizeof...(T)</span></code><span class="koboSpan" id="kobo.2362.1"> would produce the same value. </span><span class="koboSpan" id="kobo.2362.2">Then, we create and return a tuple. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.2363.1">The template parameter pack </span><code class="inlineCode"><span class="koboSpan" id="kobo.2364.1">T</span></code><span class="koboSpan" id="kobo.2365.1"> is expanded (with </span><code class="inlineCode"><span class="koboSpan" id="kobo.2366.1">T...</span></code><span class="koboSpan" id="kobo.2367.1">) into the type arguments of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2368.1">std::tuple</span></code><span class="koboSpan" id="kobo.2369.1"> class template, and the function parameter pack </span><code class="inlineCode"><span class="koboSpan" id="kobo.2370.1">a</span></code><span class="koboSpan" id="kobo.2371.1"> is expanded (with </span><code class="inlineCode"><span class="koboSpan" id="kobo.2372.1">a...</span></code><span class="koboSpan" id="kobo.2373.1">) into the values for the tuple members using brace </span><a id="_idIndexMarker436"/><span class="koboSpan" id="kobo.2374.1">initialization.</span></p>
<h2 class="heading-2" id="_idParaDest-203"><span class="koboSpan" id="kobo.2375.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.2376.1">Using fold expressions to simplify variadic function templates</span></em><span class="koboSpan" id="kobo.2377.1">, to learn how to write simpler and clearer code when creating function templates with a variable number of arguments</span></li>
<li class="bulletList"><em class="chapterRef"><span class="koboSpan" id="kobo.2378.1">Chapter 2</span></em><span class="koboSpan" id="kobo.2379.1">, </span><em class="italic"><span class="koboSpan" id="kobo.2380.1">Creating raw user-defined literals</span></em><span class="koboSpan" id="kobo.2381.1">, to understand how to provide a custom interpretation of an input sequence so that it changes the normal behavior of the compiler</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-204"><span class="koboSpan" id="kobo.2382.1">Using fold expressions to simplify variadic function templates</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.2383.1">In this chapter, we have already discussed folding several times; this is an operation that applies a binary function to a range of values to produce a single value. </span><span class="koboSpan" id="kobo.2383.2">We saw this when we discussed variadic function templates and we will see it again with higher-order functions. </span><span class="koboSpan" id="kobo.2383.3">It turns out there is a significant number of cases where the expansion of a parameter pack in variadic function templates is basically a folding operation. </span><span class="koboSpan" id="kobo.2383.4">To simplify writing such variadic function templates, C++17 introduced fold expressions, which fold an </span><a id="_idIndexMarker437"/><span class="koboSpan" id="kobo.2384.1">expansion of a parameter pack over a binary operator. </span><span class="koboSpan" id="kobo.2384.2">In this recipe, we will learn how to use fold expressions to simplify writing variadic function templates.</span></p>
<h2 class="heading-2" id="_idParaDest-205"><span class="koboSpan" id="kobo.2385.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2386.1">The</span><a id="_idIndexMarker438"/><span class="koboSpan" id="kobo.2387.1"> examples in this recipe are</span><a id="_idIndexMarker439"/><span class="koboSpan" id="kobo.2388.1"> based on the variadic function template </span><code class="inlineCode"><span class="koboSpan" id="kobo.2389.1">add</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.2390.1">()</span></code><span class="koboSpan" id="kobo.2391.1">, which we wrote in the previous recipe, </span><em class="italic"><span class="koboSpan" id="kobo.2392.1">Writing a function template with a variable number of arguments</span></em><span class="koboSpan" id="kobo.2393.1">. </span><span class="koboSpan" id="kobo.2393.2">That implementation is a left-folding operation. </span><span class="koboSpan" id="kobo.2393.3">For simplicity, we’ll present the function again:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2394.1">template</span></span><span class="koboSpan" id="kobo.2395.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2396.1">typename</span></span><span class="koboSpan" id="kobo.2397.1"> T&gt;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.2398.1">T </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.2399.1">add</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2400.1">(T value)</span></span><span class="koboSpan" id="kobo.2401.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2402.1">return</span></span><span class="koboSpan" id="kobo.2403.1"> value;
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2404.1">template</span></span><span class="koboSpan" id="kobo.2405.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2406.1">typename</span></span><span class="koboSpan" id="kobo.2407.1"> T, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2408.1">typename</span></span><span class="koboSpan" id="kobo.2409.1">... </span><span class="koboSpan" id="kobo.2409.2">Ts&gt;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.2410.1">T </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.2411.1">add</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2412.1">(T head, Ts... </span><span class="koboSpan" id="kobo.2412.2">rest)</span></span><span class="koboSpan" id="kobo.2413.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2414.1">return</span></span><span class="koboSpan" id="kobo.2415.1"> head + </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2416.1">add</span></span><span class="koboSpan" id="kobo.2417.1">(rest...);
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2418.1">In the next section, we will learn how this particular implementation can be simplified, as well as other examples of using fold expressions.</span></p>
<h2 class="heading-2" id="_idParaDest-206"><span class="koboSpan" id="kobo.2419.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2420.1">To fold </span><a id="_idIndexMarker440"/><span class="koboSpan" id="kobo.2421.1">a parameter</span><a id="_idIndexMarker441"/><span class="koboSpan" id="kobo.2422.1"> pack over a binary operator, use one of the following forms:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2423.1">Left folding with a unary form </span><code class="inlineCode"><span class="koboSpan" id="kobo.2424.1">(... </span><span class="koboSpan" id="kobo.2424.2">op pack)</span></code><span class="koboSpan" id="kobo.2425.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2426.1">template</span></span><span class="koboSpan" id="kobo.2427.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2428.1">typename</span></span><span class="koboSpan" id="kobo.2429.1">... </span><span class="koboSpan" id="kobo.2429.2">Ts&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2430.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2431.1">add</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2432.1">(Ts... </span><span class="koboSpan" id="kobo.2432.2">args)</span></span><span class="koboSpan" id="kobo.2433.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2434.1">return</span></span><span class="koboSpan" id="kobo.2435.1"> (... </span><span class="koboSpan" id="kobo.2435.2">+ args);
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2436.1">Left folding with a binary form </span><code class="inlineCode"><span class="koboSpan" id="kobo.2437.1">(init op ... </span><span class="koboSpan" id="kobo.2437.2">op pack)</span></code><span class="koboSpan" id="kobo.2438.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2439.1">template</span></span><span class="koboSpan" id="kobo.2440.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2441.1">typename</span></span><span class="koboSpan" id="kobo.2442.1">... </span><span class="koboSpan" id="kobo.2442.2">Ts&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2443.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2444.1">add_to_one</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2445.1">(Ts... </span><span class="koboSpan" id="kobo.2445.2">args)</span></span><span class="koboSpan" id="kobo.2446.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2447.1">return</span></span><span class="koboSpan" id="kobo.2448.1"> (</span><span class="hljs-number"><span class="koboSpan" id="kobo.2449.1">1</span></span><span class="koboSpan" id="kobo.2450.1"> + ... </span><span class="koboSpan" id="kobo.2450.2">+ args);
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2451.1">Right folding with a unary form </span><code class="inlineCode"><span class="koboSpan" id="kobo.2452.1">(pack op ...)</span></code><span class="koboSpan" id="kobo.2453.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2454.1">template</span></span><span class="koboSpan" id="kobo.2455.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2456.1">typename</span></span><span class="koboSpan" id="kobo.2457.1">... </span><span class="koboSpan" id="kobo.2457.2">Ts&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2458.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2459.1">add</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2460.1">(Ts... </span><span class="koboSpan" id="kobo.2460.2">args)</span></span><span class="koboSpan" id="kobo.2461.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2462.1">return</span></span><span class="koboSpan" id="kobo.2463.1"> (args + ...);
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2464.1">Right folding with a binary form </span><code class="inlineCode"><span class="koboSpan" id="kobo.2465.1">(pack op ... </span><span class="koboSpan" id="kobo.2465.2">op init)</span></code><span class="koboSpan" id="kobo.2466.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2467.1">template</span></span><span class="koboSpan" id="kobo.2468.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2469.1">typename</span></span><span class="koboSpan" id="kobo.2470.1">... </span><span class="koboSpan" id="kobo.2470.2">Ts&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2471.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2472.1">add_to_one</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2473.1">(Ts... </span><span class="koboSpan" id="kobo.2473.2">args)</span></span><span class="koboSpan" id="kobo.2474.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2475.1">return</span></span><span class="koboSpan" id="kobo.2476.1"> (args + ... </span><span class="koboSpan" id="kobo.2476.2">+ </span><span class="hljs-number"><span class="koboSpan" id="kobo.2477.1">1</span></span><span class="koboSpan" id="kobo.2478.1">);
}
</span></code></pre>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.2479.1">The parentheses shown here are part of the fold expression and cannot be omitted.</span></p>
</div>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-207"><span class="koboSpan" id="kobo.2480.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2481.1">When the</span><a id="_idIndexMarker442"/><span class="koboSpan" id="kobo.2482.1"> compiler </span><a id="_idIndexMarker443"/><span class="koboSpan" id="kobo.2483.1">encounters a fold expression, it expands it in one of the following expressions:</span></p>
<table class="table-container" id="table002-1">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.2484.1">Expression</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.2485.1">Expansion</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2486.1">(... </span><span class="koboSpan" id="kobo.2486.2">op pack)</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2487.1">((pack$1 op pack$2) op ...) op pack$n</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2488.1">(init op ... </span><span class="koboSpan" id="kobo.2488.2">op pack)</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2489.1">(((init op pack$1) op pack$2) op ...) op pack$n</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2490.1">(pack op ...)</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2491.1">pack$1 op (... </span><span class="koboSpan" id="kobo.2491.2">op (pack$n-1 op pack$n))</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2492.1">(pack op ... </span><span class="koboSpan" id="kobo.2492.2">op init)</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2493.1">pack$1 op (... </span><span class="koboSpan" id="kobo.2493.2">op (pack$n-1 op (pack$n op init)))</span></code></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.2494.1">Table 3.2: The possible forms of a fold expression</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2495.1">When the binary form is used, the operator on both the left-hand and right-hand sides of the ellipses must be the same, and the initialization value must not contain an unexpanded parameter pack.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2496.1">The following binary operators are supported with fold expressions:</span></p>
<table class="table-container" id="table003-1">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2497.1">+</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2498.1">-</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2499.1">*</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2500.1">/</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2501.1">%</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2502.1">^</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2503.1">&amp;</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2504.1">|</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2505.1">=</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2506.1">&lt;</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2507.1">&gt;</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2508.1">&lt;&lt;</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2509.1">&gt;&gt;</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2510.1">+=</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2511.1">-=</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2512.1">*=</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2513.1">/=</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2514.1">%=</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2515.1">^=</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2516.1">&amp;=</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2517.1">|=</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2518.1">&lt;&lt;=</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2519.1">&gt;&gt;=</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2520.1">==</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2521.1">!=</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2522.1">&lt;=</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2523.1">&gt;=</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2524.1">&amp;&amp;</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2525.1">||</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2526.1">,</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2527.1">.*</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2528.1">-&gt;*.</span></code></p>
</td>
<td class="table-cell"/>
<td class="table-cell"/>
<td class="table-cell"/>
<td class="table-cell"/>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.2529.1">Table 3.3: The binary operator supported with fold expressions</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2530.1">When using the unary form, only operators such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.2531.1">*</span></code><span class="koboSpan" id="kobo.2532.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2533.1">+</span></code><span class="koboSpan" id="kobo.2534.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2535.1">&amp;</span></code><span class="koboSpan" id="kobo.2536.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2537.1">|</span></code><span class="koboSpan" id="kobo.2538.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2539.1">&amp;&amp;</span></code><span class="koboSpan" id="kobo.2540.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2541.1">||</span></code><span class="koboSpan" id="kobo.2542.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2543.1">,</span></code><span class="koboSpan" id="kobo.2544.1"> (comma) are allowed with an empty parameter pack. </span><span class="koboSpan" id="kobo.2544.2">In this case, the value of the empty pack is as follows:</span></p>
<table class="table-container" id="table004-1">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.2545.1">Operator</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.2546.1">Empty pack value</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2547.1">+</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2548.1">0</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2549.1">*</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2550.1">1</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2551.1">&amp;</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2552.1">-1</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2553.1">|</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2554.1">0</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2555.1">&amp;&amp;</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2556.1">true</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2557.1">||</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2558.1">false</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2559.1">,</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2560.1">void()</span></code></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.2561.1">Table 3.4: Operators that can be used with an empty parameter pack</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2562.1">Now that we have the function templates we implemented earlier (let’s consider the left-folding version), we can write the following code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2563.1">auto</span></span><span class="koboSpan" id="kobo.2564.1"> sum = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2565.1">add</span></span><span class="koboSpan" id="kobo.2566.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2567.1">1</span></span><span class="koboSpan" id="kobo.2568.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2569.1">2</span></span><span class="koboSpan" id="kobo.2570.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2571.1">3</span></span><span class="koboSpan" id="kobo.2572.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2573.1">4</span></span><span class="koboSpan" id="kobo.2574.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2575.1">5</span></span><span class="koboSpan" id="kobo.2576.1">);         </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2577.1">// sum = 15</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2578.1">auto</span></span><span class="koboSpan" id="kobo.2579.1"> sum1 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2580.1">add_to_one</span></span><span class="koboSpan" id="kobo.2581.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2582.1">1</span></span><span class="koboSpan" id="kobo.2583.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2584.1">2</span></span><span class="koboSpan" id="kobo.2585.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2586.1">3</span></span><span class="koboSpan" id="kobo.2587.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2588.1">4</span></span><span class="koboSpan" id="kobo.2589.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2590.1">5</span></span><span class="koboSpan" id="kobo.2591.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2592.1">// sum = 16</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2593.1">Considering the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2594.1">add(1, 2, 3, 4, 5)</span></code><span class="koboSpan" id="kobo.2595.1"> call, it will produce the following function:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.2596.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2597.1">add</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2598.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2599.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2600.1"> arg1, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2601.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2602.1"> arg2, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2603.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2604.1"> arg3, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2605.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2606.1"> arg4, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2607.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2608.1"> arg5)</span></span><span class="koboSpan" id="kobo.2609.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2610.1">return</span></span><span class="koboSpan" id="kobo.2611.1"> ((((arg1 + arg2) + arg3) + arg4) + arg5);
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2612.1">It’s worth </span><a id="_idIndexMarker444"/><span class="koboSpan" id="kobo.2613.1">mentioning that </span><a id="_idIndexMarker445"/><span class="koboSpan" id="kobo.2614.1">due to the aggressive ways modern compilers do optimizations, this function can be inlined and, eventually, we may end up with an expression such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.2615.1">auto sum = 1 + 2 + 3 + 4 + 5</span></code><span class="koboSpan" id="kobo.2616.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-208"><span class="koboSpan" id="kobo.2617.1">There’s more...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2618.1">Fold expressions</span><a id="_idIndexMarker446"/><span class="koboSpan" id="kobo.2619.1"> work with all overloads for the supported binary operators, but do not work with arbitrary binary functions. </span><span class="koboSpan" id="kobo.2619.2">It is possible to implement a workaround for that by providing a wrapper type that will hold a value and an overloaded operator for that wrapper type:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2620.1">template</span></span><span class="koboSpan" id="kobo.2621.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2622.1">typename</span></span><span class="koboSpan" id="kobo.2623.1"> T&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2624.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2625.1">wrapper</span></span><span class="koboSpan" id="kobo.2626.1">
{
  T </span><span class="hljs-type"><span class="koboSpan" id="kobo.2627.1">const</span></span><span class="koboSpan" id="kobo.2628.1"> &amp; value;
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2629.1">template</span></span><span class="koboSpan" id="kobo.2630.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2631.1">typename</span></span><span class="koboSpan" id="kobo.2632.1"> T&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2633.1">constexpr</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.2634.1">auto</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.2635.1">operator</span></span><span class="koboSpan" id="kobo.2636.1">&lt;(wrapper&lt;T&gt; </span><span class="hljs-type"><span class="koboSpan" id="kobo.2637.1">const</span></span><span class="koboSpan" id="kobo.2638.1"> &amp; lhs, wrapper&lt;T&gt; </span><span class="hljs-type"><span class="koboSpan" id="kobo.2639.1">const</span></span><span class="koboSpan" id="kobo.2640.1"> &amp; rhs)
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2641.1">return</span></span><span class="koboSpan" id="kobo.2642.1"> wrapper&lt;T&gt; {lhs.value &lt; rhs.value ? </span><span class="koboSpan" id="kobo.2642.2">lhs.value : rhs.value};
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2643.1">In the preceding code, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2644.1">wrapper</span></code><span class="koboSpan" id="kobo.2645.1"> is a simple class template that holds a constant reference to a value of type </span><code class="inlineCode"><span class="koboSpan" id="kobo.2646.1">T</span></code><span class="koboSpan" id="kobo.2647.1">. </span><span class="koboSpan" id="kobo.2647.2">An overloaded </span><code class="inlineCode"><span class="koboSpan" id="kobo.2648.1">operator&lt;</span></code><span class="koboSpan" id="kobo.2649.1"> is provided for this class template; this overload does not return a Boolean to indicate that the first argument is less than the second, but actually an instance of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2650.1">wrapper</span></code><span class="koboSpan" id="kobo.2651.1"> class type to hold the minimum value of the two arguments. </span><span class="koboSpan" id="kobo.2651.2">The variadic function template </span><code class="inlineCode"><span class="koboSpan" id="kobo.2652.1">min</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.2653.1">()</span></code><span class="koboSpan" id="kobo.2654.1">, shown here, uses this overloaded </span><code class="inlineCode"><span class="koboSpan" id="kobo.2655.1">operator&lt;</span></code><span class="koboSpan" id="kobo.2656.1"> to fold the pack of arguments expanded to instances of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2657.1">wrapper</span></code><span class="koboSpan" id="kobo.2658.1"> class template:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2659.1">template</span></span><span class="koboSpan" id="kobo.2660.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2661.1">typename</span></span><span class="koboSpan" id="kobo.2662.1">... </span><span class="koboSpan" id="kobo.2662.2">Ts&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2663.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2664.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2665.1">min</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2666.1">(Ts&amp;&amp;... </span><span class="koboSpan" id="kobo.2666.2">args)</span></span><span class="koboSpan" id="kobo.2667.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2668.1">return</span></span><span class="koboSpan" id="kobo.2669.1"> (wrapper&lt;Ts&gt;{args} &lt; ...).value;
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2670.1">auto</span></span><span class="koboSpan" id="kobo.2671.1"> m = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2672.1">min</span></span><span class="koboSpan" id="kobo.2673.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2674.1">3</span></span><span class="koboSpan" id="kobo.2675.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2676.1">1</span></span><span class="koboSpan" id="kobo.2677.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2678.1">2</span></span><span class="koboSpan" id="kobo.2679.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2680.1">// m = 1</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2681.1">This </span><code class="inlineCode"><span class="koboSpan" id="kobo.2682.1">min()</span></code><span class="koboSpan" id="kobo.2683.1"> function is expanded by the compiler to something that could look like the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2684.1">template</span></span><span class="koboSpan" id="kobo.2685.1">&lt;&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2686.1">inline</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.2687.1">constexpr</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2688.1">int</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.2689.1">min</span></span><span class="koboSpan" id="kobo.2690.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2691.1">int</span></span><span class="koboSpan" id="kobo.2692.1">, </span><span class="hljs-type"><span class="koboSpan" id="kobo.2693.1">int</span></span><span class="koboSpan" id="kobo.2694.1">, </span><span class="hljs-type"><span class="koboSpan" id="kobo.2695.1">int</span></span><span class="koboSpan" id="kobo.2696.1">&gt;(</span><span class="hljs-type"><span class="koboSpan" id="kobo.2697.1">int</span></span><span class="koboSpan" id="kobo.2698.1"> &amp;&amp; __args0,
                                        </span><span class="hljs-type"><span class="koboSpan" id="kobo.2699.1">int</span></span><span class="koboSpan" id="kobo.2700.1"> &amp;&amp; __args1,
                                        </span><span class="hljs-type"><span class="koboSpan" id="kobo.2701.1">int</span></span><span class="koboSpan" id="kobo.2702.1"> &amp;&amp; __args2)
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2703.1">return</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2704.1">operator</span></span><span class="koboSpan" id="kobo.2705.1">&lt;(wrapper_min&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2706.1">int</span></span><span class="koboSpan" id="kobo.2707.1">&gt;{__args0},
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2708.1">operator</span></span><span class="koboSpan" id="kobo.2709.1">&lt;(wrapper_min&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2710.1">int</span></span><span class="koboSpan" id="kobo.2711.1">&gt;{__args1},
                wrapper_min&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2712.1">int</span></span><span class="koboSpan" id="kobo.2713.1">&gt;{__args2})).value;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2714.1">What we can see here is cascading calls to the binary </span><code class="inlineCode"><span class="koboSpan" id="kobo.2715.1">operator &lt;</span></code><span class="koboSpan" id="kobo.2716.1"> that return a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2717.1">Wrapper&lt;int&gt;</span></code><span class="koboSpan" id="kobo.2718.1"> value. </span><span class="koboSpan" id="kobo.2718.2">Without this, an implementation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2719.1">min()</span></code><span class="koboSpan" id="kobo.2720.1"> function using fold expressions would not be possible. </span><span class="koboSpan" id="kobo.2720.2">The following implementation does not work:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2721.1">template</span></span><span class="koboSpan" id="kobo.2722.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2723.1">typename</span></span><span class="koboSpan" id="kobo.2724.1">... </span><span class="koboSpan" id="kobo.2724.2">Ts&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2725.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2726.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2727.1">minimum</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2728.1">(Ts&amp;&amp;... </span><span class="koboSpan" id="kobo.2728.2">args)</span></span><span class="koboSpan" id="kobo.2729.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2730.1">return</span></span><span class="koboSpan" id="kobo.2731.1"> (args &lt; ...);
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2732.1">The compiler would transform this, based on the call </span><code class="inlineCode"><span class="koboSpan" id="kobo.2733.1">min(3, 1, 2)</span></code><span class="koboSpan" id="kobo.2734.1">, to something such as the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2735.1">template</span></span><span class="koboSpan" id="kobo.2736.1">&lt;&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2737.1">inline</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.2738.1">constexpr</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2739.1">bool</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.2740.1">minimum</span></span><span class="koboSpan" id="kobo.2741.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2742.1">int</span></span><span class="koboSpan" id="kobo.2743.1">, </span><span class="hljs-type"><span class="koboSpan" id="kobo.2744.1">int</span></span><span class="koboSpan" id="kobo.2745.1">, </span><span class="hljs-type"><span class="koboSpan" id="kobo.2746.1">int</span></span><span class="koboSpan" id="kobo.2747.1">&gt;(</span><span class="hljs-type"><span class="koboSpan" id="kobo.2748.1">int</span></span><span class="koboSpan" id="kobo.2749.1"> &amp;&amp; __args0,
                                             </span><span class="hljs-type"><span class="koboSpan" id="kobo.2750.1">int</span></span><span class="koboSpan" id="kobo.2751.1"> &amp;&amp; __args1,
                                             </span><span class="hljs-type"><span class="koboSpan" id="kobo.2752.1">int</span></span><span class="koboSpan" id="kobo.2753.1"> &amp;&amp; __args2)
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2754.1">return</span></span><span class="koboSpan" id="kobo.2755.1"> __args0 &lt; (</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2756.1">static_cast</span></span><span class="koboSpan" id="kobo.2757.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2758.1">int</span></span><span class="koboSpan" id="kobo.2759.1">&gt;(__args1 &lt; __args2));
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2760.1">The result is a function that returns a Boolean, and not the actual integer value, which is the minimum between the supplied arguments.</span></p>
<h2 class="heading-2" id="_idParaDest-209"><span class="koboSpan" id="kobo.2761.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.2762.1">Implementing higher-order functions map and fold</span></em><span class="koboSpan" id="kobo.2763.1">, to learn about higher-order functions in functional programming and how to implement the widely used </span><code class="inlineCode"><span class="koboSpan" id="kobo.2764.1">map</span></code><span class="koboSpan" id="kobo.2765.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2766.1">fold</span></code><span class="koboSpan" id="kobo.2767.1"> (or </span><code class="inlineCode"><span class="koboSpan" id="kobo.2768.1">reduce</span></code><span class="koboSpan" id="kobo.2769.1">) functions</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-210"><span class="koboSpan" id="kobo.2770.1">Implementing the higher-order functions map and fold</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.2771.1">Throughout the preceding recipes in this book, we have used the general-purpose algorithms </span><code class="inlineCode"><span class="koboSpan" id="kobo.2772.1">std::transform()</span></code><span class="koboSpan" id="kobo.2773.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2774.1">std::accumulate()</span></code><span class="koboSpan" id="kobo.2775.1"> in several examples, such as for implementing string utilities to create uppercase or lowercase copies of a string or for summing the values of a range. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.2776.1">These are basically implementations of the higher-order functions, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2777.1">map</span></code><span class="koboSpan" id="kobo.2778.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2779.1">fold</span></code><span class="koboSpan" id="kobo.2780.1">. </span><span class="koboSpan" id="kobo.2780.2">A higher-order function</span><a id="_idIndexMarker447"/><span class="koboSpan" id="kobo.2781.1"> is a function that takes one or </span><a id="_idIndexMarker448"/><span class="koboSpan" id="kobo.2782.1">more other functions as arguments and applies them to </span><a id="_idIndexMarker449"/><span class="koboSpan" id="kobo.2783.1">a range (a list, vector, map, tree, and so on), thus producing either a new range or a value. </span><span class="koboSpan" id="kobo.2783.2">In this recipe, we will learn how to implement the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2784.1">map</span></code><span class="koboSpan" id="kobo.2785.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2786.1">fold</span></code><span class="koboSpan" id="kobo.2787.1"> functions so that they work with C++ standard containers.</span></p>
<h2 class="heading-2" id="_idParaDest-211"><span class="koboSpan" id="kobo.2788.1">Getting ready</span></h2>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2789.1">map</span></code><span class="koboSpan" id="kobo.2790.1"> is a </span><a id="_idIndexMarker450"/><span class="koboSpan" id="kobo.2791.1">higher-order function that applies a function to the elements of a range and returns a new range in the same order.</span></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2792.1">fold</span></code><span class="koboSpan" id="kobo.2793.1"> is a </span><a id="_idIndexMarker451"/><span class="koboSpan" id="kobo.2794.1">higher-order function that applies a combining function to the elements of the range to produce a single result. </span><span class="koboSpan" id="kobo.2794.2">Since the order of the processing can be important, there are usually two versions of this function. </span><span class="koboSpan" id="kobo.2794.3">One is </span><code class="inlineCode"><span class="koboSpan" id="kobo.2795.1">fold_left</span></code><span class="koboSpan" id="kobo.2796.1">, which processes elements from left to right, while the other is </span><code class="inlineCode"><span class="koboSpan" id="kobo.2797.1">fold_right</span></code><span class="koboSpan" id="kobo.2798.1">, which combines the elements from right to left.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.2799.1">Most descriptions of the function map indicate that it is applied to a list, but this is a general term that can indicate different sequential types, such as list, vector, and array, and also dictionaries (that is, maps), queues, and so on. </span><span class="koboSpan" id="kobo.2799.2">For this reason, I prefer to use the term range when describing these higher-order functions.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.2800.1">As an example, the mapping operation could transform a range of strings into a range of integers representing the length of each string. </span><span class="koboSpan" id="kobo.2800.2">The fold operation could then add these lengths to determine the combined length of all the strings.</span></p>
<h2 class="heading-2" id="_idParaDest-212"><span class="koboSpan" id="kobo.2801.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2802.1">To</span><a id="_idIndexMarker452"/><span class="koboSpan" id="kobo.2803.1"> implement the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2804.1">map</span></code><span class="koboSpan" id="kobo.2805.1"> function, you should:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2806.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2807.1">std::transform</span></code><span class="koboSpan" id="kobo.2808.1"> on containers that support iterating and assignment to the elements, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.2809.1">std::vector</span></code><span class="koboSpan" id="kobo.2810.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.2811.1">std::list</span></code><span class="koboSpan" id="kobo.2812.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2813.1">template</span></span><span class="koboSpan" id="kobo.2814.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2815.1">typename</span></span><span class="koboSpan" id="kobo.2816.1"> F, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2817.1">typename</span></span><span class="koboSpan" id="kobo.2818.1"> R&gt;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.2819.1">R </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.2820.1">mapf</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2821.1">(F&amp;&amp; func, R range)</span></span><span class="koboSpan" id="kobo.2822.1">
{
  std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2823.1">transform</span></span><span class="koboSpan" id="kobo.2824.1">(
    std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2825.1">begin</span></span><span class="koboSpan" id="kobo.2826.1">(range), std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2827.1">end</span></span><span class="koboSpan" id="kobo.2828.1">(range), std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2829.1">begin</span></span><span class="koboSpan" id="kobo.2830.1">(range),
    std::forward&lt;F&gt;(func));
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2831.1">return</span></span><span class="koboSpan" id="kobo.2832.1"> range;
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2833.1">Use other</span><a id="_idIndexMarker453"/><span class="koboSpan" id="kobo.2834.1"> means such as explicit iteration and insertion for containers that do not support assignment to the elements, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.2835.1">std::map</span></code><span class="koboSpan" id="kobo.2836.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2837.1">std::queue</span></code><span class="koboSpan" id="kobo.2838.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2839.1">template</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.2840.1">&lt;</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2841.1">typename</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.2842.1"> F, </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2843.1">typename</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.2844.1"> T, </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2845.1">typename</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.2846.1"> U&gt;</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.2847.1">std::map&lt;T, U&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.2848.1">mapf</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2849.1">(F&amp;&amp; func, std::map&lt;T, U&gt; </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2850.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2851.1"> &amp; m)</span></span><span class="koboSpan" id="kobo.2852.1">
{
  std::map&lt;T, U&gt; r;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2853.1">for</span></span><span class="koboSpan" id="kobo.2854.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2855.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2856.1">const</span></span><span class="koboSpan" id="kobo.2857.1"> kvp : m)
    r.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2858.1">insert</span></span><span class="koboSpan" id="kobo.2859.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2860.1">func</span></span><span class="koboSpan" id="kobo.2861.1">(kvp));
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2862.1">return</span></span><span class="koboSpan" id="kobo.2863.1"> r;
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2864.1">template</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.2865.1">&lt;</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2866.1">typename</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.2867.1"> F, </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2868.1">typename</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.2869.1"> T&gt;</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.2870.1">std::queue&lt;T&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.2871.1">mapf</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2872.1">(F&amp;&amp; func, std::queue&lt;T&gt; q)</span></span><span class="koboSpan" id="kobo.2873.1">
{
  std::queue&lt;T&gt; r;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2874.1">while</span></span><span class="koboSpan" id="kobo.2875.1"> (!q.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2876.1">empty</span></span><span class="koboSpan" id="kobo.2877.1">())
  {
    r.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2878.1">push</span></span><span class="koboSpan" id="kobo.2879.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2880.1">func</span></span><span class="koboSpan" id="kobo.2881.1">(q.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2882.1">front</span></span><span class="koboSpan" id="kobo.2883.1">()));
    q.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2884.1">pop</span></span><span class="koboSpan" id="kobo.2885.1">();
  }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2886.1">return</span></span><span class="koboSpan" id="kobo.2887.1"> r;
}
</span></code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.2888.1">To implement </span><a id="_idIndexMarker454"/><span class="koboSpan" id="kobo.2889.1">the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2890.1">fold</span></code><span class="koboSpan" id="kobo.2891.1"> function, you should:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2892.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2893.1">std::accumulate()</span></code><span class="koboSpan" id="kobo.2894.1"> on containers that support iterating:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2895.1">template</span></span><span class="koboSpan" id="kobo.2896.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2897.1">typename</span></span><span class="koboSpan" id="kobo.2898.1"> F, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2899.1">typename</span></span><span class="koboSpan" id="kobo.2900.1"> R, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2901.1">typename</span></span><span class="koboSpan" id="kobo.2902.1"> T&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2903.1">constexpr</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.2904.1"> T </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.2905.1">fold_left</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2906.1">(F&amp;&amp; func, R&amp;&amp; range, T init)</span></span><span class="koboSpan" id="kobo.2907.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2908.1">return</span></span><span class="koboSpan" id="kobo.2909.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2910.1">accumulate</span></span><span class="koboSpan" id="kobo.2911.1">(
    std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2912.1">begin</span></span><span class="koboSpan" id="kobo.2913.1">(range), std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2914.1">end</span></span><span class="koboSpan" id="kobo.2915.1">(range),
    std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2916.1">move</span></span><span class="koboSpan" id="kobo.2917.1">(init),
    std::forward&lt;F&gt;(func));
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2918.1">template</span></span><span class="koboSpan" id="kobo.2919.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2920.1">typename</span></span><span class="koboSpan" id="kobo.2921.1"> F, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2922.1">typename</span></span><span class="koboSpan" id="kobo.2923.1"> R, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2924.1">typename</span></span><span class="koboSpan" id="kobo.2925.1"> T&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2926.1">constexpr</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.2927.1"> T </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.2928.1">fold_right</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2929.1">(F&amp;&amp; func, R&amp;&amp; range, T init)</span></span><span class="koboSpan" id="kobo.2930.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2931.1">return</span></span><span class="koboSpan" id="kobo.2932.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2933.1">accumulate</span></span><span class="koboSpan" id="kobo.2934.1">(
    std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2935.1">rbegin</span></span><span class="koboSpan" id="kobo.2936.1">(range), std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2937.1">rend</span></span><span class="koboSpan" id="kobo.2938.1">(range),
    std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2939.1">move</span></span><span class="koboSpan" id="kobo.2940.1">(init),
    std::forward&lt;F&gt;(func));
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2941.1">Use other </span><a id="_idIndexMarker455"/><span class="koboSpan" id="kobo.2942.1">means to explicitly process containers that do not support iterating, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.2943.1">std::queue</span></code><span class="koboSpan" id="kobo.2944.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2945.1">template</span></span><span class="koboSpan" id="kobo.2946.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2947.1">typename</span></span><span class="koboSpan" id="kobo.2948.1"> F, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2949.1">typename</span></span><span class="koboSpan" id="kobo.2950.1"> T&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2951.1">constexpr</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.2952.1"> T </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.2953.1">fold_left</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2954.1">(F&amp;&amp; func, std::queue&lt;T&gt; q, T init)</span></span><span class="koboSpan" id="kobo.2955.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2956.1">while</span></span><span class="koboSpan" id="kobo.2957.1"> (!q.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2958.1">empty</span></span><span class="koboSpan" id="kobo.2959.1">())
  {
    init = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2960.1">func</span></span><span class="koboSpan" id="kobo.2961.1">(init, q.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2962.1">front</span></span><span class="koboSpan" id="kobo.2963.1">());
    q.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2964.1">pop</span></span><span class="koboSpan" id="kobo.2965.1">();
  }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2966.1">return</span></span><span class="koboSpan" id="kobo.2967.1"> init;
}
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-213"><span class="koboSpan" id="kobo.2968.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2969.1">In the preceding examples, we implemented the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2970.1">map</span></code><span class="koboSpan" id="kobo.2971.1"> higher-order function in a functional way, without side effects. </span><span class="koboSpan" id="kobo.2971.2">This means it preserves the original range and returns a new one. </span><span class="koboSpan" id="kobo.2971.3">The arguments of the function are the function to apply and the range. </span><span class="koboSpan" id="kobo.2971.4">In order to avoid confusion with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2972.1">std::map</span></code><span class="koboSpan" id="kobo.2973.1"> container, we have called this function </span><code class="inlineCode"><span class="koboSpan" id="kobo.2974.1">mapf</span></code><span class="koboSpan" id="kobo.2975.1">. </span><span class="koboSpan" id="kobo.2975.2">There are several overloads</span><a id="_idIndexMarker456"/><span class="koboSpan" id="kobo.2976.1"> for </span><code class="inlineCode"><span class="koboSpan" id="kobo.2977.1">mapf</span></code><span class="koboSpan" id="kobo.2978.1">, as shown earlier:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2979.1">The first overload is for containers that support iterating and assignment to its elements; this includes </span><code class="inlineCode"><span class="koboSpan" id="kobo.2980.1">std::vector</span></code><span class="koboSpan" id="kobo.2981.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2982.1">std::list</span></code><span class="koboSpan" id="kobo.2983.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2984.1">std::array</span></code><span class="koboSpan" id="kobo.2985.1">, but also C-like arrays. </span><span class="koboSpan" id="kobo.2985.2">The function takes an </span><code class="inlineCode"><span class="koboSpan" id="kobo.2986.1">rvalue</span></code><span class="koboSpan" id="kobo.2987.1"> reference to a function and a range for which </span><code class="inlineCode"><span class="koboSpan" id="kobo.2988.1">std::begin()</span></code><span class="koboSpan" id="kobo.2989.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2990.1">std::end()</span></code><span class="koboSpan" id="kobo.2991.1"> are defined. </span><span class="koboSpan" id="kobo.2991.2">The range is passed by value so that modifying the local copy does not affect the original range. </span><span class="koboSpan" id="kobo.2991.3">The range is transformed by applying the given function to each element using the standard algorithm </span><code class="inlineCode"><span class="koboSpan" id="kobo.2992.1">std::transform()</span></code><span class="koboSpan" id="kobo.2993.1">; the transformed range is then returned.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2994.1">The second overload is specialized for </span><code class="inlineCode"><span class="koboSpan" id="kobo.2995.1">std::map</span></code><span class="koboSpan" id="kobo.2996.1">, which does not support direct assignment to its elements (</span><code class="inlineCode"><span class="koboSpan" id="kobo.2997.1">std::pair&lt;T, U&gt;</span></code><span class="koboSpan" id="kobo.2998.1">). </span><span class="koboSpan" id="kobo.2998.2">Therefore, this overload creates a new map, then iterates through its elements using a range-based </span><code class="inlineCode"><span class="koboSpan" id="kobo.2999.1">for</span></code><span class="koboSpan" id="kobo.3000.1"> loop, and inserts the result of applying the input function to each element of the original map into the new map.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3001.1">The third overload is specialized for </span><code class="inlineCode"><span class="koboSpan" id="kobo.3002.1">std::queue</span></code><span class="koboSpan" id="kobo.3003.1">, which is a container that does not support iterating. </span><span class="koboSpan" id="kobo.3003.2">It can be argued that a queue is not a typical structure to map over, but for the sake of demonstrating different possible implementations, we are considering it. </span><span class="koboSpan" id="kobo.3003.3">In order to iterate over the elements of a queue, the queue must be altered—you need to pop elements from the front until the list is empty. </span><span class="koboSpan" id="kobo.3003.4">This is what the third overload does—it processes each element of the input queue (passed by value) and pushes the result of applying the given function to the front element of the </span><a id="_idIndexMarker457"/><span class="koboSpan" id="kobo.3004.1">remaining queue.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.3005.1">Now that we have these</span><a id="_idIndexMarker458"/><span class="koboSpan" id="kobo.3006.1"> overloads implemented, we can apply them to a lot of containers, as shown in the following examples:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.3007.1">Retain absolute values from a vector. </span><span class="koboSpan" id="kobo.3007.2">In this example, the vector contains both negative and positive values. </span><span class="koboSpan" id="kobo.3007.3">After applying the mapping, the result is a new vector with only positive values:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3008.1">auto</span></span><span class="koboSpan" id="kobo.3009.1"> vnums =
  std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3010.1">int</span></span><span class="koboSpan" id="kobo.3011.1">&gt;{</span><span class="hljs-number"><span class="koboSpan" id="kobo.3012.1">0</span></span><span class="koboSpan" id="kobo.3013.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3014.1">2</span></span><span class="koboSpan" id="kobo.3015.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3016.1">-3</span></span><span class="koboSpan" id="kobo.3017.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3018.1">5</span></span><span class="koboSpan" id="kobo.3019.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3020.1">-1</span></span><span class="koboSpan" id="kobo.3021.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3022.1">6</span></span><span class="koboSpan" id="kobo.3023.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3024.1">8</span></span><span class="koboSpan" id="kobo.3025.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3026.1">-4</span></span><span class="koboSpan" id="kobo.3027.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3028.1">9</span></span><span class="koboSpan" id="kobo.3029.1">};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3030.1">auto</span></span><span class="koboSpan" id="kobo.3031.1"> r =</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3032.1">mapf</span></span><span class="koboSpan" id="kobo.3033.1">([](</span><span class="hljs-type"><span class="koboSpan" id="kobo.3034.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3035.1">const</span></span><span class="koboSpan" id="kobo.3036.1"> i) { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3037.1">return</span></span><span class="koboSpan" id="kobo.3038.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3039.1">abs</span></span><span class="koboSpan" id="kobo.3040.1">(i); }, vnums);
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.3041.1">// r = {0, 2, 3, 5, 1, 6, 8, 4, 9}</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3042.1">Square the numerical values of a list. </span><span class="koboSpan" id="kobo.3042.2">In this example, the list contains integral values. </span><span class="koboSpan" id="kobo.3042.3">After applying the mapping, the result is a list containing the squares of the initial values:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3043.1">auto</span></span><span class="koboSpan" id="kobo.3044.1"> lnums = std::list&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3045.1">int</span></span><span class="koboSpan" id="kobo.3046.1">&gt;{</span><span class="hljs-number"><span class="koboSpan" id="kobo.3047.1">1</span></span><span class="koboSpan" id="kobo.3048.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3049.1">2</span></span><span class="koboSpan" id="kobo.3050.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3051.1">3</span></span><span class="koboSpan" id="kobo.3052.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3053.1">4</span></span><span class="koboSpan" id="kobo.3054.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3055.1">5</span></span><span class="koboSpan" id="kobo.3056.1">};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3057.1">auto</span></span><span class="koboSpan" id="kobo.3058.1"> l = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3059.1">mapf</span></span><span class="koboSpan" id="kobo.3060.1">([](</span><span class="hljs-type"><span class="koboSpan" id="kobo.3061.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3062.1">const</span></span><span class="koboSpan" id="kobo.3063.1"> i) { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3064.1">return</span></span><span class="koboSpan" id="kobo.3065.1"> i*i; }, lnums);
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.3066.1">// l = {1, 4, 9, 16, 25}</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3067.1">Rounded amounts of floating points. </span><span class="koboSpan" id="kobo.3067.2">For this example, we need to use </span><code class="inlineCode"><span class="koboSpan" id="kobo.3068.1">std::round()</span></code><span class="koboSpan" id="kobo.3069.1">; however, this has overloads for all floating-point types, which makes it impossible for the compiler to pick the right one. </span><span class="koboSpan" id="kobo.3069.2">As a result, we either have to write a lambda that takes an argument of a specific floating-point type and returns the value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3070.1">std::round()</span></code><span class="koboSpan" id="kobo.3071.1"> applied to that value, or create a function object template that wraps </span><code class="inlineCode"><span class="koboSpan" id="kobo.3072.1">std::round()</span></code><span class="koboSpan" id="kobo.3073.1"> and enables its call operator only for floating-point types. </span><span class="koboSpan" id="kobo.3073.2">This technique is used in the following example:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3074.1">template</span></span><span class="koboSpan" id="kobo.3075.1">&lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3076.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.3077.1">T</span></span><span class="koboSpan" id="kobo.3078.1"> = </span><span class="hljs-type"><span class="koboSpan" id="kobo.3079.1">double</span></span><span class="koboSpan" id="kobo.3080.1">&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3081.1">struct</span></span><span class="koboSpan" id="kobo.3082.1"> fround
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3083.1">typename</span></span><span class="koboSpan" id="kobo.3084.1"> std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.3085.1">enable_if_t</span></span><span class="koboSpan" id="kobo.3086.1">&lt;std::is_floating_point_v&lt;T&gt;, T&gt;
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3087.1">operator</span></span><span class="koboSpan" id="kobo.3088.1">()(</span><span class="hljs-type"><span class="koboSpan" id="kobo.3089.1">const</span></span><span class="koboSpan" id="kobo.3090.1"> T&amp; value) </span><span class="hljs-type"><span class="koboSpan" id="kobo.3091.1">const</span></span><span class="koboSpan" id="kobo.3092.1">
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3093.1">return</span></span><span class="koboSpan" id="kobo.3094.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3095.1">round</span></span><span class="koboSpan" id="kobo.3096.1">(value);
  }
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3097.1">auto</span></span><span class="koboSpan" id="kobo.3098.1"> amounts =
  std::array&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3099.1">double</span></span><span class="koboSpan" id="kobo.3100.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3101.1">5</span></span><span class="koboSpan" id="kobo.3102.1">&gt; {</span><span class="hljs-number"><span class="koboSpan" id="kobo.3103.1">10.42</span></span><span class="koboSpan" id="kobo.3104.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3105.1">2.50</span></span><span class="koboSpan" id="kobo.3106.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3107.1">100.0</span></span><span class="koboSpan" id="kobo.3108.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3109.1">23.75</span></span><span class="koboSpan" id="kobo.3110.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3111.1">12.99</span></span><span class="koboSpan" id="kobo.3112.1">};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3113.1">auto</span></span><span class="koboSpan" id="kobo.3114.1"> a = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3115.1">mapf</span></span><span class="koboSpan" id="kobo.3116.1">(fround&lt;&gt;(), amounts);
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.3117.1">// a = {10.0, 3.0, 100.0, 24.0, 13.0}</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3118.1">Uppercase</span><a id="_idIndexMarker459"/><span class="koboSpan" id="kobo.3119.1"> the string keys of a map of words (where the key is the word and the value is the number of appearances in the text). </span><span class="koboSpan" id="kobo.3119.2">Note that creating an uppercase copy of a string is itself a mapping operation. </span><span class="koboSpan" id="kobo.3119.3">Therefore, in this example, we use </span><code class="inlineCode"><span class="koboSpan" id="kobo.3120.1">mapf</span></code><span class="koboSpan" id="kobo.3121.1"> to apply </span><code class="inlineCode"><span class="koboSpan" id="kobo.3122.1">toupper()</span></code><span class="koboSpan" id="kobo.3123.1"> to the elements of the string representing the key in order to produce an uppercase copy:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3124.1">auto</span></span><span class="koboSpan" id="kobo.3125.1"> words = std::map&lt;std::string, </span><span class="hljs-type"><span class="koboSpan" id="kobo.3126.1">int</span></span><span class="koboSpan" id="kobo.3127.1">&gt;{
  {</span><span class="hljs-string"><span class="koboSpan" id="kobo.3128.1">"one"</span></span><span class="koboSpan" id="kobo.3129.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3130.1">1</span></span><span class="koboSpan" id="kobo.3131.1">}, {</span><span class="hljs-string"><span class="koboSpan" id="kobo.3132.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.3133.1">two"</span></span><span class="koboSpan" id="kobo.3134.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3135.1">2</span></span><span class="koboSpan" id="kobo.3136.1">}, {</span><span class="hljs-string"><span class="koboSpan" id="kobo.3137.1">"three"</span></span><span class="koboSpan" id="kobo.3138.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3139.1">3</span></span><span class="koboSpan" id="kobo.3140.1">}
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3141.1">auto</span></span><span class="koboSpan" id="kobo.3142.1"> m = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3143.1">mapf</span></span><span class="koboSpan" id="kobo.3144.1">(
  [](std::pair&lt;std::string, </span><span class="hljs-type"><span class="koboSpan" id="kobo.3145.1">int</span></span><span class="koboSpan" id="kobo.3146.1">&gt; </span><span class="hljs-type"><span class="koboSpan" id="kobo.3147.1">const</span></span><span class="koboSpan" id="kobo.3148.1"> kvp) {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3149.1">return</span></span><span class="koboSpan" id="kobo.3150.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3151.1">make_pair</span></span><span class="koboSpan" id="kobo.3152.1">(
      funclib::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3153.1">mapf</span></span><span class="koboSpan" id="kobo.3154.1">(toupper, kvp.first),
      kvp.second);
    },
    words);
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.3155.1">// m = {{"ONE", 1}, {"TWO", 2}, {"THREE", 3}}</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3156.1">Normalize</span><a id="_idIndexMarker460"/><span class="koboSpan" id="kobo.3157.1"> values from a queue of priorities; initially, the values are from 1 to 100, but we want to normalize them into two values, 1=high and 2=normal. </span><span class="koboSpan" id="kobo.3157.2">All the initial priorities that have a value up to 30 get high priority; the others get normal priority:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3158.1">auto</span></span><span class="koboSpan" id="kobo.3159.1"> priorities = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3160.1">queue</span></span><span class="koboSpan" id="kobo.3161.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3162.1">int</span></span><span class="koboSpan" id="kobo.3163.1">&gt;();
priorities.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3164.1">push</span></span><span class="koboSpan" id="kobo.3165.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3166.1">10</span></span><span class="koboSpan" id="kobo.3167.1">);
priorities.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3168.1">push</span></span><span class="koboSpan" id="kobo.3169.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3170.1">20</span></span><span class="koboSpan" id="kobo.3171.1">);
priorities.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3172.1">push</span></span><span class="koboSpan" id="kobo.3173.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3174.1">30</span></span><span class="koboSpan" id="kobo.3175.1">);
priorities.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3176.1">push</span></span><span class="koboSpan" id="kobo.3177.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3178.1">40</span></span><span class="koboSpan" id="kobo.3179.1">);
priorities.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3180.1">push</span></span><span class="koboSpan" id="kobo.3181.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3182.1">50</span></span><span class="koboSpan" id="kobo.3183.1">);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3184.1">auto</span></span><span class="koboSpan" id="kobo.3185.1"> p = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3186.1">mapf</span></span><span class="koboSpan" id="kobo.3187.1">(
  [](</span><span class="hljs-type"><span class="koboSpan" id="kobo.3188.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3189.1">const</span></span><span class="koboSpan" id="kobo.3190.1"> i) { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3191.1">return</span></span><span class="koboSpan" id="kobo.3192.1"> i &gt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.3193.1">30</span></span><span class="koboSpan" id="kobo.3194.1"> ? </span><span class="hljs-number"><span class="koboSpan" id="kobo.3195.1">2</span></span><span class="koboSpan" id="kobo.3196.1"> : </span><span class="hljs-number"><span class="koboSpan" id="kobo.3197.1">1</span></span><span class="koboSpan" id="kobo.3198.1">; },
  priorities);
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.3199.1">// p = {1, 1, 1, 2, 2}</span></span>
</code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.3200.1">To implement </span><code class="inlineCode"><span class="koboSpan" id="kobo.3201.1">fold</span></code><span class="koboSpan" id="kobo.3202.1">, we actually have to consider the two possible types of folding—that is, from left to right and from right to left. </span><span class="koboSpan" id="kobo.3202.2">Therefore, we have provided two functions called </span><code class="inlineCode"><span class="koboSpan" id="kobo.3203.1">fold_left</span></code><span class="koboSpan" id="kobo.3204.1"> (for left folding) and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3205.1">fold_right</span></code><span class="koboSpan" id="kobo.3206.1"> (for right folding). </span><span class="koboSpan" id="kobo.3206.2">The implementations shown in the previous section are very similar: they both take a function, range, and initial value and call </span><code class="inlineCode"><span class="koboSpan" id="kobo.3207.1">std::accumulate()</span></code><span class="koboSpan" id="kobo.3208.1"> to fold the values of the range into a single value. </span><span class="koboSpan" id="kobo.3208.2">However, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3209.1">fold_left</span></code><span class="koboSpan" id="kobo.3210.1"> uses direct iterators, whereas </span><code class="inlineCode"><span class="koboSpan" id="kobo.3211.1">fold_right</span></code><span class="koboSpan" id="kobo.3212.1"> uses reverse iterators to traverse and process the range. </span><span class="koboSpan" id="kobo.3212.2">The second overload is a specialization for the type </span><code class="inlineCode"><span class="koboSpan" id="kobo.3213.1">std::queue</span></code><span class="koboSpan" id="kobo.3214.1">, which does not have iterators.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3215.1">Based on these implementations</span><a id="_idIndexMarker461"/><span class="koboSpan" id="kobo.3216.1"> for folding, we can implement the following examples:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.3217.1">Adding the values of a vector of integers. </span><span class="koboSpan" id="kobo.3217.2">In this case, both left and right folding will produce the same result. </span><span class="koboSpan" id="kobo.3217.3">In the following examples, we pass either a lambda that takes a sum and a number and returns a new sum or the function object </span><code class="inlineCode"><span class="koboSpan" id="kobo.3218.1">std::plus&lt;&gt;</span></code><span class="koboSpan" id="kobo.3219.1"> from the standard library, which applies </span><code class="inlineCode"><span class="koboSpan" id="kobo.3220.1">operator+</span></code><span class="koboSpan" id="kobo.3221.1"> to two operands of the same type (basically similar to the closure of the lambda):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3222.1">auto</span></span><span class="koboSpan" id="kobo.3223.1"> vnums =
  std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3224.1">int</span></span><span class="koboSpan" id="kobo.3225.1">&gt;{</span><span class="hljs-number"><span class="koboSpan" id="kobo.3226.1">0</span></span><span class="koboSpan" id="kobo.3227.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3228.1">2</span></span><span class="koboSpan" id="kobo.3229.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3230.1">-3</span></span><span class="koboSpan" id="kobo.3231.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3232.1">5</span></span><span class="koboSpan" id="kobo.3233.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3234.1">-1</span></span><span class="koboSpan" id="kobo.3235.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3236.1">6</span></span><span class="koboSpan" id="kobo.3237.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3238.1">8</span></span><span class="koboSpan" id="kobo.3239.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3240.1">-4</span></span><span class="koboSpan" id="kobo.3241.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3242.1">9</span></span><span class="koboSpan" id="kobo.3243.1">};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3244.1">auto</span></span><span class="koboSpan" id="kobo.3245.1"> s1 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3246.1">fold_left</span></span><span class="koboSpan" id="kobo.3247.1">(
  [](</span><span class="hljs-type"><span class="koboSpan" id="kobo.3248.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3249.1">int</span></span><span class="koboSpan" id="kobo.3250.1"> s, </span><span class="hljs-type"><span class="koboSpan" id="kobo.3251.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3252.1">int</span></span><span class="koboSpan" id="kobo.3253.1"> n) {</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3254.1">return</span></span><span class="koboSpan" id="kobo.3255.1"> s + n; },
  vnums, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3256.1">0</span></span><span class="koboSpan" id="kobo.3257.1">);                </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3258.1">// s1 = 22</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.3259.1">auto</span></span><span class="koboSpan" id="kobo.3260.1"> s2 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3261.1">fold_left</span></span><span class="koboSpan" id="kobo.3262.1">(
  std::plus&lt;&gt;(), vnums, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3263.1">0</span></span><span class="koboSpan" id="kobo.3264.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3265.1">// s2 = 22</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.3266.1">auto</span></span><span class="koboSpan" id="kobo.3267.1"> s3 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3268.1">fold_right</span></span><span class="koboSpan" id="kobo.3269.1">(
  [](</span><span class="hljs-type"><span class="koboSpan" id="kobo.3270.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3271.1">int</span></span><span class="koboSpan" id="kobo.3272.1"> s, </span><span class="hljs-type"><span class="koboSpan" id="kobo.3273.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3274.1">int</span></span><span class="koboSpan" id="kobo.3275.1"> n) {</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3276.1">return</span></span><span class="koboSpan" id="kobo.3277.1"> s + n; },
  vnums, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3278.1">0</span></span><span class="koboSpan" id="kobo.3279.1">);                </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3280.1">// s3 = 22</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.3281.1">auto</span></span><span class="koboSpan" id="kobo.3282.1"> s4 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3283.1">fold_right</span></span><span class="koboSpan" id="kobo.3284.1">(
  std::plus&lt;&gt;(), vnums, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3285.1">0</span></span><span class="koboSpan" id="kobo.3286.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3287.1">// s4 = 22</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3288.1">Concatenating strings from a vector into a single string:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3289.1">auto</span></span><span class="koboSpan" id="kobo.3290.1"> texts =
  std::vector&lt;std::string&gt;{</span><span class="hljs-string"><span class="koboSpan" id="kobo.3291.1">"hello"</span></span><span class="koboSpan" id="kobo.3292.1">s, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3293.1">" "</span></span><span class="koboSpan" id="kobo.3294.1">s, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3295.1">"world"</span></span><span class="koboSpan" id="kobo.3296.1">s, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3297.1">"!"</span></span><span class="koboSpan" id="kobo.3298.1">s};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3299.1">auto</span></span><span class="koboSpan" id="kobo.3300.1"> txt1 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3301.1">fold_left</span></span><span class="koboSpan" id="kobo.3302.1">(
  [](std::string </span><span class="hljs-type"><span class="koboSpan" id="kobo.3303.1">const</span></span><span class="koboSpan" id="kobo.3304.1"> &amp; s, std::string </span><span class="hljs-type"><span class="koboSpan" id="kobo.3305.1">const</span></span><span class="koboSpan" id="kobo.3306.1"> &amp; n) {
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3307.1">return</span></span><span class="koboSpan" id="kobo.3308.1"> s + n;},
  texts, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3309.1">""</span></span><span class="koboSpan" id="kobo.3310.1">s);    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3311.1">// txt1 = "hello world!"</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.3312.1">auto</span></span><span class="koboSpan" id="kobo.3313.1"> txt2 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3314.1">fold_right</span></span><span class="koboSpan" id="kobo.3315.1">(
  [](std::string </span><span class="hljs-type"><span class="koboSpan" id="kobo.3316.1">const</span></span><span class="koboSpan" id="kobo.3317.1"> &amp; s, std::string </span><span class="hljs-type"><span class="koboSpan" id="kobo.3318.1">const</span></span><span class="koboSpan" id="kobo.3319.1"> &amp; n) {
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3320.1">return</span></span><span class="koboSpan" id="kobo.3321.1"> s + n; },
  texts, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3322.1">""</span></span><span class="koboSpan" id="kobo.3323.1">s);    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3324.1">// txt2 = "!world hello"</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3325.1">Concatenating an array of characters into a string:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.3326.1">char</span></span><span class="koboSpan" id="kobo.3327.1"> chars[] = {</span><span class="hljs-string"><span class="koboSpan" id="kobo.3328.1">'c'</span></span><span class="koboSpan" id="kobo.3329.1">,</span><span class="hljs-string"><span class="koboSpan" id="kobo.3330.1">'i'</span></span><span class="koboSpan" id="kobo.3331.1">,</span><span class="hljs-string"><span class="koboSpan" id="kobo.3332.1">'v'</span></span><span class="koboSpan" id="kobo.3333.1">,</span><span class="hljs-string"><span class="koboSpan" id="kobo.3334.1">'i'</span></span><span class="koboSpan" id="kobo.3335.1">,</span><span class="hljs-string"><span class="koboSpan" id="kobo.3336.1">'c'</span></span><span class="koboSpan" id="kobo.3337.1">};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3338.1">auto</span></span><span class="koboSpan" id="kobo.3339.1"> str1 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3340.1">fold_left</span></span><span class="koboSpan" id="kobo.3341.1">(std::plus&lt;&gt;(), chars, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3342.1">""</span></span><span class="koboSpan" id="kobo.3343.1">s);
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.3344.1">// str1 = "civic"</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.3345.1">Auto</span></span><span class="koboSpan" id="kobo.3346.1"> str2 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3347.1">fold_right</span></span><span class="koboSpan" id="kobo.3348.1">(std::plus&lt;&gt;(), chars, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3349.1">""</span></span><span class="koboSpan" id="kobo.3350.1">s);
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.3351.1">// str2 = "civic"</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3352.1">Counting the</span><a id="_idIndexMarker462"/><span class="koboSpan" id="kobo.3353.1"> number of words in text based on their already computed appearances, available in a </span><code class="inlineCode"><span class="koboSpan" id="kobo.3354.1">map&lt;string, int&gt;</span></code><span class="koboSpan" id="kobo.3355.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3356.1">auto</span></span><span class="koboSpan" id="kobo.3357.1"> words = std::map&lt;std::string, </span><span class="hljs-type"><span class="koboSpan" id="kobo.3358.1">int</span></span><span class="koboSpan" id="kobo.3359.1">&gt;{
  {</span><span class="hljs-string"><span class="koboSpan" id="kobo.3360.1">"one"</span></span><span class="koboSpan" id="kobo.3361.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3362.1">1</span></span><span class="koboSpan" id="kobo.3363.1">}, {</span><span class="hljs-string"><span class="koboSpan" id="kobo.3364.1">"two"</span></span><span class="koboSpan" id="kobo.3365.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3366.1">2</span></span><span class="koboSpan" id="kobo.3367.1">}, {</span><span class="hljs-string"><span class="koboSpan" id="kobo.3368.1">"three"</span></span><span class="koboSpan" id="kobo.3369.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3370.1">3</span></span><span class="koboSpan" id="kobo.3371.1">} };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3372.1">auto</span></span><span class="koboSpan" id="kobo.3373.1"> count = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3374.1">fold_left</span></span><span class="koboSpan" id="kobo.3375.1">(
  [](</span><span class="hljs-type"><span class="koboSpan" id="kobo.3376.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3377.1">const</span></span><span class="koboSpan" id="kobo.3378.1"> s, std::pair&lt;std::string, </span><span class="hljs-type"><span class="koboSpan" id="kobo.3379.1">int</span></span><span class="koboSpan" id="kobo.3380.1">&gt; </span><span class="hljs-type"><span class="koboSpan" id="kobo.3381.1">const</span></span><span class="koboSpan" id="kobo.3382.1"> kvp) {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3383.1">return</span></span><span class="koboSpan" id="kobo.3384.1"> s + kvp.second; },
  words, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3385.1">0</span></span><span class="koboSpan" id="kobo.3386.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3387.1">// count = 6</span></span>
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-214"><span class="koboSpan" id="kobo.3388.1">There’s more...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3389.1">These functions can be pipelined—that is, they can call one function with the result of another. </span><span class="koboSpan" id="kobo.3389.2">The following example maps a range of integers into a range of positive integers by applying the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3390.1">std::abs()</span></code><span class="koboSpan" id="kobo.3391.1"> function to its elements. </span><span class="koboSpan" id="kobo.3391.2">The result is then mapped into another range of squares. </span><span class="koboSpan" id="kobo.3391.3">These are then summed together by applying a left fold on the range:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3392.1">auto</span></span><span class="koboSpan" id="kobo.3393.1"> vnums = std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3394.1">int</span></span><span class="koboSpan" id="kobo.3395.1">&gt;{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.3396.1">0</span></span><span class="koboSpan" id="kobo.3397.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3398.1">2</span></span><span class="koboSpan" id="kobo.3399.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3400.1">-3</span></span><span class="koboSpan" id="kobo.3401.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3402.1">5</span></span><span class="koboSpan" id="kobo.3403.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3404.1">-1</span></span><span class="koboSpan" id="kobo.3405.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3406.1">6</span></span><span class="koboSpan" id="kobo.3407.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3408.1">8</span></span><span class="koboSpan" id="kobo.3409.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3410.1">-4</span></span><span class="koboSpan" id="kobo.3411.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3412.1">9</span></span><span class="koboSpan" id="kobo.3413.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3414.1">auto</span></span><span class="koboSpan" id="kobo.3415.1"> s = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3416.1">fold_left</span></span><span class="koboSpan" id="kobo.3417.1">(
  std::plus&lt;&gt;(),
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3418.1">mapf</span></span><span class="koboSpan" id="kobo.3419.1">(
    [](</span><span class="hljs-type"><span class="koboSpan" id="kobo.3420.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3421.1">const</span></span><span class="koboSpan" id="kobo.3422.1"> i) {</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3423.1">return</span></span><span class="koboSpan" id="kobo.3424.1"> i*I; },
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3425.1">mapf</span></span><span class="koboSpan" id="kobo.3426.1">(
      [](</span><span class="hljs-type"><span class="koboSpan" id="kobo.3427.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3428.1">const</span></span><span class="koboSpan" id="kobo.3429.1"> i) {</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3430.1">return</span></span><span class="koboSpan" id="kobo.3431.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3432.1">abs</span></span><span class="koboSpan" id="kobo.3433.1">(i); },
      vnums)),
  </span><span class="hljs-number"><span class="koboSpan" id="kobo.3434.1">0</span></span><span class="koboSpan" id="kobo.3435.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3436.1">// s = 236</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3437.1">As an exercise, we could implement the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3438.1">fold</span></code><span class="koboSpan" id="kobo.3439.1"> function as a variadic function template, in the manner seen earlier. </span><span class="koboSpan" id="kobo.3439.2">The function that performs the actual folding is provided as an argument:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3440.1">template</span></span><span class="koboSpan" id="kobo.3441.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3442.1">typename</span></span><span class="koboSpan" id="kobo.3443.1"> F, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3444.1">typename</span></span><span class="koboSpan" id="kobo.3445.1"> T1, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3446.1">typename</span></span><span class="koboSpan" id="kobo.3447.1"> T2&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3448.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3449.1">fold_left</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3450.1">(F&amp;&amp;f, T1 arg1, T2 arg2)</span></span><span class="koboSpan" id="kobo.3451.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3452.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.3453.1">f</span></span><span class="koboSpan" id="kobo.3454.1">(arg1, arg2);
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3455.1">template</span></span><span class="koboSpan" id="kobo.3456.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3457.1">typename</span></span><span class="koboSpan" id="kobo.3458.1"> F, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3459.1">typename</span></span><span class="koboSpan" id="kobo.3460.1"> T, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3461.1">typename</span></span><span class="koboSpan" id="kobo.3462.1">... </span><span class="koboSpan" id="kobo.3462.2">Ts&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3463.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3464.1">fold_left</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3465.1">(F&amp;&amp; f, T head, Ts… rest)</span></span><span class="koboSpan" id="kobo.3466.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3467.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.3468.1">f</span></span><span class="koboSpan" id="kobo.3469.1">(head, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3470.1">fold_left</span></span><span class="koboSpan" id="kobo.3471.1">(std::forward&lt;F&gt;(f), rest...));
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3472.1">When we compare this with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3473.1">add()</span></code><span class="koboSpan" id="kobo.3474.1"> function template that we wrote in the </span><em class="italic"><span class="koboSpan" id="kobo.3475.1">Writing a function template with a variable number of arguments</span></em><span class="koboSpan" id="kobo.3476.1"> recipe, we can notice several differences:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.3477.1">The first argument is a function, which is perfectly forwarded when calling </span><code class="inlineCode"><span class="koboSpan" id="kobo.3478.1">fold_left</span></code><span class="koboSpan" id="kobo.3479.1"> recursively.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3480.1">The end case is a function that requires two arguments because the function we use for folding is a binary one (taking two arguments).</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3481.1">The return type of the two functions we wrote is declared as </span><code class="inlineCode"><span class="koboSpan" id="kobo.3482.1">auto</span></code><span class="koboSpan" id="kobo.3483.1"> because it must match the return type of the supplied binary function </span><code class="inlineCode"><span class="koboSpan" id="kobo.3484.1">f</span></code><span class="koboSpan" id="kobo.3485.1">, which is not known until we call </span><code class="inlineCode"><span class="koboSpan" id="kobo.3486.1">fold_left</span></code><span class="koboSpan" id="kobo.3487.1">.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.3488.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.3489.1">fold_left()</span></code><span class="koboSpan" id="kobo.3490.1"> function can be used as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3491.1">auto</span></span><span class="koboSpan" id="kobo.3492.1"> s1 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3493.1">fold_left</span></span><span class="koboSpan" id="kobo.3494.1">(std::plus&lt;&gt;(), </span><span class="hljs-number"><span class="koboSpan" id="kobo.3495.1">1</span></span><span class="koboSpan" id="kobo.3496.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3497.1">2</span></span><span class="koboSpan" id="kobo.3498.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3499.1">3</span></span><span class="koboSpan" id="kobo.3500.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3501.1">4</span></span><span class="koboSpan" id="kobo.3502.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3503.1">5</span></span><span class="koboSpan" id="kobo.3504.1">);
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.3505.1">// s1 = 15</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.3506.1">auto</span></span><span class="koboSpan" id="kobo.3507.1"> s2 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3508.1">fold_left</span></span><span class="koboSpan" id="kobo.3509.1">(std::plus&lt;&gt;(), </span><span class="hljs-string"><span class="koboSpan" id="kobo.3510.1">"hello"</span></span><span class="koboSpan" id="kobo.3511.1">s, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3512.1">'</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.3513.1"> '</span></span><span class="koboSpan" id="kobo.3514.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3515.1">"world"</span></span><span class="koboSpan" id="kobo.3516.1">s, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3517.1">'!'</span></span><span class="koboSpan" id="kobo.3518.1">);
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.3519.1">// s2 = "hello world!"</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.3520.1">auto</span></span><span class="koboSpan" id="kobo.3521.1"> s3 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3522.1">fold_left</span></span><span class="koboSpan" id="kobo.3523.1">(std::plus&lt;&gt;(), </span><span class="hljs-number"><span class="koboSpan" id="kobo.3524.1">1</span></span><span class="koboSpan" id="kobo.3525.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3526.1">// error, too few arguments</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3527.1">Notice that the last call produces a compiler error because the variadic function template </span><code class="inlineCode"><span class="koboSpan" id="kobo.3528.1">fold_left()</span></code><span class="koboSpan" id="kobo.3529.1"> requires at least two arguments to be passed in order to invoke the supplied binary function.</span></p>
<h2 class="heading-2" id="_idParaDest-215"><span class="koboSpan" id="kobo.3530.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="chapterRef"><span class="koboSpan" id="kobo.3531.1">Chapter 2</span></em><span class="koboSpan" id="kobo.3532.1">, </span><em class="italic"><span class="koboSpan" id="kobo.3533.1">Creating a library of string helpers</span></em><span class="koboSpan" id="kobo.3534.1">, to see how to create useful text utilities that are not directly available in the standard library</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.3535.1">Writing a function template with a variable number of arguments</span></em><span class="koboSpan" id="kobo.3536.1">, to see how variadic templates enable us to write functions that can take any number of arguments</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.3537.1">Composing functions into a higher-order function</span></em><span class="koboSpan" id="kobo.3538.1">, to learn the functional programming technique for creating a new function from one or more other functions</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-216"><span class="koboSpan" id="kobo.3539.1">Composing functions into a higher-order function</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3540.1">In the previous recipe, we implemented two </span><a id="_idIndexMarker463"/><span class="koboSpan" id="kobo.3541.1">higher-order functions, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3542.1">map</span></code><span class="koboSpan" id="kobo.3543.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3544.1">fold</span></code><span class="koboSpan" id="kobo.3545.1">, and saw various examples of using them. </span><span class="koboSpan" id="kobo.3545.2">At the end of the recipe, we saw how they can be pipelined to produce a final value after several transformations of the original data. </span><span class="koboSpan" id="kobo.3545.3">Pipelining is a form of composition, which means creating one new function from two or more given functions. </span><span class="koboSpan" id="kobo.3545.4">In the mentioned example, we didn’t actually compose functions; we only called a function with the result produced by another, but in this recipe, we will learn how to actually compose functions together into a new function. </span><span class="koboSpan" id="kobo.3545.5">For simplicity, we will only consider unary functions (functions that take only one argument).</span></p>
<h2 class="heading-2" id="_idParaDest-217"><span class="koboSpan" id="kobo.3546.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3547.1">Before you go forward, it is recommended that you read the previous recipe, </span><em class="italic"><span class="koboSpan" id="kobo.3548.1">Implementing the higher-order functions map and fold</span></em><span class="koboSpan" id="kobo.3549.1">. </span><span class="koboSpan" id="kobo.3549.2">It is not mandatory for understanding this recipe, but we will refer to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3550.1">map</span></code><span class="koboSpan" id="kobo.3551.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3552.1">fold</span></code><span class="koboSpan" id="kobo.3553.1"> functions we implemented there.</span></p>
<h2 class="heading-2" id="_idParaDest-218"><span class="koboSpan" id="kobo.3554.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3555.1">To compose</span><a id="_idIndexMarker464"/><span class="koboSpan" id="kobo.3556.1"> unary functions</span><a id="_idIndexMarker465"/><span class="koboSpan" id="kobo.3557.1"> into a higher-order function, you should do the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.3558.1">To compose two functions, provide a function that takes two functions, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3559.1">f</span></code><span class="koboSpan" id="kobo.3560.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3561.1">g</span></code><span class="koboSpan" id="kobo.3562.1">, as arguments and returns a new function (a lambda) that returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.3563.1">f(g(x))</span></code><span class="koboSpan" id="kobo.3564.1">, where </span><code class="inlineCode"><span class="koboSpan" id="kobo.3565.1">x</span></code><span class="koboSpan" id="kobo.3566.1"> is the argument of the composed function:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3567.1">template</span></span><span class="koboSpan" id="kobo.3568.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3569.1">typename</span></span><span class="koboSpan" id="kobo.3570.1"> F, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3571.1">typename</span></span><span class="koboSpan" id="kobo.3572.1"> G&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3573.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3574.1">compose</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3575.1">(F&amp;&amp; f, G&amp;&amp; g)</span></span><span class="koboSpan" id="kobo.3576.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3577.1">return</span></span><span class="koboSpan" id="kobo.3578.1"> [=](</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3579.1">auto</span></span><span class="koboSpan" id="kobo.3580.1"> x) { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3581.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.3582.1">f</span></span><span class="koboSpan" id="kobo.3583.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3584.1">g</span></span><span class="koboSpan" id="kobo.3585.1">(x)); };
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3586.1">auto</span></span><span class="koboSpan" id="kobo.3587.1"> v = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3588.1">compose</span></span><span class="koboSpan" id="kobo.3589.1">(
  [](</span><span class="hljs-type"><span class="koboSpan" id="kobo.3590.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3591.1">const</span></span><span class="koboSpan" id="kobo.3592.1"> n) {</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3593.1">return</span></span><span class="koboSpan" id="kobo.3594.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3595.1">to_string</span></span><span class="koboSpan" id="kobo.3596.1">(n); },
  [](</span><span class="hljs-type"><span class="koboSpan" id="kobo.3597.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3598.1">const</span></span><span class="koboSpan" id="kobo.3599.1"> n) {</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3600.1">return</span></span><span class="koboSpan" id="kobo.3601.1"> n * n; })(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3602.1">-3</span></span><span class="koboSpan" id="kobo.3603.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3604.1">// v = "9"</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3605.1">To compose a variable number of functions, provide a variadic template overload of the function described previously:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3606.1">template</span></span><span class="koboSpan" id="kobo.3607.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3608.1">typename</span></span><span class="koboSpan" id="kobo.3609.1"> F, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3610.1">typename</span></span><span class="koboSpan" id="kobo.3611.1">... </span><span class="koboSpan" id="kobo.3611.2">R&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3612.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3613.1">compose</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3614.1">(F&amp;&amp; f, R&amp;&amp;... </span><span class="koboSpan" id="kobo.3614.2">r)</span></span><span class="koboSpan" id="kobo.3615.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3616.1">return</span></span><span class="koboSpan" id="kobo.3617.1"> [=](</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3618.1">auto</span></span><span class="koboSpan" id="kobo.3619.1"> x) { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3620.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.3621.1">f</span></span><span class="koboSpan" id="kobo.3622.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3623.1">compose</span></span><span class="koboSpan" id="kobo.3624.1">(r...)(x)); };
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3625.1">auto</span></span><span class="koboSpan" id="kobo.3626.1"> n = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3627.1">compose</span></span><span class="koboSpan" id="kobo.3628.1">(
  [](</span><span class="hljs-type"><span class="koboSpan" id="kobo.3629.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3630.1">const</span></span><span class="koboSpan" id="kobo.3631.1"> n) {</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3632.1">return</span></span><span class="koboSpan" id="kobo.3633.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3634.1">to_string</span></span><span class="koboSpan" id="kobo.3635.1">(n); },
  [](</span><span class="hljs-type"><span class="koboSpan" id="kobo.3636.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3637.1">const</span></span><span class="koboSpan" id="kobo.3638.1"> n) {</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3639.1">return</span></span><span class="koboSpan" id="kobo.3640.1"> n * n; },
  [](</span><span class="hljs-type"><span class="koboSpan" id="kobo.3641.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3642.1">const</span></span><span class="koboSpan" id="kobo.3643.1"> n) {</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3644.1">return</span></span><span class="koboSpan" id="kobo.3645.1"> n + n; },
  [](</span><span class="hljs-type"><span class="koboSpan" id="kobo.3646.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3647.1">const</span></span><span class="koboSpan" id="kobo.3648.1"> n) {</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3649.1">return</span></span><span class="koboSpan" id="kobo.3650.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3651.1">abs</span></span><span class="koboSpan" id="kobo.3652.1">(n); })(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3653.1">-3</span></span><span class="koboSpan" id="kobo.3654.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3655.1">// n = "36"</span></span>
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-219"><span class="koboSpan" id="kobo.3656.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3657.1">Composing two unary functions into a new one is relatively trivial. </span><span class="koboSpan" id="kobo.3657.2">Create a template function, which we called </span><code class="inlineCode"><span class="koboSpan" id="kobo.3658.1">compose()</span></code><span class="koboSpan" id="kobo.3659.1"> in the earlier examples, with two arguments—</span><code class="inlineCode"><span class="koboSpan" id="kobo.3660.1">f</span></code><span class="koboSpan" id="kobo.3661.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3662.1">g</span></code><span class="koboSpan" id="kobo.3663.1">—that represent functions, and return a function that takes one argument, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3664.1">x</span></code><span class="koboSpan" id="kobo.3665.1">, and returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.3666.1">f(g(x))</span></code><span class="koboSpan" id="kobo.3667.1">. </span><span class="koboSpan" id="kobo.3667.2">It is important that the type of the value returned by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3668.1">g</span></code><span class="koboSpan" id="kobo.3669.1"> function is the same as the type of the argument of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3670.1">f</span></code><span class="koboSpan" id="kobo.3671.1"> function. </span><span class="koboSpan" id="kobo.3671.2">The returned value of the compose function is a closure—that is, it’s an instantiation of a lambda.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3672.1">In practice, it is useful </span><a id="_idIndexMarker466"/><span class="koboSpan" id="kobo.3673.1">to be able to combine more </span><a id="_idIndexMarker467"/><span class="koboSpan" id="kobo.3674.1">than just two functions. </span><span class="koboSpan" id="kobo.3674.2">This can be achieved by writing a variadic template version of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3675.1">compose()</span></code><span class="koboSpan" id="kobo.3676.1"> function. </span><span class="koboSpan" id="kobo.3676.2">Variadic templates are explained in more detail in the </span><em class="italic"><span class="koboSpan" id="kobo.3677.1">Writing a function template with a variable number of arguments</span></em><span class="koboSpan" id="kobo.3678.1"> recipe.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3679.1">Variadic</span><a id="_idIndexMarker468"/><span class="koboSpan" id="kobo.3680.1"> templates imply compile-time recursion by expanding the parameter pack. </span><span class="koboSpan" id="kobo.3680.2">This implementation is very similar to the first version of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3681.1">compose()</span></code><span class="koboSpan" id="kobo.3682.1">, except for the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.3683.1">It takes a variable number of functions as arguments.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3684.1">The returned closure calls </span><code class="inlineCode"><span class="koboSpan" id="kobo.3685.1">compose()</span></code><span class="koboSpan" id="kobo.3686.1"> recursively with the expanded parameter pack; recursion ends when only two functions are left, in which case the previously implemented overload is called.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.3687.1">Even if the code looks like recursion is happening, this is not true recursion. </span><span class="koboSpan" id="kobo.3687.2">It could be called compile-time recursion, but with every expansion, we get a call to another method with the same name but a different number of arguments, which does not represent recursion.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3688.1">Now that we have these variadic template</span><a id="_idIndexMarker469"/><span class="koboSpan" id="kobo.3689.1"> overloads implemented, we can rewrite the last example from the previous recipe, </span><em class="italic"><span class="koboSpan" id="kobo.3690.1">Implementing the higher-order functions map and fold</span></em><span class="koboSpan" id="kobo.3691.1">. </span><span class="koboSpan" id="kobo.3691.2">Refer to the following snippet:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3692.1">auto</span></span><span class="koboSpan" id="kobo.3693.1"> s = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3694.1">compose</span></span><span class="koboSpan" id="kobo.3695.1">(
  [](std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3696.1">int</span></span><span class="koboSpan" id="kobo.3697.1">&gt; </span><span class="hljs-type"><span class="koboSpan" id="kobo.3698.1">const</span></span><span class="koboSpan" id="kobo.3699.1"> &amp; v) {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3700.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.3701.1">fold_left</span></span><span class="koboSpan" id="kobo.3702.1">(std::plus&lt;&gt;(), v, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3703.1">0</span></span><span class="koboSpan" id="kobo.3704.1">); },
  [](std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3705.1">int</span></span><span class="koboSpan" id="kobo.3706.1">&gt; </span><span class="hljs-type"><span class="koboSpan" id="kobo.3707.1">const</span></span><span class="koboSpan" id="kobo.3708.1"> &amp; v) {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3709.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.3710.1">mapf</span></span><span class="koboSpan" id="kobo.3711.1">([](</span><span class="hljs-type"><span class="koboSpan" id="kobo.3712.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3713.1">const</span></span><span class="koboSpan" id="kobo.3714.1"> i) {</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3715.1">return</span></span><span class="koboSpan" id="kobo.3716.1"> i + i; }, v); },
  [](std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3717.1">int</span></span><span class="koboSpan" id="kobo.3718.1">&gt; </span><span class="hljs-type"><span class="koboSpan" id="kobo.3719.1">const</span></span><span class="koboSpan" id="kobo.3720.1"> &amp; v) {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3721.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.3722.1">mapf</span></span><span class="koboSpan" id="kobo.3723.1">([](</span><span class="hljs-type"><span class="koboSpan" id="kobo.3724.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3725.1">const</span></span><span class="koboSpan" id="kobo.3726.1"> i) {</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3727.1">return</span></span><span class="koboSpan" id="kobo.3728.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3729.1">abs</span></span><span class="koboSpan" id="kobo.3730.1">(i); }, v); })(vnums);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3731.1">Having an initial </span><a id="_idIndexMarker470"/><span class="koboSpan" id="kobo.3732.1">vector of integers, we map it to a </span><a id="_idIndexMarker471"/><span class="koboSpan" id="kobo.3733.1">new vector with only positive values by applying </span><code class="inlineCode"><span class="koboSpan" id="kobo.3734.1">std::abs()</span></code><span class="koboSpan" id="kobo.3735.1"> to each element. </span><span class="koboSpan" id="kobo.3735.2">The result is then mapped to a new vector by doubling the value of each element. </span><span class="koboSpan" id="kobo.3735.3">Finally, the values in the resulting vector are folded together by adding them to the initial value, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3736.1">0</span></code><span class="koboSpan" id="kobo.3737.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-220"><span class="koboSpan" id="kobo.3738.1">There’s more...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3739.1">Composition</span><a id="_idIndexMarker472"/><span class="koboSpan" id="kobo.3740.1"> is usually represented by a dot (</span><code class="inlineCode"><span class="koboSpan" id="kobo.3741.1">.</span></code><span class="koboSpan" id="kobo.3742.1">) or asterisk (</span><code class="inlineCode"><span class="koboSpan" id="kobo.3743.1">*</span></code><span class="koboSpan" id="kobo.3744.1">), such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.3745.1">f . </span><span class="koboSpan" id="kobo.3745.2">g</span></code><span class="koboSpan" id="kobo.3746.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.3747.1">f * g</span></code><span class="koboSpan" id="kobo.3748.1">. </span><span class="koboSpan" id="kobo.3748.2">We can actually do something similar in C++ by overloading </span><code class="inlineCode"><span class="koboSpan" id="kobo.3749.1">operator*</span></code><span class="koboSpan" id="kobo.3750.1"> (it would make little sense to try to overload the operator dot). </span><span class="koboSpan" id="kobo.3750.2">Similar to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3751.1">compose()</span></code><span class="koboSpan" id="kobo.3752.1"> function, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3753.1">operator*</span></code><span class="koboSpan" id="kobo.3754.1"> should work with any number of arguments; therefore, we will have two overloads, just like in the case of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3755.1">compose()</span></code><span class="koboSpan" id="kobo.3756.1">:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.3757.1">The first overload takes two arguments and calls </span><code class="inlineCode"><span class="koboSpan" id="kobo.3758.1">compose()</span></code><span class="koboSpan" id="kobo.3759.1"> to return a new function.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3760.1">The second overload is a variadic template function that, again, calls </span><code class="inlineCode"><span class="koboSpan" id="kobo.3761.1">operator*</span></code><span class="koboSpan" id="kobo.3762.1"> by expanding the parameter pack.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.3763.1">Based on these considerations, we can implement </span><code class="inlineCode"><span class="koboSpan" id="kobo.3764.1">operator*</span></code><span class="koboSpan" id="kobo.3765.1"> as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3766.1">template</span></span><span class="koboSpan" id="kobo.3767.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3768.1">typename</span></span><span class="koboSpan" id="kobo.3769.1"> F, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3770.1">typename</span></span><span class="koboSpan" id="kobo.3771.1"> G&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3772.1">auto</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.3773.1">operator</span></span><span class="koboSpan" id="kobo.3774.1">*(F&amp;&amp; f, G&amp;&amp; g)
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3775.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.3776.1">compose</span></span><span class="koboSpan" id="kobo.3777.1">(std::forward&lt;F&gt;(f), std::forward&lt;G&gt;(g));
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3778.1">template</span></span><span class="koboSpan" id="kobo.3779.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3780.1">typename</span></span><span class="koboSpan" id="kobo.3781.1"> F, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3782.1">typename</span></span><span class="koboSpan" id="kobo.3783.1">... </span><span class="koboSpan" id="kobo.3783.2">R&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3784.1">auto</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.3785.1">operator</span></span><span class="koboSpan" id="kobo.3786.1">*(F&amp;&amp; f, R&amp;&amp;... </span><span class="koboSpan" id="kobo.3786.2">r)
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3787.1">return</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.3788.1">operator</span></span><span class="koboSpan" id="kobo.3789.1">*(std::forward&lt;F&gt;(f), r...);
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3790.1">We can now simplify the actual composition of functions by applying </span><code class="inlineCode"><span class="koboSpan" id="kobo.3791.1">operator*</span></code><span class="koboSpan" id="kobo.3792.1"> instead of the more verbose call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.3793.1">compose()</span></code><span class="koboSpan" id="kobo.3794.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3795.1">auto</span></span><span class="koboSpan" id="kobo.3796.1"> n =
  ([](</span><span class="hljs-type"><span class="koboSpan" id="kobo.3797.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3798.1">const</span></span><span class="koboSpan" id="kobo.3799.1"> n) {</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3800.1">return</span></span><span class="koboSpan" id="kobo.3801.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3802.1">to_string</span></span><span class="koboSpan" id="kobo.3803.1">(n); } *
   [](</span><span class="hljs-type"><span class="koboSpan" id="kobo.3804.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3805.1">const</span></span><span class="koboSpan" id="kobo.3806.1"> n) {</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3807.1">return</span></span><span class="koboSpan" id="kobo.3808.1"> n * n; } *
   [](</span><span class="hljs-type"><span class="koboSpan" id="kobo.3809.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3810.1">const</span></span><span class="koboSpan" id="kobo.3811.1"> n) {</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3812.1">return</span></span><span class="koboSpan" id="kobo.3813.1"> n + n; } *
   [](</span><span class="hljs-type"><span class="koboSpan" id="kobo.3814.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3815.1">const</span></span><span class="koboSpan" id="kobo.3816.1"> n) {</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3817.1">return</span></span><span class="koboSpan" id="kobo.3818.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3819.1">abs</span></span><span class="koboSpan" id="kobo.3820.1">(n); })(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3821.1">-3</span></span><span class="koboSpan" id="kobo.3822.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3823.1">// n = "36"</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.3824.1">auto</span></span><span class="koboSpan" id="kobo.3825.1"> c =
  [](std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3826.1">int</span></span><span class="koboSpan" id="kobo.3827.1">&gt; </span><span class="hljs-type"><span class="koboSpan" id="kobo.3828.1">const</span></span><span class="koboSpan" id="kobo.3829.1"> &amp; v) {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3830.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.3831.1">fold_left</span></span><span class="koboSpan" id="kobo.3832.1">(std::plus&lt;&gt;(), v, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3833.1">0</span></span><span class="koboSpan" id="kobo.3834.1">); } *
  [](std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3835.1">int</span></span><span class="koboSpan" id="kobo.3836.1">&gt; </span><span class="hljs-type"><span class="koboSpan" id="kobo.3837.1">const</span></span><span class="koboSpan" id="kobo.3838.1"> &amp; v) {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3839.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.3840.1">mapf</span></span><span class="koboSpan" id="kobo.3841.1">([](</span><span class="hljs-type"><span class="koboSpan" id="kobo.3842.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3843.1">const</span></span><span class="koboSpan" id="kobo.3844.1"> i) {</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3845.1">return</span></span><span class="koboSpan" id="kobo.3846.1"> i + i; }, v); } *
  [](std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3847.1">int</span></span><span class="koboSpan" id="kobo.3848.1">&gt; </span><span class="hljs-type"><span class="koboSpan" id="kobo.3849.1">const</span></span><span class="koboSpan" id="kobo.3850.1"> &amp; v) {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3851.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.3852.1">mapf</span></span><span class="koboSpan" id="kobo.3853.1">([](</span><span class="hljs-type"><span class="koboSpan" id="kobo.3854.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3855.1">const</span></span><span class="koboSpan" id="kobo.3856.1"> i) {</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3857.1">return</span></span><span class="koboSpan" id="kobo.3858.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3859.1">abs</span></span><span class="koboSpan" id="kobo.3860.1">(i); }, v); };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3861.1">auto</span></span><span class="koboSpan" id="kobo.3862.1"> vnums = std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3863.1">int</span></span><span class="koboSpan" id="kobo.3864.1">&gt;{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.3865.1">2</span></span><span class="koboSpan" id="kobo.3866.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3867.1">-3</span></span><span class="koboSpan" id="kobo.3868.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3869.1">5</span></span><span class="koboSpan" id="kobo.3870.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3871.1">auto</span></span><span class="koboSpan" id="kobo.3872.1"> s = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3873.1">c</span></span><span class="koboSpan" id="kobo.3874.1">(vnums); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3875.1">// s = 20</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3876.1">Although it may not be intuitive at first glance, the functions are applied in reverse order rather than the one shown in the text. </span><span class="koboSpan" id="kobo.3876.2">For instance, in the first example, the absolute value of the argument is retained. </span><span class="koboSpan" id="kobo.3876.3">Then, the result is doubled, and the result of that operation is then multiplied by itself. </span><span class="koboSpan" id="kobo.3876.4">Finally, the result is converted to a string. </span><span class="koboSpan" id="kobo.3876.5">For the supplied argument, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3877.1">-3</span></code><span class="koboSpan" id="kobo.3878.1">, the final result is the string </span><code class="inlineCode"><span class="koboSpan" id="kobo.3879.1">"36"</span></code><span class="koboSpan" id="kobo.3880.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-221"><span class="koboSpan" id="kobo.3881.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.3882.1">Writing a function template with a variable number of arguments</span></em><span class="koboSpan" id="kobo.3883.1">, to see how variadic templates enable us to write functions that can take any number of arguments</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-222"><span class="koboSpan" id="kobo.3884.1">Uniformly invoking anything callable</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3885.1">Developers, especially those who implement libraries, sometimes need to invoke a callable object </span><a id="_idIndexMarker473"/><span class="koboSpan" id="kobo.3886.1">in a uniform manner. </span><span class="koboSpan" id="kobo.3886.2">This can be a function, a pointer to a function, a pointer to a member function, or a function object. </span><span class="koboSpan" id="kobo.3886.3">Examples of such cases include </span><code class="inlineCode"><span class="koboSpan" id="kobo.3887.1">std::bind</span></code><span class="koboSpan" id="kobo.3888.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3889.1">std::function</span></code><span class="koboSpan" id="kobo.3890.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3891.1">std::mem_fn</span></code><span class="koboSpan" id="kobo.3892.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3893.1">std::thread::thread</span></code><span class="koboSpan" id="kobo.3894.1">. </span><span class="koboSpan" id="kobo.3894.2">C++17 defines a standard function called </span><code class="inlineCode"><span class="koboSpan" id="kobo.3895.1">std::invoke()</span></code><span class="koboSpan" id="kobo.3896.1"> that can invoke any callable object with the provided arguments. </span><span class="koboSpan" id="kobo.3896.2">This is not intended to replace direct calls to functions or function objects, but it is useful in template metaprogramming for implementing various library functions.</span></p>
<h2 class="heading-2" id="_idParaDest-223"><span class="koboSpan" id="kobo.3897.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3898.1">For this recipe, you should be familiar with how to define and use function pointers.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3899.1">To exemplify how </span><code class="inlineCode"><span class="koboSpan" id="kobo.3900.1">std::invoke()</span></code><span class="koboSpan" id="kobo.3901.1"> can be used in different contexts, we will use the following function and class:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.3902.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3903.1">add</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3904.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3905.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.3906.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3907.1"> a, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3908.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.3909.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3910.1"> b)</span></span><span class="koboSpan" id="kobo.3911.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3912.1">return</span></span><span class="koboSpan" id="kobo.3913.1"> a + b;
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3914.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.3915.1">foo</span></span><span class="koboSpan" id="kobo.3916.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.3917.1">int</span></span><span class="koboSpan" id="kobo.3918.1"> x = </span><span class="hljs-number"><span class="koboSpan" id="kobo.3919.1">0</span></span><span class="koboSpan" id="kobo.3920.1">;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.3921.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3922.1">increment_by</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3923.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3924.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.3925.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3926.1"> n)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.3927.1">{ x += n; }
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3928.1">In the next section, we’ll explore the possible use cases for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3929.1">std::invoke()</span></code><span class="koboSpan" id="kobo.3930.1"> function.</span></p>
<h2 class="heading-2" id="_idParaDest-224"><span class="koboSpan" id="kobo.3931.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3932.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.3933.1">std::invoke()</span></code><span class="koboSpan" id="kobo.3934.1"> function</span><a id="_idIndexMarker474"/><span class="koboSpan" id="kobo.3935.1"> is a </span><a id="_idIndexMarker475"/><span class="koboSpan" id="kobo.3936.1">variadic function template that takes the callable object as the first argument and a variable list of arguments that are passed to the call. </span><code class="inlineCode"><span class="koboSpan" id="kobo.3937.1">std::invoke()</span></code><span class="koboSpan" id="kobo.3938.1"> can be used to call the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.3939.1">Free functions:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3940.1">auto</span></span><span class="koboSpan" id="kobo.3941.1"> a1 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3942.1">invoke</span></span><span class="koboSpan" id="kobo.3943.1">(add, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3944.1">1</span></span><span class="koboSpan" id="kobo.3945.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3946.1">2</span></span><span class="koboSpan" id="kobo.3947.1">);   </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3948.1">// a1 = 3</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3949.1">Free functions through a pointer to function:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3950.1">auto</span></span><span class="koboSpan" id="kobo.3951.1"> a2 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3952.1">invoke</span></span><span class="koboSpan" id="kobo.3953.1">(&amp;add, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3954.1">1</span></span><span class="koboSpan" id="kobo.3955.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3956.1">2</span></span><span class="koboSpan" id="kobo.3957.1">);  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3958.1">// a2 = 3</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.3959.1">int</span></span><span class="koboSpan" id="kobo.3960.1">(*fadd)(</span><span class="hljs-type"><span class="koboSpan" id="kobo.3961.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3962.1">const</span></span><span class="koboSpan" id="kobo.3963.1">, </span><span class="hljs-type"><span class="koboSpan" id="kobo.3964.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3965.1">const</span></span><span class="koboSpan" id="kobo.3966.1">) = &amp;add;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3967.1">auto</span></span><span class="koboSpan" id="kobo.3968.1"> a3 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3969.1">invoke</span></span><span class="koboSpan" id="kobo.3970.1">(fadd, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3971.1">1</span></span><span class="koboSpan" id="kobo.3972.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3973.1">2</span></span><span class="koboSpan" id="kobo.3974.1">);  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3975.1">// a3 = 3</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3976.1">Member functions through a pointer to member function:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3977.1">foo f;
std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3978.1">invoke</span></span><span class="koboSpan" id="kobo.3979.1">(&amp;foo::increment_by, f, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3980.1">10</span></span><span class="koboSpan" id="kobo.3981.1">);
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3982.1">Data members:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3983.1">foo f;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3984.1">auto</span></span><span class="koboSpan" id="kobo.3985.1"> x1 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3986.1">invoke</span></span><span class="koboSpan" id="kobo.3987.1">(&amp;foo::x, f);  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3988.1">// x1 = 0</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3989.1">Function objects:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3990.1">foo f;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3991.1">auto</span></span><span class="koboSpan" id="kobo.3992.1"> x3 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3993.1">invoke</span></span><span class="koboSpan" id="kobo.3994.1">(std::plus&lt;&gt;(),
  std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3995.1">invoke</span></span><span class="koboSpan" id="kobo.3996.1">(&amp;foo::x, f), </span><span class="hljs-number"><span class="koboSpan" id="kobo.3997.1">3</span></span><span class="koboSpan" id="kobo.3998.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3999.1">// x3 = 3</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4000.1">Lambda expressions:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4001.1">auto</span></span><span class="koboSpan" id="kobo.4002.1"> l = [](</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4003.1">auto</span></span><span class="koboSpan" id="kobo.4004.1"> a, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4005.1">auto</span></span><span class="koboSpan" id="kobo.4006.1"> b) {</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4007.1">return</span></span><span class="koboSpan" id="kobo.4008.1"> a + b; };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4009.1">auto</span></span><span class="koboSpan" id="kobo.4010.1"> a = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4011.1">invoke</span></span><span class="koboSpan" id="kobo.4012.1">(l, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4013.1">1</span></span><span class="koboSpan" id="kobo.4014.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4015.1">2</span></span><span class="koboSpan" id="kobo.4016.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4017.1">// a = 3</span></span>
</code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.4018.1">In practice, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4019.1">std:invoke()</span></code><span class="koboSpan" id="kobo.4020.1"> should </span><a id="_idIndexMarker476"/><span class="koboSpan" id="kobo.4021.1">be used in template metaprogramming to invoke a function with an arbitrary number of arguments. </span><span class="koboSpan" id="kobo.4021.2">To exemplify such a case, we’ll present a possible implementation for our </span><code class="inlineCode"><span class="koboSpan" id="kobo.4022.1">std::apply()</span></code><span class="koboSpan" id="kobo.4023.1"> function, and also a part of the standard library, as of C++17, that calls a function by unpacking the members of a tuple into the arguments of the function:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4024.1">namespace</span></span><span class="koboSpan" id="kobo.4025.1"> details
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4026.1">template</span></span><span class="koboSpan" id="kobo.4027.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4028.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.4029.1">F</span></span><span class="koboSpan" id="kobo.4030.1">, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4031.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.4032.1">T</span></span><span class="koboSpan" id="kobo.4033.1">, std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.4034.1">size_t</span></span><span class="koboSpan" id="kobo.4035.1">... </span><span class="koboSpan" id="kobo.4035.2">I&gt;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4036.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4037.1">apply</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4038.1">(F&amp;&amp; f, T&amp;&amp; t, std::index_sequence&lt;I...&gt;)</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.4039.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4040.1">return</span></span><span class="koboSpan" id="kobo.4041.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4042.1">invoke</span></span><span class="koboSpan" id="kobo.4043.1">(
      std::forward&lt;F&gt;(f),
      std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4044.1">get</span></span><span class="koboSpan" id="kobo.4045.1">&lt;I&gt;(std::forward&lt;T&gt;(t))...);
  }
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4046.1">template</span></span><span class="koboSpan" id="kobo.4047.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4048.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.4049.1">F</span></span><span class="koboSpan" id="kobo.4050.1">, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4051.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.4052.1">T</span></span><span class="koboSpan" id="kobo.4053.1">&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4054.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4055.1">apply</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4056.1">(F&amp;&amp; f, T&amp;&amp; t)</span></span><span class="koboSpan" id="kobo.4057.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4058.1">return</span></span><span class="koboSpan" id="kobo.4059.1"> details::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4060.1">apply</span></span><span class="koboSpan" id="kobo.4061.1">(
    std::forward&lt;F&gt;(f),
    std::forward&lt;T&gt;(t),
    std::make_index_sequence&lt;
      std::tuple_size_v&lt;std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.4062.1">decay_t</span></span><span class="koboSpan" id="kobo.4063.1">&lt;T&gt;&gt;&gt; {}); 
}
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-225"><span class="koboSpan" id="kobo.4064.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.4065.1">Before we </span><a id="_idIndexMarker477"/><span class="koboSpan" id="kobo.4066.1">see how </span><code class="inlineCode"><span class="koboSpan" id="kobo.4067.1">std::invoke()</span></code><span class="koboSpan" id="kobo.4068.1"> works, let’s have a quick look at how </span><a id="_idIndexMarker478"/><span class="koboSpan" id="kobo.4069.1">different callable objects can be invoked. </span><span class="koboSpan" id="kobo.4069.2">Given a function, obviously, the ubiquitous way of invoking it is by directly passing it the necessary parameters. </span><span class="koboSpan" id="kobo.4069.3">However, we can also invoke the function using function pointers. </span><span class="koboSpan" id="kobo.4069.4">The trouble with function pointers is that defining the type of the pointer can be cumbersome. </span><span class="koboSpan" id="kobo.4069.5">Using </span><code class="inlineCode"><span class="koboSpan" id="kobo.4070.1">auto</span></code><span class="koboSpan" id="kobo.4071.1"> can simplify things (as shown in the following code), but in practice, you usually need to define the type of the pointer to function first, and then define an object and initialize it with the correct function address. </span><span class="koboSpan" id="kobo.4071.2">Here are several examples:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.4072.1">// direct call</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.4073.1">auto</span></span><span class="koboSpan" id="kobo.4074.1"> a1 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4075.1">add</span></span><span class="koboSpan" id="kobo.4076.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.4077.1">1</span></span><span class="koboSpan" id="kobo.4078.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4079.1">2</span></span><span class="koboSpan" id="kobo.4080.1">);    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4081.1">// a1 = 3</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.4082.1">// call through function pointer</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.4083.1">int</span></span><span class="koboSpan" id="kobo.4084.1">(*fadd)(</span><span class="hljs-type"><span class="koboSpan" id="kobo.4085.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.4086.1">const</span></span><span class="koboSpan" id="kobo.4087.1">, </span><span class="hljs-type"><span class="koboSpan" id="kobo.4088.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.4089.1">const</span></span><span class="koboSpan" id="kobo.4090.1">) = &amp;add;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4091.1">auto</span></span><span class="koboSpan" id="kobo.4092.1"> a2 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4093.1">fadd</span></span><span class="koboSpan" id="kobo.4094.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.4095.1">1</span></span><span class="koboSpan" id="kobo.4096.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4097.1">2</span></span><span class="koboSpan" id="kobo.4098.1">);   </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4099.1">// a2 = 3</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.4100.1">auto</span></span><span class="koboSpan" id="kobo.4101.1"> fadd2 = &amp;add;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4102.1">auto</span></span><span class="koboSpan" id="kobo.4103.1"> a3 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4104.1">fadd2</span></span><span class="koboSpan" id="kobo.4105.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.4106.1">1</span></span><span class="koboSpan" id="kobo.4107.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4108.1">2</span></span><span class="koboSpan" id="kobo.4109.1">);  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4110.1">// a3 = 3</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4111.1">Calling through a function pointer becomes more cumbersome when you need to invoke a class function through an object that is an instance of the class. </span><span class="koboSpan" id="kobo.4111.2">The syntax for defining the pointer to a member function and invoking it is not simple:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4112.1">foo f;
f.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4113.1">increment_by</span></span><span class="koboSpan" id="kobo.4114.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.4115.1">3</span></span><span class="koboSpan" id="kobo.4116.1">);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4117.1">auto</span></span><span class="koboSpan" id="kobo.4118.1"> x1 = f.x;    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4119.1">// x1 = 3</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.4120.1">void</span></span><span class="koboSpan" id="kobo.4121.1">(foo::*finc)(</span><span class="hljs-type"><span class="koboSpan" id="kobo.4122.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.4123.1">const</span></span><span class="koboSpan" id="kobo.4124.1">) = &amp;foo::increment_by;
(f.*finc)(</span><span class="hljs-number"><span class="koboSpan" id="kobo.4125.1">3</span></span><span class="koboSpan" id="kobo.4126.1">);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4127.1">auto</span></span><span class="koboSpan" id="kobo.4128.1"> x2 = f.x;    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4129.1">// x2 = 6</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.4130.1">auto</span></span><span class="koboSpan" id="kobo.4131.1"> finc2 = &amp;foo::increment_by;
(f.*finc2)(</span><span class="hljs-number"><span class="koboSpan" id="kobo.4132.1">3</span></span><span class="koboSpan" id="kobo.4133.1">);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4134.1">auto</span></span><span class="koboSpan" id="kobo.4135.1"> x3 = f.x;    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4136.1">// x3 = 9</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4137.1">Regardless of how</span><a id="_idIndexMarker479"/><span class="koboSpan" id="kobo.4138.1"> cumbersome this kind of call may look, the actual problem is writing library components (functions or classes) that are able to call any of these types of callable objects, in a uniform manner. </span><span class="koboSpan" id="kobo.4138.2">This is what benefits, in practice, from a standard function, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.4139.1">std::invoke()</span></code><span class="koboSpan" id="kobo.4140.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4141.1">The implementation </span><a id="_idIndexMarker480"/><span class="koboSpan" id="kobo.4142.1">details of </span><code class="inlineCode"><span class="koboSpan" id="kobo.4143.1">std::invoke()</span></code><span class="koboSpan" id="kobo.4144.1"> are complex, but the way it works can be explained in simple terms. </span><span class="koboSpan" id="kobo.4144.2">Supposing the call has the form </span><code class="inlineCode"><span class="koboSpan" id="kobo.4145.1">invoke(f, arg1, arg2, ..., argN)</span></code><span class="koboSpan" id="kobo.4146.1">, then consider the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.4147.1">If </span><code class="inlineCode"><span class="koboSpan" id="kobo.4148.1">f</span></code><span class="koboSpan" id="kobo.4149.1"> is a pointer to a member function of a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4150.1">T</span></code><span class="koboSpan" id="kobo.4151.1"> class, then the call is equivalent to either:</span><ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.4152.1">(arg1.*f)(arg2, ..., argN)</span></code><span class="koboSpan" id="kobo.4153.1">, if </span><code class="inlineCode"><span class="koboSpan" id="kobo.4154.1">arg1</span></code><span class="koboSpan" id="kobo.4155.1"> is an instance of </span><code class="inlineCode"><span class="koboSpan" id="kobo.4156.1">T</span></code></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.4157.1">(arg1.get().*f)(arg2, ..., argN)</span></code><span class="koboSpan" id="kobo.4158.1">, if </span><code class="inlineCode"><span class="koboSpan" id="kobo.4159.1">arg1</span></code><span class="koboSpan" id="kobo.4160.1"> is a specialization of </span><code class="inlineCode"><span class="koboSpan" id="kobo.4161.1">reference_wrapper</span></code></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.4162.1">((*arg1).*f)(arg2, ..., argN)</span></code><span class="koboSpan" id="kobo.4163.1">, if it is otherwise</span></li>
</ul>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4164.1">If </span><code class="inlineCode"><span class="koboSpan" id="kobo.4165.1">f</span></code><span class="koboSpan" id="kobo.4166.1"> is a pointer to a data member of a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4167.1">T</span></code><span class="koboSpan" id="kobo.4168.1"> class and there is a single argument—in other words, the call has the form </span><code class="inlineCode"><span class="koboSpan" id="kobo.4169.1">invoke(f, arg1)</span></code><span class="koboSpan" id="kobo.4170.1">—then the call is equivalent to either:</span><ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.4171.1">arg1.*f</span></code><span class="koboSpan" id="kobo.4172.1"> if </span><code class="inlineCode"><span class="koboSpan" id="kobo.4173.1">arg1</span></code><span class="koboSpan" id="kobo.4174.1"> is an instance class </span><code class="inlineCode"><span class="koboSpan" id="kobo.4175.1">T</span></code></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.4176.1">arg1.get().*f</span></code><span class="koboSpan" id="kobo.4177.1"> if </span><code class="inlineCode"><span class="koboSpan" id="kobo.4178.1">arg1</span></code><span class="koboSpan" id="kobo.4179.1"> is a specialization of </span><code class="inlineCode"><span class="koboSpan" id="kobo.4180.1">reference_wrapper</span></code></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.4181.1">(*arg1).*f</span></code><span class="koboSpan" id="kobo.4182.1">, if it is otherwise</span></li>
</ul>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4183.1">If </span><code class="inlineCode"><span class="koboSpan" id="kobo.4184.1">f</span></code><span class="koboSpan" id="kobo.4185.1"> is a function object, then the call is equivalent to </span><code class="inlineCode"><span class="koboSpan" id="kobo.4186.1">f(arg1, arg2, ..., argN)</span></code></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.4187.1">The standard library also provides a series of related type traits: </span><code class="inlineCode"><span class="koboSpan" id="kobo.4188.1">std::is_invocable</span></code><span class="koboSpan" id="kobo.4189.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4190.1">std::is_nothrow_invocable</span></code><span class="koboSpan" id="kobo.4191.1"> on the one hand, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4192.1">std::is_invocable_r</span></code><span class="koboSpan" id="kobo.4193.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4194.1">std::is_nothrow_invocable_r</span></code><span class="koboSpan" id="kobo.4195.1"> on the other hand. </span><span class="koboSpan" id="kobo.4195.2">The first set determines whether a function can be invocable with the supplied arguments, while the second determines whether it can be invocable with the supplied arguments and produce a result that can be implicitly converted to a specified type. </span><span class="koboSpan" id="kobo.4195.3">The </span><em class="italic"><span class="koboSpan" id="kobo.4196.1">nothrow</span></em><span class="koboSpan" id="kobo.4197.1"> versions of these type traits verify that the call can be done without any exception being thrown.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4198.1">As of C++20, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4199.1">std::invoke</span></code><span class="koboSpan" id="kobo.4200.1"> function </span><a id="_idIndexMarker481"/><span class="koboSpan" id="kobo.4201.1">is </span><code class="inlineCode"><span class="koboSpan" id="kobo.4202.1">constexpr</span></code><span class="koboSpan" id="kobo.4203.1">, which means it can be used to invoke callable objects at compile-time.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4204.1">In C++23, a similar</span><a id="_idIndexMarker482"/><span class="koboSpan" id="kobo.4205.1"> utility called </span><code class="inlineCode"><span class="koboSpan" id="kobo.4206.1">std::invoke_r</span></code><span class="koboSpan" id="kobo.4207.1"> has been added. </span><span class="koboSpan" id="kobo.4207.2">This has one additional template </span><a id="_idIndexMarker483"/><span class="koboSpan" id="kobo.4208.1">parameter (the first one), which is a type template parameter that represents the type of the return value (unless it is </span><code class="inlineCode"><span class="koboSpan" id="kobo.4209.1">void</span></code><span class="koboSpan" id="kobo.4210.1">) or a type to which the return value can be implicitly converted.</span></p>
<h2 class="heading-2" id="_idParaDest-226"><span class="koboSpan" id="kobo.4211.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.4212.1">Writing a function template with a variable number of arguments</span></em><span class="koboSpan" id="kobo.4213.1">, to see how variadic templates enable us to write functions that can take any number of arguments</span></li>
</ul>
<h1 class="heading-1"><span class="koboSpan" id="kobo.4214.1">Learn more on Discord</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.4215.1">Join our community’s Discord space for discussions with the author and other readers:</span></p>
<p class="normal"><a href="Chapter_03.xhtml"><span class="url"><span class="koboSpan" id="kobo.4216.1">https://discord.gg/7xRaTCeEhx</span></span></a></p>
<p class="normal"><span class="koboSpan" id="kobo.4217.1"><img alt="" src="../Images/QR_Code2659294082093549796.png"/></span></p>
</div>
</body></html>